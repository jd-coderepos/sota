\documentclass{acmtrans2m}

\newcommand{\height}{{\mathit height}}
\newcommand{\commentout}[1]{}
\newcommand{\now}{\mathbf{now}}
\renewcommand{\P}{\cP}

\ifx\pdfoutput\undefined
\usepackage{graphicx}
  \DeclareGraphicsExtensions{.eps}
\else
\usepackage[pdftex]{graphicx}
 \DeclareGraphicsExtensions{.pdf,.eps,.ps}
\fi


\newtheorem{theorem}{Theorem}[section]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{proposition}[theorem]{Proposition}
\newdef{definition}[theorem]{{\sc Definition}}
\newtheorem{claim}[theorem]{Claim}
\newdef{example}[theorem]{{\sc Example}}
\newtheorem{remark}[theorem]{Remark}
\newcommand{\thm}{\begin{theorem}}
\newcommand{\lem}{\begin{lemma}}
\newcommand{\pro}{\begin{proposition}}
\newcommand{\dfn}{\begin{definition}}
\newcommand{\rem}{\begin{remark}}
\newcommand{\xam}{\begin{example}}
\newcommand{\cor}{\begin{corollary}}
\newcommand{\prf}{\begin{proof}}
\newcommand{\ethm}{\end{theorem}}
\newcommand{\elem}{\end{lemma}}
\newcommand{\epro}{\end{proposition}}
\newcommand{\edfn}{\bbox\end{definition}}
\newcommand{\erem}{\bbox\end{remark}}
\newcommand{\exam}{\bbox\end{example}}
\newcommand{\ecor}{\end{corollary}}
\newcommand{\eprf}{\end{proof}}
\newcommand{\beqn}{}
\newcommand{\wbox}{\mbox{\llap{}}}
\newcommand{\bbox}{\wbox}
\newenvironment{RETHM}[2]{\trivlist \item[\hskip 10pt\hskip\labelsep{\sc #1\hskip 5pt\relax\ref{#2}.}]\it}{\endtrivlist}
\newcommand{\rethm}[1]{\begin{RETHM}{Theorem}{#1}}
\newcommand{\repro}[1]{\begin{RETHM}{Proposition}{#1}}
\newcommand{\relem}[1]{\begin{RETHM}{Lemma}{#1}}
\newcommand{\recor}[1]{\begin{RETHM}{Corollary}{#1}}

\newcommand{\erethm}{\end{RETHM}}
\newcommand{\erepro}{\end{RETHM}}
\newcommand{\erelem}{\end{RETHM}}
\newcommand{\erecor}{\end{RETHM}}
\newcommand{\sat}{\models}
\newcommand{\rimp}{\Rightarrow}
\newcommand{\nthm}[1]{\begin{oldthm}{#1}}
\newcommand{\enthm}{\end{oldthm} \medskip}
\newenvironment{oldthm}[1]{\medskip\par\noindent{\bf Theorem #1:} \em \noindent}{\par}
\newenvironment{oldlem}[1]{\medskip\par\noindent{\bf Lemma #1:} \em \noindent}{\par}
\newenvironment{oldcor}[1]{\medskip\par\noindent{\bf Corollary #1:} \em \noindent}{\par}
\newenvironment{oldpro}[1]{\medskip\par\noindent{\bf Proposition #1:}
\em \noindent}{\par}
\newcommand{\othm}{\rethm}
\newcommand{\eothm}{\erethm}
\newcommand{\olem}{\relem}
\newcommand{\eolem}{\erelem}
\newcommand{\ocor}{\recor}
\newcommand{\eocor}{\erecor}
\newcommand{\opro}{\repro}
\newcommand{\eopro}{\erepro}

\newcommand{\<}{
}
\renewcommand{\>}{\rangle}
\newcommand{\sep}{~:~}
\newcommand{\union}{\cup}
\newcommand{\inter}{\cap}
\renewcommand{\phi}{\varphi}


\newenvironment{prog}{\begin{array}[t]{@{}l@{}}}{\end{array}}

\newcommand{\REMARQUE}[1]{\textbf{[[ #1 ]]}}
\newcommand{\LLIC}{\mbox{LLIC}}
\newcommand{\cA}{\mathcal{A}}
\newcommand{\cF}{\mathcal{F}}
\newcommand{\cL}{\mathcal{L}}
\newcommand{\cW}{\mathcal{W}}
\newcommand{\cC}{\mathcal{C}}
\newcommand{\cP}{\mathcal{P}}
\newcommand{\cR}{\mathcal{R}}
\newcommand{\cN}{\mathcal{N}}
\newcommand{\cM}{\mathcal{M}}
\newcommand{\cU}{\mathcal{U}}
\newcommand{\cI}{\mathcal{I}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\N}{\mathbb{N}}

\newcommand{\fnT}[2]{\mathcal{T}_{#1}\intension{#2}}
\newcommand{\intension}[1]{[\![ #1 ]\!]}

\newcommand{\len}[1]{|#1|}
\newcommand{\card}[1]{\#({#1})}

\newcommand{\Perm}[3]{\mbox{{\bf Permitted}}(#1,#2,#3)}
\newcommand{\Permm}[4]{\mbox{{\bf Permitted}}(#1,#2,#3,#4)}

\newcommand{\Att}{\mathit{\bf Attractive}}
\newcommand{\Smart}{\mathit{\bf Smart}}
\newcommand{\Said}{\mathit{\bf Said}}
\newcommand{\true}{\mathit{\bf{true}}}
\newcommand{\false}{\mathit{\bf{false}}}
\newcommand{\Permitted}{\mathit{\bf Perm}}
\renewcommand{\Pr}{\mathit{\bf Pr}}

\newcommand{\Permits}{\textbf{Permits}}
\newcommand{\PermitsInd}{\textbf{PermitsInd}}
\newcommand{\PermitsGrp}{\textbf{PermitsGrp}}
\newcommand{\SigIn}{\textbf{SigIn}}
\newcommand{\Contains}{\textbf{Contains}}

\newcommand{\getPrinc}{\mbox{getPrinc}}
\newcommand{\makeLicID}{\mbox{makeLicID}}
\newcommand{\anyone}{\mbox{anyone}}
\newcommand{\noKey}{\mbox{noKey}}
\newcommand{\phant}{\mbox{phantom}}
\newcommand{\vtab}{\phantom{Le}}
\newcommand{\vtabb}{\phantom{LetLetLetLet}}

\newcommand{\cd}{d}
\newcommand{\scd}{S}
\newcommand{\cc}{e}
\newcommand{\scc}{E}

\newcommand{\cLfo}{\cL^{\mathit{fo}}}

\newcommand{\lic}{\mathit{license}}
\newcommand{\inv}{\mathit{inventory}}
\newcommand{\grant}{\mathit{grant}}
\newcommand{\cond}{\mathit{cond}}
\newcommand{\conc}{\mathit{conc}}
\newcommand{\iss}{\mathit{issuer}}
\newcommand{\fall}{\mathit{forall}}
\newcommand{\pat}{\mathit{pat}}
\newcommand{\bind}{\mathit{binding}}
\newcommand{\princ}{\mathit{prin}}
\newcommand{\act}{\mathit{action}}
\newcommand{\rht}{\mathit{right}}
\newcommand{\rsrc}{\mathit{rsrc}}
\newcommand{\var}{\mathit{var}}
\newcommand{\princVarSet}{\mathit{prinVar}}
\newcommand{\rsrcVarSet}{\mathit{rsrcVar}}
\newcommand{\princVar}{\mathit{x_p}}
\newcommand{\rhtVar}{\mathit{x_{rht}}}
\newcommand{\rsrcVar}{\mathit{x_r}}
\newcommand{\primPrinc}{\mathit{p}}
\newcommand{\primPrincSet}{\mathit{primPrinc}}
\newcommand{\str}{\mathit{str}}
\newcommand{\ttime}{\mathit{time}}
\newcommand{\ttimeInt}{\mathit{timeInterval}}
\newcommand{\everyone}{\mathtt{everyone}}
\newcommand{\XmlExp}{\mathtt{XmlExpr}}
\newcommand{\allPrinc}{\mathtt{allPrin}}
\newcommand{\hasKey}{\mathtt{hasKey}}
\newcommand{\keyHold}{\mathtt{hasKey}}
\newcommand{\obtain}{\mathtt{obtain}}
\newcommand{\possess}{\mathtt{possess}}
\newcommand{\issue}{\mathtt{issue}}
\newcommand{\allCond}{\mathtt{AllConditions}}
\newcommand{\anyCond}{\mathtt{anyConds}}
\newcommand{\existsRht}{\mathtt{existsRight}}
\newcommand{\permits}{\mathtt{permits}}
\newcommand{\prereqRht}{\mathtt{permits}}
\newcommand{\valInt}{\mathtt{validityInterval}}
\newcommand{\fresh}{\mathtt{fresh}}
\newcommand{\revokeMech}{\mathtt{revokeMechanism}}
\newcommand{\revoke}{\mathtt{revoke}}
\newcommand{\sig}{\mathit{sig}}
\newcommand{\property}{\mathit{property}}
\newcommand{\key}{\mathit{key}}
\newcommand{\primitiveProp}{\mathit{primitiveProp}}
\newcommand{\primitivePrinc}{\mathit{primitivePrin}}
\newcommand{\grantID}{\mathit{grantID}}
\newcommand{\G}{\mathit{G}}
\newcommand{\Pri}{\mathit{P}}
\newcommand{\authGrant}{\mathit{authGrant}}
\newcommand{\propGrant}{\mathit{propGrant}}
\newcommand{\prop}{\mathit{prop}}

\newcommand{\getL}{\mathtt{getLID}}
\newcommand{\getG}{\mathtt{getGID}}
\newcommand{\getRsrc}{\mathtt{getRsrc}}
\newcommand{\getImpliedRsrcs}{\mathtt{getImpliedRsrcs}}
\newcommand{\Legit}{\textbf{Legit}}
\newcommand{\SignAs}{\textbf{SignAs}}
\newcommand{\lPossess}{\textbf{possess}}

\newcommand{\keyHolder}{\mathtt{KeyHolder}}
\newcommand{\possessProperty}{\mathtt{PossessProperty}}
\newcommand{\prerequisiteRight}{\mathtt{PrerequisiteRight}}
\newcommand{\allConditions}{\mathtt{AllConditions}}
\newcommand{\allPrincipals}{\mathtt{AllPrincipals}}

\newcommand{\imp}{\rightarrow}

\newcommand{\XA}{\textbf{Auth}}
\newcommand{\C}{\textbf{SaidEval}}
\newcommand{\XARevOne}{\textbf{AuthRev1}}
\newcommand{\CRevOne}{\textbf{PermEvalRev1}}
\newcommand{\XARevTwo}{\textbf{AuthRev2}}
\newcommand{\CRevTwo}{\textbf{PermEvalRev2}}
\newcommand{\XARevThree}{\textbf{AuthRev3}}
\newcommand{\CRevThree}{\textbf{PermEvalRev3}}
\newcommand{\ProcRevOne}{\textbf{ProcRev1}}
\newcommand{\ProcRevTwo}{\textbf{ProcRev2}}
\newcommand{\getPrereqsP}{\textbf{GetPrereqsForPerm}}
\newcommand{\getLegitG}{\textbf{GetLegitGrants}}
\newcommand{\getPrereqsC}{\textbf{GetPrereqsForCond}}
\newcommand{\isAllowed}{\textbf{IsAllowed}}
\newcommand{\condIsMet}{\textbf{CondIsMet}}
\newcommand{\CG}{\textbf{ComputeG}}

\newcommand{\CMet}{\textbf{Holds}}
\newcommand{\CMetRevOne}{\textbf{CondMetRev1}}
\newcommand{\CMetRevTwo}{\textbf{CondMetRev2}}
\newcommand{\CMetRevThree}{\textbf{CondMetRev3}}
\newcommand{\BU}{\textbf{BottomUp}}
\newcommand{\XProc}{\textbf{Query}}
\newcommand{\XProcTwo}{\textbf{Query2}}
\newcommand{\XProcFour}{\textbf{Query3}}
\newcommand{\XAFour}{\textbf{Auth3}}
\newcommand{\XProcThree}{\textbf{Query2}}
\newcommand{\CMetTwo}{\textbf{Holds2}}
\newcommand{\XATwo}{\textbf{Auth2}}
\newcommand{\CMetThree}{\textbf{Holds}}

\newcommand{\CMetFour}{\textbf{Holds3}}

\newcommand{\XAThree}{\textbf{Auth2}}

\newcommand{\FindG}{\textbf{FindG}}

\newcommand{\LicID}{\mathit{LicID}}
\newcommand{\GrantID}{\mathit{GrantID}}
\newcommand{\Sig}{\mathit{Sig}}
\newcommand{\Princ}{\mathit{Principal}}
\newcommand{\Key}{\mathit{Key}}
\newcommand{\Rht}{\mathit{Right}}
\newcommand{\Rsrc}{\mathit{Resource}}

\newcommand{\Val}{\mathsf{Val}}

\newcommand{\trans}[3]{#1^{#2}}
\newcommand{\tran}[1]{#1^{L}}
\newcommand{\trannos}[1]{#1^{L}}
\newcommand{\Eql}[2]{\mathsf{Val}(#1 \iff #2)}
\newcommand{\transwithE}[5]{#1^{#2, #3, #4, #5}}
\newcommand{\tranwithE}[1]{#1^{L, A, \scd, \scc}}
\newcommand{\tranwithEempty}[1]{#1^{L, A, \emptyset, \scc}}
\newcommand{\RStar}[1]{{\cal R}^*(#1)}
\newcommand{\EStar}{{\cal E}^*}
\newcommand{\SStar}{{\cal S}^*}
\newcommand{\GStar}[2]{{\cal G}^*(#1, #2)}
\newcommand{\HStar}[3]{{\cal H}^*(#1, #2, #3)}
\renewcommand{\iff}{\Leftrightarrow}

\newcommand{\pred}[1]{\mathbf{#1}}
\newcommand{\fn}[1]{\mathbf{#1}}
\newcommand{\const}[1]{\mathbf{#1}}
\newcommand{\vsim}{\sim\!\!}

\newcommand{\facc}{fully acceptable }
\newcommand{\gc}{guaranteed-consistent }
\newcommand{\vr}{variable-restricted }
\newcommand{\ws}{well-sized }
\newcommand{\nf}{f_{nest}}
\newcommand{\condf}{f_{cond}}
\newcommand{\base}{assets}
\newcommand{\length}{{\mathit length}}
\newcommand{\bo}{depends on~}

\newcommand{\numP}{n}
\newcommand{\numR}{m}
\newcommand{\lenC}{h}
\newcommand{\numPtotal}{n_t}
\newcommand{\numAtotal}{m_t}

\newcommand{\EX}{X}

\newcommand{\andNd}{\mathit{and}}
\newcommand{\orNd}{\mathit{or}}
\newcommand{\nandNd}{\mathit{non-and}}


\newcommand{\doublebar}[1]{\|#1\|}


\newcommand{\Rule}[2]{         \begin{array}{c}
  #1 \\\hline
  #2
  \end{array}}

\markboth{J. Halpern and V. Weissman}{A Formal Foundation for XrML}
\title{A Formal Foundation for XrML}
\author{Joseph Y.~Halpern and Vicky Weissman \\ Cornell University}

\commentout{
\title{A Formal Foundation for XrM\thanks{Authors supported in part by NSF under grant
CTC-0208535, by ONR under grants  N00014-00-1-03-41 and
N00014-01-10-511, by the DoD Multidisciplinary University Research
Initiative (MURI) program administered by the ONR under
grant N00014-01-1-0795, and by AFOSR under grant F49620-02-1-0101.
A preliminary version of this paper appeared at the 17th IEEE Computer Security
Foundations Workshop in Pacific Grove, California, 2004.
}}

\author{
Joseph Y. Halpern\\
Cornell University\\
Ithaca, NY 14853\\
halpern@cs.cornell.edu
\and
Vicky Weissman\\
Cornell University\\
Ithaca, NY 14853\\
vickyw@cs.cornell.edu
}

\maketitle
\thispagestyle{empty}
}

\begin{abstract}
XrML is becoming a popular language in industry for writing software
licenses.  The semantics for XrML is implicitly given by an algorithm
that determines if a permission follows from a set of licenses.  We
focus on a fragment of the language and use it to
highlight some problematic aspects of the algorithm.  We then correct
the problems, introduce formal semantics, and show that our semantics
captures the (corrected) algorithm.  Next, we consider the complexity of
determining if a permission is implied by a set of XrML licenses.  We
prove that the general problem is undecidable, but it is polynomial-time
computable for an expressive fragment of the language.  We extend XrML
to capture a wider range of licenses by adding negation to the language.
Finally, we discuss the key differences between XrML and MPEG-21, an
international standard based on XrML.
\end{abstract}

\category{H.2.7}{Database Management}{Database Administration}[Security \and integrity \and protection]
\category{K.4.4}{Computers and Society}{Electronic Commerce}[Security]
\terms{Security, Languages}
\keywords{Digital Rights Management}

\begin{document}

\begin{bottomstuff}
Authors' address: J.~Halpern and V.~Weissman, Cornell University,
Ithaca, NY 14853.\newline
Authors supported in part by NSF under
grants CTC-0208535, ITR-0325453, and IIS-0534064,
by ONR under grants  N00014-00-1-03-41 and
N00014-01-10-511, by the DoD Multidisciplinary University Research
Initiative (MURI) program administered by the ONR under
grant N00014-01-1-0795, and by AFOSR under
grants F49620-02-1-0101 and FA9550-05-1-0055.
A preliminary version of this paper appeared at the 17th IEEE Computer Security
Foundations Workshop in Pacific Grove, California, 2004.
\end{bottomstuff}

\maketitle
\section{Introduction}
The eXtensible rights Markup Language (XrML) is becoming an increasingly popular
language in which to write software licenses.  When first released in 2000, XrML
received the support of many technology providers, content owners, distributors,
and retailers, including Adobe Systems, Hewlett-Packard Laboratories, Microsoft,
Xerox Corp., Barnesandnoble.com, and Time Warner Trade Publishing.  In fact,
Microsoft, OverDrive, and DMDsecure have publicly announced their agreement to
build products and/or services that are XrML compliant.  Currently, XrML is being
used by international standard committees as the basis for application-specific
languages that are designed for use across entire industries.  For
example, the 
Moving Picture Experts Group (MPEG) has selected XrML as the foundation for their
MPEG-21 Rights Expression Language, henceforth referred to as MPEG-21
(see http://www.xrml.org).  It is clear that a number of industries are moving
towards a standard language for writing licenses and that many of these standard
languages are likely to be based on XrML.  To understand the new standards, we
need to understand XrML.

XrML does not have formal semantics.  Instead, the XrML specification \cite{XrML}
presents the semantics in two ways.  First is an English description of the
language.  Second is an English description of an algorithm that determines if a
permission follows from a set of licenses.  Unfortunately, the two versions of the
semantics do not agree.  To make matters worse, the algorithm has unintuitive
consequences that do not seem to reflect the language developers' intent.

To address these issues, we provide formal semantics for
a fragment of XrML.
We focus on a fragment because the entire language is somewhat unwieldy.
An
XrML license says that an agent grants a permission if certain
conditions hold.
Our
fragment includes only two types of permissions and only two types of conditions.
We give our fragment formal semantics by defining
a translation from licenses in
the fragment
to formulas in
first-order logic extended with a validity operator.  We argue that the translation
preserves the meaning of the XrML statements by proving that the algorithm included
in the XrML document, slightly modified to correct the unintuitive
behavior, 
matches our semantics.  More precisely, the algorithm says that a
permission follows from a 
set of licenses if and only if the translated permission is a logical
consequence of 
the translated licenses.  We then consider the complexity of determining if a
permission is implied by a set of licenses.  We show that the general problem is
undecidable, even for our fragment.
The problem is decidable in polynomial time if we restrict the fragment slightly.



A shortcoming of XrML is that it does not support negation.  For example, in XrML,
we cannot write ``customers may \emph{not} edit the software''.  The XrML developers
deal with this limitation, to some extent, by assuming that an action is forbidden
unless it is explicitly permitted.  As a result, a license writer does not need to say
that an action is forbidden, because the prohibition is already implied.  This
approach might be acceptable in various instances, but it is difficult to believe that
most license writers really want to forbid \emph{every} action that they do not
explicitly permit.  So, the approach does not capture the license writer's actual intent.
Moreover, it limits the class of licenses that can be expressed, because it removes the
distinction between forbidden and unregulated actions.  For example, in XrML, we cannot
say ``a hospital may petition for an exemption if it permits an action that the government
forbids''.  Similarly, a course instructor cannot say ``if the university does not object,
then Alice is permitted to audit the class''.  In this paper, we extend XrML to include
such statements and consider the effect of the addition on the language's tractability.

MPEG-21 is an international standard based on XrML.  When we first decided to give XrML
formal semantics, the MPEG committee had released a beta version of its language, which was
XrML with minor revisions, and was preparing the final release.  We chose to give semantics
to the beta language first (before analyzing the official XrML specification, as is done
here), because we hoped that any problems we found would be corrected in the final version
of MPEG-21.  This is, in fact, what occured.  After discussing our results with Thomas
DeMartini and Xin Wang of the MPEG Standards Committee, the committee released their ISO
standard \cite{RelFinal}; the shortcomings that we identified are addressed in the standard.
We conjecture that all of our results for XrML hold with minor changes for MPEG-21, although
we have not verified the details.

The rest of the paper is organized as follows.  In the next section we present
our
fragment of XrML.  In Section~\ref{s:xrmlAlg} we review XrML's algorithm for
answering queries.  After considering some examples in which the algorithm's behavior is
unintuitive and almost certainly unintended, we propose corrections that we believe captures
the designers' intent.  Formal semantics for
our fragment
are given in Section~\ref{s:semantics-xrml},
and the revised algorithm is shown to be sound and complete with respect to the semantics.  In
Section~\ref{s:trac} we show that the problem of determining if a permission follows from a set
of licenses is undecidable.  We also discuss a fragment of
XrML
that is both tractable
and relatively expressive.  In Section~\ref{s:core} we outline how our
results can be extended to
a substantial
fragment of XrML.
Negation is added to XrML in Section~\ref{s:extend}.
The analysis of this paper had an impact on practice.
MPEG-21 REL, an international standard based on XrML,
incorporates the developers' response to our concerns about XrML.
We describe MPEG-21 REL, and how it deals with our concerns,
in Section~\ref{s:MPEG-21}.
We conclude in Section~\ref{s:concl}.  All of the proofs are in the
appendix.

\section{Syntax}\label{s:XrMLsyntax}
XrML is an XML-based language; it follows XML-conventions.  Rather than present that syntax,
we use an alternative syntax that is more concise and, we believe, more intuitive.  In this
section, we introduce our syntax for a
fragment of XrML (the rest of the
language is discussed in Section~\ref{s:core}) and describe the key differences between the
syntax used in the XrML specification and that used here.

At the heart of XrML is the notion of a \emph{license}.  A license is a (principal, grant)
pair, where the license  means  issues (i.e., says) .  For example, the
license (Alice, Bob is smart) means ``Alice says `Bob is smart'''.

A grant has the form , which intuitively means that the condition implies the conclusion
under all appropriate substitutions.  Conditions and conclusions are defined as follows.
\begin{itemize}
\item A condition has the form , where each  is either
 or  for some principal  and conclusion .  Roughly speaking,
the condition  always holds and the condition  holds if  issues a
grant that says  holds if a condition  holds, and  does, in fact, hold.
\item A conclusion has either the form  or the form , where
 is a property,  is a principal,  is a right (i.e., an action), and  is a
resource.  The conclusion  means  may exercise  over .  For
example,  means
Bob may edit the budget report.  The conclusion  means  has the property .
For example, the conclusion  means Bob is attractive.
\end{itemize}
We abbreviate the grant  as
.  Also, we try to consistently use , possibly
subscripted, to denote a generic condition and , possibly subscripted, to denote a
generic conclusion.

\begin{sloppypar}
Consider the following example.  Suppose that Alice issues the grant ``Bob is smart''
and Amy issues the grant ``if Alice says that Bob is smart, then he is attractive''.  We
can write the first license in our syntax as , where
 (recall that this is an abbreviation for
), and we can write the second as
, where .  Because  is in the set of issued licenses,
 holds.  It follows from this fact and the
license  that  holds as
well.
\end{sloppypar}

The sets of principals, properties, rights, and resources depend on the particular application.
For example, a multimedia application might have a principal for each employee and each
customer; properties such as ``hearing impaired'' and ``manager''; rights such as ``edit'' and
``download''; and a resource for each object such as a movie.  We assume the application gives us
a finite set  of principals and a finite set  of properties.  We
then define the components in our language as follows.
\begin{itemize}
\item The set  of principals is the result of closing  under union.  (Here and
elsewhere we identify a principal  with the singleton  and write
 rather than .)  The interpretation of a
principal  depends on context; that is, the interpretation depends on whether
the principal appears as the first argument in a  condition, in a conclusion, or in a
license.  We discuss this later in the paper (primarily in Section~\ref{s:trac}).
\item The set of properties is .
We assume that
every property in 
takes a single argument and that argument is of sort .  For example,  can
include the property , where  means principal 
is an employee, but it cannot include the property , where
 means principal  is the mother of principal , nor can it include
the property , where  means resource  is a vehicle
(e.g., a motorcycle, car, or truck).  The results in this paper continue to hold if we extend the
language to include properties that take multiple arguments of various sorts (i.e., principals,
rights, and resources).  It is also easy to show that closing  under conjunction adds
no expressive power to the language.  Closing under negation does add expressive power; we return to
this issue in Section~\ref{s:extend}.
\item The only right in our language is  and the only resources are grants.  Intuitively, if
a principal  has the right to issue a grant , and  does issue , then  is a true
statement.  Including additional rights and resources in our language does not significantly affect
the discussion.
\end{itemize}

We formally define the syntax according to the following grammar.

where  is an element of ,  is an element of
,  is an element of , which is the set of variables
ranging over primitive principles, and  is an element of , which is the
set of variables ranging over resources.  For the remainder of this paper we assume that the first
argument in a license is a singleton.  Because the XrML document treats the license
 as an abbreviation for the set of licenses
, it is easy to modify our discussion to support all of the
licenses included in the grammar.

As mentioned at the beginning of this section, the grammar presented
here is not
identical to that described in the XrML document.  Certain components of XrML are
omitted from our language.  These are discussed in Section~\ref{s:core}.  The XrML
components that are included are represented using a syntax that we believe is more
intuitive.  The main differences between the syntax of our language and the syntax
of XrML are described below.
\begin{itemize}
\item Instead of assuming that the application provides a set of primitive principals, XrML assumes
that the application provides a set  of cryptographic keys; the set of primitive principals is
. We could take  to be this set; however, our more
general approach leads to a simpler discussion.  Moreover, our results do not change if we restrict
primitive principals to those of the form .
\item XrML does not have conclusions of the form .  To capture properties, XrML uses a right
called  and considers the properties given by the application to be resources.  The
conclusion  in our grammar corresponds to the conclusion
 in XrML.  We have two types of conclusions because we believe
the grammar should help distinguish the conceptually different notions of permissions and properties,
rather than confounding them.
\item Rather than writing , , and
, we use the more standard notations , ,
and {\bf true}, respectively.  Rather than writing
, we use the shorter and, we believe, more appropriate notation
.
\item As discussed previously, XrML abbreviates a set of licenses
 as the single license
.  For ease of exposition, we do not do this.
\end{itemize}

\section{XrML's Authorization Algorithm}\label{s:xrmlAlg}
The XrML document includes a procedure that we call  to determine if a conclusion follows from
a set of licenses (and some additional input that is discussed below).  In this section we present and
analyze the parts of the algorithm that pertain to our fragment.

Before describing the algorithm, we note that some aspects of  are inefficient.  This is
acknowledged in the XrML document, which explains that  was designed with clarity as the primary
goal; it is the responsibility of the language implementors to create efficient algorithms with the same input/output behavior as .  (In Section~\ref{s:trac}, we show that it is highly unlikely that
such an efficient algorithm exists.)

\subsection{A Description of }\label{sec:XProcdesc}
The input to  is a closed conclusion  (i.e., a conclusion with no free variables), a set
 of licenses  such that  is variable-free, and a set  of grants;  returns
 if  is implied by  and , and returns  otherwise.  To explain the intuition
behind  and , we first note that the procedure treats a predefined set of principals as trusted.
If a trusted principal issues the grant , then  is in  and it is assumed to be true.  If the
license  is in , then  issued  (i.e.,  says ) and  is not an implicitly
trusted principal.  To clarify the inferences that are drawn from  and , suppose that the grant
 is , which means Alice is Queen of Siam, and the grant
 is , which means Alice may issue .  If , then
we assume that Alice really is queen.  If  is in , then Alice says that she
is the queen, but we cannot conclude that she is royalty from this statement alone.  If
 is in  and  is in , then we assume that Alice has the authority to
declare herself queen, because ; we assume that she exercises that authority, because
; and we conclude that Alice is queen, because this follows from the two
assumptions.

 begins by calling the  algorithm.   takes , , and  as input; it returns
a set  of closed conditions (i.e., conditions with no free variables).  Roughly speaking, a closed
condition  is in  if , , and  together imply .  To determine if a condition
in  holds,  relies on the  algorithm.  The input to  is a closed condition
 and a set  of licenses;  returns true if the licenses in  imply , and
returns  otherwise.  If  returns  for some  in , then 
returns , indicating that  implies .   is summarized in
Figure~\ref{tb:XrMLProc1}.

\begin{figure*}[htb]
\begin{center}
\begin{tabular}{|l|}\hline
\underline{:}\\\\
\\
{\bf if}  for a condition \\
{\bf then} return \\
{\bf else} return \\
\hline
\end{tabular}
\end{center}
\caption{The  Algorithm}
\label{tb:XrMLProc1}
\end{figure*}

We now discuss  and  in some detail.  To define , we first consider the case where
.  Define a \emph{closed substitution} to be a mapping from variables to closed
expressions of the appropriate sort.  Given a closed substitution  and an expression , let
 be the expression that arises after all free variables  in  are replaced by
.  Roughly speaking,  returns the set  of closed conditions such
that each condition in , in conjunction with the grants in , implies .  That is, 
iff there is a grant  in  and a closed
substitution  such that  and  implies .   determines
whether  implies  in a somewhat nonstandard way.  In particular, it makes the
\emph{subset assumption}, which says that any property or permission attributed to a principal  is
attributed to every principal that includes .  In other words, if , then 
implies  and  implies .  Thus,



\begin{sloppypar}
Suppose that .  Then we reduce to the previous case by taking
, where, intuitively,  is the set of legitimate grants;
that is,  consists of the grants in  and the grants issued by someone who has the authority
to do so.  It seems reasonable to call  to determine if a
principal  has the authority to issue a grant .  However, if  calls
 to construct , then the algorithm will not terminate,
because  calls , leading to an infinite call tree.  So, instead of calling
, the XrML algorithm determines if  is permitted to
issue  by checking if  for some  in the set
.  We discuss the consequences of this solution
in Section~\ref{s:alg2}.  In summary,

Pseudocode for  is given in Figure~\ref{tb:auth}.
\end{sloppypar}

\begin{figure*}[htb]
\begin{center}
\begin{tabular}{|l|}\hline
\underline{:}\\\\
\\
{\bf if} \\
{\bf then} \\
\vtab\% Find , the conditions under which  implies \\
\vtab{\bf if} \\
\vtab\vtab{\bf for} each grant \\
\vtab\vtab\vtab \\
\vtab{\bf if} \\
\vtab\vtab{\bf for} each grant \\
\vtab\vtab\vtab \\
{\bf else} \\
\vtab\% Find \\
\vtab \\
\vtab {\bf for} each license \\
\vtab\vtab \\
\vtab\vtab \\
\vtab\vtab {\bf if}  for a condition \\
\vtab\vtab {\bf then} \\
\vtab\% Find , the conditions under which  implies \\
\vtab \\
return \\
\hline
\end{tabular}
\end{center}
\caption{The  Algorithm}
\label{tb:auth}
\end{figure*}

We define  by induction on the structure of .  If  is {\bf true},
then .  If , then  iff
 issues a grant  such that, for some
substitution ,  and .  In this context,
a principal  issues a grant  if  issues  for some
.  If , where each  is  or
a  condition, then .
Pseudocode for  is given in Figure~\ref{tb:CMet}.

\begin{figure*}[htb]
\begin{center}
\begin{tabular}{|l|}\hline
\underline{:}\\\\
{\bf if}  \\
{\bf then} return \\\\
{\bf if} \\
{\bf then}\\
\vtab \\
\vtab \forall x_1 \ldots \forall x_n(\cd_g\imp\cc_g) \in R_p\\
\vtab\phantom{ }\sigma\\
\vtab {\bf if}  for a condition \\
\vtab {\bf then} return \\
\vtab {\bf else} return \\\\
{\bf if} , where each  is  or a  condition\\
{\bf then} return \\
\hline
\end{tabular}
\end{center}
\caption{The  Algorithm}
\label{tb:CMet}
\end{figure*}

\begin{sloppypar}
\xam\label{ex:XrML1}
In Section~\ref{s:XrMLsyntax}, we argued informally that Amy says Bob is attractive if the set
of licenses is , where
 and
  The formal algorithm
gives the same conclusion.  Specifically, 
sets  and calls .
During this call  is set to  and  is called.  Because
,  and, thus, .

Suppose that a trusted principal says that Amy has the authority to issue  (i.e., if Amy
says , then  holds).  Then we can conclude that Bob really is attractive, because
, where .
Specifically,  begins by calling .
, in turn, calls , where
.
.  So,
Bob is attractive if the condition  holds.  To
determine if the condition holds,  calls
.  We have already shown that
; we evaluated this call during our
analysis of .  So Bob is indeed attractive.
\exam
\end{sloppypar}

 as described here and in the XrML specification is somewhat ambiguous.  For example,
the specification does not say in which order the conditions in  should be tested to see if at
least one condition in  holds.  As a result, there are a number of possible executions of a call
, depending on the implementation of .  It is easy to see that, for a
particular input, every execution that terminates returns the same output.  However, as we show in
Example~\ref{ex:terminate}, whether  terminates can depend on how it is implemented.  A
similar issue arises with  and .  We talk about an execution of , , or
 only if the choice of execution affects whether the algorithm terminates.  For example, we
write  if every execution of  returns .

\subsection{An Analysis of }\label{s:alg2}
In this section we present five examples in which  gives unexpected results.
Example~\ref{ex:subset} reveals a mismatch between  and the informal language description;
the discrepancy exists because  makes the subset assumption and the informal language
description does not.  Example~\ref{ex:lostL} demonstrates that a license  should not be
removed from the set of licenses when determining if  is permitted to issue .
Examples~\ref{ex:terminate}, \ref{ex:terminateC}, and \ref{ex:terminateB}, show that a reasonable
implementation of  does not terminate on all inputs, for three quite different reasons:
Example~\ref{ex:terminate} shows that on some inputs  makes infinitely many identical calls,
Example~\ref{ex:terminateC} shows that on some inputs the call tree for  includes an
infinite path of distinct nodes; and Example~\ref{ex:terminateB} shows that on some inputs the call
tree for  includes a node with infinitely many distinct children.

\begin{sloppypar}
\xam\label{ex:subset}
Suppose that Alice is quietly walking beside her two giggling daughters, Betty and Bonnie.  Are the
three of them a quiet group?  Intuitively, they are not, because Betty and Bonnie are giggling.
According to , however, the answer is yes.  Since Alice is quiet and  makes the subset
assumption,  concludes that the principal  is quiet; that
is, 
\exam
\end{sloppypar}

\begin{sloppypar}
\xam\label{ex:lostL}
Suppose that Alice says that she is smart, and if Alice says that she is smart, then she is permitted
to say that she is smart.  Is Alice smart?  Intuitively, she is, because Alice is permitted to say
that she is smart and she does so.  But consider , where
, , and
.   begins by calling
.   checks whether or not Alice is permitted to issue .
It determines that Alice may not issue , because the permission does not follow from  and
.  Since Alice is not permitted to issue ,  sets  and
returns .  Because  returns ,  returns .
\exam
\end{sloppypar}

\xam\label{ex:terminate}
Suppose that Alice issues the grant ``if I say Bob is smart, then he is'' and Alice is permitted to
issue this grant.  Can we conclude that Bob is smart?  To answer the
question using , let
, ,
, and .  We are interested
in the output of .   begins by calling  , which
returns the set .   then calls
, which sets  and calls
 again.  It is easy to see that an infinite number of calls to
 are made during the execution of  and thus
the execution does not terminate.

It is tempting to conclude that a set  of licenses and a set  of grants imply a conclusion 
only if  terminates and returns .  Unfortunately, whether 
terminates can depend on the order in which the calls to  are made.  To see why, consider a
slight modification of the previous example where we add the grant
 to .  Intuitively, this means that an implicitly trusted
principal says that Bob is smart.  It now seems reasonable to expect that every execution of
 returns , where , and , , and  are as
defined in the original example.  Surely the issued grants imply that Bob is smart, since a grant
issued by a trusted principal says just that!  However, only some of the executions terminate.  Every
execution of  begins by calling , and every execution of 
returns .  If an execution of  next calls
, then that execution of  returns .  On
the other hand, if the 
execution calls  and then waits for the call to return before
calling , then the execution does not terminate for the same reason that every
execution of  does not terminate.
\exam

\begin{sloppypar}
\xam\label{ex:terminateC}
Suppose that Alice says ``for all grants , if I say I am allowed to issue the grant
, then I am allowed to issue '', and Alice is allowed to
issue that statement.  Is Alice allowed to issue the grant ?  To answer
this question using , some abbreviations are useful.  For all grants , we abbreviate the
condition
 as
 and we abbreviate the grant  as .  We execute
, where ,
,
and .
 begins by calling , which returns
.  Next  calls ,
which calls , which calls
, and so on.  It is not hard to see that, for all
integers ,  is called, where  and
, for all grants .  It follows that  does not terminate and, thus,
 does not terminate.
\exam
\end{sloppypar}

\xam\label{ex:terminateB}
Suppose that Alice may say that she is trusted if Bob says that Alice may issue some grant (any grant
at all).  May Alice say that she is trusted?  To answer this question using , we run
 where
,
, and
.   begins by calling
 which returns .  We show below that
 is an infinite set, so every execution of  that tries to compute  does not terminate.
Even if  is defined without explicitly listing all of its elements,  must determine if some
element in  holds.  In fact, none do.  Thus, any  approach to testing if some condition in  holds
by explicitly testing each condition will not terminate.

It remains to show that  is an infinite set.  The key observation
is that infinitely many distinct grants can be expressed in the language, even if the vocabulary consists
of only one property  and one principal .  To see why, define grants , ,
inductively by taking
 and 
for all .  Since each of these grants is clearly distinct,  is infinite.
\exam

\subsection{A Corrected Version of }\label{s:alg3}
In this section we revise  to correct the problems observed in Section~\ref{s:alg2}.  One of the
corrections is fairly straightforward.  We resolve the mismatch illustrated in Example~\ref{ex:subset} by
removing the subset assumption from .  We note that the language is sufficiently expressive to force
the subset assumption, if desired, by including the following grants in :

where , , and  are variables of the appropriate sorts and  are the
properties in the language.  We now consider Examples~\ref{ex:lostL}, \ref{ex:terminate},
\ref{ex:terminateC}, and \ref{ex:terminateB}, in turn.

\begin{sloppypar}
The problem illustrated in Example~\ref{ex:lostL} lies in the definition of .
Recall that we define .  Roughly speaking, 
should consist of the set of grants in  together with those issued by someone
who has the authority to do so.  In other words,  should be
p.  However, when computing
,  is given the argument 
rather than .  Our solution is to do the ``right'' thing here, and compute
.  But now we have to deal with the problem of
termination, since a consequence of our change is that  terminates
only if the set .  To ensure termination, we modify  so that no
call is evaluated twice.  Specifically, the revised  takes a fourth argument
 that is the set of closed conditions that have been the first argument to a
previous call;  returns  if .  Because
the revised  calls , which calls , we modify  to take
 as its fourth argument.  A closed condition  is implied by a set  of
licenses and a set  of grants if the modified  algorithm returns 
on input .  Pseudocode for the revised version of ,
which we call , and for the revised version of , which we call
, are given in Figures~\ref{tb:XrMLProc2} and \ref{tb:auth2}, respectively.
 refers to the algorithm , which is  modified to correct
the behavior seen in Example~\ref{ex:terminate} (discussed below).
\end{sloppypar}

\begin{figure*}[htb]
\begin{center}
\begin{tabular}{|l|}\hline
\underline{:}\\\\
\\
{\bf if}  for a condition \\
{\bf then} return \\
{\bf else} return \\
\hline
\end{tabular}
\end{center}
\caption{The  Algorithm}
\label{tb:XrMLProc2}
\end{figure*}

\begin{figure*}[htb]
\begin{center}
\begin{tabular}{|l|}\hline
\underline{:}\\\\
{\bf if} \\
{\bf then} return \\
{\bf else}\\
\vtab \\
\vtab \\
\vtab {\bf for} each license \\
\vtab\vtab {\bf if} \\
\vtab\vtab {\bf then} \\
\vtab \\
\vtab{\bf for} each grant \\
\vtab\vtab \\
\vtab return \\
\hline
\end{tabular}
\end{center}
\caption{The  Algorithm}
\label{tb:auth2}
\end{figure*}

The type of nontermination seen in Example~\ref{ex:terminate} occurs because  tries to verify
that a condition of the form  holds by checking if  holds.  To correct
the problem, we modify  to take a third argument  that is the set of  conditions that
have been the first argument to a previous call; that is,  is the set of  conditions that
are currently being evaluated.  If the revised  is called with a first argument  that is
in  (which means that the call was made when trying to determine whether  holds), then the
algorithm returns , thereby halting the cycle.  Pseudocode for the revised version of ,
which we call , is given in Figure~\ref{tb:CMet2}.

\begin{figure*}[htb]
\begin{center}
\begin{tabular}{|l|}\hline
\underline{:}\\\\
{\bf if}  \\
{\bf then} return \\\\
{\bf if} \\
{\bf then} return \\ \\
{\bf if}  and \\
{\bf then} return \\\\
{\bf if}  and \\
{\bf then}\\
\vtab \\
\vtab \\
\vtab \forall x_1 \ldots \forall x_n(\cd_g\imp\cc_g) \in R_p\\
\vtab\phantom{ }\sigma\\
\vtab {\bf if}  for a condition \\
\vtab {\bf then} return \\
\vtab {\bf else} return \\
\hline
\end{tabular}
\end{center}
\caption{The  Algorithm}
\label{tb:CMet2}
\end{figure*}

It is easy to see that the problem illustrated by Example~\ref{ex:terminate} does not
occur during the execution of .  Moreover, the following theorem shows that
 is correct in the sense that every execution of  and 
have the same input/output behavior on the inputs for which both executions terminate
and, if an execution of  terminates for a particular input , then
some execution of  terminates as well.
\pro\label{t:correct2}
For all closed conditions  and sets  of licenses,
\begin{itemize}
\item[(a)] every execution of  that terminates returns the same output,
\item[(b)] every execution of  that terminates returns
the same output,
\item[(c)] if an execution of  terminates by returning the truth value ,
then an execution of  terminates by returning .
\end{itemize}
\epro

Now consider Examples~\ref{ex:terminateC} and \ref{ex:terminateB}.  To address the type of
nontermination seen in these examples, we might hope to find an algorithm  that
returns the same output as  on inputs for which an execution of 
terminates and returns  on all other inputs.  Returning  when no execution
of  terminates gives an intuitively reasonable answer; moreover, this approach
is essentially what is done in MPEG-21 REL (see Section~\ref{s:MPEG-21} for details).
Unfortunately, as we show shortly (see Theorem~\ref{t:undec2}) this approach will not work
in general; there is no algorithm  with these properties, since whether
 terminates on a given input is undecidable.

Since we cannot ``fix'' , the best we can do is define some restrictions such
that, if the restrictions hold for a particular query, then the problems seen in
Examples~\ref{ex:terminateC} and~\ref{ex:terminateB} do not occur for that query.  We now
describe some conditions that are sufficient and that we suspect often hold in practice.

To describe our approach for avoiding the problem seen in Example~\ref{ex:terminateC}, let
 and  be the grants  and
 respectively.  The license 
\emph{affects} the license  if and only if there are closed substitutions 
and  such that a condition of the form  is mentioned in
 and .  For example, consider the license set
, where 
and .  The
license  affects the license  because the conditions
are satisfied if  is a closed substitution and  is a closed substitution such
that .  A set  of licenses is \emph{hierarchical} if there exists
a strict partial order  on the licenses in  such that, for all license
, if  affects  then .  Continuing our example,
 is hierarchical because the ordering 
satisfies the requirements.  Observe that no hierarchical license set includes the license
 because this license affects itself.  The
license set in Example~\ref{ex:terminateC} is not hierarchical for essentially the same reason.
It is not hard to see that by restricting the set of queries  to those in
which  is hierarchical, we avoid the type of circularity that causes the problem seen in
Example~\ref{ex:terminateC}.  In the next result and elsewhere, we use  to denote the
cardinality of a set .

\pro\label{p:fixExB}
If  is a closed condition,  is a hierarchical set of licenses,  is a set of closed
 conditions, and  is the call tree of an execution of , then the
height of  is at most .
\epro

We further restrict the language to avoid the problem seen in Example~\ref{ex:terminateB}.
To understand our restriction, recall that  first extends  to  by
adding all the grants that are issued by someone who has the authority to do so.  Since
all the grants in  are in , the set  must be finite.  Then  creates the
possibly infinite set  consisting of all substitution instances of grants in
, and returns .  (For simplicity here, we
are assuming that  does not use the subset assumption; the subset assumption does
not affect our discussion.)  Since  considers only the grants in  whose
conclusion matches the first input to , we could certainly replace  by
, where

Because  is closed,  is finite if, for every grant  in , if the
condition of  mentions a free variable , then either  ranges over a finite set
or  appears in the conclusion of .  Our solution is simply to restrict the language
so that every grant has this property.  Since, in our fragment, there are infinitely many
resources (grants) and only finitely many principles, this amounts to restricting the
language so that if  is a grant, then
every free variable of sort  that appears in  also appears in .
We call a grant \emph{restrained} if it has this property; we call a license 
restrained if  is restrained.  Thus, for example,
 is restrained, but neither

nor the grant  in Example~\ref{ex:terminateB} is restrained.
It is easy to see that, for all restrained grants
 and closed conclusions , if 
is the number of primitive principals in the language and  is the length of , then
there are at most  grants of the form  such that
 is a closed substitution and .  Thus, by considering only
restrained grants and licenses, we solve the problem raised in Example~\ref{ex:terminateB}.

\section{Formal Semantics}\label{s:semantics-xrml}
In this section we provide formal semantics for the XrML fragment described in
Section~\ref{s:XrMLsyntax}.
We show that the semantics is correct 
in the sense that 
it captures the output of the (corrected) query algorithm, .
We then consider two, arguably more intuitive,
semantics and show that neither captures ..

\subsection{A Correct Translation}\label{s:correctSemantics}
To give formal semantics to our fragment, we translate licenses in the grammar to formulas
in a modal many-sorted first-order logic.
The logic has three sorts: , , and .  The vocabulary includes
the following symbols, where  is the application-provided set of primitive
principals and  is the application-provided set of properties:
\begin{itemize}
\item a constant  of sort  for every principal ;
\item a constant  of sort ;
\item a ternary predicate  that takes arguments of sort , , and
;
\item a unary predicate  that takes an argument of sort  for each property
;
\item a function ;
\item a function  for each grant  in
the language; if  are the free variables in , then  is of sort
, for .  If  is closed, then the corresponding function is a
constant that we denote as ; and
\item a modal operator  that takes a formula as its only argument.
\end{itemize}
Intuitively,  means principal  has property , and  means formula
 is valid.  Notice that every principal in the grammar corresponds to a term in the
language, because  is a function symbol.

The semantics of our language is just the standard semantics for first-order logic, extended
to deal with .  We restrict attention to models for which  satisfies the
following standard properties:
\begin{itemize}
\item[U1.] 
\item[U2.] 
\item[U3.] 
\item[U4.] 
\end{itemize}
We call such models \emph{acceptable}.   is true in a model  if  is true
in all acceptable models.  If a formula  is true in all acceptable models, then we say
that  is \emph{acceptably valid}.  Thus,  is true in an acceptable model iff
 is acceptably valid.

The translation takes four finite sets as parameters.  They are a set  of licenses, a set
 of closed resources, a set  of closed  conditions, and a set  of closed
conclusions.
Roughly speaking,  is the set of licenses that have been issued
and 
is the set of resources that are relevant to a particular application
For all XrML queries,  and .
(The reader is encouraged to take  when first
trying to understand the details of the semantics.)
The input parameter 
allows users to specify a set of  conditions that do not hold, regardless of .  We
also use the parameter to insure that the translation of a  condition does not enter an
infinite loop.  The input parameter  corresponds to the fourth argument of .
(Recall that an XrML query asks if a conclusion  follows from a set  of licenses and
set  of grants; the answer is ``yes'' if  returns .)
By including , we can give a translation that
agrees with
the  algorithm.
The translation is defined below, where  is the translation of the string  given
input , , , and .

\begin{itemize}
\item If  or , then .
\item If  and , then .  Note that we assume  is closed, because this
assumption is built into .
\item .
\item , where  if
 is of sort , and  if  is of sort .  (Recall that  is the set of
principals.)
\item .
\item If , then .
\item If , then
 where 

and .
\item .
\item , where  if  is a variable
of sort ,  if  is a closed grant, and  if  is an
open grant with free variables .
\item .
\item for every principal , .
\end{itemize}
This translation has two features that seem somewhat inelegant.  The
first is that, in dealing with 
a universal quantifier, variables are replaced by the
constants over which they range; the second is the use of the 
operator.  In the next section, we explain in more detail why we
translated in this way.  For now, we show that, in a precise sense, our
translation captures the intended interpretation of the language.

Note that  does not depend on .  This matches our intuition that the
meaning of a  condition depends only on what principals have said, rather than on what is
actually true.  By adding  to , we ensure that the meaning of the condition does not
depend on itself.  Finally, observe that  is defined in terms of the
translation of potentially more complex expressions.  Nevertheless, the following result shows that
the translation is well defined.
\thm\label{t:trans1}
For all strings  in the language and all finite sets  of licenses,
 of closed resources,  
of closed  conditions, and  of closed conclusions,
 is well defined. 
\ethm

\begin{sloppypar}
We believe that our semantics captures the intended meaning of XrML expressions, as implied by the
specification.  To make this precise, we show that  agrees with the semantics on all queries.
Specifically, we show that for all terminating executions  of , 
returns  iff  is acceptably valid, where  is the set of
closed resources that appear in the first argument of a call to , , or 
during execution .  Intuitively,  is the set of resources relevant to answering the query
.  For example, suppose that, during a particular execution  of
,
 is called.  Then
 includes  and .  Notice that if  is a
terminating execution, then  is finite.
\thm\label{t:correct1}
Suppose that  is a query and  is a terminating execution of
.  Then  returns  iff

is acceptably valid, where .
\ethm
\end{sloppypar}
\subsection{Two Alternative Translations}\label{s:temptingTrans}
We now discuss why we captured universal quantification by replacing
variables by constants and the need for the  operator.  We do so
by giving two arguably more natural alternative translations that do not
have these ``features'', and showing where they go wrong.  While this
does not show that there is no correct translation that translates
universal quantification as universal quantification, and does not use
, it does show why finding such a translation
is nontrivial.

For all strings  in our fragment, let  be a
translation of , where , ,
, and  are as defined in Section~\ref{s:correctSemantics}.  The
formula  is 
identical to  except that
.
Notice that the new translation often leads to more concise formulas and
does not depend on the input 
parameter .  
Unfortunately, this translation does not interact well with our use of
 when it comes to universally quantified formulas involving
.
The following example shows
why we rejected this translation.

\xam
Suppose that Alice may issue any grant.  Alice issues the grants ``if I say some principal  is
great, then  is also good'', ``if I say Bob is good, then Charlie is great'', and ``Bob is great.''
Can we conclude that Charlie is good?

To answer our question using , 
let  and consider
\mbox{}, where

It is not hard to see that the algorithm returns  (i.e., Charlie is good), which is the
intuitively correct answer.  Roughly speaking, the algorithm deduces that Charlie is good if Alice
says he is great; Alice says Charlie is great if Alice says Bob is
good; Alice says Bob is good if
Alice says Bob is great; and Alice does indeed say Bob is great.

\begin{sloppypar}
To answer our question using the revised translation, we 
need to 
determine the
validity of the formula 

\commentout{
It is tedious, although not difficult, to perform the translation and
observe that the formula is not
valid. The key observation is that, if a  condition  is mentioned in a grant , then the
translation of  does not depend on .  For example,
 does not depend on .  To
see this, let

and observe that ; the formula
; so
.
Roughly speaking, because  does not follow from
 and  alone (i.e., without ), we do not conclude that
 holds and, thus,
we do not conclude that
 holds.


The translation given in Section~\ref{s:correctSemantics} leads to the intuitively 
correct answer that Charlie is good.  This is because the translation instantiates 
all variables.  As a result, the translation does not have the property that every 
 condition  is independent of the grants that mention . Rather it has the 
property that every variable-free  condition  is independent of the 
``instantiations'' of the grants that mention .  So, according to the translation, 
the meaning of  depends on the 
grants  for 
all principals , , and .  Since these grants together 
imply , we conclude that 
 holds.  
\bbox
}
It is easy to see that this formula equivalent to 

Clearly, .  In the original translation, we combine
 with  to conclude  
, then combine  with 
 to derive ; that is, the formula corresponding to the
query is valid under the original translation.  Unfortunately,
the latter two steps fail with the
revised translation.  As suggested above, the problem lies in the
interaction of quantified formulas and  in .  
Consider the first step.  Note that  is equivalent to a conjunction of which one conjunct is
.  When combined with ,
we can indeed conclude .  On the other hand,
with the revised translation,  is 

The  formula is vacuously false, so  is vacuosuly true, and does not help in concluding
.  Thus, the formula corresponding to the
query is not valid under the revised translation; we do not get the
intuitively correct answer.
\bbox
\end{sloppypar}
\end{example}

Next, suppose that we modify our original translation so that
the

operator
is not used.
In particular, we fix the input parameter  to be the empty set and
remove the validity
operator from the translation of  conditions.  For all strings , let
 be the translation of  that is identical to
 except that, if  is of the form ``'', then
 and,
if  is of the form  and , then
,
where  and .
Observe that every translated string is a variable-free formula in first-order logic.
The following example
illustrates a problem
with this translation.
Roughly speaking, the problem is that, according to
the translation, every statement that follows from the given licenses and grants is said by every
principal.
\xam
Suppose that Alice cheated on an exam and, if Alice admits that she cheated, then she is trusted.
Is Alice trusted?  Intuitively, the answer is ``no'' because Alice has not confessed.

\begin{sloppypar}
To answer the question using , we execute

where
.  It is not hard to see that  returns ,
indicating that Alice is not trusted.  Specifically, the algorithm determines that Alice is trusted
 only if Alice said she cheated and Alice has not done this.
\end{sloppypar}

To answer the question using the revised translation, we determine the
validity of the formula 
.
Standard manipulations show that the formula is logically equivalent to

which is valid. So, if we use the revised translation, we conclude that
Alice is trusted.


If we use the translation in Section~\ref{s:correctSemantics}, then we determine that
Alice is not trusted.  This is because  ``isolates'' the  condition
from the statements implied by the given grants and the issued licenses.
As a result,
 holds only if 
the grants issued by Alice, in isolation, imply ; 
that is, 
holds only if  
 is . 
Since  is not an acceptably valid formula, 
we conclude that 
 does not hold and, thus,
 does not hold.
\exam

\section{Complexity}\label{s:trac}
To answer a query , we need to determine whether an execution of
 returns .  We claimed earlier that the problem of answering queries
is, in general, undecidable.  We now formalize this claim.  Recall that a grant  is restrained if
every variable of sort  mentioned in the antecedent of  is mentioned in the conclusion of .
We say that \emph{a grant  is in a set  of licenses} if  for some principal .  A
grant  is in , for some set  of grants, if  is in  or  is in .
\thm\label{t:undec2}
Determining whether some execution of  returns  is undecidable for
the set of queries  such that at most one grant in  is not restrained.
\ethm
Let  be the set of queries  such that every grant in  is restrained.
In this section, we examine the computational complexity of answering queries for fragments of .

We first show that the problem of answering queries for the full language  is NP hard for two
quite different reasons.  The first stems from the fact that, if there are  primitive principals, we
can construct  principals using the  operator.  The second is that, to answer a query, we
might need to determine if exponentially many closed  conditions hold.

We use the following definitions to state our results.   is the set of queries that do not
mention the  operator.  A grant  is \emph{-restricted} if the number of variables of sort
 that are mentioned in the antecedent of  and not in the conclusion of  is at most .
 is the set of queries  such that all grants in  are
-restricted.  A call  is \emph{-bounded} if the call tree for every execution
of  has height at most .  Note that Proposition~\ref{p:fixExB} shows that
if  is a hierarchical set of licenses, then  is -bounded.
 is the set of queries  such that if an execution of
 calls , then  is -bounded.
The next result shows that deciding if at least one execution of  returns  is hard, even
if we restrict to queries in  that satisfy any two of the following: the union operator is not
mentioned (i.e., restrict to ), the query is -restricted for some fixed , or all calls made
during an execution of the query are -bounded for some fixed .  (We show shortly that the set of
queries in  that satisfy all three restrictions is tractable.)

For a formula , let  be the length of  when viewed as a string of symbols.  For a
set , let  be the length of ; that is .  Finally, we
abbreviate , the set of primitive principals, as .

\thm\label{t:NPHardAll}
The problem of deciding
if some
execution of  returns  for 
is  NP-hard for .
\ethm

If we make all three restrictions (that is, restrict to queries in
, for some fixed  and ), then determining whether
a query returns  is decidable in polynomial time.  However, as we might expect in light of
Theorem~\ref{t:NPHardAll}, the degree of the polynomial depends on  and , and the polynomial involves
constants that are exponential in  and .  Note that, for queries in
, all executions of  terminate and return the
same answer.  Termination is fairly easy to show since every call tree of an execution of
 has a finite branching factor if , and has finite
height if .  The fact that all executions of 
return the same output for all queries
 follows easily from
Proposition~\ref{t:correct2}(b).

\thm\label{t:NPHardAll1}
For fixed  and , if 
then determining whether  returns  takes time
.
\ethm
\noindent The big-O notation is hiding some rather complex (and uninformative) terms that are functions of
 and ; we spell these out in the appendix.

In practice, we believe that queries are often in  and, as shown in Proposition~\ref{p:fixExB}, if
we restrict to queries where the set  of licenses has size at most  and is hierarchical (which we
expect in practice will often be the case), than all call trees that arise are guaranteed to have height
at most .  Thus, in practice, we expect that we can restrict to queries in  and 
for relatively small values of  and .  Moreover, even for larger values of  and  (say, as
large as 10), as long as the union operator does not appear, we expect that queries can be answered
efficiently, because the upper bound is quite conservative.

How reasonable is it to restrict to queries in  that do not mention the  operator?  We
believe that XrML without the  operator is sufficiently expressive for many applications.  To
examine the effect of not using the  operator, note that principals appear as the first argument
in a license, in a  condition, and in a conclusion.
\begin{itemize}
\item According to the XrML documentation, the license  is an abbreviation for
the set of licenses .  It follows that we can restrict the
first argument of licenses to primitive principals and variables without sacrificing any expressive
power.  (In fact, we can restrict the first argument of licenses to only primitive principals, because
 assumes that if  is a license in , then  is variable-free.)
\item We
can replace all conditions of the form
, where  are primitive principals, by a condition
, where  is a new primitive principal, and then
expand the set  of issued licenses by adding a new license  for every
license  already in , where .  It is not hard to show that this
results in at most a quadratic increase in the number of grants.  Thus, as long as the first argument to
 is variable-free, we can express it without using .
\begin{sloppypar}
\item To understand the impact of our restriction on conclusions, we need to consider the meaning of
statements such as  and
.  According to the XrML document,
 means Alice and Bob together (i.e., when viewed as a single
entity) is trusted;  means Alice and Bob is permitted to issue
.  However, the XrML document does not explain precisely what it means for Alice and Bob to be viewed as
a single entity.  Indeed, it seems to treat this notion somewhat inconsistently (recall the inconsistent use
of the subset assumption).  There are other difficulties with sets.  Notice that if
 is permitted to issue a grant, then presumably  holds if
 issues .  However, according to the XrML documentation, the license
 is simply an \emph{abbreviation} for the set of licenses
.  So it is unclear whether a principal that is not a
singleton can issue a license.  Furthermore, if principals that are not singletons can issue grants and
 is permitted to issue a grant , then it seems reasonable to conclude
that  holds if  is issued by both Alice and Bob, but it is not clear whether  holds if it is issued
by only Alice (or by only Bob).
\end{sloppypar}

There may well be applications for which these notions have an obvious and
clear semantics.  But we suspect that such applications typically include
only a relatively small set of groups of interest.
In that case, it may be possible to simply take these groups
to be new primitive principals, and express the relationship between the
group and its elements in the language.  (This approach has the added
advantage of forcing license writers to be clear about the semantics of
groups.)
\end{itemize}
In short, we are optimistic that many applications do not need the union function.

\section{The Entire XrML Language}\label{s:core}
XrML has several components that are not in our fragment.  Most have been excluded simply for ease of
exposition.
That is, our work can be extended in a straightforward way to a
much larger fragment of XrML.
In this section we list the main omissions, briefly discussing each one.
Giving formal semantics to the entire XrML language remains an open problem.

\begin{itemize}
\item XrML supports \emph{patterns}, where a pattern restricts the terms over which a variable
ranges. For example, if the variable  is restricted to the pattern ``ends in Simpson'', then
 ranges over the terms that meet this syntactic constraint (e.g.,  ranges over
).
Our semantics includes the patterns that correspond to properties in our fragment.
Continuing the example, we could capture the pattern ``ends in Simpson''
by having the property   in the
language and having the set of grants determine which terms have the property.



XrML
also
allows a pattern to be a set of patterns.  We can express a set of patterns as a
conjunction of patterns.  Since we can express conjunctions of
properties in our fragment, we can
also capture sets
of the corresponding patterns.

Patterns can be written in any language that the writer chooses.  The default is to
write patterns as XPath expressions.  First-order logic is not
well-suited to capturing
XPath expressions; the situation may be even worse with other languages.
Therefore we do not believe our semantics can be easily extended to
include all patterns.
The significance of this limitation is not yet clear.

\item XrML supports \emph{delegable grants}.  A delegable grant  can be viewed as a conjunction of a
grant  in our fragment and a set  of grants that, essentially, allow other principals to issue .
For example, the delegable grant ``Doctor Alice may view Charlie's medical file and she may also give the
right to view the file
to her colleague, Doctor Bob'' can be viewed as the conjunction of the grant
``Doctor Alice may view Charlie's medical file'' and the grant ``Alice is permitted to issue the grant
`Doctor Bob may view Charlie's medical file'\, ''.

The XrML specification
also
supports more general types of delegation.  For
example, in XrML, we can
say ``Doctor Alice may view Charlie's medical file and may delegate this
right to anyone under
any condition that she specifies.''
The extent to which our semantics can capture delegation, as defined in the XrML specification,
is an open problem.
\item XrML supports \emph{grantGroups}, where a grantGroup is a set of grants.  We can extend our syntax
to support grantGroups by closing the set of grants (as currently defined) under the union operator.
Note that our proposed treatment of grantGroups is quite similar to our current treatment of principals.
\item XrML has variables that range over conditions.  It is
not clear how this capability
is intended to be used in practice.  Our hope is that the practical
applications will translate easily
to our fragment.  Examining this issue is left as an open problem.
\begin{sloppypar}
\item XrML includes rights, resources, and conditions that are not in our fragment.  There should be no
difficulty in extending our translation to handle these new features, and proving an analogue of
Theorem~\ref{t:correct1}.  But we might not be able to answer queries in the extended language.  The
problem is that XrML allows resource terms to be formed by applying functions other than .  For
example, MPEG-21 REL extends XrML by defining a \emph{container} resource that is a sequence of resources.
This naturally translates to a function , so that
the container  is translated as
.  Allowing such functions makes the problem of deciding
if a conclusion follows from a set of XrML licenses and grants undecidable, for much the same reason that
the validity problem for negation-free Datalog with function symbols is undecidable \cite{NS}.
\end{sloppypar}
\item XrML allows an application to define additional principals, rights, resources, and conditions within
the XrML framework.  Obviously, we cannot analyze terms that have yet to be defined; however, we do not
anticipate any difficulty in extending the translation to deal with these terms and getting an analogue of
Theorem~\ref{t:correct1}.
\item XrML allows licenses to be encrypted and supports abbreviations via the \emph{Inventory} component.
However, the XrML procedure for determining if a permission follows from a set of licenses assumes that all
licenses are unencrypted and all abbreviations have been replaced by the statements for which they stand.
In other words, these features are engineering conveniences that are not part of understanding or reasoning
about licenses.
\end{itemize}

\section{Negation}\label{s:extend}
We believe that many license writers will find it important to deny permissions explicitly and to state
conclusions based on whether a permission is granted, denied, or neither granted nor denied by a particular
principal.  For example, Alice's mother might want to say ``Alice is not permitted to enter the adult
website'', a teacher might want to say ``if the university does not object, then Alice is permitted to audit
the class'', and a lawyer might want to say ``if the hospital permits an action that the government forbids,
then the hospital is not compliant''.

\begin{sloppypar}
We can write these statements in XrML by using special ``negated predicates''.  For example, we can write
 to capture
``Alice is not permitted to enter the adult website'\footnote{Since XrML allows the application to define only additional principals, rights, resources, and
conditions, we cannot add  to XrML without extending the framework, but the extension is
so minor that we ignore it here; moreover, there are no implications as far as complexity goes.},

to capture ``the university does not say that Alice is not permitted to audit the class'' (i.e., the
university does not object to Alice auditing the class), and  to
capture ``the hospital is not compliant''.  We remark that this approach of using ``negated predicates'' has
appeared before in the literature \cite{JSS,MS04}; it is essentially the technique used by XACML \cite{XACML},
another popular license language.
\end{sloppypar}

Adding negated predicates to XrML is straightforward; reasoning about statements in the extended language is
not.  One problem is that we have to handle statements that are intuitively inconsistent.  For example,
consider the grants  and ,
which say that Alice is permitted and prohibited to issue the grant .  It is not clear what we should
conclude from these grants.  In particular, it is not clear if Alice should be allowed to issue .  (The
languages that include negated predicates typically require the policy writer to specify how inconsistencies
should be resolved.)

Other problems arise if we extend XrML so that the set of conditions includes  and ,
in addition to  and .
\xam\label{ex:diff1}
Suppose that a company allows employees to access their server and allows nonemployees access if they sign a
nondisclosure agreement.  If Alice cannot prove that she is an employee, can she still get access to the
server by signing a nondisclosure agreement?  Intuitively, she should be able to, because Alice is either an
employee, in which case she has permission, or she is not an employee, in which case she still has permission
because she signed the waiver.  However, if we express the query in the obvious way (using negated predicates),
then Alice is not permitted, because

is not valid.
\exam

To address the unintuitive behavior shown in Example~\ref{ex:diff1}, we could replace the negated predicates
by a negation operator, which is the standard approach in logic.  Let XrML be XrML extended so that
the set of conditions includes   as well as , and the set of conclusions
includes  and , as well as  and .  There is
no problem extending the semantics of XrML to XrML.  Moreover, by replacing  in
Example~\ref{ex:diff1} by , we get the intuitively correct answer.  The downside of
allowing negation is intractability.  Recall that  is a small fragment
of XrML: the licenses in this fragment do not mention the  operator, every variable in the antecedent
of a grant appears in its conclusion, and the execution tree for all calls to  has height at most
two.  Theorem~\ref{t:NPHardAll} shows that queries in  are tractable;
however, as we now show, adding negation to this relatively small language makes it intractable.
\thm\label{t:ext1}
Let  be a tuple in  extended to include negated
 conditions and negated conclusions.  The problem of deciding whether

is valid is NP-hard.  This result holds even if , all of the licenses in , and all of the
conclusions in  are in XrML, all but one of the grants in  is in XrML, and the one grant that is
in XrML -- XrML is of the form .
\ethm

We are currently investigating whether there is a tractable fragment of XrML that is sufficiently
expressive to capture the grants and licenses that are of practical importance.  We expect that some
ideas from our work on Lithium \cite{HW03} will prove useful in this regard.

\section{MPEG-21 REL}\label{s:MPEG-21}
MPEG-21 is an international standard that is based on XrML.  In \cite{HW04}, we give semantics to a beta
version of MPEG-21.  All of the problems discussed in Section~\ref{s:alg2} are present in the beta version.
We reported these issues to Xin Wang and Thomas DeMartini of the MPEG-21 working group before the final
version was released, and our concerns were addressed in the final version (although not exactly as
specified in Section~\ref{s:alg3}).

The key differences between XrML and MPEG-21 are as follows.
\begin{itemize}
\item MPEG-21
consistently makes the subset assumption;
a principal  has
all of the properties and permissions of principal , for .
\item A  condition takes a \emph{trustRoot}  and a conclusion .  No definition of trustRoot
is given in the specification; rather, it is assumed that the application will associate with every
trustRoot , set  of licenses, and set  of grants a set  of grants.  
holds if the set  of issued licenses and  together imply , where  is the set of
grants that implicitly hold.
\item Rather than defining an algorithm, MPEG-21 says that  and  imply  if there is a
\emph{proof tree} that shows the result holds.  Roughly speaking, a proof tree  shows that  and 
imply  if (a)  includes a grant  that implies  if certain conditions hold; (b) for each of
these conditions,  includes a proof tree showing that the condition does, in fact, hold, and (c) either
 is in  or, for some principal ,  is in  and  includes a proof tree showing that 
is permitted to issue .
\end {itemize}
We believe that the translation and corresponding proof of correctness given in
Section~\ref{s:correctSemantics}
can be modified in a straightforward way to apply to MPEG-21.  If this is
indeed the case, then an appropriately modified  can be used
to answer queries about licenses and
grants that are written in MPEG-21.

\section{Concluding Remarks}\label{s:concl}
XrML is a popular language that does not have formal semantics.  Since there are no formal semantics,
we cannot argue that the XrML algorithm is incorrect, but its behavior on certain input does seem
unreasonable.  To address the problem, we modified the algorithm, provided formal semantics for
an interesting fragment of XrML,
and showed that the modified algorithm
corresponds to our semantics in a precise sense.


We have examined only a fragment of XrML.  A key reason for XrML's popularity is that the framework
is extensible; applications can define new components (i.e., principals, rights, resources, and
conditions) to suit their needs.  We do not believe there will be be any difficulty in giving
semantics to the extended language.  The real question is whether we can find useful {\em tractable\/}
extensions.  As we have already seen, functions pose no semantic difficulties, but adding them makes
the problem of answering queries in XrML undecidable.  Another obvious and desirable feature is
negation.  Currently, XrML does not support negation in either the condition or conclusion of grants.
This is a significant expressive weakness.  Without negation, license writers cannot forbid an action
explicitly nor can they say that a conclusion holds if a permission is denied or unregulated by a
particular principal.  While it is easy to extend XrML to include negation, doing so without placing
further restrictions on the language makes it intractable.  We suspect
that we can use our earlier
work \cite{HW03} to find a fragment of XrML with negation that is tractable and substantially more
expressive.

Of course, it remains an open question whether XrML (or some extension
of it) is the ``best'' policy language to use to for rights managment
(and, more generally, trust management).  Many
languages have been proposed to do this, including XACML \cite{XACML},
ODRL \cite{ODRL}, numerous variants of Datalog
\cite{DeT,LGF03,LMW,MS04,Tre}, SPKI/SDSI \cite{HM01a,LM06,spki1,spki2},
and our own language Lithium \cite{HW03}.
As the references above indicate, a number of these have even been given
semantics using first-order or modal logic.
Comparing the strengths and weaknesses of all these approaches (and the
semantic methods used to capture them) remains an open direction for
future research.

Our work emphasizes the need for collaboration
between language developers and
the formal methods community.  Our analysis of XrML demonstrates that a
language without formal semantics is prone to ambiguities and inconsistencies, even if
that language is carefully crafted and reviewed by industry.  The good news is that collaborations
are possible.  The XrML developers that we contacted answered our questions and listened to our
concerns.  When they designed the next version of XrML, which is the ISO Standard MPEG-21 REL,
they did not make the same mistakes.

\subsection*{Acknowledgements}
Many thanks to Xin Wang and Thomas DeMartini, who answered our questions about the intended meaning
of various MPEG-21 components.

\appendix
\section{Proofs}
\opro{t:correct2}
For all closed conditions  and sets  of licenses,
\begin{itemize}
\item[(a)] every execution of  that terminates returns the same output,
\item[(b)] every execution of  that terminates returns the same output,
\item[(c)] if an execution of  terminates by returning the truth value , then
an execution of  terminates by returning .
\end{itemize}
\eopro
\prf
Parts (a) and (b) are immediate from the description of the  and .
To prove part (c), say that a call tree for  is \emph{non-repeating}
if it is not the case that there exists a path  in the call tree and two nodes
 and  on the path such that both nodes are labeled by the same call to
.  If  terminates, then it has a finite call tree.  Moreover,
it is easy to see that if there is a finite call tree for , then
there is a nonrepeating call tree:  If there is a call to  at two
nodes on a path, we simply replace the subtree below the first call to
 by the subtree below the last call to .  A
non-repeating call tree for  is essentially a call tree for
; the same calls are made at every step (the third
component has to change appropriately).
\eprf

For the proofs of Proposition~\ref{p:fixExB} and Lemma~\ref{complexityestimate}, we
rely on the observation that, if  is the call tree for an execution of
, then  can be viewed as an and-or tree, where a node labeled
 is an  node if  is a conjunction with at least
two conjuncts, an  node if  is a  condition and
 makes at least one recursive call, and a leaf if  is
 or if  is a  condition and  makes no
recursive calls.  For future reference, note that each node in  can be assigned a
truth value in an obvious way.  An  node is assigned ``true'' if all its
children are; an  node is assigned ``true'' if at least one child is; a leaf
labeled  is assigned ``true''; and a leaf labeled
 is assigned ``false''.

\opro{p:fixExB}
If  is a closed condition,  is a hierarchical set of licenses,  is a set
of closed  conditions, and  is the call tree of an execution of
, then the height of  is at most .
\eopro
\prf
Because  is hierarchical, there exists a strict partial order  on licenses
such that, if  and  are licenses in  and  affects , then
.  A node  in  is a \emph{} node if  is an 
node or a leaf.  It follows from the description of  that every 
node has at least two children and every child of an  node is a  node.
So, if a path in  from the root to a leaf has   nodes, then that path
has at most  total nodes; thus, it suffices to show that every path in  has at
most   nodes.  If , then it is immediate from the
description of  that  has height at most .  Suppose that .
Then, for every path  in , either  includes at most   nodes, in
which case  mentions at most   nodes, or  includes 
 nodes  and  such that an  node precedes , which precedes
, and no  node is between  and .  If  has a label of the form
 and  has a label of the form ,
then it follows from the description of  that there are licenses 
and  in  and closed substitutions  and  such that the
antecedent of  under  mentions ; the antecedent of  under
 mentions ; and  affects .  Thus,
.  It follows that  has at most  
nodes.
\eprf

\dfn
Suppose that  is a query,
 is an execution of , and
.
Define

\edfn

\othm{t:trans1}
For all strings  in the language and all finite sets  of licenses,  of closed
resources,  of closed  conditions, and  of closed conclusions,
 is well defined.
\eothm
\prf
Let  be the set of  conditions that are mentioned in issued grants; that is,
 iff there is a license  such that  mentions
.  Let  be the set of  conditions mentioned in .  Finally,
let .  We define a lexicographic order on the tuples 
such that  iff either (a)  or
(b)  and .  The proof is by
induction on this ordering.  If  and , then
, so the translation is well defined.  The inductive step is trivial
except when  and .

Suppose that  is of the form  and .  Recall that

where  and
.  Because  is a finite set,  is a finite set
and because  is a conclusion,  is well
defined.  So, to prove that  is well defined, it suffices to
show that  is well defined for all .
Suppose that .  Then  since
;  since ;
 since ; and
 since .  So, putting
the pieces together,  and, by the induction
hypothesis,  is well defined.
Suppose that .  Then  since
;  since ; and
 since .  Again, putting the pieces
together, , so
 is well defined by the induction hypothesis.
\eprf

We next prove Theorem~\ref{t:correct1}.  We actually prove a stronger result, given as
Theorem~\ref{t:generalizeCorrect1}; Theorem~\ref{t:generalizeCorrect1}(c) is
Theorem~\ref{t:correct1}.  The next five lemmas 
provide a deeper understanding of the properties of the ,
, and  algorithms and the translation, and are used
in the proof of Theorem~\ref{t:generalizeCorrect1}.

\lem\label{l1}
Suppose that  is a query.  Then during an execution  of

\begin{itemize}
\item[(a)] every call made to , , and  takes  as its
second argument;
\item[(b)] every call made to  and  takes  as its third argument;
\item[(c)] if  is called, then ;
\item[(d)] if  is called, then ;
and
\item[(e)] if  is called, then every conjunct of  is in
.
\end{itemize}
\elem
\prf
Parts (a) through (d) follow immediately from the descriptions of , ,
and .  For part (e), suppose that  is called.  Because
 is a closed condition, every conjunct of  is either  or of the form
, where  is a closed principal and  is a closed conclusion.
If  is of the form , then  is clearly in
.  Otherwise,  is of the form
.  Because  is an input to a call made during  and
 is mentioned in , .
\eprf

\lem\label{l5}
Suppose that  is a query such that ,  is a set of
closed resources, and  is a set of closed  conditions.  Then

is not acceptably valid (and hence not valid).
\elem
\prf
Let  be an acceptable model that satisfies  iff .  Recall
that, for a grant ,  is a
conjunction of formulas of the form

where  is a closed substitution.  If , then  satisfies 
because, for all substitutions , either ,
in which case  satisfies , or
, in which case
 is equivalent to
.  Since  satisfies every grant,  satisfies
.  By construction,
 does not satisfy , so  does not satisfy
.
\eprf

\lem\label{l3}
Suppose that  is a query,  is a set of closed resources, and  is a set
of closed  conditions.  Then
(a)  for every closed
conclusion  in the language,
(b)  is valid for every grant
 in the language, and
(c)  is valid for every
license  in the language.
\elem
\prf
Part (a) follows immediately from the translation.

For part (b), let .  It is easy to see that
 is valid if, for all closed
substitutions ,
 is valid.
The latter statement holds because the translation of a condition does not depend on the final
input argument (i.e., the set of conditions), so
.

For part (c), let .  If  or
, then , so
 is valid.  If
 and , then
 and
.  It follows that
 is valid if
 is valid.  The latter formula
is valid by part (b).
\eprf

\dfn
For a set  of closed resources, an \emph{-closed} substitution  is a closed substitution
such that, for all variables  of sort , .
\edfn

\lem\label{l7}
Suppose that  is a set of grants,  is a set of licenses,  is a set of closed resources,
 is a set of closed  conditions,  is a set of grants, and  is a closed
conclusion.  Then  is acceptably valid iff
 is acceptably valid for some .  Moreover, for any
grant ,  is acceptably valid iff  and,
for some -closed substitution , the formula  is acceptably
valid and .
\elem
\prf
We first show that  is acceptably valid iff
 is acceptably valid for some .  The ``if'' direction
is trivial.  For the ``only if'' direction, suppose by way of contradiction that
 is acceptably valid and
 is not acceptably valid for all .  Let  be an
acceptable model such that, for all closed conclusions ,  satisfies 
iff .  Since  is acceptably valid,
there is a  such that  does not satisfy
.  By the translation, it follows that there is an -closed substitution 
such that ,  holds in , and
.  Because, for all conditions ,  can be written as
 for an appropriate formula ,  is acceptably valid since
it holds in an acceptable model.  It follows that  is acceptably
valid, which contradicts the assumption.

It remains to show that  is acceptably valid for a grant
 iff  and, for some -closed
substitution , the formula  is acceptably valid and
.  The ``if'' direction is immediate from the translation.  For the ``only if''
direction, suppose by way of contradiction that  is acceptably
valid and either  or, for each -closed substitution , either
 is not valid or .  Let  be the acceptable model
defined above; that is, for all conclusions ,  satisfies  iff
.  We can get a contradiction by showing that  satisfies .  If
, then  satisfies  since either  (because
), or  holds in  (because ).  Otherwise,
by assumption, either  is not acceptably valid or ,
for each -closed substitution .  Note that, because  (like
every formula of the form  for some condition ) is equivalent to a formula
of the form , then if it is not acceptably valid, it is not true in any acceptable
model and, in particular, not in .  It then easily follows from the translation that 
satisfies .  This gives us the desired contradiction.
\eprf

\dfn
Let  be a query, let  be a terminating execution of
, and let .  Then

\edfn

\lem\label{l2}
Suppose that  is a query,  is a terminating execution of
, and .  Then

is acceptably valid iff there is a grant  such that

is acceptably valid.
\elem
\prf
For the ``if'' direction, suppose that  is a grant in  such that
 is
acceptably valid.  If , then

is acceptably valid.  If , then there is a principal  such
that
\begin{itemize}
\item[(1a)] ,
\item[(1b)] , and
\item[(1c)]

is acceptably valid.
\end{itemize}
Let .  It follows from (1a) that
 is acceptably valid.  It follows from (1a), (1b),
and the translation that 
is acceptably valid.  It follows from Lemma~\ref{l3} and (1c) that 
is acceptably valid, so  is acceptably valid.  By
assumption  is
acceptably valid, so  is acceptably valid.

For the ``only if'' direction, suppose that there is no grant  such that
 is acceptably valid.
Let  be an acceptable model that does not satisfy  and the
formulas in .  Because  does
not satisfy , it suffices to show that  satisfies
.  We do this by showing that (1)  satisfies
 for every license  such that
, and (2)  satisfies  for
every grant .

\begin{sloppypar}
For part (1), observe that if  or , then
, so  holds
in .  If  and , then

and, by construction,  does not satisfy ; so
 is again true in .

For part (2), let ,
and recall that  is the conjunction of formulas of the form

where  is an -closed substitution.  Clearly,  satisfies
 iff, for every -closed substitution , 
satisfies .
It is easy to see that the latter statement holds if, for all -closed substitutions ,
either ,  is not true in ,
or  is true in .  We claim that this is indeed
the case.  To prove the claim, suppose by way of contradiction that ,
 is true in , and
 is not true in .
Since  is not true in , either
 or .
\end{sloppypar}

If , then we claim that  is acceptably valid.  To
see this note that 
 is acceptably valid.
Since , the formula
; so,

is acceptably valid.  Since  is true in  by
assumption, and, as we have observed, every formula of the form 
is equivalent to  for some formula , 
is acceptably valid and, as a result,
 is
acceptably valid.  By assumption, , so
 is acceptably valid.
Since  and, by assumption, none of the grants in 
imply , we have a contradiction.

\begin{sloppypar}
Finally, suppose that  and , where ,
, and .  We now prove that
 is acceptably valid,
so , which contradicts the assumptions.  We begin by noting that
 is acceptably valid.  By assumption,
, so  is acceptably valid.  Since ,
, so
 is acceptably valid.  It remains to be shown that
 is
acceptably valid.  Because the translation of a condition does not
depend on the set of conclusions, it suffices to show that
 is acceptably valid.
But, as we observed above, this follows immediately from the assumption
that  is true in . 
\end{sloppypar}
\eprf


\begin{sloppypar}
\thm\label{t:generalizeCorrect1}
Suppose that  is a query,  is a terminating execution of
, and .  Then for all calls of the form
, , or  made during
execution , including the initial call,
\begin{itemize}
\item[(a)]  returns  iff  is acceptably
valid, where  is an (arbitrary) set of closed conclusions;
\item[(b)]  returns the set  of closed conditions, where
  and, for some grant
 and closed substitution
,  and   and
\item[(c)]  returns  iff

is acceptably valid.
\end{itemize}
\ethm
\end{sloppypar}

\prf
We prove part (a) by induction on , with a subinduction
on the structure of .   Suppose that .  If
, then  and .
Suppose that  is of the form .  Then, by Lemma~\ref{l1},
.  By assumption, , so
.  It follows that  and
.  Finally, if  is a conjunction, then the result is
immediate from the induction hypothesis.  For the induction step, the argument used for the base
case applies if  or if  is a conjunction of conditions.  Suppose that  has
the form .  If , then  and
.  If  then, by the description of
,  iff there is a grant
 and an -closed substitution 
such that  and .  By the
induction hypothesis,  iff
 is acceptably valid.  By the translation,
the latter statement holds iff  is
acceptably valid.  So, by Lemma~\ref{l7},  iff
 is acceptably valid.  It is immediate from the
translation that the latter statement holds iff  is acceptably
valid.

We prove parts (b) and (c) by simultaneous induction on .  If
, then  by Lemma~\ref{l1}, so
.  Because , , so part (b) holds.
For part (c),  begins by calling , which returns the empty
set, and then  returns .  Since , it follows from Lemma~\ref{l5}
that

is not acceptably valid, so the invariant holds.

Now consider the inductive step.  For part (b), suppose that  is called
during the execution of .  If , then part (b) holds by
the same argument as in the base case.  If , then  returns a set  of
closed conditions such that  iff there is a grant
 and a closed substitution  such
that  and , where

It clearly suffices to show that .  By Lemma~\ref{l1},
 and, by assumption, .  So it follows from the induction
hypothesis that

which is .

For part (c), observe that if  then we can use the same reasoning as in the base case
to show that the invariant holds.  If  then, during execution ,
 returns  iff there is a closed condition  in the output
of  such that  calls , which
returns .  By part (b),  returns a set of conditions that includes
 iff there is a grant
 and a closed
substitution  such that  and .  Moreover, since
 is called during execution  of ,
 is -closed.  By part (a),  iff
 is acceptably valid.  So
 returns  iff there is a grant
 and an -closed
substitution  such that  is acceptably valid and
.  By assumption, ; so, by Lemma~\ref{l7},
 iff
 is acceptably
valid for some .  It follows from Lemma~\ref{l2} that the latter
statement holds iff

is acceptably valid.
\eprf

\othm{t:undec2}
Determining whether some execution of  returns  is undecidable for
the set of queries  such that at most one grant in  is not restrained.
\eothm
\begin{sloppypar}
\prf
We reduce the Post correspondence problem (PCP) \cite{PCP} to the problem of determining
whether some execution of
 returns  for a query ,
where all but one grant in  is restrained.
Let  be an alphabet; let  and  be strings over ;
and, for all strings  and , let  be the concatenation of  and .  We want to
determine if there are integers  such that
.

To encode the problem as a query, assume that the language includes the primitive principal
 for each symbol , the
primitive principal , and the property .  For every string  over , define
a function  from grants to grants by induction on the length of .  If  has length one
(), then .  If , then
.  For all grants  and , define  to be the grant
.

We claim that there are integers  such that
 iff an execution of
 returns , where

and .

Recall that an execution of  returns  iff
an execution of  returns a set  of conditions such
that an execution of  returns  for some
condition .  It is easy to see that every execution of
 returns the set
.
Moreover, if  is of the form , where
 is a closed grant, then it is not hard to see that an execution of
 returns  iff there are integers
 such that
 and
.  The latter
statements holds iff there are integers  such
that .
\eprf
\end{sloppypar}

\othm{t:NPHardAll}
The problem of deciding
if some execution of 
returns  for  is  NP-hard for
.
\eothm
\prf
For the NP hardness results, it suffices to show that the problem of deciding whether
 is NP-hard if (a)
,
(b) , and
(c) .

For part (a), we show that we can reduce the Hamiltonian path problem to the problem of determining whether
, for some .  Given a graph , where , we take  to be primitive principles.  We also assume that the language has primitive properties {\bf Node}, {\bf Edge}, and {\bf Path}.  For each node , let  be the grant  (recall that this is an abbreviation for ).  For each edge , let  be the grant  (recall that  is an abbreviation for ).
Finally, let  be the grant , where

Let  and let
.  It is not hard to show that 
iff  has a Hamiltonian path. To see this, observe that  returns , where  is some permutation of .  The condition  holds iff there is a path .  Thus,  iff there is a Hamiltonian path in .  Moreover, it is clear that  and it is not hard to see that , because the antecedent of every issued grant is .

For part (b), we show that we can reduce the 3-satisfiability problem to the problem of determining whether
, for .  Let  be a formula in propositional logic, where each  is a clause with three disjuncts.  Let  be the primitive propositions mentioned in .  We want to determine if  is satisfiable.

\begin{sloppypar}
To encode the problem as an XrML query, suppose that  are distinct primitive principals,  is a property, and  are distinct variables of sort .  Let  be a fixed closed grant.  Given principals , we define grants  inductively
as follows:  is the grant  and, for ,  is
the grant .  Let  be the conclusion .  For ease of exposition, let  be the conclusion .  Let
q_jc_i\neg q_jc_i
and let .  We claim that  is satisfiable iff
.  Note that
, since none of the grants mention
a variable of sort , the  operator is not mentioned in the query, and the antecedent of
every issued grant is .

To prove the claim, first note that  iff
 holds for some substitution .  It is not hard to see that if  exists, then  is satisfied by the truth assignment that sets  if  sets  to , and sets  to  otherwise.  Similarly, if  is satisfied by a truth assignment , then  holds for the substitution  that replaces  by  if  assigns  to , and replaces  by  otherwise.
\end{sloppypar}

For part (c), we show that we can reduce the 3-satisfiability problem to
the problem of determining whether ,
for .  As in part (b), let 
be the 3-CNF formula , whose primitive
propositions are .  Define the condition  as in part (b); again, take  to be an abbreviation
for .  Let  be fresh
principals, distinct from .  We claim that
 is satisfied iff , where



If  are variable-free principals, let  be the set of all truth assignments to  such that  is assigned  if  and  is assigned
 if , for .  (If , then there are no constraints on .)
Let  be the set of all truth assignments to
 under which  is .  We
show by induction on  that  is nonempty iff
 holds.  If , then .  It is easy to see that  is
nonempty iff, for some , either  is a disjunct of
 and , or  is a disjunct of  and .  For the inductive step, suppose that .  Clearly,
 is nonempty iff there is an assignment in
 under which  is .  If there is
at least one such assignment, then  is
nonempty, where  are variable-free principals such
that, for some  and for all ,  and either  is a disjunct of , , and , or  is a disjunct of , , and .  It follows from the induction hypothesis that  holds and it follows from
 that  holds as well.  If there is no assignment in
 under which  is  then, for every disjunct  in
,  and, for every disjunct  in , .  It follows that
 and  does not hold.

The desired result now follows quickly.  It is  easy to see that  iff  holds.  Since none of  is  or , by definition,  consists of all truth assignments.  Thus, by the induction argument, it follows that  iff  is satisfiable.  Moreover, it is easy to see that , because
the query does not mention union and, for every variable  mentioned in a grant  that is in
,  is mentioned in the conclusion of .
\eprf

We next prove Theorem~\ref{t:NPHardAll1}, which considers the complexity
of determining whether  returns  for
.
In the statement of the theorem, we viewed  and  as constants.
In our proof, we treat them as parameters, so as to bring out their role.

To prove the theorem we need three preliminary lemmas.  The first uses the fact that, for every
condition , there is a dag (directed acyclic graph)  such that  represents
 and  is no larger than .  To make this precise, recall that  is the
length of string  when viewed as a string of symbols.  For ease of exposition, we assume that
each pair of parenthesis and set braces has length 2, and each comma has length 1.  For a graph
, let .  It is easy to see that a condition  can be
represented as a tree , where .  For example, we can represent the
condition  as the tree  shown in
Figure~\ref{tree}.
\begin{figure*}[tb]
\begin{center}
\rotatebox{270}{\includegraphics[width=2.5in, height=4.5in]{tree}}
\end{center}
\caption{A tree representing }
\label{tree}
\end{figure*}
Note that  and, because the tree has  nodes and  edges, .
By ``merging'' identical subtrees, we can create a dag representation of  that can be
substantially smaller than .  Continuing our example, the dag 
in
Figure~\ref{dag} represents the condition
 and .
\begin{figure*}[tb]
\begin{center}
\rotatebox{270}{\includegraphics[width=2.5in, height=4.5in]{dag}}
\end{center}
\caption{A dag representing }
\label{dag}
\end{figure*}

\lem\label{l:boundD}
Suppose that  is the call tree for an execution of ;
every license in  is restrained; the  operator is not mentioned in 
or in a grant in ; and  is a node in  with label .
If  is a dag representing , then there exists a dag 
representing  such that , where
 is the height of .
\elem
\prf
Because  is a node in , there is a path  in  such that
 is the root of  and .  We prove by induction on  that there
is a dag  representing  such that
.  Since  by assumption, it
easily follows that .

If , then  is the root of , so .  If , then  is the
child of a node .  Let  be the label of .
The proof is by cases on the structure of .  It follows from the description
of  that  is not  because  is not a leaf in .  If
 is a conjunction, then  is a conjunct of .  So the space needed
to represent  is less than the space needed to represent , thus the
result follows easily from the induction hypothesis.  Finally, if  has the
form , then it follows from the description of  that there
is a license , where ,
and a closed substitution  such that  and .  A dag representing  (i.e., ) can be obtained by taking a
dag representing  and replacing every variable  by a dag representing
.  Because every grant in  is restrained,  is restrained, so
 assigns every variable of sort  mentioned in  to a term in
.  Since  is a subterm of  or a primitive principal, given
a dag  representing  and a dag  representing , we
can construct a dag  representing  such that
.  Since, for every condition
, there is a tree representation of  whose size is at most ,
there is a dag  representing  such that
.  Because  is the antecedent of a grant in
,  so it follows that .  Because 
is a subterm of , and by the induction hypothesis, there is a dag
 representing  such that ,
there is surely a dag  representing  such that
.  Putting this all together, it follows
that there is a dag  representing  such that
.
\eprf

\begin{sloppypar}
\lem\label{complexityestimate}
If  is -bounded, the  operator is not mentioned in  or
in a grant in ,  is both restrained and -restricted, and  is a dag representing ,
then the output of  can be determined in time

\elem
\prf
Let  be the call tree for an execution of .
Our goal is to compute the truth value associated with the root of , since
that truth value is the output of .

It is clear that once we have written the call tree, computing the truth value
of the root can be done in time linear in the number of nodes in the tree.  The
obvious way to construct the tree is to start at the root and, for each node ,
construct the successors of  (if there are any).  In constructing the call
tree, we assume that the condition  and the elements of the set  in a
node labeled  are described using the dags of
Lemma~\ref{l:boundD}.  Consider a node  in  that is labeled
 and is neither the root nor a leaf.  Since  is not a
leaf, .  If  is a conjunction, then a bound on the number
of conjuncts (and hence on the successors of the node) is  since 
is of the form , where  is the antecedent of a grant  that
is in , and  is a closed substitution.  It is easy to see that ,
and hence , has at most  conjuncts, and these can be
computed in time .

Suppose that  is of the form .  If , then  is a leaf.
Since the height of  is at most ,  has at most  elements.  It follows from
Lemma~\ref{l:boundD} that each of these elements can be represented using a dag of size
at most , so checking whether  can be
done in time .  If , then each child of
 has the form , where 
is a grant in  and  is a closed substitution such that .
Since every grant in  is restrained and -restricted,  mentions at most 
variables that are not mentioned in  and each of these variables is of sort
.  Since  and the grants in  do not mention the  operator and
, there are at most  substitutions for each variable
and thus  possible substitutions .  Finding  for all of
the variables  that are mentioned in  takes time linear in the size of the dag
representing  (since ).  Clearly the dag representing  has
size less than that representing . By Lemma~\ref{l:boundD}, the
latter dag has size at most .  Since ,
there are at most  children of  and computing what they are takes
time .

Similarly, the root of  has at most  children since the root
has zero children if , less than  children if  is a conjunction, and at most
 children if  is a  condition.  The children of the root can be computed
in time  if  is a conjunction and in time  if
 is a  condition.  This follows from the reasoning given for the case when the node is neither
the root nor a leaf modified to account for the fact that , since , and there
is a dag representation of  that has length .

To determine the number of non-leaf nodes of , observe that, if the root of  has  children and
each subtree of  has at most  non-leaf nodes, then  has at most  non-leaf nodes.  It
follows that  has at most  non-leaf
nodes, since a tree with outdegree at most  and height  has  non-leaf
nodes.  Thus, it takes time

to compute the children of the 
non-leaf nodes other than the root.  Since this time dominates the time to compute the children of the
root, it is also the time required to compute .

Once  is constructed, the truth value of its root can be computed in time linear in the number of
nodes of .  Thus,  can be computed in time

\eprf
\end{sloppypar}

\begin{sloppypar}
\lem\label{l:ComputeAuth2}
Suppose that  is a query in  such that
 and  is the output of .  Then
\begin{itemize}
\item[(a)]  is at most ;
\item[(b)] if  is a closed condition in , then there is a dag  representing
 such that ; and
\item[(c)]  can be computed in time

\end{itemize}
\elem
\prf
Let  be an execution of  and let .

For part (a), by Theorem~\ref{t:generalizeCorrect1}(b), if , then

Since every grant in  is either in  or , .  Moreover,
because , for every grant
, there are at most  variables
mentioned in  that are not mentioned in , and each of these variables is of sort
.  As in the proof of Lemma~\ref{complexityestimate}, it follows that there are at most
 substitutions of variables in  to closed terms such that 
because .  Part (a) follows immediately.

For part (b), let  be a closed condition in .  By (1), , where
 is the antecedent of a grant  and  is a closed substitution.  By the
proof of part (a),  assigns every variable in  to a term in  or to a
principal in .  Given dags  and  representing  and ,
respectively, we can obtain a dag  representing  by replacing every variable in
 by either a subgraph of  or by some .  So there is a dag
 representing  such that .
Recall that, for every string , there is a dag  representing  such that
.  So there is a dag  representing  such that
.  Since  is the antecedent of a grant in 
and every grant in  is a grant in  or , , and we are
done.

For part (c), by (\ref{eq1-xrml}), we can compute  by (i) checking whether ;
(ii) computing ; and (iii) for each grant
, computing
.  (Observe that these are the same steps taken in ; however, our
approach computes  more efficiently.)  Step (i) takes time .  We show below
that  can be completed in time

For step (iii), essentially the same arguments as those used in Lemma~\ref{complexityestimate}
show that, given grant ,  can be computed in time
.  So,  can be computed in time
.  Since , the total time needed to
compute  is


For step (ii), let .  For all integers , define the set 
of grants inductively as follows:  and, for ,
p.  We claim that .

To show that , we prove by induction that  for all .
The base case is immediate because .  For the inductive step, it suffices to show that, if
there is a license  and a subset  such that

is acceptably valid, then .  Let
.
Because , it is immediate from the definition of  that  if
 is acceptably valid.  Because , every grant
 is either in  or there is a principal  such that  and
 is acceptably valid.  It follows that
 is acceptably valid.
Since

is acceptably valid,  is acceptably valid.

To show that , we first observe that, for all , 
and, if , then  for all .  Since  and
p, it follows that
.  To show that , it suffices to show that
for all licenses  such that  is acceptably valid,
.  Suppose by way of contradiction that there is a license  such that
 is acceptably valid and .  Let
.  Since
, the grant  so, by the definition of
, the formula  is not acceptably valid.  It
follows that there is an acceptable model  that satisfies 
and is ``most forbidding'' in the sense that, for all principals  and grants , either  does
not satisfy  or the model  that does not satisfy
 and is otherwise identical to  does not satisfy .  Since  satisfies  and  is acceptably valid,
 does not satisfy .  Because  and  satisfies , 
satisfies .  So, there is a
license  such that  does not satisfy
.  If
, then
,
so  satisfies .  Thus,
.  But then
.
Since  does not satisfy this formula,  satisfies .  By the
construction of , the model  that does not satisfy  and is
otherwise identical to  does not satisfy .  So there is a grant
 such that 
does not satisfy .  Because  satisfies
 and the two models  and  differ
only in their interpretation of , it follows from the translation
of  that there is a substitution  such that
, , and
 is valid.  So
 is
acceptably valid. Since ,  is
acceptably valid, .  Because , the grant
 and, since  satisfies ,  satisfies
.  So  satisfies
, which contradicts the assumptions.

We next consider the complexity of computing .  Let
.  Clearly, we can
compute  in time  for some constant .  For all
, let  and let .
We plan to compute  inductively,  It will be useful in the induction to represent the
elements of  in a \emph{splay tree}.  (Recall that a splay tree is a form of binary search
tree such that  insertions and searches can be done in a tree with at most  nodes in time
 \cite{ST}.)  If  is represented as a splay tree, then we can compute 
in time  (since ).

For ,

By Lemma~\ref{l7},

Moreover, it follows from Lemma~\ref{l7} that, for ,
  is acceptably
valid iff the formula  is valid for some -closed substitution  such that
, where
.  Given  with
 and , we can clearly check in time  if
there exists an -closed substitution  such that ,
where  is a constant independent of .  If so, as in part (a), there are at most
 distinct formulas of the form  (since there are at most 
possible substitutions for the free variables in ).  It follows from
Theorem~\ref{t:generalizeCorrect1}(a) that
 is valid iff
.  We show shortly that there is an execution of
 that calls , so
 is -bounded.  It follows from
Lemma~\ref{complexityestimate} that we can determine if
 in time

where  is a constant independent of  and  is a dag representing
.  As in the proof of part (b), we can obtain  from a dag
 representing  by replacing every variable with a principal in  or a
resource mentioned in .  So there is a dag 
representing  such that .
Repeating this process for each of the at most  formulas , it follows
that we can check if
  is acceptably
valid in time


Assuming we have already computed  and , we can repeat the process above for all
 and .  It is not hard to show that we can compute  in time

for some constant .  We can then build the splay tree for  by inserting the grants
in  into the splay tree for ; this can be done in time
.

Since , the total time to compute 
(ignoring the time to compute the sets  and , and to build the splay trees for ) is
at most

for some constant ; i.e., it is .

Now taking into account the complexity of computing  and  and to build the splay trees, and
using the observation that , we get that the complexity for
computing  is


It remains to show that if ,
 with , and  and -closed
substitution , then there is an execution  of  that calls
.  Because  by assumption,
 calls , which calls
, which calls
.  Since ,
.  It follows that
 computes
 and, if
, then
 returns a set  that includes
.  After  returns , it
is easy to see that some execution of 
calls .  So, in short, it suffices to show that
.  The proof is by induction on .
If , then .  If
 then, by the induction hypothesis,
, so

is acceptably valid.  Since , there is a grant  and a principal
 such that  and  is acceptably valid.  Because  and , 
and, thus, it follows from the translation that
 is acceptably valid.  Putting the pieces together, there is a principal
 such that  and

is acceptably valid, so .
\eprf
\end{sloppypar}

We are now ready to prove Theorem~\ref{t:NPHardAll1}.
\othm{t:NPHardAll1}
For fixed  and , if ,
then determining whether  returns  takes time
.
\eothm
\begin{sloppypar}
\prf
Let  be the output of .  It is immediate from the description of
 that  iff there is some condition 
such that .  So the output of 
can be determined in time , where  is the time needed to compute  and
 is the time needed to determine the output of  for a condition
.  By Lemma~\ref{l:ComputeAuth2}(c),
 for a condition .  By Lemma~\ref{l:ComputeAuth2}(c),

for some constant .  If  and  are treated as constants, then
 for some constant ;
i.e.,  is .

By Lemma~\ref{l:ComputeAuth2}(a), .
By Lemma~\ref{complexityestimate},  is at most
, for some constant .  If  and  are treated as constants, then there is a
constant  such that  is at most

Since, by Lemma~\ref{l:ComputeAuth2}(b), , it follows that
,
i.e., .

Since , a
straightforward computation shows that , the time needed to determine whether
 returns , is
.
\eprf
\end{sloppypar}

\othm{t:ext1}
Let  be a tuple in  extended to
include negated  conditions and negated conclusions.  The problem of deciding whether

is valid is NP-hard.  This result holds even if , all of the licenses in , and all
of the conclusions in  are in XrML, all but one of the grants in  is in XrML, and
the one grant that is in in XrML -- XrML is of the form
.
\eothm
\prf
The proof is by reduction of the 3-satisfiability problem.  The reduction is identical to the
reduction given in the proof for the case of  in
Theorem~\ref{t:NPHardAll}, except that
.
To show that  iff  is valid, we observe that
 iff  and  imply , which occurs iff
 holds for some substitution .  The rest of
the argument proceeds as in the proof of Theorem~\ref{t:NPHardAll}.
\eprf

\bibliographystyle{acmtrans}
\bibliography{vickyw}


\end{document}
