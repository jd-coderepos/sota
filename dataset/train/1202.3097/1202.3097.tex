\documentclass{llncs}

\newcommand{\longversion}[1]{#1}
\newcommand{\shortversion}[1]{}
\newcommand{\longshort}[2]{\longversion{#1}\shortversion{#2}}

\usepackage{amsmath,amssymb}
\usepackage{times}
\usepackage{algorithm}
\usepackage{algpseudocode}


\longversion{\usepackage[totalwidth=420pt,totalheight=625pt]{geometry}}
\longversion{
\setlength{\oddsidemargin}{5mm}
\setlength{\evensidemargin}{5mm}
}

\usepackage{tikz}
\usetikzlibrary{shapes}

\usepackage{thmtools,thm-restate}

\tikzstyle{literal}=[circle, thin, draw, minimum height=0.3cm]
\tikzstyle{clause}=[rectangle, thin, draw, minimum width=0.3cm, minimum
height=0.3cm]

\newcommand{\RP}{\textsc{Resolution\hy Path Dependency Tuple}\xspace}
\newcommand{\PEC}{\textsc{Properly 2\hy Edge\hy Colored Walk}\xspace}

\newcommand{\AAA}{\mathcal{A}} \newcommand{\BBB}{\mathcal{B}}
\newcommand{\CCC}{\mathcal{C}} \newcommand{\DDD}{\mathcal{D}}
\newcommand{\LLL}{\mathcal{L}} \newcommand{\FFF}{\mathcal{F}}
\newcommand{\GGG}{\mathcal{G}} \newcommand{\HHH}{\mathcal{H}}
\newcommand{\MMM}{\mathcal{M}} \newcommand{\PPP}{\mathcal{P}}
\newcommand{\QQQ}{\mathcal{Q}} \newcommand{\RRR}{\mathcal{R}}
\newcommand{\SSS}{\mathcal{S}} \newcommand{\TTT}{\mathcal{T}}
\newcommand{\VVV}{\mathcal{V}} \newcommand{\bigoh}{\mathcal{O}}

\newcommand{\Dtrv}{D^{\text{\normalfont trv}}}
\newcommand{\Dst}{D^{\text{\normalfont std}}}
\newcommand{\Dres}{D^{\text{\normalfont res}}}
\newcommand{\Dmat}{D^{\text{\normalfont mat}}}
\newcommand{\Dtri}{D^{\text{\tiny }}}
\newcommand{\Dtris}{D^{\text{\tiny }}}

\newcommand{\mtext}[1]{\text{\normalfont #1}} \newcommand{\var}{\mathit{var}}
\newcommand{\args}{\mathit{args}} \newcommand{\lit}{\mathit{lit}}

\def\hy{\hbox{-}\nobreak\hskip0pt} \newcommand{\ellipsis}{}
\newcommand{\SB}{\{\,} \newcommand{\SM}{\;{:}\;} \newcommand{\SE}{\,\}}
\newcommand{\SBb}{\big\{\,} \newcommand{\SEb}{\,\big\}}

\newcommand{\seq}[1]{\langle #1 \rangle} \newcommand{\QB}{\langle\,}
\newcommand{\QM}{\;{:}\;} \newcommand{\QE}{\,\rangle}

\newcommand{\Card}[1]{|#1|}
\newcommand{\pbDef}[3]{\begin{quote}
    #1
    
    \emph{Input:}  #2
    
    \emph{Question:}  #3
 \end{quote}}

\pagestyle{plain}

\let\doendproof\endproof
\renewcommand\endproof{~\hfill\qed\doendproof}

\let\doendexample\endexample
\renewcommand\endexample{~\hfill\qed\doendexample}

\nonfrenchspacing





\begin{document}

\title{Computing Resolution\hy Path Dependencies\\ in Linear Time\thanks{Research supported by the European Research Council (ERC),
    project COMPLEX REASON 239962, and WWTF grant WWTF016.} \thanks{Dedicated to the memory of Marko Samer.}}

\author{Friedrich Slivovsky \and Stefan Szeider}

\institute{
 Institute of Information Systems,
 Vienna University of Technology,
 A-1040 Vienna, Austria
\email{friedrich.slivovsky@tuwien.ac.at,stefan@szeider.net}
}

\maketitle

\begin{abstract}The alternation of existential and universal quantifiers in
  a quantified boolean formula (QBF) generates dependencies among variables
  that must be respected when evaluating the formula. Dependency schemes
  provide a general framework for representing such dependencies. Since it is
  generally intractable to determine dependencies exactly, a set of potential
  dependencies is computed instead, which may include false positives. Among
  the schemes proposed so far, resolution path dependencies introduce the
  fewest spurious dependencies. In this work, we describe an algorithm that
  detects resolution-path dependencies in linear time, resolving a problem
  posed by Van Gelder (CP 2011).
\end{abstract}

\section{Introduction}
Deciding the satisfiability of quantified boolean formulas (QBF) is a
canonical PSPACE-complete problem \cite{StockmeyerMeyer73}. Under standard
complexity theoretic assumptions, that means it is much harder than testing
satisfiability of propositional formulas. The source of this discrepancy can
be found in variable dependencies introduced by the alternation of universal
and existential quantifiers in a QBF. The kind of dependencies we consider can
be illustrated with the following example:
 
While  is satisfiable, there is no single satisfying assignment to
. Instead, the value of  that satisfies~ \textit{depends} on the
value of .

For formulas in prenex normal form, it is safe to assume that a variable
depends on all variables to its left in the quantifier prefix, but this
assumption may result in a large number of spurious dependencies. More
accurate representations of the dependency structure in a formula can be
exploited for various purposes, and variable dependencies have been studied in
a series of works, including
\cite{AyariBasin02,Biere04,BubeckKleinebuning07,EglyTompitsWoltran02,LonsingBiere2009,LonsingBiere2010,Samer08,SamerSzeider09a,VanGelder11}.

Unfortunately, the problem of computing variable dependencies exactly is
PSPACE-complete \cite{SamerSzeider09a}. In practice one therefore computes an
over\hy approximation of dependencies that may contain false positives. This
leads to a trade-off between tractability and generality.
\begin{sloppypar}
  In a recent paper, Van Gelder \cite{VanGelder11} introduced
  \emph{resolution\hy path dependencies} and argued that they generate fewer
  spurious dependencies than all previously considered notions of variable
  dependency (see Figure~\ref{fig:lattice}).
\end{sloppypar}
\shortversion{\begin{figure}[b]}
\longversion{\begin{figure}}
\begin{center}
\begin{tikzpicture}[>=latex,auto,scale=0.7]
\node[anchor=west] (RP) at (-7,1) {Resolution Path};
\node[anchor=west] (QD) at (-3,1) {Quadrangle};
\node[anchor=west] (TRI) at (0,1) {Triangle};
\node[anchor=west] (STSTD) at (0,0) {Strict Standard};
\node[anchor=west] (STD) at (4,0) {Standard};
\node[anchor=west] (TRIV) at (7,0) {Trivial};
\path[thin,->] (RP) edge (QD.west);
\path[thin,->] (QD) edge (TRI.west);
\path[thin,->] (QD) edge (STSTD.west);
\path[thin,->] (TRI.east) edge (STD);
\path[thin,->] (STSTD) edge (STD.west);
\path[thin,->] (STD) edge (TRIV.west);
\end{tikzpicture}
\end{center}
\caption{Various notions of variable dependency ordered by generality
  \cite{VanGelder11}.  An arrow from A to B should be read as ``A is strictly
  more general than B.''  \emph{Trivial dependencies} include all pairs of
  variables not contained in the same quantifier block as dependent and serve
  as a baseline. \emph{Standard dependencies} \cite{SamerSzeider09a} identify
  dependencies based on a notion of local connectivity of clauses, extending
  ideas introduced in work on universal expansion
  \cite{Biere04,BubeckKleinebuning07}. \emph{Triangle dependencies} generalize
  standard dependencies without increasing the worst-case asymptotic runtime
  \cite{SamerSzeider09a}. \emph{Quadrangle dependencies} in turn refine
  triangle dependencies, and \emph{strict standard dependencies} refine
  standard dependencies \cite{VanGelder11}. \emph{Resolution path
    dependencies} are based on a sophisticated notion of connectivity motivated
  by properties of Q\hy resolution \cite{VanGelder11}.}
\label{fig:lattice}
\end{figure}
Van Gelder stated as an open problem whether resolution\hy path dependencies
can be computed in polynomial time \cite{VanGelder11}. In this work, we solve
this problem by describing a linear\hy time algorithm that identifies
resolution\hy path dependencies.  We obtain this result by a reduction to the
problem of finding properly colored walks in edge\hy colored graphs, which is
in turn solved using a variant of breadth\hy first search.  We thus show that
the most general dependency relation among those considered so far is
tractable. 

\emph{Dependency schemes} are a generic framework for representing variable
dependencies \cite{SamerSzeider09a} that are useful in various settings. In
particular, they have recently been built into state\hy of\hy the\hy art QBF
solvers, with beneficial effects \cite{LonsingBiere2009,LonsingBiere2010}. We
prove that resolution\hy path dependencies give rise to a dependency scheme,
thereby providing a basis for their use across a variety of applications.

\shortversion{The proofs of statements marked with  have been omitted
  due to space constraints. They can be found in the full version of this
  paper, which is available on arXiv:1202.3097.}
\section{Preliminaries}
\subsection{Quantified Boolean Formulas}
In this section, we cover basic definitions and notation used
throughout the paper. For an in\hy depth treatment of theoretical and
practical aspects of QBFs, we refer the reader to
\cite{KleineBuningBubeck09} and \cite{GiunchigliaMarinNarizzano09},
respectively.

We consider quantified boolean formulas in \emph{quantified
  conjunctive normal form} (QCNF). A QCNF formula consists of a
(quantifier) \emph{prefix} and a CNF formula, called the
\emph{matrix}. A CNF formula is a finite conjunction of
\emph{clauses}, where each clause is a finite disjunction of
\emph{literals}. We identify a CNF formula with the set of its
clauses, and a clause with the set of its literals. Literals are
negated or unnegated propositional \emph{variables}. If  is a
variable, we put  and ,
and let . If  is a set of literals, we
write  for the set . For a clause , we let  be the set of variables
occuring (negated or unnegated) in .  For a QCNF formula 
with matrix , we put , and . We call a clause \emph{tautological} if it
contains the same variable negated as well as unnegated. Unless
otherwise stated, we assume that the matrix of a formula does not
contain tautological clauses (tautological clauses can be deleted
without changing satisfiability of a formula). The prefix of a QCNF
formula  is a sequence  of
\emph{quantifications} , where  are
pairwise distinct variables in  and  for . We define the
\emph{depth} of variable  as , and let
. A QCNF formula  is obtained
from  by \textit{quantifier reordering} if there is a
permutation  of  such that , where 
denotes the matrix of .
\longversion{\begin{sloppypar}}
The sets of \emph{existential} and \emph{universal} variables occurring
in  are given by  and , respectively. We call a
literal  existential (universal) if  is existential
(universal). We assume that every variable in  appears in
the prefix of , and -- conversely -- that every variable
quantified in the prefix appears in . The \emph{size} of a QCNF
formula  with matrix  is defined as .

For a set  of variables, a \emph{truth assignment} is a mapping . We extend  to literals by setting , for . Let  be a truth
assignment and  a CNF formula. By  we denote the formula obtained
from  by removing all clauses containing a literal  such that
, and removing from every clause all literals  for which
; moreover, if  is a QCNF formula, we write 
for the formula obtained from  by replacing its matrix  with
 and deleting all superfluous quantifications in its prefix.


The evaluation function  on QCNF formulas is recursively defined
by , , , and
, where  denotes the
assignment  such that . A QCNF formula  is \emph{satisfiable} if
 and \emph{unsatisfiable} if . Two
formulas  and  are \emph{equivalent} if .
\longversion{\end{sloppypar}}
We call a clause \emph{ternary} if it contains at most three literals. A QCNF
formula is ternary if all of the clauses in its matrix are ternary. We denote
the class of ternary QCNF formulas by Q3CNF.

\subsection{Q\hy Resolution}
Q\hy resolution \cite{KleinebuningKarpinskiFlogel95} is an extension of
propositional resolution. Let  be QCNF formula with matrix~. A
\emph{tree-like Q\hy resolution derivation} of clause  from  is a
pair  of a rooted binary tree  and a labeling 
satisfying the following properties. The labeling  assigns to each
node a clause, and to each edge a variable. The leaves of  are labeled with
clauses of , and the root of  is labeled with . Whenever a node 
has two children  and , then there is an existential literal 
such that , , and
. Moreover,  and  is non-tautological. We call
 the \emph{(Q-)resolvent} of  and , and
say that  is obtained by \emph{resolution} of  and
 on variable . If a node  has a single child
, then  and  for some \emph{tailing} universal literal  in
. A universal literal  is tailing in  if for
all existential variables , we have . The clause  is the result of
\emph{universal reduction} of  on variable . We call
an instance of resolution or universal reduction in  a \emph{derivation
  step} in . We say  is \emph{strict} if for every path  from the root of  to one of its leaves we have
,
for all .  We call  \emph{regular} if every
existential variable appears at most once as an edge-label on a path from the
root of  to one of its leaves. For a tree\hy like Q\hy resolution
derivation , we define the set of \emph{resolved variables
  of}  as 
there is an edge  such that . We define the
\emph{height} of a tree\hy like Q\hy resolution derivation 
as the height of . A tree\hy like Q\hy resolution derivation of the empty
clause from  is called a \emph{Q\hy resolution refutation} of .
\begin{theorem}\label{ThmStrictQres}A QCNF formula  is unsatisfiable if and only if it has a
  strict, tree-like Q\hy resolution refutation.
\end{theorem}
\begin{proof}
  Completeness of ``ordinary'' Q-resolution is proved in
  \cite{KleinebuningKarpinskiFlogel95}. It is straightforward to turn the
  derivations used in this proof into strict, tree\hy like derivations.
\end{proof}

\section{Dependency Schemes}
For a binary relation~ over some set~ we write  to denote the
reflexive and transitive \emph{closure} of~, i.e., the smallest
set~ such that~. Moreover, we let  for~, and
 for . For a QCNF formula
, we define the binary relation  over~ as . That is to say,  assigns to each variable~ the variables on
the right of~ in the prefix.

\begin{definition}[Shifting]
  Let~ be a QCNF formula and . We say the QCNF
  formula~ is obtained from~ by~\emph{down-shifting}~, in
  symbols , if ~is obtained from~
  by quantifier reordering such that the following conditions hold:
  \begin{enumerate}
  \item  for some .
  \item  if and
    only if  for
    all~.
  \item  if and only if
     for all~.
  \end{enumerate}
\end{definition}
For example, let , and . Then . Note that the
result of shifting is unique. In general, shifting does not yield an
equivalent formula.
\begin{definition}[Dependency scheme]
  A \emph{dependency scheme}~ assigns to each QCNF formula~ a binary
  relation~ such that 
  and~ are equivalent for all .  A dependency scheme~ is \emph{tractable} if  can
  be computed in time that is polynomial in~.
\end{definition}
Intuitively, for a QCNF formula , variable ,
and dependency scheme~, the set  consists of variables
that \emph{may} depend on . More specifically, if we want to
simplify  by moving the variable  to the rightmost position
in the prefix, we can use a dependency scheme to identify a set  so
that down-shifting of  preserves
satisfiability. Typically, we are interested in dependency schemes
that allow us to identify sound shifts for entire sets of variables.
\begin{definition}[Cumulative]
  \label{defn:cumul}
  A dependency scheme~ is \emph{cumulative} if for every QCNF
  formula~ and set~,
   and~
  are equivalent.
\end{definition}
Cumulative dependency schemes play a crucial role in the context of
backdoor sets \cite{SamerSzeider09a}, and have been integrated in
search\hy based QBF solvers \cite{LonsingBiere2010}.

It is easy to verify that we can transpose adjacent quantifications
 in the prefix of a QCNF  as long as  for some dependency scheme~. In other words, every
dependency scheme satisfies the property defined below.
\begin{definition}[Sound for transpositions]
  \label{def:transsnd} Let  be a function that assigns to each QCNF formula
   a binary relation . We say  is
  \emph{sound for transpositions} if any two QCNF formulas \hskip 0pt\hskip 0pt and
  \hskip 0pt\hskip 0pt\hskip 0pt are equivalent given
  that .
\end{definition}
Further restrictions are required when going beyond individual transpositions:
let , where  is the CNF encoding
of , and let  be a mapping such that
 and  for .  is satisfiable and remains satisfiable after transposing  and
 (or  and ) in the prefix. However, the formula  is unsatisfiable. So  is
sound for transpositions but not a dependency scheme.
\begin{definition}[Continuous]
  \label{def:cont} Let  be a function that maps each QCNF formula  to
  a binary relation . We say  is
  \emph{continuous} if the following holds for every pair \hskip 0pt\hskip 0pt and \hskip 0pt\hskip 0pt\hskip 0pt of QCNF formulas:
   for , and  as well as
  .
\end{definition}
\begin{restatable}{lemma}{LemTransSnd} \label{lem:transsnd}\shortversion{\textup{()}}
  Let  be a function that maps each QCNF formula  to a binary
  relation . If  is sound for transpositions
  and continuous, then  is a cumulative dependency scheme.
\end{restatable}
\longversion{\shortversion{\begin{sloppypar}}
\begin{proof} Choose an arbitrary QCNF formula . Any shift
   can be represented as a series of
  transpositions of adjacent quantifications 
  where  and , because the order
  of elements within the sets  and  remains unchanged. In other words, there is a sequence
   with  and , such that for , the formula  is obtained from  by transposing
  adjacent quantifications  and 
  in the prefix of , where , , and . We
  prove for all  that  contains no pair
   such that . By induction on . Because of
   and , we must have  for . For the
  induction step, suppose  for all , where . Since  is continuous, all
  pairs in  must be of the form  for some . No such pair can be identical to any
  pair , because , while , where . We conclude that .  The lemma now follows from the fact that  is sound for
  transpositions and  for all .
\end{proof}
\shortversion{\end{sloppypar}}
 }
\begin{restatable}{lemma}{LemSubCum} \label{lem:subcum}\shortversion{\textup{()}}
  Let  be a function that maps each QCNF formula  to a binary
  relation , and let  be a cumulative
  dependency scheme. If  for all formulas
  , then  is a cumulative dependency scheme as well.
\end{restatable}
\longversion{ \longversion{\begin{sloppypar}}
\begin{proof}
  Choose an arbitrary QCNF formula , and let . From  it follows that
  . Since  is a cumulative
  dependency scheme, the formulas  and  are
  equivalent.
\end{proof}
\longversion{\end{sloppypar}}
 }
\section{Resolution\hy Path Dependencies}
In this section, we will define the resolution path dependency \emph{scheme},
which corresponds to the resolution\hy path dependency relation proposed by
Van Gelder \cite{VanGelder11}. We justify this change of name by proving that
the resolution path dependency scheme is indeed a cumulative dependency
scheme.

Van Gelder \cite{VanGelder11} gives two definitions for resolution paths
(Definitions 4.1 and 5.2), the former being more restrictive than the
latter. The former definition is problematic as we will explain in Example
\ref{ex:nontaut} below. Hence we will base our considerations on the latter
definition, which defines resolution paths as certain walks in a graph
associated with a QBF formula. However, to avoid clashes with graph\hy
theoretic terminology introduced below, we simply define resolution paths as
particular sequences of clauses and literals.

\begin{definition}[Resolution Path] \label{def:rconnected} Let  be a
  QCNF formula with clause set  and . An
  \emph{\hy resolution path} in  is a sequence of clauses and
  literals \hskip
  0pt, satisfying the following properties:
  \begin{enumerate}
  \item  and  for .
  \item  for .
  \item  and , for .
  \item  for , and
    .
\end{enumerate}
If  is an \hy resolution path in , we say
that  and  are \emph{resolution connected in  with
  respect to }.
\end{definition}

\begin{example}\label{ex:running} \longversion{Consider the following QCNF formula:
} 
\shortversion{Let , where  \hskip 0pt  \hskip 0pt , and .}

The sequence  is a \hy resolution
path in , and so the literals  and  are resolution connected
with respect to . By contrast, the sequence  is not a resolution path in , because  is
followed by a clause instead of the complementary literal .
\end{example}
\emph{Resolution path dependencies} are induced by a pair of resolution paths
that connect the same two variables in reverse polarities:
\begin{definition}[Dependency pair] Let  be a QCNF formula and
  . We say  is a \textit{resolution\hy
    path dependency pair} in  with respect to  if at least one of the following conditions
  holds:
  \begin{itemize}
  \item  and , as well as  and , are resolution connected in
     with respect to .
  \item  and , as well as  and , are resolution connected in
     with respect to .
  \end{itemize}
\end{definition}

\begin{definition}[Resolution\hy path dependency scheme]
  \label{def:resdep} The \textit{resolution\hy path dependency scheme} is a
  mapping  that assigns to each QCNF formula  the relation
   and
   is a resolution\hy path dependency pair in  with respect to
  .
\end{definition}
In the formula  of Example 1 above,  is resolution\hy path
dependency pair with respect to , and  is a
resolution\hy path dependency pair with respect to . But while
, we have , because
 is not resolution connected in  to either of  or  with respect to .

The next lemma will be needed in the proof of Theorem \ref{thm:resdep1} below.
\begin{restatable}[\cite{VanGelder11}]{lemma}{LemClauseToPath}\label{lem:ClauseToPath}\shortversion{\textup{()}}
  Let  be QCNF formula,  where , and  a regular, tree-like Q-resolution derivation
  of a clause  such that . Then  and  are
  resolution connected in  with respect to .
\end{restatable}
\longversion{\begin{proof} By induction on the height  of . For ,  must
  already be contained in , and  is an \hy
  resolution path in . Now assume the lemma holds for all . Let  denote the root of . We have to consider two
  cases. (1) If  has a single child , then  is the
  result of universal reduction of , and  must already
  contain  and . Let , where  is the
  subtree of  rooted at . Evidently,  is a regular, tree\hy like
  Q\hy resolution derivation of  whose height is strictly smaller
  than that of , so we can apply the induction hypothesis and conclude
  that  and  are resolution connected in  with respect to
  .  (2) Suppose  has
  two child nodes  and . Then  is the resolvent of
   and  on some variable . Let  and  denote the subtrees of  rooted at 
  and , respectively, and set , . If  or , we can apply the same reasoning as in case (1). So assume,
  without loss of generality, that  and . Since  and  are regular and tree-like and
  have height at most , we can conclude from the induction hypothesis
  that  and  must be resolution connected in  with respect to
  , and that  and  must be resolution
  connected in  with respect to . That means
  there must be a \hy resolution path , as well as a
  \hy resolution path  in . We claim that the
  sequence \hskip 0pt is a \hy
  resolution path between  and : it is easy to check that
  properties 1-3 of Definition \ref{def:rconnected} are satisfied by 
  because they are satisfied by  and  individually. Since  is
  regular, we must have , and so  has property
  4 as well. It follows that  and  are resolution connected in
   with respect to .
\end{proof}
 } The following result corresponds to
Theorem 4.7 in \cite{VanGelder11}.  \longversion{We were unable to follow the
  proof presented there without assuming that Q\hy resolution derivations are
  strict, so we include our own version below.}
\begin{restatable}[\cite{VanGelder11}]{theorem}{ThmResDep}\label{thm:resdep1}\shortversion{\textup{()}}
  Let  be a QCNF formula where  is followed by  in
  the quantifier prefix, so that . Suppose . Let  be the result of
  transposing  and  in the quantifier prefix. Then
   and  are equivalent.
\end{restatable}
\longversion{\begin{proof} 
  \shortversion{\begin{sloppypar}} It is sufficient to show that for all truth
    assignments  with domain , the formula  has a Q\hy resolution
    refutation if and only if  has a Q\hy resolution
    refutation. Note that  implies  because every resolution path in  is a
    resolution path in .  
  \shortversion{\end{sloppypar}} Suppose
   is unsatisfiable, and let  be a strict, tree\hy like
  Q\hy resolution refutation of . The only derivation step
  admissible in  that cannot occur in a refutation of  is
  universal reduction on  of a clause that contains  or . If
   contains no such step,  is already a refutation of 
  and we are done. Otherwise, suppose universal reduction on  is applied to
  a clause  in , where  and . We will construct a strict,
  tree\hy like Q\hy resolution refutation  that contains one less
  application of universal reduction on  of a clause that contains  or
  . The literal  is tailing in , so  does not contain
  existential literals of depth greater than
  . Without loss of generality, we can further assume
  that  contains no universal literals of depth greater than
  , so . Let  be the result of universal reduction of  on , and  be the clause  is resolved with in
  . Since  is strict,  cannot contain any existential literal
  other than , and we can again assume that there are no
  universal literals in  of depth greater than
  . Moreover, we cannot have . Otherwise -- since every strict, tree\hy like resolution
  refutation is regular -- we could apply Lemma~\ref{lem:ClauseToPath} to
  obtain  and thus , a
  contradiction. That is, we either have 
  or . To obtain , we first resolve  and
   to derive , and then apply universal reduction. Since 
  is strict and tree\hy like, it is easily verified that  must be as
  well.

  For the converse direction, observe that every Q\hy resolution refutation of
   is also a refutation of~.
\end{proof}
 }
With the next example, we illustrate the importance of allowing consecutive
clauses with a tautological Q\hy resolvent in the definition of resolution
paths.
\begin{example}\label{ex:nontaut} \longversion{Consider the following QCNF formula:
  }
\shortversion{Let , where
  , , , , and .}
 Figure \ref{fig:resolutionderivation} shows a Q\hy resolution
derivation of the clause  from . By
Lemma~\ref{lem:ClauseToPath}, there must be a -resolution path in
 connecting  and , and indeed it is straightforward to check that
 is a resolution
path. The literals  and  are trivially resolution connected,
so  is a resolution path dependency pair with respect to ,
and . This is a genuine dependency: it is easily
verified that switching  and  in the prefix of 
results in a formula that is unsatisfiable, while  itself is
satisfiable.

  Note that the clauses  and  do not have a non\hy tautological
  resolvent. All resolution paths in  between  and  lead through
   and . Consequently, if we would restrict Definition
  \ref{def:rconnected} so as to require consecutive clauses in a resolution
  path to have a non\hy tautological Q\hy resolvent (as in Definition 4.1 of
  \cite{VanGelder11}),  and  would no longer be resolution connected in
  , and  would not be identified as dependent on .
\end{example}

\shortversion{\begin{figure}[b]}
\longversion{\begin{figure}}
\begin{center}
\begin{tikzpicture} [yscale = 0.9,grow=up, level 1/.style={sibling distance=50mm},
 level 2/.style={sibling distance=20mm}, scale=0.8]
  \tikzstyle{edge from parent}=[draw,thick] 
    \node {}
      child {node {} 
        child {node {} 
          child {node {}
            edge from parent
            node[below right] {}
          }
          child {node {}
            edge from parent
            node[below left] {}
          }
          edge from parent
            node[left] {}
      }
      edge from parent
         node[below right] {}
    }
     child {node {} 
        child {node {} 
          child {node {}
            edge from parent
            node[below right] {}
          }
          child {node {}
            edge from parent
            node[below left] {}
          }
          edge from parent
            node[left] {}
      } edge from parent
            node[below left] {}
      };
\end{tikzpicture}
\end{center}
\caption{Q\hy resolution derivation of  from } 
\label{fig:resolutionderivation}
\end{figure}
\begin{theorem}\label{thm:DresDep}
   is a cumulative dependency scheme.
\end{theorem}
\begin{proof} We prove that  is (a) continuous and (b) sound for
  transpositions. The result then follows by Lemma~\ref{lem:transsnd}. (a) Let
   and  be QCNF formulas such that  is obtained from
   by quantifier reordering. Let , and
  , . The set of
  \hy resolution paths in  starting from  is identical to the set
  of \hy resolution paths in  starting from  unless . If , every \hy
  resolution path in  is a \hy resolution path in . It is an
  easy consequence that  is continuous.

  (b) Let  be a QCNF formula and  so that
   and . If  and , the result follows from
  Theorem~\ref{thm:resdep1}. Suppose  and . Let  be the result of transposing 
  and  in the quantifier prefix of . Because of , we must have , so we can again
  apply Theorem~\ref{thm:resdep1} and conclude that  and  are
  equivalent. If , equivalence is trivial.
\end{proof}
Using Lemma \ref{lem:subcum}, we can conclude that all dependency relations
appearing in Figure \ref{fig:lattice} are cumulative dependency schemes.
\section{Computing Resolution\hy Path Dependencies} \label{sec:tractability}
This section will be devoted to proving that  is tractable. More
specifically, we will show that the set of literals that are resolution
connected to a given literal in a QCNF formula  with respect to a set  can be computed in linear time. This result in
turn establishes linear time\hy tractability of deciding whether a pair of
variables is contained in .

We will reduce the problem of finding resolution paths to the task of finding
properly edge\hy colored walks in certain edge\hy colored graphs. A
\emph{graph}  consists of a finite set  of \emph{vertices} and a set
 of \emph{edges}, where the edge between two vertices  and  is
denoted by  or equivalently . All graphs we consider are undirected
and simple (i.e., without self\hy loops or multi\hy edges). If  is a graph
and , elements of the set  are called \emph{neighbors of  in }. In a \emph{\hy edge\hy
  colored graph} , every edge  is assigned a \emph{color}
. Given a (not necessarily edge\hy colored)
graph , a \emph{walk} from  to  in  is a sequence of vertices , where , , and 
for . If further  for all ,  is said to be \emph{retracting\hy free}. A walk  in a \hy edge\hy colored graph  is \emph{properly edge\hy
  colored (PEC)} if  for all
. A walk  satisfying 
for distinct  is a \emph{path}. A PEC walk which is a
path is called a \emph{PEC path}. The \emph{length} of a
walk  is . For \hy edge\hy colored graphs, we use the
names \emph{red} and \emph{blue} to denote the colors  and ,
respectively.

Note that there can be a PEC walk from a vertex  to a vertex  without
there being a PEC path from  to . For instance, consider a \hy
edge\hy colored graph with vertex set  and edge set
, such that  and  are red and the remaining edges
are blue. The sequence  is a PEC walk from  to , but there
is no PEC path from  to .
\subsubsection{Construction.}  Let  be a QCNF formula with matrix
, and let . We construct two graphs
 and :
\begin{itemize}
\item For the set of vertices of , we choose . Its edge set consists of all edges  for , and
  all edges  where .

\item We define  to be a \hy edge\hy colored graph with vertex
  set  and edge set , where the set  consists
  of all edges  for , and  consists of all edges
   such that there is a clause  with . The edges in  are red, while those in  are
  blue. \end{itemize}
For general QCNF formulas , the size of  can be quadratic
in the size of , since every clause of size  gives rise to a clique
with  vertices. This can be avoided by using the following trick: we first
convert  to a Q3CNF formula  and then carry out the
construction. For any set , we can clearly compute
 in time . Furthermore, it is well
known that SAT can be reduced to 3SAT in linear time
\cite{KleineBuningLettman99}. We show that this reduction preserves resolution
connectedness.
\begin{restatable}{lemma}{LemThreeCNF}\label{lem:3cnf}\shortversion{\textup{()}}
  Let  be an arbitrary QCNF formula and . In time , one can construct
  a Q3CNF formula  and a set 
  satisfying the following property: two literals 
  are resolution connected in  with respect to  if and only if 
  and  are r\hy connected in  with respect to .
\end{restatable}
\longversion{\begin{proof}
  Let , and suppose there is a
  clause  such that 
  and , where  for all . Let  be a variable not contained in . We set , where , for  and . We will show that two literals
   are resolution connected in  with respect
  to  if and only if  and  are
  resolution connected in  with respect to . Let \hskip 0pt be an \hy resolution path in . If  or , we
  simply replace every occurrence of  with  or , respectively, to
  obtain an \hy resolution path in . Without loss of
  generality, suppose  and . It is easy to verify that \hskip 0pt\hskip
  0pt is an \hy resolution path in
   (recall that  does not occur in anywhere in ). For the
  converse, we proceed in the opposite direction, substituting 
  for subsequences  and  of an \hy resolution path in  (where
  ). Because  is non\hy tautological,  and
   only have the variable  in common. Keeping this in mind, it is
  straightforward to check that the resulting sequence is an \hy resolution
  path in .

  We obtain the desired Q3CNF formula from a QCNF formula  by scanning
   from left to right, splitting clauses where necessary. This can be
  done in time .
\end{proof}
 }
\begin{proposition}\label{prop:linearreduction}
  Given a Q3CNF formula  and a set ,
  the graph  can be constructed in time
  .
\end{proposition}
\begin{figure}
\label{fig:clauseliteralgraph}
\shortversion{\vskip -15pt}
\begin{center}
\begin{tikzpicture}[auto, thick, scale=0.62]
\node [clause, label=below:] (c1) at (0,0) {};
\node [clause, label=below:] (c2) at (-1.5,4) {};

\node [clause, label=below:] (c3) at (-2,6) {};

\node [clause, label=below:] (c4) at (2,6) {};

\node [literal, label=above:] (x) at (0.5,7) {};
\node [literal, label=above:] (nx) at (-0.5,7) {};

\node [literal, label=right:] (u) at (0,1.5) {};
\node [literal, label=right:] (nu) at (0,2.5) {};


\node [literal, label=right:] (y) at (2,1.5) {};
\node [literal, label=right:] (ny) at (2,2.5) {};

\node [clause, label=left:] (c5) at (2,0) {};
\node [literal, label=right:] (y4) at (3,0) {};

\node [literal, label=left:] (v) at (-3,2) {};
\node [literal, label=left:] (nv) at (-3,3) {};

\node [literal, label=below:] (z) at (-1.5,0) {};
\node [literal, label=below:] (nz) at (-2.5,0) {};

\path[thin] (y) edge (ny);
\path[thin] (x) edge (nx);

\path[thin] (c1) edge (z);
\path[thin] (c1) edge (v);
\path[thin] (c1) edge (u);
\path[thin] (c1) edge (y);

\path[thin] (c2) edge (ny);
\path[thin] (c2) edge (nv);
\path[thin] (c2) edge (nu);

\path[thin] (c3) edge (nx);
\path[thin] (c3) edge (ny);

\path[thin] (c4) edge (x);
\path[thin,bend left=40] (c4) edge (ny);

\path[thin] (c5) edge (y);
\path[thin] (c5) edge (y4);


\node [literal, label=above:] (xc) at (10.5,7) {};
\node [literal, label=above:] (nxc) at (9.5,7) {};

\node [literal, label=right:] (uc) at (10,1.5) {};
\node [literal, label=right:] (nuc) at (10,2.5) {};

\node [literal, label=right:] (yc) at (12,1.5) {};
\node [literal, label=right:] (nyc) at (12,2.5) {};
\path[thick] (yc) edge (nyc);

\node [literal, label=left:] (vc) at (7,2) {};
\node [literal, label=left:] (nvc) at (7,3) {};

\node [literal, label=below:] (zc) at (8.5,0) {};
\node [literal, label=below:] (nzc) at (7.5,0) {};

\path[thick] (xc) edge (nxc);
\path[thin,dashed,bend left=20] (xc) edge (nyc);

\path[thin,dashed,bend right=20] (nxc) edge (nyc);

\path[thin,dashed,bend left=20] (nvc) edge (nyc);
\path[thin,dashed,bend right=20] (nvc) edge (nuc);

\path[thin,dashed,bend right=20] (nuc) edge (nyc);

\path[thin,dashed,bend right=40] (zc) edge (yc);
\path[thin,dashed,bend left=20] (zc) edge (vc);
\path[thin,dashed] (zc) edge (uc);

\path[thin,dashed,bend right=20] (vc) edge (uc);
\path[thin,dashed,bend left=10] (vc) edge (yc);

\path[thin,dashed,bend right=20] (uc) edge (yc);

\end{tikzpicture}
\end{center}
\caption{The graphs  (left) and  (right) for the
  formula  of Example \ref{ex:running} and . Red edges
  of  are represented by solid lines, and blue edges by dashed
  lines.}
\end{figure}
\begin{lemma} \label{lem:reduction} Let  be a QCNF formula, , and  such that . The following statements are equivalent:
\begin{enumerate}
\item  and  are resolution connected in  with respect to .
\item There is a retracting\hy free walk  in  from
   to , where  and  for
  .
\item There is a PEC walk in  from  to
   whose first and last edges are blue.
\end{enumerate}
\end{lemma}
\begin{proof}
  (1  2) Suppose  and  are resolution connected in 
  with respect to . Then there exists an \hy resolution path \hskip 0pt in
   from  to . We claim that  is already a
  retracting\hy free walk in  of the desired form. Because 
  is a resolution path, we have  and
  therefore  in  for all . Moreover, because  for , we have  as
  well. So  is indeed a walk in . Since  for ,  must be retracting\hy
  free.

  (2  3) Let  be a retracting\hy free walk from  to  in 
  so that  and  for . We show that the sequence  is a PEC walk from  to  in
   whose first and last edges are blue. Let ,
   be a pair of consecutive edges in  where . By construction of , we have . Because  is retracting\hy free, , and thus
  there is a blue edge  in . For all , the edge  of  is a red edge in
  . So  is a walk in . Moreover, the first and
  last edges of  are blue, and it is easily to verified that  is
  PEC.

  (3  1) Now let  be a PEC walk from  to  in  whose
  first and last edges are blue. By construction of , for every
  blue edge  traversed by , there is a clause  in
   such that , for . For
  every red edge , where , we
  have  and . Let  be the sequence \hskip 0pt.  is an \hy
  resolution path in : we already know that  satisfies conditions
  1-3 of Definition~\ref{def:rconnected}. To verify condition 4, we must show
  that  for all . Suppose to the contrary that  for some . Because  does not contain self\hy loops,
  this implies . But then , contrary to the assumption that  does not
  contain tautological clauses. This concludes the proof that  is an
  \hy resolution path in . It follows that  and  are
  resolution connected in  with respect to .
\end{proof}

\noindent \textbf{Algorithm PEC-Walk.} We now describe the algorithm
\emph{PEC-Walk} that takes as input a 2\hy edge\hy colored graph~ and a
vertex , and computes the set of vertices  such that there is a
PEC walk from  to  whose first and last edges are blue. We maintain a
set  containing (ordered) pairs of vertices  joined by edges that
can be traversed by a PEC walk starting from . Initially,  is empty. For
each vertex , we store a set , where  indicates that there is a PEC walk
from  to  ending in an edge with color . In an initialization phase,
we first set  for all vertices . We then add all pairs
 to  such that  is a neighbor of  and  is a blue edge,
inserting  into  at the same time. In the main
procedure, we repeat the following steps until  is empty: we remove a pair
 from  and add all pairs  to  such that  is a neighbor
of ,  is an edge with color  different from the color of , and
 is not already in . For every pair  we put into , we
add its color to . \longversion{Pseudocode for the algorithm is shown
  below. \begin{algorithm}
\renewcommand{\thealgorithm}{}
\begin{algorithmic}[1]
\ForAll{} 
\State 
\EndFor
\Statex
\ForAll{ with } 
\State add  to 
\State 
\EndFor
\Statex
\While{}
\State let  be an element of 
\State remove  from 
\ForAll{ such that }
\If {}
\State add  to 
\State add  to 
\EndIf
\EndFor
\EndWhile
\end{algorithmic}
\caption{PEC-Walk(Graph , )}
\end{algorithm}
 }
\begin{lemma}\label{lem:linearAlgorithm}
  Let  be a 2\hy edge\hy colored graph and . On input
  , \mbox{PEC-Walk} runs in time .
\end{lemma}
\begin{proof}
  Every ordered pair of vertices joined by an edge is examined at most twice
  and added to  at most once. The algorithm terminates when  is empty,
  and an element is removed from  in each iteration. Initialization can
  take at most  steps. So the time
  required by the entire algorithm is .
\end{proof}
\begin{lemma} \label{lem:algorithm} Let  be a 2\hy edge\hy colored graph,
  , and let  be a vertex labeling generated by
  running {PEC-Walk} on input . There is a PEC walk
  from  to  whose first edge is blue and whose last edge has color  if and only if .
\end{lemma}
\begin{proof} 
  By the preceding lemma, the algorithm always terminates and produces a
  labeling .

  () Let  be a vertex of  different from . We show that
  if , there is a PEC walk from  to  whose first edge is
  blue and whose final edge has color . We proceed by induction on the
  number  of times the algorithm enters the main loop with . If , color  is added to  during the
  initialization phase, so there must be a blue edge . Assume the
  statement holds for all , and  is added to  in
  iteration . Then there must be a pair  with 
  which is added to  in this iteration. That is the case only if a pair
   is removed from  during the same iteration with , where . The pair  must have been inserted into 
  before iteration , at which point  was added to . Applying
  the induction hypothesis, we can conclude there must be a PEC walk from 
  to  such that its first edge is blue and its last edge has color . By
  appending  to this walk, we obtain a PEC walk from  to  with the
  desired properties.

  () Suppose there is a PEC walk from  to  whose first edge
  is blue and whose last edge has color . Let  be the smallest integer
  that is the length of such a walk. We will show by induction on  that . The case  is taken care of by the initialization phase
  of the algorithm. Suppose the statement holds for all . Let  be a PEC walk from  to  with the
  property that its first edge is blue and its last edge has color , and
  assume there is no shorter PEC walk with this property. Then
   is a PEC walk from  to  so that  is
  blue, and  where . There can be no  such that there is a PEC walk of length  from  to  whose
  first edge is blue and whose last edge has color : otherwise, one could
  append  to this path to obtain a PEC walk from  to
   whose initial edge is blue and whose final edge has color  of
  length , a contradiction. We can therefore apply the
  induction hypothesis and conclude that . Let 
  be the pair that was removed from  in the iteration of the main loop in
  which  was added to . Because , in the same
  iteration the pair  must have been added to  and  put
  into to , unless already .
\end{proof}
The next result is immediate from Lemmas \ref{lem:linearAlgorithm} and
\ref{lem:algorithm}.
\begin{proposition}\label{prop:reachable}
  Given a \hy edge\hy colored graph , a vertex , and some , the set of vertices reachable from
   along some PEC walk in  whose first edge is blue and whose last edge
  has color  can be computed in time
  .
\end{proposition}
With all the pieces in place, it is now straightforward to prove our main result.
\begin{theorem} \label{thm:tractable} Given a QCNF formula  and a pair
  of variables , one can decide whether  in time . Hence the resolution\hy
  path dependency scheme is tractable.
\end{theorem}
\begin{proof}
  We prove that there is a linear time decision algorithm. We first check
  whether  and  is in . Using
  Lemma \ref{lem:3cnf}, we can then in linear time compute a QCNF formula
   and a set  from  and  so that two literals are resolution
  connected in  with respect to  if and only if they are resolution
  connected in  with respect to . We can then construct the graph
   and determine for all pairs  with  and  whether there is a properly
  edge\hy colored walk from  to  whose first and last edges
  are blue, which by Lemma \ref{lem:reduction} is equivalent to  and
   being resolution connected in  with respect to 
  (according to Propositions \ref{prop:linearreduction} and
  \ref{prop:reachable}, this can be done in linear time). Using this
  information, it is straightforward to decide whether  is a
  resolution\hy path dependency pair in  with respect to . Each of these steps requires
  linear time, so we need  time in total.
\end{proof}

Samer and Szeider \cite{SamerSzeider09a} generalized the notion of a strong
backdoor set from CNF formulas to QCNF formulas, by adding the requirement
that the backdoor set is closed under a cumulative dependency scheme. They
showed that evaluating QCNF formulas is fixed-parameter tractable (fpt) when
parameterized by the size of a smallest strong backdoor set (with respect to
the classes QHORN or Q2CNF) provided that the considered cumulative dependency
scheme is tractable. By Theorems \ref{thm:DresDep} and \ref{thm:tractable},
one can use the resolution path dependency scheme here and thus get an fpt
result that is stronger than the results achieved by using any of the other
dependency schemes appearing in Fig. \ref{fig:lattice}.


For an existentially quantified variable  in a QCNF , the entire
\emph{set}  can be computed in linear time: we first
determine the sets  is resolution connected
to  in  with respect to  and 
is resolution connected to  in  with respect to  and store them in a data structure that
allows us to decide membership of literals in constant time (say, an
array). To determine , we simply check for each element 
of  whether  and , or  and .

Unfortunately we cannot use the same approach to compute the set of dependent
variables  for a universal variable . For every existential variable , resolution paths that entail 
cannot contain  or . Hence the relevant resolution paths are
subject to different constraints for each , and it is not sufficient in
general to construct  for a single set .

\section{Minimal Dependency Schemes}
The fact that the resolution\hy path dependency scheme is the bottom element
of the lattice represented in Figure \ref{fig:lattice} gives reason to wonder
whether it is the most general dependency scheme. However, computing a minimal
dependency scheme is complete for PSPACE \cite{SamerSzeider09a}. Since the
resolution path dependency scheme is tractable, it follows that it cannot be
minimal. Can we instead prove that  is minimal relative to a class of
``natural'' dependency schemes? At the very least, such a class should include
all the dependency schemes considered so far, which have the following feature
in common: whether a pair of variables is considered dependent is determined
almost entirely in terms of the matrix. We use this property to define a
candidate class.
\begin{definition} A dependency scheme  is called a \emph{matrix dependency
    scheme} if it satisfies the following property: Let  and  be
  QCNF formulas such that  is obtained from  by quantifier
  reordering. Moreover, let  such that . Then for any , we have 
  if and only if .
\end{definition}
The next proposition can be easily verified by inspecting Definition
\ref{def:resdep}.
\begin{proposition}
  The resolution\hy path dependency scheme  is a matrix
  dependency scheme.
\end{proposition}
Unfortunately,  is not even the most general matrix dependency
scheme. We now show that there is a cumulative matrix dependency scheme which
is strictly more general than . Let  be an arbitrary QCNF
formula.
\begin{definition} We let , where
   there is a formula  obtained from  by quantifier reordering, such that
   and ,
  where \hskip 0pt\hskip 0pt.
\end{definition}
\begin{restatable}{proposition}{PropDmatCumulative}\label{prop:dmatcumulative}\shortversion{\textup{()}}
 is a cumulative matrix dependency scheme.
\end{restatable}
\longversion{\longversion{\begin{sloppypar}}
\begin{proof}
  It is evident that  is sound for transpositions because the
  identity permutation is among those quantified over in the definition
  above. Our next goal is to show that  is continuous. Consider two
  QCNF formulas \hskip 0pt and . For all , we have
   and therefore . Since , every
  formula  obtained by quantifier reordering from  such that
   is one that can be obtained from  by
  quantifier reordering such that . From this
  we obtain . A symmetric
  argument yields , which completes the proof that  is
  continuous. Applying Lemma \ref{lem:transsnd}, we conclude that  is
  a cumulative dependency scheme. Moreover,  is clearly a matrix
  dependency scheme.
\end{proof}
\longversion{\end{sloppypar}}
 }
\begin{restatable}{proposition}{PropDmatDres}\label{prop:resdepcontained}\shortversion{\textup{()}}
  For every QCNF formula , the relation  is contained in
  , and containment is strict in some cases.
\end{restatable}
\longversion{\begin{proof}
  Let  be a QCNF formula with , and suppose that
  . Then there is a formula  obtained
  from  by quantifier reordering, such that , and , where \hskip 0pt\hskip 0pt. Because  is a dependency
  scheme, we must have . Since , if two literals  and
   are resolution connected in  with respect
  to , then they
  are resolution connected in  with respect to . It follows that .

  To see that  is strictly contained in , consider the QCNF
  formula~:
   It is easy to verify that  is
  unsatisfiable and remains unsatisfiable if  and 
  switch positions in the prefix. From this we get . At the same time, it is straightforward to check that
  .
\end{proof}
 } 

\longversion{Note that the trivially unsatisfiable clause  in the above
  formula can be replaced by an arbitrary unsatisfiable formula.}

The reduction applied in the proof of the following result
essentially corresponds to the one used by Samer and Szeider to establish
PSPACE\hy hardness of computing minimal dependency schemes
\cite{SamerSzeider09a}.
\begin{restatable}{proposition}{PropPiTwo}\label{prop:piTwo}\shortversion{\textup{()}}
  Let  be a QCNF formula with matrix  and . The
  problem of deciding whether there exists a matrix dependency scheme  such
  that  is \hy hard.
\end{restatable}
\longversion{\begin{proof}
  Let 
  be a QCNF formula, and  new variables not in . Further, let
  , and let . We will show that there is a matrix dependency scheme 
  such that  if and only if  is unsatisfiable. It
  is well known that deciding unsatisfiability of quantified boolean formulas
  with a \hy prefix is \hy complete
  \cite{Stockmeyer76}.

  Suppose there is a matrix dependency scheme  such that . Since  is a dependency scheme,  and  are equivalent. It is easy to see that
   is unsatisfiable, so  must be unsatisfiable as well. Because
  the formula  is
  satisfiable, already  must have been unsatisfiable.

  On the other hand, if there is no matrix dependency scheme  such that
  , then in particular . By
  definition of , there must be a formula  obtained from
   by quantifier reordering so that transposing  and  in the prefix of  results in a formula  such that
  . Since  is unsatisfiable, we can conclude that  must
  be satisfiable. Downshifting of existential variables cannot turn a
  satisfiable formula into an unsatisfiable one, so  is satisfiable as
  well, and we can conclude that  is satisfiable.
\end{proof}
 }

One may object that these considerations do not rule out the possibility that
 is the most general \emph{tractable} matrix dependency scheme. That
this is not the case can be seen from the following simple argument. For any
nonnegative integer , we define a mapping  such that for any QCNF
formula  we have  if ,
and  otherwise. As both  and  are
cumulative matrix dependency schemes and the relevant properties are defined
pointwise, any such function  must be a cumulative matrix dependency
scheme as well. Moreover, each scheme  is clearly tractable and from the
proof of Proposition~\ref{prop:resdepcontained} we know that  is strictly
more general than  for .
\section{Conclusion}
We have shown that resolution path dependencies give rise to a cumulative
dependency scheme that can be decided in linear time. While the latter result
is optimal for the decision problem, we see at least two obstacles for an
efficient implementation. First, computing the entire relation 
using our current algorithm requires  time, which
is prohibitive for practical purposes. Second, it is unclear whether one can
find succinct representations of the relation  similar to those
used for the standard dependency scheme \cite{LonsingBiere2009}. We leave this
issues for future work.

To capture the kind of variable dependencies relevant for expansion\hy based
QBF solvers, Samer considered an alternative definition of dependency schemes
based on variable \emph{independence} \cite{Samer08}. It might be interesting
to study resolution path dependencies in this context as well.
\bibliographystyle{abbrv} 


\begin{thebibliography}{10}

\bibitem{AyariBasin02}
A.~Ayari and D.~Basin.
\newblock Qubos: Deciding quantified {B}oolean logic using propositional
  satisfiability solvers.
\newblock In M.~Aagaard and J.~O'Leary, editors, {\em FMCAD 2002}, volume 2517
  of {\em LNCS}, pages 187--201. Springer Verlag,
  2002.

\bibitem{Biere04} A.~Biere.  \newblock Resolve and expand.  \newblock In
  H.~Hoos and D.~G. Mitchell, editors, {\em SAT 2004}, volume 3542 of {\em
    LNCS}, pages 59--70. Springer Verlag, 2005.

\bibitem{BubeckKleinebuning07} U.~Bubeck and H.~Kleine~B\"{u}ning.  \newblock
  Bounded universal expansion for preprocessing {QBF}.  \newblock In
  J.~Marques-Silva and K.~A. Sakallah, editors, {\em SAT 2007}, volume 4501 of
  {\em LNCS}, pages 244--257. Springer Verlag,
  2007.



\bibitem{EglyTompitsWoltran02}
U.~Egly, H.~Tompits, and S.~Woltran.
\newblock On quantifier shifting for quantified {Boolean} formulas.
\newblock In {\em Proc. SAT'02 Workshop on Theory and Applications of
  Quantified Boolean Formulas}, pages 48--61. Informal Proceedings, 2002.

\bibitem{GiunchigliaMarinNarizzano09}
E.~Giunchiglia, P.~Marin, and M.~Narizzano.
\newblock Reasoning with quantified boolean formulas.
\newblock In A.~Biere, M.~Heule, H.~van Maaren, and T.~Walsh, editors, {\em
  Handbook of Satisfiability}, volume 185, pages 761--780. IOS Press, 2009.

\bibitem{KleineBuningBubeck09}
H.~Kleine~B{\"u}ning and U.~Bubeck.
\newblock Theory of quantified boolean formulas.
\newblock In A.~Biere, M.~Heule, H.~van Maaren, and T.~Walsh, editors, {\em
  Handbook of Satisfiability}, chapter~23, pages 735--760. IOS Press, 2009.

\bibitem{KleinebuningKarpinskiFlogel95}
H.~Kleine~B\"uning, M.~Karpinski, and A.~Fl\"ogel.
\newblock Resolution for quantified {Boolean} formulas.
\newblock {\em Information and Computation}, 117(1):12--18, 1995.

\bibitem{KleineBuningLettman99}
H.~Kleine~B{\"u}ning and T.~Lettman.
\newblock {\em Propositional logic: deduction and algorithms}.
\newblock Cambridge University Press, Cambridge, 1999.

\bibitem{LonsingBiere2009}
F.~Lonsing and A.~Biere.
\newblock A compact representation for syntactic dependencies in {QBFs}.
\newblock In O.~Kullmann, editor, {\em SAT 2009}, volume 5584 of {\em LNCS}, pages
  398--411. Springer, 2009.

\bibitem{LonsingBiere2010} F.~Lonsing and A.~Biere.  \newblock Integrating
  dependency schemes in search-based {QBF} solvers.  \newblock In O.~Strichman
  and S.~Szeider, editors, {\em SAT 2010}, volume 6175 of {\em LNCS}, pages
  158--171. Springer, 2010.

\bibitem{Samer08}
M.~Samer.
\newblock Variable dependencies of quantified {CSPs}.
\newblock In I.~Cervesato, H.~Veith, and A.~Voronkov, editors, {\em LPAR 2008},
  volume 5330 of {\em LNCS}, pages 512--527. Springer, 2008.

\bibitem{SamerSzeider09a}
M.~Samer and S.~Szeider.
\newblock Backdoor sets of quantified {B}oolean formulas.
\newblock {\em Journal of Automated Reasoning}, 42(1):77--97, 2009.

\bibitem{Stockmeyer76}
L.~J. Stockmeyer.
\newblock The polynomial-time hierarchy.
\newblock {\em Theoretical Computer Science}, 3(1):1--22, 1976.

\bibitem{StockmeyerMeyer73}
L.~J. Stockmeyer and A.~R. Meyer.
\newblock Word problems requiring exponential time.
\newblock In {\em Proc. Theory of Computing}, pages 1--9. ACM, 1973.

\bibitem{VanGelder11} A.~Van~Gelder.  \newblock Variable independence and
  resolution paths for quantified boolean formulas.  \newblock In J.~Lee,
  editor, {\em CP 2011}, volume 6876 of {\em LNCS}, pages 789--803. Springer,
  2011.

\end{thebibliography}


\end{document}
