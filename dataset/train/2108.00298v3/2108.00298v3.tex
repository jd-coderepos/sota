
\documentclass{article} \usepackage{iclr2022_conference,times}

\usepackage{amsmath, amsfonts, bm}


\newcommand{\figleft}{{\em (Left)}}
\newcommand{\figcenter}{{\em (Center)}}
\newcommand{\figright}{{\em (Right)}}
\newcommand{\figtop}{{\em (Top)}}
\newcommand{\figbottom}{{\em (Bottom)}}
\newcommand{\captiona}{{\em (a)}}
\newcommand{\captionb}{{\em (b)}}
\newcommand{\captionc}{{\em (c)}}
\newcommand{\captiond}{{\em (d)}}

\newcommand{\newterm}[1]{{\emph{#1}}}


\def\figref#1{figure~\ref{#1}}
\def\Figref#1{Figure~\ref{#1}}
\def\twofigref#1#2{figures \ref{#1} and \ref{#2}}
\def\quadfigref#1#2#3#4{figures \ref{#1}, \ref{#2}, \ref{#3} and \ref{#4}}
\def\secref#1{section~\ref{#1}}
\def\Secref#1{Section~\ref{#1}}
\def\twosecrefs#1#2{sections \ref{#1} and \ref{#2}}
\def\secrefs#1#2#3{sections \ref{#1}, \ref{#2} and \ref{#3}}
\def\eqref#1{equation~\ref{#1}}
\def\Eqref#1{Equation~\ref{#1}}
\def\plaineqref#1{\ref{#1}}
\def\chapref#1{chapter~\ref{#1}}
\def\Chapref#1{Chapter~\ref{#1}}
\def\rangechapref#1#2{chapters\ref{#1}--\ref{#2}}
\def\algref#1{algorithm~\ref{#1}}
\def\Algref#1{Algorithm~\ref{#1}}
\def\twoalgref#1#2{algorithms \ref{#1} and \ref{#2}}
\def\Twoalgref#1#2{Algorithms \ref{#1} and \ref{#2}}
\def\partref#1{part~\ref{#1}}
\def\Partref#1{Part~\ref{#1}}
\def\twopartref#1#2{parts \ref{#1} and \ref{#2}}

\def\ceil#1{\lceil #1 \rceil}
\def\floor#1{\lfloor #1 \rfloor}
\def\1{\bm{1}}
\newcommand{\train}{\mathcal{D}}
\newcommand{\valid}{\mathcal{D_{\mathrm{valid}}}}
\newcommand{\test}{\mathcal{D_{\mathrm{test}}}}

\def\eps{{\varepsilon}}



\newcommand{\ie}{\textnormal{i.e.,}}
\newcommand{\eg}{\textnormal{e.g.,}}


\def\reta{{\textnormal{}}}
\def\ra{{\textnormal{a}}}
\def\rb{{\textnormal{b}}}
\def\rc{{\textnormal{c}}}
\def\rd{{\textnormal{d}}}
\def\re{{\textnormal{e}}}
\def\rf{{\textnormal{f}}}
\def\rg{{\textnormal{g}}}
\def\rh{{\textnormal{h}}}
\def\ri{{\textnormal{i}}}
\def\rj{{\textnormal{j}}}
\def\rk{{\textnormal{k}}}
\def\rl{{\textnormal{l}}}
\def\rn{{\textnormal{n}}}
\def\ro{{\textnormal{o}}}
\def\rp{{\textnormal{p}}}
\def\rq{{\textnormal{q}}}
\def\rr{{\textnormal{r}}}
\def\rs{{\textnormal{s}}}
\def\rt{{\textnormal{t}}}
\def\ru{{\textnormal{u}}}
\def\rv{{\textnormal{v}}}
\def\rw{{\textnormal{w}}}
\def\rx{{\textnormal{x}}}
\def\ry{{\textnormal{y}}}
\def\rz{{\textnormal{z}}}

\def\rvepsilon{{\mathbf{\epsilon}}}
\def\rvtheta{{\mathbf{\theta}}}
\def\rva{{\mathbf{a}}}
\def\rvb{{\mathbf{b}}}
\def\rvc{{\mathbf{c}}}
\def\rvd{{\mathbf{d}}}
\def\rve{{\mathbf{e}}}
\def\rvf{{\mathbf{f}}}
\def\rvg{{\mathbf{g}}}
\def\rvh{{\mathbf{h}}}
\def\rvu{{\mathbf{i}}}
\def\rvj{{\mathbf{j}}}
\def\rvk{{\mathbf{k}}}
\def\rvl{{\mathbf{l}}}
\def\rvm{{\mathbf{m}}}
\def\rvn{{\mathbf{n}}}
\def\rvo{{\mathbf{o}}}
\def\rvp{{\mathbf{p}}}
\def\rvq{{\mathbf{q}}}
\def\rvr{{\mathbf{r}}}
\def\rvs{{\mathbf{s}}}
\def\rvt{{\mathbf{t}}}
\def\rvu{{\mathbf{u}}}
\def\rvv{{\mathbf{v}}}
\def\rvw{{\mathbf{w}}}
\def\rvx{{\mathbf{x}}}
\def\rvy{{\mathbf{y}}}
\def\rvz{{\mathbf{z}}}

\def\erva{{\textnormal{a}}}
\def\ervb{{\textnormal{b}}}
\def\ervc{{\textnormal{c}}}
\def\ervd{{\textnormal{d}}}
\def\erve{{\textnormal{e}}}
\def\ervf{{\textnormal{f}}}
\def\ervg{{\textnormal{g}}}
\def\ervh{{\textnormal{h}}}
\def\ervi{{\textnormal{i}}}
\def\ervj{{\textnormal{j}}}
\def\ervk{{\textnormal{k}}}
\def\ervl{{\textnormal{l}}}
\def\ervm{{\textnormal{m}}}
\def\ervn{{\textnormal{n}}}
\def\ervo{{\textnormal{o}}}
\def\ervp{{\textnormal{p}}}
\def\ervq{{\textnormal{q}}}
\def\ervr{{\textnormal{r}}}
\def\ervs{{\textnormal{s}}}
\def\ervt{{\textnormal{t}}}
\def\ervu{{\textnormal{u}}}
\def\ervv{{\textnormal{v}}}
\def\ervw{{\textnormal{w}}}
\def\ervx{{\textnormal{x}}}
\def\ervy{{\textnormal{y}}}
\def\ervz{{\textnormal{z}}}

\def\rmA{{\mathbf{A}}}
\def\rmB{{\mathbf{B}}}
\def\rmC{{\mathbf{C}}}
\def\rmD{{\mathbf{D}}}
\def\rmE{{\mathbf{E}}}
\def\rmF{{\mathbf{F}}}
\def\rmG{{\mathbf{G}}}
\def\rmH{{\mathbf{H}}}
\def\rmI{{\mathbf{I}}}
\def\rmJ{{\mathbf{J}}}
\def\rmK{{\mathbf{K}}}
\def\rmL{{\mathbf{L}}}
\def\rmM{{\mathbf{M}}}
\def\rmN{{\mathbf{N}}}
\def\rmO{{\mathbf{O}}}
\def\rmP{{\mathbf{P}}}
\def\rmQ{{\mathbf{Q}}}
\def\rmR{{\mathbf{R}}}
\def\rmS{{\mathbf{S}}}
\def\rmT{{\mathbf{T}}}
\def\rmU{{\mathbf{U}}}
\def\rmV{{\mathbf{V}}}
\def\rmW{{\mathbf{W}}}
\def\rmX{{\mathbf{X}}}
\def\rmY{{\mathbf{Y}}}
\def\rmZ{{\mathbf{Z}}}

\def\ermA{{\textnormal{A}}}
\def\ermB{{\textnormal{B}}}
\def\ermC{{\textnormal{C}}}
\def\ermD{{\textnormal{D}}}
\def\ermE{{\textnormal{E}}}
\def\ermF{{\textnormal{F}}}
\def\ermG{{\textnormal{G}}}
\def\ermH{{\textnormal{H}}}
\def\ermI{{\textnormal{I}}}
\def\ermJ{{\textnormal{J}}}
\def\ermK{{\textnormal{K}}}
\def\ermL{{\textnormal{L}}}
\def\ermM{{\textnormal{M}}}
\def\ermN{{\textnormal{N}}}
\def\ermO{{\textnormal{O}}}
\def\ermP{{\textnormal{P}}}
\def\ermQ{{\textnormal{Q}}}
\def\ermR{{\textnormal{R}}}
\def\ermS{{\textnormal{S}}}
\def\ermT{{\textnormal{T}}}
\def\ermU{{\textnormal{U}}}
\def\ermV{{\textnormal{V}}}
\def\ermW{{\textnormal{W}}}
\def\ermX{{\textnormal{X}}}
\def\ermY{{\textnormal{Y}}}
\def\ermZ{{\textnormal{Z}}}

\def\vzero{{\bm{0}}}
\def\vone{{\bm{1}}}
\def\vmu{{\bm{\mu}}}
\def\vtheta{{\bm{\theta}}}
\def\va{{\bm{a}}}
\def\vb{{\bm{b}}}
\def\vc{{\bm{c}}}
\def\vd{{\bm{d}}}
\def\ve{{\bm{e}}}
\def\vf{{\bm{f}}}
\def\vg{{\bm{g}}}
\def\vh{{\bm{h}}}
\def\vi{{\bm{i}}}
\def\vj{{\bm{j}}}
\def\vk{{\bm{k}}}
\def\vl{{\bm{l}}}
\def\vm{{\bm{m}}}
\def\vn{{\bm{n}}}
\def\vo{{\bm{o}}}
\def\vp{{\bm{p}}}
\def\vq{{\bm{q}}}
\def\vr{{\bm{r}}}
\def\vs{{\bm{s}}}
\def\vt{{\bm{t}}}
\def\vu{{\bm{u}}}
\def\vv{{\bm{v}}}
\def\vw{{\bm{w}}}
\def\vx{{\bm{x}}}
\def\vy{{\bm{y}}}
\def\vz{{\bm{z}}}
\def\vomega{{\bm{\omega}}}


\def\evalpha{{\alpha}}
\def\evbeta{{\beta}}
\def\evepsilon{{\epsilon}}
\def\evlambda{{\lambda}}
\def\evomega{{\omega}}
\def\evmu{{\mu}}
\def\evpsi{{\psi}}
\def\evsigma{{\sigma}}
\def\evtheta{{\theta}}
\def\eva{{a}}
\def\evb{{b}}
\def\evc{{c}}
\def\evd{{d}}
\def\eve{{e}}
\def\evf{{f}}
\def\evg{{g}}
\def\evh{{h}}
\def\evi{{i}}
\def\evj{{j}}
\def\evk{{k}}
\def\evl{{l}}
\def\evm{{m}}
\def\evn{{n}}
\def\evo{{o}}
\def\evp{{p}}
\def\evq{{q}}
\def\evr{{r}}
\def\evs{{s}}
\def\evt{{t}}
\def\evu{{u}}
\def\evv{{v}}
\def\evw{{w}}
\def\evx{{x}}
\def\evy{{y}}
\def\evz{{z}}

\def\mA{{\bm{A}}}
\def\mB{{\bm{B}}}
\def\mC{{\bm{C}}}
\def\mD{{\bm{D}}}
\def\mE{{\bm{E}}}
\def\mF{{\bm{F}}}
\def\mG{{\bm{G}}}
\def\mH{{\bm{H}}}
\def\mI{{\bm{I}}}
\def\mJ{{\bm{J}}}
\def\mK{{\bm{K}}}
\def\mL{{\bm{L}}}
\def\mM{{\bm{M}}}
\def\mN{{\bm{N}}}
\def\mO{{\bm{O}}}
\def\mP{{\bm{P}}}
\def\mQ{{\bm{Q}}}
\def\mR{{\bm{R}}}
\def\mS{{\bm{S}}}
\def\mT{{\bm{T}}}
\def\mU{{\bm{U}}}
\def\mV{{\bm{V}}}
\def\mW{{\bm{W}}}
\def\mX{{\bm{X}}}
\def\mY{{\bm{Y}}}
\def\mZ{{\bm{Z}}}
\def\mBeta{{\bm{\beta}}}
\def\mPhi{{\bm{\Phi}}}
\def\mLambda{{\bm{\Lambda}}}
\def\mSigma{{\bm{\Sigma}}}

\DeclareMathAlphabet{\mathsfit}{\encodingdefault}{\sfdefault}{m}{sl}
\SetMathAlphabet{\mathsfit}{bold}{\encodingdefault}{\sfdefault}{bx}{n}
\newcommand{\tens}[1]{\bm{\mathsfit{#1}}}
\def\tA{{\tens{A}}}
\def\tB{{\tens{B}}}
\def\tC{{\tens{C}}}
\def\tD{{\tens{D}}}
\def\tE{{\tens{E}}}
\def\tF{{\tens{F}}}
\def\tG{{\tens{G}}}
\def\tH{{\tens{H}}}
\def\tI{{\tens{I}}}
\def\tJ{{\tens{J}}}
\def\tK{{\tens{K}}}
\def\tL{{\tens{L}}}
\def\tM{{\tens{M}}}
\def\tN{{\tens{N}}}
\def\tO{{\tens{O}}}
\def\tP{{\tens{P}}}
\def\tQ{{\tens{Q}}}
\def\tR{{\tens{R}}}
\def\tS{{\tens{S}}}
\def\tT{{\tens{T}}}
\def\tU{{\tens{U}}}
\def\tV{{\tens{V}}}
\def\tW{{\tens{W}}}
\def\tX{{\tens{X}}}
\def\tY{{\tens{Y}}}
\def\tZ{{\tens{Z}}}

\def\gA{{\mathcal{A}}}
\def\gB{{\mathcal{B}}}
\def\gC{{\mathcal{C}}}
\def\gD{{\mathcal{D}}}
\def\gE{{\mathcal{E}}}
\def\gF{{\mathcal{F}}}
\def\gG{{\mathcal{G}}}
\def\gH{{\mathcal{H}}}
\def\gI{{\mathcal{I}}}
\def\gJ{{\mathcal{J}}}
\def\gK{{\mathcal{K}}}
\def\gL{{\mathcal{L}}}
\def\gM{{\mathcal{M}}}
\def\gN{{\mathcal{N}}}
\def\gO{{\mathcal{O}}}
\def\gP{{\mathcal{P}}}
\def\gQ{{\mathcal{Q}}}
\def\gR{{\mathcal{R}}}
\def\gS{{\mathcal{S}}}
\def\gT{{\mathcal{T}}}
\def\gU{{\mathcal{U}}}
\def\gV{{\mathcal{V}}}
\def\gW{{\mathcal{W}}}
\def\gX{{\mathcal{X}}}
\def\gY{{\mathcal{Y}}}
\def\gZ{{\mathcal{Z}}}

\def\sA{{\mathbb{A}}}
\def\sB{{\mathbb{B}}}
\def\sC{{\mathbb{C}}}
\def\sD{{\mathbb{D}}}
\def\sF{{\mathbb{F}}}
\def\sG{{\mathbb{G}}}
\def\sH{{\mathbb{H}}}
\def\sI{{\mathbb{I}}}
\def\sJ{{\mathbb{J}}}
\def\sK{{\mathbb{K}}}
\def\sL{{\mathbb{L}}}
\def\sM{{\mathbb{M}}}
\def\sN{{\mathbb{N}}}
\def\sO{{\mathbb{O}}}
\def\sP{{\mathbb{P}}}
\def\sQ{{\mathbb{Q}}}
\def\sR{{\mathbb{R}}}
\def\sS{{\mathbb{S}}}
\def\sT{{\mathbb{T}}}
\def\sU{{\mathbb{U}}}
\def\sV{{\mathbb{V}}}
\def\sW{{\mathbb{W}}}
\def\sX{{\mathbb{X}}}
\def\sY{{\mathbb{Y}}}
\def\sZ{{\mathbb{Z}}}

\def\emLambda{{\Lambda}}
\def\emA{{A}}
\def\emB{{B}}
\def\emC{{C}}
\def\emD{{D}}
\def\emE{{E}}
\def\emF{{F}}
\def\emG{{G}}
\def\emH{{H}}
\def\emI{{I}}
\def\emJ{{J}}
\def\emK{{K}}
\def\emL{{L}}
\def\emM{{M}}
\def\emN{{N}}
\def\emO{{O}}
\def\emP{{P}}
\def\emQ{{Q}}
\def\emR{{R}}
\def\emS{{S}}
\def\emT{{T}}
\def\emU{{U}}
\def\emV{{V}}
\def\emW{{W}}
\def\emX{{X}}
\def\emY{{Y}}
\def\emZ{{Z}}
\def\emSigma{{\Sigma}}

\newcommand{\etens}[1]{\mathsfit{#1}}
\def\etLambda{{\etens{\Lambda}}}
\def\etA{{\etens{A}}}
\def\etB{{\etens{B}}}
\def\etC{{\etens{C}}}
\def\etD{{\etens{D}}}
\def\etE{{\etens{E}}}
\def\etF{{\etens{F}}}
\def\etG{{\etens{G}}}
\def\etH{{\etens{H}}}
\def\etI{{\etens{I}}}
\def\etJ{{\etens{J}}}
\def\etK{{\etens{K}}}
\def\etL{{\etens{L}}}
\def\etM{{\etens{M}}}
\def\etN{{\etens{N}}}
\def\etO{{\etens{O}}}
\def\etP{{\etens{P}}}
\def\etQ{{\etens{Q}}}
\def\etR{{\etens{R}}}
\def\etS{{\etens{S}}}
\def\etT{{\etens{T}}}
\def\etU{{\etens{U}}}
\def\etV{{\etens{V}}}
\def\etW{{\etens{W}}}
\def\etX{{\etens{X}}}
\def\etY{{\etens{Y}}}
\def\etZ{{\etens{Z}}}

\newcommand{\tuple}[1]{{\left\langle #1 \right\rangle}}


\newcommand{\pdata}{p_{\rm{data}}}
\newcommand{\ptrain}{\hat{p}_{\rm{data}}}
\newcommand{\Ptrain}{\hat{P}_{\rm{data}}}
\newcommand{\pmodel}{p_{\rm{model}}}
\newcommand{\Pmodel}{P_{\rm{model}}}
\newcommand{\ptildemodel}{\tilde{p}_{\rm{model}}}
\newcommand{\pencode}{p_{\rm{encoder}}}
\newcommand{\pdecode}{p_{\rm{decoder}}}
\newcommand{\precons}{p_{\rm{reconstruct}}}

\newcommand{\laplace}{\mathrm{Laplace}} 

\newcommand{\E}{\mathbb{E}}
\newcommand{\Ls}{\mathcal{L}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\emp}{\tilde{p}}
\newcommand{\lr}{\alpha}
\newcommand{\reg}{\lambda}
\newcommand{\rect}{\mathrm{rectifier}}
\newcommand{\relu}{\mathrm{relu}}
\newcommand{\softmax}{\mathrm{softmax}}
\newcommand{\sigmoid}{\sigma}
\newcommand{\softplus}{\zeta}
\newcommand{\KL}{D_{\mathrm{KL}}}
\newcommand{\Var}{\mathrm{Var}}
\newcommand{\standarderror}{\mathrm{SE}}
\newcommand{\Cov}{\mathrm{Cov}}
\newcommand{\normlzero}{L^0}
\newcommand{\normlone}{L^1}
\newcommand{\normltwo}{L^2}
\newcommand{\normlp}{L^p}
\newcommand{\normmax}{L^\infty}
\newcommand{\norm}[1]{\left\lVert#1\right\rVert}

\newcommand{\parents}{Pa} 

\DeclareMathOperator*{\argmax}{arg\,max}
\DeclareMathOperator*{\argmin}{arg\,min}

\DeclareMathOperator{\sign}{sign}
\DeclareMathOperator{\Tr}{Tr}
\let\ab\allowbreak



\newcommand{\MDP}{\textnormal{MDP}} 
\usepackage{hyperref}
\usepackage{url}
\usepackage{booktabs}
\usepackage{multirow}
\usepackage{graphicx}
\usepackage{adjustbox}
\usepackage{todo}
\usepackage{tikz}
\usepackage{wrapfig}
\usetikzlibrary{shapes,arrows, positioning}
\usepackage{dsfont}


\newcommand{\GRIL}{\texttt{GRIN}}


\title{Filling the G\underline{~~}ap\underline{~~}s: Multivariate Time Series Imputation by Graph Neural Networks}



\author{Andrea Cini, Ivan Marisca\thanks{Equal contribution. Correspondence to \texttt{andrea.cini@usi.ch}.}\hspace{1.5mm}, Cesare Alippi\\
The Swiss AI Lab IDSIA, Universit\`a della Svizzera italiana Politecnico di Milano
}



\newcommand{\fix}{\marginpar{FIX}}
\newcommand{\new}{\marginpar{NEW}}

\iclrfinalcopy \begin{document}


\maketitle

\begin{abstract}
Dealing with missing values and incomplete time series is a labor-intensive, tedious, inevitable task when handling data coming from real-world applications. Effective spatio-temporal representations would allow imputation methods to reconstruct missing temporal data by exploiting information coming from sensors at different locations. However, standard methods fall short in capturing the nonlinear time and space dependencies existing within networks of interconnected sensors and do not take full advantage of the available -- and often strong -- relational information. Notably, most state-of-the-art imputation methods based on deep learning do not explicitly model relational aspects and, in any case, do not exploit processing frameworks able to adequately represent structured spatio-temporal data.
Conversely, graph neural networks have recently surged in popularity as both expressive and scalable tools for processing sequential data with relational inductive biases. In this work, we present the first assessment of graph neural networks in the context of multivariate time series imputation. In particular, we introduce a novel graph neural network architecture, named \GRIL, which aims at reconstructing missing data in the different channels of a multivariate time series by learning spatio-temporal representations through message passing. Empirical results show that our model outperforms state-of-the-art methods in the imputation task on relevant real-world benchmarks with mean absolute error improvements often higher than .
\end{abstract}

\section{Introduction}

Imputation of missing values is a prominent problem in multivariate time-series analysis~(TSA) from both theoretical and practical perspectives~\citep{little2019statistical}. In fact, in a world of complex interconnected systems such as those characterizing sensor networks or the Internet of Things, faulty sensors and network failures are widespread phenomena that cause disruptions in the data acquisition process. Luckily, failures of these types are often sparse and localized at the single sensor level, i.e., they do not compromise the entire sensor network at once. In other terms, it is often the case that, at a certain time step, missing data appear only at some of the channels of the resulting multivariate time series. In this context, spatio-temporal imputation methods~\citep{yi2016stmvl, yoon2018estimating} aim at reconstructing the missing parts of the signals by possibly exploiting both temporal and spatial dependencies. In particular, effective spatio-temporal approaches would reconstruct missing values by taking into account past and future values, and the concurrent measurements of spatially close neighboring sensors too. Here, \emph{spatial similarity} does not necessarily mean physical~(e.g., geographic) proximity, but rather indicates that considered sensors are related w.r.t. a generic~(quantifiable) functional dependency~(e.g., Pearson correlation or Granger causality -- \citealp{granger1969investigating}) and/or that are close in a certain latent space. Relational information, then, can be interpreted as a set of constraints -- linking the different time series -- that allows replacing the malfunctioning sensors with virtual ones.

Among different imputation methods, approaches based on deep learning~\citep{lecun2015deep, schmidhuber2015deep, goodfellow2016deep} have become increasingly popular~\citep{yoon2018gain, cao2018brits, liu2019naomi}. However, these methods often completely disregard available relational information or rely on rather simplistic modifications of standard neural architectures tailored for sequence processing~\citep{hochreiter1997long, chung2014empirical, bai2018empirical, vaswani2017attention}. We argue that stronger, structural, inductive biases are needed to advance the state of the art in time series imputation and allow to build effective inference engines in the context of large and complex sensor networks as those found in real-world applications.

In this work, we model input multivariate time series as sequences of graphs where edges represent relationships among different channels. We propose graph neural networks~(GNNs)~\citep{scarselli2008graph, bronstein2017geometric, battaglia2018relational} as the building block of a novel, bidirectional, recurrent neural network for multivariate time series imputation~(MTSI). Our method, named \emph{Graph Recurrent Imputation Network}~(\GRIL), has at its core a recurrent neural network cell where gates are implemented by message-passing neural networks~(MPNNs; \citealp{gilmer2017neural}). Two of these networks process the input multivariate time series in both forward and backward time directions at each node, while hidden states are processed by a message-passing imputation layer which is constrained to learn how to perform imputation by looking at neighboring nodes. In fact, by considering each edge as a soft functional dependency that constraints the value observed at corresponding nodes, we argue that operating in the context of graphs introduces a positive inductive bias for MTSI.
Our contributions are manifold: 1) we introduce a methodological framework to exploit graph neural networks in the context of MTSI, 2) we propose a novel, practical and effective implementation of a GNN-based architecture for MTSI, and 3) we achieve state-of-the-art results on several and varied MTSI benchmarks. Our method does not rely on any assumption on the distribution of the missing values~(e.g., presence and duration of transient dynamics and/or length of missing sequences) other than stationarity of the underlying process. The rest of the paper is organized as follows. In Section~\ref{s:related_works} we discuss the related works. Then, in Section~\ref{s:problem}, we formally introduce the problem settings and the task of MTSI. We present our approach to MTSI in Section~\ref{s:proposal}, by describing the novel framework to implement imputation architectures based on GNNs. We proceed with an empirical evaluation of the presented method against state-of-the-art baselines in Section~\ref{s:experiments} and, finally, we draw our conclusions in Section~\ref{s:conclusion}.

\section{Related works}\label{s:related_works}

\paragraph{Time series imputation} There exists a large literature addressing missing value imputation in time series. Besides the simple and standard interpolation methods based on polynomial curve fitting, popular approaches aim at filling up missing values by taking advantage of standard forecasting methods and similarities among time series. For example, several approaches rely on k-nearest neighbors~\citep{troyanskaya2001missing, beretta2016nearest}, the \emph{expectation-maximization} algorithm~\citep{ghahramani1994supervised, nelwamondo2007missing} or linear predictors and state-space models~\citep{durbin2012time, kihoro2013imputation}. Low-rank approximation methods, such as matrix factorization~\citep{cichocki2009fast}, are also popular alternatives which can also account for spatial~\citep{cai2010graph, rao2015collaborative} and temporal~\citep{yu2016temporal, mei2017nonnegative} information. Among linear methods, STMVL~\citep{yi2016stmvl} combines temporal and spatial interpolation to fill missing values in geographically tagged time series. 

More recently, several deep learning approaches have been proposed for MTSI. Among the others, deep autoregressive methods based on recurrent neural networks~(RNNs) found widespread success~\citep{lipton2016directly, che2018recurrent, luo2018multivariate, yoon2018estimating, cao2018brits}. GRU-D~\citep{che2018recurrent} learns how to process sequences with missing data by controlling the decay of the hidden states of a gated RNN. \citet{cao2018brits} propose \emph{BRITS}, a bidirectional GRU-D-like RNN for multivariate time series imputation that takes into account correlation among different channels to perform spatial imputation. Other successful strategies in the literature have been proposed that exploit the adversarial training framework to generate realistic reconstructed sequences~\citep{yoon2018gain, fedus2018maskgan, luo2018multivariate, luo2019e2gan}. Notably, GAIN~\citep{yoon2018gain} uses GANs~\citep{goodfellow2014generative} to learn models that perform imputation in the i.i.d. settings. \citet{luo2018multivariate, luo2019e2gan} aim, instead, at learning models that generate realistic synthetic sequences and exploit them to fill missing values. \citet{miao2021generative} use an approach similar to GAIN, but condition the generator on the predicted label for the target incomplete time series. Concurrently to our work,~\citet{kuppannagari2021spatio} developed a graph-based spatio-temporal denoising autoencoder for spatio-temporal data coming from smart grids with known topology.
\citet{liu2019naomi}, instead, uses adversarial learning to train a multiscale model that imputes highly sparse time series in a hierarchical fashion. However, we argue that none of the above-cited methods can take full advantage of relational information and nonlinear spatio-temporal dependencies. Most importantly, the above methods do not fully exploit the flexibility and expressiveness enabled by operating in the context of graph processing.

\paragraph{Graph neural networks for TSA} Graph neural networks have been exploited in TSA mostly in spatio-temporal forecasting methods. The idea behind most of the methods present in the literature is to modify standard neural network architectures for sequential data by relying on operators that work in the graph domain. For example, \citet{seo2018structured} propose a GRU cell where gates are implemented by spectral GNNs~\citep{defferrard2016convolutional}; \citet{li2018diffusion} propose an analogous architecture replacing spectral GNNs with a diffusion-convolutional network~\citep{atwood2016diffusion}. Note that these models are different w.r.t. approaches that use recurrent networks to propagate information graph-wise~\citep{scarselli2008graph, li2016gated}. \citet{yu2017spatio} and \citet{wu2019graph, wu2020connecting} propose, instead, spatio-temporal convolutional neural networks that alternate convolutions on temporal and spatial dimensions. Similar approaches have also been studied in the context of attention-based models~\citep{vaswani2017attention} with spatio-temporal Transformer-like architectures~\citep{zhang2018gaan, cai2020traffic}. Another particularly interesting line of research is related to the problem of learning the graph structure underlying an input multivariate time series~\citep{kipf2018neural, wu2020connecting, shang2020discrete}. While previously mentioned approaches focus on multivariate time series prediction, other methods aim at predicting changes in graph topology~\citep{zambon2019autoregressive, paassen2020graph}. Conversely, methods such as Temporal Graph Networks~\citep{rossi2020temporal} are tailored to learn node embeddings in dynamical graphs. Finally, recent works have proposed GNNs for imputing missing features in the context of i.i.d.\ data. Among the others, \citet{spinelli2020missing} propose an adversarial framework to train GNNs on the data reconstruction task, while \citet{you2020handling} propose a bipartite graph representation for feature imputation. Lately, GNNs have also been exploited for spatial interpolation~\citep{appleby2020kriging, wu2020inductive} -- sometimes referred to as \textit{kriging}~\citep{stein1999interpolation}. To the best of our knowledge, no previous GNN-based method targeted missing value imputation for generic multivariate time series.

\section{Preliminaries}\label{s:problem}

\begin{figure}
    \centering
    \includegraphics[width=\linewidth]{imgs/mts2graphstream.pdf}
    \vspace{-0.6cm}
    \caption{Representation of a multivariate time series as a sequence of graphs. Red circles denote nodes with missing values, nodes are identified.}
    \label{fig:graph_stream}
\end{figure}

\paragraph{Sequences of graphs} We consider sequences of weighted directed graphs, where we observe a graph  with  nodes at each time step . A graph is a couple , where  is the node-attribute matrix whose -th row contains the -dimensional node-attribute vector  associated with the -th node; entry  of the adjacency matrix  denotes the scalar weight of the edge (if any) connecting the -th and -th node. Fig.~\ref{fig:graph_stream} exemplifies this modelling framework. We assume nodes to be identified, i.e., to have a unique ID that enables time-wise consistent processing. This problem setting can be easily extended to more general classes of graphs with attributed edges and global attributes. In this work, we mainly focus on problems where the topology of the graph is fixed and does not change over time, i.e., at each time step  and . 

Any generic multivariate time series fits the above framework by letting each channel of the sequence~(i.e., each sensor) correspond to a node and using the available relation information to build an adjacency matrix. If no relational information is available, one could use the identity matrix, but this would defeat the purpose of the formulation. A more proper choice of  can be made using any standard similarity score~(e.g., Pearson correlation) or a~(thresholded) kernel. A more advanced approach instead could aim at learning an adjacency directly from data by using, for instance, spatial attention scores or resorting to graph learning techniques, e.g., \citet{kipf2018neural}. From now on, we assume that input multivariate time series have homogeneous channels, i.e., sensors are of the same type. Note that this assumption does not imply a loss in generality: it is always possible to standardize node features by adding \textit{sensor type} attributes and additional dimensions to accommodate the different types of sensor readings. Alternatively, one might directly model the problem by exploiting heterogeneous graphs~\citep{schlichtkrull2018modeling}.

\paragraph{Multivariate time series imputation} To model the presence of missing values, we consider, at each step, a binary mask  where each row  indicates which of the corresponding node attributes of  are available in . It follows that,  implies  to be missing; conversely, if , then  stores the actual sensor reading. We denote by  the \emph{unknown} ground truth node-attribute matrix, i.e., the complete node-attribute matrix without any missing data. We assume stationarity of missing data distribution and, in experiments, we mostly focus on the missing at random~(MAR) scenario~\citep{rubin1976inference}. We neither make assumptions on the number of concurrent sensor failures, nor on the length of missing data blocks, i.e., multiple failures extended over time are accounted for. Clearly, one should expect imputation performance to scale with the number of concurrent faults and the time length of missing data bursts. 

The objective of MTSI is to impute missing values in a sequence of input data. More formally, given a graph sequence  of length , we can define the missing data reconstruction error as

where  is the reconstructed ;  and  are respectively the logical binary complement of  and ,  is an element-wise error function~(e.g., absolute or squared error) and  indicates the standard dot product. Note that, in practice, it is impossible to have access to  and, as a consequence, it is necessary to define a surrogate optimization objective by, for example, using a forecasting loss or generating synthetic missing values. In the context of trainable, parametric, imputation methods, we consider two different operational settings. In the first one, named \emph{in-sample imputation}, the model is trained to reconstruct missing values in a given \emph{fixed} input sequence , i.e., the model is trained on all the available data except those that are missing and those that have been removed from the sequence to emulate additional failures for evaluation. Differently, in the second one~(referred to as \emph{out-of-sample imputation}), the model is trained and evaluated on disjoint sequences. Note that in both cases the model does not have access to the ground-truth data used for the final evaluation. The first operational setting simulates the case where a practitioner fits the model directly on the sequence to fill up its gaps. The second, instead, simulates the case where one wishes to use a model fitted on a set of historical data to impute missing values in an unseen target sequence. 

\section{Graph Recurrent Imputation Network}\label{s:proposal}

In this section, we present our approach, the \emph{Graph Recurrent Imputation Network}~(\GRIL), a graph-based, recurrent neural architecture for MTSI. Given a multivariate time series  with mask , our objective is to reconstruct missing values in the input sequence by combining the information coming from both the temporal and spatial dimensions. To do so, we design a~\emph{novel bidirectional graph recurrent neural network} which progressively processes the input sequence both forward and backward in time by performing two stages of imputation for each direction. Then, a feed-forward network takes as input the representation learned by the forward and backward models and performs a final -- refined -- imputation for each node of the graph and step of the sequence. More precisely, the final imputation depends on the output of two \GRIL\ modules whose learned representations are finally processed (space and time wise) by a last decoding multilayer perceptron~(MLP). An overview of the complete architecture is given in Fig.~\ref{fig:grill}. As shown in the figure, the two modules impute missing values iteratively, using at each time step previously imputed values as input. We proceed by first describing in detail the unidirectional model, and then we provide the bidirectional extension.

\paragraph{Unidirectional model} Each \GRIL\ module is composed of two blocks, a spatio-temporal encoder and a spatial decoder, which process the input sequence of graphs in two stages. The spatio-temporal encoder maps the input sequence  to a spatio-temporal representation  by exploiting an ad-hoc designed recurrent GNN. The spatial decoder, instead, takes advantage of the learned representations to perform two consecutive rounds of imputation.  A first-stage imputation is obtained from the representation by using a linear readout; the second one exploits available relational, spatial, information at time step . In particular, the decoder is implemented by an MPNN which learns to infer the observed values at each -th node --  -- by refining first-stage imputations considering -- locally --  and values observed at neighboring nodes.
\begin{figure}
    \centering
    \includegraphics[width=\linewidth]{imgs/gril_fig.pdf}
    \vspace{-0.75cm}
    \caption{An overview of the bidirectional architecture. Here, each unidirectional \GRIL\ module is processing the -th step of an input sequence with  dimensions~(sensors). Two values are missing at the considered time step. \GRIL\ performs a first imputation, which is then processed and refined by the spatial decoder. These second-stage imputations are then used to continue the processing at the next step. An MLP processes learned representations node and time wise to obtain final imputations.}
    \label{fig:grill}
\end{figure}
\paragraph{Spatio-temporal Encoder} In the encoder, the input sequence  and mask  are processed sequentially one step at a time, by means of a recurrent neural network with gates implemented by message-passing layers. 
Any message-passing operator could be used in principle. In particular, given , i.e., the node features vector at layer ,  we consider the general class of MPNNs described as

where  is the set of neighbors of the -th node in ,  and  are generic, differentiable, update and message functions~(e.g., MLPs), and  is a permutation invariant, differentiable aggregation function~(e.g.,  or ). Note that several definitions of \emph{neighborhood} are possible, e.g., one might consider nodes connected by paths up to a certain length . For the sake of simplicity, from now on, we indicate with MPNN the forward pass of a generic -layered message-passing neural network.
In the following, we use MPNNs as the building blocks for our spatio-temporal feature extractors.
To learn the dynamics of the system, we leverage on gated recurrent units~(GRUs; \citealp{cho2014learning}). As previously mentioned, similarly to~\citet{seo2018structured} and ~\citet{li2018diffusion}, we implement the GRU gates by relying on the message-passing layers defined above. At the node level, the elements of the message-passing GRU (MPGRU) can be described as:

where  are the reset and update gates, respectively,  is the hidden representation of the -th node at time , and  is the output of the decoding block at the previous time-step~(see next paragraph). The symbols  and  denote the Hadamard product and the concatenation operator, respectively. The initial representation  can either be initialized as a constant or with a learnable embedding. Note that for the steps where input data are missing, the encoder is fed with predictions from the decoder block, as explained in the next subsection. By carrying out the above computation time and node wise, we get the encoded sequence .
\paragraph{Spatial Decoder} As a first decoding step, we generate one-step-ahead predictions from the hidden representations of the MPGRU by means of a linear readout

where  is a learnable weight matrix and  is a learnable bias vector. We then define the \emph{filler} operator as

intuitively, the filler operator replaces the missing values in the input  with the values at the same positions in .
By feeding  to the filler operator, we get the \textit{first-stage imputation}  such that the output is  with missing values replaced by the one-step-ahead predictions . The resulting node-level predictions are then concatenated to the mask  and the hidden representation , and processed by a final \emph{one-layer} MPNN which computes for each node an \emph{imputation representation}  as

Notice that, as previously highlighted, the imputation representations only depend on messages received from neighboring nodes and the representation at the previous step. In fact, by aggregating only messages from the one-hop neighborhood,
the representations  are independent of the input features  of the -th node itself. This constraint forces the model to learn how to reconstruct a target input by taking into account spatial dependencies: this has a regularizing effect since the model is constrained to focus on \emph{local} information. Afterward, we concatenate imputation representation  with hidden representation , and generate second-stage imputations by using a second linear readout and applying the filler operator:

Finally, we feed  as input to the MPGRU~(Eq.~\ref{eq:mpgrub}~--~\ref{eq:mpgrue}) to update the hidden representation and proceed to process the next input graph .

\paragraph{Bidirectional Model} Extending~\GRIL\ to account for both forward and backward dynamics is straightforward and can be achieved by duplicating the architecture described in the two previous paragraphs. The first module will process the sequence in the forward direction (from the beginning of the sequence towards its end), while the second one in the other way around. The final imputation is then obtained with an MLP aggregating representations extracted by the two modules:

where  and  denote the forward and backward modules, respectively. The final output can then be easily obtained as . Note that, by construction, our model can exploit all the available relevant spatio-temporal information, since the only value explicitly masked out for each node is . At the same time, it is important to realize that our model does not merely reconstruct the input as an autoencoder, but it is specifically tailored for the imputation task due to its inductive biases. The model is trained by minimizing the reconstruction error of all imputation stages in both directions~(see Appendix~\ref{a:appendix_exp}).


\section{Empirical evaluation}\label{s:experiments}

\begin{table}[ht]
\caption{Results on the air datasets. Performance averaged over  runs.}
\vspace{0.1cm}
\centering
\resizebox{\linewidth}{!}{
\begin{tabular}{c | l | r r r | r r r}
\toprule
 \multicolumn{2}{c}{}&\multicolumn{3}{c}{In-sample} & \multicolumn{3}{c}{Out-of-sample} \\
\toprule
D & \multicolumn{1}{c|}{M}  & \multicolumn{1}{c}{\small MAE} & \multicolumn{1}{c}{\small MSE} & \multicolumn{1}{c}{\small MRE (\%)} & \multicolumn{1}{|c}{\small MAE} & \multicolumn{1}{c}{\small MSE} & \multicolumn{1}{c}{\small MRE (\%)}\\
\midrule
\multirow{9}{*}{\rotatebox[origin=c]{90}{AQI-36}}
&\texttt{Mean} & 53.48 {\tiny  0.00} & 4578.08 {\tiny  00.00} & 76.77 {\tiny  0.00} & 53.48 {\tiny  0.00} & 4578.08 {\tiny  00.00} & 76.77 {\tiny  0.00}\\
&\texttt{KNN} & 30.21 {\tiny  0.00} & 2892.31 {\tiny  00.00} & 43.36 {\tiny  0.00} & 30.21 {\tiny  0.00} & 2892.31 {\tiny  00.00} & 43.36 {\tiny  0.00}\\
&\texttt{MF} & 30.54 {\tiny  0.26} & 2763.06 {\tiny  63.35} & 43.84 {\tiny  0.38} & \multicolumn{1}{c}{--} & \multicolumn{1}{c}{--} & \multicolumn{1}{c}{--}\\
&\texttt{MICE} & 29.89 {\tiny  0.11} & 2575.53 {\tiny  07.67} & 42.90 {\tiny  0.15} & 30.37 {\tiny  0.09} & 2594.06 {\tiny  07.17} & 43.59 {\tiny  0.13}\\
&\texttt{VAR} & 13.16 {\tiny  0.21} & 513.90 {\tiny  12.39} & 18.89 {\tiny  0.31} & 15.64 {\tiny  0.08} & 833.46 {\tiny  13.85} & 22.02 {\tiny  0.11} \\
&\texttt{rGAIN} & 12.23 {\tiny  0.17} & 393.76 {\tiny  12.66} & 17.55 {\tiny  0.25} & 15.37 {\tiny  0.26} & 641.92 {\tiny  33.89} & 21.63 {\tiny  0.36} \\
&\texttt{BRITS} & 12.24 {\tiny  0.26} & 495.94 {\tiny  43.56} & 17.57 {\tiny  0.38} & 14.50 {\tiny  0.35} & 662.36 {\tiny  65.16} & 20.41 {\tiny  0.50}\\


\cmidrule[0.3pt]{2-8}
&\texttt{MPGRU} & 12.46 {\tiny  0.35} & 517.21 {\tiny  41.02} & 17.88 {\tiny  0.50} & 16.79 {\tiny  0.52} & 1103.04 {\tiny  106.83} & 23.63 {\tiny  0.73} \\
&\texttt{\textbf{\GRIL}} & \textbf{10.51 {\tiny  0.28}} & \textbf{371.47 {\tiny  17.38}} & \textbf{15.09 {\tiny  0.40}} & \textbf{12.08 {\tiny  0.47}} & \textbf{523.14 {\tiny  57.17}} & \textbf{17.00 {\tiny  0.67}}\\ 

\midrule
\multirow{9}{*}{\rotatebox[origin=c]{90}{AQI}}
&\texttt{Mean} & 39.60 {\tiny  0.00} & 3231.04 {\tiny  00.00} & 59.25 {\tiny  0.00} & 39.60 {\tiny  0.00} & 3231.04 {\tiny  00.00} & 59.25 {\tiny  0.00}\\
&\texttt{KNN} & 34.10 {\tiny  0.00} & 3471.14 {\tiny  00.00} & 51.02 {\tiny  0.00} & 34.10 {\tiny  0.00} & 3471.14 {\tiny  00.00} & 51.02 {\tiny  0.00}\\
&\texttt{MF} & 26.74 {\tiny  0.24} & 2021.44 {\tiny  27.98} & 40.01 {\tiny  0.35} & \multicolumn{1}{c}{--} & \multicolumn{1}{c}{--} & \multicolumn{1}{c}{--}\\
&\texttt{MICE} & 26.39 {\tiny  0.13} & 1872.53 {\tiny  15.97} & 39.49 {\tiny  0.19} & 26.98 {\tiny  0.10} & 1930.92 {\tiny  10.08} & 40.37 {\tiny  0.15}\\
&\texttt{VAR} & 18.13 {\tiny  0.84} & 918.68 {\tiny  56.55} & 27.13 {\tiny  1.26} & 22.95 {\tiny  0.30} & 1402.84 {\tiny  52.63} & 33.99 {\tiny  0.44} \\
&\texttt{rGAIN} & 17.69 {\tiny  0.17} & 861.66 {\tiny  17.49} & 26.48 {\tiny  0.25} & 21.78 {\tiny  0.50} & 1274.93 {\tiny  60.28} & 32.26 {\tiny  0.75} \\
&\texttt{BRITS} & 17.24 {\tiny  0.13} & 924.34 {\tiny  18.26} & 25.79 {\tiny  0.20} & 20.21 {\tiny  0.22} & 1157.89 {\tiny  25.66} & 29.94 {\tiny  0.33}\\
\cmidrule[0.3pt]{2-8}
&\texttt{MPGRU} & 15.80 {\tiny  0.05} & 816.39 {\tiny  05.99} & 23.63 {\tiny  0.08} & 18.76 {\tiny  0.11} & 1194.35 {\tiny  15.23} & 27.79 {\tiny  0.16} \\
&\texttt{\textbf{\GRIL}} & \textbf{13.10 {\tiny  0.08}} & \textbf{615.80 {\tiny  10.09}} & \textbf{19.60 {\tiny  0.11}} & \textbf{14.73 {\tiny  0.15}} & \textbf{775.91 {\tiny  28.49}} & \textbf{21.82 {\tiny  0.23}}\\ 
\bottomrule
\end{tabular}}

\label{t:result_air}
\end{table} 
In this section, we empirically evaluate our approach against state-of-the-art baselines on four datasets coming from three relevant application domains. Our approach, remarkably, achieves state-of-the-art performance on all of them.
\begin{itemize}
    \item \textbf{Air Quality~(AQI)}: dataset of recordings of several air quality indices from 437 monitoring stations spread across 43 Chinese cities. We consider only the \texttt{PM2.5} pollutant. Prior works on imputation \citep{yi2016stmvl, cao2018brits} consider a reduced version of this dataset, including only 36 sensors (\textbf{AQI-36} in the following). We evaluate our model on both datasets. We use as adjacency matrix a thresholded Gaussian kernel~\citep{shuman2013emerging} computed from pairwise geographic distances.
    \item \textbf{Traffic}: we consider the \textbf{PEMS-BAY} and \textbf{METR-LA} datasets from~\citet{li2018diffusion}, containing data from traffic sensors from the San Francisco Bay Area and the Los Angeles County Highway. We use the same approach of \citet{li2018diffusion} and \citet{wu2019graph} to obtain an adjacency matrix.
    \item \textbf{Smart grids}: we consider data from the Irish Commission for Energy Regulation Smart Metering Project~(\textbf{CER-E};~\citealp{cer2016cer}). We select only the subset of the available smart meters monitoring the energy consumption of small and medium-sized enterprises (SMEs), i.e.,  time series with samples acquired every  minutes. We build an adjacency matrix by extracting a k-nearest neighbor graph~(with ) from the similarity matrix built by computing the correntropy~\citep{liu2007correntropy} among the time series.
\end{itemize}

For the air quality datasets, we adopt the same evaluation protocol of previous works~\citep{yi2016stmvl, cao2018brits} and we show results for both the in-sample and out-of-sample settings. For the traffic and energy consumption datasets, we consider only the out-of-sample scenario~(except for matrix factorization which only works in-sample). We simulate the presence of missing data by considering  different settings: 1) \textit{Block missing}, i.e, at each step, for each sensor, we randomly drop  of the available data and, in addition, we simulate a failure with probability  and sample its duration uniformly in the interval , where  and  are the number of time steps corresponding respectively to  and  hours in the traffic case and  hours and  days for CER-E; 2) \textit{Point missing}, i.e., we simply randomly mask out  of the available data. We split all the datasets into training/validation/test sets. We use as performance metrics the \emph{mean absolute error}~(MAE), \emph{mean squared error}~(MSE) and \emph{mean relative error}~(MRE;~\citealp{cao2018brits}) computed over the imputation window.
For all the experiments, we use as message-passing operator the diffusion convolution introduced by~\citet{atwood2016diffusion}. We consider \texttt{BRITS}~\citep{cao2018brits} as the principal competing alternative among non-adversarial deep autoregressive approaches, as it shares architectural similarities with our methods.  As additional baselines we consider: 1) \texttt{MEAN}, i.e., imputation using the node-level average; 2) \texttt{KNN}, i.e., imputation by averaging values of the  neighboring nodes with the highest weight in the adjacency matrix ; 3) \texttt{MICE}~\citep{white2011multiple}, limiting the maximum number of iterations to  and the number of nearest features to ; 4) Matrix Factorization~(\texttt{MF}) with ; 5) \texttt{VAR}, i.e., a \textit{Vector Autoregressive} one-step-ahead predictor; 6) \texttt{rGAIN}, i.e., an unsupervised version of SSGAN~\citep{miao2021generative} which can be seen as GAIN~\citep{yoon2018gain} with bidirectional recurrent encoder and decoder; 7) \texttt{MPGRU}, a one-step-ahead GNN-based predictor similar to DCRNN~\citep{li2018diffusion}. We provide further comment and in depth details on baselines and datasets, together with additional experiments on synthetic data in the appendix.

\begin{table}[t]
\vspace{-0.3cm}
\caption{Results on the traffic and smart grids datasets. Performance averaged over  runs.}
\vspace{0.1cm}
\centering
\begin{tabular}{c | l | r r r | r r r}
\toprule
 \multicolumn{2}{c}{}&\multicolumn{3}{c}{Block missing} & \multicolumn{3}{c}{Point missing} \\
\toprule
D & \multicolumn{1}{c|}{M} & \multicolumn{1}{c}{\small MAE} & \multicolumn{1}{c}{\small MSE} & \multicolumn{1}{c|}{\small MRE(\%)} & \multicolumn{1}{c}{\small MAE} & \multicolumn{1}{c}{\small MSE} & \multicolumn{1}{c}{\small MRE(\%)}\\
\midrule
\multirow{9}{*}{\rotatebox[origin=c]{90}{PEMS-BAY}}
&\texttt{Mean}  & 5.46 {\tiny  0.00} & 87.56 {\tiny  0.00} & 8.75 {\tiny  0.00} & 5.42 {\tiny  0.00} & 86.59 {\tiny  0.00} & 8.67 {\tiny  0.00}\\
&\texttt{KNN} & 4.30 {\tiny  0.00} & 49.90 {\tiny  0.00} & 6.90 {\tiny  0.00} & 4.30 {\tiny  0.00} & 49.80 {\tiny  0.00} & 6.88 {\tiny  0.00}\\
&\texttt{MF} & 3.28 {\tiny  0.01} & 50.14 {\tiny  0.13} & 5.26 {\tiny  0.01} & 3.29 {\tiny  0.01} & 51.39 {\tiny  0.64} & 5.27 {\tiny  0.02}\\
&\texttt{MICE}  & 2.94 {\tiny  0.02} & 28.28 {\tiny  0.37} & 4.71 {\tiny  0.03} & 3.09 {\tiny  0.02} & 31.43 {\tiny  0.41} & 4.95 {\tiny  0.02}\\
&\texttt{VAR} & 2.09 {\tiny  0.10} & 16.06 {\tiny  0.73} & 3.35 {\tiny  0.16} & 1.30 {\tiny  0.00} & 6.52 {\tiny  0.01} & 2.07 {\tiny  0.01}\\
&\texttt{rGAIN} & 2.18 {\tiny  0.01} & 13.96 {\tiny  0.20} & 3.50 {\tiny  0.02} & 1.88 {\tiny  0.02} & 10.37 {\tiny  0.20} & 3.01 {\tiny  0.04}\\
&\texttt{BRITS} & 1.70 {\tiny  0.01} & 10.50 {\tiny  0.07} & 2.72 {\tiny  0.01} & 1.47 {\tiny  0.00} & 7.94 {\tiny  0.03} & 2.36 {\tiny  0.00}\\
\cmidrule[0.3pt]{2-8}
&\texttt{MPGRU} & 1.59 {\tiny  0.00} & 14.19 {\tiny  0.11} & 2.56 {\tiny  0.01} & 1.11 {\tiny  0.00} & 7.59 {\tiny  0.02} & 1.77 {\tiny  0.00}\\
&\texttt{\textbf{\GRIL}} & \textbf{1.14 {\tiny  0.01}} & \textbf{6.60 {\tiny  0.10}} & \textbf{1.83 {\tiny  0.02}} & \textbf{0.67 {\tiny  0.00}} & \textbf{1.55 {\tiny  0.01}} & \textbf{1.08 {\tiny  0.00}}\\ 

\midrule
\multirow{9}{*}{\rotatebox[origin=c]{90}{METR-LA}}
&\texttt{Mean} & 7.48 {\tiny  0.00} & 139.54 {\tiny  0.00} & 12.96 {\tiny  0.00} & 7.56 {\tiny  0.00} & 142.22 {\tiny  0.00} & 13.10 {\tiny  0.00}\\
&\texttt{KNN} & 7.79 {\tiny  0.00} & 124.61 {\tiny  0.00} & 13.49 {\tiny  0.00} & 7.88 {\tiny  0.00} & 129.29 {\tiny  0.00} & 13.65 {\tiny  0.00}\\
&\texttt{MF} & 5.46 {\tiny  0.02} & 109.61 {\tiny  0.78} & 9.46 {\tiny  0.04} & 5.56 {\tiny  0.03} & 113.46 {\tiny  1.08} & 9.62 {\tiny  0.05}\\
&\texttt{MICE} & 4.22 {\tiny  0.05} & 51.07 {\tiny  1.25} & 7.31 {\tiny  0.09} & 4.42 {\tiny  0.07} & 55.07 {\tiny  1.46} & 7.65 {\tiny  0.12}\\
&\texttt{VAR} & 3.11 {\tiny  0.08} & 28.00 {\tiny  0.76} & 5.38 {\tiny  0.13} & 2.69 {\tiny  0.00} & 21.10 {\tiny  0.02} & 4.66 {\tiny  0.00}\\
&\texttt{rGAIN} & 2.90 {\tiny  0.01} & 21.67 {\tiny  0.15} & 5.02 {\tiny  0.02} & 2.83 {\tiny  0.01} & 20.03 {\tiny  0.09} & 4.91 {\tiny  0.01}\\
&\texttt{BRITS} & 2.34 {\tiny  0.01} & 17.00 {\tiny  0.14} & 4.05 {\tiny  0.01} & 2.34 {\tiny  0.00} & 16.46 {\tiny  0.05} & 4.05 {\tiny  0.00}\\
\cmidrule[0.3pt]{2-8}
&\texttt{MPGRU} & 2.57 {\tiny  0.01} & 25.15 {\tiny  0.17} & 4.44 {\tiny  0.01} & 2.44 {\tiny  0.00} & 22.17 {\tiny  0.03} & 4.22 {\tiny  0.00}\\
&\texttt{\textbf{\GRIL}} & \textbf{2.03 {\tiny  0.00}} & \textbf{13.26 {\tiny  0.05}} & \textbf{3.52 {\tiny  0.01}} & \textbf{1.91 {\tiny  0.00}} & \textbf{10.41 {\tiny  0.03}} & \textbf{3.30 {\tiny  0.00}}\\ 
\midrule

\multirow{9}{*}{\rotatebox[origin=c]{90}{CER-E}}
&\texttt{Mean} & 1.49 {\tiny  0.00} & 5.96 {\tiny  0.00} & 72.47 {\tiny  0.00} & 1.51 {\tiny  0.00} & 6.09 {\tiny  0.00} & 71.51 {\tiny  0.00}\\
&\texttt{KNN} & 1.15 {\tiny  0.00} & 6.53 {\tiny  0.00} & 56.11 {\tiny  0.00} & 1.22 {\tiny  0.00} & 7.23 {\tiny  0.00} & 57.71 {\tiny  0.00}\\
&\texttt{MF} & 0.97 {\tiny  0.01} & 4.38 {\tiny  0.06} & 47.20 {\tiny  0.31} & 1.01 {\tiny  0.01} & 4.65 {\tiny  0.07} & 47.87 {\tiny  0.36}\\
&\texttt{MICE} & 0.96 {\tiny  0.01} & 3.08 {\tiny  0.03} & 46.65 {\tiny  0.44} & 0.98 {\tiny  0.00} & 3.21 {\tiny  0.04} & 46.59 {\tiny  0.23}\\
&\texttt{VAR} & 0.64 {\tiny  0.03} & 1.75 {\tiny  0.06} & 31.21 {\tiny  1.60} & 0.53 {\tiny  0.00} & 1.26 {\tiny  0.00} & 24.94 {\tiny  0.02}\\
&\texttt{rGAIN} & 0.74 {\tiny  0.00} & 1.77 {\tiny  0.02} & 36.06 {\tiny  0.14} & 0.71 {\tiny  0.00} & 1.62 {\tiny  0.02} & 33.45 {\tiny  0.16}\\
&\texttt{BRITS} & 0.64 {\tiny  0.00} & 1.61 {\tiny  0.01} & 31.05 {\tiny  0.05} & 0.64 {\tiny  0.00} & 1.59 {\tiny  0.01} & 30.07 {\tiny  0.11}\\
\cmidrule[0.3pt]{2-8}
&\texttt{MPGRU} & 0.53 {\tiny  0.00} & 1.84 {\tiny  0.01} & 25.88 {\tiny  0.09} & 0.41 {\tiny  0.00} & 1.22 {\tiny  0.01} & 19.51 {\tiny  0.03}\\
&\texttt{\textbf{\GRIL}} & \textbf{0.42 {\tiny  0.00}} & \textbf{1.07 {\tiny  0.01}} & \textbf{20.24 {\tiny  0.04}} & \textbf{0.29 {\tiny  0.00}} & \textbf{0.53 {\tiny  0.00}} & \textbf{13.71 {\tiny  0.03}}\\ 
\bottomrule

\end{tabular}
\label{t:result_bp}
\end{table} 
\subsection{Results}
\label{s:results}

Empirical results show that \GRIL\ can achieve large improvements in imputation performance on several scenarios, as well as increased flexibility. In fact, differently from the other state-of-the-art baselines, \GRIL\ can handle input with a variable number of dimensions.
Tab.~\ref{t:result_air} shows the experimental results on the air quality datasets. In the in-sample settings, we compute metrics using as imputation the value obtained by averaging predictions over all the overlapping windows; in the out-of-sample settings, instead, we simply report results by averaging the \emph{error} over windows. \GRIL\ largely outperforms other baselines on both settings. In particular, in the latter case, \GRIL\ decreases MAE w.r.t. the closest baseline by more than  in AQI. Interestingly, \GRIL\ consistently outperforms BRITS in imputing missing values also for sensors corresponding to isolated~(disconnected) nodes, i.e., nodes corresponding to stations more than  km away from any other station~(see~\ref{a:air}): this is empirical evidence of the positive regularizations encoded into \GRIL. Our method achieves more accurate imputation also in the -dimensional dataset, where we could expect the graph representation to have a lower impact. 
Results for the traffic and smart grids datasets are shown in Tab.~\ref{t:result_bp}. In the traffic dataset, our method outperforms both BRITS and rGAIN by a wide margin in all the considered settings while using a much lower number of parameters (see~\ref{a:appendix_exp}). In the traffic datasets, on average, \GRIL\ reduces MAE by  w.r.t. BRITS and, in particular, in the Point missing setting of the PEMS-BAY dataset, the error is halved. In CER-E, \GRIL\ consistently outperforms other baselines. Besides showing the effectiveness of our approach in a relevant application field, this experiment also goes to show that \GRIL\ can be exploited in settings where relational information is not readily available. 
\begin{wraptable}{r}{0.5\textwidth}
\vspace{-0.6cm}
\caption{Ablation study. Averages over  runs.}
\vspace{0.1cm}
\centering
\resizebox{\linewidth}{!}{
\begin{tabular}{ l | r | r | r }
\toprule
 \multicolumn{1}{c}{Model}&\multicolumn{1}{|c}{AQI} & \multicolumn{1}{|c}{METR-LA} & \multicolumn{1}{|c}{CER-E} \\
\midrule
\texttt{\textbf{\GRIL}}  & \textbf{14.73} {\tiny  \textbf{0.15}} & \textbf{2.03 {\tiny  0.00}}& \textbf{0.29 {\tiny  0.00}}\\
\cmidrule[0.3pt]{1-4}
w/o sp. dec. & 15.40 {\tiny  0.14} & 2.32 {\tiny  0.01} & \textbf{0.29 {\tiny  0.00}}\\
w/ denoise dec.  & 17.23 {\tiny  1.12} & 2.96 {\tiny  0.18}& 0.32 {\tiny  0.00}\\
\texttt{MPGRU} & 18.76 {\tiny  0.11} & 2.57 {\tiny  0.01}& 0.41 {\tiny  0.00}\\
\bottomrule
\end{tabular}}
\label{t:ablation}
\vspace{-0.2cm}
\end{wraptable} Finally, Tab.~\ref{t:ablation} show results -- in terms of MAE -- of an ablation study on the out-of-sample scenario in AQI, METR-LA~(in the Block Missing settings), and CER-E~(Point Missing setting). In particular, we compare \GRIL\ against  baselines to assess the impact of the spatial decoder and of the bidirectional architecture. The first baseline is essentially a bidirectional MPGRU where values are imputed by a final MLP taking as inputs  and , while the second one has an analogous architecture, but uses hidden representation and time step  (for both directions) and, thus, behaves similarly to a denoising autoencoder. As reference, we report the results of the unidirectional MPGRU. Results show that the components we introduce do contribute to significantly reduce imputation error. It is clear that spatial decoding and the bidirectional architecture are important to obtain accurate missing data reconstruction, especially in realistic settings with blocks of missing data. Interestingly, the denoising model suffers in the Block missing scenario, while, as one might expect, works well in the Point Missing setting. For additional results and discussion about scalability issues, we refer to the appendix of the paper.


\subsection{Virtual sensing}

\begin{wrapfigure}{r}{0.5\linewidth}
  \centering
\vspace{-0.75cm}
\includegraphics[width=\linewidth]{imgs/virtual_sensor.pdf}
\vspace{-1.cm}
\caption{Reconstruction of observations from sensors removed from the training set. Plots show that \GRIL\ might be used for virtual sensing.}
\label{fig:vs}
\end{wrapfigure}

As a final experiment, we provide a quantitative and qualitative assessment of the proposed method in virtual sensing. The idea~(often studied in the context of \textit{kriging} -- see Section~\ref{s:related_works}) is to simulate the presence of a sensor by adding a node with no available data and, then, let the model reconstruct the corresponding time series. Note that for the approach to work several assumptions are needed: 1) we have to assume that the physical quantity being monitored can be reconstructed from observations at neighboring sensors; 2) we should assume a high-degree of homogeneity of sensors~(e.g., in the case of air quality stations we should assume that sensors are placed at the same height) or that the features characterizing each neighboring sensor~(e.g., placement) are available to the model. In this context, it is worth noting that, due to the inductive biases embedded in the model, \GRIL\ performs reconstruction not only by minimizing reconstruction error at the single node, but by regularizing the reconstructed value for imputation at neighboring sensors. We masked out observed values of the two nodes of AQI- with highest~(station no.\ ) and lowest~(no.\ ) connectivity, and trained \GRIL\ on the remaining part of the data as usual. Results, in Fig.~\ref{fig:vs}, qualitatively show that \GRIL\ can infer the trend and scale for unseen sensors. In terms of MAE, \GRIL\ scored  for sensor  and  for sensor ~(averages over  independent runs).

\section{Conclusions}\label{s:conclusion}

We presented \GRIL, a novel approach for MTSI exploiting modern graph neural networks. Our method imputes missing data by leveraging the relational information characterizing the underlying network of sensors and the functional dependencies among them. Compared against state-of-the-art baselines, our framework offers higher flexibility and achieves better reconstruction accuracy on all the considered scenarios. 
There are several possible directions for future works. From a theoretical perspective, it would be interesting to study the properties that would guarantee an accurate reconstruction. Furthermore, future work should study extensions able to deal with a non-stationary setting and further assess applications of \GRIL\ in virtual and active sensing. 





\clearpage

\subsubsection*{Reproducibility Statement}

Code to reproduce experiments presented in the paper is provided as supplementary material together with configuration files to replicate reported results. All datasets, except CER-E, are open and downloading links are provided in the supplementary material. The CER-E dataset can be obtained free of charge for research purposes (see appendix). For experiments where failures are simulated, we use random number generators with fixed seed for missing data generation to ensure reproducibility and consistency among experiments and baselines.  

\subsubsection*{Acknowledgments}

This research is funded by the Swiss National Science Foundation project 200021\_172671: ``ALPSFORT: A Learning graPh-baSed framework FOr cybeR-physical sysTems''. The authors wish to thank the Institute of Computational Science at USI for granting access to computational resources.




\bibliography{main}
\bibliographystyle{iclr2022_conference}

\clearpage
\appendix
\section*{Appendix}

\section{Detailed experimental settings}
\label{a:appendix_exp}

In this appendix, we give more details on the experimental settings used to evaluate our approach. 
We train all the models by sampling at random  batches of  elements for each epoch, we fix the maximum number of epochs to  and we use early stopping on the validation set with a patience of  epochs. All methods are trained using a  cosine learning rate scheduler with initial value of , decayed over the  training epochs. During training, we randomly mask out an additional  of the input data for each batch to foster robustness to noise and missing data.

For \GRIL\ we minimize the following loss function is

where each  is of the form of Eq.~\ref{eq:loss} and the element-wise error function is MAE. Note that here we are using  and  instead of  and .

For BRITS, we use the same network hyperparameters of \citet{cao2018brits} for the AQI-36 dataset. To account for the larger input dimension, for the other datasets we increase the number of hidden neurons in the RNNs cells to  for AQI/METR-LA and  for PEMS-BAY/CER-E. The number of neurons was tuned on the validation sets.
For rGAIN we use the same number of units in the cells of the bidirectional RNN used by BRITS, but we concatenate a random vector (sampled from a uniform distribution) of dimension  to the input vector in order to model the sampling of the data generating process. To obtain predictions, we average out the outputs of  forward passes.
For VAR we used an order of  and trained the model with SGD. Since the VAR model needs past 5 observations to predict the next step, we pad each sequence using the mean for each channel.  Here we used a batch size to  and a learning rate of . The order was selected with a small search in the range : we found out a window size of  to be ideal for all the considered datasets.
For \GRIL\ we use the same hyperparameters in all the datasets: a hidden dimension of  neurons for both the spatio-temporal encoder and the spatial decoder and of  neurons for the MLP. We use diffusion convolution as message-passing operation, with a diffusion step  in the spatio-temporal encoder and  in the temporal decoder. Note that, due to the architectural differences, the other neural network baselines have a number of parameters that is far higher than \GRIL\ (depending on the considered dataset, up to  against ). 
For MPGRU we use the same hyperparameters of \GRIL~( units for both the spatio-temporal encoder and the decoder).

For data processing we use the same steps of~\citet{li2018diffusion}, data are normalized across the feature dimension~(which means graph-wise for \GRIL\  and node-wise for BRITS/rGAIN/VAR). Data masked out for evaluation are never used to train any model.

All the models were developed in Python~\citep{rossum2009python} using the following open-source libraries:
\begin{itemize}
    \item PyTorch~\citep{paszke2019pytorch};
    \item \texttt{numpy}~\citep{harris2020array};
\item Neptune\footnote{\url{https://neptune.ai/}}~\citep{neptune2021neptune};
    \item \texttt{scikit-learn}~\citep{pedregosa2011scikit};
    \item \texttt{fancyimpute}~\citep{fancyimpute}.
\end{itemize}
The implementation of the diffusion convolutional operator was adapted from the Graph-WaveNet codebase~\footnote{\url{https://github.com/nnzhan/Graph-WaveNet}}. For the implementation of BRITS, we used the code provided by the authors\footnote{\url{https://github.com/caow13/BRITS}}. The code to reproduce the experiments of the paper is available online\footnote{\url{https://github.com/Graph-Machine-Learning-Group/grin}}.

\begin{table}[ht]
\caption{Statistics on adjacency matrices used in the experiments. Self loops are excluded.}
\vspace{0.1cm}
\centering
\begin{tabular}{ l | c c c | c c c}
\toprule
 \multicolumn{1}{c}{}&\multicolumn{3}{c}{\textsc{Graph}} & \multicolumn{3}{c}{\textsc{N. Neighbors}} \\
\midrule
\multicolumn{1}{c|}{Dataset} & type & nodes & edges & mean & median & isolated nodes\\
\midrule
AQI & undirected & 437 & 2699 & 12.35 & 9.0 & 14 \\
CER-E & directed & 485 & 4365 & 9.0 & 9.0 & 0 \\
PEMS-BAY & directed & 325 & 2369 & 7.29 & 7.0 & 12 \\
METR-LA & directed & 207 & 1515 & 7.32 & 7.0 & 5\\
\bottomrule
\end{tabular}
\label{t:adj}
\end{table} 
\section{Datasets}

In this appendix, we provide more details on the datasets that we used to run experiments. Tab.~\ref{t:adj} shows detailed statistics for graph structure associated with each dataset, while Fig.~\ref{fig:adjs} shows the corresponding adjacency matrices. Tab.~\ref{tab:missing} shows missing data statistics. In the following subsections, we go deeper into details for each dataset.

\begin{table}[ht]
\vspace{-0.2cm}
\caption{Statistics on missing data distribution. (P) and (B) indicate the Point Missing and Block Missing settings, respectively. With \emph{block}, we refer to missing data bursts longer than  time steps and shorter than or equal to .}
\vspace{0.1cm}
\centering  
\begin{adjustbox}{max width=\textwidth}
\begin{tabular}{ l  c |c c c | c c c}
\toprule
 \multicolumn{2}{c}{}&\multicolumn{3}{c}{\textsc{Original data}} & \multicolumn{3}{c}{\textsc{Injected faults}} \\
\midrule
\multicolumn{2}{c|}{D} & \% missing & avg. block & median block & \%  &avg. block & median block \\
\midrule
AQI & &25.67 & 6.69 & 4.0 & 10.67 & 7.59 & 4.0 \\
\midrule
AQI-36 & &13.24 & 7.24 & 4.0 & 11.33 & 6.52 & 4.0 \\
\midrule
PEMS-BAY & (P) & 0.02 & 12.0 & 12.0 & 25.0 & 3.33 & 3.0 \\
& (B) &  &  &  & 9.07 & 27.26 & 28.0 \\
\midrule
METR-LA & (P) & 8.10 & 12.44 & 9.0 & 23.00 & 3.33 & 3.0\\
& (B) &  &  &  & 8.4 & 25.68 & 26.0\\
\midrule
CER-E &(P) & 0.04 & 48.0 & 48.0 & 24.97 & 3.33 & 3.0 \\
&(B) &  &  &  & 8.38 & 22.45 & 21.0 \\
\bottomrule
\end{tabular}
\end{adjustbox}
\label{tab:missing}
\end{table} 
\subsection{Air quality} \label{a:air}

\begin{figure}
    \centering
    \includegraphics[width=\textwidth]{imgs/adjs.pdf}
    \caption{Adjacency matrices of the different datasets.}
    \label{fig:adjs}
\end{figure}

Air pollution is nowadays a ubiquitous problem. The Urban Computing project~\citep{zheng2014urban, zheng2015forecasting} published several datasets containing real measurements of different indices affecting human life in urban spaces. We consider as benchmark the dataset regarding the air quality index~(\emph{AQI}). The complete dataset contains hourly measurements of six pollutants from  air quality monitoring stations, spread over  cities in China, over a period of one year~(from May  to April ). Prior works on imputation~\citep{yi2016stmvl, cao2018brits} considered a reduced version of this dataset, including only  sensors~(\emph{AQI-36}). This dataset is particularly interesting as a benchmark for imputation due to the high rate of missing values~( in AQI and  in AQI-36). Along with~\citet{yi2016stmvl}, we consider as the test set the months of March, June, September and December. We consider both the in-sample and out-of-sample scenarios. In latter case, we do not consider windows overlapping with any of the test months. We use the same procedure of~\citet{yi2016stmvl} to simulate the presence of missing data for evaluation.

We select windows of data of length  for AQI and  for AQI-36~(in line with \citet{cao2018brits}). To evaluate the imputation performances, we mask out from the test set and use as ground-truth the value  if: (1) the value is not missing () and (2) the value is missing at the same hour and day in the following month.
Besides air quality readings, the dataset provides geographic coordinates of each monitoring station. To obtain an adjacency matrix from the geographic distances between nodes, we use a thresholded Gaussian kernel \citep{shuman2013emerging}: the weight  of the edge connecting -th and -th node is

where  is the geographical distance operator,  controls the width of the kernel and  is the threshold. We set  to the standard deviation of geographical distances in AQI-36 in both datasets. We set  so that it corresponds to a distance of  km.

\subsection{Traffic}

The study of traffic networks is key for the development of intelligent transportation systems and a relevant application field for network science. While previous works~\citep{yu2017spatio, li2018diffusion, wu2019graph, shang2020discrete} have assessed spatio-temporal deep learning methods for the traffic forecasting task, we focus on reconstruction. We use as benchmark the \emph{PEMS-BAY} and \emph{METR-LA} datasets from \citet{li2018diffusion}. PEMS-BAY contains  months of data from  traffic sensors in San Francisco Bay Area, while METR-LA contains  months of sensor readings from  detectors in the Los Angeles County Highway~\citep{jagadish2014big}; for both datasets, the sampling rate corresponds to  minutes.

We use input sequences of  steps, which correspond to  hours of data. For adjacency, we use a thresholded Gaussian kernel applied to geographic distances following previous works~\cite{wu2019graph}. We split the data into three folds, using  of them for training and the remaining  and  for validation and testing, respectively.

\subsection{Smart grids}

We consider data from the Irish Commission for Energy Regulation~(CER) Smart Metering Project\footnote{\url{https://www.ucd.ie/issda/data/commissionforenergyregulationcer}}. We select only the subset of the available smart meters monitoring energy consumption of small and medium-sized enterprises (SMEs), i.e.,  time series with samples acquired every  minutes. Note that access to dataset can be obtained free of charge for research purposes.

We build an adjacency matrix by extracting a k-nearest neighbor graph~(with ) from the similarity matrix built by computing the week-wise correntropy~\citep{liu2007correntropy} among time series. As in the traffic case, we use a  split for training, validation and testing and use a window size of  steps. Data were normalized using standard scaling as in the previous settings, and we did not perform additional preprocessing steps.

\section{Additional results}
\label{sec:appendix_exp}
In this appendix, we show an additional experiment in a controlled environment, comparison against additional baselines, additional ablation studies, and sensitivity analyses.

\subsection{Synthetic data}
\label{a:synthetic}
In this experiment, we test our method on the simulated particle system introduced by \citet{kipf2018neural}\footnote{\url{https://github.com/ethanfetaya/NRI}}. We simulate the trajectories of  particles in a  box with elastic collision. Each particle carries a either positive or negative charge . Two particles attract each other if they have opposite sign, otherwise they repel. Interaction forces between two particles are ruled by Coulomb's law. We collect two datasets, each containing  independent simulations of  steps each. In the first dataset, particles have the same charge in every simulation. In the second one, we sample the charges uniformly at random at the beginning of every simulation. In both scenarios, the initial location and velocity of the particles are drawn randomly.
At each step,  we randomly remove blocks of consecutive readings with a probability  and a length sampled uniformly from the interval . Here, a reading consists of the  coordinates of the particle's position. We further mask out  of positions at random. The percentage of values not masked out is .
For evaluation purposes, we generate another mask using the same missing data distribution and use the masked values as ground-truth for evaluation. We split dataset in training/validation/test folds using  splits, respectively.

\begin{table}[ht]
\vspace{-0.2cm}
\caption{Results on the synthetic datasets. Performance averaged over  runs.}
\vspace{0.1cm}
\centering
\begin{tabular}{ l | r | r | r | r }
\toprule
 \multicolumn{1}{c}{} &\multicolumn{2}{c}{Fixed charge} & \multicolumn{2}{c}{Varying charge} \\
\toprule
 \multicolumn{1}{c}{Model}&\multicolumn{1}{|c}{\small MAE} & \multicolumn{1}{|c}{\small MSE} & \multicolumn{1}{|c}{\small MAE} & \multicolumn{1}{|c}{\small MSE} \\
\midrule
\texttt{BRITS} & 0.1203 {\tiny  0.0003} & 0.0878 {\tiny  0.0002} & 0.1089 {\tiny  0.0007} & 0.0840 {\tiny  0.0001}\\
\midrule[0.3pt]
\texttt{\textbf{\GRIL}} & \textbf{0.0500 {\tiny  0.0055}} & \textbf{0.0061 {\tiny  0.0010}} & \textbf{0.0530 {\tiny  0.0092}} & \textbf{0.0074 {\tiny  0.0033}}\\
\midrule
\midrule
Improv. &  &  &  & \\
\bottomrule
\end{tabular}
\label{t:synthetic}
\end{table} 
We test our method (\GRIL) and BRITS in both synthetic datasets. We use  units for the hidden layer of BRITS ( parameters) and 16 units for both the encoder and decoder of \GRIL~( parameters). Results are reported in Tab.~\ref{t:synthetic}. Both the methods take as input only the particles' positions, with no information about the charges. As can be seen, consistently with what observed by~\citet{kipf2018neural}, relational representations are impressively effective in this scenario. Our method outperforms the baseline by more than an order of magnitude in terms of MSE. Surprisingly, BRITS is more accurate in the setting with varying charge. Our hypothesis is that the added stochasticity acts as a regularization and forces BRITS to learn a more general model.

\subsection{Empirical comparison against matrix factorization with side information}

\begin{table}[h]
\vspace{-0.2cm}
\caption{Comparison of regularized matrix factorization methods on air quality datasets. Results averaged over 5 independent runs.}
\vspace{0.1cm}
\centering
\begin{adjustbox}{max width=\textwidth}
\begin{tabular}{ l | r  r  r | r  r r }
\toprule
 \multicolumn{1}{c}{} &\multicolumn{3}{c}{AQI-36} & \multicolumn{3}{c}{AQI} \\
\toprule
 \multicolumn{1}{c}{Model}&\multicolumn{1}{|c}{\small MAE} & \multicolumn{1}{c}{\small MSE}  & \multicolumn{1}{c}{\small MRE~(\%)} & \multicolumn{1}{|c}{\small MAE} & \multicolumn{1}{c}{\small MSE} & \multicolumn{1}{c}{\small MRE~(\%)}\\
\midrule
\texttt{MF} & 30.54 {\tiny  0.26} & 2763.06 {\tiny  63.35} & 43.84 {\tiny  0.38} & 26.74 {\tiny  0.24} & 2021.44 {\tiny  27.98} & 40.01 {\tiny  0.35}\\
\texttt{GRMF} & 19.29 {\tiny  0.39} & 1054.48 {\tiny  40.79} & 27.68 {\tiny  0.56} & 26.38 {\tiny  0.32} & 2031.21 {\tiny  72.10} & 39.48 {\tiny  0.48}\\
\texttt{TRMF} & 15.97 {\tiny  0.14} & 1178.65 {\tiny  60.14} & 22.92 {\tiny  0.20} & 21.86 {\tiny  0.28} & 1516.81 {\tiny  45.53} & 32.71 {\tiny  0.42}\\
\midrule[0.3pt]
\texttt{\textbf{\GRIL}} & \textbf{10.51 {\tiny  0.28}} & \textbf{371.47 {\tiny  17.38}} & \textbf{15.09 {\tiny  0.40}} & \textbf{13.10 {\tiny  0.08}} & \textbf{615.80 {\tiny  10.09}} & \textbf{19.60 {\tiny  0.11}}\\
\bottomrule
\end{tabular}
\end{adjustbox}
\label{t:grmf}
\end{table} 
As mentioned in Section~\ref{s:related_works}, several matrix factorization approaches -- often studied in the context of recommender systems -- can be regularized by considering priors on the spatio-temporal structure of the data. Intuitively, spatial regularization is achieved by imposing soft constraints on the smoothness of the interpolated function w.r.t. nodes of an underlying graph~\citep{cai2010graph, rao2015collaborative}. Temporal regularization can be obtained by imposing analogous constraints modelling temporal dependencies as -- eventually weighted -- edges of a graph. In temporal regularized matrix factorization~(TRMF;~\citealp{yu2016temporal}), similarly, coefficients of an autoregressive model are used as temporal regularizer. 

Tab.~\ref{t:grmf} shows a comparison of different matrix factorization approaches on imputation in the air quality datasets~(where we considered the in-sample setting in Section~\ref{s:experiments}). For TRMF we used an implementation adapted from the Transdim repository\footnote{\url{https://github.com/xinychen/transdim}}, while for graph regularized matrix factorization~(GMRF) we use a custom implementation of the method proposed by~\citet{cai2010graph}. We fixed the rank to be equal to ~(as the one used in all the experiments for standard MF) and tuned the regularization coefficients on a validation set. Results do show that introducing spatial and temporal regularization improve w.r.t. vanilla MF; however, deep learning methods -- and even linear VAR predictors -- achieve far superior reconstruction accuracy here. Arguably, low-rank approximation methods might instead have an edge in a low-data regime: this type of analysis is, however, out of the scope of this work.

\subsection{Scalability}

With reference to a standard bidirectional GRU, using MPNNs to implement the cell's gates increases the computational complexity by a factor that scales with the number of edges  -- if using an efficient sparse implementation -- or with the number of nodes squared . Luckily, this overhead can be amortized as most of the computation can be parallelized. Research on scalable and memory efficient GNNs is a very active field~(e.g., \citealp{hamilton2017inductive, frasca2021sign}): depending on the task, the designer can opt for massage passing operators that meet the application requirements in terms of performance, time and space constraints.

\subsection{Ablation study}

Here we provide two different ablation studies, the first one on the architecture of \GRIL\ and the second one on the graph structure.

\subsubsection{Architectural ablations}
\label{a:ablation}
Tab.~\ref{t:ablation_full} shows additional results for the ablation study presented in Section~\ref{s:experiments}. Consistently with what we already observed, the spatial decoder and bidirectional architecture improve performance and appear particularly relevant in settings with blocks of missing data.
\begin{table}[ht]
\vspace{-0.2cm}
\caption{Ablation study. MAE averaged over  runs. (P) and (B) indicate the Point Missing and Block Missing settings, respectively.}
\vspace{0.1cm}
\centering
\begin{tabular}{ l | r | r | r | r | r }
\toprule
 \multicolumn{1}{c}{Model}&\multicolumn{1}{|c}{AQI} & \multicolumn{1}{|c}{METR-LA (B)} & \multicolumn{1}{|c}{METR-LA (P)} & \multicolumn{1}{|c}{CER-E (B)} & \multicolumn{1}{|c}{CER-E (P)} \\
\midrule
\texttt{\textbf{\GRIL}}  & \textbf{14.73} {\tiny  \textbf{0.15}} & \textbf{2.03 {\tiny  0.00}} & \textbf{1.91 {\tiny  0.00}} & \textbf{0.42 {\tiny  0.00}} & \textbf{0.29 {\tiny  0.00}}\\
\midrule[0.3pt]
w/o sp. dec. & 15.40 {\tiny  0.14} & 2.32 {\tiny  0.01} & 2.01 {\tiny  0.00} & 0.49 {\tiny  0.00} & \textbf{0.29 {\tiny  0.00}}\\
w/ denoise dec. & 17.23 {\tiny  1.12} & 2.96 {\tiny  0.18} & 2.09 {\tiny  0.02} & 0.61 {\tiny  0.02} & 0.32 {\tiny  0.00}\\
\texttt{MPGRU} & 18.76 {\tiny  0.11} & 2.57 {\tiny  0.01} & 2.44 {\tiny  0.00} & 0.53 {\tiny  0.00} & 0.41 {\tiny  0.00}\\
\bottomrule
\end{tabular}
\label{t:ablation_full}
\end{table} 
\subsubsection{Graph structure ablations}

Here we study how exploiting the relational structure of the problem affects the accuracy of the reconstruction. In particular, we run two additional experiments on the METR-LA dataset~(Block missing settings), where instead of using as adjacency matrix the thresholded kernel in Eq.~\ref{eq:kernel}, we use (1) a fully connected graph~() and (2) a graph with no edges~(). To provide node -- i.e., sensor -- identification, we use learnable embeddings as additional node features. Results are shown in Tab.~\ref{t:graph_ablation}, performance for BRITS are reported as reference. It is clear that the constraints posed by the graph structure do have an impact on the accuracy of missing data imputation and, at the same time, that spatial information is relevant for the task.

\begin{table}[ht]
\vspace{-0.2cm}
\caption{Performance with  different adjacency matrices. Results averaged over  runs. (B) indicates the Block Missing setting.}
\vspace{0.1cm}
\centering
\begin{tabular}{ l | r | r | r }
\toprule
\multicolumn{1}{c}{} & \multicolumn{3}{c}{METR-LA (B)}\\
\midrule
 \multicolumn{1}{c}{Method}&\multicolumn{1}{|c}{MAE} & \multicolumn{1}{|c}{MSE} & \multicolumn{1}{|c}{MRE~(\%)} \\
\midrule
\texttt{\textbf{\GRIL}}  & \textbf{2.03 {\tiny  0.00}} & \textbf{13.26 {\tiny  0.05}} & \textbf{3.52 {\tiny  0.01}} \\
\midrule[0.3pt]
fully connected & 2.63 {\tiny  0.01} & 27.37 {\tiny  0.38} & 4.56 {\tiny  0.02}\\
no edges & 3.42 {\tiny  0.04} & 51.68 {\tiny  0.71} & 5.93 {\tiny  0.08}\\
\midrule

\texttt{BRITS} & 2.34 {\tiny  0.01} & 17.00 {\tiny  0.14} & 4.05 {\tiny  0.01}\\
\bottomrule
\end{tabular}
\label{t:graph_ablation}
\end{table} 
\subsection{Sensitivity analysis}

Finally, in this subsection we carry out an assessment of performance degradation w.r.t. the amount of missing data. Before discussing results, there are a few remarks that are worth bringing up regarding imputation in highly sparse settings. In the first place, \GRIL, as well as a large portion of the state-of-the-art baselines, is an autoregressive model, which means that it might be subject to error accumulation over long time horizons. Furthermore, here, consistently with Section~\ref{s:experiments}, we consider the out-of-sample setting which is particularly challenging in the sparse data regime. That being said, \GRIL\  achieves remarkable performance also in this benchmark.

We train one model each for \GRIL\ and BRITS by randomly masking out  of input data for each batch during training, then, we run the models on the test set by using evaluation masks with increasing sparsity~(note that this causes a distribution shift in evaluation). For each level of sparsity, evaluation is repeated  times by sampling different evaluation masks. Results are reported in Tab.~\ref{t:sensitivity} and Fig.~\ref{fig:sensitivy} shows that \GRIL\ outperforms BRITS in all the considered scenarios.

\begin{table}[ht]
\vspace{-0.2cm}
\caption{Performance with  different amounts of missing data. Results averaged over  different evaluation masks in the out-sample setting. (P) indicates the Point Missing setting.}
\vspace{0.1cm}
\centering
\resizebox{\textwidth}{!}{\begin{tabular}{ l | c | c | c | c | c | c | c | c | c}
\toprule
\multicolumn{10}{c}{METR-LA (P)}\\
\midrule
 \multicolumn{1}{c|}{\% Missing} & 10 & 20 & 30 & 40 & 50 & 60 & 70 & 80 & 90 \\
\midrule
\texttt{\textbf{\GRIL}} & \textbf{1.87 {\tiny  0.01}} & \textbf{1.90 {\tiny  0.00}} & \textbf{1.94 {\tiny  0.00}} & \textbf{1.98 {\tiny  0.00}} & \textbf{2.04 {\tiny  0.00}} & \textbf{2.11 {\tiny  0.00}} & \textbf{2.22 {\tiny  0.00}} & \textbf{2.40 {\tiny  0.00}} & \textbf{2.84 {\tiny  0.00}}\\
\texttt{BRITS} & 2.32 {\tiny  0.01} & 2.34 {\tiny  0.00} & 2.36 {\tiny  0.00} & 2.40 {\tiny  0.00} & 2.47 {\tiny  0.00} & 2.57 {\tiny  0.01} & 2.76 {\tiny  0.00} & 3.08 {\tiny  0.00} & 4.02 {\tiny  0.01}\\
\bottomrule
\end{tabular}}
\label{t:sensitivity}
\end{table} 
\begin{figure}[!h]
    \centering
    \includegraphics[width=0.65\textwidth]{imgs/sensitivity_.pdf}
    \caption{The plot shows graphically the results in Tab.~\ref{t:sensitivity}.}
    \label{fig:sensitivy}
\end{figure}

\end{document}