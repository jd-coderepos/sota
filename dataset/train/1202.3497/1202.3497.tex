\documentclass[submission]{eptcs}
\providecommand{\event}{Fics 2012} \usepackage{amssymb}
\usepackage{amsmath}
\usepackage{graphics}
\newcommand{\sqlt}{\sqsubseteq}
\newcommand{\sqgt}{\sqsupseteq}
\DeclareMathOperator{\fix}{\mu}
\DeclareMathOperator{\Fix}{\nu}
\newcommand{\ioi}{\Leftrightarrow}
\newcommand{\wder}[1]{\ensuremath{\stackrel{#1}{\Longrightarrow}}}
\newcommand{\der}[1]{\ensuremath{\stackrel{#1}{\longrightarrow}}}
\newcommand{\sder}[1]{\ensuremath{\stackrel{#1}{\rightarrow}}}
\newcommand{\dder}[1]{\ensuremath{\stackrel{#1}{\Rightarrow}}}
\newcommand{\ind}[1]{\ensuremath{\stackrel{#1}{\cdots}}}
\newcommand{\divg}{\uparrow}
\newcommand{\conv}{\downarrow}
\newcommand{\res}[1]{\restriction_{#1}}
\newcommand{\pconv}{\downarrow}
\newcommand{\fun}{\rightarrow}
\newcommand{\bisim}{\leftrightarrow}
\newcommand{\ol}[1]{\overline{ #1}}
\newcommand{\Act}{{\bf A}}
\newcommand{\Proc}{{\bf P}}
\newcommand{\Psys}{P}
\newcommand{\F}{{\cal F}}
\newcommand{\V}{{\cal V}}
\newcommand{\G}{{\cal G}}
\newcommand{\U}{{\cal U}} 
\newcommand{\Po}{{\cal P}}
\newcommand{\M}{{\cal M}}
\newcommand{\X}{{\cal X}}
\newcommand{\Lo}{{\cal L}}
\newcommand{\loof}[1]{\Lo({#1})}
\newcommand{\bools}{\ensuremath{\mathbb{B}}}
\newcommand{\setbr}[1]{\{{#1}\}} \newcommand{\logand}{\wedge}
\newcommand{\succr}[1]{{#1} + 1}
\newcommand{\succcard}[1]{{#1}^{+}}
\newcommand{\logor}{\vee} 
\newcommand\ff{f\!\!f} 
\newcommand\tr{t\!t}
\newcommand\lb {[\![}
\newcommand\rb{]\!]}
\newcommand{\lan}{\langle}
\newcommand{\ran}{\rangle}
\newcommand{\modelsp}{\models}
\newcommand{\must}[1]{[ #1 ]}
\newcommand{\may}[1]{\langle #1 \rangle}
\newcommand{\dmust}[1]{[[ #1 ]]}
\newcommand{\dmay}[1]{\langle\langle #1 \rangle \rangle}
\newcommand{\smay}[1]{\langle\cdot #1 \cdot\rangle}
\newcommand{\smust}[1]{[ \cdot #1 \cdot ]}
\newcommand{\sem}[1]{\relax\ifmmode \lb #1 \rb \else  \fi}
\newcommand{\semp}{\sem}
\newcommand{\sempf}[1]{\semp{#1}^*}
\newcommand{\casedef}[4]{\left\{ \begin{array}{lcl}
                        #1 &\mbox{for}& #2\\ 
                        #3 & \mbox{for} & #4 .  
                        \end{array}\right.}





\newtheorem{theorem}{Theorem}[section]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{definition}[theorem]{Definition}

\newenvironment{proof}[1][Proof]{\begin{trivlist}
\item[\hskip \labelsep {\bfseries #1}]}{\end{trivlist}}
\newenvironment{example}[1][Example]{\begin{trivlist}
\item[\hskip \labelsep {\bfseries #1}]}{\end{trivlist}}
\newenvironment{remark}[1][Remark]{\begin{trivlist}
\item[\hskip \labelsep {\bfseries #1}]}{\end{trivlist}}


\title{Characteristic Formulae for Relations with Nested Fixed
  Points\thanks{Supported by the project Processes and Modal Logics'
    (project nr.~100048021) of the Icelandic Research Fund.} }
\author{Luca Aceto\quad Anna Ing\'olfsd\'ottir\thanks{Supported by the
    VELUX visiting professorship funded by the VILLUM FOUNDATION.}
  \institute{ICE-TCS, School of Computer Science\\Reykjavik University \\
    Reykjavik, Iceland} \email{\quad luca,annai@ru.is}}

\def\titlerunning{Fixed points}

\def\authorrunning{Aceto \&
    Ing\'olfsd\'ottir}
\begin{document}
\maketitle
\begin{abstract}
  A general framework for the connection between characteristic
  formulae and behavioral semantics is described in
  \cite{AILS2011}. This approach does not suitably cover semantics
  defined by nested fixed points, such as the -nested simulation
  semantics for  greater than . In this study we address this
  deficiency and give a description of nested fixed points that
  extends the approach for single fixed points in an intuitive and
  comprehensive way.
\end{abstract}          

\section{Introduction}
In process theory it has become a standard practice to describe
behavioural semantics in terms of equivalences or preorders. A wealth
of such relations has been classified by van Glabbeek in his linear
time/branching time spectrum~\cite{vG2001}. Branching-time behavioural
semantics are often defined as largest fixed points of monotonic
functions over the complete lattice of binary relations over
processes.

In \cite{AILS2011} we give a general framework to reason about how
this type of behavioral semantics can be characterized by a modal
logic equipped with a greatest fixed point operator, or more precisely
by characteristic formulae expressed in such a logic. In that
reference we show that a behavioural relation that is derived as a
greatest fixed point of a function of relations over processes is
given by the greatest fixed point of the semantic interpretation of a
logical declaration that expresses the function in a formal sense that
is defined in present paper.  Roughly speaking if a logical
declaration describes a monotonic function over a complete lattice
then its fixed point describes exactly the fixed point of the
function. In \cite{AILS2011} preorders and equivalences such as simulation preorder
and bisimulation equivalence are characterized following this approach
in a simple and constructive way. However, when the definition of a
behavioural relation involves nested fixed points, i.~e.~when the
monotonic function that defines the relation takes another fixed point
as an argument, things get more complicated.  The framework offered in
\cite{AILS2011} only deals with nesting on two levels and in a rather
clumsy and unintuitive way. Furthermore it does not extend naturally
to deeper nesting, like for the -nested simulations for . In
this study we address this deficiency and define a logical framework
in which relations obtained as a chain of nested fixed points of
monotonic functions can be characterized following general
principles. This extends the approach for single fixed points in an
intuitive and comprehensive way.

As the applications we present in the paper only deal with nesting of
greatest fixed points, this study only focuses on greatest fixed
points. However it is straightforward to extend it to deal with
alternating nesting of both least and greatest fixed points.  We also
believe that our approach gives some idea about how fixed point
theories in different domains can be compared in a structured way.

The remainder of the paper is organized as follows. Section~2 presents
some background on fixed points of monotone functions. Section~3
briefly introduces the model of labelled transition systems and some
results on behavioural relations defined as greatest fixed points of
monotonic functions over binary relations. The logic we shall use to
define characteristic formulae in a uniform fashion is discussed in
Section~4. The key notion of a declaration expressing a monotone
function is also given in that section. Section~5 is devoted to an
application of our framework to the logical characterization of the
family of nested simulation semantics.


\section{Posets, monotone functions and fixed points}
In this section we introduce some basic concepts we need in the paper.
\begin{definition}\quad
\begin{itemize}
\item 
  A \emph{partially ordered set}, or \emph{poset}, 
  (usually referred to simply as ) consists of a set  and a
  partial order  over it. 
\item If  is a poset and , then  is an
  \emph{upper bound} for  if  for all .  is a
  \emph{least upper bound} (lub) for  if it is an upper bound for
   and if whenever  is an upper bound for  then .
\item A poset  is a \emph{complete lattice} if the 
  for  exists for all .
\item For posets  and , a function  is
  monotone if it is order preserving; it is an \emph{isomorphism} if it is
  bijective and both  and its inverse  are monotone.
  We let  denote the set of monotone functions from  to
  .
\item If  is a poset and , then  is a fixed
  point of  if .  We write  (or ) for
  the greatest fixed point  of  if it exists.
\item If  and  are posets,  and  is an isomorphism then we define  as
  .
\end{itemize}
\end{definition}
Note that the  of a subset of a poset  is unique if it exists
and the same holds for greatest fixed points of monotone functions over
posets. It is well known, that if  and  are posets/complete lattices
and  is some set, then the Cartesian product  and the
function space  are a posets/complete lattices under the
pointwise ordering. The following theorem is due to Tarski.
\begin{theorem}[\cite{Ta55}]\label{tarski}
  If  is a complete lattice and , then  has
  a unique greatest fixed point.
\end{theorem}
The theorem below is proved in \cite{AILS2011} and is the key to the
general theory we present in this paper.
\begin{theorem} \label{thm:isomorph}Let  and  be posets,  and  be an isomorphism. Then 
  exists iff  exists. If these fixed points exist then
  .  
\iffalse
\item If  then
  .

\item   is an isomorphism.
\item If  then 
  is well-defined for fixed  and  is in  for 
  and .
\item If   and  are posets,  and , then 
 and .\fi
\end{theorem}
\iffalse
\begin{corollary}
  If  and  then 
  .
\end{corollary}
\fi
\section{Labelled transition systems and behavioural relations}\label{sec:LTS}
It has become standard practice to describe behavioural semantics of
processes by means of a \emph{labelled transition system} as defined
below.  
 \begin{definition}[\cite{Ke76}]
   A \emph{labelled transition system (LTS)} is a triple
    where
   \begin{itemize}
   \item  is a finite set (of actions),
  \item  is a finite set (of processes), and
  \item  is a transition relation.
  \end{itemize}
\end{definition}
As usual, we write  for . Throughout
this paper we assume that the set  is fixed.

As LTSs are in general to concrete, processes are compared by
preorders or equivalences. These are often obtained as the greatest
fixed points to monotone endofunctions on the complete lattice
. We will show some example of such functions
but first we state and  prove some properties.
\begin{definition}
  If 
  and , we define
\begin{itemize}
\item
, and 
\item
.
\end{itemize}
\end{definition}
The following lemma  will be applied below.
\begin{lemma} \label{L:inverse} Let  and .  Then 
\begin{itemize}
\item
,
\item
 and
\item .
\end{itemize}
\end{lemma}
\begin{proof}
  The first two statements are proved in \cite{AILS2011}. To prove the third
  one we proceed follows:

\end{proof}
We will complete this section by giving some examples of endofunction that
define some standard behavioural preorders and equivalences
\cite{vG2001,AILS2007}.
\begin{definition}
  Let  be
  defined as follows: 

\end{definition}
It is easy to check that  is monotonic and therefore it has a
greatest fixed point.
\begin{definition}
We define:
\begin{itemize}
\item  and  (simulation
  preorder),
\item  and  (inverse
  simulation preorder),
\item  (simulation equivalence) and
\item  and
   (bisimulation equivalence).
\end{itemize}
\end{definition}
\section{Equational modal -calculi with nested fixed-points}
\label{sect:hennmil}
In this section we introduce variants of the standard equational modal
-calculus \cite{Koz83}. Like in \cite{Larsen1990} these variants
only allow for nested fixed points, i.~e.~where the logical languages
form a hierarchy where fixed points in a language on one level are
allowed as constants in the logic on the level above. Our approach,
however, differs from the original one in the sense that the
fixed-point operator is explicit in the syntax and can therefore be
used in logical expressions. In this study we only focus on greatest
fixed points (which explains the title of this section) but the
framework can easily be extended to involve nesting of both greatest
and least fixed points. The logical languages we introduce depend on
the implicitly assumed fixed finite set .

Our basic logic  is the standard Hennessy-Milner Logic (HML)
\cite{HM85} without variables.  This logic is generated by
 where 
are the constants or the operators of arity ,
 are the operators of arity
, and  are the operators of arity
.

The formulae in  are interpreted over an LTS  as the set of elements from  that satisfy
them. Satisfaction is determined by a semantic function that is
defined below.  For  we let
, and  where  is the
complement of the set .
\begin{definition}\label{def:semp}\quad
The semantic function   is defined as follows:
\begin{enumerate}
\item ,
\item
  ,
\item
  .
\end{enumerate}
\end{definition}
The logic  is the standard Hennessy-Milner logic with variables
that was introduced in \cite{Larsen1990}. It assumes a finite index
set  and an -indexed set of variables . In what remains of
this paper we assume a fixed pair of such  and , unless stated
otherwise.

As the elements of  typically contain variables, they have to
be interpreted with respect to a variable \emph{interpretation}
 that associates to each  the set of
processes in  that are assumed to satisfy the variable .
The semantic function  in this case takes a formula
 and a  and delivers an element of
.
\begin{definition}\label{def:V}
The semantic function  is defined as follows:
\begin{enumerate}
\item  if ,
\item 
  , ,
\item ,
\item
  . 
\end{enumerate}
\end{definition}
In \cite{Larsen1990} the meaning of the variables in the logic  is
defined by means of a declaration, or a function
. Intuitively the syntactic function generates a monotonic
endofunction  over  defined by
 for all . By Theorem
\ref{tarski},  has a unique largest fixed point
 that can be used to give the semantics
for the variables and the formulae that contain those in the logic
.  We can then use this to extend the logic  with  as constants  interpreted as
. By this we get a logic  that is
generated by . Then this procedure can be repeated for another
declaration that possibly depends on  as a constant and with
 as the basic logic. The following example shows how this
construction works.
\begin{example}
  Let ,  and  and let the property
  ``invariantly '' be defined as the greatest fixed point
  corresponding to the declaration  defined as
  .  To interpret
  this we define  and  where  and  have the
  meaning described above.  The derived semantic function
   is easily
  shown to be monotonic and has the greatest fixed point
  . Now we define  as the
  extension of  that is generated by , i.e. has  as a constant that is
  interpreted as , i.e.~.

  Next let us assume that we have the declaration
   where  is the variable logic generated
  by  and  is
  defined as  . As before
  the declaration is interpreted over  but using
   to interpret the constant . Again
   is interpreted by using  which leads to a
  monotonic endofunction  over 
  with a fixed point . The logic  is now
  defined as the one generated by  where  and
   are used to define the meaning of 
  and  respectively.
\end{example}
We will now generalize this procedure and define our hierarchy of
nested fixed point logics, derived from a sequence of nested
declarations , i.e. where for each ,
 is allowed to depend on the constants  and  for  and . In the definition we assume a
finite index set  and an -indexed variable set .  We use the
notation  for the logic generated by
 and  for the logic
generated by .

\begin{definition}\quad \begin{itemize}
\item Define 
\begin{itemize}
\item
, 
\item  and
\item .
\end{itemize}
\item For , if , define
\begin{itemize}
 \item ,
\item  and
\item .
\end{itemize}
\end{itemize}
\end{definition}


To define the semantic functions associated with these logics we need the
following lemma.
\begin{lemma}\label{L:logic}\quad
  Assume that  and  for some set
  of constants  where  is well defined for
  all .  Then for all , the derived semantic
  function  defined by

 is in  and hence, by Theorem
 \ref{tarski}, 
 exists.
\end{lemma}

Now we are ready to define the semantic functions
for  and  for all .
\begin{definition}\quad
\begin{itemize}
\item  and  as defined in Definition
  \ref{def:semp} and \ref{def:V} respectively.

\item For  the semantic functions for  is  defined as follows:
\begin{enumerate}
\item 
 if ,
\item
 for ,
\item
  ,
\item
  .
\end{enumerate}
\item For  the semantic function for  is defined as follows:
\begin{enumerate}
\item  if ,
\item 
  , ,
\item ,
\item
  . 
\end{enumerate}
\end{itemize}

\end{definition}
\iffalse
\begin{definition}\quad
  Given a finite index set  and a sequence of nested declarations
   we define
\begin{itemize}
  
\item  and 
\item  if  for
  .
\end{itemize}
Sometimes we write  in stead of  if the
meaning is clear from the context.
\end{definition}\fi



\subsection{Characteristic Formulae by means of
  Declarations}\label{sect:chargfp}
The aim of this section is to show how each process 
can be characterized up to a binary relation  over processes (such
as an equivalence or a preorder) by a single formula, the so called
characteristic formula for  up to .  

To achieve this, we take  in the definitions in the
previous section.  A declaration  for a variable logic 
assigns exactly one formula  from  to each process
.  We have seen that each such function induces an
endofunction
 and
therefore  exists. This leads to the following
definition:

\begin{definition}\label{D:char}
  A declaration  for the logic  characterizes
   iff for each ,

\end{definition}
\iffalse In our examples, we seek declarations that characterize a
relation, such as similarity or bisimilarity, which is of the form
, where  is a monotone endofunction on . \fi In what follows, we will describe how we can devise a
characterizing declaration for a relation that is obtained as a fixed
point, or a sequence of nested fixed points of monotone
endofunctions, which can be expressed in the logic.  In order to define
this precisely we use the notation introduced in Definition
\ref{Def:sigmaS} below.
\begin{definition}\label{Def:sigmaS}
If  we define the variable interpretation
 associated to  by

\end{definition}
Thus  assigns to  all those processes  that are related to it
via .
\begin{definition} \label{def:express} A declaration  for 
  \emph{expresses} a monotone endofunction  on  when

   for every relation  and every
   .
\end{definition}
We need the following to prove our main result.
\begin{definition}\label{def:isophi}
Let  be defined by
. 
\end{definition}
\begin{lemma}\label{L:x}\quad
\begin{itemize}
\item
  is an
 isomorphism.
\item If  and
   then 
\begin{itemize}
\item
, 
\item
 and
\item .
\end{itemize}
\end{itemize}
 \end{lemma}
\begin{proof}
  The first part is proved in \cite{AILS2011} whereas the second part
  follows directly from the definition of .
\end{proof}
\begin{corollary}\label{L:Phiiso}
  Assume that  and . Then 

\iffalse
\begin{itemize}
\item  \emph{expresses}   iff
  , and
\item  \emph{characterizes}   iff  \emph{expresses}   .
\end{itemize}\fi
 \end{corollary}
\section{Applications}

Following the approach in \cite{AILS2011}, we define declarations 
and  that express the functions  and  that
were defined in Section \ref{sec:LTS}. 
\begin{definition}Let
\begin{itemize}
\item Let  and 
\item .
\end{itemize}
\end{definition}
\newpage
From \cite{AILS2011} we have:
\begin{lemma}\label{lemma:D-F}\quad
\begin{itemize}
\item
   expresses  and characterizes ,  and 
\item

  expresses  and characterizes .
\end{itemize}
\end{lemma}
Now we recall from \cite{AILS2011} the declarations that characterize simulation
equivalence and bisimulation equivalence.
\begin{definition}
Define
 and
.
\end{definition}
\begin{lemma}\quad
  characterizes  and  characterizes . 
\iffalse
\begin{itemize}
\item  characterizes the bisimulation equivalence  and
\item  characterizes the simulation equivalence
  .
\end{itemize}
\fi
\end{lemma}
\begin{proof}
 does not contain nested fixed points and can
  therefore be interpreted directly over . 
\iffalse
Now assume that
  . Then we get:

This shows that  expresses  and, by
Cor.~\ref{L:Phiiso},  characterizes
.
\fi
Now we proceed as follows:

To interpret  we define  and  and let  and
 be defined as before. Then .
If we let , we get 

The result now follows from Cor.~\ref{L:Phiiso}.
\iffalse
 Next assume that
 and that .  Then we get

As  is a constant function, i.~e.~independent of
, we get that  or equivalently 
.
\fi
\end{proof}

Next we define the nested simulation preorders introduced in
\cite{GV92} by using the function . These definition involve
nesting of fixed points and are defined recursively on the depth of
the nesting.  The -nested simulation  is just the
simulation preorder  as defined in Section \ref{sec:LTS}
and the function  is therefore the function . As the
preorder  depends on the inverse of the preorder
, which we call , we simultaneously
define the nested simulations and their inverse in our recursive
definition.  The functions that define  and
 are called  and 
respectively.



\begin{definition}[Nested simulations]\quad
\begin{enumerate}
\item  and , 
\item  and
    ,
\item  and 
  .
\item  and 
  .
\end{enumerate} 
\end{definition}
We complete this note by defining a sequence of nested declarations
and prove that they characterize the sequence of -nested
simulation preorders.
\begin{theorem}\quad
\begin{enumerate}
\item \,  expresses\, \, and\, characterizes\,
    ,
  \item \, expresses
    \, and\, characterizes\,
    ,
  \item \, expresses
    \, and\, characterizes\, ,
  \item \,
    expresses\, \, an\,d characterizes\,
    .
\end{enumerate}
\end{theorem}
\begin{proof}
  We prove the statements simultaneously by induction on . First we
  note that  where  and
   for  is a sequence of nested
  declarations.
 For the
  case  we get from Lemma \ref{lemma:D-F} that
   and
  .  Next assume that
   and
  . To prove 3. we
  proceed as follows:

Finally, to prove 4. we have:

\end{proof}



\nocite{*}
\bibliographystyle{eptcs}
\bibliography{anna}
\end{document}
