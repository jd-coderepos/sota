\documentclass[orivec]{llncs}
\pagestyle{plain}
\usepackage{stmaryrd,bcprulesmhfix,tensor}
\bcprulessavespacetrue
\suppressrulenamesfalse
\usepackage{mathpartir}
\usepackage{upgreek}
\usepackage{proof}
\usepackage[all]{xy}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{lineno}
\usepackage{xypic}
\usepackage{graphicx}
\usepackage{wrapfig}
\bibliographystyle{abbrv}
\usepackage{url,amssymb}
\renewcommand{\phi}{\varphi}
\usepackage{xspace}
\newif\iffull\fullfalse
\newif\ifapp\apptrue
\RequirePackage{txfonts}
\usepackage{times}
 \def\baselinestretch{0.98}

\iffull
\else

\makeatletter
\renewcommand{\section}{\@startsection{section}{1}{\z@}{-10\p@ \@plus -4\p@ \@minus -4\p@}{5\p@ \@plus 4\p@ \@minus 4\p@}{\normalfont\bfseries\boldmath\rightskip=\z@ \@plus 8em\pretolerance=10000 }}

  \renewcommand\subsection{\@startsection{subsection}{2}{\z@}{-2\p@ \@plus -4\p@ \@minus -4\p@}{-0.5em \@plus -0.22em \@minus -0.1em}{\normalfont\normalsize\bfseries}}
  \makeatother

\renewcommand{\paragraph}[1]{\noindent {\bf #1}}
\fi




  \abovedisplayskip.50ex
  \belowdisplayskip.50ex
  \abovedisplayshortskip.50ex
  \belowdisplayshortskip.50ex

 \usepackage[font={small}]{caption, subfig}


 \renewcommand{\figurename}{Fig.}
 \renewcommand{\tablename}{Tab.}

 \setlength{\abovecaptionskip}{1ex}
 \setlength{\belowcaptionskip}{1ex}
 \setlength{\floatsep}{1ex}
 \setlength{\textfloatsep}{1ex}



\usepackage{paralist}

\newcommand{\keywd}[1]{\mathtt{#1}}
\newcommand{\KPER}{\mathrm{KPER}}
\newcommand{\myread}[1]{!{#1}}
\newcommand{\wcpo}[1]{-cpo}
\newcommand{\wcpos}[1]{-cpos}
\newcommand{\myref}[1]{\keywd{ref}(#1)}
\newcommand{\regm}{{-}}
\newcommand{\sq}[4]{\tensor*[^{#1}_{#2}]{\Diamond}{^{#3}_{#4}}}
\newcommand{\sqsol}{\Diamond}
\newcommand{\intt}[1]{\textit{int}(#1)}
\newcommand{\effto}[1]{\stackrel{#1}{\to}}
\newcommand{\wrong}{\textit{wrong}}
\newcommand{\unitt}[1]{\textit{unit}(#1)}
\newcommand{\sqleq}{\sqsubseteq}
\newcommand{\QPER}{\operatorname{QPER}}
\newcommand{\supp}{\operatorname{supp}}
\newcommand{\booll}[1]{\textit{bool}(#1)}
\newcommand{\reff}[1]{\textit{loc}(#1)}
\newcommand{\prodd}[1]{\textit{pair}(#1)}
\newcommand{\funn}[1]{\textit{fun}(#1)}
\newcommand{\subty}{\mathrel{<:}}
\newcommand{\mmskip}{\keywd{skip}}
\newcommand{\mwhile}{\keywd{while}}
\newcommand{\partfun}{\rightharpoondown}
\newcommand{\mdo}{\keywd{do}}
\newcommand{\mif}{\keywd{if}}
\newcommand{\mthen}{\keywd{then}}
\newcommand{\melse}{\keywd{else}}
\newcommand{\massign}{\keywd{:=}}
\newcommand{\mequals}{\keywd{=}}
\newcommand{\mseq}{\keywd{;}}
\newcommand{\mtrue}{\keywd{true}}
\newcommand{\mfalse}{\keywd{false}}
\newcommand{\mx}[1]{\keywd{#1}}
\newcommand{\und}[1]{\underline{#1}}
\newcommand{\sbra}{[\![}
\newcommand{\sket}{]\!]}
\newcommand{\lift}[1]{\lceil #1 \rceil}
\newcommand{\vars}{\mathbb{V}}
\newcommand{\ints}{\mathbb{Z}}
\newcommand{\bools}{\mathbb{B}}
\newcommand{\stores}{\mathit{Stores}}
\newcommand{\stacks}{\mathit{Stacks}}
\newcommand{\nats}{\mathbb{N}}
\newcommand{\inttype}{\keywd{int}}
\newcommand{\reftype}{\keywd{ref}}
\newcommand{\myexp}[1]{#1\ \texttt{exp}}
\newcommand{\intexp}{\myexp{\inttype}}
\newcommand{\boolexp}{\myexp{\booltype}}
\newcommand{\comm}{\texttt{com}}
\newcommand{\booltype}{\keywd{bool}}
\newcommand{\unittype}{\keywd{unit}}
\newcommand{\unitval}{\keywd{()}}
\newcommand{\mquote}[1]{\mathtt{#1}}
\newcommand{\bop}{\mathrel{bop}}
\newcommand{\op}{\mathrel{op}}
\newcommand{\lop}{\mathrel{lop}}
\newcommand{\mnot}{\keywd{not}}
\newcommand{\bnfeq}{: =}
\newcommand{\bigtop}{\mathbb{T}}
\newcommand{\bigbot}{\mathbb{F}}
\newcommand{\singleton}[1]{\{#1\}}
\newcommand{\labs}{\mathbb{L}}
\newcommand{\dom}[1]{\mathrm{dom}({#1})}
\newcommand{\cod}[1]{\mathrm{cod}({#1})}


\newcommand{\pause}{\vspace{1.5ex}}
\newcommand{\gap}{\quad\quad}
\newcommand{\biggap}{\quad\quad\quad}
\newcommand{\equalsdef}{\stackrel{\mathit{def}}{=}}

\newcommand{\rom}[1]{{\rm #1}}

\newcommand{\ba}{\begin{array}}
\newcommand{\ea}{\end{array}}
\newcommand{\lz}[1]{\makebox[1.5in][r]{}}
\newcommand{\rz}[1]{\makebox[3in][l]{}}

\newcommand{\why}[1]{\quad\quad\mbox{\{ #1 \}}}

\newcommand{\centre}[1]{}
\newcommand{\centretran}[1]{}
\newcommand{\idd}{\textit{id}}

\newenvironment{syntaxrules}{}
\newenvironment{unnamedsyntaxrules}{}
\newenvironment{typerules}{}
\newenvironment{reductions}{}
\newenvironment{reductionsif}{}
\newenvironment{translation}{}
\newenvironment{derivation}{}
\newenvironment{equations}{}
\newenvironment{fig}{\begin{minipage}{\textwidth}}{\end{minipage}\pause }
\newcommand{\squelch}[1]{}
\newcommand{\myremark}[1]{\par***** NOTE ******* #1\par}

\newcommand{\ipushval}[1]{\texttt{pushc}\ #1}
\newcommand{\ipushvar}[1]{\texttt{pushvar}\ #1}
\newcommand{\ipop}[1]{\texttt{pop}\ #1}
\newcommand{\iop}[1]{\texttt{binop}_{#1}}
\newcommand{\iif}[1]{\texttt{brtrue}\ #1}
\newcommand{\ihalt}{\texttt{halt}}
\newcommand{\store}{S}
\newcommand{\mstack}{\sigma}
\newcommand{\mconfig}[1]{\langle #1 \rangle}
\newcommand{\mstep}[3]{[#1];\mconfig{#2}\to \mconfig{#3}}
\newcommand{\multistep}[3]{[#1];\mconfig{#2}\to^{*} \mconfig{#3}}
\newcommand{\meval}[3]{[#1];\mconfig{#2}\Downarrow \mconfig{#3}}
\newcommand{\stretchyspace}{\hspace{1cm}\hspace*{\fill}}
\newcommand{\rulestart}{}
\newcommand{\sameline}{\endprooftree\stretchyspace\prooftree}
\newcommand{\nextline}{\ruleend\smallskip \rulestart}
\newcommand{\lind}[1]{\mathcal{L}_{#1}}
\newcommand{\diverges}[1]{\mathcal{D}_{#1}}

\newcommand{\vfix}[3]{\keywd{rec}\:{#1}\:{#2} = {#3}}
\newcommand{\letin}[2]{\keywd{let}\:{#1}\!\Leftarrow\!{#2}\:\keywd{in}\:}
\newcommand{\letrec}[3]{\keywd{let\ rec}\ {#1\ #2}\!\Leftarrow\!{#3}\ \keywd{in}\ }
\newcommand{\opletrec}[3]{\keywd{let\ rec}}
\newcommand{\lettwoin}[4]{\keywd{let}\:{#1}\!\Leftarrow\!{#2};{#3}\!\Leftarrow\!{#4}\:\keywd{in}\:}
\newcommand{\tlet}[3]{\keywd{let}\  #1 \Leftarrow #2\ \keywd{in}\ #3}
\newcommand{\valof}[1]{\keywd{val}\:{#1}}
\newcommand{\app}[2]{{#1}\:{#2}}
\newcommand{\abs}[2]{\lambda{#1}.\:{#2}}
\newcommand{\tabs}[2]{\Lambda{#1}.{#2}}
\newcommand{\tapp}[2]{{#1}_{#2}} 
\newcommand{\proj}[2]{\pi_{#1}{#2}}
\newcommand{\tinj}[2]{\keywd{in}_{#1}^{#2}}
\newcommand{\inj}[1]{\keywd{in}_{#1}}
\newcommand{\einj}[1]{\keywd{in}_{#1}}
\newcommand{\fold}[2]{\keywd{fold}_{#1}\:{#2}}
\newcommand{\unfold}[1]{\keywd{unfold}\:{#1}}
\newcommand{\alloc}[1]{\keywd{ref}\:{#1}}
\newcommand{\deref}[1]{!{#1}}
\newcommand{\assign}[2]{{#1}:={#2}}
\newcommand{\throw}[1]{\keywd{raise}\:{#1}}
\newcommand{\catch}[3]{{#1}\:\keywd{handle}\:{#2}\Rightarrow{#3}}
\newcommand{\try}[5]{\keywd{try}\:{#1}\Leftarrow{#2}\:\keywd{handle}\:#3 . #4\:\keywd{in}\:{#5}}
\newcommand{\scatch}[2]{#1 \: \keywd{handle}\: #2}
\newcommand{\stry}[4]{\keywd{try}\: #1 \Leftarrow #2 \:\keywd{catch}\:#3\:\keywd{in}\:#4}
\newcommand{\mycase}[1]{\texttt{case}\: #1\:\texttt{of}}
\newcommand{\wrap}[1]{\texttt{wrap}\:{#1}}
\newcommand{\unwrap}[1]{\texttt{unwrap}\:{#1}}
\newcommand{\encap}[1]{\texttt{encap}\:{#1}}
\newcommand{\altloc}{k}
\newcommand{\locset}{L}
\newcommand{\alllocs}{\mathcal{L}}
\newcommand{\locsin}[1]{\mathrm{locs}({#1})}
\newcommand{\rdsin}[1]{\mathrm{rds}({#1})}
\newcommand{\wrsin}[1]{\mathrm{wrs}({#1})}
\newcommand{\alsin}[1]{\mathrm{als}({#1})}
\newcommand{\select}[2]{{#1}|_{#2}}
\newcommand{\join}{\uplus}
\newcommand{\equalon}[1]{=_{#1}}
\newcommand{\ifz}[1]{\keywd{iszero}\:{#1}}
\newcommand{\myif}[3]{\keywd{if}\ #1\ \keywd{then}\ #2\
  \keywd{else}\ #3}
\newcommand{\lett}{{\keywd{let}\ }}
\newcommand{\bee}{{\Leftarrow}}
\newcommand{\inn}{{\ \keywd{in}\ }}
\newcommand{\ttype}[2]{T_{#1}\,#2}
\newcommand{\eff}{\varepsilon}
\newcommand{\reads}{\mathrm{rds}}
\newcommand{\writes}{\mathrm{wrs}}
\newcommand{\allocs}{\mathrm{als}}
\newcommand{\sing}[1]{\{#1\}}
\newcommand{\erase}[1]{U(#1)}
\newcommand{\powerset}{\mathbb{P}}
\newcommand{\rels}[1]{\mathcal{R}_{#1}}
\newcommand{\toprel}[1]{\mathbb{T}_{#1}}
\newcommand{\botrel}[1]{\mathbb{F}_{#1}}
\newcommand{\diagrel}[1]{\Delta_{#1}}
\renewcommand{\topfraction}{.8}
\newcommand{\fota}{A^\circ}
\newcommand{\fotb}{B^\circ}
\newcommand{\readsg}[1]{\texttt{r}_{#1}}
\newcommand{\writesg}[1]{\texttt{w}_{#1}}
\newcommand{\storetyping}{\Sigma}
\newcommand{\obseq}{\approx}
\newcommand{\converges}{\Downarrow}
\newcommand{\mperp}{\bot}
\newcommand{\fullonly}[1]{}
\newcommand{\Rule}[4]{\ensuremath{\makebox[1cm]{\hfill {\rm #1}}
    \,\dfrac{#2}{#3}\,\,{#4}}}
\newcommand{\rrule}[5]{\ensuremath{\makebox[#1]{\hfill {\rm #2}}
    \,\dfrac{#3}{#4}\,\,{#5}}}
\newcommand{\Extend}[2]{{#1}\downharpoonright^{#2}}
\newcommand{\rrulesub}[7]{\ensuremath{\makebox[#1]{\hfill {\rm #2}}_{\makebox[#3]{\hfill {\rm #4}}} \,\dfrac{#5}{#6}\,\,{#7}}}
\newcommand{\Halfrule}[4]{\ensuremath{\makebox[0.5cm]{\hfill {\rm #1}}
    \,\dfrac{#2}{#3}\,\,{#4}}}
\newcommand{\RuleTwo}[4]{\ensuremath{\makebox[2cm]{\hfill {\rm #1}}
    \,\dfrac{#2}{#3}\,\,{#4}}}
\newcommand{\RuleTwofive}[4]{\ensuremath{\makebox[2.5cm]{\hfill {\rm #1}}
    \,\dfrac{#2}{#3}\,\,{#4}}}
\newlength{\lruleZeroname}
\setlength{\lruleZeroname}{0cm}
\newcommand{\RuleZero}[4]{\ensuremath{\makebox[\lruleZeroname]{\hfill {\rm #1}}
    \,\dfrac{#2}{#3}\,\,{#4}}}
\newcommand{\TODO}[1]{{TODO: \emph{#1}}}
\newcommand{\masked}{\ensuremath{\tau}}
\newcommand{\regs}[1]{\mathrm{regs}({#1})}
\newcommand{\domL}[1]{\ensuremath{\mathrm{dom}}(#1)}
\newcommand{\domR}[1]{\ensuremath{\mathrm{dom}'}(#1)}
\newcommand{\dompL}[1]{\ensuremath{\mathrm{priv}}(#1)}
\newcommand{\dompR}[1]{\ensuremath{\mathrm{priv}'}(#1)}
\newcommand{\Parms}{\mathrm{Par}}
\newcommand{\strels}[2]{\mathrm{StRel}({#1},{#2})}
\newcommand{\Env}{\mathrm{Env}}
\newcommand{\CEnv}{\mathrm{Env}_\mathbb{C}}
\newcommand{\PEnv}{\mathrm{Env}_\mathbb{P}}
\newcommand{\fix}{\mathrm{fix}}
\newcommand{\Mcnt}{M_{\mathrm{cnt}}}
\newcommand{\Mmem}{M_{\mathrm{mem}}}
\newcommand{\Mbuf}{M_{\mathrm{buf}}}
\newcommand{\Mconst}{M_{\mathrm{const}}}
\newcommand{\Vsum}{V_{\mathrm{sum}}}
\newcommand{\inv}[1]{\ensuremath{\mathrm{inv}(#1)}}
\newenvironment{myexample}{\vspace{1em}{\bf Example.}}{\qed \vspace{1em}}
\newcommand{\ok}[2]{\ensuremath{{#1} \vdash {#2}\ \mathit{ok}}}
\newcommand{\eq}[1]{\mathrel{\sim_{#1}}}
\renewcommand{\P}{\ensuremath{\mathcal{P}}}
\newcommand{\INT}{\ensuremath{\mathbb{Z}}}
\newcommand{\BOOL}{\ensuremath{\mathbb{B}}}
\newcommand{\UNIT}{\ensuremath{\mathbf{1}}}
\newcommand{\reg}{\ensuremath{\rho}}
\newcommand{\regid}{\ensuremath{\mathsf{r}}}
\newcommand{\Regids}{\ensuremath{\mathit{Regs}}}
\newcommand{\Locs}{\ensuremath{\labs}}
\newcommand{\new}{\ensuremath{\mathit{new}}}
\newcommand{\Stores}{\ensuremath{\mathbb{H}}}
\newcommand{\sem}[1]{\ensuremath{\llbracket {#1} \rrbracket}}
\newcommand{\semV}[1]{\ensuremath{\llceil {#1} \rrceil
}}
\newcommand{\csem}[1]{\ensuremath{\llbracket {#1}
    \rrbracket_\mathbb{C}}}
\newcommand{\psem}[1]{\ensuremath{\llbracket {#1} \rrbracket_\mathbb{P}}}
\newcommand{\nwrs}{{\ensuremath{\mathit{nwrs}}}}
\newcommand{\nwrL}{{\ensuremath{\mathit{nwrs}}}}
\newcommand{\nwrR}{{\ensuremath{\mathit{nwrs}'}}}
\newcommand{\elEffs}{\mathcal{E}}
\newcommand{\aEff}[1]{\ensuremath{\mathit{al}_{#1}}}
\newcommand{\rEff}[1]{\ensuremath{\mathit{rd}_{#1}}}
\newcommand{\wEff}[1]{\ensuremath{\mathit{wr}_{#1}}}
\newcommand{\EffExt}[3]{\ensuremath{\Omega^{#1}_{#2}({#3})}}
\newcommand{\Prels}[3]{\ensuremath{\mathcal{R}^{#1}_{#3}({#2})}}
\newcommand{\Ext}[3]{\ensuremath{\operatorname{Ext}}^{#1}_{#3}({#2})}
\newcommand{\Alloc}{\operatorname{Alloc}}

\newcounter{Examplecount}
\setcounter{Examplecount}{0}
\renewenvironment{example}
{
\stepcounter{theorem} {\bf \noindent Example
\arabic{section}.\arabic{theorem} }}
{\qed}
\renewenvironment{proof}{\vspace{-1mm} \noindent {\bf Proof}\quad}{\qed}
\newcommand\im{\mathrm{Img}}

\newcommand{\loc}{\mathfrak{l}}
\newcommand{\cloc}{\ensuremath{\mathsf{l}}\xspace}
\newcommand\w{\ensuremath{\mathsf{w}}\xspace}
\newcommand\q{\ensuremath{\mathsf{q}}\xspace}
\newcommand{\bij}{\ensuremath{\mathbb{B}}\xspace}
\newcommand{\world}{\ensuremath{\mathbf{W}}\xspace}
\newcommand{\worldIso}{\ensuremath{\mathbf{W}_{\mathrm{Iso}}}\xspace}
\newcommand\heap{\ensuremath{\mathsf{h}}\xspace}
\newcommand\heapp{\ensuremath{\mathsf{g}}}
\newcommand{\Values}{\mathbb{V}}
\newcommand{\Comps}{\mathbb{C}}
\newcommand{\Astores}{\mathfrak{S}}
\newcommand{\bigsig}{\ensuremath{\mathbb{S}}\xspace}
\newcommand{\ah}{\ensuremath{\sigma}\xspace}
\newcommand{\taken}[2]{\ensuremath{#1\!\! \! \upharpoonright^#2}\xspace}

\newcommand\val{\ensuremath{\mathsf{v}}\xspace}
\newcommand\vval{\ensuremath{v}\xspace}
\newcommand\fval{\ensuremath{\mathsf{f}}\xspace}
\newcommand\ffval{\ensuremath{f}\xspace}
\newcommand\cval{\ensuremath{\mathsf{c}}\xspace}
\newcommand\ccval{\ensuremath{c}\xspace}

\newcommand\pull[2]{\ensuremath{\underline{#1}_{#2}}\xspace}
\newcommand\push[2]{\ensuremath{\overline{#1}_{#2}}\xspace}
\newcommand\rel{\ensuremath{\mathrm{Rel}}\xspace}

\newcommand\Cscr{\ensuremath{\mathcal{C}}\xspace}
\newcommand\Std{\ensuremath{\mathit{Std}}\xspace}
\newcommand\Rscr{\ensuremath{\mathcal{R}}\xspace}
\newcommand\fst[1]{\ensuremath{\mathsf{fst}(#1)}\xspace}
\newcommand\Eq[1]{\ensuremath{\mathsf{Eq}(#1)}\xspace}
\newcommand{\readSet}[1]{\ensuremath{\mathcal{R}({#1})}}
\newcommand{\writeSet}[1]{\ensuremath{\mathcal{W}({#1})}}
\newcommand{\allocSet}[1]{\ensuremath{\mathcal{A}({#1})}}
\newcommand{\fr}[1]{\ensuremath{\mathsf{Fr}(#1)}\xspace}
\newcommand{\res}[2]{\ensuremath{\mathsf{Res}(#1,#2)}\xspace}
\newcommand{\ety}[2]{{#1}\mathrel{\&}{#2}}
\newcommand{\valty}[1]{#1}

\title{Abstract Effects and Proof-Relevant Logical Relations}

\author{Nick Benton\iffull\inst{1}\fi \and Martin Hofmann\iffull\inst{2}\fi  \and Vivek
Nigam\iffull\inst{3}\fi}
\institute{Microsoft Research, LMU Munich and Federal University of Para\'iba}
\squelch{
\institute{\iffull
Microsoft Research, UK, \email{nick@microsoft.com}
\and\fi
LMU, Munich, Germany, 
\email{hofmann@ifi.lmu.de}
\iffull\and
Federal University of Para\'iba, Brazil, \email{vivek.nigam@gmail.com}\fi
}
}



\begin{document}
\maketitle
\begin{abstract}
  We introduce a novel variant of logical relations that maps types 
 not merely to partial equivalence relations on values, as is
  commonly done, but rather to a proof-relevant generalisation
  thereof, namely setoids. 
\squelch{
A setoid is like a category all of whose
  morphisms are isomorphisms (a groupoid) with the exception that no
  equations between these morphisms are required to hold. 
}
  The objects of a setoid establish that values inhabit semantic
  types, whilst its morphisms
  are understood as proofs of semantic equivalence.

  The transition to proof-relevance solves two well-known
  problems caused by the use of existential quantification over future
  worlds in traditional Kripke logical relations: failure of
  admissibility, and spurious functional dependencies.

  We illustrate the novel format with two applications: a direct-style
  validation of Pitts and Stark's equivalences for ``new'' and a
  denotational semantics for a region-based effect system that
  supports type abstraction in the sense that only externally visible
  effects need to be tracked; non-observable internal modifications,
  such as the reorganisation of a search tree or lazy initialisation,
  can count as `pure' or `read only'. This `fictional purity' allows
  clients of a module soundly to validate more effect-based program
  equivalences than would be possible with traditional effect systems.
\end{abstract}
\squelch{
\category{D.3.3}{Programming Languages}{Language Constructs and Features -- Dynamic storage management}
\category{F.3.2}{Logic and Meanings of Programs}{Semantics of Programming Languages -- Denotational semantics, Program analysis}
\category{F.3.2}{Logic and Meanings of Programs}{Studies of Program Constructs -- Type structure}
\terms
Languages, Theory
\keywords
Type and effect systems, region analysis, logical relations, parametricity, program transformation
}

\iffull \else \vspace{-4mm} \fi
\section{Introduction}
\label{sec:intro}
The last decade has witnessed significant progress in modelling and
reasoning about the tricky combination of effects and higher-order
language features (first-class functions, modules, classes).  The
object of study may be ML-, Java-, or assembly-like, but the common
source of trickiness is the way effectful operations may be
\emph{partially} encapsulated behind higher-order
abstractions. Problems in semantics and verification of effectful
languages are often addressed using a range of common techniques that
includes separation and Kripke logical relations (KLRs). The
particular problem motivating the development of the proof-relevant
form of KLR introduced here is that of giving a semantics to effect
systems that accounts for partial encapsulation, though the general
construction is more broadly applicable. As we will see, direct
semantic reasoning in our model (as opposed to generic reasoning based
on refined types) also allows many of the trickiest known equivalences
concerning encapsulated store to be proved.

\squelch{One is to devise models and reasoning principles for establishing
contextual (in)equivalences
\cite{DBLP:conf/mfcs/PittsS93,DBLP:journals/corr/abs-1103-0510}. A
second is to establish equivalence between high-level and low-level
code fragments, e.g. for compiler correctness
\cite{DBLP:conf/icfp/BentonH09,DBLP:conf/popl/HurD11}. A third is to
define Hoare-style logics for showing programs satisfy 
assertions \cite{DBLP:journals/corr/abs-1109-3031}. A fourth, which
we address here, is to study type systems and analyses that
can characterise particular \emph{classes} of behaviour (such as
purity) and be used to justify equivalences more generically.
}

Effect systems \cite{DBLP:conf/lfp/GiffordL86} refine conventional
types by tracking upper bounds on the side-effects of expressions.  A
series of papers, by ourselves and others
\cite{DBLP:conf/popl/KammarP12,DBLP:conf/ppdp/BentonKBH09,DBLP:conf/ppdp/BentonKBH07,DBLP:conf/aplas/BentonKHB06,DBLP:conf/icfp/ThamsborgB11},
have explored the semantics of effect systems for mutable state,
addressing not merely the correctness of analyses, but also the
soundness of effect-dependent optimizations and refactorings. An
example is the commutation of stateful computations  and ,
subject to the condition that the sets of storage locations
potentially written by  and  are disjoint, and that neither
potentially reads a location that the other writes.  \squelch{If one
  gives expressions refined monadic types of the form ,
  meaning `computations returning results of type  with
  side-effects bounded by ', for a suitable choice of effect
  annotations , then effect-dependent equivalences can be
  formalized in terms of conditions on annotations. For example
  \infrule {\Gamma\vdash M:T_\eff\tau \andalso \Gamma\vdash
    N:T_{\eff'}\tau' \andalso \Gamma,x:\tau,y:\tau' \vdash
    P:T_{\eff''}\tau''\\ \wrsin{\eff}\cap
    \wrsin{\eff'}=\rdsin{\eff}\cap \wrsin{\eff'} = \rdsin{\eff'}\cap
    \wrsin{\eff}=\emptyset} {\Gamma
    \vdash \begin{array}{l}\letin{x}{M}{\letin{y}{N}{P}}\\ =
      \letin{y}{N}{\letin{x}{M}{P}}\end{array} :
    T_{\eff\cup\eff'\cup\eff''}\tau''}

\noindent
where  and  are the sets of possibly-read
and possibly-written variables (or regions) in .} Our primary
interest is not syntactic rules for type assignment, but rather
semantic interpretations of effect-refined types that can justify such
equivalences.  Types provide a common interface language that can be
used in modular reasoning about rewrites; types can be assigned to
particular terms by a mixture of more or less sophisticated inference
systems, or by deeper semantic reasoning. \squelch{Clearly, such a
  separation of concerns requires that the interpretation of types be
  independent of any inference system.}

A key notion in compositional reasoning about state is that of
\emph{separation}: invariants depending upon mutually disjoint parts
of the store. Intuitively, if each function with direct access to a
part preserves the corresponding invariant, then all the invariants
will be preserved by any composition of functions. Disjointness is
naively understood in terms of sets of locations.  A memory
allocator, for example, guarantees that its own private
datastructures, memory belonging to clients, and any
freshly-allocated block inhabit mutually disjoint sets of
locations. Since the introduction of fractional permissions,
separation logics often go beyond this simple model, introducing
resources that are combined with a separating conjunction, but which
are not literally interpreted as predicates on disjoint
locations. Research on `domain-specific'
\cite{DBLP:conf/tldi/KrishnaswamiBA10}, `fictional'
\cite{DBLP:conf/vstte/Dinsdale-YoungGW10,DBLP:conf/esop/JensenB12},
`subjective' \cite{leywild:scsl}, or `superficial'
\cite{krishnaswami:superficially} separation \squelch{logics and type theories}
aims to let custom notions of separable resource be used
and combined modularly. This paper presents a semantics for effect
systems supporting fictional, or `abstract', notions of both effects
and separation.

We previously interpreted effect-refined types for stateful
computations as binary relations, defined via preservation of
particular sets of store relations. This already provides some
abstraction. For example, a function that reads a reference, but whose
result is independent of the value read can soundly be counted as pure
(contrasting with models that instrument the concrete semantics). Our
models also validated the masking rule, allowing certain
non-observable effects not to appear in annotations. But here we go
further, generalizing the interpretation of regions to partial
equivalence relations (PERs). This allows, for example, a lookup
function for a set ADT to be assigned a read-but-not-write effect,
even if the concrete implementation involves non-observable writes to
rebalance an internal datastructure. Roughly, there is a PER that
relates two heaps iff they contain well-formed datastructures
representing the same mathematical set, and the ADT operations respect
this PER: looking up equal values in related heaps yields equal
booleans, adding equal values in related heaps yields new related
heaps, and so on. A mutating operation need only be annotated with a
write effect if the updated heap is potentially in a different
equivalence class from the original one. In fact, we further improve
previous treatments of write effects, via a `guarantee' condition that
explicitly captures allowable local updates. Surprisingly, this allows
the update and remove operations for our set ADT to be flagged with
\emph{just} a write effect, despite the fact that the final state of
the set depends on the initial one, exploiting the idempotence of the
updates and validating many more useful program transformations.


Moving to PERs also allows us to revisit the notion of separation,
permitting distinct abstract locations, or regions, to refer to PERs
whose footprints overlap, albeit non-observably, in memory. A module
may, for example, implement two distinct logical references using a
single physical location containing a coding (e.g. ) of a pair
 of integers. Or a resource allocator can keep logically
separated tokens tracking each allocated resource, acting as
permissions for deallocation, in a shared datastructure such as a
bitmap or linked list (a well-known problem in modular separation
\cite{krishnaswami:superficially}). The innovation here is a notion of independence of PERs,
capturing the situation where intersection of PERs yields a cartesian
product of quotients of the heap.

\begin{wrapfigure}{r}{.5\textwidth}
\vspace{-3mm}

\vspace{-2mm}
\caption{Earlier Kripke logical relation, extract}
\label{fig:oldklr}
\vspace{-9mm}
\end{wrapfigure}
The ideas sketched above are intuitively rather compelling, but
formally integrating them into the form of KLR we had previously used
for effect systems turns out to be remarkably
hard. Figure~\ref{fig:oldklr} shows a (tweaked) extract from an earlier
paper \cite{DBLP:conf/ppdp/BentonKBH07}. Here a world  is just a finite partial bijection between
locations, with region-coloured links; 
simply means that for each link ,

and .
Two
computations , where  are
sets of heaps and values, respectively, are in the relation
, where  is an effect and the relation  interprets a
result type, if they preserve all heap relations  in a set
depending on  and , and there exists \emph{some}
disjoint world extension  such that the new heaps are equal on
the domain of , and the result values are -related at the
extended world . 



The problematic part
is the existential quantification over world extensions -- the
 on the third line -- allowing for the computations
to allocate fresh locations.
This pattern of
quantification occurs in many accounts of generativity, but
the dependence of  on both  and  creates serious problems
if one generalizes from bijections to PERs
and tries to prove equivalences.
Roughly, one has to consider varying the initial heap in
which one computation, say , is started; the
existential then produces a \emph{different} extension 
that is
not at all related, even on the side of  where the
heap stays the same, to the  with which one started. The
case of bijections, where  depends only on
 (not on ), allows one to deduce sufficient information
about the domain of  from the clause ,
but this breaks down in the more abstract setting.

To fix this problem, we here
take the rather novel step of replacing the existential
quantifier in the logical relation by appropriate Skolem functions,
explicitly enforcing the correct dependencies. In the language of
type theory, this amounts to replacing an existential  with
a -type. A statement like  is no
longer just a proposition, but we rather have a ``set of
proofs''  which in particular contains
the aforementioned Skolem functions. We use an explicit version of the 
exact-completion \cite{DBLP:conf/mfps/CarboniFS87,DBLP:conf/lics/BirkedalCRS98} akin to and motivated by ``setoid'' or groupoid interpretations of type theory 
\cite{DBLP:conf/lics/HofmannS94,DBLP:journals/jfp/BartheCP03,DBLP:conf/cpp/Voevodsky11} to make these ideas both rigorous and more
general.

Passing from relations to proof-relevant setoids also solves other
problems. Existential quantification fails to preserve admissibility
of relations, needed to deal with general recursion, and also fails to
preserve `PERness'. The `' operation in
Figure~\ref{fig:oldklr} explicitly applies an admissible and (variant)
PER closure operation; this works technically, but is very awkward to
use. We do not need such a closure here. Step indexing
\cite{DBLP:conf/esop/Ahmed06,DBLP:conf/icfp/ThamsborgB11} and the use
of continuations \cite{DBLP:conf/mfcs/PittsS93} can also deal with
admissibility.  However, step-indexing is inherently operational,
whilst continuations lose sufficient abstraction to break some program
equivalences, including commuting computations. Our third way, using
setoids, is pleasantly direct. Finally, allocation
effects are handled differently from reading and writing by the
relation in Figure~\ref{fig:oldklr}, being wired into the
quantification rather than treated more abstractly by relation
preservation. Our setoid-based formulation uses uniform machinery to
treat all effects.

We start by reviewing some preliminary definitions on syntax and
semantics of programs in Section~\ref{sec:semantics}.
Section~\ref{sec:setoids} introduces setoids, which is the setting in
which we specify in Section~\ref{test} the typed semantics and
introduce the notion of abstract effects. In
Section~\ref{sec:logical-relations} we describe proof-relevant logical
relations, prove the fundamental theorem and define observational
equivalence. Section~\ref{sec:application} demonstrates a number of
program equivalences that can be shown by using proof-revelant logical
relations. We conclude and discuss future work in
Section~\ref{sec:conclusions}.

\ifapp
\paragraph{Note:} We have elided many proofs, details of constructions
and examples. This longer version of the paper includes some of this
material in an appendix.
\else
\paragraph{Note:} We have elided many proofs, details of constructions
and examples. A longer version of the paper includes some of this
material in an appendix, and is available from the first author's
homepage.
\fi


  \squelch{A long version, possibly formalised
  will contain these details which are not hard to reconstruct
  oneself, but tedious and space-consuming to typeset.}


\section{Syntax and Semantics}
\label{sec:semantics}
We will interpret effect-refined types over a somewhat generic,
untyped denotational model for stateful computations in the category
of predomains (-cpos).  We also introduce a meta-language
\cite{moggi1991notions}, providing concrete syntax for functions in
the model. We omit the standard details of interpreting CBV
programming languages via such a metalanguage, or proofs of adequacy,
relating the operationally induced observational (in)equivalence to
(in)equality in the model.






\paragraph{Denotational model} 
\iffull
A \emph{predomain} is an -cpo, i.e. a partial order with suprema
of ascending chains. A \emph{domain} is a predomain with a least element,
. \squelch{We use predomains and continuous functions, rather than sets
and functions, so as to be able to interpret recursive definitions.}
Recall that  is \emph{continuous} if it is monotone
 and preserves suprema of ascending
chains, i.e., . Any set is a predomain with the
discrete
order. If  is a set and  a predomain then
any  is continuous. A subset  of a
predomain  is \emph{admissible} if whenever  is an ascending
chain in  such that  for all , then ,
too. If  is continuous and  is a domain
then one defines  with
. One has,  and if
 is admissible and  then
, too. We denote a partial (continuous)
function from set (predomain)  to set (predomain)  by .  
\fi
We assume predomains  and  modelling values and heaps,
respectively. As much of the metatheory does not rely on the finer
details of how these predomains are defined, we axiomatise the
properties we use.  Firstly, we assume the existence of a set of
(concrete) locations  and for each  a finite
set . We also assume a constant
, the empty heap.  If , then . If  then ; finally  yields a pair 
where  and . These three operations
are continuous, in particular,  and the following axioms hold:
,
,
 , and if
 then
 and 
and .  Given  this abstract datatype can be
implemented in a number of ways, e.g., as finite maps.
We define the domain of computations  to be 
partial continuous functions from  to , the bottom element being the everywhere undefined function.

We assume that  embeds tuples of values, i.e., if
 then  and it is
possible to tell whether a value is of that form and in this case to
retrieve the components. We also assume that  embeds
continuous functions , i.e., if  is
such a function then  and, finally, locations are
also values, i.e.\ if  then  and
one can tell whether a value is a location or a function. A canonical
example of
such a  is the least solution to the predomain equation 
with  and


\paragraph{Syntax}
The syntax of untyped values and computations is:
\iffull

Here,  ranges over variables and  over constant
\else



\noindent
Here,  ranges over variables and  over constant
\fi
symbols, each of which has an associated interpretation
; these include numerals  with
, arithmetic operations and so on.
 defines a recursive function with body  and
recursive calls made via ; we use  as syntactic sugar in
the
case when . Finally,  (reading) returns
the contents of location ,  (writing) updates
location  with value , and  (allocating) returns a
fresh location intialised with . The metatheory is simplified by
using ``let-normal form'', in which the only elimination for
computations is let, though we sometimes nest computations as
shorthand for let-expanded versions in examples.

\paragraph{Semantics}
The untyped semantics of values 
and terms  are defined by an
entirely standard mutual induction, using least fixed points to
interpret recursive functions, projection from tuples for variables
and so on.
\squelch{
are given by
the recursive clauses in Figure~\ref{seme}; note the overloading of
semantic brackets for constants, values and computations. 
The notation
 stands for the -th projection from 
if  is  and  (functionally) updates the
-th slot in  when .
}

\paragraph{Types}
Types are given by the grammar:
\iffull

where  ranges over semantically defined basic types (see
\else

where  ranges over semantically defined basic types (see
\fi
Def.~\ref{defte}). These contain reference types possibly
annotated with regions and abstract types like lists, sets, and even
objects, again possibly refined by regions. The metavariable 
represents an \emph{effect}, that is a subset of some fixed set of
elementary effects about which we say more later. The core typing
rules for values and computations are shown in
Figure~\ref{tyres}. We do not bake in type rules for
constants and effectful operations but, for a given semantic interpretation
of types, we will be able to justify adding further rules for these
primitives and, more importantly, for more complex expressions
involving them. (The rules given here incorporate
subeffecting; we expect our semantics to extend
to more general subtyping.)



\paragraph{Equations} Figure~\ref{eqth} outlines a core equational theory for
the metalanguage.  The full theory includes congruence rules for all
constructs (like that given for \texttt{rec}), all the usual beta and
eta laws and commuting conversions for conditionals as well as for
\texttt{let}.
We give
a semantic interpretation of typed equality judgements which is sound
for observational equivalence. 
As with typings, further equations involving effectful computations may be
justified semantically in a particular model and added to the theory.
The core theory then allows one to
deduce new semantic equalities from already proven ones. 
The equations are typed: a derivation
 of  is canonically
associated with typing derivations  and 
of  and ,
respectively (but note we can semantically justify extending the
type rules). The interpretation of
 will be a proof object certifying that the 
interpretations of  and  are
semantically equal which then implies (Theorem~\ref{obseq}) typed
observational equivalence of  and .

\squelch{
\begin{figure*}[tph]
\iffull

\else
\vspace{-7mm}


\fi
\caption{Semantics of the untyped meta language \label{seme}}
\vspace{-8mm}
\end{figure*}
}

\begin{figure*}[tph]
\vspace{-3mm}



\caption{Core rules for effect typing\label{tyres}\label{efte}}
\vspace{-5mm}
\end{figure*}
\begin{figure*}[tph]
\vspace{-3mm}

\iffull \vspace{2pt} \fi

\iffull \vspace{2pt} \fi

\iffull \vspace{2pt} \fi

\caption{Basic equational theory (extract)\label{eqth}}
\iffull
\else
\vspace{-2mm}
\fi
\end{figure*}
\subsection{Some example programs}\label{examples}

~\newline

\paragraph{Dummy allocation}
Define  as 
 
so  behaves like  but makes an
allocation whose result is discarded.
We will be able to show that  displays no more
abstract effects than , so that whatever program transformation
 can participate in,  can as well.

\paragraph{Memoisation}
Let \textit{memo} be the memoizing functional
\iffull

where  is sequential composition and
 is an integer equality constant.
\else



\noindent
where  is sequential composition and
 is an integer equality constant.
\fi
We can justify the typing
, saying that if  is observationally pure, , is too, and so can 
participate in any program equivalence relying
on purity. This was not justified by our previous
model~\cite{DBLP:conf/ppdp/BentonKBH07}.

\paragraph{Set factory}
The next, more complicated, example is a program that can 
create and manipulate sets implemented as linked lists.


If  and  and  is a finite set of
integers and  is a finite subset of  define
 to mean that in  location  points to
a linked list of integer values occupying at most the locations in 
(the ``footprint'') and so that the set of these integer values is
. So, for example, if  and
 and  then  holds. 

For each location  define functions ,
,  so that
 checks whether  occurs in the list
pointed to by , returning  iff yes, and---for the fun
of it---removes all duplicates in that list and relocates some of its
nodes.  Thus, in particular, if  then if  one has
 for some  where  and  iff .

The function  adds its integer argument to the
set, and  removes it, each possibly making
``optimizations'' similar to .

Now consider a function  returning upon each call
a fresh location  and a the tuple of functions
.
We will be able to justify the following
 semantic typing for : 
\iffull

which  expresses   that    allocates   in  some
\else



\noindent
which  expresses   that    allocates   in  some
\fi
(possibly fresh) region  and returns operations that only read
 (the  first one)  or write  in  (the  second and
third one)  even though, physically, all three  functions read, write,
and allocate.


Thus, these functions can participate in corresponding
effect-dependent program equivalences, in particular, two successive
 operations may be swapped and duplicated; identical
updates may even be contracted.
\iffull\footnote{We
could
also consider a more object-oriented variant that works with
a basic type  accepted as argument by the
operations.}
\fi

\paragraph{Interleaved Dummy allocation}
Consider the following example, which looks similar to the Dummy example
above, but where the dummy allocation happens after a proper allocation:
\iffull

Here  is not free in , but  may be free.
\else



\noindent
Here  is not free in , but  may be free.
\fi
This simple difference leads to many problems when 
attempting to prove
their equivalence. We sketch them below to also motivate
our technical solution introduced formally in the following Sections. 

As normally done the
evolution of the heaps can be formally captured by using Kripke models,
where, intuitively, a world contains the set of locations allocated by
programs.
Whenever there is an allocation,
we advance from the current world  to a world , which contains
some fresh locations. However, we do not have control over this
evolution. In our example, assume that the programs above
start at the same world . The allocation of the proper location,
,
in  and in  will yield two different extensions  and
, where some concrete locations,  and , are
allocated respectively. In fact,  and  may even contain other
locations that are not used by the computations. For proving the
equivalence between these programs, we need
a way to capture that   and  are equivalent, without
requiring to identify the other locations not used by computations.

\begin{wrapfigure}{r}{.25\textwidth}
 \vspace{-12mm}

\caption{Pullback square.}
\label{fig:pullback}
\vspace{-9mm}
\end{wrapfigure}
Our solution is to use \emph{pullback squares} as proofs. Their shape is
depicted in Figure~\ref{fig:pullback}.
where  and  are called, respectively, the
\emph{low point} and \emph{apex} of the square.  It helps to interpret
 as a superset of , that is, a world
containing all the locations mentioned in  and , even the
locations not used by computations, while  (modulo renaming of location names) is a world containing only
the locations that need to be identified. Intuitively, the low point
is the part of the proof showing that resulting heaps of computations are
equivalent. This is formalized by Definition~\ref{teffde}. In the
example above,
the low point is a world where  and  are
shown to be equivalent. The remaining locations in  and  that
are not used by computations may be ignored, that is, not be contained in
. 
The apex, , on the other hand, is the part of the proof 
showing that the corresponding \emph{values} resulting from computations,
 in the example above, are indeed equivalent (see again
Definition~\ref{teffde}). 

\section{Setoids}
\label{sec:setoids}
We define the \emph{category of setoids} as the exact completion of
the category of predomains, see
\cite{DBLP:conf/mfps/CarboniFS87,DBLP:conf/lics/BirkedalCRS98}. We
give here an elementary description using the language of dependent
types.  A \emph{setoid}  consists of a predomain  and for any
two  a set  of ``proofs'' (that  and  are
equal). The set of triples  must itself
be a predomain and the first and second projections must be
continuous. Furthermore, there are continuous functions  and  and
.
\iffull
We should explain what continuity of a dependent function like
 is: if  and  and  are ascending
chains in  with suprema  and  and  are proofs such that  and 
are ascending chains, too, with suprema  and  then
 is an ascending chain of proofs (by
monotonicity of ) and its supremum is .
\fi
\iffull
 Formally,
such dependent functions can be reduced to non-dependent ones using
pullbacks, that is  would be a function defined on the pullback of
the second and first projections from  to
, but we find the dependent notation to be much more readable.
\fi
If  we may write  or simply . We also
omit  wherever appropriate. We remark that ``setoids'' also appear in
constructive mathematics and formal proof, see e.g.,
\cite{DBLP:journals/jfp/BartheCP03}, but the proof-relevant nature of
equality proofs is not exploited there and everything is based on sets
(types) rather than predomains. 
A morphism from setoid  to setoid  is an equivalence class of  pairs  of
continuous functions where  and . Two such pairs
 are \emph{identified} if there exists a
continuous function . 
\begin{proposition}
The category of setoids is cartesian closed; moreover, if  is a setoid such that  has a least element  and there is also a least proof  then there is a morphism of setoids  satisfying the usual fixpoint equations. 
\end{proposition}
\subsection{Pullback squares}
\label{sec:pullback}
A morphism  in a category  is a monomorphism if 
implies  for all morphisms .  A commuting square 
of morphisms is a pullback if whenever  there is unique 
such that  and . We write  or
 (when ) for such a
pullback square. We call the common codomain of  and  the
\emph{apex} of the pullback written , while
the common domain of  the \emph{low point} of the
square written . A pullback square  is
\emph{minimal} if
whenever  and  then , in other words,  and
 are \emph{jointly epic}. A pair of morphisms  with common domain
is a span, a pair of morphisms  with common codomain is a
co-span. A category has pullbacks if every co-span can be completed to
a pullback square.
\begin{definition}[Category of worlds]
  A category  is a \emph{category of worlds} if it has
  pullbacks and every span can be completed to a minimal pullback
  square and all morphisms are monomorphisms.
\end{definition}
\begin{example}
  The category of sets and injections is a category of worlds.  
Given  and , we form their pullback as
. This is minimal when . Conversely, given a span , we can complete to a minimal pullback by
\newcommand{\myin}[1]{\mathit{in}_{#1}}
\iffull

where  is case analysis on the disjoint union .
\else



\noindent
where  is case analysis on the disjoint union .
\fi








  Given an arbitrary category , the
  category of worlds  has objects pairs
   where  is a set and  is an
  -indexed family of -objects. A morphism from 
  to  is an injective function  and a family
  of isomorphisms . The first components of
  the pullbacks and minimal pullbacks are constructed as in the
  previous example.
\end{example}
\iffull
\begin{definition}
Let  be a category of worlds.  Two pullbacks
 and  are isomorphic
if there is an isomorphism  between the two low points of the
squares so that  and , thus also  and
.
\end{definition}
\fi\iffull
\begin{lemma}\label{preo}
  Given a category of worlds , such that , 
  if  and  are
  pullback squares as indicated then there exist  such that
   is also a pullback. 
\end{lemma}
\fi
\iffull\begin{proof}
  Choose  in such a way that  and
   are pullbacks.  The verifications are then an
  easy diagram chase.
\end{proof}
\fi

We write  for  and  and  where  \iffull are given by 
Lemma~\ref{preo} assuming an arbitrary choice. \else are chosen so
that all four participating squares are pullbacks.\fi
\iffull
\begin{lemma}\label{decomp}
A pullback  square  in a category of worlds is
isomorphic to .
\end{lemma}
\fi

\subsection{Setoid-valued functors} 
\label{subsec: func-setoids}
A functor  from a category
of worlds  to the category of setoids comprises as usual for
each  a setoid  and for each 
a morphism of setoids  preserving identities
and composition. If  and  we may write
 or even  for  and likewise for proofs in . Note
that . 

\begin{definition}
We call a functor
\emph{pullback-preserving} (p.p.f.) if for every pullback square
 with apex  and low point
 the diagram  is a pullback
in . This means that there is a continuous function of type 
\iffull

\else


\fi
\end{definition}
Thus, if two values  and  are equal in a common world
 then this can only be the case because there is a value in
the ``intersection world''  from which both  arise. 
Intuitively, p.p.f.s will become the denotations
of value types.
\iffull
\begin{lemma}
  If  is a p.p.f.,  and ,
  there is a continuous function . Moreover, the ``common ancestor''  of  and  is unique up to
. 
\end{lemma}
Note that the ordering on worlds and world morphisms is discrete so
that continuity only refers to the  argument.
\fi
\iffull
\begin{definition}[Morphism of functors]\label{morphfun}
  If  are p.p.f., a morphism from  to  is a pair
   of continuous functions where
   and . A proof that
  morphisms  are equal is given by a continuous function
  .
\end{definition}
These morphisms compose in the obvious way and so
the faithful functors and morphisms between them form a category. 
\fi
\subsection{Fibred setoids}\label{fibse} In order to provide
meanings for computation types we need a weaker variant of p.p.f.,
namely, \emph{fibred setoids}. These lack the facility of transporting
values along world morphisms but instead allow the proof-relevant
comparison of values at different worlds provided the latter are
related by a pullback square.
\begin{definition}
\label{def:fibred-setoids}
  A \emph{fibred setoid} over a category of
  worlds  is given by a predomain  for every
   and for every pullback square  and
  elements  and  a set  so that
  the set of tuples  with  is a
  predomain with continuous projections.
 
  Next, we need continuous operations  so that  when  and  when
   and  when
   and .

  In addition, for any two isomorphic pullback squares  and
   between  and  there is a continuous operation
  of type .

  Finally, for each pullback square 
  with apex  and low point  there is a
  continuous function of type
\iffull

\else


\fi
\end{definition}
Note the similarity of the last operation to pullback-preservation. 

\begin{example}
  If  is a p.p.f.,\  we obtain a fibred setoid  as follows: 
   and if  with apex , 
 define the proof set . 
\iffull If  and
   are two composable pullback squares with
  composite  and  and , then the composite
proof of  is given
by . Indeed, if  is the apex of the
composite square  then   and  and  since  so the
two proofs compose in .  \fi
\end{example}
\iffull
\begin{lemma}\label{baf}
  Let  be a fibred setoid.  The elements  given by pullback
  preservation are unique up to .  If  is
  an isomorphism then there is a continuous function
   and it is bijective up to  with
  inverse . If  and  are isomorphic pullback squares then there are continuous back and forth functions 
. 
\end{lemma}
\fi
\begin{definition}
  A \emph{morphism}  from fibred setoid  to fibred setoid 
  is an equivalence class  of pairs of continuous functions  and
  . 

  Two such pairs   are identified if there exists a continuous 
function that assigns to each  and  a
proof . 
\end{definition}
\iffull \begin{lemma}\label{meanterm}
  If  is a p.p.f.\ and  is a fibred setoid then in
  order to specify a morphism from  to  with given first
  component  it is enough to provide a
  continuous function .
\end{lemma} 
\begin{proof}
  If  is a morphism we can define  by
   noting that .  Conversely, given  to define
   we pick a pullback square  with apex
   and  and , i.e., a proof in .  Applying
   to  yields the morphism ; moreover, applying  to

  yields .  Then,
   so that
  Lemmas~\ref{decomp} and \ref{baf} yield the desired proof in the square
  .

  The second part of the lemma about equality is just a restatement of
  the definition of equality of morphisms of fibred setoids. 
\end{proof}\fi
\iffull
\begin{lemma}
Let  be p.p.f.\ For every morphism  there  is a
morphism  such that . Thus, in
particular  is a full and faithful functor from the category  of
p.p.f.\ on  to the category of fibred setoids over . 
\end{lemma} 
\fi
\subsection{Contravariant functors and relations} \label{reles} The
role of the next concept is to give meaning to abstract stores.
\begin{definition}
  A contravariant functor  from a category of worlds
   to the category of setoids comprises for each  a \emph{nonempty} setoid  and for each morphism
   a setoid morphism  such that  preserves
  identities and composition.
\end{definition}
If  and  we
  write  or  for . Note that
  . Intuitively,  can be interpreted
as the abstract heap obtained by forgetting locations in  that have
been ``allocated'' by the world evolution specified by , namely, those 
appearing in \w and not in .
\iffull
The following definition corresponds to the p.p.f. used for values, but
now for abstract heaps: In particular, an abstract heap at the
low-point of a pullback square is the result of forgetting locations from
an abstract heap at its 
apex.
\fi
\begin{definition}
A contravariant functor  preserves \emph{minimal pullbacks}
if whenever  with apex  and low
point
 is a \emph{minimal pullback square} then 
the diagram  is a pullback in .
\end{definition}
This means in particular that if  and  
 then there exists a ``pasting''
 such that
 and
 and  is unique
up to . Moreover the passage from the given data to
 and the witnessing proofs is continuous. 
\iffull
Application to the trivial minimal pullback  and
nonemptiness yields the following result.
\begin{lemma}
\label{lem:unique-upto-sim}
   For every  and  there is
morphism of setoids  which is right
inverse to . 
\end{lemma}
The ``unique up to '' clause allows us in particular to assert the -equality of two abstract stores  by proving  and  separately when  is a minimal pullback  with apex .
\fi
\begin{definition}
A \emph{relation}  on such a contravariant functor 
consists of an admissible subset  such that  and  implies
 and if  and
 then , as well. 
\end{definition}

It would be natural to let relations be proof-relevant as well, but we
refrain from doing so at this stage for the sake of simplicity.

\section{Computational model}
\label{test}
We use a setoid interpretation in order to justify
nontrivial type-dependent observational equivalences for the
language above. This interpretation is parametric over an
\emph{instantiation},
defined below. 
\begin{definition}
An \emph{instantiation} comprises the following data. 

\noindent \textbullet~a category of worlds ;

\noindent \textbullet~a full-on-objects subcategory  of
\emph{inclusions}
  (in other words, a subset of the morphisms closed under composition
  and comprising the identities) with the property that every morphism
   can be factored as  and  with  isomorphisms and
   inclusions;

\noindent \textbullet~a contravariant, minimal-pullback-preserving, functor  from  to
the category of setoids;

\noindent \textbullet~for each  a relation
   subject to the axiom
  that  and  implies
  ;

\noindent \textbullet~a set of elementary effects  and for each
effect  a
set   of relations on . As usual, one defines
effects as sets of elementary effects and extends  to all
effects by  ``all relations on 
 (in the sense described in Section~\ref{reles})'' and
.
\end{definition}

We give \iffull three \else two \fi examples of instantiations. 
\ifapp
The appendix
\else
The long version 
\fi
contains a third example, mirroring our previous
model \cite{DBLP:conf/ppdp/BentonKBH09}.

\subsection{Sets of locations}
In the first one, called \emph{sets of locations}, worlds are finite
sets of (allocated) locations (taken from ) and their morphisms
are injective functions with inclusions being actual
inclusions. Abstract stores are given by  with , always,
and  given by renaming locations.

We put  whenever .  We only have
one elementary effect here, , representing the allocation of
one or more fresh names. Note that if  is a relation on 
then  is either total or empty and if  then
. A relation  is in
 if for every inclusion  one
also has , thus  is
oblivious to world extensions.

\iffull
\subsection{Flat stores} 
The second instantiation, called \emph{flat stores}, assumes that heap
locations contain merely integer values and no pointers. 
Possible worlds are
finite sets of locations together with a function that associates each
location a \emph{region} taken from a fixed set  of
regions. World morphisms must preserve this tagging. We write
 and  to mean that  occurs in 
and with region  in the second case.  Abstract stores
 comprise those heaps  with  and such that  and  implies that
 is an integer value,  for 
 (thus all locations hold integer
values). We put  in  iff for all 
one has . In this case there is a unique proof,
say .  For morphism  we define  by renaming concrete locations
according to . The elementary effects are  representing reading from within, writing
into, allocating within a region . The associated sets of
relations are given by
\iffull
3pt]

R\in\mathcal{R}(\wEff{\regid})&\iff& (\sigma,\sigma')\in R\w \Rightarrow
\forall \cloc\in \w(\regid).\forall v\in\mathbb{Z}.\Rightarrow 
(\sigma[\cloc{\mapsto}\intt{v}],\sigma'[\cloc{\mapsto}\intt{
v}])\in R\w
\
This essentially models the setting of our earlier relation-based
\else

3pt]

R\in\mathcal{R}(\wEff{\regid})&\iff& (\sigma,\sigma')\in R\w \Rightarrow
\forall \cloc\in \w(\regid).\forall v\in\mathbb{Z}.\Rightarrow 
(\sigma[\cloc{\mapsto}\intt{v}],\sigma'[\cloc{\mapsto}\intt{
v}])\in R\w
\

\noindent
This essentially models the setting of our earlier relation-based
\fi
account of reading, writing, and allocation with integer values stores
\cite{DBLP:conf/ppdp/BentonKBH09} the difference being that allocation
is modelled with relations on the same level as reading and writing
and that the stores being related share the same layout. 
\fi

\subsection{Abstract locations}
To formulate the \iffull third \else second \fi instantiation, called
\emph{Heap PERs}, we need the concept of an \emph{abstract location}
which generalises physical locations in that it models a portion of
the store that can be read from and updated. Such portion may comprise
a fixed set of physical locations or a varying such set (as in the
case of a linked list with some given root). It may also reside in
just a part of a physical location, e.g., comprise the two low order
bits of an integer value stored in a physical location. Furthermore,
the equality on such abstract location may be coarser than physical
equality, e.g., two linked lists might be considered equal when they
hold the same set of elements, and there may be an invariant, e.g.\
the linked list should contain integer entries and be neither circular
nor aliased with other parts of the heap. This then prompts us to
model an abstract location as a partial equivalence relation (PER) on
heaps together with two more components that describe how
modifications of the abstract location interact with the heap as a
whole. Thus, next to a PER, an abstract location also contains a bunch
of (continuous) functions that model \emph{writing to the} abstract
location. These functions are closed under composition (thus form a
category) and are idempotent in the sense of the PER modelling
equality.

Thirdly, a ``footprint'' which is a heap-dependent set of
physical locations which overapproximates the effect of ``the
guarantee'' so as to enable the creation of fresh abstract locations
not knowing the precise nature of the other abstract locations that
are already there. (These footprints are very similar to
accessibility maps, first introduced for reasoning in a model of state based on FM-domains \cite{DBLP:conf/tlca/BentonL05}.)

\begin{definition}
\label{def:abstract-location}
  An \emph{abstract location}  (on the chosen predomain
  ) consists of the following data:
\begin{compactitem}
\item a nonempty, admissible partial equivalence relation (PER)  on
   modelling the ``semantic equality'' on the bits of the
  store that  uses (a ``rely-condition'');
\item a set  of continuous functions on  closed by
composition, modelling the functions that ``write only on '' leaving 
other locations alone (a ``guarantee condition'');
\item a continuous function  describing the ``footprint''
   of the abstract location (where the ordering on the powerset
 is of course discrete).
\end{compactitem}
subject to the conditions
\begin{compactitem}
\item if  and  then ,  
\item if 
  and 
  then  implies
  ; thus  ``looks'' no further
  than the footprint;
\item if  and  then
   and
   implies  and .
\end{compactitem}
Two abstract locations  are independent if 
\begin{compactitem}
\item for  and  for  one has 

and

then ;
\item If  and 
there exists  such that  and
. (Amounting to
 being a cartesian product of  and .)
\end{compactitem}
If  are independent, we form a joint location
 by 
and
 and
. 

\end{definition}



If  is a concrete location, we can define an abstract
counterpart by putting  and  is the set with a
write function for each value that may be stored in . 
For instance, if  stores booleans, then  contains the
functions  and , where
 such that  and 
for all other locations , .
When  then the induced abstract locations are
independent.

The next example illustrates that abstract locations may be
independent although their footprints share some concrete locations.
Fix a concrete location  and define two abstract
locations  and  both with footprint consisting of the
location . Moreover,  belong, respectively, to
the rely of location  () if  and
 are both integers whose -th significant bit
agrees. The ``guarantee''  might then contain functions that
set the -th bit to some fixed value and leave the other bits
alone. It is easy to see that  are independent.

Thirdly, let  be two distinct concrete locations and
for heap  and finite integer sets  define
 to mean that in  the locations  point to non-overlapping integer lists with \emph{sets} of
elements  and . Now define abstract location  by
 
 and  ``locations reachable from
'' if  points to a well-formed list of integers in
 and  otherwise. The guarantee component 
contains all the (idempotent) functions  that leave the locations
not in the footprint of  alone. That ,
such that  for all .
Again,  and  are independent.

The role of the footprints  is to provide a minimum amount of
interaction with physical allocation. If  is an abstract
location and  the current heap so that
 then we may, e.g., allocate
, and define an abstract location
 by



\noindent
We now know that  and  are independent and, furthermore, 
. 
\begin{definition}
Abstract  locations  are mutually independent if they are pairwise independent and whenever  for  then there is  such that  for . 
\end{definition}
\begin{lemma}
Abstract locations  are mutually independent iff  are mutually independent and  is independent of . 
\end{lemma}
\subsection{Heap PERs}
We are now ready to formulate the \iffull third \else second \fi
instantiation \emph{Heap
  PERs}. We assume an infinite set of \emph{regions} . A
world  comprises a finite set of mutually independent abstract
locations (written ) and as in the case of flat stores a tagging of 
locations with regions from  
location. We write  to mean that 
is tagged with . We define  and
 and  otherwise. Again, 
iff . 

A morphism from  to  is given by an injective function  and a pair of partial continuous functions
. Intuitively, the function 
is used
to map the heaps in the PERs of locations in  to  according to the
renaming of locations specified in , while 
does the same but from  to . Formally,
 and . The same is valid for 
guarantees of locations, by replacing  by .
Now, .  Such a morphism  is an inclusion if
 is an inclusion and  are the identity function.

The elementary effects track reading, writing, and allocating at the
level of regions:  (writing within
region ),  (reading from within region ),
 (allocating within region ).
The sets of relations on  modelling elementary effects are then
given by 
\iffull
2pt]

R\in\mathcal{R}(\wEff{\regid})&\iff& 
(\sigma,\sigma')\in R\w \Rightarrow \forall \loc\in\w(\regid).\forall
\iota \in \loc^G. (\iota(\heap), \iota(\heap')) \in R\w\
Thus, a relation  ensures that
\else

2pt]

R\in\mathcal{R}(\wEff{\regid})&\iff& 
(\sigma,\sigma')\in R\w \Rightarrow \forall \loc\in\w(\regid).\forall
\iota \in \loc^G. (\iota(\heap), \iota(\heap')) \in R\w\

\noindent
Thus, a relation  ensures that
\fi
locations being read contain ``equal'' (in the sense of )
values; a relation  is oblivious to
writes to any abstract location in , and a relation
 is oblivious to extensions of the
current world provided that it only adds abstract locations in region
, that the initial contents of these newly allocated locations
are ``equal'' in the sense of  and that nothing else is
changed.

\section{Proof-relevant Logical Relations}
\label{sec:logical-relations}
Given an instantiation, e.g.\ one of the above examples, we 
interpret types (and typing contexts) as p.p.f.\ over
 and types with effect as a fibred setoid over . A
term in context  will be interpreted as a
morphism  from  to  where
 takes p.p.f.\ and effects to fibred setoids and is
given below in Definition~\ref{teffde}. Derivations of equations
will be interpreted as equality proofs between the corresponding morphisms
and can be used to deduce observational equivalences
(Theorem~\ref{obseq}). 

This, however, requires a loose relationship of the setoid interpretation
with the actual meanings of raw terms which is given by realization
relations . Their precise format and role are described in the
following two  definitions. 
\begin{definition}\label{defte}
  A \emph{semantic type} is a pair  where  is a
  p.p.f.\ (on ) and  is an admissible
  subset of  for each  such that for
  every inclusion  one has that  implies .  A \emph{semantic
computation} is a pair  where  is
  a fibred setoid over  and  is an
  admissible subset of  for each .
\end{definition}
\begin{definition}
  Let  and  be semantic types
  and let  be a semantic computation.  If
   is a morphism of fibred setoids and
   then we write  to mean that for some representative  of  one has that 
 whenever  then
   holds for all worlds .
\end{definition}

The following definition, corresponding to that in Fig.~\ref{fig:oldklr}, is where the machinery introduced above pays off.
In particular, it defines the semantics of computations, where proofs,
i.e., pullback squares, are constructed. 

\begin{definition}\label{teffde}\label{def:semantic-computation}
  Let  be a semantic type and  an effect. A semantic
  computation  is defined as follows: 

\smallskip
\noindent \textbullet~ (Objects) Elements of  are pairs
 of partial continuous functions where
\iffull

and  is as follows.  If  and
\else



\noindent
and  is as follows.  If  and
\fi
 then  either is
undefined and  and  are both
undefined or else  is defined and then
 and  are both defined, say
 and
. In this case,
 returns a pair 
where  such that .  Furthermore,  and,
finally,  where
 and  are low point and apex of 
.  

\smallskip
\noindent \textbullet~ (Proofs) As usual, proofs only look at the 
components.
  Thus, if  and  and  is in  with apex
  and low point  then a proof in  is a partial continuous function
   which given  and  and  either is undefined and then
   and  are both undefined or else
  is defined and then  and  are
  both defined with results, say,
   and
  . In this case,
   returns a tuple  satisfying
   and 
  with  and 
  in . 


\smallskip
\noindent \textbullet~ (Realization)
  If , we define  to mean that
  whenever   then  is defined iff
 is defined and if  and
 then
 and . 
\end{definition}
\iffull
\begin{proposition}
The semantic computation  as defined in
Definition~\ref{def:semantic-computation} is a fibred setoid.
\end{proposition}
\begin{proof}
  The tricky case is to show the existence of a transitive operation.
  It is here that we require the independence of abstract locations as
  stated in Definition~\ref{def:abstract-location}, which implies that
   is also minimal-pullback-preserving.

Assume that there are proofs in  and  where 
 and . We also have  and , such that they are equivalent in the pullback of
the low points of these two pullback squares. Let  be such
pullback. 

In order to use the proofs  and , we need to construct
from  and  an abstract heap .
Let  be the minimal pullback over the apexes of the two pullback
squares  and . Then  and  form a pullback
square with apex  and low point . Since
 is minimal-pullback-preserving, there is a , such that it is equivalent to  and  when
taken to the world . We now define  to be  taken to the world . We thus have , and , such that  and .

We can now use the  and . In particular, 
let , , and . From the proofs, we get two
pullback squares  and . It
is easy to show that the values obtained are equal in the minimal pullback over 
the
apexes of these two pullback squares and that the abstract heaps are
equivalent in the pullback of their low points.
\end{proof} 
\else
Proving that a semantic computation  as  in
Definition~\ref{def:semantic-computation} is a fibred setoid is 
nontrivial.  The tricky case is the existence of a transitivity
 operation. 
It is here that we need the independence of abstract locations as
stated in Definition~\ref{def:abstract-location}, which implies that 
 is also minimal-pullback-preserving. 
\fi
\iffull
\begin{definition}[cartesian product]
If  and  are semantic types their cartesian product  is defined by  (cartesian product of setoids) and . 
\end{definition}
\begin{definition}[function space]
  Let  be a semantic type and  be a
  semantic computation. We define a semantic type  as follows.  
  An object  of  is a pair  of
  continuous functions where  assigns to each  and
   a continuous function . The second component  assigns to each
   and  a continuous
  function .


  If  then a proof  is a continuous function assigning to each
   and  a proof .

  If  and 
  then  is given by precomposition with
  , i.e., , etc.



  As for the realisation relation  we put
   to mean that  for some
   and whenever  is an inclusion and
   then .
\end{definition}
Notice that unlike morphisms the elements of the function space are \emph{not} identified if they are ``provably equal.''. 
Notice also that if  implies
 whenever 
is an inclusion.
\else
Details, along with the construction of the cartesian product
 and function space
 , given semantic types
  and  and computation ,
may be found in the 
\ifapp
appendix.
\else
long version of the paper.
\fi
\fi
\subsection{Fundamental theorem}
Given a semantic type  for each basic type
 we can interpret any type  as a semantic type 
by putting
. A
typing context  is interpreted
as the semantic type

where  is the constant functor returning the discrete setoid
.

To every typing derivation  we then
associate a morphism 

such that . 
(Note: \emph{this} is point where the untyped semantics is related with the
abstract one.)
For every equality derivation  we
have ,
where the two typing derivations  and
 are the canonical ones associated with
the equality derivation .
\iffull 
In what follows we define semantic counterparts to the generic
syntactic constructions common to all instantiations, namely
application and abstraction, sequential composition, and recursion
that allow us to define this interpretation of derivations in a
compositional fashion. Having given these semantic counterparts we
then omit the formal definition of the interpretation .
\begin{lemma}[Abstraction]
Let  be  semantic types,  a semantic computation. There is a function  so that if  is a morphism of fibred setoids then . Moreover, if  then  and if  then . 
\end{lemma}
\begin{lemma}[Application]
Let  be a semantic type and  be a semantic computation. There  is a
morphism  and
.  
\end{lemma}
We elide assertions about -versions of beta-eta-equality, and semantic 
rendering of subeffecting and the existence of ``value morphisms'' of type  for any semantic type . 


\begin{lemma}[let]
Let  be semantic types and  an effect. 
There is a function  such that if  and  are morphisms
then . Moreover, if
 and  then . 
Finally, if  and
 then . 
\end{lemma}

\begin{proof}
Consider the following definition for the first component of the morphism
 which is only defined when  and
 are defined. The type of this component is . Hence, assume a world , and a context , then one returns an object . The first component  is:

where .

For the second component, , assume a relation , and two abstract heaps 
such that . From  we get a 
proof , where
 and , such that  and . Applying  on  and
 we get a proof ,
such that . However,
we need to show that the heaps obtained from applying  on 
and  (using the correct world and context), namely 
and , are related. For this we rely on
the morphism . In particular,
we use  on the pullback  and
obtain a pullback  such that  and

are equal in its low point. Similarly, applying  on the
pullback , we get a pullback 
, where  is equal to
 in its pullback. Using Lemma~\ref{preo}, we compose the
pullbacks ,  and , obtaining a common pullback , where 
 and  when taken to  are in . 

The morphism  can be then defined when 
and  are defined.
Assume a pullback  and an abstract heap  and a context . Using the
morphism between  and  on these objects, we obtain a
pullback ,  and , where  and . 
From the pullback preserving property of computations and ,
there is a common value  and context
 which are equal, respectively, to
 and , and  and  (when taken to the
correct world). We then construct a
proof . We now apply twice the
morphism between  and  once in the pullback  and
another on the
pullback , obtaining two pullbacks
 and . From
Lemma~\ref{preo}, we can compose them where the resulting values and
heaps are equal.
\end{proof}
\begin{lemma}[fix]\label{fixlse}
  Let  be semantic types so that for each  the predomain
   is a domain with least element  such that
   holds for every proof  and such that  holds for every
  .\footnote{For example 
for semantic types .}
\begin{compactenum}
\item[i] There then exists a function
   so that whenever  then
  
\item[ii] If  then . Furthermore, the fixpoint and unrolling equations
  from Lemma~\ref{fixlse} hold. 
\item[iii] Finally, if  then
.    
\end{compactenum}
\end{lemma}
\begin{proof}
{\bf MH: dagger notation and accompanying lemma have disappeared} 
For every  we have . We can thus form .  It remains to define . To do that, we
recall that we 
have an ascending chain of elements 
 given by 
 and 
 and have
. 
Now suppose that  and  and
 and . Write
 and .
Inductively, we get proofs  where  (note that
) and . Since
 we obtain by
monotonicity of  and induction that  is an ascending
chain with supremum  for some proof 
which we take as . Note that the passage from  to
 is continuous. 
\end{proof}
\else 
In essence, one has to provide a semantic counterpart for every
syntactic concept, e.g. let, fix, etc. Details are in the 
\ifapp
appendix.
\else
long
version.
\fi
\fi


























\subsection{Observational equivalence}
Let  stand for the constant functor that returns the
discrete setoid on the set  of integers. We define
. We also assume that there
is some initial store and abstract store  and a
world  such that . For instance,
 can be the empty world with no locations and accordingly
 the initial store at startup. 

\begin{definition}
  Let  be a semantic type.  We define an
  \emph{observation of type } as a morphism  for some  and a function  so that
  .

  Two values  are \emph{observationally equivalent at type }
  if for all observations  of type  one has that  is
  defined iff  is defined and when
   and 
  then .
\end{definition}
Taking  immediately yields the following:
\begin{proposition}
If  are observationally equivalent at type  and  is a
term such that  then 
is
  defined iff  is defined and when
   and

  then .
\end{proposition}
\begin{theorem}[Observational equivalence]
\label{thm:obs-equivalence}\label{obseq}
If  is a semantic type and  and
 with  in  then  and   are
observationally equivalent at type . 
\end{theorem}
\begin{proof}
  We have  and  and also  in  for some  as in Definition~\ref{teffde}.

The application  to  either is
undefined in which case  and  and
 and  are all undefined, the latter by
the definition of . Otherwise, we get
 and  and
 and 
where, by definition of realization in  and
, we have  and . Now,
 returns a pullback
 such that, in particular, , whence  since  is constant and then
 as required.
\end{proof}


\section{Applications}
\label{sec:application}
In what follows we use our semantics to establish a number of
effect-dependent semantic equalities, hence program equivalences in
the sense of observational equivalences. We also give some
semantically justified typings of concretely given functions, in
particular ``set factory'' described in Section~\ref{examples}.
More examples are discussed in the 
\ifapp
appendix.
\else
longer version of this paper.
\fi

\subsection{Sets of locations}
We work in the instantiation ``sets of locations''.  Recall the
example, ``dummy allocation'' from Section~\ref{examples}.  Suppose
that . Now, put
, where  is the heap
obtained by adding a dummy location to \heap. We have
 since  is oblivious to
extensions of the store. Therefore, reflexivity also furnishes a proof
of equality. It also means that, semantically, 
does not need to flag the allocation effect  since no
semantically visible world extension takes place. 

For the Interleaved Dummy Allocation example, on the other hand, there is
an extra step caused by the proper allocation, which yields a world
extension  and . In order to show the equivalence, we construct a
proof, i.e., a pull-back square , where the
allocated concrete locations are identified in its low point. Then the
reasoning is the same as above used for showing the semantic equivalence
of the Dummy example.

This is different in the following example. Define a semantic type 
of names by letting  be the discrete setoid on the set  and
 and .
\iffull


\noindent
We now define semantic counterparts , 
. We omit the dummy
arguments of type .
\else
Moreover, 
, and .
We now define semantic counterparts , 
, where
\fi
\iffull

Here and in what follows it is assumed that
\else



\noindent
Here and in what follows it is assumed that
\fi
 and
 and
 and . Recall that
. Finally,  and
 stand for the obvious inclusions.  We use
analogous definitions for the primed variants.

In order to define  we start with
 and ,
 such that . Define
 so that , that is
, . We now return the
pullback square  with apex  and low
point  and the trivial proof that . This 
settles the definition of , since  is total since
. Notice though, that we cannot avoid the allocation
effect here.

The functions  and  are defined analogously.

We now construct a proof that , recall that only
 and
 are needed for this. Given  and the notation from
above this proof amounts to a pullback square
 such that  and
 and . Note that, accidentally, the final abstract stores of
both computations are the same, namely, . Now let  be the
bijection that swaps  and fixes everything else. We
then put .  Now, obviously
 and -equality of
abstract stores is trivial by definition.

\subsection{Heap PERs}
In this section we generalize our earlier collection of effect-dependent program
equivalences 
\cite{DBLP:conf/ppdp/BentonKBH07} to the abstract locations of the
Heap PERs instantiation. We first show how the
set factory indeed has the announced effect typings and thus can
participate in effect-dependent equivalences.

\paragraph{Set factory}
Let  be a world and . Suppose that 
arises from  by allocating a fresh set data structure, e.g., a
linked list, with entry point(s) . Let  be the abstract
location describing this fresh data structure, i.e.,
 the data structures starting from 
in  are well-formed, denote the same set, and do not
overlap with the footprints of all the abstract locations in . The
footprint  comprises the locations that make up this 
data structure assuming that , otherwise any
value can be chosen. Finally,  contains idempotent
functions, , such that 
and  agree on all concrete locations from
 and, moreover,
. 

Now for any chosen region  we add  to  to
yield a new world . The function 
then returns  and a tuple of semantic functions for reading,
membership, removal of which we only sketch reading here: If
 and  and
 then the reading function looks up  in the data
structure starting at the entry points  in . (Note that
 asserts that this data structure exists and is
well-formed.) The returned (abstract) store  might not be the
same as  because internal reorganizations, e.g., removal of
duplicates, might have occurred. However, no world extension is needed
and
 holds. This together with the fact that
the outcome only depends on the  equivalence class \iffull(in the
proof-relevant sense)\fi justifies a read-only typing for reading. 

\iffull
In order to model the object-oriented version with a basic type
 for each region , we can use the p.p.f.\
 and
 is of the above format and 
. Equality on  is discrete and one puts
. The indirection through  is
necessary so that we recognize that a given abstract location is
indeed a ``set''.
\fi
\paragraph{Memoization} For the simple  functional
from Section~\ref{examples} we produce just as in the previous example a
fresh
abstract location  that contains the two newly allocated
concrete locations, say , and on which we impose the
invariant 
 contain the same integer value, say 
and that  both contain the integer value
 where  is the pure function to be memoised.\iffull We see in
Lemma~\ref{lemmasix} that if a function is semantically pure (empty
effect) then there is a world- and store-independent function
describing its action.\fi

\iffull
\subsubsection{Effect-dependent equivalences}
\else
\paragraph{Effect-dependent equivalences} Consider the following
notation
\fi

\iffull
Before we prove the soundness of a number of program equivalences, 
we introduce some notation. Given a set of effects , we write 
, ,   and . Moreover, the set . We also introduce the following piece of notation for
:

which specify that the abstract heaps  and  are
\else 



\noindent
which specify that the abstract heaps  and  are
\fi
equivalent on all the abstract locations  in regions associated,
respectively, to read effects and no-writes in .  


\begin{lemma}\label{lemmasix}
\label{lem:invariant}
Let . For any world ,
and context , whenever  such that , then  and
 where  are
equally defined  and if  and 

then there exist (continuously!) a pullback 
  with apex
 and low point  and a proof of  such that  and the following is satisfied:
\begin{compactenum}
 \item for all , we have either: 
and  (remain
equivalent) or
 (equally modified);
 \item if , then  and .

\item There exists a morphism , such that   and if
, then for all regions ,
. 
\end{compactenum}
\end{lemma}
\iffull\begin{proof}
The proof that the values are equal in  follows directly from 
the definition of computations and effects.


For the first part,  we use the following relation  defined for all
worlds , such that :



\noindent
Otherwise, for the worlds  not reachable from \w, the relation
 is the trivial set. Notice that  and it is
contravariant. The claim then 
follows directly.

The proof of the second part follows in a similar fashion, but we use the
following relation:



\noindent
And we use a similar relation for showing that  and
 agree on the not written locations .

For the third property, first, we show that there is an
isomorphism between  and  for all regions
 by using the following relation:



\noindent
where  denotes the number of abstract locations coloured with 
.
Clearly,  as  does not contain any allocation effects. This gives
us one direction, while the other direction is obtained by the universal
property of pullbacks. Given this property, one can easily construct the 
function .
\end{proof}
\begin{proposition}\label{compr}
(commuting computations) Suppose that:
 and
,
where  . Let 

then .
\end{proposition}

\begin{proof}
Assume a world \w and a context .
Let  for
. 

It is enough to assume a pullback 
, and an abstract heap . 
Assume that these functions are defined as follows:



\noindent
One can easily show that when one of these functions is undefined, then 
the corresponding function is also undefined. 

We need to show that there is a proof  such that
 and 
and .
Decompose , where
. 
The existence of such decomposition follows from the disjointness of write
effects in  and .

From Lemma~\ref{lem:invariant} and from 
the disjointness of reads and writes, it is the case that  and
 agree on the locations in .
That is, there is a proof , defined 
using the proof , where .
Applying  to the objects above,
we get the pullback , and  proof . Symmetrically, we obtain the proofs 
, and  . Hence, there is also a proof in the larger world .

To see informally that the final heaps  and  are
equal, we use
the following facts obtained using Lemma~\ref{lem:invariant}: 
and  agree on the locations in ; moreover, 
 and  agree on the locations in ; 
hence  and  agree on the locations in . Symmetrically, we can also argue that  and 
agree on the locations in . Composing these proofs 
(see comment after Lemma~\ref{lem:unique-upto-sim} why this is allowed), 
we get that  and  agree on the locations in . 
Finally, since the locations allocated by one computation are not used by
the other computation, the final heaps are equal at the
apex world.
\end{proof}

The following propositions are also provable. All propositions are proved
in a similar way as the soundness proof of the commuting case, using 
Lemma~\ref{lem:invariant} when needed. For instance, the soundness proof
of the duplicated computation uses the third case in
Lemma~\ref{lem:invariant}.

\begin{proposition}[dead computation]\label{dead}
Suppose that
,
that \iffull  \else 
 contains no writes \fi and that  is defined for all
. 
Then if for all worlds \w, all contexts , and abstract heaps ,
the function  is defined, 
then .
\end{proposition}

\begin{proof}
Assume a world \w and a context .
Let . 
It is enough to assume a pullback 
, and an abstract heap . Let . We need to construct a pullback such that  is equivalent
to  in its apex and  is equivalent to  in
its low point. Consider the pullback . Clearly
, and therefore the values are equivalent in .
Moreover, from the fact that ,  and  agree on all locations in .
Hence, , which finishes the proof. 
\end{proof}


\begin{proposition}[duplicated computation]\label{dupl}
  Suppose that  and suppose
that
  . Thus, 
  reads and writes on disjoint portions of the store and makes no
  allocations. The the terms   and  below

 are contextually equivalent. That is
formally .
\end{proposition}

\begin{proof}
Assume a world \w and a context .
Let . 
It is enough to assume a pullback 
, and an abstract heap . 
From Lemma~\ref{lemmasix} and since these functions do not allocate, we
can assume that they do not cause any world extension and are therefore
defined as follows:

We need to show that the values  and  are equivalent and 
the heaps , obtained by applying once , and ,
obtained by applying twice , are also equal. 

Decompose , where  contains all
the regions read by  and  all the regions written by . This is
possible because of the disjointness of of 's read and write effects. 
From Lemma~\ref{lemmasix} and the disjointness of  's read and write
effects, we have that  and  agree on the regions read
by , that is, . Hence, again
from Lemma~\ref{lemmasix}, we have that the values  and 
are equal. Moreover, the locations in  are equaly written, while the
locations in  are left unchanged, that is,
 and  agree on the location in .
\end{proof}

\begin{proposition}[pure lambda hoist]\label{hoist}
Suppose that  and 

Let  and  be respectively  and
. 
Then .
\end{proposition}


\begin{proof}
Assume a world \w and a context .
Let  and 
. 
It is enough to assume a pullback 
, and an abstract heap . Since  has no effects, we have no world extension:

Moreover, from Lemma~\ref{lemmasix},  and  agree on
all locations. We now show that 

In order to prove this, assume a morphism  and . We need then to prove that the computations resulting from 
applying  to the functions above are equivalent in the pullback
. For this, assume an abstract heap . Since  has no effect, we have no world extension:

Since  is pure, we have  and from
Lemma~\ref{lemmasix} we have that  and  agree on all
locations in  and in particular on locations read by . Hence, 
again by Lemma~\ref{lemmasix} the pullback proof exists where 
and 
 are equal in its low point and the resulting values are equal
in its apex.
\end{proof}
\else
We can validate all the effect-dependent program equivalences ``dead,
commuting, duplicated computation'' and ``pure lambda hoist'', as well
as the ``masking rule'' from previous work \cite{DBLP:conf/aplas/BentonKHB06} in our new, more powerful,
setting.
To give an impression of the
formulation of these validations we state the corresponding proposition for
``dead computation'' which is particularly interesting in that it contains
a termination precondition. The proof, and details of the other
equations are in the 
\ifapp
appendix,
\else
long version, 
\fi
which also 
contains a validation of loop unrolling optimisation 
described by Tristan and Leroy \cite{tristan10popl}. 
 \begin{proposition}[dead computation]\label{dead}
Suppose that
,
that  and that  is defined for all
. 
Then if for all worlds \w, all contexts , and abstract heaps ,
the function  is defined, 
then .
\end{proposition}
 \fi
\iffull
\begin{figure*}[t]
\begin{center}
\begin{small}
\begin{tabular}{l@{\quad}l@{\quad}l@{\quad}l}
Body of Loop & Prolog & Steady Program & Epilogue\\
\texttt{x := load(p);} & \texttt{p1 := p;} &
\texttt{store(p1, y);}
\textbf{[]} & \texttt{store(p1, y);}
\textbf{[]}\\ 

\texttt{y := x * c;} & \texttt{p2 := p;} & \texttt{p1 := p2 + 8;} &
\texttt{y := x2 * c;} \\

\texttt{store(p, y);} & \texttt{x1 := x;} & \texttt{y := x2 * c;}
& \texttt{store(p2, y);} \textbf{[]}\\

\texttt{p := p + 8;} & \texttt{x2 := x;} & \texttt{x1 := load(p1);
\textbf{[]}} & \texttt{x := x2;}\\

\texttt{i := i + 1;} & \texttt{x1 := load(p1);}
\textbf{[]} &
\texttt{store(p2, y);} \textbf{[]}
& \texttt{p := p2;}\\

& \texttt{p2 := p1 + 8;} & \texttt{p2 = p1 + 8;}\\
& \texttt{x2 := load(p2);} \textbf{[]} &
\texttt{y
= x1 * c;}\\

& \texttt{y := x1 * c;} & \texttt{y = load(p2);
\textbf{[]}}\\

& \texttt{i := i + 2;} & \texttt{i := i + 2;}\\
\end{tabular}
\end{small}
\vspace{-2mm}
\end{center}
\caption{Program obtained from the loop unrolling technique. Here
\texttt{p}, \texttt{p1} and \texttt{p2} are pointers and all \texttt{load}
and \texttt{store} operations are on 64 bit numbers (float).}
\label{fig:loop-unrolling}
\vspace{-4mm}
\end{figure*}

\subsection{Loop Unrolling}
Loop unrolling is a software pipelining technique used to enhance the use
of parallel processing. The idea is instead of iterating a loop 
in a sequential manner, one attempts to process a number of iterations
of the loop at the same time using multiple processors.

As described in \cite{tristan10popl} implementing and proving the
correctness of loop unrolling techniques is hard as
one needs to demonstrate that the program resulting from loop unrolling
that can be executed in parallel is equivalent to the original sequential
program. We briefly illustrate the power of our system with regions and
effects by one of the running examples in \cite{tristan10popl}. Consider
a loop program whose body is depicted in Figure~\ref{fig:loop-unrolling}.
Intuitively, this program is multiplying all the elements of an array of 
float values by the value \texttt{c}. Clearly, instead of executing this
program sequentially, we can execute different iterations in parallel. 
In particular, after applying the loop unrolling optimization to a program,
one obtains a program that is divided in three parts: the prolog, that
initializes all the variables, the steady state, that is iterated, and the
epilogue, that is executed when the loop condition is no longer true and
the loop is over. Figure~\ref{fig:loop-unrolling} contains the program
obtained by loop unrolling two iterations of the program above. The Prolog
and the Epilogue are executed at the beginning and the end, respectively,
while the Steady Program may be executed several times. 

The task is to show that the optimized program is equivalent to the
sequential program above. Using the unrolling equations from
Lemmas~\ref{fixlse} we can unroll the loop twice
() and extract a prologue. We can then conclude with
effect-dependent equivalences, in particular Prop.~\ref{compr} as
follows. We use two regions 
and . All even elements of the array, that is, \texttt{p},
\texttt{p + 16}, \texttt{p + 32}, \ldots, belong to the region ,
while all odd elements, that is, \texttt{p + 8},
\texttt{p + 24}, \texttt{p + 40}, \ldots, belong to the region .
Given this setting, the read and write effects are as shown in
Figure~\ref{fig:loop-unrolling}. It is now a simple exercise to show that
any execution of the optimized program is equivalent to an execution of
the sequential program. For instance, any instruction with a read effect 
on  can be permuted so that it appears immediately before the
following instruction with write effect  on the same region
. This is possible because the only effect between these two
instructions is a read on the other region . The same is true
for permuting instructions that read on . 

\fi
\subsection{State Dependent Abstract Data Types (ADT)}
We prove the equivalence of a number of programs involving state dependent
abstract data types. 

\paragraph{Awkward Example}
 The first example is Pitts and Stark's classic \emph{awkward}
example\cite{pitts98high}. Consider the
following two programs:
\iffull

Intuitively, the expressions  and  are equivalent as they both
\else



\noindent
Intuitively, the expressions  and  are equivalent as they both
\fi
return the value , although  uses a fresh location to do so.
We can formally prove the equivalence of these functions as follows:
Assign the region where  is allocated as . If  has the type
 with effects , then  has 
type , while 
 has type . Notice that   may contain

or  or both. Moreover,
assume that the footprint of a location in
region \regid\ consists of a single concrete location \cloc, and that the
guarantee of a location  consist of a single function
 such that  where
 and  for all other
locations. Clearly  has such a write effect.

For proving the equivalence of  and , assume a world  and an
abstract heap . Let  and . We need to construct a pullback square  such that the values 
and  are equal in its apex and  and  are equal
in its low point. Since  is in the effects of , we
have that . We also have  trivially. Hence
 and  are equal in the apex of the pullback square . Similarly,  when
taken to the low point of the square, that is, where the locations in
 are forgotten, the resulting heap is equivalent to .


\paragraph{Modified Awkward Example} 
Consider now the following variant of the Awkward example, due to
Dreyer et al.\cite{dreyer10icfp}:
\iffull

The difference is that in the first program  is written to  and the
\else



\noindent
The difference is that in the first program  is written to  and the
\fi
call-back function is used twice. Interestingly, however, the solution
given for the Awkward example works just fine. We can prove semantically
that the type of the program  has the same type as before in the
Awkward example, where the only writes allowed on abstract location
assigned for  is to write one.
Therefore, if  has effect of writing on the region , it will set
 to one.

\paragraph{Callback with Lock Example}
We now show equivalence of the following programs, also due to Dreyer
et al.\cite{dreyer10icfp}:
\iffull

\else



\noindent
\fi
Both programs produce a pair of functions, one incrementing the
value stored in  and the second returning the value stored in .
The boolean reference  serves as lock in the
incrementing function. 
Once this function is called the value in  is set to
 and only after calling the call-back, the value in
 is incremented is  set again to . However, the
implementation of 
the increment function is different. While the program to the 
left calls the call-back function  and then increments the value of
 using the value stored in , the program to the right remembers (in
) the value of  before the call-back is called and then uses it to
increment the value stored in . 

Assume that  and  are in the footprint of the same abstract location
() in the
region . We show that these programs are equivalent under the type
\iffull

 where  may contain the effects
\else



\noindent
 where  may contain the effects
\fi
. In particular, the location  is
specified as follows: its footprint consists only of the concrete
locations storing  and , written  and , while its
rely-condition is equality. The more interesting is its guarantee condition
(), which contains 
the following idempotent functions  for :
 if  and  if , where  if
 and ; 
moreover, the value of  is unchanged, that is, .
It is easy to check that these functions are idempotent as well as their
composition. 

First, notice that indeed the two functions above have type 
as the increment of  is captured by using some write function

and moreover  is . Now, to show that the two programs above
are equivalent, we need to show that the value stored in  before and
after the call back is called is the same. This is the case, as even if
, the value stored in  is , which means
that any function  used will leave the concrete locations storing 
and  untouched.

Notice that if the read function also called the call-back, then the
reasoning above would break, as the call-back could modify the value
stored in  because  is .



\section{Conclusions}
\label{sec:conclusions}
We have laid out the basic theory of proof-relevant logical relations
and shown how they can be used to justify nontrivial effect-dependent
program equivalences. We have also shown that proof-relevant logical
relations give direct-style justifications of the Pitts-Stark-Shinwell
equivalences for name generation. For the first time it was possible
to combine effect-dependent program equivalences with hidden
invariants allowing ``silent modifications'' that do not count towards
the ascription of an effect.
Earlier accounts of effect-dependent program equivalences
\cite{DBLP:conf/popl/KammarP12,DBLP:conf/ppdp/BentonKBH09,DBLP:conf/ppdp/BentonKBH07,DBLP:conf/aplas/BentonKHB06,DBLP:conf/icfp/ThamsborgB11}
do not provide such possibilities.

Proof-relevant logical relations or rather the sets  where 
is a semantic type bear a vague relationship with the \emph{model
  variables} \cite{DBLP:journals/spe/CheonLSE05} from ``design by
contract'' \cite{DBLP:journals/computer/Meyer92} and more generally
data refinement \cite{DBLP:books/cu/RoeverE1998}. The commonality is
that we track the semantic behavior of a program part with abstract
functions on some abstracted set of data that may contain additional
information (the ``model''). The difference is that we do not focus on
particular proof methods or specification formalisms but that we
provide a general, sound semantic model for observational equivalence
and program transformation and not merely for functional
correctness. This is possible by the additional, also proof-relevant
part of the semantic equality proofs between the elements of the
models. We also note that our account rigorously supports higher-order
functions, recursion, and dynamic allocation. 



Our abstract locations draw upon several ideas from separation logic
\cite{DBLP:conf/lics/Reynolds02}, in particular footprints and the
conditions on rely/guarantee assumptions from
\cite{DBLP:conf/concur/VafeiadisP07}. Intriguingly, we did not need
something resembling the ``frame rule'' although perhaps the
-quantification over larger worlds in function spaces plays its
role.

Pullback-preserving functors and especially the instantiation
\emph{sets of locations} are inspired by FM-sets 
\cite{DBLP:journals/fac/GabbayP02} or rather the \emph{Schanuel topos}
to which they are equivalent (see Staton \cite{statonphd} for a
comprehensive account). The instantiations other than \emph{sets of
  locations}, as well as the use of setoids for the ``values'' of
these functors rather than plain sets is original to this work.

\iffull
For a while we worked with groupoids instead of setoids.  At some
point though we found that the required equations between proofs are
needed only to establish other such equations, never in order to prove
something that does not mention them and we thus took the somewhat
bold step to give up all equations between proofs leading us to
setoids. Should we ever want to model dependent types where the index
types are already nontrivial setoids then the passage to groupoids would
become necessary for then, by way of substitution, equality proofs
interfere with actual (semantic) terms. E.g.\ if  then we
expect a function  from  to .
\fi

We would like to have a semi-formal format that allows one to
integrate semantic arguments with typing and equality derivations more
smoothly. We would also like to allow proof-relevant partial
equivalences in the Heap PER instantiation, which essentially amounts
to the ability to store values with proof-relevant equality. In
particular, this would allow us to model higher-order store with some
layering policy  \cite{DBLP:journals/iandc/Boudol10}. For
unrestricted higher-order store as in
\cite{DBLP:conf/icfp/ThamsborgB11}, but with abstract locations, one
would need to overcome the well-known difficulties with circular
definition of worlds. Step-indexing \cite{DBLP:conf/esop/Ahmed06} is
an option, but we would prefer a domain-theoretic solution. The formal
similarity of our abstract locations with the rely-guarantee formalism
\cite{DBLP:journals/logcom/ColemanJ07,DBLP:conf/concur/VafeiadisP07}
suggests the intriguing possibility of an extension to concurrency.

We also believe that update operations governed by finite state
machines \cite{DBLP:conf/popl/AhmedDR09} can
be modelled as an instance of our framework and thus combined with
effect-dependency. The application of our general framework to effects other
than reading, writing, allocation deserves further investigation.

Indeed, we feel that with the transition to proof-relevance we have
opened a door to a whole new world that hopefully others will
investigate with us. 
\iffull
\bibliography{bib}
\else
\vspace{-2mm}
\begin{thebibliography}{10}

\bibitem{DBLP:conf/popl/AhmedDR09}
A.~Ahmed, D.~Dreyer, and A.~Rossberg.
\newblock State-dependent representation independence.
\newblock In {\em POPL}, 2009.

\bibitem{DBLP:conf/esop/Ahmed06}
A.~J. Ahmed.
\newblock Step-indexed syntactic logical relations for recursive and
quantified
  types.
\newblock In {\em ESOP}, volume 3924 of {\em LNCS}, 2006.

\bibitem{DBLP:journals/jfp/BartheCP03}
G.~Barthe, V.~Capretta, and O.~Pons.
\newblock Setoids in type theory.
\newblock {\em J. Funct. Program.}, 13(2):261--293, 2003.



\bibitem{DBLP:conf/ppdp/BentonKBH07}
N.~Benton, A.~Kennedy, L.~Beringer, and M.~Hofmann.
\newblock Relational semantics for effect-based program transformations
with
  dynamic allocation.
\newblock In {\em PPDP}, 2007.

\bibitem{DBLP:conf/ppdp/BentonKBH09}
N.~Benton, A.~Kennedy, L.~Beringer, and M.~Hofmann.
\newblock Relational semantics for effect-based program transformations:
  higher-order store.
\newblock In {\em PPDP}, 2009.

\bibitem{DBLP:conf/aplas/BentonKHB06}
N.~Benton, A.~Kennedy, M.~Hofmann, and L.~Beringer.
\newblock Reading, writing and relations.
\newblock In {\em APLAS}, volume 4279 of {\em LNCS}, 2006.

\bibitem{DBLP:conf/tlca/BentonL05}
N.~Benton and B.~Leperchey.
\newblock Relational reasoning in a nominal semantics for storage.
\newblock In {\em TLCA}, volume 3461 of {\em LNCS}, 2005.

\bibitem{DBLP:conf/lics/BirkedalCRS98}
L.~Birkedal, A.~Carboni, G.~Rosolini, and D.~S. Scott.
\newblock Type theory via exact categories.
\newblock In {\em LICS}, pages 188--198. IEEE Computer Society, 1998.

\bibitem{DBLP:journals/iandc/Boudol10}
G.~Boudol.
\newblock Typing termination in a higher-order concurrent imperative
language.
\newblock {\em Inf. Comput.}, 208(6), 2010.

\bibitem{DBLP:conf/mfps/CarboniFS87}
A.~Carboni, P.~J. Freyd, and A.~Scedrov.
\newblock A categorical approach to realizability and polymorphic types.
\newblock In {\em Proc.\ MFPS, Springer LNCS 298}, pages 23--42, 1987.

\bibitem{DBLP:journals/spe/CheonLSE05}
Y.~Cheon, G.~T. Leavens, M.~Sitaraman, and S.~H. Edwards.
\newblock Model variables: cleanly supporting abstraction in design by
  contract.
\newblock {\em Softw., Pract. Exper.}, 35(6):583--599, 2005.


\bibitem{DBLP:journals/logcom/ColemanJ07}
J.~W. Coleman and C.~B. Jones.
\newblock A structural proof of the soundness of rely/guarantee rules.
\newblock {\em J. Log. Comput.}, 17(4):807--841, 2007.

\bibitem{DBLP:conf/vstte/Dinsdale-YoungGW10}
T.~Dinsdale-Young, P.~Gardner, and M.~J. Wheelhouse.
\newblock Abstraction and refinement for local reasoning.
\newblock In {\em VSTTE}, volume 6217 of {\em LNCS}, 2010.

\bibitem{dreyer10icfp}
D.~Dreyer, G.~Neis, and L.~Birkedal.
\newblock The impact of higher-order state and control effects on local
  relational reasoning.
\newblock In {\em Proc. ICFP, ACM}, pages 143--156, 2010.

\bibitem{DBLP:journals/fac/GabbayP02}
M.~Gabbay and A.~M. Pitts.
\newblock A new approach to abstract syntax with variable binding.
\newblock {\em Formal Asp. Comput.}, 13(3-5):341--363, 2002.

\bibitem{DBLP:conf/lfp/GiffordL86}
D.~K. Gifford and J.~M. Lucassen.
\newblock Integrating functional and imperative programming.
\newblock In {\em LISP and Functional Programming}, 1986.

\bibitem{DBLP:conf/lics/HofmannS94}
M.~Hofmann and T.~Streicher.
\newblock The groupoid model refutes uniqueness of identity proofs.
\newblock In {\em LICS}, 1994.

\bibitem{DBLP:conf/esop/JensenB12}
J.~B. Jensen and L.~Birkedal.
\newblock Fictional separation logic.
\newblock In {\em ESOP}, volume 7211 of {\em LNCS}, 2012.

\bibitem{DBLP:conf/popl/KammarP12}
O.~Kammar and G.~D. Plotkin.
\newblock Algebraic foundations for effect-dependent optimisations.
\newblock In {\em POPL}, 2012.

\bibitem{DBLP:conf/tldi/KrishnaswamiBA10}
N.~Krishnaswami, L.~Birkedal, and J.~Aldrich.
\newblock Verifying event-driven programs using ramified frame properties.
\newblock In {\em TLDI}, 2010.

\bibitem{krishnaswami:superficially}
N.~Krishnaswami, A.~Turon, D.~Dreyer, and D.~Garg.
\newblock Superficially substructural types.
\newblock In {\em ICFP}, 2012.

\bibitem{leywild:scsl}
R.~Ley-Wild and A.~Nanevski.
\newblock Subjective concurrent separation logic.
\newblock submitted for publication, Jan. 2012.


\bibitem{DBLP:journals/computer/Meyer92}
B.~Meyer.
\newblock Applying "design by contract".
\newblock {\em IEEE Computer}, 25(10):40--51, 1992.


\bibitem{moggi1991notions}
E.~Moggi.
\newblock Notions of computation and monads.
\newblock {\em Information and Computation}, 9(1):55--92, 1991.


\bibitem{DBLP:books/cu/RoeverE1998}
W.~P. de~Roever and K.~Engelhardt.
\newblock {\em Data Refinement: Model-oriented Proof Theories and their
  Comparison}.
\newblock Cambridge University Press, 1998.



\bibitem{pitts98high}
A.~Pitts and I.~Stark.
\newblock Operational reasoning for functions with local state.
\newblock In {\em Higher order operational techniques in semantics},
1998.

\bibitem{DBLP:conf/mfcs/PittsS93}
A.~M. Pitts and I.~D.~B. Stark.
\newblock Observable properties of higher-order functions that dynamically
  create local names, or what's new?
\newblock In {\em MFCS}, volume 711 of {\em LNCS}, 1993.

\bibitem{DBLP:conf/lics/Reynolds02}
J.~C. Reynolds.
\newblock Separation logic: A logic for shared mutable data structures.
\newblock In {\em LICS}, 2002.



\bibitem{statonphd}
S.~Staton.
\newblock {\em Name-Passing Process Calculi: Operational Models and
Structural
  Operational Semantics}.
\newblock PhD thesis, Univ.\ Cambridge, 2007.

\bibitem{DBLP:conf/icfp/ThamsborgB11}
J.~Thamsborg and L.~Birkedal.
\newblock A {Kripke} logical relation for effect-based program
transformations.
\newblock In {\em ICFP}, 2011.

\bibitem{tristan10popl}
J.-B. Tristan and X.~Leroy.
\newblock A simple, verified validator for software pipelining.
\newblock In {\em POPL}, 2010.

\bibitem{DBLP:conf/concur/VafeiadisP07}
V.~Vafeiadis and M.~J. Parkinson.
\newblock A marriage of rely/guarantee and separation logic.
\newblock In {\em CONCUR}. 2007.

\bibitem{DBLP:conf/cpp/Voevodsky11}
V.~Voevodsky.
\newblock Univalent semantics of constructive type theories.
\newblock In {\em CPP}. 2011.

\end{thebibliography}


\fi


\ifapp
\newpage
\appendix
\section{Online Appendix}
This appendix contains some additional technical material that was
omitted from the main body for space reasons. In particular,
Section~\ref{sec:app-syntax} contains standard details on semantics of
values and computations as well as of domain theory.
Section~\ref{sec:app-setoids} elaborates the Setoids theory, introducing
the definition of Isomorphic pullbacks and contains more properties of
p.p.f. In Section~\ref{sec:app-comp-model}, a third instantiation, more
complex than the sets of locations, but simpler than Heap PERs can be
found. Section~\ref{sec:app-logical-relations} contains most of the
machinery necessary to establish the Fundamental Theorem. Finally,
Section~\ref{sec:app-applications} contains further applications of our
setting. For instance, we prove the soundness of a number of re-writes,
such as the communting equation, duplication elimination, pure
lambda-hoist, etc. We also prove the soundness of the Masking rule and
discuss the loop-unrolling example in \cite{tristan10popl}.

\subsection{Syntax and Semantics}
\label{sec:app-syntax}
\mbox{}

\paragraph{Predomains}
A \emph{predomain} is an -cpo, i.e. a partial order with suprema
of ascending chains. A \emph{domain} is a predomain with a least element,
. \squelch{We use predomains and continuous functions, rather than sets
and functions, so as to be able to interpret recursive definitions.}
Recall that  is \emph{continuous} if it is monotone
 and preserves suprema of ascending
chains, i.e., . Any set is a predomain with the
discrete
order. If  is a set and  a predomain then
any  is continuous. A subset  of a
predomain  is \emph{admissible} if whenever  is an ascending
chain in  such that  for all , then ,
too. If  is continuous and  is a domain
then one defines  with
. One has,  and if
 is admissible and  then
, too. We denote a partial (continuous)
function from set (predomain)  to set (predomain)  by .  

\fulltrue
\paragraph{Semantics}
The untyped semantics of values and computations is given by
the recursive clauses in Figure~\ref{seme}; note the overloading of
semantic brackets for constants, values and computations. 
The notation
 stands for the -th projection from 
if  is  and  (functionally) updates the
-th slot in  when .
\begin{figure*}[tph]
\iffull

\else
\vspace{-7mm}


\fi
\caption{Semantics of the untyped meta language \label{seme}}
\vspace{-8mm}
\end{figure*}

\subsection{Setoids}
\label{sec:app-setoids}
\mbox{}

\paragraph{More on dependency}
We should explain what continuity of a dependent function like
 is: if  and  and  are ascending
chains in  with suprema  and  and  are proofs such that  and 
are ascending chains, too, with suprema  and  then
 is an ascending chain of proofs (by
monotonicity of ) and its supremum is .

Formally, such dependent functions can be reduced to non-dependent ones
using pullbacks, that is  would be a function defined on the pullback of
the second and first projections from  to
, but we find the dependent notation to be much more readable.


\paragraph{Isomorphic pullbacks}

\begin{definition}
Let  be a category of worlds.  Two pullbacks
 and  are isomorphic
if there is an isomorphism  between the two low points of the
squares so that  and , thus also  and
.
\end{definition}
\fi\iffull
It is easy to see that pullback squares can be composed.
\begin{lemma}\label{preo}
  Given a category of worlds , such that , 
  if  and  are
  pullback squares as indicated then there exist  such that
   is also a pullback. 
\end{lemma}
\fi
\begin{proof}
  Choose  in such a way that  and
   are pullbacks.  The verifications are then an
  easy diagram chase.
\end{proof}

Pullback squares can be decomposed as formally described below. This
property is used for instance in the definition of fibred setoids,
formalizing our notion of semantic computation. In particular, to
formalize that the executions of related computations do not depend on 
each other.

\begin{lemma}\label{decomp}
A pullback  square  in a category of worlds is
isomorphic to .
\end{lemma}

\paragraph{Pullback-preserving functors}
\iffull
\begin{lemma}
  If  is a p.p.f.,  and ,
  there is a continuous function . Moreover, the ``common ancestor''  of  and  is unique up to
. 
\end{lemma}
Note that the ordering on worlds and world morphisms is discrete so
that continuity only refers to the  argument.
\fi
\iffull
\begin{definition}[Morphism of functors]\label{morphfun}
  If  are p.p.f., a morphism from  to  is a pair
   of continuous functions where
   and . A proof that
  morphisms  are equal is given by a continuous function
  .
\end{definition}
These morphisms compose in the obvious way and so
the pullback-preserving functors and morphisms between them form a category. 
\fi

\paragraph{More on  and fibred setoids}
\iffull If  and
   are two composable pullback squares with
  composite  and  and , then the composite
proof of  is given
by . Indeed, if  is the apex of the
composite square  then   and  and  since  so the
two proofs compose in .  \fi

\iffull
\begin{lemma}\label{baf}
  Let  be a fibred setoid.  The elements  given by pullback
  preservation are unique up to .  If  is
  an isomorphism then there is a continuous function
   and it is bijective up to  with
  inverse . If  and  are isomorphic pullback squares then there are continuous back and forth functions 
. 
\end{lemma}
\fi

\iffull \begin{lemma}\label{meanterm}
  If  is a p.p.f.\ and  is a fibred setoid then in
  order to specify a morphism from  to  with given first
  component  it is enough to provide a
  continuous function .
\end{lemma} 
\begin{proof}
  If  is a morphism we can define  by
   noting that .  Conversely, given  to define
   we pick a pullback square  with apex
   and  and , i.e., a proof in .  Applying
   to  yields the morphism ; moreover, applying  to

  yields .  Then,
   so that
  Lemmas~\ref{decomp} and \ref{baf} yield the desired proof in the square
  .

  The second part of the lemma about equality is just a restatement of
  the definition of equality of morphisms of fibred setoids. 
\end{proof}\fi
\iffull
\begin{lemma}
Let  be p.p.f.\ For every morphism  there  is a
morphism  such that . Thus, in
particular  is a full and faithful functor from the category  of
p.p.f.\ on  to the category of fibred setoids over . 
\end{lemma} 
\fi

\paragraph{On abstract heaps}
The definition of minimal pullback-preserving functor corresponds to
the p.p.f. used for values, but is used for abstract heaps. In
particular, an abstract heap at the low-point of a pullback square is
the result of forgetting locations from an abstract heap at its apex.

\iffull
Applying the definition of minimal ppf to the trivial minimal pullback
, plus
nonemptiness, yields the following result.
\begin{lemma}
\label{lem:unique-upto-sim}
   For every  and  there is
morphism of setoids  which is right
inverse to . 
\end{lemma}
The ``unique up to '' clause allows us in particular to assert the -equality of two abstract stores  by proving  and  separately when  is a minimal pullback  with apex .
\fi


\subsection{Computational model}
\label{sec:app-comp-model}
\mbox{}

We now discuss a third instantiation of our framework, which captures
the setting developed in \cite{DBLP:conf/ppdp/BentonKBH09}.

\paragraph{Flat stores} 
The \emph{flat stores} instantiation assumes that heap
locations contain merely integer values and no pointers. 
Possible worlds are
finite sets of locations together with a function that associates each
location a \emph{region} taken from a fixed set  of
regions. World morphisms must preserve this tagging. We write
 and  to mean that  occurs in 
and with region  in the second case.  Abstract stores
 comprise those heaps  with  and such that  and  implies that
 is an integer value,  for 
 (thus all locations hold integer
values). We put  in  iff for all 
one has . In this case there is a unique proof,
say .  For morphism  we define  by renaming concrete locations
according to . The elementary effects are  representing reading from within, writing
into, allocating within a region . The associated sets of
relations are given by
\iffull
3pt]

R\in\mathcal{R}(\wEff{\regid})&\iff& (\sigma,\sigma')\in R\w \Rightarrow
\forall \cloc\in \w(\regid).\forall v\in\mathbb{Z}.\Rightarrow 
(\sigma[\cloc{\mapsto}\intt{v}],\sigma'[\cloc{\mapsto}\intt{
v}])\in R\w
\
This essentially mirrors the setting of our earlier relation-based
\else

3pt]

R\in\mathcal{R}(\wEff{\regid})&\iff& (\sigma,\sigma')\in R\w \Rightarrow
\forall \cloc\in \w(\regid).\forall v\in\mathbb{Z}.\Rightarrow 
(\sigma[\cloc{\mapsto}\intt{v}],\sigma'[\cloc{\mapsto}\intt{
v}])\in R\w
\

\noindent
This essentially mirrors the setting of our earlier relation-based
\fi
account of reading, writing, and allocation with integer values stores
\cite{DBLP:conf/ppdp/BentonKBH09} with the difference that allocation
is modelled with relations on the same level as reading and writing
and that the stores being related share the same layout. 

\subsection{Proof-relevant logical relations}
\label{sec:app-logical-relations}

In following establishes that the semantics of the monad corresponds
indeed to a semantic computation, that is, a fibred setoid.

\begin{proposition}
The semantic computation  as defined in
Definition~\ref{def:semantic-computation} is a fibred setoid.
\end{proposition}
\begin{proof}
  The tricky case is to show the existence of a transitive operation.
  It is here that we require the independence of abstract locations as
  stated in Definition~\ref{def:abstract-location}, which implies that
   is also minimal-pullback-preserving.

Assume that there are proofs in  and  where 
 and . We also have  and , such that they are equivalent in the pullback of
the low points of these two pullback squares. Let  be such
pullback. 

In order to use the proofs  and , we need to construct
from  and  an abstract heap .
Let  be the minimal pullback over the apexes of the two pullback
squares  and . Then  and  form a pullback
square with apex  and low point . Since
 is minimal-pullback-preserving, there is a , such that it is equivalent to  and  when
taken to the world . We now define  to be  taken to the world . We thus have , and , such that  and .

We can now use the  and . In particular, 
let , , and . From the proofs, we get two
pullback squares  and . It
is easy to show that the values obtained are equal in the minimal pullback over 
the
apexes of these two pullback squares and that the abstract heaps are
equivalent in the pullback of their low points.
\end{proof} 

\begin{definition}[cartesian product]
If  and  are semantic types their cartesian product  is defined by  (cartesian product of setoids) and . 
\end{definition}
\begin{definition}[function space]
  Let  be a semantic type and  be a
  semantic computation. We define a semantic type  as follows.  
  An object  of  is a pair  of
  continuous functions where  assigns to each  and
   a continuous function . The second component  assigns to each
   and  a continuous
  function .


  If  then a proof  is a continuous function assigning to each
   and  a proof .

  If  and 
  then  is given by precomposition with
  , i.e., , etc.



  As for the realisation relation  we put
   to mean that  for some
   and whenever  is an inclusion and
   then .
\end{definition}
Notice that unlike morphisms the elements of the function space are
\emph{not} identified if they are ``provably equal.''
Notice also that if  implies
 whenever 
is an inclusion.

In what follows we define semantic counterparts to the generic
syntactic constructions common to all instantiations, namely
application and abstraction, sequential composition, subeffecting, and
recursion
that allow us to define this interpretation of derivations in a
compositional fashion. Having given these semantic counterparts we
then omit the formal definition of the interpretation .
\begin{lemma}[Abstraction]
Let  be  semantic types,  a semantic computation. There is a function  so that if  is a morphism of fibred setoids then . Moreover, if  then  and if  then . 
\end{lemma}
\begin{lemma}[Application]
Let  be a semantic type and  be a semantic computation. There  is a
morphism  and
.  
\end{lemma}

\begin{lemma}[subeffecting]
 Let  be semantic types and  be effects. There is
a function \emph{subeff}, so that if , then 
. Moreover, if , then . Finally, if  then .
\end{lemma}

\begin{proof}
For the first component, , we use the same first component
 of  . What changes is the definition of the second
component, . It is defined only for relations , for which  is also defined. For some related
given abstract heaps in ,  calls  constructing the
corresponding pullback. For proofs the reasoning is similar.
\end{proof}


We elide assertions about -versions of beta-eta-equality, and
the existence of ``value morphisms'' of type
 for any semantic type . 


\begin{lemma}[let]
Let  be semantic types and  an effect. 
There is a function  such that if  and  are morphisms
then . Moreover, if
 and  then . 
Finally, if  and
 then . 
\end{lemma}

\begin{proof}
Consider the following definition for the first component of the morphism
 which is only defined when  and
 are defined. The type of this component is . Hence, assume a world , and a context , then one returns an object . The first component  is:

where .

For the second component, , assume a relation , and two abstract heaps 
such that . From  we get a 
proof , where
 and , such that  and . Applying  on  and
 we get a proof ,
such that . However,
we need to show that the heaps obtained from applying  on 
and  (using the correct world and context), namely 
and , are related. For this we rely on
the morphism . In particular,
we use  on the pullback  and
obtain a pullback  such that  and

are equal in its low point. Similarly, applying  on the
pullback , we get a pullback 
, where  is equal to
 in its pullback. Using Lemma~\ref{preo}, we compose the
pullbacks ,  and , obtaining a common pullback , where 
 and  when taken to  are in . 

The morphism  can be then defined when 
and  are defined.
Assume a pullback  and an abstract heap  and a context . Using the
morphism between  and  on these objects, we obtain a
pullback ,  and , where  and . 
From the pullback preserving property of computations and ,
there is a common value  and context
 which are equal, respectively, to
 and , and  and  (when taken to the
correct world). We then construct a
proof . We now apply twice the
morphism between  and  once in the pullback  and
another on the
pullback , obtaining two pullbacks
 and . From
Lemma~\ref{preo}, we can compose them where the resulting values and
heaps are equal.
\end{proof}


\begin{lemma}[fix]\label{fixlse}
  Let  be semantic types so that for each  the predomain
   is a domain with least element  such that
   holds for every proof  and such that  holds for every
  .\footnote{For example 
for semantic types .}
\begin{compactenum}
\item[i] There then exists a function
   so that whenever  then
  
\item[ii] If  then . Furthermore, the fixpoint and unrolling equations
  from Lemma~\ref{fixlse} hold. 
\item[iii] Finally, if  then
.    
\end{compactenum}
\end{lemma}
\begin{proof}
For every  we have . We can thus form .  It remains to define . To do that, we
recall that we 
have an ascending chain of elements 
 given by 
 and 
 and have
. 
Now suppose that  and  and
 and . Write
 and .
Inductively, we get proofs  where  (note that
) and . Since
 we obtain by
monotonicity of  and induction that  is an ascending
chain with supremum  for some proof 
which we take as . Note that the passage from  to
 is continuous. 
\end{proof}

\subsection{Applications}
\label{sec:app-applications}\mbox{}

The following lemma formalizes our intuition that 

\paragraph{Lemma~\ref{lemmasix}}
\begin{proof}
The proof that the values are equal in  follows directly from 
the definition of computations and effects.


For the first part,  we use the following relation  defined for all
worlds , such that :



\noindent
Otherwise, for the worlds  not reachable from \w, the relation
 is the trivial set. Notice that  and it is
contravariant. The claim then 
follows directly.

The proof of the second part follows in a similar fashion, but we use the
following relation:



\noindent
And we use a similar relation for showing that  and
 agree on the not written locations .

For the third property, first, we show that there is an
isomorphism between  and  for all regions
 by using the following relation:



\noindent
where  denotes the number of abstract locations coloured with 
.
Clearly,  as  does not contain any allocation effects. This gives
us one direction, while the other direction is obtained by using the
inclusion morphisms. Given this property, one can easily construct the 
function .
\end{proof}

\begin{proposition}\label{compr}
(commuting computations) Suppose that:
 and
,
where  . Let 

then .
\end{proposition}

\begin{proof}
Assume a world \w and a context .
Let  for
. 

It is enough to assume a pullback 
, and an abstract heap . 
Assume that these functions are defined as follows:



\noindent
One can easily show that when one of these functions is undefined, then 
the corresponding function is also undefined. 

We need to show that there is a proof  such that
 and 
and .
Decompose , where
. 
The existence of such decomposition follows from the disjointness of write
effects in  and .

From Lemma~\ref{lem:invariant} and from 
the disjointness of reads and writes, it is the case that  and
 agree on the locations in .
That is, there is a proof , defined 
using the proof , where .
Applying  to the objects above,
we get the pullback , and  proof . Symmetrically, we obtain the proofs 
, and  . Hence, there is also a proof in the larger world .

To see informally that the final heaps  and  are
equal, we use
the following facts obtained using Lemma~\ref{lem:invariant}: 
and  agree on the locations in ; moreover, 
 and  agree on the locations in ; 
hence  and  agree on the locations in . Symmetrically, we can also argue that  and 
agree on the locations in . Composing these proofs 
(see comment after Lemma~\ref{lem:unique-upto-sim} why this is allowed), 
we get that  and  agree on the locations in . 
Finally, since the locations allocated by one computation are not used by
the other computation, the final heaps are equal at the
apex world.
\end{proof}

The following propositions are also provable. All propositions are proved
in a similar way as the soundness proof of the commuting case, using 
Lemma~\ref{lem:invariant} when needed. For instance, the soundness proof
of the duplicated computation uses the third case in
Lemma~\ref{lem:invariant}.

\begin{proposition}[dead computation]Suppose that
,
that \iffull  \else 
 contains no writes \fi and that  is defined for all
. 
Then if for all worlds \w, all contexts , and abstract heaps ,
the function  is defined, 
then .
\end{proposition}

\begin{proof}
Assume a world \w and a context .
Let . 
It is enough to assume a pullback 
, and an abstract heap . Let . We need to construct a pullback such that  is equivalent
to  in its apex and  is equivalent to  in
its low point. Consider the pullback . Clearly
, and therefore the values are equivalent in .
Moreover, from the fact that ,  and  agree on all locations in .
Hence, , which finishes the proof. 
\end{proof}


\begin{proposition}[duplicated computation]\label{dupl}
  Suppose that  and suppose
that
  . Thus, 
  reads and writes on disjoint portions of the store and makes no
  allocations. The the terms   and  below

 are contextually equivalent. That is
formally .
\end{proposition}

\begin{proof}
Assume a world \w and a context .
Let . 
It is enough to assume a pullback 
, and an abstract heap . 
From Lemma~\ref{lemmasix} and since these functions do not allocate, we
can assume that they do not cause any world extension and are therefore
defined as follows:

We need to show that the values  and  are equivalent and 
the heaps , obtained by applying once , and ,
obtained by applying twice , are also equal. 

Decompose , where  contains all
the regions read by  and  all the regions written by . This is
possible because of the disjointness of of 's read and write effects. 
From Lemma~\ref{lemmasix} and the disjointness of  's read and write
effects, we have that  and  agree on the regions read
by , that is, . Hence, again
from Lemma~\ref{lemmasix}, we have that the values  and 
are equal. Moreover, the locations in  are equaly written, while the
locations in  are left unchanged, that is,
 and  agree on the location in .
\end{proof}

\begin{proposition}[pure lambda hoist]\label{hoist}
Suppose that  and 

Let  and  be respectively  and
. 
Then .
\end{proposition}


\begin{proof}
Assume a world \w and a context .
Let  and 
. 
It is enough to assume a pullback 
, and an abstract heap . Since  has no effects, we have no world extension:

Moreover, from Lemma~\ref{lemmasix},  and  agree on
all locations. We now show that 

In order to prove this, assume a morphism  and . We need then to prove that the computations resulting from 
applying  to the functions above are equivalent in the pullback
. For this, assume an abstract heap . Since  has no effect, we have no world extension:

Since  is pure, we have  and from
Lemma~\ref{lemmasix} we have that  and  agree on all
locations in  and in particular on locations read by . Hence, 
again by Lemma~\ref{lemmasix} the pullback proof exists where 
and 
 are equal in its low point and the resulting values are equal
in its apex.
\end{proof}

\paragraph{Masking}
We now justify soundness of the masking rule shown below:

which allows one to mask effects, that is, allowing it to behave closer to
pure functions. As discussed in \cite{DBLP:conf/ppdp/BentonKBH07}, as the
effect-dependent equations can be applied only if some conditions on the
set of effects is satisfied, the masking of effects may enable the use of
such equations. (See the commutation computation equation.)

Assume that for 
for every set of regions , we take a different instantiation 
where all abstract locations get colors from . Within  we can
interpret app, lambda, fix, etc.
If  and  is a semantic type over  denote  its restriction to . 
In our setting, we prove of the soundness of the
masking rule by providing morphisms between the objects in
 and objects in  when restricted to , where . This corresponds in our
setting to the Masking Lemma in \cite{DBLP:conf/ppdp/BentonKBH07} and is
formalized by introducing the notion of matching pairs:
 Let  be a semantic
type over  and  be a semantic type over
. The two form a \emph{matching pair} if there are morphisms
 and  both tracked by the identity on the
level of values and isomorphisms w.r.t. . The idea is that if 
only mentions regions in  then  with respect to  and
 with respect to  will be a matching pair.




Suppose that . 
If  then, since  can be viewed also over ,
we can understand  as living in . Conversely, if  and , then we also have 
 by coarsening. This is because if 
satisfies all the contracts in the larger worlds involving the regions
, then it also satisifies the contracts for the regions in the smaller
set . In fact, every world  induces a world .

We now prove that if only regions from  are mentioned in  then
 and  form a matching pair where 
denotes the interpretation with respect to : Suppose that 
mentions all of  and that 
are matching pairs and that  is a morphism tracked
by . There then exists a morphism   also tracked by  and if  then .

Let the morphisms  and  due to the fact that
 form a matching pair and  and  due to the
fact that  form a matching pair. It is then easy to prove the
soundness of masking by using the morphism
.

\iffull
\begin{figure*}[t]
\begin{center}
\begin{small}
\begin{tabular}{l@{\quad}l@{\quad}l@{\quad}l}
Body of Loop & Prolog & Steady Program & Epilogue\\
\texttt{x := load(p);} & \texttt{p1 := p;} &
\texttt{store(p1, y);}
\textbf{[]} & \texttt{store(p1, y);}
\textbf{[]}\\ 

\texttt{y := x * c;} & \texttt{p2 := p;} & \texttt{p1 := p2 + 8;} &
\texttt{y := x2 * c;} \\

\texttt{store(p, y);} & \texttt{x1 := x;} & \texttt{y := x2 * c;}
& \texttt{store(p2, y);} \textbf{[]}\\

\texttt{p := p + 8;} & \texttt{x2 := x;} & \texttt{x1 := load(p1);
\textbf{[]}} & \texttt{x := x2;}\\

\texttt{i := i + 1;} & \texttt{x1 := load(p1);}
\textbf{[]} &
\texttt{store(p2, y);} \textbf{[]}
& \texttt{p := p2;}\\

& \texttt{p2 := p1 + 8;} & \texttt{p2 = p1 + 8;}\\
& \texttt{x2 := load(p2);} \textbf{[]} &
\texttt{y
= x1 * c;}\\

& \texttt{y := x1 * c;} & \texttt{y = load(p2);
\textbf{[]}}\\

& \texttt{i := i + 2;} & \texttt{i := i + 2;}\\
\end{tabular}
\end{small}
\vspace{-2mm}
\end{center}
\caption{Program obtained from the loop unrolling technique. Here
\texttt{p}, \texttt{p1} and \texttt{p2} are pointers and all \texttt{load}
and \texttt{store} operations are on 64 bit numbers (float).}
\label{fig:loop-unrolling}
\vspace{-4mm}
\end{figure*}

\paragraph{Example: Loop Unrolling}
Loop unrolling is a software pipelining technique used to enhance the use
of parallel processing. The idea is instead of iterating a loop 
in a sequential manner, one attempts to process a number of iterations
of the loop at the same time using multiple processors.

As described in \cite{tristan10popl} implementing and proving the
correctness of loop unrolling techniques is hard as
one needs to demonstrate that the program resulting from loop unrolling
that can be executed in parallel is equivalent to the original sequential
program. We briefly illustrate the power of our system with regions and
effects by one of the running examples in \cite{tristan10popl}. Consider
a loop program whose body is depicted in Figure~\ref{fig:loop-unrolling}.
Intuitively, this program is multiplying all the elements of an array of 
float values by the value \texttt{c}. Clearly, instead of executing this
program sequentially, we can execute different iterations in parallel. 
In particular, after applying the loop unrolling optimization to a program,
one obtains a program that is divided in three parts: the prolog, that
initializes all the variables, the steady state, that is iterated, and the
epilogue, that is executed when the loop condition is no longer true and
the loop is over. Figure~\ref{fig:loop-unrolling} contains the program
obtained by loop unrolling two iterations of the program above. The Prolog
and the Epilogue are executed at the beginning and the end, respectively,
while the Steady Program may be executed several times. 

The task is to show that the optimized program is equivalent to the
sequential program above. Using the unrolling equations from
Lemmas~\ref{fixlse} we can unroll the loop twice
() and extract a prologue. We can then conclude with
effect-dependent equivalences, in particular Prop.~\ref{compr} as
follows. We use two regions 
and . All even elements of the array, that is, \texttt{p},
\texttt{p + 16}, \texttt{p + 32}, \ldots, belong to the region ,
while all odd elements, that is, \texttt{p + 8},
\texttt{p + 24}, \texttt{p + 40}, \ldots, belong to the region .
Given this setting, the read and write effects are as shown in
Figure~\ref{fig:loop-unrolling}. It is now a simple exercise to show that
any execution of the optimized program is equivalent to an execution of
the sequential program. For instance, any instruction with a read effect 
on  can be permuted so that it appears immediately before the
following instruction with write effect  on the same region
. This is possible because the only effect between these two
instructions is a read on the other region . The same is true
for permuting instructions that read on . 
\fi
\end{document}
