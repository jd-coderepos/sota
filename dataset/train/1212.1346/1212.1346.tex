\documentclass[11pt]{article}

\usepackage{amsmath, amssymb, amsthm}
\usepackage{graphicx}
\usepackage{comment}

\newcommand*{\tw}{\textsc{2}}
\newcommand*{\twdfa}{\tw\textsc{dfa}}
\newcommand*{\twdfas}{\tw\textsc{dfa}s}
\newcommand*{\twnfa}{\tw\textsc{nfa}}
\newcommand*{\twnfas}{\tw\textsc{nfa}s}
\newcommand*{\ow}{\textsc{1}}
\newcommand*{\owdfa}{\ow\textsc{dfa}}
\newcommand*{\owdfas}{\ow\textsc{dfa}s}
\newcommand*{\ownfa}{\ow\textsc{nfa}}
\newcommand*{\ownfas}{\ow\textsc{nfa}s}

\newcommand*{\cfg}{\textsc{cfg}}
\newcommand*{\cfgs}{\textsc{cfg}s}
\newcommand*{\cnfg}{\textsc{Cnfg}}
\newcommand*{\cnfgs}{\textsc{Cnfg}s}
\newcommand*{\cfl}{\textsc{cfl}}
\newcommand*{\cfls}{\textsc{cfl}s}




\newcommand{\derivesForm}[2]{\mathrel{\underset{\scriptstyle #1}{\overset{\scriptstyle #2}{\Longrightarrow}}}}

\newcommand{\derives}{\derivesForm{}{\star}}
\newcommand{\Derives}{\derivesForm{}{+}} 
\newcommand{\DERIVES}[1]{\derivesForm{#1}{}}
\newcommand{\der}{\DERIVES{}} 
\newcommand{\derivesGrammar}[1]{\derivesForm{#1}{\star}}
\newcommand{\DerivesGrammar}[1]{\derivesForm{#1}{+}}
\newcommand{\DERIVESGrammar}[2]{\derivesForm{#1}{#2}}
\newcommand{\derGrammar}[1]{\DERIVESGrammar{#1}{}} 
\newcommand{\derivesG}{\derivesGrammar{G}} 
\newcommand{\DerivesG}{\DerivesGrammar{G}} 
\newcommand{\DERIVESG}[1]{\DERIVESGrammar{G}{#1}}
\newcommand{\derG}{\derGrammar{G}} 
\newcommand{\derivesZ}{\derivesGrammar{G_0}} 
\newcommand{\DerivesZ}{\DerivesGrammar{G_0}} 
\newcommand{\DERIVESZ}[1]{\DERIVESGrammar{G_0}{#1}}
\newcommand{\derZ}{\derGrammar{G_0}} 






\newcommand{\Pred}{\ensuremath{\mathrm{Pred}}}

\newcommand{\Pref}{\ensuremath{\mathrm{Pref}}}

\def\Vec#1{\mbox{\boldmath }}




\newtheorem{theorem}{Theorem}[section]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem*{claim}{Claim}     \newtheorem{ex}[theorem]{Example}
\newenvironment{example}{\begin{ex}\rm}{\end{ex}}





\begin{document}\title{Converting Nondeterministic Automata and Context-Free Grammars into Parikh Equivalent One-Way and
Two-Way Deterministic Automata\footnote{Preliminary version presented at
  \emph{DLT'12---\,Developments in Language Theory}, Taipei,
  Taiwan, Aug 14--17, 2012 [\emph{Lect.\ Notes Comput.\
  Sci.},\ 7410, pp.\ 284--295, Springer-Verlag, 2012]\@.}}\author{Giovanna J. Lavado\footnotemark[3]\and
Giovanni Pighizzini\footnotemark[3]\and
Shinnosuke Seki\footnotemark[4]\and
\mbox{}\\
{\normalsize \mbox{\footnotemark[3] }\,Dipartimento di Informatica}\\
{\normalsize  Universit\`{a} degli Studi di Milano, Italy}\\
{\small\sf giovanna.lavado@unimi.it} --
{\small\sf giovanni.pighizzini@unimi.it}\
\Pref(L) = \bigcup_{u \in L} \Pref(u)\,.

L_1=L\cap\{a_1\}^*,~L_2=L\cap\{a_2\}^*,\ldots,~L_m=L\cap\{a_m\}^*\,,

L_0=L-\left(L_1\cup L_2\cup\ldots\cup L_m\right)\,,

  d(V)=\sum_{i=1}^k(-1)^{i+k}\Vec{v}_k[i]d_{i,k}\,,
  
\Pred(\Vec{v}) = \{\Vec{u} \mid \Vec{u} \preceq \Vec{v}\}\,.

\left\{\Vec{v}_0 + n_1\Vec{v}_1+n_2 \Vec{v}_2 +\cdots+n_k\Vec{v}_k \mid n_1, n_2,\ldots, n_k \in \mathbb{N}\right\}\,,\label{eq:linear}

\psi(w)=\left(|w|_{a_1}, |w|_{a_2}, \ldots, |w|_{a_m}\right)\,, 

\psi(L) = \{\psi(w) \mid w \in L\}\,.

\{w_0\}\cdot\{w_1,w_2,\ldots,w_k\}^*\,,

S \derG BC \DerivesG u C \DerivesG uv
V' = \{S'\} \cup \{B_i \mid B \in V \setminus \{S\}, 1 \le i \le m\}B_i \derZ C_i D_j \DerivesZ w_1 D_j \DerivesZ w_1 w_2 = wB \derG CD \DerivesG w_1' D \DerivesG w_1' w_2' = w
	B_i \derZ C_i D_j \DerivesZ w_1 D_j \DerivesZ w_1' w_2' = w
	S' \derZ B_i C_j \DerivesZ u_1 C_j \DerivesZ u_1 u_2 = u
S \derG BC \DerivesG w_1 C \DerivesG w_1 w_2 = w
S' \derZ B_i C_j \DerivesZ w_1 C_j \DerivesZ w_1 w_2 = w

L=\{ba^n\mid n\bmod 210\neq 0\}\,.
\label{eq:nf}
	\psi(L(A)) = Y\cup\bigcup_{i \in I} Z_i\,,
	\label{eq:Zi}
		Z_i = \{\Vec{v}_{i, 0} + n_1 \Vec{v}_{i, 1} + n_2 \Vec{v}_{i, 2} + \cdots + n_{k_i} \Vec{v}_{i, k_i}\mid n_1,n_2, \ldots, n_{k_i} \in \mathbb{N}\}\,,
	\label{eq:newZi}
		Z_{N_I+j} = \{(\Vec{v}_{i, 0}+h_j\Vec{v}_{i, j}) + n_1 \Vec{v}_{i, 1} + \cdots + n_{k_i} \Vec{v}_{i, k_i}\mid n_1, \ldots, n_{k_i} \in \mathbb{N}\}\,,
	\label{eq:hj}
		N_I+j\le \|\Vec{v}_{i, 0}+h_j\Vec{v}_{i, j}\|<N_I+j+n
	\label{eq:Yi}
		Y_i = \{\Vec{v}_{i, 0} + n_1 \Vec{v}_{i, 1} + \cdots + n_{k_i} \Vec{v}_{i, k_i}\mid 0\le n_1<h_1, \ldots, 0\le n_{k_i}<h_{k_i}\}\,.
	
  Z_i=Y_i\cup\bigcup_{j=1}^{k_i}Z_{N_I+j}\,.
  
  \widehat I=I-\{i\}\cup\{N_I+1,\ldots,N_I+k_i\}\,,
  
g(\Vec{v}) = a_1^{i_1} a_2^{i_2} \cdots a_m^{i_m}\,,

s_{i, 1}= g(\Vec{v}_{i, 1}),\  s_{i, 2}= g(\Vec{v}_{i, 2}),\ \ldots,\ s_{i, k_i}= g(\Vec{v}_{i, k_i})\,.

w_{i, 0} = f(\Vec{x}_i) g(\Vec{v}_{i, 0} - \Vec{x}_i)\,,

W = \{w_{i, 0} \mid i \in I\}\,.

A\rightarrow a\,,~ B\rightarrow b\,,~ A_0\rightarrow AB\,,~ A_j\rightarrow A_{j-1}A_{j-1}\,,\mbox { for }
\,.

As easy induction shows that, for , the only word which is generated from~
is . 
Hence, by choosing  as start symbol, we have~, with~. 
An immediate pumping argument shows that each \owdfa\ (or even \ownfa) with
less than~ states accepting a word of length~, should also  accept some
words of length . Since  contains only the word~, it turns out that each 
\owdfa\ accepting a language Parikh equivalent to  requires
 states, namely a number exponential in~.



\section{Conversions into Parikh equivalent \mbox{\sc\twdfa}s}
	\label{sec:to_2DFA}


In this section we study the conversions of \ownfas\ and \cnfgs\ into Parikh equivalent
\emph{two-way} deterministic automata.
In the previous sections, for the conversions into \emph{one-way} deterministic automata,
we observed that the unary parts are the most expensive. However, the cost
of the conversions of unary \ownfas\ and \cnfgs\ into \twdfas\ are smaller than the costs for
the corresponding conversions into \owdfas. 
This allows us to prove that, in the general case, the cost of the conversions
of  \ownfas\ and \cnfgs\ into Parikh equivalent \twdfas\ are smaller
than the cost of the corresponding conversions into \owdfas.

Let us start by presenting the following result, which derives from~\cite{Chrobak1986}:

\begin{theorem}\label{thm:u1NFAto2DFA}
  For each -state unary \ownfa\ there exists an equivalent halting \twdfa\ with  states.
\end{theorem}
\begin{proof}
  For the sake of completeness, we present a proof which is essentially the same
  given by Chrobak~\cite[Thm.~6.2]{Chrobak1986} where, however,	the obtained upper bound was~. 
  Then we will explain why the big- in the upper bound can be removed.
	
	First of all, each -state unary \ownfa~ can be converted into an equivalent
	~ in a special form, which is known as \emph{Chrobak normal form}~\cite[Lemma~4.3]{Chrobak1986}, 
	consisting of a deterministic path which starts from the initial state,
	and  disjoint deterministic cycles. The number of states in the path is~,
	while the \emph{total} number of states in the cycles is .
	From the last state of the path there are  outgoing edges, each one of them reaching
	a fixed state on a different cycle. Hence, on each input of length , the computation visits
	all the states on the initial path, until the last one where the \emph{only} nondeterministic
	choice is taken, moving to one of the cycles, where the remaining part of the input
	is examined. However, if  then computation ends in a state on the initial path, without reaching
	any loop. (In the special case  the accepted language is finite.)
	
	A \twdfa~ can simulate the ~ in Chrobak normal form, traversing the input
	word at most  times. In the first traversal, the automaton checks whether or not the input
	length is . If this is the case, then the automaton accepts or rejects according to the
	corresponding state on the initial path of~. Otherwise, it moves to the right endmarker.
	This part can be implemented with  states ( states for the simulation of the initial path,
	plus one more state to move to the right endmarker).
	From the right endmarker, the automaton traverses the input leftward, by simulating the first
	cycle of  from a suitable state (which is fixed, only depending on  and on the cycle length).
	If the left endmarker is reached in a state which simulates a final state in the cycle then the
	automaton~ moves to the final state  and accepts, otherwise it
	traverses the input  rightward, simulating the nd cycle of~, and so on.
	Hence, in the th traversal of the input, , the th cycle is simulated.
	So the number of states used to simulate the cycles is equal to the total number of
	states in the cycles, namely~.
	Considering the final state , we conclude that  can be implemented with  states.
	
	Finally, we point out that finer estimations for the number of the states on the initial path and in the
	loops of~ have been found. In~\cite{Geffert2007}, it was proved that the number of  of the states
	in the initial path is bounded by  and the sum  of the numbers of the states in the cycles 
	is bounded by .\footnote{Actually, there is an exception: if the given \ownfa~ is just one cycle of  states then~ is
	already a \owdfa. If it is minimal, then in any equivalent \ownfa\ we cannot have a cycle with less than~ states
	which is useful to accept some input.
	However, in this degenerate case, Theorem~\ref{thm:u1NFAto2DFA} is trivially true, without making use of the Chrobak
	normal form.}
	The first bound has been further reduced in~\cite{Gawrychowski2011}
	to . This allows us to conclude that the \twdfa~ can be obtained
	with at most  states.
\end{proof}

The upper bound given in Theorem~\ref{thm:u1NFAto2DFA} is asymptotically tight. As proven in~\cite[Thm.~6.3]{Chrobak1986},
for each integer  there exists an -state unary \ownfa\ such that any equivalent \twdfa\ requires
 states.

\medskip

By combining Theorem~\ref{thm:u1NFAto2DFA} with the bound for the transformation of
unary \cnfgs\ into \ownfas\ given in Theorem~\ref{thm:PSW2002}, we immediately obtain the
following bound.

\begin{theorem}\label{thm:uCFGto2DFA}
  For each  -variable unary \cnfg\ there exists an equivalent halting \twdfa\ with 
  at most~ states.
\end{theorem}

We now have the tools for studying the conversions of \ownfas\ and \cfgs\ into Parikh equivalent \twdfas.
Let us start with the first conversion.

\begin{theorem}\label{thm:1NFAto2DFA}
  For each -state \ownfa\ there exists a Parikh equivalent \twdfa\ with a number of states polynomial in .
\end{theorem}
\begin{proof}
  We use the same technique as in the proof of Theorem~\ref{thm:NFA_to_DFA}, by splitting the language accepted
  by the given \ownfa\  into its unary and nonunary parts, as explained in Lemma~\ref{lemma:decREG}. 
  Each unary part is accepted by a \ownfa\ with 
   states. According to Theorem~\ref{thm:u1NFAto2DFA}, this gives us  \twdfas\ ,
  accepting the unary parts, each one
  of them has at most~ states, where  is the cardinality of the input alphabet
  .
    
  For the nonunary part we have a \ownfa\ with  states and, according to Theorem~\ref{thm:nonunary_NFA_to_DFA},
  a Parikh equivalent \owdfa\  with a number of states polynomial in~ and, hence, in~.
  
  Finally, as explained in Section~\ref{sec:constructions}, we can build a \twdfa\  such that 
  .
  Hence,  is Parikh equivalent to the given \ownfa~ and its number of states is polynomial in~.\footnote{By making the same considerations as in Notes~\ref{noteC} and~\ref{noteD}, we can obtain an~
  bound for the degree of the polynomial.}
\end{proof}


Now, we consider the conversion of~\cfgs.

\begin{theorem}\label{thm:CFGto2DFA}
  For each -variable \cnfg\ there exists a Parikh equivalent \twdfa\ with  states.
\end{theorem}
\begin{proof}
  Even in this case, the construction is obtained by adapting the corresponding conversion
  into \owdfas\ (Theorem~\ref{thm:CNFG_to_DFA}).
  In particular, the construction uses the same steps~\ref{step:split}-\ref{step:last_merge} given
  in that proof, with some modifications in steps~\ref{step:unary} and~\ref{step:last_merge}, which are replaced
  by the following ones:
\begin{itemize}
  \item[\ref{step:unary}'.]
	The grammars  are converted into respectively equivalent unary \twdfas\ .
\item[\ref{step:last_merge}'.]
	Finally, {}from , a \twdfa\ that accepting the language
	 is obtained.
\end{itemize}
  Clearly, the \twdfas\ resulting from this procedure is Parikh equivalent to the original grammar~.
  The costs of steps~\ref{step:split} and~\ref{step:CNFG_to_DFA} has been discussed in the proof
  of Theorem~\ref{thm:CNFG_to_DFA}. For the remaining steps:
\begin{itemize}
  \item[\ref{step:unary}'.]
	According to Theorem~\ref{thm:uCFGto2DFA}, for , the \twdfa~ has at most
	 states.
\item[\ref{step:last_merge}'.]
	We use the construction presented at the end of Section~\ref{sec:preliminaries}, to obtain a
	\twdfa\ whose number of states is the sum of the number of the states of ,
	hence .\footnote{Explicitly mentioning the dependency on the alphabet size~, we can give 
	a~ bound. This derives from the size of the automaton~ (cf. Note~\ref{noteE}).
}
\qedhere
\end{itemize}
\end{proof}


\section{Conclusion}
	\label{sec:conclu}


We proved that the state cost of the conversion of -state \ownfas\ into Parikh equivalent \owdfas\ is 
. This is the same cost of the conversion of unary \ownfas\
into equivalent \owdfas.
Since in the unary case Parikh equivalence is just equivalence, this result can be seen as
a generalization of the Chrobak conversion~\cite{Chrobak1986} to the nonunary case.
More surprisingly, such a cost is due to the unary parts of the languages. In fact, as shown
in Theorem~\ref{thm:nonunary_NFA_to_DFA}, for each -state unary \ownfa\ accepting a language
which does not contain any unary word there exists a Parikh equivalent \owdfa\ with polynomially many states.
Hence, while for the transformation {}from \ownfas\ to equivalent \owdfas\ we need at least two different
symbols to prove the exponential gap {}from  to  states and we have a smaller gap
in the unary case, for Parikh equivalence the worst case is due only to unary words.

Even in the proof of our result for \cfgs\ (Theorem~\ref{thm:CNFG_to_DFA}), the separation between the
unary and nonunary parts was crucial. Also in this case, it turns out that the most expensive
part is the unary one.

On the other hand, in our conversions into Parikh equivalent \twdfas, the most expensive part turns out
to be the nonunary one.

\paragraph*{Acknowledgment}
The authors wish to thank Viliam Geffert who suggested to study the conversions into
Parikh equivalent \emph{two-way} automata. In particular, Theorem~\ref{thm:1NFAto2DFA}
is due to him. Many thanks also to Jeff Shallit who suggested to add Example~\ref{example}.


\bibliographystyle{alpha}\bibliography{pcomp}


\end{document}
