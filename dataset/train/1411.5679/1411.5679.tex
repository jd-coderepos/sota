\documentclass{roffin}
\usepackage[]{algorithm2e}

\begin{document}

\markboth{Bryce M. Kim}{Zeno machines and Running Turing machine for infinite time}
\author{Bryce M. Kim}
\title{Zeno machines and Running Turing machine for infinite time}

\maketitle

\begin{abstract}
This paper explores and clarifies several issues surrounding Zeno machines and the issue of running a Turing machine for infinite time. Without a minimum hypothetical bound on physical conditions, any magical machine can be created, and therefore, a thesis on the bound is formulated. This paper then proves that the halting problem algorithm for every Turing-recognizable program and every input cannot be devised whatever method is used to exploit infinite running-time of .
\end{abstract}
\section{Introduction}
Since the discovery of decisions problems that cannot be computed by Turing machines (\cite{turing36}), discussions related to computing what Turing machines cannot has never gone away. For example, in computability theory, there exists discussion of various Turing degrees beyond (\cite{kleene54}), the degree of halting problem, and how they relate to arithmetic hierarchy. It would therefore be incorrect to state that hypercomputation is a science fiction in logical domain. Most of hypercomputation controversies actually have occurred in physical domain, and often Physical Church-Turing Thesis, which states that scientific laws only allow us to build Turing machine at maximum as a machine, is invoked (\cite{fitz06}) to challenge the possibility of hypercomputation machines. As a constrast, a strong form of Church-Turing thesis is Logical Church-Turing Thesis, which states that it is impossible to build a logically coherent hypercomputation machine model. Logical Church-Turing Thesis is often refuted by invoking the fact that Turing degrees above  have been researched in computability theory and what Logical Church-Turing Thesis amounts to is the refutation of Turing degrees above . Since Turing machine is mentioned from the start, it will be beneficial to state the definition of Turing machine, as a reference for the entire paper(\cite{hopcroft79}).
\begin{definition}
Turing machine is a 7-tuple  with arbitrarily infinite length of a tape  and the other tape  and the tape head  and  for each tape where  is a non-empty finite set of states that Turing machine can be in,  is a non-empty finite set of alphabet symbols written to and read off  and .  is the blank symbol,  is the set of input symbols,  is the initial state,  is the set of accepting states for which Turing machine halt,  is a transition function by which Turing machine changes its states and writes to the tape where  itself is a partial function (it is not a total function) and  represents left shift of  by one tape unit,  represents no shift of ,  represents right shift of  by one tape unit.  
\end{definition}
\begin{definition}
Machine  is Turing-equivalent to Turing machine , if  meets the definition of , or if  can simulate  by algorithmic procedure and  can simulate  by its own algorithmic procedure.
\end{definition}
\begin{definition}
Machine  is Turing-complete, if  can simulate execution of instructions written for Turing machine .
\end{definition}
In this definition, any program written for  is understood as the symbols of  that are read off to change the state of  and act on  and .
\begin{definition}
Machine  and  are language-equivalent, if they recognize/accept the same set  of inputs and algorithms as the contents of tapes and recognize no more than . If one of the machines is Turing machine  and they are language-equivalent, the corresponding language  is called Turing-recognizable. 
\end{definition}
\begin{definition}
Turing machine  ``computes'' a decision problem, if  reaches accepting or rejecting states for any input for the decision problem in finite time.
\end{definition}
With all above definitions in mind, we may go back into the issue of a decision problem that is not computable by , mainly halting problem. The ordinary diagonalization pseudocode for halting problem goes the following (\cite{penrose90}):\\

Program :\\
\begin{algorithm}[H]
 \eIf{h(i,i) == 0}{
 \KwRet{0} 
 }{
 \While{1}{
 Loop Forever\; 
 }
 }
 \caption{Diagonalization pseudocode}
\end{algorithm}
where  represents some arbitrary halting algorithm not specifically defined with  as program and  as inputs to .\\
It is worthwhile to state some misunderstanding that may rise out of the above algorithm and Turing's demonstration of uncomputability of halting problem for Turing-recognizable language. The above diagonalization demonstration only works if  is assumed to Turing-recognizable. That is, if  is not Turing-recognizable, then the whole program  is not Turing-recognizable. In such case,  is not solving the halting problem for Turing-recognizable language but solving the halting problem for a non-Turing-recognizable algorithm. A similar assessment can be found in \cite{ord05}.\\
But what if  can be Turing-recognizable and is performed by hypercomputation machine, allowing us to see the outputs of  in finite time in our spacetime reference? Is this logically possible? A such possibility will be explored in the following sections of this paper.
\section{Minimal Physical Computation Thesis}
But before moving onto the construction our machine, we need to set on a minimum criterion on what would constitute as a machine. Without any criterion, machine  may do nothing and some set of spacetimes ``magically'' compute every different problem, when requested by a human being. Therefore, the following Minimal Physical Computation Thesis will be used.
\begin{definition}
Minimal Physical Computation Thesis(MPCT): the logical rules of imaginary or real spacetimes in which machines run must not be dependent on specific time. They may depend on , or , infinitesimal. 
\end{definition}
The above definition does not ask whether a machine is physically possible or not according to our laws of physics. Rather, it is a much weaker thesis that asks all machine models to follow at least minimal conditions. With the above thesis, I will discuss Zeno machines.
\section{Zeno machine and Turing machine running for infinity}
Let us first define Zeno machine, as done in \cite{potgieter06}:
\begin{definition}
Zeno machine  is a machine that satisfies all criteria for Turing machine except that each execution step of  is executed twice as fast as the previous execution step.
\end{definition}
This definition, by itself, asserts that  is just a Turing machine except it meddles with time, so it should recognize the same language as Turing machine.\\
But this definition, while not entirely problematic, will suffer from MPCT problems, if not given a specific hypothetical physical environment. It is important to note that the direction of each movement of  in Turing machine will be different. It may shift left, it may shift right. It is well known that Turing machine that can shift only in one direction (often represented by Read-only right moving Turing machine) cannot be a full-featured Turing machine, because Read-only right moving Turing machine is equivalent to DFAs, not full Turing machine (\cite{tucker04}).\\
This suggests that just placing a Turing machine  in a constant acceleration reference frame will not create a Zeno machine, as head  needs to move in different directions. \\
There is one hypothetical logical possibility that involves visualizing time as we visualize space and solves  problem. Basically, like how space may get contracted, as time goes on, time interval  gets contract while other space dimensions remain unchanged (in other words,  remains the same, where  refers to space coordinate). Then when  (or  where  refers to standard part function), spacetime refreshes itself, bringing us back into some initial , where  is distance-like measure, and then continues contracting to  and going back to  again. As the physical rule itself is uniform across time, this does not violate .\\    
While the example seem impossible according to our understanding of physics, this will not hamper with our results below, because the paper is concerned with the logical development from minimal physical conditions, not physical plausibility.\\
It is important to note that Zeno machine is just a  that runs for infinite time, with the help of physical environment, Zeno machine will only accept Turing-recognizable algorithms. And if Zeno machine can solve the halting problem for every Turing-recognizable algorithms and inputs, and  is a , then a Zeno algorithm that solves the halting problem would be Turing-recognizable, if such one exists.\\
Whether Zeno machine ``solves'' the halting problem by an algorithm is debatable. The usual way of solving the halting problem in  is to simulate each execution step of a Turing machine and a program, check whether the program halted, modify and mark into a separate tape of  to show whether the program halted or not. When  stops in finite time, running infinite number of executions, it did not really give an output. What we see as an output is rather a result of  stopping. If  represents not halted and  represents halted, then no presence of  on a separate tape implies that the program never halted. In this interpretation, there exists no algorithm for  that solves the halting problem, because  by itself cannot determine the output. However, the algorithm that ``tries'' (but does not give an output if the program never halts) to solve the halting problem is Turing-recognizable.\\
There is the other way of solving the halting problem in , which is more algorithmic. The below halting problem algorithm for  is basically a modification of the first method, except that this time  also performs division of  by half each time it is called.\\
Let the tape alphabet symbols of the below Zeno machine be defined by , where  is the blank symbol.\\\\
Algorithm 2 starts:\\
\begin{algorithm}[H]
Receive an input that is a program \;
, and  is stored in a separate tape  of \;
\While{1}{
Execute a single succeeding instruction/execution step of . If the program halts, go to the accepting/halting state as required, and escape the while loop.\;
 and instead of writing on the original tape locations of , it is fine to write the new  after the original , separated by \;
\If{Last digit of  is zero, as pointed by the head of }
{Move  to a unique state that frees the heads of  from being stopped. After this state transition,  starts in the previous initial speed of  before the execution of Algorithm 2. Escape the while loop.
}
}
Check whether  is in the halting state - if so, output 1. if not, output 0.\;
\caption{Halting problem algorithm for }
\end{algorithm}

In practice,  will check whether the program  halted in constant time , which is 2 seconds if the initial execution step takes 1 second and each succeeding step takes half of the previous step's execution time. The reason for extra ``If'' conditional is to allow our halting procedure to be modelled as Turing-recognizable algorithm involving state transitions.\\
But now the question: how can we be sure that the infinite division of  by half will result in the last digit being zero?\\
\begin{proposition}
It is impossible for a  in any spacetime or any reference frame-reference reference relationship to have non-zero digit as the result of the infinite division of  by half.
\end{proposition}
\begin{proof}
To specify what division would do in , let us choose base-2 notation. That is, the first digit of binary number is understood as being , the next digit, , the succeeding digit,  and so on.  will be  in base-2 notation,  will be  and so on. Therefore, what division by half does is shifting the number by one to the right.\\
Each writing operation of one digit occupies one cell - therefore, the location number, or ordinal, of the rightmost non-empty part of the tape increases by . By both ZF set-theoretical argument following from the Axiom of Infinity, or by the intuitive understanding that finite number cannot suddenly jump to infinite number, the first infinite ordinal,  exists.\\
Suppose that as the result of the infinite division of , the last digit proves to be . Let the first infinite division result be .  has infinite number of 's before . The number of divisions that occurred therefore is . But at the  division of  by half, there will still be infinite number of 's before , because infinite number of  cannot become finite number of  just by taking away one .\\
Note that in Zermelo-Fraenkel set theory,  does not exist as an ordinal number. This is possible because in mathematical setting, this type of physical problem does not exist.\\
Therefore, the infinite division of  cannot result in the last digit of the number being non-zero.
\end{proof}
\begin{proposition}
Either the infinite division of  is not computable even in infinite time, or the division results in zero.
\end{proposition}
\begin{proof}
This is the tautological statement derived from the preceding proposition.
\end{proof}
\begin{proposition}
Let us assume, to the contrary of the propositions above, that  does have non-zero last digit as the infinite divisions of  by half. Then  can recognize that it has run for infinite time, because th division result equals th division result.
\end{proposition}
\begin{proof}
If  does have non-zero last digit as the infinite divisions of , then this suggests that th division is not accessible or does not exist. Therefore,  will no longer be . But suppose that our assertions are wrong so that  is still .\\
As th division is not accessible, th division has the set of 's before the last digit that is of order type , which means that each tape cell of the th division result before the last digit cell can be placed in bijection with . Adding one additional  to the left of the cells of the result does not change the order type. Therefore, when th division and th division are compared, they should turn out to be equal.\\
Just add the algorithm that compares the two numbers from the first digit to the last digit digit-by-digit from the leftmost side, and  can know whether it is in th division step. 
\end{proof}
Another question: would not the answer of  as the infinite division of  by half cause contradictions?  and because the first infinite division of  by half is , th division of  by half may also need to be .\\
This is not actually the case, because it assumes that shifting left or multiplication is an inverse operation to shifting right or division. The generalization of the finite case where multiplication is inverse to division does not occur at the infinite level. Replacing  with infinitesimal number cannot change this conclusion, because th division of  would still need to be infinitesimal.\\
Assuming that the infinite division of  can be computed in infinite time (and space), during the computation of the infinite division, infinite number of  may appear, and if th division shows such a behaviour, would not this also cause contradiction?\\
But it is very easy to see that this question is actually equivalent to the question of whether  implies the contradiction. Also, in such case infinite number of digits of  can be truncated, leaving only one  before moving onto the next step.\\
What if the infinite division of  is uncomputable? This causes no problem for . The infinite division of  resulting in  in  can also be understood as  referring to the state of undefined. The rationale for this can be inferred by , because it is easy to prove in finite time in ordinary  that finite number of divisions of  by half cannot be zero.\\
It is also crucial to note that infinite division of  not computable in a certain machine operation even with infinite time does not mean that infinite division of  is undefined. Therefore, one cannot say that because ordinary  running for infinite time may not compute infinite division of , infinite division of  being defined in different machine operation modes is wrong. It is easier to understand this argument, if ``not computable'' is replaced by ``execution steps having not halted and continuing to run.''\\
From a different perspective, the division-by-half part of our  algorithm above can be understood as taking the standard part of the division result result. As such, infinite division of  defined as zero is not problematic.\\
It is, for sure, weird to say that the calculation of infinite division of , either understood as standard part function of the divisions or normal divisions, will result in zero and seems to cause problems. But at least this does not create an outright contradiction, while the non-zero last digit of the infinite division result causes an outright contradiction.\\
Until now, I have assumed that uncomputability possibility exists.
\begin{proposition}
It was demonstrated above that it is impossible to read infinite number of cells if the infinite division operations of  by half is not computable in infinite time. Assume that it is indeed impossible to access all cells in the tapes of . Then the number of cells accessible in  is finitely bounded.   
\end{proposition}
\begin{proof}
There is really nothing to prove here. If the number of cells is not infinite, it must be finite. When the number of cells is finite, that number is constant . If not constant , there is no proof that the number of cells is finite.
\end{proof}
\begin{proposition}
Universal Turing machine that simulates every other Turing machine cannot have finite number of cells in its tapes. 
\end{proposition}
\begin{proof}
A simple Turing-recognizable program that writes  to a new tape cell each time would suffice. 
\end{proof}
Therefore, it can be concluded that infinite division of  is computable, given infinite time. 
\begin{proposition}
If infinite division of  by half results in, or is, , then it is assured that the above algorithm will give an output for halting problem of Turing machines. 
\end{proposition}
\begin{proof}
Suppose that  contains non-zero digit as the last digit of the division, but the program executed the infinite number of execution steps that make the heads of the tapes of  not move. But this means contradiction, because the fact that  contains non-zero digit as the last digit implies that there have only been finite number of executions plus some finite number of succeeding executions. Therefore, it must be the case that  contains  when the heads of  stop for the given moments.
\end{proof}
Because Algorithm 2 is Turing-recognizable, the existence of Algorithm 2 that solves the halting problem leads to the following diagonalization paradox:
For simplicity of proof, it will be assumed that our universal Turing machine stops every program runs in a clocked fashion led by division-of-1-counter. So every program runs one execution step, asks a counter divide by half, waits until the counter finishes the division. Also, after reaching  state, the counter clears up infinite number of 's. (So, if infinite division of  results in , as it is argued in the paper, then  will be the counter's result afterwards, or otherwise, the counter basically repeats infinite division of  again)
\begin{lemma}
The running time of the Algorithm 2 is , as the first  comes from running programs,  comes from computing of  number of 's in division of . But if the assumption above is used, it reduces to  in terms of program's own non-counter execution time.
\end{lemma}
\begin{definition}
 is defined as running time that necessarily runs for  and may run for additional some finite time. Similarly,  means the running time of  where . 
\end{definition}
\begin{proposition}
There exists an algorithm that checks whether a program  with input set  has the following if Algorithm 2 that checks whether  with  halts in finite time exists (As said above, Algorithm 2 runs for -time.):\\
Either:\\
1. Program stops before -time\\
OR all of:\\
2-1. there exists `if(R(f(x),k))' instruction for  with  that is initiated at finite time but only stop at -time, where  is some Turing-recognizable algorithm/function and  is its input set and  where  and  is some relation,\\
2-2. the `if(R(f(x),k))' that 2-A-1 applies runs only for at most -time after reaching -time, 
2-B.  with  stops before -time.\\
2-1 and 2-2 must both be satisfied. If either condition 1 or 2 is satisfied then the algorithm prints out . Otherwise, print .     
\end{proposition}
For simplification of our proof, it will be assumed that all `if' instruction has the similar machine code that can be checked by a finite-time running algorithm. It is soon seen that this does not cause any problem for the proposition.
\begin{proof}
We use a dove-tailing approach.\\
Let each tape divided by sub-tape section that is used by single . Different sub-tape sections are distinguished by a special character . each sub-tape section is divided into sub-areas that are used by single . Different sub-areas are distinguished by a special character . The proof will be given by the combination of Algorithm 3, 4 and 5.\\  
\begin{algorithm}
Receive input  and \;
\;
\;
\;
\;
 \While{Division of  by half is yet to reach zero}{
 \For{}{
 Check whether  is the newly created sub-area by checking th sub-tape. If so, create a new sub-area in the th sub-tape\;
 Continue running a single instruction from computations left from sub-area  (or the parent sub-area of , if  is a newly-created sub-area) of sub-tape . If necessary, also write down the location of instructions being read and the location of the next instruction to be executed\;
 Check whether succeeding instructions to be executed right after executing , when running  with , are the form of  where  a usual if branch conditional,  is relation of , , ,  or ,  is a Turing-recognizable algorithm/function,  where . If it does, mark at the end of the sub-area that two new sub-areas need to be created at the next . Two new sub-areas are created, because each sub-area assumes different value (true or false) to relation  and carry out computation from there. The newest sub-area is numbered after the number of the last sub-area\; 
 Check whether there exists the set  of sub-areas that can be labelled as ``killed'' because of the result reached in sub-area  (that is, , that made some th sub-area to separate as a new sub-area, is determined in the branch related to sub-area .), and if so, fill every th sub-area in previous sub-tapes with special ``kill'' character \;
 Check whether th sub-area in previous sub-tapes is marked with . If so, also mark a single cell of th sub-area with \;
 If the branch that is associated with sub-area  halted, mark with halting character \;
 Whenever  and  are both applicable,  rules over \;
 If th sub-area does not exist, mark with special character \;
 Mark the cell next to the last cell of sub-area  with special character .
 \If{}{
 Check whether  with  halted. If so,  and escape the While loop\;
 }    
 }
 Check whether there exists a sub-area not filled with , if so \;
 Mark with special character \;
 \; 
 }
\caption{Demonstrating infinity-time diagonalization paradox: program }
\end{algorithm}
\begin{algorithm}
 \eIf{}{
 \KwRet 1\;
 }
 {
 \If{}{\KwRet 0\;}
 Check the last sub-tape and find the second and third sub-areas that are not filled with \;
 \If{the second sub-area, not filled with , is filled with }
 {Run next execution steps of  with  for time  for every  and  that is not , Algorithm 5. If the result has implication for the second and third sub-areas, kill a sub-area that is inconsistent with the result, and check whether a consistent sub-area halted (That is, proper `If' result is matched). If so, \KwRet 1\; Check also whether  and , where  is Algorithm 5. If so, first set  and check consistency of both sub-areas. If both result in inconsistency, check . If both are inconsistent, then  is undefined and \KwRet 0\; If  is consistent, while  is not, check whether second sub-area halted. If so, \KwRet 1\; If not, \KwRet 0\; Similarly, if  is consistent, while  is not, check whether third sub-area halted. If so, \KwRet 1\; If not, \KwRet 0\; Otherwise, \KwRet 0\;}
 }
 \caption{Continuation of program }
\end{algorithm}
\begin{algorithm}
Receive input \;
\eIf{u(i,i) == 0}{\KwRet 1\;}
{Some code that can never stop\;}
\caption{Program }
\end{algorithm}
Look at Algorithm 5, or program . If , then it stops before  and  is defined before , because  stops in -time, but  either should not stop at  or  is undefined. Contradiction. If , then it does not stop before . Contradiction.\\
It should be noted that this proof is possible, because we can hard-code the existence of  and already figure out that the only `if' loop of  will be , repeating endlessly. Therefore, one can know exactly which sub-area to look for, avoiding the conclusion that  can be justified because  has `if' conditional that should run more than -time, but still finite time, to finish. 
\end{proof}
Because the ability to check halting problem leads to algorithm 3,4 and 5, halting problem is not solvable by  even in infinity.\\
It can be argued that because specific indexes are used for `If' instruction and program , the result cannot be valid, because such a method results in proof of uncomputability of halting problem to break down. This is clearly not the case. The reason why halting problem algorithm  cannot just check paradoxical  in Algorithm 1 is the fact that 's input space is every Turing-recognizable program and input. Furthermore, there is the set of infinitely many indices for program  that may not be recursive (it is indeed not recursive). Therefore, if one algorithm  creates a paradox for ,  is not computable (recursive). Our algorithm 3,4,5 are different from halting problem algorithm in this context.\\ 
This implies that even using , halting problem for every Turing algorithm and input cannot be solved.\\
Note that Algorithm 2 can be extended to an ordinary Turing machine running for infinite time, if infinite divisions of  by half results in the last digit being , as we have concluded. It is just that, as finite-living beings, humans cannot see the results in finite time with some inputs, while  allows humans to see the results in finite time. 
\begin{proposition}
It is impossible to solve the halting problem for Turing machines by utilizing a Turing machine and infinite time in any form. If the halting is solved using a Turing machine and infinite time, the extra solving power does not from the Turing machine. A finite time case is already proven, so there is no need for proof.
\end{proposition}
\begin{proof}
Run infinite divisions of  by half in ordinary  and  in infinite time (In 's case, it will be finite time in our reference frame). But in such case, because Algorithm 2 leads to the diagonalization paradox seen in Algorithm 3 and 4, the halting problem for Turing machines cannot be computed using either  or ordinary  and infinite time. If any Super-Turing algorithm for Super-Turing machine can be reduced to the above Turing-recognizable algorithm, then such a Super-Turing algorithm does not work.   
\end{proof}
This leads to the paradoxical state that whether  is in the infinite state is not checkable, while we just proved that such a checker exists, by dividing  by half. Denying the existence of infinite tape is not desirable, because as restated in the paper, then Universal Turing machine is no longer universal. How this paradox will be resolved will not be discussed.
\section{Conclusion}
Throughout past years, it has well been recognized that if halting problem algorithm , where  is a Turing-recognizable program and  is 's input set, is computable/recursive, then it creates a diagonalization paradox. What has not been often recognized, though, is the fact that diagonalization paradox also works when  is assumed to just be Turing-recognizable. This paper studies the possibility of building a Turing-recognizable algorithm using a Zeno machine and possible hypothetical physical environment that surrounds the machine. How a Zeno machine connects to running a Turing machine for infinite time is also studied. It is then concluded that while the algorithm can be created, it obviously results in the diagonalization paradox, and therefore cannot compute halting problem. This also leads to the problematic state that the use of infinite tape for Universal Turing machine may also be problematic. How these paradoxes will live with empirically justified usages of Turing machines will be left as future works.

\begin{thebibliography}{99}

\bibitem[Fitz (2006)]{fitz06}
H. Fitz (2006). Church’s Thesis and Physical Computation, in A. Olszewski \& J. Wolenski \& R. Janusz , eds., Church's Thesis After 70 Years, Ontos Verlag, Heusenstamm, p. 177.
\bibitem[Hamkins (2000)]{hamkins00}
J. Hamkins \& A. Lewis (2000). \emph{Infinite time Turing machine}, The Journal of Symbolic Logic, \textbf{65(2)}, p. 567--604.
\bibitem[Hopcraft (1979)]{hopcroft79}
J. Hopcroft \& J. Ullman (1979). \emph{Introduction to Automata Theory, Languages, and Computation}, Addison–-Wesley, Mass., p. 148.
\bibitem[Kleene (1954)]{kleene54}
S.C. Kleene \& E.L. Post (1954). \emph{The Upper Semi-Lattice of Degrees of Recursive Unsolvability}, Annals of Mathematics, \textbf{Series 2, 59(3)}, p. 379--407.
\bibitem[Lewis (1981)]{lewis81}
H. Lewis \& C. Papadimitriou (1981). \emph{Elements of the Theory of Computation}, Prentice--Hall, Englewood Cliffs, p. 206--211.
\bibitem[Ord (2005)]{ord05}
T. Ord \& T.D. Kieu (2005). \emph{The Diagonal Method and Hypercomputation}, British Journal for the Philosophy of Science, \textbf{56(1)}, p. 147--156.
\bibitem[Papadimitriou (1994)]{papadimitriou94}
C. Papadimitriou (1994). \emph{Computational Complexity}, Addison–-Wesley, Mass., p. 53.
\bibitem[Penrose (1990)]{penrose90}
R. Penrose (1990). \emph{The Emperor's New Mind: Concerning computers, Minds and the Laws of Physics}, Oxford University Press, Oxford, p. 57--63.
\bibitem[Potgieter (2006)]{potgieter06}
P. Potgieter (2006). \emph{Zeno machines and hypercomputation}, Theoretical Computer Science, \textbf{358(1)}, p. 23--33.  
\bibitem[Tucker (2004)]{tucker04}
A. Tucker (2004). \emph{Computer Science Handbook, Second Edition}, Chapman and Hall/CRC, ch. 6 p. 28 (6-28).
\bibitem[Turing (1936)]{turing36} 
A. Turing (1936). \emph{On computable numbers, with an application to the entscheidungsproblem}, Proceedings of the London Mathematical Society, \textbf{Series 2, 42}, p. 230--265.

\end{thebibliography}

\end{document}