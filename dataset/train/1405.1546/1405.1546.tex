\documentclass{LMCS}

\def\dOi{10(3:10)2014}
\lmcsheading {\dOi}
{1--46}
{}
{}
{Jul.~\phantom05, 2013}
{Aug.~22, 2014}
{}


\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{stmaryrd}
\usepackage{url}
\usepackage{code,hyperref}
\setlength\hfuzz{3pt}
\usepackage{mathrsfs}
\DeclareMathAlphabet{\mathpzc}{OT1}{pzc}{m}{it}
\let\mathpzc\mathscr
\let\mathpzc\mathcal
\def\BNF{\ \  | \ \  }
\def\bondi{{\bf bondi}}
\def\ltrans{[\![}
\def\rtrans{]\!]}

\usepackage{prooftree}
\usepackage{macros}




\title[A Concurrent Pattern Calculus]{A Concurrent Pattern Calculus\rsuper*}

\titlecomment{{\lsuper*}This paper significantly builds upon
``Concurrent Pattern Calculus'' that first introduced the titled work
\cite{GivenWilsonGorlaJay10}.
Moreover, the behavioural theory has been presented in
\cite{GivenWilsonPHD,GivenWilsonGorla13}.}

\author[T.~Given-Wilson]{Thomas Given-Wilson\rsuper a}	\address{{\lsuper a}INRIA, Paris, France}	\email{thomas.given-wilson@inria.fr}  \thanks{{\lsuper a}The first author has been partially supported by the project ANR-12-IS02-001 PACE}

\author[D.~Gorla]{Daniele Gorla\rsuper b}	\address{{\lsuper b}Dip.~di Informatica, ``Sapienza'' Universit\`a di Roma}	\email{gorla@di.uniroma1.it}

\author[B.~Jay]{Barry Jay\rsuper c}	\address{{\lsuper c}University of Technology, Sydney}	\email{Barry.Jay@uts.edu.au}

\keywords{Pattern Matching; Process Calculi; Behavioural Theory; Encodings}

\ACMCCS{[{\bf Theory of computation}]: Models of computation---Concurrency---Process calculi}

\renewcommand{\beq}{\simeq}
\renewcommand{\rew}{\redar}
\newcommand{\xangle}[1]{\langle #1 \rangle}

\newcommand{\withproof}[1]{#1}


\newcommand{\withsetnot}[2]{#2} 

\makeatletter
\def \rightarrowfill{\m@th\mathord{\smash-}\mkern-6mu\cleaders\hbox{}\hfill
  \mkern-6mu\mathord\to}
\makeatother
\makeatletter
\def \Rightarrowfill{\m@th\mathord{\smash=}\mkern-6mu\cleaders\hbox{}\hfill
  \mkern-6mu\mathord\Rightarrow}
\makeatother
\def \overstackrel#1#2{\mathrel{\mathop{#1}\limits^{#2}}}

\begin{document}
\makeatactive





\maketitle  

\begin{abstract}
Concurrent pattern calculus (CPC) drives interaction between processes by
  comparing data structures, just as sequential pattern calculus
  drives computation. By generalising from pattern matching to pattern
  unification, interaction becomes symmetrical, with information
  flowing in both directions.
  CPC provides a natural language to express trade where information
  exchange is pivotal to interaction.
The unification allows some patterns to be more discriminating than
  others; hence, the behavioural theory must take this aspect into
  account, so that bisimulation becomes subject to compatibility of patterns.
Many popular process calculi can be encoded in CPC; this allows for a
  gain in expressiveness, formalised through encodings.

\end{abstract} 

\section{Introduction}
\label{sec:intro}



The -calculus \cite{milner.parrow.ea:calculus-mobile,sangiorgi.walker:theory-mobile} 
holds an honoured position amongst process calculi as a succinct calculus that can capture topological changes in a network, as well as encode computation as represented by -calculus \cite{Barendregt85}.
Interaction in -calculus is done by matching upon a single name known by both the input and output primitives.
The polyadic -calculus extends this by also matching on the length of the tuple of names to be communicated.
Linda \cite{Gel85} extends this further by allowing matching on any number of names known by both processes.
A more symmetric approach to communication is taken in Fusion calculus \cite{parrow.victor:fusion-calculus} 
that matches a channel name and tuple length, like polyadic -calculus, but allows symmetric information exchange.
Other calculi consider structured information rather than simply names \cite{gordon1997ccp},
even matching arbitrary structures asymmetrically during communication \cite{BJPV11}.
Hence it is natural to explore how a concurrent pattern calculus can unify structured patterns with symmetric matching and communication mechanisms.

This paper develops pattern unification in a setting that supports
parallel composition, name restriction, and replication. This yields
{\em concurrent pattern calculus} (CPC), where prefixes for input and
output are generalised to patterns whose {\em unification} triggers a
symmetric flow of information, as represented by the sole interaction
rule
where  and  are the substitutions on names resulting
from the unification of the patterns  and . 




The flexibility of the pattern unification and the symmetry of exchange 
in CPC align closely with the world of trade. Here the support for 
discovering a compatible process and exchanging information mirrors 
the behaviour of trading systems such as a stock market.
The main features of CPC are illustrated in the following sample trade interaction:

The first line models a seller that will synchronise with a buyer, using the protected
information , and exchange its shares () for bank
account information (bound to ).
The second line models a buyer. Notice that the information exchange is bidirectional
and simultaneous: {\it sharesID} replaces  in the (continuation of the) buyer and
{\it bankAcc} replaces  in the (continuation of the) seller.
Moreover, the two patterns 
and  also specify the
details of the stock being traded, that must be matched for equality in the pattern
matching, as indicated by the syntax .

Pattern unification in CPC is even richer than indicated in this example, as unification
may bind a compound pattern to a single name; that is, patterns do not need to be
fully decomposed in unification.
For example, the bank account information could be specified, and matched upon, in
much more detail.
The buyer could provide the account name and number such as in the following pattern:
.
This more detailed buyer would still match against the seller, now yielding
.
Indeed, the seller could also specify a desire to only accept bank account information
whose structure includes some name and number (bound to  and  respectively) with the following pattern:

and continuation .
This would also match with the detailed buyer information by
unifying  with ,  with , and binding
 and  to  and  respectively.
The second seller exploits the structural matching of CPC to only interact with a
buyer whose pattern is of the right structure (four sub-patterns) and contains
the right information (the protected names  and , and shared information
in the other two positions).


The structural patterns of CPC are inspired by those of {\em pattern calculus} \cite{JK09,pcb}
that supports even more computations than -calculus, since pattern-matching functions may
be {\em intensional} with respect to their arguments \cite{JayGW10}.
For example, the pattern  can decompose any compound data structure
 into its components  and .
This is different from {\em extensional} computation, like those of
- and -calculus, where arguments are `atomic'.
This rich form of structural interaction, combined with concurrency, makes CPC very expressive, as
illustrated by the following diamond \cite{GivenWilsonPHD}:
\begin{center}
\begin{picture}(240,85)(0,0)
\put(95,1){\mbox{-calculus}}
\put(12,38){\mbox{-calculus}}
\put(169,38){\mbox{~-calculus}}
\put(58,78){\mbox{Concurrent Pattern Calculus}}
\put(90,6){\vector(-1,1){28}}
\put(148,6){\vector(1,1){28}}
\put(62,47){\vector(1,1){28}}
\put(174,47){\vector(-1,1){28}}
\end{picture}
\end{center}
The -calculus sits at the bottom and can be generalised either by 
-calculus \cite{JayGW10}, by considering intensionality in the sequential setting,
or by -calculus, by considering concurrency in the extensional setting.
CPC completes the diamond by adding either concurrency to -calculus, or
intensionality to -calculus. Thus, CPC is the most expressive of all
by supporting intensional concurrent computation.

The definition of CPC also includes a behavioural theory that defines
when two processes are behaviourally equivalent. This is done using a
standard approach in concurrency.  First, define an intuitive notion of
equivalence that equates processes with the same behaviour (i.e., with
the same interaction capabilities), in any context and along any reduction sequence, to yield a
notion of {\em barbed congruence}. Second, provide a more effective
characterisation of such equivalence by means of a {\em labelled
transition system} (LTS) and a {\em bisimulation-based} equivalence.
Although this path is familiar, some delicacy is required for each
definition.  For example, as unification of patterns may require
testing of names for equality, the {\em barbs} of CPC (i.e.  the
predicate describing the interactional behaviour of a CPC process)
must account for names that {\em might} be matched, not just those
that {\em must} be matched.  This is different from the standard barbs
of, say, the -calculus.  Further, as some patterns are more
discriminating than others, the bisimulation defined here will rely on
a notion of {\em compatibility} of patterns, yielding a bisimulation
game in which a challenge can be replied to with a different, though
compatible, reply. This is reminiscent of the asynchronous
bisimulation for the asynchronous -calculus
\cite{amadio.castellani.ea:bisimulations-asynchronous}
or the symbolic characterization of open bisimilarity in the -calculus
\cite{San96}.

CPC's support for interaction that is both structured and symmetrical
allows CPC to simulate many approaches to interaction and reduction in the
literature \cite{G:IC08}.  For example, checking equality of channel names, as in
-calculus \cite{milner.parrow.ea:calculus-mobile}, can be viewed
as a trivial form of pattern unification. It also supports 
unification of tuples of names, as in Linda \cite{Gel85}, or fusing names,
as in Fusion \cite{parrow.victor:fusion-calculus}.  Spi calculus
\cite{gordon1997ccp} adds patterns for numbers (zero and successors)
and encryptions. Also the Psi calculus \cite{BJPV11} introduces
support for structures, albeit with a limited symmetry.

More formally, -calculus, Linda and Spi calculus can all be
encoded into CPC but CPC cannot be encoded into any of them.  By
contrast, the way in which name fusion is modeled in fusion calculus
is not encodable into CPC; conversely, the richness of CPC's pattern
unification is not encodable in fusion calculus. Similarly, the
implicit computation of name equivalence
in Psi calculus cannot be encoded within CPC;
the converse separation result is ensured by CPC's symmetry.

A natural objection to CPC is that its unification is too complex to
be an atomic operation. In particular, any limit to the size of
communicated messages could be violated by some match. Also, one
cannot, in practice, implement a simultaneous exchange of information,
so that pattern unification must be implemented in terms of simpler
primitives.
This objection applies to many other calculi.
For example, neither polyadic -calculus' arbitrarily large tuple communication
nor Linda's pattern matching are atomic, but both underpin many existing programming environments
\cite{Pierce97pict:a,cpplinda,Klava,Lime}.
Indeed the arbitrary complexity of both Psi calculus and CPC patterns can
exceed the capability of any computer, yet both have implementations
\cite{Khorsandiaghai603139,cbondi}.
Simlar comments apply to other process calculi
\cite{20110201:jocaml,nomadic-pict}.
A further complexity is the secure synchronisation and information exchange between agents
in distinct locations \cite{DY83,Fournet07atype,bengtson2011refinement},
however since the focus here is on exploring structured, symmetric, pattern unification
and not implementations, we do not attempt to address these details.

The structure of the paper is as follows.  Section \ref{sec:cpc}
introduces symmetric matching through a concurrent pattern calculus
and an illustrative example. Section \ref{sec:bisim} defines the
behavioural theory of the language: its barbed congruence, LTS and the
alternative characterization via a bisimulation-based equivalence.  Section \ref{sec:compare} formalises the relation between CPC and
other process calculi.
Section \ref{sec:conclusions} concludes the paper.
Standard proofs have been moved to the Appendix.

\section{Concurrent Pattern Calculus} 
\label{sec:cpc} 
This section presents a {\em concurrent pattern calculus} (CPC) that
uses symmetric pattern unification as the basis of communication. Both
symmetry and pattern matching appear in existing models of
concurrency, but in more limited ways.  For example, -calculus
requires a sender and receiver to share a channel, so that knowledge
of the channel is symmetric but information flows in one direction
only.  Fusion calculus achieves symmetry by fusing names together but
has no intensional patterns.  Linda's matching is more intensional as
it can test equality of an arbitrary number of names, and the number
of names to be communicated, in an atomic interaction.  Spi calculus
has even more intensional patterns, e.g.~for natural numbers, and can
check equality of terms (i.e.\ patterns), but does not perform
matching in general.  Neither Linda or Spi calculus support much
symmetry beyond that of the -calculus.

The expressiveness of CPC comes from extending the class of
communicable objects from raw names to a class of {\em patterns} that
can be unified. This merges equality testing and bi-directional
communication in a single step.


\subsection{Patterns}

Suppose given a countable set of {\em names}  (meta-variables ).
The {\em patterns} (meta-variables )
are built using names and have the following forms:


A binding name  denotes information sought, e.g.\ by a
trader; a variable name  represents such information. Note that a
binding name binds the underlying process, defined in
Section~\ref{subsec:processes}.  Protected names  represent
information that can be checked but not traded.  A compound combines
two patterns  and , its {\em components}, into a pattern
.  Compounding is left associative, similar to application
in -calculus, and pure pattern calculus.
The {\em atoms} are patterns that are not compounds.  The
atoms  and  {\em know} .

Binding, variable and protected names are all well established
concepts in the literature. Indeed, there is a correspondence between
patterns and prefixes of more familiar process calculi, such as
-calculus: binding names correspond to input arguments and
variable names to output arguments.  Moreover, a form of protected
names appear in Linda.
There is some subtlety in the relationship of protected names to
variable names.  As protected names specify a requirement, it is
natural that they unify with the variable form of the name.
Similarly, as protected names can be used to support
channel-based communication, it is also natural that protected names
unify with themselves.


Given a pattern  the sets of: {\em variables names}, denoted ; {\em protected names}, denoted ; and {\em
  binding names}, denoted , are defined as expected with
the union being taken for compounds.  The {\em free names} of a
pattern , written , is the union of the variable names
and protected names of .  A pattern is {\em well formed} if its
binding names are pairwise distinct and different from the free ones.
All patterns appearing in the rest of this paper are assumed to be
well formed.

As protected names are limited to recognition and binding names are
being sought, neither should be communicable to another process.
This leads to the following definition.
\begin{defi}[Communicable Pattern]
\label{def:communicable}
A pattern is {\em communicable} if it contains no protected or binding names.
\end{defi}
Protection can be extended from names to communicable patterns by
defining


A {\em substitution}  is defined as a partial function from names to communicable patterns.
The {\em domain} of  is denoted ;
the free names of , written , is given by the union of the sets  where .
The {\em names} of , written , are .
A substitution  {\em avoids} a name  (or a collection of names ) if  (respectively ).
Note that all substitutions considered in this paper have finite domain.
For later convenience, we denote by  the identity
substitution on a finite set of names ; it maps every name in  to
itself, i.e.  , for every .


Substitutions are applied to patterns as follows

The action of a substitution
 on patterns can be adapted to produce a function 
that acts on binding names rather than on free names.  In CPC, it is
defined by

When  is of the form ,
then  may be used to denote .

The {\em symmetric matching} or {\em unification}  of
two patterns  and  attempts to unify  and  by generating
substitutions upon their binding names. When defined, the result is
a pair of substitutions whose domains are the binding names of 
and of , respectively. The rules to generate the substitutions are:

Two atoms unify if they know the same name. A name that seeks
information (i.e., a binding name) unifies with any communicable pattern to
produce a binding for its underlying name.  Two compounds unify if
their corresponding components do; the resulting substitutions are
given by taking unions of those produced by unifying the components 
(necessarily disjoint as patterns are well-formed).  Otherwise the
patterns cannot be unified and the unification is undefined.

\begin{prop}
\label{prop:free_n_match}
If the unification of patterns  and  is defined then any protected
name of  is a free name of .
\end{prop}
\begin{proof}
By induction on the structure of . 
\end{proof}



\subsection{Processes}
\label{subsec:processes}

The processes of CPC are given by:
The null process, parallel composition, replication and restriction
are the classical ones for process calculi:  is the inactive
process;  is the parallel composition of processes  and
, allowing the two processes to evolve independently or to
interact; the replication  provides as many parallel copies of 
as desired;  binds  in  so that it is not visible from
the outside.  The
traditional input and output primitives are replaced by the {\em
  case}, viz.  , that has a {\em  pattern}  and a {\em body} .  If
 is  then  may be denoted by .


The free names of processes, denoted , are defined as
usual for all the traditional primitives and
for the case. As expected the binding names of the pattern bind their free occurrences in the body.


\subsection{Operational Semantics}
\label{s:reduction-new}

The application  of a substitution  to a process 
is defined in the usual manner, provided that there is no name
capture.
Name capture can be avoided by -conversion (written ) that
is the congruence relation generated by the following axioms:


The {\em structural congruence relation}  is defined
just as in -calculus \cite{milner:polyadic-tutorial}: it includes
-conversion and its defining axioms are:

It states that:  is a commutative, associative, monoidal operator,
with  acting as the identity; that restriction has no effect
on the null process; that the order of restricted names is
immaterial; that replication can be freely unfolded; and that the
scope of a restricted name can be freely extended, provided that no
name capture arises.

For later convenience,  denotes a sequence of 's, for example
 can denote the names .
Similarly,  will be written ;
however, due to structural congruence, these shall be considered as a set of names.
\withsetnot{}{For clarity set notation is used, for example

shall be denoted .}

The operational semantics of CPC is formulated via a {\em reduction
relation}  between pairs of CPC processes.  Its defining
rules are:

CPC has one interaction axiom, stating that, if the unification of two
patterns  and  is defined and generates , then
the parallel composition of two cases  and  reduces
to the parallel composition of  and .
Alternatively, if the unification of  and  is undefined, then no
interaction occurs.
Unlike the sequential setting, there is no need for a rule to capture failure
of unification since failure to interact with one process does not
prevent interactions with other processes.

The interaction rule is then closed under parallel composition,
restriction and structural congruence in the usual manner. Unlike
pure pattern calculus, but like pi-calculus, computation does not occur within the body of a
case. As usual,  denotes  interactions, and  denotes the reflexive and transitive closure
of .

The section concludes with three simple properties of substitutions and the reduction relation.

\begin{prop}
\label{lem:fn-sub}
For every process  and substitution , it holds that .
\end{prop}
\begin{proof}
By definition of the application of .
\end{proof}

\begin{prop}
\label{prop:free_name_subset}
If , then .
\end{prop}
\begin{proof}
 means that , for some . The proof is by induction on 
and follows by Proposition~\ref{lem:fn-sub}.
\end{proof}

\begin{prop}
\label{red:renaming}
If , then , for every .
\end{prop}
\begin{proof}
By induction on the derivation of  .
\end{proof}

\begin{prop}
\label{prop:free_n_match_proc}
Suppose a process  interacts with a process . If  is a protected
name in  then  must be a free name in .
\end{prop}
\begin{proof}
  For  to interact with  it must be that  such that  and  is defined. Then, by
  Proposition~\ref{prop:free_n_match}, the free names of  include
   and, consequently,  must be free in .  By
  Proposition~\ref{prop:free_name_subset},  is free in . Further,
   cannot belong to , since  and
  .
\end{proof}


\subsection{Trade in CPC}
\label{subsec:cpc-trade}

This section uses the example of share trading to explore the
potential of CPC. The scenario is that two  traders, a buyer
and a seller, wish to engage in trade. To complete a transaction, the
traders need to progress through two stages: {\em discovering} each
other and {\em exchanging} information. Both traders begin with a
pattern for their desired transaction.
The discovery phase can be characterised as a pattern-unification
problem, where traders' patterns are used to find a compatible
partner.
The exchange phase occurs when a buyer and seller have agreed upon a
transaction. Now each trader wishes to exchange information in a
single interaction, preventing any incomplete trade from occurring.

The rest of this section develops three solutions of increasing
sophistication that: demonstrate discovery; introduce a registrar to
validate the traders; and protects names to ensure privacy.
\enlargethispage{\baselineskip}

\subsubsection*{Solution 1}
\label{sec:example:sol1}
Consider two traders, a buyer and a seller. The buyer  with
bank account  and desired shares  can be given by

The first pattern  is used to match with a
compatible seller using share information , and to input a name 
to be used as a channel to exchange bank account information  for
share certificates bound to . The transaction successfully
concludes with .

The seller  with share certificates  and desired share sale
 is given by

The seller creates a channel name  and then tries to find a buyer
for the shares described in , offering  to the buyer to
continue the transaction. The channel is then used to exchange
billing information, bound to , for the share certificates .
The seller then concludes with the successfully completed transaction
as .

The discovery phase succeeds when the traders are placed in a parallel
composition and discover each other by unification on 

The next phase is to exchange billing information for share certificates, as in

The transaction concludes with the buyer having the share
certificates  and the seller having the billing account .

This solution allows the traders to discover each other and exchange
information atomically to complete a transaction. However, there is no way to
determine if a trader is  trustworthy.

\subsubsection*{Solution 2}
\label{sec:example:sol2}
Now add a registrar that keeps track of registered
traders. Traders offer their identity to potential partners
and the registrar confirms if the identity belongs to a valid trader.
The buyer is now

The first pattern now swaps the buyer's identity  for the seller's, 
bound to . The buyer then consults the registrar using the
identifier  to validate ; if valid, the exchange continues as before.

Now define the seller symmetrically by

Also define the registrar  with identifiers  and  to
communicate with the buyer and seller, respectively, by

The registrar creates a new identifier  and delivers it to traders who
have been validated; then it makes the identifier available to known
traders who attempt to validate another known trader.  Although rather
simple, the registrar can easily be extended to support a multitude of
traders.

Running these processes in parallel yields the following interaction

The share information  allows the buyer and seller to discover
each other and swap identities  and . The next two
interactions involve the buyer and seller validating each other's
identity and inputting the identifier to complete the transaction

Now that the traders have validated each other, they can continue
with the exchange step from before

The traders exchange information and successfully complete with 
 and .


\subsubsection*{Solution 3}
\label{sec:example:sol3}
Although Solution 2 satisfies the desire to validate that
traders are legitimate, the freedom of unification allows for
malicious processes to interfere. Consider the promiscuous
process  given by

This process is willing to match any other process that will swap
two pieces of information for some arbitrary name . Such a
process could interfere with the traders trying to complete the
exchange phase of a transaction. For example,

where the promiscuous process has stolen the identifier  and the
bank account information . The unfortunate buyer is left with some
useless information  and the seller is waiting to complete the
transaction.

This vulnerability (emerging both in Solution 1 and 2) can be repaired by using protected
names.
For example, the buyer, seller and registrar of Solution 2 can become 

Now all communications between the buyer, seller and registrar
use protected identifiers:  and .
Thus, we just need to add the appropriate restrictions:

Therefore, other processes can only interact with the traders during
the discovery phase, which will not lead to a successful
transaction. The registrar will only interact with the
traders as all the registrar's patterns have protected names
known only to the registrar and a trader (Proposition~\ref{prop:free_n_match_proc}).


\section{Behavioural Theory}
\label{sec:bisim}
\newcommand{\usedby}[1]{}


This section follows a standard approach in concurrency to defining
behavioural equivalences, beginning with a barbed congruence and
following with a labelled transition system (LTS) and a bisimulation
for CPC. We will prove that the two semantics do coincide. Then the
bisimulation technique will be used to prove some sample equational
laws for CPC.
\nobreak
\subsection{Barbed Congruence}
The first  step is to characterise the interactions a process can participate in via
{\em barbs}. 
Since a barb is an opportunity for interaction, a simplistic
definition could be the following:

However, this definition is too strong: for example,  does not
exhibit a barb according to \eqref{def-one}, but it can interact with an external
process, e.g. .
Thus, an improvement to \eqref{def-one} is as follows:

However, this definition is too weak. Consider : it exhibits
a barb according to \eqref{def-two}, but cannot interact with any external
process.
A further refinement on \eqref{def-two} could be:

This definition is not yet the final one, as it is not sufficiently discriminating to have
only a single kind of barb.
Because of the rich form of interactions in CPC, there is no single identifier such as in CCS
and -calculus -calculus \cite{milner.sangiorgi:barbed-bisimulation},
thus CPC barbs include the set of names that {\em may} be tested for equality
in an interaction, not just those that {\em must} be equal. This leads to the following definition:

\begin{defi}[Barb]
\label{def:barb}
Let  mean that

for some  and  and  and  such that 
 and .
\end{defi}

For later convenience, define  to mean that there exists some 
such that  and .

Using this definition, a barbed congruence can be defined in the standard way
\cite{milner.sangiorgi:barbed-bisimulation,HY95} by requiring three properties.
Let  denote a binary relation on CPC processes, and let a {\em context}
 be a CPC process with the hole `'.

\begin{defi}[Barb preservation]
\label{def:barb-pres}
 is barb preserving iff, for every  and set of names  , it holds that 
implies .
\end{defi}

\begin{defi}[Reduction closure]
\label{def:barb-close}
 is reduction closed iff, for every , it holds that 
implies , for some  such that .
\end{defi}

\begin{defi}[Context closure]
\label{def:cont-close}
 is context closed iff, for every  and CPC context
, 
it holds that .
\end{defi}

\begin{defi}[Barbed congruence]
\label{def:barb-con}
Barbed congruence, , is the least binary relation on CPC processes that is symmetric, barb preserving, reduction closed and
context closed.
\end{defi}

Barbed congruence relates processes with the same
behaviour, as captured by barbs: two equivalent processes must exhibit the same behaviours, 
and this property should hold along every sequence of reductions and in every execution context.

The challenge in proving barbed congruence is to prove
context closure.  The typical way of solving the problem is by giving
a coinductive (bisimulation-based) characterization of barbed
congruence, that provides a manageable proof technique. In turn, this
requires an alternative operational semantics, by means of a labelled
transition system, on top of which the bisimulation equivalence can be
defined.

\subsection{Labelled Transition System}
\label{sec:LTS}

The following is an adaption of the late LTS for the
-calculus \cite{milner.parrow.ea:calculus-mobile}.
{\em Labels} are defined as follows:

where  is used to label silent transitions.
\begin{figure}[t]

\caption{Labelled Transition System for CPC (the symmetric versions of {\sf parint} and {\sf parext} have been omitted)}
\label{fig:lts}
\end{figure}

Labels are used in {\em transitions}  between CPC
processes, whose defining rules are given in Figure~\ref{fig:lts}. If
 then  is a {\em -reduct} of , alternatively the transition 
indicates that  is able to {\em perform}  and reduces to .
Rule {\sf case} states that a case's pattern can be used to interact with external processes.
Rule {\sf resnon} is used when a restricted name does not appear in the names of the label: it simply maintains the restriction on the process after the transition.
By contrast, rule {\sf open} is used when a restricted name occurs in the label: as the restricted name is going to be shared with other processes, the restriction is moved from the process to the label (this is called {\em extrusion}, in -calculus terminology).
Rule {\sf unify} defines when two processes can interact to perform an internal action:
this can occur whenever the processes exhibit labels with unifiable patterns and with no possibility of clash or capture due to restricted names.
Rule {\sf parint} states that, if either process in a parallel composition can evolve with an internal action, then the whole process can evolve with an internal action.
Rule {\sf parext} is similar, but is used when the label is visible: when one of the processes in parallel exhibits an external action, then the whole composition exhibits the same external action, as long as the restricted or binding names of the label do not appear free in the parallel component that does not generate the label.
Finally, rule {\sf rep} unfolds the replicated process to infer the action. 

Note that -conversion is always assumed, so that the  side conditions can always be satisfied in practice. 

The presentation of the LTS is concluded with the following two
results.  First, for every  and , there are finitely many
-equivalence classes of -reducts of 
(Proposition~\ref{prop:imfin}).  Second, the LTS induces the same
operational semantics as the reductions of CPC
(Proposition~\ref{prop:tau-red}).  As CPC reductions only involve
interaction between processes and not external actions, it is
sufficient to show that any internal action of the LTS is mimicked by
a reduction in CPC, and vice versa. All proofs are in Appendix A, because they are quite standard.

\begin{defi}
An LTS is {\em structurally image finite} if, for every  and , it holds that
 contains finitely many elements.
\end{defi}


\begin{prop}
\label{prop:imfin}
The LTS defined in Figure~\ref{fig:lts} is structurally image finite.
\end{prop}
\usedby{Lemma \ref{lem:bisim-rep}}


\begin{lem}
\label{lem:lts-exhibit-p}
If  then 
there exist  and  and  such that 
 and
 and
 and .
\end{lem}
\usedby{Prop \ref{prop:tau-red} and Lemma \ref{lem:sound-one}}

\begin{prop}
\label{prop:tau-red}
If  then .
Conversely, if  then there exists  such that .
\end{prop}
\usedby{Lemma \ref{lem:sound-two}, Lemma \ref{lem:succ-beq} and Thm \ref{thm: complete}}

To conclude, it is known that -conversion must be handled with care \cite{UBN07}.
A way in which we can leave it out from our presentation is to follow \cite{BP09}, that
also has the advantage of being implementable in Isabelle/HOL \cite{NPW02}.
However, we prefer to follow a more traditional approach in our presentation.


\subsection{Bisimulation}
\label{sec:bis}

We now develop a {\em bisimulation} relation for CPC that equates processes with the same interactional behaviour; this is captured by the labels of the LTS.
The complexity for CPC is that the labels for external actions contain patterns, and some patterns are more general than others, in that they unify with more things. 
For example, a transition  performs the action ; however a similar external action of another process could be the variable name  and the transition .
Both transitions have the same barb, that is  and ; however their labels are not identical
and, indeed, the latter can interact with a process performing a transition labeled with  whereas the former cannot.
Thus, a {\em compatibility} relation is defined on patterns that can be used to develop the bisimulation.
The rest of this section discusses the development of compatibility and concludes with the definition of bisimulation for CPC.

Bisimilarity of two processes  and  can be captured by a challenge-reply game 
based upon the actions the processes can take.
One process, say , issues a {\em challenge} and evolves to a new state .
Now  must perform an action that is a {\em proper reply} and evolve to a state .
If  cannot perform a proper reply then the challenge issued by  can distinguish  and , 
and shows they are not equivalent.
If  can properly reply then the game continues with the processes  and .
Two processes are bisimilar (or equivalent) if any challenge by one
can be answered by a proper reply from the other. 

The main complexity in defining a bisimulation to capture this challenge-reply game is the choice of actions, i.e.\ challenges and replies.
In most process calculi, a challenge is replied to with an identical action \cite{Mil89,milner.parrow.ea:calculus-mobile}.
However, there are situations in which an exact reply would make the bisimulation equivalence too fine for characterising barbed congruence \cite{amadio.castellani.ea:bisimulations-asynchronous,DGP:IC07}.
This is due to the impossibility for the language contexts to force barbed congruent processes to execute the same action; in such calculi more liberal replies must be allowed. That CPC lies in this second group of calculi is demonstrated by the following two examples.

\begin{exa}{Example 1}
\label{ex:input}
Consider the processes

together with the challenge .
One may think that a possible context

to enforce a proper reply could be , for  fresh.
Indeed, 
and the latter process exhibits a barb over .
However, the exhibition of action  is {\em not} necessary
for the production of such a barb: indeed,
,
but in doing so  performs  instead of .
\end{exa}

\begin{exa}{Example 2}
\label{ex:pro}
Consider the processes

together with the context , for  fresh.
Although  and the latter process exhibits a barb over ,
the exhibition of action  is {\em not} necessary for the production of such a barb:
 also exhibits a barb on ,
but in doing so  performs  instead of .
\end{exa}

\medskip

Example~1 shows that CPC pattern-unification allows binding names to be contractive: 
it is not necessary to fully decompose a pattern to bind it.
Thus a compound pattern may be bound to a single name or to more than one name in unification.
Example~2 illustrates that CPC pattern-unification on protected names only requires the other pattern know the name, but such a name is not necessarily protected in the reply.

These two observations make it clear that some patterns are more discerning than others,
i.e.\ unify with fewer patterns than others. This leads to the following definitions.

\begin{defi}
\label{def:match}
Define a {\em match}  to be a pattern  and substitution  such that
.
\end{defi}

\begin{defi}
\label{def:compat}
Let  and  be matches.
Define inductively that  is {\em compatible} with  by  and , 
denoted  as follows:

\end{defi}

The idea behind this definition is that a pattern  is compatible
with another pattern  with substitutions  if and only if every other pattern  that
unifies  by some substitutions  also unifies with
 with substitutions .
That is, the patterns that unify with  are a subset of
the patterns that unify with .  This will be proved later in
Proposition~\ref{lem:pat-lessthan}.

The compatibility relation on patterns provides the concept of proper reply in the challenge-reply game.

\begin{defi}[Bisimulation]
\label{def:bisim}
A symmetric binary relation on CPC processes  is a bisimulation if,
for every  and , it holds that:
\begin{itemize}
  \item if , then , for some  such that ;
  \item if  and ,
		then, for all matches  with 
        ,
        there exist a match  and  
		such that
         and
         
        and .
\end{itemize}
Denote by  the largest bisimulation closed under any substitution.
\end{defi}

The definition is inspired by the early bisimulation congruence for the
-calculus \cite{milner.parrow.ea:calculus-mobile} (actually, it is what
in \cite{sangiorgi.walker:theory-mobile} is called {\em strong full bisimilarity} -- see Definition 2.2.2 therein):
	for every possible instantiation  of the binding names,
	there exists a proper reply from .
Of course,  cannot be chosen arbitrarily:
	it cannot use in its range names that were opened by .
Also the action  cannot be arbitrary, as in the -calculus:
	its restricted and binding names cannot occur free in .

Unlike the -calculus, however, the reply from  can be
different from the challenge from :
	this is due to the fact that contexts in CPC are not powerful enough to
	enforce an identical reply (as highlighted in Examples~1 and~2).
Indeed, this notion of bisimulation allows a challenge  to be replied to by
any compatible , provided that  is properly adapted (yielding , as
described by the compatibility relation) before being applied to .
This feature somehow resembles the symbolic characterization of 
open bisimilarity given in \cite{San96,BM08}. There, labels are pairs made up
of an action and a set of equality constraints. A challenge can be replied to by a 
smaller (i.e.~less constraining) set. However, the action in the reply must be 
the same (in \cite{San96}) or becomes the same once we apply the name identifications
induced by the equality constraints (in \cite{BM08}).

An alternative approach may consider a standard bisimulation defined on top of an LTS that directly captures
the difficulties of Examples 1 and 2.
That is, allow  to reduce with label  to ; similarly, allow
 to reduce with label  to . For example, this would allow the transition 
.
The difficulty with this approach is that, for every binding name in a pattern, there would be an
infinite collection of transitions. For example,  would have transitions , 
where  can be  (for every ), but also
 and ,
and so forth (with  adapted appropriately).
This would make working with the LTS very heavy (the LTS would not be finitely branching anymore);
so the simplicity of relating patterns by compatibility is used here.


\subsection{Properties of Compatibility}

This section considers some properties of the compatibility relation on patterns introduced in Section~\ref{sec:bis}; 
they are formalised for later exploitation, even though some of them also illustrate some general features of patterns.
In particular, we show that compatibility preserves information used for barbs, is stable under substitution, is reflexive and transitive.

\begin{lem}
\label{prop:compat-fn}
If  then  and  
and .
\end{lem}
\usedby{Lemma \ref{lem:sound-one} and \ref{lem:bisim-nuR}}
\begin{proof}
By definition of compatibility and induction on the structure of .
\end{proof}


Given two substitutions  and , denote with  
the composition of  and ,
with domain limited to the domain of , 
i.e.\ the substitution mapping every  to .

\begin{lem}
\label{lem:compat-compose-subs}
If  then , for every .
\end{lem}
\usedby{Lemma \ref{lem:succ-beq} and Thms \ref{thm: complete} and \ref{eq-grrr}}
\begin{proof}
By induction on the structure of . The only interesting base case is when .
Since , we have that
, for .
\end{proof}

\begin{prop}[Compatibility is reflexive]
\label{prop:compat-reflexive}
For all matches , it holds that .
\end{prop}
\usedby{Lemma \ref{lem:bisim-case}, Lemma \ref{lem:bisim-nuR} and Thms \ref{thm: complete} and \ref{eq-grrr}}
\begin{proof}
By definition of compatibility.
\end{proof}

\begin{prop}[Compatibility is closed under substitution]
\label{prop:compat-sub-closed}
If  then for all substitutions  there exists
 and  such that
.
\end{prop}
\usedby{Lemma~\ref{lem:bisim-case}}
\begin{proof}
By induction on the structure of .
\end{proof}

\begin{prop}[Compatibility is transitive]
\label{prop:trans-pattern}
If  and  then .
\end{prop}
\usedby{Lemma \ref{lem:trans-bisim}}
\begin{proof}
By induction on . We have three possible base cases:
\begin{itemize}
\item : in this case, , for some , and
	 
	Again by definition of compatibility,
	,
	for some , and 
	
	Thus, 
	and , as desired.
\item : in this case  and . Again by compatibility,
	 and ; thus .
\item : in this case  can either be  or , and . Again by compatibility,
	 or  (this is possible only when ), and ; in all cases, 
	.
\end{itemize}
For the inductive step, let . By compatibility,  and
 and , with
, for . Similarly,  and 
, with , for . 
By two applications of the inductive hypothesis, we obtain , for ,
and by definition of compatibility we can conclude.
\end{proof}

The next result captures the idea behind the definition of
compatibility: the patterns that unify with  are a subset of the
patterns that unify with .

\begin{prop}
\label{lem:pat-lessthan}
If  then, for every  and  such that ,
we have that .
\end{prop}
\proof
The proof is by induction on . There are three possible base cases:
\begin{itemize}
	\item If  then  and ; for the unification of
				 and  to be defined, it must be  and
				, each  is communicable and .
				It follows that .
	\item If  then  and .
				For  to unify with , it must be that  is  or ; in both cases .
				Hence, .
	\item If  then  is either  or , and . 
				In both cases,  can as well be either  or .
				The proof is similar to the previous case.
\end{itemize}
For the inductive step, ; by comparability, .
There are two possible cases for  to unify with :
	\begin{itemize}
	\item If , then  must be communicable and ; 
		thus, by definition of comparability,  and .
		Hence, .
	\item Otherwise, for  to unify with , it must be  
		with , for ,
		and  and . 
		Conclude by two applications of induction and by definition of compatibility.\qed
	\end{itemize}

\noindent Notice that the converse does not hold. Take  and ; we have that, for every
 such that , we have that  (the only
such 's are  and , for which ); however, .

The following result is a variation of the previous lemma, that fixes  to  but
allows an arbitrary substitution in the unification with .

\begin{prop}
\label{lem:compat-match}
If  and ,
then .
\end{prop}
\usedby{Thm \ref{eq-grrr}}
\proof
By induction on . There are three possible base cases:
\begin{itemize}
\item : by Definition~\ref{def:compat}, it must be that , i.e.
, for some . Thus, ,
 communicable,  and .
By definition of unification,  and conclude, since
.

\item : in this case, it must be either  or ; in both cases, .
If , then conclude, since  and .
If , obtain that  can be either  or ; in both cases 
and conclude.

\item : in this case ,  and work like in the previous case.
\end{itemize}
For the inductive case, ; thus, by Definition~\ref{def:compat},
 and , where
, for . We have two possibilities for :
\begin{itemize}
\item , where , for ; 
moreover, 
and . Apply induction two times and to conclude.

\item  and  is communicable; thus,  and .
  By definition of compatibility,  and . Conclude
  with .\qed
\end{itemize}


\noindent As compatibility is an ordering on matches,
it is interesting to observe that, for every pattern , there is a unique (up to -conversion) 
maximal pattern w.r.t. . Note that, as in Proposition~\ref{lem:compat-match} the substitution can be 
fixed (or indeed entirely elided).

\begin{prop}
\label{prop:maximal}
For every pattern  there exists a maximal pattern  with respect to ;
this pattern is unique up-to -conversion of binding names.
\end{prop}
\usedby{Lemma \ref{lem:bisim-rep}}
\begin{proof}
The proof is by induction on the structure of :
\begin{itemize}
	\item If , then the largest  w.r.t.  is  for some fresh .
	\item If  is  or , then the largest  w.r.t.  is .
	\item Otherwise, if , then proceed by induction on  and .
\end{itemize}
The only arbitrary choice is the  used in the first item, that can be -converted to
any other fresh name.
\end{proof}

To conclude the properties of the compatibility, it is worth remarking that it does not yield a lattice: there is no supremum for the two patterns  and .



\subsection{Soundness of the Bisimulation}
\label{sec:sound}

This section proves soundness by showing that the bisimulation relation is included in barbed congruence.
This is done by showing that the bisimilarity relation is an equivalence, it is
barb preserving, reduction closed and context closed.

\begin{lem}
\label{lem:trans-bisim}
If  and  then .
\end{lem}
\usedby{Lemma \ref{lem:bisim-rep}}
\begin{proof}
Standard, by exploiting Proposition~\ref{prop:trans-pattern}.
\end{proof}

\begin{lem}
\label{lem:sound-one}
 is barb preserving.
\end{lem}
\usedby{Thm \ref{thm: sound}}
\begin{proof}
Straightforward by Lemmata~\ref{prop:compat-fn} and~\ref{lem:lts-exhibit-p}, and by definition of the LTS.
\end{proof}

Closure under any context is less easy to prove.
The approach here is as follows:
prove bisimilarity is closed under case prefixing,
name restriction and parallel composition; finally, prove closure under replication.
Proofs of these lemmata are in Appendix B, because they are adaptions
of the corresponding results for the -calculus.
These three results will easily entail closure under arbitrary contexts (Lemma~\ref{lem:sound-three}).

\begin{lem}
\label{lem:bisim-case}
If  then .
\end{lem}
\usedby{Lemma \ref{lem:sound-three}}

\begin{lem}
\label{lem:bisim-nu}
If  then .
\end{lem}
\usedby{Lemma \ref{lem:bisim-rep}, Lemma \ref{lem:sound-three} and Thm \ref{eq-grrr}}

\begin{lem}
\label{lem:bisim-par}
If  then .
\end{lem}
\usedby{Lemma \ref{lem:bisim-rep}, Lemma \ref{lem:sound-three} and Thm \ref{eq-grrr}}

\begin{lem}
\label{lem:bisim-rep}
If  then .
\end{lem}
\usedby{Lemma \ref{lem:sound-three}}

\begin{lem}
\label{lem:sound-three}
 is contextual.
\end{lem}
\usedby{Thm \ref{thm: sound}}
\begin{proof}
Given two bisimilar processes  and , it is necessary to show that for any context 
 it holds that .
The proof is by induction on the structure of the context.
If  then the result is immediate.
For the inductive step, we reason by case analysis on the outer operator of :
then, we simply use the inductive hypothesis and Lemmata~\ref{lem:bisim-case}, \ref{lem:bisim-nu},
\ref{lem:bisim-par} and~\ref{lem:bisim-rep}, respectively.
\end{proof}

Finally, we have to prove that bisimilarity is reduction closed; to this aim, we first need
to prove that structural congruence is contained in bisimilarity.

\begin{lem}
\label{lem:struct-is-a-bisim}
 is a bisimulation closed under substitutions.
\end{lem}
\usedby{Thm \ref{lem:sound-two}}
\proof
For every structural axiom  it suffices to show that 
is a bisimulation. Closure under contexts follows from Lemma~\ref{lem:sound-three}. Closure under
substitutions follows from the fact that the axioms only involve bound names. The only exception 
is the rule for scope extension; however, the fact that substitution application is capture-avoiding
allows us to conclude.
\qed

\begin{lem}
\label{lem:sound-two}
 is reduction closed.
\end{lem}
\usedby{Thm \ref{thm: sound}}
\begin{proof}
By Proposition~\ref{prop:tau-red} and Lemma~\ref{lem:struct-is-a-bisim}.
\end{proof}


The soundness of bisimilarity w.r.t. barbed congruence now follows.

\begin{thm}[Soundness of bisimilarity]
\label{thm: sound}
.
\end{thm}
\begin{proof}
Lemma~\ref{lem:sound-one}, Lemma~\ref{lem:sound-three} and Lemma~\ref{lem:sound-two}
entail that  satisfies the conditions of Definition~\ref{def:barb-con}.
\end{proof}



\subsection{Completeness of the Bisimulation}

Completeness is proved by showing that barbed congruence is a bisimulation.
There are two results required:
showing that barbed congruence is closed under substitutions,
and showing that, for any challenge, a proper reply can be obtained via closure under an appropriate context.
To this aim, we define notions of success and failure that can be reported.
A fresh name  is used for reporting success, with a barb  indicating success, and  indicating a reduction sequence that can eventually report success. Failure is handled similarly using the fresh name .
A process  {\em succeeds} 
if  and ;
 is {\em successful} if , for some  and  and  
such that  and .

The next lemma shows that barbed congruence is closed under any substitution.

\begin{lem}
\label{lem:bcon-sub}
If  then , for every .
\end{lem}
\usedby{Lemma \ref{lem:succ-beq} and Thm \ref{thm: complete}}
\begin{proof}
Given a substitution , choose patterns  and  such that ;
to be explicit,  and ,
for .
Define ;
by context closure, .
By reduction closure, the reduction  can be replied to 
only by ; hence, , as desired.
\end{proof}

The other result to be proved is that challenges can be tested for a proper reply by a context.
When the challenge is an internal action, the reply is also an internal action; thus, the empty 
context suffices, as barbed congruence is reduction closed.
The complex scenario is when the challenge is a pattern together with a set of restricted names, 
i.e., a label of the form .
Observe that in the bisimulation such challenges also fix a substitution  whose domain is the binding names of .
Most of this section develops a reply for a challenge of the form ;
the general setting (with an arbitrary ) will be recovered in Theorem~\ref{thm: complete}
by relying on Lemma~\ref{lem:compat-compose-subs}.

The context for forcing a proper reply for a challenge of the form  is developed in three steps.
The outcome will be a process that interacts by some pattern  and reduces to a collection of tests  such that  succeeds
if and only if .
The first step presents the {\em specification} of a pattern and a set of names  (to be thought of as the free names of the processes being compared for bisimilarity); this is the information required to build a reply context.
The second step develops auxiliary processes to test specific components of a pattern, based on information from the specification.
The third step combines these into a reply context that succeeds if and only if it interacts 
with a process that exhibits a proper reply to the challenge.

For later convenience, we define the {\em first projection}  and
{\em second projection}  of a set of pairs: e.g.,
 and , respectively.


\begin{defi}
\label{def:bchar}
The {\em specification}  of a pattern  with respect to a finite set of names  is defined follows:

where  denotes , provided that 
(a similar meaning holds for ).
\end{defi}
Observe that, since we only consider well formed patterns, the disjoint unions  and  are defined and the choices of the binding names for  are pairwise distinct.

Given a pattern , the specification  of  with respect to a set of names  has three components:
\begin{enumerate}
\item , called the {\em complementary pattern}, is a pattern used to ensure that the context interacts with a 
process that exhibits a pattern  such that  is compatible with  (via some substitutions);
\item  is a collection of pairs  made up by a binding name in  and the expected 
name (free in the process being tested) it will be bound to;
\item finally,  is a collection of pairs  made up by a binding name in  and the expected
name (restricted in the process being tested) it will be bound to.
\end{enumerate}

\noindent The specification is straightforward for binding names, protected names and compounds.
When  is a variable name,  is a fresh binding name  and the intended binding of  to  
is recorded in  or , according to whether  is free or restricted, respectively.

\begin{lem}
\label{prop:spec-pp}
Given a pattern  and a finite set of names , let .
Then, .
\end{lem}
\usedby{Thm \ref{thm:lts-2-reply-succeed}}
\begin{proof}
By straightforward induction on the structure of .
\end{proof}
\enlargethispage{\baselineskip}

To simplify the definitions, let  be the parallel composition of 
processes , for each  in . 
The tests also exploit a check  to ensure equality or 
inequality of name substitutions:

Observe that failure here is indicated by pattern ; in this way,
two failure barbs cannot unify and so they cannot disappear during computations.

\begin{defi}[Tests]
Let  and  be fresh names, i.e.\ different from all the other names around. Then define:

\end{defi}

The behaviour of the tests just defined is formalized by the following three results.

\begin{lem}
\label{lem:free-succ}
Let  be such that ; then,
 succeeds if and only if .
\end{lem}
\usedby{Lemma \ref{lem:theta-charP} and \ref{lem:reply-rename}}
\begin{proof}
Straightforward.
\end{proof}

\begin{lem}
\label{lem:rest-succ}
Let  be such that ; then,
 succeeds if and only if .
\end{lem}
\usedby{Lemma \ref{lem:theta-charP} and \ref{lem:reply-rename}}
\begin{proof}
Straightforward.
\end{proof}

\begin{lem}
\label{lem:equi-succ}
Let  be such that ; then,
 succeeds if and only if, for every , 
 if and only if .
\end{lem}
\usedby{Lemma \ref{lem:theta-charP} and \ref{lem:reply-rename}}
\begin{proof}
In order for  to succeed by exhibiting a barb , 
each check  must succeed by producing .
The rest of the proof is straightforward.
\end{proof}

\begin{lem}
\label{lem:exact-reduct-tests}
Let  be a test and  be a substitution such that  succeeds; 
there are exactly  reductions of  to a successful process, where  depends only on the structure of .
\end{lem}
\begin{proof}
Straightforward for free and restricted tests, for which  and , respectively. 
For an equality test  it suffices to observe that each successful check has an exact 
number of reductions to succeed (1, if , 0 otherwise) and then there is a reduction to consume the success 
barb of each check.
Thus, , where  is the number of pairs in  whose second component equals .
\end{proof}

From now on, we adopt the following notation: if , then 
denotes . Moreover,  denotes
; hence,  denotes
.

\begin{defi}
\label{def:char}
The {\em characteristic process}  of a pattern  with respect to a finite set of names  is  where  and 

where  and
.
\end{defi}


\begin{lem}
\label{lem:theta-charP}
Let  be such that ; then,
 succeeds if and only if
\begin{enumerate}
\item for every  it holds that ;
\item for every  it holds that ;
\item for every  and  it holds that  if and only if .
\end{enumerate}
\end{lem}
\usedby{Thm \ref{thm:lts-2-reply-succeed}}
\begin{proof}
By induction on  and Lemmata~\ref{lem:free-succ},
\ref{lem:rest-succ} and \ref{lem:equi-succ}. Indeed, by Definition~\ref{def:bchar},
; moreover, freshness of
 and  implies that .
\end{proof}

Note that the following results will consider the number of reductions required to succeed.
These are significant to proving the results in the strong setting, but unimportant in
the weak setting, i.e.\ with  replaced by .

\begin{lem}
\label{lem:min-reduct-charP}
Given  and any substitution 
such that  and  succeeds,
then there are exactly  reduction steps ,
where  and  and  depends only on  and  and ; moreover,
no sequence of reductions shorter than  can yield a successful process.
\end{lem}
\usedby{Prop \ref{prop:reply-context-minimum} and Thm \ref{thm:lts-2-reply-succeed}}
\begin{proof}
By induction on  and Lemma~\ref{lem:exact-reduct-tests}.
\end{proof}

Notice that  does not depend on ; thus, we shall refer to  as the number of 
reductions for  to become successful.
The crucial result we have to show is that the characterisation of a pattern  with respect to a set of names  can yield a reduction via a proper reply (according to Definition~\ref{def:bisim}) to the challenge  when  does not intersect .
A reply context for a challenge  with a finite set of names  can be defined by exploiting the characteristic process.

\begin{defi}
\label{def:reply-context}
A {\em reply context}  for the challenge  with a finite set of names  such that  is disjoint from  is defined as follows:

\end{defi}

\begin{prop}
\label{prop:reply-context-minimum}
Given a reply context , the minimum number of reductions required for  
to become successful (for any ) is the number of reduction steps for  to become successful plus 1.
\end{prop}
\usedby{Thms \ref{thm:lts-2-succeed-reply} and \ref{thm: complete}}
\begin{proof}
By Definition~\ref{def:reply-context}, success can be generated only after removing the case  from ;
this can only be done via a reduction together with , i.e.\  must eventually yield a pattern 
that unifies with . The minimum number of reductions is obtained when  already yields such a , i.e.\ when  is a 
process of the form , for some  and  and  and  such that  and  succeeds. In this case, 
; 
by Lemma~\ref{lem:min-reduct-charP},  is successful after
 reductions; thus,  is successful after  reductions, and this is
the minimum over all possible 's.
\end{proof}

Denote the number of reductions put forward by Proposition~\ref{prop:reply-context-minimum} as .
The main feature of  is that, when the hole is filled with a process , it holds that
 is successful after  reductions if and only if
there exist  and  such that  and .
This fact is proved by Propositions~\ref{thm:lts-2-reply-succeed} and~\ref{thm:lts-2-succeed-reply}.

\begin{prop}
\label{thm:lts-2-reply-succeed}
Suppose given a challenge , a finite set of names , a process  and fresh names  and  such that 
 and .
If  has a transition of the form  and there is a substitution  such that
 then
 succeeds and has a reduction sequence
, where  and .
\end{prop}
\usedby{Lemma \ref{lem:succ-beq} and Thm \ref{thm: complete}}
\begin{proof}
We assume, by -conversion, that binding names of  are fresh, in particular do not appear in .
By Lemma~\ref{prop:spec-pp}  where  and .
By Proposition~\ref{lem:pat-lessthan} ; thus . Since  and  do not appear in , the only possibility of producing a successful
process is when  succeeds; this is ensured by Lemma~\ref{lem:theta-charP}. The thesis follows by Lemma~\ref{lem:min-reduct-charP}.
\end{proof}

The main difficulty in proving the converse result is the possibility of renaming restricted names. 
Thus, we first need a technical lemma that ensures us the possibility of having the same set of restricted 
names both in the challenge and in the reply, as required by the definition of bisimulation.

\begin{lem}
\label{lem:reply-rename}
Let  and  be such that ,  and
. If  is such that  and
 such that  succeeds, then:
\begin{itemize}
\item ; 
\item there exists a bijective renaming  of  into 
such that ;
\item .
\end{itemize}
\end{lem}
\usedby{Thm \ref{thm:lts-2-succeed-reply}}
\proof
The proof is by induction on the structure of . We have three possible base cases:
\begin{enumerate}
	\item If , then  and . By definition of pattern unification,
		, for any . Since  and ,
		it can only be ; then,  and . This suffices to conclude,
		since  and
		.
	\item If , then , for  fresh. Let us distinguish two subcases:
		\begin{enumerate}
		\item If , then  and . By definition of pattern unification,
                   must be communicable,  and .  Since  only
                  contains , by
                  Lemma~\ref{lem:free-succ} it holds that . This suffices to conclude, since
                   and .

		\item If , then  and . Like before,
		 must be communicable,  and . 
		Since  contains ,
		by Lemma~\ref{lem:rest-succ} it holds that ;
		thus, .
		This suffices to conclude, by taking , since . 
		\end{enumerate}
	\item If , then  and . By definition of pattern unification,
		 and . In any case, 
		 and
		.
\end{enumerate}
For the inductive case, let . By definition of specification,
,  and , where
, for . 
By definition of pattern unification, there are two possibilities for :
\begin{enumerate}
\item If , for some , then  must be communicable and
	 and .
    If  is communicable then by definition of specification
     and 
    and conclude with .

\item Otherwise, it must be that , with
	, for ; moreover,
	 and .
	Since the first components of  and  are disjoint (and similarly for  and ),
	 succeeds implies that both  and
	 succeed, since every test of 
	is a test of . Now, by two applications of the induction hypothesis,
	we obtain that, for :
	\begin{itemize}
	\item , where  and ; 
	\item there exists a bijective renaming  of  into 
	such that ;
	\item .
	\end{itemize}
    We now show that every name  is in the domain of  and that .
    Further, that if  is in only one of  then  only appears in the
    corresponding , alternatively if  is in both  and  then 
    for some .
	\begin{enumerate}
	\item {\em if , then :}\\
		by contradiction, assume that  (indeed, 
		, by construction of ). By construction of the specification,
		there exists . Moreover, since , there exists 
		such that  but . Again by construction of the specification,
		there exists . By inductive hypothesis,  
		and . But then , that
		is part of , cannot succeed, since 
		(see Lemma~\ref{lem:equi-succ}). Contradiction.
	\item {\em if , then :}\\
		similar to the previous case.
	\item {\em if , then :}\\
		let ; by construction of the specification,
		there exists . By contradiction, assume that .
		Then, , that is part of , 
		reports failure, since by induction 
		(see Lemma~\ref{lem:equi-succ}). Contradiction.
	\end{enumerate}
	Thus,  and  have the same cardinality; moreover,  is a
	bijection between them and it is well-defined (in the sense that  and  coincide on all elements
	of  -- see point (c) above). 
	Thus,  and ;
	so, . Moreover, 
 as desired.\qed
\end{enumerate}
\enlargethispage{\baselineskip}

\begin{prop}
\label{thm:lts-2-succeed-reply}
Suppose given a challenge , a finite set of names , a process  and fresh names  and  such that  and .
If  is successful after  reduction steps,
then there exist  and  such that 
and .
\end{prop}
\usedby{Lemma \ref{lem:succ-beq} and Thm \ref{thm: complete}}
\begin{proof}
By Proposition~\ref{prop:reply-context-minimum},
there must be a reduction 
obtained because  and .
Since  and , it must be that
 succeeds; by 
Proposition~\ref{prop:reply-context-minimum}, this happens in  reduction steps.

By hypothesis, ; thus, .
Moreover, by -conversion, ;
thus, by , we have
that . Since ,
we also have that ; thus, we can
use Lemma~\ref{lem:reply-rename} and obtain a bijection  
such that ; moreover, by -conversion,
. We can conclude by taking  and
.
\end{proof}


We are almost ready to give the completeness result, we just need an auxiliary lemma that allows us to remove
success and dead processes from both sides of a barbed congruence, while also opening the scope of the names
exported by the success barb.

\begin{lem}
\label{lem:succ-beq}
Let , 
for  and ; then .
\end{lem}
\usedby{Thm \ref{thm: complete}}
\begin{proof}
By Theorem~\ref{thm: sound}, it suffices to prove that

is a bisimulation. Consider the challenge  and reason by case analysis on .
\begin{itemize}
\item If , then .
By Proposition~\ref{prop:tau-red} and reduction closure, 
 such that .
By Proposition~\ref{prop:free_n_match_proc} (since ) and , it can only be that
, where .
By definition of , we conclude that .

\item If , for .
By -conversion, we can also assume that .
Let us now fix a substitution  such that  and
. Consider the context

for  fresh (in particular, different from ). Consider now the following sequence of reductions:

The first reduction is obtained by unifying  with the first
case of ; this replaces the binding names  in the context with 
the variable names  and the scope of the restriction is extended consequently.
Moreover, : the first equality holds because
 and ;
the second equality holds by definition of reply context.
The second sequence of reductions follows by Proposition~\ref{thm:lts-2-reply-succeed}
(ensuring that , for ), 
Proposition~\ref{red:renaming}
and by the fact that 
(indeed,  is fresh and ).
Moreover, notice that , because of 
Lemma~\ref{lem:bcon-sub}.
The last reduction is obtained by unifying  with the 
case  of the context; this replaces the binding names  
in the context with the variable names  and the scope of the restriction 
is extended consequently.

Consider now ; then
reduction closure yields
 such
that . As  has a barb containing , so must  ;
by definition of , this can happen only if 
is successful after  steps. By Proposition~\ref{thm:lts-2-succeed-reply},
this entails that there exist  and  such that 
and . Moreover, with a reasoning similar to that
for the reductions of , we can conclude
that ;
indeed, in this case applying  Proposition~\ref{thm:lts-2-reply-succeed} yields
.

To state that , it suffices to notice
that ; this holds because of contextuality of barbed congruence.
Finally, Lemma~\ref{lem:compat-compose-subs} entails that : 
indeed,  because .
This shows that  and  is a proper reply to the challenge 
 together with .
\end{itemize}
Closure under substitution holds by definition of .
\end{proof}

\begin{thm}[Completeness of the bisimulation] 
\label{thm: complete}
.
\end{thm}
\begin{proof}
It is sufficient to prove that, for every pair of processes  and  such that  and
for every transition , there exists a proper reply (according to the definition of 
the bisimulation) of  and the reducts are still barbed congruent.
This is straightforward when , due to reduction closure and Proposition~\ref{prop:tau-red}.
The difficult case if when , for .
In this case fix a substitution  such that  and .

By Propositions~\ref{thm:lts-2-reply-succeed} and~\ref{prop:compat-reflexive},
 is successful after  reduction steps, where .
It follows by barbed congruence that  is successful after  reduction steps too;
Proposition~\ref{thm:lts-2-succeed-reply} then implies that 
for some  and  such that .

By two applications of Proposition~\ref{thm:lts-2-reply-succeed} it follows that
, for , and
.
Notice that, by Proposition~\ref{prop:reply-context-minimum} and definition of the reply context, 
these are the only possibilities that yield a success barb in  reductions.
Furthermore, reduction closure of  and Lemma~\ref{lem:succ-beq} imply that .
By Lemma~\ref{lem:bcon-sub}, we obtain .
By Lemma~\ref{lem:compat-compose-subs},  
implies . This suffices to conclude.
\end{proof}

To conclude, we want to stress that we have developed our semantic theories
in the {\em strong} setting just for the sake of simplicity. Their {\em weak} counterparts,
consisting of allowing multiple s/reductions in every predicate, can be obtained
in the usual manner \cite{milner.parrow.ea:calculus-mobile,milner.sangiorgi:barbed-bisimulation}.
As usual, the main difficulty is in the completeness proof just shown. Indeed, to force a proper
reply via contexts, we need to use ``fresh" barbs (viz, the s and  in our tests). Such barbs 
have to be removed after the forced action; however, this can be done only if the left and right
hand side of the equated processes have the same shape (see Lemma~\ref{lem:succ-beq}).
This is straightforward in the strong case, where the number of reductions (viz,  --
see Propositions~\ref{thm:lts-2-reply-succeed} and~\ref{thm:lts-2-succeed-reply}) ensures this property. 
By contrast, in the weak case we can stop along this sequence of  reductions, since the
weak barbs will cover the missing steps. This requires a different proof of Lemma~\ref{lem:succ-beq}.
To achieve this, we can follow the traditional path: instead of having a single success barb ,
our tests have two (say,  and ) in mutual exclusion (i.e., internal choice); we then 
consider an additional reduction that excludes . This ensures that the other process must also reach
the reduction that excludes  and thus complete the proof.


\subsection{Example Equivalences}
\label{subsec:examples}

This section considers some examples where bisimulation can be used to show the equivalence of processes.
The first example exploits the unification of protected names with both variable and protected names:

It states that the processes  can be subsumed by the more compact process ;
indeed, any interaction of the left hand processes can be properly responded to by the right hand process and vice versa.

The second example considers the contractive nature of binding names in CPC:
a case with the pattern  can be subsumed by a case with the pattern  as long as some conditions are met.
For example:

The side condition requires that the bodies of the cases must be bisimilar under a substitution that preserves the structure of any pattern bound by  in the process .

These examples both arise from pattern unification and also appear in the compatibility relation.
Indeed, the examples above are instances of a general result:

\begin{prop}
\label{eq-grrr}
Let  and .
If there exists  such that  and , 
then .
\end{prop}
\begin{proof}
It suffices to prove that

is a bisimulation. To this aim, consider every challenge from  and show that
there exists a transition from  that is a proper reply (according to the bisimulation). 
The converse (when the challenge comes from ) is easier.

Let ; there are two possibilities for :
\begin{enumerate}
\item : in this case, we also have to fix a substitution  such that
 and . 
There are three possible ways for producing :
	\begin{enumerate}[label={\alph*}]
	\item  and : this case is straightforward.

	\item , where :
	Let  be such that ; by Proposition~\ref{lem:compat-match},
	. But a pattern can unify with itself only if it
    contains no binding names;
    this entails that  and .
	Hence,  and conclude by
	taking , since by hypothesis .

	\item , where  and 
	: by -conversion, now let 
	and . Now consider  with 
	; by Proposition~\ref{lem:compat-match}, the hypothesis
	 entails . 
	Thus, ,
	where the first equality holds because  
	and . Conclude by using the hypothesis ,
	thanks to closure of  under substitutions, parallel and restriction.

	\item , where  and 
	: this case is simple, by considering 
	 and by observing that 
	, with .

	\item , where :
	this case is straightforward, by observing that .
	\end{enumerate}
\end{enumerate}
Closure under substitution is straightforward by Proposition~\ref{prop:compat-sub-closed}.
\end{proof}

To conclude, notice that the more general claim
\begin{quote}
Let  and ; if there are 
and  such that  and
, then 
\end{quote}
does {\em not} hold. To see this, consider the following two processes:

Trivially  and ;
however,  is {\em not} bisimilar to . Indeed, in the context ,
for , they behave differently:  can reduce in one step to a process that is stuck and cannot
exhibit any barb on ; by contrast, every reduct of  reduces in another step to a process that exhibits
a barb on . (As usual, for proving equivalences it is easier to rely on bisimulation, while for proving
inequivalences it is easier to rely on barbed congruence, thanks to Theorems~\ref{thm: sound} and~\ref{thm: complete}.)
Proposition~\ref{eq-grrr} is more demanding: it does not leave us free to choose whatever  we want, but
it forces us working with . Now, the only  such that 
is ; with such a substitution, the second hypothesis of the theorem, in this case , does not hold
and so we cannot conclude that .


\section{Comparison with Other Process Calculi}
\label{sec:compare}

This section exploits the techniques developed in \cite{G:IC08,G:CONCUR08} to formally
assess the expressive power of CPC with respect to -calculus, Linda, Spi calculus, Fusion and Psi calculus.
After briefly recalling these models and some basic material from \cite{G:CONCUR08}, the 
relation to CPC is formalised. First, let each model, including CPC, be augmented with
a reserved process `', used to signal successful termination.
This feature is needed to formulate what a {\em valid} encoding is in Definition~\ref{def:ve}.


\subsection{Some Process Calculi}
\label{subsec:calculi}

\paragraph{-calculus \cite{milner.parrow.ea:calculus-mobile,sangiorgi.walker:theory-mobile}.}
The -calculus processes are given by the following grammar:

and the only reduction axiom is

The reduction relation is obtained by closing this interaction rule by parallel, restriction and the
same structural congruence relation defined for CPC.

\paragraph{Linda \cite{Gel85}.} Consider the following variant of Linda formulated to follow 
CPC's syntax. Processes are defined as:

where  ranges over names and  denotes a template field, defined by:

Assume that input variables occurring in templates are all distinct.
This assumption rules out template , but accepts .  Templates are used to implement Linda's pattern
matching, defined as follows:

where
`' denotes the union of partial functions with disjoint domains. The interaction axiom is:

The reduction relation is obtained by closing this interaction rule by parallel, restriction and the
same structural congruence relation defined for CPC.


\paragraph{Spi calculus \cite{gordon1997ccp}.} This language is unusual as names 
are now generalised to {\em terms} of the form

\change{Thomas}
{They are rather similar to the patterns of CPC in that they may have
internal structure. Of
particular interest is the pair, that combines terms and allows the
construction of arbitrary structured data,
and the encryption construct.
Pairing is distinct from the polyadic data exchange
discussed previously, as compound messages may be bound to a single name
and then
decomposed later by some intensional reduction. Similarly, the encryption 
requires they key to be known to gain access to the encrypted term.}
{They are rather similar to the patterns of CPC in that they may have internal
structure. Of particular interest are the pair, successor and encryption that
may be bound to a name and then decomposed later by an intensional reduction.
Note that  denotes a natural number greater than zero, and is considered
equal to the th successor of zero.}

The processes of the Spi calculus are:

The null process, parallel composition, replication and restriction
are all familiar.
The input  and output  are generalised 
from -calculus to 
allow arbitrary terms in the place of channel names and output arguments.
The match  determines equality of  and .
The splitting  decomposes pairs.
The decryption  decrypts  
and binds the encrypted message to .
The integer test  branches
according to the number.
\change{Thomas}
{The last four can all get stuck if  is an incompatible term.}
{Note that the last four processes can all get stuck if  is an incompatible term.
Furthermore, the last three are intensional, i.e.\ they depend on the internal
structure of .}

Concerning the operational semantics, we
consider a slightly modified version of Spi calculus where
interaction is generalised to

where  is any term of the Spi calculus. The remaining axioms are:

Again, the reduction relation is obtained by closing the interaction axiom
under parallel, restriction and the structural congruence of CPC. 


\paragraph{Fusion \cite{parrow.victor:fusion-calculus}.}
Processes are defined as:

The interaction rule for Fusion is taken from \cite{WG:explicit-fusions}:

where  is the least equivalence relation on names
generated by the equalities  (that is defined 
whenever ).
Fusion's reduction relation is obtained by closing the interaction axiom
under parallel, restriction and the structural congruence of CPC.

\newcommand{\cheq}{\stackrel\cdot\leftrightarrow}
\newcommand{\terms}{{\bf T}}
\newcommand{\assertion}{{\bf A}}
\newcommand{\one}{{\bf 1}}
\newcommand{\compose}{\otimes}
\newcommand{\assert}[1]{\llparenthesis \, #1 \, \rrparenthesis}
\newcommand{\fram}[1]{{\cal F}(#1)}

\paragraph{Psi \cite{BJPV11}.}
For our purposes, Psi-calculi are parametrized w.r.t. two sets: terms ,
ranged over by , and assertions , ranged over by .
The empty assertion is written .
We also assume two operators: channel equivalence, ,
and assertion composition, . 
It is also required that  is transitive and
symmetric, and that  is a commutative monoid.

Processes in Psi are defined as:

We now give a reduction semantics, by isolating the  actions of the
LTS given in \cite{BJPV11}. To this aim, we recall the definiton of frame
of a process , written , as the set of unguarded assertions 
occurring in . Formally:

and is  in all other cases. We denote as  the frame of .
The structural laws are the same as in -calculus.
The reduction relation is inferred by the following laws:

We write  whenever .


\subsection{Valid Encodings and their Properties}

This section recalls and adapts the definition of valid encodings as well as some
useful theorems (details in \cite{G:CONCUR08}) for formally relating process calculi.
The validity of such criteria in developing expressiveness studies emerges from the
various works 
\cite{G:IC08,G:DC10,G:CONCUR08}, that have also recently inspired similar works 
\cite{LPSS10,LVF10,gla12}. 

An {\em encoding} of a language  into another language  is a pair 
where  translates every -process into an -process
and  maps every name (of the source language) into a tuple of  names (of the target language), for .
The translation  turns every term of the source language into a term of the target; in doing this,
the translation may fix some names to play a precise r\^ole 
or may translate a single name into a tuple of names. This can be obtained
by exploiting . 

Now consider only encodings that satisfy the following properties.
Let a {\em -ary
context}  be a term where 
occurrences of  are linearly replaced by the holes  (every one of the  holes must occur once and only once).
Moreover, denote with  and  
the relations  and  in language ;
denote with  an infinite sequence of reductions in .
Moreover, we let  denote the reference behavioural equivalence for language .
Also, let  mean that there exists  such that  and ,
for some .
Finally, to simplify reading, let  range
over processes of the source language (viz., ) and  range
over processes of the target language (viz., ).

\begin{defi}[Valid Encoding]
\label{def:ve}
An encoding  of  into 
is {\em valid} if it satisfies the following five properties:
\begin{enumerate}
\item {\em Compositionality:} for every -ary operator  of 
and for every subset of names ,
there exists a -ary context  of 
such that, for all  with , it holds
that .

\item {\em Name invariance:}
for every  and name substitution , it holds that

where  is such that 

for every name .

\item {\em Operational correspondence:}
\begin{itemize}
\item for all , it holds that ;
\item for all , there exists  such that  
and .
\end{itemize}

\item {\em Divergence reflection:}
for every  such that 
, it holds that 
\linebreak  \mbox{}.

\item {\em Success sensitiveness:}
for every , it holds that  if and only if .
\end{enumerate}
\end{defi}

The criteria we have just presented may seem quite demanding; for example,
they do not allow schemes including parameters that are changed along the 
way of the encoding (the most notable of such examples is Milner's encoding
of -calculus into -calculus \cite{Milner92}). Of course, this
makes our separation results slightly weaker and leaves room for further
improvement. Moreover, as fully explained in \cite{GN:MSCS14}, we do not 
consider full abstraction as a validity criterion for expressiveness.

Now recall some results concerning valid encodings, in particular for showing
separation results, i.e.\ for proving that no valid encoding can exist between
a pair of languages  and  satisfying certain
conditions.
Here, these languages will be limited to CPC and those introduced in Section~\ref{subsec:calculi}.
Originally valid encodings considered were assumed to be {\em semi-homomorphic}, 
i.e.\ where the interpretation of parallel
  composition is via a context of the form , for some  and  that only depend on the
  free names of the translated processes.
This assumption simplified the proofs of the following results in general, i.e.\ without
relying on any specific process calculus; in our setting, since the languages are fixed,
we can prove the same results without assuming semi-homomorphism.


\change{barry}{It is worth remarking that, since the calculi considered here have been already defined
(see Section~\ref{subsec:calculi}), we do not need any assumption on the context used
to translate the parallel operator. In \cite{G:CONCUR08} we needed to explicitly
assume that such an operator is translated ``semi"-homomorphically, i.e.\ via a context
of the form , for some  and  that only 
depend on the free names of the translated processes. ``Semi"-homomorphism comes for free
by Proposition~\ref{deadlock} and by the kind of interactions that can occur in our sample 
process calculi.}{}

\comments{barry}{The limitation to semi-homomorphisms that was
  implicit in [9] is here made explicit. It is worth remarking that
  the limitation to the given set of languages does not remove the
  need for this assumption in the given proofs, even though it kills
  of one particular counter-example. }

\begin{thm}
\label{autoriduz}
Assume that there exists  such that  and
 and ; 
moreover, assume that every 
that does not reduce is such that . Then, 
there cannot exist any 
valid encoding of  into .
\end{thm}

To state the following proof technique, define the {\em matching degree} 
of a language , written , as the least upper bound on the number 
of names that must be matched to yield a reduction in . For example,
, since the only name matched for performing
a reduction is the name of the channel where the communication happens,
whereas , since there is no upper bound
on the number of names that can be matched in a reduction.

\begin{thm}
\label{match}
If , then there exists no 
valid encoding of  into .
\end{thm}

The previous proof techniques can be directly used in some cases: for example,
we shall prove that CPC cannot be encoded in any other sample calculus by exploiting
Theorem~\ref{autoriduz}. However, not all separation results can be obtained as 
corollaries of such results. The following technique provides a very useful tool when
the theorems above cannot be applied.

\begin{prop}
\label{deadlock}
Let  be a valid encoding; then, 
implies that .
\end{prop}

The way in which we shall use this technique is the following. To prove that 
 cannot be encoded into  we reason by contradiction and assume a
valid encoding . Then, we pick an -process  that reduces;
we first show that this implies that  also reduces. We then analyze how
the latter reduction may have happened and, for every possible case, show a process
 obtained from  (usually, by just swapping two names) such that 
reduces whereas  does not. This contradicts Proposition~\ref{deadlock}
and allows us to conclude that no valid encoding exists.


\subsection{CPC vs -calculus and Linda}
\label{subsec:pi-linda}

A hierarchy of sets of process calculi with different communication primitives is
obtained in \cite{G:IC08} via combining four features: 
synchronism (synchronous vs asynchronous), 
arity (monadic vs polyadic data exchange), 
communication medium (channels vs shared dataspaces), 
and the presence of a form of pattern matching (that checks the arity of the 
tuple of names and equality of some specific names).
This hierarchy is built upon a very similar notion of encoding to that presented
in Definition~\ref{def:ve} and, in particular, it is proved that Linda \cite{Gel85} (called  in \cite{G:IC08}) is more expressive than
monadic/polyadic -calculus \cite{milner.parrow.ea:calculus-mobile,milner:polyadic-tutorial} (called  and , respectively, in \cite{G:IC08}).

As Linda is more expressive than -calculus, it is sufficient to show that CPC is more expressive than Linda.
However, apart from being a corollary of such a result, the lack of a valid encoding of CPC into -calculus can also be shown by exploiting the matching degree, i.e.\ Theorem~\ref{match}: the matching degree of -calculus is one, while the matching degree of CPC is infinite.

\begin{thm}
\label{noCPCinLinda-1}
There is no valid encoding of CPC into Linda.
\end{thm}
\begin{proof}
The self-matching CPC process  is such that  and , however  and . Every Linda process  such that  can reduce in isolation, i.e.\ : this fact can be proved by induction on the structure of . Conclude by Theorem~\ref{autoriduz}.
\end{proof}

The next step is to show a valid encoding of Linda into CPC.
The encoding  is homomorphic with
respect to all operators except for input and output which are encoded as follows:

The functions  and  are used to translate templates and data, respectively, 
into CPC patterns. The functions are defined as follows:

where  is any name (a symbolic name is used for clarity but no result relies upon this choice).
Moreover, the function  associates a bound variable to 
every name in the sequence; this fact ensures that 
a pattern that translates a datum and a pattern that translates 
a template match only if they have the same length (this is a feature
of Linda's pattern matching but not of CPC's unification).
It is worth noting that the simpler translation

would not work: the Linda process 
does not reduce, whereas its encoding would, in contradiction with Proposition~\ref{deadlock}.

Next is  to prove that this encoding is valid. 
This is a corollary of the following lemma, stating a strict 
correspondence between Linda's pattern matching and CPC's unification
(on patterns arising from the translation).

\begin{lem}
\label{lem:twomatchs}
 if and only if 

where  and
 
and  maps names to names. 
\end{lem}
\proof
In both directions the proof is by induction on the length of .
The forward direction is as follows.
\begin{itemize}
	\item The base case is when  is the empty sequence of template fields;
				thus, .
				By definition of , it must be that  is the empty sequence
				and that  is the empty substitution.
				Thus,  and the thesis follows.
	\item For the inductive step  and .
				By definition of , it must be that  and  and
				 and .
				By the induction hypothesis, ,
				where 
				and .
				There are now two sub-cases to consider according to the kind of template field .
				\begin{itemize}
					\item If  then ; therefore,
								 as well as
								.
					\item If  then  and .
								Thus,  is a pattern in CPC and it follows that
								.
				\end{itemize}
\end{itemize}
The reverse direction is as follows.
\begin{itemize}
	\item The base case is when  is the empty sequence of template fields;
				thus, .
				Now proceed by contradiction.
				Assume that  is not the empty sequence.
				In this case, ,
				for some .
				By definition of pattern unification in CPC,  and  cannot unify,
				and this would contradict the hypothesis. Thus, it must be that  is the empty sequence
				and we conclude.
	\item The inductive case is when  and thus,
				.
				If  was the empty sequence, then
				 and it would not unify with .
 				Hence,  and so
 				.
 				By definition of pattern-unification in CPC it follows that
 				 and
					and .
				Now consider the two sub-cases according to the kind of the template field .
				\begin{itemize}
					\item If  then  and so .
								By induction hypothesis, ,
								and so .
					\item If  then  and
								 for 
								and .
								Thus,  and so .
								By the induction hypothesis, ;
								moreover, .
								Thus, .\qed
				\end{itemize}
\end{itemize}



\begin{lem}
\label{lem:structenc-linda}
If  then .
Conversely, if  then , for some .
\end{lem}
\begin{proof}
Straightforward, from the fact that  acts only on operators that  translates homomorphically.
\end{proof}

\begin{thm}
\label{thm:opcorr}
The translation  from Linda into CPC preserves and reflects reductions.
That is:
\begin{itemize}
	\item If  then ;
	\item if  then  for some  such that .
\end{itemize}
\end{thm}
\begin{proof}
Both parts can be proved by a straightforward induction
on judgements  and , respectively.
In both cases, the base step is the most interesting one and
follows from Lemma~\ref{lem:twomatchs}; the inductive
cases where the last rule used is the structural one rely on
Lemma~\ref{lem:structenc-linda}.
\end{proof}

\begin{cor}
\label{cor:valid-linda}
The encoding of Linda into CPC is valid.
\end{cor}
\begin{proof}
Compositionality and name invariance hold by construction. 
Operational correspondence and divergence reflection
follow from Theorem~\ref{thm:opcorr}. Success sensitiveness
can be proved as follows:  means that there exist 
and  such that ; 
by exploiting Theorem~\ref{thm:opcorr}  times 
and Lemma~\ref{lem:structenc-linda}, we obtain that , i.e.\ that .
The converse implication can be proved similarly. 
\end{proof}



\subsection{CPC vs Spi}
\label{subsec:spi-new}
CPC cannot be encoded into Spi calculus, as a corollary of Theorem~\ref{autoriduz}.
This can be proved as in Theorem~\ref{noCPCinLinda-1}: the self-unifyinging CPC
process  cannot be properly rendered in Spi.

The remainder of this section develops an encoding of Spi calculus into CPC.
The terms can be encoded as patterns using the reserved
names {\sf pair}, {\sf encr}, , {\sf suc}, and the natural numbers  ranged over by  with

where  denotes {\sf suc} compounded  times with .
The tagging is used for safety, as otherwise there are potential
pathologies in the translation: for example,
without tags, the representation of an encrypted term could be confused
with a pair.

The encoding of the familiar process forms are homomorphic as expected. The input and output
both encode as cases:

The symbolic name  (input) and fresh name  (output) are used to
ensure that encoded inputs will only unify with encoded outputs as for Linda.

The four remaining process forms all require pattern unification and so
translate to cases in parallel. In each encoding a fresh name  is
used to prevent interaction with other processes, see
Proposition~\ref{prop:free_n_match_proc}. As in the Spi calculus,
the encodings will reduce only after a successful unification and will be
stuck otherwise. The encodings are

The unification  only reduces to  if , thus the
encoding creates two patterns using  and  with one reducing to .  The encoding of pair splitting  
creates a case with a pattern that unifies with a tagged pair and binds the
components to  and  in . This is put in parallel with
another case that has  in the pattern. The encoding of a decryption  checks
whether  is encoded with key  and
retrieves the value encrypted by binding it to  in the continuation.
Lastly the encoding of an integer test  creates a case for each of the zero and the
successor possibilities. These cases unify the tag and the reserved
names , reducing to , or  and binding  in
. The term to be compared  is as in the other cases.

Let us now prove validity of this encoding.

\begin{lem}
\label{lem:structenc-spi}
If  then .
Conversely, if  then , for some .
\end{lem}
\begin{proof}
Straightforward, from the fact that  acts only on operators that  translates homomorphically.
\end{proof}

\begin{thm}
\label{spi2cpc-red}
The translation  from Spi calculus into CPC preserves and reflects reductions, up-to CPC's barbed
congruence. That is:
\begin{itemize}
	\item If  then ;
	\item if  then  for some  such that .
\end{itemize}
\end{thm}
\proof
The first claim can be proved by a straightforward induction
on judgement . The base case is proved by reasoning on the Spi axiom used to infer the reduction.
Although all the cases are straightforward, a reduction rule for integers is shown for illustration.
Consider the reduction for a successor as the reduction for zero is simpler.
In this case, 
and . Then, 

and it can only reduce to

A straightforward induction on the structure of  proves
. Thus,
,
where the last equivalence follows from Proposition~\ref{prop:free_n_match_proc}.
The inductive case is straightforward, with the structural case relying on Lemma~\ref{lem:structenc-spi}.

The second part can be proved by induction on judgement .
There is just one base case, i.e.\ when  and
 and .
By definition of the encoding, it can only be that
 and  and
 and 
for some , ,  and . This means that 
and that .
To conclude, it suffices to take .
For the inductive case there are two possibilities.
\begin{itemize}
	\item The inference of  ends with an application of the rule for
				parallel composition or for structural congruence: this case can be proved by a
				straightforward induction.
	\item The inference of  ends with an application of the rule for restriction;
				thus, , with  and .
				If , for some , apply a straightforward induction.
				Otherwise, there are the following four possibilities.
				\begin{itemize}
					\item 
								and, hence, . By definition of the encoding, 
								. Notice that the reduction  can happen only if
								 and  unify; by construction of the encoding of Spi-terms,
								this can happen only if  and, hence, .
								The thesis follows by letting , since  is a fresh name and so
								.
					\item 
								and, hence, . 
								This case is similar to the previous one, by letting  be
								.
					\item 
								and, hence, .
								This case is similar to the previous one, by letting  be
								.
					\item .
								Hence, .
								According to the kind of , there are two sub-cases
								(notice that, since , no other possibility is allowed for ).
								\begin{itemize}
									\item : in this case, 
												and so .
												In this case,  and so ; to conclude,
												it suffices to let  be .
									\item , for some :
												in this case, 
												and so .
												In this case,  and so ; to conclude, 
												it suffices to let  be .\qed
								\end{itemize}
				\end{itemize}
\end{itemize}

\begin{cor}
\label{cor:valid-spi}
The encoding of Spi calculus into CPC is valid.
\end{cor}
\begin{proof}
See the proof for Corollary~\ref{cor:valid-linda}. 
\end{proof}

Notice that the criteria for a valid encoding do not imply full
abstraction of the encoding (actually, they were defined as an alternative to full abstraction
\cite{G:IC08,G:CONCUR08}). This means that the encoding of equivalent
Spi calculus processes can be distinguished by contexts in CPC that do not result from the
encoding of any Spi calculus context. Indeed, while this encoding allows Spi calculus to be modelled in
CPC, it does {\em not} entail that cryptography can be properly rendered.
Consider the pattern  that could unify with the encoding of an encrypted term
to bind the message and key, so that CPC can break any encryption!
Indeed this is an artefact of the straightforward approach to encoding taken here.
Some discussion of alternative approaches to encryption in CPC are detailed in 
\cite{GivenWilsonPHD}.


\subsection{CPC vs Fusion}

The separation results for CPC and the other process calculi presented so far have all been proved via symmetry;
thus, the relationship between Fusion and CPC is of particular interest.
Such calculi are {\em unrelated}, in the sense that there exists no valid
encoding from one into the other. The impossibility for a valid
encoding of CPC into Fusion can be proved in two ways, by exploiting either the matching degree or the symmetry of CPC.

\begin{thm}
\label{thm:nocpc2fusion-1}
There is no valid encoding of CPC into Fusion.
\end{thm}
\begin{proof}
The matching degree of Fusion is 1 while the matching degree of CPC is infinite;
conclude by Theorem~\ref{match}.
Alternatively, reuse the proof for Theorem~\ref{noCPCinLinda-1} as every Fusion process 
 is such that  implies .
\end{proof}

The converse separation result is ensured by the following theorem.

\begin{thm}
\label{thm:fusionNoinCPC}
There exists no valid encoding of Fusion into CPC.
\end{thm}
\proof
By contradiction, assume that there exists a valid encoding 
of Fusion into CPC.
Consider the Fusion process ,
for ,  and  pairwise distinct. By success sensitiveness, 
entails that . 

We first show that  must reduce before reporting success,
i.e.\ every occurrence of  in  falls underneath
some prefix.  By compositionality, .  If  had a top-level unguarded occurrence
of , then such an occurrence could be in , in , in
 or in ; in any case, it
would also follow that at least one of:

that has  replaced with ;
or

that has  replaced with ,
would report success, 
whereas both
Equation~\ref{eq:fus:ex1}
and
Equation~\ref{eq:fus:ex2},
against success sensitiveness of .
Thus, the only possibility for  to report success is
to perform some reduction steps (at least one) and then exhibit
a top-level unguarded occurrence of .

We now prove that every possible reduction leads to contradiction of the validity of ;
this suffices to conclude. There are five possibilities for .
\begin{enumerate}
	\item Either , or
				, or 
				 or . In any
				of these cases, at least one out of 
				 or
				 would reduce;
				however,  and
				, 
				against Proposition~\ref{deadlock} (that must hold whenever 
				is valid).

	\item Reduction is generated by interaction between
				 and
				.  Then, as before, 
				
				whereas , 
				against Proposition~\ref{deadlock}.

	\item Reduction is generated by interaction between
				 and , for
				. Like case 2.

	\item Reduction is generated by interaction between
				 and , for
				. As before it follows that
				
				whereas , 
				against Proposition~\ref{deadlock}.

	\item The reduction is generated by an interaction between the processes
				 and . In this
				case, it follows that 
				whereas : indeed, the interaction
				rule of Fusion imposes that at least one between  and  must
				be restricted to yield the interaction.\qed
\end{enumerate}

\subsection{CPC vs Psi}

CPC and Psi are {\em unrelated}, in the sense that there exists no valid
encoding from one into the other. As in Theorem~\ref{noCPCinLinda-1}, 
the impossibility for a valid
encoding of CPC into Psi can be proved by exploiting 
the symmetry of CPC.
The converse separation result is ensured by the following theorem.

\begin{thm}
\label{thm:psiNoinCPC}
There exists no valid encoding of Psi into CPC.
\end{thm}
\proof
Assume that there exists a valid encoding 
of Psi into CPC. Consider the Psi process 
,
where we have omitted the argument of the actions to simplify the proofs,
and chosen ,  and  pairwise distinct; also consider the reduction

Therefore,  and, by success sensitiveness, . 
Hence, by compositionality, .
Like in the proof of Theorem~\ref{thm:fusionNoinCPC}, it can be proven that the only possibility 
for  to report success is to perform some reduction steps (at least one) and then exhibit
a top-level unguarded occurrence of .

We now prove that every possible reduction leads to contradiction of the validity of ;
this suffices to conclude. Of course, none of , 
and  can reduce, because ,  and 
do not reduce. Thus, there are seven possibilities for .
\begin{enumerate}
	\item Either  or the reduction is obtained by synchronizing
	the two copies of . In both cases, 
    (with  replaced by )
	would also reduce, whereas , 
	against Proposition~\ref{deadlock} (that must hold whenever  is valid).

	\item The reduction is obtained by synchronizing 
	with (one of the two copies of) . In this case, 
	also 
    (with  replaced by )
	would reduce, whereas .

	\item The reduction is obtained by synchronizing 
	with (one of the two copies of) . This case is
	proved impossible like case 1 above.

	\item The reduction is obtained by synchronizing 
	with (one of the two copies of) . This case is
	proved impossible like cases 1 and 2 above.

	\item The reduction is obtained by synchronizing 
	with . In this case, 
	also 
	would reduce, whereas .

	\item The reduction is obtained by synchronizing 
	with . This case is
	proved impossible like case 2 above.

	\item The reduction is obtained by synchronizing 
	with . This case is
	proved impossible like case 1 above.\qed
\end{enumerate}


\section{Conclusions} \label{sec:conclusions}

Concurrent pattern calculus uses patterns to represent input,
output and tests for equality, whose interaction is driven by
unification that allows a two-way flow of information.  This symmetric
information exchange provides a concise model of trade in the
information age.  This is illustrated by the example of traders who
can discover each other in the open and then close the deal
in private.

As patterns drive interaction in CPC, 
their properties heavily influence CPC's behaviour theory. As pattern
unification may match any number of names these must all be accounted
for in the definition of barbs. More delicately, some patterns are
compatible with others, in that their unifications yield similar results.
The resulting  bisimulation requires that the transitions be compatible
patterns rather than exact.
Further, the pattern-matching bisimulation developed for CPC can easily account
for other kinds of pattern-matching, such as in polyadic -calculus and
Linda \cite{GivenWilsonGorla13}.

CPC supports valid encodings of many popular concurrent calculi such
as -calculus, Spi calculus and Linda as its patterns describe
more structures. However, these three calculi do not support valid
encodings of CPC because, among other things, they are insufficiently
symmetric. On the other hand, while fusion calculus is completely
symmetric, it has an incompatible approach to interaction.
Similarly, Psi calculus is unrelated to CPC due to supporting implicit
computations, while also being less symmetric.


Another path of development for a process calculus is implementation in a
programming language \cite{Pierce97pict:a,Klava,cpplinda,20110201:jocaml}.
The \bondi\ programming language is based upon pattern matching as the core
of reduction and the theory of pattern calculus \cite{pcb,bondi}. A
\cbondi\ has also been developed that extends \bondi\ with concurrency
and interaction based on the pattern unification and theory of CPC
\cite{GivenWilsonPHD,cbondi}.

\bigskip
\noindent{\bf Acknowledgments } We would like to thank the anonymous reviewers for their
fruitful comments and for their constructive attitude towards our paper.

\section*{Appendix A: Proofs of Section~\ref{sec:LTS}}

\paragraph{Proof of Proposition~\ref{prop:imfin}}
First of all, let us define an alternative (but equivalent, up-to ) LTS
for CPC, written : it is obtained by replacing {\sf rep} with the 
following two rules (all the other rules are the same, with  in place
of  everywhere):

We can prove that: (1) if  then ; and (2)
if  then , for some 
(both proofs are done by a straightforward induction on the derivation of
the premise, whose only interesting case is when , for some ).

Now define the following measure associated to a process:

By induction on the structure of , we can prove that .
By exploiting this fact and (2) above, it follows that there are finitely many (up-to )
 such that .
\qed



\paragraph{Proof of Lemma~\ref{lem:lts-exhibit-p}}
The proof is by induction on the inference for .
The base case is when the last rule is {\sf case}, with ;
conclude by taking  and  and .
For the inductive step, consider the last rule in the inference.
\begin{itemize}
	\item If the last rule is {\sf resnon} then , where
				 and .
				By induction, there exist  and  and  such that 
				 and
				 and 
				 and .
				As  and by -conversion ,
				conclude with  and  and .
	\item If the last rule is {\sf open} then , where
				 and 
				
				and .
				By induction, there exist  and  and  such that 
				 and
				 and
				 and
				.
				Conclude with  and  and .
	\item If the last rule is {\sf parext} then , 
				where 
				and .
				By induction, there exist  and  and  such that 
				 and 
				 and
				 and .
				As , we can
				conclude with  and  and .
	\item If the last rule is {\sf rep} then , 
				where . We conclude by induction
				and by the fact that .
\qed
\end{itemize}

\paragraph{Proof of Proposition~\ref{prop:tau-red}}
The first claim is proved by induction on the inference for .
The base case is with rule {\sf unify}: , where
 and  and 
 and
 and 

and . By Lemma~\ref{lem:lts-exhibit-p}, it follows that 
 and
, with 
and ; similarly, 
 and , 
with 
and .
By exploiting -conversion on the names in  and , we have 
;
thus, .
Since  avoids  ,  and
 avoids ,  and
, conclude 
.

For the inductive step, reason on the last rule used in the inference.
\begin{itemize}
	\item If the last rule is {\sf parint} then ,
				for  and .
				Apply induction to the transition  to obtain that ;
				thus, .
	\item If the last rule is {\sf resnon} then , for  and .
				Again, conclude by induction.
	\item If the last rule is {\sf rep} then , for .
				By induction,  and conclude, since .
\end{itemize}

\medskip\noindent
The second claim is by induction on the inference for .
The base case is when  and ,
for . By the {\sf unify} rule in the LTS
        
and the result is immediate.
For the inductive step, reason on the last rule used in the inference.
\begin{itemize}
	\item If , where  and ,
		then use the induction and exploit the {\sf parint} rule.
	\item If , where  and ,
		then use the induction and exploit the {\sf resnon} rule.
	\item Otherwise, it must be that . 
		By induction,  for some .
		We now have to prove that structurally equivalent processes have
		the same -transitions, up-to ; this is done via
		a second induction, on the inference of the judgement .
		The following are two representative base cases; the other base cases are easier,
		as is the inductive case.
		\begin{itemize}
		\item : since , for ,
			we can use rule {\sf rep} of the LTS and obtain ; 
			we can conclude, since .
		\item , that holds since
			: by the first inductive hypothesis, 
			, for . Moreover, by definition
			of the LTS, the last rule used in this inference must be {\sf resnon}; thus, 
			 and . There are three possible
			ways to generate the latter -transition:
			\begin{itemize}
			\item  and : in this case
			
			and conclude by noticing that .
		\item  and : this case is similar to the previous one, but simpler.
		\item  and , and , where ,
			 and :
			this case is similar to the base case of the first claim of this Proposition and, essentially, relies
			on Lemma~\ref{lem:lts-exhibit-p}. The details are left to the interested reader.
\qed
			\end{itemize}
		\end{itemize}
\end{itemize}


\section*{Appendix B: Proofs of Section~\ref{sec:sound}}

\paragraph{Proof of Lemma~\ref{lem:bisim-case}}
It is necessary to prove that the relation

is a bisimulation. The only possible challenge of  is
 such that ;
moreover, fix any  such that .
The only possible reply from  is , that is
a valid reply (in the sense of Definition~\ref {def:bisim}). Indeed,
, by Proposition~\ref{prop:compat-reflexive},
and , because  and 
 is closed under substitutions by definition.
Closure under substitution holds by definition of .
\qed

\paragraph{Proof of Lemmata~\ref{lem:bisim-nu} and~\ref{lem:bisim-par}}
The two lemmata have to be proved together; as in -calculus, this is necessary because of name extrusion.
We can conclude if we show that the relation

is a bisimulation.
Fix any transition  that,
by definition of the LTS, has been inferred as follows:

where  and  and
the dots denote repeated applications of {\sf resnon} (one for every name in ) 
and {\sf open} (one for every name in ).

If , then ; moreover,  can
be generated in three ways:
\begin{itemize}
\item If the transition is
	
	then because of  there exists 
        such that ; hence conclude with
	.
\item If the transition is
	
	consider  and conclude.
\item If the transition is
	
	with  and
	.
	Now, there exist  and  such that  and
	 and .
	By Proposition~\ref{lem:pat-lessthan}, 
	and so
	
	where, by -conversion, we can always let 
	(the other side conditions for applying rule {\sf unify} already hold).
	By repeated applications of rule {\sf resnon}, infer 
	
	and conclude.
\end{itemize}

\noindent If , it must be that .
Then, fix any  such that  and .
The transition  can be now generated in two ways:
\begin{itemize}
\item The transition is
	
	By  there exist  and  such that  and
	 and . By -equivalence,
	let ; thus, .
	By applying the same sequence of rules {\sf resnon} and {\sf open} used for 
	(this is possible since , see Lemma~\ref{prop:compat-fn}), 
	conclude with .
	Since  and
	substitution application is capture-avoiding by definition, obtain that .
	Similarly, .
	This suffices to conclude , as desired.
\item The transition is
	
	By -equivalence, let ;
	this allows us to infer . The same sequence of
	rules {\sf resnon} and {\sf open} used for , yields
	.
	By Proposition~\ref{prop:compat-reflexive}, . Moreover, 
	since  and
	substitution application is capture-avoiding, obtain that  and
	.
	This suffices to conclude , as desired.
\end{itemize}
Closure under substitution holds by definition of .
\qed

\paragraph{Proof of Lemma~\ref{lem:bisim-rep}}
This proof rephrases the similar one in \cite{sangiorgi.walker:theory-mobile}. 
First, define the -th approximation of the bisimulation:

Trivially, .

We now prove that, since the LTS is structurally image finite (see Proposition~\ref{prop:imfin}),
it follows that

One inclusion is trivial: by induction on , it can be proved that  for every ,
and so .
For the converse, fix  and consider the case for , since
the case for  can be proved like in -calculus. For every , since , 
there exist  and  such that  and 
and . However, by Proposition~\ref{prop:maximal}, 
there are finitely many (up-to -equivalence) such 's; thus, there must exist
(at least) one  that leads to infinitely many 's that, because of Proposition~\ref{prop:imfin},
cannot be all different (up-to ). Fix one of such 's; there must exist (at least) one  
such that  and there are infinitely many 's such that 
 and . Fix one of such 's. It suffices to prove that
, for every . This fact trivially holds whenever :
in this case, we have that . So, let . If ,
conclude, since  is closed under substitutions (notice that  since
) and , for every . 
Otherwise, there must exist  such that  
(otherwise there would not be infinitely many 's structurally equivalent to ): 
thus,  that implies , since .

\medskip

Thus,  if and only if , for all .
Let  denote the parallel composition of  copies of the process  (and similarly for ).
Now, it can be proved that

The proof is by induction on  and exploits a Lemma similar to Lemma~\ref{lem:bisim-par} (with  in
place of ); the details are left to the interested reader.
By repeatedly exploiting Lemma~\ref{lem:bisim-par}, it follows that 
and so by \eqref{eq:appr}

Now by \eqref{eq:PQ} it follows that  implies that , for all .
By \eqref{eq:n} and Lemma~\ref{lem:trans-bisim} (that also holds with  in place of ),
it follows that , for all .
By \eqref{eq:appr}, conclude that .
\qed



\bibliographystyle{abbrv}
\bibliography{main}

\end{document}
