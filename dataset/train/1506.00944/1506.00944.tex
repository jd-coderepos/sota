\documentclass[12pt]{article}
\usepackage{amsmath,amsfonts}
\usepackage{mathrsfs}
\usepackage{graphicx}

\title{Parameterized mixed cluster editing via modular decomposition\footnote{This work has been partially supported by the
 Conselho Nacional de Desenvolvimento Cient\'{\i}fico e Tecnol\'{o}gico (CNPq), Funda\c c\~ao de Amparo \`a Pesquisa do
 Estado do Rio de Janeiro (FAPERJ) and Coordena\c c\~ao de Aperfei\c coamento do Pessoal de Ensino Superior (CAPES),
 Brazilian research agencies.}}

\author{Maise Dantas da Silva\footnote{P\'{o}lo Universit\'{a}rio de Rio das Ostras, Universidade Federal Fluminense, RJ, Brazil.
E-mail: {\tt maise@vm.uff.br}} \and F\'abio Protti\footnote{Instituto de Computa\c c\~ao, Universidade Federal Fluminense, Rua Passo da P\'{a}tria 156, 24210-240, Niter\'oi,
RJ, Brazil. E-mail: {\tt fabio@ic.uff.br}} \and  Jayme Luiz
Szwarcfiter\footnote{Instituto de Matem\'atica, N\'ucleo de
Computa\c c\~ao Eletr\^onica, and COPPE-Sistemas, Universidade
Federal do Rio de Janeiro, Caixa Postal 68511, 21945-970, Rio de
Janeiro, RJ, Brazil. E-mail: {\tt jayme@nce.ufrj.br}}}

\def\qed{ \fbox \par \medskip }

\def\qed2{ \hfill \framebox[.09in] \par \bigskip }

\def\M{{\cal M}}
\def\L{{\cal L}}
\def\KL{{\cal K}_{\ell}}

\parindent=0cm
\parskip=12pt
\textwidth=16cm
\textheight=21cm
\oddsidemargin=0cm

\begin{document}

\newtheorem{teo}{Theorem}\newtheorem{lema}[teo]{Lemma}
\newtheorem{cor}[teo]{Corollary}
\newtheorem{prop}[teo]{Proposition}
\newtheorem{obs}[teo]{Remark}
\newtheorem{defin}[teo]{Definition}


\maketitle

\begin{abstract}

In this paper we introduce a natural generalization of the well-known problems {\sc Cluster Editing} and {\sc Bicluster Editing}, whose parameterized versions have been intensively investigated in the recent literature. The generalized problem, called {\sc Mixed Cluster Editing} or {\sc -Cluster Editing}, is formulated as follows. Let  be a family of graphs. Given a graph  and a nonnegative integer , transform , through a sequence of at most  edge editions, into a target graph  with the following property:  is a vertex-disjoint union of graphs  such that every  is a member of . The graph  is called a {\em mixed cluster graph} or {\em -cluster graph}. Let  denote the family of complete graphs,  the family of complete -partite graphs (), and
. In this work we focus on the case . Using modular decomposition techniques previously applied to {\sc Cluster/Bicluster Editing}, we present a linear-time algorithm to construct a problem kernel for the parameterized version of {\sc -Cluster Editing}.\\ \\
\textbf{Keywords}: bicluster graphs, cluster graphs, edge edition problems, edge modification problems, fixed-parameter tractability, NP-complete problems.
\end{abstract}

\section{Introduction} \label{sec1}

Edge edition (or edge {\em modification}) problems have been intensively studied within
the context of parameterized complexity theory. The general
formulation for this class of problems is: ``transform an input
graph  into a member of a target family
by editing at most  of its edges.'' For a detailed study on
edge edition problems, see \cite{NSS99}.

In particular, cluster editing problems appeared as a promising
field for this research, due to their applications in
computational biology, data mining, facility location, network
models, etc. For this class of problems, the target family
is usually formed by graphs consisting of a vertex-disjoint union
of cliques ({\sc Cluster Editing}), bicliques ({\sc Bicluster Editing}), or other types of dense and/or regularly structured
graphs. Several recent works have presented results on cluster editing problems,
see for instance~\cite{TBGEP2004,CM2011,DSPS2006,DSPS2009,FLRS2007,GGHN2003,G2007,YZ2007,SST2004}.

A natural generalization of cluster editing problems consists of
defining the target family to contain {\em mixed cluster graphs}. A mixed cluster graph is
a vertex-disjoint union of graphs 
such that each  is a member of a fixed family .
In this formulation, {\sc Cluster Editing} corresponds precisely to
, and {\sc Bicluster Editing} to
. Let us call such
a generalized problem {\sc Mixed Cluster Editing} or {\sc -Cluster Editing}.
Mixed cluster graphs are also called {\em -cluster graphs}.

The proposed generalization covers the case in which 
includes graphs of two or more well-known families. For a fixed integer
, define  as the family of {\em
-cliques}\footnote{In the literature, `-clique' also stands for a clique of size ,
but we employ here the above terminology in order to generalize
the term `bicliques' (for which ).}, consisting of the connected\footnote{A non-trivial edgeless graph is complete -partite (with one non-empty color class
and  empty color classes), but is not connected; thus, according to our definition, it is not an -clique.}, complete -partite
graphs.
Clearly, , for every .
Let .
In this work, we focus on the case ,
that is, the target graph must be a vertex-disjoint union of graphs 
such that each  is a clique or an -clique.

Since the family  can be characterized by a finite set of forbidden induced subgraphs
with at most  vertices
(Proposition~\ref{forbidden}), the tractability of the parameterized version of
{\sc -Cluster Editing}, denoted by {\sc-Cluster Editing},
follows directly from a result by Cai~\cite{C1996}, which provides an -time
algorithm to solve it. In fact, Cai's result can also be applied
to {\sc -Cluster Editing} whenever  is characterized
by a finite set of forbidden induced subgraphs.

We propose a linear-time kernelization algorithm for {\sc -Cluster Editing}
that builds a problem kernel with  vertices.
Considering the trivial  time
bounded search tree \cite{NR2000}, this gives an
 time algorithm for {\sc -Cluster Editing}.

Our kernelization algorithm is based on the modular decomposition techniques
previously applied to {\sc Cluster/Bicluster
Editing}~\cite{DSPS2006,DSPS2009}, extending their usefulness to solve
cluster editing problems in general.
Recent algorithms~\cite{CM2011,G2007,YZ2007} construct kernels for {\sc Cluster Editing} with size , but not in linear time.


The remainder of this work is organized as follows. Section
\ref{sec2} contains basic definitions, notation and preliminary results.
In Section \ref{sec3} we deal with the concept of {\em quotient graphs} and show how it allows us to derive
useful bounds and reduction rules for the kernelization algorithm.
In Section \ref{sec4} we show how to construct a problem
kernel in linear time for {\sc -Cluster Editing}.
Finally, Section \ref{sec5} discusses how the kernelization algorithms developed here and in \cite{DSPS2006,DSPS2009}
can be applied to obtain reduced graphs with  vertices, in linear time, both for {\sc Cluster Editing()} and {\sc Bicluster Editing()}.


\section{Preliminaries} \label{sec2}

Let  denote a finite graph, without loops and multiple edges.
If  is an induced subgraph of  then we say that  {\it contains} , or  {\it is contained in} .
The vertex set and the edge set of  are denoted by  and , respectively.
Assume  and . A chordless path with  vertices is denoted by .
A \emph{clique} is a complete (sub)graph.  A \emph{cluster graph} is a vertex-disjoint union of cliques.
A clique with  vertices is denoted by .  denotes the family of complete graphs.
A graph is -partite if it is -colorable.
An \emph{-clique} is a connected, complete -partite (sub)graph.
 denotes the family of -cliques, and  is defined as .
A \emph{-cluster graph} is a vertex-disjoint union of -cliques.
An \emph{-cluster graph} is a vertex-disjoint union of cliques and/or -cliques.

We remark that a graph  is a cluster graph if and only if  does not contain ,
and an -cluster graph if and only if  does not contain any of the graphs
,  and  (the graph 
is called {\em paw}). Denote by  the complete graph with  vertices minus one edge.
The following proposition characterizes -cluster graphs by means of forbidden induced subgraphs:

\begin{prop} \label{forbidden}
A graph  is an -cluster graph if and only if  does
not contain any of the graphs ,  and .
\end{prop}



\noindent
\emph{\textbf{Proof:}} If  is an -cluster graph then it is clear that  cannot contain
any of the graphs ,  and . Conversely, assume that
 does not contain such graphs. Since  contains no ,
 is a cograph~\cite{CLB81}. Let  be a connected component of . By properties of modular decomposition,  is formed
by disjoint subgraphs  such that each  is either trivial or disconnected,
and every vertex of  is adjacent to every vertex of  for .
If every  is trivial,  is a clique. Otherwise, assume . If  contains an
edge , we can choose a vertex  in a connected component of  not containing  and a vertex 
to form an induced paw, a contradiction. This means that every  is an edgeless graph. To conclude the proof,
since  contains no ,  we have , that is,  is an -clique. Hence,
 is an -cluster graph.  \qed2

An \emph{edition set}  is a set of unordered pairs of
vertices, each pair marked  or , such that:

\begin{itemize}

\item  represents the deletion from  of the edge  \ ({\em edge deletion});

\item  represents the addition to  of the edge  \ ({\em edge addition}).

\end{itemize}

In both cases, we say that  or  is an {\em edge edition}.
Assume that  does not contain a pair  (resp. ) if  (resp. ).
Assume also that no edge is edited more than once in .

Sometimes, the type of edition ( or ) will be omitted for simplicity; in this case,
we will denote an edge edition involving vertices  and  simply by .

We say that an induced subgraph  of  is {\em destroyed} by the edition
set  if there exist  such that:

\begin{itemize}

\item  if  then  contains ;

\item  if  then  contains .

\end{itemize}

In either case, we also say that  is destroyed by the corresponding edge edition ( or ).

In this work we are mainly concerned with the following objective: given a graph ,
find an edition set  such that  does not contain
any member of a family  of forbidden subgraphs. Such an edition set, if any, is called a {\em solution}.
An {\em optimal} edition set  is one with minimum size. We seek for solutions with size at most ,
for a nonnegative integer . Clearly, such solutions exist if and only an optimal solution  satisfies .

The notation  stands for the edition set obtained from
 by replacing each mark  by , and vice versa.  and
 denote the graphs obtained by applying to  the editions
determined by  and , respectively. Clearly,  if and
only if .

The following lemma will be useful:

\begin{lema} \label{orderF}
Let  be a graph,  a family of forbidden subgraphs, and  a minimum edition set with  such that  destroys all the members of  contained in . Then there exists an ordering  of the editions in  such that  destroys a member of  contained in  for every , where  and  for .
\end{lema}

\noindent
\emph{\textbf{Proof:}} Clearly, the result is valid for edition sets of size . Suppose that the result is valid for edition sets of size at most , . Let  be a minimum edition set such that  contains no member of . It is easy to see that there exists at least one edition of  that destroys a member of  contained in . Without loss of generality, let  be this edition. By the induction hypothesis, the result is valid for the edition set  when applied to . Then, we can obtain the desired ordering of  by appending  in the beginning of the ordering of . We remark that the lemma is also valid for {\it minimal} edition sets. \qed2


A subset  is a \emph{module} in  if for all
  and ,  if
and only if . A module  is \emph{strong} if,
for every module , either  or one of these
modules is contained in the other. A strong module is
\emph{parallel} when the subgraph induced by its vertices is
disconnected, \emph{series} when the complement of the subgraph
induced by its vertices is disconnected, and \emph{neighborhood}
when both the subgraph induced by its vertices and its complement
are connected. The process of decomposing a graph into strong
modules is called \emph{modular decomposition}. The modular
decomposition of  is represented by a \emph{modular
decomposition tree} . The nodes of  correspond to the
strong modules of . The root corresponds to , and the
leaves correspond to the vertices of .  Each internal node of
 is labeled P (parallel), S (series) or N (neighborhood),
according to the type of the module. The children of every
internal node  of  are the maximal submodules of .
The modular decomposition tree of a graph is unique up to
isomorphism and can be obtained in linear time \cite{MS94}.
Important references on modular decomposition are \cite{BH83,DGC01,G67,HMC2004,MR84,MS94,RJ2000}.
Figures \ref{grafosQquoc}(a) and \ref{grafosQquoc}(b) show,
respectively, a graph  and its modular decomposition tree
.

\begin{figure}[htb]
\begin{center}
\includegraphics[height=9.33cm,width=13.01cm]{grafosQquoc.EPS}
\caption{\label{grafosQquoc}(a) A graph  \ (b) The modular
decomposition tree  \ (c) Quotient graph }
\end{center}
\end{figure}

\subsection{Hardness of {\sc -Cluster Editing}}

To conclude Section 2, we prove that the decision version of {\sc -Cluster Editing} is NP-complete.
We first show that the decision version of {\sc -Cluster Editing} is NP-complete. Given  and ,
{\sc -Cluster Editing} has answer `yes' if and only if  can be transformed
into a target graph consisting of a disjoint union of -cliques by editing at most  edges of .

\begin{lema} \label{NP-hard L-cluster}
Let . The problem {\sc -Cluster Editing} is NP-complete.
\end{lema}

\noindent
\emph{\textbf{Proof:}}
Membership in NP is trivial. We remark that the case  ({\sc Bicluster Editing})
was already shown to be NP-complete by Amit~\cite{TBGEP2004}.
We prove the NP-hardness via a reduction from {\sc Cluster Editing},
which is known to be NP-complete~\cite{SST2004}.

Let  be a graph with .
We can assume that  contains no trivial component.
Define  as follows:

\begin{itemize}

\item 

\item 

\item  and

\item 

\end{itemize}

In words, for each vertex , we construct a clique  with  vertices in ,
and for each edge , we add all possible edges between  and , except between
vertices with the same superscript. Observe that  is -partite (vertices with the same superscript  form an independent set).

We prove that there exists a solution  of {\sc Cluster Editing} for  with size at most 
if and only if there exists a solution  of {\sc -Cluster Editing} for  with size at most .

Let  be a solution for  with size at most . Define  as the following edition set for :



As pointed out before, it is implicit that if  (resp. ) then  (resp. ) for . An edge edition  implies linking  and  in  by  edges (vertices  and  remain unlinked for all ), and an edge edition  implies disconnecting  and  in  by removing the  edges between them.

Note that each clique in the cluster graph  corresponds to an -clique in . Thus  is indeed a solution for , and .

Conversely, suppose there exists a minimum solution  for  such that . Without loss of generality, suppose also . Since  is minimum, by Lemma~\ref{orderF} there exists an ordering  of  such that  destroys a forbidden subgraph in , , where  and  for . We prove that



is a minimum solution for . Clearly,  is a solution and .

For , we use induction on  to prove the result. Let  be the only  contained in . When , there exist three minimum solutions  for , each one having size . Namely, ,   and , corresponding to solutions ,  and , respectively (see Figure \ref{casobase}).

\begin{figure}[htb]
\centering
\includegraphics[height=1.9cm,width=5.26cm]{casoBase2.EPS}
\caption{\label{casobase} A  contained in  and the corresponding induced subgraph in , for .}
\end{figure}

When , assume by the induction hypothesis that the result is valid for . Let  and . In order to destroy all forbidden subgraphs induced by the subset of vertices ,  in ,  edge editions are necessary. Besides, there exist three minimum solutions  for , each of size , namely ,  and . These three cases are analyzed as follows.


\noindent
\textbf{Case 1)} , . Consider . In this graph, it is still necessary to destroy the paws illustrated in Figure \ref{caso1}. The edition subset  of  achieves this end. Moreover, the edge editions in  are mandatory, in the sense that excluding one of them from  leaves a paw undestroyed in . Since \  , we have overall for this case a unique minimum edition set , , whose size is .

\begin{figure}[htb]
\centering
\includegraphics[height=5.94cm,width=10.21cm]{caso1b.EPS}
\caption{\label{caso1}(a) ,  (b) , ,  (c) ,  (d) , ;  \mbox{(e) ,  (f) , }.}
\end{figure}

\noindent
\textbf{Case 2)} , . This case is analogous to the previous one.

\noindent
\textbf{Case 3)} , . Consider again the graph , and note that several paws still need to be destroyed. Some of them are illustrated in Figure \ref{caso3}.

\begin{figure}[htb]
\centering
\includegraphics[height=2.53cm,width=13.97cm]{caso3b.EPS}
\caption{\label{caso3}(a) ,  or 
(b) , 
(c) , ,  or 
(d) , .}
\end{figure}

In order to destroy the forbidden subgraphs of , there exists a unique applicable edition subset of size , namely
. Overall, we have for this case a unique minimum edition set
, , whose size is .

As the result is valid for , we conclude (using the ordering  of ) that the result is valid for any . \qed2

\begin{teo}
{\sc -Cluster Editing} is NP-complete.
\end{teo}

\emph{\textbf{Proof:}} Membership in NP is trivial. Let  be an instance of {\sc -Cluster Editing}.
Recall from the reduction in Lemma~\ref{NP-hard L-cluster} that {\sc -Cluster Editing} remains NP-complete when restricted to -partite graphs.
Hence, assume that  is -partite. Define an instance  for {\sc -Cluster Editing} by setting . We show that there exists a solution for  with size at most  if and only if there exists a solution for  with size at most . The `only if' part is trivial, since every -cluster graph is also an -cluster graph.
Conversely, let  be a solution for , and let  be the connected components of .
If these components are all -cliques, the result follows. Otherwise, assume that  is a clique but not an -clique.
Then  contains at least  vertices (otherwise it would be -partite and thus an -clique). Since  is -partite, let  be the partite sets of ,
and consider the subsets .
At least one of these subsets contains more than one vertex. Thus we can construct a new edition set  from , ,
by removing from  the edge additions among vertices of a same subset , for all ,
and proceeding the same way for all clique components of  with at least  vertices. \qed2


\section{Q-quotient graphs}\label{sec3}

In this section we define a special type of graph, namely the Q-\emph{quotient graph}, that allows the establishment of reduction rules for the kernelization algorithm.


\begin{defin}
A partition  of  is the \emph{Q-partition} of  if  satisfies the following conditions:\\
-- if  is a leaf child of a node labelled \emph{N} in  then  is a part of ;\\
-- if  are the leaf children of a node labelled \emph{P} or \emph{S} in  then  is a part of .
\end{defin}

A partition  of  such that each part of  is a
module is called \emph{congruence partition}, and the graph whose
vertices are the parts of  and whose edges correspond to the
adjacency relationships involving parts of  is called
\emph{quotient graph} .

Clearly, every part of the Q-partition is a strong module in .
Therefore, it is a special type of congruence partition. Since the
modular decomposition tree of a graph is unique, the Q-partition
is also unique.

\begin{defin}
Let  be a partition of . If  is the
\emph{Q}-partition of  then  is the \emph{Q-quotient
graph} of , denoted by .
\end{defin}

A vertex of  corresponding to a part of  which
contains the children of a node labelled P (resp. S) in  is
called P-\emph{vertex} (resp. S-\emph{vertex}); whereas a vertex
corresponding to a singleton  of  is called
U-\emph{vertex}. We remark that S-vertices can also be seen as
{\em critical cliques}~\cite{G2007}, and P-vertices as {\em
critical independent sets}~\cite{YZ2007}.

Let  be a module corresponding to a P-vertex (or S-vertex).
For simplicity, we write  to stand for both the
module and the P-vertex (S-vertex). Similarly, if a U-vertex is associated with
part   of  then we write  to stand
for the U-vertex. We also say that a vertex   {\em
belongs} to a P-vertex or an S-vertex  when
.

If  is a Q-quotient graph, denote by  (resp.
) the set of P-vertices (resp. S-vertices) of
, and by  the set of U-vertices of .

Figure \ref{grafosQquoc}(c) depicts the graph  for
the graph  in Figure \ref{grafosQquoc}(a), where P-vertices are
graphically represented by the symbol
\mbox{\hspace{-.105in}\scriptsize{P}} \normalsize, and
S-vertices by \mbox{\hspace{-.10in}\scriptsize{S}}
\normalsize.

In the remainder of this work,  denotes an edition set for , and  denotes the graph .

The next lemma presents useful bounds on the sizes of ,
,  and 
for the case of one edge edition in .

\begin{lema} \label{1edicao-quociente}
Let  be an edition set for , and let .
If  then the following inequalities hold:

\noindent {\em (1)} .

\noindent {\em (2)} .

\noindent {\em (3)} .

\noindent {\em (4)} .
\end{lema}

\noindent \emph{\textbf{Proof:}} Let  be the edited
edge. The proof is based on the analysis of the local editions
made in  in order to obtain , by
considering the new adjacency relations in . There are eight
cases, described below.

\medskip

\noindent {\em Case 1}:  and  are U-vertices in . In this case  does not form a module in , and
therefore cannot be converted into a P-vertex or an S-vertex in
. Since  are vertices in , it
will be useful to regard  also as an edition set of size
one for , and look at the graph 
(which in general is \emph{not} isomorphic to ).

\medskip

\begin{itemize}

\item[(a)] If there exists a U-vertex  in  such
that  is nonadjacent to , and  is a module in
, then  is a new P-vertex in
.


\item[(b)] If there exists a U-vertex  in  such
that  is adjacent to , and  is a module in
, then  is a new S-vertex in
.


\item[(c)] If there exists a P-vertex  in  such
that  is nonadjacent to , and  is a module in
, then  is a new P-vertex in
.


\item[(d)] If there exists an S-vertex  in  such
that  is adjacent to , and  is a module in
, then  is a new S-vertex in
.


\item[(e)] If none of the previous situations (a)-(d) applies to
 then  is still a U-vertex in .

\end{itemize}

The same possibilities (a)-(e) are applicable to .

Overall, we have for this case , , , and .

\medskip

\noindent {\em Case 2}:  is a U-vertex and  belongs to a
P-vertex  in .
Write \}.

If , we can observe, considering vertex , that:
\begin{itemize}
\item[(a)]  cannot form a new P-vertex in  together with a U-vertex  () of , because  would already belong to  in . By the same reason,  could not be joined to a P-vertex  already existing in .

\item[(b)]  cannot form a new S-vertex in  together with a U-vertex  () of , because  would be adjacent to  but not to  in . By the same reason,  could not be joined to an S-vertex  already existing in .

\item[(c)]  cannot form a new P-vertex with  in  (if they are not adjacent in ), because  would already belong to  in . Besides,  would be adjacent to  but not to  in .

\item[(d)]  can form with  a new S-vertex in , if  and  is a module in .
\end{itemize}

Consider vertex . We observe that if  is not a new S-vertex then  is still a U-vertex in .
With respect to , there are three possibilities:  can be a new U-vertex,  can form a new P-vertex with some U-vertex  of  (), or  can be added to a pre-existing P-vertex  of .

If  then  is a P-vertex in , since the previous cases (a) and (c) would also be applied (by replacing  by \}), and  has at least two nonadjacent vertices (thus cannot be included into an S-vertex). Therefore, in this case  is still a U-vertex in . With respect to , the same possibilities of the previous situation are applied.

Overall,  we have for this case
,
,
, and
.

\medskip


\noindent {\em Case 3}:  is a U-vertex and  belongs to an
S-vertex  in . Write \}.

If , we can observe, considering vertex , that:
\begin{itemize}
\item[(a)]  cannot form a new S-vertex in  together with a U-vertex  () of , because  would already belong to  in . By the same reason,  could not be joined to an S-vertex  already existing in .

\item[(b)]  cannot form a new P-vertex in  together with a U-vertex  () of , because  would be adjacent to  but not to  in . By the same reason,  could not be joined to a P-vertex  already existing in .

\item[(c)]  cannot form a new S-vertex with  in  (if they are adjacent in ), because  would already belong to  in . Besides,  would be adjacent to  but not to  in .

\item[(d)]  can form with  a new P-vertex in , if  and  is a module in .
\end{itemize}

Considering vertex , we observe that if  is not a new P-vertex then  is still a U-vertex in .
With respect to , there are three possibilities:  can be a new U-vertex,  can form a new S-vertex with some U-vertex  of  (), or  can be added to a pre-existing S-vertex  of .


If  then  is an S-vertex in , since the previous cases (a) and (c) would also be applied (by replacing  by \}), and  has at least two adjacent vertices (thus cannot be included into a P-vertex). Therefore, in this case  is still a U-vertex in . With respect to , the same possibilities  of the previous situation are applied.

Overall, we have for this case
,
,
, and
.

\medskip

\noindent {\em Case 4}:  and  belong to distinct P-vertices
 and  in , respectively.
Write  and . Then  and  are two new U-vertices in . If  and ,  and  are also two new U-vertices in . If  and ,  is a new U-vertex and  is a P-vertex in . The situation  and  is similar to the previous one. Finally, if  then  and  are P-vertices in .

Overall,
we have for this case
,
,
, and


\medskip


\noindent {\em Case 5}:  and  belong to the same P-vertex  in .
Write . Then  is an added edge. The vertex  cannot form a new P-vertex , because  would be adjacent to  but not to  (the same applies to ). Vertex  cannot either form a new S-vertex  with a U-vertex  (or with another \makebox{S-vertex}), because  would be adjacent to , but not to  (the same applies to ). Since  is still a module in ,   forms a new S-vertex in . If  then  is a new U-vertex, and if  then  is a P-vertex in .

Overall,
we have for this case
,
,
, and


\medskip

\noindent {\em Case 6}:  and  belong to distinct S-vertices
 and  in , respectively.
Write  and . Then  and  are two new U-vertices in . If  and ,  and  are also two new U-vertices in . If  and ,  is a new U-vertex and  is an S-vertex in . The situation  and  is similar to the previous one. Finally, if  then  and  are S-vertices in .

Overall,
we have for this case
,
,
, and


\medskip

\noindent {\em Case 7}:  and  belong to the same S-vertex  in .
Write . Then  is a removed edge. Vertex  cannot form a new S-vertex , because  would be adjacent to  but not to  (the same applies to ). Vertex  cannot either form a new P-vertex  with a U-vertex  (or with another \makebox{P-vertex}), because  would be adjacent to   but not to  (the same applies to ). Since  is still a module in ,   forms a new P-vertex in . If  then  is a new U-vertex, and if  then  is an S-vertex in .

Overall,
we have for this case
,
,
, and


\medskip

\noindent {\em Case 8}:  belongs to a P-vertex  and 
belongs to an S-vertex  in  .
Write  and . Consider vertex . We observe that:

\begin{itemize}
\item[(a)]  cannot form with  a new P-vertex neither a new S-vertex in , because  or  would be adjacent to one vertex of , but not to the other;

\item[(b)] if ,  is not adjacent to  and  is a module in  (thus  forms a new P-vertex in );

\item[(c)]  cannot be joined to a U-vertex neither to an S-vertex (or a P-vertex) already existing in  to form a new S-vertex (P-vertex) in .
\end{itemize}

Consider now vertex . The following facts hold:
\begin{itemize}
\item[(a)] if ,  is adjacent to  and  is a module in  (thus  forms a new S-vertex in );

\item[(b)]  cannot be joined to a U-vertex neither to an S-vertex (or a P-vertex) already existing in   to form a new S-vertex (P-vertex) in .
\end{itemize}

If ,  can also be a new U-vertex; otherwise,  is a P-vertex in . If ,  can also be a new U-vertex; otherwise,  is an S-vertex in .
Overall,
we have for this case
,
,
, and


\medskip

All the cases have been analyzed, thus the lemma follows. \hfill \framebox[.09in]

\bigskip

\section{Building the Problem Kernel} \label{sec4}


Clearly, connected components of the input graph  that are
already cliques or -cliques can be omitted from
consideration.

If , , is an -cluster graph then  contains at
most  connected components. In graph , each of them
can have one of the graphical representations illustrated in
Figure \ref{q-quocCliqueBiclique}.

\begin{figure}[htb]
\centering
\includegraphics[height=2.27cm,width=8.68cm]{q-quocCliqueL-clique.EPS}
\caption{\label{q-quocCliqueBiclique}Possible graphical
representations of a connected component of ,
where .}
\end{figure}

Lemma \ref{kernel1mod} presents bounds on the sizes of ,
 and  when  and 
is an -cluster graph.



\begin{lema} \label{kernel1mod}
If  contains no clique or -clique component and there
exists an edition set  for  such that  and
 is an -cluster graph then ,  and
.
\end{lema}


\emph{\textbf{Proof:}} Since , we can apply to  the inverse
edition in  in order to obtain . Graph 
contains at most  connected components. All the cases in the
proof of Lemma \ref{1edicao-quociente} can then be applied.
The proof follows by analyzing the worst case for each case.

\medskip

\noindent {\em Case 1}:  and  are U-vertices in . In the worst case (maximizing the total number of vertices of ),  and  belong to distinct -cliques. By applying the limits established by this case in the proof of Lemma \ref{1edicao-quociente}, we have  ,    (in the worst case each -clique contains  P-vertices) and .

\medskip

\noindent {\em Case 2}:  is a U-vertex and  belongs to a P-vertex in . In the worst case,  and  belong to distinct -cliques. By applying again the limits established by this case in Lemma \ref{1edicao-quociente}, we have ,  (in the worst case the -clique of  contains  P-vertices and the -clique of  contains  P-vertices) and .

\medskip

\noindent {\em Case 3}:  is a U-vertex and  belongs to an S-vertex in . Clearly,  and  belong to distinct connected components. In the worst case, we have ,  and .

\medskip

\noindent {\em Case 4}:  and  belong to distinct P-vertices in . In the worst case, we have ,  and .

\medskip

\noindent {\em Case 5}:  and  belong to the same P-vertex in . In the worst case, ,  and .

\medskip

\noindent {\em Case 6}:  and  belong to distinct S-vertices in . In the worst case, ,    and .

\medskip

\noindent {\em Case 7}:  and  belong to the same S-vertex in . In the worst case, ,  and .

\medskip

\noindent {\em Case 8}:  belongs to a P-vertex and  belongs to an S-vertex in . In the worst case, ,  and .
\hfill \framebox[.09in] \\ \\

The next theorem generalizes the previous lemma.

\begin{teo} \label{sizeG_Q}
If  contains no clique or -clique component and there
exists an edition set  for  such that  and
 is an -cluster graph then , 
and .
\end{teo}

\emph{\textbf{Proof:}} Since , we can apply to  the inverse
editions in  in order to obtain . The proof is by induction on .
The basis of the induction is given by Lemma \ref{kernel1mod}.

Let  be a subset of  such that , and let
. By the induction hypothesis, the result is
valid for . Hence, the subgraph of 
induced by components which are not cliques or -cliques
contains at most  vertices, among which at most
 are P-vertices and at most  are S-vertices.
Since  can contain  components, 
can possibly contain some other components which are cliques or
-cliques.

Let  be the edge edition such that . Then . Let  be the vertices
of . All the cases of the proof of Lemma
\ref{1edicao-quociente} can be applied, by considering all the situations
for vertices  and . Again, the proof follows by analyzing the worst case for each of them. \hfill \framebox[.09in]


\subsection{Splitting P-vertices and S-vertices}

When there exists an optimal solution with size  of {\sc -Cluster Editing}
such that no P-vertex or S-vertex  of  is
split into distinct vertices of ,
the size of  is bounded by  \cite{DSPS2006,DSPS2009}.
However, such an optimal solution may not exist.
For instance, let  and consider the graph  depicted in Figure \ref{splitPvertex}. We have
three optimal solutions for {\sc -Cluster Editing} in this case; all of
them split the P-vertex  of  into two S-vertices
of . One of the solutions is illustrated in Figure \ref{splitPvertex}(c).

\begin{figure}[htb]
\centering
\includegraphics[height=4.43cm,width=14.25cm]{splitPvertex.EPS}
\caption{\label{splitPvertex}(a) Input graph G; (b) Graph  (c) Graph 
obtained from , where , , , , ,
, , , , , , , , 
is an optimal solution for {\sc Mixed Cluster Editing} ().}
\end{figure}


In order to build a problem kernel for {\sc -Cluster Editing}(),
we will obtain a bound on the size of P-vertices and S-vertices of
, by analyzing all possible cases
in which a P-vertex or an S-vertex of  is split into distinct vertices
of  in an optimal solution.

In this subsection, we analyze all possible cases in which two distinct vertices of  contain
vertices of a same P-vertex or S-vertex of .
When a contradiction arises, the assumed split
does not occur in any optimal solution and can be disregarded.
In the next subsection, the analysis is generalized for several
vertices of  containing vertices of the same P-vertex or
S-vertex of . Since at most  edge editions are
allowed, a bound on the size of a P-vertex or an S-vertex of 
that is split into distinct vertices of  in an optimal solution can be derived.


Let  be a P-vertex (or S-vertex) of  whose
vertices are split into distinct vertices of , in an
optimal solution . Let  and  be two vertices of
 that contain vertices of . Let 
and . We denote by  the edition subset of
 containing the editions of the form  such that  and . Similarly,  denotes the edition subset of  containing the editions of the form 
such that  and . Let  and .

Since  is a module in  (because  is contained in a vertex of )
and is still a module in  (because  is contained in a vertex of ),
the edge editions in  with only one endpoint in  are
replicated for each vertex of , considering the other endpoint and the edition type.
That is, if there exists in  an edition  such that
 then there exists the edition  in ,
for all . Hence, we have  editions in
 for each vertex of .

The same argument above applies to .

We now analyze the following cases.

\textbf{Case 1.  and  belong to the same connected
component.}\ \ Then  (or ) can be a U-vertex or
P-vertex of an -clique in .

\textbf{Case 1.1.}  is a P-vertex. Then the total number of
editions in  involving vertices of  is
.

 If  then . We have . We obtain a smaller edition set if the vertices of
 belong to , and a contradiction follows.

 If  then
. We obtain a smaller edition set if the vertices of  belong to , and a
contradiction follows.

\textbf{Case 1.2.}  is an S-vertex. Then the total number of
editions in  involving vertices of  is .

 If  then
. We can obtain an edition set ,
, if the vertices of  belong to .

 If  then
. We can obtain an edition set ,
, if the vertices of  belong to .

 If  then there is no contradiction,
and we cannot construct an edition set  with  by applying to all vertices
of  the same edge editions.


\textbf{Case 2.  and  belong to distinct connected
components.}

\textbf{Case 2.1.}  and  are clique components of  (each of them is a U-vertex or an S-vertex in ).

\textbf{2.1.1.}  is an S-vertex. The total number of editions in
 involving vertices of  is .

 If  then . Thus .  A smaller edition set is obtained if the vertices of
 belong to , and a contradiction follows.

 If  then
. A smaller edition set is obtained if the vertices of  belong to , and a
contradiction follows.

\textbf{2.1.2.}  is a P-vertex. The total number of editions in
 involving vertices of  is
.

 If  then
. We can obtain  with  if the vertices of  belong to .

 If  then
. We can obtain  with  if the vertices of  belong to .

 If  then there is no contradiction, and we cannot construct 
with  by applying to all vertices of  the
same edge editions.

\textbf{Case 2.2.}  is a clique component of size one
(therefore a U-vertex in ), and  is contained
in an -clique component ( is a U-vertex or a P-vertex in
).

\textbf{2.2.1.}  is an S-vertex. The total number of editions
in  involving vertices of  is .

 If  then . We can
obtain a smaller edition set by applying to  the same edge
editions applied to  by  (instead of applying ), and
a contradiction follows.

 If   then . Thus . We can obtain a smaller edition set by
applying to  the same edge editions applied to  by ,
and a contradiction follows.

\textbf{2.2.2.}  is a P-vertex. The total number of editions in
 involving vertices of  is .

 If  then . We can obtain a smaller edition set by
applying to  the same edge editions applied to  by ,
and a contradiction follows.

 If   then . We can obtain an edition set  with
 by applying  to each vertex of .

\textbf{Case 2.3.}  is a clique component of size at least two
(an S-vertex in ), and  is contained in an
-clique component ( is a U-vertex or a P-vertex in
).

\textbf{2.3.1.}  is a P-vertex. The total number of editions in
 involving vertices of  is
.

 If  then
. We can
obtain  with  if the vertices of  belong to
.

 If  then . We can obtain  with  if the vertices of  belong to .

 If  then there is no
contradiction, and we cannot construct  with  by
applying to all vertices of  the same edge editions.

\textbf{2.3.2.}  is an S-vertex. The total number of editions
in  involving vertices of  is
.

 If  then
. A smaller edition set is obtained if
the vertices of  belong to , and a contradiction follows.

 If  then
. Thus
. A
smaller edition set is obtained if the vertices of  belong
to , and a contradiction follows.

\textbf{Case 2.4.}  and  are contained in -clique
components of  (each of them is a U-vertex or P-vertex in
). In this case,  can be a P-vertex or an
S-vertex, since in both cases  is an independent
set in .

 If , we can obtain a smaller
edition set by applying to  the same edge editions applied
to  by , and a contradiction follows.

 If  , we can obtain an edition set  with  by applying to  the same
edge editions applied to  by .


\subsection{Determining the kernel's size}

By analyzing all the cases previously described, we observe that it is
often possible to replace an optimal solution containing the
split of a P-vertex or S-vertex by another optimal solution in
which this split does not occur. However, there exist some
unavoidable splits, described below. We analyze these
cases in order to bound the size of P-vertices and S-vertices in
the problem kernel.


\emph{\textbf{Splitting an S-vertex.}} An S-vertex can be
split into distinct vertices of the same -clique of
. If an S-vertex  contains more than 
vertices then, given a solution  such that , no
vertex of  is an endpoint of an edge edition in , since each
edge edition can decrease the chromatic number of a clique by at
most one and  induces an -clique in .


\emph{\textbf{Splitting a P-vertex.}} There are two cases for
the split of a P-vertex :

1) Only cliques in  contain vertices of . Since 
contains no clique or -clique component, there exists at
least one vertex  adjacent to . Since  induces
a cluster subgraph in , all the 's in  are
destroyed by an optimal solution . Therefore, if  then  contains at most  vertices.

2) Exactly one -clique  and some cliques of size at least
two contain vertices of . Let  be one of these cliques. The
vertices of a P-vertex cannot be split into distinct parts of a
same -clique. Therefore, exactly one vertex of  contains
vertices of  in . Let  and . There exists at least one vertex  such that  is adjacent to  in  (otherwise, we could
obtain a better solution if each vertex of  was an isolated
clique in ). Therefore,  is adjacent to  in .
Similarly, there exists at least one vertex  such that  is adjacent to  in  and adjacent to
 in . Therefore,  is adjacent to  in . Hence, the
edges  and 
have been removed by an optimal solution . If  then
. The same argument can be applied to other
cliques, if any. Therefore, .


\begin{teo}
A problem kernel with  vertices can be constructed
for {\sc -Cluster Editing} in  time.
\end{teo}

\emph{\textbf{Proof:}} By the previous analysis, we can construct
a problem kernel  by restricting the size of the P-vertices
of  to  and the size of the S-vertices to
. By Theorem \ref{sizeG_Q},  contains at most
 vertices. Graph 
can be constructed in  time by applying modular
decomposition \cite{DSPS2006,DSPS2009}. \hfill \framebox[.09in]


\section{Conclusions} \label{sec5}

The kernelization algorithms developed here and in \cite{DSPS2006,DSPS2009} can be applied to obtain, in linear time, special reduced graphs with  vertices which may help to solve {\sc Cluster Editing()} and {\sc Bicluster Editing()}, as explained below.

First, consider a generalization of {\sc Cluster Editing} (or {\sc Bicluster Editing}) in which edges and non-edges have positive integer weights (in the standard version, all edges/non-edges have weight one). The objective is then to obtain a cluster (bicluster) graph by applying to the input graph an edition set of minimum weight. The {\it weighted parameterized problem} associated with this generalization asks whether it is possible to obtain a cluster (bicluster) graph via an edition set of weight at most . Let us denote it by {\sc Weighted Cluster Editing()} ({\sc Weighted Bicluster Editing()}).

Next, recall that if an instance  of {\sc Cluster Editing()} has answer `yes', then there exists an optimal solution such that no S-vertex  of the S-quotient graph  is split into different vertices of . Define weights for the edges of  as follows: the weight of an edge  of  is the sum of the weights of all edges of  with one endpoint in  and other endpoint in  ( and  can be modules of size larger than one). It is clear that  is a yes-instance of {\sc Cluster Editing()} if and only if  (with the so-defined edge weights) is a yes instance of {\sc Weighted Cluster Editing()}. Moreover,  contains  vertices.

The same argument of the previous paragraph can be applied to {\sc Bicluster Editing()} and the graphs  and .

However, since in the problem {\sc -Cluster Editing()} P-vertices and S-vertices are in general unavoidably split into different vertices in an optimal solution, the Q-quotient graph  cannot be used as above. In this case, the modular decomposition technique provides an  kernel in linear time.

A future work is the development of linear size kernels for {\sc -Cluster Editing}.

\bibliographystyle{plain}

\begin{thebibliography}{99}

\bibitem{TBGEP2004}
Amit, N. \emph{The Bicluster Graph Editing Problem}, M.Sc. Thesis,
Tel Aviv University, 2004.

\bibitem{BH83}
Bauer, H. and M\"ohring, R. H. A fast algorithm for the decomposition of graphs and posets.
{\em Mathematics of Operations Research} 8 (1983) 170--184.

\bibitem{C1996}
Cai, L. Fixed-parameter tractability of graph modification
problems for hereditary properties. {\em Information Processing
Letters} 58 (1996) 171--176.

\bibitem{CM2011}
Chen, J. and Meng, J. A  kernel for the Cluster Editing Problem.
{\em Journal of Computer and System Sciences}, to appear.

\bibitem{CLB81}
Corneil, D. G., Lerchs, H., and Burlingham, L. S. Complement
reducible graphs. {\em Discrete Applied Mathematics} 3 (1981)
163--174.

\bibitem{DGC01}
Dahlhaus, E., Gustedt, J., and McConnell, R. M. Efficient and practical algorithms for sequential modular decomposition. {\em Journal of Algorithms} 41 (2001) 360--387.

\bibitem{DSPS2006}
Dantas da Silva, M., Protti, F., and Szwarcfiter, J. L.
Applying modular decomposition to parameterized bicluster editing.
{\em 2nd International Workshop on Parameterized and Exact Computation (IWPEC 2006)}, Z\"{u}rich, Switzerland,
{\em Lecture Notes in Computer Science} 4169 (2006) 1--12.

\bibitem{DSPS2009}
Dantas da Silva, M., Protti, F., and Szwarcfiter, J. L.
Applying modular decomposition to parameterized cluster editing problems.
{\em Theory of Computing Systems} 44 (2009) 91--104.

\bibitem{DF1999}
Downey, R. G. and Fellows, M. R.
\emph{Parameterized Complexity.} Springer-Verlag, 1999.

\bibitem{FLRS2007}
Fellows, M., Langston, M., Rosamond, F., and Shaw, P. Efficient
parameterized preprocessing for cluster editing.
\emph{16th International Symposium on Fundamentals of Computation Theory}, \emph{Lecture Notes in
Computer Science} 4639 (2007) 312--321.

\bibitem{G67}
Gallai, T. Transitiv orientierbare Graphen.
{\em Acta Math. Acad. Sci. Hung.} 18 (1967) 26--66.

\bibitem{GGHN2003}
Gramm, J., Guo, J., H\"uffner, F., and Niedermeier, R. Graph-modeled
data clustering: Fixed-parameter algorithms for clique generation.
{\em Theory of Computing Systems} 38, 4 (2005) 373--392.

\bibitem{GGHN2004}
Gramm, J., Guo, J., H\"uffner, F., and Niedermeier, R. Automated
generation of search tree algorithms for hard graph modification
problems. \emph{Algorithmica} 39 (2004) 321--347.

\bibitem{G2007}
Guo, J. A more effective linear kernelization for Cluster Editing.
\emph{1st International Symposium on Combinatorics, Algorithms,
Probabilistic and Experimental Methodologies }(\emph{ESCAPE
2007}), \emph{Lecture Notes in Computer Science} 4614 (2007)
36--47.

\bibitem{YZ2007}
Guo, J., H\"uffner, F., Komusiewicz, C., and Zhang, Y. Improved algorithms for bicluster editing.
\emph{5th Annual Conference on Theory and Applications of Models of Computation (TAMC'08)}, \emph{Lecture Notes in Computer Science} 4978 (2008) 451--462.

\bibitem{HMC2004}
Habib, M., Montgolfier, F., and Paul, C. A simple linear-time modular decomposition algorithm for graphs, using order extension.
{\em 9th Scandinavian Workshop on Algorithm Theory (SWAT 2004)}, {\em Lecture Notes in Computer Science} 3111 (2004) 187--198.

\bibitem{MR84}
M\"ohring, R. H., and Radermacher, F. J.
Substitution decomposition and connections with combinatorial optimization.
{\em Ann. Discrete Math.} 19 (1984) 257--356.

\bibitem{MS94}
McConnell, R. M. and Spinrad, J. P. Linear-time modular
decomposition and efficient transitive orientation of
comparability graphs. {\em Proc. of the 5th Annual ACM-SIAM Symposium on Discrete Algorithms (SODA 1994)}, Arlington, Virginia, pp. 536--545.

\bibitem{RJ2000}
McConnell, R. M. and Spinrad, J. P. Ordered vertex partitioning.
{\em Discrete Mathematics and Theoretical Computer Science} 4
(2000) 45--60.

\bibitem{NSS99}
Natanzon, A., Shamir, R., and Sharan, R. Complexity classification of
some edge modification problems. {\em Discrete Applied
Mathematics} 113 (1999) 109--128.

\bibitem{N2006}
Niedermeier, R. \emph{Invitation to Fixed-Parameter Algorithms}.
Oxford University Press, 2006.

\bibitem{NR2000}
Niedermeier, R. and Rossmanith, P. A general method to speed up
fixed-parameter-tractable algorithms. \emph{Information Processing
Letters} 73 (2000) 125--129.

\bibitem{SST2004}
Shamir, R., Sharan, R., and Tsur, D. Cluster graph modification
problems. {\em Discrete Applied Mathematics} 144 (2004) 173--182.

\end{thebibliography}

\end{document}
