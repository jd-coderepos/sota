\documentclass[12pt]{amsart}  







\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{longtable}
\usepackage{float}
\usepackage{latexsym}
\usepackage{amssymb}
\usepackage{bbm}
\usepackage{hyperref}
\tolerance=1000
\usepackage{amsmath,amsthm}
\usepackage{dsfont}
\usepackage{color}
\usepackage{enumerate}


\newtheorem{theorem}{Theorem}[section]
\newtheorem{conjecture}[theorem]{Conjecture}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{definition}[theorem]{Definition}


\graphicspath{{figs/}}

\newcommand{\suchthat}{\mathbin |}
\newcommand{\absval}[1]{\left\vert #1 \right\vert}
\newcommand{\norm}[1]{\left\Vert #1 \right\Vert}
\newcommand{\tphi}{{\tilde\varphi}}
\newcommand{\suc}{\mathrm{succ}}
\newcommand{\MSO}{\textrm{MSO}}
\newcommand{\FO}{\textrm{FO}}
\newcommand{\R}{\mathds{R}}
\newcommand{\N}{\mathds{N}}
\newcommand{\cT}{\mathcal{T}}
\newcommand{\tcT}{\tilde{\mathcal{T}}}
\newcommand{\cV}{\mathcal{V}}
\newcommand{\topmin}{\preceq_{\mathrm{top}}}
\newcommand{\tV}{\tilde{V}}
\newcommand{\cP}{\mathcal{P}}
\newcommand{\cN}{\mathcal{N}}
\newcommand{\eg}{\mathrm{eg}}
\newcommand{\fA}{\mathfrak{A}}
\newcommand{\todo}[1]{{\color{red}Todo: #1}}
\let\oldphi=\phi
\let\phi=\varphi

\newcommand{\tw}{\operatorname{tw}}
\newcommand{\pw}{\operatorname{pw}}
\newcommand{\cw}{\operatorname{cw}}


\newcommand{\AAA}{\mathcal{A}} \newcommand{\BBB}{\mathcal{B}}
\newcommand{\CCC}{\mathcal{C}} \newcommand{\DDD}{\mathcal{D}}
\newcommand{\EEE}{\mathcal{E}} \newcommand{\FFF}{\mathcal{F}}
\newcommand{\GGG}{\mathcal{G}} \newcommand{\HHH}{\mathcal{H}}
\newcommand{\III}{\mathcal{I}} \newcommand{\JJJ}{\mathcal{J}}
\newcommand{\KKK}{\mathcal{K}} \newcommand{\LLL}{\mathcal{L}}
\newcommand{\MMM}{\mathcal{M}} \newcommand{\NNN}{\mathcal{N}}
\newcommand{\OOO}{\mathcal{O}} \newcommand{\PPP}{\mathcal{P}}
\newcommand{\QQQ}{\mathcal{Q}} \newcommand{\RRR}{\mathcal{R}}
\newcommand{\SSS}{\mathcal{S}} \newcommand{\TTT}{\mathcal{T}}
\newcommand{\UUU}{\mathcal{U}} \newcommand{\VVV}{\mathcal{V}}
\newcommand{\WWW}{\mathcal{W}} \newcommand{\XXX}{\mathcal{X}}
\newcommand{\YYY}{\mathcal{Y}} \newcommand{\ZZZ}{\mathcal{Z}}

\newcommand{\ssL}{\mathsf{L}}

\renewcommand{\AA}{{\mathfrak A}} \newcommand{\BB}{{\mathfrak B}}
\newcommand{\CC}{{\mathfrak C}} \newcommand{\DD}{{\mathfrak D}}
\newcommand{\EE}{{\mathfrak E}} \newcommand{\FF}{{\mathfrak F}}
\newcommand{\GG}{{\mathfrak G}} \newcommand{\HH}{{\mathfrak H}}
\newcommand{\II}{{\mathfrak I}} \newcommand{\JJ}{{\mathfrak J}}
\newcommand{\KK}{{\mathfrak K}} \newcommand{\LL}{{\mathfrak L}}
\newcommand{\NN}{{\mathfrak N}} \newcommand{\MM}{{\mathfrak M}}
\newcommand{\OO}{{\mathfrak O}} \newcommand{\PP}{{\mathfrak P}}
\newcommand{\QQ}{{\mathfrak Q}} \newcommand{\RR}{{\mathfrak R}}
\newcommand{\TT}{{\mathfrak T}} \newcommand{\UU}{{\mathfrak U}}
\newcommand{\VV}{{\mathfrak V}} \newcommand{\WW}{{\mathfrak W}}
\newcommand{\XX}{{\mathfrak X}} \newcommand{\YY}{{\mathfrak Y}}
\newcommand{\ZZ}{{\mathfrak Z}}



\renewcommand{\MSO}{\textup{MSO}\xspace}
\newcommand{\MC}{\textup{MC}}
\newcommand{\MCs}{\MC_{+1}}
\newcommand{\MCo}{\MC_{<}}
\newcommand{\MCsi}{\MC_{+1\textit{-inv}}}
\newcommand{\MCoi}{\MC_{<}\textit{-inv}}
\newcommand{\Cdegd}{\DDD_d}
\newcommand{\AWs}{\textup{AW}\xspace}
\newcommand{\FOs}{\FO[+1]}
\newcommand{\FOsi}{\FO[+1\textit{-inv}]}
\newcommand{\FOo}{\FO[{<}]}
\newcommand{\FOoi}{\FO[{<}\textit{-inv}]}
\newcommand{\MSOs}{\MSO[+1]}
\newcommand{\MSOsi}{\MSO[+1\textit{-inv}]}
\newcommand{\MSOo}{\MSO[{<}]}
\newcommand{\MSOoi}{\MSO[{<}\textit{-inv}]}
\newcommand{\cl}{\textup{cl}}





\usepackage{xspace}
\newcommand{\PTIME}{\textsc{Ptime}\xspace}


\begin{document}

\title[succ-inv FO on Graphs with excl. top. subgraphs]{Successor-Invariant First-Order Logic on Graphs with Excluded
  Topological Subgraphs}
\author{Kord Eickmeyer}
\address{Technical University Darmstadt, Department of Mathematics, Schlossgartenstr. 7, 64289 Darmstadt, Germany}
\email{eickmeyer@mathematik.tu-darmstadt.de}

\author{Ken-ichi Kawarabayashi}
\address{National Inst. of Informatics and JST, ERATO, Kawarabayashi Large Graph Project, Hitotsubashi 2-1-2, Tokyo 101-8430, Japan}
\email{k\_keniti@nii.ac.jp}





\let\realbfseries=\bfseries
\def\bfseries{\realbfseries\boldmath}





\begin{abstract}
  We show that the model-checking problem for successor-invariant
  first-order logic is fixed-parameter tractable on graphs with
  excluded topological subgraphs when parameterised by both the size
  of the input formula and the size of the exluded topological
  subgraph. Furthermore, we show that model-checking for
  order-invariant first-order logic is tractable on coloured posets of
  bounded width, parameterised by both the size of the input formula
  and the width of the poset.

  Results of this form, i.e. showing that model-checking for a certain
  logic is tractable on a certain class of structures, are often
  referred to as algorithmic meta-theorems since they give a unified
  proof for the tractability of a whole range of problems. First-order
  logic is arguably one of the most important logics in this context
  since it is powerful enough to express many computational problems
  (e.g. the existence of cliques, dominating sets etc.) and yet its
  model-checking problem is tractable on rich classes of graphs. In
  fact, Grohe et al.~\cite{gks14} have shown that model-checking for
   is tractable on all nowhere dense classes of graphs.

  Successor-invariant  is a semantic extension of  by allowing
  the use of an additional binary relation which is interpreted as a
  directed Hamiltonian cycle, restricted to formulae whose truth value
  does not depend on the specific choice of a Hamiltonian cycle. While
  this is very natural in the context of model-checking (after all,
  storing a structure in computer memory usually brings with it a
  linear order on the structure), the question of how the
  computational complexity of the model-checking problem for this
  richer logic compares to that of plain  is still open.

  Our result for successor-invariant  extends previous results
  for this logic on planar graphs \cite{EngelmannKS12} and graphs with
  excluded minors \cite{ekk13}, further narrowing the gap between what
  is known for  and what is known for successor-invariant
  . The proof uses Grohe and Marx's structure theorem for graphs
  with excluded topological subgraphs \cite{gromar12+}. For
  order-invariant  we show that Gajarský et al.'s recent result
  for  carries over to order-invariant .
\end{abstract}

\maketitle



\section{Introduction}
\label{sec:intro}

Model-checking is one of the core algorithmic problems in finite model
theory: Given a sentence  in some logic  and a finite
structure , decide whether . The problem can be
generalised by allowing  to have free variables, in which
case we would like to find instances  for which , or count the number of such
instances. One important application of this is the case where
 is a database query and  the datebase to be queried. The
logic  from which  is drawn then serves as an abstract
model of the database query language.

Commonly studied logics  include first-order logic () and
monadic second-order logic (). Even for first-order logic the
model-checking problem is PSPACE complete already when restricted to
structures  with two elements. On the other hand, for every fixed
-formula , checking whether  can be
done in time polynomial in the size of . This discrepancy between
the \emph{query complexity}, i.e. the complexity depending on the size
of the query  on the one hand and the \emph{data complexity},
i.e. the complexity depending on the size of the structure , on the
other hand suggests that the complexity of model-checking problems is
best studied in the framework of \emph{parameterised
  complexity}~\cite{DowneyF98,FlumG06}.

In parameterised complexity, apart from the size  of the input
problem (commonly the length of an appropriate binary representation
of  and ) a \emph{parameter}  is introduced. For
model-checking problems the size of the input formula is a common
choice of parameter. The role of PTIME as the class of problems
commonly considered to be tractable is played by the parameterised
complexity class of \emph{fixed-parameter tractable (fpt)} problems,
i.e. problems which can be solved in time

for some computable function  and a constant . Note that the
constant  must not depend on , and indeed the model-checking
problem for first-order logic is unlikely to be fixed-parameter
tractable.

In order to obtain tractable instances of model-checking problems, one
can restrict the space of admissible input structures , e.g. by
requiring the Gaifman graph of  to possess certain graph theoretic
properties such as bounded degree or planarity. A long list of results
have been obtained, starting with Courcelle's famous result that
model-checking for monadic second-order logic is fixed-parameter
tractable on structures  with bounded
tree-width~\cite{Courcelle90}.

Results of this form are often referred to as \emph{algorithmic
  meta-theorems} because many classical problems can be rephrased as
model-checking problems by formalising them as a sentence  in
a suitable logic. For example, since the existence of a Hamiltonian
cycle in a graph  of bounded tree-width can be expressed by a
sentence  of monadic second-order logic, Courcelle's Theorem
immediately implies that hamiltonicity can be checked in polynomial
time on such graphs. Besides giving a mere proof of tractability,
algorithmic meta-theorems provide a unified treatment of how
structural properties can be used in algorithm
design. Cf.~\cite{Grohe07} and \cite{Kreutzer11} for excellent surveys
of the field of algorithmic meta-theorems.

The model-checking problem for first-order logic is particularly well
studied and has been shown to be fixed-parameter tractable on a large
number of graph classes: Starting with Seese's result~\cite{Seese96}
for graphs of bounded degree, Frick and Grohe showed tractability on
classes of graphs with bounded tree-width and, more generally, locally
bounded tree-width~\cite{FrickGro01}, which in particular includes
planar graphs. This has been generalised to graph classes with
excluded minors~\cite{FlumG01} and locally excluded
minors~\cite{DawarGroKre07}. Using rather different techniques, {Dvo\v
  r\'ak} et al. gave a linear fpt model-checking algorithm for
first-order logic on graphs of bounded
expansion~\cite{DvorakKT13}. As a generalisation of all the
graph classes mentioned so far, Grohe et al. have shown
in~\cite{gks14} that model-checking for first-order logic is possible
in near-linear fpt on all nowhere dense graph classes.

While the tractability of model-checking for first-order logic on
sparse graphs is well understood, few results are available for
classes of dense graphs. Recently, Gajarský et al. gave an fpt
algorithm for  model-checking on posets of bounded width, which
we extend to order-invariant  in Section~\ref{sec:dense}.

\subsection*{Excluded Topological Subgraphs}

A more general concept than that of a class of graphs excluding some
graph  as a minor is that of graphs which exclude  as a
\emph{topological subgraph}. This is the concept originally used by
Kuratowski in his famous result that a graph is planar if, and only
if, it does not contain  nor  as a topological subgraph
(cf. Section 4.4 in~\cite{diestel}). Recently, Grohe and Marx have
extended Robertson and Seymour's graph structure theorem to classes of
graphs excluding a fixed graph  as a topological
subgraph~\cite{gromar12+}: These graphs can be decomposed along small
separators into parts which exclude  as a minor and parts in which
all but a bounded number of vertices have small degree.

Since every topological subgraph of a graph  is also a minor of
, if a class  of graphs excludes some graph  as a
topological subgraph then it also excludes  as a minor. The
converse is not true, however, since every -regular graph excludes
 as a topological subgraph, but for every  there is a
-regular graph containing  as a minor. On the other hand,
graph classes with excluded topological subgraphs have bounded
expansion, so model-checking for first-order logic is tractable on
these classes by {Dvo\v r\'ak} et al.'s
result.

Figure~\ref{fig:sparseclasses} shows an overview of sparse graph
classes on which model-checking for first-order logic is
tractable. Note that a class  of graphs excludes some finite
graph  as a topological subgraph if, and only if, there is an  such that  excludes the clique  as a topological
subgraph.

\begin{figure}
  \begin{center}
    \resizebox{.8\textwidth}{!}{\includegraphics{classes.pdf}}
  \end{center}
  \caption{Sparse classes of graphs on which model-checking for
    first-order logic is tractable.}
  \label{fig:sparseclasses}
\end{figure}

\subsection*{Successor-Invariant Logic}

We investigate the question in how far tractability results for
first-order model-checking carry over to \emph{successor-invariant
  first-order logic}, i.e. first-order logic enriched by a binary
successor relation, restricted to formulae whose truth value does not
depend on the specific choice of successor relation. Linear
representations of an input structure  to a model-checking
algorithm usually induce some linear order on the elements of ,
and it seems natural to make this linear order (or at least its
successor relation) accessible to the query formula. This may,
however, break the structural properties of the Gaifman graph of 
needed by the model-checking algorithm.

Having access, even invariantly, to a successor relation provably
increases the expressive power of  on finite structures, as shown
in~\cite{Rossman07}. However, all known classes of structures
separating  from order-invariant or successor-invariant 
contain large cliques, and in fact on trees~\cite{BenediktS09} and on
structures of bounded tree-depth~\cite{EickmeyerEH14} even
order-invariant  has the same expressive power as plain . On
all the classes depicted in Figure~\ref{fig:sparseclasses}, this
question is still open, prompting for tractability results for
successor-invariant or even order-invariant  on these classes.

Previous work investigating the complexity of model-checking for
successor-invariant first-order logic to that of plain first-order
logic has been carried out by \cite{EngelmannKS12}, who showed
tractibility on planar graphs, and \cite{ekk13}, who showed
tractability on graph classes with excluded minors. Here we extend
these results further by generalising from excluded minors to excluded
topological subgraphs, further narrowing the gap between what is known
for first-order logic and succesor-invariant first-order logic.

Note that for first-order logic, the result of \cite{gks14} is optimal
if one restricts attention to classes of graphs which are closed under
taking subgraphs. In fact, Kreutzer has shown in~\cite{Kreutzer11}
that under the complexity theoretic assumption that , if model-checking for  on some subgraph-closed
class  of graphs is fixed-parameter tractable, then  is
nowhere dense (see also~Section~1.4 of~\cite{DvorakKT13}). Examples of
classes of graphs on which model-checking is fpt even for monadic
second-order logic but which are not nowhere dense are graphs of
bounded clique-width~\cite{CourcelleMakRot00}.


\section{Preliminaries and Notation}
\label{sec:prelim}

For a natural number  we let  denote the interval
.

\subsection{Graphs}
\label{sec:graphprelim}

We will be dealing with finite simple (i.e. loop-free and without
multiple edges) graphs, cf.~\cite{diestel,tutte} for an in-depth
introduction. Thus a \emph{graph}  consists of some finite
set  of \emph{vertices} and a set  of
\emph{edges}. We write  for . For a set  we denote the \emph{induced subgraph} on  by ,
i.e. the graph  with

For ease of notation we occasionally blur the distinction between a
set  of vertices and the subgraph induced on this set. The union  of two graphs  and  is defined as the
graph . For a set  of vertices,  denotes
the complete graph (or \emph{clique}) with vertex set . For , we denote the -clique  by .

A \emph{walk} is a sequence of vertices ,
alternatively written as a function , such that
 for all . A \emph{path} is a
walk in which  for , except possibly , in which case the path is called a \emph{cycle}. The vertices
 are called \emph{inner vertices}. Two paths
 and  are called
\emph{independent} if neither of them contains an inner vertex of the
other, i.e. if  implies  and .

For , a \emph{-walk through} a graph  is a
walk  such that 

for all .
A -walk is also called a \emph{Hamiltonian path}. 





\subsubsection*{Tree-Decompositions}

A \emph{tree} is a connected acyclic graph.
A \emph{tree-decomposition} of a graph  is a pair
 consisting of a tree  and a mapping  such that
\begin{itemize}
\item ,
\item for every edge  there is a  with , and
\item for every  the set  is a
  subtree of  (i.e. it is connected).
\end{itemize}
The sets  are called the \emph{bags} of the
tree-decomposition. Let  have neighbours
. The \emph{torso}  of
 is the graph


Rather than decomposing a graph  into small parts we are interested
in decompositions  for which (the torsos of) all bags
 have nice structural properties and for which

is small for all . The \emph{(maximal) adhesion} of
 is the maximum of  for all
.

\subsubsection*{Subgraphs, Minors, Topological Subgraphs}

Let  and  be graphs. If  and  then we call  a \emph{subgraph} of  and write . In other words,  can be obtained from  be removing
vertices and edges.

We say that  is a \emph{minor} of , written , if
there are disjoint connected nonempty subgraphs  in
 such that for every edge  there is an edge 
for some  and . The sets  are
called \emph{branch sets} of the minor . Equivalently,  if  can be obtained by repeatedly contracting edges in a
subgraph of .

A graph  is a \emph{subdivision} of a graph  if it can be
obtained from  be replacing edges with paths. If  for
some subdivision  of  we say that  is a \emph{topological
  subgraph} of  and write . In this case there is an
injective mapping  and independent paths
 connecting  to  in  for
. The vertices in the image of  are called
\emph{branch vertices}. Obviously  implies ,
but the converse is not in general true.


\subsection{Logics}
\label{sec:logicprelim}

We will be dealing with finite structures over finite, relational
vocabularies. Thus a \emph{vocabulary}  is a finite set of
relation symbols , each with an associated \emph{arity} , and
a -\emph{structure}  consists of a finite set  (the
\emph{universe}) and relations  for all . For vocabularies  and a
-structure , a -\emph{expansion}  is a
-structure with  and  for all .

The \emph{Gaifman graph} of a structure  is the graph with vertex
set  and edge set

When applying graph-theoretic notions such as planarity to relational
structures, we mean that the corresponding Gaifman graph has the said
property.

We use standard definitions for first-order logic (FO),
cf.~\cite{eft96,ebbflu99,lib04}. In particular,  and 
denote false and true, respectively. Let  be a vocabulary and
 a new binary relation symbol. We set
 and say that  is interpreted
by a \emph{successor relation} in a -structure  if
 is the graph of a cyclic permutation on . An
-formula  is called
\emph{successor-invariant} if for all -structures  and all
-expansions  of  in which  is interpreted
by a successor relation we have

when all free variables of  are interpreted identically in
 and . In this case we say that  if  for one such expansion  (equivalently for all such
expansions).

Note that another common definition of successor relation is to
require  to be of the form

for some enumeration  of the elements of
. This differs from our definition in that we require  as well, eliminating the somewhat artificial status of
the first and last element. The expressive power of
successor-invariant FO is not affected by this, though the quantifier
rank of formulas may change.

Order-invariant first-order logic is defined analogously to
successor-invariant , by allowing the use of a binary relation
 which is interpreted as a linear order and demanding the truth
value of a formula to be independent of the chosen linear order.



\section{Model-Checking for Successor-Invariant First-Order Logic}

The main result of this paper is the following:
\begin{theorem}
  \label{thm:mainthm}
  There is an algorithm  with the following properties:
  Let  be a finite graph,  a relational vocabulary,  a successor-invariant formula, and
   a -structure whose Gaifman graph does not contain  as
  a topological subgraph. Then on input ,  and  the
  algorithm  checks whether
  
  in time  for some
  computable function  and .
\end{theorem}

Note that model-checking for first-order logic on nowhere dense
classes of graphs is possible in time  for arbitrarily small  by a
result of Grohe et al.~\cite{gks14}. Even though a representation of a
structure  in computer memory is likely to induce a linear order on
the elements of , making this linear order or its successor
relation accessible to the formula  potentially complicates
the model-checking problem. In particular, adding the cycle
corresponding to this linear order (or any other cycle through the
whole graph) to  may introduce new shallow minors.

The proof of Theorem~\ref{thm:mainthm} is based on the following two lemmas:
\begin{lemma}
  \label{lem:kwalktopsub}
  For every finite graph  there are constants  and  such that for every graph  which does not contain  as a
  topological subgraph there is a graph  and a -walk  through  such that  is obtained from 
  by only adding edges and  does not contain  as a
  topological subgraph. Furthermore, , ,  and  can be
  computed, given  and , in time  for some computable function  and .
\end{lemma}
\begin{lemma}
  \label{lem:succfromkwalk}
  Let  be a finite relational vocabulary,  a finite
  -structure, and  a -walk through the
  Gaifman graph of .

  Then there is a finite relational vocabulary  and a
  first-order fomula , both depending only
  on , and a -expansion  of  which can
  be computed from  and  in polynomial time, such that
  \begin{itemize}
  \item The Gaifman-graphs of  and  are the same,
  \item  defines a successor relation on .
  \end{itemize}
\end{lemma}

Lemma~\ref{lem:succfromkwalk} is taken from~\cite[Lemma~4.4]{ekk13}
and has been proved there. We will prove Lemma~\ref{lem:kwalktopsub}
in Section~\ref{sec:kwalktopsub}. The proof of
Theorem~\ref{thm:mainthm} then is a combination of the above lemmas:
\begin{proof}[Proof of Theorem~\ref{thm:mainthm}]
  Given a -structure , a successor-invariant
  -formula  and a graph  which is
  not a topological subgraph of the Gaifman graph of , we first
  compute the Gaifman graph  of . Using the algorithm of
  Lemma~\ref{lem:kwalktopsub} we then compute a -walk  through a supergraph  of  which excludes some
  clique  as a topological subgraph.

  Let  be a binary relation symbol. We expand  to a
  -structure  by setting
  
  Then  is the Gaifman graph of , which by
  Lemma~\ref{lem:kwalktopsub} excludes  as a topological
  subgraph.

  Using Lemma~\ref{lem:succfromkwalk} we compute, for a suitable , a -expansion  of  and an
  -formula  which
  defines a successor relation on . We substitute
   for  for all
  occurences of  in , obtaining an
  -formula  such that
  
  where  the successor relation defined by
  . Note
   and  depend only on .

  Since the Gaifman graph  of  excludes  as a topological
  subgraph, there is a class  of graphs of bounded expansion
  such that . We can therefore use {Dvo\v r\'ak} et
  al.'s model-checking algorithm for  on  to check whether
  
  in time linear in .
\end{proof}

\section{-walks in Graphs with Excluded Topological Subgraphs}
\label{sec:kwalktopsub}


In this section we will prove Lemma~\ref{lem:kwalktopsub}. Given a
graph  which excludes a graph  as a topological subgraph, as a
first step towards constructing a supergraph  with a -walk we
compute a tree-decomposition of  into graphs which exclude  as a
minor and graphs of almost bounded degree:
\begin{theorem}[Theorem~4.1 in~\cite{gromar12+}]
  \label{thm:topminstructure}
  For every  there exists a constant  such
  that the following holds: If  is a a graph on  vertices and
   a graph which does not contain  as a topological subgraph, then
  there is a tree-decomposition  of  of adhesion at
  most  such that for all 
  \begin{itemize}
  \item   has at most  vertices of degree larger than
    , \emph{or}
  \item   excludes  as a minor.
  \end{itemize}
  Furthermore, there is an algorithm that, given graphs  of size
   and  of size  computes such a decomposition in time
   for some computable function .
\end{theorem}

For the rest of this section we assume a graph  together
with a tree-decomposition  satisfying the properties of
Theorem~\ref{thm:topminstructure} as given. We will construct
-walks through each of the bags of this decomposition, for a
suitable  depending only on , suitably adding edges within the
bags in a way that will not create large topological subgraphs. We
will then connect these -walks to obtain a -walk through all of
, carefully adding further edges where necessary.

If  are neighbours in  we will connect the
-walk through  and the -walk through  by
joining them along a suitably chosen vertex . Since the resulting walk may visit  a total of 
times, we must be careful not to select the same vertex  more than
a bounded number of times.

We first pick an arbitrary tree node  as the root of the
tree-decomposition. Notions such as parent and sibling nodes are meant
with respect to this root node . For a node  we define
its adhesion  as

By adding the necessary edges within the bags we may assume that each
 is identical to its torso, in other words we may assume that
 is a clique for each .

\subsection{Computing the -walks }

Let  be nodes such that  is the parent of . It may
happen that , and that in fact
some vertex  appears in an unbounded number of bags. Since we
are only allowed to visit each vertex a bounded number of times, we
first compute, for , a -walk  through a suitable
supergraph of .

If  contains only  vertices of degree larger than 
we choose an arbitrary enumeration  of
 and add edges

to . This will increase the degree of each vertex by at most ,
so there are still at most  vertices of degree larger than
. We set

for these bags.

If, on the other hand,  exludes a clique  as
a minor, we invoke the following lemma on the graph :
\begin{lemma}[Lemma~3.3 in \cite{ekk13}]
  \label{lem:kwalkexcl}
  For every natural number  there are  such that: If  is a graph which does not contain a -minor, then there
  is a supergraph  obtained from  by possibly adding
  edges such that  does not contain a -minor and there is a
  -walk  through . Moreover,  and  can be found in
  polynomial time for fixed .
\end{lemma}
Since we ignore the vertices in  when computing the
-walk , it may happen that the resulting supergraph of
 \emph{does} contain a -minor. However, the largest
possible clique minor is still of bounded size, because
:
\begin{lemma}
  Let  be a graph such that , and let  be the graph with vertex set  and edge
  set
  
  In other words,  is the disjoint sum of  and 
  plus edges between all vertices of  and all vertices of
  . Then .
\end{lemma}
\begin{proof}
  Otherwise let  be the branch sets of a
  -minor in . At most  of the sets contain
  vertices of the added -clique. The remaining sets form the
  branch sets of a -minor in , contradicting the assumption
  that .
\end{proof}

\subsection{Connecting the -walks}

We still need to connect the -walks through the individual bags of
 to obtain a single -walk through the whole graph,
for some  to be determined below. This is the most complicated
part of our construction, since we must guarantee that no vertex is
visited more than  times by the resulting walk, and that no large
topological subgraphs are created.

In the case of graphs excluding some fixed minor, the Graph Structure
Theorem guarantees the existence of a tree-decomposition into nearly
embeddable graphs such that neighbouring bags intersect only in apices
and vertices lying on some face or vortex of their near embeddings,
and this was used in~\cite{ekk13} to select vertices from the adhesion
sets of bags in a suitable way. Since the decomposition theorem for
graphs excluding a topological minor does not provide this kind of
information, we need a different approach here. Our method for
selecting vertices along which to connect the -walks relies on the
fact that sparse graphs are \emph{degenerate}, i.e. every subgraph of
a sparse graph contains some vertex of small degree.

In connecting the walks , we will proceed down the tree
. At any point in the process we keep a set 
and a walk  such that
\begin{itemize}
\item  is a connected subset of ,
\item the -walk has been constructed in ,
\item if  and  is a sibling of  then also ,
\item  is a -walk through , and if
   has a child , then the vertices in  are visited at most  times by .
\end{itemize}
We start with  and , where  is the root of
. This is easily seen to satisfy all of the above conditions.

Now let  be a node whose children  are not
in . We let

be the adhesion set of  with all vertices of the adhesion set of
 removed. If  then  can be made a sibling of
 (rather than a child), so we assume that all  are
nonempty. Since the properties of  are guaranteed for
the torsos of the bags we may assume that  is a clique for
each  and that  visits the vertices of  at most 
times.

It may happen that  for some . To deal with
this, assume that

For each  we choose an edge 
which is traversed by the walk  in the direction from 
to  at some point. We add edges

and connect the walks  along these
edges. Because  is a walk through , we have

for . To accomodate for the extra edges, we add the
vertices  and  to , and therefore to 
and . Since these vertices together with the added edges form an
isolated cycle

in , no new topological subgraphs are created by this. The
maximal adhesion of  is still bounded by .

Therefore we now assume that the cliques  are all
distinct. It remains to find a function

such that
\begin{itemize}
\item  for all , and
\item  for all  and some constant
   depending only on .
\end{itemize}

We define the function  iteratively on larger subsets of  as
follows: Let  be the subgraph of  induced on the union of
all :

We show that  contains a vertex of degree (in ) at
most , for some constant  depending only on the constant 
from Theorem~\ref{thm:topminstructure} (and therefore only on the
excluded topological subgraph  we started with). If 
contains only  vertices of degree larger than  then this is true
with . If  excludes some clique  as a minor we use
the fact that these graphs are -degenerate for some  depending
only on . In fact, by Theorem~7.2.1 in \cite{diestel} there is a
constant  such that if the average degree of  is at least
, then  and therefore .

In both cases there is a  which has degree at
most  in . But any such  can only be in at most

of the cliques , which all satisfy . It is
therefore safe to define

We remove these cliques and iterate until no cliques remain.

\begin{figure}
  \begin{center}
    \begin{picture}(0,0)\includegraphics{connect.pdf}\end{picture}\setlength{\unitlength}{4144sp}\begingroup\makeatletter\ifx\SetFigFont\undefined \gdef\SetFigFont#1#2#3#4#5{\reset@font\fontsize{#1}{#2pt}\fontfamily{#3}\fontseries{#4}\fontshape{#5}\selectfont}\fi\endgroup \begin{picture}(3589,1822)(519,827)
\put(1294,2502){\makebox(0,0)[lb]{\smash{{\SetFigFont{9}{10.8}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(769,948){\makebox(0,0)[lb]{\smash{{\SetFigFont{9}{10.8}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(1584,2117){\makebox(0,0)[lb]{\smash{{\SetFigFont{8}{9.6}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,1}}}}}}
\put(1193,1337){\makebox(0,0)[lb]{\smash{{\SetFigFont{8}{9.6}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(1256,1597){\makebox(0,0)[lb]{\smash{{\SetFigFont{9}{10.8}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(1801,1109){\makebox(0,0)[lb]{\smash{{\SetFigFont{8}{9.6}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,1}}}}}}
\put(1261,1784){\makebox(0,0)[lb]{\smash{{\SetFigFont{8}{9.6}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(3229,2502){\makebox(0,0)[lb]{\smash{{\SetFigFont{9}{10.8}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(2704,948){\makebox(0,0)[lb]{\smash{{\SetFigFont{9}{10.8}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(3519,2117){\makebox(0,0)[lb]{\smash{{\SetFigFont{8}{9.6}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,1}}}}}}
\put(3128,1337){\makebox(0,0)[lb]{\smash{{\SetFigFont{8}{9.6}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(3191,1597){\makebox(0,0)[lb]{\smash{{\SetFigFont{9}{10.8}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(3196,1784){\makebox(0,0)[lb]{\smash{{\SetFigFont{8}{9.6}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\end{picture}   \end{center}
  \caption{Connecting the individual -walks}  
  \label{fig:connect}
\end{figure}

Once the function  has been found we connect the walk  through
 with the walks  through the bags . Let  be the walk constructed so far. For each  let
 be the vertex chosen by , and let  be a neighbour of . If no such
neighbour exists it is safe to create one by adding an edge between
 and an arbitrary vertex of . We now extend the walk  by inserting the -walk
 along the edge  when  is first visited by
. This increases the number of times  and  are visited by
one each (cf. Figure~\ref{fig:connect}).

After inserting all walks  we set

and repeat the process until . Note that the resulting walk
is a -walk through the supergraph  of  obtained by
adding edges to .

\subsection{Topological Subgraphs in }

By now we have a supergraph  of , obtained by only adding
edges, and a -walk  through this
supergraph. Furthermore, there is a  depending only on
(the size of)  and a tree-decomposition  of  such
that if  then  and for
all 
\begin{itemize}
\item  has at most  vertices of degree larger
  than  or
\item  excludes  as a minor.
\end{itemize}

We show that this implies : Assume for a
contradiction that , and let 
be the branch vertices of a -subdivision in . Then there
is a  such that : Otherwise choose  and  so that

Then, since the adhesion of  is at most , there is a
set  of size at most  separating two branch
vertices, which is not possible in a -clique.

Now let  be a tree node for which  contains all
branch vertices. For , let  be the path in 
connecting  and . If all vertices on this path are in
 we are done. Otherwise we may shorten this path to get a path
 connecting  and  in the torso of . Thus


But none of the bags  can contain  as a topological
subgraph: Since  implies  which in turn implies , none of the
bags excluding  as a minor can contain  as a
topological subgraph. But if  then there must
be at least  vertices of degree at least , namely the
branch vertices of the image of a subdivision of . We
conclude that .








\section{Dense Graphs}
\label{sec:dense}

While model-checking for first-order logic has been studied rather
thoroughly for sparse graph classes, few results are known for dense
graphs:
\begin{itemize}
\item On classes of graphs with bounded clique-width (or,
  equivalently, bounded rank-width; cf.~\cite{OumSey06}),
  model-checking even for monadic second-order logic has been shown to
  be fpt by Courcelle et al.~\cite{CourcelleMakRot00}.
\item More recently, model-checking on coloured posets of bounded
  width has been shown to be in fpt for existential  by Bova et
  al.~\cite{bova2015model} and for all of  by Gajarský et
  al.~\cite{gajarsky2015fo}.
\end{itemize}

Both of these results extend to order-invariant , and therefore
also to successor-invariant . For bounded clique-width, this has
already been shown by Engelmann et
al. in~\cite[Thm.~4.2]{EngelmannKS12}. For posets of bounded width we
give a proof here. We first review the necessary definitions:
\begin{definition}
  A \emph{partially ordered set (poset)}  is a set 
  with a reflexive, transitive and antisymmetric binary relation
  . A \emph{chain}  is a totally ordered
  subset, i.e. for all  one of  and  holds. An \emph{antichain} is a set  such that if
   for  then . The \emph{width} of
   is the maximal size  of an antichain . A \emph{coloured} poset is a poset  together with a
  function  mapping  to some set 
  of \emph{colours}. By  we denote the length of a
  suitable encoding of .
\end{definition}
We will need Dilworth's Theorem, which relates the width of a poset to
the minimum number of chains needed to cover the poset:
\begin{theorem}[Dilworth's Theorem]
  Let  be a poset. Then the width of  is equal
  to the minimum number  of disjoint chains  needed to cover , i.e. such that .
\end{theorem}
A proof can be found in~\cite[Sec.~2.5]{diestel}. Moreover, by a
result of Felsner et al.~\cite{felsner2003recognition}, both the width
 and a set of chains  covering  can be computed
from  in time .

With this, we are ready to prove the following:
\begin{theorem}
  There is an algorithm which, on input a coloured poset 
  with colouring  and an order-invariant
  first-order formula , checks whether  in
  time  where  is the width of
  .
\end{theorem}
\begin{proof}
  Using the algorithm of~\cite{felsner2003recognition}, we compute a
  chain cover  of . To obtain a linear
  order on , we just need to arrange the chains in a suitable
  order, which can be done by colouring the vertices with colours
   via
  
  Then
  
  defines a linear order on  with colouring
  . After substituting  for  in
   we may apply Gajarský et al.'s algorithm to check whether
  .
\end{proof}


\section*{Conclusion and Further Research}

We have shown that model-checking for successor-invariant first-order
logic is fixed-parameter tractable on classes of graphs excluding some
fixed graph  as a topological subgraph. This extends previous
results showing tractibility on planar graphs~\cite{EngelmannKS12} and
graphs with excluded minors~\cite{ekk13}. For dense graphs, we showed
how the recent model-checking algorithm by Gajarský et
al.~\cite{gajarsky2015fo} can be adapted to order-invariant .

This prompts for further generalisation in two ways: First, can we
close the gap between plain first-order logic and its
successor-invariant counterpart? Next steps could be graph classes
with bounded expansion or with locally excluded minors. However, no
structure theorem comparable to those of Robertson and Seymour and of
Grohe and Marx are known for these graph classes.

Another interesting open question is whether model-checking for
order-invariant first-order logic is tractable on any of the classes
depicted in Figure~\ref{fig:sparseclasses}. Since the Gaifman graph of
a linearly ordered structure is a clique, there is no hope of finding
a ``good'' linear order which can be added to the input structure
without destroying the desirable properties of its Gaifman graph. As
shown in~\cite{GroheS00}, order-invariant first-order logic has a
Gaifman-style locality property (see also~\cite{AndersonMSS12}). It
is, however, not at all clear how this could be turned into an
efficient model-checking algorithm. In particular, no variant of
Gaifman normal form is known for this logic.

\begin{thebibliography}{10}

\bibitem{AndersonMSS12}
Matthew Anderson, Dieter van Melkebeek, Nicole Schweikardt, and Luc Segoufin.
\newblock Locality from circuit lower bounds.
\newblock {\em {SIAM} J. Comput.}, 41(6):1481--1523, 2012.

\bibitem{BenediktS09}
Michael Benedikt and Luc Segoufin.
\newblock Towards a characterization of order-invariant queries over tame
  graphs.
\newblock {\em J. Symb. Log.}, 74(1):168--186, 2009.

\bibitem{bova2015model}
Simone Bova, Robert Ganian, and Stefan Szeider.
\newblock Model checking existential logic on partially ordered sets.
\newblock {\em ACM Transactions on Computational Logic (TOCL)}, 17(2):10, 2015.

\bibitem{Courcelle90}
Bruno Courcelle.
\newblock Graph rewriting: An algebraic and logic approach.
\newblock In J.~{van Leeuwen}, editor, {\em Handbook of Theoretical Computer
  Science}, volume~2, pages 194 -- 242. Elsevier, 1990.

\bibitem{CourcelleMakRot00}
Bruno Courcelle, Johann Makowsky, and Udi Rotics.
\newblock Linear time solvable optimization problems on graphs of bounded
  clique-width.
\newblock {\em Theory of Computing Systems}, 33(2):125--150, 2000.

\bibitem{DawarGroKre07}
Anuj Dawar, Martin Grohe, and Stephan Kreutzer.
\newblock Locally excluding a minor.
\newblock In {\em Logic in Computer Science (LICS)}, pages 270--279, 2007.

\bibitem{diestel}
Reinhard Diestel.
\newblock {\em Graph Theory}.
\newblock Number 173 in GTM. Springer, 4th edition, 2012.

\bibitem{DowneyF98}
Rod Downey and Michael~R. Fellows.
\newblock {\em Parameterized Complexity}.
\newblock Springer, 1998.

\bibitem{DvorakKT13}
Zden{\v{e}}k Dvo{\v{r}}{\'a}k, Daniel Kr{\'a}l, and Robin Thomas.
\newblock Testing first-order properties for subclasses of sparse graphs.
\newblock {\em Journal of the ACM (JACM)}, 60(5):36, 2013.

\bibitem{ebbflu99}
Heinz-Dieter Ebbinghaus and Jörg Flum.
\newblock {\em Finite Model Theory}.
\newblock Perspectives in Mathematical Logic. Springer, 2nd edition, 1999.

\bibitem{eft96}
Heinz-Dieter Ebbinghaus, Jörg Flum, and Wolfgang Thomas.
\newblock {\em Mathematical Logic}.
\newblock Springer, 2nd edition, 1994.

\bibitem{EickmeyerEH14}
Kord Eickmeyer, Michael Elberfeld, and Frederik Harwath.
\newblock Expressivity and succinctness of order-invariant logics on
  depth-bounded structures.
\newblock In {\em Mathematical Foundations of Computer Science 2014 - 39th
  International Symposium, {MFCS} 2014, Budapest, Hungary, August 25-29, 2014.
  Proceedings, Part {I}}, pages 256--266, 2014.

\bibitem{ekk13}
Kord Eickmeyer, Ken-Ichi Kawarabayashi, and Stephan Kreutzer.
\newblock Model checking for successor-invariant first-order logic on
  minor-closed graph classes.
\newblock In {\em Proceedings of the 2013 28th Annual ACM/IEEE Symposium on
  Logic in Computer Science}, LICS '13, pages 134--142. IEEE Computer Society,
  2013.

\bibitem{EngelmannKS12}
Viktor Engelmann, Stephan Kreutzer, and Sebastian Siebertz.
\newblock First-order and monadic second-order model-checking on ordered
  structures.
\newblock In {\em Logics in Computer Science}, pages 275--284, 2012.

\bibitem{felsner2003recognition}
Stefan Felsner, Vijay Raghavan, and Jeremy Spinrad.
\newblock Recognition algorithms for orders of small width and graphs of small
  dilworth number.
\newblock {\em Order}, 20(4):351--364, 2003.

\bibitem{FlumG01}
J{\"o}rg Flum and Martin Grohe.
\newblock Fixed-parameter tractability, definability, and model-checking.
\newblock {\em SIAM J. Comput.}, 31(1):113--145, 2001.

\bibitem{FlumG06}
Jörg Flum and Martin Grohe.
\newblock {\em Parameterized Complexity Theory}.
\newblock Springer, 2006.
\newblock ISBN 3-54-029952-1.

\bibitem{FrickGro01}
Markus Frick and Martin Grohe.
\newblock Deciding first-order properties of locally tree-decomposable
  structures.
\newblock {\em Journal of the ACM}, 48:1148 -- 1206, 2001.

\bibitem{gajarsky2015fo}
Jakub Gajarský, Petr Hliněný, Daniel Lokshtanov, Jan Obdržálek, Sebastian
  Ordyniak, MS~Ramanujan, and Saket Saurabh.
\newblock Fo model checking on posets of bounded width.
\newblock In {\em Foundations of Computer Science (FOCS), 2015 IEEE 56th Annual
  Symposium on}, pages 963--974. IEEE, 2015.

\bibitem{Grohe07}
Martin Grohe.
\newblock Logic, graphs, and algorithms.
\newblock In E.Gr{\"a}del~T.Wilke J.Flum, editor, {\em Logic and Automata --
  History and Perspectives}. Amsterdam University Press, 2007.

\bibitem{gks14}
Martin Grohe, Stephan Kreutzer, and Sebastian Siebertz.
\newblock Deciding first-order properties of nowhere dense graphs.
\newblock In {\em Proceedings of the 46th Annual ACM Symposium on Theory of
  Computing}, STOC '14, pages 89--98. ACM, 2014.

\bibitem{gromar12+}
Martin Grohe and Dániel Marx.
\newblock Structure theorem and isomorphism test for graphs with excluded
  topological subgraphs.
\newblock {\em SIAM Journal on Computing}, 44(1):114--159, 2015.

\bibitem{GroheS00}
Martin Grohe and Thomas Schwentick.
\newblock Locality of order-invariant first-order formulas.
\newblock {\em ACM Trans. Comput. Logic}, 1(1):112--130, July 2000.

\bibitem{Kreutzer11}
Stephan Kreutzer.
\newblock Algorithmic meta-theorems.
\newblock In Javier Esparza, Christian Michaux, and Charles Steinhorn, editors,
  {\em Finite and Algorithmic Model Theory}, London Mathematical Society
  Lecture Note Series, chapter~5, pages 177--270. Cambridge University Press,
  2011.
\newblock a preliminary version is available at Electronic Colloquium on
  Computational Complexity (ECCC), TR09-147,
  http://www.eccc.uni-trier.de/report/2009/147.

\bibitem{lib04}
Leonid Libkin.
\newblock {\em Elements of Finite Model Theory}.
\newblock Texts in Theoretical Computer Science. Spinger-Verlag, 2004.

\bibitem{OumSey06}
Sang-Il Oum and Paul~D. Seymour.
\newblock Approximating clique-width and branch-width.
\newblock {\em Journal of Combinatorial Theory, Series B}, 96:514 -- 528, 2006.

\bibitem{Rossman07}
Benjamin Rossman.
\newblock Successor-invariant first-order logic on finite structures.
\newblock {\em J. Symb. Log.}, 72(2):601--618, 2007.

\bibitem{Seese96}
Detlef Seese.
\newblock Linear time computable problems and first-order descriptions.
\newblock {\em Mathematical {S}tructures in Computer Science}, 5:505--526,
  1996.

\bibitem{tutte}
William~T. Tutte.
\newblock {\em Graph Theory}, volume~21 of {\em Encyclopedia of Mathematics and
  Its Applications}.
\newblock Cambridge University Press, 2001.

\end{thebibliography}

\end{document}
