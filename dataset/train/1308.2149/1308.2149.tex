\documentclass[11pt,fleqn]{article}

\usepackage{latexsym}
\usepackage{amssymb}
\usepackage{stmaryrd}
\usepackage{phonetic}
\usepackage{pgf}
\usepackage{tikz}
\usepackage{url}
\usetikzlibrary{arrows}



\renewcommand{\labelenumi}{(\theenumi)}
\newcommand{\be}{\begin{enumerate}}
\newcommand{\ee}{\end{enumerate}}
\newcommand{\bi}{\begin{itemize}}
\newcommand{\ei}{\end{itemize}}
\newcommand{\bc}{\begin{center}}
\newcommand{\ec}{\end{center}}
\newcommand{\bsp}{\begin{sloppypar}}
\newcommand{\esp}{\end{sloppypar}}

\newcommand{\sglsp}{\ }
\newcommand{\dblsp}{\ \ }

\newcommand{\sA}{\mbox{}}
\newcommand{\sB}{\mbox{}}
\newcommand{\sC}{\mbox{}}
\newcommand{\sD}{\mbox{}}
\newcommand{\sE}{\mbox{}}
\newcommand{\sF}{\mbox{}}
\newcommand{\sG}{\mbox{}}
\newcommand{\sH}{\mbox{}}
\newcommand{\sI}{\mbox{}}
\newcommand{\sJ}{\mbox{}}
\newcommand{\sK}{\mbox{}}
\newcommand{\sL}{\mbox{}}
\newcommand{\sM}{\mbox{}}
\newcommand{\sN}{\mbox{}}
\newcommand{\sO}{\mbox{}}
\newcommand{\sP}{\mbox{}}
\newcommand{\sQ}{\mbox{}}
\newcommand{\sR}{\mbox{}}
\newcommand{\sS}{\mbox{}}
\newcommand{\sT}{\mbox{}}
\newcommand{\sU}{\mbox{}}
\newcommand{\sV}{\mbox{}}
\newcommand{\sW}{\mbox{}}
\newcommand{\sX}{\mbox{}}
\newcommand{\sY}{\mbox{}}
\newcommand{\sZ}{\mbox{}}

\renewcommand{\phi}{\varphi}
\newcommand{\seq}[1]{{\langle #1 \rangle}}
\newcommand{\set}[1]{{\{ #1 \}}}
\newcommand{\tuple}[1]{{( #1 )}}
\newcommand{\mlist}[1]{{[ #1 ]}}
\newcommand{\sembrack}[1]{\llbracket#1\rrbracket}
\newcommand{\synbrack}[1]{\ulcorner#1\urcorner}
\newcommand{\commabrack}[1]{\lfloor#1\rfloor}
\newcommand{\bsynbrack}[1]{\lceil#1\rceil}
\newcommand{\bsembrack}[1]{\lceil\!\!\lceil#1\rceil\!\!\rceil}
\newcommand{\mname}[1]{\mbox{\sf #1}}
\newcommand{\mcolon}{\mathrel:}
\newcommand{\mdot}{\mathrel.}
\newcommand{\modpar}{\models_{\rm par}}
\newcommand{\modreg}{\models_{\rm reg}}
\newcommand{\proves}[2]{#1 \vdash #2}
\newcommand{\notproves}[2]{#1 \not\vdash #2}
\newcommand{\provesin}[3]{#1 \vdash_{#2} #3}
\newcommand{\notprovesin}[3]{#1 \not\vdash_{#2} #3}
\newcommand{\parrow}{\rightharpoonup}
\newcommand{\tarrow}{\rightarrow}
\newcommand{\term}{\seq}
\newcommand{\lub}{\sqcup}
\newcommand{\subfun}{\sqsubseteq}
\newcommand{\subpred}{\subseteq}
\newcommand{\BoxApp}{\Box\,}
\newcommand{\BOX}{\mathrel{\Box}}
\newcommand{\StarApp}{\star\,}

\newcommand{\com}{\mname{complement}}
\newcommand{\dom}{\mname{domain}}
\newcommand{\sumcl}{\mname{sum}}
\newcommand{\pow}{\mname{power}}
\newcommand{\pair}{\mname{pair}}
\newcommand{\opair}{\mname{ordered-pair}}
\newcommand{\inters}{\mname{intersection}}
\newcommand{\emp}{\mname{empty}}
\newcommand{\uni}{\mname{univocal}}
\newcommand{\fun}{\mname{function}}
\newcommand{\card}{\mname{card}}
\newcommand{\sets}{\mname{sets}}
\newcommand{\monotone}{\mname{monotone}}
\newcommand{\continuous}{\mname{continuous}}
\newcommand{\chain}{\mname{chain}}
\newcommand{\mub}{\mname{ub}}
\newcommand{\mlub}{\mname{lub}}
\newcommand{\fixedpoint}{\mname{fp}}
\newcommand{\leastfixedpoint}{\mname{lfp}}
\newcommand{\strongfixedpoint}{\mname{sfp}}
\newcommand{\emptyfun}{\triangle}
\newcommand{\emptylist}{[\,]}

\newcommand{\Iota}{\mbox{\rm I}}
\newcommand{\IotaApp}{\mbox{\rm I}\,}
\newcommand{\iotaApp}{\iota\,}
\newcommand{\invertediota}{\rotatebox[origin=c]{180}{}}
\newcommand{\Epsilon}{\mbox{\rm E}}
\newcommand{\EpsilonApp}{\mbox{\rm E}\,}
\newcommand{\epsilonApp}{\epsilon\,}
\newcommand{\True}{\mbox{\sf T}} 
\newcommand{\False}{\mbox{\sf F}} 
\newcommand{\Trueword}{\sf true}
\newcommand{\Falseword}{\sf false}
\newcommand{\Neg}{\neg} 
\newcommand{\And}{\wedge}
\newcommand{\AND}{\mathrel\&}
\newcommand{\Or}{\vee}
\newcommand{\Implies}{\supset}
\newcommand{\ImpliesAlt}{\Rightarrow}
\newcommand{\Iff}{\equiv}
\newcommand{\IffAlt}{\Leftrightarrow}
\newcommand{\Sheffer}{\mathrel|}
\newcommand{\Forall}{\forall}
\newcommand{\ForallApp}{\forall\,}
\newcommand{\Forsome}{\exists}
\newcommand{\ForsomeApp}{\exists\,}
\newcommand{\ForsomeUniqueApp}{\exists\,!\,}
\newcommand{\IsDef}{\downarrow}
\newcommand{\IsUndef}{\uparrow}
\newcommand{\Equal}{=}
\newcommand{\QuasiEqual}{\simeq}
\newcommand{\Undefined}{\bot}
\newcommand{\If}{\mname{if}}
\newcommand{\IsDefApp}{\!\IsDef}
\newcommand{\IsUndefApp}{\!\IsUndef}
\newcommand{\TRUE}{\mbox{{\sc t}}}
\newcommand{\FALSE}{\mbox{{\sc f}}}
\newcommand{\truthvalues}{\{\TRUE,\FALSE\}}
\newcommand{\LambdaApp}{\lambda\,}
\newcommand{\LAMBDAapp}{\Lambda\,}
\newcommand{\PiApp}{\Pi\,}
\newcommand{\SetAbs}{\mbox{\rm S}}
\newcommand{\SetAbsApp}{\mbox{\rm S}\,}
\newcommand{\ClassAbs}{\mbox{\sc C}}
\newcommand{\ClassAbsApp}{\mbox{\sc C}\,}
\newcommand{\funapp}{\mathrel@}

\newcommand{\mterm}[2]{\textbf{term}_{#1}[#2]}
\newcommand{\mterma}[3]{\textbf{term}_{#1}[#2,#3]}
\newcommand{\mform}[2]{\textbf{form}_{#1}[#2]}
\newcommand{\mforma}[3]{\textbf{form}_{#1}[#2,#3]}
\newcommand{\mkind}[2]{\textbf{kind}_{#1}[#2]}
\newcommand{\mtype}[2]{\textbf{type}_{#1}[#2]}
\newcommand{\mtypea}[3]{\textbf{type}_{#1}[#2,#3]}
\newcommand{\mvar}[3]{\textbf{var}_{#1}[#2,#3]}
\newcommand{\mexpr}[3]{\textbf{expr}_{#1}[#2,#3]}
\newcommand{\mexpra}[2]{\textbf{expr}_{#1}[#2]}
\newcommand{\mins}[3]{\textbf{ins}_{#1}[#2,#3]}

\iffalse
\newcommand{\mvar}[3]{\textbf{var}_{#1}(#2,#3)}
\newcommand{\mterm}[3]{\textbf{term}_{#1}(#2,#3)}
\newcommand{\mform}[2]{\textbf{form}_{#1}(#2)}
\newcommand{\mtype}[2]{\textbf{type}_{#1}(#2)}
\newcommand{\mexpr}[3]{\textbf{expr}_{#1}(#2,#3)}
\fi

\newcommand{\imps}{\mbox{\sc imps}}
\newcommand{\fol}{\mbox{\sc fol}}
\newcommand{\lutins}{\mbox{\sc lutins}}
\newcommand{\bestt}{\mbox{\sc bestt}}
\newcommand{\stt}{\mbox{\sc stt}}
\newcommand{\sttwu}{\mbox{{\sc stt}{\small w}{\sc u}}}
\newcommand{\sttws}{\mbox{{\sc stt}{\small w}{\sc s}}}
\newcommand{\vlisp}{\mbox{\sc vlisp}}
\newcommand{\vmach}{\mbox{\sc vmach}}
\newcommand{\gnu}{\mbox{\sc gnu}}
\newcommand{\ml}{\mbox{\sc ml}}
\newcommand{\zf}{\mbox{\sc zf}}
\newcommand{\nbg}{\mbox{\sc nbg}}
\newcommand{\pnbg}{\mbox{\sc pnbg}}
\newcommand{\snbg}{\mbox{\sc snbg}}
\newcommand{\pfol}{\mbox{\sc pfol}}
\newcommand{\nbgstar}{}
\newcommand{\boldnbgstar}{}

\newcommand{\eves}{\mbox{\sc eves}}
\newcommand{\hol}{\mbox{\sc hol}}
\newcommand{\mizar}{Mizar}
\newcommand{\nqthm}{Nqthm}
\newcommand{\pvs}{\mbox{\sc pvs}}
\newcommand{\stmm}{\mbox{\sc stmm}}
\newcommand{\stmmstar}{}
\newcommand{\ehdm}{\mbox{\sc ehdm}}
\newcommand{\obj}{\mbox{\sc obj}3}
\newcommand{\iotasys}{\mbox{\sc iota}}
\newcommand{\kids}{\mbox{\sc kids}}
\newcommand{\cstt}{\mbox{\sc cstt}}
\newcommand{\tps}{\mbox{\sc tps}}
\newcommand{\lego}{\mbox{\sc lego}}
\newcommand{\Blang}{\mbox{\sc b}}
\newcommand{\zed}{\mbox{\sc z}}
\newcommand{\vdm}{\mbox{\sc vdm}}
\newcommand{\vdmsl}{\mbox{\sc vdm-sl}}
\newcommand{\bee}{\mbox{\sc b}}

\newtheorem{theorem}{Theorem}
\newtheorem{corollary}{Corollary}
\newtheorem{lemma}{Lemma}
\newtheorem{proposition}{Proposition}
\newtheorem{remark}{Remark}
\newtheorem{example}{Example}
\newtheorem{definition}{Definition}
\newtheorem{axschemas}{Axiom Schemas}
\newtheorem{infrule}{Rule}
\newtheorem{infrules}{Rules}
\newtheorem{requirement}{Requirement}
\newtheorem{designelt}{Design Element}

\newtheorem{thm}{Theorem}[subsection]
\newtheorem{cor}[thm]{Corollary}
\newtheorem{lem}[thm]{Lemma}
\newtheorem{prop}[thm]{Proposition}
\newtheorem{rem}[thm]{Remark}
\newtheorem{eg}[thm]{Example}
\newtheorem{df}[thm]{Definition}

\newenvironment{proof}{\par\noindent{\bf Proof\dblsp}}{\hfill}

\newenvironment{namedform}[1]
   {\begin{tabbing}\textbf{#1}\ } {\end{tabbing}}

\newcommand{\urlpart}[1]{\mbox{\texttt{#1}}\linebreak[0]}

\newcommand{\Dv}{D_{\rm v}}
\newcommand{\Dc}{D_{\rm c}}
\newcommand{\Ds}{D_{\rm s}}
 
\renewcommand{\labelenumi}{\theenumi.}
\renewcommand{\labelenumii}{\theenumii.}

\title{{\bf Frameworks for Reasoning about Syntax that Utilize Quotation
  and Evaluation}\thanks{This research was supported by NSERC.}}

\author{William M. Farmer and Pouya Larjani\thanks{Address:
  Department of Computing and Software, McMaster University 1280 Main
  Street West, Hamilton, Ontario L8S 4K1, Canada. E-mail:
  \texttt{wmfarmer@mcmaster.ca}, \texttt{pouya.larjani@gmail.com}.}}

\date{24 June 2014}

\begin{document}

\maketitle

\begin{abstract}
It is often useful, if not necessary, to reason about the syntactic
structure of an expression in an interpreted language (i.e., a
language with a semantics).  This paper introduces a mathematical
structure called a \emph{syntax framework} that is intended to be an
abstract model of a system for reasoning about the syntax of an
interpreted language.  Like many concrete systems for reasoning about
syntax, a syntax framework contains a mapping of expressions in the
interpreted language to syntactic values that represent the syntactic
structures of the expressions; a language for reasoning about the
syntactic values; a mechanism called \emph{quotation} to refer to the
syntactic value of an expression; and a mechanism called
\emph{evaluation} to refer to the value of the expression represented
by a syntactic value.  A syntax framework provides a basis for
integrating reasoning about the syntax of the expressions with
reasoning about what the expressions mean.  The notion of a syntax
framework is used to discuss how quotation and evaluation can be built
into a language and to define what quasiquotation is.  Several
examples of syntax frameworks are presented.
\end{abstract}

\iffalse
\begin{keywords}
formal mathematics \sep
reasoning about syntax \sep
formal languages \sep
quotation \sep
evaluation \sep
quasiquotation
\end{keywords}
\fi

\newpage

\section{Introduction} \label{sec:intro}

Every calculus student knows that computing the derivative of a
function directly from the definition is an excruciating task, while
computing the derivative using the rules of differentiation is a
pleasure.  A differentiation rule is a function, but not a usual
function like the square root function or the limit of a sequence
operator.  Instead of mapping a function to its derivative, it maps
one syntactic representation of a function to another.  For example,
the \emph{product rule} maps an expression of the
form  where  and  are expressions
that may include occurrences of , to the
expression 

We call a mapping, like a differentiation rule, that takes one
syntactic expression to another syntactic expression a
\emph{transformer}~\cite{FarmerMohrenschildt03}.  A full formalization
of calculus requires a reasoning system in which (1) the derivative of
a function can be defined, (2) the differentiation rules can be
represented as transformers, and (3) the transformers representing the
differentiation rules can be shown to compute derivatives.  Such a
reasoning system must provide the means to reason about the syntactic
manipulation of expressions as well as the connection these
manipulations have to the semantics of the expressions.  In other
words, the reasoning system must allow one to reason about syntax and
its relationship to semantics.  See \cite{Farmer13} for a detailed
discussion about the formalization of symbolic differentiation and
other syntax-based mathematical algorithms.

An \emph{interpreted language} is a language  such that each
expression  in  is mapped to a \emph{semantic value} that serves
as the meaning of .  What facilities does a reasoning system need
for reasoning about the interplay of the syntax and semantics of an
interpreted language ?  Here are four candidates:

\be

  \item A set of \emph{syntactic values} that represent the syntactic
    structures of the expressions in .

  \item \bsp A language for expressing statements about syntactic
    values and thereby indirectly about the syntactic structures of
    the expressions in .\esp

  \item A mechanism called \emph{quotation} for referring to the
    syntactic value that represents a given expression in .

  \item A mechanism called \emph{evaluation} for referring to the
    semantic value of the expression whose syntactic structure is
    represented by a given syntactic value.

\ee 
Quotation and evaluation together provide the means to integrate
reasoning about the syntax of the expressions with reasoning about
what the expressions mean.

This paper has three objectives.  The first objective is to introduce a
mathematical structure called a \emph{syntax framework} that is
intended to be an abstract model of a system for reasoning about the
syntax of an interpreted language.  A syntax framework for an
interpreted language  contains four components corresponding to the
four facilities mentioned just above:

\be

  \item A function called a \emph{syntax representation} that maps
    each expression  in  to a \emph{syntactic value} that
    represents the syntactic structure of .

  \item A language called a \emph{syntax language} whose expressions
    denote syntactic values.  

  \item A \emph{quotation} function that maps an expression  in 
    to an expression in the syntax language that denotes the syntactic
    value of .

  \item An \emph{evaluation} function that maps an expression  in
    the syntax language to an expression in  whose semantic value
    is the same as that of the expression in  whose syntactic value
    is denoted by .

\ee

The second objective is to demonstrate that a syntax framework has the
ingredients needed for reasoning effectively about syntax.  We discuss
the benefits of a syntax framework for reasoning about syntax and
particularly for reasoning about transformers like the differentiation
rules.  We explain how the liar paradox can be avoided when quotation
and evaluation are built-in operators.  And we define in a syntax
framework a notion of quasiquotation which greatly facilitates
constructing expressions that denote syntactic values.

The third objective is to show that the notion of a syntax framework
embodies a common structure that is found in a variety of systems for
reasoning about the interplay of syntax and semantics.  In particular,
we show that the standard systems in which syntactic structure is
represented by strings, G\"odel numbers, and members of an inductive
type are instances of a syntax framework.  We also show that several
more sophisticated systems from the literature, including a simplified
version of Lisp, can be viewed as syntax frameworks.

\emph{Reflection} is a technique to embed reasoning about a reasoning
system (i.e., metareasoning) in the reasoning system itself.
Reflection has been employed in logic~\cite{Koellner09}, theorem
proving~\cite{Harrison95}, and programming~\cite{DemersMalenfant95}.
Since metareasoning very often involves the syntactic manipulation of
expressions, a syntax framework is a natural subcomponent of a
reflection mechanism.

\iffalse
The ideas underlying our notion of a syntax framework are not deep,
but they tend to be confusing since they deal with the interplay of
syntax and semantics.  This confusion is well known to programmers who
are trying to sort out the meanings of \texttt{quote} and
\texttt{eval} in Lisp.  Our objective is to explicate what quotation
and evaluation are and how they interact.  We believe that these ideas
are useful in both logic and programming.  Most of the paper is
devoted to examples and definitions, but some applications of syntax
frameworks are briefly discussed.
\fi

The rest of the paper is organized as follow.  The next section,
section~\ref{sec:syn-frame}, defines the notion of a syntax framework
and discusses it benefits.  Section~\ref{sec:examples} presents three
standard syntax reasoning systems that are instances of a syntax
framework.  Section~\ref{sec:built-in} discusses built-in operators
for quotation and evaluation as found in Lisp and other languages and
explains how the liar paradox is avoided in a syntax framework.
Section~\ref{sec:quasiquotation} defines a notion of quasiquotation in
a syntax framework.  Section~\ref{sec:literature} identifies some
sophisticated syntax reasoning systems in the literature that are
instances of a syntax framework.  The paper ends with a conclusion in
section~\ref{sec:conclusion}.

\section{Syntax Frameworks} \label{sec:syn-frame}

In this section we will define a mathematical structure called a
\emph{syntax framework}.  In the subsequent sections we will give
several examples of syntax reasoning systems that can be interpreted
as instances of this structure.

The reader should note that the notion of a syntax framework presented
here is not adequate to interpret syntax reasoning systems, such as
programming languages, that contain context-sensitive expressions
(such as mutable variables).  To interpret these kinds of systems, a
syntax framework must be extended to a \emph{contextual syntax
  framework} that includes mutable contexts.  For further discussion,
see Remark~\ref{rem:contextual}.

\subsection{Interpreted Languages} \label{subsec:inter-lang}

Let a \emph{formal language} be a set of expressions each having a
unique mathematically precise syntactic structure.  We will leave
``expression'' and ``mathematically precise syntactic structure''
unspecified.  A formal language  is a \emph{sublanguage} of a
formal language  if .

An interpreted language is a formal language with a semantics:

\begin{df}[Interpreted Language] \label{df:interp-lang} \em \bsp
An \emph{interpreted language} is a triple  where: 

\be

  \item  is a formal language.

  \item  is a nonempty domain (set) of \emph{semantic
    values}.

  \item  is a total function,
    called a \emph{semantic valuation function}, that assigns each
    expression  a semantic value . \hfill 

\ee 
\esp
\end{df}
An interpreted language is thus a formal language with an associated
assignment of a semantic meaning to each expression in the language.
Each expression of an interpreted language thus has both a syntactic
structure and a semantic meaning.  There is no restriction placed on
what can be a semantic value.  An interpreted language is graphically
depicted in Figure~\ref{fig:interp-lang} (we will add elements to this
figure as the discussion advances).

\begin{figure}
\center
\begin{tikzpicture}[scale=.75]
\draw[very thick] (-3,0) circle (3);
    \draw (-5.5,0) node {\Large };
  \draw[very thick] (7,0) circle (3.5);
    \draw (4.4,0) node {\Large };
  \draw[-triangle 45] (-3,3) .. controls (-1,5) and (5,5.5) .. (7,3.5);
    \draw[right] (2.5,5.2) node {\Large };
\end{tikzpicture}
\caption{An Interpreted Language}  \label{fig:interp-lang}
\end{figure}

\begin{eg}[Many-Sorted First-Order Languages] \label{eg:ms-fol} \em
\bsp Let  be the set of the terms and formulas of a many-sorted
first-order language with sorts .  Define
 to be the set of terms of sort  for each  with  and  to be the set of formulas of the
many-sorted first-order language. \esp

Let  be a model for the many-sorted first-order
language  where each  is a nonempty domain and  is an
interpretation function for the individual constants, function
symbols, and predicate symbols of .  Let  be a mapping from
the variables in  to  for each  with .
The model  and variable assignments
 determine a semantic valuation function  on terms of sort  for each  with  and a semantic valuation function  on formulas.  Then  is an interpreted language. \hfill 
\end{eg}

\subsection{Syntax Representations and Syntax Languages}

A syntax representation of a formal language is an assignment of
syntactic values to the expressions of the language:

\begin{df}[Syntax Representation] \label{df:syn-rep} \em \bsp
Let  be a formal language. A \emph{syntax representation} of  is
a pair  where:

\be

  \item  is a nonempty domain (set) of \emph{syntactic
    values}.  Each member of  represents a syntactic
    structure.

  \item  is an injective, total
    function, called a \emph{syntactic valuation function}, that
    assigns each expression  a syntactic value  such that  represents
    the syntactic structure of . \hfill 

\ee 
\esp
\end{df}
A syntax representation of a formal language is thus an assignment of
a syntactic meaning to each expression in the language.  Notice that,
if  is a syntax representation of ,
then  is an interpreted language.

\begin{eg}[Expressions as Strings: Syntax Representation] \label{eg:strings-a} \em \bsp
Let  be a many-sorted first-order language.  The expressions of 
--- i.e.,~the terms and formulas of  --- can be viewed as certain
strings of symbols.  For example, the term  can be viewed as the
string \texttt{"f(x)"} composed of four symbols.  Let  be the
alphabet of symbols occurring in the expressions of  and
 be the set of strings over .  Then the
syntactic structure of an expression can be represented by a string in
, and we can define a function  that maps each expression of  to
the string over  that represents its syntactic structure.   is
an injective, total function since, for each , there is
exactly one string in  that represents the
syntactic structure of .  Therefore,  is a syntax representation of . \hfill  \esp
\end{eg}

A syntax language for a syntax representation is a language of
expressions that denote syntactic values in the syntax representation:

\begin{df}[Syntax Language] \label{df:syn-lang} \em \bsp
Let  be a syntax representation of a
formal language .  A \emph{syntax language} for  is a pair
 where:

\be

  \item  in an interpreted language.

  \item , , and
    .

  \item  restricted to  is a total function
    . \hfill 

\ee
\esp
\end{df}
Notice that, if  is a syntax language for  (as
in the definition above), then  is an
interpreted language.

\begin{eg}[Expressions as Strings: Syntax Language] \label{eg:strings-b} \em
\bsp Let  where  and  be the interpreted language given in Example~\ref{eg:ms-fol}.
Recall that  is the set of terms and formulas of a many-sorted
first-order language with sorts .  Suppose
, ,  is the
alphabet of , and  is the set of strings over .  Let  be the total function that maps each  to the
string in  that represents the syntactic structure of .  Then
 is a syntax representation of  as in
Example~\ref{eg:strings-a} and  is a syntax language for 
since , , and  restricted to
 is . \hfill  \esp
\end{eg}

\subsection{Definition of a Syntax Framework} \label{subsec:frameworks}

A syntax framework is a structure that is built from an interpreted
language  in three stages.  

The first stage is to choose an object language  and a syntax representation  for
 such that .  ( could be the entire language  as in
Example~\ref{eg:strings-a}.)  This first stage is depicted in
Figure~\ref{fig:syn-frame-stage-1}.

\begin{figure}
\center
\begin{tikzpicture}[scale=.75]
\draw[very thick] (-3,0) circle (3);
    \draw (-5.5,0) node {\Large };
  \draw[very thick] (-4,1) circle (1);
    \draw (-4,1) node {\Large };
  \draw[very thick] (7,0) circle (3.5);
    \draw (4.4,0) node {\Large };
  \draw[very thick] (8,-1) circle (1.5);
    \draw (8,-1) node {\Large };
  \draw[-triangle 45] (-3,3) .. controls (-1,5) and (5,5.5) .. (7,3.5);
    \draw[right] (2.5,5.2) node {\Large };
  \draw[-triangle 45] (-4,2) .. controls (-1,4) and (5,5) .. (8,.5);
    \draw[right] (2.5,4) node {\Large };
\end{tikzpicture}
\caption{Stage 1 of a Syntax Framework}  \label{fig:syn-frame-stage-1}
\end{figure}

The second stage is to choose a language 
such that  is a syntax language for .  This second
stage, depicted in Figure~\ref{fig:syn-frame-stage-2}, establishes
 as a language that can be used to make statements in 
about the syntax of the object language  via the syntax
representation established in the stage 1.  ( is  restricted to .)

\begin{figure}
\center
\begin{tikzpicture}[scale=.75]
\draw[very thick] (-3,0) circle (3);
    \draw (-5.5,0) node {\Large };
  \draw[very thick] (-4,1) circle (1);
    \draw (-4,1) node {\Large };
  \draw[very thick] (-2,-1) circle (1);
    \draw (-2,-1) node {\Large };
  \draw[very thick] (7,0) circle (3.5);
    \draw (4.4,0) node {\Large };
  \draw[very thick] (8,-1) circle (1.5);
    \draw (8,-1) node {\Large };
  \draw[-triangle 45] (-3,3) .. controls (-1,5) and (5,5.5) .. (7,3.5);
    \draw[right] (2.5,5.2) node {\Large };
  \draw[-triangle 45] (-4,2) .. controls (-1,4) and (5,5) .. (8,.5);
    \draw[right] (2.5,4) node {\Large };
  \draw[-triangle 45] (-2,0) .. controls (-1,1.5) and (5,3) .. (8,.51);
    \draw[right] (2.5,2.4) node {\Large };
\end{tikzpicture}
\caption{Stage 2 of a Syntax Framework}  \label{fig:syn-frame-stage-2}
\end{figure}

The third and final stage is to link  and 
using mappings  and  as depicted in Figure~\ref{fig:syn-frame}.
 is an injective, total function such that, for all ,  For ,  is called the \emph{quotation} of .   denotes
a value in  that represents the syntactic structure of
.   is a (possibly partial) function such that, for all ,  whenever  is defined.  For ,  is called the \emph{evaluation} of .  If it is
defined,  denotes the same value in  that the
expression represented by the value of  denotes.  Notice that the
equation above implies  is undefined if  is not
in the image of  under .  Since there will
usually be different  that denote the same
syntactic value,  will usually not be injective.

\begin{figure}
\center
\begin{tikzpicture}[scale=.75]
\draw[very thick] (-3,0) circle (3);
    \draw (-5.5,0) node {\Large };
  \draw[very thick] (-4,1) circle (1);
    \draw (-4,1) node {\Large };
  \draw[very thick] (-2,-1) circle (1);
    \draw (-2,-1) node {\Large };
  \draw[very thick] (7,0) circle (3.5);
    \draw (4.4,0) node {\Large };
  \draw[very thick] (8,-1) circle (1.5);
    \draw (8,-1) node {\Large };
  \draw[-triangle 45] (-3,3) .. controls (-1,5) and (5,5.5) .. (7,3.5);
    \draw[right] (2.5,5.2) node {\Large };
  \draw[-triangle 45] (-4,2) .. controls (-1,4) and (5,5) .. (8,.5);
    \draw[right] (2.5,4) node {\Large };
  \draw[-triangle 45] (-2,0) .. controls (-1,1.5) and (5,3) .. (8,.51);
    \draw[right] (2.5,2.4) node {\Large };
  \draw[-triangle 45] (-3,1) -- (-2,0);
    \draw[right] (-2.6,.8) node {\Large };
  \draw[-triangle 45] (-3,-1) -- (-4,0);
    \draw[right] (-4.3,-.9) node {\Large };
\end{tikzpicture}
\caption{A Syntax Framework}  \label{fig:syn-frame}
\end{figure}

The full definition of a syntax framework is obtained when we put these
three stages together:

\begin{df}[Syntax Framework in an Interpreted Language]\label{df:syn-frame-lang}\em
\bsp
Let  be an interpreted language
and  be a sublanguage of .  A \emph{syntax framework}
for  is a tuple  where:\esp

\be

  \item  is a syntax representation of
    .

  \item  is syntax language for .

  \item  is an injective, total
    function, called a \emph{quotation function}, such that:

    \textbf{Quotation Axiom.} For all , 

  \item  is a (possibly partial)
    function, called an \emph{evaluation function}, such that:

    \textbf{Evaluation Axiom.} For all , 
    whenever  is defined. \hfill 

\ee 
\end{df}
\bsp \noindent  is called the \emph{full language} of the .
When  and  are understood, we will say that
 is a syntax framework for  in .  Notice that a
syntax framework contains three interpreted languages: , , and
.  Notice also that the
functions  and  are part of the metalanguage of  and the
expressions of the form  and  are not necessarily
expressions of .  In section~\ref{sec:built-in} we will discuss
syntax frameworks in which quotations and evaluations are expressions
in  itself. \esp

\subsection{Two Basic Lemmas}

\bsp Let  be an interpreted language,
 be a sublanguage of , and  be a syntax framework for . \esp

\begin{lem}[Law of Disquotation] \label{lem:disquotation}
For all , 
whenever  is defined.
\end{lem}

\begin{proof}
Let  such that  is defined.  Then
\setcounter{equation}{0}

(1) follows from the Evaluation Axiom since  is defined. (2)
follows from the Quotation Axiom.  And (3) is by the fact that  is total on .
\end{proof}

\bigskip

The Law of Disquotation does not hold universally in general because
 may not be total on quotations.

\begin{df}[Direct Evaluation] \label{df:direct-eval} \em \bsp
Let  to be the (possibly
partial) function such that, for all ,  whenever  is defined.   is called the \emph{direct
  evaluation function for }. \hfill  \esp
\end{df}

\begin{lem}[Direct Evaluation] \label{lem:direct-eval}
\be

  \item[]

  \item  satisfies the Evaluation Axiom.

  \item For all , if  and  are
    defined, then 

  \item If  is surjective, then  is total.

\ee
\end{lem}

\begin{proof}

\bigskip

\noindent \textbf{Part 1} \sglsp Follows immediate from the definition
of .

\bigskip

\noindent \textbf{Part 2} \sglsp Let  such that
 and  are defined.  By the Evaluation Axiom,
.

\bigskip

\noindent \textbf{Part 3} \sglsp Let  be surjective and
.  Then  is
defined and hence  is total by its definition.
\end{proof}

\bigskip

Thus the direct evaluation function is a special evaluation function
that is defined for every syntax framework and is total if the
syntactic valuation function is surjective.

\subsection{Syntax Frameworks in an Interpreted Theory}

The notion of a syntax framework can be easily lifted from an
interpreted language to an interpreted theory.  Let a \emph{theory} be
a pair  where  is a language and  is a set
of sentences in  (that serve as the axioms of theory).  A
\emph{model} of  is a pair 
such that  is a set of values that includes the truth
values  (true) and  (false) and  is a total function such that, for all
sentences , .  An
\emph{interpreted theory} is then a pair  where  is a
theory and  is a set of models of .

A syntax framework in an interpreted theory is a syntax framework with
respect to each model of the interpreted theory:

\begin{df}[Syntax Framework in an Interpreted Theory] \label{df:syn-frame-thy} \em
\hspace{2ex}\\
Let  be an interpreted theory where  and
 be a sublanguage of .  A \emph{syntax framework} for
 is a triple  where:

\be

  \item .

  \item  is an injective, total
    function.

  \item  is a (possibly partial)
    function.

  \item For all ,
     is a
    syntax framework for  where  is the range of 
    restricted to  and .\hfill 

\ee 
\end{df}

\subsection{Benefits of a Syntax Framework}

The purpose of a syntax framework is to provide the means to reason
about the syntax of a designated object language.  We will briefly
examine the specific benefits that a syntax framework offers for this
purpose.

Let  be an interpreted language,
 be a sublanguage of , and  be a syntax framework for .

The first, and most important, benefit of  is that it provides a
language, , for expressing statements in  about the
syntactical structure of expressions in .  These
statements refer to the syntax of  via the syntax
representation of .  For example, if  is a formula in ,  is an expression in  that denotes the
representation of , and  is sufficiently expressive, we could
express in  a statement of the form 
that \emph{indirectly} says `` is an implication''.

\bsp Having quotation in  enables statements about the syntax of
 to be expressed directly in the metalanguage of .
For example,  would \emph{directly} say
`` is an implication''.  Quotation also allows us to construct new
expressions from deconstructed components of old expressions.  For
example, if  is a formula in  and  is
sufficiently expressive,
 would denote the
representation of . \esp

Having evaluation in  enables statements about the semantics of the
expressions represented by members of  to be expressed
directly in the metalanguage of .  For example, if  is the
expression given in the previous paragraph, then  would be a
formula in  that asserts .

By virtue of these basic benefits, a syntax framework is well equipped
to define and specify transformers.  As we have mentioned in the
introduction, a \emph{transformer} maps expressions to expressions.
More precisely, an \emph{-ary transformer over a language } maps
expressions  in  to an expression  in  (where
).  A transformer can be defined by either an algorithm
(e.g., a program in a programming language) or a function (e.g., an
expression in a logic that denotes a function).  Transformers include
symbolic computation rules (like the product rule mentioned in the
Introduction), rules of inference, rewrite rules, expression
simplifiers, substitution operations, decision procedures, etc.

A transformer over a language  is usually defined only in the
metalanguage of  and is not defined by an expression in  itself.
For example, the rules of inference for first-order logic are not
expressions in first-order logic.  A syntax framework with a
sufficiently expressive language can be used to transfer a transformer
over  from the metalanguage of  to  itself.  To see this, let

be an -ary transformer over  defined in the
metalanguage of .  If  is sufficiently expressive, it would be
possible to define an operator  in  that denotes a function  that
represents .  Using quotation,  is specified by the following
statement in the metalanguage of : 

The full power of a syntax framework is exhibited in a specification
of the semantic meaning of a transformer.  Suppose  is a language
of natural number arithmetic, the expressions in  denote
natural numbers,  contains a sublanguage  of
terms denoting natural numbers, and  contains a
sublanguage  of terms denoting natural number numerals
.  Further suppose that  is a
binary transformer over  that ``adds'' two natural number
terms so that, e.g., .  Then, using evaluation,
the semantic meaning of , the representation of
\mname{add} in , is specified by the following statement in the
metalanguage of :
 where  is a binary operator in  that denotes the sum
function.

See \cite{Farmer13} for further discussion on how transformers can be
formalized using a syntax framework.

\subsection{Further Remarks}

\begin{rem}[Syntax Representation]\em
Although a syntax representation is a crucial component of a syntax
framework, very little restriction is placed on what a syntax
representation can be.  Almost any representation that captures the
syntactic structure of the expressions in the object language is
acceptable.  In fact, it is not necessary to capture the entire
syntactic structure of an expression, only the part of the syntactic
structure that is of interest to the developer of the syntax
framework.\hfill 
\end{rem}

\begin{rem}[Theories of Quotation]\em
The quotation function  of a syntax framework is based on the
\emph{disquotational theory of quotation}~\cite{Quotation12}.
According to this theory, a quotation of an expression  is an
expression that denotes  itself.  In our definition of a syntax
framework,  denotes a value that represents  (as a syntactic
entity).  Andrew Polonsky presents in~\cite{Polonsky11} a set of
axioms for quotation operators of this kind.  There are several other
theories of quotation that have been
proposed~\cite{Quotation12}.\hfill 
\end{rem}

\begin{rem}[Theories of Truth]\em\bsp
When  is a representation of a truth-valued expression , the
evaluation  is a formula that asserts the truth of .  Thus
the evaluation function  of a syntax framework is a \emph{truth
  predicate}~\cite{Truth13}.  A truth predicate is the face of a
\emph{theory of truth}: the properties of a truth predicate
characterize a theory of truth~\cite{Leitgeb07}.  The definition of a
syntax framework imposes no restriction on  as a truth predicate
other than that the Evaluation Axiom must hold.  What truth is and how
it can be formalized is a fundamental research area of logic, and
avoiding inconsistencies derived from the liar paradox (which we
address below) and similar statements is one of the major research
issues in the area (see~\cite{Halbach11}).\hfill \esp
\end{rem}

\begin{rem}[Contextual Syntax Frameworks]\em\label{rem:contextual}
We have mentioned already that a syntax framework cannot interpret
syntax reasoning systems that contain context-sensitive expressions.
This means that a syntax framework is not suitable for programming
languages with mutable variables.  For programming languages, a syntax
framework needs to be generalized to a \emph{contextual syntax
  framework} that includes a semantic valuation function that takes a
\emph{valuation context} as part of its input and returns a modified
valuation context as part of its output.  \emph{Metaprogramming} is
the writing of programs that manipulate other programs.  It requires a
means to manipulate the syntax of the programs in a programming
language.  In other words, metaprogramming requires code to be data.
Examples of metaprogramming languages include Lisp,
Agda~\cite{Norell07,Norell09}, F\#~\cite{FSharp11},
MetaML~\cite{TahaSheard00}, MetaOCaml~\cite{MetaOCaml11},
reFLect~\cite{GrundyEtAl06}, and Template
Haskell~\cite{SheardJones02}.  An appropriate contextual syntax
framework would provide a good basis for discussing the code
manipulation done in metaprogramming.  We will present the notion of a
contextual syntax framework in a future paper.\hfill 
\end{rem}

\section{Three Standard Examples} \label{sec:examples}

We will now present three standard syntax reasoning systems that are
examples of a syntax framework.

\subsection{Example: Expressions as Strings} \label{subsec:strings}

We will continue the development of Example~\ref{eg:strings-b}.
Suppose  contains the following operators:

\bi

  \item An individual constant  of sort \mname{Symbol} for each
    .

  \item An individual constant \mname{nil} of sort \mname{String}.

  \item A function symbol \mname{cons} of sort .

  \item A function symbol \mname{head} of sort .

  \item A function symbol \mname{tail} of sort .

\ei
The terms of sort \mname{String} are intended to denote strings over
 in the usual way.  \mname{cons} is used to describe the
construction of strings, while \mname{head} and \mname{tail} are used
to describe the deconstruction of strings.  The terms of sort
\mname{String} can thus be used as a language to reason
\emph{directly} about strings over  and \emph{indirectly} about
the syntactic structure of the expressions of  (including the terms
of sort \mname{String} themselves).

This reasoning system for the syntax of  can be strengthened by
interconnecting the expressions of  and the terms of sort
\mname{String}.  This is done by defining a quotation function  and
an evaluation function .  

 maps each expression  of  to a term 
of sort \mname{String} such that  denotes , the string
over  that represents .  For example,  could map 
to 
which denotes the string \texttt{"f(x)"}.  Thus  provides the means
to refer to a representation of the syntactic structure of an
expression of .

 maps each term  of sort \mname{String} to the
expression  of  such that the syntactic structure of 
is represented by the string denoted by  provided  denotes a
string that actually represents the syntactic structure of some
expression of .  For example,  maps the term displayed above
(i.e., ) to .  Thus  provides the means to refer to
the value of the expression whose syntactic structure is represented
by the string that a term of sort \mname{String} denotes.   is a
partial function on the terms of sort \mname{String} since not every
string in  represents the syntactic structure of some expression
in  and  is surjective.  Notice that, for all expressions 
of ,  --- that is, the \emph{law of disquotation}
holds universally.

We showed previously that  is an interpreted language,
 is a syntax representation of , and  is a
syntax language for .   is injective since the syntactic
structure of each expression in  is represented by a unique string
in .  For ,  and thus 
satisfies the Quotation Axiom if , , , and .  For 
such that  is defined,
 
and thus  satisfies the Evaluation Axiom if ,
, , and .

Therefore,  is a syntax framework for
. Notice that  is actually the direct evaluation function
for .

\subsection{Example: G\"odel Numbering} \label{subsec:goedel}

Let  be the expressions (i.e., terms and formulas) of a first-order
language of natural number of arithmetic, and let  be the
alphabet of symbols occurring in the expressions of .  Once again
the expressions of  can be viewed as strings over the alphabet
.  As Kurt G\"odel famously showed in 1931~\cite{Goedel31}, the
syntactic structure of an expression  of  can be represented by
a natural number called the G\"odel number of .  Define  to be
the total function that maps each expression of  to its G\"odel
number.   is injective since each expression in  has a unique
G\"odel number.  The terms of , which denote natural numbers, can
thus be used to reason \emph{directly} about G\"odel numbers and
\emph{indirectly} about the syntactic structure of the expressions of
.

We will show that this reasoning system based on G\"odel numbers can
be interpreted as a syntax framework.  Let  be the set of
terms in  and  be the set of formulas in .  Then  where ,  is the set of natural numbers, and , is an interpreted language corresponding to
the language given in Example~\ref{eg:ms-fol}.

Since  is an injective, total function that
maps each expression in  to its G\"odel number,  is a syntax representation of .  Since , , and  restricted to  is ,  is a syntax language
for .

Let  be a total function that maps each
expression  to a term  such that .   is injective since each expression in  has a
unique G\"odel number.  For ,  and thus  satisfies the Quotation Axiom if , , , and .

Let  be the function that, for all ,  is the expression in  whose G\"odel number is
 if  is a G\"odel number of some
expression in  and  is undefined otherwise. For  such that  is defined,  and thus  satisfies the Evaluation Axiom if
, , , and
.  Since not every natural number is a
G\"odel number of an expression in ,  is
not surjective and thus  is partial.  For an
expression  of ,  such that  by
the definition of  and then  by the the definition of
.  Hence  and so the law of disquotation holds
universally.

Therefore,
 
is a syntax framework for .  Notice that  is actually the
direct evaluation function for .

Define  to be the sublanguage of  such that  iff  is a G\"odel number of some expression in
.  Then  where  is 
restricted to , is a syntax framework for  in which
the evaluation function  is total.

\subsection{Example: Expressions as Members of an Inductive Type} \label{subsec:ind-type}

In the previous two subsections we saw how strings of symbols and
G\"odel numbers can be used to represent the syntactic structure of
expressions.  These two syntax representations are very popular, but
they are not convenient for practical applications.  In this example
we will see a much more practical syntax representation in which
expressions are represented as members of an inductive type.

Let  be a language of propositional logic (with logical
connectives for negation, conjunction, and disjunction). An
interpreter for the language  is a program that receives
user input (which we assume is a string), parses the input into a
usable internal representation (i.e., a parse or syntax tree),
computes the value of the internal representation in the form of a new
internal representation, and then displays the new internal
representation in a user-readable form (which we again assume is a
string).  We will describe the components of such an interpreter.

Let \texttt{formula} be the type of the internal data structures
representing the propositional formulas in .  This type can be
implemented as an inductive type, e.g., in F\#~\cite{FSharp14}
as:
\begin{verbatim}
type formula =
  | True
  | False
  | Var of string
  | Neg of formula
  | And of (formula * formula)
  | Or  of (formula * formula)
\end{verbatim}
Notice that the type constructors correspond precisely to the various
ways of constructing a well-formed formula in propositional logic.

The interpreter for  is the composition of the following functions:

\be

  \item A function \texttt{parse} of type  which parses a user input string into an
    internal representation of a well-formed propositional formula ---
    or raises an error if the input does not represent one.  For the
    sake of simplicity, we assume that  is chosen so
    that \texttt{parse} is injective.

  \item A function \texttt{value} of type  which determines the truth value of a
    propositional formula of  --- or simplifies it in cases that
    contain unknown variables. We will later see how this function
    also requires an additional input  of a variable assignment.

  \item A function \texttt{print} of type  which prints an internal representation of a
    formula as a string for the user.  We assume that, for each string
     representing a well-formed propositional formula of , .

\ee

\noindent
For example, suppose  is a user input string
that denotes a propositional formula in .  Then  is the expression of
type \texttt{formula} that denotes its internal representation,  is the expression of type
\texttt{formula} that denotes its computed value, and  is the string representation of its
computed value.  Hence the interpretation of 
is  



We will show that this system for interpreting propositional formulas
can be regarded as a syntax framework.  This example demonstrates how
to add a syntax representation and a syntax language to a language
that does not inherently support reasoning about syntax.  It also
demonstrates that any typical implementation of a formal language can
be interpreted as a syntax framework.

Let  be the set of well-formed formulas of propositional
logic represented by strings as discussed above,  be the domain of truth values (i.e., the values
formulas of propositional logic denote), and  be the semantic valuation function
for propositional logic relative to a variable assignment . Then
 is an
interpreted language for propositional logic.

Similarly, let  be the set of expressions of type
\texttt{formula},  be the members of the inductive type
\texttt{formula}, and  be the semantic valuation function for the expressions of
type \texttt{formula}. Then  is also an interpreted language. This secondary
interpreted language is the augmentation that we are adding to the
language of propositional logic in order to represent the syntax of
.  Using functions similar to \texttt{parse},
\texttt{value}, and \texttt{print} shown above, we can implement the
language  in a programming language.

Let  be the function such that,
for ,  is the value of type
 denoted by .  Then  is an
injective, total function since each  has exactly
one parse tree that represents the syntactic structure of .
Therefore,  is a syntax representation of
.  The structures , , and
 are depicted in Figure~\ref{fig:impl-lang}.

\begin{figure}
\center
\begin{tikzpicture}[scale=.75]
  \draw[very thick] (0,0) circle (1);
    \draw (0,0) node {\Large };
  \draw[very thick] (0,-3) circle (1);
    \draw (0,-3) node {\Large };
  \draw[very thick] (10,0) circle (1);
    \draw (10,0) node {\Large };
  \draw[very thick] (10,-3) circle (1);
    \draw (10,-3) node {\Large };
  \draw[-triangle 45] (1,-3) .. controls (5,-4) and (6,-4) .. (9,-3);
    \draw[right] (4.5,-4.3) node {\Large };
  \draw[-triangle 45] (1,0) .. controls (4,1) and (6,1) .. (9,0);
    \draw[right] (4.5,1.3) node {\Large };
  \draw[-triangle 45] (0.9,-0.5) .. controls (4,-0.8) and (6, -1) .. (9.3,-2.3);
    \draw[right] (4.5,-0.5) node {\Large };
  \draw[-triangle 45] (0.7,-0.7) -- (0.7,-2.3);
    \draw[right] (1,-1.5) node {\Large };
  \draw[-triangle 45] (-0.7,-2.3) -- (-0.7,-0.7);
    \draw[right] (-3,-1.5) node {\Large };
  \draw[-triangle 45] (-0.9,-3.5) .. controls (-1.9,-4) and (-1,-4.9) .. (-0.5,-3.9);
    \draw[right] (-3.8,-4.2) node {\Large };
\end{tikzpicture}
\caption{Domains and Mappings related to } \label{fig:impl-lang}
\end{figure}

Let , , and . 
is a function since the two functions  and  have disjoint domains. Then  is an
interpreted language and  is a syntax language for
 by construction.

The tuple  is a syntax framework for
 since: 

\be

  \item  is a syntax representation of  as shown above.

  \item  is syntax language for  as shown above.

  \item \textbf{Quotation Axiom}: For all ,
     by definition, and thus
    

  \item \textbf{Evaluation Axiom}: For all ,
     since ,
    and thus
    
\ee
\noindent
Since  holds for all
expressions in , the Law of Disquotation holds
universally.

The syntax framework for this example provides the structure that is
needed to understand the function  shown in
Figure~\ref{fig:impl-lang} as an implementation of the semantic
valuation function . The formula that specifies
, 
illustrates the interplay of syntax and semantics that is inherent in
its meaning.

The approach employed in this third example, in which the syntactic
values are members of an inductive type, is commonly used in
programming to represent syntax (see~\cite{FriedmanWand08}).  It
utilizes a \emph{deep embedding}~\cite{BoultonEtAl93} of the object
language  into the full underlying formal language .

\subsection{Further Remarks}

\begin{rem}[Variable Binding]\em
None of the standard examples discussed above treat variable binding
constructions in any special way.  There are other syntax
representation methods that identify expressions that are the same up
to a renaming of the variables that are bound by variable binders.
One method is \emph{higher-order abstract
  syntax}~\cite{Miller00,PfenningElliot88} in which the syntactic
structure of an expression with variable binders is represented by a
term in typed lambda calculus.  Another method is \emph{nominal
  techniques}~\cite{GabbayPitts02,Pitts03} in which the swapping of
variable names can be explicitly expressed.  The
paper~\cite{NanevskiPfenning05} combines quotation/evaluation
techniques with nominal techniques.\hfill 
\end{rem}

\begin{rem}[Types]\em
The languages in a syntax framework are not required to be typed.
However, it is natural that, if an expression  in the object
language is of type , then  should be of some type
.  The operator  behaves like the
necessity operator  in modal logic~\cite{DaviesPfenning01}.  An
important design decision for such a type system is whether or not
every expression of the syntax language equals a quotation of an
expression.  In other words, should a syntax framework with a type
system admit only expressions in the syntax language that denote the
syntactic structure of well-formed expressions or should it admit in
addition expressions that denote the syntactic structure of ill-formed
expressions.  Recall that in the example of
subsection~\ref{subsec:goedel} the syntax language of  contains the
latter kind of expressions, while the syntax language of  contains
only the former kind.\hfill
\end{rem}

\section{Syntax Frameworks with Built-In Operators} \label{sec:built-in}

The three examples in the previous section illustrate how a syntax
framework provides the means to reason about the syntax of a
designated object language .  In all three
examples, only \emph{indirect statements} about the syntax of  can be expressed in , while direct statements using  and
 can be expressed in the metalanguage of .  In this section we
will explore syntax frameworks in which \emph{direct statements} about
the syntax of , such as , can be expressed
in  itself.

\subsection{Built-in Quotation and Evaluation}

\bsp Let  be an interpreted language,  be a
sublanguage of , and  be a syntax framework for .   has
\emph{built-in quotation} if there is an operator (which we will
denote as \mname{quote}) such that, for all ,
 is the syntactic result of applying the operator to  (which
we will denote as ).   has \emph{built-in
  evaluation} if there is an operator (which we will denote as
\mname{eval}) such that, for all ,  is the
syntactic result of applying the operator to  (which we will denote
as ) whenever  is defined.\footnote{If  is a typed language, it may be necessary for the
  \mname{eval} operator to include a parameter that ranges over the
  types of the expressions in .}  There are similar
definitions of built-in quotation and evaluation for syntax frameworks
in interpreted theories. \esp

Assume  has both built-in quotation and evaluation.  Then
quotations and evaluations are expressions in , and  thus
provides the means to reason directly in  about the interplay of
the syntax and semantics of the expressions in .  In
particular, it is possible to specify in  the semantic meanings of
transformers.  The following lemma shows that, since the quotations
and evaluations in  begin with the operators \mname{quote} and
\mname{eval}, respectively,  cannot be the direct evaluation for
.  

\begin{lem}
Suppose  is a syntax framework that has built-in quotation and
evaluation.  Then .
\end{lem}

\begin{proof}
Suppose .  Let .  Then
\setcounter{equation}{0}

(1) is by the fact that  is total on ; (2)
is by built-in quotation and the Quotation Axiom; (3) is by the
definition of the direct evaluation function; (4) is by hypothesis;
and (5) is by the fact that  is built in.  Hence , which is a contradiction since these
are syntactically distinct expressions.
\end{proof}

\bigskip

The syntax framework  is \emph{replete} if the object language of
 is equal to the full language of  (i.e., ) and
 has both built-in quotation and evaluation.  A replete syntax
framework whose full language is  has the facility to reason about
the syntax of all of  within  itself.   is \emph{weakly
  replete} if  and  has both
built-in quotation and evaluation.  There are similar definitions of
replete and weakly replete for syntax frameworks in interpreted
theories.  We will give two examples of a replete syntax framework,
one in the next subsection and one in section~\ref{sec:literature}.
We will also give another example in section~\ref{sec:literature} of a
syntax framework that is almost replete.

\begin{rem}\em
A \emph{biform
  theory}~\cite{CaretteFarmer08,Farmer07b,FarmerMohrenschildt03} is a
combination of an axiomatic theory and an algorithmic theory.  It is a
basic unit of mathematical knowledge that consists of a set of
\emph{concepts}, \emph{transformers}, and \emph{facts}.  The concepts
are symbols that denote mathematical values and, together with the
transformers, form a language  for the theory.  The transformers
are programs whose input and output are expressions in ; they
represent syntax-based algorithms like reasoning rules.  The facts are
statements expressed in  about the concepts and transformers.  A
logic with a replete syntax framework (such as Chiron discussed in
subsection~\ref{subsec:chiron}) is well-suited for formalizing biform
theories~\cite{Farmer07b}.\hfill 
\end{rem}

\subsection{Example: Lisp} \label{subsec:lisp}

We will show that the Lisp programming language with a simplified
semantics is an instance of a syntax framework with built-in quotation
and evaluation.

Choose some standard implementation of Lisp.  Let  be the set of
S-expressions that do not change the Lisp valuation context when they
are evaluated by the Lisp interpreter.  Let  be the total function that, for all S-expressions ,  is the S-expression the interpreter returns when  is
evaluated if the interpreter returns an S-expression in  and  otherwise.   is thus an
interpreted language.

, where  is the identity function
on , is a syntax representation of  since each S-expression
represents its own syntactic structure.  Let  be the sublanguage
of  such that, for all ,  iff .
It follows immediately by the definition of  that  is a
syntax language for .

Let  be the total function that maps each 
to the S-expression .  For ,  since .   is obviously
injective.  For ,  and thus  satisfies the Quotation Axiom if
, , ,
and .

Let  be the total function that, for all ,
 is the S-expression .  For all ,  (Notice that  is always defined
since .)  Thus  satisfies the Evaluation Axiom if , , , and
.

Therefore,  is a replete syntax
framework for .

Suppose  were the full set of S-expressions, including the
S-expressions that modify the Lisp valuation context when they are
evaluated by the interpreter.  Then, in order to interpret Lisp as a
syntax framework, we would need to extend the notion of a \emph{syntax
  framework} to the notion of \emph{contextual syntax framework} as
mentioned in Remark~\ref{rem:contextual}

\subsection{Example: Liar Paradox} \label{subsec:liar}

The virtue of a syntax framework with built-in quotation and
evaluation is that it provides the means to express statements about
the interplay of the syntax and semantics of the expressions in
 in .  On the other hand, the vice of such a syntax
framework is that, if  is sufficiently expressive, the liar paradox
can be expressed in  using quotation and evaluation.

\bsp Let  be the
interpreted language and  be the
syntax framework for  given in subsection~\ref{subsec:goedel}.  Assume
that  is defined so that the axioms of first-order Peano arithmetic
are satisfied (see~\cite{Mendelson09}).  Assume also that  has
been modified so that it has both built-in quotation and built-in
evaluation. \esp

\bsp We claim  cannot be total.  Assume otherwise.  By the
diagonalization lemma~\cite{Carnap34}, there is an expression , such that .  Then
\esp \setcounter{equation}{0}

(1) is by built-in evaluation, the totality of , and the
Evaluation Axiom; (2) is by the definition of ; (3) is by built-in
quotation and the Quotation Axiom, and (4) is by the fact  is total
on .  Hence , which
contradicts the fact that  never assigns a formula and its negation
the same truth value.  Therefore,  cannot be total and, in
particular, cannot be total on quotations.

The formula  expresses the \emph{liar paradox} and
the argument above is a proof of Alfred Tarski's 1933 theorem on the
undefinability of truth~\cite{Tarski33,Tarski35,Tarski35a}, which says
that built-in evaluation cannot serve as a truth predicate over all
formulas.  This example demonstrates why evaluation is allowed to be
partial in a syntax framework: if evaluation were required to be
total, the notion of a syntax framework would not cover reasoning
systems with built-in quotation and evaluation in which the liar
paradox can be expressed.

\subsection{Example: G\"odel Numbering with Built-In Quotation}

A syntax framework without built-in quotation and evaluation can
sometimes be modified to have built-in quotation or evaluation.

\bsp Let  be the
interpreted language and  be the
syntax framework for  given in subsection~\ref{subsec:goedel}.
Extend  to the language  and  to
 by adding a new operator  so that
 for all .
Extend  to  so that
 is the G\"odel number of  for all .
Extend  to  so that 
for all .  And, finally, define  to be
 for all .  (We do not need to
change the definition of .)  Then  is an interpreted
language and  is a syntax framework for 
that has built-in quotation. \esp

See \cite{Farmer13} for further discussion on the challenges involved
in modifying a traditional logic to embody the structure of a replete
syntax framework.

\section{Quasiquotation} \label{sec:quasiquotation}

Quasiquotation is a parameterized form of quotation in which the
parameters serve as holes in a quotation that are filled with the
values of expressions.  It is a very powerful syntactic device for
specifying expressions and defining macros.  Quasiquotation was
introduced by Willard Quine in 1940 in the first version of his book
\emph{Mathematical Logic}~\cite{Quine03}.  It has been extensively
employed in the Lisp family of programming
languages~\cite{Bawden99}.\footnote{In Lisp, the standard symbol for
  quasiquotation is the backquote (\texttt{`}) symbol, and thus in
  Lisp, quasiquotation is usually called \emph{backquote}.}

\bsp We will show in this section how quasiquotation can be defined in
a syntax framework.  Let  be an interpreted language,  be a sublanguage of , and  be a syntax framework for . \esp

\subsection{Marked Expressions} \label{subsec:marked-expr}

Suppose .  A \emph{subexpression} of  is an occurrence in
 of some .  We assume that there is a set of
\emph{positions} in the syntactic structure of  such that each
subexpression of  is indicated by a unique position in .  Two
subexpressions  and  of  are \emph{disjoint} if  and
 do not share any part of the syntactic structure of .

Let .  A \emph{marked expression} derived from 
is an expression of the form 
where ,  are positions of pairwise disjoint
subexpressions of , and  are expressions in .
Define  to be the set of marked expressions
derived from members of .

\bsp Let  be the function
that, given a marked expression ,
simultaneously replaces each subexpression in  at position 
with  (the application of the direct evaluation
function for  to ) for all  with .  
will be undefined if either  is undefined or
 does not have the same type as the subexpression at
position  for some  with .  \esp

\subsection{Quasiquotation}

Define  to be
the (possibly partial) function such that, if , then
.   is defined iff 
is defined.  For ,  is
called the \emph{quasiquotation} of .\footnote{The
  position-expression pairs  in a quasiquotation
   are sometimes
  called \emph{antiquotations}.}

 has \emph{built-in quasiquotation} if there is an operator (which
we will denote as \mname{quasiquote}) such that, for all , 
is the syntactic result of applying the operator to
 (which we will denote as
).

\subsection{Backquote in Lisp} \label{subsec:backquote} 

Let us continue the example in subsection~\ref{subsec:lisp} involving
Lisp with a simplified semantics.  In Lisp, a \emph{backquote} of 
is an expression of the form  where  is an
S-expression in  in which some of the subexpressions of  are
marked by a comma (\texttt{,}).  For example,
 is a backquote in which \texttt{(+ 3 1)} 
is a subexpression marked by a comma.  We will restrict our attention
to unnested backquotes.  The Lisp interpreter normally returns an
S-expression when it evaluates a backquote .  In
this case the S-expression returned is obtained from  by replacing
each subexpression  in  marked by a comma with the S-expression
.  For example, when evaluating \texttt{`(+ 2 ,(+ 3 1))}, the
interpreter returns \mbox{\texttt{(+ 2 4)}}.  Let  be extended to
 to include the backquotes of  and  be the total function such that, for all
S-expressions and backquotes ,  is the
S-expression the interpreter returns when  is evaluated if the
interpreter returns an S-expression and  otherwise.

\bsp A backquote  in  corresponds to a marked
expression 
where each  is the position of a subexpression  in
 marked by a comma for all  with .  Let
 be a backquote and  be a marked
expression that corresponds to it.  We will show that the semantic
value of the backquote , when it is not , is the
same as the semantic value of the quasiquotation .
Assume .  Then
\setcounter{equation}{0}

(1) is by the semantics of backquote and the definition of  since
 for each  with .  (2) is by the
Quotation Axiom and the fact that  is the identity
function.  And (3) is by the definition of . \esp

\section{Examples from the Literature} \label{sec:literature}

\subsection{Example: Lambda Calculus} \label{subsec:lambda}
\newcommand{\betaarrow}{\twoheadrightarrow_{\beta}}
\newcommand{\nflambda}{{\rm NF}_{\Lambda}}
\newcommand{\nfdomain}{\nflambda \cup \{\bot\}}

In 1994 Torben Mogensen~\cite{Mogensen94} introduced a method of self
representing and interpreting terms of lambda calculus. We will
analyze this method and demonstrate how the self-interpretation of
lambda calculus is almost an instance of a replete syntax framework.

Let  be
the set of -terms where  is a countable set of
variables.  is the language of lambda calculus consisting of
all the -terms.  A -term is a \emph{normal form} if
-reduction cannot be applied to it.  Given a -term
, let the \emph{normal form of }, , be the normal
form that results from repeatedly applying -reduction to 
until a normal form is obtained.  The normal form of  is undefined
if a normal form is never obtained after repeatedly applying
-reduction to .  We will introduce two different syntax
representations of this language. The first syntax representation of
 uses an inductive type similar to
subsection~\ref{subsec:ind-type} such that  is the syntactic
valuation function where: \setcounter{equation}{0}

\noindent 
Let  be the domain of values of this inductive type.
Then  is a syntax representation of .

Mogensen~\cite{Mogensen94} suggests a different syntax representation
of lambda calculus. Let  be a {\em representation schema} for lambda calculus such
that: 
\setcounter{equation}{0}

\noindent 
where  are variables not occurring free in the -terms
 and . This representation of -terms is an equivalent
representation to the method described earlier which utilizes the
constructs of lambda calculus itself instead of an external data type.

Then  is a syntax
representation of  and  is a
syntax language for . Notice that, since 
is in normal form for any , then trivially
.

Let a {\em self-interpreter}  be a -term such that for any
,  is -equivalent to ,
i.e.,  (which means  and  are -convertible when these
normal forms exist).  Mogensen proves that the -term

\noindent where  is the Y-combinator, is a self-interpreter.
Define  to be the partial
function such that  if  for
some -term  and is undefined otherwise.

\iffalse
The immediate implementation of  for the syntax representation  is as follows:
\setcounter{equation}{0}

\fi

\begin{thm}\bsp
Let  be the language of lambda calculus and  be the interpreted language of
lambda calculus as defined earlier. Let  be the
representation schema of  and  be the function
defined above.  Then  is a syntax framework for
. \esp
\end{thm}

\begin{proof}
 is a syntax framework since it satisfies the four
  conditions of Definition~\ref{df:syn-frame-lang}:

\be

  \item  is a syntax
    representation of .

  \item  is syntax language for
    .

  \item  is an
    injective, total function such that, for all ,
     (Quotation Axiom).

  \item  is a partial
    function such that, for all  with  for some -term ,  (Evaluation Axiom) since 
    is a self-interpreter.

\ee
\end{proof}

\bigskip

 is almost replete:  is both the object and full
language of  and  has built-in evaluation,
but  does not have built-in quotation.

\iffalse
 does not have built-in quotation, but this can be
defined in  by introducing a constant  such that  for all .  Hence the Mogensen
self-interpretation of lambda calculus can be formulated as a replete
syntax framework.
\fi

\iffalse
\bsp Mogensen also introduces a {\em self-reducer}  for
-terms such that  and provides a proof of correctness for the
self-reducer. Let  be a -term and
 be the marked expression
, where  is the top position in , as
in section~\ref{subsec:marked-expr}.  Then . Therefore,  and the self-reducer for
lambda calculus is a built-in special form of the quasiquotation in
syntax frameworks.  \esp
\fi

\subsection{Example: The Ring Tactic in Coq} \label{subsec:coq}
Coq~\cite{Coq8.4} is an interactive theorem prover based on the
calculus of inductive constructions. Let  be a ring with the
associative, commutative binary operators  and  and the
constants  and  that are the identities of  and ,
respectively. A {\em polynomial} in  is an expression that consists
of the constants of , the operators  and , and variables
 of type .

The {\em ring tactic} in Coq is a polynomial simplifier that converts
any polynomial to its equivalent {\em normal form}. The normal form of
a polynomial is defined as the ordered sum of unique monomials in
lexicographic order.

Earlier we mentioned that syntax-based operations such as
(symbolically) computing derivatives require a syntax framework to
manipulate and reason about syntax using quotation and evaluation.
Polynomial simplification is a term rewriter that uses the quotation
and evaluation mechanisms.  The {\tt ring} tactic in Coq automatically
quotes and simplifies every polynomial expression.

Internally, when the {\tt ring} tactic is applied, the polynomials are
represented by an inductive type {\tt polynomial}. The Coq
reference manual~\cite{Coq8.4} defines this type as:
\begin{verbatim}
Inductive polynomial : Type :=
  | Pvar : index -> polynomial
  | Pconst : A -> polynomial
  | Pplus : polynomial -> polynomial -> polynomial
  | Pmult : polynomial -> polynomial -> polynomial
  | Popp : polynomial -> polynomial.
\end{verbatim}
which represents polynomials similar to the inductive type example in
subsection \ref{subsec:ind-type}.

Let  be the language of Coq,  be the semantic domain of values
in the calculus of inductive constructions, and  be the semantic
interpreter of Coq, then  is the interpreted language for
Coq. Let  be the language of polynomials of type 
(i.e., expressions in  that are built with operators and constants
of  and variables  as defined earlier),  be the language of expressions belonging to the
inductive type {\tt polynomial},  be the
image of  under , and  be the internal
quotation mechanism of Coq the {\tt ring} tactic uses to lift
polynomial expressions in  to expressions in .
Then  is a syntax representation and
 is a syntax language for this syntax representation
which is suitable for describing the \texttt{ring} tactic in Coq.

Coq's ring normalization library ({\tt Ring\_normalize.v}) also defines
an interpretation function that transforms a polynomial expression of
type {\tt polynomial} back to a ring value of type :
\begin{verbatim}
Fixpoint interp_p (p:polynomial) : A :=
  match p with
  | Pconst c => c
  | Pvar i => varmap_find Azero i vm
  | Pplus p1 p2 => Aplus (interp_p p1) (interp_p p2)
  | Pmult p1 p2 => Amult (interp_p p1) (interp_p p2)
  | Popp p1 => Aopp (interp_p p1)
  end.
\end{verbatim}

To finish a definition of a syntax framework for the \texttt{ring}
tactic in Coq, we need to construct two functions  and  in the metalanguage of Coq.
Their definitions are:

\be

  \item For all ,  is the  such
    that 

  \item \bsp For all ,  is the  such
    that . \esp

\ee
Then  is a syntax
framework for .

Notice that the two functions  and  are not normally present in
Coq and were constructed by the machinery in Coq described above
specifically to satisfy the requirements of a syntax framework.
Although the concepts of the syntax language and the syntax
representation arose naturally from the internal mechanism for the
\texttt{ring} tactic in Coq, a syntax framework for the \texttt{ring}
tactic does \emph{not} reside in Coq as explicitly as our previous
examples.

\subsection{Example: Chiron} \label{subsec:chiron}

Chiron~\cite{Farmer07a,Farmer12}, is a derivative of
von-Neumann-Bernays-G\"odel ({\nbg}) set theory~\cite{Goedel40,
  Mendelson09} that is intended to be a practical, general-purpose
logic for mechanizing mathematics.  Unlike traditional set theories
such as Zermelo-Fraenkel ({\zf}) and {\nbg}, Chiron is equipped with a
type system, and unlike traditional logics such as first-order logic
and simple type theory, Chiron admits undefined terms.  The most
noteworthy part of Chiron is its facility for reasoning about the
syntax of expressions that includes built-in quotation and evaluation.

We will assume that the reader is familiar with the definitions
concerning Chiron in~\cite{Farmer12}.  Let  be a language of
Chiron,  be the set of expressions in ,  be a standard
model for ,  be the set of values in ,  be the valuation
function in , and  be an assignment into .  Then
 is an interpreted language.

 includes certain sets called \emph{constructions} that are
isomorphic to the syntactic structures of the expressions in .
 is a function in  that maps each expression in  to a
construction representing it.  Let  be the range of 
and  be the set of terms  such that .  For , define .
For , define  as follows:

\be

  \item If  is a construction that
    represents a type and  is eval-free, then 
    

  \item If  is a construction that represents a term,
     is eval-free, and
    , then 

  \item If  is a construction that
    represents a formula and  is eval-free, then 
    

  \item Otherwise,  is undefined.

\ee

\begin{thm}
\bsp  is a syntax framework
for .\esp
\end{thm}

\begin{proof}
 is a syntax framework since it satisfies the four conditions of
  the Definition~\ref{df:syn-frame-lang}:

\be

  \item  maps each  to a construction that represents
    the syntactic structure of .  Thus  is a set of
    values that represent syntactic structures and  is injective and total.  So  is a syntax
    representation of .

  \item  is an interpreted language.  .
    .  
    (since since  is the range of , , and ).  And  restricted
    to  is a total function .  So  is a syntax language for
    .

  \item Let .  Then  by the definition of  and the
    definition of  on quotations. So  is an injective, total function such that, for all
    , .

  \item Let  such that  is defined.  Hence
     is a construction that represents a type, term, or
    formula.  If  represents a type, term, or formula, let
     be \mname{type}, \mname{C}, or \mname{formula},
    respectively. Then  by the definition of  and the
    definition of  on evaluations.  So  is a partial function such that, for all , 
    whenever  is defined.

\ee
Finally,  is replete since  is both the object and full
language of  and  has built-in quotation and evaluation.
\end{proof}

\bigskip

Quasiquotation is a notational definition in Chiron; it is not a
built-in operator in Chiron as quotation and evaluation
are~\cite{Farmer12}.  The quasiquotation defined in Chiron is
semantically equivalent to the notion of quasiquotation defined in the
previous section.

\newpage

\section{Conclusion} \label{sec:conclusion}

We have introduced a mathematical structure called a \emph{syntax
  framework} consisting of six major components:

\be

  \item A formal language  with a semantics.

  \item A sublanguage  of  that is the object language
    of the syntax framework.

  \item A domain  of values that represent the syntactic
    structures of expressions in .

  \item A sublanguage  of  whose expressions denote
    values in .

  \item A quotation function .

  \item An evaluation function .

\ee

A syntax framework provides the means to reason about the interplay of
the syntax and semantics of the expressions in  using
quotation and evaluation.  In particular, it provides three basic
syntax activities:

\be

  \item Expressing statements in  about the syntax of .

  \item Constructing expressions in  that denote values
    in .

  \item Employing expressions in  as expressions in
    .

\ee
These activities can be used to specify, and even implement,
transformers that map expressions in  to expressions in
.  They are needed, for example, to specify the rules of
differentiation and to prove that these rules correctly produce
representations of expressions that denote
derivatives~\cite{Farmer13}.  A syntax framework also provides a basis
for defining a notion of quasiquotation which is very useful for the
second basic activity.

When a syntax framework has built-in quotation and evaluation, it
provides the means to reason \emph{directly} in  about the syntax
and semantics of the expressions in .  However, in this
case, the evaluation function  cannot be the direct evaluation
function (Lemma~\ref{lem:direct-eval}) and, if  is sufficiently
expressive,  cannot be total on quotations
(subsection~\ref{subsec:liar}) and thus the Law of Disquotation
(Lemma~\ref{lem:disquotation}) cannot hold universally. 

We showed that the notion of a syntax framework embodies a common
structure found in a variety of systems for reasoning about the
interplay of syntax and semantics.  We did this by showing how several
examples of such systems can be regarded as syntax frameworks.  Three
of these examples were the standard syntax-reasoning systems based on
expressions as strings, G\"odel numbers, and members of an inductive
type.  The other, more sophisticated, examples were taken from
the literature.

We have also mentioned that a syntax framework is not adequate for
modeling syntax reasoning in programming languages with mutable
variables.  This requires a generalization of a \emph{syntax
  framework} to a \emph{contextual framework} that will be presented
in a future paper.

\section*{Acknowledgments}
\bsp
The authors are grateful to Marc Bender, Jacques Carette, Michael
Kohlhase, Russell O'Connor, and Florian Rabe for their comments about
the paper.
\esp  

\iffalse

The authors would also like to thank the referees for their detailed
examination of the paper and valuable suggestions.

\fi

\bibliography{syntax-bibliography} 
\bibliographystyle{plain}

\end{document}
