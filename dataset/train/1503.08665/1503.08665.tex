\documentclass[openright,a4paper,11pt]{scrartcl}
\usepackage{fancyhdr}

\usepackage[utf8]{inputenc}
\usepackage[ngerman,english]{babel}
\usepackage{listings}
\usepackage{url}

\usepackage{multicol}
\usepackage{datetime}
\newtimeformat{mytime}{\twodigit{\THEHOUR}:\twodigit{\THEMINUTE}}
\newdateformat{mydate}{\twodigit{\THEYEAR}.\twodigit{\THEMONTH}.\twodigit{\THEDAY}}
\newcommand{\mytoday}{\mydate\today~\mytime}
\usepackage{xcolor}
\usepackage{minibox}

\usepackage{todonotes}
\usepackage{amsmath}
\usepackage{tabularx}
\usepackage{amssymb}
\usepackage{multirow}
\usepackage{bussproofs}
\usepackage{booktabs}
\usepackage{bm}
\usepackage{stmaryrd}
\usepackage[inline]{enumitem}
\usepackage{tabularx}
\usepackage{mdframed}
\usepackage{minibox}
\usepackage{xparse}
\usepackage{tikz}

\usetikzlibrary{arrows,decorations.pathmorphing,backgrounds,fit,positioning,shapes.symbols,chains,shapes}
\usepackage{makecell}

\definecolor{darkgray}{rgb}{0.95,0.95,0.95}
\definecolor{darkgreen}{rgb}{0.05,0.70,0.0}
\definecolor{lstcap}{cmyk}{0.43,0.35,0.35,0.01}
\definecolor{lightgreen}{rgb}{0.55,0.70,0.55}
\definecolor{darkred}{rgb}{0.85,0.50,0.50}
\definecolor{dark-red}{rgb}{0.4,0.15,0.15}
\definecolor{dark-blue}{rgb}{0.15,0.15,0.4}
\definecolor{defblue}{rgb}{0.15,0.15,0.4}
\definecolor{medium-blue}{rgb}{0,0,0.5}


\usepackage{varwidth}

\usepackage[backend=bibtex,
babel=hyphen,
maxbibnames=10,
isbn=false,
doi=false,
backref=true,
mincrossrefs=100,
firstinits=true,
backref=false,
maxcitenames=1]{biblatex}

\usepackage{hyperref}
\hypersetup{    colorlinks, linkcolor={dark-red},
    citecolor={dark-blue}, urlcolor={medium-blue}
}

\usepackage[hyperref]{ntheorem}



\newcommand{\Nat}{\ensuremath{\mathbb{N}}}
\newcommand{\slist}[1]{\ensuremath{\overline{#1}}}
\newcommand{\denot}[1]{\ensuremath{\llbracket #1 \rrbracket}}
\newcommand{\impl}{\ensuremath{\Longrightarrow\,}}

\newcommand{\update}[2]{\ensuremath{[#1\mapsto{}#2]}}
\newcommand{\upd}[3]{\ensuremath{#1[#2\mapsto{}#3]}}

\newcommand{\M}[1]{\ensuremath{\mathit{#1}}}
\newcommand{\pto}{\ensuremath{\rightharpoonup}}

\newcommand{\indu}[1]{\ensuremath{\textbf{\textit{#1}}}}

\newcommand{\dom}{\ensuremath{\textup{\textit{dom\,}}}}
\newcommand{\incl}{\ensuremath{\subseteq}}
\newcommand{\set}[1]{\ensuremath{\{#1\}}}

\newcommand{\agreeon}[1]{\ensuremath{\,{=}_{#1}}\,}
\newcommand{\injon}[2]{\ensuremath{#1\rightarrowtail{}#2}}

\newcommand{\nrule}[1]{\ensuremath{\textup{\textsc{#1}}}}
\newcommand{\nbrule}[1]{\ensuremath{\textup{\textbf{\textsc{#1}}}}}


\newcommand{\Exp}{\ensuremath{\M{Exp}}}
\newcommand{\Trm}{\ensuremath{\M{Term}}}
\newcommand{\Fun}{\ensuremath{\mathcal{F}}}
\newcommand{\Act}{\ensuremath{\mathcal{A}}}
\newcommand{\Op}{\ensuremath{\textup{Op}}}
\newcommand{\Var}{\ensuremath{\mathcal{V}}}
\newcommand{\Val}{\ensuremath{\mathbb{V}}}
\newcommand{\Valb}{\ensuremath{\mathbb{V}_{\bot}}}
\newcommand{\Lab}{\ensuremath{\mathcal{L}}}
\newcommand{\Evt}{\ensuremath{\mathcal{E}}}

\newcommand{\valtobool}{\ensuremath{\beta}}
\newcommand{\fv}{\ensuremath{\textup{fv}}}

\newcommand{\inlan}[1]{\ensuremath{\langle #1 \rangle}\,}

\newcommand{\ilIn}{\textsf{in}}
\newcommand{\ilReturn}[1]{#1}
\newcommand{\ilReturnAA}[2]{\inlan{#2}\ilReturn{#1}}
\newcommand{\ilGoto}[2]{#1\,#2}
\newcommand{\ilGotoAA}[3]{\inlan{#3}\ilGoto{#1}{#2}}
\newcommand{\ilLetRec}[4]{\textsf{fun}\,#1\,#2=#3\,\ilIn\,#4}
\newcommand{\ilLetRecA}[5]{\textsf{fun}\,#1\,#2\,:\,#5\,=#3\,\ilIn\,#4}
\newcommand{\ilLetRecAA}[6]{\inlan{#5}\ilLetRecA{#1}{#2}{#3}{#4}{#6}}

\newcommand{\ilLetRecM}[4]{\M{fun}~\slist{#1\,#2\,=\,#3}~\ilIn~#4}
\newcommand{\ilLet}[3]{\textsf{let}\,#1=#2\,\ilIn\,#3}
\newcommand{\ilLetAA}[4]{\inlan{#4}\ilLet{#1}{#2}{#3}}
\newcommand{\ilIf}[3]{\textsf{if}\,{#1}\,\textsf{then}\,{#2}\,\textsf{else}\,{#3}}
\newcommand{\ilIfAA}[4]{\inlan{#4}\ilIf{#1}{#2}{#3}}
\newcommand{\ilEvent}[4]{\textsf{let}~#1=#2\,#3~\ilIn~#4}


\newcommand{\cfgIn}{\textup{\M{in}}}
\newcommand{\cfgReturn}[1]{\M{return}\,#1}
\newcommand{\cfgGoto}{\textup{\M{goto}}}
\newcommand{\cfgLetRec}[4]{\M{block}\,#1\,#2\,\set{#3};\,\set{#4}}
\newcommand{\cfgLet}[3]{#1\,:=\,#2;~#3}
\newcommand{\cfgApp}[2]{\M{goto}~#1~#2}
\newcommand{\cfgIf}[3]{\M{if}~{#1}~\M{then}~\set{#2}~\M{else}~\set{#3}}

\newcommand{\freenam}[1]{\ensuremath{\fv(#1)}}

\newcommand{\closure}{\ensuremath{\textit{closure}}}
\newcommand{\opEval}[3]{\ensuremath{#1\vdash{}#2\Downarrow{}#3}}
\newcommand{\opeval}[2]{\ensuremath{\denot{#1}\,#2}}
\newcommand{\expEval}[2]{\ensuremath{#1\Downarrow{}#2}}
\newcommand{\bigEval}[3]{\ensuremath{#2\Downarrow_{#1}{#3}}}
\newcommand{\fstate}[3]{\ensuremath{#1~|~#2~|~#3}}
\newcommand{\fstatet}[3]{\ensuremath{#1&|\,#2&|\,#3}}
\newcommand{\fevals}{\ensuremath{\longrightarrow}}
\newcommand{\fevalsg}[2]{\stackrel{#2}{\fevals}_{#1}}

\newcommand{\statetype}{\M{state}}
\newcommand{\cons}{\ensuremath{\!::\!}}

\newcommand{\fevalstg}[4]{\ensuremath{
\begin{array}{llll}
        & #1 \\
\stackrel{#4}{\fevals}_{#3} & #2
\end{array}
}
}
\newcommand{\fevalstgsl}[4]{\ensuremath{#1~~\stackrel{#4}{\fevals}_{#3}~~#2}}

\newcommand{\fevalst}[2]{\fevalstg{#1}{#2}{}{\tau}}
\newcommand{\ievalst}[2]{\fevalstg{#1}{#2}{I}{\tau}}
\newcommand{\block}{\M{block}}

\newcommand{\ctxeq}{\simeq}
\newcommand{\freevars}[1]{\ensuremath{\fv(#1)}}

\newcommand{\ctx}{\ensuremath{\mathcal{C}}}


\newcommand{\diverge}{\ensuremath{\!\Uparrow}}
\newcommand{\trm}[1]{\ensuremath{\Downarrow{#1}}}
\newcommand{\trmg}[2]{\ensuremath{\Downarrow_{#2}{#1}}}
\newcommand{\stuck}{\ensuremath{\trm{\bot}}}
\newcommand{\cobs}{\ensuremath{\Updownarrow}}

\newcommand{\obseq}{\approx_{\textit{obs}}}
\newcommand{\Sim}{\ensuremath{\sim}}
\newcommand{\SimS}{\ensuremath{\stackrel{\circ}{\sim}}}

\newcommand{\redsys}[5]{\ensuremath{(#1, #2, #3, #4, #5)}}
\newcommand{\LTS}[3]{\ensuremath{(#1, #2, #3)}}
\newcommand{\red}{\ensuremath{\fevals}}
\newcommand{\obs}{\ensuremath{\M{obs}}}


\newcommand{\G}{\ensuremath{\gamma}}
\newcommand{\ET}{\ensuremath{\Gamma}}
\newcommand{\LT}{\ensuremath{\Lambda}}
\newcommand{\D}{\ensuremath{\Delta}}
\newcommand{\LC}{\ensuremath{\Lambda}}
\newcommand{\lv}{\ensuremath{X}}


\newcommand{\coh}[3]{\ensuremath{#1~\vdash\textbf{\textup{coh}}~{}#3}}
\newcommand{\cohCtx}[2]{\ensuremath{#2\vdash\textbf{\textup{coh}}\,{}#1}}
\newcommand{\cohapx}{\ensuremath{\approx_{\textit{coh}}}}

\newcommand{\name}[1]{\M{#1}}
\newcommand{\location}[1]{\M{#1}}

\newcommand{\reach}{\ensuremath{\mathcal{R}}}

\newcommand{\supp}[2]{\ensuremath{#1\subseteq{}#2}}
\newcommand\restr[2]{{  \left.\kern-\nulldelimiterspace   #1   \vphantom{\big|}   \right|_{#2}   }}
\newcommand{\restrict}[2]{\ensuremath{\lfloor#1\rfloor_{#2}}}

\newcommand{\agr}[3]{\ensuremath{#1,#2\models#3}}



\newcommand{\live}[3]{\ensuremath{#1\vdash\textbf{\textup{live}\,}{}#3:#2}}
\newcommand{\lives}[3]{\ensuremath{#1\vdash\textbf{\textup{live}}\,{}#3:#2}}
\newcommand{\livesA}[3]{\ensuremath{#1\vdash\textbf{\textup{live}}\,{}#3}}
\newcommand{\liveCtx}[2]{\ensuremath{#1\models#2}}

\newcommand{\tlive}[3]{\ensuremath{#1\vdash\textbf{\textup{tlive}}~{}#3~:~#2}}
\newcommand{\tliveCtx}[2]{\ensuremath{#2\vdash\textbf{\textup{tlive}}~{}#1}}

\newcommand{\ri}[3]{\ensuremath{#1\vdash\indu{inj}~#3}}



\tikzset{
node distance = 1cm, auto,font=\footnotesize,
every node/.style={node distance=5mm},
core/.style={rectangle, rounded corners, draw, inner sep=5pt, text width=20mm, minimum height=5mm, font=\footnotesize\sffamily},
cora/.style={rectangle, rounded corners, draw, inner sep=5pt, rectangle split, rectangle split parts = 2, text width=30mm, minimum height=5mm, font=\footnotesize\sffamily},
label/.style={rectangle, draw, inner xsep= 5pt, minimum height=0.6cm, font=\footnotesize\sffamily},
}
\tikzstyle{mybox} = [inner sep=5pt, inner ysep=5pt,rounded corners]















\lstset{basicstyle=\small\upshape\ttfamily,
language=Octave,                numbers=left,                   numberstyle=\tiny\color{gray},  stepnumber=1,                                                   mathescape=true,
numbersep=6pt,                  backgroundcolor=\color{white},  showspaces=false,               showstringspaces=false,         showtabs=false,                 tabsize=2,                      captionpos=t,                   breaklines=true,                breakatwhitespace=false,        title=\lstname,                                                 escapeinside={\%*}{*)},         morekeywords={if, then, else, goto, return, fun, let, letrec, in},       columns=flexible
}


\newcommand{\shtodo}[1]{{\color{red} TODO: #1}}

\newcommand{\ndef}[1]{\textbf{#1}}
\newcommand{\devurl}{\url{http://www.ps.uni-saarland.de/~sdschn/master}}
\newcommand{\myref}[1]{\autoref{#1}}

\DeclareDataInheritance{proceedings}{inproceedings}{
\inherit[override=true]{booktitle}{booktitle}
}

\AtEveryBibitem{  \ifentrytype{inproceedings}{}{\clearlist{editors}}  \ifentrytype{inproceedings}{\clearlist{location}\clearfield{volume}\clearfield{series}}{}  \clearfield{booksubtitle}  \clearfield{day}  \clearfield{month}  \clearfield{endday}  \clearfield{endmonth}  \clearfield{endyear}}

\tikzset{
node distance = 1cm, auto,font=\footnotesize,
every node/.style={node distance=5mm},
core/.style={rectangle, rounded corners, draw, inner sep=5pt, text width=16mm, minimum height=5mm, font=\footnotesize\sffamily},
cora/.style={rectangle, rounded corners, draw, inner sep=5pt, rectangle split, rectangle split parts = 2, text width=15mm, minimum height=5mm, font=\footnotesize\sffamily},
label/.style={rectangle, draw, inner xsep= 5pt, minimum height=0.6cm, font=\footnotesize\sffamily},
}


\newcommand{\Ann}{\textup{Ann}}
\newcommand{\ann}[1]{#1}
\newcommand{\anni}[2]{#1\cdot#2}
\newcommand{\annii}[3]{#1\cdot#2,#3}

\newcommand{\alphai}[4]{\ensuremath{#1,#2\vdash#3 \,\sim_\alpha\, #4}}
\newcommand{\alphaie}[4]{\ensuremath{#1,#2\vdash_{\Exp}#3 \,\sim_\alpha\, #4}}

\newcommand{\rmp}{\ensuremath{\rho}}
\newcommand{\rmpp}{\ensuremath{d}}



  \let\llncssubparagraph\subparagraph
  \let\subparagraph\paragraph
   \let\subparagraph\llncssubparagraph


\bibliography{main}
\renewcommand{\bibfont}{\small}

\newsavebox{\topprooftreebox}
\newlength{\topprooftreewidth}

\newcommand{\sigurd}[1]{\par
	\adjustbox{margin=1ex,minipage=\linewidth-4ex-2pt,bgcolor=pink!50,cframe=black
1pt 0pt 0pt,padding=1ex}{#1}\par}
\newcommand{\sigurdi}[1]{
\colorbox{pink!50}{#1}}


\fancypagestyle{fancyplain}{\fancyhf{} \fancyfoot[C]{\textsc{\thepage}} \renewcommand{\headrulewidth}{0pt}
\renewcommand{\footrulewidth}{0pt}
}
\setlength{\headheight}{14pt}
\pagestyle{fancy}
\renewcommand{\headrulewidth}{.5pt}
\renewcommand{\sectionmark}[1]{\markright{\thesection}}
\fancyhf{}
\fancyhead[CO]{\leftmark }
\fancyhead[LO]{ }
\fancyfoot[LO]{}
\fancyfoot[CO]{\textsc{\thepage}}
\fancyfoot[RO]{}



\NewDocumentEnvironment{topprooftree}{m}  {\begin{lrbox}{\topprooftreebox}}  {\DisplayProof\end{lrbox}
\setlength{\topprooftreewidth}{\wd\topprooftreebox}    \begin{minipage}[b][][t]{\topprooftreewidth}      \nrule{\small #1}\1mm]\usebox{\topprooftreebox}
    \end{minipage}
  }

\makeatletter
\newcommand{\shorteq}{  \settowidth{\@tempdima}{-}  \resizebox{\@tempdima}{\height}{=}}
\makeatother

\makeatletter
\newenvironment{btHighlight}[1][]
{\begingroup\tikzset{bt@Highlight@par/.style={#1}}\begin{lrbox}{\@tempboxa}}
{\end{lrbox}\bt@HL@box[bt@Highlight@par]{\@tempboxa}\endgroup}

\newcommand\btHL[1][]{  \begin{btHighlight}[#1]\bgroup\aftergroup\bt@HL@endenv}
\def\bt@HL@endenv{  \end{btHighlight}  \egroup
}
\newcommand{\bt@HL@box}[2][]{  \tikz[#1]{    \pgfpathrectangle{\pgfpoint{1pt}{0pt}}{\pgfpoint{\wd #2}{\ht #2}}    \pgfusepath{use as bounding box}    \node[anchor=base west, fill=orange!30,outer sep=0pt,inner xsep=1pt, inner ysep=0pt, rounded corners=3pt, minimum height=\ht\strutbox,#1]{\raisebox{0pt}{\strut}\strut\usebox{#2}};
  }}
\makeatother

\defbibenvironment{bibliography}
{\begin{enumerate}
{\setlength{\leftmargin}{\bibhang}\setlength{\itemindent}{-\leftmargin}\setlength{\itemsep}{\bibitemsep}\setlength{\parsep}{\bibparsep}}}
{\end{enumerate}}
{\item}

\definecolor{darkgray}{rgb}{0.95,0.95,0.95}
\lstset{language=C++}
\lstset{backgroundcolor=\color{darkgray}}
\lstset{numbers=left, numberstyle=\tiny, stepnumber=1, numbersep=5pt}
\lstset{morekeywords={phi,then,let,letrec,fun,in}}
\lstset{escapeinside=||}
\lstset{moredelim=**[is][\btHL]{`}{`}}
\lstset{moredelim=**[is][{\btHL[fill=green!40]}]{@}{@}}
\lstset{xleftmargin=5.0ex}
\lstset{framextopmargin=0.0ex}







\theoremnumbering{arabic}
\theoremstyle{plain}
\theorembodyfont{\normalfont}

\newtheorem{theorem}{Theorem}

\theoremnumbering{arabic}
\theoremstyle{plain}
\theorembodyfont{\normalfont}

\newtheorem{lemma}{Lemma}
\providecommand*{\lemmaautorefname}{Lemma}

\newtheorem{corollary}{Corollary}
\providecommand*{\corollaryautorefname}{Corollary}

\newtheorem{conjecture}{Conjecture}
\providecommand*{\corollaryautorefname}{Conjecture}

\newtheorem{proposition}{Proposition}
\providecommand*{\propositionautorefname}{Proposition}

\theoremnumbering{arabic}
\theoremstyle{plain}
\theorembodyfont{\normalfont}

\newtheorem{definition}{Definition}
\providecommand*{\definitionautorefname}{Definition}

\theoremnumbering{arabic}
\theoremstyle{plain}
\theorembodyfont{\normalfont}


\providecommand*{\exampleautorefname}{Example}

\theoremstyle{nonumberplain}
\theoremheaderfont{\itshape}
\theorembodyfont{\normalfont}
\theoremsymbol{\ensuremath{_\blacksquare}}
\qedsymbol{\ensuremath{_\blacksquare}}
\newtheorem{proof}{Proof}


\begin{document}


\renewcommand{\sectionautorefname}{Section}
\renewcommand{\subsectionautorefname}{Subsection}
\pagestyle{headings}  \title{A Linear First-Order Functional \\ Intermediate Language for Verified Compilers}
\author{Sigurd Schneider, Gert Smolka, Sebastian Hack\
\eta ::=&~e~|~\extevt&&\quad\textup{extended expression}\\
\Trm\ni{}s,t ::=&~\ilLet{x}{\extexp}{s}&&\quad\textup{variable binding}\\
   |&~\ilIf{e}{s}{t}&&\quad\textup{conditional}\\
   |&~e&&\quad\textup{value}\\
   |&~\ilLetRec{f}{\slist{x}}{s}{t}&&\quad\textup{function definition}\\
   |&~f\,\slist{e}&&\quad\textup{application}
\Evt\ni\evt ::= \tau~|~v=\alpha}
  \UnaryInfC{}
\end{topprooftree}
\begin{topprooftree}{I-App}
  \AxiomC{}
  \AxiomC{}
  \BinaryInfC{}
\end{topprooftree}
\end{center}





 \section{Program Equivalence}
\label{chap:progeq}
\label{sec:prog_eq}
\label{sec:progeq}
To relate programs from different languages, we abstract from
a configuration's internal behavior and only consider
interactions with the environment (via system calls) and termination behavior.
IL's reduction relation forms a labeled transition
 system (LTS) over configurations.

\begin{definition}
A \emph{reduction system} (RS) is a tuple
, s.t.
\begin{multicols}{2}
\begin{enumerate}[label=\textup{(\arabic*)}]
\item  is a LTS
\item 
\item 
\item \red
\end{enumerate}
\end{multicols}
\noindent
An \emph{internally deterministic} reduction system (IDRS) additionally satisfies
\begin{enumerate}[label=\textup{(\arabic*)}]
\setcounter{enumi}{4}
\item  \hfill \textup{action-deterministic} \quad

\item  \hfill \textup{-deterministic} \quad
\end{enumerate}

\end{definition}




\newcommand{\ParTrace}{\ensuremath{\Pi}}
\subsection{Partial Traces}
\newcommand{\prods}{\ensuremath{\triangleright}}
\newcommand{\nil}{\ensuremath{\epsilon}}
We consider two configurations in an IDRS equivalent, if they produce the
same partial traces.
A partial trace  adheres to the following grammar:

We inductively define the relation  such that
 whenever  produces the trace .
In the following, we write trace for partial trace.

\begin{center}\begin{topprooftree}{Tr-Tau}
  \AxiomC{}
  \AxiomC{}
  \BinaryInfC{\raisebox{0pt}[10pt]{}}
\end{topprooftree}\begin{topprooftree}{Tr-End}
  \AxiomC{\phantom{}}
  \UnaryInfC{\raisebox{0pt}[10pt]{}}
\end{topprooftree}
\begin{topprooftree}{Tr-Trm}
  \AxiomC{\red}
  \UnaryInfC{\raisebox{0pt}[10pt]{}}
\end{topprooftree}
\begin{topprooftree}{Tr-Evt}
  \AxiomC{}
  \AxiomC{}
  \BinaryInfC{}
\end{topprooftree}
\end{center}
\newcommand{\Prefixes}{\ensuremath{\mathcal{P}}}
The traces a configuration produces are given as
 .

\newcommand{\PrefixEq}{\ensuremath{\simeq}}
\begin{definition}[Trace Equivalence]

\end{definition}

\begin{lemma}
  silently diverges if and only if .
\end{lemma}












\subsection{Bisimilarity}
\label{sec:bisimilarity}
We give a sound and complete characterization of trace equivalence via bisimilarity.
Bisimilarity enables coinduction as proof method for program equivalence, which is more concise than arguing about traces directly.
We say a configuration  is \emph{ready} if the next step is a system call.
We write
 for
.
We write  (where ) if  such that  is -terminal and .

\begin{definition}[Bisimilarity] Let  be an IDRS.
Bisimilarity  is coinductively defined as the greatest relation closed under the following rules:
\label{def:bisim}
\begin{center}
\begin{topprooftree}{Bisim-Silent}
  \AxiomC{}
  \AxiomC{}
  \AxiomC{}
  \doubleLine
  \TrinaryInfC{}
\end{topprooftree}
\begin{topprooftree}{Bisim-Term}
  \AxiomC{}
  \AxiomC{}
  \doubleLine
  \BinaryInfC{}
\end{topprooftree}
\end{center}
\begin{center}
\begin{topprooftree}{Bisim-Extern}
  \Axiom
    \Axiom
  \Axiom
  \Axiom
  \Axiom
  \doubleLine
  \QuinaryInfC{}
\end{topprooftree}
\end{center}
\end{definition}
\nrule{Bisim-Silent} allows to match finitely many steps on both sides, as long as all transitions are silent.
This makes sense for IDRS, but would not yield a meaningful definition otherwise.
\nrule{Bisim-Extern} ensures that every external transition of  is matched by the same external transition of , and vice versa.
This ensures that if two programs are in relation, they react to every possible result value of the external call in a bisimilar way.
The premises that  are ready is there to simplify case distinctions by ensuring that the next event cannot be .

\begin{theorem}[Soundness and Completeness]
Let  be an IDRS and . Then:

\end{theorem}

The semantics of IL and of IL/I each forms an IDRS. We define  such that  if  is of the form  and . Otherwise, . The definitions for IL/I are analogous.
To relate configurations IL to IL/I, we form a reduction system on the sum  of the configurations and lift  and  accordingly.
It is easy to see that the resulting reduction system is internally deterministic.
If not clear from context, we use an index ,  to indicate which language a configuration belongs to.







































 \section{Invariance}
\label{sec:invariance}
We call a term \emph{invariant} if it has the same traces in both the functional and the imperative interpretation.

\begin{definition}[Invariance]
\label{def:invariance}
A closed program  is invariant if\end{definition}
Invariance is undecidable.
We develop a syntactic, efficiently decidable criterion sufficient for invariance, which we call coherence.
Coherence simplifies the translation between IL and IL/I.


Coherence is based on the observation that some IL programs do not really depend on information from the closure.
Assume  and consider the following IL reduction according to rule \nrule{App}:

If  agrees with~ on all variables  that  depends on, then the configuration could have equivalently reduced to .
This reduction does not require the closure  and is similar in spirit to the rule \nrule{I-App}.
Coherence is a syntactic criterion that ensures  and  agree on a suitable set  at every function application.
We proceed in two steps:
\begin{enumerate}
\item \myref{sec:liveness} introduces the notion of live variables, which identifies a set that contains all variables a program depends on.
\item \myref{sec:coherence} gives the inductive definition of coherence and shows that coherent programs are invariant.
\end{enumerate}








 \section{Liveness}
\label{chap:liveness}
\label{sec:liveness}
A variable  is \emph{significant} to a program~ and a context~,
if there is an environment~ and a value~ such that .
Significance is not decidable, as it is a non-trivial semantic property.

Liveness analysis is a standard technique in compiler construction to over-approximate the set of variables significant to the evaluation of an imperative program.
While usual characterizations of live variables rely on data-flow equations~\cite{Nipkow:2014},
we define liveness inductively on the structure of IL's syntax.
To the best of our knowledge, such an inductive definition is not in literature.
The inductive definition factorizes the correctness aspect from the algorithmic aspect of liveness analysis.

We embed liveness information in the syntax of IL by introducing annotations
for function definitions: The term  is annotated with a set of variables .






\subsection{Inductive Definition of the Liveness Judgment}

We define inductively the judgment \ndef{live}, which characterizes sound results of a liveness analysis.
\begin{center}
\begin{tabular}{lcrll}
 \multirow{3}{*}{}&
 \multirow{3}{*}{~~where~~}
 &&&~liveness for functions\\
 &&&&~live variables\\
 &&&&~expression
\end{tabular}
\end{center}
The predicate  can be read as
\textit{ contains all variables significant to  in any context satisfying the assumptions .}
The context~ records for every function  a set of variables  that we call the \ndef{globals} of .
Assuming  are the parameters of , we will arrange things such that the set  contains all variables significant for the body of ,
but never a parameter of : .
Throughout the paper,  is always a (partial) mapping from labels to globals,
and  denotes a set of variables.



\begin{figure}[ht]
\begin{center}
  \begin{topprooftree}{Live-Op}
    \AxiomC{}
    \noLine
    \UnaryInfC{}
    \AxiomC{}
    \noLine
    \UnaryInfC{}
    \BinaryInfC{}
  \end{topprooftree}
  \begin{topprooftree}{Live-Exp}
    \AxiomC{}
    \UnaryInfC{}
  \end{topprooftree}
  \begin{topprooftree}{Live-App}
    \AxiomC{}
    \AxiomC{}
    \BinaryInfC{}
  \end{topprooftree}
\end{center}
\begin{center}
  \begin{topprooftree}{Live-Cond}
    \AxiomC{}
    \noLine
    \UnaryInfC{}
    \AxiomC{}
    \noLine
    \UnaryInfC{}
    \BinaryInfC{}
  \end{topprooftree}
  \begin{topprooftree}{Live-Fun}
    \Axiom
    \noLine
    \UnaryInf
    \Axiom
    \noLine
    \UnaryInf
    \BinaryInfC{}
  \end{topprooftree}
\end{center}
\caption{Liveness: An approximation of the significant variables for IL/I}
\label{fig:liveness}
\end{figure}
\subsubsection{Description of the Rules.}
\nrule{Live-Op}
 ensures that all variables free in  are live.
Every live variable of the continuation  except  must be live at the assignment.
We require  to be live in the continuation.
\nrule{Live-Cond} ensures that the live variables of a conditional at least contain the free variables of the condition, and the variables live in the consequence and alternative.
\nrule{Live-Exp} ensures that for programs consisting of a single expression~ at least the free variables of~ are live.
\nrule{Live-App} ensures that the free variables of every argument are live, and that the globals  of~ are live at the call site.
\nrule{Live-Fun} records the annotation  as globals for  in , ensures that  is a large enough live set for the function body, and that  does not contain parameters of~.
The live variables~ of the continuation~ must be live at the function definition.



\begin{theorem}[Liveness is Decidable]
  For all ,  and annotated , it is efficiently decidable whether  holds.
\label{thm:live_dec}
\end{theorem}
The proof of \myref{thm:live_dec} is constructive and yields an efficient, extractable decision procedure.
The decision procedure recursively descends on the program structure,
checking the conditions of the appropriate rule in every step.



\subsection{Liveness Approximates Significance}
We show that the live variables approximate the significant variables.
We write  if a context  satisfies the assumptions~,
and define:

\begin{center}
  \begin{topprooftree}{LiveCtx1}
    \AxiomC{}
    \AxiomC{}
    \AxiomC{}
      \TrinaryInfC{}
  \end{topprooftree}
  \begin{topprooftree}{LiveCtx2}
    \AxiomC{}
    \UnaryInfC{}
  \end{topprooftree}
  \begin{topprooftree}{Coh-App}
    \AxiomC{}
    \UnaryInfC{}
  \end{topprooftree}
\end{center}
\begin{center}
\small
  \begin{topprooftree}{Coh-Cond}
    \AxiomC{}
    \AxiomC{}
    \BinaryInfC{}
  \end{topprooftree}
  \begin{topprooftree}{Coh-Fun}
    \AxiomC{}
    \AxiomC{}
    \BinaryInfC{}
  \end{topprooftree}
\end{center}



\subsubsection{Description of the Rules.}
\nrule{Coh-Op} deals with binding a variable .
Every function that has  as a global (i.e. ) becomes unavailable, and must be removed from .
We write  to remove all definitions from  that require more globals than . Trivally, .
To remove all definitions from  that use  as global, we use .

Formally, the definition of \restrict{\LT}{X} exploits the list structure of contexts:
\begin{center}
\begin{minipage}{.4\textwidth}

\end{minipage}
\begin{minipage}{.55\textwidth}

\end{minipage}
\end{center}
\nrule{Coh-App} ensures only available functions can be applied, since  maps functions that are not available to~.
\nrule{Coh-Fun} deals with function definitions.
When the definition of a function  is encountered, its globals   according to the annotation are recorded in~.
In the function body~, only functions that require at most  as globals are available, so the
context is restricted to .




\begin{theorem}[Coherence is Decidable]
  For all  and annotated~, it is efficiently decidable whether  holds.
\label{thm:coh_dec}
\end{theorem}












\subsection{Coherent Programs are Invariant}
Given a configuration  such that , the \textbf{agreement invariant} describes a correspondence between the values of variables in the function closure  and the environment .
If the closure of~ is available, the closure environment~ agrees with the primary environment~ on~'s globals~: {}.
We write  if  (where  and  ).

Function application continues evaluation with the function body from the closure.
Assume  and consider the IL reduction:

If coherence is to be preserved,  must be coherent under suitable assumptions.
We say ~approximates  if whenever  is defined, it agrees with~ and define
.
The \ndef{context coherence} predicate \cohCtx{F}{\LT} ensures that all function bodies in closures are coherent.
It is defined inductively on the context:
\begin{center}
  \begin{topprooftree}{CohC-Emp}
    \AxiomC{}
    \UnaryInfC{}
  \end{topprooftree}
  \begin{topprooftree}{CohC-Bot}
    \AxiomC{}
    \UnaryInfC{}
  \end{topprooftree}
  \begin{topprooftree}{CohC-Con}
    \AxiomC{}
    \noLine
    \UnaryInfC{}
    \UnaryInfC{}
  \end{topprooftree}
\end{center}
\nrule{CohC-Con} encodes two requirements:
First, the body of~ must be coherent under the context restricted to the globals  of  (cf. \nrule{Coh-Fun}).
Second,  must suffice as live variables for the function body  under some assumptions~ such that  approximates .
Approximation ensures stability under restriction: .






We define  and lift \M{strip} pointwise to contexts.




\begin{theorem}[Coherence implies Invariance]
Let  and  and  such that .
Then for all  such that , it holds
.
\label{cor:main_thm}
\end{theorem}
\myref{cor:main_thm} reduces the problem of translating between IL/I and IL to the problem of establishing coherence.
For the translation from IL to IL/I, it suffices to establish coherence while preserving IL semantics.
Since SSA and functional programming correspond~\cite{Kelsey:1995, DBLP:journals/sigplan/Appel98},
the translation from IL/I to IL can be seen as~SSA construction~\cite{DBLP:journals/toplas/CytronFRWZ91}, and the translation from IL to IL/I, which we treat in the next section, as SSA destruction.















\section{Translating from IL/F to IL/I via Coherence}
\label{trans:fct}
\label{sec:destr}
\label{sec:rassign}
\label{sec:il:funcoh}
 The simplest method to establish coherence while preserving IL semantics is -renaming the program apart.
A renamed-apart program (for formal definition see \myref{sec:renamedapart}) is coherent, since every function is always available.
The properties of -conversion ensure semantic equivalence.

We present an algorithm that establishes coherence and uses no more different names than the maximal number of simultaneously live variables in the program.
This algorithm corresponds to the assignment phase of SSA-based register allocation~\cite{DBLP:conf/cc/HackGG06}. The algorithm requires a renamed-apart program as input to ensure that every consistent renaming can be expressed as a function from .
We proceed in two steps:
\begin{enumerate}
\item We define the notion of \emph{local injectivity} for a function .
      We show that renaming with a locally injective  yields an -equivalent and coherent program .
\item We give an algorithm  and show that it constructs a locally injective  that uses the minimal number of different names.
\end{enumerate}






\newcommand{\sterm}{\ensuremath{s}}
\newcommand{\tterm}{\ensuremath{t}}
We introduce \textbf{more liveness annotations} before every term in the syntax, i.e. wherever a term  appeared before, now a term  appears that annotates  with the set .
From now on,  range over such annotated terms.
We define the projection .
The annotation corresponds directly to the live set parameter  of the relation , hence it suffices to write  for annotated programs.

\subsection{Local Injectivity}
We define inductively a judgment  where  and  is an annotated program.
We use the following notation for injectivity on~:

The rules defining the judgement are given below and require  to be injective on every live set  annotating any subterm:




\begin{center}
\small
  \begin{topprooftree}{Inj-Op}
    \AxiomC{}
    \AxiomC{}
    \BinaryInfC{}
  \end{topprooftree}
  \begin{topprooftree}{Inj-Val}
    \AxiomC{}
    \UnaryInfC{}
  \end{topprooftree}
  \begin{topprooftree}{Inj-App}
    \AxiomC{}
    \UnaryInfC{}
  \end{topprooftree}
\end{center}
\begin{center}
\small
  \begin{topprooftree}{Inj-Cond}
    \AxiomC{}
    \AxiomC{}
    \AxiomC{}
    \TrinaryInfC{}
  \end{topprooftree}
  \begin{topprooftree}{Inj-Fun}
    \AxiomC{}
    \AxiomC{}
    \AxiomC{}
    \TrinaryInfC{}
  \end{topprooftree}
\end{center}



Let  be the set of variables that occur in a binding position in~, and \freenam{s} be the set of free variables of .
For our theorems, several properties are required:
\begin{enumerate}[label=(\arabic*)]
\item The program must be without unreachable code, i.e.
in every subterm  it must be the case that  is applied in .
\item A variable in  must not occur in a set of globals in .
We define .
\item A variable in  must not occur in the annotation .
We write  if for every subterm  of  it holds that every  is either
in  or bound at  in .
\end{enumerate}
For renamed-apart programs, these conditions ensure that the live set  in \nrule{Inj-Fun} always contains the globals  of  (cf. \nrule{Live-App}).

\begin{theorem}
\label{thm:inj_coh}
Let  be a renamed-apart program without unreachable code such that ,
 and . Then

\end{theorem}
\myref{thm:inj_coh} states that the renamed program  is coherent under the assumptions , i.e. the point-wise image of  under .


Renaming with a locally injective renaming produces an -equivalent program (for formal definition see \myref{sec:alphaequiv}), and hence preserves program equivalence:


\begin{theorem}
\label{thm:inj_alpha}
Let  be a renamed-apart program without unreachable code such that ,  and .
Let  such that  is the inverse of  on . Then

\end{theorem}










\newcommand{\ra}[3]{\ensuremath{\mathit{rassign}\,#3\,#1}}
\newcommand{\freshv}{\ensuremath{\mathit{fresh}}}
\newcommand{\fresh}[1]{\ensuremath{\freshv\,#1}}
\newcommand{\freshl}[2]{\ensuremath{\mathit{freshlist}\,#1\,#2}}

\subsection{A Simple Register Assignment Algorithm}
\label{sec:ra_algo}


The algorithm \textup{rassign} is parametrized by a function  of which we require  for all finite sets of variables .
Based on , we define a function  that yields a list of  pairwise-distinct variables such that .
The SSA algorithm must process the program in an order compatible with the dominance order to work~\cite{DBLP:conf/cc/HackGG06}.
In our case it suffices to simply recurse on  as follows:


We prove in \myref{thm:rassign_corr} that the algorithm is correct for any choice of  and ,
as long as they satisfy the specifications above.

\begin{theorem}
Let  be renamed-apart such that ,  and .
Let  be injective on .
Then: .

\label{thm:rassign_corr}
\end{theorem}

\newcommand{\occurvars}[1]{\ensuremath{\mathcal{V}_O(#1)}}
\newcommand{\segment}[1]{\ensuremath{\mathcal{S}(#1)}}

Our implementation of  implements the heuristic of simply choosing the smallest unused variable.
\myref{thm:rassign_bound} shows that for this choice of , the largest live set determines the number of required names.
We use  to denote the set of the  smallest variables, and
 to denote the set of variables occurring (free or in a binding position) in .
\begin{theorem}
Assume  yields a variable less or equal to .
Let  be renamed-apart such that ,  and .
Let  be the size of the largest set of live variables in , and .
If  then
.
\label{thm:rassign_bound}
\end{theorem}
We prove a slightly generalized version of \myref{thm:rassign_bound} by induction on .





\section{Formal Coq Development}
\label{sec:formdev}
Each theorem and lemma in this paper is proven as part of a larger Coq development,
which is available online\footnote{\url{http://www.ps.uni-saarland.de/~sdschn/publications/lvc15}}.
The development extracts to a simple compiler that, for instance, produces program~(b) when given program~(a) from the introduction as input.

The formalization uses De-Bruijn representation for labels, and named representation for variables.
Notable differences to the paper presentation concern the treatment of annotations, the technical realization of the definition of liveness, and the inductive generalizations of Theorems~6-9.

 \section{Conclusion}
We presented the functional intermediate language IL and developed the notion of coherence, which
provides for a canonical and verified translation between functional and imperative programs.
We formulated an register assignment algorithm by recursion on the structure of IL that achieves the same bound on the number of required registers as SSA-based register assignment.
Coherence allowed us to justify correctness without directly arguing about program semantics by proving that the algorithm -renames to a coherent program.

\enlargethispage{6mm}



\label{chap:conclusion}
\label{sec:conclusion}


















\section{Appendix}

\subsection{Table of Variable Names and Types}

\begin{tabular}{lll}
\textbf{Variable}&\textbf{Type}&\textbf{comment}\\
 & set & set of values\\
 &  & conversion to truth value\\
 &  & value\\
 & set & set of expressions\\
 & set & set of variables\\
 &  & expression\\
 &  & variables\\
 & set & set of lables\\
 &  & labels\\
 & set & set of actions  \\
 &   & extended expression \\
 &  & action  \\
 & set & set of terms\\
 &  & terms\\
 &  & environment\\
 & set & set of closures\\
 & context of  &\\
 & set & set of events\\
 &  & event\\
 &  & silent event\\
 & set & set of blocks \\
 & context of  & \\
 & set & set of states (LTS)\\
 &  & state, configuration\\
 & set & set of partial traces\\
 &  & partial trace \\
 &  & empty trace\\

\end{tabular}


\subsection{-Equivalence}
\label{sec:alphaequiv}
We formalize a generalization of alpha equivalence as an inductively defined judgment
 where  and  are terms.
The mapping~ describes how the free variables of  map to free variables of~,
and~ describes how the free variables of~ map to free variables of~.
If  holds, then  is the inverse of  on
, i.e. 
Symmetrically,  is the inverse of  on
.

The formalization assumes a similar judgment  for -equivalence of expressions.
The variable case of judgment for expressions explains how  and  are used:
\begin{center}
\begin{topprooftree}{Alpha-Var}
  \AxiomC{}
  \AxiomC{}
  \BinaryInfC{}
\end{topprooftree}
\end{center}
\nrule{Alpha-Var} ensures that  maps  to  and  maps  to .

The other rules of the expression judgment are structurally recursive and we omit them.

\begin{figure}[htb]
\begin{center}
  \begin{topprooftree}{Alpha-Op}
    \AxiomC{}
    \AxiomC{}
    \BinaryInfC{}
  \end{topprooftree}
  \begin{topprooftree}{Alpha-Val}
    \AxiomC{}
    \UnaryInfC{}
  \end{topprooftree}
\end{center}
\begin{center}
  \begin{topprooftree}{Alpha-App}
    \AxiomC{}
    \UnaryInfC{}
  \end{topprooftree}
  \begin{topprooftree}{Alpha-Cond}
    \AxiomC{}
    \AxiomC{}
    \noLine
    \UnaryInfC{}
    \BinaryInfC{}
  \end{topprooftree}
\end{center}

\begin{center}
  \begin{topprooftree}{Alpha-Fun}
    \AxiomC{}
    \AxiomC{}
    \AxiomC{}
    \TrinaryInfC{}
  \end{topprooftree}
\end{center}

\caption{Inductive judgment generalizing -equivalence}
\label{fig:alpha}
\end{figure}

The relation has several pleasant properties.
\begin{lemma}[Reflexivity]

\end{lemma}

\begin{lemma}[Symmetry]

\end{lemma}

\begin{lemma}[Transitivity]

\end{lemma}


We validate our definition and prove soundness with respect to trace equivalence .
We define 
We relate two closures in the following way:

We then lift  point-wise to contexts of the same length.

\begin{theorem}
If  and 
then .
\end{theorem}

In the formal development we have an additional formalization of IL which uses De-Bruijn representation also for variables (and not just for labels).
We give a translation from the named IL to De-Bruijn IL, and prove this translation correct with respect to trace equivalence.
We then show that terms that are -equivalent by our inductive definition translate to identical terms in De-Bruijn representation.










 \newcommand{\apart}[3]{\ensuremath{#1\vdash#2\,\textbf{apart}\, #3}}

\newcommand{\vs}{\ensuremath{X}}

\subsection{Definition of Renamed Apart}
\label{sec:renamedapart}
A program is renamed apart, if every variable  occurring in a binding position does not occur free and  is different from every variable occurring in a different binding position.
We formulate an inductive predicate \apart{\vs}{s}{\vs'} that ensures this property.
The predicate maintains the invariant that all free variables of  are in ,
and that  contains exactly the variables occurring in binding positions in .

\begin{figure}[htb]
\begin{center}
  \begin{topprooftree}{Apart-Op}
    \AxiomC{}
    \AxiomC{}
    \BinaryInfC{}
  \end{topprooftree}
  \begin{topprooftree}{Apart-Val}
    \AxiomC{}
    \UnaryInfC{}
  \end{topprooftree}
\end{center}
\begin{center}
  \begin{topprooftree}{Apart-App}
    \AxiomC{}
    \UnaryInfC{}
  \end{topprooftree}
  \begin{topprooftree}{Apart-Cond}
    \AxiomC{}
    \noLine
    \UnaryInfC{}
    \AxiomC{}
    \noLine
    \UnaryInfC{}
    \BinaryInfC{}
  \end{topprooftree}
\end{center}

\begin{center}
  \begin{topprooftree}{Apart-Fun}
    \AxiomC{}
    \noLine
    \UnaryInfC{}
    \AxiomC{}
    \AxiomC{}
    \noLine
    \UnaryInfC{}
    \TrinaryInfC{}
  \end{topprooftree}
\end{center}

\caption{Inductive definition of renamed apart}
\label{fig:apart}
\end{figure}

\begin{lemma}[Disjoint]
If  then .
\end{lemma}

\begin{lemma}[Relation to free and bound variables]
If  and then  and .
\end{lemma}

\subsection{A Procedure to Rename Apart}

\renewcommand{\ra}[3]{\mathit{apart}\,#1\,#2\,#3}

We define the procedure  such that  ensures  is renamed apart and -equivalent to .  contains the newly chosen variables now occurring in binding positions in .
\myref{thm:apart_correct} and \myref{thm:apart_alpha} make these claims precise.



\begin{theorem}[\textnormal{\textit{apart}} renames apart]
Let  be a program such that  and .
Then: .
\label{thm:apart_correct}
\end{theorem}

\begin{theorem}[Renaming apart respects -conversion]
\label{thm:apart_alpha}
Let  be a program such that  and  and
let  be inverse to  on .
Then .
\end{theorem}

 \subsection{Joining the Parts}
This section describes how the theorems proven in this paper fit together in a compiler.
Assume that the compiler uses IL as an intermediate language, and now wants to produce code for an IL program . The compiler procedes as follows:

\begin{enumerate}
 \item Rename  apart, obtaining an -equivalent program  (\myref{thm:apart_alpha}).
 \item Run the algorithm  on  to obtain a register assignment .
       Theorem \myref{thm:rassign_corr} ensures  is locally injective.
 \item Rename  accoding to  and obtain , which is -equivalent
   (\myref{thm:inj_alpha}) and coherent (\myref{thm:inj_coh}) because  is locally injective.
 \item Theorem \myref{cor:main_thm} ensures that  can be seen equivalently as an IL/I program,
       hence the functional program  has been translated to an imperative program .
\end{enumerate}

\printbibliography



\end{document}
