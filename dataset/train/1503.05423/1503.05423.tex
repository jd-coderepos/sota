\documentclass[a4paper,UKenglish]{lipics}
 
\usepackage{microtype}


\bibliographystyle{plain}

\title{Rank logic is dead, long live rank logic!}

\author{Erich Grädel}
\author{Wied Pakusa}
\affil{Mathematical Foundations of Computer Science, RWTH Aachen University\\
  \texttt{\{graedel,pakusa\}@logic.rwth-aachen.de}}
\authorrunning{E.\,Grädel and W.\,Pakusa}
\Copyright{Erich Grädel and Wied Pakusa}




\usepackage{mathtools}
\usepackage{fixltx2e}
\usepackage{xspace}
\usepackage{xcolor}
\usepackage{enumerate}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{MnSymbol}
\usepackage{amsthm}
\usepackage{booktabs}
\usepackage{blindtext}
\usepackage{bbm}
\usepackage{graphicx}
\usepackage{todonotes}

\usepackage[]{fixme}

\usepackage{tikz}
\usetikzlibrary{arrows,shapes,positioning,arrows,decorations,calc,
decorations.pathmorphing,decorations.pathreplacing}
\tikzset{every picture/.style={>=stealth,thick}}






\makeatletter
\newcommand{\@abbrev}[3]{
  \def\c@a@def##1{
      \if ##1.
        \relax
      \else
        \@ifdefinable{\@nameuse{#1##1}}{\@namedef{#1##1}{#2##1}}
        \expandafter\c@a@def
      \fi
    }
  \c@a@def #3.
}
\@abbrev{bb}{\mathbb}{ABCDEFGHIJKLMNOPQRSTUVWXYZ}
\@abbrev{bf}{\mathbf}{ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz}
\@abbrev{bit}{\boldsymbol}{ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz}
\@abbrev{mc}{\mathcal}{ABCDEFGHIJKLMNOPQRSTUVWXYZ}
\@abbrev{mf}{\mathfrak}{ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz}
\@abbrev{rm}{\mathrm}{ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz}
\@abbrev{scr}{\mathscr}{ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz}
\@abbrev{sf}{\mathsf}{ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz}
\makeatother


\newcommand{\cf}{cf.\xspace}


\newcommand{\limp}{\rightarrow}

\newcommand{\defeq}{:=}
\newcommand{\defiff}{\,\, :\Longleftrightarrow \,\,}
\newcommand{\isom}{\cong}
\newcommand{\nisom}{\not\cong}
\newcommand{\isoto}
{\xrightarrow{\raisebox{-0.3em}[0 em][0 em]{\ensuremath{\sim}}}}
\newcommand{\inseg}[1]{\ensuremath{[#1]}}
\newcommand{\card}[1]{\ensuremath{|#1|}}
\newcommand{\sgn}{\ensuremath{\textrm{sgn}}}
\newcommand{\modulo}{\ensuremath{\text{mod }}}
\newcommand{\dom}{\ensuremath{\textrm{dom}}}
\newcommand{\Primes}{\bbP}
\newcommand{\symdiff}{\triangle}

\newcommand{\ordg}[1]{|#1|}
\newcommand{\gengroup}[1]{\langle #1 \rangle}
\newcommand{\Orbit}{\ensuremath{\textrm{Orbit}}\xspace}
\newcommand{\Orbitx}[1]{\ensuremath{\textrm{Orbit}^{#1}}\xspace}
\newcommand{\Stab}{\ensuremath{\textrm{Stab}}\xspace}
\newcommand{\Stabx}[1]{\ensuremath{\textrm{Stab}^{#1}}\xspace}
\newcommand{\Stabp}{\ensuremath{\textrm{Fix}}\xspace}
\newcommand{\Stabpx}[1]{\ensuremath{\textrm{Fix}^{#1}}\xspace}


\newcommand{\pcycle}[1]{\ensuremath{( \, #1 \, )}\xspace}


\newcommand{\ideal}[1]{\mathfrak{#1}}
\newcommand{\idealeq}{\trianglelefteq}
\newcommand{\idealgeq}{\trianglerighteq}

\newcommand{\units}[1]{\ensuremath{#1^{*}}}
\newcommand{\ringbase}[1]{\ensuremath{\mathcal{B}(#1)}}

\newcommand{\lockring}[1]{\ensuremath{\mathcal{LR}_{#1}}}

\newcommand{\field}[1]{\mathbb{#1}}

\newcommand{\TC}{\ensuremath{\textsc{TC}}\xspace}
\newcommand{\GL}{\ensuremath{\textsc{GL}}\xspace}
\newcommand{\Aut}{\ensuremath{\text{Aut}}\xspace}
\newcommand{\Sym}{\ensuremath{\text{Sym}}\xspace}
\newcommand{\Iso}{\ensuremath{\text{Iso}}\xspace}


\newcommand{\con}{\ensuremath{\text{con}}\xspace}


\newcommand{\onevec}{\ensuremath{\mathbbm{1}}}
\newcommand{\zerovec}{\ensuremath{\vec{0}}}
\newcommand{\kernel}{\text{ker}}

\newcommand{\N}{\ensuremath{\bbN}}
\newcommand{\Z}{\ensuremath{\bbZ}}


\newcommand{\arity}{\ensuremath{\text{ar}}}
\newcommand{\Str}{\ensuremath{\mathscr{S}}}

\newcommand{\logic}[1]{\ensuremath{\textsc{#1}}\xspace}
\newcommand{\Logi}{\ensuremath{\mathscr{L}}\xspace}
\newcommand{\FO}{\logic{FO}}
\newcommand{\FOC}{\logic{FOC}}
\newcommand{\MSO}{\logic{MSO}}
\newcommand{\DTC}{\logic{DTC}}
\newcommand{\STC}{\logic{STC}}

\newcommand{\FP}{\logic{FP}}
\newcommand{\LFP}{\logic{LFP}}

\newcommand{\FPC}{\logic{FPC}}
\newcommand{\FPRK}{\logic{FPR}}
\newcommand{\FPR}{\FPRK}

\newcommand{\CPT}{\logic{CPT}}
\newcommand{\BGS}{\logic{BGS}}


\newcommand{\FOSp}{\ensuremath{\logic{FOS}_p}\xspace}
\newcommand{\FOSx}[1]{\ensuremath{\logic{FOS}_{#1}}\xspace}
\newcommand{\FPSp}{\ensuremath{\logic{FPS}_p}\xspace}
\newcommand{\FPS}{\ensuremath{\logic{FPS}}\xspace}
\newcommand{\FPSvar}{\ensuremath{\logic{FPS}^*}\xspace}
\newcommand{\FPSx}[1]{\ensuremath{\logic{FPS}_{#1}}\xspace}
\newcommand{\FORp}{\ensuremath{\logic{FOR}_p}\xspace}
\newcommand{\FOR}{\ensuremath{\logic{FOR}}\xspace}
\newcommand{\FORx}[1]{\ensuremath{\logic{FOR}_{#1}}\xspace}
\newcommand{\FPRp}{\ensuremath{\logic{FPR}_p}\xspace}
\newcommand{\FPRvar}{\ensuremath{\logic{FPR}^*}\xspace}
\newcommand{\FPRx}[1]{\ensuremath{\logic{FPR}_{#1}}\xspace}

\newcommand{\INFCk}{\ensuremath{\logic{C}^k_{\infty\omega}}\xspace}
\newcommand{\INFCkx}[1]{\ensuremath{\logic{C}^{#1}_{\infty\omega}}\xspace}




\newcommand{\ifp}{\ensuremath{\textsf{ifp}}\xspace}
\newcommand{\slv}{\ensuremath{\textsf{slv}}\xspace}
\newcommand{\slvp}{\ensuremath{\textsf{slv}_p}\xspace}
\newcommand{\rkp}{\ensuremath{\textsf{rk}_p}\xspace}
\newcommand{\rkx}[1]{\ensuremath{\textsf{rk}_{#1}}\xspace}
\newcommand{\rk}{\ensuremath{\textsf{rk}^*}\xspace}
\newcommand{\rankk}{\ensuremath{\textsf{rk}}\xspace}


\newcommand{\Ckeqv}{\ensuremath{\equiv^C_k}\xspace}
\newcommand{\Ckeqvx}[1]{\ensuremath{\equiv^C_{#1}}\xspace}



\newcommand{\qr}{\ensuremath{\text{qr}}\xspace}

\newcommand{\compclass}[1]{\ensuremath{\textsc{#1}}\xspace}
\newcommand{\PTIME}{\compclass{Ptime}}
\newcommand{\NP}{\compclass{NP}}
\newcommand{\NCx}[1]{\ensuremath{\textsc{NC}^{#1}}\xspace}
\newcommand{\MODLx}[1]{\ensuremath{\textsc{MOD}_{#1}\textsc{L}}\xspace}

\renewcommand{\phi}{\varphi}

\newcommand{\lintdom}[1]{\ensuremath{#1_{\delta}}}
\newcommand{\lintcong}[1]{\ensuremath{#1_{\approx}}}

\newcommand{\ba}{{\bar a}}
\newcommand{\bb}{{\bar b}}
\newcommand{\bc}{{\bar c}}
\newcommand{\bd}{{\bar d}}
\newcommand{\be}{{\bar e}}
\newcommand{\bm}{{\bar m}}
\newcommand{\bn}{{\bar n}}
\newcommand{\bp}{{\bar p}}
\newcommand{\bv}{{\bar v}}
\newcommand{\bx}{{\bar x}}
\newcommand{\by}{{\bar y}}
\newcommand{\bz}{{\bar z}}
\newcommand{\bmu}{{\bar \mu}}
\newcommand{\bnu}{{\bar \nu}}




\newcommand{\lindq}{\ensuremath{\mcQ}}


\newcommand{\red}[1]{\ensuremath{\leq_{#1}}}
\newcommand{\redtt}[1]{\ensuremath{\leq^{\mathrm{tt}}_{#1}}}
\newcommand{\redmo}[1]{\ensuremath{\leq^{\mathrm{m}}_{#1}}}
\newcommand{\redeq}[1]{\ensuremath{\equiv_{#1}}}
\newcommand{\redeqtt}[1]{\ensuremath{\equiv^{\mathrm{tt}}_{#1}}}
\newcommand{\redeqmo}[1]{\ensuremath{\equiv^{\mathrm{m}}_{#1}}}


\newcommand{\vct}[1]{\vec{#1}}	

\newcommand{\vocRing}{\tau_{\text{ring}}}
\newcommand{\vocModule}{\tau_{\text{module}}}
\newcommand{\vocGroup}{\tau_{\text{group}}}
\newcommand{\vocMatrix}{\tau_{\text{mat}}}
\newcommand{\vocMatrixRingFixed}[1]{\vocMatrix(#1)}
\newcommand{\vocMatrixPair}{\tau_{\text{mpair}}}
\newcommand{\vocMatrixOrd}{\tau_{\text{mat}}^\leqslant}
\newcommand{\vocMatrixPairOrd}{\tau_{\text{mpair}}^\leqslant}
\newcommand{\vocVector}{\tau_{\text{vec}}}
\newcommand{\vocVectorOrd}{\tau_{\text{vec}}^\leqslant}
\newcommand{\vocLinEqRing}{\tau_{\text{les-r}}}
\newcommand{\vocLinEqRingFixed}[1]{\tau_{\text{les}}(#1)}
\newcommand{\vocLinEqRingOrd}{\tau_{\text{les-r}}^\leqslant}
\newcommand{\vocLinEqGroup}{\tau_{\text{les-g}}}
\newcommand{\vocLinEqModule}{\tau_{\text{les-m}}}
\newcommand{\vocLinEqModuleOrd}{\tau_{\text{les-m}}^\leqslant}
\newcommand{\vocLinEqFp}{\tau_{\text{les}}(\field F_p)}


\newcommand{\sles}{\ensuremath{\textsc{Ls}}\xspace}
\newcommand{\solvablesles}{\ensuremath{\textsc{SLs}}\xspace}


\newcommand{\Solve}[1]{\ensuremath{\textsc{Slv#1}}\xspace}
\newcommand{\SolveOrd}[1]{\ensuremath{\textsc{Slv#1}_\leqslant}\xspace}

\newcommand{\SolveField}{\Solve{F}}


\newcommand{\SolveRing}{\Solve{R}}
\newcommand{\SolveOrdRing}{\SolveOrd{R}}

\newcommand{\SolveComRing}{\Solve{CR}}
\newcommand{\SolveOrdComRing}{\SolveOrd{CR}}


\newcommand{\SolveLocalRing}{\Solve{LR}}
\newcommand{\SolvekLocalRing}{\Solve{LR}_k}

\newcommand{\SolveGroup}{\Solve{G}}
\newcommand{\SolveCycGroup}{\Solve{CG}}

\newcommand{\SolveModule}{\Solve{M}}
\newcommand{\SolveOrdModule}{\SolveOrd{M}}

\newcommand{\AlgebraicClass}[1]{\ensuremath{\textsc{#1}}\xspace}

\newcommand{\AGroups}{\AlgebraicClass{AGroups}}

\newcommand{\Modules}{\AlgebraicClass{Modules}}

\newcommand{\complexityclass}[1]{\ensuremath{\textsc{#1}}\xspace}
\newcommand{\LOGSPACE}{\complexityclass{Logspace}}





\colorlet{blau}{blue!50}
\newcommand{\lightercolor}[3]{\colorlet{#3}{#1!#2!white}
}

\newcommand{\darkercolor}[3]{\colorlet{#3}{#1!#2!black}
}
\lightercolor{blau}{50}{hellblau}







\theoremstyle{plain}
\newtheorem{prop}[theorem]{Proposition}


\newcommand{\eqcount}{\ensuremath{
\stepcounter{equation}
\tag{E \theequation}
}
}

\newcommand{\eqcountreset}
{
\setcounter{equation}{0}
}
\newenvironment{claim}[1]{\par\noindent\textbf{Claim:}\space 
{#1}}{}
\newenvironment{claimproof}[1]{\par\noindent\textit{Proof of 
claim:}\space#1}
{\leavevmode\unskip\penalty9999 \hbox{}\nobreak\hfill\quad\hbox{
}}






\begin{document}

\maketitle

\begin{abstract}
Motivated by the search for a logic for polynomial time, we study 
rank logic (\FPR) which extends fixed-point logic with counting 
(\FPC) by operators that determine the rank of matrices over finite fields.
While   can express most of the known queries that 
separate  from , nearly nothing was known about the limitations 
of its expressive power.

In our first main result we show that the extensions of \FPC by rank operators 
over different prime fields are incomparable. This 
solves an open question posed by Dawar and Holm and also implies that rank 
logic, in its original definition with a distinct rank operator for every 
field, 
fails to capture polynomial time.
In particular we show that the variant of rank logic  with an operator 
that uniformly expresses the matrix rank over finite fields is more expressive 
than .

One important step in our proof is to consider solvability logic \FPS which is 
the analogous extension of \FPC by quantifiers which express the solvability 
problem for linear equation systems over finite fields.
Solvability logic can easily be embedded into rank logic, but it is open 
whether it is a strict fragment.
In our second main result we give a partial answer to this question: 
in the absence of  counting, rank operators are strictly more expressive than 
solvability quantifiers.
\end{abstract}

\section{Introduction}

\emph{``Le roi est mort, vive le roi!''} has been the traditional proclamation,
in France and other countries,
to announce not only the death of the monarch, but also the
immediate installment of his successor on the throne.
The purpose of this paper is to kill the rank logic \FPR, in the form in which 
it
has been proposed in \cite{DaGrHoLa09},  as a candidate for a logic for \PTIME.
The logic \FPR extends fixed-point logic by operators  (for every
prime ) which compute the rank of definable matrices over the prime
field  with  elements. Although rank logic is well-motivated,
as a logic that strictly extends fixed-point logic with counting
by the ability to express important properties of linear algebra,
most notably the solvability of linear equation systems over finite
fields, our results show that the choice of having a separate rank operator 
for every prime  leads to a significant deficiency of the logic.
Indeed, it follows from our main theorem that 
even the uniform rank problem, of computing the rank of a 
given matrix over an arbitrary prime, cannot be expressed in \FPR
and thus separates  from \PTIME. 
This also reveals that a more general variant of rank logic,
which has already been proposed in \cite{Ho10, La11, Pa10}
and which is based on a rank operator that takes not only the matrix but also
the prime  as part of the input, is indeed strictly
more powerful than . 
Our result thus installs this
new rank logic, denoted \FPRvar, as the rightful 
and distinctly more powerful successor of 
\FPR as a potential candidate for a logic for \PTIME. 

\subparagraph*{A logic for polynomial time}
The question whether there is a logic that expresses precisely the 
polynomial-time properties of finite structures
is an important challenge in the field of finite model theory 
\cite{FMTbook,Gr08}. 
The logic of reference for this quest is
fixed-point logic with counting (\FPC) which
captures polynomial time on many interesting classes
of structures and is strong enough to express most of 
the algorithmic techniques leading to polynomial-time procedures~\cite{Da15}.
Although it has been known for more than twenty years that
\FPC fails to capture \PTIME in general, by the fundamental
CFI-construction due to Cai, Fürer, and Immerman~\cite{CFI92},
we still do not know many properties of finite structures
that provably separate \FPC from \PTIME.
The two main sources of such problems
are tractable cases of the graph isomorphism problem and queries from the field
of linear algebra.
First of all, the CFI-construction shows that \FPC 
cannot define the isomorphism problem on graphs with bounded 
degree \emph{and}  bounded colour class size
whereas the isomorphism problem is known to
be tractable on all classes of graphs  
with bounded degree \emph{or} bounded colour class size. 
Secondly, Atserias, Bulatov and Dawar~\cite{AtBuDa09} proved 
that \FPC cannot express the solvability of linear equation systems over 
any finite Abelian group. 
It follows, that also other problems from the field of linear 
algebra are not definable in \FPC.
Interestingly, also the CFI-query can be formulated
as linear equation system over ~\cite{DaGrHoLa09}.

\subparagraph*{Rank logic}
This latter observation motivated Dawar, Grohe, Holm and 
Laubner~\cite{DaGrHoLa09} 
to introduce \emph{rank logic} (\FPR) which is the extension of \FPC by 
operators for the rank of definable matrices over prime 
fields .
To illustrate the idea of rank logic, let
 be a formula (of , say) which defines a binary 
relation  in an input structure .
We identify the relation  with the associated adjacency matrix 

In this sense, the formula  defines in every structure  a 
matrix  with entries in . 
Now, rank logic  contains for every prime 
 a \emph{rank operator}  which can be used to form a 
\emph{rank term}  whose value in an input structure 
 is 
the matrix rank of  over  (we remark that rank logic 
also allows to express the rank of matrices which are indexed by tuples of 
elements; the precise definition is given in Section~\ref{sec:logics:linalgop}).

It turns out that rank operators have quite surprising expressive power. 
For example, they can define the transitive closure of symmetric 
relations, they can count the number of paths in DAGs modulo  and they 
can express the solvability of linear equation systems over finite fields 
(recall that a linear equation system  is solvable if, 
and only if, )~\cite{DaGrHoLa09}. 
Furthermore, rank operators can be used to define the isomorphism problem on
various classes of structures on which the Weisfeiler-Lehman method (and thus 
fixed-point logic with counting) fails, e.g.\ classes of
C(ai)-F(ürer)-I(mmerman) graphs~\cite{CFI92,DaGrHoLa09} and 
multipedes~\cite{GuSh96,Ho10}.
The common idea of these isomorphism procedures is to reduce the isomorphism 
problem of structures to a suitable linear equation system over a finite field.
More generally, by a recent result (which is mainly concerned with another 
candidate of a logic for polynomial time~\cite{AGGP14}), it follows that \FPR 
captures polynomial time on certain classes of structures of bounded colour 
class size. In particular, this holds for the class of all structures of colour 
class size two (to which CFI-graphs and multipedes belong).

\medskip
While these results clearly show the high potential of rank 
logic, almost nothing has been known about its limitations.
For instance, it has remained open whether rank logic suffices to capture 
polynomial time, whether rank operators can simulate fixed-point 
inductions~\cite{DaGrHoLa09} and also whether rank logic 
can define closely related problems from linear algebra 
(such as the solvability of linear equations over finite 
\emph{rings} rather than fields~\cite{DaGrHoKoPa13}).
One particular intriguing question is whether rank operators over 
different prime fields can simulate each other. In other words:
 is it possible to reduce the problem of determining the rank of a matrix over 
 (within fixed-point logic with counting) to the 
problem of determining the rank of a matrix over  (where  are 
distinct primes)?
To attack this problem, Dawar and Holm~\cite{DaHo12, Ho10} 
developed a powerful toolkit of so called \emph{partition games} of which one 
variant (so called \emph{matrix-equivalence games}) precisely characterises the 
expressive power of infinitary logic extended by rank quantifiers.
By using these games, Holm~\cite{Ho10} was able to give a negative answer to 
the 
above question for the restricted case of rank operators of dimension one.

\smallskip
In this paper we propose a different method, based 
on exploiting symmetries rather than game theoretic arguments, to prove new 
lower bounds for logics with rank operators.
In our main result (Theorem~\ref{thm:fps:distinct:primes}) we prove that for 
every prime  there exists a class of structures  on which \FPC fails 
to capture polynomial time and on which rank operators over \emph{every} prime 
field ,  can be simulated in \FPC.
On the other hand, rank operators over  can be used to canonise 
structures in  which means that the extension of fixed-point logic by
-operators captures polynomial time on .
From this result we can easily extract the following answers to the open 
questions outlined above.
\begin{enumerate}[(a)]
 \item Rank logic (as defined in \cite{DaGrHoLa09}) fails to capture polynomial 
time (Theorem~\ref{thm:ranklogic:ptime}).
 \item The extensions of fixed-point logic by rank operators over 
different prime fields are incomparable (Theorem~\ref{thm:fpr:mainthm}), cf.\ 
\cite{Ho10,DaHo12,La11}.
\end{enumerate}

\smallskip
We obtain these classes of structures  by generalising the 
well-known construction of Cai, Fürer and Immerman~\cite{CFI92}.
It has been observed that their construction actually is a clever way of 
encoding a linear equation system over  into an appropriate graph 
structure (see e.g.\ \cite{AtBuDa09, DaGrHoLa09, Ho10, La11}).
Intuitively, each gadget in the CFI-construction can be seen as an 
equation (or, equivalently, as a circuit gate) which counts the number of 
transpositions of adjacent edges modulo two, and the CFI-query is to decide 
whether the total number of such transpositions is even or odd.
Knowing this, it is very natural to ask whether this idea can be generalised to 
encode linear equation systems over arbitrary finite fields or, more generally, 
equation systems over arbitrary (Abelian) groups.

In~\cite{To04}, in order to obtain hardness results for 
the graph isomorphism problem, Tor\'{a}n followed this idea and established a 
graph construction which simulates -counting gates
for all . 
Moreover, in order to separate the fragments of rank logic by operators over 
different prime fields, Holm presented in~\cite{Ho10} an even more general kind 
of construction which allows the representation of equations over \emph{every} 
Abelian group . In fact, we obtain the classes  essentially by 
using his construction for the special case where .


\subparagraph*{Solvability logic}
One important step in our proof is to consider \emph{solvability 
logic} \FPS which is the extension of \FPC by quantifiers which can express the 
solvability of linear equation systems over finite fields (so called 
\emph{solvability quantifiers}, see~\cite{DaGrHoKoPa13, Pa10}). 
Obviously the logic  can easily be embedded into rank logic (as rank 
operators can be used to solve linear equation systems), but it remains open 
whether the inclusion  is strict.
To prove our main result outlined above we show that over certain classes of 
structures the logics  and  have precisely the same expressive 
power. In a more general context this might give some evidence that in the 
framework of fixed-point logic with counting rank operators can be simulated by 
solvability quantifiers.
On the other hand we show in Section~\ref{sec:slv:rk} that the 
extension of first-order logic (without counting) by solvability quantifiers 
is strictly weaker than the respective extension by rank operators.
This last result thus separates solvability quantifiers and rank 
operators in  the absence of counting.

\bigskip
Let us briefly sketch the main idea of our proofs which is to exploit the 
symmetries of definable linear equation systems. 
To this end, let  be a linear 
equation 
system over some prime field  where  is an -matrix over  and where  is the -identity vector over 
, i.e.\  for all .
Moreover, let  be a group which acts on  and which 
stabilises , i.e.\ for all  and  we have 
. 
In other words, if we identify the elements  with -permutation matrices  then we have .
Now let  be a solution of the linear 
equation system . Then we observe that also  is a solution for  since

In other words: the solution space of the linear equation system  is closed under the action of .
Such and similar observations will enable us to transform a given 
linear equation system into a considerably simpler linear system which still is 
equivalent to the original one. 


\section{Logics with linear-algebraic operators}
\label{sec:logics:linalgop}

By  we denote the class of all \emph{finite, relational} structures 
of signature .
We assume that the reader is familiar with \emph{first-order logic} () and 
\emph{inflationary fixed-point logic} (). For details 
see~\cite{ebbinghaus99finite,FMTbook}.
We write  for the set of primes and denote the prime field with  
elements by . 
We consider matrices and 
vectors over \emph{unordered} index sets. Formally, if 
 and  are non-empty sets, then an -matrix  over  is a mapping  and an -vector  
over  is a mapping .


A \emph{(linear) preorder}  on  is a 
reflexive, transitive and total binary relation. A preorder  induces a 
linear order on the classes of the associated equivalence relation . 
We write  to denote the decomposition 
of  into -classes  which are linearly ordered by  as 
indicated.

We briefly recall the definitions of \emph{first-order logic with 
counting}  and \emph{(inflationary) fixed-point logic with counting} 
 which are the extensions of  and  by counting terms.
Formulas of  and  are evaluated over 
the \emph{two-sorted extension} of an input structure by a copy of the 
arithmetic. Following~\cite{DaGrHoLa09} we let  denote the 
two-sorted extension of a -structure  by the 
arithmetic , i.e.\ the two-sorted structure  where the universe of the first 
sort (also referred to as \emph{vertex sort}) is  and the universe of the 
second sort (also referred to as \emph{number sort} or \emph{counting sort}) is 
.

As usual for the two-sorted setting we have,
for both, the vertex and the number sort, a collection of typed
first-order variables. We agree to use Latin letters 
for variables which range over the vertices and Greek letters  for variables ranging over the numbers. 
Similarly, for second-order variables  we allow mixed types, i.e.\ a 
relation symbol  of type  stands for a relation 
. Of course, already first-order logic over 
such 
two-sorted extensions is undecidable. To obtain logics whose 
data complexity is in polynomial time we restrict the quantification over the 
number sort by a numeric term , i.e.\  where  and where  is a closed \emph{numeric} term.
Similarly, for fixed-point logic \FP we bound the numeric components of 
fixed-point variables  of type  in all fixed-point definitions 

by a tuple of closed numeric terms  where each 
 bounds the range of the variable  in the tuple . 
For the logics which we consider here the value of such 
numeric terms (and thus the range of all quantifiers over the number sort) 
is polynomially bounded in the size of the input structure. Together 
with the standard argument that inflationary fixed-points can be evaluated in 
polynomial time and the fact that the matrix rank over any field can be 
determined in polynomial time (for example by the method of Gaussian 
elimination), this ensures that all the logics which we introduce in the 
following have polynomial-time data complexity.


Let  be a mixed tuple of variables and let  be a tuple of 
closed numeric terms which bounds the range of the numeric variables in .
For a formula  we define a \emph{counting term}  whose value  in a structure  
corresponds to the number of tuples 
 such that  
and   where  and .

We define \emph{first-order logic with counting } as the extension of 
(the above described two-sorted variant of)  by counting terms. 
Similarly, by adding counting terms to the logic  we obtain
\emph{(inflationary) fixed-point logic with counting }.


\paragraph*{Extensions by rank operators}

Next, we recall the notion of rank operators as introduced 
in~\cite{DaGrHoLa09}. 
Let  be a numeric 
term where  and  are tuples of closed numeric terms which bound 
the 
range of the numeric variables in the tuples  and , respectively. 
Given a structure  we define . 
The set  is defined 
analogously. The term  defines in the structure  
for  and 
the -matrix  with values in  that is given
as .

The \emph{matrix rank operators} compute the rank of the matrix  
over a prime field  for .
Firstly, as in~\cite{DaGrHoLa09}, we define for every prime  a matrix rank 
operator  which allows us to construct a new numeric \emph{rank term}  whose value in the 
structure  is the rank of the matrix  over 
.
Secondly, we propose a more flexible rank operator  which gets the prime 
 as an additional input. Formally, with this rank operator  we can 
construct a rank term  where  is an additional free numeric variable 
whose range is bounded by some closed numeric term . Given a structure 
 
and an assignment  for some prime , the value of 
this rank term is the matrix rank of  considered as a 
matrix over .
The rank operator  can be seen as a unification for the 
the family of rank operators  and has been introduced 
in~\cite{Ho10, La11, Pa10}.

\smallskip
We define, for every set of primes , the extension 
 of  and the extension  of  by  
matrix rank operators  with . 
For convenience, we let  and .
Similarly, we denote by  the extension of  by the uniform rank 
operator . 
We remark, that rank operators can directly simulate counting terms. For 
example we have that 
 
Hence, we could equivalently define the rank logics  and  as the extensions of (the two-sorted variants of) 
 and , respectively.
\smallskip


\paragraph*{Extensions by solvability quantifiers}

It is well-known that the extensions of  and  by matrix rank 
operators have surprising expressive power which, in particular, goes beyond 
that of fixed-point logic with counting. 
For example, it is known that rank operators can easily define the 
symmetric transitive closure of binary relations and that they can be used 
to express the structure isomorphism problem on various classes on which
the Weisfeiler-Lehman test fails like, for example, classes of Cai, Fürer and 
Immerman graphs~\cite{CFI92, DaGrHoLa09}.
Interestingly, such results for rank logic were obtained by reducing the 
respective queries to a \emph{solvability problem for linear equation system 
over finite fields}.
Although the solvability problem (for linear equation systems) can 
be defined in rank logic, we propose to study extensions by 
quantifiers which directly express this solvability problem. One 
advantage of this approach is that one can naturally define such 
quantifiers for 
linear systems over more 
general classes of algebraic domains, like rings, for which no appropriate 
notion of matrix rank exists, cf.\ \cite{DaGrHoKoPa13}. 

\medskip
Let  be a set of primes. Then the \emph{solvability 
logic}  extends the syntax of  for every  by the following formula creation rule for \emph{solvability 
quantifiers} .
\begin{itemize}
 \item Let  and let 
  and  be tuples of closed numeric terms with  and .
  Then also  is a formula of . 
\end{itemize}


The semantics of the formula  is defined similarly as for rank logic.
More precisely, let  and . 
To a pair  we 
associate the -matrix  over  where  and  and where for  and  
we have  if, and only if, .

Let  be the -identity vector over , i.e.\ 
 for all . Then  and  
determine
the linear
equation system  over  where 
 is a -vector of variables  which range over 
. Finally,  if, and only if,  is solvable.

\smallskip
At first glance, the solvability quantifier seem to pose 
serious restrictions on 
the syntactic form of definable linear equation systems.
Specifically, the coefficient matrix has to be a matrix over  and
the vector of constants is fixed from outside.
However, it is not hard to show that general linear equation systems can 
be brought into this kind of normal form by using quantifier-free 
first-order transformations (see Lemma~4.1 in~\cite{DaGrHoKoPa13}).


We write  to denote the logic  and  to denote 
the logic  for . 
Analogously to the definition of  we also consider a 
solvability quantifier  which gets the prime  as an 
additional input and which can uniformly simulate all solvability 
quantifiers  for . 
Let  denote the extension of  by this uniform version of a 
solvability quantifier.
Then the following inclusions easily follow from the definitions and the fact 
that rank operators can be used to define the solvability problem for linear 
equation systems.


Finally we remark that, analogously to \cite{DaGrHoLa09}, we defined rank 
operators and solvability quantifiers for prime fields only. Of course, the 
definition can easily be generalised to cover all finite fields, i.e.\ also 
finite fields of prime power order. 
However, for the case of solvability quantifiers, Holm was able to prove 
in~\cite{Ho10} that this does not alter the expressive power of the resulting 
logics since solvability quantifiers over a finite field  of prime 
power order  can be simulated by solvability quantifiers over . Moreover, a similar reduction can be achieved for rank operators which 
altogether shows that it suffices to focus on rank operators and solvability 
quantifiers over prime fields.


\section{Separation results over different classes of fields}
\label{sec:sep:fields}

In this section we separate the extensions of fixed-point logic with counting 
by solvability quantifiers and rank operators over different prime fields. 
Specifically, we show that the expressive power of the logics  
is different for all sets of primes .
Moreover, we transfer these results to the extensions  by rank 
operators. In this way we can answer the following open question about rank 
logic:
\begin{center}
 It holds that  for pairs of different primes . 
\cite{DaHo12, Ho10, La11}
\end{center}

Another important consequence of our result is that rank logic (in the way it 
was defined in~\cite{DaGrHoLa09}) does not suffice to capture 
polynomial time. 
Let us state these results formally.

\begin{theorem}\label{thm:fpr:mainthm}
 Let  be two sets of primes.
Then  and .
\end{theorem}

\begin{theorem} \label{thm:ranklogic:ptime}
Rank logic fails to capture polynomial time. We have .
\end{theorem}

\noindent
In fact, both theorems are simple consequences of our following main result.
\begin{theorem}\label{thm:fps:distinct:primes}
For every prime  there is a class of structures  such that
\begin{enumerate}[(a)]
  \item  on  for every set of primes  
with , 
\label{thm:fps:distinct:primes:fps:fpc}
 \item  on  for all sets of primes 
, 
 \label{thm:fps:distinct:primes:fpr:fps}
 \item  on , and
 \label{thm:fps:distinct:primes:fpc:not:ptime}
  \item  on .
 \label{thm:fps:fpsq:ptime}
\end{enumerate} 
\end{theorem}

\begin{proof}[Proof of Theorem~\ref{thm:fpr:mainthm}]
 Let  and  be two sets of primes as above. Without loss of 
generality let us assume that there exists a prime . Then by Theorem~\ref{thm:fps:distinct:primes} there exists a class 
 on which  and on which
.
\end{proof}

\begin{proof}[Proof of Theorem~\ref{thm:ranklogic:ptime}]
 Otherwise assume that . 
Then, in particular, \FPR = \FPRvar and there exists a formula  which can uniformly determine the rank of matrices over prime fields, 
i.e.\ which can express the uniform rank operator .
As a matter of fact we have  for some \emph{finite} set 
of primes .
By using  we can uniformly express the matrix rank over each prime field 
 in . In other words, we have .

Now let . 
By Theorem~\ref{thm:fps:distinct:primes} there exists a class of 
structures  on which .
However, the class  can be chosen such that  on  by
Theorem~\ref{thm:fps:distinct:primes}~(\ref{thm:fps:fpsq:ptime})
and we obtain the desired contradiction.
\end{proof}

The proof of Theorem~\ref{thm:ranklogic:ptime} reveals a deficiency of the 
logic \FPR: each formula can only access -operators for a finite 
set  of distinct primes . In fact, the query which we constructed to 
separate  from  can be defined in . 
Altogether this suggests to generalise the notion of rank operators 
and to specify the prime  as a part of the input, as we did for , 
and as it was proposed in \cite{Ho10, La11, Pa10}. 


\medskip
The remainder of this section is devoted to the proof 
of Theorem~\ref{thm:fps:distinct:primes}.
We fix a prime  and proceed as follows.
In a first step, we identify properties of classes of 
structures  which guarantee that the relations claimed in
(\ref{thm:fps:distinct:primes:fps:fpc}),
(\ref{thm:fps:distinct:primes:fpr:fps}), 
(\ref{thm:fps:distinct:primes:fpc:not:ptime}) and
(\ref{thm:fps:fpsq:ptime}) hold.
In a second step, we proceed to show that we can obtain a
class of structures  that satisfies all of these sufficient 
criteria. This together then proves our theorem.

\paragraph*{Establishing sufficient criteria}
We start by establishing sufficient criteria for the most relevant 
part of Theorem~\ref{thm:fps:distinct:primes}
which is the relation claimed in~(\ref{thm:fps:distinct:primes:fps:fpc}).
Assume that we have a class of structures  with the following properties.
\begin{enumerate}[]
 \item \label{item:property:classk:autogroups}
 The automorphism groups  of 
structures  are Abelian -groups.
 \item \label{item:property:classk:deforbits}
 The orbits of -tuples in structures  can be ordered in 
\FPC.

Formally, for each  there is a formula 
 such that for 
every structure , the formula  defines in 
  a linear preorder  on  with the property that two 
-tuples  
are -equivalent if, and only if, they are in the same 
-orbit.
\end{enumerate}

\begin{lemma}
\label{lemma:fps:fpc:prop12}
 If  satisfies (\ref{item:property:classk:autogroups}) and
 (\ref{item:property:classk:deforbits}), then  on  
for all .
\end{lemma}

The proof of this lemma is by induction on the structure of 
-formulas. 
Obviously, 
the only interesting step is the translation of a solvability formula

into an -formula  which is equivalent to 
 on the class .
Let ,  
and 
. To explain our main argument, we fix a structure  and a -tuple of parameters  which 
is compatible with the type of the variable tuple . 
According to the semantics of the solvability quantifier, the formula 
 defines in 
 an -matrix  with 
entries in  where  
and  that is defined for  and  as


By definition we have  if, and only if, the linear 
equation system  over  is solvable.
The key idea is to use the symmetries of the structure  to translate 
the linear equation system  into 
an equivalent linear system which is \emph{simpler} in the sense that its
solvability can be defined in the logic .
The reader should observe that each automorphism  naturally 
induces an automorphism of the two-sorted extension  which 
point-wise fixes every number . In particular we 
have .

\medskip
We set . 
The group  acts on  and  in the natural way. We identify 
each automorphism  with the corresponding -permutation matrix  and the corresponding -permutation 
matrix  in the usual way. More precisely, to  
we associate the -permutation matrix  which is defined as

Then  acts on the set of -matrices by left
multiplication with -permutation matrices. Similarly, we let
 denote the -permutation matrix defined as 

Then  also acts on the set of -matrices by right
multiplication with -permutation matrices. Specifically, for
 we have  and . Since  is defined by a formula in the structure  and 
since  we conclude that  and thus

This identity leads to the following important observation.

\begin{lemma}\label{lemma:fps:symmetric:solution}
 If  is solvable, then 
the system has a \emph{-symmetric} solution, i.e.\ a solution  such that  for all .
\end{lemma}
\begin{proof}
If , then also  and thus  for all 
. This shows that  acts on the solution space of the 
linear equation system. 
Since  satisfies property~(\ref{item:property:classk:autogroups}) we know 
that  is a -group for a prime . Thus each -orbit 
has size  for some . On the other hand, the number of 
solutions is a power of . We conclude that there is at least one 
-orbit of size one which proves our claim.
\end{proof}

Let  be a -symmetric solution. Then the 
entries of the solution  on -orbits are constant: for  
and  we have .
We proceed to use the property (\ref{item:property:classk:deforbits}) and 
show that there exists an \FPC-formula   which 
defines for all  and  as above a 
linear preorder  on  which identifies -orbits. 
Note that, in general,  is a strict subgroup of 
. Thus we can not directly apply 
(\ref{item:property:classk:deforbits}).
However, the -orbits on 
 correspond to the -orbits on 
 where the first  entries are fixed to the elements .

The linear preorder  naturally extends to a preorder on the 
sets  and  with the same properties.
Let us write  to denote the 
decomposition of  into the -orbits  which are ordered 
by  as indicated.
Moreover, for  we let  denote the identity vector on the 
-th orbit , i.e.\ the -vector which defined for  as


Let  denote the -matrix whose -th column is the vector 
. It follows that a -symmetric solution  can be written as 
 for a unique -vector .
Together with Lemma~\ref{lemma:fps:symmetric:solution} this shows the following.

\begin{lemma}
 The linear equation system  is solvable if, and only 
if, the linear equation system  is 
solvable.
\end{lemma}

Finally, we observe that the coefficient matrix  of the equivalent linear equation system  can easily be obtained in  and that it is a matrix over the 
\emph{ordered} set of column indices . 
It is a simple observation that such linear equation systems can be solved 
in : the linear order on the column set induces 
(together with some fixed order on ) a lexicographical 
ordering on the set of rows which is, up to duplicates of rows, a 
linear order on this set. Thus, in general, if we have a linear order on 
\emph{one} of the index sets of the coefficient matrix this suffices to 
obtain an equivalent matrix where \emph{both} index sets are ordered, see 
also~\cite{Pa10}.
This finishes our proof of Lemma~\ref{lemma:fps:fpc:prop12}.

\bigskip
We proceed to show that the conditions 
(\ref{item:property:classk:autogroups}) and
 (\ref{item:property:classk:deforbits}) also  guarantee that 
rank operators can be reduced to solvability operators over the class 
. In fact, for this translation we only require the somewhat weaker 
assumption that we can define in \FPC on -tuples in 
structures  a linear preorder in which every class can be 
linearised in \FPC by fixing a constant number of parameters. 
The precise technical requirements will become clear from the proof of the 
following lemma.
\begin{lemma}\label{lemma:rank:to:solve}
If  satisfies (\ref{item:property:classk:autogroups})
 and (\ref{item:property:classk:deforbits}), then
  on  for all sets of primes .
\end{lemma}
\begin{proof}
 We inductively translate -formulas into formulas of 
 which 
are equivalent on the class . The only interesting case is 
the transformation of rank terms


Let ,  
and 
. Let  and let  be a -tuple of 
parameters  which 
is compatible with the type of the variable tuple . 
The term  defines in  
for  and 

the -matrix  over  which is defined as


According to the semantics of matrix rank operators, the 
value  is the rank of the matrix .
We proceed to show that we can determine the matrix rank of  by a 
recursive application of solvability queries. To this end we make the 
following key observation.

\medskip
\begin{claim}
 There are -formulas , 
 such that for every 

\begin{enumerate}[(a)]
 \item  is a linear preorder  on 
, and such that
 \item for every -class  there exists a 
parameter tuple  such that  is 
a linear order  on .
\end{enumerate}
\end{claim}
\begin{claimproof}
 First of all, we let  be an \FPC-formula which defines in 
every structure  a linear preorder  on  
such that -classes correspond to -orbits. Such a 
formula exists by our assumption that  satisfies 
property~(\ref{item:property:classk:deforbits}).
Analogously, we choose an -formula  which defines 
in every structure  a linear preorder  on 
 that induces a linear order on the 
-orbits.

Now let  be a -class for some . 
By property (\ref{item:property:classk:autogroups}) we know that 
 is an Abelian group. Thus, each automorphism  which fixes \emph{one} element in the 
-orbit  point-wise 
fixes \emph{every} element in the class . 
We conclude that the restriction of  to elements in  corresponds to a linear order on  for each .
In this way we obtain an \FPC-formula  with the desired 
properties.
\end{claimproof}

\smallskip
We are now prepared to describe the recursive procedure which allows us to 
determine the rank of the matrix  in .
To this end we fix formulas  and  with the above 
properties. Moreover, let  denote the linear preorder defined by 
 on  and let

We use the formula  to obtain on each class  a 
family of definable linear orderings (which depend on the choice of 
different parameters).
For  we denote by  the -th column of 
the matrix . Then the rank of  coincides with the dimension of the 
-vector space which is generated by the set of columns  of the matrix .

Now, for  we recursively obtain the 
dimension  of the -vector space generated by 
 as 
follows.
First, we use  to fix a linear order on  (the following 
steps are independent of the specific linear order and can thus be 
performed in parallel for each such order).
Using this linear order on  we can identify in  a maximal 
set 
 of linearly independent columns 
such that .
Indeed, if , then 
for , 
we have that 
 if, and only if, . Observe 
that the conditions  and  correspond to the solvability of a linear equation system 
over .
We claim that . Indeed, by the 
maximality of  and since  it follows that . Moreover,  consists of linearly independent 
columns and is a basis for .

Since the above described recursion can easily be implemented in 
, we conclude that the rank  of the matrix  can be 
determined in  which completes our proof.
\end{proof}


\bigskip
We now focus on the parts 
(\ref{thm:fps:distinct:primes:fpc:not:ptime})
and 
(\ref{thm:fps:fpsq:ptime})
of Theorem~\ref{thm:fps:distinct:primes} and establish sufficient criteria 
which guarantee that  fails to capture  on 
 while  can express every polynomial-time decidable 
property of -structures.

\begin{enumerate}[]
\setcounter{enumi}{2}
 \item There exists an -definable canonisation procedure on .
\label{item:property:classk:isopoly}
 \item For every  there exists a pair of structures  and  such that  and .
\label{item:property:classk:ckeqv}
\end{enumerate}
\begin{lemma}\label{lemma:fps:fpc:prop34}
 If  satisfies  (\ref{item:property:classk:isopoly}) and
 (\ref{item:property:classk:ckeqv}), then  on~.
\end{lemma}
\begin{proof}
It is clear that by property (\ref{item:property:classk:isopoly}) we have
  on .
 Moreover, if we had  on  then,  by the embedding of 
 
into  and the fact that -structures can be canonised in 
polynomial time, there exists a fixed  such that  can identify 
each structure in  which, in turn, contradicts 
property~(\ref{item:property:classk:ckeqv}).
\end{proof}

\paragraph*{Constructing an appropriate class of structures}
We proceed to construct a class of structures  which satisfies 
properties (\ref{item:property:classk:autogroups}) - 
(\ref{item:property:classk:ckeqv}).
Our approach is a generalisation of the well-known construction of Cai, Fürer 
and Immerman~\cite{CFI92} for cyclic groups other than . 
To illustrate the main differences, let us briefly recall the idea of the 
original construction. Starting from an undirected and connected graph 
, we take two copies  of every edge .
Moreover, for every vertex  we consider the set  of 
edges which are adjacent to  and we add one of the following two constraints 
to restrict the symmetries of the resulting CFI-graph: either the set of all 
sets  with  and  is stabilised (an \emph{even} 
node) or the dual set of all sets  with 
 and  is stabilised (an 
\emph{odd} node).
These constraints are encoded by a simple graph gadget.
Although it seems that for each of these exponentially many choices we obtain a 
different CFI-graph, there really are, up to isomorphism, only two such graphs
which in turn are determined by the parity of the number of odd nodes.
Very roughly, the reason is that we can transpose, or \emph{twist}, two 
copies  of each an edge  and move this twist along a path (in the 
\emph{connected} graph ) to iteratively resolve pairs of odd nodes.


In order to generalise this construction to  we take for 
every edge  a \emph{directed cycle} of length  over  copies 
 of the edge .
We then add similar constraints for sets of incident edges as above, but 
naturally, instead of having only two different kinds of such constraints, we 
have one for each value .
Now, instead of twisting pairs of edges, we consider 
\emph{cyclic shifts} of length  on the edge classes  which respect the cycle relation. Again, these shifts can be 
propagated along paths in the original graph  and, with a reasoning 
analogous to the original approach, it turns out that there are, up to 
isomorphism, only  different types of generalised CFI-graphs over . We remark that the same kind of generalisations has been studied, 
for example, in~\cite{Ho10,To04}.

\newcommand{\CFI}{\ensuremath{\logic{CFI}_q}}

\smallskip
Let us formalise the above described intuitions.
We start with an \emph{(undirected), connected} 
and \emph{ordered} graph .
Let  and  be binary relation symbols.
We set .
We define for every prime  and every sequence of \emph{gadget values} 
 a -structure  which we call a \emph{CFI-structure over 
}.
For the following construction we agree that arithmetic is modulo  so that 
we can drop the operator ``'' in 
statements 
of the form  and  for the sake of better readability. 
For what follows, let  denote the set of \emph{directed} 
edges starting in . 
Since  is an undirected graph, this means that for each undirected edge 
 of  we have  and .
The construction is illustrated in Figure~\ref{fig:cfiq}.

\begin{itemize}
 \item The \emph{universe} of  consists of \emph{edge 
nodes} and \emph{equation nodes}.
\begin{itemize}
\item The set of \emph{edge nodes}  is defined as  where
 for every \emph{directed} edge  we let
 the \emph{edge class}  consist of  distinct copys of . 
In particular, for every edge  and its reversed 
edge  the sets  and  are 
disjoint. 
We say that two such edges (or edge classes) are \emph{related}. 
\item The set of \emph{equation nodes}  is defined as  where for every 
vertex  and   the \emph{equation class} 
 
consist of all functions  which satisfy .
\end{itemize}


 \item The \emph{linear preorder}  orders the edge 
classes according to the linear order induced by  on . More 
precisely, we let  whenever .
Similarly,  orders the equation classes according to the 
order of  on , i.e.\  if . Moreover, 
we let  for edge classes  and  
equation classes .

 \item The \emph{cycle relation}  contains a directed 
cycle of length  on each of the edge classes  for , i.e.\ .
 \item The \emph{inverse relation}  connects two related edge classes 
by pairing additive inverses. More precisely, let 
 and . Then  contains all 
edges  with  for .

 \item The \emph{gadget relation}   is defined as  where for  and  the relation 
 is given as

\end{itemize}




\begin{figure}[ht]
 \centering
\begin{tikzpicture}[>=stealth]
 
\coordinate (vertexv) at (-4.3,-1.8);

\draw[draw=lightgray, fill=white, thick] () 
ellipse (6em and 9em);

\node[font=\Large] at () {};
\draw [>=open triangle 90,->,very thick,lightgray ] () arc (130:30:1.5cm);

\node[draw,fill,circle, inner sep=0.8pt, label={[label 
distance=0.4em]20:{\Large }}] (v) at (vertexv)  {};
\node[draw,fill,circle, below left of=v, node distance =6em, inner 
sep=0.8pt, 
label=below:{\Large }] (a)  {};
\node[draw,fill,circle, above of = v, node distance =6em, inner sep=0.8pt, 
label=above:{\Large }] (b)  {};
\node[draw,fill,circle, below right of=v, node distance =6em, inner 
sep=0.8pt, 
label=below:{\Large }] (c)  {};
\draw[->,thin] (v) to [bend left=20] node[below right] {} (a) ;
\draw[->,thin] (a) to [bend left=20] node[above left] {} (v) ;
\draw[->,thin] (v) to [bend left=20] node[left] {} (b) ;
\draw[->,thin] (b) to [bend left=20] node[right] {} (v) ;
\draw[->,thin] (v) to [bend left=20] node[above right] {} (c) ;
\draw[->,thin] (c) to [bend left=20] node[below left] {} (v) ;







\begin{scope}
\node (posb) at (1.8,-0.5) {};
\node (posbrecx) at () {};
\node (posbrecy) at () {};

\pgfmathsetmacro{\hoehe}{1.13} 
\pgfmathsetmacro{\breite}{3.11}
\coordinate (rbe1) at ();
\coordinate (rbe2) at ();
\coordinate (rbe3) at ();
\coordinate (rbe4) at ();
\draw[draw=black, fill=lightgray, fill opacity=0.3, thin] 
(rbe1) -- (rbe2) -- (rbe3) -- (rbe4) --cycle;

\node[draw,fill,circle, inner sep=0.5pt, 
 label={[label distance=0.2em]180:{\footnotesize }}] (eb0) at 
(posb) 
{};
\node[draw,fill,circle, inner sep=0.5pt, 
label={[label distance=0em]120:{\footnotesize }},right 
of=eb0,node 
distance=2em] (eb1)  {};
\node[draw,fill,circle, inner sep=0.5pt, 
label={[label distance=0.2em]0:{\footnotesize }},right of=eb1,node 
distance=2em] (eb2)  {};
 
 \draw[->,thin] (eb0) -- (eb1);
 \draw[->,thin] (eb1) -- (eb2);
 \draw[->, thin] (eb2) to  [bend left=85] (eb0) ;
 \node [below of = eb1, node distance=0.8em, font=\footnotesize] {} ;

 \node (posb2) at () {};
\pgfmathsetmacro{\hoehe}{1.13} 
\pgfmathsetmacro{\breite}{3.11}
\coordinate (rbf1) at ();
\coordinate (rbf2) at ();
\coordinate (rbf3) at ();
\coordinate (rbf4) at ();
\draw[draw=black, fill=hellblau, fill opacity=0.3, thin] 
(rbf1) -- (rbf2) -- (rbf3) -- (rbf4) --cycle;
 
 \node[draw,fill,circle, inner sep=0.5pt, 
 label={[label distance=0.2em]180:{\footnotesize }}] (fb0) at 
(posb2) {};
\node[draw,fill,circle, inner sep=0.5pt, 
label={[label distance=0em]240:{\footnotesize }},right 
of=fb0,node 
distance=2em] (fb1)  {};
\node[draw,fill,circle, inner sep=0.5pt, 
label={[label distance=0.2em]0:{\footnotesize }},right of=fb1,node 
distance=2em] (fb2)  {};
 
 \draw[->,thin] (fb0) -- (fb1);
 \draw[->,thin] (fb1) -- (fb2);
 \draw[->, thin] (fb2) to [bend right=85] 
 node[below left,font=\footnotesize] {} (fb0) ;
 
\draw[-,thin] (fb0) to (eb0) ;
 \draw[-,thin] (fb2) to (eb1) ;
 \draw[-,thin] (fb1) to (eb2) ;
 \node (posbI) at () {};
\end{scope}

 






\begin{scope}
 
\node (posa) at (1,-4.5) {};

\pgfmathsetmacro{\hoehe}{0.8} 
\pgfmathsetmacro{\breite}{2.2}
\coordinate (rae1) at ();
\coordinate (rae2) at ();
\coordinate (rae3) at ();
\coordinate (rae4) at ();
\draw[draw=black, fill=lightgray, fill opacity=0.3, thin] 
(rae1) -- (rae2) -- (rae3) -- (rae4) --cycle;

 \node[draw,fill,circle, inner sep=0.5pt, 
 label={[label distance=0.05em]340:{\footnotesize }}] (ea0) at 
(posa) 
{};
\node[draw,fill,circle, inner sep=0.5pt, 
label={[label distance=0.1em]270:{\footnotesize }},above left
of=ea0,node 
distance=2em] (ea1)  {};
\node[draw,fill,circle, inner sep=0.5pt, 
label={[label distance=0.05em]120:{\footnotesize }},above left 
of=ea1,node 
distance=2em] (ea2)  {};
 
 \draw[->,thin] (ea0) -- (ea1);
 \draw[->,thin] (ea1) -- (ea2);
 \draw[->, thin] (ea2) to [bend left=85] 
 node[left,font=\footnotesize] {} (ea0) ;

 
 
 \node (posa2) at () {};
\pgfmathsetmacro{\hoehe}{0.8} 
\pgfmathsetmacro{\breite}{2.2}
\coordinate (raf1) at ();
\coordinate (raf2) at ();
\coordinate (raf3) at ();
\coordinate (raf4) at ();
\draw[draw=black, fill=hellblau, fill opacity=0.3, thin] 
(raf1) -- (raf2) -- (raf3) -- (raf4) --cycle;
 
 
 \node[draw,fill,circle, inner sep=0.5pt, 
 label={[label distance=0.05em]340:{\footnotesize }}] (fa0) at 
(posa2) {};
\node[draw,fill,circle, inner sep=0.5pt, 
label={[label distance=0.05em]0:{\footnotesize }},above left 
of=fa0,node 
distance=2em] (fa1)  {};
\node[draw,fill,circle, inner sep=0.5pt, 
label={[label distance=0.05em]120:{\footnotesize }},above left 
of=fa1,node 
distance=2em] (fa2)  {};
 
 \draw[->,thin] (fa0) -- (fa1);
 \draw[->,thin] (fa1) -- (fa2);
 \draw[->, thin] (fa2) to [bend right=85] 
 node[right,font=\footnotesize] {} (fa0) ;
 
\draw[-,thin] (fa0) to (ea0) ;
 \draw[-,thin] (fa2) to (ea1) ;
 \draw[-,thin] (fa1) to (ea2) ;
 \node (posaI) at () {};
 \end{scope} 


 







\begin{scope}
 
\node (posc) at (4,-4.5) {};

\pgfmathsetmacro{\hoehe}{0.8} 
\pgfmathsetmacro{\breite}{2.2}
\coordinate (rce1) at ();
\coordinate (rce2) at ();
\coordinate (rce3) at ();
\coordinate (rce4) at ();
\draw[draw=black, fill=lightgray, fill opacity=0.3, thin] 
(rce1) -- (rce2) -- (rce3) -- (rce4) --cycle;

 \node[draw,fill,circle, inner sep=0.5pt, 
 label={[label distance=0.05em]250:{\footnotesize }}] (ec0) at 
(posc) {};
\node[draw,fill,circle, inner sep=0.5pt, 
label={[label distance=0.1em]270:{\footnotesize }},above right
of=ec0,node 
distance=2em] (ec1)  {};
\node[draw,fill,circle, inner sep=0.5pt, 
label={[label distance=0.05em]20:{\footnotesize }},above right 
of=ec1,node 
distance=2em] (ec2)  {};
 
 \draw[->,thin] (ec0) to (ec1);
 \draw[->,thin] (ec1) to  (ec2);
 \draw[->, thin] (ec2) to [bend right=85] (ec0) ;
 \node[font=\footnotesize] at ()  {};
 
 
 \node (posc2) at () {};
\pgfmathsetmacro{\hoehe}{0.8} 
\pgfmathsetmacro{\breite}{2.2}
\coordinate (rcf1) at ();
\coordinate (rcf2) at ();
\coordinate (rcf3) at ();
\coordinate (rcf4) at ();
\draw[draw=black, fill=hellblau, fill opacity=0.3, thin] 
(rcf1) -- (rcf2) -- (rcf3) -- (rcf4) --cycle;
 
 
 \node[draw,fill,circle, inner sep=0.5pt, 
 label={[label distance=0.05em]250:{\footnotesize }}] (fc0) at 
(posc2) {};
\node[draw,fill,circle, inner sep=0.5pt, 
label={[label distance=0.05em]180:{\footnotesize }},above right 
of=fc0,node 
distance=2em] (fc1)  {};
\node[draw,fill,circle, inner sep=0.5pt, 
label={[label distance=0.05em]20:{\footnotesize }},above right 
of=fc1,node 
distance=2em] (fc2)  {};
 
 \draw[->,thin] (fc0) -- (fc1);
 \draw[->,thin] (fc1) -- (fc2);
 \draw[->, thin] (fc2) to [bend left=85] 
 node[left,font=\footnotesize] {} (fc0) ;
 
\draw[-,thin] (fc0) to (ec0) ;
 \draw[-,thin] (fc2) to (ec1) ;
 \draw[-,thin] (fc1) to (ec2) ;
 \node (poscI) at () {};
 \end{scope} 
 
  







 \node[draw=gray,fill=hellblau,rectangle, inner sep=1.5pt, 
 label={[label distance=0.15em]110:{\footnotesize }}] (in210) at 
() {};

\draw[-,darkgray] (in210) to (ea2) ;
\draw[-,darkgray] (in210) to (eb1) ;
\draw[-,darkgray] (in210) to (ec0) ;

\node[draw=gray,fill=hellblau,rectangle, inner sep=1.5pt, 
 label={[label distance=0.15em]20:{\footnotesize }}] (in111) at 
() {};
  
\draw[-,darkgray] (in111) to (ea1) ;
\draw[-,darkgray] (in111) to (eb1) ;
\draw[-,darkgray] (in111) to (ec1) ;


\node[font=\large,darkgray] (Rdots) at () {};
\node[above of=Rdots, font=\large, darkgray, node distance=1.5em] (Rdots) {};

  
\end{tikzpicture}  
\caption{Generalised CFI-construction for the -gadget where  and }
\label{fig:cfiq}
\end{figure}


\newcommand{\gadget}{}
At first glance our construction associates to every 
graph~ (with the above properties) and to each
sequence of gadget values   a different structure 
.
However, for each graph  with the above properties there really are, up 
to isomorphism, only  different CFI-structures .
In fact, the value  
completely determines the isomorphism class of a CFI-structure over .

\medskip
To obtain this characterisation, we  analyse the automorphism group 
of CFI-structures 
and, more generally, the set of isomorphisms 
between two structures  and 
.
For such structures we know that the set  of edge nodes, the linear 
preorder  on , the cycle relation  and the inverse relation 
 do not depend on the sequence of gadget values. 
This means that each possible isomorphism  which maps  to  
induces an automorphism of the common substructure
 which only 
depends on  but not on .
Thus  


Let .
The linear preorder  on  and the cycle 
relation  enforce that  is the composition of
 cyclic shifts on the individual edge classes , i.e.\ 
 .
It is convenient to identify the group  with the vector space  in the 
obvious way. 

In addition, the inverse relation  enforces that cyclic shifts for 
pairs of related edge classes are inverse to each other in the following sense: 
let  and  be a pair of related edges.
Assume that we have a permutation  such that  
and . We have . Hence, if  is supposed 
to be an automorphism of  then we have  and thus 
 which means that .

In conclusion, it follows that  is the subgroup of 
 
which contains all -vectors  with
the property that  for pairs of related edges 
. 
Again we remind the reader that  only depends on  but 
not on . If we want to stress this dependence, then we 
sometimes write  but usually we omit  if the graph is 
clear from the context.

Now, given a CFI-structure , we define for 
each vertex  the \emph{-gadget} as the set .

\begin{lemma}
Let  and let . 
Then there is precisely one extension  of 
to  such that  is a CFI-structure 
over .
\end{lemma}
\begin{proof}
 Let  for some . We show that 
under 
the 
assumption that  is a CFI-structure over  the 
action of  on  determines .

We have that  for all . Hence for a 
potential isomorphism  we must have that 
 (for a gadget relation 
 of a CFI-structure over ). 
Since we have , it follows by the 
definition of CFI-structures that the function  is determined as
 which in turn only depends on the 
action of  on the edge classes  for .
\end{proof}


\smallskip
The preceding lemma shows that  can be identified with 
a subset of . In fact, the set 
 turns out to be a subgroup of  of which  
is a coset in .
Specifically, we saw that every  can uniquely be 
identified with an isomorphism of CFI-structures over  by setting
 for  . As a consequence, 
this 
means that  where  and that 

In particular,  stabilises the relation  if, 
and only if, .

\begin{lemma}\label{lemma:action:on:cfi}
 acts on . For  we have  

\end{lemma}



\begin{lemma}\label{lemma:gencfi:isoclasses}
 Let  be two sequences of gadget values.
  Then  if, and only if, .
\end{lemma}
\begin{proof}
Let  such that 
.
By Lemma~\ref{lemma:action:on:cfi} this means that 
 for .
Thus . Since for all pairs of related edges  we have  the claim follows.

\smallskip
For the other direction we proceed by induction on the number  of 
vertices  such that .
If no such vertex exists, then the claim is trivial.
Otherwise, because of our assumption, there exist at least two such
vertices , .
Since  is connected we find a simple path 

from  to  of length .
Consider the following -vector  which is defined for 
 as

By the definition of  it follows that .
Let . We claim that the 
number of  such that  is at 
most .
From Lemma~\ref{lemma:action:on:cfi} we know that 
. For  it follows that
\begin{itemize}
 \item if , then , and
 \item if , then , and
 \item if  for , then
 
 \item if , then .
\end{itemize}
Thus the claim follows from the induction hypothesis.
\end{proof}

The kind of isomorphism that we constructed in the proof of 
Lemma~\ref{lemma:gencfi:isoclasses} plays an important role
later on. Thus, for a simple path  from  to  () 

as above and a constant  we denote this isomorphism by 
. 
In other words, if  we let  for  and  denote the -vector which is defined as

then .
Intuitively, the isomorphism  
allows us to simultaneously increase the gadget value at  by  and 
to decrease the gadget value at  by  while the induced twists are 
moved along the path  through the gadget relations of the 
vertices , , whose gadget value does not change.
A very important special case arises when  is a simple cycle of length 

Then for all values  the isomorphism  is an \emph{automorphism} of CFI-structures over . 
We are going to use these automorphisms to show that it is possible to define 
in 
\FPC an ordering on the orbits of -tuples as required 
by property~(\ref{item:property:classk:deforbits}).
It turns out that it therefore suffices to ensure that the graph  is 
sufficiently connected. 

\medskip
Recall that a graph  is \emph{-connected}, for , 
if  contains more than  vertices and if  stays connected 
when we remove any set of at most  vertices. The \emph{connectivity} 
 
of a graph  is the maximal  such that  is 
-connected.
Moreover, the \emph{connectivity}  of a class  of 
graphs is the function  defined by

We are prepared to define the class : 
let  be a class of \emph{undirected, ordered} graphs
such that . 
Then we set


\paragraph*{Verifying the required properties}
We proceed to show that  
satisfies the required properties
(\ref{item:property:classk:autogroups}) - 
(\ref{item:property:classk:ckeqv}).

First of all, we saw that the automorphism group of each CFI-structure 
 is a -vector space, so 
property~(\ref{item:property:classk:autogroups}) clearly holds for the class 
.

The proof that  satisfies property~(\ref{item:property:classk:deforbits}) 
is more involved.
Let us fix the length  of tuples on which we want to 
define a linear preorder which identifies -orbits.
By the choice of  it suffices to consider CFI-structures  over graphs  
with  since almost all structures in 
satisfy this condition.
As above let  denote the group that acts on the set 
of 
CFI-structures over  and let  denote 
the universe of the 
CFI-structure .

\begin{definition}
 Let  and let .

 \begin{enumerate}[(i)]
  \item Let . 
  We say that the vertex  is \emph{marked (given the parameters )} 
if for some  we have .
  \item Let . 
  We say that the edge  is \emph{marked (given the parameters~)} 
if one of the vertices  or  is marked or if for some  we have that  where  is the edge related with .
 \end{enumerate}
 \end{definition}
 
\begin{lemma}\label{lemma:marked:identified}
  Let  and let .
\begin{enumerate}[(a)]
 \item If  is marked, then the -gadget can be 
identified in  (using the parameters ), i.e.\ 
 for every   there exists a formula 
  
 such that .
 \item If an edge  is marked, then the edge classes  and 
 for  are 
identified in  (given the parameters ), i.e.\ 
 for every   there exists a formula 
  
 such that .
\end{enumerate}
\end{lemma}
\begin{proof}
  First of all, it is straightforward (even without using the parameters) 
to fix the -class of any element  in .
  Secondly, observe that if an element  is fixed, then 
we can fix an element in each of the edge classes  for  since  is -connected to 
precisely one vertex in each of these classes. 
Moreover, if we have fixed an element  in some edge class 
, then we can simply use the cycle relation  to identify each 
element  via its -distance to  in .
Finally, the inverse relation  yields a definable bijection between 
related edge classes. 
\end{proof}


 
\begin{lemma}\label{lemma:markedstable}
 Let ,  and let  be a 
vertex that is not marked.
 Then for all edges ,  which are not marked 
there exists  such that  and 
such that  for all .
 \end{lemma}
\begin{proof}
Let  and  as above.
Then the vertices  and  are not marked.

Consider the graph  that results from  by removing the vertex 
 and each marked vertex .
Let  denote the vertex set and  
the edge relation of the graph .
Moreover, let  .
We observe that .

For every  there is an edge  such that 
. For each such edge  that is also contained in the 
subgraph  we delete one of its endpoints but \emph{neither 
the vertex  nor the vertex } and denote the resulting subgraph by 
 with vertex set  and edge relation . 
It still might happen that there is a parameter  
such that  for . However, this can only occur if 
 connects  and . 
Since we removed at most  vertices from the graph  to obtain   
and 
since  we know that there is a simple path 
of length  (i.e.\ the path does not consist of a 
single edge between  
and ) which connects  and  in :


\noindent
We extend  to a simple cycle  in  from  to 
 by 
using the edges :

Let . We claim that  satisfies 
the desired properties.

By the definition of  it holds that . 
Let . Then we have , since none of the vertices ,  and
 is marked and since we removed any other marked vertex  
from .

Moreover, for  we have 
that  by our assumption that  are not marked.
Also for  we have  since 
otherwise we had removed the vertices  and  from .
Finally, for
 
we have 
since otherwise we had removed one of the endpoints of each such edge  from 
. Hence . 
Finally, since  we also have that  
for all .
\end{proof}


\begin{lemma}\label{lemma:slvclass:orbit:ckeqv}
 Let  and let .
 Then  if, and only if, there exists 
 such that .
\end{lemma}
\begin{proof}
We proceed by induction on the maximal position  up to 
which the tuples  and  agree, i.e.\ such that for  we 
have  and such that .
Let  and . 
Then we have to show that there exists an automorphism 
 such that 
.
Since  and  have the same -type we know that 
 and  belong to the same -class. 
We choose  such that . 

In what follows, whenever we speak of \emph{marked vertices} or 
\emph{marked edges} then we implicitly refer to a marking with respect to 
the already fixed part of parameters .

Without loss of generality we may assume that the vertex  is not 
marked (by an element ), because otherwise, by 
Lemma~\ref{lemma:marked:identified}, every element in  can 
uniquely be identified in .
We distinguish between the two cases where  and  are equation nodes 
and where  and  are edge nodes.

For the first case let .
There exists a unique  such that 
 and such that .
Moreover, this vector  can easily be defined in 
 given the elements  and . 
Now assume that one of the edges  is marked but that 
. 
Since the edge  is marked, every element in  can uniquely be 
identified in  
by Lemma~\ref{lemma:marked:identified}.
However, since  and  are -connected to \emph{different} elements 
in  (as ) this 
contradicts the fact that  and  have the same -type.
Thus, for every edge  we either have that  or that  
is not marked. By induction on the number of edges  with 
 we show that  can be extended to an 
automorphism in .
Thus let us fix  such that . Since we have 
that  there has to be another edge  with . We apply 
Lemma~\ref{lemma:markedstable}
to obtain an automorphism  such 
that 
,  and  for all .
Now consider . By the 
induction 
hypothesis we can extend this vector to an automorphism 
. But then  is an extension of .

For the second case assume that  for some edge .
As above we conclude that the edge  is not marked.
Since  the minimal degree of each 
vertex in  is at least . 
Since the vertex  is not marked there has to be 
another edge ,  which is not marked.
Thus we can apply 
Lemma~\ref{lemma:markedstable}
to obtain an automorphism  
such that  and  for all . 
\end{proof}

\medskip
It is well-known that classes of -equivalent tuples 
can be ordered in , see e.g.\ \cite{Ot97}.
Hence, it follows from our previous lemma that the class  satisfies 
property~(\ref{item:property:classk:deforbits}). 

\begin{lemma} \label{lemma:slv:classk:prop:12}
The class  satisfies the properties
(\ref{item:property:classk:autogroups}) and
(\ref{item:property:classk:deforbits}).
\end{lemma}


\medskip
Let us now turn our attention to 
property~(\ref{item:property:classk:ckeqv}).
In the next lemma we are going to show that for each  and each
sufficiently connected graph , the logic  cannot 
distinguish between any pair of CFI-structures over  (although there 
exist non-isomorphic CFI-structures over ).
\begin{lemma} \label{lemma:slv:classk:prop:4}
 Let  and let  such that .
 Then for all  it holds that
 
 Thus, the class  satisfies 
property~(\ref{item:property:classk:ckeqv}).
\end{lemma}
\begin{proof}
 Let  and let . 
 Without loss of generality we assume that .
 We show 
that Duplicator wins the -pebble bijection game 
on  and . Let , let  and let .
As above, for  and  we let  denote the isomorphism which shifts the edge class  by 
, the edge class  for  by  and which stabilises all 
remaining classes, i.e.\

Given a position  in the 
-pebble bijection game, we say that a pair  with  and  is \emph{good} if:
\begin{itemize}
 \item the -gadget is not marked (by the pebbled elements  in  or, equivalently, by the pebbled elements  in ),
 \item  for , 
 \item , and
 \item  for all .
\end{itemize}
Intuitively this means that  is nearly an isomorphism between  
and  except for the gadget associated to vertex .
Of course  itself does not induce a bijection between the universes 
of the two CFI-structures (as otherwise ).
However, for each  we can associate a bijection  to  which is defined as


In what follows we show that Duplicator can play in such a way that 
after each round such a good pair  exists. Obviously, if Duplicator 
can 
maintain this invariant this suffices for her to win the game.

Indeed we can find such a good pair  
by Lemma~\ref{lemma:gencfi:isoclasses} for the initial position  
of the game.
Let us now consider one round of the game which starts from a 
position  for which a 
good 
pair  exists.
First, Spoiler chooses a pair  of pebbles which he removes from the 
game board (if the corresponding pebbles are placed at all). 
Duplicator then answers Spoiler's challenge by providing a bijection 
 for some edge  which is not marked. 
Note that such an edge  exists since  and thus each 
vertex has degree at least .
Spoiler picks a new pair  of -related elements on which he places the -th pair of pebbles.
By the properties of  it immediately follows that the resulting mapping 
 is a partial isomorphism. 
However, it might happen that Spoiler placed the -th pair of pebbles on 
equation nodes  in the gadget associated to vertex . In this case 
the 
pair  is not good any longer.
So assume that Spoiler pebbled a new pair of elements .
Since the edge  was not marked we know that  is not 
marked.
Thus it is easy to see that the 
pair  is good. 
\end{proof}

To complete our proof we establish an -definable 
canonisation procedure on the class . 
The idea is as follows: given a CFI-structure  
over a graph  and a value  we construct a 
linear equation system over  which is solvable if, 
and only if, . This linear equation system 
is -definable in the structure  which shows that  can 
determine the isomorphism class of a CFI-structure over . Since the 
graph  is ordered it is easy to construct an ordered
representative from each isomorphism classes of CFI-structures over  
which concludes our argument.

More specifically, let , let  and let . 
For our linear equation system we identify each element  
and each vertex  with a variable over , i.e.\ we let 
 be the set of variables.
The equations of the linear system are given as follows:

\eqcountreset



It is easy to see that this system is -definable in . 
First of all, the equation (\ref{les:slvq:e4}) can be defined as a sum over the 
ordered set . Moreover, we can 
express the equations of type (\ref{les:slvq:e1}) and (\ref{les:slvq:e2}) by 
using the cycle and inverse relation, respectively. 
Finally, the equations of type (\ref{les:slvq:e3}) can be expressed by using 
the gadget relation . 


\begin{lemma}
 The above defined system is solvable if, and only if, 
 .
\end{lemma}
\begin{proof}
 If  then it is easy to verify that we obtain a solution 
 of the linear system by setting  and .
For the other direction, we show that a solution  of 
this system defines an isomorphism  between  and  where . 
As a preparation, we let  for  and some . Since  is a solution,  is well-defined.
Now we obtain the isomorphism  for  and  by setting

Using the equations (\ref{les:slvq:e1}) and (\ref{les:slvq:e2}) one 
easily verifies that  respects the cycle relation  and the inverse 
relation .
Moreover, let . Then 

Thus,  also respects .
Finally, by the equations of type (\ref{les:slvq:e3}),  for all  and 
 we have that

This shows that  and that  because of equation (\ref{les:slvq:e4}).
\end{proof}


\begin{lemma} \label{lemma:slv:classk:prop:3}
The class  satisfies the property
(\ref{item:property:classk:isopoly}).
\end{lemma}

This finishes our proof of Theorem~\ref{thm:fps:distinct:primes}.



\section{Solvability quantifiers vs.\ rank operators}
\label{sec:slv:rk}

In the previous section we obtained separation results for the 
extensions of  by solvability quantifiers (and rank operators) over 
different sets of primes.
One important step of our proof was to construct a class of structures on which 
the expressive power of the logics  and  
coincides. 
Moreover, as we already mentioned in Section~\ref{sec:logics:linalgop}, most of 
the queries which are known to separate fixed-point logic with counting and 
rank logic can also be expressed in . 
This leads to the interesting question whether, in general, rank operators can 
be simulated by solvability quantifiers within fixed-point logic with counting.
In this context, it is worthwhile to remark that many other problems from 
linear algebra are known to sit in between of ``solving linear equation 
systems'' and ``computing the matrix rank'', for example, deciding whether two 
matrices are similar or equivalent, see~\cite{Pa10, Ho10, La11}.

\smallskip
In this section we solve a simplified version of this question and show that 
in the absence of fixed-points and, more importantly, in the 
absence of counting, rank operators are strictly more expressive than 
solvability quantifiers. The reader should note that rank 
operators can easily simulate counting terms but this does not hold 
for solvability quantifiers.

In order to state our main result formally, we first define for every
prime  the extension  of first-order logic (without counting) by 
solvability quantifiers over . 
The crucial difference to the extension  of first-order logic by rank 
operators  is that the logic  is a \emph{one-sorted} logic which 
does not have access to a counting sort.

\begin{definition}\label{def:fosp}
For every prime , the logic  results by extending the syntax of 
 by the following
formula creation rule:
\begin{itemize}
 \item If , then
    is an 
-formula.
\end{itemize}
\noindent
The semantics of  are defined as above. 
For completeness, let  and . A pair  with  defines an -matrix 
 over  where  and  and where
 if, and only if, .

Let  be the -identity vector over , i.e.\ 
 for all . Then  and  determine
the linear
equation system  over .
Now we let  if, and only if,  is solvable.
\end{definition}

Analogously to the definition of  in Section~\ref{sec:logics:linalgop}, 
the syntactic normal form of definable linear equation systems in the 
definition of -quantifier does not lead to a severe restriction (again, 
see Lemma~4.1 in~\cite{DaGrHoKoPa13}).

\medskip
Let us briefly summarise what is known about the logic  (see
also \cite{DaGrHoKoPa13,Pa10}). First of all, it follows from \cite{DaGrHoLa09} 
that for
every prime , the logic 
 can express the symmetric transitive closure of definable 
relations. Hence,  subsumes the logic  and can express every 
\LOGSPACE-computable property of ordered structures. Secondly, it also follows
from \cite{DaGrHoLa09} that  can distinguish between the odd and even
version of a CFI-graph, which means that  cannot be a fragment of
. More generally, by adapting the CFI-construction for other fields
one can show that  for all  (see
e.g.\ \cite{Ho10}).

On the domain of ordered structures, the expressive power 
of  can be characterised in terms of a natural complexity 
class: in \cite{BuHeDaMe91}, Buntrock~et.~al.\ introduced
the \emph{logarithmic space modulo counting classes}  for integers
. Analogously to the case of modulo counting classes for polynomial
time, the idea is to say that a problem is in  if there exists a
non-deterministic logspace Turing machine which verifies its inputs by producing
a number of accepting paths which is not congruent . For the 
formal
definition we refer the reader to~\cite{BuHeDaMe91}. It turns out that, at least
for primes , the class  is closed under many natural operations,
including all Boolean operations and even logspace Turing reductions
\cite{BuHeDaMe91,HeReVo00}. Furthermore, many problems from linear
algebra over  are complete for . In particular this is
true for the solvability problem of linear equation systems over 
and for computing the matrix rank over ~\cite{BuHeDaMe91}.

Building on these insights, Dawar~et.~al.\ were able to show that for all
primes , the logic  captures  on the class of ordered
structures. It has been noted in~\cite{Pa10} that their proof shows that 
the same correspondence holds for the logic .
\begin{prop}[\cite{DaGrHoLa09},\cite{Pa10}]
 On ordered structures we have .
\end{prop}

Despite this characterisation over the class of ordered 
structures, the situation over general structures remained unclear. It easily 
follows that , but, 
so far, it 
has been open whether one, or even both, of these inclusions are strict.
In this section we are going to settle one of these questions:

\begin{theorem}
\label{thm:fos:for}
 For all primes  we have  (over the class of sets 
).
\end{theorem}

In some sense, this result is not very surprising. 
Over the class of sets, the logic  captures the complexity class 
 since the size of a set is a complete invariant.
In contrast, the logic  cannot access the counting sort 
and thus had to express properties over pure unordered sets which have 
the maximal amount of symmetries.
However, it is not obvious how one can turn this intuition into a formal 
argument. Strikingly,  has non-trivial expressive 
power over sets. For instance,  can determine the 
size of sets modulo ~\cite{Pa10}, and consequently, modulo  for 
every fixed  (since  if, and only if, 
 and ). 
Note that fixed-point logic , for example, collapses to 
first-order logic over sets.

In order to prove Theorem~\ref{thm:fos:for} we make use of the following 
strong normal form for \FOSp which has been established 
in Corollary~4.8 of~\cite{DaGrHoKoPa13}.
\begin{theorem}
\label{thm:normalform:fos}
Every formula  is equivalent to an 
-formula of
the form  where 
 is quantifier-free.
\end{theorem}


\medskip
Similar to our approach in Section~\ref{sec:sep:fields}, the main idea 
for separating  and  is to exploit the symmetries of definable 
linear equation systems.
More precisely, we are aiming at considerably reducing the size of an input 
linear equation system via an -definable transformation. For the 
remainder of this proof, let us fix a quantifier-free formula 
 and a 
prime . 
According to the semantics of , the formula  defines in an
input structure  of size  the -coefficient
matrix  which is given for  as

Then  if the linear
equation system   over  is solvable.
For convenience we set  and . 

Let . Then the group  acts on 
and  in the natural way. 
As in Section~\ref{sec:sep:fields} we identify the action of  with the multiplication by the associated -permutation matrix  and the -permutation 
matrix , respectively. Hence, for  we have 


For what follows, we fix a prime  which is distinct from  
and a subgroup  which is a -group, i.e.\  for some . The overall strategy is to use the -symmetries of the 
matrix 
to strongly reduce the size of the linear equation system .
More precisely we claim that for  the
linear equation system  is solvable if, and only if,
 is solvable. First of all we note that for all
 we have:
\begin{itemize}
 \item 
 \item .
\end{itemize}
To verify our original claim assume that . Then we have

For the other direction let . Then
, hence  is a solution of the
linear equation system . Note that for this 
direction we require that  and  are co-prime as we have to divide by 
.

\smallskip
Since  satisfies  for
all  we have 
 for all  and .
In other words, the entries of the -matrix  are constant 
on the -orbits of the index sets  and . 
More specifically, if we let  and  denote the sets of
-orbits on  and , respectively, then  can
be identified with the matrix  which is defined as 

Note that, depending on the size of the group , the sets 
 and  can be noticeably smaller than the index 
sets  and . 
Hence our obvious strategy is to choose  as large as 
possible to obtain a much more compact linear equation system  which is  equivalent to the given one.

\medskip
Recall that the maximal -subgroups   are 
 the \emph{-Sylow groups} of . 
It is well-known that for the case where  these 
groups can be obtained via an inductive construction which we
want to explain here for the special case of  being a power of  (the 
general case can be handled similarly, see e.g.~\cite{Ha76}). Hence from 
now on, let us assume that  for some .

First of all, we determine the size of -Sylow groups of 
. A simple induction shows that
the maximal  such that   divides 

is given as

In fact, we can write  as .
Hence  where  is the maximal such that 
divides .

In particular, if we denote for  a -Sylow of 
by , then our argument from above shows that  and that


As it turns out, this equation already gives a hint about the algebraic
structure of . Indeed,  can be obtained as the 
\emph{wreath product} of 
 and the cyclic group . Since  
it 
follows that  is the -fold wreath product of the 
cyclic group . We
decided to skip the
formal definition of the notion of wreath products and rather to directly
illustrate this concept for the particular case of the -Sylow groups of 
.

To obtain an algebraic description of these groups, we inductively 
construct for  a -Sylow subgroup  together 
with a family of trees  for  
and  such that the following properties
hold.
\begin{enumerate}[(I)]
 \item  is a complete -ary tree of height  whose leaves 
are labelled with elements from .
 More precisely, the labels of the leaves of  form the set 
 (note that 
 is the -th block of the natural partition of  into 
parts of size ).
\label{properties:sylow_tress:1}
 \item For all  the group  transitively acts on the set  by applying
permutations  to the labels of the leaves of the tress 
.
Moreover, for each , the subgroup of  which point-wise 
stabilises the trees  is a normal subgroup of .
\label{properties:sylow_tress:2}
 \item We have  where 
 acts on the set of labels  of the tree 
. More generally, for every block , the group 
contains a subgroup  which point-wise fixes
the elements of all blocks  for  and whose action on
 corresponds to the action of  on .
\label{properties:sylow_tress:3}
\end{enumerate}


The inductive construction of the trees  is depicted in
Figure~\ref{fig:definition:trees_q_sylow}. 
To understand this construction better, it is quite
useful to think of elements  as being represented in their 
-adic encoding, i.e.\
. 
Then we have that  and
\begin{itemize}
 \item  
 \item 
 \item 
 \item .
\end{itemize}
Hence, the -adic encoding of  describes the unique path in the tree 
 from the root to the leaf .
The trees  clearly satisfy the properties stated
in~(\ref{properties:sylow_tress:1}).

For the inductive construction of the -Sylow groups
 we first fix  as the cyclic group generated by the natural 
cyclic shift  on the set .

\begin{figure}[ht]
 \centering
\begin{tikzpicture}[>=stealth]
 


\node[draw,rectangle,thin] at (-3.2,0) {};
 
\node (t00) at (-2,0) {:};
 \node[right of=t00, node distance=25, draw,fill,circle, inner sep=0.8pt,
label=right:{}] (treet00) {};
 
\node[right of=treet00, node distance=45] (dotsib1) {};
  
\node[right of=dotsib1, node distance=45] (t01) {:};
 \node[right of=t01, node distance=25, draw,fill,circle, inner sep=0.8pt,
label=right:{}] (treet01) {};
 
\node[right of=treet01, node distance=45] (dotsib2) {};
  
\node[right of=dotsib2, node distance=45] (t0last) {:};
 \node[right of=t0last, node distance=30, draw,fill,circle, inner sep=0.8pt,
label=right:{}] (treet0last) {};
 
 
 


\node[draw,rectangle,thin] at (-3.2,-2) {};
 
\node (ti0) at (-2,-2) {:};
 \node[right of=ti0, node distance=25, draw,fill,circle, inner sep=0.8pt]
(treeti0) {};
 \node[below left of=treeti0, node distance=40, draw, fill, circle,
inner sep=0.8pt,label=below:{}] (treeti0child1) {} ;
\node[below of=treeti0, node distance=28] (treeti0childdots) {} ;
  \node[below right of=treeti0, node distance=40, draw, fill, circle,
inner sep=0.8pt,label=below:{}] (treeti0childlast) {} ;
  
  \draw[->,thin] (treeti0) edge (treeti0child1);
  \draw[->,thin] (treeti0) edge (treeti0childlast);
  
  
\node[right of=treeti0, node distance=45] (dotsis1) {};
 
 
\node[right of=dotsis1, node distance=45] (tix) {:};
 \node[right of=tix, node distance=25, draw,fill,circle, inner sep=0.8pt]
(treetix) {};
 \node[below left of=treetix, node distance=40, draw, fill, circle,
inner sep=0.8pt,label=below:{}] (treetixchild1) {} ;
\node[below of=treetix, node distance=28] (treetixchilddots) {} ;
  \node[below right of=treetix, node distance=40, draw, fill, circle,
inner sep=0.8pt,label=below:{}] (treetixchildlast) {} ;
 
 \draw[->,thin] (treetix) edge (treetixchild1);
  \draw[->,thin] (treetix) edge (treetixchildlast);
  
 
\node[right of=treetix, node distance=45] (dotsis2) {};
 
\node[right of=dotsis2, node distance=45] (tilast) {:};
 \node[right of=tilast, node distance=25, draw,fill,circle, inner sep=0.8pt]
(treetilast) {};
 \node[below left of=treetilast, node distance=40, draw, fill, circle,
inner sep=0.8pt,label=below:{}] (treetilastchild1)
{} ;
\node[below of=treetilast, node distance=28] (treetilastchilddots) {} ;
  \node[below right of=treetilast, node distance=40, draw, fill, circle,
inner sep=0.8pt,label=below:{}] (treetilastchildlast)
{} ;
  \draw[->,thin] (treetilast) edge (treetilastchild1);
  \draw[->,thin] (treetilast) edge (treetilastchildlast);
   
\end{tikzpicture}
\caption{Inductive definition of the trees }
\label{fig:definition:trees_q_sylow}
\end{figure}

We proceed with the inductive step .
The set  splits into  blocks  each of size .
The group  acts on  and point-wise fixes
the elements from the blocks  with .
Let  for  be the following 
permutation which shifts
the segments  in a cycle of length  by
composing the natural shifts on the sets of residues modulo :


Hence for all  we have .
We set  and, more generally,  for  to 
obtain  copys of  which independently act on the segments
 for . 
Finally, we define  
as the \emph{semi-direct product} of  and the cyclic group  of size .
This means that the group elements of  are elements in the set

and that the group operation is given by

Since  we conclude that
 indeed is a -Sylow subgroup.

\medskip
From our construction it immediately follows that  satisfies the
properties stated in~(\ref{properties:sylow_tress:3}). To see that
 also satisfies the properties stated
in~(\ref{properties:sylow_tress:2}) we start by showing that, for , 
 transitively acts on .
If we split the set   
into  blocks  of size 
then we know from the induction hypothesis that  transitively
acts on the set of trees . 
Moreover, it is easy to verify that for all  we have
 where .
Hence  for all  which means that
 transitively acts on  and
thus~(\ref{properties:sylow_tress:2}) holds.


\bigskip
The crucial step is to understand the action of 
on the sets  and  (for the case where 
).
In fact, our next aim is to develop a complete invariant for 
the -orbits on these index sets. Recall that the sets 
of -orbits on  and  provide index sets for 
the succinct linear equation system 
.
To define this invariant, the main idea is to describe the position 
of a tuple  (or , respectively) in the tree 
.

Let us first define the \emph{signature}  of a pair  as the tuple  such that the lowest common ancestor of  in  is the 
root of a tree  and  such that  is located in a subtree 
 for  and  is located in the 
subtree  where . For the 
special case where  we have  and agree to set . With this 
preparation we define the signature  of a tuple  as the list  consisting of the individual signatures 
 for all pairs  with .
The signature of tuples in  is defined analogously.

\begin{lemma}
\label{lemma:sgnsylow:part1}
 Let . Then  for all .
\end{lemma}
\begin{proof}
 Immediately follows from the construction of  and the trees
.
\end{proof}


\begin{lemma}
Let . If , then .
\end{lemma}
\begin{proof}
 We proceed by induction on the maximal position  such that
 for all . The case  is clear, so assume
that .
Let  and . We show that there exists a permutation  which pointwise fixes  and such that
. Then the claim follows from
Lemma~\ref{lemma:sgnsylow:part1} together with the induction hypothesis.
For  this is easy, because  acts transitively on . If  we choose  such that
 and such that  is minimal with this 
property.
Obviously we
have . By the choice of  the lowest common ancestor of
 and  is the root of a tree . Moreover,  is
located in a subtree  for some  and
 is located in the subtree  where . Since  also  occurs as the label of a
leave in the subtree .
By the minimality assumption on  we know that non of the elements 
 occurs in the tree .
Hence, by the
properties of the group  stated in~(\ref{properties:sylow_tress:3})
we can find an element  which point-wise fixes all elements
outside the block  (in particular, the elements ) and which moves  to . 
\end{proof}


Following our definition from above, the signature  of an element 
 is a tuple of length  whose entries are pairs 
. We denote the set of all possible 
sequences of this form by . Of course, not every tuple in  can be
realised as the signature  of an element . 
Similarly, we define the set  to capture all possible signatures of elements in .

\medskip
Since the coefficient matrix  of the equivalent linear 
equation system  can be defined 
as a matrix whose index sets are the collections of -orbits on 
 and , we can use the notion of signatures to describe 
 as an 
-matrix. This fits with our 
proof plan as the index sets  and  of the 
matrix  are much smaller than the  index sets  and  of the 
coefficient matrix  of the original linear equation system.
However, it still might be the case that the succinctness of the 
matrix  does not help, because it is not possible to obtain its 
entries within .

We show that this is not the case. More precisely we show
that we can define the matrix  in  in a 
structure of size  (where we assume that ). 
Therefore, the main technical 
step is to show that  can count (modulo ) the number of 
realisations of a potential signature .

\medskip
First of all, we need some further notation. A \emph{complete equality 
type in  variables}  is a consistent set  of literals 
which contains for every pair  either the atom  or the literal
. Note that each quantifier-free formula  can be 
expressed as a Boolean combination of complete equality types.

In the following main technical lemma we show that in the structure  we can count (modulo ) the number of 
realisations of a (potential) signature  in a 
subtree  in . More generally, this is possible  if 
we additionally 
fix some entries of the tuples which should realise  in 
.
Here we need another prerequisite: as we want to work with elements 
from the set  in a structure of size  we have to 
agree on some sort of succinct representation. 
Of course the natural choice here is 
to represent numbers  in the structure  via their 
-adic encoding: a binary relation  which corresponds to a function  
represents the number . Note that this encoding requires a linear order on the set  
(which is \emph{not} the case for the 
structure ). However, as we are working with  we can just use the 
number sort on which a linear order is available.
Hence in the following, whenever we specify -formulas or -terms 
with free variables or with free relation symbols which should represent 
numbers, then we implicitly assume that these variables are \emph{numeric} 
variables and that the relation symbols are evaluated over the number 
sort. The same holds for signatures  which we specify 
in -formulas by a list of pairs  of \emph{numeric} 
variables  of length .

Before we state our main technical lemma it is helpful to recall that our 
inductive construction of the trees  fits very well with the 
-adic encoding 
of numbers .
Again, let  be given by its -adic encoding as 
, i.e.\ . Then the -th node on the unique path from the root 
in the tree   to the leave  is the root of the tree 
 where . 
In other words, the -adic encoding of  precisely describes the 
path in the tree  from the root to the leave labelled with  where 
at level  the  last entries   in 
the -adic encoding of  are determined (i.e.\  is a member of the 
block ).


\begin{lemma}\label{lemma:counting:realisations:sgn}
  For all  and  there exist
 \begin{enumerate}[(a)]
  \item a term , and
  \item formulas  for ,
 \end{enumerate}
where , such that for all , all , all 
 
where , all  and all  the following holds: let  and let  be numerical relations such that  represents the 
(-adic 
encoding of the) element  and such that each  
represents 
the  (-adic encoding of) the element . Then we have that
 \begin{enumerate}[(i)]
  \item the value  of the 
term  in  is  where 

 \item if , then the formulas  define the -adic representation of witnessing elements , i.e.\ such that .
\end{enumerate}

\end{lemma}

\begin{proof}
 First of all, by our previous observations it is easy to see that the 
condition  for  can be defined in 
. More generally, we can use the -adic encoding of the elements 
 to determine  in . Hence, for the 
remainder of the proof we assume that  is consistent 
with  and that  for .

We proceed by induction on . For  it suffices to 
show that  can compute  where  in the 
structure . To see this, recall that  and  are co-prime and 
thus we can use Lagrange's theorem to conclude that  if . 
Since  is a constant, the claim follows.

Let . We distinguish between the following two cases. If , 
then we can partition the set of realisations  of  according 
to first entry  into  parts of 
equal size.
It suffices to determine the size of each of these blocks, since we can
determine 
in  similarly as above.

Without loss of generality let us assume that . Since 
we 
have given the -adic encoding of  it is easy to see that we can 
define the -adic encoding of  in \FOC. This gives us the formula 
.
Next, we partition the set of indices  into classes 
according to the
equivalence relation
 if . Let the
resulting
classes be  and let  for all
 and . 

We observe that there exists a tuple  with  which
realises  in the tree  (that is )
if, and only if, the following conditions are satisfied:

\begin{itemize}
 \item for all  we have , and
 \item for every  there is a 
tuple  of length  which realises  (restricted to the
indices from ) in the subtree , and
 \item for all pairs  and  with  we
have that 
  
\end{itemize}

Since  is a constant, the number of possible partitions of  is bounded by a constant as well. It is easy to see that for
every possible such partition we can check the first and third
condition in . 
To verify the second condition in  we use the induction 
hypothesis. 
There are two aspects which have to be discussed with more precision. First of
all, we have to handle one particular case separately: indeed, if 
for all , then we cannot use the induction
hypothesis since all elements (including ) have to be chosen in the 
same subtree of height one.
However, in this case there is only one realisation (if the third condition is
satisfied) so this does not cause any problems.
The other difficulty is that we have to define the -adic encoding of the
value  in . 
We already noted before 
that the -adic representation of  can be defined in  and
since  we can also define the -adic encoding of  in
.

In fact, the induction hypothesis also provides us with a term which counts
modulo  the number of possible realisations of  in the subtrees 
 restricted to the indices in  together
with formulas  which define witnessing elements. 
Finally, since the overall number of possible realisations of  in
 is the product of the realisations restricted to the components
, the claim follows for the case where . 

For the general case let  and let  be the components of the tuple  that are already fixed. 
Recall that we can assume without loss of generality that 
 is consistent with  and that
all elements  are located in the subtree .
Since we have fixed the element , we can proceed as above except for two
small changes. First of all, when applying the induction hypothesis we have 
to respect the remaining fixed elements . Moreover, when we
form the partitions of  into parts  as
above then we have to adapt the position of elements corresponding to the index
set  since the element  is not necessarily contained in the tree
. However, since we have given the -adic
representation of  we can define in  the element 
such that  is located in the subtree . 
The remaining steps can be performed as above. This finishes our proof.
\end{proof}

\begin{lemma}\label{lemma:entrymn:comp:type}
Let
 be a complete 
equality type (in  variables).
Then there is an -term  such that for all 
, all  and , 
where , the value
 of  in  is 

for some (or, equivalently, all)  with .
\end{lemma}
\begin{proof}
 By Lemma~\ref{lemma:counting:realisations:sgn} we can first check in
 that  and  can be realised (otherwise the
answer is trivial). Moreover, if  (restricted to ) is not
consistent with  or if  (restricted to )
contradicts , then the answer is trivial as well.

In all other cases, Lemma~\ref{lemma:counting:realisations:sgn} provides 
-formulas which define in the structure  the -adic encoding 
of elements  such that . 
Moreover, if  contains a literal , then we can
fix the entry  as well. Hence, let us assume without loss of 
generality that  contains the literals  for all 
 and .

For  and a partial assignment  with  we define the set 
 

With this notation our overall aim is to determine  for  in . The first observation is
that by Lemma~\ref{lemma:counting:realisations:sgn} we can determine
 for all partial
assignments  in .
The second observation is that we can construct the values
 by induction on  as follows. 
For
 and a partial assignment  (with
) we have for all  that

In this way we recursively obtain the value 
 for . 
Since  is a 
constant the recursion depth is bounded by a constant as well and the 
procedure can be formalised in . 
\end{proof}


\begin{lemma}\label{lemma:mnstar:definable}
There exists an -term  which defines for 
all  in the structure  the matrix  
where .
\end{lemma}

\begin{proof}
 Recall that we can view  as an -matrix over . To represent the index sets  
and  we let  and  be tuples of numeric variables of 
lengths  and , 
respectively.

Note that the entry  of 
for  and  is given as 

for some (or, equivalently, all)  with . The entry , in turn, is 
determined by the quantifier-free formula . With this preparation, 
Lemma~\ref{lemma:entrymn:comp:type} already shows that we can determine 
the value  for the case where  is 
a complete equality type. For the general case we just write  as 
the union of complete equality types and combine the constant number of 
intermediate results.
\end{proof}


\begin{definition}
 Let  be a class of sets. The 
\emph{-power  of } 
consists of all sets  such that .
\end{definition}


\begin{theorem}
\label{thm:foslv:qred}
 Let  be a class of sets. If  is 
definable in , then 
 is definable in .
\end{theorem}
\begin{proof}
 If  is definable in , then by 
Theorem~\ref{thm:normalform:fos} we can also find a formula  
that defines  such that 
 is quantifier-free. 

By using the above construction and Lemma~\ref{lemma:mnstar:definable}, 
we conclude that the linear equation system  
defined by  in an input structure  of size 
 can be transformed into the equivalent 
system  which is -definable in .
Let  be a formula which expresses the solvability of 
the linear system  in a structure .

Then  if, and only if,  since the 
linear equation systems  
and  are equivalent.
\end{proof}


\begin{theorem}
 For all primes  we have 
  (even over ).
\end{theorem}
\begin{proof}
 Otherwise we had . As above we fix some prime . 
Let  be a class of sets such that , but such that . Such a class  is 
well-known to exist (just combine the fact that, over sets, we have 
 and the space-hierarchy 
theorem, see e.g.~\cite{Pa95}). Since  we had  and by Theorem~\ref{thm:foslv:qred} this means that . Again, since , we had . A second 
application of Theorem~\ref{thm:foslv:qred} yields  
which contradicts our assumptions.
\end{proof}

Finally we remark that the proof also works for the extension of 
fixed-point logic by solvability quantifiers but in the absence of counting.
The simple reason is that fixed-point operators do not increase the expressive 
power of first-order logic over the empty signature since all definable 
relations are composed from a constant-sized set of basic building blocks. 


\section{Discussion}

We showed that the expressive power of rank operators over 
different prime fields is incomparable and we inferred that the version of rank 
logic \FPR with a distinct rank operator  for every prime  
fails to capture polynomial time.
In particular our proof shows that  cannot express the uniform version of 
the matrix rank problem where the prime  is part of the input.
Moreover, we separated rank operators and solvability quantifiers in the 
absence of counting.

Of course, an immediate question is whether the extension  of 
 by the uniform rank operator  suffices to capture polynomial time.
We do not believe that this is the case.
A natural candidate to separate  from  is the solvability 
problem for linear equation systems over finite rings
rather than fields~\cite{DaGrHoKoPa13}.
While linear equations systems can be efficiently solved also over rings,
there is no notion of matrix rank that seems to be helpful for this purpose.
In particular, it is open, whether  can
define the isomorphism problem for CFI-structures 
generalised to .
A negative answer to this last question would provide a class 
of structures on which  is strictly weaker than
Choiceless Polynomial Time (which captures  on this 
class~\cite{AGGP14}).

Another question concerns the relationship between solvability 
logic  and rank logic . Our proof of 
Lemma~\ref{lemma:rank:to:solve} shows that on every class of structures of 
bounded colour class size the two logics have the same expressive power.
However, over general structures this reduction fails.
We only know, by our results from Section~\ref{sec:slv:rk}, that
a simulation of rank operators by solvability quantifiers would require
counting.

Finally, we think it is worth to explore the connections between our approach 
and the game-theoretic approach proposed by Dawar and Holm in~\cite{DaHo12} to 
see to what extent our methods can be combined. 
For example, what kind of properties does a variant of their partition games 
have for  infinitary logics with solvability quantifiers?



\bibliography{fps-fpr}




\end{document}
