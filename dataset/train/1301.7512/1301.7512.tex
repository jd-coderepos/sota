\documentclass{llncs}
\usepackage{tabularx,booktabs,multirow,delarray,array}
\usepackage{graphicx,amssymb,amsmath,amssymb}
\usepackage{latexsym}
\usepackage[mathlines]{lineno}




\newcommand{\TT}{\mbox{}}
\newcommand{\SF}{\mbox{}}
\newcommand{\RG}{\mbox{}}
\newcommand{\WD}{\mbox{}}
\newcommand{\TR}{\mbox{}}
\newcommand{\BR}{\mbox{}}
\newcommand{\SR}{\mbox{}}
\newcommand{\BS}{\mbox{}}
\newcommand{\CBS}{\mbox{}}
\newcommand{\VD}{\mbox{}}
\newcommand{\CD}{\mbox{}}
\newcommand{\IN}{\mbox{}}
\newcommand{\DP}{\mbox{}}
\newcommand{\BP}{\mbox{}}
\newcommand{\MST}{\mbox{}}
\newcommand{\SPM}{\mbox{}}
\newcommand{\OPT}{\mbox{}}
\newcommand{\SP}{\mbox{}}
\newcommand{\SPL}{\mbox{}}
\newcommand{\Vor}{\mbox{}}
\newcommand{\Tri}{\mbox{}}
\newcommand{\diff}{\mbox{}}

\renewcommand{\thefootnote}{\fnsymbol{footnote}}




\newenvironment{myproof}{\noindent {\textbf{Proof:}}\rm}{\hfill \rm}



\def\calP{\mathcal{P}}
\def\calT{\mathcal{T}}
\def\calD{\mathcal{D}}
\def\calR{\mathbb{R}^2}
\def\cen{-center}
\def\wsf{WSF}
\def\problem{{\it 1DkCenter}}

\def\lemmaspace{\vspace*{-0.07in}}
\def\sectionspace{\vspace*{-0.10in}}
\def\subsectionspace{\vspace*{-0.06in}}




\begin{document}


\title{Efficient Algorithms for the One-Dimensional -Center Problem\thanks{D.Z.~Chen's research was supported in part by NSF
under Grant CCF-1217906. H.~Wang's research was supported in part by NSF under Grant CCF-1317143.}}

\author{Danny Z.~Chen\inst{1} \and Jian Li\inst{2}
\and Haitao Wang\inst{3}\thanks{This work was partially done while the
author was visiting at IIIS at Tsinghua University.}}

\institute{
  Department of Computer Science and Engineering\\
  University of Notre Dame, Notre Dame, IN 46556, USA\\
  \email{dchen@nd.edu}\\
  \and
  Institute for Interdisciplinary Information Sciences (IIIS)\\
  Tsinghua University, Beijing 100084, China\\
  \email{lijian83@mail.tsinghua.edu.cn}\\
  \and
  Department of Computer Science\\
  Utah State University, Logan, UT 84322, USA\\
  \email{haitao.wang@usu.edu}\\
}

\maketitle

\pagestyle{plain}
\pagenumbering{arabic}
\setcounter{page}{1}


\begin{abstract}
We consider the problem of finding  centers for  weighted points on a real line.
This (weighted) \cen\ problem was solved in  time previously by using Cole's parametric search and other complicated approaches. In this paper, we present an easier  time algorithm that avoids the parametric search, and in certain special cases our algorithm solves the problem
in  time. In addition, our techniques involve developing interesting data structures for processing queries that find a
lowest point in the common intersection of a certain subset of half-planes. This subproblem is interesting in its own right and our solution for it may find other applications as well.
\end{abstract}

{\bf Key words:} -center, one-dimension, facility locations, algorithms, data structures, 2-D sublist LP queries, computational geometry



\section{Introduction}
\label{sec:intro}

We study the weighted -center problem for a set
of  points on a real line. Let ,  be a set
of  points on a real line . For each  with ,
the point  has a weight . For a point  on
, denote by  the coordinate of  on , which we also
refer to as the -coordinate of . For two points  and  on
, let  be the {\em distance} between  and
. Further, for a set  of
points and a point  on , define . Given  and an integer , the weighted
{\em one-dimensional -center} problem seeks to determine a set
 of  points on  such that the value
 is minimized. We
use \problem\ to denote this problem. Also, the points in  are
called {\em centers}, and the points in  are called
{\em demand points}.


The {\em unweighted version} of \problem\ is the case where all
points have the same weight. If  is required, then the
case is called the {\em discrete version}.




Although many variants of the \cen\ problem are NP-hard
\cite{ref:Ben-MosheAn06,ref:ChandrasekaranPo82,ref:FredericksonFi83,ref:KarivAn79,ref:MegiddoNe83}, some special cases are
solvable in polynomial time. Megiddo and Tamir
\cite{ref:MegiddoNe83} presented an  time
algorithm for the weighted \cen\ problem on a tree of  nodes, and
the running time can be reduced to  by applying Cole's
parametric search \cite{ref:ColeSl87}. Later, Frederickson
\cite{ref:FredericksonPa91} gave a linear time algorithm for the
unweighted \cen\ problem on a tree. Jeger and Kariv
\cite{ref:JegerAl85} gave an  time algorithm for the
weighted \cen\ problem on a tree. For the weighted \cen\ problem on
a real line (i.e., the problem \problem), Bhattacharya and Shi
\cite{ref:BhattacharyaOp07} recently proposed an algorithm with a
time bound linear in  but exponential in .
In addition, the discrete weighted \cen\ problem on a tree is solvable in
 time \cite{ref:MegiddoAn81} and the discrete
unweighted \cen\ problem on a tree is solvable in  time
\cite{ref:FredericksonPa91}.
The discrete weighted \problem\ has been solved in
 time \cite{ref:MegiddoAn81}, without using the parametric search in \cite{ref:ColeSl87}.
Note that our problem \problem\ is the
``non-discrete'' weighted version.


As indicated by Tamir \cite{ref:TamirPe14},
 the problem \problem\ can be solved in  time by combining the techniques given by Megiddo and Tamir \cite{ref:MegiddoNe83} and Cole's parametric search  \cite{ref:ColeSl87}.
Although the approach in \cite{ref:MegiddoNe83} is elegant and simple, Cole's parametric search \cite{ref:ColeSl87} is quite complicated and involves large constants, and thus is mainly of theoretical interest.
In this paper, we present another  time algorithm for \problem, which is much easier and avoids Cole's parametric search \cite{ref:ColeSl87}.
Further, if all points in  are given sorted on  and their weights are
also sorted, our algorithm can solve \problem\ in
 time, which is in favor
of small .
For example, if  for any  (which is true
in many applications), our algorithm runs in  time.
It should be noted that if the points in  are given sorted on , then the unweighted \problem\ is solvable in  time \cite{ref:TamirPe14}.
In addition, our techniques also yield an efficient data structure for
processing queries for finding a lowest point in the common
intersection of a certain subset of half-planes, which we call the
{\em 2-D sublist LP queries}. Since the 2-D sublist LP query is a basic
geometric problem, our data structure may be interesting in its own right.









\subsection{An Overview of Our Approach}

We first model the \problem\ problem as a problem of approximating a set of
weighted points by a step function in the plane \cite{ref:ChenA13,ref:ChenAp13,ref:FournierA13,ref:LiuA10}.
For this points approximation problem, by using Cole's parametric search \cite{ref:ColeSl87}, Fournier and
Vigneron \cite{ref:FournierA13} gave an  time
algorithm. Thus, by combining
our problem modeling and the algorithm in \cite{ref:FournierA13}, the
\problem\ problem can be solved in  time. This approach, again, uses Cole's parametric search \cite{ref:ColeSl87}. Chen and Wang \cite{ref:ChenA13} proposed another  time algorithm without using parametric search, by modifying the slope selection algorithms \cite{ref:BronnimannOp98,ref:KatzOp93}. Although the algorithm in \cite{ref:ChenA13} avoids the parametric search, it is still complicated and not practical because it involves the techniques of either cutting \cite{ref:BronnimannOp98} or expanders \cite{ref:KatzOp93}. In addition, Liu \cite{ref:LiuA10} presented an  time randomized algorithm for this points approximation problem.




In fact, we model \problem\ as a special case of the above points approximation problem such that we are able to develop a simple and deterministic  time algorithm. Further, we can solve the problem in  time in some special situations, as discussed earlier.
Specifically, after the
geometric transformations, a key component to solving the problem is
the following {\em 2-D
sublist LP query} problem: Given a set of  upper half-planes,
, in the plane, for each query 
(), compute a lowest point  in the common
intersection of all half-planes in . A data structure was proposed in \cite{ref:ChenAp091} for this
problem, which can be built in  time and answers each
query in  time.
On the \problem\ problem, we observe that the input half-plane
set  has a special property that the intersections between the
-axis and the bounding lines of the half-planes are
ordered from left to right according to the half-plane indices in . Exploiting
this special property and using the compact
interval trees \cite{ref:GuibasCo91},
we design a new data structure for this special case of the 2-D
sublist LP queries, which can be built in
 time and can answer each query in 
time. This new data structure allows us to solve \problem\ in
 time, and in  time in certain situations.
Further, since the 2-D sublist LP query problem
is a very basic problem, our new data structure may find other applications as
well.





In the following, we present the high-level scheme of our algorithm
in Section \ref{sec:algorithms}. In Section
\ref{sec:chreduction}, we model our problem as the
2-D sublist LP queries and present our data structure.
Section \ref{sec:conclusion} concludes the
paper and discusses the  time lower bound of the problem \problem.


For simplicity of discussion, we make a general position assumption that no two
points in  are at the same position on . We also assume the
weight of each point in  is positive and finite. These
assumptions are only for ease of exposition and our algorithms can
be easily extended to the general case.

\section{The Algorithmic Scheme}
\label{sec:algorithms}

In this section, we discuss the high-level framework
of our algorithm. As pointed out in
\cite{ref:BhattacharyaOp07}, it is possible that there is more than
one optimal solution for the \problem\ problem.
Our algorithm focuses on finding one optimal solution.

\subsection{Preliminaries}

For any two points  and  on  with  (recall
that  is the coordinate of  on L, and similarly for ), denote
by  the (closed) interval of  between  and .

We first sort all points of  from left to right on . Without loss of
generality (WLOG), let  be the sorted order in
increasing coordinates on . For any two points  with , denote by  the interval . Let
 be the value of  for an optimal solution of
\problem. Suppose  is the center set in an optimal solution;
for a demand point 
and a center , if , then we say that
 can be {\em served} by .  It is easy to see that
there is an optimal solution  such that each center of  is in
. Further, as discussed in \cite{ref:BhattacharyaOp07},
there is an optimal solution  such that the
points of  are partitioned into  intervals  by integers , each interval 
contains exactly one center , and for each point , 
holds. In other words, each center of
 serves a subset of consecutive demand points in .


For any two integers  and  with , denote
by  the subset of points of  in the interval , i.e.,
 ( for ).
Consider the following {\em weighted 1-center} problem: Find a
single center (i.e., a point)  in the interval  such that
the value of  is
minimized. Let  denote the minimum value of
 for this weighted 1-center problem.

For solving the \problem\ problem, our strategy is to determine 
integers  such that the value of

is minimized and this minimized value is . Note that
in the above formulation, for each value , exact one center is
determined in the interval . To solve this problem, we reduce
it to a planar weighted point approximation problem
\cite{ref:ChenAp091} in the next subsection.

\subsection{The Reduction to the Planar Weighted Point Approximation Problem}
\label{sec:reduction}

We first review the planar weighted point approximation problem
and then show our problem reduction.

Let  be a point set in the plane
with , and each point  be associated with a
weight . Assume the points in  are ordered
increasingly by their -coordinates. Suppose  is a step
function (i.e., a peicewise constant function, e.g., see Fig.~\ref{fig:sfpf})
which we use to approximate the points of  (in other
words, we fit the step function  to the point set ). The {\em
weighted vertical distance} between any point  and  is
defined as  (see
Fig.~\ref{fig:sfpf}). The approximation error of , denoted by
, is defined as . The {\em
size} of  is the number of its horizontal line segments. Given an
integer , the {\em point approximation problem} seeks a step
function  to approximate the points of  such that the size of
 is at most  and the error  is minimized. In
\cite{ref:ChenAp091}, this problem is referred to as the {\em
weighted step function min- problem}, denoted by \wsf.
Here we also use \wsf\ to denote this problem.

\begin{figure}[t]
\begin{minipage}[t]{\linewidth}
\begin{center}
\includegraphics[totalheight=0.8in]{sfpf.eps}
\caption{\footnotesize Approximating a set of points by a step function
(i.e., the three horizontal line segments).}
\label{fig:sfpf}
\end{center}
\end{minipage}
\vspace*{-0.15in}
\end{figure}


We now show that the \problem\ problem can be reduced to \wsf.
Consequently, \wsf\ algorithms can be used to solve \problem.
Indeed, consider the demand point set  for
\problem\ with the points ordered increasingly
by their coordinates on . For each demand point ,
, we create a point  in a 2-D
Euclidean plane 
(i.e, the -coordinate of  in  is the index  and
its -coordinate  in  is the coordinate of  on
), and let the weight of  be that of  (i.e.,
). Let  be the set of  weighted points thus
created in . The next lemma states the relation between
\problem\ and the reduced instance of \wsf.

\begin{lemma}\label{lem:00}
An optimal solution  for \wsf\ on  in 
corresponds to an optimal solution  for \problem\ on .
Further, once having ,  can be obtained in 
time.
\end{lemma}

\begin{myproof}
For any two integers  and  with , let
 ( for
). Consider the following problem: Find a value  for one
single horizontal line segment with  as its -coordinate such
that the value of  is minimized (where ).
Let  denote the minimized value of .

Let  be the approximation error of an optimal solution
for \wsf\ on . It is easy to see that computing an optimal
solution for \wsf\ on  is equivalent to determining 
integers  such that
the value of  is minimized and this minimized value is
.
According to the way that we create the point set  from the
demand point set , each value  is exactly equal to
the value , which is the minimized value of
 for the weighted 1-center problem on the demand
point subset  by determining the value of .
Further, we have shown that to find an optimal solution for
\problem\ on , it suffices to determine  integers  such that the value of
 is minimized and the minimized value is
.

The above discussion shows that to find an optimal solution for
\problem\ on , it suffices to find an optimal solution for \wsf\
on ; further, . Given an optimal solution
 for \wsf\ on , below we show how to obtain an
optimal solution  for \problem\ on  from  in linear time.

Note that  is a step function with  steps (i.e.,
horizontal line segments).  Let  and . For each , suppose the -th step of  has a
-coordinate  and covers the points of  from
 to , i.e., for each point 
with , the vertical line through 
intersects the -th horizontal segment of .
We obtain  for \problem\ on  as follows. For each , the -th center  is put at the position  on
 (i.e., ), which serves the demand points of  from
 to .

Thus, once  is available,  can be obtained in
 time.
\end{myproof}

Based on Lemma \ref{lem:00}, to compute a set  of  centers for
 to minimize the value , it suffices to solve the
corresponding WSF problem on  and . Specifically, after an
optimal step function  for  is obtained, each horizontal
segment of  defines a center on  whose coordinate is equal to
the -coordinate of that horizontal segment of  in .

To apply the WSF algorithms to the \problem\ problem, we need a data
structure for answering queries  with . Suppose such a data structure can be built in 
time and can answer each query  in  time; then we
say the time bounds of the data structure are . The two
lemmas below follow from the results in \cite{ref:ChenAp091}.




\begin{lemma}\label{lem:10}{\em \cite{ref:ChenAp091}} Suppose
there is a data structure for the queries  with time
bounds ; then the \problem\ problem is solvable
in  time.
\end{lemma}

\begin{lemma}\label{lem:20}{\em \cite{ref:ChenAp091}} Suppose
there is a data structure for the queries  with time
bounds ; then the \problem\ problem is solvable
in  time.
\end{lemma}

Refer to \cite{ref:ChenAp091} for the details of the algorithms in the
above two lemmas.
By the above two lemmas, Lemma \ref{lem:100} follows.

\begin{lemma}\label{lem:100} Suppose
there is a data structure for the queries  with time
bounds ; then the \problem\ problem can be solved
in  time.
\end{lemma}





A data structure based on fractional cascading \cite{ref:ChazelleFr86} was given in
\cite{ref:ChenAp091} for answering the
queries  with time bounds . Consequently, by
Lemma \ref{lem:100}, the \problem\ problem is
solvable in  time. In Section \ref{sec:chreduction}, we develop a data
structure for processing the queries  with time bounds
, which allows us to solve \problem\
in  time.

The reason why we can solve the \problem\ problem faster than simply applying
the \wsf\ algorithms \cite{ref:ChenAp091} is that the
\wsf\ instance constructed above from the problem \problem\ has a special property: The
-coordinates of the points  are increasing.
As shown in Section \ref{sec:chreduction}, this
special property allows us to design a new data structure for the 
queries with time bounds .
Note that this special property does not hold for the general \wsf\
problem studied in \cite{ref:ChenAp091}.








\section{The Data Structure for Computing }
\label{sec:chreduction}


In this section, we present a data structure with time bounds
 for answering the  queries.
In the following, we first model the problem of computing 
as the problem of finding a lowest point in the common
intersection of a set of half-planes (i.e., the 2-D sublist LP query).

\sectionspace
\subsection{The Problem Modeling}

Consider a point subset  with . Recall that
. To compute , we
need to find a point  such that the value  is minimized and
 is the minimized value.
Consider an arbitrary point  on .
Since , each point
 defines two constraints:
 and
.

Consider a 2-D -coordinate system with  as the -axis. For each
point , the inequality  defines
two (upper) half-planes:  and .  Note that the two lines bounding the two half-planes
intersect at the point  on .

Based on the above discussion, if  is a lowest point in
the common intersection of the  (upper) half-planes defined by the
points in , then  and  is the
coordinate of an optimal center  on  for . Figure~\ref{fig:cone}
shows an example in which each ``cone" is the intersection of
the two upper half-planes defined by a point in .
Clearly, this is an
instance of the 2-D linear programming (LP) problem, which is solvable
in  time \cite{ref:DyerLi84,ref:MegiddoLi84}. However, we
can make the computation faster by preprocessing. Let
 be the set of  (upper) half-planes defined by
the  points in , such that for each , the demand point
 defines  and . Then to compute
, it suffices to find the lowest point  in the
common intersection of the half-planes defined by the points in
, i.e., the half-planes in
.

\begin{figure}[t]
\begin{minipage}[t]{\linewidth}
\begin{center}
\includegraphics[totalheight=1.1in]{cone.eps}
\caption{\footnotesize Illustrating the common intersection of the
half-planes defined by three points , , and . The
point  is the lowest point in the common
intersection.}\label{fig:cone}
\end{center}
\end{minipage}
\vspace*{-0.15in}
\end{figure}


We actually consider a more general problem: Given in the plane
a set of  upper half-planes , each
query  with  asks for a lowest point
 in the common intersection of all half-planes in
. We call this problem the {\em
2-D sublist LP query}. Based on our discussion above,
if we solve the 2-D sublist LP query problem, then the
 queries for the \problem\ problem can be processed as well in the
same time bound.
A data structure for the 2-D sublist LP query problem with time bounds  was given in \cite{ref:ChenAp091}.

Yet, the 2-D sublist LP query problem for
\problem\ is special in the
following sense. For each half-plane  for \problem, we call the
-coordinate of the intersection point between  (i.e., the -axis)
and the line bounding  the {\em -intercept} of 
(or its bounding line). As discussed above, for each
point , the -intercepts of both the half-planes 
and  defined by  are exactly the point . Since all
points of  are ordered along  from left to right by their
indices, a special property of  is that the -intercepts of
all half-planes in  are ordered from left to right on  by
the indices of the half-planes. For a set  of half-planes for a
2-D sublist LP query problem instance, if  has the above special property,
then we say that  is {\em -intercept ordered}.


Below, we show that if  is -intercept ordered, then there is a
data structure for the specific 2-D sublist LP query problem with time
bounds .
Henceforth, we assume that  is an -intercept ordered half-plane
set. In the \problem\ problem, since all the point weights for 
are positive finite values, the bounding line of each half-plane in
 is neither horizontal nor vertical. Thus, we also assume that
no bounding line of any half-plane in  is horizontal
or vertical. Again, this assumption is only for simplicity of discussion.


In the next section, we solve the 2-D sublist LP queries by reducing
it to computing the convex hull of a query sub-path of a given simple
path \cite{ref:GuibasCo91}.
Given a simple path in the plane, based on
compact interval trees, data structures are proposed in
\cite{ref:GuibasCo91} to compute (in logarithmic time)
the convex hull of a query subpath
that is specified by the indices of the beginning vertex and the end
vertex of the subpath, and the convex hull is represented
(by a compact interval tree) such that standard convex hull
queries on it can be done in  time.

\subsection{Answering 2-D Sublist LP Queries}


For each half-plane , we denote by  the
bounding line of ; let  be the set of the bounding lines of
the half-planes in any subset .


Our problem reduction utilizes a duality transformation
\cite{ref:deBergCo08}, which is a technique commonly used in
computational geometry, as follows. Suppose we have a
{\em primary} plane . For each point , it
corresponds to a line  in the {\em dual} plane ; the
line is also called the {\em dual} of the point and vice versa.
Similarly, each line  in  corresponds to a point
 in .


Suppose all half-planes in  are in the primary plane .
By duality, we can obtain a
set  of points in the dual plane  corresponding to the
lines in . For each query  on , our goal is to locate
the lowest point  in the common intersection of all half-planes
in  (note that due to our assumption that no line in  is
horizontal, there is only one lowest point in the common intersection).
Since all half-planes in  are upper half-planes,
an observation is that  is also the lowest point of
the upper envelope of the arrangement of the lines in .
Denote by  the above upper envelope for .
Denote by  the set of points (in the dual plane ) dual to the
lines  in . Let  denote
the lower hull of the convex hull of . It is commonly known
\cite{ref:deBergCo08} that the dual of  is exactly 
(in the dual plane ).
Therefore, if we have a representation of 
that can support standard binary-search-based queries, then we can compute
the lowest point  in logarithmic time accordingly.

One may attempt to design a data structure for querying
the lower hull on any subset  of . However,
there are difficulties when doing so ``directly", which will be explained later.
Instead, we use an ``indirect" approach, as follows.
Recall that we have assumed the bounding line of any half-plane in
 is not vertical or horizontal.  We partition the half-plane set  into
two subsets  and  such that a half-plane  of  is in  (resp.,
) if and only if the slope of 
is negative (resp., positive). Accordingly, for each
subset , we also have  and ,
and we define the envelopes  and  accordingly. Since the
bounding lines of all half-planes in  have negative slopes,
the upper envelope  is monotone decreasing from left to
right. Similarly,  the upper envelope  is monotone
increasing from left to right. Hence, it is easy to see that the
lowest point  is the {\em single} intersection of  and .
Let  and  be the sets of points in the dual plane
corresponding to the lines in  and , respectively.
Denote by  and  the lower hulls of
 and , respectively. By duality, the
intersection of  and  corresponds exactly to the
common tangent line of the two lower hulls  and
 such that both hulls are above the tangent line. Note
that since all lines in  have negative slopes, by
duality, all points in  are to the left of the -axis
in the dual plane, and thus the lower hull  is to the
left of the -axis. Similarly, the lower hull  is to
the right of the -axis. Namely, the two lower hulls 
and  are on different sides of the -axis. This
property can make our computation of their tangent line easier.

In summary,
if we can represent both  and  in such a way that
the common tangent line can be found efficiently, then 
can be obtained immediately. Our remaining task is to derive a way to
support convex hull (or lower hull) queries on any subset of consecutive points in
 (and similarly
on ). Our result is that a data structure can be built in
 time such that given any , the lower hull
 can be obtained (implicitly) in  time and is represented
in a way that supports binary-search-based queries (e.g., compute the
common tangent of it and another lower hull, say ). The
details are given below.

Without loss of generality, we assume the
bounding lines of the half-planes in  all have negative slopes
(i.e., ) and the other case can be handled analogously. Suppose
the bounding line of each  corresponds to the point 
in the dual plane . Let  be the path by connecting all
pairs of two consecutive points in  by line segments, i.e.,
connecting  to 
for . Consider the line segment connecting  and
 and the line segment connecting  and ; then
the two segments are {\em adjacent} to each other if  or
. The following Lemma \ref{lem:simple} shows that the path
 is a simple path, that is, any two line segments of 
that are not adjacent do not intersect.
As can be seen from the proof of Lemma \ref{lem:simple}, we note that
the correctness of Lemma \ref{lem:simple} heavily relies on two properties of :
(1)  is -intercept ordered; (2) the slopes of the bounding lines
of the half-planes in  are all negative (or positive). Without
either property above, the lemma would not hold, and the second
property also
explains why we need to partition the original set  into  and
.


\begin{lemma}\label{lem:simple}
The path  is a simple path.
\end{lemma}
\begin{myproof}
Consider two segments  and  where  connects 
and  and  connects  and . Suppose
 and  are not adjacent. To prove the lemma, it is sufficient
to show  and  does not intersect.
Since  and  are not adjacent, either  or .
Without loss of generality, assume .


Note that  and  are in the dual plane .
It is commonly known \cite{ref:deBergCo08} that
the dual of  in the primary plane  is the {\em double
wedge} bounded by the lines  and  such that
the double wedge does not contain a vertical line
(e.g., see Fig.~\ref{fig:doublewedge}); we denote the double wedge by .
Similarly, the dual of  is the double wedge  bounded by
 and .

\begin{figure}[t]
\begin{minipage}[t]{\linewidth}
\begin{center}
\includegraphics[totalheight=1.3in]{doublewedge.eps}
\caption{\footnotesize Illustrating the two double edges  and
 (the shaded
regions) in the primary plane  corresponding to the two segments
 and  in the dual plane . The two segments  and
 are their intersections with the -axis.}\label{fig:doublewedge}
\end{center}
\end{minipage}
\vspace*{-0.15in}
\end{figure}


Assume to the contrary the two segments  and  intersect each
other, say, at a point .
Then,  corresponds to a line in the primary
plane , which
is in the common intersection of the two double wedges 
and . However, we claim that the
common intersection of  and  does not contain any
line, which incurs contradiction. Hence,  cannot intersect 
and the lemma follows. Below, we prove the above claim.

Suppose to the contrary there is a line  contained in
. Denote by  (resp., ) the
intersection of the -axis and  (resp., ), e.g.,
see Fig.~\ref{fig:doublewedge}. Hence, both  and  are line
segments on the -axis. Since the intersection of
 and the -axis is strictly to the right of the intersection of
 and the -axis (since  is -intercept
ordered),  does not intersect . Since the slopes of both
 and  are negative, a line contained in
 must intersect , and thus the line  intersects 
(due to ).
Similarly,  also intersects . Hence, we obtain that 
intersects both  and . Since both  and  lie in
-axis and  does not intersect ,
the line  has to be the -axis. However, since the slopes of both
 and  are negative, the
double wedge  cannot contain the -axis and thus cannot
contain . Therefore, we obtain contradiction and the claim follows.
\end{myproof}

In light of Lemma \ref{lem:simple}, we can utilize the results in
\cite{ref:GuibasCo91}. Given a simple path in the plane,
{\em compact interval tree} data structures are proposed in
\cite{ref:GuibasCo91} to compute the convex hull of a query subpath
that is specified by the indices of the beginning vertex and the end
vertex of the subpath.
If applied to  in our problem, then after spending  time sorting the points in  by their -coordinates,
we have the following results: A data structure can be constructed in
 time that can compute the lower hull  for
any query  in  time and  is represented
(by a compact interval tree) such that any standard convex hull
queries on  can be done in  time, where the
{\em standard convex hull queries} includes point-in-polygon tests,
finding intersections with lines, finding tangents through query
points, finding extreme vertices in a query direction, detecting
intersections of two polygons, and finding common tangents of
two convex hulls. Further, another data structure of construction time
 and query time  is also given in
\cite{ref:GuibasCo91};  in
addition, there is also a data structure of construction time
 and query time  by making trade-off
between the construction and query \cite{ref:GuibasCo91}.
Both data structures are applicable to our problem.

By duality, the -coordinate of each point 
corresponds to the slope of the line . Thus, a sorted
order of the points in  by -coordinate corresponds to a
sorted order of the bounding lines of the half-planes in  by
slope. The following lemma summarizes our discussions above.

\begin{lemma}\label{lem:summary}
In  time, we can build a data structure that can answer
each 2-D sublist LP query in  time. Further, if the
bounding lines of the half-planes in  are sorted by their slopes,
then there exist three data structures for the 2-D sublist LP
queries, whose construction time complexities are ,
, and , respectively, and query time
complexities are , , and
, respectively.
\end{lemma}

According to the reduction procedure from the \problem\ problem to the
planar points
approximation problem \cite{ref:ChenEfkCenter11}, the slopes of the
bounding lines of the half-planes in  correspond to the weights
of the points in the input point set . Therefore, we have the following
corollary.

\begin{corollary}
There exists a data structure of time complexity  for the  queries. Further, if the points of 
are sorted on the line  and the weights of the points in 
are also sorted, then we have three data structures for the
 queries of time complexities ,
, and ,
respectively.
\end{corollary}

By Lemma \ref{lem:100}, we have the following result for the \problem\
problem.

\begin{theorem}\label{theo:continuous}
The \problem\ problem is solvable in  time. Further, if
the points of  are sorted on  and the weights of the
points in  are also sorted, then the \problem\ is solvable in
 time.
\end{theorem}

Therefore, if the points of  are sorted on the line  and
the weights of the points in  are also sorted, for small 
(e.g., , which is true in
many applications), the \problem\
problem is solvable in  time.




\section{Conclusions}
\label{sec:conclusion}

In this paper, we give an  time algorithm for the k-center
problem on a real line. In certain special cases, we can solve the
problem in linear time.
We also propose an efficient data structure to answer the 2-D sublist LP queries, which may find other applications.

As suggested by Tamir,
when , the discrete unweighted \problem\ is equivalent to the Min
Gap problem, i.e., finding the closest pair of neighbors in .
Hence, there is an  time lower bound on the discrete
version. In fact, by the reduction from the Min Gap problem, we can
also show that the non-discrete unweighted \problem\ also has an
 lower bound on the running time. Indeed, in any optimal
solution  for , there must be a
center at the middle position of the closest pair of neighbors in ,
and that center serves both neighbors; further, any
other center in  serves one and only one demand point in .
Therefore, given an optimal solution , since the demand points
served by each center are known, the two demand points served by the
same center are the closest neighbors in . We thus obtain the
 time lower bound on the non-discrete unweighted \problem.


Note that the linear time algorithms for the unweighted
continuous/discrete k-center
problem on trees \cite{ref:FredericksonPa91} do not violate the
 time lower
bound discussed above because the tree
structure already gives a partial order of the nodes in the tree.
An open problem is whether the techniques given in this paper can be
extended to the tree structure.


\section*{Acknowledgments}

We wish to thank Arie Tamir for his many helpful comments and suggestions.





\footnotesize \baselineskip=11.0pt
\bibliographystyle{plain}


\begin{thebibliography}{10}

\bibitem{ref:Ben-MosheAn06}
B.~Ben-Moshe, B.~Bhattacharya, and Q.~Shi.
\newblock An optimal algorithm for the continuous/discrete weighted 2-center
  problem in trees.
\newblock In {\em Proc. of the 7th Latin American Conference on Theoretical
  Informatics}, pages 166--177, 2006.

\bibitem{ref:BhattacharyaOp07}
B.~Bhattacharya and Q.~Shi.
\newblock Optimal algorithms for the weighted -center problems on the real
  line for small .
\newblock In {\em Proc. of the 10th International Workshop on Algorithms and
  Data Structures}, pages 529--540, 2007.

\bibitem{ref:BronnimannOp98}
H~{Br\"onnimann} and B.~Chazelle.
\newblock Optimal slope selection via cuttings.
\newblock {\em Computational Geometry: Theory and Applications}, 10(1):23--29,
  1998.

\bibitem{ref:ChandrasekaranPo82}
R.~Chandrasekaran and A.~Tamir.
\newblock Polynomially bounded algorithms for locating {-centers} on a tree.
\newblock {\em Mathematical Programming}, 22(1):304--315, 1982.

\bibitem{ref:ChazelleFr86}
B.~Chazelle and L.~Guibas.
\newblock Fractional cascading: {I. A} data structuring technique.
\newblock {\em Algorithmica}, 1(1):133--162, 1986.

\bibitem{ref:ChenA13}
D.Z. Chen and H.Wang.
\newblock A note on searching line arrangements and applications.
\newblock {\em Information Processing Letters}, 113:518--521, 2013.

\bibitem{ref:ChenAp091}
D.Z. Chen and H.~Wang.
\newblock Approximating points by a piecewise linear function: {I}.
\newblock In {\em Proc. of the 20th International Symposium on Algorithms and
  Computation (ISAAC)}, volume 5878 of {\em Lecture Notes in Computer Science},
  pages 224--233. Springer, 2009.

\bibitem{ref:ChenEfkCenter11}
D.Z. Chen and H.~Wang.
\newblock Efficient algorithms for the weighted {}-center problem on a real
  line.
\newblock In {\em Proc. of the 22nd International Symposium on Algorithms and
  Computation (ISAAC)}, pages 584--593, 2011.

\bibitem{ref:ChenAp13}
D.Z. Chen and H.~Wang.
\newblock Approximating points by a piecewise linear function.
\newblock {\em Algorithmica}, 88:682--713, 2013.

\bibitem{ref:ColeSl87}
R.~Cole.
\newblock Slowing down sorting networks to obtain faster sorting algorithms.
\newblock {\em Journal of the ACM}, 34(1):200--208, 1987.

\bibitem{ref:deBergCo08}
M.~de~Berg, O.~Cheong, M.~van Kreveld, and M.~Overmars.
\newblock {\em Computational Geometry --- Algorithms and Applications}.
\newblock Springer-Verlag, Berlin, 3rd edition, 2008.

\bibitem{ref:DyerLi84}
M.~Dyer.
\newblock Linear time algorithms for two- and three-variable linear programs.
\newblock {\em SIAM J. Comp.}, 13(1):31--45, 1984.

\bibitem{ref:FournierA13}
H.~Fournier and A.~Vigneron.
\newblock A deterministic algorithm for fitting a step function to a weighted
  point-set.
\newblock {\em Information Processing Letters}, 113:51--54, 2013.

\bibitem{ref:FredericksonPa91}
G.N. Frederickson.
\newblock Parametric search and locating supply centers in trees.
\newblock In {\em Proc. of the 2nd International Workshop on Algorithms and
  Data Structures (WADS)}, pages 299--319, 1991.

\bibitem{ref:FredericksonFi83}
G.N. Frederickson and D.B. Johnson.
\newblock Finding {th} paths and {-centers} by generating and searching
  good data structures.
\newblock {\em Journal of Algorithms}, 4(1):61--80, 1983.

\bibitem{ref:GuibasCo91}
L.~Guibas, J.~Hershberger, and J.~Snoeyink.
\newblock Compact interval trees: A data structure for convex hulls.
\newblock {\em International Journal of Computational Geometry and
  Applications}, 1(1):1--22, 1991.

\bibitem{ref:JegerAl85}
M.~Jeger and O.~Kariv.
\newblock Algorithms for finding {-centers} on a weighted tree (for
  relatively small {}).
\newblock {\em Networks}, 15(3):381--389, 1985.

\bibitem{ref:KarivAn79}
O.~Kariv and S.L. Hakimi.
\newblock An algorithmic approach to network location problems. {I: The}
  -centers.
\newblock {\em SIAM J. on Applied Mathematics}, 37(3):513--538, 1979.

\bibitem{ref:KatzOp93}
M.~Katz and M.~Sharir.
\newblock Optimal slope selection via expanders.
\newblock {\em Information Processing Letters}, 47(3):115--122, 1993.

\bibitem{ref:LiuA10}
J.-Y. Liu.
\newblock A randomized algorithm for weighted approximation of points by a step
  function.
\newblock In {\em Proc. of the 4th International Conference on Combinatorial
  Optimization and Applications}, pages 300--308, 2010.

\bibitem{ref:MegiddoLi84}
N.~Megiddo.
\newblock Linear programming in linear time when the dimension is fixed.
\newblock {\em Journal of the ACM}, 31(1):114--127, 1984.

\bibitem{ref:MegiddoNe83}
N.~Megiddo and A.~Tamir.
\newblock New results on the complexity of -centre problems.
\newblock {\em SIAM J. on Computing}, 12(4):751--758, 1983.

\bibitem{ref:MegiddoAn81}
N.~Megiddo, A.~Tamir, E.~Zemel, and R.~Chandrasekaran.
\newblock An {} algorithm for the -th longest path in a tree
  with applications to location problems.
\newblock {\em SIAM J. on Computing}, 10:328--337, 1981.

\bibitem{ref:TamirPe14}
A.~Tamir.
\newblock Personal communication, 2014.

\end{thebibliography}







\end{document}
