








\documentclass[10pt, a4paper, onecolumn, conference, compsocconf]{IEEEtran}























\ifCLASSINFOpdf
\else
\fi




























































\usepackage{times}                               \usepackage{graphicx}
\usepackage[cmex10]{amsmath}
\usepackage{amsthm,amssymb}

\newcommand{\procbegin}{\vspace*{3mm}\hrule\vspace{2mm}\noindent}
\newcommand{\procend}{\vspace*{2mm}\hrule\vspace{3mm}}
\newcommand{\hst}{\\\hspace*{2mm}}
\newcommand{\hstt}{\\\hspace*{4mm}}
\newcommand{\hsttt}{\\\hspace*{6mm}}
\newcommand{\hstttt}{\\\hspace*{8mm}}
\newcommand{\hsttttt}{\\\hspace*{10mm}}
\newcommand{\hstttttt}{\\\hspace*{12mm}}
\newcommand{\hsttttttt}{\\\hspace*{14mm}}
\newcommand{\hstttttttt}{\\\hspace*{16mm}}

\newcommand{\set}[1]{\mbox{\textit{#1}}}

\newenvironment{list1}{\begin{list}{}
{\topsep 0 pt \parsep 0 pt \partopsep 0 pt \itemsep 0
pt}}{\end{list}}
\newenvironment{list2}{\begin{list}{}
{\topsep 0 pt \parsep 0 pt \partopsep 0 pt \itemsep 0
pt}}{\end{list}}
\newenvironment{list3}{\begin{list}{}
{\topsep 0 pt \parsep 0 pt \partopsep 0 pt \itemsep 0
pt}}{\end{list}}
\newenvironment{list4}{\begin{list}{}
{\topsep 0 pt \parsep 0 pt \partopsep 0 pt \itemsep 0
pt}}{\end{list}}

\newcommand{\pf}{\noindent\mbox{\bf Proof : }}
\newcommand{\mcla}{\mathcal{A}}
\newcommand{\emvadd}{\mbox{\em vertex\_add}}
\newcommand{\emaadd}{\mbox{\em arc\_add}}
\newcommand{\emcadd}{\mbox{\em clock\_add}}
\newcommand{\emsadd}{\mbox{\em sync\_add}}
\newcommand{\emvaradd}{\mbox{\em var\_add}}
\newcommand{\emjadd}{\mbox{\em jump\_add}}
\newcommand{\emjedt}{\mbox{\em jump\_edit}}
\newcommand{\emgrop}{\mbox{\em graph\_edit}}

\newtheorem{defi}{Definition}
\newtheorem{theo}{Theorem}
\newtheorem{prop}{Proposition}
\newtheorem{lemma}{Lemma}
\newtheorem{obser}{Observation}

\begin{document}
\title{Modeling and Verification for Timing Satisfaction of Fault-Tolerant Systems with Finiteness}




\author{
\IEEEauthorblockN{Chih-Hong Cheng\authorrefmark{1},
                    Christian Buckl\authorrefmark{3},
                    Javier Esparza\authorrefmark{2}
                    Alois Knoll\authorrefmark{1}}
\IEEEauthorblockA{\authorrefmark{1}Unit 6: Robotics and Embedded
Systems, Department of Informatics, TU Munich, Germany}
\IEEEauthorblockA{\authorrefmark{1}Unit 11: Theoretical Computer Science, Department of Informatics, TU Munich, Germany}
\IEEEauthorblockA{\authorrefmark{2}Fortiss GmbH, Germany
\\Email:\{chengch,buckl,esparza,knoll\}@in.tum.de }}











\maketitle


\begin{abstract}
The increasing use of model-based tools enables further use of formal verification techniques in the context of distributed real-time systems. To avoid state explosion, it is necessary to construct verification models that focus on the aspects under consideration.

In this paper, we discuss how we construct a verification model for timing analysis in distributed real-time systems.
We (1) give observations concerning restrictions of timed automata to model these systems,
(2) formulate mathematical representations on how to perform model-to-model transformation to derive verification models from system models, and (3) propose some theoretical criteria how to reduce the model size. The latter is in particular important, as for the verification of complex systems, an efficient model reflecting the properties of the system under consideration is equally important to the verification algorithm itself.
Finally, we present an extension of the model-based development tool FTOS, designed to develop fault-tolerant systems, to demonstrate our approach.
\end{abstract}






\IEEEpeerreviewmaketitle
\section{Introduction}

The complexity of distributed real-time systems is growing rapidly; model-based development tools are used to accelerate the development process and increase the quality of the produced code. In addition, it is possible to integrate formal verification as analysis technique into these tools.



Currently, the standard verification process is achieved by first translating system models into verification models, followed by verifying relevant properties by verification engines using special algorithms. In the verification community, researchers focus on tighter theoretical complexity bounds or computationally faster algorithms to reduce the required time for verification. Nevertheless, if it comes to verification of complex systems, an efficient model reflecting the properties of the system under consideration becomes essential. By \emph{efficient model}, we refer to a model containing "just-enough" information of the system behavior regarding these properties. In fact, an inefficient modeling with irrelevant details can simply render the verification intractable.

Within this paper, we introduce an approach for the construction of such an efficient model for the verification of timing assumptions and constraints. The approach is presented in, but not restricted to, the context of FTOS~\cite{buckl:2008}, a model-based development tool for the design of fault-tolerant systems.

In our presentation, we first introduce FTOS, mention insights regarding differences in comparison to other development tools, and propose our two-phase verification methodology (sec.~\ref{sec.Motivating.Examples}).
Then based on FTOS and timed automata~\cite{alur:1994:tta}, we describe the model construction process, focusing on the aspects concerning expressiveness, modification, and efficiency.
\begin{itemize}
\item \textbf{(Expressiveness)} We give observations regarding restrictions of timed automata to construct models of real-time systems (sec.~\ref{sec.Network.Finite.Capacities},~\ref{sec.Task.Element.Finite.Precision},~\ref{sec.Dispatcher}); these observations are valid not only in the context of FTOS, but apply also for other systems.
\item \textbf{(Modification)} We formulate mathematical representations how to perform model modification to derive verification models from system models (sec.~\ref{sec.Job.Processing.Element}).
\item \textbf{(Efficiency)} With the understanding of (1) complexities of verification and (2) our problem structure, we propose some theoretical criteria regarding how to construct an efficient model, such that it is possible for existing model checkers to generate results within reasonable time (sec.~\ref{Sec.Invocation.Faults.Events}).
\end{itemize}

At last, we report our preliminary implementation (sec.~\ref{sec.Implementation}), mention related work (sec.~\ref{sec.Related.Work}), and conclude this paper (sec.~\ref{sec.Conclusion}).

\section{FTOS and Motivating Examples\label{sec.Motivating.Examples}}

\subsection{Introduction to FTOS}
FTOS is a model-based development tool for the development of fault-tolerant real-time systems, that alleviates designers' burden by offering code generation for non-functional aspects with high extensibility.

The conceptual modeling in FTOS uses multi-aspect techniques comprising four different perspectives:

\begin{list1}
    \item \textbf{Hardware Model}: The hardware model specifies the hardware used, including specifications of \emph{electronic control units} (ECUs) and the interconnecting \emph{network}.
    \item \textbf{Software Model}: The underlying model of computation in FTOS shares large similarities with that of Giotto \cite{Henzinger01giotto:a}, which is based on the concept of Logical Execution Times. A designer should specify \emph{tasks}, \emph{ports}, \emph{inputs}, \emph{outputs}, and \emph{jobs}.
    \item \textbf{Fault Model}: The fault model specifies the \emph{fault hypothesis} of the system, which includes the set of \emph{fault containment units} (FCUs) (possible faults concerning locations, types, durations), and the set of \emph{fault configurations}
                                (possible simultaneously activating FCUs). Examples for the fault hypothesis are:
                                \begin{enumerate}
\item A network link can have message lost (fault type: \verb"MsgLoss") with minimum interval between consecutive occurrences equal to  milliseconds\footnote{This minimum interval is called \emph{least time between faults} (LTBF) in FTOS and is derived from the required probability of the system to withstand the fault.}.
\item A software task can produce errors (fault type: \verb"WrongResult") due to a fault within an associated sensor; once happened, it will not be corrected unless explicitly done by the user or the fault-tolerant mechanism. The minimum interval for the correct operation between two consecutive faults of the sensor is expected to be  milliseconds\footnote{In (1) the message loss is transient, and in (2) computation errors caused by hardware faults are permanent.}.
\end{enumerate}
    \item \textbf{Fault-tolerance Model}: The fault-tolerance model specifies methods to detect errors and to repair and restore the system.
\end{list1}

During code generation, FTOS selects, adapts and combines pre-implemented code templates based on model features. A detailed description of FTOS can be found in \cite{buckl:2008}.

\begin{figure}
 \centering
 \includegraphics[width=0.45\columnwidth]{fig/Mapping}
 \caption{Behaviorial models and architectures.}
 \label{fig:Mapping}
\end{figure}

\subsection{General Settings and Examples}
The concepts presented in this paper do not only apply for FTOS, but also a range of other related projects, such as Giotto \cite{Henzinger01giotto:a} or event-driven tasks with fixed deadlines. Figure \ref{fig:Mapping} shows the different models of execution. An aperiodic or sporadic function is event driven; when such an event happens, a deadline is assigned to the task handling the event. Giotto functions are functions that interact synchronously at macro step level (logical level), while at micro step level the execution is asynchronous. For detailed description of Giotto and the concept of logical execution time, see \cite{Henzinger01giotto:a}. FTOS functions are extensions of Giotto functions. Intuitively they are equipped with fault-tolerance abilities such that the system can resist faults defined by the fault model. In fig.~\ref{fig:Mapping}, three redundant copies (, , ) are deployed on the three machines (, , ).

The figure also shows the necessity of a mapping the behavioral model (in FTOS: software model) to the architecture model (in FTOS: hardware model). Note that in general a design space exploration is needed for finding such a mapping. For details, we refer readers to articles regarding platform-based design \cite{sangiovannivincentelli:2001:pbd}. Since this mapping is specified in FTOS by the developer, our analysis can start from a given selection of hardware and software settings.

\subsection{Verification Goals\label{subsec.Verification.Goals}}
The main property of fault-tolerant systems that needs to be verified is the ability to withstand the assumed faults. The fault assumptions are summarized in the fault hypothesis (in FTOS: fault model) that defines faults regarding its location, effect, and frequency.

The verification of such systems is hindered by two aspects: deadline violations and non-determinism due to e.g. imperfect synchronization of redundant units.

\begin{enumerate}
\item In ordinary systems, correctness relies on the assumption that a scheduling never leads to deadline violations (without loss of generality, we assume that deadlines specified in our model are hard). Nevertheless, in fault-tolerant systems, the constraint can be loosened. Due to replication, a deadline violation of one unit might be tolerated. In fact, the violation of the deadline can be categorized as an occurrence of a fault defined in the fault model. This brings dramatic differences between fault-tolerant systems and ordinary systems, i.e., deadline violation is feasible or acceptable provided that there exists a fault-tolerance mechanism such that the effect of fault can be eliminated.
\item On the other hand, replication also introduces further difficulties. In ordinary Giotto systems, internal determinism is guaranteed, meaning that two deployments having the same relative ordering in the
micro step level will have the same behavior, irrelevent of the absolute timing. Unfortunately, internal determinism will not be maintained if
no constraints are added additionally on FTOS functions. Consider fig.~\ref{fig:Nondeterminism}, where ,  and  are three deployments.
The send action will broadcast messages to other machines regarding its liveness. Ideally, when no error happens, then each machine should conceive a consistent view of the system. However, when the scheduling of  changes to that of , with zero time transmission, the result will be an inconsistent view at  and . This brings semantic incompatibility between
different deployments.
\end{enumerate}

To solve these problems, we thus propose the concept called \emph{deterministic assumption}~\cite{Cheng:2009:FTOSVerify}. Intuitively, the goal is to assume that the implementation of fault tolerance mechanisms will always provide a consistent view for all correct machines regardless of deadline violation  and scheduling issues. In practice, this will place constraints regarding the earliest and latest arrival time between messages sent, which need to be verified.

\begin{figure}
 \centering
 \includegraphics[width=0.45\columnwidth]{fig/Nondeterminism}
 \caption{Internal nondeterminism due to scheduling differences.}
 \label{fig:Nondeterminism}
\end{figure}

For above purpose, we adapt a two-phase verification process in our tool FTOS-Verify:
\begin{list1}
\item \textbf{(Phase 1: Verification on the platform independent layer)} We first assume that the deterministic assumption holds in all deployments. Based on this assumption, we construct a verification model. The model is an abstract machine (closed model) where injection of faults is regulated based on the fault model. The model offers precision by revealing detailed mechanisms of fault-tolerance. Our theoretical
      foundation enables us to construct a concise model with huge benefits\footnote{Our theorem states that we can construct a synchronous verification model (exponentially smaller reachable state space) provided that (1) the deterministic assumption holds and (2) the properties are local (in-machine) LTL properties without
      using temporal operator \textbf{X}. This makes formal verification of large systems practicable.}. For this phase, the mathematical formulation and the proof of theorems are stated in \cite{Cheng:2009:FTOSVerify}; it will not be the focus of this paper.

\item \textbf{(Phase 2: Validity checking of the behavior-architectural mappings)} In this phase, we have to focus on two aspects. First, we have to check whether the deterministic assumption holds in the platform. Second, we have to check if there exists possibilities where deadlines are violated, and the violation exceeds the constraint specified and regulated in the fault model. Note that since the correctness of the data and mechanisms are checked in the first phase, in the latter phase only protocol checking (timing) is needed. This will be the focus and the main contribution of the paper. For the analysis of the temporal behavior, we transform the models in FTOS to communicating timed automata (CTA). In the following sections, we will describe our observations, relevant parts of the construction process, and theoretical criteria for model efficiency. By using a generalized view, the results are applicable not only in the context of FTOS, but can be used for verifying temporal behavior for generic distributed real-time systems.
\end{list1}

\section{System Modeling and Observations\label{sec.System.Modeling.Observations}}
We use an extended format of communicating timed automata (CTA)~\cite{bdl:2004:uppaal} using variables of finite domain to express the features of the behavioral model. It is important to mention that this extended format does not change the expressiveness of CTA.

\begin{defi} A system of communicating timed automata is a tuple
, where

  is
an automaton with the following constraints.
\begin{list1}
\item  is a finite set of \emph{modes} (\emph{locations}).

\item  is the set of finite-domain integer variables.

\item  is the set of
\emph{clock variables}.

\item  is the set of
\emph{synchronizers}; each synchronizer  is of the format  where elements in  represent
synchronizer symbols. Conceptually,  represents receiving,
and  represents sending.

\item  is the \emph{initial location} of the
automaton.

\item 
is the jump from mode to mode.
\begin{enumerate}
\item  is the conjunction of inequalities
    of the form  or , where , , , and .
\item  is the set of assignments of the form  or , where , , and .
\end{enumerate}

\item  is the set of mode invariants mapping a mode to a
subspace of  indicating the possible clock
values to maintain in the mode.
\end{list1}
\end{defi}

In the following, we summarize required components of the verification model and outline our observations.
\begin{figure}
 \centering
 \includegraphics[width=0.4\columnwidth]{fig/NetworkWithOverflow.PNG}
 \caption{Timed automaton representing point-to-point transmission with capacity 1.}
 \label{fig:TA.p2p}
\end{figure}
\subsection{Network Element with Finite Capacity\label{sec.Network.Finite.Capacities}}
To model the network of the distributed system, an appropriate level of detail must be selected. In general, for a network with message delay and  junction points, we have to model such a network with  automata to handle point-to-point communication. Fig.~\ref{fig:TA.p2p} is the template (defined in UPPAAL \cite{bdl:2004:uppaal}) of a timed automaton  which models the point-to-point transmission with storage capacity equal to , and one overflow location. The function  is used to return the index of the channel.

\begin{obser}
For modeling of network components, only finite capacity can be reached.
Furthermore, the number of controlled locations grows exponentially as the number of allowed storage increases, because
the variable delay (due to the fault model) or the routing scheme may lead to an arbitrary ordering of arrived messages\footnote{As the
synchronizer in CTA takes no time, the timing and the ordering of messages should be modeled in the network automaton.}.
\end{obser}


\subsection{Task Element with Finite Precision\label{sec.Task.Element.Finite.Precision}}
For Giotto-like MoCs, tasks are units which perform dedicated computations. Modeling the task execution can vary based depending on whether the applied scheduling is preemptive.
Fig.~\ref{fig:TA.task} shows a timed automaton representing the task execution with potential context switches. Since context switch and preemption can occur, the
task should keep the record for the remaining time (portion) to finish the task. The variable \verb"percentage" represents the progress of execution and \verb"increment" reflects the minimal advance related to the time accuracy used during verification. The constraints regarding time accuracy imply finite precision in the model.

\begin{obser}
Modeling of tasks can only be achieved with finite precision, since with context switch, we need to record the portion
of executed tasks. This also brings issues between expressiveness and complexity;
a better accuracy regarding the timing behavior of the context switch (with finer time unit) leads to increasing complexity of the resulting model since it depends on the biggest integer used
in the system.
\end{obser}

\begin{figure}
 \centering
 \includegraphics[width=0.5\columnwidth]{fig/TaskWithFinitePrecision.PNG}
 \caption{A timed automaton to represent task execution with context switch.}
 \label{fig:TA.task}
\end{figure}

\subsection{Job Processing Element\label{sec.Job.Processing.Element}}
The task of the job processing element is to manage the execution of tasks and to implement the inter-task communication. The construction in timed automata may vary due to the concrete application. However, for FTOS, a fixed sequence of atomic actions is defined in the software model. Each atomic action can be represented by a similar model as used for the task model described previously. The main difference is that the models of the atomic actions are linked together instead of having a closed loop in the automaton representing the job processing element. Here we omit the detailed construction process for the original model, but focus on the transformation into the according verification model. We give two motivating examples.

\begin{itemize}
    \item In order to model the effect of faults, we need to add additional edges on the original model to represent the occurrence of faults.
    \item To observe deadline violation, additional clocks that reflect the time progress since event occurrence, locations that represent the deadlines, and jumps are required to annotate the original model.
\end{itemize}

For these purposes, we define this annotation as a sequence of edit-operations over a labeled graph \cite{wang2008prs}; this facilitates the mathematical formulation how we transform between models.

\begin{defi} Define five atomic edit actions as follows\footnote{Here we merely define edit actions necessary for our propositions and algorithms; more can be defined.}.
\begin{enumerate}
\item \textbf{Clock add}: Given a clock variable ,  is an operation that adds a clock to .
      Formally speaking, given  , the result of  is a new timed automaton .
\item \textbf{Variable add}: Given a variable ,  is an operation that adds a variable to .
      Formally speaking, given  , the result of  is a new timed automaton .
\item \textbf{Location add}
    Given a location  and an invariant , where  is the conjunction of inequalities of the form  with clock ,  , and ,
      is an operation that adds a location to  with invariant condition .
   Formally speaking, let , the result of  is a new timed automaton
   .

\item \textbf{Jump add}:
    Given two locations  with guard , assignment , and set of synchronizers , where
    \begin{enumerate}
    \item  is the conjunction of inequalities of the form  or , where  is a clock,  is a variable, , and .
    \item  is the set of assignments of the form  or , where  is a clock,  is a variable, and .
    \end{enumerate}
    Let , then the result of  is a
    new timed automaton  by adding an arc  to .
\item \textbf{Jump edit}:
    Given two locations  with guards , assignments , and sets of synchronizers .
    \begin{enumerate}
    \item  are conjunctions of inequalities of the form  or , where  is a clock,  is a variable, , and .
    \item  are sets of assignments of the form  or , where  is a clock,  is a variable, and .
    \end{enumerate}
    Let , then the result of  is a new timed automaton
     by changing the arc  to  in .
\end{enumerate}
\end{defi}

Note that in our formulations, we assume due to simplification reasons that the added element is not identical to any elements in the original set, and
every newly added location or jump is well defined (e.g., to add  a new location with invariants using clock  ,  should have been
defined in ).

\begin{defi}
Let an edit sequence be , where  are edit actions.
Define the result of  on , in symbols  inductively as follows.
\begin{itemize}
\item  where  is the null sequence.
\item ,  .
\item , .
\item , .

\item , .
\item ,   .
\end{itemize}
\end{defi}

Starting from the textual description of the fault model, we can construct the set of \emph{deadline requirements}  for the system
model . Intuitively this means that for all runs entering the location , it must subsequently enter  within at most  time units.
Based on above definitions, we sketch the algorithm\footnote{This editing algorithm is not general;  for requirement ,  is not reentered before entering  because actions in the job processing element are chained.} how to generate the verification model from the system model as follows:
\begin{small}
\procbegin
\textbf{Algorithm}: \verb"GenVerificationModelPart()"\\
\{
\hstt /* Input: Original system model  */
\hstt /* Output: Verification model  */
\hstt \textbf{let} .
\hstt \textbf{forall} deadline requirements ,
\hstt /* add new clock and new variable for testing */
\hstttt.
\hstttt.
\hstt /*  is the location for deadline violation */
\hstttt.
\hstttt \textbf{forall} incoming jumps  of ,
\hstttttt ,
\hstttttttt where .
\hstttt \textbf{endfor}
\hstttt \textbf{forall} incoming jumps  of ,
\hstttttt ,
\hstttttttt where .
\hstttt \textbf{endfor}
\hstttt \textbf{forall} reachable locations  from ,
\hstttttt .
\hstttttttt where  is defined as .
\hstttt \textbf{endfor}
\hstt \textbf{endfor}
\hstt \textbf{return} . /* apply changes in  */
\\\}
\procend
\end{small}

For the property of deterministic assumption mentioned in section~\ref{subsec.Verification.Goals}, similar algorithms can be applied to annotate clocks, locations, and jumps; the problem for checking deterministic assumption in FTOS turns to be a reachability problem in timed automata.

\subsection{Dispatcher\label{sec.Dispatcher}}
With respect to the operating system, we have to model the dispatcher explicitly.
The modeled dispatcher merely captures the scheme for the execution of threads; deadline violation, fault-tolerance or error handling is modeled in the job processing element. Therefore, it can be used in arbitrary settings and not only in FTOS.
Due to different scheduling algorithms, the model of the dispatcher differs dramatically regarding actual verifiability.
For our analysis, we use priority based dispatchers modeling either FIFO or round-robin techniques.
Nevertheless, as context switch of tasks/threads occurs, we have the following observation.

\begin{obser}
Using a round-robin dispatcher leads to exponential increase of possible behaviors compared to a FIFO-based dispatcher with the number of parallel tasks, if no assumptions on the task behavior can be made.
\end{obser}

In summary, this section gave insight in the main components of the verification model and their construction. Besides the job processing element, all components and related observations can be directly applied for arbitrary real-time systems. For the job processing element, we described a generic way to use annotations to construct a model to use for verifying the absence of deadline violations. In the next section, we point out how aperiodic behavior introduced by faults or events can be considered.
\section{Invocation of Faults and Aperiodic Events\label{Sec.Invocation.Faults.Events}}

To perform verification, modeling the arrival of faults or aperiodic events is necessary to establish a closed model, and in this section we consider its effect.
In FTOS, the probability of faults is implicitly reflected by the concept called \emph{least time between faults} (LTBF). In our analysis, the invocation of aperiodic tasks can be done similarly - the least time between occurrences
of events for aperiodic tasks is defined as \emph{least time between arrivals} (LTBA). With LTBA or LTBF,
we can augment the original model with a timed automaton producing the event (called \emph{event agent}) similar to fig.~\ref{fig:TA.event.agent}.
However, since LTBF (or LTBA) is an integer which might be relatively large, and the complexity of verification in timed systems is related to this
integer\footnote{The reachability problem for timed automata is PSPACE-complete, i.e., the complexity is exponential to (1) the number of clocks and (2) the
maximum integer used in the system. Concerning (2), if the maximum number changes from  to , intuitively the execution time can increase by the factor of , where .},
the use of LTBF (or LTBA) may hinder the practicability of model checking.
Thus we propose some methods to effectively reduce the value of LTBF (or LTBA) with equivalence criterion.
For simplicity reasons, the following theorems are all discussed using event-triggered aperiodic functions with LTBA without loss of generality.

\begin{figure}
 \centering
 \includegraphics[width=0.15\columnwidth]{fig/EventAgent.PNG}
 \caption{A sample timed automaton representing the event agent.}
 \label{fig:TA.event.agent}
\end{figure}

\begin{prop}\label{simple}
Let system  have one FTOS function with periodic deadline  and one event-triggered aperiodic function. \begin{list1}
\item W.L.O.G., let  be the timed automaton of the event agent,
where  be the least time between two consecutive aperiodic events.
\end{list1}
Let  be the maximal time interval for the system to finish processing the event (called deadline interval from now on)\footnote{Let  be the time for the event arrival. If the system can not finish processing this event within time , then the system violates the deadline.}. If , then consider another system , where , i.e., the
only difference is to change  from  to . Then both systems are equivalent regarding their behavior concerning deadline violation.
That is, for  and , either they both satisfy the deadline, or they both miss the deadline.
\end{prop}

An intuitive argument for the bound  can be derived using fig.~\ref{fig:Proof.Explanation}. Tasks and events influence the execution of each other. The execution of an arriving event is influenced by the currently running task. During the deadline interval of the event, this and all preceding tasks are influenced as well. The chain of influence can only be stopped if the execution is decoupled. Since preceding tasks are decoupled by definition, two events with a minimal bound of  can not influence the execution of the same task. In fig.~\ref{fig:Proof.Explanation}, we call a time point  \emph{decoupling point} if two consecutive tasks immediately before and after  are not mutually influenced due to the occurrence of an event.



\begin{IEEEproof}
We consider four possible cases in :
\begin{enumerate}
    \item Consider the case where in , it is proven that no deadline is violated. When the verification engine proofs that the deadline is never
            violated with  in , the deadline of the FTOS function in  will never be violated because ; the verification engine has already considered  all cases in .
    \item Consider the case where in , the counter-example indicates that the -th aperiodic task violates the deadline. We further split the discussion in subjects whether it is the first time for  to process the event. Our goal is to construct a counter-example for deadline violation in  from the counter-example in .
\begin{figure}
 \centering
 \includegraphics[width=0.5\columnwidth]{fig/ProofExplainationNew}
 \caption{Illustrations for proofs of Proposition~\ref{simple}.}
 \label{fig:Proof.Explanation}

\end{figure}
        \begin{enumerate}
            \item If , i.e., it is the first time for  to execute the aperiodic task, then this deadline violation can also occur in , since no constraints are made for the first
                occurrence of events in  or .
            \item If , consider the -th aperiodic execution which does not violate the deadline. Let the time for the coming of event -th be , and let the interval between the -th
                  and the -th event be .  The system should finish the -th processing before time . Since , from time  to , FTOS function should finish one of its execution and proceed a new one. Let the time for the start of that cycle be . If we change the counter-example time trace such that no event has happened before , we still get a counter-example trace in . This new counter-example trace is also a counter-example trace in .
        \end{enumerate}
    \item Consider the case where in , the counter-example indicates that the FTOS function violates the deadline. Let the time which violates the deadline be  (note that  is the multiple of ). Let the occurrence of the nearest event be  (if there exists no such event, then both  and  can deadlock).
          \begin{enumerate}
            \item  If , then the event is processed before time , the starting of the period which violates the deadline. In this way, the system violates the deadline with only the existence of FTOS function, thus in , the deadline will also be violated.
            \item  If , we consider whether the event is the first one being processed.
            \begin{enumerate}
            \item If yes, then the counter-example in  is also a counter-example in .
            \item If not, then consider the time where the previous event occurs, and let the time be . Since , we can find a decoupling point , where , where at  it starts a new period.
                In this way, we can perform the same technique stated in (2-b) before .
            \end{enumerate}
          \end{enumerate}
    \item Consider the case where in , the counter-example indicates that both the -th aperiodic task and the FTOS function violate the deadline.
          Let the time which violates the deadline be  (note that  is the multiple of ), then the event occurs in time . By an argumentation similar to point 3-b, a counter-example trace in  can be established.
\end{enumerate}

\end{IEEEproof}

Remark: (1) Proposition~\ref{simple} formulates the insight that previous events occurred long before can not influence the current processing and scheduling, and therefore, are not the root cause of deadline violation. In other words, we could also construct a counter example with a single event as root cause.
(2) The introduction of faults can be viewed analogously. For faults, in FTOS (or similar fault-tolerant systems) the value of  is much smaller then  (LTBF), and this brings
significant advantages for construction of a model with smaller state space.

Proposition~\ref{simple} can only be used for very simple systems with only one task and one event. In the following, we will generalize the result to systems consisting of one periodic function with period  and several aperiodic functions.

\begin{prop}\label{more.events}
 Let  be a system  with  aperiodic functions. Each function with index , where , is associated with a pair
  describing the LTBA and deadline interval.
 Consider another system , where the only difference is to perform the following change: if for all ,
, then we change  to . Both systems  and 
are equivalent regarding their behavior concerning deadline
violation.
\end{prop}

\begin{IEEEproof} We consider the following cases.
\begin{enumerate}
    \item If  does not violate the deadline, then so does .
    \item Consider the case where in , the counter-example indicates that the -th aperiodic task of type
           violates the deadline.
    \begin{enumerate}
          \item If , let the time for the -th and -th arrival of type- events be 
          and . Our goal is to find the decoupling point  such that we can overlook
          all previously happened events.

          Since ,
          then within  the periodic function is executed at least 
          times. Consider the worst case where it is only executed
           times. Within , there are  potential decoupling points , where , .

          Due to the sparsity of events, each type of event arrives at most once within . For each type , the according event with deadline interval  will overlap in worst case at most  of these potential decoupling points.
          Thus the total number of overlapped points is at most ,
          which is less than the number of points among . Therefore,
          there exists at least one point  such that it is not overlapped
          by any deadline interval. Thus we can set the decoupling point  as . As a result, we can construct an equivalent counter-example where no event has happened before . This new counter-example trace is also a counter-example
            trace in .
          \item If , let the time for the -th  arrival of type- events be .
            \begin{enumerate}
                \item If for all type of events, the according events occurred at most once before , then the counter-example
                is also a counter-example in .
                \item If there exists some type of events occurred more than once: let  for type   be
                the total number of events occurred in the counter-example and  be the latest event
                arrival time. Choose  such that  and , .
                Then we can find the decoupling point between the -th and -th arrival of
                event with type , similar to the argument in case 2-a.
            \end{enumerate}
    \end{enumerate}
    \item Consider cases where the deadlock happens in the FTOS function.
    \begin{enumerate}
        \item If in the counter-example no event has occurred, then both  and  can deadlock.
        \item Otherwise, first we try to pick an event based on arguments in 2-b-ii. If possible, then the decoupling point can be found, and the counter-example for  can be established. If selection based on 2-b-ii is not possible, it follows the statement of 2-b-i that the counter example for  is also a counter-example in .
    \end{enumerate}

\end{enumerate}
\end{IEEEproof}

Lastly, we discuss the most general case.

\begin{prop}\label{more.tasks}
Let system  have  periodic FTOS/Giotto functions with periodic deadline , where , and
 aperiodic functions. Each function with index , where , is associated with a pair
  describing the LTBA and deadline interval.
 Consider another system , where the only difference is to perform the following change: if for all ,
, where  is the least common multiple of
, then we change  to . Both systems  and 
are equivalent regarding their behavior concerning deadline
violation.
\end{prop}

\begin{IEEEproof}The main difference to the previous case is that periodic functions with different tasks might influence each other. Potential decoupling points occur only at points in time, where all tasks start together. The proof idea is to view multiple periodic functions as a whole by taking the least common multiple. Here we omit the detailed proof.
\end{IEEEproof}



\section{Implementation\label{sec.Implementation}}


For implementation, we extend the functionality of FTOS-Verify to test the applicability. The verification model is constructed in a format acceptable by UPPAAL~\cite{bdl:2004:uppaal}.
Note that templates in UPPAAL are not completely suitable for our usage, since they only represent a fixed behavior with configurable
parameters. Therefore, algorithms to automatically generate timed automata based on FTOS models are needed. We have implemented our automated M2M transformation tool using openArchitectureWare\footnote{http://www.openarchitectureware.org}under the Eclipse modeling framework\footnote{http://www.eclipse.org/modeling/emf/}.

As use case, we apply the verification in the context of our balanced-rod example\footnote{For configurations, see http://www6.in.tum.de for details.}, where the control functions are replicated on three redundant machines to guarantee fault-tolerance. All components mentioned previously are generated by our automatic conversion technique; the resulting UPPAAL system has  communicating timed automata. As timing information for the different components, we use currently user-specified assumptions. An integration of WCET-analyzers is foreseen. One desired property specified is the guarantee for the absence of deadline violation, which turns to be the reachability property in UPPAAL.

The overall execution time varies from  to  minutes depending on the accuracy of the verification model on a Intel 2.33 GHz machine using a FIFO-based priority-driven scheduler. The  memory consumption can reach up to Mb. The verification of using a Round-Robin based scheduler showed to be too memory comsuming.

\section{Related Work\label{sec.Related.Work}}
We mention related work, but constrain ourselves in works regarding the analysis of Giotto-like systems; for techniques applying formal verification
in real-time analysis, we refer readers to the survey paper by Wang \cite{wang2004fvt}.
In Giotto, the Giotto-Compiler will perform hardware mapping and apply analysis techniques to check schedulability.
Many design tools with Giotto-like MoCs apply similar approaches, for example, TDL~\cite{simmons:1998:tdl} or HTL~\cite{ghosal:2006:htl}, but
analysis techniques are not explicitly mentioned.
One interesting work comes from COMDES-II project~\cite{ke2008vci}, which is also based on the concept of logical execution time; here, researchers apply model transformation from system models to verification models.
Nevertheless, as we focus on fault-tolerant systems, our work differs from the above works with the following facts.
First, we encounter a harder problem; by applying software fault-tolerance, modeling the communication between multiple deployed
units is required, and this is not required by other Giotto-like MoCs.
For those MoCs, scheduling analysis developed in real-time community could be enough without the use of model checking.
Furthermore, by proposing the similarity between aperiodic events and fault occurrences, our theoretical criteria is powerful to
reduce dramatically the complexity of the model (not the verification algorithm). This is based on our understanding regarding constituents
for the complexity of timed verification.

\section{Conclusion\label{sec.Conclusion}}

In this paper, we discussed the issue of constructing a model to verify timing assumptions in the context of FTOS using timed automata. However, due to our general approach, the results can be applied to arbitrary distributed real-time systems.

Our contribution can be summarized as follows.
\begin{enumerate}
    \item We give observations concerning modeling of general distributed real-time systems using timed automata and formulate our verification model construction process.
    \item With the context of systems consisting of periodic and aperiodic tasks, we give theoretical criteria how to reduce the size of the verification model, which is particularly useful for our approach. The change of the maximum integer used in the system decreases the required time for verification with exponential scale.
    \item A prototype software for the conversion process is constructed with preliminary experiments.
\end{enumerate}


Our work is currently based on user-specified assumptions regarding the timing of involved components. The next step will be the integration of WCET analyzing tools to have a faithful verification result.

Furthermore, we are investigating on approaches to separate the verification problem for control functions executed in parallel to make our approach applicable also for large-scale applications.



\bibliographystyle{plain}


\begin{thebibliography}{10}

\bibitem{emf:2009}
{Eclipse Modeling Framework}.
\newblock {\em http://www.eclipse.org/modeling/emf/}.

\bibitem{oaw:2009}
{openArchitectureWare Project}.
\newblock {\em http://www.openarchitectureware.org/}.

\bibitem{alur:1994:tta}
R.~Alur and D.L. Dill.
\newblock {A theory of timed automata}.
\newblock {\em Theoretical computer science}, 126(2):183--235, 1994.

\bibitem{bdl:2004:uppaal}
Gerd Behrmann, Alexandre David, and Kim~G. Larsen.
\newblock A tutorial on {\sc uppaal}.
\newblock In Marco Bernardo and Flavio Corradini, editors, {\em Formal Methods
  for the Design of Real-Time Systems: 4th International School on Formal
  Methods for the Design of Computer, Communication, and Software Systems
  (SFM-RT'04)}, number 3185 in LNCS, pages 200--236. Springer--Verlag,
  September 2004.

\bibitem{buckl:2008}
Christian Buckl.
\newblock {\em {Model-Based Development of Fault-Tolerant Real-Time Systems}}.
\newblock PhD thesis, Technische Universit{\"a}t M{\"u}nchen, Oct 2008.

\bibitem{Cheng:2009:FTOSVerify}
C. Cheng, C.~Buckl, J.~Esparza, and A.~Knoll.
\newblock {FTOS-Verify: Analysis and Verification of Non-Functional Properties
  for Fault-Tolerant Systems}.
\newblock Technical report (arXiv:0905.3946), TU Munich, 2009.

\bibitem{ghosal:2006:htl}
A.~Ghosal, A.~Sangiovanni-Vincentelli, C.M. Kirsch, T.A. Henzinger, and
  D.~Iercan.
\newblock {A hierarchical coordination language for interacting real-time
  tasks}.
\newblock In {\em Proceedings of the 6th ACM \& IEEE International conference
  on Embedded software (EMSOFT'06)}, pages 132--141. ACM New York, NY, USA,
  2006.

\bibitem{Henzinger01giotto:a}
Thomas~A. Henzinger, Benjamin Horowitz, and Christoph~M. Kirsch.
\newblock Giotto: A time-triggered language for embedded programming.
\newblock In {\em Proceedings of the First International Workshop on Embedded
  Software (EMSOFT'01)}, pages 166--184. Springer-Verlag, 2001.

\bibitem{ke2008vci}
X.~Ke, P.~Pettersson, K.~Sierszecki, and C.~Angelov.
\newblock {Verification of COMDES-II Systems Using UPPAAL with Model
  Transformation}.
\newblock In {\em Proceedings of the 14th IEEE International Conference on
  Embedded and Real-Time Computing Systems and Applications (RTCSA'08)}, pages
  153--160. IEEE Computer Society Washington, DC, USA, 2008.

\bibitem{sangiovannivincentelli:2001:pbd}
A.~Sangiovanni-Vincentelli and G.~Martin.
\newblock {Platform-Based Design and Software Design Methodology for Embedded
  Systems}.
\newblock {\em IEEE Design \& Test of Computers}, pages 23--33, 2001.

\bibitem{simmons:1998:tdl}
R.~Simmons and D.~Apfelbaum.
\newblock A task description language for robot control.
\newblock volume~3, pages 1931--1937 vol.3, Oct 1998.

\bibitem{torrespomales:2000:sft}
W.~Torres-Pomales.
\newblock {Software fault tolerance: A tutorial}.
\newblock {\em Langley research Center, Hampton, Virginia, Technical Report,
  No. NASA/TM-2000-210616}, 2000.

\bibitem{wang2004fvt}
F.~Wang.
\newblock {Formal verification of timed systems: A survey and perspective}.
\newblock {\em Proceedings of the IEEE}, 92(8):1283--1305, 2004.

\bibitem{wang2008prs}
F.~Wang and C.H. Cheng.
\newblock {Program Repair Suggestions from Graphical State-Transition
  Specifications}.
\newblock In {\em Proceedings of the 28th IFIP WG 6.1 international conference
  on Formal Techniques for Networked and Distributed Systems (FORTE'08)},
  volume 5048 of {\em LNCS}, pages 185--200. Springer--Verlag, 2008.

\end{thebibliography}


\end{document}
