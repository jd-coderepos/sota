\documentclass{article} \usepackage{iclr2020_conference,times}



\usepackage{amsmath,amsfonts,bm}

\newcommand{\figleft}{{\em (Left)}}
\newcommand{\figcenter}{{\em (Center)}}
\newcommand{\figright}{{\em (Right)}}
\newcommand{\figtop}{{\em (Top)}}
\newcommand{\figbottom}{{\em (Bottom)}}
\newcommand{\captiona}{{\em (a)}}
\newcommand{\captionb}{{\em (b)}}
\newcommand{\captionc}{{\em (c)}}
\newcommand{\captiond}{{\em (d)}}

\newcommand{\newterm}[1]{{\bf #1}}


\def\figref#1{figure~\ref{#1}}
\def\Figref#1{Figure~\ref{#1}}
\def\twofigref#1#2{figures \ref{#1} and \ref{#2}}
\def\quadfigref#1#2#3#4{figures \ref{#1}, \ref{#2}, \ref{#3} and \ref{#4}}
\def\secref#1{section~\ref{#1}}
\def\Secref#1{Section~\ref{#1}}
\def\twosecrefs#1#2{sections \ref{#1} and \ref{#2}}
\def\secrefs#1#2#3{sections \ref{#1}, \ref{#2} and \ref{#3}}
\def\eqref#1{equation~\ref{#1}}
\def\Eqref#1{Equation~\ref{#1}}
\def\plaineqref#1{\ref{#1}}
\def\chapref#1{chapter~\ref{#1}}
\def\Chapref#1{Chapter~\ref{#1}}
\def\rangechapref#1#2{chapters\ref{#1}--\ref{#2}}
\def\algref#1{algorithm~\ref{#1}}
\def\Algref#1{Algorithm~\ref{#1}}
\def\twoalgref#1#2{algorithms \ref{#1} and \ref{#2}}
\def\Twoalgref#1#2{Algorithms \ref{#1} and \ref{#2}}
\def\partref#1{part~\ref{#1}}
\def\Partref#1{Part~\ref{#1}}
\def\twopartref#1#2{parts \ref{#1} and \ref{#2}}

\def\ceil#1{\lceil #1 \rceil}
\def\floor#1{\lfloor #1 \rfloor}
\def\1{\bm{1}}
\newcommand{\train}{\mathcal{D}}
\newcommand{\valid}{\mathcal{D_{\mathrm{valid}}}}
\newcommand{\test}{\mathcal{D_{\mathrm{test}}}}

\def\eps{{\epsilon}}


\def\reta{{\textnormal{}}}
\def\ra{{\textnormal{a}}}
\def\rb{{\textnormal{b}}}
\def\rc{{\textnormal{c}}}
\def\rd{{\textnormal{d}}}
\def\re{{\textnormal{e}}}
\def\rf{{\textnormal{f}}}
\def\rg{{\textnormal{g}}}
\def\rh{{\textnormal{h}}}
\def\ri{{\textnormal{i}}}
\def\rj{{\textnormal{j}}}
\def\rk{{\textnormal{k}}}
\def\rl{{\textnormal{l}}}
\def\rn{{\textnormal{n}}}
\def\ro{{\textnormal{o}}}
\def\rp{{\textnormal{p}}}
\def\rq{{\textnormal{q}}}
\def\rr{{\textnormal{r}}}
\def\rs{{\textnormal{s}}}
\def\rt{{\textnormal{t}}}
\def\ru{{\textnormal{u}}}
\def\rv{{\textnormal{v}}}
\def\rw{{\textnormal{w}}}
\def\rx{{\textnormal{x}}}
\def\ry{{\textnormal{y}}}
\def\rz{{\textnormal{z}}}

\def\rvepsilon{{\mathbf{\epsilon}}}
\def\rvtheta{{\mathbf{\theta}}}
\def\rva{{\mathbf{a}}}
\def\rvb{{\mathbf{b}}}
\def\rvc{{\mathbf{c}}}
\def\rvd{{\mathbf{d}}}
\def\rve{{\mathbf{e}}}
\def\rvf{{\mathbf{f}}}
\def\rvg{{\mathbf{g}}}
\def\rvh{{\mathbf{h}}}
\def\rvu{{\mathbf{i}}}
\def\rvj{{\mathbf{j}}}
\def\rvk{{\mathbf{k}}}
\def\rvl{{\mathbf{l}}}
\def\rvm{{\mathbf{m}}}
\def\rvn{{\mathbf{n}}}
\def\rvo{{\mathbf{o}}}
\def\rvp{{\mathbf{p}}}
\def\rvq{{\mathbf{q}}}
\def\rvr{{\mathbf{r}}}
\def\rvs{{\mathbf{s}}}
\def\rvt{{\mathbf{t}}}
\def\rvu{{\mathbf{u}}}
\def\rvv{{\mathbf{v}}}
\def\rvw{{\mathbf{w}}}
\def\rvx{{\mathbf{x}}}
\def\rvy{{\mathbf{y}}}
\def\rvz{{\mathbf{z}}}

\def\erva{{\textnormal{a}}}
\def\ervb{{\textnormal{b}}}
\def\ervc{{\textnormal{c}}}
\def\ervd{{\textnormal{d}}}
\def\erve{{\textnormal{e}}}
\def\ervf{{\textnormal{f}}}
\def\ervg{{\textnormal{g}}}
\def\ervh{{\textnormal{h}}}
\def\ervi{{\textnormal{i}}}
\def\ervj{{\textnormal{j}}}
\def\ervk{{\textnormal{k}}}
\def\ervl{{\textnormal{l}}}
\def\ervm{{\textnormal{m}}}
\def\ervn{{\textnormal{n}}}
\def\ervo{{\textnormal{o}}}
\def\ervp{{\textnormal{p}}}
\def\ervq{{\textnormal{q}}}
\def\ervr{{\textnormal{r}}}
\def\ervs{{\textnormal{s}}}
\def\ervt{{\textnormal{t}}}
\def\ervu{{\textnormal{u}}}
\def\ervv{{\textnormal{v}}}
\def\ervw{{\textnormal{w}}}
\def\ervx{{\textnormal{x}}}
\def\ervy{{\textnormal{y}}}
\def\ervz{{\textnormal{z}}}

\def\rmA{{\mathbf{A}}}
\def\rmB{{\mathbf{B}}}
\def\rmC{{\mathbf{C}}}
\def\rmD{{\mathbf{D}}}
\def\rmE{{\mathbf{E}}}
\def\rmF{{\mathbf{F}}}
\def\rmG{{\mathbf{G}}}
\def\rmH{{\mathbf{H}}}
\def\rmI{{\mathbf{I}}}
\def\rmJ{{\mathbf{J}}}
\def\rmK{{\mathbf{K}}}
\def\rmL{{\mathbf{L}}}
\def\rmM{{\mathbf{M}}}
\def\rmN{{\mathbf{N}}}
\def\rmO{{\mathbf{O}}}
\def\rmP{{\mathbf{P}}}
\def\rmQ{{\mathbf{Q}}}
\def\rmR{{\mathbf{R}}}
\def\rmS{{\mathbf{S}}}
\def\rmT{{\mathbf{T}}}
\def\rmU{{\mathbf{U}}}
\def\rmV{{\mathbf{V}}}
\def\rmW{{\mathbf{W}}}
\def\rmX{{\mathbf{X}}}
\def\rmY{{\mathbf{Y}}}
\def\rmZ{{\mathbf{Z}}}

\def\ermA{{\textnormal{A}}}
\def\ermB{{\textnormal{B}}}
\def\ermC{{\textnormal{C}}}
\def\ermD{{\textnormal{D}}}
\def\ermE{{\textnormal{E}}}
\def\ermF{{\textnormal{F}}}
\def\ermG{{\textnormal{G}}}
\def\ermH{{\textnormal{H}}}
\def\ermI{{\textnormal{I}}}
\def\ermJ{{\textnormal{J}}}
\def\ermK{{\textnormal{K}}}
\def\ermL{{\textnormal{L}}}
\def\ermM{{\textnormal{M}}}
\def\ermN{{\textnormal{N}}}
\def\ermO{{\textnormal{O}}}
\def\ermP{{\textnormal{P}}}
\def\ermQ{{\textnormal{Q}}}
\def\ermR{{\textnormal{R}}}
\def\ermS{{\textnormal{S}}}
\def\ermT{{\textnormal{T}}}
\def\ermU{{\textnormal{U}}}
\def\ermV{{\textnormal{V}}}
\def\ermW{{\textnormal{W}}}
\def\ermX{{\textnormal{X}}}
\def\ermY{{\textnormal{Y}}}
\def\ermZ{{\textnormal{Z}}}

\def\vzero{{\bm{0}}}
\def\vone{{\bm{1}}}
\def\vmu{{\bm{\mu}}}
\def\vtheta{{\bm{\theta}}}
\def\va{{\bm{a}}}
\def\vb{{\bm{b}}}
\def\vc{{\bm{c}}}
\def\vd{{\bm{d}}}
\def\ve{{\bm{e}}}
\def\vf{{\bm{f}}}
\def\vg{{\bm{g}}}
\def\vh{{\bm{h}}}
\def\vi{{\bm{i}}}
\def\vj{{\bm{j}}}
\def\vk{{\bm{k}}}
\def\vl{{\bm{l}}}
\def\vm{{\bm{m}}}
\def\vn{{\bm{n}}}
\def\vo{{\bm{o}}}
\def\vp{{\bm{p}}}
\def\vq{{\bm{q}}}
\def\vr{{\bm{r}}}
\def\vs{{\bm{s}}}
\def\vt{{\bm{t}}}
\def\vu{{\bm{u}}}
\def\vv{{\bm{v}}}
\def\vw{{\bm{w}}}
\def\vx{{\bm{x}}}
\def\vy{{\bm{y}}}
\def\vz{{\bm{z}}}

\def\evalpha{{\alpha}}
\def\evbeta{{\beta}}
\def\evepsilon{{\epsilon}}
\def\evlambda{{\lambda}}
\def\evomega{{\omega}}
\def\evmu{{\mu}}
\def\evpsi{{\psi}}
\def\evsigma{{\sigma}}
\def\evtheta{{\theta}}
\def\eva{{a}}
\def\evb{{b}}
\def\evc{{c}}
\def\evd{{d}}
\def\eve{{e}}
\def\evf{{f}}
\def\evg{{g}}
\def\evh{{h}}
\def\evi{{i}}
\def\evj{{j}}
\def\evk{{k}}
\def\evl{{l}}
\def\evm{{m}}
\def\evn{{n}}
\def\evo{{o}}
\def\evp{{p}}
\def\evq{{q}}
\def\evr{{r}}
\def\evs{{s}}
\def\evt{{t}}
\def\evu{{u}}
\def\evv{{v}}
\def\evw{{w}}
\def\evx{{x}}
\def\evy{{y}}
\def\evz{{z}}

\def\mA{{\bm{A}}}
\def\mB{{\bm{B}}}
\def\mC{{\bm{C}}}
\def\mD{{\bm{D}}}
\def\mE{{\bm{E}}}
\def\mF{{\bm{F}}}
\def\mG{{\bm{G}}}
\def\mH{{\bm{H}}}
\def\mI{{\bm{I}}}
\def\mJ{{\bm{J}}}
\def\mK{{\bm{K}}}
\def\mL{{\bm{L}}}
\def\mM{{\bm{M}}}
\def\mN{{\bm{N}}}
\def\mO{{\bm{O}}}
\def\mP{{\bm{P}}}
\def\mQ{{\bm{Q}}}
\def\mR{{\bm{R}}}
\def\mS{{\bm{S}}}
\def\mT{{\bm{T}}}
\def\mU{{\bm{U}}}
\def\mV{{\bm{V}}}
\def\mW{{\bm{W}}}
\def\mX{{\bm{X}}}
\def\mY{{\bm{Y}}}
\def\mZ{{\bm{Z}}}
\def\mBeta{{\bm{\beta}}}
\def\mPhi{{\bm{\Phi}}}
\def\mLambda{{\bm{\Lambda}}}
\def\mSigma{{\bm{\Sigma}}}

\DeclareMathAlphabet{\mathsfit}{\encodingdefault}{\sfdefault}{m}{sl}
\SetMathAlphabet{\mathsfit}{bold}{\encodingdefault}{\sfdefault}{bx}{n}
\newcommand{\tens}[1]{\bm{\mathsfit{#1}}}
\def\tA{{\tens{A}}}
\def\tB{{\tens{B}}}
\def\tC{{\tens{C}}}
\def\tD{{\tens{D}}}
\def\tE{{\tens{E}}}
\def\tF{{\tens{F}}}
\def\tG{{\tens{G}}}
\def\tH{{\tens{H}}}
\def\tI{{\tens{I}}}
\def\tJ{{\tens{J}}}
\def\tK{{\tens{K}}}
\def\tL{{\tens{L}}}
\def\tM{{\tens{M}}}
\def\tN{{\tens{N}}}
\def\tO{{\tens{O}}}
\def\tP{{\tens{P}}}
\def\tQ{{\tens{Q}}}
\def\tR{{\tens{R}}}
\def\tS{{\tens{S}}}
\def\tT{{\tens{T}}}
\def\tU{{\tens{U}}}
\def\tV{{\tens{V}}}
\def\tW{{\tens{W}}}
\def\tX{{\tens{X}}}
\def\tY{{\tens{Y}}}
\def\tZ{{\tens{Z}}}


\def\gA{{\mathcal{A}}}
\def\gB{{\mathcal{B}}}
\def\gC{{\mathcal{C}}}
\def\gD{{\mathcal{D}}}
\def\gE{{\mathcal{E}}}
\def\gF{{\mathcal{F}}}
\def\gG{{\mathcal{G}}}
\def\gH{{\mathcal{H}}}
\def\gI{{\mathcal{I}}}
\def\gJ{{\mathcal{J}}}
\def\gK{{\mathcal{K}}}
\def\gL{{\mathcal{L}}}
\def\gM{{\mathcal{M}}}
\def\gN{{\mathcal{N}}}
\def\gO{{\mathcal{O}}}
\def\gP{{\mathcal{P}}}
\def\gQ{{\mathcal{Q}}}
\def\gR{{\mathcal{R}}}
\def\gS{{\mathcal{S}}}
\def\gT{{\mathcal{T}}}
\def\gU{{\mathcal{U}}}
\def\gV{{\mathcal{V}}}
\def\gW{{\mathcal{W}}}
\def\gX{{\mathcal{X}}}
\def\gY{{\mathcal{Y}}}
\def\gZ{{\mathcal{Z}}}

\def\sA{{\mathbb{A}}}
\def\sB{{\mathbb{B}}}
\def\sC{{\mathbb{C}}}
\def\sD{{\mathbb{D}}}
\def\sF{{\mathbb{F}}}
\def\sG{{\mathbb{G}}}
\def\sH{{\mathbb{H}}}
\def\sI{{\mathbb{I}}}
\def\sJ{{\mathbb{J}}}
\def\sK{{\mathbb{K}}}
\def\sL{{\mathbb{L}}}
\def\sM{{\mathbb{M}}}
\def\sN{{\mathbb{N}}}
\def\sO{{\mathbb{O}}}
\def\sP{{\mathbb{P}}}
\def\sQ{{\mathbb{Q}}}
\def\sR{{\mathbb{R}}}
\def\sS{{\mathbb{S}}}
\def\sT{{\mathbb{T}}}
\def\sU{{\mathbb{U}}}
\def\sV{{\mathbb{V}}}
\def\sW{{\mathbb{W}}}
\def\sX{{\mathbb{X}}}
\def\sY{{\mathbb{Y}}}
\def\sZ{{\mathbb{Z}}}

\def\emLambda{{\Lambda}}
\def\emA{{A}}
\def\emB{{B}}
\def\emC{{C}}
\def\emD{{D}}
\def\emE{{E}}
\def\emF{{F}}
\def\emG{{G}}
\def\emH{{H}}
\def\emI{{I}}
\def\emJ{{J}}
\def\emK{{K}}
\def\emL{{L}}
\def\emM{{M}}
\def\emN{{N}}
\def\emO{{O}}
\def\emP{{P}}
\def\emQ{{Q}}
\def\emR{{R}}
\def\emS{{S}}
\def\emT{{T}}
\def\emU{{U}}
\def\emV{{V}}
\def\emW{{W}}
\def\emX{{X}}
\def\emY{{Y}}
\def\emZ{{Z}}
\def\emSigma{{\Sigma}}

\newcommand{\etens}[1]{\mathsfit{#1}}
\def\etLambda{{\etens{\Lambda}}}
\def\etA{{\etens{A}}}
\def\etB{{\etens{B}}}
\def\etC{{\etens{C}}}
\def\etD{{\etens{D}}}
\def\etE{{\etens{E}}}
\def\etF{{\etens{F}}}
\def\etG{{\etens{G}}}
\def\etH{{\etens{H}}}
\def\etI{{\etens{I}}}
\def\etJ{{\etens{J}}}
\def\etK{{\etens{K}}}
\def\etL{{\etens{L}}}
\def\etM{{\etens{M}}}
\def\etN{{\etens{N}}}
\def\etO{{\etens{O}}}
\def\etP{{\etens{P}}}
\def\etQ{{\etens{Q}}}
\def\etR{{\etens{R}}}
\def\etS{{\etens{S}}}
\def\etT{{\etens{T}}}
\def\etU{{\etens{U}}}
\def\etV{{\etens{V}}}
\def\etW{{\etens{W}}}
\def\etX{{\etens{X}}}
\def\etY{{\etens{Y}}}
\def\etZ{{\etens{Z}}}

\newcommand{\pdata}{p_{\rm{data}}}
\newcommand{\ptrain}{\hat{p}_{\rm{data}}}
\newcommand{\Ptrain}{\hat{P}_{\rm{data}}}
\newcommand{\pmodel}{p_{\rm{model}}}
\newcommand{\pratio}{p_{\rm{ratio}}}
\newcommand{\pdatalab}{p_{\rm{labeled}}}
\newcommand{\pdataunlab}{p_{\rm{unlabeled}}}
\newcommand{\Pmodel}{P_{\rm{model}}}
\newcommand{\ptildemodel}{\tilde{p}_{\rm{model}}}
\newcommand{\pencode}{p_{\rm{encoder}}}
\newcommand{\pdecode}{p_{\rm{decoder}}}
\newcommand{\precons}{p_{\rm{reconstruct}}}
\newcommand{\decay}{\eta}

\newcommand{\laplace}{\mathrm{Laplace}} 

\newcommand{\E}{\mathbb{E}}
\newcommand{\Ls}{\mathcal{L}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\emp}{\tilde{p}}
\newcommand{\lr}{\alpha}
\newcommand{\reg}{\lambda}
\newcommand{\rect}{\mathrm{rectifier}}
\newcommand{\softmax}{\mathrm{softmax}}
\newcommand{\sigmoid}{\sigma}
\newcommand{\softplus}{\zeta}
\newcommand{\KL}{D_{\mathrm{KL}}}
\newcommand{\Var}{\mathrm{Var}}
\newcommand{\standarderror}{\mathrm{SE}}
\newcommand{\Cov}{\mathrm{Cov}}
\newcommand{\normlzero}{L^0}
\newcommand{\normlone}{L^1}
\newcommand{\normltwo}{L^2}
\newcommand{\normlp}{L^p}
\newcommand{\normmax}{L^\infty}

\newcommand{\parents}{Pa} 

\DeclareMathOperator*{\argmax}{arg\,max}
\DeclareMathOperator*{\argmin}{arg\,min}

\DeclareMathOperator{\sign}{sign}
\DeclareMathOperator{\Tr}{Tr}
\let\ab\allowbreak
 

\usepackage{url}
\usepackage{booktabs}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[]{caption}
\usepackage{multirow}
\usepackage{graphicx}
\usepackage{pdfpages}
\usepackage{mathtools}\usepackage{color}
\usepackage{soul}
\usepackage{subcaption}
\usepackage{algorithmicx}
\usepackage{nicefrac,xfrac}
\usepackage{algorithm,algpseudocode}
\usepackage{pifont}\newcommand{\cmark}{\ding{51}}\newcommand{\xmark}{\text{\ding{55}}}

\newcommand{\augustus}[1]{\textcolor{red}{\textbf{Augustus: #1}}}

\newcommand{\han}[1]{\textcolor{blue}{\textbf{TODO: #1}}}

\usepackage[toc,page]{appendix}
\usepackage{chngcntr}


\usepackage{hyperref}



\title{Consistency Regularization \\ for Generative Adversarial Networks}



\author{Han Zhang, Zizhao Zhang, Augustus Odena, Honglak Lee \\
Google Research\\
\texttt{\{zhanghan,zizhaoz,augustusodena,honglak\}@google.com} 
}



\newcommand{\fix}{\marginpar{FIX}}
\newcommand{\new}{\marginpar{NEW}}

\iclrfinalcopy \begin{document}


\maketitle

\begin{abstract}
Generative Adversarial Networks (GANs) are known to be difficult to train, despite considerable research effort.
Several regularization techniques for stabilizing training have been proposed, but they introduce non-trivial computational overheads and interact poorly with existing techniques like spectral normalization.
In this work, we propose a simple, effective training stabilizer based on the notion of consistency regularization---a popular technique in the semi-supervised learning literature.
In particular, we augment data passing into the GAN discriminator and penalize the sensitivity of the discriminator to these augmentations. 
We conduct a series of experiments to demonstrate that consistency regularization works effectively with spectral normalization and various GAN architectures, loss functions and optimizer settings. Our method achieves the best FID scores for unconditional image generation compared to other regularization methods on CIFAR-10 and CelebA.  
Moreover, Our consistency regularized GAN (CR-GAN) improves state-of-the-art FID scores for conditional generation from 14.73 to 11.48 on  CIFAR-10 and from 8.73 to 6.66 on ImageNet-2012. 

\end{abstract}

\section{Introduction}

Generative Adversarial Networks (GANs) \citep{goodfellow2014generative} have recently demonstrated impressive results on image-synthesis benchmarks \citep{Radford15, Han17,  Miyato18b, zhang2018photographic, BIGGAN, Karras2019}. In the original setting, GANs are composed of two neural networks trained with competing goals: the \emph{generator} is trained to synthesize realistic samples to fool the discriminator and the \emph{discriminator} is trained to distinguish real samples from fake ones produced by the generator. 

One major problem with GANs is the instability of the training procedure and the general sensitivity of the results to various hyperparameters \citep{salimans2016improved}.
Because GAN training implicitly requires finding the Nash equilibrium of a non-convex game in a continuous and high dimensional parameter space, it is 
substantially more complicated than standard neural network training.
In fact, formally characterizing the convergence properties of the GAN training procedure
is mostly an open problem \citep{OPENPROBLEMS}.
Previous work \citep{ArjovskyB17, Miyato18a,odena2017conditional,ChenZRLH19, WeiGL0W18} has shown that interventions focused on the discriminator can mitigate stability issues. 
Most successful interventions fall into two categories, normalization and regularization.
Spectral normalization is the most effective normalization method, in which weight matrices in the discriminator are divided by an approximation of their largest singular value.
For regularization, \citet{WGANGP} penalize the gradient norm of straight lines between real data and generated data.
\citet{RothLNH17} propose to directly regularize the squared gradient norm for both the training data and the generated data.
DRAGAN \citep{kodali2017convergence} introduces another form of gradient penalty where the gradients at Gaussian perturbations of training data are penalized. One may anticipate simultaneous regularization and normalization could improve sample quality.  
However, most of these gradient based regularization methods either provide marginal gains or fail to introduce any improvement when normalization is used \citep{compare_gan}, which is also observed in our experiments. These regularization methods and spectral normalization are motivated by controlling Lipschitz constant of the discriminator. We suspect this might be the reason that applying both does not lead to overlaid gain.

In this paper, we examine a technique called consistency regularization \citep{BachmanAP14, CONSISTENCY,laine2016temporal, CONSISTENCYAVITAL,UDACONSISTENCY, HuMTMS17} in contrast to gradient-based regularizers. Consistency regularization is widely used in semi-supervised learning to ensure that the classifier output remains unaffected for an unlabeled example even it is augmented in semantic-preserving ways. In light of this intuition, we hypothesize a well-trained discriminator should also be regularized to have the consistency property, which enforces the discriminator to be unchanged by arbitrary semantic-preserving perturbations and to focus more on semantic and structural changes between real and fake data. Therefore, we propose a simple regularizer to the discriminator of GAN: we augment images with semantic-preserving augmentations before they are fed into the GAN discriminator and penalize the sensitivity of the discriminator to those augmentations. 


\begin{figure}[t]
    \centering
    \includegraphics[width=140mm]{result_image/illustration.pdf}
    \caption{
    An illustration of consistency regularization for GANs. Before consistency regularization, 
    the zoomed-in dog and the zoomed-in cat (bottom left) can be closer than they are to their original images in feature space induced by the GAN discriminator.
    This is illustrated in the upper right (the semantic feature space), where the purple dot is closer to the 
    blue dot than to the red dot, and so forth.
    After we enforce consistency regularization based on the implicit assumption 
    that image augmentation preserves the semantics we care about, the purple dot pulled
    closer to the red dot.
    }
    \label{fig:illustration}
\end{figure}


This technique is simple to use and surprisingly effective.
It is as well less computationally expensive than prior techniques. 
More importantly, in our experiments, consistency regularization can always further improve the model performance when spectral normalization is used, whereas the performance gains of previous regularization methods diminish in such case. In extensive ablation studies, we show that it works across a large range of GAN variants
and datasets.
We also show that simply applying this technique on top of existing GAN models leads to
new state-of-the-art results as measured by Frechet Inception Distance \citep{FID}.

In summary, our contributions are summarized as follows:
    \begin{itemize}
    \item We propose consistency regularization for GAN discriminators to yield a simple, effective regularizer with lower computational cost than gradient-based regularization methods.
    \item We conduct extensive experiments with different GAN variants to demonstrate that our technique interacts effectively with spectral normalization. Our consistency regularized GAN (CR-GAN) achieves the best FID scores for unconditional image generation on both CIFAR-10 and CelebA.
    \item  We show that simply applying the proposed technique can further boost the performance of state-of-the-art GAN models. We improve FID scores for conditional image generation from 14.73 to 11.48 on CIFAR-10 and from 8.73 to 6.66 on ImageNet-2012.
\end{itemize}

\section{Method}

\subsection{GANs} \label{sec:gans}
A GAN consists of a generator network and a discriminator network.
The generator  takes a latent variable  sampled from a prior distribution and maps it to the observation space .
The discriminator  takes an observation  and produces a decision output over possible observation sources (either from  or from the empirical data distribution). 
In the standard GAN training procedure the generator  and the discriminator  are trained by minimizing the following objectives in an alternating fashion:

where  is usually a standard normal distribution. This formulation is originally proposed by \citet{goodfellow2014generative} as non-saturating (NS) GAN. A significant amount of research has been done on modifying this formulation in order to improve the training process. A notable example is the hinge-loss version of the adversarial loss~\citep{lim2017, Tran2017}:

Another commonly adopted GAN formulation is the Wassertein GAN (WGAN) \citep{WGAN}, in which the authors propose clipping the weights of the discriminator in an attempt to enforce that the GAN training procedure implicitly optimizes
a bound on the Wassertein distance between the target distribution and the distribution given by the generator. The loss function of WGAN can be written as

Subsequent work has refined this technique in several ways 
\citep{WGANGP,Miyato18a,SAGAN},
and the current widely-used practice is to enforce spectral normalization~\citep{Miyato18a} on both the generator and the discriminator.

\subsection{Consistency Regularization}
Consistency regularization has emerged as a gold-standard technique \citep{CONSISTENCY,laine2016temporal,CONSISTENCYAVITAL,UDACONSISTENCY,REALISTICSSL, mixmatch2019} for
semi-supervised learning on image data.
The basic idea is simple: an input image is perturbed in some semantics-preserving ways
and the sensitivity of the classifier to that perturbation is penalized. 
The perturbation can take many forms: it can be image flipping, or cropping, or adversarial attacks.
The regularization form is either the mean-squared-error \citep{CONSISTENCY,laine2016temporal} between the model's output for a perturbed and non-perturbed input or the KL divergence \citep{UDACONSISTENCY, miyato2018virtual} between the distribution over classes implied by the output logits.


\subsection{Consistency Regularization for GANs}
The goal of the discriminator in GANs is to distinguish real data from fake ones produced by the generator. The decision should be invariant to any valid domain-specific data augmentations. For example, in the image domain, the image being real or not should not change if we flip the image horizontally or translate the image by a few pixels. However, the discriminator in GANs does not guarantee this property explicitly. 

To resolve this, we propose a consistency regularization on the GAN discriminator during
training.
In practice, we randomly augment training images as they are passed to 
the discriminator and penalize the sensitivity of the discriminator to those augmentations.

We use  to denote the output vector before activation of the th layer of the discriminator
given input . 
 denotes a stochastic data augmentation function. 
This function can be linear or nonlinear, but aims to preserve the 
semantics of the input. 
Our proposed regularization is given by

where  indexes the layers,  is the starting layer and  is the ending layer that consistency is enforced.
 is weight coefficient for th layer and   denotes  norm of a given vector. 
This consistency regularization encourages the discriminator to produce the same output for a data point under various data augmentations.

In our experiments, we find that consistency regularization on the last layer of the discriminator before the activation function is sufficient.  can be rewritten as

where from now on we will drop the layer index for brevity. 
This cost is added to the discriminator loss (weighted by a hyper-parameter ) when updating the discriminator parameters.
The generator update remains unchanged.
Thus, the overall consistency regularized GAN (CR-GAN) objective is written as

Our design of  is general-purpose and thereby can work with any valid adversarial losses  and  for GANs (See Section \ref{sec:gans} for examples). 
Algorithm \ref{alg:main} illustrates the details of CR-GAN with Wassertein loss as an example. In contrast to previous regularizers, our method does not increase much overhead. The only extra computational cost comes from feeding an additional (third) image through the discriminator forward and backward when updating the discriminator
parameters.



\begin{algorithm}[t]
    \caption{Consistency Regularized GAN (CR-GAN). We use  by default.} 
    \label{alg:main}
\begin{algorithmic}[1]
    \renewcommand{\algorithmicrequire}{\textbf{Input:}}
    \renewcommand{\algorithmicensure}{\textbf{Output:}}
    \Require generator and discriminator parameters , consistency regularization coefficient , Adam hyperparameters , batch size , number of discriminator iterations per generator iteration 
    
    \For{number of training iterations} \For{}            \For{}
    \State Sample ,  
    \State Augment  to get 
    \State 
    \State 
    \EndFor
    \State 
    \EndFor
    \State  Sample a batch of latent variables   \State 
    \EndFor
\end{algorithmic}
\end{algorithm}



\section{Experiments}
\label{section:experiments}

This section validates our proposed CR-GAN method. First we conduct a large scale study to compare consistency regularization to existing GAN regularization techniques \citep{kodali2017convergence, WGANGP, RothLNH17} for several GAN architectures, loss functions and other hyper-parameter settings. 
We then apply consistency regularization to a state-of-the-art GAN model \citep{BIGGAN} 
and demonstrate performance improvement.
Finally, we conduct ablation studies to investigate the importance of various design choices 
and hyper-parameters. 
All our experiments are based on the open-source code from Compare GAN \citep{compare_gan},
which is available at 
{\href{https://github.com/google/compare\_gan}{https://github.com/google/compare\_gan.}}

\subsection{Datasets and Evaluation Metrics}
We validate our proposed method on three datasets: CIFAR-10 \citep{cifar10}, 
CELEBA-HQ-128 \citep{PROGRESSIVEGAN}, and ImageNet-2012 \citep{IMAGENET}.
We follow the procedure in \citet{compare_gan} to prepare datasets.
CIFAR-10 consists of 60K of  images in 10 classes; 
50K for training and 10K for testing.
CELEBA-HQ-128 (CelebA) contains 30K images of faces at a resolution of . 
We use 3K images for testing and the rest of images for training.
ImageNet-2012 contains roughly 1.2 million images with 1000 distinct categories and we down-sample the images to  in our experiments.


We adopt the Fr\'echet Inception distance (FID)~\citep{FID} as primitive metric for quantitative evaluation, 
as FID has proved be more consistent with human evaluation. 
In our experiments the FID is calculated on the test dataset.
In particular, we use 10K generated images vs. 10K test images on CIFAR-10, 3K vs. 3K on CelebA and 50K vs. 50K on ImageNet. We also provide the Inception Score~\citep{salimans2016improved} for different methods in the Appendix \ref{sec:is_section} for supplementary results. 
By default, the augmentation used in consistency regularization is a combination of randomly 
shifting the image by a few pixels and randomly flipping the image horizontally.
The shift size is 4 pixels for CIFAR-10 and CelebA and 16 for ImageNet.

\subsection{Comparison with other GAN regularization methods}
In this section, we compare our methods with three GAN regularization techniques,  Gradient Penalty (GP) \citep{WGANGP}, DRAGAN Regularizer (DR) \citep{kodali2017convergence} and JS-Regularizer (JSR) \citep{RothLNH17} on CIFAR-10 and CelebA. 

Following the procedures from \citep{compare_gan, LucicKMGB18}, we evaluate these methods across different optimizer parameters, loss functions, regularization coefficient and neural architectures.
For optimization, we use the Adam optimizer with batch size of 64 for all our experiments.
We stop training after 200k generator update steps for CIFAR-10 and 100k steps for CelebA. By default, spectral normalization (SN) \citep{Miyato18a} is used in the discriminator, 
as this is the most effective normalization method for GANs \citep{compare_gan} and is becoming the standard for `modern' GANs \citep{SAGAN,BIGGAN}.
Results without spectral normalization can be seen in the Appendix \ref{sec:no_sn}.


\subsubsection{Impact of Loss function} \label{sec: impact_loss}

\begin{figure}[t]
    \centering
    \includegraphics[width=130mm]{result_image/dcgan_fig1.pdf}
    \caption{
    Comparison of our method with existing regularization techniques under different GAN losses.
    Techniques include no regularization (W/O), Gradient Penalty (GP) \citep{WGANGP}, DRAGAN (DR) \citep{kodali2017convergence} and JS-Regularizer (JSR) \citep{RothLNH17}.
    Results (a-c) are for CIFAR-10 and results (d-f) are for CelebA.  
    }
    \label{fig:loss_fn}
\end{figure}
In this section, we discuss how each regularization method performs when the loss function is changed. 
Specifically, we evaluate regularization methods using three loss functions: 
the non-saturating loss (NS) \citep{goodfellow2014generative},
the Wasserstein loss (WAS) \citep{WGAN}, and 
the hinge loss (Hinge) \citep{lim2017, Tran2017}.
For each loss function, we evaluate over 7 hyper-parameter settings of the Adam optimizer 
(more details in Section \ref{sec:hyper_settings} of the appendix). 
For each configuration, we run each model 3 times with different random seeds.
For the regularization coefficient, we use the best value reported in the corresponding paper.
Specifically  is set to be 10 for both GP, DR and our method and 0.1 for JSR.
In this experiment, we use the SNDCGAN network architecture \citep{Miyato18a} for simplicity.
In the end, similar as \citet{compare_gan},  we aggregate all runs and report the FID distribution of the top 15\% of trained models.

The results are shown in Figure~\ref{fig:loss_fn}. The consistency regularization improves the baseline across all different loss functions and both datasets. 
Other techniques have more mixed results:
For example, GP and DR can marginally improve the performance for settings (d) and (e) but lead to worse results for settings (a) and (b) (which is consistent with findings from \citet{compare_gan}). 
In all cases, our consistency-regularized GAN models have the lowest (best) FID. 

This finding is especially encouraging, considering that the consistency regularization has lower computational cost (and is simpler to implement) than the other techniques. In our experiments, the consistency regularization is around  times faster than gradient based regularization techniques, including DR, GP and JSR, which need to compute the gradient of the gradient norm . Please see Table \ref{tab:speed_comparison} in the appendix for the actual training speed. 


\begin{table}[t]
\centering
\begin{tabular}{l|ccccc}
 \hline
Setting   & W/O &  GP & DR & JSR  & Ours (CR-GAN) \\ 
\hline
 CIFAR-10 (SNDCGAN)  & 24.73 & 25.83  & 25.08  & 25.17   & \textbf{18.72} \\
  CIFAR-10 (ResNet)  &19.00 & 19.74  & 18.94  & 19.59 &   \textbf{14.56}\\ 
 \hline
 CelebA (SNDCGAN)  & 25.95 & 22.57  & 21.91 &  22.17 & \textbf{16.97}\\
 
 
 \hline \hline
\end{tabular}
\caption{Best FID scores for unconditional image generation on CIFAR-10 and CelebA.
} 
\label{tab:main_comparison}
\end{table}


\subsubsection{Impact of the regularization coefficient}

\begin{figure}[t]
    \centering
    \includegraphics[width=140mm]{result_image/lambda_sweep_new.pdf}
\caption{
    Comparison of FID scores with different values of the regularization coefficient  
    on CIFAR-10 and CelebA. The dotted line is a model without regularization.
    }
    \label{fig:lambda_sweep}
\end{figure}

Here we study the sensitivity of GAN regularization techniques to the regularization coefficient .
We train SNDCGANs with non-saturating losses and fix the other hyper-parameters.
 is chosen among \{0.1, 1, 10, 100\}.
The results are shown in Figure \ref{fig:lambda_sweep}.
From this figure, we can see consistency regularization is more robust to changes in  than other
GAN regularization techniques (it also has the best FID for both datasets).
The results indicate that consistency regularization can be used as a plug-and-play technique
to improve GAN performance in different settings without much hyper-parameter tuning. 



\subsubsection{Impact of Neural Architectures}

\begin{figure}[t]
    \centering
    \includegraphics[width=120mm]{result_image/cifar_resnet.pdf}
    \caption{
    Comparison of FID scores with ResNet structure on different loss settings on CIFAR-10. 
    }
    \label{fig:resnet_loss}
\end{figure}

To validate whether the above findings hold across different neural architectures, 
we conduct experiments on CIFAR-10 using a ResNet \citep{HeZRS15, WGANGP} architecture instead of an 
SNDCGAN.
All other experimental settings are same as in Section \ref{sec: impact_loss}.
The FID values are presented in Figure \ref{fig:resnet_loss}.
By comparing results in Figure \ref{fig:resnet_loss} and Figure \ref{fig:loss_fn}, 
we can see that results on SNDCGAN and results on ResNet are comparable, though 
consistency regularization favors even better in this case:
In sub-plot (c) of Figure~\ref{fig:resnet_loss}, we can see that consistency regularization is the only regularization method that can generate satisfactory samples with a reasonable FID score (The FID scores for other methods are above 100). 
Please see Figure \ref{fig:stability_sample} for the actual generated samples in this setting. 
As in Section \ref{sec: impact_loss}, consistency regularization has the best FID for each setting.

In Table \ref{tab:main_comparison}, we show FID scores for the best-case settings from this section.
Consistency regularization improves on the baseline by a large margin and achieves the best results across different network architectures and datasets.
In particular, it achieves an FID 14.56 on CIFAR-10 16.97 on CelebA. 
In fact, our FID score of 14.56 on CIFAR-10 for \textit{unconditional} image generation is even lower than the 14.73 reported in \citet{BIGGAN} for
\textit{class-conditional} image-synthesis with a much larger network architecture and much bigger batch size.




\subsection{Comparison with state-of-the-art GAN models}

In this section, we add consistency regularization to the state-of-the-art BigGAN
model \citep{BIGGAN} and perform class conditional image-synthesis on CIFAR-10 and ImageNet.
Our model has exactly the same architecture and is trained under the same settings as BigGAN, the open-source implementation of BigGAN from \citet{compare_gan}.
The only difference is that our model uses consistency regularization. 
In Table~\ref{tab:compare_others}, we report the original FID scores without noise truncation.
Consistency regularization improves the FID score of BigGAN on CIFAR-10 from 20.42 to 11.48.
In addition, the FID on ImageNet is improved from 7.75 to 6.66. 

Generated samples for CIFAR-10 and ImageNet with consistency regularized models and baseline models are shown in Figures \ref{fig:cifar_samples_conditional}, \ref{fig:imagenet_ours} and \ref{fig:imagenet_baseline} in the appendix.

\begin{table*}[hbt]
\begin{center}
\begin{tabular}{l|ccccc}
\hline
Dataset  & SNGAN &SAGAN  & BigGAN  & BigGAN & CR-BigGAN \\
\hline
CIFAR-10 & 17.5  & /&  14.73  &20.42 & \textbf{11.48} \\
ImageNet & 27.62 & 18.65 &  8.73    & 7.75 & \textbf{6.66} \\ 

\hline
\hline
\end{tabular}
\end{center}
\vspace{-6pt}
    \caption{Comparison of our technique with state-of-the-art GAN models including SNGAN \citep{Miyato18b}, SAGAN \citep{SAGAN} and BigGAN \citep{BIGGAN} 
    for class conditional image generation on CIFAR-10 and ImageNet in terms of FID.
    BigGAN is the BigGAN implementation of \citet{compare_gan}.
    CR-BigGAN has the exactly same architecture as BigGAN and is trained with the same settings.
    The only difference is CR-BigGAN adds consistency regularization.}
\label{tab:compare_others} 
\end{table*}













\section{Ablation Studies and Discussion}

\subsection{How Much Does Augmentation Matter by Itself?}

\begin{figure}[t]
    \centering
    \includegraphics[width=130mm]{result_image/d_loss.pdf}
    \caption{
    A study of how much data augmentation matters by itself.
    Three GANs were trained on CIFAR-10: one baseline GAN, one GAN with data augmentation 
    only, and one GAN with consistency regularization.
    (\textbf{Left}) Training accuracy of the GAN discriminator. 
    (\textbf{Middle}) Test accuracy of the GAN discriminator on the held out test set. 
    The accuracy is low for the baseline GAN, which indicates it suffered from over-fitting. 
    The accuracy for the other two is
    basically indistinguishable for each other. This suggests that augmentation by itself is enough to reduce discriminator
    over-fitting, and that consistency regularization by itself does little to address
    over-fitting.
    (\textbf{Right})
    FID scores of the three settings. 
    The score for the GAN with only augmentation is not any better than the score for the
    baseline, even though its discriminator is not over-fitting.
    The score for the GAN with consistency regularization is better than both of the others, suggesting that the consistency regularization acts on the score through some 
    mechanism other than by reducing discriminator over-fitting.
    }
    \label{fig:d_loss}
\end{figure}

Our consistency regularization technique actually has two parts: 
we perform data augmentation on inputs from the training data,
and then consistency is enforced between the augmented data and the 
original data. We are interested in whether the performance gains shown in Section \ref{section:experiments} are merely due to data augmentation, since data augmentation reduces the over-fitting of the discriminator to the input data. Therefore, we have designed an experiment to answer this question. 
First, we train three GANs:
(1) a GAN trained with consistency regularization, as in Algorithm \ref{alg:main},
(2) a baseline GAN trained without augmentation or consistency regularization, and 
(3) a GAN trained with only data augmentation and no consistency regularization.
We then plot (Figure~\ref{fig:d_loss}) both their FID and the test accuracy of their discriminator on a held-out 
test set.
The FID tells us how `good' the resulting GAN is, and the discriminator test accuracy tells us
how much the GAN discriminator over-fits. Interestingly, we find that these two measures are not well correlated in this case. 
The model trained with only data augmentation over-fits substantially less than the baseline
GAN, but has almost the same FID. 
The model trained with consistency regularization has the same amount of over-fitting 
as the model trained with just data augmentation, but a much lower FID. 

This suggests an interesting hypothesis, which is that the mechanism by which the consistency regularization improves GANs is not simply discriminator generalization (in terms of classifying images into real vs fake). We believe that the main reason for the impressive gain from the consistency regularization is due to learning more semantically meaningful representation for the discriminator. More specifically, data augmentation will simply treat all real images and their transformed images with the same label as real without considering semantics, whereas our consistency regularization further enforces learning implicit manifold structure in the discriminator that pulls semantically similar images (i.e., original real image and the transformed image) to be closer in the discriminator representation space.


\subsection{How does the Type of Augmentation Affect Results?}
To analyze how different types of data augmentation affect our results, we conduct an ablation study on the CIFAR-10 dataset comparing the results of using four different types of image augmentation: 
(1) adding Gaussian noise to the image in pixel-space,
(2) randomly shifting the image by a few pixels and randomly flipping it horizontally,
(3) applying cutout \citep{devries2017improved} transformations to the image, and
(4) cutout \textit{and} random shifting and flipping. 
\begin{table}[t]
\centering
\begin{tabular}{l|cccc}
 \hline
Metric   & Gaussian Noise &  Random shift \& flip & Cutout & Cutout w/ random shift \& flip \\ \cline{1-5}
 FID     & 21.91   & 16.04  &   17.10  &   19.46    \\
 \hline \hline
\end{tabular}
\caption{
FID scores on CIFAR-10 for different types of image augmentation.
Gaussian noise is the worst, and random shift and flip is the best, consistent with 
general consensus on the best way to perform image optimization on CIFAR-10 \citep{Zagoruyko2016WRN}.
} 
\label{tab:different_aug}
\end{table}
As shown in Table \ref{tab:different_aug}, random flipping and shifting \textit{without} cutout gives the best results (FID 16.04) among all four methods.
Adding Gaussian noise in pixel-space gives the worst results.
This result empirically suggests that adding Gaussian noise is not a good semantic preserving transformation in the image manifold.  
It's also noteworthy that the most extensive augmentation (random flipping and shifting with cutout) 
did not perform the best. One possible reason is that the generator sometimes also generates samples with augmented artifacts (e.g., cutout). If such artifacts do not exist in the real dataset, it might lead to worse FID performance.  


\section{Conclusion}
In this paper, we propose a simple, effective, and computationally cheap method -- consistency regularization -- to improve the performance of GANs.
Consistency regularization is compatible with spectral normalization and results in improvements in all of the many contexts in which we evaluated it.
Moreover, we have demonstrated consistency regularization is more effective than other regularization methods under different loss functions, neural architectures and optimizer hyper-parameter settings.
We have also shown simply applying consistency regularization on top of state-of-the-art GAN models can further greatly boost the performance. 
Finally, we have conducted a thorough study on the design choices and hyper-parameters of consistency regularization. 

\section*{Acknowledgments}
We thank Colin Raffel for feedback on drafts of this article.
We also thank Marvin Ritter, Michael Tschannen and Mario Lucic for answering our questions of using compare GAN codebase for large scale GAN evaluation. 

\bibliography{iclr2020_conference}
\bibliographystyle{iclr2020_conference}



\newpage
\section*{Appendix}

\appendix
\counterwithin{figure}{section}
\renewcommand{\thefigure}{A\arabic{figure}}
\setcounter{table}{0}
\renewcommand{\thetable}{A\arabic{table}}

\section{Hyperparameter settings of optimizer} \label{sec:hyper_settings}

\begin{table}[h]
\centering
\begin{tabular}{c|cccc}
 \hline
Setting   &  &   &  &  \\ \cline{1-5}
 A  & 0.0001  & 0.5  & 0.9   &  5    \\
 B  & 0.0001  & 0.5  & 0.999 &  1    \\ 
 C  & 0.0002  & 0.5  & 0.999 &  1    \\
 D  & 0.0002  & 0.5  & 0.999 &  5    \\
 E  & 0.001   & 0.5  & 0.9   &  5    \\
 F  & 0.001   & 0.5  & 0.999 &  5     \\
 G  & 0.001   & 0.9  & 0.999 &  5     \\
 
 \hline \hline
\end{tabular}
\caption{Hyper-parameters of the optimizer used in our experiments. 
} 
\label{tab:different_adam_parameter}
\end{table}


 Here, similar as the experiments in \citet{Miyato18a, compare_gan}, we evaluate all regularization methods across 7 different hyperparameters settings for (1) learning rate   (2)  first and second order momentum parameters of Adam ,  (3) number of the updates of the discriminator per generator update, . The details of all the settings are shown in Table \ref{tab:different_adam_parameter}. Among all these 7 settings, A-D are the "good" hyperparameters used in previous publications \citep{Radford15, WGANGP, compare_gan}; E, F, G are the "aggressive" hyperparameter settings introduced by \citet{Miyato18a} to test model performance under noticeably large learning rate or disruptively high momentum. In practice, we find setting C generally works the best for SNDCGAN and setting D is the optimal setting for ResNet. These two settings are also the default settings in the Compare GAN codebase for the corresponding network architectures. 
 
 \begin{figure}[hbt]
    \centering
    \includegraphics[width=140mm]{result_image/optimizer_setting.pdf}
    \caption{
    Comparison of FID scores with different optimizer settings.
    }
    \label{fig:optimizer_setting}
\end{figure}
 
Figure \ref{fig:optimizer_setting} displays the FID score of all methods with 7 settings A-G. We can observe that consistency regularization is fairly robust even for some of the aggressive hyperparameter settings. In general, the proposed consistency regularization can generate better samples with different optimizer settings compared with other regularization methods. 


\newpage 
\renewcommand{\thefigure}{B\arabic{figure}}
\setcounter{figure}{0}

\section{Comparison of different regularization methods when spectral normalization is not used} \label{sec:no_sn}


\begin{figure}[hbt]
    \centering
    \includegraphics[width=140mm]{result_image/sn_false_all.pdf}
    \caption{
    Comparison of FID scores when SN is not used.
    }
    \label{fig:sn_false_all}
\end{figure}

Here, we compare different regularization methods when spectral normalization (SN) is not used. As shown in Figure \ref{fig:sn_false_all}, our consistency regularization always improves the baseline model (W/O). It also achieves the best FID scores in most of the cases, which demonstrates that consistency regularization does not depend on spectral normalization. By comparing with the results in Figure \ref{fig:loss_fn} and Figure \ref{fig:resnet_loss}, we find adding spectral normalization will further boost the results. More importantly, the consistency regularization is only method that improve on top of spectral normalization without exception. The other regularization methods do not have this property. 

\section{Training Speed}
\renewcommand{\thefigure}{C\arabic{figure}}
\setcounter{figure}{0}
\renewcommand{\thetable}{C\arabic{table}}
\setcounter{table}{0}

Here we show the actual training speed of discriminator updates for SNDCGAN on CIFAR-10 with NVIDIA Tesla V100. Consistency regularization is around  times faster than gradient based regularization techniques.


\begin{table}[hbt]
\centering
\begin{tabular}{l|ccccc}
 \hline
Method   & W/O &  GP & DR & JSR  & Ours (CR-GAN) \\ 
\hline
Speed (step/s)  & 66.3 & 29.7  & 29.8 & 29.2   & 51.7 \\

 \hline \hline
\end{tabular}
\caption{Training speed of discriminator updates for SNDCGAN on CIFAR-10. 
} 
\label{tab:speed_comparison}
\end{table}
\newpage 
\section{Generated samples for unconditional image generation}

\renewcommand{\thefigure}{D\arabic{figure}}
\setcounter{figure}{0}
\renewcommand{\thetable}{D\arabic{table}}
\setcounter{table}{0}

\begin{figure}[hbt]
    \centering
    \includegraphics[width=130mm]{result_image/celeba_sample_all_jpg}
    \caption{
    Comparison of generated samples of CelebA.
    }
    \label{fig:celeba_samples}
\end{figure}



\begin{figure}[hbt]
    \centering
    \includegraphics[width=130mm]{result_image/cifar_sample_resnet.pdf}
    \caption{
    Comparison of generated samples for unconditional image generation on CIFAR-10 with a ResNet architecture. 
    }
    \label{fig:cifar_samples_unconditional}
\end{figure}

\begin{figure}[hbt]
    \centering
    \includegraphics[width=130mm]{result_image/stability_samples.pdf}
    \caption{
    Comparison of unconditional generated samples on CIFAR-10 with a ResNet  architecture,  Wasserstein loss and spectral normalization. This is a hard hyperparameter setting where the baseline and previous regularization methods fail to generate reasonable samples. Consistency Regularization is the only regularization method that can generate satisfactory samples in this setting. FID scores are shown in sub-plot (c) of Figure \ref{fig:resnet_loss}.
    }
    \label{fig:stability_sample}
\end{figure}


\section{Generated samples for conditional image generation}
\renewcommand{\thefigure}{E\arabic{figure}}
\setcounter{figure}{0}
\renewcommand{\thetable}{E\arabic{table}}
\setcounter{table}{0}

\begin{figure}[hbt]
    \centering
    \includegraphics[width=140mm]{result_image/cifar10_conditional.pdf}
    \caption{
    Comparison of generated samples for conditional image generation on CIFAR-10. Each row shows the generated samples of one class.
    }
    \label{fig:cifar_samples_conditional}
\end{figure}
\newpage
\begin{figure}[hbt!]
    \centering
    \includegraphics[width=138mm]{result_image/imagenet_compare_2}
    \caption{
        Comparison of conditionally generated samples of BigGAN* and CR-BigGAN* on ImageNet. (\textbf{Left}) Generated samples of CR-BigGAN*. (\textbf{Right}) Generated samples of BigGAN*. 
    }
    \label{fig:imagenet_ours}
\end{figure}
\begin{figure}[hbt!]
    \centering
    \includegraphics[width=138mm]{result_image/imagenet_compare_1}
    \caption{
    More results for conditionally generated samples of BigGAN* and CR-BigGAN* on ImageNet. (\textbf{Left}) Generated samples of CR-BigGAN*. (\textbf{Right}) Generated samples of BigGAN*. 
    }
    \label{fig:imagenet_baseline}
\end{figure}

\section {Comparison with inception score} \label{sec:is_section}
\renewcommand{\thefigure}{F\arabic{figure}}
\setcounter{figure}{0}
\renewcommand{\thetable}{F\arabic{table}}
\setcounter{table}{0}
Inception Score (IS) is another GAN evaluation metric introduced by \citet{salimans2016improved}. Here, we compare the Inception Score of the unconditional generated samples on CIFAR-10. As shown in Table \ref{tab:main_inception_comparision},  Figure \ref{fig:cifar_dcgan_is} and Figure \ref{fig:cifar_resnet_is}, consistency regularization achieves the best IS result with both SNDCGAN and ResNet architectures. 

\begin{table}[hbt]
\centering
\begin{tabular}{l|ccccc}
 \hline
Setting   & W/O &  GP & DR & JSR  & Ours (CR-GAN)\\ 
\hline
 CIFAR-10 (SNDCGAN)  & 7.54 & 7.54  & 7.54  & 7.52   & \textbf{7.93} \\
 CIFAR-10 (ResNet)  &8.20 & 8.04  & 8.09  & 8.03 &   \textbf{8.40}\\ 

 
 \hline \hline
\end{tabular}
\caption{Best Inception Score for unconditional image generation on CIFAR-10.
} 
\label{tab:main_inception_comparision}
\end{table}

\begin{figure}[hbt!]
    \centering
    \includegraphics[width=140mm]{result_image/cifar_dcgan_is}
    \caption{
    Comparison of IS with a SNDCGAN architecture on different loss settings. Models are trained on CIFAR-10.
    }
    \label{fig:cifar_dcgan_is}
\end{figure}

\begin{figure}[hbt!]
    \centering
    \includegraphics[width=140mm]{result_image/cifar_resnet_is}
    \caption{
    Comparison of IS with a ResNet architecture on different loss settings. Models are trained on CIFAR-10.
    }
    \label{fig:cifar_resnet_is}
\end{figure}


\section {Effect of the number of layers regularized in Discriminator } \label{sec:num_layers}

\renewcommand{\thefigure}{G\arabic{figure}}
\setcounter{figure}{0}
\renewcommand{\thetable}{G\arabic{table}}
\setcounter{table}{0}

Here, we examine the effect of the number of layers regularized in discriminator.
In this experiment, we use SNDCGAN architecture with NS loss on the CIFAR-10 dataset.
There are 8 intermediate layers in the discriminator.
To start, we add consistency only to the last layer (0 intermediate layers).
Then we gradually enforce consistency for more intermediate layers.
We use two weighting variations to combine the consistency loss across different layers.
In the first setting, the weight of each layer is the inverse of feature dimension  in that layer,
which corresponds to  in Equation~\ref{eq:ori_eq}.
In the second setting, we give equal weight to each layer, which corresponds to  .
The results for both settings are shown in Figure \ref{fig:layer_sensitivity}.
In both settings, we observe that consistency regularization on the final layer achieves reasonably good results.
Adding the consistency to first few layers in the discriminator harms the performance.
For simplicity, we only add consistency regularization in the final layer of the discriminator in the rest of our experiments. 

\begin{figure}[hbt!]
    \centering
    \includegraphics[width=140mm]{result_image/layer_sesitivity.pdf}
    \caption{
    Comparison of consistency regularization on different number of intermediate layers: (a) first weight setting, where the weight for each layer is the inverse of its feature dimension (b) second weight setting, where each layer has equal weight. 
    }
    \label{fig:layer_sensitivity}
\end{figure}




\section {Consistency Regularization on the generated samples} \label{sec:generated_sample}

\renewcommand{\thefigure}{H\arabic{figure}}
\setcounter{figure}{0}
\renewcommand{\thetable}{H\arabic{table}}
\setcounter{table}{0}

In this section, we investigate the effect of adding consistency regularization for the generated samples.
We compare four settings, no consistency regularization (W/O), regularization only on the real samples (CR-Real),
consistency regularization only on the fake samples produced by the generator (CR-Fake) and regularization on both real and fake samples (CR-All).
CR-Real is presented in Algorithm \ref{alg:main}. 
CR-Fake has similar computational cost as CR-Real and CR-All doubles the computational cost, 
since both the augmented real and fakes samples need to be fed into the discriminator to calculate the consistency loss.
As shown in Figure \ref{fig:cr_fake}, CR-Real, CR-Fake and CR-All are always better than the baseline without consistency regularization.
In addition, CR-Real is consistently better than CR-Fake.
It is interesting to note that CR-All is not always better than CR-real given the extra computational costs and stronger regularization.
For example, CR-All improves FID from 20.21 of CR-Real to 15.51 for SNDCGAN, but it also gives slightly worse results for ResNet  (14.93 vs 15.07)
and for CR-BigGAN* (11.48 vs 12.51).
We observe that enforcing additional consistency on the generated samples gives more performance gain when the model capacity is small and that gain
decreases when model capacity increases.
For computational efficiency and simplicity of the training algorithm, we use consistency regularization on real samples for the rest of our 
experiments. 





\begin{figure}[hbt!]
    \centering
    \includegraphics[width=0.49\linewidth]{result_image/cr_fake_a.pdf}
    \includegraphics[width=0.49\linewidth]{result_image/cr_fake_b.pdf}
    \includegraphics[width=0.49\linewidth]{result_image/cr_fake_c.pdf}
    
    \caption{
    Comparison of FID scores with no consistency regularization (W/O), regularization only on the real samples (CR-Real), consistency regularization only on the fake samples produced by the generator (CR-Fake) and regularization on both real and fake samples (CR-All) for (a) unconditional image generation on CIFAR-10 with SNDCGAN, (b) unconditional image generation on CIFAR-10 with ResNet, (c) conditional image generation on CIFAR-10 with CR-BigGAN*.
    }
    \label{fig:cr_fake}
\end{figure} 
\end{document}
