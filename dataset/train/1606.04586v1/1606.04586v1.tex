\documentclass{article}

\usepackage[nonatbib,final]{nips_2016}





\usepackage[utf8]{inputenc} \usepackage[T1]{fontenc}    \usepackage{hyperref}       \usepackage{url}            \usepackage{booktabs}       \usepackage{amsfonts}       \usepackage{amsmath}       
\usepackage{nicefrac}       \usepackage{microtype}      \usepackage{graphicx}

\title{Regularization With Stochastic Transformations and Perturbations for Deep Semi-Supervised Learning}



\author{
  Mehdi Sajjadi\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,Mehran Javanmardi\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,Tolga Tasdizen\\
\\
  Department of Electrical and Computer Engineering\\
  University of Utah\\
  \texttt{\{mehdi, mehran, tolga\}@sci.utah.edu} \\
}

\begin{document}


\maketitle

\begin{abstract}
Effective convolutional neural networks are trained on large sets of labeled data. However, creating large labeled datasets is a very costly and time-consuming task. Semi-supervised learning uses unlabeled data to train a model with higher accuracy when there is a limited set of labeled data available. In this paper, we consider the problem of semi-supervised learning with convolutional neural networks. Techniques such as randomized data augmentation, dropout and random max-pooling provide better generalization and stability for classifiers that are trained using gradient descent. Multiple passes of an individual sample through the network might lead to different predictions due to the non-deterministic behavior of these techniques. We propose an unsupervised loss function that takes advantage of the stochastic nature of these methods and minimizes the difference between the predictions of multiple passes of a training sample through the network. We evaluate the proposed method on several benchmark datasets.
\end{abstract}
\section{Introduction}
Convolutional neural networks (ConvNets) \cite{le1990handwritten,lecun1998gradient} achieve state-of-the-art accuracy on a variety of computer vision tasks, including classification, object localization, detection, recognition and scene labeling \cite{sermanet2013overfeat, long2015fully}. The advantage of ConvNets partially originates from their complexity (large number of parameters), but this can result in overfitting without a large amount of training data. However, creating a large labeled dataset is very costly. A notable example is the ’ImageNet’ \cite{berg2010large} dataset with 1000 category and more than 1 million training images. The state-of-the-art accuracy of this dataset is improved every year using ConvNet-based methods (e.g., \cite{szegedy2015going, krizhevsky2012imagenet}). This dataset is the result of significant manual effort. However, with around 1000 images per category, it barely contains enough training samples to prevent the ConvNet from overfitting \cite{krizhevsky2012imagenet}. On the other hand, unlabeled data is cheap to collect. For example, there are numerous online resources for images and video sequences of different types. Therefore, there has been an increased interest in exploiting the readily available unlabeled data to improve the performance of ConvNets.

Randomization plays an important role in the majority of learning systems. Stochastic gradient descent, dropout \cite{hinton2012improving}, randomized data transformation and augmentation \cite{ciresan2012multi} and many other training techniques that are essential for fast convergence and effective generalization of the learning functions introduce some non-deterministic behavior to the learning system. Due to these uncertainties, passing a single data sample through a learning system multiple times might lead to different predictions. Based on this observation, we introduce an unsupervised loss function optimized by gradient descent that takes advantage of this randomization effect and minimizes the difference in predictions of multiple passes of a data sample through the network during the training phase, which leads to more stable generalization in testing time. The proposed unsupervised loss function specifically regularizes the network based on the variations caused by randomized data augmentation, dropout and randomized max-pooling schemes. This loss function can be combined with any supervised loss function. In this paper, we apply the proposed unsupervised loss function to ConvNets as a state-of-the-art supervised classifier. We show through numerous experiments that this combination leads to a competitive semi-supervised learning method.

\section{Related Work}
\label{sec::rel}
There are many approaches to semi-supervised learning in general \cite{chapelle2006semi, zhu2005semi}. Self-training and co-training \cite{blum1998combining, de1994learning} are two well-known classic examples. In self-training, the confident predictions of the classifier are added to the training set. In co-training, two classifiers are trained on disjoint subsets of features. It is assumed that the two feature sets are conditionally independent. Then, unlabeled samples leading to strong predictions in one of the classifiers will be added to the training set of the other classifier. Another set of approaches to semi-supervised learning is based on generative models, for example, methods based on Gaussian Mixture Models (GMM) and Hidden Markov Models (HMM) \cite{miller1997mixture}. These generative models generally try to use unlabeled data in modeling the joint probability distribution of the training data and labels. Transductive SVM (TSVM) \cite{joachims1999transductive} and S3VM \cite{bennett1999semi} are another semi-supervised learning approach that tries to find a decision boundary with a maximum margin on both labeled and unlabeled data. A large group of semi-supervised methods is based on graphs and the similarities between the samples \cite{blum2001learning, zhu2003semi}. For example, if a labeled sample is similar to an unlabeled sample, its label is assigned to that unlabeled sample. In these methods, the similarities are encoded in the edges of a graph. Label propagation \cite{zhu2002learning} is an example of these methods in which the goal is to minimize the difference between model predictions of two samples with large weighted edge. In other words, similar samples tend to get similar predictions. 

In this paper, our focus is on semi-supervised deep learning. There has always been interest in exploiting unlabeled data to improve the performance of ConvNets. One approach is to use unlabeled data to pre-train the filters of ConvNet \cite{lecun2010convolutional, jarrett2009best}. The goal is to reduce the number of training epochs required to converge and improve the accuracy compared to a model trained by random initialization. Predictive sparse decomposition (PSD) \cite{kavukcuoglu2010fast} is one example of these methods used for learning the weights in the filter bank layer. The works presented in \cite{agrawal2015learning} and \cite{doersch2015unsupervised} are two recent examples of learning features by pre-training ConvNets using unlabeled data. In these approaches, an auxiliary target is defined for a pair of unlabeled images \cite{agrawal2015learning} or a pair of patches from a single unlabeled image \cite{doersch2015unsupervised}. Then a pair of ConvNets is trained to learn descriptive features from unlabeled images. These features can be fine-tuned for a specific task with a limited set of labeled data. However, many recent ConvNet models with state-of-the-art accuracy start from randomly initialized weights using techniques such as Xavier's method \cite{glorot2010understanding, szegedy2015going}. Therefore, approaches that make better use of unlabeled data during training instead of just pre-training are more desired. 

Another example of semi-supervised learning with ConvNets is region embedding \cite{johnson2015semi}, which is used for text categorization. The work in \cite{weston2012deep} is also a deep semi-supervised learning method based on embedding techniques. Unlabeled video frames are also being used to train ConvNets \cite{wang2015unsupervised, jayaraman2015learning}. The target of the ConvNet is calculated based on the correlations between video frames. Another notable example is semi-supervised learning with ladder networks \cite{rasmus2015semi} in which the sums of supervised and unsupervised loss functions are simultaneously minimized by backpropagation. In this method, a feedforward model, is assumed to be an encoder. The proposed network consists of a noisy encoder path and a clean one. A decoder is added to each layer of the noisy path. This decoder is supposed to reconstruct a clean activation of each layer. The unsupervised loss function is the difference between the output of each layer in clean path and its corresponding reconstruction from the noisy path. 

Another approach by \cite{dosovitskiy2014discriminative} is to take a random unlabeled sample and generate multiple instances by randomly transforming that sample multiple times. The resulting set of images forms a surrogate class. Multiple surrogate classes are produced and a ConvNet is trained on them. One disadvantage of this method is that it does not scale well with the number of unlabeled examples because a separate class is needed for every training sample during unsupervised training.
In \cite{mutualexclusive}, the authors propose a mutual-exclusivity loss function that forces the set of predictions for a multiclass dataset to be mutually-exclusive. In other words, it forces the classifier's prediction to be close to one only for one class and zero for the others. It is shown that this loss function makes use of unlabeled data and pushes the decision boundary to a less dense area of decision space.
\vspace{-0.2cm}
\section{Method}
\vspace{-0.1cm}
Given any training sample, a model's prediction should be the same under any random transformation of the data and perturbations to the model. The transformations can be any linear and non-linear data augmentation being used to extend the training data. The disturbances include dropout techniques and randomized pooling schemes. In each pass, each sample can be randomly transformed or the hidden nodes can be randomly activated. As a result, the network's prediction can be different for multiple passes of the same training sample. However, we know that each sample is assigned to only one class. Therefore, the network's prediction is expected to be the same despite transformations and disturbances. We introduce an unsupervised loss function that minimizes the mean squared differences between different passes of an individual training sample through the network. Note that we do not need to know the label of a training sample in order to enforce this loss. Therefore, the proposed loss function is completely unsupervised and can be used along with supervised training as a semi-supervised learning method. It can also be applied on labeled samples to enforce stability w.r.t. training samples. 

Next, we formally define the proposed unsupervised loss function. We start with a dataset with  training samples and  classes. Let us assume that  is the classifier's prediction vector on the 'th training sample during the 'th pass through the network. We assume that each training sample is passed  times through the network. We define the  to be a random linear or non-linear transformation on the training sample  before the 'th pass through the network. The proposed loss function for each data sample is:

Where 'TS' stands for transformation/stability. We pass a training sample through the network  times. In each pass, the transformation  produces a different input to the network from the original training sample. In addition, each time the randomness inside the network, which can be caused by dropout or randomized pooling schemes, leads to a different prediction output. We minimize the sum of squared differences between each possible pair of predictions. We can minimize this objective function using gradient descent. Note that recent neural-network-based methods are optimized on batches of training samples instead of a single sample (batch vs. online training). We can design batches to contain replications of training samples so we can easily optimize this transformation/stability loss function. This unsupervised loss function can be used with any backpropagation-based algorithm. It is also possible to combine it with any supervised loss function. 

As mentioned in section \ref{sec::rel}, mutual-exclusivity loss function of \cite{mutualexclusive} forces the classifier's prediction vector to have only one non-zero element. This loss function naturally complements the transformation/stability loss function. In supervised learning, each element of the prediction vector is pushed towards zero or one depending on the corresponding element in label vector. The proposed loss minimizes the -norm of the difference between predictions of multiple transformed versions of a sample, but it does not impose any restrictions on the individual elements of a single prediction vector. As a result, each prediction vector might be a trivial solution instead of a valid prediction due to lack of labels. Mutual-exclusivity loss function forces each prediction vector to be valid and prevents trivial solutions. This loss function for the training sample  is defined as follows:

Where 'ME' stands for mutual-exclusivity.  is the -th element of prediction vector . In the experiments, we show that the combination of both loss functions leads to further improvements in the accuracy of the models. We define the combination of both loss functions as transformation/stability plus mutual-exclusivity loss function:

\section{Experiments}
We show the effect of the proposed unsupervised loss functions using ConvNets on MNIST \cite{lecun1998gradient}, CIFAR10 and CIFAR100 \cite{krizhevsky2009learning}, SVHN \cite{netzer2011reading}, NORB \cite{lecun2004learning} and ILSVRC 2012 challenge \cite{berg2010large}. We use two frameworks to implement and evaluate the proposed loss function. The first one is cuda-convnet \cite{cudac}, which is the original implementation of the well-known AlexNet model. The second framework is the sparse convolutional networks \cite{graham2014spatially} with fractional max-pooling \cite{graham2014fractional}, which is a more recent implementation of ConvNets achieving state-of-the-art accuracy on CIFAR10 and CIFAR100 datasets. We show through different experiments that by using the proposed loss function, we can improve the accuracy of the models trained on a few labeled samples on both implementations. In Eq. \ref{eq1}, we set  to be 4 for experiments conducted using cuda-convnet and 5 for experiments performed using sparse convolutional networks. Sparse convolutional network allows for any arbitrary batch sizes. As a result, we tried different options for  and  is the optimal choice. However, cuda-convnet allows for mini-batches of size 128. Therefore, it is not possible to use . Instead, we decided to use . In practice the difference is insignificant. It must be noted that replicating a training sample four or five times does not necessarily  increase the computational complexity with the same factor. Based on the experiments, with higher  fewer training epochs are required for the models to converge. We perform multiple experiments for each dataset. We use the available training data of each dataset to create two sets: labeled and unlabeled. We do not use the labels of the unlabeled set during training. We compare models that are trained only on the labeled set with models that are trained on both the labeled set and the unlabeled set using the unsupervised loss function. We show that by using the unsupervised loss function, we can improve the accuracy of classifiers on benchmark datasets. For experiments performed using sparse convolutional network, we describe the network parameters using the format:

In the above example network,  is the number of maps in the 'th convolutional layer. In this example, .  specifies that convolutions use a kernel size of .  indicates that convolutional layers are followed by a fractional max-pooling (FMP) layer \cite{graham2014fractional} that reduces the size of feature maps by a factor of . As mentioned earlier, the mutual-exclusivity loss function of \cite{mutualexclusive} complements the transformation/stability loss function. We implement that loss function in both cuda-convnet and sparse convolutional networks as well. We experimentally choose  and  in Eq. \ref{eq:comb}. However, the performance of the models is not overly sensitive to these parameters, and in most of the experiments it is fixed to  and .
\vspace{-0.2cm}
\subsection{MNIST}
\vspace{-0.1cm}
MNIST is the most frequently used dataset in the area of digit classification. It contains 60000 training and 10000 test samples of size 28  28 pixels. We perform experiments on MNIST using a sparse convolutional network with the following architecture:  We use dropout to regularize the network. The ratio of dropout gradually increases from the first layer to the last layer. We do not use any data augmentation for this task. In other words,  of Eq. \ref{eq1} is identity function for this dataset. In this case, we take advantage of the random effects of dropout and fractional max-pooling using the unsupervised loss function. We randomly select 10 samples from each class (total of 100 labeled samples). We use all available training data as the unlabeled set. First, we train a model based on this labeled set only. Then, we train models by adding unsupervised loss functions. In separate experiments, we add transformation/stability loss function, mutual-exclusivity loss function and the combination of both. Each experiment is repeated five times with a different random subset of training samples. We repeat the same set of experiments using 100\% of MNIST training samples. The results are given in Table \ref{tab5}. We can see that the proposed loss significantly improves the accuracy on test data. We also compare the results with ladder networks \cite{rasmus2015semi}. The state-of-the-art error rate on MNIST using all training data without data augmentation is 0.24\% \cite{chang2015batch} to the best of our knowledge. It can be seen that we can achieve a close accuracy by using only 100 labeled samples.
\begin{table}[h]
  \caption{Error rates (\%) on test set for MNIST (mean \%  std. dev).}
  \begin{center}
  \begin{tabular}{ c  c  c  c  c  c  c}
    & labeled & transform & mut-excl  & both & ladder & ladder net\\
 \rule[-1.2ex]{0pt}{0ex}	 &  data only  &  /stability loss &  loss \cite{mutualexclusive}  &   losses  & net. \cite{rasmus2015semi}  &  baseline \cite{rasmus2015semi} \\ \hline     
 \rule{0pt}{3ex}     100 :    &   5.44  1.48    &  0.76  0.61     &  3.92  1.12  &  {\bf 0.55  0.16} &  0.89  0.50  &  6.43  0.84 \\
                     all: &   0.32  0.02   &  0.29  0.02    &  0.30  0.03   &  {\bf 0.27  0.02} &   -  &  0.36 \\              
  \end{tabular}  
  \end{center}
  \label{tab5}
\end{table}
\vspace{-0.2cm}
\subsection{SVHN}
\vspace{-0.1cm}
SVHN is another digit classification task similar to MNIST. This dataset contains about 70000 images for training and more than 500000 easier images \cite{netzer2011reading} for validation. We do not use the validation set. The test set contains 26032 images, which are RGB images of size . Generally, SVHN is a more difficult task compared to MNIST because of the large variations in the images. We do not perform any pre-processing for this dataset. We simply convert the color images to grayscale by removing hue and saturation information. We perform experiments on this dataset using both cuda-convnet and sparse convolutional network implementations of the unsupervised loss function. 

In the first set of experiments, we use cuda-convnet to train models with different ratios of labeled and unlabeled data. We randomly choose 1\%, 5\%, 10\%, 20\% and 100\% of training samples as labeled data. All of the training samples are used as the unlabeled set. For each labeled set, we train four models using cuda-convnet. The first model uses labeled set only. The second model is trained on unlabeled set using mutual-exclusivity loss function in addition to the labeled set. The third model is trained on the unlabeled set using the transformation/stability loss function in addition to the labeled set. The last model is also trained on both sets but combines two unsupervised loss functions. Each experiment is repeated five times. For each repetition, we use a different subset of training samples as labeled data. The cuda-convnet model consists of two convolutional layers with 64 maps and kernel size of 5, two locally connected layers with 32 maps and kernel size 3. Each convolutional layer is followed by a max-pooling layer. A fully connected layer with 256 nodes is added before the last layer. We use data augmentation for these experiments.  of Eq. \ref{eq1} crops every training sample to  at random locations.  also randomly rotates training samples up to . These transformations are applied to both labeled and unlabeled sets. The results are shown in Figure \ref{fig1}. Each point in the graph is the mean error rate of five repetitions. The error bars show the standard deviation of these five repetitions. As expected, we can see that in all experiments the classification accuracy is improved as we add more labeled data. However, we observe that for each set of labeled data we can improve the results by using the proposed unsupervised loss functions. We can also see that when the number of labeled samples is small, the improvement is more significant. For example, when we use only 1\% of labeled data, we gain an improvement in accuracy of about 2.5 times by using unsupervised loss functions. As we add more labeled samples, the difference in accuracy between semi-supervised and supervised approaches becomes smaller. Note that the combination of transformation/stability loss function and mutual-exclusivity loss function improves the accuracy even further. As mentioned earlier, these two unsupervised loss functions complement each other. Therefore, in most of the experiments we use the combination of two unsupervised loss functions.

\begin{figure}[ht]
\centering
\begin{minipage}{.48\textwidth}
	\centering
	\includegraphics[width=\textwidth]{Figs/svhn2.pdf}
	\caption{SVHN dataset: semi-supervised learning vs. training with labeled data only.}
   	\label{fig1}    
\end{minipage}\hspace{0.5cm}\begin{minipage}{.48\textwidth}
	\centering
	\includegraphics[width=\textwidth]{Figs/norb2.pdf}
	\caption{NORB dataset: semi-supervised learning vs. training with labeled data only.}
   	\label{fig2} 
\end{minipage}
\end{figure}

We perform another set of experiments on SVHN dataset using sparse convolutional networks as a state-of-the-art classifier. We create five sets of labeled data. For each set, we randomly pick a different 1\% subset of training samples. We train two models: the first trained only on labeled data, and the second using the labeled set and a combination of both unsupervised losses. Similarly, we train models using all available training data as both the labeled set and unlabeled set. We do not use data augmentation for any of these experiments. In other words,  of Eq. \ref{eq1} is identity function. As a result, dropout and random max-pooling are the only sources of variation in this case. We use the following model:  Similar to MNIST, we use dropout to regularize the network. Again, the ratio of dropout gradually increases from the first layer to the last layer. The results are shown in Table \ref{tab3}. Here, we can see that by using unsupervised loss functions we can significantly improve the accuracy of the classifier by trying to minimize the variation in prediction of the network.
\begin{table}[h]
  \caption{Error rates on test data for SVHN with 1\% and 100\% labeled samples (mean \%  std. dev).}
  \begin{center}
  \begin{tabular}{ c  c  c }
 \rule[-1.2ex]{0pt}{0ex}		         &  1\% of labeled data & 100\% of labeled data \\ \hline     
 \rule{0pt}{3ex}     labeled data only:  &  12.25  0.80 &  2.28  0.05   \\
                      semi-supervised:   &  6.03   0.62 &  2.22  0.04   \\              
  \end{tabular}  
  \end{center}
  \label{tab3}
\end{table}
\vspace{-0.5cm}
\subsection{NORB}
\vspace{-0.1cm}
NORB is a collection of stereo images in six classes. The training set contains 10 folds of 29160 images. It is common practice to use only the first two folds for training. The test set contains two folds, totaling 58320. The original images are . However, we scale them down to  similar to \cite{ciresan2012multi}. We perform experiments on this dataset using both implementations of the proposed loss function. First, similar to SVHN, we use cuda-convnet to train models with different ratios of labeled and unlabeled data. Again, we randomly choose 1\%, 5\%, 10\%, 20\% and 100\% of training samples as labeled data, and all training samples are used as the unlabeled set. For each labeled set, we train the same four models as we did for SVHN. Each experiment is repeated five times, and for each repetition, we use a different subset of training samples as labeled data. The model parameters are the same as SVHN. We use data augmentation for these experiments.  of Eq. \ref{eq1} performs image translation by randomly cropping the training images to .  also randomly rotates training samples up to . These transformations are applied to both labeled and unlabeled sets. The results are shown in Figure \ref{fig2}. Each point in the graph is the mean error rate of five repetitions. The error bars show the standard deviation of these five repetitions. Similar to SVHN, we can see that using unsupervised loss functions improves the accuracy of the model without additional labeled data. Again, we can see the combination of both unsupervised loss functions improves the accuracy even further.

We also evaluate the proposed loss function on NORB using sparse convolutional networks. We use the same model parameters as SVHN. Again, we create five sets of labeled data containing 1\% of training samples, and each labeled set is a different subset of training data. First, we train models using the labeled set only, and then we train another set of models by optimizing unsupervised loss functions on unlabeled sets in addition to the labeled data. We also perform similar experiments using all training data as both labeled and unlabeled sets. We do not use data augmentation for these experiments meaning  of Eq. \ref{eq1} is identity function. Similar to SVHN, we are using the random effects of dropout and randomized max-pooling. The results are given in Table \ref{tab4}. Here again, we can see that it is possible to significantly improve the accuracy by minimizing the unsupervised loss functions when we have a small number of labeled samples. In this case, we can observe that by using only 1\% of labeled data and applying unsupervised loss functions, we can achieve accuracy that is close to the case when we use 100\% of labeled data.
\begin{table}[h]
  \caption{Error rates on test data for NORB with 1\% and 100\% labeled samples (mean \%  std. dev).}
  \begin{center}
  \begin{tabular}{ c  c  c }
 \rule[-1.2ex]{0pt}{0ex}		         &  1\% of labeled data & 100\% of labeled data \\ \hline     
 \rule{0pt}{3ex}     labeled data only:  &  10.01  0.81 &  1.63  0.12   \\
                      semi-supervised:   &  2.15  0.37  &  1.63  0.07   \\              
  \end{tabular}  
  \end{center}
  \label{tab4}
\end{table}
\vspace{-0.5cm}
\subsection{CIFAR10}
\vspace{-0.1cm}
CIFAR10 is a collection of 60000 tiny  images of 10 categories (50000 for training and 10000 for test). We use sparse convolutional networks to perform experiments on this dataset. For this dataset, we create 10 labeled sets. Each set contains 4000 samples that are randomly picked from the training set. All 50000 training samples are used as unlabeled set. We train two sets of models on these data. The first set of models is trained on labeled data only, and the other set of models is trained on the unlabeled set using a combination of both unsupervised loss functions in addition to the labeled set. For this dataset, we do not perform separate experiments for two unsupervised loss functions because of time constraints. However, based on the results from MNIST, SVHN and NORB, we deduce that the combination of both unsupervised losses provides improved accuracy. We use data augmentation for these experiments. Similar to \cite{graham2014fractional}, we perform affine transformations, including randomized mix of translations, rotations, flipping, stretching and shearing operations by  of Eq. \ref{eq1}. Similar to \cite{graham2014fractional}, we train the network without transformations for the last 10 epochs. We use the following parameters for the models:  We use dropout, and its ratio gradually increases from the first layer to the last layer. The results are given in Table \ref{tab1}. We also compare the results to ladder networks \cite{rasmus2015semi}. The model in \cite{rasmus2015semi} does not use data augmentation. We can see that the combination of unsupervised loss functions on unlabeled data improves the accuracy of the models.
\begin{table}[h]
  \caption{Error rates on test data for CIFAR10 with 4000 labeled samples (mean \%  std. dev).}
  \begin{center}
  \begin{tabular}{ c  c  c }
 \rule[-1.2ex]{0pt}{0ex}		         &  transformation/stability+mutual-exclusivity & ladder networks \cite{rasmus2015semi} \\ \hline     
 \rule{0pt}{3ex}     labeled data only:  &  13.60  0.24 &  23.33  0.61   \\
                      semi-supervised:   &  11.29  0.24 &  20.40  0.47   \\              
  \end{tabular}  
  \end{center}
  \label{tab1}
\end{table}
In another set of experiments, we use all available training data as both labeled and unlabeled sets. We train a network with the following parameters:  We use affine transformations for this task too. Here again, we use transformation/stability plus the mutual-exclusivity loss function. We repeat this experiments five times and achieve {\bf 3.18\%  0.1} mean and standard deviation error rate. The state-of-the-art error rate for this dataset is 3.47\%, achieved by the fractional max-pooling method \cite{graham2014fractional} but obtained with a larger model ( vs. ). We perform a single run experiment with  model and achieve the error rate of {\bf 3.00\%}. Similar to \cite{graham2014fractional}, we perform 100 passes during test time. Here, we surpass state-of-the-art accuracy by adding unsupervised loss functions.
\vspace{-0.2cm}
\subsection{CIFAR100}
\vspace{-0.1cm}
CIFAR100 is also a collection of  tiny images of size . This dataset is similar to CIFAR10. However, it contains images of 100 categories compared to 10. Therefore, we have a smaller number of training samples per category. Similar to CIFAR10, we perform experiments on this dataset using sparse convolutional networks. We use all available training data as both labeled and unlabeled sets. The state-of-the-art error rate for this dataset is 23.82\%, obtained by fractional max-pooling \cite{graham2014fractional} on sparse convolutional networks. The following model was used to achieve this error rate:  Dropout was also used with a ratio increasing from the first layer to the last layer. We use the same model parameters and add transformation/stability plus the mutual-exclusivity loss function. Similar to \cite{graham2014fractional}, we do not use data augmentation for this task ( of Eq. \ref{eq1} is identity function). Therefore, the proposed loss function minimizes the randomness effect due to dropout and max-pooling. We achieve {\bf 21.43\%  0.16} mean and standard deviation error rate, which is the state-of-the-art for this task. We perform 12 passes during the test time similar to \cite{graham2014fractional}.
\vspace{-0.2cm}
\subsection{ImageNet}
\vspace{-0.1cm}
We perform experiments on the ILSVRC 2012 challenge. The training data consists of 1281167 natural images of different sizes from 1000 categories. We create five labeled datasets from available training samples. Each dataset consists of 10\% of training data. We form each dataset by randomly picking a subset of training samples. All available training data is used as the unlabeled set. We use cuda-convnet to train AlexNet model \cite{krizhevsky2012imagenet} for this dataset. Similar to \cite{krizhevsky2012imagenet}, all images are re-sized to . We also use data augmentation for this task following steps of \cite{krizhevsky2012imagenet}, i.e.,  of Eq. \ref{eq1} performs random translations, flipping and color noise. We train two models on each labeled dataset. One model is trained using labeled data only. The other model is trained on both labeled and unlabeled set using the transformation/stability plus mutual-exclusivity loss function. We train the model for 20 epochs. The results on validation set are shown in Table \ref{tab2}. We also compare the results to the model trained on the mutual-exclusivity loss function only and reported in \cite{mutualexclusive}. We can see that even for a large dataset with many categories, the proposed unsupervised loss function improves the classification accuracy. The error rate of a single AlexNet model on validation set of ILSVRC 2012 using all training data is 18.2\% \cite{krizhevsky2012imagenet}.
\begin{table}[h]
  \caption{Error rates (\%) on validation set for ILSVR 2012 (Top-5).}
  \begin{center}
  \vspace{-0.5cm}
  \begin{tabular}{ c  c  c  c  c  c  c  c }
 \rule[-1.2ex]{0pt}{0ex}		         &  rep 1  &  rep 2  &   rep 3  & rep 4  &  rep 5 &  mean  std. dev. & mut-xcl \cite{mutualexclusive} \\ \hline     
 \rule{0pt}{3ex}     labeled data only:  &  45.73  &  46.15  &   46.06  & 45.57  &  46.08 &  45.91  0.25                    & 45.63 \\
                      semi-supervised:   &  39.50  &  39.99  &   39.94  & 39.70  &  40.08 &  39.84  0.23                     & 42.90               
  \end{tabular}  
  \end{center}
  \label{tab2}
\end{table}
\vspace{-0.6cm}
\section{Discussion}
\vspace{-0.1cm}
We can see that the proposed loss function can improve the accuracy of a ConvNet regardless of the architecture and implementation. We improve the accuracy of two relatively different implementations of ConvNets, i.e., cuda-convnet and sparse convolutional networks. For SVHN and NORB, we do not use dropout or randomized pooling for the experiments performed using cuda-convnet. Therefore, the only source of variation in different passes of a sample through the network is random transformations (translation and rotation). For the experiments performed using sparse convolutional networks on these two datasets, we do not use data transformation. Instead, we use dropout and randomized pooling. Based on the results, we can see that in both cases we can significantly improve the accuracy when we have a small number of labeled samples. For CIFAR100, we achieve state-of-the-art error rate of 21.43\% by taking advantage of the variations caused by dropout and randomized pooling. In ImageNet and CIFAR10 experiments, we use both data transformation and dropout. For CIFAR10, we also have randomized pooling and achieve the state-of-the-art error rate  of 3.00\%. In MNIST experiments with 100 labeled samples and NORB experiments with 1\% of labeled data, we achieve accuracy reasonably close to the case when we use all available training data by applying mutual-exclusivity loss and minimizing the difference in predictions of multiple passes caused by dropout and randomized pooling.
\vspace{-0.2cm}
\section{Conclusion}
\vspace{-0.1cm}
In this paper, we proposed an unsupervised loss function that minimizes the variations in different passes of a sample through the network caused by non-deterministic transformations and randomized dropout and max-pooling schemes. We evaluated the proposed method using two ConvNet implementations on multiple benchmark datasets. We showed that it is possible to achieve significant improvements in accuracy by using the transformation/stability loss function along with mutual-exclusivity of \cite{mutualexclusive} when we have a small number of labeled data available.

{\small
\bibliographystyle{ieeetr}
\bibliography{egbib}
}

\end{document}
