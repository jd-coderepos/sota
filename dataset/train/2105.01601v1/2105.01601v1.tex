\documentclass{article}

\usepackage[nonatbib, preprint]{neurips_2020}
\usepackage[numbers]{natbib}










\usepackage[utf8]{inputenc} \usepackage[T1]{fontenc}    \usepackage{hyperref}       \usepackage{url}            \usepackage{booktabs}       \usepackage{siunitx}        \usepackage{amsfonts}       \usepackage{nicefrac}       \usepackage{microtype}      

\usepackage{makecell}
\usepackage{amsmath,amsfonts,amssymb}
\usepackage{graphicx}
\usepackage{wrapfig}
\usepackage{tikz}
\usepackage{rotating}
\usepackage{subcaption}

\usepackage{wasysym}
\usepackage{marvosym}

\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage{setspace}

\usepackage{listings}
\usepackage{placeins}

\usepackage{xcolor}
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}

\lstset{style=mystyle}

\definecolor{darkgreen}{rgb}{0,0.4,0}
\definecolor{cerise}{rgb}{0.871, 0.192, 0.388}
\definecolor{carmine}{rgb}{0.59, 0.0, 0.09}

\newcommand{\ilya}[1]{{\color{darkgreen} Ilya: #1}}
\newcommand{\todo}[1]{\textcolor{blue}{TODO: #1}}
\newcommand{\note}[1]{\textcolor{red}{KEEP THIS NOTE: #1}}
\newcommand{\neil}[1]{\textcolor{cerise}{Neil: #1}}
\newcommand{\jessica}[1]{{\color{purple} Jessica: #1}}
\newcommand{\daniel}[1]{{\color{carmine} Daniel: #1}}
\newcommand{\thomas}[1]{{\color{teal} Thomas: #1}}
\newcommand{\ml}[1]{{\color{purple} Mario: #1}}

\definecolor{mixer}{rgb}{0.76, 0.50, 0.65}
\definecolor{cnn}{rgb}{0.94, 0.89, 0.38}
\definecolor{attention}{rgb}{0.18, 0.45, 0.68}

\newcommand{\MDot}{\raisebox{0.5pt}{\tikz\fill[mixer] (0,0) circle (.5ex);}}
\newcommand{\CDot}{\raisebox{0.5pt}{\tikz\fill[cnn] (0,0) circle (.5ex);}}
\newcommand{\ADot}{\raisebox{0.5pt}{\tikz\fill[attention] (0,0) circle (.5ex);}}

\newcommand{\fullname}{MLP-Mixer}
\newcommand{\name}{Mixer}


\title{\fullname{}: An all-MLP Architecture for Vision}



\author{\centerline{Ilya Tolstikhin, Neil Houlsby, Alexander Kolesnikov, Lucas Beyer,} \vspace{2mm}\\
    \centerline{\textbf{Xiaohua Zhai, Thomas Unterthiner, Jessica Yung, Daniel Keysers,}} \vspace{2mm}\\
    \centerline{\textbf{Jakob Uszkoreit, Mario Lucic, Alexey Dosovitskiy}} \vspace{1.5mm}\\
    \centerline{equal contribution} \vspace{1.5mm} \\
    \centerline{Google Research, Brain Team} \vspace{1.5mm} \\
    \centerline{\texttt{{\{tolstikhin, neilhoulsby, akolesnikov, lbeyer,}}} \\
    \centerline{\texttt{{xzhai, unterthiner, jessicayung, keysers,}}} \\
    \centerline{\texttt{{usz, lucic, adosovitskiy\}}@google.com}}
}


\begin{document}

\maketitle



\begin{abstract}
Convolutional Neural Networks (CNNs) are the go-to model for computer vision.
Recently, attention-based networks, such as the Vision Transformer, have also become popular.
In this paper we show that while convolutions and attention are both sufficient for good performance, neither of them are necessary.
We present \emph{\fullname{}}, an architecture based exclusively on multi-layer perceptrons (MLPs).
\fullname{} contains two types of layers: one with MLPs applied independently to image patches (i.e.\,``mixing'' the per-location features), and one with MLPs applied across patches (i.e.\,``mixing'' spatial information).
When trained on large datasets, or with modern regularization schemes, \fullname{} attains competitive scores on image classification benchmarks, with  pre-training and inference cost comparable to state-of-the-art models.
We hope that these results spark further research beyond the realms of well established CNNs and Transformers.\footnote{\fullname{} code will be available at \url{https://github.com/google-research/vision_transformer}}
\end{abstract}

\section{Introduction}

As the history of computer vision demonstrates, the availability of larger datasets coupled with increased computational capacity often leads to a paradigm shift.
While Convolutional Neural Networks (CNNs) have been the de-facto standard for computer vision, recently Vision Transformers~\citep{Dosovitskiy2021} (ViT), an alternative based on self-attention layers, attained state-of-the-art performance.
ViT continues the long-lasting trend of removing hand-crafted visual features and inductive biases from models and relies further on learning from raw data.

We propose the \emph{\fullname{}} architecture (or ``\name{}'' for short), a competitive but conceptually and technically simple alternative, that does not use convolutions or self-attention.
Instead, \name{}'s architecture is based entirely on multi-layer perceptrons (MLPs) that are repeatedly applied across either spatial locations or feature channels.
\name{} relies only on basic matrix multiplication routines, changes to data layout (reshapes and transpositions), and scalar non-linearities.
 
Figure~\ref{fig:architecture} depicts he macro-structure of \name{}. 
It accepts a sequence of linearly projected image patches (also referred to as \emph{tokens}) shaped as a ``patches\,\,channels'' table as an input, and maintains this dimensionality.
\name{} makes use of two types of MLP layers:  \emph{channel-mixing MLPs} and \emph{token-mixing MLPs}. 
The channel-mixing MLPs allow communication between different channels; they operate on each token independently and take individual rows of the table as inputs.
The token-mixing MLPs allow communication between different spatial locations (tokens); they operate on each channel independently and take individual columns of the table as inputs.
These two types of layers are interleaved to enable interaction of both input dimensions.

In the extreme case, our architecture can be seen as a very special CNN, which uses 11 convolutions for \emph{channel mixing}, and single-channel depth-wise convolutions of a full receptive field and parameter sharing for \emph{token mixing}.
However, the converse is not true as typical CNNs are not special cases of \name{}. Furthermore, a convolution is more complex than the plain matrix multiplication in MLPs as it requires an additional costly reduction to matrix multiplication and/or specialized implementation. 

Despite its simplicity, \name{} attains competitive results.
When pre-trained on large datasets (i.e.,  100M images), it reaches near state-of-the-art performance, previously claimed by CNNs and Transformers, in terms of the accuracy/cost trade-off.
This includes 87.94\% top-1 validation accuracy on ILSVRC2012 ``ImageNet''~\citep{deng2009-imagenet}.
When pre-trained on data of more modest scale (i.e., 1--10M images), coupled with modern regularization techniques~\cite{deit,rw2019timm}, \name{} also achieves strong performance.
However, similar to ViT, it falls slightly short of specialized CNN architectures.

\section{\name{} Architecture}

\begin{figure}[tb]
    \centering
    \includegraphics[width=1.0\linewidth]{pics/Mixer.pdf}
    \caption{
     \fullname{} consists of per-patch linear embeddings, \name{} layers, and a classifier head.
     \name{} layers contain one token-mixing MLP and one channel-mixing MLP, each consisting of two fully-connected layers and a GELU nonlinearity.
     Other components include: skip-connections, dropout, layer norm on the channels, and linear classifier head.
    }
  \label{fig:architecture}
\end{figure}


Modern deep vision architectures consist of layers that mix features (i) at a given spatial location, (ii) between different spatial locations, or both at once.
In CNNs, (ii) is implemented with  convolutions (for ) and pooling.
Neurons in deeper layers have a larger receptive field~\citep{araujo2019computing,luo2017understanding}.
At the same time, 11 convolutions also perform (i), and larger kernels perform both (i) and (ii).
In~Vision Transformers and other attention-based architectures, self-attention layers allow both (i) and (ii) and the MLP-blocks perform (i).
The idea behind the \name{} architecture is to clearly separate the per-location (\emph{channel-mixing}) operations (i) and cross-location (\emph{token-mixing}) operations (ii).
Both operations are implemented with MLPs.

Figure~\ref{fig:architecture} summarizes the architecture. 
\name{} takes as input a sequence of  non-overlapping image patches, each one projected to a desired \emph{hidden dimension} .
This results in a two-dimensional real-valued input table, .
If the original input image has resolution ,
and each patch has resolution ,
then the number of patches is .
All patches are linearly projected with the \emph{same} projection matrix.
\name{} consists of multiple layers of identical size, and each layer consists of two MLP blocks.
The first one is the \emph{token-mixing} MLP block: it acts on columns of  (i.e.\,it is applied to a transposed input table ), maps , and is shared across all columns.
The second one is the \emph{channel-mixing} MLP block: it acts on rows of , maps , and is shared across all rows.
Each MLP block contains two fully-connected layers and a non-linearity applied independently to each row of its input data tensor. 
\name{} layers can be written as follows (omitting layer indices):

Here  is an element-wise nonlinearity (GELU~\cite{hendrycks2016gelu}).
 and  are tunable hidden widths in the token-mixing and channel-mixing MLPs, respectively.
Note that  is selected independently of the number of input patches.
Therefore, the computational complexity of the network is linear in the number of input patches, unlike ViT whose complexity is quadratic.
Since  is independent of the patch size, the overall complexity is linear in the number of pixels in the image, as for a typical CNN.

As mentioned above, the \emph{same} channel-mixing MLP (token-mixing MLP) is applied to every row (column) of~.
Tying the parameters of the channel-mixing MLPs (within each layer) is a natural choice---it provides positional invariance, a prominent feature of convolutions.
However, tying  parameters across channels is much less common.
For example, separable convolutions \cite{chollet2017xception,Sifre2014phd}, used in some CNNs, apply convolutions to each channel independently of the other channels.
However, in separable convolutions, a different convolutional
kernel is applied to each channel unlike the token-mixing MLPs in \name{} that share the same kernel (of full receptive field) for all of the channels.
The parameter tying prevents the architecture from growing too fast when increasing the hidden dimension  or the sequence length  and leads to significant memory savings.
Surprisingly, this choice does not affect the empirical performance, see Supplementary~\ref{appendix:did-not-work}.

Each layer in \name{} (except for the initial patch projection layer) takes an input of the same size.
This ``isotropic'' design is most similar to Transformers, or deep RNNs in other domains, that also use a fixed width.
This is unlike most CNNs, which have a \emph{pyramidal} structure: deeper layers have a lower resolution input, but more channels.
Note that while these are the typical designs, other combinations exist, such as isotropic ResNets~\citep{Sandler2019} and pyramidal ViTs~\citep{wang2021pyramid}.

Aside from the MLP layers, \name{} uses other standard architectural components: skip-con\-nec\-tions~\cite{he2016deep} and Layer Normalization~\cite{ba2016layer}.
Furthermore, unlike ViTs, \name{} does not use position embeddings because the token-mixing MLPs are sensitive to the order of the input tokens, and therefore may learn to represent location.
Finally, \name{} uses a standard classification head with the global average pooling layer followed by a linear classifier. 
Overall, the architecture can be written compactly in JAX/Flax, the code is given in Supplementary~\ref{sec:app:code}.


\section{Experiments}
We evaluate the performance of \fullname{} models, pre-trained with medium- to large-scale datasets,
on a range of small and mid-sized downstream classification tasks.
We are interested in three primary quantities:
(1)~Accuracy on the downstream task.
(2)~\emph{Total} computational cost of pre-training, which is important when training the model from scratch on the upstream dataset.
(3)~Throughput at inference time, which is important to the practitioner.
Our goal is not to demonstrate state-of-the-art results, but to show that, remarkably, a simple MLP-based model is competitive with today's best convolutional and attention-based models.

\paragraph{Downstream tasks}
We use multiple popular downstream tasks such as ILSVRC2012 ``ImageNet'' (1.3M training examples, 1k classes) with the original validation labels~\citep{deng2009-imagenet} and cleaned-up ReaL labels~\citep{beyer2020-imagenet},
CIFAR-10/100 (50k examples, 10/100 classes)~\citep{Krizhevsky2009-cifar},
Oxford-IIIT Pets (3.7k examples, 36 classes)~\citep{parkhi2012-pets},
and Oxford Flowers-102 (2k examples, 102 classes)~\citep{Nilsback2008-flowers}.
We also evaluate on the Visual Task Adaptation Benchmark (VTAB-1k), which consists of 19 diverse datasets, each with 1k training examples~\citep{vtab}.

\paragraph{Pre-training data}
We follow the standard transfer learning setup: pre-training followed by fine-tuning on the downstream tasks.
We pre-train all models on two public datasets: 
ILSVRC2021~ImageNet, and ImageNet-21k, a superset of ILSVRC2012 that contains 21k classes and 14M images~\cite{deng2009-imagenet}.
To assess performance at even larger scale, we also train on JFT-300M, a proprietary dataset with 300M examples and 18k classes~\citep{sun2017-jft}.
We de-duplicate all pre-training datasets with respect to the test sets of the
downstream tasks as done in~\citet{Dosovitskiy2021,kolesnikov2020-bit}.

\paragraph{Pre-training details}
We pre-train all models using Adam with , , and
batch size 4\,096, using weight decay,
and gradient clipping at global norm 1.
We use a linear learning rate warmup of 10k steps and linear decay.
We pre-train all models at resolution 224.
For JFT-300M, we pre-process images by applying the cropping technique from~\citet{szegedy15inception} in addition to random horizontal flipping.
For ImageNet and ImageNet-21k, we employ additional data augmentation and regularization techniques. In particular, we use RandAugment~\cite{cubuk2020rand}, mixup~\cite{zhang2018mixup}, dropout~\cite{srivastava14dropout}, and stochastic depth~\cite{huang2016deep}. 
This set of techniques was inspired by the \emph{timm library}~\cite{rw2019timm} and~\citet{touvron2019}. 
More details on these hyperparameters are provided in Supplementary~\ref{sec:app:reg}.

\paragraph{Fine-tuning details}
We fine-tune using SGD with momentum, batch size 512,
gradient clipping at global norm 1,
and a cosine learning rate schedule with a linear warmup. 
We do not use weight decay when fine-tuning.
Following common practice \cite{kolesnikov2020-bit,touvron2019}, we also apply fine-tune at higher resolutions with respect to those used during pre-training.
Since we keep the patch resolution fixed, this increases the number of input patches (say from  to ) and thus requires modifying the shape of \name{}'s token-mixing MLP blocks.
Formally, the input in Eq.\,\eqref{eq:channel-wise-mlp} is left-multiplied by a weight matrix  and this operation has to be adjusted when changing the input dimension .
For this, we increase the hidden layer width from  to  in proportion to the number of patches and initialize the (now larger) weight matrix  with a block-diagonal matrix containing copies of  on its diagonal. 
See Supplementary~\ref{sec:app:fine-tuning} for more details.
On the VTAB-1k benchmark we follow the BiT-HyperRule~\cite{kolesnikov2020-bit} and fine-tune \name{} models at resolution 224 and 448 on the datasets with small and large input images respectively.

\paragraph{Metrics}
We evaluate the trade-off between the model's computational cost and quality.
For the former we compute two metrics:
(1)~Total pre-training time on TPU-v3 accelerators, which combines three relevant factors: the theoretical FLOPs for each training setup, the computational efficiency on the relevant training hardware, and the data efficiency.
(2)~Throughput in images/sec/core on TPU-v3. Since models of different sizes may benefit from different batch sizes, we sweep the batch sizes in  and report the highest throughput for each model.
For model quality, we focus on top-1 downstream accuracy after fine-tuning.
On one occasion (Figure~\ref{fig:compute-frontier}, right), where fine-tuning all of the models would have been too costly, we report the few-shot accuracies obtained by solving the -regularized linear regression problem between the frozen learned representations of images and the labels.

\newcommand{\pf}{\phantom{5}}

\begin{table}[tb]
  \caption{Specifications of the \name{} architectures used in this paper. 
  The ``B'', ``L'', and ``H'' (base, large, and huge) model scales follow~\citet{Dosovitskiy2021}.
  We use a brief notation: ``B/16'' means the model of base scale with patches of resolution 1616.
  ``S'' refers to a small scale with 8 \name{} layers.
  The number of parameters is reported for an input resolution of 224 and does not include the weights of the classifier head.
  }
  \medskip
  \label{table:architecture-configs}
  \centering
  \begin{tabular}{@{}lccccccc@{}}
    \toprule
    Specification & S/32 & S/16 & B/32 & B/16 & L/32 & L/16 & H/14\\
    \cmidrule{1-8}
    Number of layers & 8 & 8 & 12 & 12 & 24 & 24 & 32\\
    Patch resolution  & 3232 & 1616 & 3232 & 1616 & 3232 & 1616 & 1414\\
    Hidden size  & 512 & 512 & 768 & 768 & 1024 & 1024 & 1280\\
    Sequence length  & 49 & 196 & 49 & 196 & 49 & 196 & 256\\
    MLP dimension  & 2048 & 2048 & 3072 & 3072 & 4096 & 4096 & 5120\\
    MLP dimension  & 256 & 256 & 384 & 384 & 512 & 512 & 640\\
    Parameters (M) & 10 & 10 & 46 & 46 & 188 & 189 & 409\\
    \bottomrule
  \end{tabular}
\end{table}

\paragraph{Models}
We compare various configurations of \name{}, summarized in Table~\ref{table:architecture-configs}, to the most recent, state-of-the-art, CNNs and attention-based models.
In all the figures and tables, 
the MLP-based \name{} models are marked with pink~(\MDot{}),
convolution-based models with yellow~(\CDot{}), 
and attention-based models with blue~(\ADot{}).
The Vision Transformers (ViTs) have model scales and patch resolutions similar to \name{}, including ViT-L/16 and ViT-H/14.
HaloNets are attention-based models that use a ResNet-like structure with local self-attention layers instead of 33 convolutions~\citep{vaswani2021scaling}.
We focus on the particularly efficient ``HaloNet-H4 (base 128, Conv-12)'' model, which is a hybrid variant of the wider HaloNet-H4 architecture with some of the self-attention layers replaced by convolutions.
Note, we mark HaloNets with both attention and convolutions with blue~(\ADot{}).
Big Transfer (BiT)~\citep{kolesnikov2020-bit} models are ResNets optimized for transfer learning, pre-trained on ImageNet-21k or JFT-300M.
NFNets~\citep{brock2021high} are normalizer-free ResNets with several optimizations for ImageNet classification.
We consider the NFNet-F4+ model variant.
Finally, we consider MPL~\citep{pham2020meta} and ALIGN~\citep{jia2021scaling} for EfficientNet architectures. MPL is pre-trained at very large-scale on JFT-300M images, using meta-pseudo labelling from ImageNet instead of the original labels. We compare to the EfficientNet-B6-Wide model variant. ALIGN pre-train image encoder and language encoder on noisy web image text pairs in a contrastive way. We compare to their best EfficientNet-L2 image encoder.

\begin{table}[tb]
  \caption{
  Transfer performance, inference throughput, and training cost. 
  The rows are sorted by inference throughput (fifth column).
  \name{} has comparable transfer accuracy to state-of-the-art models with similar cost.
  The \name{} models are fine-tuned at resolution 448. \name{} performance numbers are averaged over three fine-tuning runs and standard deviations are smaller than .
  }
  \medskip
  \label{table:main-results-sota}
  \centering
  \begin{tabular}{@{}p{2.6cm}cccccc@{}}
    \toprule
    & ImNet & ReaL & Avg 5 & VTAB-1k & Throughput & TPUv3\\
    & top-1 & top-1 & top-1 & 19 tasks & {\small img/sec/core} & {\small core-days}\\
    \midrule \multicolumn{7}{c}{Pre-trained on ImageNet-21k (public)}\\
    \cmidrule{1-7}
    \ADot{} HaloNet \cite{vaswani2021scaling}  & 85.8\pf & --- & --- & --- & 120 & 0.10k\\
    \MDot{} \name{}-L/16  & 84.15 & 87.86 & 93.91 & 74.95 & 105 & 0.41k\\
    \ADot{} ViT-L/16 \cite{Dosovitskiy2021} & 85.30 & 88.62 & 94.39 & 72.72 & \pf32 & 0.18k\\
    \CDot{} BiT-R152x4 \cite{kolesnikov2020-bit} & 85.39 & --- & 94.04 & 70.64 & \pf26 & 0.94k\\
    \midrule \multicolumn{7}{c}{Pre-trained on JFT-300M (proprietary)}\\
    \cmidrule{1-7}
    \CDot{} NFNet-F4+ \cite{brock2021high} & 89.2\pf & --- & --- & --- & \pf46 & 1.86k\\
    \MDot{} \name{}-H/14  & 87.94 & 90.18 & 95.71 & 75.33 & \pf40 & 1.01k\\
    \CDot{} BiT-R152x4 \cite{kolesnikov2020-bit} & 87.54 & 90.54 & 95.33 & 76.29 & \pf26 & 9.9{0}k\\
    \ADot{} ViT-H/14 \cite{Dosovitskiy2021}  & 88.55 & 90.72 & 95.97 & 77.63 & \pf15 & 2.30k\\
    \midrule \multicolumn{7}{c}{Pre-trained on unlabelled or weakly labelled data (proprietary)}\\
    \cmidrule{1-7}
    \CDot{} MPL \cite{pham2020meta} & 90.0\pf & 91.12 & --- & --- & --- & \hspace{-1ex}20.48k\\
    \CDot{} ALIGN \cite{jia2021scaling} & 88.64 & --- & --- & 79.99 & 15 & \hspace{-1ex}14.82k\\
    \bottomrule
\end{tabular}
\end{table}


\subsection{Main results}
Table~\ref{table:main-results-sota} presents comparison of the largest \name{} models to state-of-the-art models from the literature.
``ImNet'' and ``ReaL'' columns refer to the original ImageNet validation labels~\citep{deng2009-imagenet} and cleaned-up ReaL labels~\citep{beyer2020-imagenet}.
``Avg.\,5'' stands for the average performance across all five downstream tasks (ImageNet, CIFAR-10, CIFAR-100, Pets, Flowers).
Figure~\ref{fig:main-sota-and-jft-fractions}~(left) visualizes the accuracy-compute~frontier.

When pre-trained on ImageNet-21k with additional regularization, \name{} achieves an overall strong performance (84.15\% top-1 on ImageNet), although slightly inferior to other models\footnote{
In Table~\ref{table:main-results-sota} we consider the highest accuracy models in each class, that use the largest resolutions (448 and above).
However, fine-tuning at smaller resolution leads to substantial improvements in the test-time throughput, with often only a small accuracy penalty.
For instance, when pre-training on ImageNet-21k
the \name{}-L/16 model fine-tuned at 224 resolution achieves 82.84\% ImageNet top-1 accuracy at throughput 420 img/sec/core;
the ViT-L/16 model fine-tuned at 384 resolution achieves 85.15\% at 80 img/sec/core \cite{Dosovitskiy2021};
and HaloNet fine-tuned at 384 resolution achieves 85.5\% at 258 img/sec/core \cite{vaswani2021scaling}.
}.
Regularization in this scenario is necessary and \name{} overfits without it, which is consistent with similar observations for ViT \cite{Dosovitskiy2021}.
We also report the results when training \name{} from scratch on ImageNet in Table~\ref{table:main-results-appendix} and the same conclusion holds.
Supplementary~\ref{sec:app:reg} details our regularization settings.

When the size of the upstream dataset increases, \name{}'s performance improves significantly.
In~particular, \name{}-H/14 achieves 87.94\% top-1 accuracy on ImageNet, which is 0.5\% better than BiT-ResNet152x4 and only 0.5\% lower than ViT-H/14.
Remarkably, \name{}-H/14 runs 2.5 times faster than ViT-H/14 and almost twice as fast as BiT. 
Overall, Figure~\ref{fig:main-sota-and-jft-fractions}~(left) supports our main claim that in terms of the accuracy-compute trade-off \name{} is competitive with more conventional neural network architectures. The figure also demonstrates a clear correlation between the total pre-training cost and the downstream accuracy, even across architecture classes.

BiT-ResNet152x4 in the table are pre-trained using SGD with momentum and a long schedule.
Since Adam tends to converge faster, we complete the picture in Figure~\ref{fig:main-sota-and-jft-fractions}~(left) with the BiT-R200x3 model from \citet{Dosovitskiy2021} pre-trained on JFT-300M using Adam.
This ResNet has a slightly lower accuracy, but considerably lower pre-training compute.
Finally, the results of smaller ViT-L/16 and \name{}-L/16 models are also reported in this figure.

\begin{figure}[tb]
\centering
\begin{subfigure}{.44\textwidth}
  \centering\vspace{-5pt}
  \includegraphics[width=0.96\linewidth]{pics/sota_frontier.pdf}
\end{subfigure}\begin{subfigure}{.55\textwidth}
  \centering
  \includegraphics[width=1.0\linewidth]{pics/data_frac_5shot.pdf}
\end{subfigure}
\caption{
  {\bf Left:}~ImageNet accuracy/training cost Pareto frontier (dashed line) for the SOTA models  presented in Table~\ref{table:main-results-sota}.
  These model are pre-trained on ImageNet-21k, or JFT (labelled, or pseudo-labelled for MPL), or noisy web image text pairs.
  In addition, we include ViT-L/16, \name{}-L/16, and BiT-R200x3 (Adam) for context.
  \name{} is as good as these extremely performant ResNets, ViTs, and hybrid models,
  and sits on frontier with HaloNet, ViT, NFNet, and MPL.
  {\bf Right:}~\name{} (solid) catches or exceeds BiT (dotted) and ViT (dashed) as the data size grows.
  Every point on a curve uses the same pre-training compute; they correspond to pre-training on 3\%, 10\%, 30\%, and 100\% of JFT-300M for 233, 70, 23, and 7 epochs, respectively.
  \name{} improves more rapidly with data than ResNets, or even ViT, and the gap between large scale \name{} and ViT models shrinks until the performance is matched on the entire dataset.
}
\label{fig:main-sota-and-jft-fractions}
\end{figure}

\begin{figure}[tb]
    \centering
    \includegraphics[width=.9\linewidth]{pics/finetune_vs_compute.pdf}
  \caption{
  The role of the model scale.
  ImageNet validation top-1 accuracy vs.\ total pre-training compute~({\bf left}) and throughput~({\bf right}) of ViT, BiT, and \name{} models at various scales.
  All models are pre-trained on JFT-300M and fine-tuned at resolution 224, which is lower than in Figure~\ref{fig:main-sota-and-jft-fractions}~(left).}
  \label{fig:compute-frontier}
\end{figure}

\subsection{The role of the model scale}
The results outlined in the previous section focus on (large) models at the upper end of the compute spectrum.
We now turn our attention to smaller \name{} models.

We may scale the model in two independent ways: 
(1)~Increasing the model size (number of layers, hidden dimension, MLP widths) when pre-training.
(2)~Increasing the input image resolution when fine-tuning.
While the former affects both pre-training compute and test-time throughput, the latter only affects the throughput.
Unless stated otherwise, we fine-tune at resolution 224.

\begin{table}[tbp]
  \caption{
  Performance of \name{} and other models from the literature across various model and pre-training dataset scales.
  ``Avg.\,5'' denotes the average performance across five downstream tasks and is presented where available.
  \name{} and ViT models are averaged over three fine-tuning runs and standard deviations are smaller than .
  ()~ViT models reported were fine-tuned with Polyak averaging \cite{polyak}.
  ()~Extrapolated from the numbers reported for the same models pre-trained on JFT-300M without extra regularization.
  (\Telefon) Numbers provided by authors of~\citet{Dosovitskiy2021} through personal communication.
  Rows are sorted by throughput.
  }
  \medskip
  \label{table:main-results-appendix}
  \centering
\begin{tabular}{@{}lccccc@{\;}S[table-number-alignment=right,group-digits=false,mode=text]@{\;}S[table-number-alignment=left,mode=text]@{}}
    \toprule
    & Image & Pre-Train & ImNet & ReaL & Avg.\,5 & {Throughput} & {TPUv3}\\
    & size & Epochs & top-1& top-1 & top-1 & {(img/sec/core)} & {~core-days~}\\
    \midrule \multicolumn{8}{c}{Pre-trained on ImageNet (with extra regularization)}\\
    \cmidrule{1-8}
    \MDot{} \name{}-B/16 & 224 & 300 & 76.44 & 82.36 & 88.33 & 1384 & 0.01k\\
    \ADot{} ViT-B/16 (\small{\Telefon}) & 224 & 300 & 79.67 & 84.97 & 90.79 & 861 & 0.02k\\
    \MDot{} \name{}-L/16 & 224 & 300 & 71.76 & 77.08 & 87.25 & 419 & 0.04k\\
    \ADot{} ViT-L/16 (\small{\Telefon})  & 224 & 300 & 76.11 & 80.93 & 89.66 & 280 & 0.05k\\
    \midrule \multicolumn{8}{c}{Pre-trained on ImageNet-21k (with extra regularization)}\\
    \cmidrule{1-8}
    \MDot{} \name{}-B/16 & 224 & 300 & 80.64 & 85.80 & 92.50 & 1384 & 0.15k\\
    \ADot{} ViT-B/16 (\small{\Telefon}) & 224 & 300 & 84.59 & 88.93 & 94.16 & 861 & 0.18k\\
    \MDot{} \name{}-L/16 & 224 & 300 & 82.89 & 87.54 & 93.63 & 419 & 0.41k\\
    \ADot{} ViT-L/16 (\small{\Telefon}) & 224 & 300 & 84.46 & 88.35 & 94.49 & 280 & 0.55k\\
    \MDot{} \name{}-L/16 & 448 & 300 & 83.91 & 87.75 & 93.86 & 105 & 0.41k\\
    \midrule \multicolumn{8}{c}{Pre-trained on JFT-300M}\\
    \cmidrule{1-8}
    \MDot{} \name{}-S/32 & 224 & \pf5 & 68.70 & 75.83 & 87.13 & 11489 & 0.01k\\
    \MDot{} \name{}-B/32 & 224 & \pf7 & 75.53 & 81.94 & 90.99 & 4208 & 0.05k\\
    \MDot{} \name{}-S/16 & 224 & \pf5 & 73.83 & 80.60 & 89.50 & 3994 & 0.03k\\
    \CDot{} BiT-R50x1  & 224 & \pf7 & 73.69 & 81.92 & --- & 2159 & 0.08k\\
    \MDot{} \name{}-B/16 & 224 & \pf7 & 80.00 & 85.56 & 92.60 & 1384 & 0.08k\\
    \MDot{} \name{}-L/32 & 224 & \pf7 & 80.67 & 85.62 & 93.24 & 1314 & 0.12k\\
    \CDot{} BiT-R152x1 & 224 & \pf7 & 79.12 & 86.12 & --- & 932 & 0.14k\\
    \CDot{} BiT-R50x2 & 224 & \pf7 & 78.92 & 86.06 & --- & 890 & 0.14k\\
    \CDot{} BiT-R152x2 & 224 & 14 & 83.34 & 88.90 & --- & 356 & 0.58k\\
    \MDot{} \name{}-L/16 & 224 & \pf7 & 84.05 & 88.14 & 94.51 & 419 & 0.23k\\
    \MDot{} \name{}-L/16 & 224 & 14 & 84.82 & 88.48 & 94.77 & 419 & 0.45k\\
    \ADot{} ViT-L/16 & 224 & 14 & 85.63 & 89.16 & 95.21 & 280 & 0.65k\\
    \MDot{} \name{}-H/14 & 224 & 14 & 86.32 & 89.14 & 95.49 & 194 & 1.01k\\
    \CDot{} BiT-R200x3 & 224 & 14 & 84.73 & 89.58 & --- & 141 & 1.78k\\
    \MDot{} \name{}-L/16 & 448 & 14 & 86.78 & 89.72 & 95.13 & 105 & 0.45k\\
    \ADot{} ViT-H/14 & 224 & 14 & 86.65 & 89.56 & 95.57 & 87 & 2.30k\\
    \MDot{} \name{}-H/14 & 448 & 14 & 87.78 & 90.08 & 95.62 & 40 & 1.01k\\
    \ADot{} ViT-L/16 \cite{Dosovitskiy2021} & 512 & 14 & 87.76 & 90.54 & 95.63 & 32 & 0.65k\\
    \CDot{} BiT-R152x4 \cite{kolesnikov2020-bit} & 480 & 40 & 87.54 & 90.54 & 95.33 & 26 & 9.90k\\
    \ADot{} ViT-H/14 \cite{Dosovitskiy2021} & 518 & 14 & 88.55 & 90.72 & 95.97 & 15 & 2.30k\\
    \bottomrule
  \end{tabular}
\end{table}

We compare various configurations of \name{} (see Table~\ref{table:architecture-configs}) to ViT models of similar scales and BiT models pre-trained with Adam. The results are summarized in Table~\ref{table:main-results-appendix} and Figure~\ref{fig:compute-frontier}.
When trained from scratch on ImageNet, \name{}-B/16 achieves a reasonable top-1 accuracy of 76.44\%. This is 3\% behind the ViT-B/16 model. The training curves (not reported) reveal that both models achieve very similar values of the training loss.
In other words, \name{}-B/16 overfits more than ViT-B/16.
For the \name{}-L/16 and ViT-L/16 models this difference is even more pronounced.

As the pre-training dataset grows, \name{}'s performance steadily improves.
Remarkably, \name{}-H/14 pre-trained on JFT-300M and fine-tuned at 224 resolution is only 0.3\% behind ViT-H/14 on ImageNet whilst running 2.2 times faster.
Figure~\ref{fig:compute-frontier} clearly demonstrates that although \name{} is slightly below the frontier on the lower end of model scales, it sits confidently on the frontier at the high end. 

\subsection{The role of the pre-training dataset size}

The results presented thus far demonstrate that pre-training on larger datasets significantly improves \name{}'s performance. Here, we study this effect in more detail.

To study \name{}'s ability to make use of the growing number of training examples we pre-train \name{}-B/32, \name{}-L/32, and \name{}-L/16 models on random subsets of JFT-300M containing 3\%, 10\%, 30\% and 100\% of all the training examples for 233, 70, 23, and 7 epochs. Thus, every model is pre-trained for the same number of total steps.
We use the linear 5-shot top-1 accuracy on ImageNet as a proxy for transfer quality.
For every pre-training run we perform early stopping based on the best upstream validation performance.
Results are reported in Figure~\ref{fig:main-sota-and-jft-fractions}~(right), where we also include ViT-B/32, ViT-L/32, ViT-L/16, and BiT-R152x2 models. 

When pre-trained on the smallest subset of JFT-300M, all \name{} models strongly overfit. 
BiT models also overfit, but to a lesser extent, possibly due to the strong inductive biases associated with the convolutions.
As the dataset increases, the performance of both \name{}-L/32 and \name{}-L/16 grows faster than BiT; \name{}-L/16 keeps improving, while the BiT model plateaus.

The same conclusions hold for ViT, consistent with \citet{Dosovitskiy2021}. However, the relative improvement of larger \name{} models are even more pronounced.
The performance gap between \name{}-L/16 and ViT-L/16 shrinks with data scale.
It appears that \name{} models benefit from the growing pre-training dataset size even more than ViT. 
One could speculate and explain it again with the difference in inductive biases. Perhaps, self-attention layers in ViT lead to certain properties of the learned functions that are \emph{less compatible} with the true underlying distribution than those discovered with \name{} architecture.

\begin{figure}[tb]
    \centering
    \includegraphics[width=0.31\linewidth]{pics/weightvisualization_b16_block0.pdf}\hfill
    \includegraphics[width=0.31\linewidth]{pics/weightvisualization_b16_block1.pdf}\hfill
    \includegraphics[width=0.31\linewidth]{pics/weightvisualization_b16_block2.pdf} 
    \caption{
     A selection of input weights to the hidden units in the first ({\bf left}), second ({\bf center}), and third ({\bf right}) token-mixing MLPs of a \name{}-B/16 model trained on JFT-300M.
     Each unit has  weights, one for each of the  incoming patches. 
     We pair units whose inverse is closest, to easily visualize the emergence of kernels of opposing phase.
     Pairs are sorted approximately by filter frequency.
     We highlight that in contrast to the kernels of convolutional filters, where each weight corresponds to one pixel in the input image, one weight in any plot from the left column corresponds to a particular  patch of the input image. 
     Complete plots in Supplementary~\ref{sec:app:weightvisualizations}.
    }
  \label{fig:weight-plots}
\end{figure}

\subsection{Visualization}
It is commonly observed that the first layers of CNNs tend to learn Gabor-like detectors that act on pixels in local regions of the image. In contrast, \name{} allows for global information exchange in the token-mixing MLPs, which begs the question whether it processes information in a similar fashion.

Figure~\ref{fig:weight-plots} shows the weights in the first few token-mixing MLPs of \name{} trained on JFT-300M. 
Recall that the token-mixing MLPs allow communication between different spatial locations (see Figure~\ref{fig:architecture}). 
Some of the learned features operate on the entire image, while others operate on smaller regions. 
The~first token-mixing MLP contains many local interactions, while the second and third layers contain more mixing across larger regions.
Higher layers appear to have no clearly identifiable structure. 
Similar to CNNs, we observe that many of the low-level feature detectors appear in pairs with opposite phases~\cite{shang2016crelu}.
In Supplementary~\ref{sec:app:weightvisualizations}, we show that the structure of learned units depends on the hyperparameters and input augmentations.
In the linear projection of the first patch embedding layer we observe a mixture of high and low frequency filters; we provide a visualization in Supplementary Figure~\ref{fig:embedding-plots}.


\section{Related Work}

\name{} is a new architecture for computer vision that differs from previous successful architectures because it uses neither convolutional nor self-attention layers. Nevertheless, the design choices can be traced back to ideas from the literature on  CNNs~\cite{KrizhevskyNIPS12,LeCun1989BackpropagationAT} and Transformers~\cite{vaswani2017}.

CNNs have been the de facto standard in computer vision field since the AlexNet model~\cite{KrizhevskyNIPS12} surpassed prevailing approaches based on hand-crafted image features, see~\cite{pinz2006object} for an overview.
An enormous amount of work followed, focusing on improving the design of CNNs. 
We highlight only the directions most relevant for this work. 
\citet{simonyan2014very} demonstrated that a series of convolutions with a small 33 receptive field is sufficient to train state-of-the-art models. 
Later, \citet{he2016deep} introduced skip-connections together with the batch normalization layer~\cite{ioffe2015batch}, which enabled training of very deep neural networks with hundreds of layers and further improved performance.
A prominent line of research has investigated the benefits of using sparse convolutions, such as grouped~\cite{Xie2016} or depth-wise~\cite{chollet2017xception,howard2017mobilenets} variants. 
Finally, \citet{hu2018squeeze} and \citet{wang2018-nonlocalnn} propose to augment convolutional networks with non-local operations to partially alleviate the constraint of local processing from CNNs.

\name{} takes the idea of using convolutions with small kernels to the extreme: by reducing the kernel size to 11 it effectively turns convolutions into standard dense matrix multiplications applied independently to each spatial location (channel-mixing MLPs).
This modification alone does not allow aggregation of spatial information and to compensate we apply dense matrix multiplications that are applied to every feature across all spatial locations (token-mixing MLPs). 
In \name{}, matrix multiplications are applied row-wise or column-wise on the ``patchesfeatures'' input table, which is also closely related to the work on sparse convolutions. Finally, \name{} makes use of skip-connections~\cite{he2016deep} and normalization layers~\cite{ba2016layer,ioffe2015batch}.

The initial applications of self-attention based Transformer architectures to computer vision were for generative modeling~\cite{child2019-sparsetransformers,parmar18-imagetransformer}.
Their value for image recognition was demonstrated later, albeit in combination with a convolution-like locality bias~\cite{ramachandran19-sasa}, or on very low-resolution images~\cite{cordonnier2020-sacnn}.
Recently, \citet{Dosovitskiy2021} introduced ViT, a pure transformer model that has fewer locality biases, but scales well to large data. 
ViT achieves state-of-the-art performance on popular vision benchmarks while retaining the robustness properties of CNNs~\cite{bhojanapalli2021understanding}. 
\citet{deit} showed that ViT can be trained effectively on smaller datasets using extensive regularization.
\name{} borrows design choices from recent transformer-based architectures; the design of MLP-blocks used in \name{} originates from~\citet{vaswani2017}.
Further, converting images to a sequence of patches and then directly processing embeddings of these patches originates in~\citet{Dosovitskiy2021}.

Similar to \name{}, many recent works strive to design more effective architectures for vision. 
For example, \citet{srinivas2021bottleneck} replace 33 convolutions in ResNets by self-attention layers.
\citet{ramachandran19-sasa}, \citet{li2021involution}, and \citet{bello2021lambdanetworks} design networks that work well with new attention-like mechanisms. 
\name{} can be seen as a step in an orthogonal direction, without reliance on locality bias and attention mechanisms.

\citet{neyshabur2020towards} is closely related.
The authors devise custom regularization and optimization algorithms, to train a fully-connected network for vision. It attains reasonable performance on small-scale image classification tasks. Our architecture instead relies on token-mixing and channel-mixing MLPs, uses standard regularization and optimization techniques, and scales to large data effectively. 

Traditionally, networks evaluated on ImageNet~\citep{deng2009-imagenet} are trained from-scratch using Inception-style pre-processing~\citep{inception}.
For smaller datasets, transfer of ImageNet models is popular.
However, modern state-of-the-art models typically use either weights pre-trained on larger datasets, or more recent data-augmentation and training strategies.
For example, \citet{Dosovitskiy2021,kolesnikov2020-bit,mahajan2018,pham2020meta,xie2020-noisystudent} all advance the state of the art in image classification using large-scale pre-trained weights.
Examples of improvements due to augmentation or regularization changes include \citet{autoaugment}, who attain excellent classification performance with learned data augmentation, and \citet{bello2021revisiting}, who show that canonical ResNets are still near the state of the art, if one uses recent training and augmentation strategies.

\section{Conclusions}
We describe a very simple architecture for vision.
Our experiments demonstrate that it is as good as existing state-of-the-art methods in terms of the trade-off between accuracy and computational resources required for training and inference.
We believe these results open many questions.
On the practical side, it may be useful to study the features learned by the model and identify the main differences (if any) from those learned by CNNs and Transformers.
On the theoretical side, we would like to understand the inductive biases hidden in these various features and eventually their role in generalization.
Most of all, we hope that our results spark further research, beyond the realms of established models based on convolutions and self-attention.
It would be particularly interesting to see whether such a design works in NLP or other domains.

\textbf{Acknowledgments.} The work was performed in the Brain teams in Berlin and Z\"urich.
We thank Josip Djolonga for feedback on the initial version of the paper; 
Olivier Bousquet, Yann Dauphin, and Dirk Weissenborn for useful discussions;
Andreas Steiner for the help with opensourcing the~code.
 

\bibliographystyle{abbrvnat}  \bibliography{mixer2021bibliography}

\appendix
\section{Things that did not help}

\subsection{Modifying the token-mixing MLPs}
\label{appendix:did-not-work}

We ablated a number of ideas trying to improve the token-mixing MLPs for \name{} models of various scales pre-trained on JFT-300M.

\paragraph{Untying (not sharing) the parameters}

Token-mixing MLPs in the \name{} layer are shared across the columns of the input table .
In other words, the \emph{same} MLP is applied to each of the  different features.
Instead, we could introduce  \emph{separate} MLPs with independent weights, effectively multiplying the number of parameters by .
We did not observe any noticeable improvements.

\paragraph{Grouping the channels together}

Token-mixing MLPs take -dimensional vectors as inputs.
Every such vector contains values of a single feature across  different spatial locations.
In other words, token-mixing MLPs operate by looking at only \emph{one channel} at once.
One could instead group channels together by concatenating  neighbouring columns in , reshaping it to a matrix of dimension .
This increases the MLP's input dimensionality from  to  and reduces the number of vectors to be processed from  to .
Now the MLPs look at \emph{several channels at once} when mixing the tokens.
This concatenation of the column-vectors improved linear 5-shot top-1 accuracy on ImageNet by less than 1--2\%.

We tried a different version, where we replace the simple reshaping described above with the following:
(1) Introduce  linear functions (with trainable parameters) projecting  to .
(2) Using them, map each of the  rows (tokens) in  to  different -dimensional vectors.
This results in  different ``views'' on every token, each one consisting of  features.
(3)~Finally, concatenate vectors corresponding to  different views for each of the  features. This results in a matrix of dimension .
The idea is that MLPs can look at  different \emph{views} of the original channels, when mixing the tokens.
This version improved the top-5 ImageNet accuracy by 3--4\% for the \name{}-S/32 architecture, however did not show any improvements for the larger scales.

\paragraph{Pyramids}
All layers in \name{} retain the same, isotropic design.
Recent improvements on the ViT architecture hint that this might not be ideal~\citep{wang2021pyramid}.
We tried using the token-mixing MLP to reduce the number of tokens by mapping from  input tokens to  output tokens.
While first experiments showed that on JFT-300M such models significantly reduced training time without losing much performance, we were unable to transfer these findings to ImageNet or ImageNet-21k.
However, since pyramids are a popular design, exploring this design for other vision tasks may still be promising.

\subsection{Fine-tuning}
Following ideas from BiT \cite{kolesnikov2020-bit} and ViT \cite{Dosovitskiy2021}, we also tried using mixup~\cite{zhang2018mixup} and Polyak averaging~\cite{polyak} during fine-tuning. 
However, these did not lead to consistent improvements, so we dropped them. 
We also experimented with using inception cropping \cite{szegedy15inception} during fine-tuning, which also did not lead to any improvements.
We did these experiments for JFT-300M pre-trained \name{} models of all scales.


\section{Pre-training: hyperparameters, data augmentation and regularization}~\label{sec:app:reg}

In Table~\ref{table:reg} we describe 
optimal hyperparameter settings that were used for pre-training \name{} models.

For pre-training on ImageNet and ImageNet-21k we used additional augmentation and regularization.
For RandAugment~\cite{cubuk2020rand} we always use two augmentations layers and sweep magnitude, , parameter in a set . For mixup~\cite{zhang2018mixup} we sweep mixing strength, , in a set . For dropout~\cite{srivastava14dropout} we try dropping rates,  of  and . For stochastic depth, following the original paper~\cite{huang2016deep}, we linearly increase the probability of dropping a layer from  (for the first MLP) to  (for the last MLP), where we try . Finally, we sweep learning rate, , and weight decay, , from  and  respectively. 

\begin{table}
  \caption{Hyperparameter settings used for pre-training \name{} models.}
  \medskip
  \label{table:reg}
  \centering
  \begin{tabular}{@{}llccccccc@{}}
    \toprule
    Model & Dataset & Epochs &  &  & \hspace{-1ex}RandAug. & Mixup & Dropout & \hspace{-1ex}Stoch.\,depth  \\
    \cmidrule{1-9}
    \name{}-B & ImNet & 300 & 0.001 & 0.1 &  15 & 0.5 & 0.0 & 0.1 \\
    \name{}-L & ImNet & 300 & 0.001 & 0.1 &  15 & 0.5 & 0.0 & 0.1 \\
    \name{}-B & ImNet-21k\hspace{-1ex} & 300 & 0.001 & 0.1 & 10 & 0.2 & 0.0 & 0.1 \\
    \name{}-L & ImNet-21k\hspace{-1ex} & 300 & 0.001 & 0.1 & 20 & 0.5 & 0.0 & 0.1 \\
    \name{}-S& JFT-300M & 5 & 0.003 & 0.03 &  -- & -- & -- & -- \\
    \name{}-B& JFT-300M & 7 & 0.003 & 0.03 &  -- & -- & -- & -- \\
    \name{}-L& JFT-300M & 7/14 & 0.001 & 0.03 &  -- & -- & -- & -- \\
    \name{}-H& JFT-300M & 14 & 0.001 & 0.03 &  -- & -- & -- & -- \\
    \bottomrule
  \end{tabular}
\end{table}

\section{Fine-tuning: hyperparameters and higher image resolution}
Models are fine-tuned at resolution 224 unless mentioned otherwise.
\label{sec:app:fine-tuning}
We follow the setup of~\cite{Dosovitskiy2021}.
The only differences are:
(1) We exclude  from the grid search and instead include  for CIFAR-10, CIFAR-100, Flowers, and Pets.
(2) We perform a grid search over  for VTAB-1k.
(3) We try two different ways of pre-processing during evaluation:
(i) ``resize-crop'': first resize the image to  pixels and then take a  pixel sized central crop.
(ii) ``resmall-crop'': first resize the shorter side of the image to  pixels and then take a  pixel sized central crop.
For the \name{} and ViT models reported in Table~\ref{table:main-results-appendix} we used (ii) on ImageNet, Pets, Flowers, CIFAR-10 and CIFAR-100.
We used the same setup for the BiT models reported in Table~\ref{table:main-results-appendix}, with the only exception of using (i) on ImageNet.
For the \name{} models reported in Table~\ref{table:main-results-sota} we used (i) for all 5 downstream datasets.


Fine-tuning at higher resolution than the one used at pre-training time has been shown to substantially improve the transfer performance of existing vision models~\citep{touvron2019,kolesnikov2020-bit,Dosovitskiy2021}.
We therefore apply this technique to \name{} as well. 
When feeding images of higher resolution to the model, we do not change the patch size, which results in a longer sequence of tokens.
The token-mixing MLPs have to be adjusted to handle these longer sequences.
We experimented with several options and describe the most successful one below.

For simplicity we assume that the image resolution is increased by an integer factor~.
The length  of the token sequence increases by a factor of .
We increase the hidden width  of the token-mixing MLP by a factor of  as well.
Now we need to initialize the parameters of this new (larger) MLP with the parameters of the pre-trained MLP.
To this end we split the input sequence into  equal parts, each one of the original length , and initialize the new MLP so that it processes all these parts independently in parallel with the pre-trained MLP.

Formally, the pre-trained weight matrix  of the original MLP in Eq.\,\ref{eq:channel-wise-mlp}
will be now replaced with a larger matrix .
Assume the token sequence for the resized input image is a concatenation of  token sequences of length  each, computed by splitting the input into  equal parts spatially.
We then initialize  with a block-diagonal matrix that has copies of  on its main diagonal.
Other parameters of the MLP are handled analogously.

\section{Weight Visualizations}\label{sec:app:weightvisualizations}
For better visualization, we sort all hidden units according to a heuristic that tries to show low frequency filters first.
For each unit, we also try to identify the unit that is closest to its inverse. Figure~\ref{fig:weight-plots-full} shows each unit followed by its closest inverse.
Note that the models pre-trained on ImageNet and ImageNet-21k used heavy data augmentation.
We found that this strongly influences the structure of the learned units.

\begin{figure}[t]
    \includegraphics[width=1.0\linewidth]{pics/weightvisualization_b16_full.pdf}
    \caption{Weights of all hidden dense units in the first two token-mixing MLPs ({\bf rows}) of the \name{}-B/16 model trained on three different datasets ({\bf columns}). 
    Each unit has  weights, which is the number of incoming tokens, and is depicted as a  image.
    In each block there are 384 hidden units in total.
    }
  \label{fig:weight-plots-full}
\end{figure}

We also visualize the linear projection units in the embedding layer learned by different models in Figure~\ref{fig:embedding-plots}. 
Interestingly, it appears that their properties strongly depend on the patch resolution used by the models.
Across all \name{} model scales, using patches of higher resolution 3232 leads to Gabor-like low-frequency linear projection units, while for the 1616 resolution the units show no such structure.

\begin{figure}[t]
    \includegraphics[width=0.49\linewidth]{pics/embedding_visualization_b16_jft300m.pdf}\hfill
    \includegraphics[width=0.49\linewidth]{pics/embedding_visualization_b32_jft300m.pdf}
    \caption{Linear projection units of the embedding layer for \name{}-B/16 ({\bf left}) and \name{}-B/32~({\bf right}) models pre-trained on JFT-300M.
    \name{}-B/32 model that uses patches of higher resolution  learns very structured low frequency projection units, while most of the units learned by the \name{}-B/16 have high frequencies and no clear structure.
    }
  \label{fig:embedding-plots}
\end{figure}

\FloatBarrier

\section{MLP-Mixer code}
\label{sec:app:code}

\begin{lstlisting}[language=Python, caption=MLP-Mixer code written in JAX/Flax.]
import einops
import flax.linen as nn
import jax.numpy as jnp

class MlpBlock(nn.Module):
  mlp_dim: int
  @nn.compact
  def __call__(self, x):
    y = nn.Dense(self.mlp_dim)(x)
    y = nn.gelu(y)
    return nn.Dense(x.shape[-1])(y)

class MixerBlock(nn.Module):
  tokens_mlp_dim: int
  channels_mlp_dim: int
  @nn.compact
  def __call__(self, x):
    y = nn.LayerNorm()(x)
    y = jnp.swapaxes(y, 1, 2)
    y = MlpBlock(self.tokens_mlp_dim, name='token_mixing')(y)
    y = jnp.swapaxes(y, 1, 2)
    x = x+y
    y = nn.LayerNorm()(x)
    return x+MlpBlock(self.channels_mlp_dim, name='channel_mixing')(y)

class MlpMixer(nn.Module):
  num_classes: int
  num_blocks: int
  patch_size: int
  hidden_dim: int
  tokens_mlp_dim: int
  channels_mlp_dim: int
  @nn.compact
  def __call__(self, x):
    s = self.patch_size
    x = nn.Conv(self.hidden_dim, (s,s), strides=(s,s), name='stem')(x)
    x = einops.rearrange(x, 'n h w c -> n (h w) c')
    for _ in range(self.num_blocks):
      x = MixerBlock(self.tokens_mlp_dim, self.channels_mlp_dim)(x)
    x = nn.LayerNorm(name='pre_head_layer_norm')(x)
    x = jnp.mean(x, axis=1)
    return nn.Dense(self.num_classes, name='head',
                    kernel_init=nn.initializers.zeros)(x)

\end{lstlisting}
 \end{document}