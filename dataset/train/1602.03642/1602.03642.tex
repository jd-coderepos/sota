\documentclass{llncs}
\pagestyle{plain}
\usepackage[utf8]{inputenc}
\usepackage{amssymb, amsfonts, amsmath, bm, mathtools}
\usepackage{url}
\usepackage{fullpage}
\usepackage{xspace}
\usepackage{tikz,pgfplots,xcolor}
\usepackage{color}
\usepackage{hyperref}
\usepackage{array}
\usepackage{enumitem}
\allowdisplaybreaks


\let\proof\relax	\let\endproof\relax
\usepackage{amsthm} 	\usepackage{thmtools} 	


\definecolor{light-gray}{gray}{0.95}

\declaretheoremstyle[
    spaceabove=6pt, spacebelow=6pt,
    headfont=\normalfont\bfseries,
    bodyfont=\normalfont\itshape,
    notefont=\normalfont\bfseries, notebraces={(}{)},
    postheadspace=.5em,
mdframed={
  		hidealllines=true,
  		skipabove=10pt,
  		backgroundcolor=light-gray,
		innerrightmargin=2pt,
		innerleftmargin=2pt,
		innertopmargin=0pt,
		innerbottommargin=2pt,
 		leftmargin=0pt,
 		rightmargin=0pt,
 	 }
]{mathstyle}

\declaretheorem[name={Theorem}, 
    style=mathstyle
]{thm}

\declaretheorem[name={Lemma}, 
    style=mathstyle
]{lem}

\declaretheorem[name={Definition},
    style=mathstyle
]{defi}


\title{Access Control Encryption: \\ Enforcing Information Flow with Cryptography
\thanks{This project was supported by: the Danish National Research Foundation and The National Science Foundation of China (grant 61361136003) for the Sino-Danish Center for the Theory of Interactive Computation.}
\thanks{Full version of TCC 2016-B paper~\cite{ACE-TCC2016B}}}
\author{Ivan Damg{\aa}rd \and Helene Haagh \and Claudio Orlandi}
\institute{\{ivan,haagh,orlandi\}@cs.au.dk, Aarhus University}
\begin{document}

\maketitle
\newcommand{\todo}[1]{\textcolor{red}{(TODO: #1)}}
\newcommand{\hfh}[1]{\textcolor{green}{(Helene: #1)}}
\newcommand{\cnote}[1]{\textcolor{blue}{(Claudio: #1)}}

\newcommand{\from}{\leftarrow}
\newcommand{\zo}{\{0,1\}}
\newcommand{\zon}{\{0,1\}^n}
\newcommand{\zok}{\{0,1\}^\kappa}

\newcommand{\RR}{\mathbb{R}}
\newcommand{\NN}{\mathbb{N}}
\newcommand{\San}{\mathsf{San}}
\newcommand{\negl}{\mathsf{negl}}

\newtheorem{construction}{Construction}



\newcommand{\Setup}{\mathsf{Setup}}
\newcommand{\Gen}{\mathsf{Gen}}
\newcommand{\Enc}{\mathsf{Enc}}
\newcommand{\Dec}{\mathsf{Dec}}
\newcommand{\randDec}{\mathsf{RDec}}
\newcommand{\Prove}{\mathsf{Prove}}
\newcommand{\Verify}{\mathsf{Verify}}
\newcommand{\M}{\mathcal{M}}
\newcommand{\sen}{\mathsf{sen}}
\newcommand{\rec}{\mathsf{rec}}
\newcommand{\san}{\mathsf{san}}
\newcommand{\C}{\mathcal{C}}
\newcommand{\Sim}{\mathsf{Sim}}

\newcommand{\Rand}{\San}
\newcommand{\PKE}{\mathsf{PKE}}
\newcommand{\secparam}{\kappa}
\newcommand{\ACE}{\mathsf{ACE}}

\newcommand{\desc}{\textup{desc}}

\newcommand{\oACE}{-ACE\xspace}

\newcommand{\oneACE}{\mathsf{1ACE}}
\newcommand{\oneACEpow}{\mathsf{1ACE}}
\newcommand{\EGACE}{\mathsf{EGACE}}

\newcommand{\CCG}{\mathsf{Challenge}}


\newcommand{\sanFE}{\mathsf{sFE}}
\newcommand{\sanFEpow}{\mathsf{sFE}}
\newcommand{\sanPKE}{\mathsf{sPKE}}
\newcommand{\NIZK}{\mathsf{NIZK}}
\newcommand{\PRF}{\mathsf{PRF}}

\newcommand{\R}{\mathcal{R}}
\newcommand{\MasterDec}{\mathsf{MDec}}
\newcommand{\adv}[1]{\mathsf{adv}^{#1}} 

\newcommand{\sssprob}{p_{sss}}

\newcounter{claimcounter}
\renewenvironment{claim}{
	\refstepcounter{claimcounter}
	\medskip
	\noindent \textit{Claim~\arabic{claimcounter}}. \enskip
}{

}


\begin{abstract}
We initiate the study of \emph{Access Control Encryption (ACE)}, a novel cryptographic primitive that allows fine-grained access control, by giving different rights to different users not only in terms of which messages they are allowed to \emph{receive}, but also which messages they are allowed to \emph{send}.

Classical examples of security policies for information flow are the well known Bell-Lapadula~\cite{lapadula1996secure} or Biba~\cite{biba} model: in a nutshell, the Bell-Lapadula model assigns roles to every user in the system  (e.g., \emph{public}, \emph{secret} and \emph{top-secret}). A users' role specifies which messages the user is allowed to receive (i.e., the \emph{no read-up} rule, meaning that users with \emph{public} clearance should not be able to read messages marked as \emph{secret} or \emph{top-secret}) but also which messages the user is allowed to send (i.e., the \emph{no write-down} 
rule, meaning that a malicious user with \emph{top-secret} clearance should not be able to write messages marked as 
\emph{secret} or \emph{public}). To the best of our knowledge, no existing cryptographic primitive allows for even this 
simple form of access control, since no existing cryptographic primitive enforces any restriction on what 
kind of messages one should be able to encrypt. Our contributions are:
\begin{itemize}
\item Introducing and formally defining access control encryption (ACE);
\item A construction of ACE with complexity linear in the number of the roles based on classic number theoretic assumptions (DDH, Paillier);
\item A construction of ACE with complexity polylogarithmic in the number of roles based on recent results 
on cryptographic obfuscation;
\end{itemize}
\end{abstract}




\section{Introduction}

Traditionally, cryptography has been about providing secure communication over insecure channels. We want to 
protect honest parties from external adversaries: only the party who has the decryption key can access 
the message. More recently, more complicated situations have been considered, where we do not want to trust 
everybody with the same information: depending on who you are and which keys you have, you can access 
different parts of the information sent (this can be done using, e.g., functional 
encryption~\cite{DBLP:conf/tcc/BonehSW11}).

However, practitioners who build secure systems in real life are often interested in achieving different and 
stronger properties: one wants to control the information flow in the system, and this is not just about 
what you can receive, but also about what you can send. As an example, one may think of the first security 
policy model ever proposed, the one by Bell and Lapadula \cite{lapadula1996secure}. Slightly simplified,  
this model classifies users of a system in a number of levels, from ``public''  in the bottom to 
``top-secret'' on top. Then two rules are defined: 1) ``no read-up'' -- a user is not allowed to receive
 data from higher levels and 2) ``no write-down'' -- a user is not allowed to send data to lower levels. 
 The idea is of course to ensure confidentiality: data can flow from the bottom towards the top, but not in
 the other direction. Clearly, 
both rules are necessary, in particular we need no write-down, since a party on top-secret level may try to 
send information she should not, either by mistake or because her machine has been infected by a virus.

In this paper we study the question of whether cryptography can help in enforcing such security policies.
A first thing to realize is that this problem cannot be solved without some assumptions about physical, 
i.e.,  non-cryptographic security: if the communication lines cannot be controlled, we cannot prevent a 
malicious user 
from sending information to the wrong place. We therefore must introduce a party that controls
the communication, which we will call the 
\emph{sanitizer} . We assume that all outgoing communication must pass through this party. 
 can then be instructed to do some specific processing on the messages it gets.

Of course, with this assumption the problem can be solved:  is told what the security policy is and simply blocks all messages that should not be sent according to the policy. This is actually a (simplified) model of how existing systems work, where  is implemented by the operating system and various physical security measures.

However, such a solution is problematic for several reasons: users must securely identify themselves to
 so that he can take the correct decisions, this also means that when new users join the system
 must be informed about this, directly or indirectly.  A side effect  of this is that  necessarily 
knows who sends to whom, and must of course know the security policy. This means that a company cannot outsource the function of  to  another party without disclosing information on internal activities of the company.

Therefore, a better version of our basic question is the following: \emph{can we use cryptography to simplify
the job of  as much as is possible, and also ensure that he learns minimal information?} 

To make the goal more precise, note that it is clear that  must process each message that is sent
i.e., we cannot allow a message violating the policy to pass through unchanged. But we can hope that the processing to be done does not depend on the security policy, and also not on the identities of the sender and therefore of the allowed receivers. This way we get rid of the need for users to identify themselves to . It is also clear that  must at least learn when a message was sent and its length, but we can hope to ensure he learns nothing more. This way, one can outsource the function of running  to a party that is only trusted to execute correctly.

Our goal in this paper is therefore to come up with a cryptographic notion and a construction that  reduces the sanitizer's job to the minimum we just described.
To the best of our knowledge, this problem has not been studied before in the cryptographic literature, and it is easy to see that existing constructions only solve ``half the problem'': we can easily control which users you can \emph{receive from} by selecting the key material we give out (assuming that the sender is honest). This is exactly what attribute based \cite{DBLP:conf/ccs/GoyalPSW06} or functional encryption \cite{DBLP:conf/tcc/BonehSW11} can do. But any such scheme of course allows a malicious sender to encrypt what he wants for any receiver he wants.



\paragraph{Our Contribution.} In this paper we propose a solution based on
a new notion called Access Control Encryption (ACE).
In a nutshell ACE works as follows:  an ACE scheme has a key generation algorithm that produces a set of sender keys, a set of receiver keys and a sanitizer key. 
An honest  sender   encrypts  message  under his sender key and sends it for processing by  using the sanitizer key.  does not need to know the security policy, nor who sends a message or where it is going (so a sender does not have to identify himself):  simply executes a specific randomised algorithm on the incoming ciphertext and passes the result on to a broadcast medium, e.g., a disk from where all receivers can read. So, as desired, 
 only knows when a message was sent and its length.\footnote{Note that the sanitizer has to send the ciphertext to all receivers -- both those who are allowed to decrypt and those who are not. A sanitizer who could decide whether a particular receiver is allowed to receive a particular ciphertext would trivially be able to distinguish between different senders with different writing rights.} An honest receiver  who is allowed to receive from  is able to recover  
using his key and the output from . On the other hand, consider a corrupt sender  who is not allowed to send to . ACE ensures that no matter what  sends, what  receives (after being processed by ) looks like a random encryption of a random message.
 In fact we achieve security against collusions: considering a subset  of senders and a subset  of receivers, if none of these senders are allowed to send to any of the receivers, then  cannot transfer any information to 
, even if players in each set work together. We propose two constructions of ACE: one based on standard number theoretic assumptions (DDH, Pailler) which achieves complexity linear in the number of roles,  and one based on recent results in cryptographic obfuscation, which achieves complexity polylogarithmic in the number of roles.


\paragraph{Example.} A company is working on a top-secret military project for the government. To protect the secrets the company sets up an access policy that determines which employees are allowed to communicate (e.g., a researcher with top-secret clearance should not be allowed to send classified information to the intern, who is making the coffee and only has public clearance). 
To implement the access policy, the company sets up a special server that sanitizes every message sent on the internal network before publishing it on a bulletin board or broadcasting it. Using ACE this can be done without requiring users to log into the sanitizer. Furthermore,  if corrupted parities (either inside or outside the company) want to intercept the communication they will get no information from the sanitizer server, since it does not know the senders identities and the messages sent over the network.


In the following sections, we describe ACE in more detail and take a closer look at our technical contributions.


\subsection{Access Control Encryption: The Problem it Solves} 

\paragraph{Senders and Receivers.} We have  (types of) senders  and  (types of) receivers .\footnote{The number of senders equals the number of receivers only for the sake of exposition.} There is some predicate , where  means that  is allowed to send to , while  means that  is not allowed to send to . 

\paragraph{Network Model.} We assume that senders are connected to all receivers via a public channel i.e., a sender cannot send a message only to a specific receiver and any receiver can see all traffic from all senders (also from those senders they are not allowed to communicate with). 

\paragraph{Requirements.} Informally we want the following properties\footnote{The security model, formalized in Definitions~\ref{def:ACEnoread} and~\ref{def:ACEnowrite}, is more general than this.} 
\begin{enumerate}
\item \emph{Correctness:} When an honest sender  sends a message , all receivers  with  learn ;
\item \emph{No-Read Rule:} At the same time all receivers  with  learn no information about ;
\item \emph{No-Write Rule:} No (corrupt) sender  should be able to communicate any information to any (possibly corrupt) receiver  if 
\end{enumerate}

Note that the \emph{no-read rule} on its own is a simple \emph{confidentiality} requirement, which can be enforced using standard encryption schemes. On the other hand standard cryptographic tools do not seem to help in satisfying the \emph{no-write rule}.
In particular the \emph{no-write} rule is very different from the standard \emph{authenticity} requirement and e.g., signature schemes cannot help here: had we asked for a different property such as \emph{``a corrupt sender  should not be allowed to communicate with an honest receiver  if ''} then the problem could be solved by having  verify the identity of the sender (using a signature scheme) and ignore messages from any sender  with . Instead, we are trying to block communication even between corrupt senders and corrupt receivers. 

The problem as currently stated is impossible to solve, since a corrupt sender can broadcast  in the clear to all receivers (the corrupt sender might not care that other receivers also see the message). As mentioned above, we therefore enhance the model by adding a special party, which we call the \emph{sanitizer} . The sanitizer receives messages from senders, performs some computation on them, and then forwards them to all receivers. 
In other words, we allow the public channel to perform some computation before delivering the messages to the receivers. Hence, the output of the sanitizer is visible to all receivers (i.e., the sanitizer cannot give different outputs to different receivers). 
We therefore add the following requirement to our \emph{no-read rule}:
\begin{enumerate}
\item[2b.] The sanitizer should not learn anything about the communication it routes. In particular, the sanitizer should not learn any information about the message  which is being transmitted nor the identity of the sender ; 
\end{enumerate}

In Section~\ref{sec:definition} we formalize properties  and  as a single one (i.e., no set of corrupt receivers, even colluding with the sanitizer, should be able to break the \emph{no-read} rule). When considering property , we assume the sanitizer not to collude with the corrupt senders and receivers: after all, since the sanitizer controls the communication channel, there is no way of preventing a corrupt sanitizer from forwarding messages from corrupt senders to the corrupt receivers.\footnote{Note that it is possible to reduce the trust on the sanitizer in different ways: in a black-box way, one could imagine several parties emulating the work of the sanitizer using MPC. In a more concrete way, it is possible to have a \emph{chain} of sanitizers, where the senders send their encryptions to sanitizer , the receivers receive ciphertexts from sanitizer , and sanitizer  further sanitizes the output of sanitizer . We note that all definitions and constructions in this paper can be easily generalized to this scenario but, to keep the presentation as simple as possible, we do not discuss this solution further and stick to the case of a single sanitizer.}

We stress that previous work is not sufficient to achieve property : Even encryption schemes with fine-grained decryption capabilities (such as predicate- and attribute based- encryption \cite{DBLP:conf/ccs/GoyalPSW06,DBLP:journals/joc/KatzSW13}) do not offer security guarantees against colluding senders and receivers. 








\subsection{Technical Overview} 

\paragraph{Linear ACE.} The main idea behind our construction of ACE with linear complexity (described in Section~\ref{sec:linear}) 
is the following: we start with an ACE for a single identity i.e., where  and . First we need 
to make sure that even a corrupt sender with encryption rights (i.e., ) cannot communicate with a 
corrupt receiver with no decrypting right (i.e., with a special identity ). To prevent this, since the receiver cannot 
decrypt the ciphertext, it is enough to use a randomizable public key encryption and let the sanitizer 
refresh the ciphertext. This ensures that the outgoing ciphertext is distributed exactly as a fresh 
encryption.

The more challenging task is to ensure that a corrupt sender with no rights (i.e., with a special identity ) cannot transfer any information to a corrupt receiver with decrypting rights (i.e., ), since in this case the receiver knows the decryption key. Thus, we cannot use the security of the underlying encryption scheme. We solve the problem using any encryption scheme which is homomorphic both in the message and in the randomness (such as ElGamal or Pailler). The main idea is to let the encryption key  as well as the randomizer key  be some secret value , and an encryption of a message  being a tuple . On input such a tuple the sanitizer picks a random  and outputs , a fresh encryption of  (which can be computed thanks to the homomorphic properties of ): note that sanitization does not interfere with honestly generated encryptions (since ), while the sanitized version of a ciphertext produced by anyone who does not know  is indistinguishable from a random encryption of a random value. 

We then turn this into a scheme for any predicate  by generating  copies of the single identity ACE scheme. Each receiver  is given the decryption key for one of the schemes, and each sender  is given the encryption key for all instances  such that . The resulting scheme has linear complexity in , the number of the roles in the system, which makes our scheme impractical for large predicates.



\paragraph{Polylogarithmic ACE.} At first it might seem easy to construct an ACE scheme with compact ciphertexts using standard tools (such as non-interactive zero-knowledge proofs). In Section~\ref{sec:polylog} we discuss why this is not the case before presenting our construction of an ACE with complexity polylogarithmic in . To construct the scheme we first introduce the notion of a \emph{sanitizable functional encryption} (sFE) scheme which is a functional encryption (FE) scheme enhanced with a sanitization algorithm. Informally we require that given any two ciphertexts  that decrypt to the same message and a sanitized ciphertext , no one (even with access to the master secret key), should be able to tell whether  is a sanitized version of  or .\footnote{We note that this is a relaxation of re-randomizability for FE, in the sense that we do not require sanitized ciphertexts to be indistinguishable from fresh encryptions, but only independent of the randomness used in the original encryption. However, to the best of our knowledge, no re-randomizable FE scheme for all circuits exist.} We are able to construct such a scheme by modifying the FE based on indistinguishability obfuscation of Garg et al.~\cite{DBLP:conf/focs/GargGH0SW13}: in their scheme ciphertexts consist of two encryptions and a \emph{simulation statistically-sound} NIZK proof that they contain the same message. We instantiate their construction with a sanitizable encryption scheme\footnote{Similar to a re-randomizable encryption scheme, where we do not require sanitized ciphertexts to look indistinguishable from fresh encryptions.}, and we instruct the sanitizer to sanitize the two encryptions, drop the original proof and append a \emph{proof of a proof} instead (that is, a proof of the fact that the sanitizer saw a proof who would make the original verifier accept). This preserves the functionality of the original FE scheme while making the sanitized ciphertext independent of the randomness used by the sender. 
We formally define sFE in Section~\ref{sec:sfe} and present a construction in Section~\ref{sec:sfecons}.

Finally, armed with such a sFE scheme, we construct a polylog ACE scheme in Section~\ref{sec:polylogace} in the following way: ciphertexts are generated by encrypting tuples of the form  with  for a PRF  (where  is the the encryption key of the sender ), using the sFE scheme. Decryption keys are sFE secret keys for the function that outputs  only if  (and ignores ). The sanitizer key is a sFE secret key which outputs  only if  is a valid MAC on  for the identity  (note that this can be checked by a compact circuit by e.g., generating all the keys  pseudorandomly using another PRF). This key allows the sanitizer to check if an encryption contains a valid MAC or not, but without learning anything about the message nor the identity. Now the sanitizer drops invalid encryptions (or replaces them with random encryptions of random values for a special, undecryptable identity ) and forwards valid encryptions (after having refreshed them). 



\paragraph{Open Questions.} We identify two major opens questions: the first one is to construct practically interesting ACE from noisy, post-quantum assumptions such as LWE -- the challenge here is that it always seems possible for a malicious sender to encrypt with just enough noise that any further manipulation by the sanitizer makes the decryption fail. This can be addressed using ``bootstrapping'' techniques, but this is not likely to lead to schemes with efficiency comparable to the ones based on DDH or Pailler described above. The second open question is to design sublinear ACE scheme with practical efficiency even for limited classes of interesting predicates such as e.g., .


 

\subsection{Related Work} 
One of the main challenges in our setting is to prevent corrupt senders to communicate to corrupt receivers using subliminal channels (e.g., by producing the encryptions with maliciously generated randomness). In some sense we are trying to prevent steganography~\cite{DBLP:conf/crypto/HopperLA02}. 
Recent work on cryptographic firewalls~\cite{DBLP:conf/eurocrypt/MironovS15,DBLP:journals/iacr/DodisMS15} also deals with this problem, but in the context of preventing malicious software implementations to leak information via steganographic techniques. 
Raykova et al.~\cite{DBLP:conf/fc/RaykovaZB12} presented solutions to the problem of access control on outsourced data, with focus on hiding the access patterns from the cloud (this is not a concern in our application since all receivers receive all ciphertexts) and in preventing malicious writers from updating files they are not allowed to update. However they only guarantee that malicious writers are caught if they do so, while we want to prevent any communication between corrupt senders and receivers. 
Backes and Pfitzmann introduced the notion of probabilistic non-interference which allows to relate cryptography to the notion of information flow for both transitive~\cite{DBLP:conf/sp/BackesP03} and intransitive policies~\cite{DBLP:journals/ijisec/BackesP04}. Halevi et al.~\cite{DBLP:journals/iacr/HaleviKN05} address the problem of enforcing confinement in the T10 OSD protocol, in the presence of a fully trusted manager (which has a role similar to the sanitizer in our model). 
Fehr and Fischlin~\cite{FF15} study the case of sanitizable signatures in the context of an intermediate party that sanitizes messages and signatures send over the channel. The special party learns as little as possible about the messages and signatures. However, they do not prevent corrupt senders from sending information to corrupt receivers. Finally, the problem of hiding policies and credentials in the context of attribute based encryption has been studied by Frikken et al.~\cite{FAL06}, Kapadia et al.~\cite{KTS07}, M{\"{u}}ller and Katzenbeisser~\cite{DBLP:conf/stm/MullerK11}, and Ferrara et al.~\cite{DBLP:conf/csfw/FerraraFLW15}. However, they do not consider the case of preventing corrupt sender from communicating with corrupt receivers (e.g. by sending the message unencrypted over the channel).







\section{Defining ACE}\label{sec:definition}

\paragraph{ACE Notation.} An \emph{access control encryption} (ACE) scheme is defined by the following algorithms:
\begin{description}
\item[Setup:] The  algorithm on input the security parameter  and a policy  outputs a master secret key  and public parameters , which include the message space  and ciphertext spaces .\footnote{We use the convention that all other algorithms take  as input even if not specified. Formally, one can think of the  as being part of  and all other keys .} 

\item[Key Generation:] The  algorithm on input the master secret key , an identity ,\footnote{To make notation more compact we define two special identities:  representing a sender or receiver with no rights such that  for all ;  to be the sanitizer identity, which cannot receive from anyone but can send to all i.e.,  and } and a type  outputs a key . We use the following notation for the three kind of keys in the system:
	\begin{itemize}
	\item  and call it an \emph{encryption key for } 
	\item  and call it a \emph{decryption key for } 
	\item ;
	\item  and call it the \emph{sanitizer key};
	\end{itemize}

\item[Encrypt:] The  algorithm on input an encryption key  and a message  outputs a ciphertext . 

\item[Sanitizer:]  transforms an incoming ciphertext  into a sanitized ciphertext  using the sanitizer key ;

\item[Decryption:]  recovers a message  from a ciphertext  using a decryption key . \end{description}


\paragraph{ACE Requirements.} We formalize Properties 1-3 from the introduction in the following way: 


\begin{defi}[Correctness] \label{def:ACE-correct}\label{def:one-correct}
For all ,  such that :


with , , , and , and the probabilities are taken over the random coins of all algorithms.
\end{defi}







\begin{defi}[No-Read Rule] \label{def:oneprivacy}\label{def:ACEnoread} \label{def:privacy} Consider the following game between a challenger  and a stateful adversary :
\begin{center}
\begin{small}
    \begin{tabular}{| p{5.5cm} | p{5cm} |}
    \hline
	\multicolumn{2}{|c|}{\textbf{\emph{No-Read Rule}}} \\
	\hline
	\multicolumn{1}{|c|}{\textbf{\emph{Game Definition}}} & \multicolumn{1}{|c|}{\textbf{\emph{Oracle Definition}}}  \\
	\hline
	\

	1. ;

	2. ;

	3. ;

	4. ;

	5. ;

	&
	\

	: \newline 1. Output ;

	\ 

	: 

	1. ;

	2. Output ;

	\\
	\hline
	\end{tabular}
\end{small}
\end{center}
We say that  \emph{wins the No-Read game} if , ,  and one of the following holds:
\begin{description}
	\item[Payload Privacy:] For all queries  to  with  it holds that 
		
	\item[Sender Anonymity:] For all queries  to  with  it holds that 
		
\end{description}
We say an ACE scheme satisfies the \emph{No-Read rule} if for all PPT 
 
\end{defi}


Definition~\ref{def:privacy} captures the requirement that only intended receivers should be able to learn anything about the message (payload privacy) and that no one (even intended receivers) should learn anything about the identity of the sender (sender anonymity). Note that the ciphertext  sent by the challenger to the adversary has \emph{not} been sanitized and that the adversary is allowed to query for the sanitizer key . This implies that even the sanitizer (even with help of any number of senders and unintended receivers) should not learn anything. Note additionally that the adversary is allowed to query for the encryption keys  corresponding to the challenge identities , which implies that the ability to \emph{encrypt} to a particular identity does not automatically grant the right to \emph{decrypt} ciphertexts created with that identity (e.g., a user might be able to \emph{write} top-secret documents but not to \emph{read} them). Note that if  for some , then the definition implies that it is possible to create ``good looking'' ciphertexts even without having access to any of the senders' keys. This is  explicitly used in our solution with linear complexity. 
Furthermore note that if there exist multiple keys for a single identity (e.g., the output of  is randomized), then our definition does not guarantee that the adversary can ask the oracle  for the encryption key used to generate the challenge ciphertext. The definition can be easily amended to grant the adversary this power but (since in all our constructions  is a deterministic function of  and ) we prefer to present the simpler definition.
Finally, the encryption oracle  models the situation that the adversary is allowed to see encrypted messages under identities for which he does not have the encryption key.



\begin{defi}[No-Write Rule] \label{def:security}\label{def:ACEnowrite} \label{def:onesecurity}
Consider the following game between a challenger  and a stateful adversary :
\begin{center}
\begin{small}
    \begin{tabular}{| p{6.5cm} | p{5cm} |}
    \hline
	\multicolumn{2}{|c|}{\textbf{\emph{No-Write Rule}}} \\
	\hline
	\multicolumn{1}{|c|}{\textbf{\emph{Game Definition}}} & \multicolumn{1}{|c|}{\textbf{\emph{Oracle Definition}}}  \\
	\hline
	\

	1. ;

	2. ;

	3. ;

	4. ;

	5. ;

	6. , 
	\begin{itemize}
		\item If , ; 
		\item If , ;
	\end{itemize}
	7. ;

	&
	\
	
	: \newline 1. Output ;

	\ 

	: \newline 1. Output ;

	\ 


	: 

	1. ;

	2. ;
	
	3. Output ;

	\\
	\hline
	\end{tabular}
\end{small}
\end{center}
Let  (resp. ) be the set of all queries  that  issues to  (resp. both  and ). Let  be the set of all  such that  and let  be the set of all  such that . Then we say that  \emph{wins the No-Write game} if  and all of the following hold:
\begin{enumerate}
	\item ;
	\item ;
	\item ,  ;
\end{enumerate}
We say an ACE scheme satisfies the \emph{No-Write rule} if for all PPT 
 
\end{defi}


Definition~\ref{def:security} captures the property that any set of (corrupt) senders  cannot transfer any information to any set of (corrupt) receivers  unless at least one of the senders in  is allowed communication to at least one of the receivers in  (Condition 3)\footnote{Note that the adversary is allowed to ask for any senders' key in the post-challenge queries.}. This is modelled by saying that in the eyes of the receivers, the sanitized version of a ciphertext coming from this set of senders looks like the sanitized version of a fresh encryption of a random value produced by one of these senders (Condition 2). Note that if the adversary does not ask for any encryption key (i.e., ), then the only valid choice for  is : this implies that (as described for the no-read rule) there must be a way of constructing ``good looking'' ciphertexts using the public parameters only\footnote{Recall that we defined .} and this property is used crucially in the construction of our linear scheme. 
Furthermore, we require that the adversary does not corrupt the sanitizer (Condition 1) which is, as discussed in the introduction, an unavoidable condition. 
Finally, the encryption oracle  again models the situation that the adversary is allowed to see encrypted messages under identities for which he do not have the encryption key.






\section{Linear ACE from Standard Assumptions}\label{sec:linear}


The roadmap of this section is the following: we construct an ACE scheme for a single identity (i.e.,  and ) from standard number theoretic assumptions, and then we construct an ACE scheme for any predicate  using a \emph{repetition scheme}. The complexity of the final scheme (in terms of public-key and ciphertext size) is  times the complexity of the single-identity scheme.






\subsection{ACE for a Single Identity}

We propose two constructions of ACE for a single identity (or \oACE for short). The first is based on the DDH assumption and is presented in this section, while the second is based on the security of Pailler's cryptosystem and is deferred to Appendix~\ref{app:onepailler}. Both schemes share the same basic idea: the encryption key  is some secret value , and an encryption of a message  is a pair of encryptions . The sanitizer key is also the value , and a sanitized ciphertext is computed as  which (thanks to the homomorphic properties of both ElGamal and Pailler) is an encryption of a uniformly random value unless  is an encryption of , in which case it is an encryption of the original message . The decryption key is simply the decryption key for the original encryption scheme, which allows to retrieve  from . Note that even knowing the decryption key is not enough to construct ciphertexts which ``resist'' the sanitization, since the receiver never learns the value .



\paragraph{\oACE from DDH:}
Our first instantiation is based on the ElGamal public-key encryption scheme \cite{DBLP:journals/tit/Elgamal85}. The construction looks similar to other \emph{double-strand} versions of ElGamal encryption which have been used before in the literature to achieve different goals (e.g., by Golle et al.~\cite{DBLP:conf/ctrsa/GolleJJS04} in the context of universal re-encryption and by Prabhakaran and Rosulek~\cite{DBLP:conf/crypto/PrabhakaranR07} in the context of rerandomizable CCA security). 


\begin{construction} \label{con:oneElGamal}
Let  be a \oACE scheme defined by the following algorithms:
\end{construction}
\begin{description}
\item[Setup:] Let  be the description of a cyclic group of prime order  generated by . Let  be uniform random elements, and compute . Output the public parameter   and the master secret key . The message space is  and the ciphertext spaces are  and .

\item[Key Generation:] Given the master secret key , the encryption, decryption and sanitizer key are computed as follows:
	\begin{itemize}
	\item ;
	\item ;
	\item ;
	\end{itemize}

\item[Encryption:] Given the message  and an encryption key , sample random  and output:

(and encryptions for the identity  are random tuples from ).

\item[Sanitize:] Given a ciphertext  and a sanitizer key , sample uniform random  and output:


\item[Decryption:] Given a ciphertext  and a decryption key , output:

\end{description}




\begin{lem}\label{lem:elgamal}
Construction~\ref{con:oneElGamal} is a \emph{correct} \oACE scheme that satisfies the \emph{No-Read Rule} and the the \emph{No-Write Rule} assuming that the DDH assumption holds in .
\end{lem}

\begin{proof}
\emph{Correctness:} 
Let   be an honestly generated ciphertext, and let  be a sanitized version of . We check that  is still an encryption of the original message :

Thus, the sanitization of a valid ciphertext produces a new valid ciphertext under the same identity and of the same message.
\\


\noindent \emph{No-Read Rule:}
There are three possible cases, depending on which identities the adversary queries during the game: the case  is trivial as both  for  are random ciphertexts; the case  is trivial if the adversary asks for the decryption key , since in this case it must be that . The case where the adversary does not ask for the decryption key and  implies the case where the adversary does not ask for the decryption key and  using standard hybrid arguments (i.e., if  is indistinguishable from a random ciphertext  for all , then  is indistinguishable from  for all ). So we are only left to prove that honest encryptions are indistinguishable from a random element in , which follows in a straightforward way from the DDH assumption. In particular, since  is indistinguishable from  for random  we can replace  with a uniformly random element (independent of ). Notice that neither  (the encryption and sanitizer key) nor encryptions from oracle  will help the adversary distinguish. 
Thus, we can conclude that the adversary's advantage is negligible, since he cannot distinguish in all three cases.
\\


\noindent \emph{No-Write Rule:}
We only need to consider two cases, depending on which keys the adversary asks for \emph{before} producing the challenge ciphertext  and identity : 1) the adversary asks for  before issuing his challenge  with  (and receives no more keys during the distinguishing phase) and 2) the adversary asks for  before issuing his challenge  and then asks for  during the distinguishing phase. Case 1) follows directly from the DDH assumption: without access to the decryption key the output of the sanitizer is indistinguishable from a random ciphertext thanks to the choice of the random , in particular since  is indistinguishable from  for random  we can replace  with uniformly random elements in . Case 2) instead has to hold unconditionally, since the adversary has the decryption key. We argue that the distribution of  is independent of its input. In particular, given any (adversarially chosen)  we can write:

Then the output  is

Which is distributed exactly as a uniformly random ciphertext  with  since for all  there exists  such that:

This is guaranteed unless the two equations are linearly dependent i.e., unless  which happens only with negligible probability thanks to the principle of deferred decisions.
The adversary is allowed to see sanitized ciphertext from the encryption oracle. However, this does not help him distinguish, since the output of the  algorithm is distributed exactly as a uniform ciphertext.
Thus, we can conclude that the adversary's advantage is negligible, since he cannot distinguish in both cases.
\end{proof}



\subsection{Construction of an ACE Scheme for Multiple Identities}

In this section we  present a construction of an ACE scheme for multiple identities, which is based on the \oACE scheme in a black-box manner. In a nutshell, the idea is the following: we run  copies of the \oACE scheme and we give to each receiver  the decryption key  for the -th copy of the scheme. An encryption key for identity  is given by the set of encryption keys  of the \oACE scheme such that . To encrypt, a sender encrypts the same message  under all its encryption keys  and puts random ciphertexts in the positions for which he does not know an encryption key. The sanitizer key contains all the sanitizer keys for the \oACE scheme: this allows the sanitizer to sanitize each component independently, in such a way that for all the positions for which the sender knows the encryption key, the message ``survives'' the sanitization, whereas in the other positions the output is uniformly random.

\paragraph{Example.} We conclude this informal introduction of our repetition scheme by giving a concrete example of an ACE scheme for the Bell-LaPadula access control policy with three levels of access: \textit{Level 1: top-secret, level 2: secret, level 3: public}.
The predicate of this access control is defined as . This predicate ensures the property of \textit{no write down} and \textit{no read up} as discussed in the introduction.
Table~\ref{table:BL_ACE} shows the structure of the keys and the ciphertext for the different levels of access.

\renewcommand{\oneACE}{}
\renewcommand{\oneACEpow}{{}}
\begin{table}
\centering
\begin{tabular}{l|l|ccc|ccccc}
		&	\multicolumn{1}{|c|}{}	
		&	\multicolumn{3}{|c}{}	
		&	\multicolumn{5}{|c}{}		\\ \hline
		
1		&							
		&		
&&&	&&&& \\
		
2		&					
		&&		
&&	&&&& \\
		
3		&				
		&&&		
&	&&&& \\
\end{tabular}
\newline
\caption{Access Control Encryption Scheme for Bell-LaPadula access control policy.  are random ciphertexts from .}
\label{table:BL_ACE}
\end{table}
\renewcommand{\oneACE}{\mathsf{1ACE}}
\renewcommand{\oneACEpow}{\mathsf{1ACE}}


\begin{construction} \label{con:ACE}
Let  be a \oACE scheme. Then we can construct an ACE scheme  defined by the following algorithms:
\end{construction}
\begin{description}
\item[Setup:] Let  be the number of senders/receivers specified by the policy . Then run  copies of the  setup algorithm

For each of the  master secret keys run the  key generation algorithm on each of the three modes. For  do the following


Output the public parameter and the master secret key\footnote{There exists some encoding function that takes a message  from the message space of the  scheme and encodes it into a message of each of the \oACE message spaces. The ciphertext spaces of the  scheme are the crossproduct of all the \oACE ciphertext spaces, thus  and .}


\item[Key Generation:] On input an identity , a mode  and the master secret key , output a key depending on the mode
	\begin{itemize}
	\item , where  is the subset s.t.  iff ;
	
	\item ;
	
	\item ;
	\end{itemize}

\item[Encrypt:] On input an encryption key  and a message  encrypt the message under each of the  encryption keys in  and sample uniform random ciphertext for each public key not in the encryption key. 
Thus, for  do the following
\begin{itemize}
\item If  then compute .

\item If  then sample  \C_j^\oneACEpowc_j^\oneACEpow \gets_\ is a shorthand for .}
\end{itemize}
Output the ciphertext .


\item[Sanitizer:] On input a ciphertext  and a sanitizer key , sanitize each of the   ciphertexts as follows
 
Output the sanitized ciphertext .

\item[Decryption:] On input a ciphertext  and a decryption key  decrypt the 'th  ciphertext

\end{description}

We can prove that the scheme presented above satisfies \emph{correctness} as well as the \emph{no-read} and the \emph{no-write} rule, by reducing the properties of the repetition scheme to properties of the scheme with a single identity using hybrid arguments. The formal proofs are deferred to Appendix~\ref{app:repetitionproofs}. 


\section{Polylogarithmic ACE from iO}\label{sec:polylog}


In this section, we present our construction of ACE with polylogarithmic complexity in the number of roles .

At first it might seem that it is easy to construct an ACE scheme with short ciphertexts by using NIZK and re-randomizable encryption: the sender would send to the sanitizer a ciphertext and a NIZK proving that the ciphertext is a well-formed encryption of some message using a public key that the sender is allowed to send to (for instance, each sender could have a signature on their identity to be able to prove this statement). Now the sanitizer drops the NIZK and passes on the re-randomized ciphertext. However, the problem is that the sanitizer would need to know the public key of the intended receiver to be able to re-randomize (and we do not want to reveal who the receiver is). 

As described in the introduction, we build our ACE scheme on top of a FE scheme which is \emph{sanitizable}, which roughly means that given a ciphertext it is possible to produce a new encryption of the same message which is independent of the randomness used in the original encryption (this is a relaxation of the well-known \emph{re-randomizability} property, in the sense that we do not require sanitized ciphertexts to look indistinguishable from fresh encryptions e.g., they can be syntactically different). We construct such an FE scheme by modifying the FE scheme of Garg et al.~\cite{DBLP:conf/focs/GargGH0SW13}, and therefore our construction relies on the assumption that indistinguishability obfuscation exists. We define and construct sFE in Section~\ref{sec:sfe} and then construct ACE based on sFE (and a regular PRF) in Section~\ref{sec:polylogace}. 


\subsection{Sanitizable Functional Encryption Scheme -- Definition}\label{sec:sfe}
A \emph{sanitizable functional encryption} (sFE) scheme is defined by the following algorithms:
\begin{description}
\item[Setup:] The  algorithm on input the security parameter  outputs a master secret key  and public parameters , which include the message space  and ciphertext spaces .

\item[Key Generation:] The  algorithm on input the master secret key  and a function , outputs a corresponding secret key .

\item[Encrypt:] The  algorithm on input the public parameters  and a message , outputs a ciphertext 

\item[Sanitizer:] The  algorithm on input the public parameters  and a ciphertext , transforms the incoming ciphertext into a sanitized ciphertext  

\item[Decryption:] The  algorithm on input a secret key  and a sanitized ciphertext  that encrypts message , outputs .





\end{description}

For the sake of exposition we also define a \emph{master decryption algorithm} that on input , returns .\footnote{Formally  is a shortcut for , where  is the identity function.} We formally define \emph{correctness} and \emph{IND-CPA} security for an sFE scheme (which are essentially the same as for regular FE), and then we define the new \emph{sanitizable} property which, as described above, is a relaxed notion of the re-randomization property.

\begin{defi}[Correctness for sFE]
Given a function family . For all  and all messages :
	
where  and the probabilities are taken over the random coins of all algorithms.
\end{defi}


\begin{defi}[IND-CPA Security for sFE] \label{def:FEnoread}
Consider the following game between a challenger  and a stateful adversary :
\begin{center}
\begin{small}
    \begin{tabular}{| p{5.5cm} | p{5cm} |}
    \hline
	\multicolumn{2}{|c|}{\textbf{\emph{ IND-CPA Security}}} \\
	\hline
	\multicolumn{1}{|c|}{\textbf{\emph{Game Definition}}} & \multicolumn{1}{|c|}{\textbf{\emph{Oracle Definition}}}  \\
	\hline
	\
	
	1. ;

	3. ;
	
	4. ;

	5. 
	
	6. ;

	&
	\

	: \newline 1. Output ;

	\\
	\hline
	\end{tabular}
\end{small}
\end{center}
We say that  \emph{wins the IND-CPA game} if , , and that  for all oracle queries .
We say a sFE scheme satisfies the IND-CPA security property if for all PPT 
 
\end{defi}

\begin{defi}[Sanitization for sFE] \label{def:FEnowrite}
Consider the following game between a challenger  and a stateful adversary :
\begin{center}
\begin{small}
    \begin{tabular}{| p{8cm} |}
    \hline
	\multicolumn{1}{|c|}{\textbf{\emph{Sanitization}}} \\
	\hline
	\multicolumn{1}{|c|}{\textbf{\emph{Game Definition}}}  \\
	\hline
	\

	1. ;

	2. ;

	3. , 
	\begin{itemize}
		\item If , ;
		\item If , ; 
	\end{itemize}
	4. ;

	\\
	\hline
	\end{tabular}
\end{small}
\end{center}
We say that  \emph{wins the sanitizer game} if .
We say a sFE scheme is sanitizable if for all PPT 
 
\end{defi}

Note that in Definition~\ref{def:FEnowrite} the adversary has access to the master secret key.
















\subsection{Sanitizable Functional Encryption Scheme -- Construction}\label{sec:sfecons}
We now present a construction of a sFE scheme based on iO. The construction is based on the functional encryption construction by Garg et. al~\cite{DBLP:conf/focs/GargGH0SW13}. In their scheme a ciphertext contains two encryptions of the same message and a NIZK of this statement, thus an adversary can leak information via the randomness in the encryptions or the randomness in the NIZK. In a nutshell we make their construct sanitizable by:
\begin{enumerate}
\item Replacing the PKE scheme with a \emph{sanitizable PKE} (as formalized in Definition~\ref{def:PKE_sanitation}).
\item Letting the sanitizer drop the original NIZK, and append a \emph{proof of a proof} instead (i.e., a proof that the sanitizer knows a proof that would make the original verifier accept). Thanks to the ZK property the new NIZK does not contain any information about the randomness used to generate the original NIZK.
\item Changing the decryption keys (obfuscated programs) to check the new proof instead.

\end{enumerate} 


\paragraph{Building Blocks.} We formalize here the definition of sanitization for a PKE scheme. Any re-randomizable scheme (such as Paillier and ElGamal) satisfies perfect PKE sanitization, but it might be possible that more schemes fit the definition as well.

\begin{defi}[Perfect PKE Sanitization] \label{def:PKE_sanitation}
Let  be the message space and  be the space from which the randomness for the encryption and sanitization is taken. 
Then for every message  and for all  there exists  such that

\end{defi}

Our constructions also uses (by now standard) tools such as \emph{pseudo-random functions (PRF)}, \emph{indistinguishability obfuscation (iO)} and \emph{statistical simulation-sound non-interactive zero-knowledge (SSS-NIZK)}, which are defined for completeness in Appendix~\ref{app:bb}.

\paragraph{Constructing sFE.} We are now ready to present our construction of sFE.

\begin{construction} \label{con:sanFE}
Let  be a perfect sanitizable public key encryption scheme.
Let  be a statistical simulation-sound NIZK.
Let  be an indistinguishability obfuscator.
We construct a sanitizable functional encryption scheme  as follows:
\end{construction}
\begin{description}
\item[Setup:] On input the security parameter  the setup algorithm compute the following
	\begin{enumerate}
	\item ;
	\item ;
	\item ;
	\item ;
	\item Output   and  ;
	\end{enumerate}

	The relations  and  are defined as follows: Let  be a statement and  a witness, then  is defined as
	
	
	Let  be a statement and  a witness, then  is defined as
	
	
	
\item[Key Generation:] On input the master secret key  and a function  output the secret key  as the obfuscation of the following program

\begin{center}
\begin{small}
    \begin{tabular}{| p{6cm} |}
	\hline
	\multicolumn{1}{|c|}{\textbf{\emph{Program} }} \\
	\hline 
	\
	
	Input: ; 
	
	Const: ;
	
	\

	1. If ;
	\begin{itemize}
		\item[] output ;
	\end{itemize}

	2. else output fail;

	\\
	\hline
	\end{tabular}
\end{small}
\end{center}


\item[Encrypt:] On input the public parameters  and a message  compute two PKE encryptions of the message
	
	with randomness .	Then create a proof  that  with  and witness  
	
	using randomness . 
	Output the triple  as the ciphertext.


\item[Sanitizer:] On input the public parameter  and a ciphertext  compute the following
	\begin{enumerate}
	\item If  then
		\begin{itemize}
		\item[] 
		\item[] 
		\item[] 
		\item[] Output 
		\end{itemize}
	\item Else
		\begin{itemize}
		\item[] Output 
		\end{itemize}
	\end{enumerate}
	with randomness  and  in the PKE and NIZK respectively. The  generated NIZK is a proof that  with   and .
	
	
\item[Decryption:] On input a secret key  and a ciphertext , run the obfuscated program  and output the answer.


\end{description}


\begin{lem}
Construction~\ref{con:sanFE} is a correct functional encryption scheme.
\end{lem}

\begin{proof}
Correctness follows from the correctness of the , PKE, and SSS-NIZK schemes, and from inspection of the algorithms.
\end{proof}



\begin{lem}\label{lem:IND-CPA_sFE}
For any adversary  that breaks the IND-CPA security property of Construction~\ref{con:sanFE}, there exists an adversary  for the computational zero-knowledge property of the NIZK scheme, an adversary  for the IND-CPA security of the PKE scheme, and an adversary  for iO such that the advantage of adversary  is

where  is the number of secret key queries adversary  makes during the game, and  is the negligible soundness error of the SSS-NIZK scheme.
\end{lem}


\begin{proof}
This proof follows closely the selective IND-CPA security proof of the FE construction presented by Garg et. al.~\cite{DBLP:conf/focs/GargGH0SW13}.
See Appendix~\ref{app:IND-CPA_sFE} for the full proof.
\end{proof}

\begin{lem}\label{lem:Sanitize_sFE}
For any adversary  that breaks the sanitizer property of Construction~\ref{con:sanFE}, there exists an adversary  for the computational zero-knowledge property of the NIZK scheme such that the advantage of adversary  is

\end{lem}


\begin{proof}
This lemma is proven via a series of indistinguishable hybrid games between the challenger and the adversary. For the proof to go through we notice that the challenger needs to simulate the NIZK proof. At a first look it might seem that the reduction needs to guess the entire ciphertext before setting up the system parameter, but in fact we show that it is enough to guess the \emph{message} beforehand! Thus, we can use a complexity leveraging technique to get the above advantage.
See Appendix~\ref{app:Sanitize_sFE} for the full proof.

\end{proof}



\subsection{Polylog ACE scheme}\label{sec:polylogace}

In this section, we present a construction of an ACE scheme for multiple identities based on sanitizable functional encryption. The idea of the construction is the following: an encryption of a message  is a sFE encryption of the message together with the senders identity  and a MAC of the message based on the identity. Crucially, the encryption keys for all identities are generated in a pseudorandom way from a master key, thus it is possible to check MACs for all identities using a compact circuit.
The sanitizer key is a sFE secret key for a special function that checks that the MAC is correct for the claimed identity. 
Then the sanitization consists of sanitizing the sFE ciphertext, and then using the sanitizer key to check the MAC.
The decryption key for identity  is a sFE secret key for a function that checks that identity  in the ciphertext and identity  are allowed to communicate (and ignores the MAC). The function then outputs the message iff the check goes through.


\begin{construction} \label{con:ACEfromFE}
Let  be a sanitizable functional encryption scheme. Let  be pseudorandom functions.
Then we can construct an ACE scheme  defined by the following algorithms:
\end{construction}
\begin{description}
\item[Setup:]
Let  be a key for the pseudorandom function . Run . 
Output the public parameter  and the master secret key 


\item[Key Generation:]
Given the master secret key  and an identity , the encryption, decryption and sanitizer key are computed as follows:
\begin{itemize}
\item 
\item 
\item 
\end{itemize}
where the functions  and  are defined as follows

\begin{center}
\begin{small}
    \begin{tabular}{| p{5.5cm} | p{5cm} |}
\hline
	\multicolumn{1}{|c|}{\textbf{\emph{Decryption function}}} & \multicolumn{1}{|c|}{\textbf{\emph{Sanitizer function}}}  \\
	\hline
	\
	
	:

	1. If : output ;

	2. Else output ;

	&
	\

	: 
	
	1. ;
	
	2. If : output ;
	
	3. Else output ;

	\\
	\hline
	\end{tabular}
\end{small}
\end{center}


\item[Encryption:]
On input a message  and an encryption key , compute  and output 


\item[Sanitizer:]
Given a ciphertext  and the sanitizer key  check the MAC and output a sanitized FE ciphertext
\begin{enumerate}
\item 
\item If : output 
\item Else output  
\end{enumerate}


\item[Decryption:] 
Given a ciphertext  and a decryption key  output 
\end{description}


\begin{lem} \label{lem:FEcorrect}
Construction~\ref{con:ACEfromFE} is a \emph{correct} ACE scheme \end{lem}

\begin{proof}
Let  for some . Let  be a honest sanitization of a honest generated encryption of message  under identity : 


Given the decryption key . Then the correctness property of the  scheme gives

\end{proof}

\begin{thm} \label{thm:ACE_sFE_no-read}
For any adversary  that breaks the No-Read Rule of Construction~\ref{con:ACEfromFE}, there exists an adversary  for the IND-CPA security of the sanitizable functional encryption scheme, such that the advantage of  is
	
\end{thm}

\begin{proof}
Assume that any adversary wins the IND-CPA security game of the sanitizable functional encryption (sFE) scheme with advantage at most .
Assume for contradiction that there is an adversary  that wins the ACE no-read game with advantage greater than , then we can construct an adversary  that wins the IND-CPA security game for the sFE scheme with advantage greater than .

 starts by generating  for some pseudorandom function . Then  receives  from the challenger and forwards it as the ACE public parameter to the adversary . 
Adversary  then performs some oracle queries to  and  to which  replies as follows: 
\begin{itemize}
\item  receives , then he sends  to .
\item  receives , then he makes an oracle query  to the challenger and gets back .  sends  to .
\item  receives , then he makes an oracle query  to the challenger and gets back .  sends  to .
\item  receives , then he computes  and sends to  
\end{itemize}
After the oracle queries  receives messages  and identities  from adversary . Then  computes  for  and sends  and  to the challenger, where  for .
Then the sFE challenger sends a ciphertext , which  forwards to  as the ACE ciphertext. 
This is followed by a new round of oracle queries.

If the sFE challenger is in case , then  is generated as an sFE encryption of message , and we are in the case  in the no-read game. Similar, if the sFE challenger is in case , then we are in the case  in the no-read game. Note that our adversary respects the rules of the IND-CPA game, since  and  for all  such that  was queried. This follows directly from the payload privacy (the function outputs ) and sender anonymity () properties of the no-read rule.
Thus, we can conclude that if  wins the no-read game with non-negligible probability, then  wins the IND-CPA security game for the sFE scheme.
\end{proof}




\begin{thm} \label{thm:ACE_sFE_no_write}
For any adversary  that breaks the No-Write Rule of Construction~\ref{con:ACEfromFE}, there exists an adversary  for the PRF security, an adversary  for the sanitizer property of the sFE scheme, and an adversary  for the IND-CPA security of the sFE scheme, such that the advantage of  is
	
\end{thm}

\begin{proof}
This theorem is proven by presenting a series of hybrid games.

\paragraph{Hybrid 0.} The no-write game for 

\paragraph{Hybrid 1.} As Hybrid 0, except that when the challenger receives a oracle request  he saves the identity: , and the encryption key . When the challenger receives the challenge  he uses the sFE master decryption to get 

If , then the challenger generates  honestly.
Next, he checks that . If the check goes through he computes the challenge response as , otherwise .

\paragraph{Hybrid 2.} As Hybrid 1, except that the encryption keys are chosen uniformly at random:  \zo^\kappaiek_{i^*}i^* \in I_St^*c^* \from \San(rk,\Enc(ek_0,\bot))i^* \in I_St^* = F_{2}(ek_{i^*},m^*)r \from_\ and .

\paragraph{Hybrid 6.} As Hybrid 5, except that the encryption keys are generated honestly:  for all . Observe, this is the no-write game for . \\



Now we show that each sequential pair of the hybrids are indistinguishable.

\begin{claim}
Hybrid 0 and Hybrid 1 are identical.
\end{claim}

\begin{proof}
This follows directly from the definition of the sanitization and sanitizer key .
\end{proof}

\begin{claim} \label{claim:ACE_nowrite_PRF_1}
For any adversary  that can distinguish Hybrid 1 and Hybrid 2, there exists an adversary  for the security of PRF  such that the advantage of  is 
.
\end{claim}

\begin{proof}
Assume that any adversary can break the PRF security with advantage , and assume for contradiction that we can distinguish the hybrids with advantage greater than . Then we can construct an adversary  that breaks the PRF security with advantage greater than .

 starts by creating the public parameters honestly and sends it to the adversary. 
All the adversary oracle queries are answered as follows: whenever  receives  from the adversary, he sends  to the PRF challenger, receives back , set , and sends  to the adversary. 
When  receives the challenge  he ask the challenger for the encryption key (as before), and encrypts . The rest of adversary's queries are answered honestly by using the algorithms of the construction.
When  receives  from the adversary, he master decrypts the ciphertext to get . If , then  creates  by sending  to the challenger.
 concludes the game by forwarding the adversary's guess  to the challenger.

Observe that the if  then we are in Hybrid 1, and if  is uniform random, then we are in Hybrid 2. 
Thus, if adversary  can distinguish between the hybrids, then  can break the constraint PRF property. 
\end{proof}


\begin{claim} 
For any adversary  that can distinguish Hybrid 2 and Hybrid 3,
there exists an adversary  for the security of PRF  such that the advantage of  is 
.
\end{claim}

\begin{proof}
Assume that any adversary can break the PRF security with advantage , and assume for contradiction that we can distinguish the hybrids with advantage greater than . Then we can construct an adversary  that breaks the PRF security with advantage greater than .

 starts by creating the public parameters and sending them to the adversary. The adversary's oracle queries are answered honestly by using the algorithms of the construction.
When  receives the challenge  he master decrypts the ciphertext to get . Then he sends  to the challenger and receives back . If  then  guess that the challenger is using the pseudorandom function , otherwise  guess that the challenger is using a random function.

We evaluate now the advantage of  in the PRF game: Observe, if  is generated using , then  outputs ``PRF'' with probability exactly . In the case when  is generated using a random function, then it does not matter how  was created, and the probability that  is . Thus, the advantage of adversary  is greater than .
\end{proof}


\begin{claim} \label{claim:ACE_nowrite_sFE_san}
For any adversary  that can distinguish Hybrid 3 and Hybrid 4, there exists an adversary  for the sanitizer property of the sFE scheme such that the advantage of  is 
.
\end{claim}

\begin{proof}
Assume that any adversary wins the sanitizer game for the sFE scheme with advantage , and assume for contradiction that we can distinguish the hybrids with advantage greater than . Then we can construct an adversary  that wins the sanitizer game with advantage greater than .

 starts by receiving the sFE system parameters from the challenger, and he forwards the public parameters as the ACE public parameters to the adversary. 
The adversary's oracle queries are answered honestly by using the algorithms of the construction, since  receives the sFE master secret key from the challenger.
When  receives the challenge  he master decrypts the ciphertext to get . Then he checks that  and . If the check goes through he sends  to the challenger and receives back a sFE sanitized ciphertext . Thus, the challenge response is . 
 concludes the game by forwarding the adversary's guess  to the challenger.

Observe, if , then we are in Hybrid 3. On the other hand, we are in Hybrid 4 if 

Thus, if adversary  can distinguish between the hybrids, then  can break the sFE sanitizer property. 
\end{proof}


\begin{claim} \label{claim:ACE_nowrite_sFE_IND-CPA}
For any adversary  that can distinguish Hybrid 4 and Hybrid 5, there exists an adversary  for the IND-CPA security of the sFE scheme such that the advantage of  is 
.
\end{claim}

\begin{proof}
Assume that any adversary wins the IND-CPA game for the sFE scheme with advantage , and assume for contradiction that we can distinguish the hybrids with advantage greater than . Then we can construct an adversary  that wins the IND-CPA game with advantage greater than .

 start by receiving the sFE public parameters from the challenger and forwards it to the challenger. The adversary's oracle queries are answered by sending secret key queries to the challenger, and otherwise using the algorithms of the construction (see the proof of Theorem~\ref{thm:ACE_sFE_no-read} for more details).
When  receives the challenge  he master decrypts the ciphertext to get . Then he checks that  and . If the check goes through he set , otherwise he sets .
Then he creates , sends  and  to the challenger, and receives back an sFE encryption . 
Next,  creates the response .
 concludes the game by forwarding the adversary's guess  to the challenger.


If  is an encryption of the message , then we are in Hybrid 4, and if it is an encryption of , then we are in Hybrid 5.
Thus, if adversary  can distinguish between the hybrids, then  can break the sFE IND-CPA security. 
\end{proof}

\begin{claim} \label{claim:ACE_nowrite_PRF_2}
For any adversary  that can distinguish Hybrid 5 and Hybrid 6, there exists an adversary  for the security of PRF  such that the advantage of  is 
. \\
\end{claim}

The proof follow the same structure as the proof for Claim~\ref{claim:ACE_nowrite_PRF_1}. \\

From these claims we can conclude that for any adversary  that can distinguish Hybrid 0 and Hybrid 6, there exists an adversary  for the PRF security, an adversary  for the sanitizer property of the sFE scheme, and an adversary  for the IND-CPA security of the sFE scheme, such that the advantage of  is

\end{proof}





\newpage
\bibliographystyle{alpha}
\bibliography{ACE}
\appendix

\clearpage

\section{Standard Building Blocks}\label{app:bb}

\subsection{Pseudorandom Function}
\begin{defi}[PRF]
We say  is a pseudorandom function if for all PPT  
 with  a uniform random function and .  \end{defi}

\subsection{Statistical Simulation-Sound Non-Interactive Zero-Knowledge Proofs} \label{app:nizk_sss}
The content of this subsection is taken almost verbatim from~\cite{DBLP:conf/focs/GargGH0SW13}.
Let  be a language and  a relation such that  if and only if there exists a witness  such that .
A non-interactive proof system \cite{DBLP:conf/stoc/BlumFM88} for a relation  is defined by the following PPT algorithms
\begin{description}
\item[Setup:] The  algorithm takes as input the security parameter  and outputs common reference string .

\item[Prove:] The  algorithm takes as input the common reference string , a statement , and a witness , and outputs a proof .

\item[Verify:] The  algorithm takes as input the common reference string , a statement , and a proof . It outputs  if it accepts the proof, and  otherwise.
\end{description}

The non-interactive proof system must be complete, meaning that if   and  then   
Furthermore, the proof system must be statistical sound, meaning that no (unbounded) adversary can convince a honest verifier of a false statement.
Moreover, we define the following additional properties of a non-interactive proof system.


\begin{defi}[Computational Zero-Knowledge]A non-interactive proof  is computational zero-knowledge if there exists a polynomial time simulator  such that for all non-uniform polynomial time adversaries  we have for all  that
	\begin{center}
		\\
		 \\
				
	\end{center}
where  is the common reference string,  is the statement,  is the witness,  is the proof, and  is the trapdoor.
\end{defi}

Thus, the definition states that the proof do not reveal any information about the witness to any bounded adversary.
In the definition this is formalized by the existence of two simulators, where  returns a simulated common reference string together with a trapdoor that enables  to simulate proofs without access to the witness.


\begin{defi}[Statistical Simulation-Soundness]A non-interactive proof  is statistical simulation-sound (SSS) if for all statements  and all (unbounded) adversaries  we have that
	
	where  is negligible in the security parameter.
\end{defi}

Thus, the definition states that it is not possible to convince a honest verifier of a false statement even if the adversary is given a simulated proof.


\begin{remark}
If a proof system is statistical simulation-sound then it is also statistical sound. Thus, we can upper bound the negligible probability of statistical soundness by the negligible probability of the statistical simulation-soundness. 
\end{remark}
\subsection{Indistinguishability Obfuscation}
\newcommand{\Obf}{iO}
\newcommand{\Circs}{\mathcal{C}}
\newcommand{\obf}[1]{\bar{#1}}
\newcommand{\poly}{\mathsf{poly}}
\newcommand{\Adv}{\mathcal{A}}


We use an \emph{indistinguishability obfuscator} like the one proposed in~\cite{DBLP:conf/focs/GargGH0SW13} such that  which takes any polynomial size circuit  and outputs an obfuscated version  that satisfies the following property.
\begin{defi}[Indistinguishability Obfuscation] \label{def:io} We say  is an \emph{indistinguishability obfuscator} for a circuit class  if for all  such that  and  it holds that:
\begin{enumerate}
\item ;
\item   
\item  for all PPT :

\end{enumerate}
\end{defi}








\section{Equivalent Definition of the No-Write Rule}
In this section we provide an alternative definition of the No-Write rule and we prove that this is equivalent to the No-Write rule of Definition~\ref{def:ACEnowrite} (Section~\ref{sec:definition}). The alternative definition is used in the proof of Theorem~\ref{thm:no-write}.
In Definition~\ref{def:ACEnowrite} the challenger chooses, encrypts and sanitizes a random message if . In the following definition, we will let the adversary choose the message to be encrypted and sanitized in case . Thus, we replace the randomly chosen message with an adversarial chosen message.



\begin{defi}[Alternative No-Write Rule] \label{def:alternativeACEnowrite}
Consider the following game between a challenger  and a stateful adversary :
\begin{center}
\begin{small}
    \begin{tabular}{| p{6.5cm} | p{5cm} |}
    \hline
	\multicolumn{2}{|c|}{\textbf{\emph{No-Write Rule}}} \\
	\hline
	\multicolumn{1}{|c|}{\textbf{\emph{Game Definition}}} & \multicolumn{1}{|c|}{\textbf{\emph{Oracle Definition}}}  \\
	\hline
	\

	1. ;

	2. ;

	3. ;

	4. ;

	5. , 
	\begin{itemize}
		\item If , ; 
		\item If , ;
	\end{itemize}
	6. ;

	&
	\
	
	: \newline 1. Output ;

	\ 

	: \newline 1. Output ;

	\ 


	: 

	1. ;

	2. ;
	
	3. Output ;

	\\
	\hline
	\end{tabular}
\end{small}
\end{center}
Let  (resp. ) be the set of all queries  that  issues to  (resp. both  and ). Let  be the set of all  such that  and let  be the set of all  such that . Then we say that  \emph{wins the No-Write game} if  and all of the following hold:
\begin{enumerate}
	\item ;
	\item ;
	\item ,  ;
\end{enumerate}
We say an ACE scheme satisfies the \emph{No-Write rule} if for all PPT 
 
\end{defi}

\newcommand{\ACEscheme}{\mathsf{ACE}}
\begin{lem} \label{lem:nowrite_equiv}
Let  be a correct ACE scheme that satisfies the \emph{No-Read Rule}. Then  satisfies the alternative \emph{No-Write Rule} from Def.~\ref{def:alternativeACEnowrite} iff it satisfies the \emph{No-Write Rule} from Def.~\ref{def:ACEnowrite}.
\end{lem}

\setcounter{claimcounter}{0}
\begin{proof}
The lemma is proven by splitting the bi-implication in two cases:

\ \newline
\noindent\textbf{Def.~\ref{def:alternativeACEnowrite} implies Def.~\ref{def:ACEnowrite}.}
Assume that  satisfies the alternative no-write rule, and assume for contradiction that there is an adversary  that wins the ACE no-write game (from Def.~\ref{def:ACEnowrite}), then we can construct an adversary  that wins the alternative ACE no-write game.

Adversary  receives the public parameters from the challenger (from Def.~\ref{def:alternativeACEnowrite}) and forwards them to the adversary . Then  performs some oracle queries, which adversary  forwards to the challenger. After the oracle queries  receives the challenge  from adversary . Next,  picks a message  and sends  to the challenger. 
The challenger respond with a sanitized ciphertext , where  if , and  if .
Adversary  forward  to . This is followed by a new round of oracle queries. Note that  corresponds to the challenge of the no-write game of Def.~\ref{def:ACEnowrite}.
Thus, we can conclude that if  wins the ACE no-write game (from Def.~\ref{def:ACEnowrite}), then  wins the alternative ACE no-write game (from Def.~\ref{def:alternativeACEnowrite}).

\ \newline
\noindent\textbf{No-Read Rule and Def.~\ref{def:ACEnowrite} implies Def.~\ref{def:alternativeACEnowrite}.}
This is proven by presenting a series of hybrid games.

\paragraph{Hybrid 0.} The alternative no-write game (Def.~\ref{def:alternativeACEnowrite}) for .

\paragraph{Hybrid 1.} As Hybrid 0, except the challenger ignores the message  send by the adversary and draws its own message  to encrypt.

\paragraph{Hybrid 2.} As Hybrid 1, except .

\paragraph{Hybrid 3.} The alternative no-write game (Def.~\ref{def:alternativeACEnowrite}) for .

\begin{claim}
Assume that the ACE scheme  satisfies the no-read rule, then Hybrid 0 and Hybrid 1 are indistinguishable.
\end{claim}

\begin{proof}
Assume for contradiction that there is an adversary  that can distinguish between the hybrids, then we can construct an adversary  that wins the no-read game from Def.~\ref{def:ACEnoread}.

Adversary  forwards the public parameter from the challenger (of the no-read game) to adversary , and forwards the oracle queries made by  to the challenger. Note that  plays the alternative no-write game, where the allowed oracle queries are a strict subset of the allowed oracle queries in the no-read game. 
Next,  sends the challenge  to , who draws a random message  and sends  to the challenger. 
The challenger draws a random bit  and responds with  if , and  if . 
Adversary  queries the challenger for the sanitizer key , sanitizes the challenge ciphertext  and sends  to adversary , who performs a new set of oracle queries. 
Note, if  then we are in Hybrid 0 and if  then we are in Hybrid 1, which means that if adversary  can distinguish between the hybrids, then adversary  breaks the no-read rule. Thus, Hybrid 0 and Hybrid 1 are indistinguishable.
\end{proof}

\begin{claim}
Assume that the ACE scheme  satisfies the no-write rule from Def.~\ref{def:ACEnowrite}, then Hybrid 1 and Hybrid 2 are indistinguishable.
\end{claim}

\begin{proof}
Assume for contradiction that there is an adversary  that can distinguish between the hybrids, then we can construct an adversary  that wins the no-write game (from Def.~\ref{def:ACEnowrite}).

Adversary  forwards the public parameter from the challenger (from Def.~\ref{def:ACEnowrite}) to adversary , and forwards the oracle queries made by  to the challenger. 
Next,  receives the challenge  from adversary  and forward  to the challenger.
The challenger draws a random bit  and responds with  for random  if , and  if . 
Adversary  forwards  to , which is followed by a new round of oracle queries. 
Note, if  then we are in hybrid 1, and if  then we are in hybrid 2, which means that if adversary  can distinguish between the hybrids, then adversary  breaks the no-read rule. Thus, Hybrid 1 and Hybrid 2 are indistinguishable.
\end{proof}

\begin{claim}
Hybrid 2 and Hybrid 3 are identical.
\end{claim}

\begin{proof}
In both hybrids the adversary sends the challenge  and the challenger will in both cases respond with .
\end{proof}

Thus, we can conclude that the alternative definition of the no-write rule presented in Def.~\ref{def:alternativeACEnowrite} is equivalent to the no-write rule presented in Def.~\ref{def:ACEnowrite} in Section~\ref{sec:definition}.
\end{proof}





\section{Linear ACE}

\subsection{ACE for a Single Identity from Pailler}\label{app:onepailler}

Our second instantiation of \oACE is based on Pailler's cryptosystem~\cite{DBLP:conf/eurocrypt/Paillier99,DBLP:conf/pkc/DamgardJ01}. The scheme uses the same high level idea as the DDH-based instantiation.


\begin{construction} \label{con:onePailler} Let  be a \oACE scheme defined by the following algorithms:
\end{construction}
\begin{description}
\item[Setup and Key Generation:] The public parameters  contain the modulus  and the master secret key  is the factorization of . The encryption key for the only identity in the system is  for a random  and the sanitizer key is . Finally the decryption key  is the master secret key .
Furthermore, the message space is  and the ciphertext spaces are  and .

\item[Encryption:] To encrypt a message  with identity  first sample  and then output:


(and encryptions for the identity  are random .)

\item[Sanitizer:] On input  and the randomization key  sample  and then output 


\item[Decryption:] On input  and the decryption key run the decryption of Pailler cryptosystem to get  from . 
\end{description}


\begin{lem} Construction~\ref{con:onePailler} is a \emph{correct} \oACE scheme satisfying the \emph{No-Read} and the \emph{No-Write Rule} assuming the Pailler's assumption holds.
\end{lem}

\begin{proof} \emph{Correctness:} Correctness follows from inspection: thanks to the homomorphic properties of Pailler . \\

\noindent \emph{No-Read Rule:} Exactly as in Lemma~\ref{lem:elgamal} we only need to prove that honest encryptions are indistinguishable from a random element in , which follows in a straightfoward way from the Pailler assumption: both  and  are fresh Pailler encryptions using independent random values , and the assumption says that  with  is indistinguishable from a random element in . \\

\noindent \emph{No-Write Rule:} As in Lemma~\ref{lem:elgamal} there are only two cases, depending on which keys the adversary asks for \emph{before} producing the challenge ciphertext  and identity : 1) the adversary asks for  before issuing his challenge  with  (and receives no more keys during the distinguishing phase) and 2) the adversary asks for  before issuing his challenge  and then asks for  during the distinguishing phase. Case 1) follows directly from the security of Pailler cryptosystem: without access to the decryption key the output of the sanitizer is indistinguishable from a random ciphertext thanks to the choice of the random . In case 2) instead the adversary has the decryption key, and we therefore need to argue that the distribution of  is independent of its input unconditionally. Given any  we can write:

Then the output  is

Which is distributed exactly as a uniformly random ciphertext  with  since for all  there exists  such that 

Which is guaranteed unless  which happens only with negligible probability thanks to the principle of deferred decisions.
\end{proof}




\subsection{The Repetition Scheme - Proofs}\label{app:repetitionproofs}


\begin{lem}
Assume that  is a correct \oACE scheme.
Then the ACE scheme  from Construction~\ref{con:ACE} enjoys correctness.
\end{lem}

\begin{proof}
Given any  such that .
Let  be an honest encryption of  under encryption key , and let  be a honest sanitized version of .
Thus, the ciphertext  is a honest created \oACE encryption (since ), and  is a sanitized version of . 
Observe, given the decryption key , the decryption algorithm  decrypts the 'th  ciphertext.
This means that


The last inequality comes from the correctness of the \oACE scheme.
Thus, we can conclude that  enjoys correctness.
\end{proof}



\begin{thm} \label{thm:no-read}
Assume that  is a \oACE scheme that satisfies the \emph{No-Read Rule}, and let  be the ACE scheme from Construction~\ref{con:ACE} using  as the underlying \oACE scheme. Then  satisfies the \emph{No-Read Rule}.
\end{thm}

\begin{proof}
Let  be the set of all queries  that the adversary issues to the oracle , and let  be the set of all  such that . 

The no-read rule is shown by presenting a series of hybrid games such that no adversary can distinguish between two successive hybrid games with non-negligible probability.
In the hybrid games we  replace the encryption algorithm with the algorithm: , which starts by encrypting the two messages  and  under the keys  and  to get 

Next, the algorithm outputs the following ciphertext , where the first  positions are the first  \oACE ciphertexts from , and the last  positions are the last  \oACE ciphertexts from .

\paragraph{Game 0.} The no-read game with ;
\paragraph{Hybrid  for .} Like Game 0 but the encryption algorithm is replaced by the  algorithm;
\paragraph{Game 1.} The no-read game with ;


\ \newline
\noindent\textbf{Payload Privacy.} 
The conditions for the payload privacy property states that for all  it holds that .
This means that for all  we have that  for .

\paragraph{Game 0  Hybrid 0.} 
In  Game 0 the ciphertext is generated by running , while in Hybrid 0 the ciphertext is generated by running 
From the description of the algorithm  we can conclude that  is an encryption of  generated by the  algorithm using key .
Thus, the two ciphertexts are identically distributed, which means that Game 0 and Hybrid 0 are identical and therefore indistinguishable to any adversary.

\paragraph{Hybrid   Hybrid .} 
The only difference between the two hybrids is the following: in Hybrid  the 'th \oACE ciphertext is the 'th ciphertext from , while in Hybrid  the 'th \oACE ciphertext is the 'th ciphertext from .

Observe that in  for  the 'th ciphertext is a \oACE encryption of message  under key  if , otherwise the ciphertext is taken uniformly random from the \oACE ciphertext space .
Thus, we look at four cases
\begin{enumerate}
\item  and 
\item  and 
\item  and 
\item  and 
\end{enumerate}

Notice, from the condition of the the payload privacy we have that the adversary is only allowed to ask for the decryption key  if  for . 
Thus, if the adversary gets , then we are in Case 1.

In Case 1 the two ciphertexts are clearly indistinguishable, since they are chosen uniformly random from the same ciphertext space. 

In Case 2 and 3, the adversary does not have the decryption key . If the adversary  is able to distinguish between Hybrid  and Hybrid , then we can construct a new adversary  that breaks the no-read rule of the \oACE scheme. 
Intuitively this is done as follow: when  receives the challenge from adversary  he forwards the messages together with identities 1 and 0, and receives back a \oACE ciphertext  from the \oACE challenger. Then  creates the challenge ciphertext as in Hybrid , replaces the 'th \oACE ciphertext by , and sends the ciphertext to the adversary. 
 will answer adversary 's queries as follows
\begin{itemize}
\item  queries  where , then  queries the challenger for encryption key , and construct the rest of the encryption key  honestly.
\item  queries , then  queries the challenger for the sanitizer key , and construct the rest of the sanitizer key  honestly.
\item  queries  where  for , then  sends the query  to the challenger, receives back a ciphertext , and construct the rest of the response honestly. 
\item For all other queries  will answer using the algorithms of the scheme.
\end{itemize}
Notice,  will never query  since then we would not be in case 2 or 3. Thus,  never has to query the challenger for .
If  wins the no-read game with non-negligible probability, then so does adversary . This contradicts our assumption that the \oACE scheme satisfies the no-read rule. Thus, adversary  cannot distinguish between the two hybrids.






In Case 4, the adversary does not have the decryption key . To argue that the two ciphertexts are indistinguishable, we use an intermediate step. Following the same arguments as above, we argue that  is indistinguishable from a random ciphertext , and then we argue that  is indistinguishable from .
Thus, the two ciphertexts are indistinguishable.


\paragraph{Hybrid   Game 1.} 
In  Game 1 the ciphertext is generated by running , while in Hybrid  the ciphertext is generated by running 
From the description of the algorithm  we can conclude that  is actually an encryption of  generated by the  algorithm using key .
Thus, the two ciphertexts are identically distributed, which means that Game 1 and Hybrid  are identical and therefore indistinguishable to any adversary.

\ \newline
\noindent\textbf{Sender Anonymity.} 
The conditions for the sender anonymity property states that for all  it holds that  and .
This means that for all  we have that  is either in both encryption keys  for , or not in any of the two.


\paragraph{Game 0  Hybrid 0.} The same arguments as in the payload privacy case.

\paragraph{Hybrid   Hybrid .} 
The only difference between the two hybrids is the following: in Hybrid  the 'th \oACE ciphertext is the 'th ciphertext from , while in Hybrid  the 'th \oACE ciphertext is the 'th ciphertext from .
Again, we look at four cases depending on whether  for some 
\begin{enumerate}
\item  and 
\item  and 
\item  and 
\item  and 
\end{enumerate}

Notice, from the condition of the sender anonymity property, we have that the adversary can ask for the decryption key , iff  for all . Thus, if the adversary queries  then we are in Case 1 or 4. 

In Case 1, the two ciphertexts are indistinguishable, since they are chosen uniformly random from the same ciphertext space. 

In Case 2 and 3, the adversary does not have the decryption key . Thus, if the adversary can distinguish between the two hybrids, then he breaks the no-read rule of the \oACE scheme (see Case 2 and 3 for payload privacy). 

In Case 4, we have , and the adversary is allowed to get the corresponding decryption key . If the adversary queries , then the condition states that . Thus, the two \oACE ciphertexts are encryptions of the same message under the same \oACE encryption key. Thus, the adversary cannot distinguish between the hybrids.
If the adversary does not ask for the decryption key , then we are in the same situation as in Case 4 for payload privacy.

\paragraph{Hybrid   Game 1.} The same arguments as in the payload privacy case.


\end{proof}



\begin{thm} \label{thm:no-write}
Assume  is a \oACE scheme that satisfies the \emph{No-Write Rule}, and let  be the ACE scheme from Construction~\ref{con:ACE} using  as the underlying \oACE scheme. Then  satisfies the \emph{No-Write Rule}. 
\end{thm}

\begin{proof}
This theorem is shown by presenting a series of hybrid games such that no adversary can distinguish between two successive hybrids with non-negligible probability.

In the hybrid games we  replace the encryption/sanitization algorithm with a special challenge ciphertext generation algorithm: , which takes the encryption key , the sanitizer key , a random element  from the message space, and the ciphertext  generated by the adversary. The algorithm then encrypts and sanitizes message  to get 
 
and sanitizes the ciphertext  to get 
 
Finally, the algorithm outputs the following ciphertext , where the first  positions are sanitized encryptions of a random message, and the last  are sanitizations of the adversary's ciphertext.

\paragraph{Game 0.} The no-write game with 
\paragraph{Hybrid  for .} Like Game 0 but replace the encryption algorithm with the special challenge ciphertext generation algorithm .
\paragraph{Game 1.} The no-write game with 

\paragraph{Game 0  Hybrid 0.} 
In Hybrid 0 the ciphertext  is generated by running . From the description of this algorithm we can conclude that this is a ciphertext generated by . Thus, Game 0 and Hybrid 0 both generates the ciphertext  as a sanitized ACE encryption of a random message. Thus, Game 0 and Hybrid 0 are identical and therefore indistinguishable to any adversary.


\paragraph{Game   Hybrid .} The difference between the two hybrids is the following: in Hybrid  the 'th \oACE ciphertext is the 'th ciphertext from , while in Hybrid  the 'th \oACE ciphertext is the 'th ciphertext from . 
This give rise to the following two cases depending on whether 
\begin{enumerate}
\item  \newline and 
\item  and 
\end{enumerate}

Notice, from the condition stated by the no-write rule we have that for all  it holds that . This means that for all the encryption keys the adversary gets before the challenge and for all the decryption keys he gets during the game it must hold that the decryption keys cannot be used to decrypt anything encrypted using the encryption keys.
Specially, this means that if the adversary gets  then  (i.e.~Case 2).

In Case 1, the adversary does not get the decryption key . However, he has queried the encryption key , which contains .
If the adversary  is able to distinguish between Hybrid  and Hybrid , then he is able to distinguish between the case where the 'th \oACE ciphertext is created as a sanitized encryption of message  or the sanitization of his ciphertext. This means that we can construct an adversary  that wins the alternative No-Write game (Def.~\ref{def:alternativeACEnowrite}, equivalent to Def.~\ref{def:ACEnowrite} by Lemma~\ref{lem:nowrite_equiv}) for the \oACE scheme with non-negligible probability. (Note that here it is necessary to use the alternative No-Write game since the reduction must encrypt the same random value  in all positions.) Intuitively, this is done by letting  create the ciphertext  as in Hybrid , forward the challenge , and replacing the 'th \oACE ciphertext by the one he receives from the challenger. Finally, he sends the new ciphertext to the adversary . 


If  wins the game with non-negligible probability, then so does the adversary . This gives us a contradiction with the assumption that the \oACE scheme satisfies the no-write rule. Thus, we can conclude that  cannot distinguish between the two hybrids.
Furthermore, notice that the adversary  can query encryption keys , where . In this case the adversary   queries his challenger for the encryption key . This  never conflicts the no-write game for the \oACE scheme, since the adversary  never queries the decryption key . 

In Case 2, the adversary can freely query the decryption and encryption keys as long as he respect the conditions of the no-write game: 1) He can query  iff  for all , 2) He can query any encryption key after the challenge.
If the adversary  can distinguish between the two hybrids, we can create an adversary  that wins the alternative no-write game (Def.~\ref{def:alternativeACEnowrite}) for the \oACE scheme. 
Intuitively, this is done by letting  create the ciphertext  as in Hybrid , forward the challenge together with message , and replacing the 'th \oACE ciphertext by the one he receives from the challenger.
Notice that if adversary  queries the decryption key , then he cannot query any encryption key  for , which contains . 
Thus, adversary  can query to get the decryption key  but does not query for the encryption key  until after the challenge.
This means that the \oACE ciphertext  send by the challenger is either a random \oACE ciphertext or a sanitization of .
If  wins the game with non-negligible probability, then so does the adversary . This gives us a contradiction with the assumption that the \oACE scheme satisfies the no-write rule. Thus, we can conclude that  cannot distinguish between the two hybrids.

If the adversary does not query the decryption key , then he can either query an encryption key , where  before the challenge (i.e.~Case 1), or after the challenge (equivalent to Case 2). 
Furthermore, notice that in both cases all encryption queries  are answered by sending the message to the challenger to get the 'th \oACE sanitized ciphertext for the response. 

\paragraph{Hybrid   Game 1.} 
In Hybrid  the ciphertext  is generated by running . From the description of this algorithm we can conclude that this is actually a ciphertext generated by . Thus, Game 1 and Hybrid  both generates the ciphertext  as a sanitized version of the ciphertext . Thus, Game 1 and Hybrid  are identical and therefore indistinguishable to any adversary.



\end{proof}









\section{Sanitizable Functional Encryption Scheme - Proofs}

\subsection{Proof of Lemma~\ref{lem:IND-CPA_sFE}}\label{app:IND-CPA_sFE}
\setcounter{claimcounter}{0}

In this appendix we show the full adaptive proof of the IND-CPA security for Construction~\ref{con:sanFE}. The proof follows closely the selective IND-CPA security proof of the functional encryption scheme presented by Garg et. al.~\cite{DBLP:conf/focs/GargGH0SW13}. 
The main differences between the proof are the following: we enhance their proof by making it adaptive and quantifying the advantage of the adversary. Furthermore, we make a small change in the proof of the valid iO instance, which make the proof work for our sanitizable version of the functional encryption scheme.

\paragraph{Game 0.} The IND-CPA security game where ;

\paragraph{Game 1.} The IND-CPA security game where ; \\

Before proving that Game 0 and Game 1 are indistinguishable, we prove that the following sequence of hybrids are indistinguishable. 

\paragraph{Hybrid 0.} The challenger choose uniformly random two messages . Then he proceeds as in Game 0 with the exception that when he receives  and  from the adversary, then he checks that  and . If this is not the case, then the challenger aborts the game, otherwise he continues as in Game 0.

\paragraph{Hybrid 1.} The same as Hybrid 0, except that after choosing the messages  and , the challenger encrypts message  twice:  for . Then the challenger simulates the common reference string  and NIZK proof  as follows
	
	where  is the statement we want to prove (see definition of  in Construction~\ref{con:sanFE}). Note: the challenger still checks that  and .

\paragraph{Hybrid 2.} The same as Hybrid 1, except that we change the message of the second PKE ciphertext. Thus, the ciphertexts are computed as follows
	
	Note:  and  are still simulated.

\paragraph{Hybrid 3, for .} The same as Hybrid 2, except that in the first  secret key queries the secret key is generated as an obfuscation of program , while in the last  secret key queries the secret key is generated as an obfuscation of program .
Observe, Hybrid 2 and Hybrid 3,0 are identical.

\begin{center}
\begin{small}
    \begin{tabular}{| p{6cm} | p{6cm} |}
	\hline
	\multicolumn{1}{|c|}{\textbf{\emph{Program} }} & \multicolumn{1}{|c|}{\textbf{\emph{Program} }}\\
	\hline 
	\
	
	Input: ; 
	
	Const: ;
	
	\

	1. If ;
	\begin{itemize}
		\item[] output ;
	\end{itemize}

	2. else output fail;

	&
	\

	Input: ; 
	
	Const: ;
	
	\

	1. If ;
	\begin{itemize}
		\item[] output ;
	\end{itemize}

	2. else output fail;

	\\
	\hline
	\end{tabular}
\end{small}
\end{center}

\paragraph{Hybrid 4.} The same as Hybrid , except that we change the message of the first PKE ciphertext. Thus, the ciphertexts are computed as follows
	

\paragraph{Hybrid 5, for .} The same as Hybrid 4, except that in the first  secret key queries the secret key is generated as an obfuscation of program , while in the last  secret key queries the secret key is generated as an obfuscation of program .
Observe, Hybrid 4 and Hybrid 5,0 is identical.

\paragraph{Hybrid 6.} The same as Hybrid , except that  and  is generated honestly, and the PKE ciphertexts are generated as in  Hybrid , but after we see the challenge, and have checked that  and . \\

We  now show that each sequential pair of the hybrids are indistinguishable.


\begin{claim} \label{claim:sFE_IND-CPA_ZK_1}
For any adversary  that can distinguish Hybrid 0 and Hybrid 1, there exists an adversary  for the computational zero-knowledge property of the SSS-NIZK scheme such that the advantage of  is
	
\end{claim}



\begin{proof}
Assume that any adversary breaks the computational zero-knowledge property with advantage at most .
Assume for contradiction that there exists an adversary  that distinguishes the hybrids with advantage greater than , then we can construct a poly-time adversary  that breaks the computational zero-knowledge property with advantage greater than . 

 begins by choosing  uniformly random. Then he computes the PKE public and secret keys honestly, and runs one copy of the NIZK setup algorithm: . Next,  encrypts message  under both public keys:  for , and sends  and  to the zero-knowledge challenger. In return  receives , and he uses  and . Thus,  lets the public parameters , and the challenge response . 
The rest of the game follow the structure of the sFE IND-CPA game, and concludes with  forwarding 's response  to the challenger. 

Observe, if the challenger generates  and  honestly, then we are in Hybrid 0, and if the challenger simulates the proof, then we are in Hybrid 1. Thus, if adversary  can distinguish the hybrids with advantage greater than , then adversary  can break the computational zero-knowledge property of the SSS-NIZK scheme with advantage greater than . Thus, we reach a contradiction.
\end{proof}

\begin{claim} \label{claim:sFE_IND-CPA_PKE_1}
For any adversary  that can distinguish Hybrid 1 and Hybrid 2, there exists an adversary  for the IND-CPA security game of the sanitizable PKE scheme such that the advantage of  is
	
\end{claim}

\begin{proof}
Assume that any adversary wins the IND-CPA security game with advantage at most .
Assume for contradiction that there exists an adversary  that distinguishes the hybrids with advantage greater than , then we can construct a poly-time adversary  that breaks the PKE IND-CPA security with advantage greater than . 

 begins by choosing  uniformly random. Then he computes  and , and he runs one copy of the NIZK setup algorithm: . He then receives a second public key  from the challenger, and sets . Next, he sends  to the challenger at receives back , and sets . Then  uses the SSS-NIZK simulator to generate  and  for the statement . Then,  sets the public parameters , and the challenge response . 
The rest of the game follow the structure of the sFE IND-CPA game, and concludes with  forwarding 's response  to the challenger. 

Observe, if the challenger encrypts  then we are in Hybrid 1, and if the challenger encrypts  then we are in Hybrid 2. Thus, if adversary  can distinguish the hybrids with advantage greater than , then adversary  can break the IND-CPA security of the PKE scheme with advantage greater than . Thus, we reach a contradiction.
\end{proof}


\begin{claim} \label{claim:sFE_IND-CPA_iO_1}
For any adversary  that can distinguish Hybrid  and Hybrid , there exists an adversary  for iO such that the advantage of  is
	
	where  is the negligible probability of the statistical simulation-soundness for the SSS-NIZK scheme.
\end{claim}

\begin{proof}
Assume that any adversary wins the iO indistinguishable game with advantage at most .
Assume for contradiction that there exists an adversary  that distinguishes the hybrids with advantage greater than , then we can construct a poly-time adversary  that breaks the iO property with advantage greater than . 

 begins by choosing  uniformly random. Then he runs two copies of the PKE setup algorithm and encrypts:  and . Next, he runs the SSS-NIZK setup algorithm to get , and uses the SSS-NIZK simulators to get  and  for statement . Then,  sets the public parameters , and the challenge response . 
Next, the game follows the structure of the sFE IND-CPA game, except the secret key queries are generated as follows
\begin{itemize}
\item For  the 'th secret key is generated as the obfuscation of program 
\item For  the 'th secret key is generated as the obfuscation of program 
\item For  the 'th secret key is generated as follows:  sends  and  to the challenger, and receives back an obfuscated program , which  sends to  as the 'th secret key.
\end{itemize}
 concludes the game by forwarding 's response  to the challenger.  \\

Assume that the two programs  and  are a valid iO instance, then we observe: if the challenger obfuscates program , then we are in Hybrid , and if the challenger obfuscates program , then we are in Hybrid . Thus, if adversary  can distinguish the hybrids with advantage greater than , then adversary  can break the iO property with advantage greater than . 

If the two program are not a valid iO instance, then  does not follow the rules of the iO game, and cannot win the game. Let  be the probability that the two programs are a valid iO instance. Then the adversary  can break the iO property with advantage greater than . \\

Next, we prove that  and  are a valid instance with probability .
To prove this we look at the possible inputs to the program. Let  denote the sanitization of .
\begin{enumerate}
\item  is a correct encryption of some message (i.e.,  and  are encryption of the same message, and  is a proof of that), and  is a correct sanitization of ciphertext  (i.e.,  is a PKE sanitization of  for , and  is a proof of that and a proof that  is a correct proof).
\item  and  are PKE encryptions of different messages, but the proof  verifies, and  is a correct sanitization of ciphertext .
\item  is an incorrect ciphertext such that the proof  does not verify, and  is a correct sanitization of .
\item  is an incorrect sanitized ciphertext such that the proof  does not verify.
\end{enumerate}

Case 1: the proof  passes the verification, and both programs  decrypt to the same message and compute the same function. 

Case 2: the statistical simulation-soundness of the SSS-NIZK used in the encryption gives us that with probability negligible close to one, this only happens if  and  (i.e. the ciphertext for which the proof was simulated). Since the simulated proof can be verified, we can construct a correct proof  that also verifies. Thus, program  decrypts  to  and outputs , while  decrypts  to  and outputs . Thus, the two program have the same output, since . 
This means that the two programs have different output on the same input with negligible probability .

Case 3: the statistical soundness property of the SSS-NIZK used in the sanitization gives us that this is impossible with probability negligible close to one. Since the proof  does not verify, we cannot construct a proof  that verifies. 
Thus, the two programs have different output on the same input with negligible probability .

Case 4: The verification of the proof  does not pass in both programs. Thus, both programs outputs fail. \\

This means, that the combined probability that the two programs have different output on the same input can be upper bounded by  . Thus, the probability that the two programs are a valid iO instance is .
\end{proof}



\begin{claim} \label{claim:sFE_IND-CPA_PKE_2}
For any adversary  that can distinguish Hybrid  and Hybrid 4, there exists an adversary  for the IND-CPA security game of the sanitizable PKE scheme such that the advantage of  is
	
\end{claim}

The proof of the claim follow the same structure at the proof of Claim~\ref{claim:sFE_IND-CPA_PKE_1}.

\begin{claim} \label{claim:sFE_IND-CPA_iO_2}
For any adversary  that can distinguish Hybrid  and Hybrid , there exists an adversary  for iO such that the advantage of  is
	
	where  is the negligible probability of the statistical simulation-soundness for the SSS-NIZK scheme. \\
\end{claim}

The proof of the claim follow the same structure at the proof of Claim~\ref{claim:sFE_IND-CPA_iO_1}.

\begin{claim} \label{claim:sFE_IND-CPA_ZK_2}
For any adversary  that can distinguish Hybrid  and Hybrid 6, there exists an adversary  for the computational zero-knowledge property of the SSS-NIZK scheme such that the advantage of  is
	
\end{claim}

The proof of the claim follow the same structure at the proof of Claim~\ref{claim:sFE_IND-CPA_ZK_1}. \\

From these claims we can conclude that for any adversary  that can distinguish Hybrid 0 and Hybrid 6, there exists an adversary  for the computational zero-knowledge property of the SSS-NIZK scheme, an adversary  for the IND-CPA security game of the sanitizable PKE scheme, and an adversary  for iO such that the advantage of  is
	
	where  is the number of the secret key queries the adversary makes during the game.

We conclude the proof of Lemma~\ref{lem:IND-CPA_sFE} by proving that for any adversary  that can distinguish Game 0 and Game 1, there exists an adversary  that can distinguish Hybrid 0 and Hybrid 6 such that the advantage of  is 

Assume that any adversary  can distinguish Game 0 and Game 1 with advantage . 
We start by changing the game such that the challenger guesses the two messages in the beginning of the games, and aborts if the guesses is wrong. Thus, the advantage of the adversary is now .
Observe, the two new games are identical to Hybrid 0 and Hybrid 6. Thus, we get the inequality which concludes the proof.




\subsection{Proof of Lemma~\ref{lem:Sanitize_sFE}}\label{app:Sanitize_sFE}
\setcounter{claimcounter}{0}

In this appendix we show that Construction~\ref{con:sanFE} fulfils the sanitizable property from Definition~\ref{def:FEnowrite}.
Lets define the following games
\paragraph{Game 0.} The sanitization game where ;
\paragraph{Game 1.} The sanitization game where ; \\

Before proving that Game 0 and Game 1 are indistinguishable, we  prove that the following sequence of hybrids are indistinguishable. 

\paragraph{Hybrid 0.} The challenger chooses a uniformly random message . Then he proceeds as in Game 0 with the exception that when he receives  from the adversary, he first checks that . If this is not the case, then the challenger aborts the game, otherwise he continues as in Game 0.

\paragraph{Hybrid 1.} The same as Hybrid 0, except that the challenger encrypts the message  twice and sanitizes the two encryptions
	
	When the challenger receives the challenge  he checks that , constructs the proof  honestly, and sends the respond: .

\paragraph{Hybrid 2.} The same as Hybrid 1, except that after choosing the messages , the challenger generates the PKE keys  and generates . 
Next, the challenger encrypts the message  twice and sanitizes the two encryptions
	
Then the challenger simulates the common reference string  and NIZK proof  as follows
	
	where  is the statement we want to prove (see definition of  in Construction~\ref{con:sanFE}). 
Thus, the public parameters are , the master secret key is , and the challenger response is .
When receiving the challenge  from the adversary, the challenger still checks that .

\paragraph{Hybrid 3.} The same as Hybrid 2, except that after choosing the messages  we generate the system parameters honestly and send them to the adversary. 
Next and before seeing the challenge, the challenger generates two PKE encryptions of the message  and sanitizes them as in Hybrid 1 to get  and . Then he generates the proofs  and  honestly. Thus, the challenge response is .
After receiving the challenge , the challenger still checks that  before sending .

\paragraph{Hybrid 4.} The challenger chooses a uniformly random message . Then he proceeds as in Game 1 with the exception that when he receives  from the adversary, then he checks that . \\

We now show that each sequential pair of the hybrids are indistinguishable.

\begin{claim} \label{claim:sFE_san_PKE}
Hybrid 0 and Hybrid 1 are identical.
\end{claim}

\begin{proof}
Let  and  be the PKE encryptions from the challenge . The perfect sanitization property of the PKE scheme (see Definition~\ref{def:PKE_sanitation}) states that given , , , and  there exists some randomness  and  such that
	
Thus, we can conclude that two hybrids are identical (note that this randomness only need to exist for the argument to go through, not to be efficiently computable). 
\end{proof}


\begin{claim} \label{claim:sFE_san_ZK_1}
For any adversary  that can distinguish Hybrid 1 and Hybrid 2, there exists an adversary  for the computational zero-knowledge property of the SSS-NIZK scheme such that the advantage of  is 

\end{claim}

\begin{proof} 
Assume that any adversary breaks the computational zero-knowledge property with advantage at most . Assume for contradiction that there exists an adversary  that distinguishes the hybrids with advantage greater than , then we can construct an adversary  that breaks the computational zero-knowledge property with advantage greater than .

 begins by choosing  uniformly at random. Then he computes the PKE keys  and  honestly and generates . Next, he generates an honest sFE encryption of : , and sanitizes the PKE ciphertexts:  for . 
Then it sends the statement  and the witness  to the challenger, and receives back a common reference string  and a proof . 
 then sets  and . Thus, the public parameters are , the master secret key is , and the challenger response is . 
 sends  and  to adversary , receives a challenge , checks that , and if so respond with . 

If the challenger generates  and  honestly, then we are in Hybrid 1, and if the challenger simulates the proof, then we are in Hybrid 2. 
Thus, if adversary  can distinguish between the hybrids with advantage greater than , then adversary  can break the computational zero-knowledge property with advantage greater than .
\end{proof}


\begin{claim} \label{claim:sFE_san_ZK_2}
For any adversary  that can distinguish Hybrid 2 and Hybrid 3, there exists an adversary  for the computational zero-knowledge property of the SSS-NIZK scheme such that the advantage of  is 

\end{claim}

The proof of this claim follows the same structure as the proof of Claim~\ref{claim:sFE_san_ZK_1}. 

\begin{claim} \label{claim:sFE_san_identical}
Hybrid 3 and Hybrid 4 are identical. 
\end{claim}

\begin{proof} 
In both hybrids, we check that the received challenge  is an encryption of the message , we guessed in the beginning of the game. 
In Hybrid 3, we create an honest encryption and sanitization of the message  before seeing the challenge . 
In Hybrid 4, we decrypt the challenge  to get the message  (same as the one we guessed), then we create an honest encryption and sanitization of the message. 
Thus, the two hybrids are identical. 
\end{proof}

From these claims we can conclude that for any adversary  that can distinguish Hybrid 0 and Hybrid 4, there exists an adversary  for the computational zero-knowledge property of the SSS-NIZK scheme such that the advantage of  is at most .

We conclude the proof by proving that for any adversary  that can distinguish Game 0 and Game 1, there exists an adversary  that can distinguish Hybrid 0 and Hybrid 4 such that the advantage of  is
	

Assume that any adversary  can distinguish Game 0 and Game 1 with advantage . 
We start by changing the game such that the challenger guesses the message in the beginning of the games, and aborts if the guesses is wrong. Thus, the advantage of the adversary is now .
Observe, the two new games are identical to Hybrid 0 and Hybrid 4. Thus, we get the above inequality.







\end{document}
