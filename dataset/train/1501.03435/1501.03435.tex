\documentclass{article}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage[ruled,lined]{algorithm2e}
\usepackage{enumerate}
\usepackage{graphicx}
\usepackage{color}
\newtheorem{definition}{Definition:}
\newtheorem{lemma}{Lemma:}
\newenvironment{proof}{{\bf Proof:}}{\hfill {\fbox{}}}
\newtheorem{prop}{Property:}
\newtheorem{ex}{Example:}
\setlength{\textheight}{9in}
\setlength{\textwidth}{5.5in}
\setlength{\topmargin}{-0.25in}
\addtolength{\oddsidemargin}{-0.25in}
\addtolength{\evensidemargin}{-0.25in}
\begin{document}
\title{BITS-Tree -- An Efficient Data Structure for Segment Storage and Query Processing}
\author{K.S. Easwarakumar\thanks{Corresponding Author.Email: easwara@cs.annauniv.edu} and T.Hema\thanks{Email: hema@cs.annauniv.edu}\\Department of Computer Science \& Engineering\\ Anna University, Chennai 600 025, INDIA.}
\maketitle
\begin{abstract}
In this paper, a new and novel data structure is proposed to dynamically insert and delete segments. Unlike the standard segment trees\cite{b1}, the proposed data structure permits insertion of a segment with interval range beyond the interval range of the existing tree, which is the interval between minimum and maximum values of the end points of all the segments. Moreover, the number of nodes in the proposed tree is lesser as compared to the dynamic version of the standard segment trees, and is able to answer both stabbing and range queries practically much faster compared to the standard segment trees. \\~\\
{\bf Keywords:}
Segment Trees, Stabbing Query, Threaded Binary Tree, Height Balancing.
\end{abstract}  
\section{Introduction}
Solving geometrical problems computationally seems to be difficult due to its complex nature such as varying dimensionality and shape. Several algorithms are available in literature\cite{bcko,ps} for storing and retrieving geometrical objects. Segment tree \cite{b1} is one such data structure designed to handle intervals on the real line, whose extremes belong to a fixed set of abscissas. The static segment tree requires  space, and the stabbing query processing time is , where  is the number of segments and  is the number of output segments. Though it looks reasonable in space and query processing, it does not support dynamic insertion and deletion of segments. However, in the dynamic segment trees, one can insert or delete a segment in the existing segment tree, but storage space requirements are likely get increased as the range of the tree is not based on the segment end points. The range of the tree is predefined, and one can insert or delete the segments whose interval contained in this range, thus in those cases where the range of the segment falls beyond the range of the segment tree, reconstruction of the tree is the only possibility, which is not advisable. Also, this may practically increases the time as the number of nodes to be traversed get increased.  
\par
Variants of segment trees are used in packet classification problem. One such data structure is Fat Inverted Segment Trees (FIS-trees) \cite{fm,t} with the space requirements of  and having complexity for insertion/deletion as , where  is the height of the tree. Here, the tree is compressed  (made `fat') by increasing the degree to more than two in order to decrease the height, however this has an upper bound on the total number of insertions and deletions allowed. Also, Agarwal et. al \cite{aa} proposed a linear-size data structure for the stabbing semi-group problem by combining the features of interval and segment tree, with the assumption that the end points of all intervals belong to a fixed set of points. 
\par
In this paper, a novel data structure, BITS-tree (\textbf{B}alanced \textbf{I}norder \textbf{T}hreaded \textbf{S}egment Tree),is proposed to dynamically insert and delete segments, with interval range of the node is only based on the end points of segments stored in the tree. In addition to this, it answers both stabbing and range queries efficiently. Unlike in the dynamic version of the standard segment trees, the root of the BITS-tree does not have the information of overall interval range of nodes in the tree, the BITS-tree also permits insertion of segment with any interval range, and thus it is a real dynamic tree that is suitable for all situations. 
\section{BITS-Tree}
\begin{definition}
A -tree is a height balanced two-way inorder-threaded binary tree  that satisfies the following properties.
\begin{enumerate}
\itemsep=0pt
\parskip=0pt
	\item Each node  of  associates with a range  and a list of segments containing the range .
	\item The range of a node cannot overlap with a range of any other node, other than at the end points. 
	\item The range of the nodes are sorted according to the inorder sequence. 
	\item It has a special node, called , with range  (empty), and its list is . 
	\item The inorder predecessor of the first node of the inorder sequence is . Similarly the inorder successor of the last node of the inorder sequence is .
\end{enumerate}
\end{definition}
\par
For example, consider the -tree given figure \ref{f1}.
\begin{figure}[!ht]
\begin{center}
\unitlength 1mm \linethickness{0.4pt}
\ifx\plotpoint\undefined\newsavebox{\plotpoint}\fi \begin{picture}(87.5,58.5)(0,0)
\put(-1.25,45){\line(1,0){88.75}}
\put(5,51){\line(1,0){27.75}}
\put(25.25,56.25){\line(1,0){22.25}}
\multiput(4.93,45.18)(0,.94643){15}{{\rule{.4pt}{.4pt}}}
\multiput(25.18,45.18)(0,.94643){15}{{\rule{.4pt}{.4pt}}}
\multiput(32.68,45.18)(0,.94643){15}{{\rule{.4pt}{.4pt}}}
\multiput(59.18,45.18)(0,.94643){15}{{\rule{.4pt}{.4pt}}}
\multiput(47.18,45.18)(0,.94643){15}{{\rule{.4pt}{.4pt}}}
\multiput(70.93,45.18)(0,.94643){15}{{\rule{.4pt}{.4pt}}}
\put(59.25,50.5){\line(1,0){11.75}}
\put(5,42){\makebox(0,0)[cc]{5}}
\put(26,42){\makebox(0,0)[cc]{10}}
\put(32.25,42){\makebox(0,0)[cc]{12}}
\put(47,42){\makebox(0,0)[cc]{15}}
\put(59,42){\makebox(0,0)[cc]{18}}
\put(71.25,42){\makebox(0,0)[cc]{21}}
\put(15.5,53){\makebox(0,0)[cc]{a}}
\put(37.75,58.25){\makebox(0,0)[cc]{b}}
\put(64.75,52.5){\makebox(0,0)[cc]{c}}
\put(27.25,24.25){\makebox(0,0)[cc]{[12,15]}}
\put(40,14){\makebox(0,0)[cc]{[18,21]}}
\put(12.5,14){\makebox(0,0)[cc]{[5,10]}}
\put(21.25,2.75){\makebox(0,0)[cc]{[10,12]}}
\put(26.88,23.88){\oval(14.25,6.25)[]}
\put(39.63,13.63){\oval(14.25,6.25)[]}
\put(12.13,13.63){\oval(14.25,6.25)[]}
\put(20.88,2.38){\oval(14.25,6.25)[]}
\multiput(21,22)(-.052884615,-.033653846){156}{\line(-1,0){.052884615}}
\multiput(32.75,22)(.044326241,-.033687943){141}{\line(1,0){.044326241}}
\put(17,10.75){\line(4,-5){4}}
\put(67.5,25){\makebox(0,0)[lc]{List([12,15]) = \{b\}}}
\put(67.5,17.75){\makebox(0,0)[lc]{List([5,10])=\{a\}}}
\put(67.5,10.75){\makebox(0,0)[lc]{List([10,12])=\{a,b\}}}
\put(67.5,3.5){\makebox(0,0)[lc]{List([18,21])=\{c\}}}
\put(9,10.5){\vector(0,1){.07}}\multiput(8.93,7.18)(0,.8125){5}{{\rule{.4pt}{.4pt}}}
\multiput(8.43,6.68)(-.925,-.025){11}{{\rule{.4pt}{.4pt}}}
\put(-1,22.5){\vector(0,1){.07}}\multiput(-1.07,6.68)(0,.98438){17}{{\rule{.4pt}{.4pt}}}
\put(18.75,-.75){\vector(0,1){.07}}\multiput(18.68,-4.07)(0,.8125){5}{{\rule{.4pt}{.4pt}}}
\multiput(18.68,-4.07)(-.96429,0){8}{{\rule{.4pt}{.4pt}}}
\put(12,10){\vector(0,1){.07}}\multiput(11.93,-4.07)(0,.93333){16}{{\rule{.4pt}{.4pt}}}
\put(23.25,-.75){\vector(0,1){.07}}\multiput(23.18,-4.07)(0,.8125){5}{{\rule{.4pt}{.4pt}}}
\multiput(23.43,-4.32)(.85714,.03571){8}{{\rule{.4pt}{.4pt}}}
\multiput(29.68,-4.07)(0,.94231){14}{{\rule{.4pt}{.4pt}}}
\multiput(29.43,8.43)(-.63889,.63889){10}{{\rule{.4pt}{.4pt}}}
\put(23.5,20.75){\vector(0,1){.07}}\multiput(23.43,14.68)(0,.85714){8}{{\rule{.4pt}{.4pt}}}
\put(37.5,10.25){\vector(0,1){.07}}\multiput(37.43,6.43)(0,.9375){5}{{\rule{.4pt}{.4pt}}}
\multiput(37.68,6.18)(-.85714,.03571){8}{{\rule{.4pt}{.4pt}}}
\put(31,20.25){\vector(0,1){.07}}\multiput(31.68,6.68)(-.05357,.96429){15}{{\rule{.4pt}{.4pt}}}
\put(41.25,10.25){\vector(0,1){.07}}\multiput(41.43,6.18)(-.05,.8){6}{{\rule{.4pt}{.4pt}}}
\multiput(41.68,5.68)(.875,.03125){9}{{\rule{.4pt}{.4pt}}}
\put(49,22.25){\vector(0,1){.07}}\multiput(48.68,5.68)(.01471,.97059){18}{{\rule{.4pt}{.4pt}}}
\put(10.5,21.75){}
\put(41.25,21){}
\put(23,9){}
\put(26.5,31){}
\end{picture}
 \end{center}
\caption{A -tree.}
\label{f1}
\end{figure}
The inorder sequence of range is  , ,  and , which is sorted in ascending order, as this satisfies the binary search tree properties on ranges. So, searching for a particular range could be done as in the case of binary search tree, using the following definition. The doted lines in figure \ref{f1} denote threads. The hanging threads points to the  node.
\begin{definition}
\label{d1}
Given two segments  and ,   implies , that is the segment  falls left of . Similarly,   implies , and this means  falls right of .
\end{definition}
\begin{definition}
\label{d2}
Given two segments  and , where  and ,   denotes  {\em left overlaps} with . Similarly,  denotes  {\em right overlaps} with . Otherwise,  is said to be {\em contained in}  when  or , or {\em covered up}  when  or .
\end{definition}
\par All four cases stated in definition \ref{d2} are commonly called as  and  {\em overlaps}. Note that,  left overlaps with  also implies  right overlaps with . Similarly,  contained in  also implies  covered up .
\begin{definition}
Given two overlapping segments  and ,  and  are respectively defined as  and  .
\end{definition}
\begin{definition}
\label{d3}
Given two overlapping segments  and , , say , partitions into ,  and . Here, , say . Now, 
\begin{center}
\\
and ~~

\end{center}
\end{definition}
\begin{definition}
\label{d4}
Let  and  be the two overlapping segments and their associated lists respectively be  and . Now, the list associated with ,  and  are defined as follows.

\end{definition}
\subsection{Insertion}
For to insert a segment, say , one has to search for a node, whose range overlaps with , from root like in the binary search tree based on the relation given in definition \ref{d1}. As soon as, an overlapping range is found in any node , the insertion process starts as follows. Let  be the range of . Now,  is partitioned into sub-ranges as described in definition \ref{d3}. Now, range of  will be changed as  and the segment  will be included in the list of . Further, insertion of  (if not empty) continues with the inorder predecessor of , and insertion of  (if not empty) continues with the inorder successor of . However, in these two cases, the list of segments to be inserted may change, as in definition \ref{d4}. Note that initially, the list of segments to inserted contains only , and later may be changed according to definition \ref{d4}. At one point of time, the insertion may reach a null pointer (not always). If so, the balancing range (sub-range of segment not yet considered) will be considered as a range for a node, by creating a new one, with necessary thread pointers and having the list currently to be inserted. As the tree is balanced, creation of a new node may require necessary rotation to get the tree to be balanced. The rotations we performed here is only the AVL-tree based rotations \cite{avl}. The formal description of the insertion procedure is given in algorithm \ref{a1}.
\begin{algorithm}
\caption{BITS-Insert(,,)}\label{a1}
\KwIn{ - the pointer to the root of the tree,  - the segment to be inserted; and  - Set of segments, initially .}
\hspace{-3mm};\\
;\\
\If{ and }
{
  \Repeat{ {\rm or} }
  {
dd     \hspace{-3mm};\\
     ;\\
     ;\\
     \If{}
     {
        \hspace{-3mm}\lIf{}{;}\\
        \lElse{;}
     } 
  }
  \If {}
  {
    \hspace{-3mm};\\
    ;\\
    ;\\
    \If {}
    {
       \hspace{-3mm}\lIf{}{;}\\
       BITS-Insert();
    }
    \If {}
    {
       \hspace{-3mm}\lIf{}{;}\\
       BITS-Insert();
    }
  }
}
\If{ or }
{
   \hspace{-3mm};\\
   ; \\
   ;\\
   \If{}
   {
     \hspace{-3mm}\lIf{}{;}\\
     \lElse{;}
   }
   Perform rotation if required;
}
\end{algorithm}
The CreateNode() function used in algorithm \ref{a1}, create a node as in threaded binary tree \cite{k,pt}, however here the treads are bidirectional.
\begin{figure}[!ht]
\begin{center}
\unitlength 1mm \linethickness{0.4pt}
\ifx\plotpoint\undefined\newsavebox{\plotpoint}\fi \begin{picture}(125.75,77.75)(0,0)
\put(17.75,61.25){\line(1,0){88.75}}
\put(29.75,69){\line(1,0){27.75}}
\put(50,74.25){\line(1,0){22.25}}
\multiput(57.43,63.18)(0,.94643){15}{{\rule{.4pt}{.4pt}}}
\multiput(71.93,63.18)(0,.94643){15}{{\rule{.4pt}{.4pt}}}
\put(84,68.5){\line(1,0){11.75}}
\put(30.25,58){\makebox(0,0)[cc]{5}}
\put(50.75,58){\makebox(0,0)[cc]{10}}
\put(58.25,58){\makebox(0,0)[cc]{12}}
\put(73,58){\makebox(0,0)[cc]{15}}
\put(85,58){\makebox(0,0)[cc]{18}}
\put(97.25,58){\makebox(0,0)[cc]{21}}
\put(40.25,71){\makebox(0,0)[cc]{a}}
\put(62.5,76.25){\makebox(0,0)[cc]{b}}
\put(89.5,70.5){\makebox(0,0)[cc]{c}}
\put(27.5,42.75){\makebox(0,0)[cc]{[12,15]}}
\put(40.25,32.5){\makebox(0,0)[cc]{[18,21]}}
\put(12.75,32.5){\makebox(0,0)[cc]{[5,7]}}
\put(27.13,42.38){\oval(14.25,6.25)[]}
\put(39.88,32.13){\oval(14.25,6.25)[]}
\put(12.38,32.13){\oval(14.25,6.25)[]}
\multiput(21.25,40.5)(-.052884615,-.033653846){156}{\line(-1,0){.052884615}}
\multiput(33,40.5)(.044326241,-.033687943){141}{\line(1,0){.044326241}}
\put(17.25,29.25){\line(4,-5){4}}
\put(37.75,28.75){\vector(0,1){.07}}\multiput(37.68,24.93)(0,.9375){5}{{\rule{.4pt}{.4pt}}}
\multiput(37.93,24.68)(-.85714,.03571){8}{{\rule{.4pt}{.4pt}}}
\put(31.25,38.75){\vector(0,1){.07}}\multiput(31.93,25.18)(-.05357,.96429){15}{{\rule{.4pt}{.4pt}}}
\put(41.5,28.75){\vector(0,1){.07}}\multiput(41.68,24.68)(-.05,.8){6}{{\rule{.4pt}{.4pt}}}
\multiput(41.93,24.18)(.875,.03125){9}{{\rule{.4pt}{.4pt}}}
\put(49.25,40.75){\vector(0,1){.07}}\multiput(48.93,24.18)(.01471,.97059){18}{{\rule{.4pt}{.4pt}}}
\put(10.75,40.25){}
\put(41.5,39.5){}
\put(23.25,27.5){}
\put(26.75,49.5){}
\put(26,68.75){d}
\put(24.25,58.25){\makebox(0,0)[cc]{2}}
\multiput(22.68,75.93)(0,-.96667){16}{{\rule{.4pt}{.4pt}}}
\put(37.75,57.75){\makebox(0,0)[cc]{7}}
\multiput(37.18,62.68)(0,.98214){15}{{\rule{.4pt}{.4pt}}}
\multiput(29.18,76.18)(0,-.98333){16}{{\rule{.4pt}{.4pt}}}
\multiput(49.93,77.18)(0,-.95313){17}{{\rule{.4pt}{.4pt}}}
\multiput(83.68,76.93)(0,-.96875){17}{{\rule{.4pt}{.4pt}}}
\multiput(95.68,77.68)(0,-.97059){18}{{\rule{.4pt}{.4pt}}}
\multiput(9,28.75)(-.033557047,-.036912752){149}{\line(0,-1){.036912752}}
\put(4.745,21.495){\makebox(0,0)[cc]{[2,5]}}
\put(4.375,21.125){\oval(14.25,6.25)[]}
\multiput(22,17.75)(-.033687943,-.042553191){141}{\line(0,-1){.042553191}}
\put(23.995,20.995){\makebox(0,0)[cc]{[10,12]}}
\put(23.625,20.625){\oval(14.25,6.25)[]}
\put(16.495,9.495){\makebox(0,0)[cc]{[7,10]}}
\put(16.125,9.125){\oval(14.25,6.25)[]}
\put(96,42.5){\makebox(0,0)[cc]{[10,12]}}
\put(108.75,32.25){\makebox(0,0)[cc]{[12,15]}}
\put(81.25,32.25){\makebox(0,0)[cc]{[5,7]}}
\put(95.63,42.13){\oval(14.25,6.25)[]}
\put(108.38,31.88){\oval(14.25,6.25)[]}
\put(80.88,31.88){\oval(14.25,6.25)[]}
\multiput(89.75,40.25)(-.052884615,-.033653846){156}{\line(-1,0){.052884615}}
\multiput(101.5,40.25)(.044326241,-.033687943){141}{\line(1,0){.044326241}}
\put(85.75,29){\line(4,-5){4}}
\put(106.25,28.5){\vector(0,1){.07}}\multiput(106.18,24.68)(0,.9375){5}{{\rule{.4pt}{.4pt}}}
\multiput(106.43,24.43)(-.85714,.03571){8}{{\rule{.4pt}{.4pt}}}
\put(99.75,38.5){\vector(0,1){.07}}\multiput(100.43,24.93)(-.05357,.96429){15}{{\rule{.4pt}{.4pt}}}
\put(79.25,40){}
\put(91.75,27.25){}
\multiput(77.5,28.5)(-.033557047,-.036912752){149}{\line(0,-1){.036912752}}
\put(73.245,21.245){\makebox(0,0)[cc]{[2,5]}}
\put(72.875,20.875){\oval(14.25,6.25)[]}
\put(92.495,20.745){\makebox(0,0)[cc]{[7,10]}}
\put(92.125,20.375){\oval(14.25,6.25)[]}
\put(116.245,21.995){\makebox(0,0)[cc]{[18,21]}}
\put(115.875,21.625){\oval(14.25,6.25)[]}
\put(-6.75,36.5){\vector(0,1){.07}}\multiput(-6.32,15.68)(-.02381,.9881){22}{{\rule{.4pt}{.4pt}}}
\put(13.75,5.75){\vector(0,1){.07}}\multiput(13.93,2.68)(-.0625,.75){5}{{\rule{.4pt}{.4pt}}}
\put(18,5.75){\vector(0,1){.07}}\multiput(17.68,2.93)(.0833,.9167){4}{{\rule{.4pt}{.4pt}}}
\multiput(17.68,2.43)(.96875,.03125){9}{{\rule{.4pt}{.4pt}}}
\put(25.25,16.75){\vector(0,1){.07}}\multiput(25.43,2.68)(-.01667,.93333){16}{{\rule{.4pt}{.4pt}}}
\multiput(13.68,1.93)(-.9,.05){11}{{\rule{.4pt}{.4pt}}}
\multiput(4.68,2.43)(-.05,.975){11}{{\rule{.4pt}{.4pt}}}
\multiput(4.18,12.18)(.88636,.36364){12}{{\rule{.4pt}{.4pt}}}
\put(14.25,28.25){\vector(0,1){.07}}\multiput(14.43,17.18)(-.02083,.91667){13}{{\rule{.4pt}{.4pt}}}
\put(75.75,17.75){\vector(0,1){.07}}\multiput(75.93,14.93)(-.0833,.9167){4}{{\rule{.4pt}{.4pt}}}
\put(28.25,17.25){\vector(0,1){.07}}\multiput(28.18,14.18)(0,.75){5}{{\rule{.4pt}{.4pt}}}
\multiput(28.18,14.43)(.85,.05){6}{{\rule{.4pt}{.4pt}}}
\multiput(32.43,14.68)(-.03125,.9375){9}{{\rule{.4pt}{.4pt}}}
\multiput(32.18,22.18)(-.54167,.70833){13}{{\rule{.4pt}{.4pt}}}
\put(25.5,39){\vector(0,1){.07}}\multiput(25.68,31.43)(-.03125,.9375){9}{{\rule{.4pt}{.4pt}}}
\multiput(-6.07,15.68)(.88889,0){10}{{\rule{.4pt}{.4pt}}}
\put(2.5,18){\vector(0,1){.07}}\multiput(2.18,15.68)(.0833,.75){4}{{\rule{.4pt}{.4pt}}}
\put(5.25,17.75){\vector(0,1){.07}}\multiput(5.18,15.93)(0,.875){3}{{\rule{.4pt}{.4pt}}}
\multiput(5.18,15.93)(.92857,.07143){8}{{\rule{.4pt}{.4pt}}}
\put(12,27.75){\vector(0,1){.07}}\multiput(12.18,16.93)(-.02273,.97727){12}{{\rule{.4pt}{.4pt}}}
\multiput(75.93,14.68)(.83333,.04167){7}{{\rule{.4pt}{.4pt}}}
\multiput(80.93,14.93)(0,0){3}{{\rule{.4pt}{.4pt}}}
\put(80.5,27.75){\vector(0,1){.07}}\multiput(80.43,14.93)(0,.98077){14}{{\rule{.4pt}{.4pt}}}
\put(83.5,27.25){\vector(0,1){.07}}\multiput(83.68,14.93)(-.01923,.94231){14}{{\rule{.4pt}{.4pt}}}
\put(89.75,17.5){\vector(0,1){.07}}\multiput(89.93,13.93)(-.0625,.875){5}{{\rule{.4pt}{.4pt}}}
\put(94.75,17.25){\vector(0,1){.07}}\multiput(94.68,13.93)(0,.8125){5}{{\rule{.4pt}{.4pt}}}
\multiput(83.93,14.43)(.89286,-.03571){8}{{\rule{.4pt}{.4pt}}}
\multiput(94.93,14.18)(.875,0){9}{{\rule{.4pt}{.4pt}}}
\multiput(101.93,14.18)(-.03125,.9375){9}{{\rule{.4pt}{.4pt}}}
\multiput(101.68,21.68)(-.57692,.71154){14}{{\rule{.4pt}{.4pt}}}
\put(93.75,38){\vector(0,1){.07}}\multiput(93.93,31.68)(-.03571,.89286){8}{{\rule{.4pt}{.4pt}}}
\put(70,17.25){\vector(0,1){.07}}\multiput(70.18,14.93)(-.0833,.75){4}{{\rule{.4pt}{.4pt}}}
\put(62.75,33){\vector(0,1){.07}}\multiput(62.68,15.68)(0,.95833){19}{{\rule{.4pt}{.4pt}}}
\multiput(62.18,14.93)(.88889,-.02778){10}{{\rule{.4pt}{.4pt}}}
\put(.5,26.75){d}
\put(16.5,14){a}
\put(67.5,27){d}
\put(120.5,28){c}
\put(94.75,49){a,b}
\put(111.5,39.5){b}
\put(113,18.75){\vector(0,1){.07}}\multiput(112.93,14.68)(0,.8){6}{{\rule{.4pt}{.4pt}}}
\multiput(113.18,14.18)(-.91667,.04167){7}{{\rule{.4pt}{.4pt}}}
\multiput(107.68,14.43)(-.125,.9375){9}{{\rule{.4pt}{.4pt}}}
\multiput(106.68,21.93)(.55,.65){6}{{\rule{.4pt}{.4pt}}}
\put(109.5,28.75){\vector(0,1){.07}}\multiput(109.68,25.43)(-.0625,.8125){5}{{\rule{.4pt}{.4pt}}}
\put(118.25,18.75){\vector(0,1){.07}}\multiput(118.43,13.68)(-.04167,.83333){7}{{\rule{.4pt}{.4pt}}}
\multiput(118.18,13.18)(.96429,0){8}{{\rule{.4pt}{.4pt}}}
\put(125.25,33.75){\vector(0,1){.07}}\multiput(125.68,13.93)(-.025,.9875){21}{{\rule{.4pt}{.4pt}}}
\multiput(112.25,28.5)(.054621849,-.033613445){119}{\line(1,0){.054621849}}
\put(58.5,52.75){\makebox(0,0)[cc]{(a)}}
\put(15,-2.25){\makebox(0,0)[cc]{(b)}}
\put(93.25,8.5){\makebox(0,0)[cc]{(c)}}
\thicklines
\put(22.75,65){\line(1,0){14.25}}
\end{picture}
 \end{center}
\caption{Insertion: (a) Set of segments including new segment . (b) Insertion of segment  in BITS-tree in figure \ref{f1}, before rotation. (c) BITS-tree after rotation.}
\label{f2}
\end{figure}
\par
For example, consider insertion of segment  in the BITS-tree given in figure \ref{f1}. The search starts with the root node, and stop in the node with range  as this range overlaps with , and  results in , as in definition \ref{d3}. Here, ,  and . Now, the range  is  retained at that node by including  in the list of this node, and further insertion takes with respect to the ranges  and  at the inorder predecessor and successor, respectively. This process in turn creates two new nodes in the tree given in figure \ref{f1}, one with range  and other with range . This is shown in figure \ref{f2}(b). As creation of new node with range   does not affect the balancing factor, no rotation is required. However, creation of new node for the  affects the balancing factor (figure \ref{f2}(b)), and hence necessary rotation to be carried out, here it is left-right rotation. The effect of this rotation is shown in figure \ref{f2}(c). Note here that the thread pointers are not affected due to rotation. Whichever be the rotation, the thread pointer cannot change, as the rotation does not affect the inorder sequence. Note here that the usage of threads obviously reduces the time for inserting a segment, as compared to the standard dynamic version of the segment tree. \par
The time required for inserting a node is , where the first factor  stands for locating first overlapping node, and  be the number of nodes in which the new segment get inserted.  Note that, a segment tree contains at most  nodes, where  is the number of segments in the tree. 
\subsection{Deletion}  
Let  be the segment to be deleted. First step of the deletion process is to locate a node  with range , where  denotes a value less than or equal to . If the list of the node  does not contain the segment , then deletion does not require, and the process of deletion can be terminated. Otherwise, the segment  can be removed from the list of . Now, after removal of , if  is empty then convert the  as  (empty), and  should be merged with . Note that, during merge the node appears at lower level will be joined at the node at the higher level, and also it performs necessary rotation if required to make the tree balanced. In case, the  is not empty after removal of  then compare the  with the  and if found matching then merge the node  with . Now, the deletion process can be continued with the , and that to be continued till the node  with range , where  denotes a value greater than equal to . Then, to complete the deletion, compare the new range of  with the , and if found matching then  and  must be merged. Each time when a node is merged with the inorder predecessor or successor, necessary rotation need to be performed as in the case of AVL trees.
\par
\begin{algorithm}
\caption{BITS-Deletion}\label{a2}
\KwIn{T - the pointer to the root of the tree, and  - the segment to be deleted.}
\Begin{
\While {}
{
    \hspace{-3mm}\lIf {}
      {;\\}
    \lElse
      {;}
}
\Repeat{}
{\hspace{-3mm};\\
\lIf{}{;\\}
\If{ {\rm or} }{merge(T,PRED(T));}
\lElse{;}
}
\lIf{}{merge(T,SUCC(T));}
}
\end{algorithm}
\begin{figure}[!ht]
\begin{center}
\unitlength 1mm \linethickness{0.4pt}
\ifx\plotpoint\undefined\newsavebox{\plotpoint}\fi \begin{picture}(132.25,114.5)(0,0)
\put(14,98){\line(1,0){88.75}}
\put(46.25,111){\line(1,0){22.25}}
\multiput(53.68,99.93)(0,.94643){15}{{\rule{.4pt}{.4pt}}}
\multiput(68.18,99.93)(0,.94643){15}{{\rule{.4pt}{.4pt}}}
\put(80.25,105.25){\line(1,0){11.75}}
\put(26.5,94.75){\makebox(0,0)[cc]{5}}
\put(47,94.75){\makebox(0,0)[cc]{10}}
\put(54.5,94.75){\makebox(0,0)[cc]{12}}
\put(69.25,94.75){\makebox(0,0)[cc]{15}}
\put(81.25,94.75){\makebox(0,0)[cc]{18}}
\put(93.5,94.75){\makebox(0,0)[cc]{21}}
\put(36.5,107.75){\makebox(0,0)[cc]{a}}
\put(58.75,113){\makebox(0,0)[cc]{b}}
\put(85.75,107.25){\makebox(0,0)[cc]{c}}
\put(22.25,105.5){d}
\put(20.5,95){\makebox(0,0)[cc]{2}}
\multiput(18.93,112.68)(0,-.96667){16}{{\rule{.4pt}{.4pt}}}
\put(19,101.75){\line(1,0){15.25}}
\put(34,94.5){\makebox(0,0)[cc]{7}}
\multiput(33.43,99.43)(0,.98214){15}{{\rule{.4pt}{.4pt}}}
\multiput(25.43,112.93)(0,-.98333){16}{{\rule{.4pt}{.4pt}}}
\multiput(46.18,113.93)(0,-.95313){17}{{\rule{.4pt}{.4pt}}}
\multiput(79.93,113.68)(0,-.96875){17}{{\rule{.4pt}{.4pt}}}
\multiput(91.93,114.43)(0,-.97059){18}{{\rule{.4pt}{.4pt}}}
\put(31.25,79.25){\makebox(0,0)[cc]{[10,12]}}
\put(102.5,79){\makebox(0,0)[cc]{[10,12]}}
\put(102.5,30){\makebox(0,0)[cc]{[10,15]}}
\put(33,29.75){\makebox(0,0)[cc]{[10,12]}}
\put(44,69){\makebox(0,0)[cc]{[12,15]}}
\put(115.25,68.75){\makebox(0,0)[cc]{[12,15]}}
\put(115.25,19.75){\makebox(0,0)[cc]{[18,21]}}
\put(45.75,19.5){\makebox(0,0)[cc]{[12,15]}}
\put(16.5,69){\makebox(0,0)[cc]{[5,7]}}
\put(87.75,68.75){\makebox(0,0)[cc]{[2,7]}}
\put(87.75,19.75){\makebox(0,0)[cc]{[2,7]}}
\put(18.25,19.5){\makebox(0,0)[cc]{[2,7]}}
\put(30.88,78.88){\oval(14.25,6.25)[]}
\put(102.13,78.63){\oval(14.25,6.25)[]}
\put(102.13,29.63){\oval(14.25,6.25)[]}
\put(32.63,29.38){\oval(14.25,6.25)[]}
\put(43.63,68.63){\oval(14.25,6.25)[]}
\put(114.88,68.38){\oval(14.25,6.25)[]}
\put(114.88,19.38){\oval(14.25,6.25)[]}
\put(45.38,19.13){\oval(14.25,6.25)[]}
\put(16.13,68.63){\oval(14.25,6.25)[]}
\put(87.38,68.38){\oval(14.25,6.25)[]}
\put(87.38,19.38){\oval(14.25,6.25)[]}
\put(17.88,19.13){\oval(14.25,6.25)[]}
\multiput(25,77)(-.052884615,-.033653846){156}{\line(-1,0){.052884615}}
\multiput(96.25,76.75)(-.052884615,-.033653846){156}{\line(-1,0){.052884615}}
\multiput(96.25,27.75)(-.052884615,-.033653846){156}{\line(-1,0){.052884615}}
\multiput(26.75,27.5)(-.052884615,-.033653846){156}{\line(-1,0){.052884615}}
\multiput(36.75,77)(.044326241,-.033687943){141}{\line(1,0){.044326241}}
\multiput(108,76.75)(.044326241,-.033687943){141}{\line(1,0){.044326241}}
\multiput(108,27.75)(.044326241,-.033687943){141}{\line(1,0){.044326241}}
\multiput(38.5,27.5)(.044326241,-.033687943){141}{\line(1,0){.044326241}}
\put(21,65.75){\line(4,-5){4}}
\put(92.25,65.5){\line(4,-5){4}}
\put(41.5,65.25){\vector(0,1){.07}}\multiput(41.43,61.43)(0,.9375){5}{{\rule{.4pt}{.4pt}}}
\put(112.75,65){\vector(0,1){.07}}\multiput(112.68,61.18)(0,.9375){5}{{\rule{.4pt}{.4pt}}}
\put(112.75,16){\vector(0,1){.07}}\multiput(112.68,12.18)(0,.9375){5}{{\rule{.4pt}{.4pt}}}
\put(43.25,15.75){\vector(0,1){.07}}\multiput(43.18,11.93)(0,.9375){5}{{\rule{.4pt}{.4pt}}}
\multiput(41.68,61.18)(-.85714,.03571){8}{{\rule{.4pt}{.4pt}}}
\multiput(112.93,60.93)(-.85714,.03571){8}{{\rule{.4pt}{.4pt}}}
\multiput(112.93,11.93)(-.85714,.03571){8}{{\rule{.4pt}{.4pt}}}
\multiput(43.43,11.68)(-.85714,.03571){8}{{\rule{.4pt}{.4pt}}}
\put(35,75.25){\vector(0,1){.07}}\multiput(35.68,61.68)(-.05357,.96429){15}{{\rule{.4pt}{.4pt}}}
\put(106.25,75){\vector(0,1){.07}}\multiput(106.93,61.43)(-.05357,.96429){15}{{\rule{.4pt}{.4pt}}}
\put(106.25,26){\vector(0,1){.07}}\multiput(106.93,12.43)(-.05357,.96429){15}{{\rule{.4pt}{.4pt}}}
\put(36.75,25.75){\vector(0,1){.07}}\multiput(37.43,12.18)(-.05357,.96429){15}{{\rule{.4pt}{.4pt}}}
\put(14.5,76.75){a,d}
\put(85.75,76.5){d}
\put(16.25,26.25){d}
\put(85.5,26.25){d}
\put(27,64){a}
\put(98.25,63.75){a}
\multiput(12.75,65.25)(-.033557047,-.036912752){149}{\line(0,-1){.036912752}}
\put(8.495,57.995){\makebox(0,0)[cc]{[2,5]}}
\put(8.125,57.625){\oval(14.25,6.25)[]}
\put(27.745,57.495){\makebox(0,0)[cc]{[7,10]}}
\put(98.995,57.245){\makebox(0,0)[cc]{[7,10]}}
\put(27.375,57.125){\oval(14.25,6.25)[]}
\put(98.625,56.875){\oval(14.25,6.25)[]}
\put(51.495,58.745){\makebox(0,0)[cc]{[18,21]}}
\put(122.745,58.495){\makebox(0,0)[cc]{[18,21]}}
\put(53.245,9.245){\makebox(0,0)[cc]{[18,21]}}
\put(51.125,58.375){\oval(14.25,6.25)[]}
\put(122.375,58.125){\oval(14.25,6.25)[]}
\put(52.875,8.875){\oval(14.25,6.25)[]}
\put(11,54.5){\vector(0,1){.07}}\multiput(11.18,51.68)(-.0833,.9167){4}{{\rule{.4pt}{.4pt}}}
\multiput(11.18,51.43)(.83333,.04167){7}{{\rule{.4pt}{.4pt}}}
\multiput(77.18,51.68)(0,0){3}{{\rule{.4pt}{.4pt}}}
\put(15.75,64.5){\vector(0,1){.07}}\multiput(15.68,51.68)(0,.98077){14}{{\rule{.4pt}{.4pt}}}
\put(18.75,64){\vector(0,1){.07}}\multiput(18.93,51.68)(-.01923,.94231){14}{{\rule{.4pt}{.4pt}}}
\put(90,63.75){\vector(0,1){.07}}\multiput(90.18,51.43)(-.01923,.94231){14}{{\rule{.4pt}{.4pt}}}
\put(25,54.25){\vector(0,1){.07}}\multiput(25.18,50.68)(-.0625,.875){5}{{\rule{.4pt}{.4pt}}}
\put(96.25,54){\vector(0,1){.07}}\multiput(96.43,50.43)(-.0625,.875){5}{{\rule{.4pt}{.4pt}}}
\put(30,54){\vector(0,1){.07}}\multiput(29.93,50.68)(0,.8125){5}{{\rule{.4pt}{.4pt}}}
\put(101.25,53.75){\vector(0,1){.07}}\multiput(101.18,50.43)(0,.8125){5}{{\rule{.4pt}{.4pt}}}
\multiput(19.18,51.18)(.89286,-.03571){8}{{\rule{.4pt}{.4pt}}}
\multiput(90.43,50.93)(.89286,-.03571){8}{{\rule{.4pt}{.4pt}}}
\multiput(30.18,50.93)(.875,0){9}{{\rule{.4pt}{.4pt}}}
\multiput(101.43,50.68)(.875,0){9}{{\rule{.4pt}{.4pt}}}
\multiput(37.18,50.93)(-.03125,.9375){9}{{\rule{.4pt}{.4pt}}}
\multiput(108.43,50.68)(-.03125,.9375){9}{{\rule{.4pt}{.4pt}}}
\multiput(36.93,58.43)(-.57692,.71154){14}{{\rule{.4pt}{.4pt}}}
\multiput(108.18,58.18)(-.57692,.71154){14}{{\rule{.4pt}{.4pt}}}
\put(29,74.75){\vector(0,1){.07}}\multiput(29.18,68.43)(-.03571,.89286){8}{{\rule{.4pt}{.4pt}}}
\put(100.25,74.5){\vector(0,1){.07}}\multiput(100.43,68.18)(-.03571,.89286){8}{{\rule{.4pt}{.4pt}}}
\put(5.25,54){\vector(0,1){.07}}\multiput(5.43,51.68)(-.0833,.75){4}{{\rule{.4pt}{.4pt}}}
\put(85.5,65.5){\vector(0,1){.07}}\multiput(85.68,63.18)(-.0833,.75){4}{{\rule{.4pt}{.4pt}}}
\put(85,16.25){\vector(0,1){.07}}\multiput(85.18,13.93)(-.0833,.75){4}{{\rule{.4pt}{.4pt}}}
\put(15.75,15.75){\vector(0,1){.07}}\multiput(15.93,13.43)(-.0833,.75){4}{{\rule{.4pt}{.4pt}}}
\put(-2,69.75){\vector(0,1){.07}}\multiput(-2.07,52.43)(0,.95833){19}{{\rule{.4pt}{.4pt}}}
\put(78.25,81.25){\vector(0,1){.07}}\multiput(78.18,63.93)(0,.95833){19}{{\rule{.4pt}{.4pt}}}
\put(77.75,32){\vector(0,1){.07}}\multiput(77.68,14.68)(0,.95833){19}{{\rule{.4pt}{.4pt}}}
\put(8.5,31.5){\vector(0,1){.07}}\multiput(8.43,14.18)(0,.95833){19}{{\rule{.4pt}{.4pt}}}
\multiput(-2.57,51.68)(.88889,-.02778){10}{{\rule{.4pt}{.4pt}}}
\multiput(77.68,63.18)(.88889,-.02778){10}{{\rule{.4pt}{.4pt}}}
\multiput(77.18,13.93)(.88889,-.02778){10}{{\rule{.4pt}{.4pt}}}
\multiput(7.93,13.43)(.88889,-.02778){10}{{\rule{.4pt}{.4pt}}}
\put(2.75,63.75){d}
\put(55.75,64.75){c}
\put(127,64.5){c}
\put(57.5,15.25){c}
\put(30,85.75){a,b}
\put(101.25,85.5){a,b}
\put(101.25,36.5){b}
\put(31.75,36.25){a,b}
\put(46.75,76.25){b}
\put(118,76){b}
\put(118,27){c}
\put(48.5,26.75){b}
\put(48.25,55.5){\vector(0,1){.07}}\multiput(48.18,51.43)(0,.8){6}{{\rule{.4pt}{.4pt}}}
\put(119.5,55.25){\vector(0,1){.07}}\multiput(119.43,51.18)(0,.8){6}{{\rule{.4pt}{.4pt}}}
\put(50,6){\vector(0,1){.07}}\multiput(49.93,1.93)(0,.8){6}{{\rule{.4pt}{.4pt}}}
\multiput(48.43,50.93)(-.91667,.04167){7}{{\rule{.4pt}{.4pt}}}
\multiput(119.68,50.68)(-.91667,.04167){7}{{\rule{.4pt}{.4pt}}}
\multiput(50.18,1.43)(-.91667,.04167){7}{{\rule{.4pt}{.4pt}}}
\multiput(42.93,51.18)(-.125,.9375){9}{{\rule{.4pt}{.4pt}}}
\multiput(114.18,50.93)(-.125,.9375){9}{{\rule{.4pt}{.4pt}}}
\multiput(44.68,1.68)(-.125,.9375){9}{{\rule{.4pt}{.4pt}}}
\multiput(41.93,58.68)(.55,.65){6}{{\rule{.4pt}{.4pt}}}
\multiput(113.18,58.43)(.55,.65){6}{{\rule{.4pt}{.4pt}}}
\multiput(43.68,9.18)(.55,.65){6}{{\rule{.4pt}{.4pt}}}
\put(44.75,65.5){\vector(0,1){.07}}\multiput(44.93,62.18)(-.0625,.8125){5}{{\rule{.4pt}{.4pt}}}
\put(116,65.25){\vector(0,1){.07}}\multiput(116.18,61.93)(-.0625,.8125){5}{{\rule{.4pt}{.4pt}}}
\put(46.5,16){\vector(0,1){.07}}\multiput(46.68,12.68)(-.0625,.8125){5}{{\rule{.4pt}{.4pt}}}
\put(53.5,55.5){\vector(0,1){.07}}\multiput(53.68,50.43)(-.04167,.83333){7}{{\rule{.4pt}{.4pt}}}
\put(124.75,55.25){\vector(0,1){.07}}\multiput(124.93,50.18)(-.04167,.83333){7}{{\rule{.4pt}{.4pt}}}
\put(117.75,16.5){\vector(0,1){.07}}\multiput(117.93,11.43)(-.04167,.83333){7}{{\rule{.4pt}{.4pt}}}
\put(55.25,6){\vector(0,1){.07}}\multiput(55.43,.93)(-.04167,.83333){7}{{\rule{.4pt}{.4pt}}}
\multiput(53.43,49.93)(.96429,0){8}{{\rule{.4pt}{.4pt}}}
\multiput(124.68,49.68)(.96429,0){8}{{\rule{.4pt}{.4pt}}}
\multiput(117.68,10.93)(.96429,0){8}{{\rule{.4pt}{.4pt}}}
\multiput(55.18,.43)(.96429,0){8}{{\rule{.4pt}{.4pt}}}
\put(60.5,70.5){\vector(0,1){.07}}\multiput(60.93,50.68)(-.025,.9875){21}{{\rule{.4pt}{.4pt}}}
\put(131.75,70.25){\vector(0,1){.07}}\multiput(132.18,50.43)(-.025,.9875){21}{{\rule{.4pt}{.4pt}}}
\put(124.75,31.5){\vector(0,1){.07}}\multiput(125.18,11.68)(-.025,.9875){21}{{\rule{.4pt}{.4pt}}}
\put(62.25,21){\vector(0,1){.07}}\multiput(62.68,1.18)(-.025,.9875){21}{{\rule{.4pt}{.4pt}}}
\multiput(47.5,65.25)(.054621849,-.033613445){119}{\line(1,0){.054621849}}
\multiput(118.75,65)(.054621849,-.033613445){119}{\line(1,0){.054621849}}
\multiput(49.25,15.75)(.054621849,-.033613445){119}{\line(1,0){.054621849}}
\put(60.25,89.5){\makebox(0,0)[cc]{(a)}}
\put(33.75,45.25){\makebox(0,0)[cc]{(b)}}
\put(105,45){\makebox(0,0)[cc]{(c)}}
\put(101.25,.25){\makebox(0,0)[cc]{(e)}}
\put(31.75,0){\makebox(0,0)[cc]{(d)}}
\thicklines
\put(25.75,106){\line(1,0){28}}
\thinlines
\multiput(41.75,107.75)(-.03353659,-.03963415){82}{\line(0,-1){.03963415}}
\multiput(39,107.5)(.03658537,-.03353659){82}{\line(1,0){.03658537}}
\multiput(90.43,13.68)(.925,0){11}{{\rule{.4pt}{.4pt}}}
\multiput(20.93,13.43)(.925,0){11}{{\rule{.4pt}{.4pt}}}
\put(90.5,16){\vector(0,1){.07}}\multiput(90.43,13.43)(0,.8333){4}{{\rule{.4pt}{.4pt}}}
\put(21,15.75){\vector(0,1){.07}}\multiput(20.93,13.18)(0,.8333){4}{{\rule{.4pt}{.4pt}}}
\put(99.75,26.5){\vector(0,1){.07}}\multiput(99.68,13.68)(0,.98077){14}{{\rule{.4pt}{.4pt}}}
\put(30.25,26.25){\vector(0,1){.07}}\multiput(30.18,13.43)(0,.98077){14}{{\rule{.4pt}{.4pt}}}
\end{picture}
 \end{center}
\caption{Deletion: (a) Set of segments including the segment  to be deleted. (b) Original -tree. (c) After removal of segment  from node having range [5,7]. (d) After removal of segment  from node having range [7,10]. (e) After removal of segment  from node having range [10,12].}
\label{f3}
\end{figure}
As an example, suppose segment  is removed, as in figure \ref{f3}(a).  This process starts with node having range . Now, after removal of segment  from this node, the list of this node matches with its inorder predecessor, thus to be merged with its inorder predecessor and the result is shown in figure \ref{f3}(c). Next, the process continues with the node having range . Now by removing segment  from this node, its list becomes empty and so its range to be modified as empty() and required merging is to be done with its inorder predecessor, and the result is shown in figure \ref{f3}(d). Finally, the segment  must be removed from the list of the node having range . Here, the list of this node does not match with its inorder predecessor, and hence merging with the predecessor is not required, rather as a last step of the deletion process, its range is to be compared with the inorder successor, and as it is matching it should be merged with its in order successor. The final result is shown in figure \ref{f3}(e).\
\par
Like insertion, deletion also takes  time, where  is the number of nodes in which the segment to be deleted is present. 
\subsection{Query Processing} 
\subsubsection{Stabbing Query}
Given a point (one dimensional) , it reports the segments containing . On the other hand, it reports set of all segments intersects with the line . In standard segment \footnote{trees}, the answer to this query lies in several nodes and one has to take union of lists of all those nodes to report the final answer. However, in BITS-tree, the answer lies in only one node. Here, the process is only to find the node whose range contains , and the list of that node is the answer to the query. As the ranges of the nodes are not overlapped, a simple binary search will do for locating the range contains . Since, BITS-tree is height balanced,  time is sufficient for locating a node with such range. Due to reduction in number of nodes and height as compared to the standard segment tree, our approach certainly outperforms considerably as compared to the existing one.
\subsubsection{Range Query}
Knowing set of segments overlaps with a given segment is an important problem in computational geometry\cite{bcko}. In BITS-tree, such queries can be answered very efficiently as compared to the standard segment trees. Here, given a segment , finding set of overlapping segments are determined by first locating a node  having range perfectly contains , and traverse through the inorder successor till reaching the node  with range perfectly contains . Now the answer is the union of list of nodes traversed from  to . The time required for the same is , where  is the number of nodes containing answer to the query.
\section{Comparison}
The static version of the standard segment tree of the segments, given in figure \ref{f1}, is shown in figure \ref{f4}. Similarly, the best dynamic version of the standard segment tree for the same set of segments is shown in figure \ref{f5}. For this particular example, the comparison is shown in table \ref{t1}. 
\begin{figure}[!ht]
\begin{center}
\tiny
\unitlength 1mm \linethickness{0.4pt}
\ifx\plotpoint\undefined\newsavebox{\plotpoint}\fi \begin{picture}(92.36,31.12)(0,0)
\put(16,-5.39){}
\put(33.71,5.11){\oval(11,4)[]}
\put(46.28,5.36){\oval(11,4)[]}
\put(14.33,13.81){\oval(11,4)[]}
\put(10.43,12.93){}
\put(29.93,3.9){10,12}
\put(42,4.15){12,15}
\put(51.12,29.12){\oval(11,4)[]}
\put(46.07,28.92){}
\put(26.94,21.13){\oval(11,4)[]}
\put(76.56,21.13){\oval(11,4)[]}
\put(22.94,19.88){}
\put(72.56,19.88){}
\put(21.27,5.15){\oval(11,4)[]}
\put(7.81,4.94){\oval(11,4)[]}
\put(86.86,4.94){\oval(11,4)[]}
\put(17.27,3.9){}
\put(3.81,3.69){}
\put(82.86,3.69){}
\put(59.74,5.36){\oval(11,4)[]}
\put(55.74,4.11){}
\put(74.25,5.15){\oval(11,4)[]}
\put(70.25,3.9){}
\put(53.6,-5.04){}
\put(64.11,-5.25){}
\put(78.63,-4.83){}
\put(27.54,-5.46){}
\put(40.58,-4.83){}
\put(40.18,13.56){\oval(11,4)[]}
\put(66.88,13.56){\oval(11,4)[]}
\put(36.18,12.31){}
\put(62.88,12.31){}
\put(20.18,1.05){a}
\put(40.36,9.88){b}
\put(33.85,1.26){\makebox(0,0)[cc]{a}}
\put(73.16,1.47){\makebox(0,0)[cc]{c}}
\put(4.62,-1.47){\line(1,0){85.14}}
\put(16.19,-1.47){\circle*{.59}}
\put(27.75,-1.47){\circle*{.59}}
\put(40.57,-1.47){\circle*{.59}}
\put(54.66,-1.47){\circle*{.59}}
\put(66.01,-1.47){\circle*{.59}}
\put(79.47,-1.47){\circle*{.59}}
\put(4.84,-3.78){\makebox(0,0)[cc]{}}
\put(89.56,-2.94){\makebox(0,0)[cc]{}}
\multiput(10.72,11.77)(-.03370025,-.03530502){131}{\line(0,-1){.03530502}}
\multiput(17.87,11.98)(.03363606,-.04835183){100}{\line(0,-1){.04835183}}
\multiput(37.42,11.56)(-.03356539,-.03886519){119}{\line(0,-1){.03886519}}
\multiput(43.73,11.56)(.0334449,-.0430006){88}{\line(0,-1){.0430006}}
\multiput(64.54,11.35)(-.03371539,-.03966516){106}{\line(0,-1){.03966516}}
\multiput(69.79,11.56)(.0334449,-.0477785){88}{\line(0,-1){.0477785}}
\multiput(73.37,19.13)(-.04958145,-.03371539){106}{\line(-1,0){.04958145}}
\multiput(79.68,19.13)(.03370702,-.05144756){237}{\line(0,-1){.05144756}}
\multiput(30.9,19.34)(.06544752,-.03371539){106}{\line(1,0){.06544752}}
\multiput(22.91,19.34)(-.07357888,-.03363606){100}{\line(-1,0){.07357888}}
\multiput(47.09,27.54)(-.11729966,-.03351419){138}{\line(-1,0){.11729966}}
\multiput(55.92,27.54)(.12998667,-.03370025){131}{\line(1,0){.12998667}}
\end{picture}
 \normalsize
\end{center}
\caption{Static version of the standard segment tree for the segments shown in figure \ref{f1}.}
\label{f4}
\end{figure}
\begin{figure}[!ht]
\begin{center}
\tiny
\unitlength .7mm \linethickness{0.4pt}
\ifx\plotpoint\undefined\newsavebox{\plotpoint}\fi \begin{picture}(193.65,48.25)(0,0)
\put(10.45,8.75){\oval(9.9,4)[]}
\put(6.87,7.25){}
\put(5.7,-.75){\oval(9.9,4)[]}
\put(2.13,-2.25){}
\multiput(9.25,7.75)(-.04816514,-.05963303){109}{\line(0,-1){.05963303}}
\multiput(11,6.75)(.04782609,-.05){115}{\line(0,-1){.05}}
\put(36.2,9.75){\oval(9.9,4)[]}
\put(32.63,8.25){}
\put(30.7,-.5){\oval(9.9,4)[]}
\put(27.13,-2){}
\multiput(34.25,8)(-.04816514,-.05963303){109}{\line(0,-1){.05963303}}
\put(60.95,9.75){\oval(9.9,4)[]}
\put(57.38,8.25){}
\put(55.45,-.5){\oval(9.9,4)[]}
\put(51.88,-2){}
\put(68.2,-.25){\oval(9.9,4)[]}
\put(63.37,-1.75){}
\multiput(59,8)(-.04816514,-.05963303){109}{\line(0,-1){.05963303}}
\multiput(61.5,7.75)(.04782609,-.05){115}{\line(0,-1){.05}}
\put(85.45,10.25){\oval(9.9,4)[]}
\put(80.62,8.75){}
\put(79.95,0){\oval(9.9,4)[]}
\put(75.12,-1.5){}
\put(92.7,.25){\oval(9.9,4)[]}
\put(87.87,-1.25){}
\multiput(83.5,8.5)(-.04816514,-.05963303){109}{\line(0,-1){.05963303}}
\multiput(86,8.25)(.04782609,-.05){115}{\line(0,-1){.05}}
\put(109.7,10.5){\oval(9.9,4)[]}
\put(104.87,9){}
\put(104.2,.25){\oval(9.9,4)[]}
\put(99.37,-1.25){}
\put(116.95,.5){\oval(9.9,4)[]}
\put(112.12,-1){}
\multiput(107.75,8.75)(-.04816514,-.05963303){109}{\line(0,-1){.05963303}}
\multiput(110.25,8.5)(.04782609,-.05){115}{\line(0,-1){.05}}
\put(133.2,10.75){\oval(9.9,4)[]}
\put(128.38,9.25){}
\put(127.7,.5){\oval(9.9,4)[]}
\put(122.87,-1){}
\put(140.45,.75){\oval(9.9,4)[]}
\put(135.63,-.75){}
\multiput(131.25,9)(-.04816514,-.05963303){109}{\line(0,-1){.05963303}}
\multiput(133.75,8.75)(.04782609,-.05){115}{\line(0,-1){.05}}
\put(156.95,11){\oval(9.9,4)[]}
\put(152.13,9.5){}
\put(151.45,.75){\oval(9.9,4)[]}
\put(146.63,-.75){}
\put(164.2,1){\oval(9.9,4)[]}
\put(159.38,-.5){}
\multiput(155,9.25)(-.04816514,-.05963303){109}{\line(0,-1){.05963303}}
\multiput(157.5,9)(.04782609,-.05){115}{\line(0,-1){.05}}
\put(181.45,11.5){\oval(9.9,4)[]}
\put(176.63,10){}
\put(175.95,1.25){\oval(9.9,4)[]}
\put(171.13,-.25){}
\put(188.7,1.5){\oval(9.9,4)[]}
\put(183.88,0){}
\multiput(179.5,9.75)(-.04816514,-.05963303){109}{\line(0,-1){.05963303}}
\multiput(182,9.5)(.04782609,-.05){115}{\line(0,-1){.05}}
\put(22.45,18.5){\oval(9.9,4)[]}
\put(18.88,17){}
\put(71.95,19.5){\oval(9.9,4)[]}
\put(68.37,18){}
\put(120.95,20.75){\oval(9.9,4)[]}
\put(116.12,19.25){}
\put(167.45,20.5){\oval(9.9,4)[]}
\put(162.63,19){}
\put(45.95,29.75){\oval(9.9,4)[]}
\put(42.38,28.25){}
\put(90.45,46.25){\oval(9.9,4)[]}
\put(86.87,44.75){{5,21}}
\multiput(25,16.75)(.07568807,-.04816514){109}{\line(1,0){.07568807}}
\multiput(18.25,16)(-.07798165,-.04816514){109}{\line(-1,0){.07798165}}
\multiput(60.75,12.25)(.04816514,.05275229){109}{\line(0,1){.05275229}}
\multiput(75.75,18)(.06192661,-.04816514){109}{\line(1,0){.06192661}}
\multiput(110.75,12.75)(.05,.04807692){130}{\line(1,0){.05}}
\multiput(123.75,18.75)(.05625,-.04791667){120}{\line(1,0){.05625}}
\multiput(164,18.75)(-.05208333,-.04791667){120}{\line(-1,0){.05208333}}
\put(157.75,13){\line(0,1){0}}
\multiput(170,19)(.0733945,-.04816514){109}{\line(1,0){.0733945}}
\multiput(23,20.5)(.12582781,.04801325){151}{\line(1,0){.12582781}}
\multiput(48,27.75)(.178,-.048){125}{\line(1,0){.178}}
\multiput(121.25,22.75)(.08898305,.0480226){177}{\line(1,0){.08898305}}
\put(142.95,31.25){\oval(9.9,4)[]}
\put(138.13,29.75){}
\multiput(146.75,29.75)(.11815068,-.04794521){146}{\line(1,0){.11815068}}
\multiput(48,32)(.148076923,.048076923){260}{\line(1,0){.148076923}}
\multiput(94.5,45)(.18545082,-.04815574){244}{\line(1,0){.18545082}}
\multiput(37.5,7.5)(.04807692,-.05048077){104}{\line(0,-1){.05048077}}
\put(43.45,-.5){\oval(9.9,4)[]}
\put(39.88,-2){}
\put(21.75,13){}
\put(60.75,3.75){}
\put(78.5,-5.75){}
\put(85.5,3.75){}
\put(109.5,4.25){}
\put(181,5.75){}
\put(161.75,-5.25){}
\put(17.7,-1.25){\oval(9.9,4)[]}
\put(14.13,-2.75){}
\put(66.25,-6){}
\put(22.5,18.5){\oval(11.5,5)[]}
\put(61,9.75){\oval(11.5,5)[]}
\put(79.75,0){\oval(11.5,5)[]}
\put(110,10.5){\oval(11.5,5)[]}
\put(181.5,11.5){\oval(11.5,5)[]}
\put(164.25,1){\oval(11.5,5)[]}
\put(85.75,10.25){\oval(11.5,5)[]}
\put(68.25,-.25){\oval(11.5,5)[]}
\end{picture}
 \normalsize
\end{center}
\caption{Dynamic version of the standard segment tree for the segments shown in figure \ref{f1}.}
\label{f5}
\end{figure}
\begin{table}[!ht]
\caption{Comparison of trees given in figures \ref{f1}, \ref{f4} and \ref{f5}. SST denotes Static Segment Tree, DST denotes Dynamic Segment Tree and BITS denotes BITS Tree.}
\label{t1}
\vspace{3mm}
\begin{center}
\begin{tabular}{|l|c|c|c|}
\hline
Description & SST & DST & BITS\\
\hline
Number of nodes &13&31&4\\
\hline
Cumulative list size &4&8&5\\
(for segment storage)&&&\\
\hline
Height of the tree &3&4&2\\
\hline
Maximum stabbing&7&9&4\\
query time&&&\\
\hline
\end{tabular}
\end{center}
\end{table}
The maximum stabbing query time for the static segment tree comes when the query point is 15, and in the dynamic segment tree the maximum query time comes when the query point is 13. However, this analysis is not sufficient, and thus the factors related to the theoretical analysis  with respect to the number of segments as  is shown in table \ref{t2}, which are due to the following lemmas.
\par
For the following lemmas, let us assume SST and DST respectively represent the static and dynamic versions of the standard segment trees. Also, the terms trees and BITS trees are used interchangeably in rest of the paper.
\begin{lemma}
\label{l1}
The maximum number of nodes required for the BITS tree is , where  is the number of segments.
\end{lemma}
\begin{proof}
The range of nodes in BITS trees are due to the end points of the segments, and these ranges are not overlapped with the ranges of other nodes in the tree. As  segments partition the range  into  sub-ranges, the BITS tree can have the maximum of  nodes, since the BITS tree cannot have the nodes with range either  or , where  and  are respectively  and  for the set of segments .
\end{proof}
\begin{table}[!ht]
\caption{Theoretical comparison of static segment trees, dynamic segment trees and the proposed BITS trees. SST denotes Static Segment Trees, DST denotes Dynamic Segment Trees and BITS denotes BITS Trees.}
\label{t2}
\vspace{3mm}
\footnotesize
\begin{center}
\begin{tabular}{|l|c|c|c|}
\hline
Description & SST & DST & BITS\\
\hline
Maximum&&&\\
number of nodes &4n+1&&2n-1\\
\hline
Maximum &&&\\
cumulative list &&&\\
size (for segment &&&\\
storage)&&&\\
\hline
Maximum height&&&\\
of the tree &&&\\
\hline
Maximum stabbing&&&\\
query time&&&\\
\hline
\end{tabular}
\end{center}
\normalsize
\end{table}
\begin{lemma}
Maximum storage required for maintaining the lists on all the nodes together in BITS tree is .
\end{lemma}
\begin{proof}
The maximum storage required for maintaining the lists arises only when one of the node's (say, ) list with  segments and two nodes, other than , each with , , , 1 segments.
Thus, a total of , which is , segments (may be with replication across the lists) stored altogether in the BITS tree. 
\end{proof}
\begin{lemma}
The height of the BITS trees does not exceed .
\end{lemma}
\begin{proof}
The proof follows from the fact that the height of the AVL tree is less than  \cite{avl}.
\end{proof}
\begin{lemma}
Stabbing query on BITS tree can be addressed within  time, where  is the number of output segments.
\end{lemma}
\begin{proof}
As the height of the tree is , to locate a node whose range contains the query point requires  time. Once such a node is found, the segments exists in the list of that node becomes the answer, and thus, we add  time to output the segments. However, if the query point is exactly one of end points of a segment, it is required to access either the inorder successor or the inorder predecessor of the node to list out the segments. In this case, it requires an additional  time to visit that node using the threads. Thus, the stabbing query can be addressed within the time of .
\end{proof}
\begin{lemma}
Let  be the range of root of a DST , and  be the number of segments stored in . Then, .
\end{lemma}
\begin{proof}
Let  be the number of leaf nodes in . Let the range of -th leaf be , where  . It is clear that the range  of the leaf in DST satisfies . Also, the number of leaf nodes in  is , which is the disjoint union of ranges of unit length across the range of the root. Thus, if , then there should at least one segment, say , exists by satisfying , which is impossible. Thus, .
\end{proof}
\par
\begin{lemma}
BITS trees outperforms SST and DST in case of range search.
\end{lemma}
\begin{proof}
Given a range, say , the range search has to find the number of segments overlapped with . In BITS tree, this is done by locating the node , whose range contains , then by visiting the nodes using inorder successor threads till reaching the node  with the range containing . Here, the segments stored in the list of nodes between  and  in the inorder sequence will be the answer. This process needs to visit  nodes, where  is the number of nodes lies between  and  in the inorder sequence. Note that, , where  is the number of nodes in the tree, as a node visited once cannot be visited again. 
\par
However, it is impossible to use inorder sequence in standard segment trees due to the following two reasons.
\begin{itemize}
	\item The SST or BST does not have inorder thread to efficiently access the next node in the inorder sequence.
	\item The range of the nodes are overlapped with its ancestors.
\end{itemize}
Thus, to do range search on SST or DST, one has to use a known binary tree traversal method to answer the query, and that takes the time of , where  is the number of nodes in the tree. This is due to fact that the properties of segment trees are not useful, in this case, to find the range search. 
\par
Thus, the BITS trees outperforms both SST and DST in case of answering the range query.
\end{proof}
\par
The above analysis shows that BITS trees are better, as compared to the standard segment trees, except in list size requirements. Asymptotically, it is  for BITS trees and  for the SST, and may be more for DST as the number of segments does not determine this. However, this is not a major issue, as in any search tree, the time taken to query processing is more important than the space requirements. Once the segments are stored, the overall complexity relies on the number of queries performed. Moreover, in BITS tree the answer (for stabbing query) lies in only one node, but in SST or DST it may spread in several nodes. Due to reduction of height and number of nodes in the tree, it is sure that the BITS trees are much better compared to the standard segment trees. 
\section{Conclusion}
The BITS-tree, proposed in this paper, is a balanced two-way inorder threaded segment tree, which is useful for storing geometric data objects available in one dimension. It handles both stabbing and range queries very efficiently than the standard segment tress. The BITS-trees are not restricted to any bound in range, unlike in the standard segment trees, and that is main advantage of this structure. Thus, one can insert a segment of any range without knowing the overall range the segment tree. Moreover, it is quite possible to generalize this to higher dimension with slight modifications in the data representation.
\bibliographystyle{plain}
\bibliography{hema}
\end{document}
