

\documentclass[nohyperref]{article}

\usepackage{microtype}
\usepackage{graphicx}
\usepackage{subfigure}
\usepackage{booktabs} 

\usepackage{hyperref}

\newcommand{\theHalgorithm}{\arabic{algorithm}}



\usepackage[accepted]{icml2022}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{mathtools}
\usepackage{amsthm}

\usepackage[capitalize,noabbrev]{cleveref}

\usepackage[utf8]{inputenc} \usepackage[T1]{fontenc}    \usepackage{url}            \usepackage{amsfonts}       \usepackage{nicefrac}       \usepackage{xcolor}         \usepackage{listings}


\DeclareUnicodeCharacter{22A2}{}
\DeclareUnicodeCharacter{2200}{}
\DeclareUnicodeCharacter{2124}{}
\DeclareUnicodeCharacter{2115}{}
\DeclareUnicodeCharacter{211D}{}
\DeclareUnicodeCharacter{03BB}{}
\DeclareUnicodeCharacter{2223}{}
\DeclareUnicodeCharacter{2228}{}
\DeclareUnicodeCharacter{2264}{}
\DeclareUnicodeCharacter{2211}{}
\DeclareUnicodeCharacter{2260}{}
\DeclareUnicodeCharacter{2227}{}
\DeclareUnicodeCharacter{2080}{}
\DeclareUnicodeCharacter{2081}{}
\DeclareUnicodeCharacter{2082}{}
\DeclareUnicodeCharacter{2083}{}
\DeclareUnicodeCharacter{2084}{}
\DeclareUnicodeCharacter{2085}{}
\DeclareUnicodeCharacter{2086}{}
\DeclareUnicodeCharacter{211A}{}
\DeclareUnicodeCharacter{2203}{}
\DeclareUnicodeCharacter{2208}{}
\DeclareUnicodeCharacter{03B2}{}
\DeclareUnicodeCharacter{00D0}{}
\DeclareUnicodeCharacter{03B1}{}
\DeclareUnicodeCharacter{03A0}{}
\DeclareUnicodeCharacter{2194}{}
\DeclareUnicodeCharacter{207B}{}
\DeclareUnicodeCharacter{220F}{}
\DeclareUnicodeCharacter{03C6}{}
\DeclareUnicodeCharacter{03C8}{}
\DeclareUnicodeCharacter{2218}{}

\theoremstyle{plain}
\newtheorem{theorem}{Theorem}[section]
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{corollary}[theorem]{Corollary}
\theoremstyle{definition}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{assumption}[theorem]{Assumption}
\theoremstyle{remark}
\newtheorem{remark}[theorem]{Remark}

\usepackage[textsize=tiny]{todonotes}

\icmltitlerunning{Formal Mathematics Statement Curriculum Learning}

\begin{document}

\twocolumn[
\icmltitle{Formal Mathematics Statement Curriculum Learning}





\icmlsetsymbol{equal}{*}

\begin{icmlauthorlist}
\icmlauthor{Stanislas Polu}{openai}
\icmlauthor{Jesse Michael Han}{openai}
\icmlauthor{Kunhao Zheng}{polytechnique}
\icmlauthor{Mantas Baksys}{cambridge}
\icmlauthor{Igor Babuschkin}{openai}
\icmlauthor{Ilya Sutskever}{openai}
\end{icmlauthorlist}

\icmlaffiliation{openai}{OpenAI}
\icmlaffiliation{polytechnique}{École Polytechnique}
\icmlaffiliation{cambridge}{University of Cambridge}

\icmlcorrespondingauthor{Stanislas Polu}{spolu@openai.com}



\vskip 0.3in
]





\printAffiliationsAndNotice

\begin{abstract}
We explore the use of expert iteration in the context of language modeling applied to formal mathematics. We show that at same compute budget, expert iteration, by which we mean proof search interleaved with learning, dramatically outperforms proof search only. We also observe that when applied to a collection of formal statements of sufficiently varied difficulty, expert iteration is capable of finding and solving a curriculum of increasingly difficult problems, without the need for associated ground-truth proofs. Finally, by applying this expert iteration to a manually curated set of problem statements, we achieve state-of-the-art on the \textit{miniF2F} benchmark, automatically solving multiple challenging problems drawn from high school olympiads.
\end{abstract}

\section{Introduction}

Deep learning has enjoyed spectacular success in many domains, including language \cite{brown2020language,devlin2018bert,wu2016google}, vision \cite{radford2021learning,tan2019efficientnet}, and image generation \cite{ramesh2021zero,karras2019style}. One domain where deep learning has not yet enjoyed a comparable success is in tasks that require extensive \emph{planning} and \emph{symbolic reasoning}, with the exception of two-player games \cite{silver2016mastering,silver2017mastering,berner2019dota,vinyals2019grandmaster}. In such games, deep learning systems exhibit a considerable degree of reasoning, especially when trained with self-play combined with a search procedure such as Monte Carlo Tree Search (MCTS) \cite{browne2012survey}. But the resulting reasoning abilities achieved are limited due to the relatively narrow scope of games.

As such, theorem proving in interactive proof assistants, or formal mathematics, appears as an interesting game-like domain to tackle due to its increased scope. Like games, formal mathematics has an automated way of determining whether a trajectory (\emph{i.e.} a proof) is successful (\emph{i.e.} formally correct). But the vast scope of formal mathematics means that any strong reasoning result obtained in it will be more meaningful than comparable results in games (\emph{e.g.} finding proofs to mathematical conjectures), and could even be applicable to important practical problems (\emph{e.g.} software verification).

However, tackling formal mathematics involves two main challenges that we must address in order to continue making progress:  

{\bf Infinite action space} Not only does formal mathematics have an extremely large search space (like Go for example), it also has an infinite action space. At each step of proof search, the model must choose not from a well-behaved finite set of actions, but a complex and infinite set of tactics, potentially involving exogenous mathematical terms that have to be generated (e.g., generating a mathematical statement to be used as a witness, an object used steps such as ``there exists an  ...'', or a cut, the introduction and the chaining of a lemma in the middle of a proof).

{\bf No direct self-play setup} In formal mathematics, a prover is not playing against an opponent but against a set of statements to prove. When faced with a statement that is just too hard, there is no obvious reframing of the formal mathematics setup that will let the prover generate intermediary easier statements to tackle first. This asymmetry prevents naive application of the symmetric self-play algorithms commonly used in 2-player games.

These two differences make a naive application of reinforcement learning to formal mathematics unlikely to succeed. Past work proposed to address the infinite action space problem by sampling from a language model~\cite{polu2020generative}. This paper focuses on this second problem and our basis for addressing it is the observation that the key role of self-play is to provide an unsupervised curriculum. We propose instead to supply auxiliary sets of problem statements (without requiring proofs) of varying difficulty. We empirically show that, when the difficulty of these auxiliary problems is varied enough, a simple expert iteration procedure is able to solve a curriculum of increasingly difficult problems, eventually generalizing to our target distribution. We show that this works with both automatically-generated and manually-curated auxiliary distributions of problems and leverage this to achieve state-of-the-art on the \emph{miniF2F} benchmark. Our results suggest that continuous self-improvement in formal mathematics can potentially be reduced to the problem of generating such sets of formal statements, which we have done in part manually in this work, but could eventually be scaled in the future with more automation (such as more domain-specific statements generator or even informal to formal machine translation).

\subsection{\textit{miniF2F} benchmark}

In this work, we target the \textit{miniF2F}~\cite{zheng2021minif2f} benchmark, which consists of 244 \textit{validation} and 244 \textit{test} formalized statements of mathematical problems from various competitions. We believe it to be a better measure of mathematical reasoning compared to a formal library-derived split. Also, the extreme scarcity in formal libraries of this type of problems makes it an ideal test-bed for the expert iteration methodology studied in this paper.

\subsection{Contribution}

Our contributions are the following: we present \texttt{lean-gym}, a simple REPL interface for interacting with the Lean theorem prover; we propose an expert iteration methodology for GPT-f~\cite{polu2020generative} which uses proofs generated by our models as training data to iteratively improve their performance; we demonstrate that, at fixed compute budget, expert iteration outperforms proof search only; we present a synthetic inequality generator and study how expert iteration finds and solves a curriculum of increasingly difficult problems from a set of generated statements of various difficulty; finally, we present a manually curated set of formalized problem statements and leverage it to achieve state-of-the-art performance on the \textit{miniF2F} benchmark.

\section{Related Work}

Our work strongly relies on, and can be seen as a natural continuation of the work presented in the original GPT-f paper~\cite{polu2020generative} which studies the use of language models to generate tactics, the PACT paper~\cite{han2021proof} which applies GPT-f to Lean and studies the benefits from co-training on self-supervised objectives, and the \textit{miniF2F} benchmark~\cite{zheng2021minif2f}.

We present additional related work in Appendix~\ref{appendix-related}.

\section{Formal Environment}

We choose Lean~\cite{de2015lean,leanprover} as our formal environment. Unlike Metamath~\cite{megill2019metamath}, which has been studied in the original GPT-f paper~\cite{polu2020generative}, Lean benefits from high-level tactics which were shown to be beneficial in the context of the \textit{miniF2F} benchmark~\cite{zheng2021minif2f}--Lean proofs are typically 10x shorter than Metamath's. Also, Lean has recently received a lot of attention from the mathematical community, thanks to projects such as the Perfectoid Spaces~\citep{perfectoidspaces} and the Liquid Tensor experiment~\citep{liquidtensor}, and benefits from a vibrant community of hundreds of contributors to its main mathematical library called \textit{mathlib}. We refer to the {\sc PACT} paper's Background section~\cite{han2021proof} for a detailed introduction to Lean in the context of neural theorem proving.

\subsection{\texttt{lean-gym}}

In the {\sc PACT} paper~\cite{han2021proof}, proof search is performed by the Lean runtime using the {\sc LeanStep} environment, with a generic backend interface to models. While easy to use--one just needs to plug in their model--this approach makes it difficult to alter and iterate on the search procedure because it is programmed in Lean (which is not designed or intended for cluster-wide parallelised I/O intensive tasks), and the coupling of the search procedure with the Lean runtime introduces challenges when scaling to a large number of parallel workers.

To solve these issues we implemented \texttt{lean-gym}\footnote{\url{https://github.com/openai/lean-gym}} -- a simple REPL interface over the standard input/output implemented in Lean directly. We present \texttt{lean-gym}'s API and discuss some of its advantages and limitations in Appendix~\ref{appendix-leangym}.

\subsection{Proof datasets extraction}

We rely on the proof extraction methodology presented in the {\sc PACT} paper~\cite{han2021proof} to extract human tactic proof steps from \textit{mathlib} (the \texttt{tactic} dataset) as well as the various other proof artifacts (\texttt{mix1} and \texttt{mix2} datasets). We also extract \textit{mathlib-\{train,valid,test\}}, the set of statements from \textit{mathlib} along the split proposed in \citet{han2021proof} (the \textit{validation} and \textit{test} splits of \texttt{tactic, mix1, mix2} being aligned with \textit{mathlib-\{valid, test\}} as the splits are determined by declaration name hashes (across all data sources including proof-term mining) as opposed to individual proof steps or data-points).

\section{Expert Iteration}

\textit{Expert iteration} was introduced in \citet{silver2017mastering} and broadly consists in iteratively training models on their previously sampled trajectories, to achieve continuous improvement. In this section we present our expert iteration methodology, including the models and pre-training strategies we rely on.

\subsection{Model}

We use decoder-only Transformers similar to GPT-3~\cite{brown2020language}. Throughout this paper we focus on a model with 36 layers and 774 million trainable parameters (referred to as the \textit{700m} model in the GPT-f paper~\cite{polu2020generative}).

\subsection{Pre-Training}
\label{pre-training}

We pre-train our models successively on GPT-3's post-processed version of CommonCrawl (for 300B tokens) and an updated version of \textit{WebMath}~\cite{polu2020generative} (for 72B tokens) whose mix is presented in Appendix~\ref{appendix-webmath}.

\subsection{Training objectives}

\subsubsection{\textit{Proofstep objective}}

The \textit{proofstep objective}, introduced in \citet{polu2020generative}, consists in generating a \texttt{PROOFSTEP} (a Lean tactic) given a \texttt{GOAL} (a Lean tactic state). We also condition this objective on the current \texttt{DECLARATION} (a Lean theorem name), which remains the same throughout a proof search: \verb|DECL <DECLARATION>| \verb|GOAL <GOAL> PROOFSTEP <PROOFSTEP>|.

The rationale for conditioning on the declaration name is to hint our models on the position of the current declaration in the \textit{mathlib} library. It can be considered as a weak proxy signal for the large amount of information not shown to the model (the full environment consisting of the available imports and currently open declarations such as module names, notations, declared instances, ...). The declaration name lets models at least in principle memorize and then retrieve some of that information, knowing that \texttt{lean-gym} errors if a theorem or definition that is not available in the environment associated with the current declaration is used by tactics generated by our models. Also note that conversely to \citet{polu2020generative} and like \citet{han2021proof} \texttt{<GOAL>} is not necessarily a single goal but a Lean tactic state, which possibly comprises multiple goals.

\subsubsection{\textit{Proofsize objective}}
\label{proofsize}

We depart from \citet{polu2020generative} and use a \textit{proofsize objective} to guide our proof searches, which consists in generating one token that represents a proof size estimate bucket for the current goal (Lean tactic state): \verb|DECL <DECLARATION>| \verb|GOAL <GOAL>| \verb|PROOFSIZE <PROOFSIZE_BUCKET_TOKEN>|

For a given goal , either the goal was proved as part of the proof search and we denote its proof size (the number of tactic applications (compounded Lean tactics counting as one)) as , or the goal was not proved in which case we assign the goal to a bucket that virtually represents "infinite" proof sizes.

We use 11 buckets  and compute the \textit{proofsize} bucket  for a goal  by assigning infinite proof sizes to bucket , all proof sizes over  to bucket  and linearly projecting proof sizes lower than  on the remaining buckets  ( being the bucket for the shortest proof sizes). In practice, when training and sampling from the model, we map  to the tokens .

To value goals as we run proof searches, we sample the \textit{proofsize} bucket token and record the logits  for each viable bucket and use them to get a weighted average with the following formula: .

As an example, if the model assigns  (hence ) then . Conversely if the model assigns  ( being the bucket for the shortest proof sizes) then .

The rationale for using this \textit{proofsize objective} instead of the \textit{outcome objective} described in \citet{polu2020generative} is that (i) it achieves better performance compared to the \textit{outcome objective} (see table~\ref{fig:bootstrap-eval}), and (ii) it prioritizes goals that potentially lead to shorter proofs during proof search, creating an intrinsic incentive for the system to converge towards shorter proofs. Similarly to \citet{polu2020generative} we favor this token-based approach to the introduction of a separate value head to keep the overall architecture simple. This way the \textit{proofsize objective} can be implemented by simply augmenting the training dataset and without any architectural change.



\subsection{Bootstrapping}
\label{boostrapping}

Bootstrapping consists in the steps required to train an initial model on both the \textit{proofstep objective} and the \textit{proofsize objective}.

Given a pre-trained model on \textit{WebMath}, we fine-tune it on the \texttt{tactic} dataset extracted from \textit{mathlib} as well as the proof artifacts dataset \texttt{mix1} as described in \citet{han2021proof}. This initial model, which we denote  is solely trained on the \textit{proofstep objective}. We use the \textit{validation} splits of the \texttt{tactic} and \texttt{m1} datasets to early-stop training. Note that this is our only use of \textit{mathlib-valid} to influence the training process throughout this paper.

To generate data for the \textit{proofsize objective}, we use  to sample proofs for statements from \textit{mathlib-train}. For each statement from \textit{mathlib-train} (25k) we attempt  proof searches using the cumulative logprob priority search described in \citet{polu2020generative} (which does not require a trained value function) using  expansions and  samples per expansion. We denote the set of successful proof searches created in this process as .

Using  we generate dataset  by concatenating: (i) the initial \texttt{tactic} dataset (\textit{proofstep objective}), (ii) a deduplicated set of proofsteps extracted from the proofs in  (\textit{proofstep objective}) and (iii) a deduplicated set of proofsize tuples (goals and proofsize) extracted from the full proof searches in  (\textit{proofsize objective}).

Note that the full proof searches in  include goals that are visited but eventually remain unproved, which provides useful negative examples for the trained value function (even if these negatives may include provable goals that simply were not prioritized by the search). Also note that  doesn't include failed proof searches (which would contain only negative examples and no \textit{proofstep objective} data).

We fine-tune  on  for exactly one epoch (no use of \textit{validation} data for early-stopping) to obtain our initial model  trained on both the \textit{proofstep objective} and the \textit{proofsize objective}.  is used in our expert iteration setup as base model to fine-tune from at each iteration, and  is our first iterated model or \textit{mathlib} bootstrapped model trained on both objectives.

\begin{table}[t]
\caption{Performance of  and  on \textit{mathlib-valid} and \textit{miniF2F-valid} compared to PACT Lean GPT-f as reported in \citet{han2021proof,zheng2021minif2f}. All models have the same architecture.  is sampled using cumulative logprob priority best-first search.  is sampled using best-first search based on the \textit{proofsize objective}. We report our setup ( expansions and  tactic samples per expansions) as well as the setups used in \citet{han2021proof,zheng2021minif2f} to control for compute. We also report the performance of  on \textit{mathlib-valid} when trained using the \textit{outcome objective} from \citet{polu2020generative} as an ablation of our proposed \textit{proofsize objective}.}
\label{fig:bootstrap-eval}
\begin{center}
\begin{small}
\begin{tabular}{lrrrr}
\toprule
Model &  &  & \textit{pass@1} & \textit{pass@8} \\
\cmidrule(r){1-5}
\multicolumn{5}{l}{\textit{mathlib-valid}} \\
~PACT & 512 & 16 & 48.4\% & \\
~ (PACT setup) & 512 & 16 & 48.5\% & 57.6\% \\
~ & 512 & 8 & 46.7\% & 57.5\% \\
~ & 512 & 8 & {\bf 56.3\%} & {\bf 66.3\%} \\  
~ (\textit{outcome objective}) & 512 & 8 & 55.6\% & 65.9\% \\  
\cmidrule(r){1-5}
\multicolumn{5}{l}{\textit{miniF2F-valid}} \\
~MiniF2F & 128 & 16 & 23.9\% & 29.3\% \\
~ (MiniF2F setup) & 128 & 16 & 27.6\% & 31.8\% \\
~ & 512 & 8 & 28.4\% & 33.6\% \\
~ & 512 & 8 & {\bf 28.5\%} & {\bf 35.5\%} \\  
~ (\textit{outcome objective}) & 512 & 8 & 28.3\% & 34.7\% \\
\bottomrule
\end{tabular}
\end{small}
\end{center}
\end{table}

We report in Table~\ref{fig:bootstrap-eval} the pass rates of  and  on \textit{mathlib-valid} and \textit{miniF2F-valid} and compare with previously reported pass rates for equivalent amounts of compute. As reported in \citet{polu2020generative}, training a value function to guide search greatly improves the pass rates of  on \textit{mathlib-valid} (see \citet{polu2020generative} for an ablation of the value function). Interestingly, the gap between  and  on \textit{miniF2F-valid} is not as significant, demonstrating that training a value function on proofs sampled from \textit{mathlib-train} has limited transfer to \textit{miniF2F-valid}. The main differences with \citet{zheng2021minif2f}, potentially explaining the gap on \textit{minif2f-valid} ( vs ), consists in the new pre-training described in section~\ref{pre-training} as well as the use of a more recent \textit{mathlib} checkpoint for the \texttt{mix1}, \texttt{mix2} and \texttt{tactic} datasets.



\subsection{Iterated sampling and training}

Our expert iteration process takes as input: (i) a set of formal statements , (ii) a function  indicating the number of proof search attempts to run per statement at each iteration, (iii) a base model  to fine-tune from at each iteration, and (iv) a \textit{mathlib} bootstrapped model  trained on both objectives.

Each iteration  consists in sampling proof searches for statements in  using , filtering successful proof searches  to extract a new dataset , and fine-tuning  on it to obtain , on which we can iterate. To sample proof searches from  we use the best-first search described in \citet{polu2020generative} with the value function described in section~\ref{proofsize}. We attempt  proof searches for each statement  with  expansions and  samples per expansion. We denote the set of successful proof searches for iteration  as . 

Using  we generate datasets  by concatenating: (i) the initial \texttt{tactic} dataset (\textit{proofstep objective}), (ii) a deduplicated set of proofsteps extracted from the proofs in  (\textit{proofstep objective}), and (iii) a deduplicated set of proofsize tuples (goals and proofsize) extracted from the full proof searches in  (\textit{proofsize objective}).

Note that we use a global deduplication across iterations for both proofsteps and proofsize tuples which we found to be important to maintain the stability of the expert iteration procedure. This global deduplication is somewhat equivalent for each statement to growing a unique proof tree by aggregating all the proof searches that have been run for it across iterations. This virtual proof tree accumulates a growing number of positive proof paths as well as a growing number of visited goals that remain unproven. We use these goals as negative examples for the \textit{proofsize objective}, labeling them with an infinite proofsize. Positive goals are deduplicated keeping the minimum proof sizes across proof searches.

Finally  is obtained by fine-tuning  for exactly one epoch on . Note that the initial \texttt{tactic} dataset is included in each , despite  being already trained on it (along with \texttt{mix1}). We found this repetition to be beneficial overall (as it adds the \textit{mathlib} extracted proofsteps to our deduplicated per statements virtual proof trees) despite it leading to a slight overfit on the \texttt{tactic} dataset in terms of validation loss.

\subsection{Expert iteration on \textit{mathlib-train}}
\label{expit-mathlib-train}

In this section we propose to set  to the statements in \textit{mathlib-train}, run our expert iteration process with it and report performance on both \textit{mathlib-valid} and \textit{miniF2F-valid}. Performance is reported in terms of pass rate (percentage of successful proof searches) as a function of the number of attempts per statement, noted \textit{pass@k} where  is the number of attempts per statement at test time. To reduce noise in these metrics we generally run more than  attempts at test time (generally  to compute  and ), averaging across attempts as needed to obtain a smoother \textit{pass@k} value.

Given the large number of statements in \textit{mathlib-train} (25k) we uniformly set  and use  and  as described in section~\ref{boostrapping} and report \textit{pass@1} and \textit{pass@8} across 8 iterations in figure~\ref{fig:pp-mathlib-2}. The \textit{pass@1} on \textit{mathlib-valid} goes from  for  to  for . The performance steadily improves and follows a clear logarithmic scaling law on \textit{mathlib-valid}. It is also notable that, initially, transfer to out-of-distribution \textit{minif2f-valid} appears limited but eventually kicks in as we reach better performance on \textit{mathlib-valid}. This demonstrates that the expert iteration process does not just overfit to \textit{mathlib} but also leads to improved performance on out-of-distribution statements.

\begin{figure}[ht]
    \begin{center}
    \centerline{\includegraphics[width=\columnwidth]{figures/pp-mathlib-2.pdf}}
    \caption{\textit{pass@1} (plain) and \textit{pass@8} (dotted) for \textit{mathlib-valid} and \textit{minif2f-valid} when running 8 expert iterations with  set to be the statements in \textit{mathlib-train}. The x-axis is log-scaled. It corresponds to the indices of the  models and serves as a good proxy to compute (the amount of test-time and train-time compute per iteration being fixed). The y-axis is scaled linearly and simply shifted between the two graphs (spans an equal range).}
    \label{fig:pp-mathlib-2}
    \end{center}
\end{figure}

\begin{figure}[ht]
    \begin{center}
    \centerline{\includegraphics[width=\columnwidth]{figures/pp-mathlib-3.pdf}}
    \caption{Cumulative pass rate for our \textit{expert iteration} loop as well as a \textit{sample only} loop where we skip re-training the model between iterations. The \textit{adjusted compute} line is computed by fitting the \textit{sample only} curve and shifting it to approximate a setup where we would focus all the additional compute used by expert iteration (sampling training data from \textit{mathlib-train} as well as re-training models at each iteration) towards running proof searches against \textit{mathlib-valid}.}
    \label{fig:pp-mathlib-3}
    \end{center}
\end{figure}


We define the cumulative pass rate at iteration  as the pass rate consisting of all proof searches up to iteration  (necessarily monotonic in ). Since we set  for evaluation on \textit{mathlib-valid} and \textit{minif2f-valid} at each iteration, the cumulative pass rate at iteration  can be seen as a noisy ensembled \textit{pass@16k} (multiple models (), no averaging). In figure~\ref{fig:pp-mathlib-3}, we report this cumulative pass rate for two iteration loops, our normal one and a sampling-only loop where we skip re-training the model between iterations and solely sample from . This directly compares test-time compute scaling (scaling proof search attempts) to expert iteration scaling (interleaved training on new data sampled from \textit{mathlib-train}) and provides a very clear visualization of the gains of expert iteration. For a fair comparison, we also report an \textit{adjusted compute} line which approximates the test-time performance we would get at each iteration if we were to focus all the additional compute used by expert iteration (sampling proofs from \textit{mathlib-train} as well as re-training models at each iteration) towards solely running proof searches against \textit{mathlib-valid}. 

As shown by figure~\ref{fig:pp-mathlib-3}, the scaling exponent of expert iteration is substantially higher than the scaling exponent associated with solely scaling test-time compute (running more proof searches), demonstrating the clear benefit of expert iteration. We'll denote the fully iterated model from this section as .

Even in the presence of ground-truth proofs for each of the statements in \textit{mathlib-train} (\texttt{tactic} dataset), expert iteration generates data that further improves the performance of the model. The number of statements proved in \textit{mathlib-train} goes from  () at iteration  to  () at iteration 9, while the average proof length of these statements goes from  to . We hypothesize that this continuously improving performance through expert iteration stems from two effects: (i) the model finding new original proofs for the same statements and (ii) the model closing marginally harder statements at each iteration -- which in turn provides more useful training data for the next iteration. By iteration , the model is trained on more than  generated data. We present in Appendix~\ref{appendix-mathlib-proofs} a few examples of original proofs found by our models on \textit{mathlib-train} compared with their ground-truth versions. 

To verify our hypothesis that expert iteration is capable of closing a curriculum of increasingly difficult problems out of a set of problem statements, and that this capability is independent of having access to ground-truth proofs, we propose in the next section to study expert iteration applied to a synthetically generated set of problems for which we have fine-grained control on the difficulty of each statement.

\section{Statement curriculum learning}
\label{climbing}

In this section we focus on running expert iteration on synthetic statements generated by an inequality generator. The use of synthetic statements enables us to control the difficulty of each statement to present evidence that expert iteration can hill-climb the intrinsic difficulty gradient of the resulting set of statements. In particular, we show that, at fixed compute budget, expert iteration eventually closes proofs of hard statements that remain completely out of reach of simply sampling proof searches without interleaved training.

\subsection{Synthetic inequality generator}

We designed a synthetic inequality statement generator for Lean in the spirit of the INT~\cite{wu2020int} generator. The generator consists in generating inequalities from well known inequality theorems (AM-GM, Trivial inequality, Cauchy-Schwarz, Bernoulli, Young, Hölder) and composing them. It is driven by two difficulty parameters:  which controls depth of composition of inequalities and  which controls the complexity of the input expressions to the composed inequalities. We provide details on its implementation in Appendix~\ref{appendix-ineq}.

Using this generator we generate a curriculum of  inequality statements (for which we don't have proofs),  for each values of  and . We denote this set of statements as \textit{synth-ineq}.

To bootstrap our models capabilities on this specific task, we also generate  statements of low difficulty ( and ) and formalize a proof for each of these statements. We refer to this dataset as \textit{synth-ineq-train}. In the rest of this paper we adjunct this training dataset to the \texttt{tactic} dataset used to train our models.

\subsection{Expert iteration on synthetic inequality statements}

In this section we propose to set  to the union of the statements in \textit{mathlib-train} and \textit{synth-ineq}. Again, we uniformly set  and use  and  as described in section~\ref{boostrapping}, except that they are now also trained on \textit{synth-ineq-train}.

Similarly to the previous section, we report in figure~\ref{fig:pp-ineq} the cumulative pass rate for two loops, our standard expert iteration loop, and a proof search only loop where we don't interleave training between iterations. The pass rates are reported split by values of  (pooling together ) which we found to be the main driver for difficulty.

\begin{figure}[ht]
    \begin{center}
    \centerline{\includegraphics[width=\columnwidth]{figures/pp-ineq.pdf}}
    \caption{Cumulative pass rate for our \textit{expert iteration} loop as well as a \textit{sample only} loop where we skip re-training the model between iterations. Pass rates are reported for each value of  (pooling together ).}
    \label{fig:pp-ineq}
    \end{center}
\end{figure}

Despite the challenging nature of these synthetic inequalities, figure~\ref{fig:pp-ineq} demonstrates that expert iteration is capable of learning the intrinsic curriculum induced by \textit{synth-ineq}. In particular, expert iteration is capable of closing  problems of difficulty  without having been provided with any seed ground-truth proof for this difficulty level. Note that difficulty  remains completely out of reach of simply scaling the number of attempts per statements (the \textit{sample only} loop remaining stuck at  for ).

This confirms on our synthetic statements dataset \textit{synth-ineq} that not only expert iteration is capable of learning the curricula occurring in a set of statements, but this process also enables the emergence of new capabilities without the need for ground-truth proofs (ability to close, highly challenging, deeply composed inequalities).

\section{Targeting \textit{miniF2F}}

Motivated by the results from Section~\ref{climbing}, we curated and manually formalized a set of math exercises to target \textit{miniF2F}. \textit{miniF2F} statements being quite out of distribution compared to the distribution of statements present in \textit{mathlib} (which typically includes generic theorems and lemmas but very few exercises), we hypothesized that if the difficulty of this set of statements was made varied enough, expert iteration could potentially leverage it to effectively shift our models' distribution closer to \textit{miniF2F}'s, and in turn, improve their eventual performance on it.

\subsection{Formalization effort}

We manually formalized  statements\footnote{\url{https://github.com/openai/miniF2F/tree/statement_curriculum_learning/lean/src/statement_curriculum_learning}} drawn from the following sources:  examples and exercises from \citet{aopsv1,aopsv2}. The books are classic problem solving textbooks for students in grades 7-12 preparing for contests such as AMCs and AIMEs.  problems from the MATH dataset~\cite{hendrycks2021measuring}. All problems were drawn from the train split of the dataset, focusing on difficulty 5 problems (\textit{miniF2F} only contains problems from the test split).

We refer to \citet{zheng2021minif2f} for more details on the formalization procedure and the typical time needed for it as these problems were formalized in similar conditions. We denote this set of statements as \textit{miniF2F-curriculum} and verified (based on problem provenance and manual inspection of statements) that it had an empty intersection with \textit{miniF2F-\{test,valid\}}.

\subsection{Transfer to \textit{miniF2F}}

In this section we propose to set  to the union of the statements in \textit{mathlib-train}, \textit{synth-ineq} and \textit{miniF2F-curriculum}. We uniformly set  on \textit{mathlib-train} and \textit{synth-ineq} and  on \textit{miniF2F-curriculum} and use  and  as described in section~\ref{climbing}.

\begin{figure}[ht]
    \begin{center}
    \centerline{\includegraphics[width=\columnwidth]{figures/pp-curr-1.pdf}}
    \caption{{\bf Left:} cumulative pass rate on \textit{miniF2F-valid} for our expert iteration loop using our full curriculum (\textit{mathlib-train}, \textit{synth-ineq} and \textit{miniF2F-curriculum}) compared to the expert iteration loop from section~\ref{expit-mathlib-train}. The total number of attempts per iteration in our \textit{full} loop is , which means the total compute deployed is higher than in the \textit{mathlib-train} only loop (). We therefore also report in dotted a \textit{mathlib-train} only loop, taking , whose total number of attempts per iteration is . {\bf Right:} \textit{pass@1} (plain) and \textit{pass@8} (dotted) for our expert iteration loop using our full curriculum (\textit{mathlib-train}, \textit{synth-ineq} and \textit{miniF2F-curriculum}) compared to the \textit{expert iteration} loop from section~\ref{expit-mathlib-train}.}
    \label{fig:pp-curr-1}
    \end{center}
\end{figure}

Similarly to previous sections, we report in figure~\ref{fig:pp-curr-1} (left) the cumulative pass rate on \textit{miniF2F-valid} of our full curriculum expert iteration loop and compare them with the \textit{mathlib-train} only expert iteration from section~\ref{expit-mathlib-train}. Since more compute is deployed in our full-curriculum loop (more statements) we also report a \textit{mathlib-train} only loop taking . At the end of the expert iteration,  out of the  statements from \textit{miniF2F-curriculum} end up being closed, suggesting a lack of density in our manually formalized set of statement. 

We also report in figure~\ref{fig:pp-curr-1} (right) the \textit{pass@1} and \textit{pass@8} for our full curriculum expert iteration loop. The steady improvement on \textit{miniF2F-valid} shows that the expert iteration procedure we propose does not overfit on the statements that compose the curriculum it uses. Despite the potential inefficiency of our curriculum, the improved performance associated with its use demonstrates, as hypothesized, an effective transfer between \textit{miniF2F-curriculum, synth-ineq} and \textit{miniF2F-valid} through expert iteration. We'll denote the fully iterated model from this section as .

\subsection{Results}

\begin{table}[ht]
\caption{Performance of  (value-function based search),  (expert iterated on \textit{mathlib-train}) and  (expert iterated on our full curriculum) on \textit{mathlib-\{valid, test\}} and \textit{miniF2F-\{valid,  test\}}. All proof searches are run with  and .}
\label{fig:final-results}
\begin{center}
\begin{small}
\begin{tabular}{lrrr}
\toprule
Model & \textit{pass@1} & \textit{pass@8} & \textit{pass@64} \\
\cmidrule(r){1-4}
\multicolumn{4}{l}{\textit{mathlib-valid}} \\
~~PACT~\cite{han2021proof} & 48.4\% & - & - \\
~~~~~~~~~~~~~~~~~~~~ & 56.3\% & 66.3\% & 72.0\% \\  
~~ & {\bf 62.6\%} & {\bf 70.7\%} & {\bf 75.8\%} \\  
~~ & 61.7\% & 69.8\% & 75.3\% \\  
\multicolumn{4}{l}{\textit{mathlib-test}} \\
~~ & 56.5\% & 66.9\% & 73.7\% \\  
~~ & {\bf 63.0\%} & 71.5\% & {\bf 77.1\%} \\  
~~ & 62.9\% & {\bf 71.6\%} & 76.3\% \\  
\cmidrule(r){1-4}
\multicolumn{4}{l}{\textit{miniF2F-valid}} \\
~~PACT~\cite{zheng2021minif2f} & 23.9\% & 29.3\% & -\\
~~ & 28.5\% & 35.5\% & 41.2\% \\  
~~ & 31.3\% & 38.3\% & 44.1\% \\  
~~ & {\bf 33.6\%} & {\bf 41.2\%} & {\bf 47.3\%} \\  
\multicolumn{4}{l}{\textit{miniF2F-test}} \\
~~PACT~\cite{zheng2021minif2f} & 24.6\% & 29.2\% & -\\
~~ & 25.9\% & 31.1\% & 33.6\% \\  
~~ & 27.2\% & 33.0\% & 35.2\% \\  
~~ & {\bf 29.6\%} & {\bf 34.5\%} & {\bf 36.6\%} \\  
\bottomrule
\end{tabular}
\end{small}
\end{center}
\end{table}

We report in table~\ref{fig:final-results} the pass rates on \textit{mathlib-\{valid, test\}} and \textit{miniF2F-\{valid, test\}} for the  models trained in previous sections, namely , , and . We achieve a  pass rate (using  attempts) on \textit{miniF2F-valid} and a  pass rate on \textit{miniF2F-test}, substantially improving from the previous state-of-the-art~\cite{zheng2021minif2f}. 

These results include the resolution of  AMC12 problems,  AIME problems and  problems adapted from the IMOs. Out of these statements,  AMC12 problems (\verb|amc12b_2020_p5|, \verb|amc12a_2009_p9|, \verb|amc12a_2003_p24|, \verb|amc12b_2003_p17|),  AIME problems (\verb|aime_1984_p1|, \verb|aime_1990_p4|), and  IMO-adapted problems (\verb|imo_1961_p1|\footnote{Note that this IMO-adapted statement from \textit{miniF2F-valid} is a much weaker version than the original problem (see Appendix~\ref{appendix-proofs} for more context)}, \verb|imo_1964_p2|) are uniquely solved by expert iterated models, the two IMO-adapted and the two AIME problems being uniquely solved by . 

We provide a selection of the proofs found by our models for these statements as well as a qualitative analysis of them in Appendix~\ref{appendix-proofs}.

Also, we achieve a higher than  pass rate (using  attempts) on \textit{mathlib-\{valid, test\}} (a new state-of-the-art as well) suggesting that our models have the potential to be effectively leveraged as proof assistants in the formalization efforts associated with \textit{mathlib}.


\section{Discussion}

\subsection{Model Size}

Throughout this paper, we used a single model size (774m trainable parameters). We briefly experimented with different model sizes (not reported in this paper) and found that model size scaling is not as straightforward as in the case of unsupervised learning~\cite{kaplan2020scaling}. We found that bigger models are better, in the sense that they consistently exhibit higher \textit{pass@1}. But, they are also much more expensive to sample from. And despite their \textit{pass@1} being higher, it is often the case that for a fixed amount of compute, sampling more attempts from a smaller model leads to a better final performance.

For the compute budget we had available, we estimated the model size we used to be a compelling trade-off. We leave as future work a more thorough study of these dynamics to better understand the different compute frontiers involved. Indicatively, with our 774m parameters model, running a full expert iteration to train  required about  A100 days of compute. Running one full proof search (  ) when properly parallelised, requires on average about  A100 hour of compute.

\subsection{Limitations}
\label {limitations}

Despite our models' capability, as discussed in Appendix~\ref{appendix-qualitative}, to generate cuts and witnesses, we believe that their current main limitation lies in their inability (under our proposed search procedure) to chain more than 2 or 3 non-trivial steps of mathematical reasoning, preventing them from consistently (instead of exceptionally) solving challenging olympiad problems. We've been repeatedly impressed by the complexity of some of the proofsteps generated by our models. But, proofs requiring many of such reasoning steps remain beyond our current compute horizon. Even if we solved a selection of challenging olympiad problems, our models are still very far from being competitive with the brightest students in these competitions.

While our models have demonstrated some capabilities to generate cuts, the cuts they generate are often shallow (they involve only a few proofsteps and don't necessarily deeply change the structure of the proof--we refer the reader to the Cut-Elimination theorem and \citet{carbone1996cuts} for a discussion of the influence of cuts on proof size). We believe that studying language models' ability to generate cuts, and designing search procedures that leverage that capability (related ideas can be found in \citet{czechowski2021subgoal}), are interesting avenues of research to alleviate this limitation.

\section{Conclusion}

In this paper we presented an expert iteration procedure for \textit{GPT-f}\cite{polu2020generative}, demonstrating that it is capable of solving a curriculum of increasingly difficult problems out of a set of formal statements of sufficiently varied difficulty. Our results suggest that the lack of self-play in the formal mathematics setup can be effectively compensated for by automatically as well as manually curated sets of formal statements, which are much cheaper to formalize than full proofs. Finally, we hope that the \textit{statement curriculum learning} methodology we presented in this work will help accelerate progress in automated reasoning, especially if scaled with automated generation and curation of formal statements in the future.

\bibliography{references.bib}
\bibliographystyle{icml2022}

\newpage
\appendix
\onecolumn

\section{Related Work}
\label{appendix-related}

\paragraph{Deep learning applied to premise selection and proof guidance} Early applications of deep learning to formal mathematics focused primarily on premise selection and proof guidance. DeepMath~\cite{irving2016deepmath} explored the use of CNNs and RNNs to predict whether a premise is useful to demonstrate a given conjecture. Their results were later improved with FormulaNet~\cite{wang2017premise} by the use of graph neural networks, reminiscent of NeuroSAT~\cite{selsam2018learning}. Proof guidance consists in selecting the next clause to process \textit{inside} an automated theorem prover. \citet{loos2017deep} investigated the use of models similar to DeepMath's for proof guidance and demonstrated a significant uplift on the Mizar library. More recently \citet{firoiu2021training} demonstrated the potential of deep learning techniques to be competitive with E prover's heuristics when applied to resolution calculus while training on fully synthetic data.

\paragraph{Deep learning applied to automated theorem-proving} \textit{HOList}~\cite{bansal2019holist} proposes a formal environment based on HOL Light. They achieve their best performance~\cite{bansal2019learning} with a GNN model designed for premise selection and the use of exploration. The same team studied the use of a skip-tree objective with Transformers on formal statements~\cite{rabe2020language}, demonstrating, along with GPT-f~\cite{polu2020generative}, the potential of leveraging Transformers for formal reasoning. \textit{GamePad}~\cite{huang2018gamepad} and \textit{CoqGymn/ASTactic}~\cite{yang2019learning} introduce environments based on the Coq theorem prover. \textit{ASTactic} generates tactics as programs by sequentially expanding a partial abstract syntax tree. \citet{urban2020first} studied the capability of GPT-2 to produce useful conjectures for the Mizar library and IsarStep~\cite{li2020modelling} explored the synthesis of intermediate propositions in declarative proofs for Isabelle/HOL using Transformers. 

\section{Lean-gym}
\label{appendix-leangym}

\texttt{lean-gym} presents the following API:

\begin{itemize}

\item \verb|init-search|: . Takes a declaration name (a theorem name from the loaded library) and initializes a search while setting the run-time environment at that particular declaration. It returns the initial tactic state along with a fresh \verb|search_id| and \verb|tactic_state_id|.
\item \verb|run_tac|: . Takes a \verb|search_id| and a \verb|tactic_state_id| to identify a tactic state, as well as a tactic string to apply to it. It returns a new tactic state and its associated \verb|tactic_state_id|.

\end{itemize}

Below is an example in-terminal trace demonstrating the use of \texttt{lean-gym}'s REPL interface:

\begin{verbatim}
En_vn_nN_SElog(\cdot ), log(1/\cdot ), sqrt(\cdot )+, -, \times, /, \wedge , max, minEEn_v+n_n+N_SEN_DN_Dn_v+n_n+N_SN_DN_SN_DN_Sn_n = 42 \leq n_v \leq 8N_DN_SN_D=0N_S=0N_D=0N_S=4N_D=4N_S=4 
    map_le_iff_le_comap.1 hψ).trans _).antisymm 
    (map_le_iff_le_comap.1 hφ),
  rw [comap_comap, eq, comap_id],
  exact le_rfl
end
    \end{verbatim} 
  \end{minipage} \\
  \hline 
  \centering Model proof & 
  \begin{minipage}{11 cm}
    \begin{verbatim} 
 
begin
  refine le_antisymm _ (filter.map_le_iff_le_comap.1 hφ),
  refine λ s hs, _,
  rw mem_comap,
  use [ψ ⁻¹' s, hψ hs],
  rw [← preimage_comp, eq, preimage_id]
end
    \end{verbatim} 
  \end{minipage} \\
  \hline
\end{tabular}
\end{small}
\end {table}

\newpage

\subsection*{\texttt{sum\_range\_sub\_sum\_range}}
\begin{table}[h]
\begin{small}
\begin{tabular}{|p{3.5cm}|p{12.5cm}|} 
  \hline 
  \centering Statement & 
  \begin{minipage}{11 cm}
    \begin{verbatim} 
 
lemma sum_range_sub_sum_range {α : Type*} [add_comm_group α] 
  {f : ℕ → α} {n m : ℕ} (hnm : n ≤ m) : 
  ∑ k in range m, f k - ∑ k in range n, f k =
  ∑ k in (range m).filter (λ k, n ≤ k), f k :=
    \end{verbatim} 
  \end{minipage} \\
  \hline 
  \centering Ground-truth & 
  \begin{minipage}{11 cm}
    \begin{verbatim} 
 
begin
  rw [← sum_sdiff (@filter_subset _ (λ k, n ≤ k) _ 
    (range m)), sub_eq_iff_eq_add,
    ← eq_sub_iff_add_eq, add_sub_cancel'],
  refine finset.sum_congr
    (finset.ext ababx, y, za, b, cax^5 + by^5a,b,x,y2 : \mathbb{R}f(x) = Ax + Bg(x) = Bx + AA \ne Bf(g(x)) - g(f(x)) = B - AA + B0 : \mathbb{R}n \geq 9,\textbf{(A) } \text{a multiple of }4 \qquad \textbf{(B) } \text{a multiple of }10 \qquad \textbf{(C) } \text{a prime number} \\ \textbf{(D) } \text{a perfect square} \qquad \textbf{(E) } \text{a perfect cube}24x^2-19x-35(Ax-5)(2Bx+C)ABCAB-3C_1_01, 2, 3a_2+a_4+a_6+a_8+\ldots+a_{98}a_1a_2a_3\ldotsa_1+a_2+a_3+\ldots+a_{98}=137\frac {n} {n +1}\frac {1}{2}\frac {2}{3}\frac{3}{4}1n \rightarrow \infty_0_03050\lambda\mathbb{N}$, we can state the problem by using \texttt{finset.filter}, which is computable. Hence, \texttt{refl} is able to close the goal.   \\
  \hline
\end{tabular}
\end{small}
\end {table}

\end{document}