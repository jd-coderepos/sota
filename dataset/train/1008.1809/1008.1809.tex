\documentclass[envcountsame]{llncs}
\usepackage{tikz}
\usetikzlibrary{snakes}

\newcommand{\systemname}[1]{\emph{#1}}
\newcommand{\alphabet}{\mathcal{A}}
\newcommand{\atom}[1]{atom(#1)}
\newcommand{\head}[1]{head(#1)}
\newcommand{\body}[1]{body(#1)}
\newcommand{\dneg}[0]{\sim\!\!}
\newcommand{\nodelabel}[2]{#1_{\scriptscriptstyle\!#2}}
\newcommand{\dneglabel}[2]{{\scriptstyle\sim\!}\nodelabel{#1}{#2}}

\begin{document}

\title{Symmetry-breaking Answer Set Solving}

\author{Christian Drescher\inst{1} \and Oana Tifrea\inst{2} \and Toby Walsh\inst{3}}

\institute{Vienna University of Technology, Austria
\and Free University of Bozen-Bolzano, Italy
\and NICTA and University of New South Wales, Australia}

\maketitle

\begin{abstract}
In the context of Answer Set Programming, this paper investigates symmetry-breaking to eliminate symmetric parts of the search space and, thereby, simplify the solution process.
We propose a reduction of disjunctive logic programs to a coloured digraph such that permutational symmetries can be constructed from graph automorphisms.
Symmetries are then broken by introducing symmetry-breaking constraints.
For this purpose, we formulate a preprocessor that integrates a graph automorphism system. Experiments demonstrate its computational impact.
\end{abstract}

\section{Introduction}
Answer Set Programming (ASP; \cite{baral03}) has been shown to be a useful approach for knowledge representation and non-monotonic reasoning in various applications that include difficult combinatorial search, among them graph theoretic problems, planning, model checking, and problems from bioinformatics. ASP combines an expressive but simple modelling language, able to encode all search problems within the first three levels of the polynomial hierarchy, with high-performance solving capacities \cite{drgegrkakoossc08a}. In fact, ASP solvers have experienced dramatic improvements in their performance \cite{gekasc09b} and compete\footnote{\texttt{http://www.satcompetition.org/}} with the best Boolean Satisfiability (SAT; \cite{bihemawa09a}) solvers.

However, many combinatorial search problems exhibit symmetries which can frustrate a search algorithm to fruitlessly explore independent symmetric subspaces. Various instance families, such as the \emph{Pigeon Hole} problem, are known to require exponential time for resolution and backtracking algorithms \cite{ur87a}. Indeed, state-of-the-art ASP solvers take a very long time to solve those instances (Section \ref{sec:exp}). Once their symmetries are identified, it is possible to avoid redundant computational effort by pruning parts of the search space through symmetry-breaking.

Symmetry-breaking also addresses post-processing: Where symmetries induce equivalence classes in the solution space, symmetric solutions can be discarded. Problems like the \emph{All-interval Series} taken from the CSPLib~\cite{gewa99a} have plenty symmetric solution. However, all solutions to the original problem can be reconstructed from the answer sets under symmetry-breaking.

In this paper we break the problem of symmetry-breaking down into two parts: (1) identifying symmetries and (2) breaking the identified
symmetries. We adopt existing theoretical foundations on introducing sym\-me\-try-breaking constraints (SBC) for SAT instances in conjunctive normal form (CNF) that exhibit symmetries \cite{crgiluro96a,almasa03a,alramasa03a,sa09a}. As to SAT, the basic idea is to detect irredundant generators of the group of permutational symmetries using a reduction to coloured graph automorphism. For each such generator, an SBC is constructed and added to the original CNF formula.

The key contribution of our work is a reduction of symmetry detection for disjunctive logic programs to the automorphisms of a coloured digraph, and an ASP representation of SBC which is linear in the number of problem variables. Furthermore, we formulate Symmetry-breaking Answer Set Solving as preprocessing and demonstrate its computational impact on difficult combinatorial search problems.

The remainder of this paper is organized as follows. We start by giving the necessary background notions of ASP and group theory. In turn, Sections~\ref{sec:sd} and~\ref{sec:sb} cover symmetry detection and symmetry-breaking for ASP, respectively. In Section~\ref{sec:psb} we motivate partial symmetry-breaking, in Section~\ref{sec:exp} we empirically evaluate our approach. Section~\ref{sec:con} draws conclusions.

\section{Logical Background}
A \emph{(disjunctive) logic program} over a set of primitive propositions  is a finite set of \emph{rules}  of the form

where and  are \emph{atoms} for , , and .
A \emph{literal} is an atom  or its default negation .
Let  be the \emph{head} of  and  the \emph{body} of . For a set of literals , define  and . The set of atoms occurring in a logic program  is denoted by , and the set of bodies in  is . For regrouping bodies sharing the same head atom , define .

The semantics of a logic program is given by its answer sets. A set  is an \emph{answer set} of a logic program  over , if  is a -minimal model of the \emph{reduct} \cite{gellif91a}

A rule of form (\ref{form:rule}) can be seen as a constraint on the answer sets of a program, stating that if  are in the answer set and none of  are included, then one of  must be in the set. Clearly, an answer set induces a truth assignment on the atoms in .

The semantics of important extensions to logic programs, such as integrity constraints, is given through program transformations that introduce additional propositions \cite{siniso02a}.
An \emph{integrity constraint} of the form

is a short hand for a rule with an unsatisfiable head, and thus forbids its body to be satisfied in any answer set.

\begin{example} Consider the logic programs  and , both have two answer sets  and , where

Observe, that  and  remain invariant under a swap of atoms  and  which is what we call a symmetry. In this work we will only deal with symmetries that can be thought of as permutations of atoms.
\end{example}

\begin{example} \label{ex:allint}
The \emph{All-interval Series problem} is to find a permutation of the  integers from  to  such that the difference of adjacent numbers are also all-different. We encode the All-interval Series problem introducing propositional variables  and  for the  integer variables taking values , and  auxiliary variables taking values  to represent the differences between adjacent numbers, respectively. Furthermore, we require both sets of variables to have pairwise different values (all-different constraint).

Note that above encoding for the all-different constraint corresponds to its \emph{support encoding}~\cite{drwa10a}. It remains invariant under complex permutation of atoms (see Example~\ref{ex:allintsym}).
\end{example}

\section{Group Theoretic Background}
Intuitively, a symmetry of a discrete object is a transformation of its components that leaves the object unchanged. By a symmetry of an answer set program we mean a permutation of its atoms that does not change the logic program, in particular, maps rules to rules. In principle, such a permutation can affect arbitrarily many atoms at once, for instance, as in the case of a complete cyclic shift.

Symmetries are studied in terms of groups. A \emph{group} is an abstract algebraic structure~, where  is a set closed under a binary associative operation~ such that there is a \emph{unit} element and every element has a unique \emph{inverse}. Often, we abuse notation and refer to the group~, rather than to the structure . A subset  of  is referred to as a \emph{subgroup} of  if  is closed under the binary operation of . A set of group elements  such that any other group element in  can be expressed in terms of their product is called a \emph{generating set} and the elements of  are called \emph{generators} of . A generator is \emph{redundant} if it can be expressed in terms of other generators. An \emph{irredundant} generating set does not contain redundant generators, and provides an extremely compact representation of the group. In fact, representing groups by sets of generators always ensures exponential compression.
\begin{theorem}[Exponential Compression \cite{sa09a}]
Any irredundant generating set for a finite group , such that , contains at most  elements.
\end{theorem}
A \emph{permutation} of a set~ is a bijection . Indeed, the set of permutations form a group under composition, denoted as . It is easy to see that the composition of two permutations is a permutation, that the composition of permutations is associative, that the composition with the \emph{identity} never changes a permutation, and that every permutation has a unique inverse.


The image of  under a permutation  is denoted as , and for  define . The \emph{orbits} of  under  are the set of elements of  to which  can be mapped by (repeatedly) applying . Orbits under a permutation define an equivalence relation on . Analogously, for vectors  define , and sets of sets  such that  for  define .

For a logic program , we define the \emph{symmetric group} of , , to be the group of all permutations of the atoms that occur in .
We will make use of the \emph{cycle notation} where a permutation is a product of disjoint cycles. A cycle~ means that the permutation maps  to ,  to , and so on, finally  back to . An element that does not appear in any cycle is understood as being mapped to itself. Table \ref{fig:graphs} provides some examples. Finally, we define the \emph{support} \cite{mc81a} of a permutation as those elements that are not mapped to themselves.

As to Symmetry-breaking Answer Set Solving, given a logic program , we are interested in the subgroup of the symmetric group of  which elements leave  unchanged. Obviously, a symmetry of a logic program preserves answer sets.
\begin{definition}[Symmetry of a Logic Program]
A symmetry of a logic program  is a permutation of its atoms that does not change .
\end{definition}

\begin{example} \label{ex:allintsym}
There are four symmetries in the All-interval Series problem: (1) the identity, (2) reversing the series (variable symmetry), (3) reflecting the series by substracting each element from  (value symmetry), and (4) doing both. It is easy to see that (2) and (3) form a group of generators. Indeed, we can find both symmetries in our encoding (see Example~\ref{ex:allint}) given in cycle notation below.

Intuitively, the circles in the first three lines of  simply swap the first and the last variable, the second and the last but one variable, etc., value by value to reverse the series, where the remaining circles adjust the auxiliary variables, i.e., swap the differences value by value, respectively. The circles in  swap the values  and ,  and , etc., for each variable to reflect the series. Obviously, the permutations  and  represent (2) and (3), respectively, and do not change the logic program.
\end{example}


\section{ASP Symmetries via Graph Automorphism \label{sec:sd}}
Our approach for detecting symmetries of a logic program is through reduction to, and solution of, an associated Graph Automorphism problem (GAP).

Given a graph , where  is a set of vertices and  is a set of edges. An \emph{automorphism} (symmetry) of  is a permutation of its vertices that maps edges to edges, and non-edges to non-edges. Edge orientation must be preserved in case  is a directed graph. A further extension considers vertex colourings, where symmetries must map each vertex into a vertex with the same colour. More formally, given a partition of the vertices , the \emph{automorphism group} of  \cite{mc81a} is . We will think of the partition  as a \emph{colouring} of the vertices.
The \emph{(Coloured) Graph Automorphism problem} (GAP) is to find all symmetries of a given graph, for instance, in terms of generators. It is not known to have any polynomial time solution, and is conjectured to be strictly between the complexity classes P and NP \cite{ba95a}, thus potentially easier than computing answer sets. A practical algorithm for graph automorphism has been implemented in \systemname{nauty}~\cite{mc81a} and significantly improved in the systems \systemname{saucy}~\cite{dalisama04a,dasakama08a}.

A quite natural GAP encoding for detecting symmetries of logic programs is based on their body-atom graph. The \emph{body-atom graph}  of a logic program  is a directed graph with vertices , and labelled edges , , and .
The body-atom graph has been shown to be a suitable representation of a logic program \cite{linke03b}. However, we modify the body-atom graph by introducing additional vertices for negated atoms to circumvent labelled edges.
\begin{figure}
\begin{center}
\begin{tabular}{c@{\hspace{5em}}c}
\begin{tikzpicture}
	[circle, inner sep=0pt, minimum size=5.0mm, >=stealth]
	\node (b)	at ( 0.0, 0.0) [draw] {};
	\node (a1)	at (-1.5, 0.5) [draw] {};
	\node (al)	at (-1.5,-0.5) [draw] {};
	\node (b1)	at ( 1.5, 1.5) [draw] {};
	\node (bm)	at ( 1.5, 0.5) [draw] {};
	\node (nc1)	at ( 1.5,-0.5) [draw] {};
	\node (nc1)	at ( 1.5,-0.5) [] {};
	\node (ncn)	at ( 1.5,-1.5) [draw] {};
	\node (ncn)	at ( 1.5,-1.5) [] {};
	\draw [-, dotted, thick] (-1.5, 0.125) -- (-1.5,-0.125);
	\draw [-, dotted, thick] ( 1.5, 1.125) -- ( 1.5, 0.875);
	\draw [-, dotted, thick] ( 1.5,-1.125) -- ( 1.5,-0.875);
	\draw [->] (b) -- (a1);
	\draw [->] (b) -- (al);
	\draw [->] (b1) -- (b);
	\draw [->] (bm) -- (b);
	\draw [->, snake=snake, segment amplitude=0.5mm, segment length=2.5mm, line after snake=0.5mm, line before snake=0.5mm] (nc1) -- (b);
	\draw [->, snake=snake, segment amplitude=0.5mm, segment length=2.5mm, line after snake=0.5mm, line before snake=0.5mm] (ncn) -- (b);
\end{tikzpicture} &
\begin{tikzpicture}
	[circle, inner sep=0pt, minimum size=5.0mm, >=stealth]
	\node at ( 1.5,-0.5) [fill, color=lightgray] {};
	\node at ( 1.5,-1.5) [fill, color=lightgray] {};
	\node at (-3.0, 0.5) [fill, color=lightgray] {};
	\node at (-3.0,-0.5) [fill, color=lightgray] {};
	\node at ( 3.0, 1.5) [fill, color=lightgray] {};
	\node at ( 3.0, 0.5) [fill, color=lightgray] {};
	\node (b)	at ( 0.0, 0.0) [draw, rectangle] {};
	\node (a1)	at (-1.5, 0.5) [draw] {};
	\node (al)	at (-1.5,-0.5) [draw] {};
	\node (na1)	at (-3.0, 0.5) [draw] {};
	\node 		at (-3.0, 0.5) [] {};
	\node (nal)	at (-3.0,-0.5) [draw] {};
	\node 		at (-3.0,-0.5) [] {};
	\node (b1)	at ( 1.5, 1.5) [draw] {};
	\node (nb1)	at ( 3.0, 1.5) [draw] {};
	\node 		at ( 3.0, 1.5) [] {};
	\node (bm)	at ( 1.5, 0.5) [draw] {};
	\node (nbm)	at ( 3.0, 0.5) [draw] {};
	\node 		at ( 3.0, 0.5) [] {};
	\node (nc1)	at ( 1.5,-0.5) [draw] {};
	\node 		at ( 1.5,-0.5) [] {};
	\node (ncn)	at ( 1.5,-1.5) [draw] {};
	\node 		at ( 1.5,-1.5) [] {};
	\node (c1)	at ( 3.0,-0.5) [draw] {};
	\node (cn)	at ( 3.0,-1.5) [draw] {};
	\draw [-, dotted, thick] (-1.5, 0.125) -- (-1.5,-0.125);
	\draw [-, dotted, thick] ( 1.5, 1.125) -- ( 1.5, 0.875);
	\draw [-, dotted, thick] ( 1.5,-1.125) -- ( 1.5,-0.875);
	\draw [-, dotted, thick] (-3.0, 0.125) -- (-3.0,-0.125);
	\draw [-, dotted, thick] ( 3.0, 1.125) -- ( 3.0, 0.875);
	\draw [-, dotted, thick] ( 3.0,-1.125) -- ( 3.0,-0.875);
	\draw [->] (a1) -- (na1);
	\draw [->] (al) -- (nal);
	\draw [->] (b) -- (a1);
	\draw [->] (b) -- (al);
	\draw [->] (b1) -- (b);
	\draw [->] (bm) -- (b);
	\draw [->] (b1) -- (nb1);
	\draw [->] (bm) -- (nbm);
	\draw [->] (nc1) -- (b);
	\draw [->] (ncn) -- (b);
	\draw [->] (c1) -- (nc1);
	\draw [->] (cn) -- (ncn);
\end{tikzpicture}
\end{tabular}
\end{center}
\caption{The left picture shows a rule  of the form (\ref{form:rule}) as a body-atom-graph, where  is the body vertex. Straight lines represent edges in , curly lines represent edges in . On the right is the general structure of a 3-coloured graph construction of . Vertices of color 1, 2, and 3 are represented by empty circles, filled circles, and empty squares, respectively.}
\end{figure}

In our GAP encoding every atom in  is represented by two vertices of colour  and  that correspond to the positive and negative literals, respectively. Every rule is represented by a (body) vertex of colour , a set of directed edges that connect the vertices of the literals that appear in the rule's body to its body vertex, and a set of directed edges that connect the body vertex to the vertices of the atoms (positive literals) that appear in the head of the rule. To ensure consistency, that is,  maps to  if and only if  maps to  for any atoms  and , vertices of opposite literals are mated by a directed edge from the positive literal to the negative literal. The choice of three vertex colours insures that body vertices can only be mapped to body vertices, and positive (negative) literal vertices can only be mapped to positive (negative) literal nodes. To conclude, given a logic program  consisting of  rules and  literals over  atoms, the GAP encoding for detecting symmetries of  is constructed by  vertices and  edges. Examples are given in Fig. \ref{fig:graphs}.

Since graph automorphism algorithms are sensitive to the number of vertices of an input graph, our construction can be optimised to reduce the number of graph vertices while preserving its automorphism group. A first simplification is achieved by modelling rules with an empty body and a single head atom, so-called \emph{facts}, by a (forth) colour for the vertex corresponding to the head atom instead of using (empty) body vertices. Furthermore, rules with a single head atom and a 1-literal body are modelled using a directed edge from the vertex corresponding to the literal of the body to the vertex corresponding to the head atom. Observe that this optimisation may connect a literal vertex to a positive literal vertex, where consistency edges connect positive literal vertices to their negative mates. Therefore, unintended mappings between 1-literal body edges and consistency edges are impossible. For the special case of a 1-literal body and an empty head, we connect the literal vertex to the special node ''.
\begin{figure}
\begin{center}
\begin{tabular}{c@{\hspace{5em}}c}
\begin{tikzpicture}
	[circle, inner sep=0pt, minimum size=5.0mm, >=stealth]
	\node at (0.0,0.0) [fill, color=lightgray] {};
	\node at (3.0,1.5) [fill, color=lightgray] {};
	\node (lna) at (0.0,0.0) [draw] {};
	\node (la)  at (0.0,1.5) [draw] {};
	\node (b2)  at (1.5,0.0) [rectangle, draw] {2};
	\node (b1)  at (1.5,1.5) [rectangle, draw] {1};
	\node (lb)  at (3.0,0.0) [draw] {};
	\node (lnb) at (3.0,1.5) [draw] {};
	\draw [->] (lna) -- (b2);
	\draw [->] (b2) -- (lb);
	\draw [->] (lnb) -- (b1);
	\draw [->] (b1) -- (la);
	\draw [->] (la) -- (lna);
	\draw [->] (lb) -- (lnb);
\end{tikzpicture} & 
\begin{tikzpicture}
	[circle, inner sep=0pt, minimum size=5.0mm, >=stealth]
	\node at (0.0,0.0) [fill, color=lightgray] {};
	\node at (4.5,1.5) [fill, color=lightgray] {};
	\node (lna) at (0.0,0.0) [draw] {};
	\node (la)  at (1.5,0.0) [draw] {};
	\node (b1)  at (1.5,1.5) [rectangle, draw] {1};
	\node (b2)  at (3.0,0.0) [rectangle, draw] {2};
	\node (lb)  at (3.0,1.5) [draw] {};
	\node (lnb) at (4.5,1.5) [draw] {};
	\draw [->] (la) -- (b2);
	\draw [->] (b1) -- (lb);
	\draw [->] (lb) -- (b2);
	\draw [->] (b1) -- (la);
	\draw [->] (la) -- (lna);
	\draw [->] (lb) -- (lnb);
\end{tikzpicture} \\
Original 3-coloured graph of  & Original 3-coloured graph of  \\ \noalign{\vspace {.5cm}}
\begin{tikzpicture}
	[circle, inner sep=0pt, minimum size=5.0mm, >=stealth]
	\node at (0.0,0.0) [fill, color=lightgray] {};
	\node at (3.0,1.5) [fill, color=lightgray] {};
	\node (lna) at (0,0) [draw] {};
	\node (la)  at (0,1.5) [draw] {};
	\node (b2)  at (1.5,0) [rectangle, draw] {1};
	\node (b1)  at (1.5,1.5) [rectangle, draw] {2};
	\node (lb)  at (3,0) [draw] {};
	\node (lnb) at (3,1.5) [draw] {};
	\draw [->] (lna) -- (b2);
	\draw [->] (b2) -- (lb);
	\draw [->] (lnb) -- (b1);
	\draw [->] (b1) -- (la);
	\draw [->] (la) -- (lna);
	\draw [->] (lb) -- (lnb);
\end{tikzpicture} &
 \begin{tikzpicture}
	[circle, inner sep=0pt, minimum size=5.0mm, >=stealth]
	\node at (0.0,0.0) [fill, color=lightgray] {};
	\node at (4.5,1.5) [fill, color=lightgray] {};
	\node (lna) at (0.0,0.0) [draw] {};
	\node (la)  at (1.5,0.0) [draw] {};
	\node (b1)  at (1.5,1.5) [rectangle, draw] {1};
	\node (b2)  at (3.0,0.0) [rectangle, draw] {2};
	\node (lb)  at (3.0,1.5) [draw] {};
	\node (lnb) at (4.5,1.5) [draw] {};
	\draw [->] (la) -- (b2);
	\draw [->] (b1) -- (lb);
	\draw [->] (lb) -- (b2);
	\draw [->] (b1) -- (la);
	\draw [->] (la) -- (lna);
	\draw [->] (lb) -- (lnb);
\end{tikzpicture} \\
 & \\
\end{tabular}
\end{center}
\caption{3-coloured graph constructions and resulting symmetries for the example logic programs  and . \label{fig:graphs}}
\end{figure}

\section{Symmetry-breaking Constraints \label{sec:sb}}
Recall that symmetries of a logic program  induce equivalence classes in the solution space (orbits). Given an answer set of , all sets to which it can be mapped by symmetries, must be answer sets of . Similarly, symmetries always map non-answer sets to non-answer sets. Therefore, it is sufficient to reason about one representative from every equivalence class. Symmetry-breaking amounts to selecting some representatives from every equivalence class and constructing rules, composed into a symmetry-breaking constraint, that is only satisfied on those representatives. A \emph{full} SBC selects exactly one representative from each orbit, otherwise we call an SBC \emph{partial}. The most common approach is to order all elements from the solution space lexicographically, and to select the lexicographically smallest element, the \emph{lex-leader}, from each orbit as its representative (cf. \cite{crgiluro96a,almasa03a,alramasa03a,sa09a}). A \emph{lex-leader symmetry-breaking constraint} is an SBC that is satisfied only on the lex-leaders of orbits.

We will assume a total ordering on the atoms  of a logic program  and consider the induced lexicographic ordering on the truth assignments, i.e. their interpretation as unsigned integers. The most common approach for accomplishing the construction of a lex-leader SBC is by encoding a \emph{permutation constraint} (PC) for every permutation , where

A careful analysis reveals some possibilities to reduce the size of permutation constraints (cf. \cite{sa09a}). The first corresponds to atoms that are mapped to themselves by the permutation, i.e., . This makes the consequent of the implication unconditionally true. For sparse symmetries, one can significantly reduce the size of the permutation constraint with a restriction of the PC construction to only those atoms that are in the support of . A second possibility corresponds to the lexicographically biggest atom in each cycle of . Assume a cycle  on the atoms of some index set . Using equality propagation on the portion of the permutation constraint where , we get  which is tautologous. Hence, we can further restrict the index set in the PC by excluding the lexicographically biggest atom in each cycle.

Through \emph{chaining} which includes additional atoms, we achieve a PC representation that is linear in the number of atoms (cf. \cite{almasa03a}):

Finally, we encode above permutation constraint in ASP that is satisfied for the lex-leader in the orbit induced by  as follows

where . The lex-leader symmetry-breaking constraint that breaks every symmetry in a logic program can now be constructed by conjoining all of its permutation constraints. 
\begin{example}
We illustrate our PC encoding on the symmetries detected for the previous examples  and . Since both permutations  and  (see Fig. \ref{fig:graphs}) map  to  and vice versa, they share the same lex-leader SBC which is as simple as follows (assuming  is lexicographically greater than ):

Observe that the ordering on the atoms of a logic program  induces a preference relation on the answer sets of  under symmetry-breaking. Here, the ordering selects  as the representative of the set of all answer sets symmetric to , hence, eliminating the answer set . 
\end{example}


\section{Partial Symmetry-breaking \label{sec:psb}}
Breaking all symmetries may not speed up search because there are often exponentially many of them. A better trade-off may be provided by breaking \emph{enough} symmetries \cite{crgiluro96a}. Irredundant generators are good candidates because they can not be expressed in terms of each other, and implicitly represent all symmetries.
Hence, breaking all symmetries in a generating set can eliminate all problem symmetries. However, this does not hold in general. In fact, it has been shown that even when breaking all symmetries is polynomial, there exists cases where for which SBCs based on any irredundant generating set fail to break all symmetry \cite{kanawa09a}.

We can further reduce the size of symmetry-breaking constraints by restricting the construction of permutation constraints up to the -th atom in each permutation \cite{almasa03a}.
\begin{example}
Consider the All-interval Series problem encoded as in Example~\ref{ex:allint} and the generators  and  from Example~\ref{ex:allintsym}.
The symmetry-breaking constraint, where both permutation constraints are restricted to the second atom, is given through the following, where  are new atoms.

\end{example}

\section{Experiments \label{sec:exp}}
Our approach to Symmetry-breaking Answer Set Solving has been implemented within the preprocessor \systemname{sbass}\footnote{\texttt{http://potassco.sourceforge.net/} provides \systemname{clasp}, \systemname{gringo}, and \systemname{sbass}}. It accepts a logic program in \systemname{smodels}\footnote{\texttt{http://www.tcs.hut.fi/Software/smodels/} provides \systemname{lparse} and \systemname{smodels}} format~\cite{lparseManual} produced by a grounder, e.g. \systemname{lparse} and \systemname{gringo}, and incorporates the graph automorphism tool \systemname{saucy}\footnote{\texttt{http://vlsicad.eecs.umich.edu/BK/SAUCY/}} (2.1) for detecting irredundant generators of the group of permutational symmetries. In return, \systemname{sbass} outputs the given program together with symmetry-breaking constraints, again in \systemname{smodels} format, which can be applied to any suitable answer set solver, e.g. \systemname{smodels} and \systemname{clasp}. Note that \emph{sbass} provides several options, for instance, to print detected generators in cycle notation or statistics.

To evaluate our approach, we conducted experiments on ASP encodings of several difficult combinatorial search problems. Experiments consider the answer set solver \systemname{clasp} (1.3.2) on instances with symmetry-breaking in terms of generators, i.e., instances preprocessed by \systemname{sbass}, and without symmetry-breaking. To explore the impact of partial SBC, we also tried restrictions on the construction of permutation constraints up to the -th support in a permutation, denoted as \systemname{clasp}.
All tests were run on a 2.00~GHz PC under Linux, where each run was limited to 600 s time and 1 GB RAM, preprocessing excluded. However, we also report the runtime for \systemname{sbass} and give the number of generators. The latter gives an impression about the size of the search space implicitly pruned through symmetry-breaking.
In the experiments below we generally compare the runtime for testing the existence of an answer set to a given problem.

\subsection{Pigeon Hole Problems}
The \emph{Pigeon Hole problem} is to show that it is impossible to put  pigeons into  holes if each pigeon must be put into a distinct hole. This problem is provably exponentially hard for any resolution based method, but is tractable using symmetries (all the pigeons are interchangeable and all the holes are interchangeable). We encoded the Pigeon Hole problem based on the support encoding for the all-different constraint \cite{drwa10a}, as follows, where  is taken to mean that pigeon  is assigned hole :

The runtimes for various sizes of  are shown in Table \ref{tab:php}. Although symmetry-breaking has a positive impact, the runtime even with \systemname{clasp} is still exponentially growing with the number of pigeons. Here, symmetry-breaking on the generating set returned by \systemname{saucy} does not break all problem symmetries. We enforced \systemname{saucy} to compute a different set of generators, denoted as \systemname{clasp}, and got a polynomial runtime.
On such problems, full SBCs are essential.
\begin{table}
\caption{Runtime results in seconds for Pigeon Hole problems. \label{tab:php}}
\centering
\begin{tabular}{ccccccccc}
\hline\noalign{\smallskip}
\#&\#gen.& \systemname{sbass} & \systemname{clasp} & \systemname{clasp} & \systemname{clasp} & \systemname{clasp} & \systemname{clasp}\\  
\noalign{\smallskip}
\hline
\noalign{\smallskip}
11 & 18 & 0.05 &  0.38 &  0.15 &  0.06 & 0.02 &  0.62 \\
12 & 20 & 0.08 &  4.09 &  0.07 &  0.22 & 0.03 &  5.99 \\
13 & 22 & 0.11 & 30.57 &  0.43 &  0.32 & 0.03 & 53.39 \\
14 & 24 & 0.16 &272.72 &  4.95 &  1.73 & 0.04 &448.98 \\
15 & 26 & 0.23 & ---   & 62.61 &  3.02 & 0.04 & ---   \\
16 & 28 & 0.32 & ---   & ---   & 23.01 & 0.07 & ---   \\
17 & 30 & 0.44 & ---   & ---   &130.87 & 0.10 & ---   \\
\hline
\end{tabular}
\end{table}

\subsection{Ramsey's Theorem}
Ramsey's Theorem states that for any pair of positive integers  there exists a least positive integer  such that, no matter how we color the edges of the clique with  vertices, , using two colours, say blue and red, there is a sub-clique with  nodes of colour blue or a sub-clique with  nodes of colour red. We used the encoding from \cite{lepffaeigopesc02a}, denoted as , to determine whether  is not an integer for which the theorem holds.

In formerly hard cases, namely  and , symmetry-breaking lead to significant pruning of the search space and yield solutions in a considerably short amount of time. The results presented in Table \ref{tab:ramsey} suggest full SBCs for unsatisfiable instances, but small, partial SBCs for satisfiable instances.

\begin{table}
\caption{Average time for completed runs in seconds and the number of timeouts on Ramsey's Theorem instances, each shuffled 5 times. The asterisk denotes instances that have no answer sets.\label{tab:ramsey}}
\centering
\begin{tabular}{lcccccccccc}
\hline\noalign{\smallskip}
 & & \systemname{sbass} & \multicolumn{2}{c}{\systemname{clasp}} & \multicolumn{2}{c}{\systemname{clasp}} & \multicolumn{2}{c}{\systemname{clasp}} & \multicolumn{2}{c}{\systemname{clasp}}\\ 
   & \#gen. & time & time & \#t.out & time & \#t.out & time & \#t.out & time & \#t.out\\
\noalign{\smallskip}
\hline
\noalign{\smallskip}
 & 11 & 0.06 & \textbf{0.01} &  &  \textbf{0.01} &  &  0.03 &  &  \textbf{0.01} &  \\
 & 12 & 0.10 &  3.58 &  &  1.23 &  &  \textbf{0.49} &  &354.25 &  \\
 & 15 & 1.18 &  0.12 &  &  0.12 &  &  0.14 &  &  \textbf{0.11} &  \\
 & 16 & 1.87 & ---   & 5&  ---  & 5& ---   & 5& ---   & 5\\
 & 15 & 0.26 &  0.73 &  &  0.12 &  &  0.50 &  &  \textbf{0.07} &  \\
 & 16 & 0.37 & ---   & 5&  ---  & 5& ---   & 5& ---   & 5\\
 & 21 & 5.43 &  4.23 &  &  2.29 &  &  2.05 &  &  \textbf{1.32} &  \\
 & 22 & 7.15 & \textbf{77.64} &  &208.66 & 1&180.96 & 3& ---   & 5\\
 & 23 & 9.54 & ---   & 5& ---   & 5& ---   & 5& ---   & 5\\
\hline
\end{tabular}
\end{table}

\subsection{Graceful Graphs}
A labelling  of the vertices of a graph  is \emph{graceful} if  assigns a unique label~ from  to each vertex  such that, when each edge  is assigned the label , the resulting edge labels are distinct. The problem of determining the existence of a graceful labelling of a graph has been modelled as a CSP in \cite{pesm03a}, and is an interesting application for Symmetry-breaking Answer Set Solving because the symmetries are different for each instance and can not be modelled a-priori in general. Our experiments consider graphs  and . The \emph{double wheel} graph  is composed of two copies of a cycle with  vertices, each connected to a central hub. The two wheels , each have rotation and reflection symmetries. The labels of the two cycles can also be interchanged. The graph  is the cross-product of the clique  and the path . It consists of  copies of , with corresponding vertices in the  cliques also forming the vertices of a path . Symmetries of the graph are simultaneous rotations of the cliques and inter-clique permutations.

As can be seen in Table \ref{tab:graceful}, we achieve speed-up on the unsatisfiable instance . For the other instances, all of which are satisfiable, the branching heuristic used in our approach sometimes appears to be misled by the extra variables introduced in \systemname{clasp}. That explains some of the variability in the runtimes. However, the difficult instances show symmetry-breaking to be outperforming.
\begin{table}
\caption{Average time for completed runs in seconds and the number of timeouts on Graceful Graph instances, each shuffled 5 times. The asterisk denotes instances that have no answer sets.\label{tab:graceful}}
\centering
\begin{tabular}{lcccccccccc}
\hline\noalign{\smallskip}
 & & \systemname{sbass} & \multicolumn{2}{c}{\systemname{clasp}} & \multicolumn{2}{c}{\systemname{clasp}} & \multicolumn{2}{c}{\systemname{clasp}} & \multicolumn{2}{c}{\systemname{clasp}}\\ 
   & \#gen. & time & time & \#t.out & time & \#t.out & time & \#t.out & time & \#t.out\\
\noalign{\smallskip}
\hline
\noalign{\smallskip}
   & 5 & 0.02 & 4.24 & & 1.45 & & \textbf{1.32} & & 5.40 &\\
   & 5 & 0.17 & \textbf{0.46} & & 0.56 & & 1.09 & & 0.57 &\\
   & 5 & 0.48 &28.81 & & 5.47 & &17.11 & & \textbf{4.30} &\\
& 5 & 1.21 &191.86& &66.18 & &\textbf{61.59} & &27.04 &2\\
& 5 & 3.34 & \textbf{145.89}& &202.18&1&111.96 &1&112.38 &4\\
 & 3 & 0.04 & 0.08 & & 0.08 & & \textbf{0.07} & & 0.08 &\\
 & 4 & 0.07 & 0.20 & & \textbf{0.10} & & 0.54 & & 0.19 &\\
 & 4 & 0.29 &24.68 & &29.06 & &198.57& &\textbf{24.01}& \\
 & 5 & 0.37 &274.85&3&334.55&3&\textbf{312.56}&\textbf{1}&226.03&3\\
\hline
\end{tabular}
\end{table}

\subsection{Answer Set Enumeration \label{sec:enum}}
Finally, we want to test the impact of symmetry-breaking on the number of answer sets. We modelled the All-interval Series problem (AllInt) as described in Example~\ref{ex:allint}, using a direct representation for  integer variables and auxiliary variables to represent the differences between adjacent numbers (cf.~\cite{drwa10a}), and required both sets of variables to be all-different.

As expected we observe that symmetry-breaking significantly reduces the number of solutions, and therefore, reduces the time necessary for post-processing solutions (see Table~\ref{tab:models}). Clearly, \systemname{clasp} for an increasing number~ discards more solutions (eliminating up to 90 per cent of the solution space).

As in all previous benchmarks, it seems safe to assume that the detection of symmetries in logic programs through reduction to graph automorphism is computationally quite feasible using today's GAP tools such as \systemname{saucy}.

We should also note that a given problem can be encoded in many equivalent logic programs, and with each different encoding our techniques may detect a different generating set. For instance, we tried symmetry detection and symmetry-breaking on logic programs that were preprocessed, i.e. simplified. The key idea of preprocessing logic programs is to identify equivalences among its relevant constituents. These equivalences are then used for building a compact representation of the program \cite{gekanesc08a}. Sometimes, we observed significant better results in terms of time and number of answer sets (eliminating up to 95 per cent of the solution space).
\begin{table}
\caption{Results on computing all answer sets of selected instances. Runtime, number of solutions, and the maximum compression achieved using full SBC are shown.\label{tab:models}}
\centering
\begin{tabular}{lccccccccccc}
\hline\noalign{\smallskip}
 & & \systemname{sbass} & \multicolumn{2}{c}{\systemname{clasp}} & \multicolumn{2}{c}{\systemname{clasp}} & \multicolumn{2}{c}{\systemname{clasp}} & \multicolumn{2}{c}{\systemname{clasp}} & \\
  & \#gen. & time & time & \#sol. & time & \#sol. & time & \#sol. & time & \#sol. & compr.\\
\noalign{\smallskip}
\hline
\noalign{\smallskip}
  & 2 & 0.01 &   0.15 & 39   &   0.11 & 15   &   0.17 & 14   &   0.14 & 40    &65\%\\
  & 2 & 0.01 &   0.78 & 119  &   0.60 & 60   &   0.93 & 40   &   0.77 & 120   &67\%\\
 & 2 & 0.01 &   4.60 & 295  &   3.43 & 148  &   5.69 & 107  &   4.08 & 296   &64\%\\
 & 2 & 0.01 &  23.26 & 647  &  22.82 & 372  &  32.70 & 238  &  24.40 & 648   &63\%\\
 & 2 & 0.01 & 161.90 & 1327 & 147.17 & 862  & 211.27 & 442  & 160.32 & 1328  &67\%\\
        & 5 & 0.07 & 282.36 & 9472 & 168.03 & 5152 &  85.65 & 1150 & 314.15 & 11264 &90\%\\
      & 3 & 0.05 & 229.15 & 5704 & 119.99 & 2836 & 126.25 & 1487 & 268.80 & 6816  &76\%\\
      & 4 & 0.08 & 119.66 & 1080 &  67.96 & 552  &  27.72 & 146  & 145.13 & 1440  &90\%\\
\hline
\end{tabular}
\end{table}


\section{Conclusions \label{sec:con}}
We have investigated symmetry-breaking in the context of Answer Set Programming. In particular, we proposed a reduction from symmetry detection of disjunctive logic programs to the automorphisms of a coloured digraph. Our techniques were formulated as a completely automated flow that (1) starts with a logic program, (2) detects all of its permutational symmetries, (3) represents all symmetries implicitly and always with exponential compression, (4) adds symmetry-breaking constraints that do not affect the existence of answer sets, and (5) can be applied to any existing ASP system without changing its code, which allows for programmers to select the solvers that best fit their needs.

We have empirically evaluated symmetry-breaking on difficult combinatorial search problems and got promising results. In many cases, SBC lead to significant pruning of the search space and yield solutions to problems which are otherwise intractable.
We also observe a significant compression of the solution space which makes symmetry-breaking attractive whenever all solutions have to be post-processed.

Motivated by this success future work concerns an extension to choice rules and weight constraints \cite{siniso02a}.
However, one should not expect Symmetry-breaking Answer Set Solving to give improvement on all benchmark classes. Many ASP benchmarks\footnote{\texttt{http://asparagus.cs.uni-potsdam.de/}} have large numbers of symmetries, but can be solved so quickly that the symmetry detection and -breaking overhead is not justified.

Furthermore, it is often reasonable to assume that the symmetries for a problem are known. For particular symmetries, there are more efficient breaking methods (cf. \cite{wa06a}). This is also target to future work.

\paragraph*{Acknowledgements} The work of Christian Drescher is partially funded by the Austrian Science Fund (FWF) under grant number P20841 and the Vienna Science and Technology Fund (WWTF) under grant ICT08-020.

\begin{thebibliography}{10}
\providecommand{\url}[1]{\texttt{#1}}
\providecommand{\urlprefix}{URL }

\bibitem{almasa03a}
Aloul, F.A., Markov, I.L., Sakallah, K.A.: Shatter: efficient symmetry-breaking
  for boolean satisfiability. In: Proceedings of DAC'03. pp. 836--839. ACM
  (2003)

\bibitem{alramasa03a}
Aloul, F.A., Ramani, A., Markov, I.L., Sakallah, K.A.: Solving difficult
  instances of boolean satisfiability in the presence of symmetry. IEEE
  Transactions on CAD of Integrated Circuits and Systems  22(9),  1117--1137
  (2003)

\bibitem{ba95a}
Babai, L.: Automorphism groups, isomorphism, reconstruction. In: Graham, R.L.,
  Gr{\"o}tschel, M., Lov{\'a}sz, L. (eds.) Handbook of Cominatorics, vol.~2,
  pp. 1447--1540. Elsevier (1995)

\bibitem{baral03}
Baral, C.: Knowledge Representation, Reasoning and Declarative Problem Solving.
  Cambridge University Press (2003)

\bibitem{bihemawa09a}
Biere, A., Heule, M., {van Maaren}, H., Walsh, T. (eds.): Handbook of
  Satisfiability. IOS Press (2009)

\bibitem{crgiluro96a}
Crawford, J., Ginsberg, M., Luks, E., Roy, A.: Symmetry-breaking predicates for
  search problems. In: Proceedings of KR'96. pp. 148--159. Morgan Kaufmann
  (1996)

\bibitem{dalisama04a}
Darga, P.T., Liffiton, M.H., Sakallah, K.A., Markov, I.L.: Exploiting structure
  in symmetry detection for cnf. In: Proceedings of DAC'04. pp. 530--534. ACM
  Press (2004)

\bibitem{dasakama08a}
Darga, P.T., Sakallah, K.A., Markov, I.L.: Faster symmetry discovery using
  sparsity of symmetries. In: Proceedings of DAC'08. pp. 149--154. ACM (2008)

\bibitem{drgegrkakoossc08a}
Drescher, C., Gebser, M., Grote, T., Kaufmann, B., K{\"o}nig, A., Ostrowski,
  M., Schaub, T.: Conflict-driven disjunctive answer set solving. In:
  Proceedings of KR'08. pp. 422--432. AAAI Press (2008)

\bibitem{drwa10a}
Drescher, C., Walsh, T.: A translational approach to constraint answer set
  solving. In: Proceedings of ICLP'10. Cambridge University Press (2010), {T}o
  appear

\bibitem{gekanesc08a}
Gebser, M., Kaufmann, B., Neumann, A., Schaub, T.: Advanced preprocessing for
  answer set solving. In: Proceedings of ECAI'08. pp. 15--19. IOS Press (2008)

\bibitem{gekasc09b}
Gebser, M., Kaufmann, B., Schaub, T.: The conflict-driven answer set solver
  clasp: Progress report. In: Proceedings of LPNMR'09. pp. 509--514. Springer
  (2009)

\bibitem{gellif91a}
Gelfond, M., Lifschitz, V.: Classical negation in logic programs and
  disjunctive databases. New Generation Computing  9,  365--385 (1991)

\bibitem{gewa99a}
Gent, I.P., Walsh, T.: {CSPLIB}: A benchmark library for constraints. In:
  Proceedings of CP'99. pp. 480--481. Springer (1999)

\bibitem{kanawa09a}
Katsirelos, G., Narodytska, N., Walsh, T.: Breaking generator symmetry (2009)

\bibitem{lepffaeigopesc02a}
Leone, N., Pfeifer, G., Faber, W., Eiter, T., Gottlob, G., Perri, S.,
  Scarcello, F.: The dlv system for knowledge representation and reasoning. ACM
  Transactions on Computational Logic  7,  499--562 (2002)

\bibitem{linke03b}
Linke, T.: Suitable graphs for answer set programming. In: Proceedings of
  ASP'03. pp. 15--28 (2003)

\bibitem{mc81a}
McKay, B.: Practical graph isomorphism. In: Numerical mathematics and
  computing. pp. 45--87 (1981)

\bibitem{pesm03a}
Petrie, K.E., Smith, B.M.: Symmetry breaking in graceful graphs. In:
  Proceedings of CP'03. pp. 930--934. Springer (2003)

\bibitem{sa09a}
Sakallah, K.A.: Symmetry and satisfiability. In: Biere et~al.
  \cite{bihemawa09a}, pp. 289--338

\bibitem{siniso02a}
Simons, P., Niemel{\"a}, I., Soininen, T.: Extending and implementing the
  stable model semantics. Artificial Intelligence  138(1-2),  181--234 (2002)

\bibitem{lparseManual}
Syrj{\"a}nen, T.: Lparse 1.0 user's manual

\bibitem{ur87a}
Urquhart, A.: Hard examples for resolution. Journal of ACM  34(1),  209--219
  (1987)

\bibitem{wa06a}
Walsh, T.: Symmetry breaking using value precedence. In: Proceedings of
  ECAI'06. pp. 168--172. IOS Press (2006)

\end{thebibliography}
\end{document}
