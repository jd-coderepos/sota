\clearpage
\part{ORCHID: ``Optimized Routing and sCHeduling in grID wireless sensor networks''}
\section{Overview about ORCHID}\label{sec:overview}
In this section, we will describe the problem statement and give an overview about the principles of the proposed solution ORCHID ("Optimized Routing and sCHeduling in grID wireless sensor networks").

\subsection{Assumptions}\label{sec:assumpProblem}
In addition to the assumptions considered in Section~\ref{sec:genAssum}, we present some other assumptions. We assume a data gathering application where sensors monitor a region and transmit periodic measures or alarms to the sink. We assume also that aggregation is possible: any sensor is able to aggregate data it receives with the data it generates. This assumption is realistic especially for low traffic or when sensor nodes perform some operations like computing the average value or the maximum value of the received data. We assume that each node is assigned a single time slot that suffices for all its transmissions. 

\subsection{Problem Statement}
When the scheduling is based on colors, ordering the slots of a given schedule is equivalent to associating each color with a time slot in the right order (cf. Figure~\ref{fig:intro}).\\

\textit{The problem statement: 
Given a grid colored by the periodic coloring VCM, we want to build routes taking into account these colors and then to order these colors in a schedule ensuring that data reach the sink in one cycle. 
}

We will see in the next sections that solving this problem is achieved by a cross layering between the scheduling and the routing.


\subsection{Discussion about Intuitive Solutions}
Before describing the proposed solution, we explain the different steps that lead us to find the solution that we will propose under the aforementioned assumptions.

\subsubsection{First solution: OPERA~\cite{operaSite}}
We have previously proposed the OPERA software composed of the routing EOLSR~\cite{operaSite} and the scheduling OSERENA~\cite{oserena} adapted to general topologies. EOLSR builds a routing spanning tree and OSERENA colors the tree such that the color of any node is higher than the color of its parent. Colors are ordered in the cycle according to the decreasing order. Consequently, this coloring constraint allows the data aggregation in one cycle. However, for dense and large grid networks, VCM is more optimized than OSERENA in terms of number of colors. 
Moreover, applying a routing algorithm that relies on a spanning tree like EOLSR and integrating it with a periodic coloring like VCM raises some issues as explained in the next section.

\subsubsection{Second solution: Spanning Tree with VCM}
This solution consists in building a spanning tree of the colored grid.
\begin{enumerate}
\item Assume first that we keep a random order of VCM colors on the STDMA cycle. This random order might result in slot inversion and hence additional delays as explained in the scenario of Figure~\ref{fig:goodBad}. Hence, what we should do is to order colors of nodes in the routes.
\item Having a spanning tree that contains all nodes raises the following constraints:
\begin{enumerate}
\item Due to the periodicity of VCM colors, it is impossible that any tree branch contains any color just once for large grids. In this case, delays might exceed one cycle.
\item Let a node  and the route of this node towards the sink via the tree. We order the colors of intermediate nodes in this route such that the color of the first node that appears first in this route is associated to the first slot.
This ensures one STDMA cycle for data transmission for this node . However, we cannot do this for all nodes, for two reasons. First, colors are shared between routes (color repetitions with VCM). Second, nodes are located at different geographic locations relative to the data sink. So, optimizing the order of these colors for some nodes according to one direction might make this order not suitable for other directions. 
\end{enumerate}
\end{enumerate}
 
The previous constraints lead us to define the following principles. 
Instead of building a unique spanning tree including all nodes where it is impossible to have delay optimal routes towards the sink for all nodes, we build several trees. Roots of these trees are particular nodes called aggregators. Then, we order the colors of nodes on these trees. Furthermore, each color does not appear more than once in any tree branch. Any aggregator routes data to another aggregator until data is received by the data sink. In the following two sections, a detailed description of the proposed solution ORCHID is given.


\subsection{Principles of ORCHID}
Figure~\ref{fig:overview} illustrates an example of a grid colored by VCM.  and  are the generator vectors of VCM.
\begin{enumerate}
\item 
Over this grid, ORCHID builds a hierarchical routing: nodes transmit data to a set of aggregators which are the vertices of VCM pattern, and these aggregators route data to the sinks (such as node  in Figure~\ref{fig:overview}). The sinks should be placed themselves at aggregators.
\item Routing and scheduling must ensure that: 
	\begin{itemize}
	\item Any node reaches the closest aggregator in a single cycle. The path followed by this node is denoted '\textit{Route}'.
	\item The number of nodes that are able to reach more than one aggregator in a single cycle must be maximized. Hence, if a node cannot reach the closest aggregator because of link failure, it can route over another aggregator to reach the data sink. Also, this is useful also when there are multiple sinks. In this case, any node can select the closest aggregator for every sink.
\item Paths between aggregators should be fast. They are denoted \textit{`Highways'} in the remaining of this report.
		\end{itemize}              




\item  and  are activated successively in the STDMA cycle as depicted in Figure~\ref{routeHighways}. 
\begin{figure}[!h]
\centering
\includegraphics[width=1.8in]{routeHigh-vect}
\caption{Orchestration of  and  slots in the STDMA cycle.\label{routeHighways}}
\end{figure}
The first activity period of the STDMA cycle is dedicated to : activation of VCM colors. Each VCM color occurs only once. 
Unlike the first period which appears only once in the global STDMA cycle, the second period corresponds to the repetition of the  cycle a number of times sufficient to allow data sent by aggregators to reach the sink. We will see later that this cycle is divided into sub-cycles. Notice that the number of scheduled colors in this period is smaller than in the first one.
\item The scheduling is based on VCM colors. More precisely, no new colors are used and the spatial reuse obtained by VCM must be guaranteed. Furthermore, these colors must be ordered in the STDMA cycle for both  and  periods, in such a way that the end-to-end delays are minimized.

\item Any node is active only during the slots associated with its color and the colors of its potential transmitters and can sleep the remaining time, in both  and  periods.
\end{enumerate}
\subsection{Overview and Steps of ORCHID}
This section provides a more detailed description of ORCHID. Figure~\ref{fig:steps} illustrates its different steps and components.

\begin{figure}[H]
\centering
\includegraphics[width=3.5in]{overview2}\caption{Steps of ORCHID.\label{fig:steps}}
\end{figure}
First, the solution is applied to a colored grid of sensors where each node has a color computed by VCM. The principles of the solution can be presented in the following components:

\begin{enumerate}
\item \textbf{Hierarchical routing structure}:
Figure~\ref{fig:overview} illustrates the hierarchical routing proposed. It is composed of  (dominating trees) and .  and  are the VCM generator vectors.
\begin{figure}[H]
\centering
\REPLACE{\includegraphics[width=3.2in]{overviewNew}}{\includegraphics[width=3.5in]{diagram-2parts}}
\caption{Hierarchical routing structure (left: routing to one aggregator on its dominating tree -- right: mesh routing between aggregators).\label{fig:overview}}
\end{figure}
\begin{enumerate}
\item \textbf{\textit{Routes}}:
\begin{itemize}


\item A set of aggregators is chosen: the vertices of VCM patterns (see Figure~\ref{fig:overview} as an example).
\item Each aggregator  is the root of a dominating tree . A dominating tree is defined by Definition~\ref{def:domTree}.
\begin{definition} \label{def:domTree}
A tree  dominates a set of nodes if any node of this set is either in the tree or has at least one neighbor belonging to this tree. Such a neighbor is called .
\end{definition}

In other words, we build a connected dominated set (CDS) constructed as a tree which is rooted at the aggregator. The tree rooted at any aggregator  is a copy of the tree rooted at another aggregator  after translation by the vector . 

\item For any aggregator , any tree  is as large as possible as long as any color appears only once in this tree branch. 
\item Any node in the grid is necessarily dominated by the tree rooted at the closest aggregator and possibly by trees rooted at other aggregators. As previously said, these other trees are copies of the tree rooted at the closest aggregator after being translated.
\end{itemize}

\item \textbf{\textit{Highways}}: are used by aggregators to join the data sink.
Except aggregators in the border of the grid, any other aggregator has 
 neighboring aggregators (in the grid formed by aggregators). We build  shortest paths between this aggregator and each of these  neighboring aggregators. These shortest paths are called .


\begin{remark}
 and  construction takes into account the colors of the nodes and is based on the same algorithm for all nodes. Hence, the obtained trees and  are the same for all aggregators (as illustrated in Figure~\ref{fig:overview}). For this reason, in the following, we only reason about one aggregator.
\end{remark}

\item \textbf{Routing}: 
For \textit{routing}, any node should maintain the list and positions of the aggregators that it can reach in a single cycle. Given a sink with a known position, this node determines the closest aggregator to this sink and routes data over the dominating tree rooted at this aggregator. Hence, it transmits data either to its parent if it belongs to the tree, or its dominator otherwise.
Then, we use geographic routing to determine for each aggregator the following aggregator over .
\end{enumerate}
\item \textbf{Ordering colors}:
Recall that the slot assignment is based on colors computed by VCM. To ensure minimized delays avoiding slot misordering, ORCHID performs \textbf{Color Ordering} of  and . The Color Ordering is defined as:
\begin{definition}[Color Ordering]
Given a set of colored nodes in a given path, each node color is associated with a time slot in such a way that the color of the node that appears first in the path (the farthest node from the destination) is associated with the first slot. 
\end{definition}
Color Ordering ensures that nodes along a path are activated in the STDMA cycle in the same order of their appearance in this path. Hence, slot misordering delays are avoided and data are delivered within the same cycle.
\textit{Color Ordering} of  and  consists in:
\begin{enumerate}
\item \textbf{\textit{CO-Routes (Color Ordering of )}}: 
The color of the first node linked to the tree is associated with slot , the color of the second node is associated with color , etc. Then, colors of remaining nodes are associated with remaining slots.
This method ensures that the slot granted to a node increases with the node level in the tree. Also, any dominated node has a slot after its .


\item \textbf{\textit{CO-Highways (Color Ordering of )}}: Similarly, for  the order of colors is the same as the order of the nodes on the routes from one aggregator to the next one. 
\end{enumerate}

\item \textbf{Orchestration}:
The global STDMA cycle is composed of the  cycle and the  cycle. Notice that the  cycle is smaller. The  cycle itself is composed of sub-cycles repeated a number of times sufficient to allow the farthest aggregator to reach the data sink.

\end{enumerate}



In the following, we will detail the steps of ORCHID.

\section{: Dominating Tree Construction}\label{sec:aggregators}
Aggregators are nodes with coordinates  where  and  are VCM generator vectors and  and . Each aggregator is the root of a dominating tree.
Hence, ORCHID deals with the dominating tree construction problem. This problem~\cite{CDSExample1, CDSExample2} is similar to the CDS (Connected dominating Set) problem~\cite{CDSSurvey} but the obtained structure must be a tree. Both of these problems are NP-complete~\cite{CDSSurvey, CDSExample1}. The dominating tree problem is defined in~\cite{CDSExample1} as follows: given a graph  with weighted edges, DomTree problem asks to find a minimum total edge weight tree  such that each vertex is either in  or has a neighbor in . In our case, the objective of ORCHID is to connect as many as possible sensors to their closest aggregator. Furthermore, constraints concern essentially colors and behind them the induced delays. More specifically, we define the problem of \textbf{\textit{Dominating Tree Construction}} denoted \textbf{\textit{DomTree}} as: \\
~~\\
\mybox{
\textit{\textbf{DomTree Problem}: Finding a dominating tree with:
\begin{itemize}
\item The objectives:
\begin{enumerate}
\item[\textbf{O1.}] Each node dominated by a tree must reach the root of this tree in one cycle. 
\item[\textbf{O2.}] The number of aggregators that any node can reach in a single cycle is maximized. 
\item[\textbf{O3.}] Any tree dominates the largest possible number of nodes in the grid.
\end{enumerate}
\item The constraints:
\begin{enumerate}
\item[\textbf{C1.}] Each color appears only once in any branch of the dominating tree. 
\item[\textbf{C2.}] Between any two branches of the tree, any two colors appear always in the same order when going on a path towards the root.
\end{enumerate}
\end{itemize}
}
}
The constraints \textbf{C1.} and \textbf{C2}. make the problem different
from (and harder than) a classical connected dominating set/dominating tree 
problem: in fact, they force the tree to be bounded (unlike any 
classical CDS). \\





In this section, we describe our algorithm to answer this problem. 
We start by introducing the following notation where  and  are VCM generator vectors.
\begin{notation}[Parallelogram ]
By abuse of notation, for a vector  of coordinates , we denote  the vector of coordinates  and \footnote{ is the symbol for integer part.}.
Then, we define for any aggregator  of coordinates   the parallelogram  with vertices  translated by . \end{notation}





\subsection{Principles of the Construction of a Dominating Tree}
We consider the aggregator with coordinates . The obtained tree will be repeated for all other aggregators (see Remark~1). We propose a connected dominating tree construction algorithm based on a ``greedy" heuristic, as follows:

\begin{enumerate}
\item The tree is built in  steps: for the aggregator  of coordinates  , we first build a connected dominating tree in  only. Then, we extend the obtained tree via the domination of nodes outside this area. The same algorithm is used for the interior and the exterior of this area.
\item The first node added to the tree is its root. All its neighbors are then dominated. 
\item More generally, when any node is added to the tree, all its undominated neighbors are marked as dominated. The algorithm will not attempt to dominate them later.\item Nodes are dominated in the order of their increasing number of hops towards the root. For two nodes that are at the same number of hops from the root, the node with the smallest geographic distance to the root is dominated first.
\item Nodes belonging to  must have dominators inside .

\item \textbf{Nodes having VCM colors already used in the tree (color is identical to the color of a node already in the tree) cannot be dominated and cannot be used as dominators.}



\item \textbf{When any node  is linked to the tree after having dominated one node, other nodes that have the same color and that are already dominated, are also linked to the tree.}


\item Selection of dominators is based on a priority denoted . To define this priority, we use a heuristic. The priority of any node is the total number of the undominated neighbors that will be dominated if this node is added to the tree (with all other candidates of the same color).
\item Steps {\bf 6.} and {\bf 7.} are the greatest difference with classical CDS.
\end{enumerate}



\subsection{Algorithm of the Construction of a Dominating Tree}
Given the aggregator  of coordinates , Algorithms~\ref{algo:domTree},~\ref{algo:addNode}  and~\ref{algo:domNode} illustrate the construction of the dominating tree  rooted at .



\begin{comment}
\begin{algorithm}\caption{Procedure Initialization}\label{algo:init}
\begin{algorithmic}[1]
\begin{footnotesize}

\STATE  = 
\STATE  = \{color of \}

\STATE Add all the neighbors of  to 
\end{footnotesize}
\end{algorithmic}
\end{algorithm}
\end{comment}
\begin{comment}
\begin{algorithm}\caption{Procedure Dominate\_Node (, ,  , , )}\label{algo:domNode}
\begin{algorithmic}[1]
\begin{footnotesize}

\IF {(  ) OR (  ) OR (color of   ) } \label{algo-line:nodeom1}
\STATE exit  /*This node cannot be dominated*/ \label{algo-line:nodeom2}
\ENDIF
\STATE /*Try to dominate node  */
\FORALL {( neighbors of node )}
	\IF {( and )}
	\STATE break
	\ENDIF 
	\IF {(  ) OR (  ) OR (color of   )}
	\STATE break \label{line:continue}
    \ELSE 
    \STATE {Add  to } \label{line:add}
    \ENDIF 
\ENDFOR 
\IF {( is empty)}
\STATE break /*Cannot dominate this node*/
\ENDIF 
\STATE Sort  according to 
\STATE  = first node sorted in the list 
\STATE Add  to  \label{line:addT}
\STATE The parent of  = the dominator of 
\STATE Add color of  to 
\STATE The dominator of  = 

\end{footnotesize}
\end{algorithmic}
\end{algorithm}
\end{comment}



\begin{algorithm}\caption{\textsc{Dominating-Tree-Construction}}\label{algo:domTree}
\begin{algorithmic}[1]
\begin{scriptsize}
\STATE Input: the grid , the aggregator  and the  (the heuristic for the selection of the )
\STATE Output: the dominating tree   
\STATE  = 
\STATE  =  \STATE Add all the neighbors of  to 
\STATE  = list of nodes in  sorted according to the increasing distance in number of hops relative to the root of the tree. In case of equality, consider the node with the smallest geographic distance to the sink.
\STATE 
\FORALL {(  ) /*Dominate nodes inside */
}
	\STATE  = \textsc{Dominate-Node} (, , ,  , , )
	\IF {()} 
	\STATE \textsc{Add-Nodes} (, , , ) /*Adding dominated nodes with the same color as */
	\ENDIF
\ENDFOR
\STATE  = list of nodes   sorted according to the increasing distance in number of hops relative to the root of the tree. In case of equality, consider the node with the smallest geographic distance to the sink.

\STATE  

\FORALL {(  )/*Dominate nodes outside */}
	\STATE  = \textsc{Dominate-Node} (, , , , , )
	\IF {()} 
	\STATE \textsc{Add-Nodes} (, , , ) /*Adding dominated nodes with the same color as */
	\ENDIF
\ENDFOR
\end{scriptsize}
\end{algorithmic}
\end{algorithm}
\vspace{-11pt}
\begin{algorithm}
\caption{\textsc{Add-Nodes} (, , , )}\label{algo:addNode}
\begin{algorithmic}[1]
\begin{scriptsize}\FORALL {(  the grid  with the same color as )}
	\IF {(  )}
	\STATE hasDominated = False	
	\FORALL {( neighbor of )}
		\IF {() and (color of )} 
		\STATE hasDominated = True		
		\STATE Add  to  		
		\STATE The dominator of  =  		
		\ENDIF	
	\ENDFOR
	\ENDIF	
	\IF {(hasDominated == True)}
		\STATE Add  to  \label{line:addT2}
		\STATE The parent of  = the dominator of 
	\ENDIF	
\ENDFOR
\end{scriptsize}\end{algorithmic}
\end{algorithm}



\begin{algorithm}\caption{\textsc{Dominate-Node} (, ,  , , , )}\label{algo:domNode}
\begin{algorithmic}[1]
\begin{scriptsize}

\IF {(  ) OR (  ) OR (color of   ) } \label{algo-line:nodeom1}
\STATE return NULL /*This node cannot be dominated*/ \label{algo-line:nodeom2}
\ENDIF
\STATE /*Try to dominate node  */
\FORALL {( neighbors of node )}
	\IF {( and )}
	\STATE continue /*next neighbor*/	
	\ENDIF
	\IF {((  ) OR (  ) OR (color of   ))}\label{line:noDom}
	\STATE continue \label{line:continue}/*next neighbor*/	
    \ELSE 
    \STATE {Add  to } \label{line:add}
    \ENDIF 
\ENDFOR 
\IF {( is empty)}
\STATE return NULL /*Cannot dominate this node*/
\ENDIF 
\STATE Sort  according to 
\STATE  = first node sorted in the list 
\STATE Add  to  \label{line:addT}
\STATE The parent of  = the dominator of 
\STATE Add color of  to 
\STATE The dominator of  = 
\STATE return 
\end{scriptsize}\end{algorithmic}
\end{algorithm}



%
 \newpage
\subsection{Properties of a Dominating Tree}\label{sec:propoDomTree}
In this section, we present some results concerning the dominating tree. 


\subsubsection{General Properties}
\begin{theorem}
Algorithm~\ref{algo:domTree} generates a tree.
\end{theorem}

\proof
When any node is dominated, a new link is added to the tree between this node and its dominator. Consequently, there is no disconnected parts in the grid. Hence the result.
\endproof


\begin{lemma}\label{lemma:domNeigh}
At each iteration, the closest undominated node  to the root  has necessarily at least one neighbor that is dominated by .
\end{lemma}

\proof
Assume by contradiction that  has no dominated neighbors. Since nodes form a grid (a connected graph), this assumption means that there exists a shortest path  between  and the aggregator , where  is a positive integer. 
Two cases are possible: 
\begin{itemize}
\item either  is dominated, then there is a contradiction because we could select it as a dominator for ;
\item  either  is not dominated and it is then the closest node to the root and not  as assumed. This results in a contradiction. Hence the proof.
\end{itemize}


\endproof

\begin{lemma}\label{lemma:undominated}
At any iteration, the algorithm attempts to dominate the closest node  to the root aggregator that is not dominated. Two cases are possible,
\begin{itemize}
\item Case 1:  cannot be dominated because:
	\begin{itemize}
	\item its color is used by another node already in the tree;
	\item all of its dominated neighbors have colors already in the tree;
	\end{itemize}

\item Case 2:  can be dominated and a possible dominator exists.
\end{itemize}
\end{lemma}

\proof
First, at any iteration, Algorithm~\ref{algo:domTree} considers the closest node  to the root and attempts to dominate this node if and only if this node is not dominated and this node has not a color used by a node belonging to the tree (see lines~\ref{algo-line:nodeom1} and~\ref{algo-line:nodeom2} in Algorithm~\ref{algo:domNode}).
Second, from Lemma~\ref{lemma:domNeigh},  has at least one neighbor that is dominated. If this neighbor has a color that appears in the tree, it is not kept (see line~\ref{line:continue} in Algorithm~\ref{algo:domNode}). Otherwise, it is a possible dominator for  (see line~\ref{line:add} in Algorithm~\ref{algo:domNode}). Hence the Lemma.\endproof



\begin{theorem}\label{theo:trueAlgo}
Algorithm~\ref{algo:domTree} meets the constraints of \textit{DomTree} problem.\end{theorem}

\proof
According to Algorithms~\ref{algo:domNode} and~\ref{algo:addNode}, any color is linked to the tree in two occasions:
\begin{itemize}
\item First, to dominate any node, its dominator is added to the tree only if its color does not already appear in the tree (see lines~\ref{line:noDom} and~\ref{line:addT} in Algorithm~\ref{algo:domNode}). Hence, no color repetition is produced. Let  denotes this dominator.
\item Second, once  is linked to the tree, other nodes sharing the same color are added to the tree at the same time if they are already dominated and if they have undominated neighbors (see line~\ref{line:addT2} in Algorithm~\ref{algo:addNode}). 
This is the only time when nodes with this color are added to the tree. Because the tree is "grown" from the root, the same color cannot be repeated twice in the branch.
\end{itemize}
Now, to prove that Constraint \textbf{C2.} is met, let us assume that two colors  and  are on the same branch. Assume that  is closer to the root than . This means that all nodes with color  had been added in the tree before all nodes with the color  and are all closer to the root. Hence, the ordering of colors on the branches must be identical.
\endproof

\begin{theorem}\label{theo:cannotDom}
A dominating tree addressing the  problem cannot dominate all nodes for all sizes of the grids.
\end{theorem}

\proof
From Lemma~\ref{lemma:undominated}, dominating one node becomes not possible when the color unicity of the tree might be not guaranteed. However, the number of colors is finite. Consequently, to guarantee the color unicity in the tree, some nodes might not be dominated. 
\endproof

\subsubsection{Properties Concerning Nodes in }


\begin{lemma}\label{lemma:diffColors}
Nodes in  have all different colors.
\end{lemma}

\proof
 is nothing other than the VCM pattern translated by the vector . By definition, inside VCM pattern, there is no color reuse.
\endproof

\begin{theorem}\label{theo:dom}
Any node among  is necessarily dominated by the dominating tree rooted at .
\end{theorem}

\proof
By contradiction, let us assume that there is one or several nodes in  that are not dominated. Let  be the undominated node that is the closest to the aggregator. 
According to Lemma~\ref{lemma:domNeigh}, node  has at least one neighbor  that is dominated. Because all nodes in  (hence in the dominating tree ) have different colors (Lemma~\ref{lemma:diffColors}),  could have been selected as a dominator for . Hence the contradiction. \endproof

\begin{corollary}\label{coro:closest}
Any grid node is necessarily dominated by the tree rooted at the closest aggregator and possibly by trees rooted at other aggregators. 
\end{corollary}
\proof
The result is true because of Theorem~\ref{theo:dom} and because by construction, an aggregator  is the closest aggregator to nodes in . In addition, a tree    
rooted at  can dominate nodes belonging to some  for  and  different positive integers.
\endproof

\subsection{Results: Examples of Dominating Trees}
Figure~\ref{fig:tree} depicts the dominating tree rooted at the aggregator of coordinates . The radio range is set to the grid step. Thick lines present the tree links while the thin lines are the links between a node and the nodes it dominates. We observe that the obtained tree dominates a larger area: almost  color patterns.
\begin{figure}[!h]
\centering
\includegraphics[width=3.in]{tree00-dom}
\caption{The dominating tree obtained for  hop coloring and radio range  the grid step.\label{fig:tree}}
\end{figure}
~~ \\
Figure~\ref{fig:twoTrees} depicts two trees rooted at aggregators of coordinates  and . \begin{figure}[!h]
\centering
{\includegraphics[width=3.in]{R2-two-tree-dom-clip}}\caption{Two dominating trees for  hop coloring and radio range  the grid step.\label{fig:twoTrees}}
\end{figure}

Notice that the built trees cover a large area of the grid which answers the objective \textbf{\textit{O3}} of DomTree problem.


\subsection{Routing Over the Dominating Tree}
Any node that is dominated by a tree, including the tree rooted at the closest aggregator, can reach the root of this tree. Its next hop to reach this aggregator is:
\begin{itemize}
\item Either its parent in the tree, if it belongs to the tree.
\item Or its dominator relative to this tree, otherwise.
\end{itemize}

\section{CO-Routes: Color Ordering for }\label{sec:ordering}
Our objective is to have \textit{Color Ordering} of . 



\subsection{Method of CO-Routes}\label{sec:methOrder}
\begin{method}[CO-Routes]\label{meth:orderColor}

The method is based on the following steps:\begin{enumerate}
\item \textit{Step1: Nodes of a tree}:\\
Consider the tree  rooted at the aggregator  of coordinates . We first start by ordering colors of nodes belonging to .
During the construction procedure of the dominating tree (line~\ref{line:addT} in Algorithm~\ref{algo:domNode}), the color of the first node added to the tree is associated with slot , the second (node or set of nodes) is associated with slot , etc. With this method, nodes with deepest levels in the tree are scheduled in the latest slots of the schedule. \item \textit{Step2: Remaining nodes}: \\
The remaining grid nodes are sorted according to the increasing number of hops to the root of  and in case of equality the geographic distance is considered as a second criteria.
Then, the colors of these nodes are associated with time slots starting with the last slot of the first step.
\end{enumerate}
\end{method}

\begin{comment}
\subsection{Method of Associating Slots to Colors}
\begin{method}[Associating slots to colors]\label{meth:orderSlot}
Slots are associated to colors according to their decreasing order: earliest slots are occupied by highest colors.
\end{method}
\end{comment}

\begin{remark}
Method~\ref{meth:orderColor} only orders colors. Hence,  no new colors than those of VCM are used and no color conflict are created.
\end{remark}


















\begin{comment}
\begin{lemma}
For any two trees  and  rooted respectively at aggregators  and , the maximum number of colors used by this trees inside  and  respectively is the same.
\end{lemma}

\proof
The algorithm of dominating tree construction is the same for any aggregator.
Also, the features this algorithm uses are only relative to the symmetry of the grid. \tred{Consequently, the obtained trees are similar.}
Hence the lemma.
\endproof
\end{comment}

\begin{lemma}\label{lemma:insideFirst}
According to Method~\ref{meth:orderColor}, for any aggregator , colors of nodes inside  are ordered before nodes outside.
\end{lemma}
\proof
Colors of nodes linked first to the tree are ordered firstly. Since the dominating tree construction starts by dominating nodes inside , we have the result.
\endproof
\subsection{Results about the Delays Obtained}
\begin{theorem}\label{theo:treeNode}
Nodes belonging to any tree  reach  in one cycle.
\end{theorem}

\proof
Let  be any node in . By Method~\ref{meth:orderColor},   will be scheduled after all its ascendants since they are linked to the tree before node . Moreover, from Theorem~\ref{theo:trueAlgo}, no two nodes have the same color among these ascendants. 
Because of Constraint~C2., the ordering of colors is consistent on all branches. Hence, no slot misordering is produced and no more than one cycle is needed by any node  to reach this aggregator . 
\endproof
Theorem~\ref{theo:treeNode} is essential. Indeed, generally the whole activity period in the STDMA cycle is followed by an inactivity period. Hence, delivering data in a single cycle avoids the latency caused by this inactivity period.

\begin{lemma}
All nodes that reach any aggregator  in one cycle are necessarily dominated by the tree .
\end{lemma}

\proof
Assume that a node can reach the aggregator in one cycle. This means that there is a path to the root with only increasing slots numbers. Algorithm~\ref{algo:domTree} adds nodes to the tree one after the other, and orders their colors at the same time.
Iteratively, each node of the path, in the reverse order, will be successively dominated by the next-hop and later linked to the tree. Therefore, the path will be (part of) a branch of the tree. 
\endproof





\begin{lemma}\label{lemma:otherTree}
For any aggregator , for any node  , 
  and  where  is another aggregator, then  is scheduled after its dominator relative to the tree rooted at .
\end{lemma}

\proof
According to Lemma~\ref{lemma:insideFirst}, the colors of nodes inside  is ordered before the part outside. Thus, the color of  is ordered after all nodes in . This means that the color of  is ordered after all nodes in  (because  is a copy of ). Hence,  has a slot after its dominator relatively to .


\endproof

\begin{theorem}\label{theo:oneCycleTree}
Given any aggregator , nodes in  reach the aggregator  in one cycle.
\end{theorem}

\proof
Let  be a node in . From Lemma~\ref{theo:dom}, this node has necessarily one dominator which is its next hop towards the aggregator . Three cases are possible:
	\begin{enumerate}
	\item : the result comes from Theorem~\ref{theo:treeNode}. 
	\item  and does not belong to any tree. According to Method~\ref{meth:orderColor}, the color of  is ordered after nodes in the tree, and hence after its dominator. This dominator is able to reach the sink in a single cycle (see Theorem~\ref{theo:treeNode}). 
	\item  but belongs to a tree  rooted at another aggregator . According to Lemma~\ref{lemma:otherTree},  is scheduled after its dominator, itself able to reach the sink in a single cycle according to Theorem~\ref{theo:treeNode}.
	\end{enumerate}	
\endproof

\begin{comment}
\begin{theorem}
Given a tree , any node dominated by  is able to reach the aggregator  in one cycle.
\end{theorem}

\proof
Let  any node dominated by . Two case are possible:
\begin{enumerate}
\item If  or , then the theorem is true according to Theorem~\ref{theo:oneCycleTree} and Theorem~\ref{theo:treeNode}.
\item Else, two cases are possible:
	\begin{enumerate}
	\item  does not belong to any tree. This node is colored in  of Method~\ref{meth:orderColor}, that is after all nodes in the tree  including its dominator. Hence the result. 
	\item  belongs to a tree rooted at another aggregator . As proved in Lemma~\ref{lemma:otherTree},  is scheduled before its dominator. Hence the theorem.
	\end{enumerate}
\end{enumerate}
\endproof
\end{comment}

\section{ Construction and Color Ordering}\label{sec:highways}
 are paths between aggregators and the data sink. Data are routed from one aggregator to another in the direction of the sink. These paths are called  because they are fast; they comprise a small number of nodes and slots granted to these nodes are ordered according to the appearance order of nodes in these paths. In this section, we detail these aspects.

\subsection{ Construction and Routing over }\label{sec:highCon}


The construction of  is based on the following steps:


\begin{enumerate}
\item Considering the grid composed of aggregators (that is a grid where vertices are the aggregators), except aggregators on the grid border, other aggregators have  neighboring aggregators. That is, if we consider the aggregator  placed at the center of the grid, this aggregator has  neighboring aggregators , ,  placed respectively at nodes of coordinates , ,  and  where  and  are the VCM vectors. 
\item We build  shortest paths between the aggregator  and each of its neighboring aggregators , , . For this reason, we speak about  :  on the direction of  vector (between  and ), the second one denoted  in the direction of  vector, the third one denoted  is in the direction of  vector and the fourth one denoted  in the direction of  vector.
\item Two different  should not share the same nodes in order to balance the routing load among different nodes.

Figure~\ref{fig:highway-R3} illustrates the  built by ORCHID for the node  for .

\begin{figure}[h!]
\centering
\includegraphics[width=2.7in]{R3-highway}
\caption{Highways built by ORCHID for .
\label{fig:highway-R3}}
\end{figure}

\item The  built for the aggregator  are repeated for all other aggregators. Notice that aggregators that are in the border of the grid do not need to use all of these .
\item The previous steps allow each aggregator to have  in four directions. These  are used for routing as follows: We use a geographic routing like~\cite{geoRou} to select the closest neighboring aggregator to the sink. The path followed to reach this aggregator is the  computed in step .
\end{enumerate}

\begin{remark}
Each aggregator has  in  directions. This ensures a routing flexibility especially in the following scenarios: the position of the sink is unknown beforehand, the sink is mobile or when there are multiple sinks. Furthermore, it increases robustness against routing failures.
\end{remark}

\begin{remark}
Notice that building  for further directions means activating more nodes in  period. 
Hence, the number of built  for any aggregator is subject to a compromise between delays and energy consumed per node. 
\end{remark}


\subsection{CO-Highways: Color Ordering for }
After building , we now order the colors of nodes in these  in a specific part of the STDMA cycle dedicated to . Indeed, for each , we order the color of intermediate nodes of this  such that the color of the  node on this path is associated with the time slot number  in the part of the STDMA cycle dedicated to . 

\begin{theorem}
With , no more than one cycle is required to any aggregator to reach one of its neighboring aggregators.
\end{theorem}
\proof
Nodes on  have colors that are sorted according to the order of nodes in . So, each node is scheduled before its next hop. Hence the theorem.
\endproof


\section{Orchestration in a STDMA cycle}\label{sec:orchestration}
The key idea of the proposed architecture is that each packet is transmitted first from its source node to the closest aggregator, then this packet is transmitted from one aggregator to another via  until it reaches the data sink. 
In this section, we describe how to carry out this orchestration. 
\subsection{Overview}
Figure~\ref{fig:globalTDMA} depicts the global STDMA cycle obtained. This cycle is composed of two periods:
\begin{figure}[H]
\centering
\includegraphics[width=1.85in]{globalTDMACycle-vect}
\caption{Global STDMA cycle.\label{fig:globalTDMA}}
\end{figure}

\begin{enumerate}
\item The first period  corresponds to the schedule 
of . In this period, each node is awake during its slots and during the slots of its children in the dominating tree. Let  be the number of slots of this period.
\item The second period  is composed of colors of the . This period is divided itself into  sub-periods: , ,  and . Each period  corresponds to a  between two aggregators optimized according to the direction of vector  (see Section~\ref{sec:highCon}). The alternation of the  directions in  cycle favors access fairness between aggregators that follow different directions to reach the sink. 
The period  is repeated a number of times until the farthest aggregator from the sink reaches this sink. In this period, each node belonging to any  is awake during its slots and during the slots of nodes for which it is a next hop. \end{enumerate}


\subsection{Further CO-Highways Optimizations}\label{sec:highway-opt}
In the cycle for , , , , , we observe
that one slot is allocated to aggregators at the beginning of each  cycle where 
. Some of these are unneeded, such as the first slot of  
that immediately follows the last slot of the , also dedicated for
aggregators.
By further reordering the  sequence as , , , ,
the first slots of  and  can also be 
removed, as they never provide progress for routing\footnote{The one of  is still required so as to be able to route both along  and  in the same highway cycle.}. Hence, if the highway  has 3 intermediate nodes, the relative cycle should contain only 3 slots.



\section{Analytical Evaluation of ORCHID Performance} \label{sec:results}
The objective of this section is to estimate the number of slots of the global STDMA cycle of ORCHID and compare the  energy consumed in ORCHID and in IRCO 
(see Section~\ref{sec:IRCO}) when .
First, we introduce the following notations: \\
 The radio range is  and the network is comprised of nodes of the grid, within the disk of size defined by  (with radius = ). \\
 The periodic coloring is defined with VCM vectors , ; their angle
  is , and the number of colors is asymptotically equal to  (Property~\ref{theo:nbColor}). \\
 We have proved in~\cite{VCM} that an asymptotically optimal (in number of colors) h-hop coloring produced by VCM yields 
  when   values asymptotically equal to: 
  , 
  , 


The determination of the number of nodes in a disk of radius  is known as the \textit{Gauss Circle Problem}\footnote{http://en.wikipedia.org/wiki/Gauss\_circle\_problem}. This number is equal to . In the following, we asymptotically approximate this number by .
\subsection{Cycle Length}\label{sec:analysis}
The STDMA cycle of ORCHID comprises a number of slots estimated by Theorem~\ref{theo:totalSlots}. 
\begin{theorem}\label{theo:totalSlots}
With VCM coloring, the global STDMA cycle comprises a number of slots estimated by ~\footnote{without the optimization of Section~\ref{sec:highway-opt}.}.
\end{theorem}

\begin{proof}
The global STDMA cycle of ORCHID is composed of  that asymptotically contains  slots and  that should be repeated a number of times that we denote . 
 should be such that one aggregator is able to reach the farthest other aggregator in the disk of radius . The largest \emph{geographic} distance between any two nodes corresponds to the diagonally opposite nodes with . The minimum (worst-case) progress in along one direction with geographic routing is  per full  cycle
 (, , , ). Consequently, (when ):
 
Now, we need to compute the number of slots of a given . Remember that a  is a path between two given neighbor aggregators. 
Asymptotically when  (and thus ,  also 
grow), the number of hops approaches the distance, and is .
For VCM, asymptotically, they are exactly  hops away (see \cite{VCM}). 
This completes the proof.
\end{proof}

\begin{corollary}\label{coro:cycles}
Asymptotically, ORCHID with VCM coloring needs  cycle of length  and  cycles of length .
\end{corollary}

Notice here that the  cycle is shorter than the  cycles. We will find the same result with simulation results in Section~\ref{sec:slotOrchSimul}.

\subsection{Energy Consumption}\label{sec:energyCon}
The aim of this section is to evaluate the benefits of ORCHID from energy point of view. 
\newcommand{\cE}{\mathcal{E}}
Notice that generally with radio duty cycling scheduling, the sensor node consumes energy: during its slot if it is transmitting and during the slots of its potential transmitters. For simplicity, we will assume that such active node (during a slot), receiving or transmitting, will require an energy equal to .
From results in Section~\ref{sec:analysis} and in Section~\ref{sec:model}, we can estimate the total energy consumed by all nodes in ORCHID and IRCO. \\

In Property~\ref{prop:eqModel}, we have evaluated the average delay in number of slots needed to traverse one radio range which is equal to . In a disk of radius , the farthest two nodes are of a distance . Hence, to route between any two nodes
in this disk, the total number of slots needed is: . Thus, a number of cycles equal to .

We assume that the density defined as the number of nodes per surface unit is equal to . Hence, the total number of nodes in the disk of radius  is equal to: . Each node is awake one slot per cycle for transmission and its neighbors ( neighbors) are awake during this slot for reception. Hence, the total energy consumed in IRCO is:

Recall that , hence we have:


\begin{comment}
During any slot, all nodes having the associated color are awake as well as their neighbors ( nodes). The number of nodes of a given color (slot) is equal to the density of a color which is given by  multiplied by the total number of nodes in the disk (). The total energy consumed in IRCO is:

Recall that , hence we have:

\end{comment}
\begin{comment}
Using this result, we can estimate the number of cycles needed by IRCO to route between any pair of nodes in the disk of radius.
Since one node plus all its neighbors is active at every slot, this yield an estimate of the energy consumption
of IRCO:

\end{comment}

For ORCHID, the total energy consumed is the energy consumed in the  cycle plus the energy consumed in the  cycle.  \\
Asymptotically, the  cycle contains  slots. For each slot, all nodes having the associated color (whose number is = ) are awake as well as their neighbors (). \\ From Corollary~\ref{coro:cycles},  cycles are repeated , each of length  slots. During each  slot,  nodes are active (the transmitter and its next hop). Of course, all nodes having the same color as these two nodes (with a number = ) are also active, hence:

Hence,


As a result, when  is fixed and when : most of
the cost from  comes from the  (right part),
and the ratio
between the  two methods converges to 
 where  is a constant, illustrating the gains of ORCHID for higher densities.














\section{Experimental Results}\label{sec:exp-res}


We developed Python programs implementing ORCHID and IRCO. 
We compare these two methods in terms of delays and energy consumption.
\newcommand{\OO}{}
We used a topology with nodes of the grid inside the disk of radius . 
The scenario is that information sent by any node in this topology reaches the aggregator \OO, the center of the disk.
\footnote{They could be extended to the case where every node reaches one aggregator.}.

\subsection{Number of Slots of ORCHID and IRCO}\label{sec:slotOrchSimul}
\subsubsection{How the Number of Slots is Computed?} 
\noindent  {\bf ORCHID}: 
We first find , the number of  repetition. Then, the number of slots is obtain by adding this to  size of  cycle   the size of the  cycle (= the number of VCM colors). \\
 {\bf IRCO with Shortest-Delay Path}: Path delays are expressed as in Equation~\ref{eq:delay}.


\subsubsection{Results}
We run experiments with various radio ranges ( experiment par radio range). Table~\ref{tab:orchid-result} gives the worst case results (in terms of number of slots). Hence, this table gives an idea about the dimensioning of the global STDMA cycle. 

\begin{table}[!h]
\centering
\begin{scriptsize}
\begin{tabular}{|c|c|c|c|c|c|c|}\hline
\multicolumn{4}{|c|}{VCM parameters ()} & IRCO &
    \multicolumn{2}{c|}{ORCHID} \\ \hline
Radio range &  &  & nb colors. & max nb VCM cycles  & nb highway slots &  max nb highway cycles\\ \hline
&  & &  &  &  & \\ \hline
&  & &  &  &  & \\ \hline
&  & &  &  &  & \\ \hline
&  & &  &  &  & \\ \hline
 \end{tabular} 
\end{scriptsize}
\caption{Comparison of results for sample grid networks with various
radio range\label{tab:orchid-result}}
\end{table}


From Table~\ref{tab:orchid-result} we can deduce two results. \textit{First}, as highlighted in Section~\ref{sec:energyCon}, in ORCHID, the number of slots produced by the repetition of the  is smaller than the number of slots in the  cycle.
For instance, for radio range ,  cycle comprises  slots and the  cycle should be repeated  times and comprises  slots (with optimisation of Section~\ref{sec:highway-opt}, otherwise ): hence a total of  slots. 
\textit{Second}, ORCHID has a smaller number of 
slots than IRCO. For instance, for radio range =, while ORCHID uses  slots, IRCO uses  slots.




\begin{figure}[!h]
\centering
\includegraphics[width=0.7\linewidth]{full-cycle-length.pdf}\caption{Total number of slots necessary for reaching center node in one cycle}\label{fig:orchid-result}
\end{figure}

Figure~\ref{fig:orchid-result} represents graphically the same information (average of  simulations for IRCO): it is the total
number of slots necessary to guarantee that every node of the disk of radius  reaches the center aggregator \OO.

As illustrated in Figure~\ref{fig:orchid-result}, ORCHID is noticeably more efficient than IRCO. This highlights the efficiency of ORCHID scheduling. 

Notice also that as the radio range increases, the number of colors in the VCM cycle becomes the main part of the ORCHID cycle. For IRCO, this part would suffice to cover a large set of the nodes which means that this cycle is repeated only a few times in these topologies. Consequently, the margin of improvement is restricted in this case.
 
 

Note also that in actual WSN networks it is unlikely that a ``all-to-all'' route computation would be performed, hence another routing
such as IRCO with greedy routing would be implemented, at the
cost of worst performance than shortest-delay path. This means that ORCHID is suitable for WSNs.




\subsection{Energy Consumption in ORCHID}
\subsubsection{How Energy Consumption is Computed?}
The energy evaluation is computed as follows:
we count  unit energy consumed 
for every slot where one node is listening to neighbors or is transmitting.
In a VCM cycle ( cycle), potentially every node should be listening
to every neighbor (as it might be used as a relay by these neighbors). In a  cycle, in each slot, only nodes belonging to a  can be transmitting and only their predefined destination should be listening.

\subsubsection{Results}
\begin{figure}[!h]
\centering
\includegraphics[width=0.7\linewidth]{relative-energy.pdf}\caption{Ratio between energy needed by ORCHID, and by IRCO}\label{fig:energy}
\end{figure}
Although ORCHID requires less cycles for guaranteeing the same routing to one aggregator, another essential feature of ORCHID is the energy-efficiency. This is illustrated by Figure~\ref{fig:energy}: the energy consumption is evaluated for both methods, with schedule parameters  found as in Figure~\ref{fig:orchid-result}. 

In Figure~\ref{fig:energy}, we show the ratio between the energy 
consumed with ORCHID and the energy consumed by IRCO. It is represented by the curve ``Relative energy consumption'': it appears that this ratio is between 
 and : this means that ORCHID consumes  to  times less
energy than repeating VCM, a dramatic improvement.

Moreover, as detailed previously (Section~\ref{sec:energyCon}), the asymptotic energy gain of ORCHID is 
even better: this is because the density of the  is much lower
than the density of the network (especially when the radio range increases).
Hence it is very beneficial to replace repetitions of the VCM cycles by
repetitions of the  cycles. In Figure~\ref{fig:orchid-result},
we extrapolate the simulation results for estimating the ratio when
the radius of the disk grows to infinity. Under this condition, in ORCHID,  must be repeated several times. Hence, the  cycle would be a vanishingly low part of the energy cost compared to . For this reason, we compare the energy consumed because of the repetition of  compared to the repetition of .
This is illustrated by the curve ``Asymptotic relative energy consumption'':
as shown, energy consumption in ORCHID is  orders of magnitude lower
than VCM cycle repetition for range greater than .





\subsection{Number of Reachable Aggregators in one Cycle per Node}\label{sec:reachAgg}
Figure~\ref{avgNbAgg} illustrates the average number of aggregators that any node can reach in a single cycle. 
This figure shows that this number is large. For instance, for a radio range , 400 aggregators are reachable in one cycle. Consequently, a node can route through any of these aggregators in one cycle. This is useful in case of multiple sinks or mobile sink. In these scenarios, the closest aggregator to a given sink is not necessarily the best aggregator to reach another sink, or the same sink in a new location. Hence, having many possible aggregators that a node can reach rapidly (in one cycle)    is a real advantage of ORCHID.
This is also useful in case of link failure with a given aggregator. To conclude, ORCHID supports sink mobility and some link failures. 


\begin{figure}[h!]
\centering
\includegraphics[width=3.5in]{avg-nb-aggregator.pdf}
\caption{Average number of reachable aggregators per node.
\label{avgNbAgg}}
\end{figure} 
