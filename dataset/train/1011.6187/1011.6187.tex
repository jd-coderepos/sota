We extend the chain decomposition to assign one of the types , , ,  and  to each chain in . The motivation for this classification is that chains of certain types are, under some conditions, \BG-paths and therefore allow to compute the next step of the construction sequence. The types are defined by Algorithm~\ref{alg:classify}: E.\,g., a chain  with parent  is of type~ if  and of type~ if it is not of type~ and  holds (see Figures~\ref{fig:Classification} and~\ref{fig:Example1}). All chains are unmarked at the beginning of Algorithm~\ref{alg:classify}. It is not difficult to show that the decomposition and classification can be carried out in linear time. We omit a proof.

\begin{wrapfigure}[12]{R}{3cm}
	\vspace{-0.99cm}
	\centering
	\includegraphics[scale=0.7]{./figures/Classification}
	\caption{ and  are of type~,  is of type~,  of type~,  of type~ and  of type~.}
	\label{fig:Classification}
\end{wrapfigure}

\begin{algorithm}
\caption{classify}\label{alg:classify}\begin{algorithmic}[1]
	\State \Comment{the parent of  in : }
	\If{ is contained in }\Comment{type~~}\label{typeone}
		\State assign type~ to 
	\ElsIf{}\Comment{type~: ,  is inner vertex of }
		\If{ is a backedge}
			\State assign type~ to \Comment{type~}
		\Else
			\State assign type~ to ; mark \Comment{type~}
		\EndIf
	\Else \Comment{type~: , ,  is inner vertex of }\If{ is not marked}
			\State assign type~ to \Comment{type~}
		\Else \Comment{ is marked}
			\State assign type~ to ; create a list ; \Comment{type~}\label{assign}
			\While{ is marked}\Comment{ is called a \emph{caterpillar}}
				\State unmark ; append  to ; \label{unmarking}
			\EndWhile
		\EndIf
	\EndIf
\end{algorithmic}
\end{algorithm}


\begin{lemma}\label{ChainDecomposition}
Computing a chain decomposition of a -connected graph and classifying each chain with Algorithm~\ref{alg:classify} takes running time .
\end{lemma}


\begin{definition}\label{upwardsclosed}
Let a subdivision  be \emph{upwards-closed} if for each vertex in  the edge to its parent is in . Let  be \emph{modular} if  is the union of chains.
\end{definition}

In order to find \BG-paths efficiently, we want to restrict every subdivision  to be upwards-closed and modular. However, configurations exist where no \BG-path for a subdivision  is a chain, e.\,g., the subdivision  in Figure~\ref{fig:Classification}. This violates the modularity of  and we have to weaken the restriction: We will allow intermediate subdivisions that are neither upwards-closed nor modular but demand in these cases that we can find a set of  \BG-paths in advance that restores these properties after  steps.







We impose the additional restriction that each link of  that consists only of tree edges has no parallel link, except  in . This prevents \BG-path candidates from violating property~\ref{bgpathdefinition}.\ref{bgpathdefinition3} due to the DFS-structure. We summarize the restrictions.


\begin{enumerate}[label=(), leftmargin=*]
	\item For each upwards-closed and modular subdivision , \BG-paths are only added as\label{R1} single chains of type~,  or , with  being upwards-closed and modular or as sets of  subsequent \BG-paths constructing an upwards-closed modular subdivision  that differs from  in exactly  chains of types  and .
\item For each upwards-closed and modular subdivision , the links of  that consist only of tree edges of  have no parallel links, except  in .\label{R2}
\end{enumerate}



We refer to the current upwards-closed and modular subdivision in a construction sequence that is restricted by~\ref{R1} and~\ref{R2} as . The existence of a restricted sequence is shown in Section~\ref{caterpillars}.
We show that chains of type~ help to find \BG-paths efficiently (proof omitted).

\begin{lemma}\label{structural3a}
Let  be a chain of type~ and  the parent of  such that  but not  is contained in . Then  is a \BG-path for  preserving~\ref{R1} and~\ref{R2}.
\end{lemma}



\begin{wrapfigure}[14]{R}{5.7cm}
	\vspace{-0.5cm}
	\centering
	\subfigure[A \emph{bad} caterpillar  with parent .]{
		\includegraphics[scale=0.5]{./figures/CaterpillarBad}
		\label{fig:CaterpillarBad}
	}
\hspace{0.01cm}
	\subfigure[A \emph{good} caterpillar  with parent .]{
		\includegraphics[scale=0.5]{./figures/CaterpillarGood}
		\label{fig:CaterpillarGood}
	}
	\caption{Kinds of caterpillars.}
	\label{fig:Caterpillar}
\end{wrapfigure}

\subsection{Caterpillars and Existence of the Restricted Sequence}\label{caterpillars}
While chains of type~ form \BG-operations under the conditions of Lemma~\ref{structural3a}, chains of types  and  in general do not. For every chain  of type~, Algorithm~\ref{alg:classify} collects a list  of chains that contains only  and chains of type~ (see line~\ref{unmarking}). We call each list  a \emph{caterpillar}.





\begin{definition}
Let the \emph{parent of a caterpillar}  be the parent of the chain in  that is minimal with respect to .
Let a caterpillar  with parent  be \emph{bad} for a subdivision  if  is a descendant of  and  contains no inner real vertex (see Figure~\ref{fig:CaterpillarBad}). Otherwise,  is called a \emph{good} caterpillar (see Figure~\ref{fig:CaterpillarGood}).
\end{definition}

Caterpillars bundle the single chains of type~, which cannot immediately be added as \BG-paths. They also offer a simple decomposition into successive \BG-paths.

\begin{lemma}\label{AddCaterpillar}
Let  be a caterpillar that consists of  chains and has parent . Let  but no chain in  be contained in . If  is good,  can be efficiently decomposed into  successive \BG-paths satisfying~\ref{R1} and~\ref{R2}.
\end{lemma}
\begin{proof} (sketch) Let  be the last vertex of the minimal chain in  and let  be the parent of . We add either the path , followed by  for all chains  (see Figure~\ref{fig:CaterpillarGood}) or the path , followed by  and  for every remaining chain .
\end{proof}






\begin{definition}\label{segment}
We define the equivalence relation  on  with  for all  and with  for all  if there is a path  without an inner vertex in .
Let the \emph{segments} of  be the subgraphs of  that are induced by the equivalence classes of . Let  be the \emph{attachment points} of .
\end{definition}



\begin{definition}
For a chain  and a subdivision , let  be the set of children of  of types~ and~ that are not contained in  and let  be the set of chains of type~ that start at a vertex in  and are not contained in .
\end{definition}

The following theorem is a key result of this paper and leads not only to an existence proof of the restricted construction sequence but also to an efficient algorithm for computing it.

\begin{theorem}\label{correctness}
For a subdivision , let  be a chain such that  holds for every proper ancestor  of . Then all chains in  and their proper ancestors that are not already contained in  can be successively added as \BG-paths (possibly being part of caterpillars) such that~\ref{R1} and~\ref{R2} is preserved. Moreover, the chains in  that are contained in segments in which the minimal chain is not contained in  can be added at any point in time in arbitrary order (together with their proper ancestors that are not contained in ).
\end{theorem}


The precondition of Theorem~\ref{correctness} is met in every subdivision: For ,  is the desired chain and applying the Theorem on  allows to take the descendants of  in  in subsequent subdivisions. This ensures the existence of the restricted construction sequence.

\begin{corollary}\label{correctnessCorollary}
Let  be a -connected graph with a chain decomposition . Then there is a construction sequence of  restricted by~\ref{R1} and~\ref{R2} that starts with .
\end{corollary}




\section{A Linear-Time Algorithm}\label{algorithm}
With Lemma~\ref{ChainDecomposition}, a chain decomposition, a subdivision  and the classification of chains can be computed in time . Theorem~\ref{correctness} provides an algorithmic method to find iteratively \BG-paths building the restricted construction sequence: Iteratively for each chain , , we add all chains in  (we say that  is \emph{processed}). Note that  meets the precondition of Theorem~\ref{correctness} and that  and  can be build in time  by storing lists of type~ chains at every vertex. We partition the chains in  into the different segments of  containing them by storing a pointer on each  to the minimal chain  of the segment containing . The chain  is computed by traversing  from  to the root until the next vertex is contained in . The current vertex is then an inner vertex of  (each inner vertex has a pointer to its chain) and we mark each vertex of the traversed path with . Further traversals get  by stopping at the first marker that points to a chain not in . Since all traversed chains will be added, the running time amortizes to a total of .

First, we add all chains in  that are contained in segments in which the minimal chain is not contained in  (this can be checked in constant time per chain). According to Theorem~\ref{correctness}, the chains can be added in arbitrary order, as long as their proper ancestors that are not in  are added before. We want to add the remaining chains in . However, Theorem~\ref{correctness} does not specify in which order the chains have to be added, so we need to compute a valid order on them.

Let  be a remaining chain in  and let  be the segment containing it. Then the minimal chain  in  is of type~ or~, as it is contained in . If  is of type~ or~, , ,  and all other attachment points of  must be contained in . The same holds for the remaining case of  being of type~, as the type~-chain in the caterpillar containing  cannot start in a proper ancestor of  by assumption. Let the \emph{dependent path} of  be the maximal path in  connecting two attachment points of , e.\,g., for  being of type~ or~, the dependent path is just . We can compute all attachment points of  and therefore the dependent path of  efficiently, as the previous computation provides  and the set of chains ; we just have to add  and  to the start vertices of the latter chains.

If  is a chain of type~ (thus, ) and  is real, we can add . Otherwise, restriction~\ref{R2} implies that every segment  that has a dependent path  without inner real vertices does neither contain chains nor caterpillars forming \BG-paths while preserving~\ref{R1} and~\ref{R2}. Conversely, if  contains an inner real vertex, all chains in  can be added: If  is of type~,  does not violate~\ref{R2} and can be added and if  is of type~, the caterpillar containing  is good and can be added with Lemma~\ref{AddCaterpillar}. As the minimal chain in  is not contained in , the remaining chains in , if exist, can be added as well using Theorem~\ref{correctness}.

\begin{wrapfigure}[16]{R}{7cm}
	\vspace{-0.5cm}
	\centering
	\subfigure[The chain  and the chains in .]{
		\includegraphics[scale=0.4]{./figures/Mapping1}
		\label{fig:Mapping1}
	}
\hspace{0.1cm}
	\subfigure[The intervals in  are constructed from the real vertices in .]{
		\includegraphics[scale=0.42]{./figures/Mapping3}
		\label{fig:Mapping2}
	}
	\caption{Mapping segments in . Different shades depict different segments.}
	\label{fig:Mapping}
\end{wrapfigure}

Finding a valid order on the remaining chains in  thus reduces to finding an order on their segments such that the dependent paths of the segments contain inner real vertices. Having this sequence would allow to add subsequently ) for every segment  in this order. We map each  to a set  of intervals in the range of the dependent path  of : Let  be the attachment points of  and let  (see Figure~\ref{fig:Mapping}). Additionally, we map the real vertices  of  to the set of intervals . This construction is efficient and creates at most  intervals for , which amortizes to a total of  for all chains.

Let two intervals  and  \emph{overlap} if  or . Starting with , we find the next segment with an inner real vertex on its dependent path by finding a next overlapping interval  and adding the whole segment that contains . This reduction finds the desired order: Clearly, an overlap induces an inner real vertex in the next interval and therefore in the dependent path of the next segment. Conversely, for every segment  with an inner real vertex on its dependent path , an interval can be found that overlaps with , either in  if  was real at the beginning or in  for a previously added segment  (note that segments having only the attachment points  and  cannot occur, as they contain no chain in ).

A sequence of overlaps from  to every other created interval exists if and only if the \emph{overlap graph} (i.\,e., the graph with intervals as vertices and edges between overlapping intervals) is connected. Simple sweep-line algorithms for constructing the connected components of the overlap graph are known~\cite{Olariu1996} (Lemmas~4.1 and 4.2 suffice), run in time  for  intervals and, thus, ensures the efficient computation of the reduction.

\begin{theorem}
The construction sequences \emph{\ref{characterizations}}.\eqref{BGConstruction}, \emph{\ref{characterizations}}.\eqref{BGPathConstruction}, \emph{\ref{characterizations}}.\eqref{removals} and \emph{\ref{characterizations}}.\eqref{contractions} of a -connected graph can be computed in time .
\end{theorem}



\begin{figure}
	\centering
	\subfigure[A -connected input graph  with  and . Straight lines depict the edges of the DFS-tree .]{
		\includegraphics[scale=0.62]{./figures/Example0}
		\label{fig:Example0}
	}
	\hfill
\subfigure[The decomposition of  into  chains. Light solid chains are of type~, dashed ones of type~ and black solid ones of type~. The only chain of type~ is . The only chains of type~ are  and , which create the caterpillars  and , respectively.]{
		\includegraphics[scale=0.62]{./figures/Example1}
		\label{fig:Example1}
	}
	\hfill
	\subfigure[The subdivision  (thick edges). We start with processing . Since , we can add all chains in . The first two have parents that are already contained in . We thus add one of them as \BG-path, say .]{
		\includegraphics[scale=0.62]{./figures/Example2}
		\label{fig:Example2}
	}
	\hfill
	\subfigure[The -subdivision . Its real vertices are depicted in black. Note that choosing  instead of  would have led also to a -subdivision. After adding the remaining chain  as \BG-path, the parent of  is contained in  and can therefore be added as well.]{
		\includegraphics[scale=0.62]{./figures/Example2_5}
		\label{fig:Example2_5}
	}
	\subfigure[The subdivision . We process  next, but have to continue to process , as there is nothing to add. According to Theorem~\ref{correctness}, , , , , ,  and the caterpillar  can be added. We first add , as its segment does not contain a chain in . To obtain the right order of the remaining chains, we group them by segments.]{
		\includegraphics[scale=0.62]{./figures/Example3}
		\label{fig:Example3}
	}
	\hfill
	\subfigure[We map the segments to intervals.  is induced by the real vertices ,  and . As  and  are in the same segment, they are mapped to the same group of intervals. By overlapping intervals, we get the sequence of segments , , , ,  and . Note that overlapped intervals imply adding the whole segment.]{
		\includegraphics[scale=0.55]{./figures/Example3_5}
		\label{fig:Example3_5}
	}
\hfill
	\subfigure[The subdivision . The next non-trivial chain to process is . The interval {} contains the inner real vertex  and overlaps with {}. This implies that  can be added, forming the two \BG-paths  and .]{
		\includegraphics[scale=0.62]{./figures/Example5}
		\label{fig:Example4}
	}
	\hfill
	\subfigure[The subdivision . It remains to process the chain , where  is added as the last \BG-path of the construction sequence. This results in the subdivision , which is identical to .]{
		\includegraphics[scale=0.62]{./figures/Example6}
		\label{fig:Example6}
	}
\captcont{A running example of the algorithm.}
	\label{fig:Example}
\end{figure}




\paragraph{A New Certifying 3-Connectivity Test.}\label{test}
It remains to deal with the case when the input graph  is not -connected. For simplicity, we assume  to be -connected, although the chain decomposition can check this fact. If  is not -connected, the described algorithm fails to add a \BG-path due to Theorem~\ref{characterizations} when processing some chain, say . Therefore, after the processing phase for ,  must still contain a chain . Let  be the segment containing  and let  be the set of segments that map to the connected component of the interval overlap graph containing . Then the union of dependent paths of the segments in  is a path  and the two extremal attachment points on  of segments in  build a separation pair. This pair certifies that  is not -connected and can be computed in linear time.