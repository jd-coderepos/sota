We extend the chain decomposition to assign one of the types $1$, $2a$, $2b$, $3a$ and $3b$ to each chain in $C \setminus \{C_0\}$. The motivation for this classification is that chains of certain types are, under some conditions, \BG-paths and therefore allow to compute the next step of the construction sequence. The types are defined by Algorithm~\ref{alg:classify}: E.\,g., a chain $C_i$ with parent $C_k$ is of type~$1$ if $t(C_i) \rightarrow_T s(C_i) \subseteq C_k$ and of type~$2$ if it is not of type~$1$ and $s(C_i)=t(C_k)$ holds (see Figures~\ref{fig:Classification} and~\ref{fig:Example1}). All chains are unmarked at the beginning of Algorithm~\ref{alg:classify}. It is not difficult to show that the decomposition and classification can be carried out in linear time. We omit a proof.

\begin{wrapfigure}[12]{R}{3cm}
	\vspace{-0.99cm}
	\centering
	\includegraphics[scale=0.7]{./figures/Classification}
	\caption{$C_1$ and $C_2$ are of type~$1$, $C_3$ is of type~$2b$, $C_4$ of type~$2a$, $C_5$ of type~$3b$ and $C_6$ of type~$3a$.}
	\label{fig:Classification}
\end{wrapfigure}

\begin{algorithm}
\caption{classify$(C_i \in C \setminus \{C_0\}, \textrm{DFS-tree } T)$}\label{alg:classify}\begin{algorithmic}[1]
	\State $C_k := \emph{parent}(C_i)$\Comment{the parent of $C_i$ in $U$: $C_k < C_i$}
	\If{$t(C_i) \rightarrow_T s(C_i)$ is contained in $C_k$}\Comment{type~$1$~}\label{typeone}
		\State assign type~$1$ to $C_i$
	\ElsIf{$s(C_i)=s(C_k)$}\Comment{type~$2$: $C_k \neq C_0$, $t(C_i)$ is inner vertex of $C_k$}
		\If{$C_i$ is a backedge}
			\State assign type~$2a$ to $C_i$\Comment{type~$2a$}
		\Else
			\State assign type~$2b$ to $C_i$; mark $C_i$\Comment{type~$2b$}
		\EndIf
	\Else \Comment{type~$3$: $s(C_i) \neq s(C_k)$, $C_k \neq C_0$, $t(C_i)$ is inner vertex of $C_k$}\If{$C_k$ is not marked}
			\State assign type~$3a$ to $C_i$\Comment{type~$3a$}
		\Else \Comment{$C_k$ is marked}
			\State assign type~$3b$ to $C_i$; create a list $L_i = \{C_i\}$; $C_j := C_k$\Comment{type~$3b$}\label{assign}
			\While{$C_j$ is marked}\Comment{$L_i$ is called a \emph{caterpillar}}
				\State unmark $C_j$; append $C_j$ to $L_i$; $C_j := \emph{parent}(C_j)$\label{unmarking}
			\EndWhile
		\EndIf
	\EndIf
\end{algorithmic}
\end{algorithm}


\begin{lemma}\label{ChainDecomposition}
Computing a chain decomposition of a $3$-connected graph and classifying each chain with Algorithm~\ref{alg:classify} takes running time $O(n+m)$.
\end{lemma}


\begin{definition}\label{upwardsclosed}
Let a subdivision $S_l \subseteq G$ be \emph{upwards-closed} if for each vertex in $S_l$ the edge to its parent is in $E(S_l)$. Let $S_l$ be \emph{modular} if $S_l$ is the union of chains.
\end{definition}

In order to find \BG-paths efficiently, we want to restrict every subdivision $S_l$ to be upwards-closed and modular. However, configurations exist where no \BG-path for a subdivision $S_l$ is a chain, e.\,g., the subdivision $S_3 = \{C_0,C_1,C_2\}$ in Figure~\ref{fig:Classification}. This violates the modularity of $S_{l+1}$ and we have to weaken the restriction: We will allow intermediate subdivisions that are neither upwards-closed nor modular but demand in these cases that we can find a set of $t$ \BG-paths in advance that restores these properties after $t$ steps.







We impose the additional restriction that each link of $S_l$ that consists only of tree edges has no parallel link, except $C_0$ in $S_3$. This prevents \BG-path candidates from violating property~\ref{bgpathdefinition}.\ref{bgpathdefinition3} due to the DFS-structure. We summarize the restrictions.


\begin{enumerate}[label=($R_\arabic*$), leftmargin=*]
	\item For each upwards-closed and modular subdivision $S_l$, \BG-paths are only added as\label{R1} single chains of type~$1$, $2a$ or $3a$, with $S_{l+1}$ being upwards-closed and modular or as sets of $t > 1$ subsequent \BG-paths constructing an upwards-closed modular subdivision $S_{l+t}$ that differs from $S_l$ in exactly $t$ chains of types $2b$ and $3b$.
\item For each upwards-closed and modular subdivision $S_l$, the links of $S_l$ that consist only of tree edges of $T$ have no parallel links, except $C_0$ in $S_3$.\label{R2}
\end{enumerate}



We refer to the current upwards-closed and modular subdivision in a construction sequence that is restricted by~\ref{R1} and~\ref{R2} as $S^R_l$. The existence of a restricted sequence is shown in Section~\ref{caterpillars}.
We show that chains of type~$3a$ help to find \BG-paths efficiently (proof omitted).

\begin{lemma}\label{structural3a}
Let $C_i$ be a chain of type~$3a$ and $C_k$ the parent of $C_i$ such that $C_k$ but not $C_i$ is contained in $S^R_l$. Then $C_i$ is a \BG-path for $S^R_l$ preserving~\ref{R1} and~\ref{R2}.
\end{lemma}



\begin{wrapfigure}[14]{R}{5.7cm}
	\vspace{-0.5cm}
	\centering
	\subfigure[A \emph{bad} caterpillar $L_j$ with parent $C_k$.]{
		\includegraphics[scale=0.5]{./figures/CaterpillarBad}
		\label{fig:CaterpillarBad}
	}
\hspace{0.01cm}
	\subfigure[A \emph{good} caterpillar $L_j$ with parent $C_k$.]{
		\includegraphics[scale=0.5]{./figures/CaterpillarGood}
		\label{fig:CaterpillarGood}
	}
	\caption{Kinds of caterpillars.}
	\label{fig:Caterpillar}
\end{wrapfigure}

\subsection{Caterpillars and Existence of the Restricted Sequence}\label{caterpillars}
While chains of type~$3a$ form \BG-operations under the conditions of Lemma~\ref{structural3a}, chains of types $1$ and $2$ in general do not. For every chain $C_i$ of type~$3b$, Algorithm~\ref{alg:classify} collects a list $L_i$ of chains that contains only $C_i$ and chains of type~$2b$ (see line~\ref{unmarking}). We call each list $L_i$ a \emph{caterpillar}.





\begin{definition}
Let the \emph{parent of a caterpillar} $L_j$ be the parent of the chain in $L_j$ that is minimal with respect to $<$.
Let a caterpillar $L_j$ with parent $C_k$ be \emph{bad} for a subdivision $S_l$ if $s(C_j)$ is a descendant of $t(C_k)$ and $s(C_k) \rightarrow_{C_k} s(C_j)$ contains no inner real vertex (see Figure~\ref{fig:CaterpillarBad}). Otherwise, $L_j$ is called a \emph{good} caterpillar (see Figure~\ref{fig:CaterpillarGood}).
\end{definition}

Caterpillars bundle the single chains of type~$2b$, which cannot immediately be added as \BG-paths. They also offer a simple decomposition into successive \BG-paths.

\begin{lemma}\label{AddCaterpillar}
Let $L_j$ be a caterpillar that consists of $t$ chains and has parent $C_k$. Let $C_k$ but no chain in $L_j$ be contained in $S^R_l$. If $L_j$ is good, $L_j$ can be efficiently decomposed into $t$ successive \BG-paths satisfying~\ref{R1} and~\ref{R2}.
\end{lemma}
\begin{proof} (sketch) Let $y$ be the last vertex of the minimal chain in $L_j$ and let $C_h$ be the parent of $C_j$. We add either the path $P := C_j \cup (t(C_j) \rightarrow_T y)$, followed by $C_i \setminus P$ for all chains $C_i \in L_j \setminus \{C_j\}$ (see Figure~\ref{fig:CaterpillarGood}) or the path $(C_j \cup C_h) \setminus ((t(C_j) \rightarrow_T y) \setminus \{t(C_j)\})$, followed by $t(C_j) \rightarrow_T y$ and $C_i \setminus (t(C_j) \rightarrow_T y)$ for every remaining chain $C_i \in L_j \setminus \{C_j,C_h\}$.
\end{proof}






\begin{definition}\label{segment}
We define the equivalence relation $\sim$ on $E(G) \setminus E(S_l)$ with $e \sim e$ for all $e \in E(G) \setminus E(S_l)$ and with $e \sim f$ for all $e, f \in E(G) \setminus E(S_l)$ if there is a path $e \rightarrow_G f$ without an inner vertex in $S_l$.
Let the \emph{segments} of $S_l$ be the subgraphs of $G$ that are induced by the equivalence classes of $\sim$. Let $H \cap S_l$ be the \emph{attachment points} of $H$.
\end{definition}



\begin{definition}
For a chain $C_i$ and a subdivision $S^R_l$, let $\Children(C_i)$ be the set of children of $C_i$ of types~$1$ and~$2$ that are not contained in $S^R_l$ and let $\Type(C_i)$ be the set of chains of type~$3$ that start at a vertex in $C_i$ and are not contained in $S^R_l$.
\end{definition}

The following theorem is a key result of this paper and leads not only to an existence proof of the restricted construction sequence but also to an efficient algorithm for computing it.

\begin{theorem}\label{correctness}
For a subdivision $S^R_l$, let $C_i$ be a chain such that $\Children(C_j) = \Type(C_j) = \emptyset$ holds for every proper ancestor $C_j$ of $C_i$. Then all chains in $\Children(C_i) \cup \Type(C_i)$ and their proper ancestors that are not already contained in $S^R_l$ can be successively added as \BG-paths (possibly being part of caterpillars) such that~\ref{R1} and~\ref{R2} is preserved. Moreover, the chains in $\Type(C_i)$ that are contained in segments in which the minimal chain is not contained in $\Children(C_i)$ can be added at any point in time in arbitrary order (together with their proper ancestors that are not contained in $S^R_l$).
\end{theorem}


The precondition of Theorem~\ref{correctness} is met in every subdivision: For $S^R_3$, $C_0$ is the desired chain and applying the Theorem on $C_0$ allows to take the descendants of $C_0$ in $U$ in subsequent subdivisions. This ensures the existence of the restricted construction sequence.

\begin{corollary}\label{correctnessCorollary}
Let $G$ be a $3$-connected graph with a chain decomposition $C = \{C_0,\ldots,C_{m-n+1}\}$. Then there is a construction sequence of $G$ restricted by~\ref{R1} and~\ref{R2} that starts with $S^R_3 = \{C_0 \cup C_1 \cup C_2\}$.
\end{corollary}




\section{A Linear-Time Algorithm}\label{algorithm}
With Lemma~\ref{ChainDecomposition}, a chain decomposition, a subdivision $S^R_3$ and the classification of chains can be computed in time $O(n+m)$. Theorem~\ref{correctness} provides an algorithmic method to find iteratively \BG-paths building the restricted construction sequence: Iteratively for each chain $C_i$, $0 \leq i \leq m-n$, we add all chains in $\Children(C_i) \cup \Type(C_i)$ (we say that $C_i$ is \emph{processed}). Note that $C_i$ meets the precondition of Theorem~\ref{correctness} and that $\Children(C_i)$ and $\Type(C_i)$ can be build in time $O(|C_i|+|\Children(C_i)|+|\Type(C_i)|)$ by storing lists of type~$3$ chains at every vertex. We partition the chains in $\Type(C_i)$ into the different segments of $S^R_l$ containing them by storing a pointer on each $C_j \in \Type(C_i)$ to the minimal chain $D$ of the segment containing $C_j$. The chain $D$ is computed by traversing $T$ from $t(C_j)$ to the root until the next vertex is contained in $S^R_l$. The current vertex is then an inner vertex of $D$ (each inner vertex has a pointer to its chain) and we mark each vertex of the traversed path with $D$. Further traversals get $D$ by stopping at the first marker that points to a chain not in $S^R_l$. Since all traversed chains will be added, the running time amortizes to a total of $O(n+m)$.

First, we add all chains in $\Type(C_i)$ that are contained in segments in which the minimal chain is not contained in $\Children(C_i)$ (this can be checked in constant time per chain). According to Theorem~\ref{correctness}, the chains can be added in arbitrary order, as long as their proper ancestors that are not in $S^R_l$ are added before. We want to add the remaining chains in $\Children(C_i) \cup \Type(C_i)$. However, Theorem~\ref{correctness} does not specify in which order the chains have to be added, so we need to compute a valid order on them.

Let $C_j$ be a remaining chain in $\Type(C_i)$ and let $H$ be the segment containing it. Then the minimal chain $D$ in $H$ is of type~$1$ or~$2$, as it is contained in $\Children(C_i)$. If $D$ is of type~$1$ or~$2a$, $s(D)$, $t(D)$, $s(C_j)$ and all other attachment points of $H$ must be contained in $C_i$. The same holds for the remaining case of $D$ being of type~$2b$, as the type~$3b$-chain in the caterpillar containing $D$ cannot start in a proper ancestor of $C_i$ by assumption. Let the \emph{dependent path} of $H$ be the maximal path in $C_i$ connecting two attachment points of $H$, e.\,g., for $D$ being of type~$1$ or~$2a$, the dependent path is just $s(D) \rightarrow_{C_i} t(D)$. We can compute all attachment points of $H$ and therefore the dependent path of $H$ efficiently, as the previous computation provides $D$ and the set of chains $H \cap \Type(C_i)$; we just have to add $s(D)$ and $t(D)$ to the start vertices of the latter chains.

If $D$ is a chain of type~$2a$ (thus, $H=D$) and $t(D)$ is real, we can add $D$. Otherwise, restriction~\ref{R2} implies that every segment $H$ that has a dependent path $P$ without inner real vertices does neither contain chains nor caterpillars forming \BG-paths while preserving~\ref{R1} and~\ref{R2}. Conversely, if $P$ contains an inner real vertex, all chains in $H \cap (\Children(C_i) \cup \Type(C_i))$ can be added: If $D$ is of type~$1$, $D$ does not violate~\ref{R2} and can be added and if $D$ is of type~$2b$, the caterpillar containing $D$ is good and can be added with Lemma~\ref{AddCaterpillar}. As the minimal chain in $H \setminus \{D\}$ is not contained in $\Children(C_i)$, the remaining chains in $H \cap \Type(C_i)$, if exist, can be added as well using Theorem~\ref{correctness}.

\begin{wrapfigure}[16]{R}{7cm}
	\vspace{-0.5cm}
	\centering
	\subfigure[The chain $C_i$ and the chains in $\Type(C_i) \cup \Children(C_i)$.]{
		\includegraphics[scale=0.4]{./figures/Mapping1}
		\label{fig:Mapping1}
	}
\hspace{0.1cm}
	\subfigure[The intervals in $I_0$ are constructed from the real vertices in $C_i$.]{
		\includegraphics[scale=0.42]{./figures/Mapping3}
		\label{fig:Mapping2}
	}
	\caption{Mapping segments in $C_i$. Different shades depict different segments.}
	\label{fig:Mapping}
\end{wrapfigure}

Finding a valid order on the remaining chains in $\Children(C_i) \cup \Type(C_i)$ thus reduces to finding an order on their segments such that the dependent paths of the segments contain inner real vertices. Having this sequence would allow to add subsequently $H \cap (\Children(C_i) \cup \Type(C_i)$) for every segment $H$ in this order. We map each $H$ to a set $I(H)$ of intervals in the range of the dependent path $P$ of $H$: Let $a_1,\ldots,a_k$ be the attachment points of $H$ and let $I(H) := \bigcup_{1 < j \leq k} \{[a_1,a_j]\} \cup \bigcup_{1 < j < k} \{[a_j,a_k]\}$ (see Figure~\ref{fig:Mapping}). Additionally, we map the real vertices $b_1,\ldots,b_k$ of $C_i$ to the set of intervals $I(C_i) := \bigcup_{1 < j < k} \{[b_1,b_j]\} \cup \bigcup_{1 < j < k} \{[b_j,b_k]\}$. This construction is efficient and creates at most $2*(|\Children(C_i)|+|\Type(C_i)|+|V_{real}(C_i)|)$ intervals for $C_i$, which amortizes to a total of $O(n+m)$ for all chains.

Let two intervals $[a,b]$ and $[c,d]$ \emph{overlap} if $a < c < b < d$ or $c < a < d < b$. Starting with $I(C_i)$, we find the next segment with an inner real vertex on its dependent path by finding a next overlapping interval $C_j$ and adding the whole segment that contains $C_j$. This reduction finds the desired order: Clearly, an overlap induces an inner real vertex in the next interval and therefore in the dependent path of the next segment. Conversely, for every segment $H$ with an inner real vertex on its dependent path $P$, an interval can be found that overlaps with $P$, either in $I(C_i)$ if $v$ was real at the beginning or in $I(H')$ for a previously added segment $H'$ (note that segments having only the attachment points $s(C_i)$ and $t(C_i)$ cannot occur, as they contain no chain in $\Children(C_i)$).

A sequence of overlaps from $I(C_i)$ to every other created interval exists if and only if the \emph{overlap graph} (i.\,e., the graph with intervals as vertices and edges between overlapping intervals) is connected. Simple sweep-line algorithms for constructing the connected components of the overlap graph are known~\cite{Olariu1996} (Lemmas~4.1 and 4.2 suffice), run in time $O(t)$ for $t$ intervals and, thus, ensures the efficient computation of the reduction.

\begin{theorem}
The construction sequences \emph{\ref{characterizations}}.\eqref{BGConstruction}, \emph{\ref{characterizations}}.\eqref{BGPathConstruction}, \emph{\ref{characterizations}}.\eqref{removals} and \emph{\ref{characterizations}}.\eqref{contractions} of a $3$-connected graph can be computed in time $O(n+m)$.
\end{theorem}



\begin{figure}
	\centering
	\subfigure[A $3$-connected input graph $G$ with $n=18$ and $m=34$. Straight lines depict the edges of the DFS-tree $T$.]{
		\includegraphics[scale=0.62]{./figures/Example0}
		\label{fig:Example0}
	}
	\hfill
\subfigure[The decomposition of $G$ into $m-n+2=18$ chains. Light solid chains are of type~$1$, dashed ones of type~$2$ and black solid ones of type~$3$. The only chain of type~$2a$ is $C_3$. The only chains of type~$3b$ are $C_{14}$ and $C_{16}$, which create the caterpillars $L_{14}=\{C_{14},C_6,C_5\}$ and $L_{16}=\{C_{16},C_4\}$, respectively.]{
		\includegraphics[scale=0.62]{./figures/Example1}
		\label{fig:Example1}
	}
	\hfill
	\subfigure[The subdivision $S^R_3 = \{C_0,C_1,C_2\}$ (thick edges). We start with processing $C_0$. Since $\Children(C_0) = \emptyset$, we can add all chains in $\Type(C_0)=\{C_7,C_8,C_9\}$. The first two have parents that are already contained in $S^R_3$. We thus add one of them as \BG-path, say $C_7$.]{
		\includegraphics[scale=0.62]{./figures/Example2}
		\label{fig:Example2}
	}
	\hfill
	\subfigure[The $K_4$-subdivision $S^R_4$. Its real vertices are depicted in black. Note that choosing $C_8$ instead of $C_7$ would have led also to a $K_4$-subdivision. After adding the remaining chain $C_8$ as \BG-path, the parent of $C_9$ is contained in $S^R_5$ and can therefore be added as well.]{
		\includegraphics[scale=0.62]{./figures/Example2_5}
		\label{fig:Example2_5}
	}
	\subfigure[The subdivision $S^R_6$. We process $C_1$ next, but have to continue to process $C_2$, as there is nothing to add. According to Theorem~\ref{correctness}, $C_3$, $C_{10}$, $C_{11}$, $C_{12}$, $C_{13}$, $C_{15}$ and the caterpillar $L_{14}$ can be added. We first add $C_{11}$, as its segment does not contain a chain in $\Children(C_2)$. To obtain the right order of the remaining chains, we group them by segments.]{
		\includegraphics[scale=0.62]{./figures/Example3}
		\label{fig:Example3}
	}
	\hfill
	\subfigure[We map the segments to intervals. $I(C_2)$ is induced by the real vertices $v_3$, $v_5$ and $v_1$. As $L_{14}$ and $C_{15}$ are in the same segment, they are mapped to the same group of intervals. By overlapping intervals, we get the sequence of segments $I(C_2)$, $I(C_{10})$, $I(C_{12})$, $I(C_{13})$, $I(C_3)$ and $I(L_{14} \cup C_{15})$. Note that overlapped intervals imply adding the whole segment.]{
		\includegraphics[scale=0.55]{./figures/Example3_5}
		\label{fig:Example3_5}
	}
\hfill
	\subfigure[The subdivision $S^R_{14}$. The next non-trivial chain to process is $C_5$. The interval {$[v_{11},v_1] \subset I(L_{16})$} contains the inner real vertex $v_{12}$ and overlaps with {$[v_{10},v_{12}] \subset I(C_5)$}. This implies that $L_{16}$ can be added, forming the two \BG-paths $v_{11} \rightarrow_{G \setminus E(S_{15})} v_1$ and $v_{12} \rightarrow_T v_{17}$.]{
		\includegraphics[scale=0.62]{./figures/Example5}
		\label{fig:Example4}
	}
	\hfill
	\subfigure[The subdivision $S^R_{17}$. It remains to process the chain $C_6$, where $C_{17}$ is added as the last \BG-path of the construction sequence. This results in the subdivision $S^R_{18}$, which is identical to $G$.]{
		\includegraphics[scale=0.62]{./figures/Example6}
		\label{fig:Example6}
	}
\captcont{A running example of the algorithm.}
	\label{fig:Example}
\end{figure}




\paragraph{A New Certifying 3-Connectivity Test.}\label{test}
It remains to deal with the case when the input graph $G$ is not $3$-connected. For simplicity, we assume $G$ to be $2$-connected, although the chain decomposition can check this fact. If $G$ is not $3$-connected, the described algorithm fails to add a \BG-path due to Theorem~\ref{characterizations} when processing some chain, say $C_i$. Therefore, after the processing phase for $C_i$, $\Children(C_i)$ must still contain a chain $C_j$. Let $H$ be the segment containing $C_j$ and let $H' \supseteq H$ be the set of segments that map to the connected component of the interval overlap graph containing $I(H)$. Then the union of dependent paths of the segments in $H'$ is a path $P \subseteq C_i$ and the two extremal attachment points on $P$ of segments in $H'$ build a separation pair. This pair certifies that $G$ is not $3$-connected and can be computed in linear time.