\documentclass[a4paper,11pt]{llncs}
\usepackage{ifthen}
\newboolean{pgf}
\setboolean{pgf}{true}
\usepackage[colorlinks=true, citecolor= blue, linkcolor= blue, urlcolor= blue, bookmarks=false]{hyperref}
\usepackage[all]{hypcap}


\usepackage{graphicx,color}      \usepackage{verbatim}
\usepackage[ruled,linesnumbered]{algorithm2e}
\usepackage{amsmath, amsfonts, amssymb}
\usepackage[a4paper,margin=3.72cm,centering]{geometry}
\usepackage{subfig}
\usepackage{ifthen}
\usepackage{url}
\setlength{\algomargin}{1em}
\setlength{\AlCapSkip}{1ex}




\spnewtheorem{fact}{Fact}{\bf}{\it}

\newboolean{includeXXX}
\newboolean{includecut}

\setboolean{includeXXX}{false}
\setboolean{includecut}{false}

\ifthenelse{\boolean{includecut}}{
\newcommand{\cut}[1]{\textcolor{blue}{#1}}
\newcommand{\edit}[2]{\textcolor{blue}{#1}}

\newcommand{\Rcut}[1]{}  \newcommand{\Redit}[2]{#2} 


}
{
\newcommand{\cut}[1]{}
\newcommand{\edit}[2]{#2}

\newcommand{\Rcut}[1]{#1} \newcommand{\Redit}[2]{#1} 

}

\ifthenelse{\boolean{includeXXX}}{
\newcommand{\XXX}[1]{\textcolor{red}{XXX #1 XXX\ }}
\newcommand{\xxx}{\textcolor{red}{XXX\ }}
\newcommand{\alm}[1]{\textcolor{red}{#1}}
}
{
\newcommand{\XXX}[1]{}
\newcommand{\xxx}{}
\newcommand{\alm}[1]{#1}
}

\newcommand{\gap}[1]{} \newcommand{\otl}{\textcolor{blue}}

\def \Zed {\mathbb{Z}}
\def \ep  {\varepsilon}
\def \tep  {\tilde{\varepsilon}}







\usepackage{tikz}
\usetikzlibrary{scopes}
\usetikzlibrary{arrows,shapes,calc,shapes,patterns,backgrounds}
\newcommand{\pgfgraphic}[1]{\input{#1}}






\newcommand{\cost}{\text{cost}}
\newcommand{\Cost}{\text{Cost}}
\pagestyle{plain}
\def\OPT{{\mathop{\rm OPT}}}

\usepackage{xstring}
		\newcounter{l}


\newboolean{colour}
\setboolean{colour}{true}



\ifthenelse{\boolean{pgf}}{
\ifthenelse{\boolean{colour}}{
\tikzstyle{c2}=[color=blue!70]
\tikzstyle{c1}=[color=red!70]
\tikzstyle{c3}=[color=orange!70]
\tikzstyle{c6}=[color=pink!70]
\tikzstyle{c5}=[color=cyan!70]
\tikzstyle{c4}=[color=green!70]

}{
\tikzstyle{c1}=[color=black!20]
\tikzstyle{c2}=[color=black!50]
\tikzstyle{c3}=[color=black!75]
\tikzstyle{c4}=[color=gray!70]
\tikzstyle{c5}=[color=black]
\tikzstyle{c6}=[pattern=north west lines]

}

\tikzstyle{c7}=[color=gray!70]
\tikzstyle{c8}=[color=white]
\tikzstyle{ct8}=[color=white]

\newcommand{\drawbox}[2]{\draw[very thick,color=black] (0,0) rectangle (#1,-#2);}
\newcommand{\drawWbox}[2]{\draw[color=white] (0,0) rectangle (#1,-#2);}
\newcommand{\drawrow}[2]{


		\StrLen{#2}[\l] 


		\scope[shift={(0,-#1)}]


		\foreach \x in {1,2,...,\l} {
				\StrChar{#2}{\x}[\ch]

				
				\if \ch0

				\else
					\draw[fill,c\ch] (\x-1,0) rectangle +(1,1);
					\draw[color=black!80] (\x-1,0) rectangle +(1,1);
\fi

				

				
			}



\endscope
}

\newcommand{\drawrowL}[2]{


		\StrLen{#2}[\l] 


		\scope[shift={(0,-#1)}]


		\foreach \x in {1,2,...,\l} {
				\StrChar{#2}{\x}[\ch]

				
				\if \ch0

				\else
					\draw (\x-0.5,0.37) node[anchor=mid,color=white] {{\bf \ch}};
				\fi

				

				
			}



\endscope
}

\newcommand{\drawrownum}[2]{


		\StrLen{#2}[\l] 


		\scope[shift={(0,-#1)}]


		\foreach \x in {1,2,...,\l} {
				\StrChar{#2}{\x}[\ch]

				\draw (\x-0.5,0.5) node[anchor=mid] {};
			}



\endscope
}
}{}

\newcommand{\num}{\ensuremath{\text{num}}}
\newcommand{\ceil}{\ensuremath{\text{ceil}}}
\newcommand{\floor}{\ensuremath{\text{floor}}}




\renewcommand{\geq}{\geqslant}
\renewcommand{\leq}{\leqslant}



\newcommand{\Ptime}{\ensuremath{\mathbf{P}}}
\newcommand{\NPtime}{\ensuremath{\mathbf{NP}}}
\newcommand{\PSPACE}{\ensuremath{\mathbf{PSPACE}}}

\newcommand{\Coloroid}[1]{-\textsc{Flood-It}}
\newcommand{\ColoroidFree}[1]{-\textsc{Free-Flood-It}}
\newcommand{\ColoroidF}{\textsc{Free-Flood-It}}
\newcommand{\Floodit}{\textsc{Flood-It}}
\newcommand{\Mnc}{\ensuremath{\max\{m(B)\,|\,B \in B_{n,c}\}}}
\newcommand{\SCS}{\textsc{SCS}}

\newcommand{\recdim}[2]{}


\title{The Complexity of Flood Filling Games}
\author{Rapha\"{e}l~Clifford \and  Markus~Jalsenius \and Ashley~Montanaro \and Benjamin~Sach}
\institute{Department of Computer Science, University of Bristol, UK}

\begin{document}


\maketitle

\begin{abstract}
We study the complexity of the popular one player combinatorial game known as Flood-It. In this game the player is given an \recdim{n}{n} board of tiles where each tile is allocated one of  colours. The goal is to make the colours of all tiles equal via the shortest possible sequence of flooding operations. In the standard version, a flooding operation consists of the player choosing a colour~, which then changes the colour of all the tiles in the monochromatic region connected to the top left tile to . After this operation has been performed, neighbouring regions which are already of the chosen colour  will then also become connected, thereby extending the monochromatic region of the board. We show that finding the minimum number of flooding operations is \NPtime-hard for  and that this even holds when the player can perform flooding operations from any position on the board. However, we show that this `free' variant is in \Ptime\ for . We also prove that for an unbounded number of colours, Flood-It remains \NPtime-hard for boards of height at least 3, but is in \Ptime\ for boards of height 2. Next we show how a  approximation and a randomised  approximation algorithm can be derived, and that no polynomial time constant factor, independent of , approximation algorithm exists unless \Ptime=\NPtime.  We then investigate how many moves are required for the `most demanding' \recdim{n}{n} boards (those requiring the most moves) and show that the number grows as fast as .    Finally, we consider boards where the colours of the tiles are chosen at random and show that for , the number of moves required to flood the whole board is  with high probability.
\end{abstract}


\section{Introduction} \label{sec:intro}
In the popular one player combinatorial game known as Flood-It, each tile of an \recdim{n}{n} board is allocated one of  colours, where  is a parameter of the game.  Two left/right/up/down adjacent tiles are said to be connected if they have the same colour and a (connected) region of the board is defined to be any maximal connected component.   The standard version of the game starts with the player `flooding' the region that contains the top left tile. The flooding operation simply involves changing the colour of all the tiles in the region to be some new colour. However, this also has the effect of connecting the newly flooded region to all neighbouring regions of this colour.    The overall aim is to flood the entire board, that is connect all regions, in as few flooding operations as possible. Every flooding operation changes the colour of the region that contains the top left tile.  Figure~\ref{fig:turns} gives an example of the first few moves of a game. The border shows the outline of the region which has so far been flooded.
\begin{figure}[t]
    \centering
	\pgfgraphic{graphic-turns} \caption{A sequence of four moves on a \recdim{6}{6} Flood-It board with 3 colours. }
    \label{fig:turns}
\end{figure}

In this paper, we investigate a number of questions inspired by Flood-It. We first show that not only are natural greedy approaches to the game bad, but in fact finding an optimal solution (one which requires the fewest possible moves) for Flood-It is \NPtime-hard for , and that this also holds for a variant of the game we call Free-Flood-It where the player can perform flooding operations at any position on the board. On the other hand, we show that solving Free-Flood-It with  is in \Ptime.  We also consider the effect of changing the shape of the board, and prove that Flood-It remains \NPtime-hard for rectangular boards of height at least 3, with an unbounded number of colours, but is in \Ptime\ for boards of height 2. As a stepping stone, we also prove \NPtime-hardness of a restricted version of the well-studied shortest common supersequence problem (q.v.).

 Next we show how a  approximation and a randomised  approximation algorithm for Flood-It can be derived. However, no polynomial time constant factor, independent of , approximation algorithm exists unless \Ptime=\NPtime.  We then consider how many moves are required for the most demanding boards and show that the number grows as fast as . We say that a board is one of the most demanding boards if it requires at least as many moves as any other board which has the same size and number of colours. Finally, we investigate boards where the colours of the tiles are chosen at random and give a simple proof that for , the number of moves required to flood the whole board is  with high probability. We then observe that the same result can in fact be proven for  by appealing to previous deep results in percolation theory~\cite{CW1993:random,FN1993:random}; indeed, our work can be seen as a drastic simplification of these results for the case .





\vskip 3pt
\noindent {\em History and related work:} Perhaps the most famous recent hardness result involving a popular game is the \NPtime-completeness of Tetris~\cite{DHL2003:Tetris}. Flood-It seems to be a somewhat newer game than Tetris, first making its appearance online in early 2006 courtesy of a company called Lab Pixies.  Since then numerous versions have become available for almost every conceivable platform. We have very recently become aware of a sketch proof by Elad Verbin posted on a blog of the \NPtime-hardness of Flood-It with  colours~\cite{Verbinblog:2009}. Although our work was completed independently, it is interesting to note that there is some similarity to the techniques used in our \NPtime-hardness proof for  colours.

Independently of this work, Fleischer and Woeginger have studied a closely related game to Flood-It, known as Honey-Bee \cite{FW2010:honey}. This game is also based around repeatedly applying a flood filling operation on a grid. The main differences are that the grid is hexagonal and may contain barriers, and also that there is a two-player variant of the game. In this variant, two players start flood filling from opposite corners, and the goal is to control more of the board than your opponent. Fleischer and Woeginger focus on the computational complexity of Honey-Bee, and consider a number of generalisations of the single player game to different classes of graphs. They prove that some generalisations are \NPtime-hard, while others are in \Ptime. Again, there is some similarity in the techniques used in one of their \NPtime-hardness proofs, although we note that this proof does not immediately apply to Flood-It without some modification. Fleischer and Woeginger also show that the two-player game on arbitrary graphs is \PSPACE-complete.

Another related game whose computational complexity has been studied in detail is known as Clickomania~\cite{BDDFJM2002:Click}.  A rectangular board is initialised in the same way as in Flood-It. The move permitted is for the player to remove a chosen connected monochromatic component of at least two tiles after which any blocks above it will fall down as far as they can. Finding an optimal solution to Clickomania has been shown to be \NPtime-hard for two or more columns and five or more colours, or five or more columns and three or more colours.

There is also existing work on a majority-based recolouring game on graphs \cite{Berger:2001,Flocchini:2003,Peleg:1998}. The game is played over a number of rounds on a simple undirected graph where each vertex is initially coloured white or black. In each round each vertex is recoloured by the colour of the majority of its neighbours. The player's only interaction is to determine the set of vertices which are initially coloured white. The goal is to pick the smallest possible set of vertices such that after a finite number of rounds, all vertices are white.


Flood-It can be thought of as a model for a number of different (possibly not entirely) real world applications.  For example, our results supplement that of recent work on zombie infestation~\cite{MHIS2009:Zombies} if one regards the flooding operation as one where the minds of neighbouring non-zombies are infected by those who have already been turned into zombies.  A separate but no less significant line of research considers the complexity of tools commonly provided with Microsoft Windows. Previous work has shown that aspects of Excel~\cite{IMO2009:Draw} and even Minesweeper~\cite{Kaye2000:Minesweeper} are \NPtime-complete. Our work extends this line of research by showing that flood filling in Microsoft's Paint application is also \NPtime-hard.

\subsection{Notation and definitions}

Let  be the set of all \recdim{n}{n} boards with at most  colours. We write  for the minimum number of moves required to flood a board . We will refer to rows and columns in a board in the usual manner. We further denote the colour of the tile in row  and column  as ; colours are represented by integers between 1 and . Throughout we assume that .
\begin{figure}[t] \centering

        \centering
        \pgfgraphic{graphic-diamonds}
        \caption{(a) An alternating 4-diamond and (b) a cropped 6-diamond.\label{fig:kdiamonds}}
\end{figure}

We define a \emph{diamond} to be a diamond-shaped subset of the board (see Figure~\ref{fig:kdiamonds}a). These structures are used throughout the paper. The centre of the diamond is a single tile and the \emph{radius}  is the number of tiles from its centre to its leftmost tile. We write -diamond to denote a diamond of radius . A single tile is therefore a 1-diamond. For , the th \emph{layer} of an -diamond is the set of tiles at board distance  from its centre. We will also consider diamonds which are cropped by intersection with the board edges as in Figure~\ref{fig:kdiamonds}b.






\section{A greedy approach is bad} \label{sec:greed}
An obvious strategy for playing the Flood-It game is the greedy approach. There are two natural greedy algorithms: (1)~we pick the colour that results in the largest gain (number of acquired tiles), or (2)~we choose the colour dominating the perimeter of the currently flooded region. It turns out that both these approaches can be surprisingly bad.

\begin{figure}[t] \centering
        \centering
        \pgfgraphic{graphic-greed}
        \caption{A \recdim{10}{10} board where a greedy approach is bad.\label{fig:greedy}}
\end{figure}

To see this, let  be the \recdim{10}{10} board on three colours illustrated in Figure~\ref{fig:greedy}.   The number of moves required to flood  is three.  However, either greedy approach given would first pick the colours appearing on the horizontal lines before finally choosing to flood the left-hand vertical column. In both cases, this requires  moves to fill the board.   It should be clear how this example can easily be extended to arbitrarily large \recdim{n}{n} boards. In general, the greedy algorithm will make  moves, while the optimal algorithm will still make only three.


\section{The complexity of Flood-It} \label{sec:NPC}
\newcommand{\stl}{w}



Let \Coloroid{c} denote the problem which takes as input an \recdim{n}{n} board  of  colours and outputs the minimum number of moves  in a Flood-It game that are required to flood . Similarly, let \ColoroidFree{c} denote the generalised version of \Coloroid{c} in which we are free to flood fill from an arbitrary tile in each move. Although we have seen that a straightforward greedy algorithm fails, it is not too far-fetched to think that a dynamic programming approach would solve these problems efficiently, but the longer one ponders over it, the more inconceivable it seems. To aid frustrated Flood-It enthusiasts, we prove in this section that both \Coloroid{c} and \ColoroidFree{c} are indeed \NPtime-hard, even when the number of colours is as small as three. Interestingly, we will see that \ColoroidFree{2} is in \Ptime.

To show \NPtime-hardness, we reduce from the \emph{shortest common supersequence} problem, denoted \SCS{}, which is defined as follows. The input is a set  of  strings over an alphabet . A \emph{common supersequence}  of the strings in  is a string such that every string in  is a subsequence of . The output is the length of a shortest common supersequence of the strings in . The decision version of \SCS{} takes an additional integer  and outputs yes if the shortest common supersequence has length at most , otherwise it outputs no.

Maier~\cite{Mai1978:SCS} showed in 1978 that the decision version of \SCS{} is \NPtime-complete if the alphabet size . A couple of years later, R\"aih\"a and Ukkonen~\cite{RU1981:SCS} extended this result to hold for . For a long time, various groups of people tried to approximate \SCS{} but no polynomial-time algorithm with guaranteed approximation bound was to be found. It was not until 1995 that Jiang and Li~\cite{JM1995:SCS} settled this open problem by proving that no polynomial-time algorithm can achieve a constant approximation ratio for \SCS{}, unless . Their result holds for an unbounded alphabet.

The following lemma proves the \NPtime-hardness of both \Coloroid{c} and \ColoroidFree{c} when the number of colours is at least four. The inapproximability of both problems follows immediately from the approximation preserving nature of the reduction. However, in the reduction we present, the number of colours in the \Coloroid{c} instance will be exactly twice the number of alphabet symbols in the \SCS{} instance. For this reason, our inapproximability results only hold when the number of colours is unbounded. We will need a more specialised reduction for the case , which is given in Lemma~\ref{lem:NPC-three}.

\begin{lemma}
    \label{lem:NPC-four}
    For , \Coloroid{c} and \ColoroidFree{c} are \NPtime-hard (and the decision versions are \NPtime-complete). Further, for an unbounded number of colours , there is no polynomial-time constant factor approximation algorithm, unless .
\end{lemma}
\begin{proof}
    The proof is split into two parts; first we prove the lemma for \Coloroid{c} in which we flood fill from the top left tile in each move, and in the second part we generalise the proof to \ColoroidFree{c} in which we can flood fill from any tile in each move.

    We reduce from an instance of \SCS{} that contains  strings  each of length at most  over the alphabet . Suppose that  contains  letters and let  be an alphabet with  new letters. For , let  be the string obtained from  by inserting the character  after each  and inserting the character  at the very front. For example, from the string  we get .

    Let  represent the set of  colours that we will use to construct a board . First, for , we define the -diamond  such that the th layer will contain only one colour which will be the th character from the right-hand end of . Thus, the colour of the outermost layer of  is the first character of  (which is  for all strings) and the centre of  is the last character of . The reason why we intersperse the strings with letters from the auxiliary alphabet  is to ensure that no two adjacent layers of a diamond have the same colour. This property is crucial in our proof. Let  be a sufficiently large \recdim{n}{n} board constructed by first colouring the whole board with the colour  and then placing the  diamonds  on  such that no two diamonds overlap. Since each of the  diamonds has a radius of at most , we can be assured that  never has to be greater than .

    Suppose that  is a shortest common supersequence of  and suppose its length is . We will now argue that the minimum number of moves to flood  is exactly , first showing that  moves are sufficient. Let  be the -long string obtained from  by inserting the character  after each . We make  moves by choosing the colours in the same order as they appear in . Note that we flood fill from the top left tile in each move. From the construction of the diamonds~ it follows that all diamonds, and hence the whole board, are flooded after the last character of  has been processed.

    It remains to be shown that at least  moves are necessary to flood . Let  be a string over the alphabet  that specifies a shortest sequence of moves that would flood the whole board . From the construction of the diamonds  it follows that the string obtained from  by removing every character in  is a common supersequence of  and therefore has length at least . By symmetry (replace every  with  in the strings ), the string obtained from  by removing every character in  has length at least  as well. Thus, the length of  is at least .

    Since the decision version of \SCS{} is \NPtime-complete even for a binary alphabet , it follows that \Coloroid{c} is \NPtime-hard for , and the decision version is \NPtime-complete.  As discussed above, observe that the number of colours used is exactly twice the alphabet size of the \SCS{} instance. Therefore the inapproximability result for an unbounded number of colours in the statement of the lemma follows immediately from the approximation preserving nature of the reduction given.

    Now we show how to extend these results to \ColoroidFree{c}. The reduction from \SCS{} is similar to the previously presented reduction. However, instead of constructing only one board , we construct  copies of  and put them together to one large \recdim{n'}{n'} board . If necessary in order to make  a square, we add sufficiently many \recdim{n}{n} boards that are filled only with the colour . Note that  and hence  is a generous upper bound on .

    From the construction of  it follows that exactly  moves are required to flood  if we flood fill from the top left tile in each move; all copies of  will be flooded simultaneously. The question is whether we can do better by flood filling from tiles other than the top left one (or any tile in its connected component). That is, can we do better by picking a tile inside one of the diamonds? We will argue that the answer is no. First note that . Suppose that we do flood fill from a tile inside some diamond  for some move. This move will clearly not affect any of the other diamonds on . Suppose that this move would miraculously flood the whole of  in one go so that we can disregard it in the subsequent moves. However, there were originally  copies of , which is one more than the absolute maximum number of moves required to flood , hence we can use a recursive argument to conclude that flood filling from a tile inside a diamond will do us no good and would only result in more moves than if we choose to flood fill from the top left tile in each move.
    \qed
\end{proof}

The reduction in the previous proof is approximation preserving, which allowed us to prove that there is no efficient constant factor approximation algorithm. We reduced from an instance of \SCS{} by doubling the alphabet size, resulting in instances of \Coloroid{c} and \ColoroidFree{c} with  colours. To establish \NPtime-hardness for  colours, we need to consider a different reduction. We do this in the lemma below by reducing from the decision version of \SCS{} over a binary alphabet to the decision versions of \Coloroid{3} and \ColoroidFree{3}. This reduction is not approximation preserving as in the previous proof; the number of moves required to flood the board in the reduced instance of \Coloroid{3} (or \ColoroidFree{3}) does not correspond in a straightforward way to the length of shortest common supersequence in the \SCS{} instance we reduce from.

\begin{lemma}
    \label{lem:NPC-three}
    \Coloroid{3} and \ColoroidFree{3} are \NPtime-hard (and the decision versions are \NPtime-complete).
\end{lemma}
\begin{proof}
    We reduce from an instance of the decision version of \SCS{} on  strings  of length at most  over the binary alphabet  and an integer . The yes/no question is whether there exists a common supersequence of length at most .

    For , let  be the string obtained from  by inserting the new character~3 at the front of  and after each character of . Let the set  represent the colours that we will use to construct a board . First, for each of the  strings  we define the diamond  exactly as in the proof of Lemma~\ref{lem:NPC-four} (see Figure~\ref{fig:NPC}a). We define  to be the following rectangular area of the board of width  and height . Let  be the middle tile at the bottom of . Around  we have layers of concentric half rectangles (see Figure~\ref{fig:NPC}b). We refer to these layers as \emph{arches}, with the first arch being  itself. As demonstrated in the figure, the first arch has the colour~1 and the second arch has the colour~2. All the remaining odd arches have the colour~3, and all the remaining even arches are coloured~2 everywhere except for the tile above  which has the colour~1. As described in detail below, the purpose of these arches is to control which minimal sequences of moves would flood .


\begin{figure}[t]
\centering
	\pgfgraphic{graphic-npc}
\caption{ An example of (a) a diamond and (b) a rectangle constructed in the proof of Lemma~\ref{lem:NPC-three}.}
\label{fig:NPC}
\end{figure}

    Let  be a sufficiently large \recdim{n}{n} board constructed as follows. First colour the whole board with the colour~3. Then, at the bottom of  starting from the left, place  copies of  one after another without any overlaps. Finally place the  diamonds  on  such that no two diamonds overlap and no diamond overlaps any copy of . Figure~\ref{fig:NPC2} illustrates a board  with  and . Since a diamond has a radius of at most  and ,  is an upper bound on .

    The reason why we place copies of  on the board  is to make sure that at least  moves are required to flood , even in the absence of diamonds. To see this, suppose first that we flood fill from the top left square in each move. From the definition of the arches of , disregarding the diamonds on , a minimal sequence of moves will consist of  1s or 2s interspersed with a total of  3s, followed by the three moves 3, 2 and 1, respectively. Note that only one copy of  on  would be enough to achieve this. However, having several copies of  on  does not affect the minimum number of moves as all copies will get flooded simultaneously. The idea with the  copies of  is to make sure that at least  moves are required to flood  even when we are allowed to choose which tile to flood fill from in each move. To see this, suppose that we choose to flood fill from a tile inside one of the copies of . Since there are  copies, similar reasoning to the end of the proof of Lemma~\ref{lem:NPC-four} tells us that we will do worse than  moves.



    We will now argue that the number of moves required to flood  is  if and only if there is a common supersequence of  of length at most . We choose to flood fill from the top left tile in each move.

    Suppose first that there is a common supersequence  of length . Let  be the string  followed by ~1s. Let  be the -long string obtained from  by inserting a~3 after each character of  and adding the two additional characters 2 and 1 to the end. We make  moves by choosing the colours in the same order as they appear in . Note that all diamonds are flooded after  moves, and by the last move we have also flooded every copy of , and hence the whole board .

\begin{figure}[t]
\centering
	\pgfgraphic{graphic-npc2}
\caption{A board constructed in the proof of Lemma~\ref{lem:NPC-three}.}
\label{fig:NPC2}
\end{figure}

    Suppose second that  can be flooded in  moves. The centre of each diamond has the colour~3 and therefore the first  moves flood the diamonds. The subsequence of these first  moves induced by the colours 1 and 2 is an -long common supersequence of .
    \qed
\end{proof}

We can now summarise Lemmas~\ref{lem:NPC-four} and~\ref{lem:NPC-three} in the following theorem.

\begin{theorem}
    \label{thm:NPC}
    For , \Coloroid{c} and \ColoroidFree{c} are \NPtime-hard (and the decision versions are \NPtime-complete). Further, for an unbounded number of colours , there is no polynomial-time constant factor approximation algorithm, unless .
\end{theorem}

For two colours, \Coloroid{2} is trivially in \Ptime, but it is not that obvious what the complexity of \ColoroidFree{2} is. The next theorem settles this question, by showing that an optimal strategy for any instance of \ColoroidFree{2} consists of flooding from the same tile in each move.

\begin{theorem}\label{thm:NPC-freetwo}
        \ColoroidFree{2} is in \Ptime.
\end{theorem}
\begin{proof}
    We first consider the case where we are allowed to flood fill from exactly two distinct tiles of the board. At the end of the proof we consider the case where flooding from any tile is allowed.

    Suppose there exists a shortest sequence of moves  that floods the board from only two tiles  and . Suppose also that  and  belong to different connected components during the first  moves but become connected in the th move, where  is the number of flood filling operations from  and  is the number of flood filling operations from . Suppose without loss of generality that in move , we flood fill from . Let  and  be two adjacent tiles such that after  moves,  and  belong to the same monochromatic region, and  and  belong to the same monochromatic region. Let  be a simple path from  to  in the board with the monochromatic connected components , such that the th flood filling move from  merges  with the monochromatic region that contains . Thus,  and the whole path  is monochromatic after  flood filling operations from . We define a path  from  to  similarly. Let  be the monochromatic connected components of . Figure~\ref{fig:NPC-2freeA} illustrates the two paths  and .
\begin{figure}[t]
        \centering
	\pgfgraphic{graphic-2freeA}
        \caption{ A board (a) before and (b) after  moves as discussed in the proof of Theorem~\ref{thm:NPC-freetwo}. The solid and dashed paths give  and  respectively. In left-to-right order, the emphasised tiles are  and .}
    \label{fig:NPC-2freeA}
    \end{figure}

    We now show that the area flooded after the first  moves of  can be flooded with  flood filling moves from one single tile . Let  be the path  concatenated with a reversed copy of . Thus, the monochromatic connected components  of  are . Let  be a tile in  and consider a series of flood filling moves from this tile: after the first  moves,  and  are connected, and after the first  moves,  and  are connected. Once a tile  is in the same monochromatic component as , flooding from  is equivalent to flooding from . Thus, after a total of  flood filling moves from , we have effectively performed  flood filling moves from  and  flood filling moves from . This is exactly what the first  moves of  do. Hence we can replace the moves in  by flooding from a single tile .

    Finally we deal with the case where we are allowed to flood fill from any tile. Consider a shortest sequence  of moves that flood the board and suppose that we flood fill from the tiles , for . Suppose without loss of generality that the first merge of any of these tiles is when we flood fill from , which connects  with , where . Let  be the number of flood filling operations that have taken place from  before this merge. The following sequence  of moves will flood the board in at most  moves but flood fills from only  tiles. For , first perform  flood filling operations from . Instead of flooding from  and  separately, we use the result above and flood fill from a different tile . Thus, by the next  moves we have connected . The subsequent moves of  follow those of , where any move at  or  is replaced with a move at . Inductively we reduce the number of tiles to flood fill from to a single tile. The conclusion is that we can solve \ColoroidFree{2} by attempting to flood the entire board from each tile of the board in turn, which requires only polynomial time.
    \qed
\end{proof}

\section{The complexity of constant height boards} \label{sec:shape}


So far we have analysed the complexity of  on square shaped \recdim{n}{n} boards. A natural question to ask is: what is the complexity of \Coloroid{c} on an \recdim{h}{n} board, where the height  is a fixed constant? We denote this problem by \Coloroid{(c,h)} and the `free' variant by \ColoroidFree{(c,h)}, analogously.

\Coloroid{(c,1)} is trivially in \Ptime, and Fleischer and Woeginger have shown (personal communication) that \ColoroidFree{(c,1)} is also in \Ptime. We will show that of \Coloroid{(c,2)} on a \recdim{2}{n} board remains in \Ptime. However, the complexity of \ColoroidFree{(c,2)} remains unresolved. Before stating this result we will prove in Theorem~\ref{thm:hNPC} that when the number of colours is unbounded and  then both \Coloroid{(c,h)} and \ColoroidFree{(c,h)} are \NPtime-hard.



For the \Coloroid{c} problem on a square \recdim{n}{n} board with  we gave a reduction from the shortest common supersequence problem (\SCS{}) which embedded a number of diamond structures into a board filled with a single background colour. Each diamond represented one of the strings in the \SCS{} instance. The problem with this reduction on an \recdim{h}{n} board is that a string of length  was represented by a diamond with height . This is not possible if . However, Timkovskii proved~\cite{Timkovskii:1989} that the \SCS{} problem remains \NPtime-hard even when the length of the strings is constrained to be at most , and the alphabet size is unbounded. Inspection of the proof of Lemma~\ref{lem:NPC-four} shows that \Coloroid{(c,h)} is \NPtime-hard (and the decision version \NPtime-complete) when  and the number of colours is unbounded. Naively, it would appear that  suffices in the proof of Lemma~\ref{lem:NPC-four} as it allows enough height to embed a diamond representing a string of length  as is required. However, for the reduction to be valid we also need to leave at least one row of space above the diamonds so that all diamonds can be flooded simultaneously on any move.

To reduce the board height required for our \NPtime-hardness proof further we reduce the height of the diamond structures used in the reduction. Recall that the reduction begins by doubling the length of all strings in a way that ensures that no string contains a character which is followed immediately by another occurrence of the same character. We now show in Lemma~\ref{lem:SCSab} that the \SCS{} problem remains \NPtime-hard even when all the strings are of the form  where  and . The proof is by reduction from the \SCS{} problem with the constraint that all strings have length at most . This result allows us to remove the doubling step and reduce the height of the diamond structures, resulting in Theorem~\ref{thm:hNPC} which gives the desired result.

\begin{lemma}
    \label{lem:SCSab}
    The \SCS{} problem is \NPtime-hard when all the strings are of the form  where  and .
\end{lemma}
\begin{proof}
Let  be an instance of \SCS{} that contains  strings  each of length  over the alphabet . We abuse notation by referring to  as both the instance and the set of  strings. We begin by assuming that  contains a string of length . Without loss of generality let  be such a string. Let  be the instance of \SCS{} formed by the  strings . There are two cases to consider. In the first case, the single character, , in  occurs in some string . Therefore any common supersequence of  contains an  and hence is also a common supersequence of . Further, as  is a superset of , any common supersequence of  is a common supersequence of . Hence . In the second case, the single character, , in  does not occur in . A common supersequence for  can therefore be found by inserting  at the end of the shortest common supersequence for . Hence . Further, any common supersequence for  must contain an  and is also a common supersequence for . Therefore by removing the  we have that . Hence in this case . Repeated application of the above technique gives a poly-time reduction from the \SCS{} problem with strings of length  to  the \SCS{} problem with strings of length . Therefore we have that the latter is also \NPtime-hard.

We now redefine  to be an instance of \SCS{} that contains  strings  each of length exactly  over the alphabet . We begin by assuming that  contains a string of the form  where . Without loss of generality let  be such a string. Let  be the instance of \SCS{} formed by the  strings  and new strings  and  where  does not occur in . First consider the shortest common supersequence of , which must contain  as a subsequence. By inserting  between these two occurrences of , we obtain a common supersequence of  of length . Therefore . Now consider the shortest common supersequence of , which must contain either  or  as a subsequence. In the former case by removing the  symbol we obtain a common supersequence of  and have that . In the latter, when we remove the two occurrences of  we obtain a common supersequence of  of length . This sequence contains exactly one occurrence of , and by inserting a second we obtain a common supersequence of  of length . Therefore . Repeated application of the above technique gives a poly-time reduction from the \SCS{} problem with strings of length  to  the \SCS{} problem with strings of the form  where  and . Therefore we have that the latter is also \NPtime-hard. \qed
\end{proof}

\begin{theorem}
    \label{thm:hNPC}
     \Coloroid{(c,h)} and \ColoroidFree{(c,h)} are \NPtime-hard when  and the number of colours  is unbounded (and the decision versions are \NPtime-complete).
\end{theorem}
\begin{proof}
First observe that the decision versions of both problems are in \NPtime{} because the unconstrained versions, \Coloroid{c} and \ColoroidFree{c}, are in \NPtime{}. We begin by considering the \Coloroid{(c,h)} problem for . We reduce from an instance of \SCS{} on  strings  over the alphabet  and an integer . The strings are constrained to have the form  where  and . Let  be a \recdim{h}{n} board filled with a single background colour where . For each symbol in  we have a corresponding distinct colour in addition to the background colour. For each string  we embed a `half' diamond against the bottom edge of the board. The half diamond consists of a single tile of colour  (the inner layer), surrounded on all three sides by a tile of colour  (the outer layer). This is illustrated in Figure~\ref{fig:height3} for .

\begin{figure}[t]
    \centering
	\pgfgraphic{graphic-height3}
    \caption{An example of a board constructed in the proof of Theorem~\ref{thm:hNPC}. In left-to-right order, the strings embedded are ``23'',``12'',``32'' and ``21''. The shortest common supersequence is ``2132''.}
    \label{fig:height3}
\end{figure}

Observe that as  and , all the half diamonds can be placed so that the outer layer of each half diamond is surrounded by the background colour. Therefore on any move, the outer layer of any half diamond can be flooded. Further observe that for all , as  the diamond for  is flooded if and only if the move sequence contains  as a subsequence. Therefore a move sequence floods the board if and only if it is a common supersequence of , so  equals the length of the shortest move sequence which floods the board. As this reduction can be implemented in polynomial time, we have that \Coloroid{(c,h)} problem is \NPtime-hard with an unbounded number of colours.

We now consider the \ColoroidFree{(c,h)} problem for . \NPtime-hardness follows by the same argument as for the \NPtime-hardness of \ColoroidFree{c} for  given in the proof of Lemma~\ref{lem:NPC-four}. We increase the size of the board (horizontally) and embed  copies of each half diamond. We observe that any flood-filling move begun from a tile in an unflooded half diamond floods only tiles in that half diamond. This ensures that any move sequence which floods the board and contains moves begun from tiles in an unflooded half diamond either contains at least  moves or contains redundant moves. In either case, it is not minimal. \qed
\end{proof}



We finally show that \Coloroid{(c,2)} is in \Ptime.

\begin{theorem}
    \label{thm:height2}
    For any , \Coloroid{c} on a \recdim{2}{n} board is in \Ptime. More precisely, the running time is .
\end{theorem}
\begin{proof}
    Suppose that  is a \recdim{2}{n} board and  is the number of colours. We say that a tile  on  is \emph{marked} if it has colour  and no other tile in the columns strictly to the right of  has the colour . A column is marked if it contains a marked tile.

    The key observation, which holds on a \recdim{2}{n} board, is that if the marked tiles are flooded then so is the whole board . To see this, note that when a marked tile  of colour  is flooded, all other tiles of the colour  that have not yet been flooded are to the left of  and therefore adjacent to the flooded region. Hence they will be flooded when  is flooded. Thus, we ask for the shortest sequence of moves that would flood the marked tiles.

    A \emph{shortest path} to a tile  denotes a shortest sequence of flood filling operations that includes   in the flooded region. If  is already included in the flooded region, then the length of the shortest path to  is~0.

    One might think that a solution to \Coloroid{c} on a \recdim{2}{n} board would be to go from one marked tile to the next in left-to-right order using shortest paths. Although this is correct, we must be a little careful with which shortest paths we choose. The following procedure floods the marked tiles in the smallest number of moves possible.

    \begin{description}
        \item{\bf Beginning of procedure.} Let  be the leftmost marked column such that  contains a marked tile  that has not yet been flooded. Let  be the other tile in column . We have two cases.
\begin{description}
                \item{\bf Case 1 ( is unmarked).} Let  and  be the lengths of the shortest paths to  and , respectively. Note that . We consider two subcases.
\begin{description}
                        \item{\bf Case 1a ().} Flood using the sequence of colours found along the shortest path to , then go to the beginning of the procedure. Correctness: Flooding  before  means that we are bound to flood  at a later stage. Once  is flooded we can never do worse by flooding  immediately. Thus, flooding  before  and then flooding  takes a total of at least  moves. However, flooding  takes  moves and we are not necessarily forced to spend an extra move on flooding , which is not a marked tile.
                        \item{\bf Case 1b ().}  Flood using the sequence of colours found along the shortest path to  and then flood . Then go to the beginning of the process. Correctness: Flooding  takes at at least  steps, even if we do not go via . Since all remaining marked tiles are to the right of column , we should therefore flood  before . Once  is flooded, we can never do worse by flooding  immediately.
\end{description}
\item{\bf Case 2 ( is marked).} Flood using the sequence of colours found along the shortest of the shortest paths to  or . Then flood the remaining tile in column . Then go to the beginning of the process. Correctness: Both  and  must eventually be flooded. Once one of them is flooded, there is no reason to wait to flood the other.
            \end{description}
    \end{description}

    Using for example dynamic programming, the shortest path to a tile  on a \recdim{2}{n} board can be computed in time linear in the distance between the flooded region and . We note that the shortest paths are always calculated between the rightmost end of the flooded region and a marked column~. Since the flooded region is always extended to column  in each step of the procedure, the total running time of computing the shortest paths is linear in . Hence the running time of the whole process is . \qed
\end{proof}


\section{Approximating the number of moves} \label{sec:approx}
As we have seen, \Coloroid{c} and \ColoroidFree{c} are not efficiently approximable to within a constant factor for an unbounded number of colours . However, a -approximation for \Coloroid{c}, , can easily be obtained as follows. Suppose that  is a board on the colours . Clearly, if we repeatedly cycle through the sequence of colours   then  will be flooded after at most  moves. We can do a little better by first cycling through the ordered sequence of colours  and then repeatedly alternating between a cycle of the sequence  and a cycle of  until there are only two distinct colours left on the board, after which we alternate between the two remaining colours. Note that there are always exactly two distinct colours left before the final move. The board  is guaranteed to be flooded after at most  moves, which gives us a -approximation algorithm.

A randomised approach with an expected number of moves of approximately  is obtained as follows. Suppose that  is a minimal sequence of colours that floods  (flood filling from the top left square in each move). We shuffle the  colours and process them one by one. If  is not flooded then we shuffle again and repeat. Note that this procedure could (and most likely will) generate many useless moves that do not merge any monochromatic regions. Thus, if  then the algorithm could take up to  moves, although a single move would suffice. If  then  is an upper bound on the expected number of moves; with probability , the two moves in  appear in the same order as in the shuffled sequence of colours, and if not, we might have to shuffle the colours again and repeat one last time. We generalise this as follows. Let  be (an upper bound on) the expected number of moves it takes to produce a fixed sequence of  moves. We have . Solving the recurrence with the values of  and  above gives us a solution in which  is asymptotically  for a fixed .



\section{General bounds on the number of moves} \label{sec:bound}
Recall that we denote the minimum number of moves which flood some board  as . In this section we investigate bounds on the maximum  over all boards in  which we denote \Mnc{}. Intuitively, this can be seen as the minimum number of moves to flood the `worst' board in .

For motivation, consider an \recdim{n}{n} checker board of two colours as shown in Figure~\ref{fig:uplow}. First observe that as the board has only two colours, the player has no choice in their next move. Consider a diagonal of tiles in the direction top-right to bottom-left where the 0th diagonal is the top-left corner. Further observe that move  floods exactly the th diagonal, so the total number of moves is . Thus we have shown that .

\begin{figure}[t]
\centering
	\pgfgraphic{graphic-checker}
\caption{Progression of a \recdim{6}{6} checker board. }
\label{fig:uplow}
\end{figure}

We now give an overview of a simple algorithm which floods any board in  in at most  moves. The algorithm performs  stages. The purpose of the th stage is to flood the th row.  Stage  repeatedly picks the colour of the leftmost tile in row  which is not in the flooded region, until row  is flooded.

First observe that Stage  performs at most  moves to flood row  (we can flood at least one tile of row  per move). When the algorithm begins Stage , observe that row  is entirely flooded as well as any tiles in row  which match the colour of row . Therefore when a new colour is selected, all tiles in row  of this colour become flooded. Hence at most  moves are performed by Stage . Summing over all rows, this gives the desired bound that . Observe that from the previous example with the checker board on  colours, the bound  is tight. Thus, the checker board is the `worst' board in .

As motivation, we have given weak bounds on \Mnc{}. We now tighten these bounds for large  by providing a better algorithm for flooding an arbitrary board. We will also give a description of `bad' boards which require many moves to be flooded. It will turn out that \Mnc{} is asymptotically  for increasing  and~.

\newcommand{\rem}{\text{rem}}
\begin{theorem} \label{thm:good}
There exists a polynomial time algorithm for \Floodit{} which can flood any \recdim{n}{n} board with  colours in at most  moves.
\end{theorem}

\begin{proof}

For a given integer  (to be determined later), we partition the board horizontally into  contiguous sections, denoted  from top to bottom, as follows. Let  and . Section  consists of the first  rows,  contain  rows each (if ), and  contain  rows each (if ). Section  contains  rows. See Figure~\ref{fig:upper} for an illustration. We let  denote the final row of .

The algorithm performs the following three stages.
\begin{description}
    \item{Stage~1.} Flood the first column.
    \item{Stage~2.} Flood row  for all .
    \item{Stage~3.} Cycle through the  colours until the board is flooded.
\end{description}


The correctness of our algorithm is immediate as Stage~ ensures that the board is flooded by cycling colours. Stage~ can be implemented to perform at most  moves as argued for the simple algorithm above. Similarly, Stage~ can be completed in  moves. We now analyse Stage~.
\begin{figure}[t]
    \begin{minipage}[b]{0.50\linewidth}
        \centering
        \pgfgraphic{graphic-upper}
        \caption{The board decomposition used in the proof of Theorem~\ref{thm:good}.\label{fig:upper}}
    \end{minipage}\hspace{0.06\linewidth}\begin{minipage}[b]{0.44\linewidth}
        \centering
        \pgfgraphic{graphic-packed}
        \caption{4-diamonds packed in a \recdim{20}{20} board.\label{fig:packed}}
    \end{minipage}
\end{figure}

First consider . At the start of Stage , row  is entirely in the top-left region, so a single cycle of the  colours suffices to expand the region to include row . Each subsequent cycle of  colours expands the region to include an additional row. Therefore, after  moves of Stage , all rows above  are included in the top left region. Similarly, the section  will be included in the top-left region as it contains  rows.

Now consider section  for some . Observe that there are at most  rows in  which are not already completely in the top-left section (after stage~2). Further observe that any cycle of  colours expands the region to include \emph{two} more of these rows. One row is gained from the region bordering the top of the section (which is in the top-left region from stage ). The second is gained from the region bordering the top of the section (which is also in the top-left region from stage ). Therefore after at most  moves of Stage  the board is flooded.

Over all three stages this gives a total of at most  moves. We pick  to minimise this number of moves. By recalling that  and simplifying we have that this total is less than  moves as required. \qed
\end{proof}

\begin{theorem} \label{thm:bad}
    For , there exists an \recdim{n}{n} board with (up to)  colours which requires at least  moves to flood.
\end{theorem}
\begin{proof}


    Suppose first that  is even. For a given integer , let  be an -diamond where odd layers are coloured  and even layers are coloured . Any board containing  requires at least  moves of colours  and . Further, observe that as long as the centre of  is in the board, even if it is cropped by at most two edges of the board, at least  moves of colours  and  are still required (see Figure~\ref{fig:kdiamonds}b). We refer to such an -diamond as \emph{good}. The central idea is to populate the board with good -diamonds, . As each -diamond uses two colours (or one of the two colours if ) which do not occur in any other diamond, the board must take at least  moves to flood.

    It is not difficult to show that at least  good -diamonds can be embedded in an \recdim{n}{n} board. An example of such a packing for a \recdim{20}{20} board is given in Figure~\ref{fig:packed} (which shows only the edges of diamonds and not their colouring). This scheme generalises well to an \recdim{n}{n} board but the details are omitted in the interest of brevity.
    



    We now take  and note that . As , the -diamonds are cropped by at most two board edges as required. Therefore we have at least  good -diamonds in our board. However, as the number of good -diamonds is an integer, this is at least  as required. Therefore, the number of moves required to flood this board is at least 

    Finally, in the case that  is odd we proceed as above using  of the colours to give the stated result. \qed
\end{proof}

The next corollary is immediate from Theorems~\ref{thm:good} and~\ref{thm:bad}.

\begin{corollary}
    \label{col:moves}
    \,.
\end{corollary}


\section{Random boards} \label{sec:random}


In this section, we try to understand the complexity of a random Flood-It board -- that is, a board where each tile is coloured uniformly at random. This question is of both theoretical and practical interest. A common initialisation for Flood-It is to pick the colours of tiles at random and the game designer will surely be keen to know if they are likely to have chosen an instance whose solution is trivially short. The option of having to solve every created instance to test for this possibility is also likely to be unattractive, especially given the complexity results shown in this paper.  Intuitively, one would expect random boards to usually require a large number of moves to flood. Determining how many moves are actually needed turns out to be closely related to a body of research in {\em percolation theory}, the study of connected clusters in random graphs.

Indeed, a problem in percolation theory that is essentially equivalent to the question of the number of moves required for a random Flood-It board has been solved quite recently by Chayes and Winfield \cite{CW1993:random}, and independently Fontes and Newman \cite{FN1993:random}. In our terminology, their result was that a random \recdim{n}{n} Flood-It board with  colours requires  moves with high probability. The proofs are lengthy and use some deep previous results in percolation theory.

We now present a greatly simplified proof of the results of \cite{CW1993:random,FN1993:random}, in the case that . Formally, our result is as follows.

\begin{theorem}
    \label{thm:random}
    Let  be a board where the colour of each tile is chosen uniformly at random from . Then, for , . For , .
\end{theorem}

In order to prove this theorem, we will use two lemmas concerning paths in Flood-It boards. Let  be a simple path in a Flood-It board, i.e.\ a simple path on the underlying square lattice\footnote{Simple paths on square lattices have been intensively studied, and are known as {\em self-avoiding walks} \cite{MS1996:SAW}. There are known upper bounds, which are slightly stronger than Lemma \ref{lem:pathcount}, on the number of self-avoiding walks of a given length; however, we avoid these here to keep our presentation elementary.}, where tiles are vertices on the path. Note that a path of length  includes  tiles. We say that a simple path  is {\em non-touching} if every tile in  is adjacent to at most two tiles that are also in . Define the {\em cost} of , , to be the number of maximal monochromatic connected components of the path, minus one (so a monochromatic path has cost 0).


\begin{lemma}
    \label{lem:pathcost}
    For any , there is a non-touching path from  to  with cost at most .
\end{lemma}

\begin{proof}
    For  there is nothing to prove, so consider a strategy for completing  which uses  moves. Label every tile  with an integer  between 0 and  that indicates the number of the move which changed the colour of  to be the colour of tile . Then, for each , there is a connected component labelled with  which has at least one neighbour labelled with . As the label of  is at most , and the label of  is 0, there is a simple path from  to  with cost at most . This path can be taken to be non-touching, because any pair of adjacent tiles  that are on the path but not connected by it correspond to a loop in the path that can be removed without increasing the cost.
    \qed
\end{proof}

\begin{lemma}
    \label{lem:pathcount}
    For any integer , there are at most  non-touching paths of length  from any given tile.
\end{lemma}

\begin{proof}
    Let  denote the maximum number of non-touching paths of length  starting from any given tile.  can be straightforwardly upper bounded by  for , as with each step of the path, aside from the first, there are at most 3 choices of direction. We get a tighter bound by analysing a few steps on a non-touching path . Consider the th vertex on , for some . As  is simple, there are at most 3 choices for the th vertex of the path. For vertex , if the previous two steps were in the same direction, there are at most 3 more choices. On the other hand, if the previous two were in different directions, there are only at most 2 choices (otherwise, the path would go back on itself, and would not be non-touching). In total, there are only at most 7 possible options for vertices , . Therefore, for any , we have .
    \qed
\end{proof}

\noindent The last result we will need is the following Chernoff-Hoeffding bound.

\begin{fact}[Hoeffding \cite{hoeffding63}]
    \label{fact:chernoff}
    Let , , be independent 0/1-valued random variables with  then,  where  is the Kullback-Leibler divergence 
\end{fact}

\noindent We are finally ready to prove Theorem \ref{thm:random}.

\begin{proof}[of Theorem \ref{thm:random}]
    For any , and for any board  such that , by Lemma \ref{lem:pathcost} there exists a non-touching path from  to  with cost at most . So consider an arbitrary non-touching path  in  of length  between these two tiles, and let  denote the th tile on the path, for . Note that . Then , or equivalently . Define the 0/1-valued random variable  by . Then, as the colours of tiles are uniformly distributed,  for all , and

where we use Fact \ref{fact:chernoff}. Thus, using the union bound over all paths of length at least  from  to , we get that the probability that there exists {\em any} path of cost at most  is upper bounded by

where we use the estimate for the number of paths which was derived in Lemma~\ref{lem:pathcount}. In the final part of the proof, we consider the cases  and  separately.

    First suppose that . We take , as in the statement of the theorem, and use  (from Fact~\ref{fact:chernoff}) to obtain the bound

As , this sum is exponentially small in .

    Lastly, suppose that . In this case, our choice of  above is negative. Instead we take , which implies . In order to obtain a sufficiently tight bound on , we use the explicit formula in Fact~\ref{fact:chernoff} to show that , which implies that there is a bound in Equation~(\ref{eqn:union}) which is exponentially small in . This completes the proof.
    \qed
\end{proof}


\section{Conclusion and open problems} \label{sec:conc}
We have shown that, for three or more colours, \Floodit{} is \NPtime-hard. However, for two colours, the relaxed version of the problem termed \ColoroidF{} in which we are allowed to flood fill from any tile of the board remains in \Ptime. Some interesting open questions remain. First, the complexity of solving \ColoroidF{} on a height 2 board remains unresolved. Second, we conjecture that the true lower bound for random boards is , matching the general upper bound. Interestingly, the percolation theory techniques that we are aware of do not appear to allow for super-linear lower bounds of the sort that would be required.

\section{Acknowledgements}
AM was funded by an EPSRC Postdoctoral Research Fellowship. MJ was supported by the EPSRC. We are grateful to Dave Arthur for producing an implementation of Flood-It, complete with examples of our NP-hardness reductions.  We
would also like to thank Leon Atkins, Aram Harrow, Tom Hinton and Alex Popa for many helpful and encouraging discussions.


\bibliographystyle{plain}
\bibliography{flood-it}



\end{document}
