\documentclass{article} \usepackage{iclr2019_conference,times}
\usepackage{subcaption}



\usepackage{hyperref}
\usepackage{url}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{booktabs}
\usepackage{xcolor}
\usepackage{appendix}
\usepackage{multirow}
\usepackage{float}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{amsthm}
\usepackage{verbatim}

\newtheorem{lemma}{Lemma}
\newtheorem{theo}{Theorem}
\newtheorem{cor}{Corollary}

\title{Deep Graph Infomax}

\DeclareMathOperator*{\argmax}{argmax}
\DeclareMathOperator*{\argmin}{argmin}



\author{Petar Veli\v{c}kovi\'{c}\thanks{Work performed while the author was at Mila.} \\
Department of Computer Science and Technology\\
University of Cambridge\\
\texttt{petar.velickovic@cst.cam.ac.uk} \\
\And
William Fedus \\
Mila -- Qu\'{e}bec Artificial Intelligence Institute \\
Google Brain \\
\texttt{liamfedus@google.com} \\
\And
William L. Hamilton\\
Mila -- Qu\'{e}bec Artificial Intelligence Institute\\
McGill University\\
\texttt{wlh@cs.mcgill.ca}\\
\And
Pietro Li\`{o} \\
Department of Computer Science and Technology\\
University of Cambridge\\
\texttt{pietro.lio@cst.cam.ac.uk} \\
\And
Yoshua Bengio\thanks{CIFAR Fellow} \\
Mila -- Qu\'{e}bec Artificial Intelligence Institute\\
Universit\'{e} de Montr\'{e}al\\
\texttt{yoshua.bengio@mila.quebec} \\
\And
R Devon Hjelm \\
Microsoft Research \\
Mila -- Qu\'{e}bec Artificial Intelligence Institute\\
\texttt{devon.hjelm@microsoft.com} \\
}



\newcommand{\fix}{\marginpar{FIX}}
\newcommand{\new}{\marginpar{NEW}}
\newcommand{\will}[1]{\textcolor{cyan}{Will H: #1}}
\newcommand{\liam}[1]{\textcolor{blue}{liam: #1}}
\newcommand{\devon}[1]{\textcolor{red}{DEVON: #1}}
\newcommand{\yoshua}[1]{\textcolor{green}{YB: #1}}
\newcommand{\xhdr}[1]{{\noindent\bfseries #1}.}

\iclrfinalcopy \begin{document}


\maketitle

\begin{abstract}
We present \emph{Deep Graph Infomax} (DGI), a general approach for learning node representations within graph-structured data in an unsupervised manner. DGI relies on maximizing mutual information between patch representations and corresponding high-level summaries of graphs---both derived using established graph convolutional network architectures. The learnt patch representations summarize subgraphs centered around nodes of interest, and can thus be reused for downstream node-wise learning tasks. In contrast to most prior approaches to unsupervised learning with GCNs, DGI does not rely on random walk objectives, and is readily applicable to both transductive and inductive learning setups. We demonstrate competitive performance on a variety of node classification benchmarks, which at times even exceeds the performance of supervised learning.
\end{abstract}

\section{Introduction}
Generalizing neural networks to graph-structured inputs is one of the current major challenges of machine learning \citep{bronstein2017geometric,hamilton2017representation,battaglia2018relational}. 
While significant strides have recently been made, notably with \emph{graph convolutional networks}~\citep{kipf2016semi,gilmer2017neural,velickovic2018graph}, most successful methods use \emph{supervised learning}, which is often not possible as most graph data in the wild is unlabeled. In addition, it is often desirable to discover novel or interesting structure from large-scale graphs, and as such, unsupervised graph learning is essential for many important tasks.

Currently, the dominant algorithms for unsupervised representation learning with graph-structured data rely on random walk-based objectives~\citep{grover2016node2vec,perozzi2014deepwalk,tang2015line,hamilton2017inductive}, sometimes further simplified to reconstruct adjacency information \citep{kipf2016variational,duran2017learning}.
The underlying intuition is to train an encoder network so that nodes that are ``close" in the input graph are also ``close" in the representation space.

While powerful---and related to traditional metrics such as the personalized PageRank score \citep{jeh2003scaling}---random walk methods suffer from known limitations. Most prominently, the random-walk objective is known to over-emphasize proximity information at the expense of structural information~\citep{ribeiro2017struc2vec}, and performance is highly dependent on hyperparameter choice~\citep{grover2016node2vec,perozzi2014deepwalk}.
Moreover, with the introduction of stronger encoder models based on graph convolutions~\citep{gilmer2017neural}, it is unclear whether random-walk objectives actually provide any useful signal, as these encoders already enforce an inductive bias that neighboring nodes have similar representations.

In this work, we propose an alternative objective for unsupervised graph learning that is based upon {\em mutual information}, rather than random walks.
Recently, scalable estimation of mutual information was made both possible and practical through Mutual Information Neural Estimation~\citep[MINE,][]{belghazi2018mine}, which relies on training a \emph{statistics network} as a classifier of samples coming from the joint distribution of two random variables and their product of marginals.
Following on MINE, \citet{hjelm2018learning} introduced Deep InfoMax (DIM) for learning representations of high-dimensional data.
DIM trains an encoder model to maximize the mutual information between a high-level ``global" representation and  ``local" parts of the input (such as patches of an image).
This encourages the encoder to carry the type of information that is present in all locations (and thus are \emph{globally relevant}), such as would be the case of a class label.

DIM relies heavily on convolutional neural network structure in the context of image data, and to our knowledge, no work has applied mutual information maximization to graph-structured inputs.
Here, we adapt ideas from DIM to the graph domain, which can be thought of as having a more general type of structure than the ones captured by convolutional neural networks.
In the following sections, we introduce our method called \emph{Deep Graph Infomax} (DGI).
We demonstrate that the representation learned by DGI is consistently competitive on both transductive and inductive classification tasks, often outperforming both supervised and unsupervised strong baselines in our experiments.

\section{Related Work}
\xhdr{Contrastive methods}
An important approach for unsupervised learning of representations is to train an encoder to be \emph{contrastive} between representations that capture statistical dependencies of interest and those that do not.
For example, a contrastive approach may employ a \emph{scoring function}, training the encoder to increase the score on ``real" input (a.k.a, positive examples) and decrease the score on ``fake" input (a.k.a., negative samples).
Contrastive methods are central to many popular word-embedding methods~\citep{collobert2008unified, mnih2013learning, mikolov2013distributed}, but they are found in many unsupervised algorithms for learning representations of graph-structured input as well.
There are many ways to score a representation, but in the graph literature the most common techniques use classification~\citep{perozzi2014deepwalk,grover2016node2vec,kipf2016variational,hamilton2017representation}, though other scoring functions are used~\citep{duran2017learning,bojchevski2018deep}.
DGI is also contrastive in this respect, as our objective is based on classifying local-global pairs and negative-sampled counterparts.

\xhdr{Sampling strategies}
A key implementation detail to contrastive methods is how to draw positive and negative samples.
The prior work above on unsupervised graph representation learning relies on a local contrastive loss (enforcing proximal nodes to have similar embeddings). Positive samples typically correspond to pairs of nodes that appear together within \emph{short random walks} in the graph---from a language modelling perspective, effectively treating nodes as \emph{words} and random walks as \emph{sentences}. Recent work by \cite{bojchevski2018deep} uses node-anchored sampling as an alternative.
The negative sampling for these methods is primarily based on sampling of random pairs, with recent work adapting this approach to use a curriculum-based negative sampling scheme~\citep[with progressively ``closer'' negative examples;][]{ying2018graph} or introducing an adversary to select the negative examples~\citep{bose2018adversarial}.

\xhdr{Predictive coding}
Contrastive predictive coding~\citep[CPC,][]{oord2018representation} is another method for learning deep representations based on mutual information maximization.
Like the models above, CPC is also contrastive, in this case using an estimate of the conditional density~\citep[in the form of noise contrastive estimation, ][]{gutmann2010noise} as the scoring function.
However, unlike our approach, CPC and the graph methods above are all \emph{predictive}: the contrastive objective effectively trains a predictor between structurally-specified parts of the input (e.g., between neighboring node pairs or between a node and its neighborhood). Our approach differs in that we contrast global / local parts of a graph simultaneously, where the global variable is computed from all local variables. 


To the best of our knowledge, the sole prior works that instead focuses on contrasting ``global'' and ``local'' representations on graphs do so via (auto-)encoding objectives on the adjacency matrix \citep{wang2016structural} and incorporation of community-level constraints into node embeddings \citep{wang2017community}. Both methods rely on matrix factorization-style losses and are thus not scalable to larger graphs. 

\section{DGI Methodology}

In this section, we will present the Deep Graph Infomax method in a top-down fashion: starting with an abstract overview of our specific unsupervised learning setup, followed by an exposition of the objective function optimized by our method, and concluding by enumerating all the steps of our procedure in a single-graph setting. 

\subsection{Graph-based unsupervised learning}

We assume a generic graph-based unsupervised machine learning setup: we are provided with a set of \emph{node features}, ${\bf X} = \{\vec{x}_1, \vec{x}_2, \dots, \vec{x}_N\}$, where $N$ is the number of nodes in the graph and $\vec{x}_i \in \mathbb{R}^F$ represents the features of node $i$. We are also provided with relational information between these nodes in the form of an \emph{adjacency matrix}, ${\bf A} \in \mathbb{R}^{N\times N}$. While ${\bf A}$ may consist of arbitrary real numbers (or even arbitrary edge features), in all our experiments we will assume the graphs to be \emph{unweighted}, i.e. $A_{ij} = 1$ if there exists an edge $i\rightarrow j$ in the graph and $A_{ij} = 0$ otherwise.

Our objective is to learn an \emph{encoder}, $\mathcal{E} : \mathbb{R}^{N \times F} \times \mathbb{R}^{N \times N} \rightarrow \mathbb{R}^{N \times F'}$, such that $\mathcal{E}({\bf X}, {\bf A}) = {\bf H} = \{\vec{h}_1, \vec{h}_2, \dots, \vec{h}_N\}$ represents high-level representations $\vec{h}_i \in \mathbb{R}^{F'}$ for each node $i$. These representations may then be retrieved and used for downstream tasks, such as node classification.

Here we will focus on \emph{graph convolutional} encoders---a flexible class of node embedding architectures, which generate node representations by repeated aggregation over local node neighborhoods \citep{gilmer2017neural}.
A key consequence is that the produced node embeddings, $\vec{h}_i$, \emph{summarize a patch} of the graph centered around node $i$ rather than just the node itself. In what follows, we will often refer to $\vec{h}_i$ as {\em patch representations} to emphasize this point.



\subsection{Local-global mutual information maximization}

Our approach to learning the encoder relies on \emph{maximizing local mutual information}---that is, we seek to obtain node (i.e., local) representations that capture the global information content of the entire graph, represented by a \emph{summary vector}, $\vec{s}$. 

In order to obtain the graph-level summary vectors, $\vec{s}$, we leverage a \emph{readout function}, $\mathcal{R} : \mathbb{R}^{N\times F} \rightarrow \mathbb{R}^F$, and use it to summarize the obtained patch representations into a \emph{graph-level representation}; i.e., $\vec{s} = \mathcal{R}(\mathcal{E}({\bf X}, {\bf A}))$.

As a proxy for maximizing the local mutual information, we employ a \emph{discriminator}, $\mathcal{D} : \mathbb{R}^F \times \mathbb{R}^F \rightarrow \mathbb{R}$, such that $\mathcal{D}(\vec{h}_i, \vec{s})$ represents the probability scores assigned to this patch-summary pair (should be higher for patches contained within the summary).

Negative samples for $\mathcal{D}$ are provided by pairing the summary $\vec{s}$ from $({\bf X}, {\bf A})$ with patch representations $\vec{\widetilde{h}}_j$ of an alternative graph, $({\bf \widetilde{X}}, {\bf \widetilde{A}})$. In a multi-graph setting, such graphs may be obtained as other elements of a training set. However, for a single graph, an explicit (stochastic) \emph{corruption function}, $\mathcal{C} : \mathbb{R}^{N\times F} \times \mathbb{R}^{N \times N} \rightarrow \mathbb{R}^{M\times F} \times \mathbb{R}^{M\times M}$ is required to obtain a negative example from the original graph, i.e. $({\bf \widetilde{X}}, {\bf \widetilde{A}}) = \mathcal{C}({\bf X}, {\bf A})$. The choice of the negative sampling procedure will govern the specific kinds of structural information that is desirable to be captured as a byproduct of this maximization.

For the objective, we follow the intuitions from Deep InfoMax~\citep[DIM,][]{hjelm2018learning} and use a noise-contrastive type objective with a standard binary cross-entropy (BCE) loss between the samples from the joint (positive examples) and the product of marginals (negative examples). Following their work, we use the following objective\footnote{Note that \citet{hjelm2018learning} use a softplus version of the binary cross-entropy.}:
\begin{equation}
\label{eqngan}
	\mathcal{L} = \frac{1}{N+M}\left(\sum_{i=1}^N\mathbb{E}_{({\bf X}, {\bf A})}\left[\log \mathcal{D}\left(\vec{h}_i, \vec{s}\right)\right] + \sum_{j=1}^M\mathbb{E}_{({\bf \widetilde{X}}, {\bf \widetilde{A}})}\left[\log\left(1 - \mathcal{D}\left(\vec{\widetilde{h}}_j, \vec{s}\right)\right)\right]\right)
\end{equation} 
This approach effectively maximizes mutual information between $\vec{h}_i$ and $\vec{s}$, based on the Jensen-Shannon divergence\footnote{The ``GAN'' distance defined here---as per \cite{goodfellow2014generative} and \cite{nowozin2016f}---and Jensen-Shannon divergence can be related by $D_{GAN} = 2D_{JS} - \log{4}$. Therefore, any parameters that optimize one also optimize the other.} between the joint and the product of marginals.

As all of the derived patch representations are driven to preserve mutual information with the global graph summary, this allows for discovering and preserving similarities on the patch-level---for example, distant nodes with similar structural roles~\citep[which are known to be a strong predictor for many node classification tasks;][]{donnat2018}. Note that this is a ``reversed'' version of the argument given by \citet{hjelm2018learning}: for node classification, our aim is for the \emph{patches} to establish links to similar patches across the graph, rather than enforcing the summary to contain all of these similarities (however, both of these effects should in principle occur simultaneously).

\subsection{Theoretical motivation}

We now provide some intuition that connects the classification error of our discriminator to mutual information maximization on graph representations.

\begin{lemma}
Let $\{{\bf X}^{(k)}\}_{k = 1}^{|{\bf X}|}$ be a set of node representations drawn from an empirical probability distribution of graphs, $p({\bf X})$, with finite number of elements, $|{\bf X}|$, such that $p({\bf X}^{(k)}) = p({\bf X}^{(k')}) \ \forall k, k'$.
Let $\mathcal{R}(\cdot)$ be a deterministic readout function on graphs and $\vec{s}^{(k)} = \mathcal{R}({\bf X}^{(k)})$ be the summary vector of the $k$-th graph, with marginal distribution $p(\vec{s})$.
The optimal classifier between the joint distribution $p({\bf X}, \vec{s})$ and the product of marginals $p({\bf X})p(\vec{s})$, assuming class balance, has an error rate upper bounded by $\mathrm{Err}^* = \frac{1}{2} \sum_{k=1}^{|{\bf X}|} p(\vec{s}^{(k)})^2$. This upper bound is achieved if $\mathcal{R}$ is injective.
\label{lemma}
\end{lemma}
\begin{proof}
Denote by $\mathcal{Q}^{(k)}$ the set of all graphs in the input set that are mapped to $\vec{s}^{(k)}$ by $\mathcal{R}$, i.e. $\mathcal{Q}^{(k)} = \{{\bf X}^{(j)}\ |\ \mathcal{R}({\bf X}^{(j)}) = \vec{s}^{(k)}\}$. As $\mathcal{R}(\cdot)$ is deterministic, samples from the joint, $({\bf X}^{(k)}, \vec{s}^{(k)})$ are drawn from the product of marginals with probability $p(\vec{s}^{(k)}) p({\bf X}^{(k)})$, which decomposes into:
\begin{equation}
p(\vec{s}^{(k)}) \sum_{\vec{s}} p({\bf X}^{(k)}, \vec{s}) = p(\vec{s}^{(k)})p({\bf X}^{(k)}|\vec{s}^{(k)})p(\vec{s}^{(k)}) = \frac{p({\bf X}^{(k)})}{\sum_{{\bf X'}\in\mathcal{Q}^{(k)}} p({\bf X'})} p(\vec{s}^{(k)})^2
\end{equation}
For convenience, let $\rho^{(k)} = \frac{p({\bf X}^{(k)})}{\sum_{{\bf X'}\in\mathcal{Q}^{(k)}} p({\bf X'})}$. As, by definition, ${\bf X}^{(k)}\in\mathcal{Q}^{(k)}$, it holds that $\rho^{(k)} \leq 1$. This probability ratio is maximized at $1$ when $\mathcal{Q}^{(k)} = \{{\bf X}^{(k)}\}$, i.e. when $\mathcal{R}$ is injective for ${\bf X}^{(k)}$.
The probability of drawing any sample of the joint from the product of marginals is then bounded above by $\sum_{k=1}^{|{\bf X}|} p(\vec{s}^{(k)})^2$. 
As the probability of drawing $({\bf X}^{(k)}, \vec{s}^{(k)})$ from the joint is $\rho^{(k)}p(\vec{s}^{(k)}) \geq \rho^{(k)}p(\vec{s}^{(k)})^2$, we know that classifying these samples as coming from the joint has a lower error than classifying them as coming from the product of marginals.
The error rate of such a classifier is then the probability of drawing a sample from the joint as a sample from product of marginals under the mixture probability, which we can bound by $\mathrm{Err} \leq \frac{1}{2} \sum_{k=1}^{|{\bf X}|} p(\vec{s}^{(k)})^2$, with the upper bound achieved, as above, when $\mathcal{R}(\cdot)$ is injective for all elements of $\{{\bf X}^{(k)}\}$.
\end{proof}
It may be useful to note that $\frac{1}{2|{\bf X}|} \leq \mathrm{Err}^* \leq \frac{1}{2}$. The first result is obtained via a trivial application of Jensen's inequality, while the other extreme is reached only in the edge case of a constant readout function (when every example from the joint is also an example from the product of marginals, so no classifier performs better than chance).
\begin{cor}
From now on, assume that the readout function used, $\mathcal{R}$, is injective. Assume the number of allowable states in the space of $\vec{s}$, $|\vec{s}|$, is greater than or equal to $|{\bf X}|$. Then, for $\vec{s}^{\star}$, the optimal summary under the classification error of an optimal classifier between the joint and the product of marginals, it holds that $|\vec{s}^{\star}| = |{\bf X}|$.
\end{cor}
\begin{proof}
By injectivity of $\mathcal{R}$, we know that $\vec{s}^{\star} = \argmin_{\vec{s}} \mathrm{Err}^*$.
As the upper error bound, $\mathrm{Err}^*$, is a simple geometric sum, we know that this is minimized when $p(\vec{s}^{(k)})$ is uniform.
As $\mathcal{R}(\cdot)$ is deterministic, this implies that each potential summary state would need to be used at least once. Combined with the condition $|\vec{s}| \geq |{\bf X}|$, we conclude that the optimum has $|\vec{s}^{\star}| = |{\bf X}|$.
\end{proof}

\begin{theo}
$\vec{s}^{\star} = \argmax_{\vec{s}} \mathrm{MI}({\bf X}; \vec{s})$, where $\mathrm{MI}$ is mutual information.
\label{theorem}
\end{theo}
\begin{proof}
This follows from the fact that the mutual information is invariant under invertible transforms.
As $|\vec{s}^{\star}| = |{\bf X}|$ and $\mathcal{R}$ is injective, it has an inverse function, $\mathcal{R}^{-1}$.
It follows then that, for any $\vec{s}$, $\mathrm{MI}({\bf X}; \vec{s}) \leq  H({\bf X}) =\mathrm{MI}({\bf X}; {\bf X}) = \mathrm{MI}({\bf X}; \mathcal{R}({\bf X})) = \mathrm{MI}({\bf X}; \vec{s}^{\star})$, where $H$ is entropy.
\end{proof}

Theorem~\ref{theorem} shows that for finite input sets and suitable deterministic functions, minimizing the classification error in the discriminator can be used to maximize the mutual information between the input and output.
However, as was shown in \citet{hjelm2018learning}, this objective alone is not enough to learn useful representations.
As in their work, we discriminate between the global summary vector and local high-level representations.

\begin{theo}
Let ${\bf X}^{(k)}_i = \{\vec{x}_j\}_{j \in n({\bf X}^{(k)}, i)}$ be the neighborhood of the node $i$ in the $k$-th graph that collectively maps to its high-level features, $\vec{h}_i = \mathcal{E}({\bf X}^{(k)}_i)$, where $n$ is the neighborhood function that returns the set of neighborhood indices of node $i$ for graph ${\bf X}^{(k)}$, and $\mathcal{E}$ is a deterministic encoder function.
Let us assume that $|{\bf X}_i| = |{\bf X}| = |\vec{s}| \geq |\vec{h}_i|$.
Then, the $\vec{h}_i$ that minimizes the classification error between $p(\vec{h}_i,\vec{s})$ and $p(\vec{h}_i)p(\vec{s})$ also maximizes $\mathrm{MI}({\bf X}^{(k)}_i; \vec{h}_i)$.
\end{theo}
\begin{proof}
Given our assumption of $|{\bf X}_i| = |\vec{s}|$, there exists an inverse ${\bf X}_i = \mathcal{R}^{-1}(\vec{s})$, and therefore $\vec{h}_i = \mathcal{E}(\mathcal{R}^{-1}(\vec{s}))$, i.e. there exists a deterministic function ($\mathcal{E}\circ\mathcal{R}^{-1}$) mapping $\vec{s}$ to $\vec{h}_i$.
The optimal classifier between the joint $p(\vec{h}_i, \vec{s})$ and the product of marginals $p(\vec{h}_i)p(\vec{s})$ then has (by Lemma 1) an error rate upper bound of $\mathrm{Err}^* = \frac{1}{2} \sum_{k=1}^{|{\bf X}|} p(\vec{h}_i^{(k)})^2$.
Therefore (as in Corollary 1), for the optimal $\vec{h}_i$, $|\vec{h}_i| = |{\bf X}_i|$, which by the same arguments as in Theorem 1 maximizes the mutual information between the neighborhood and high-level features, $\mathrm{MI}({\bf X}^{(k)}_i; \vec{h}_i)$.
\end{proof}

This motivates our use of a classifier between samples from the joint and the product of marginals, and using the binary cross-entropy (BCE) loss to optimize this classifier is well-understood in the context of neural network optimization.

\subsection{Overview of DGI}\label{sec:algo}

Assuming the single-graph setup (i.e., $({\bf X}, {\bf A})$ provided as input), we will now summarize the steps of the Deep Graph Infomax procedure:
\begin{enumerate}
	\item Sample a negative example by using the corruption function: $({\bf \widetilde{X}}, {\bf \widetilde{A}}) \sim \mathcal{C}({\bf X}, {\bf A})$.
	\item Obtain patch representations, $\vec{h}_i$ for the input graph by passing it through the encoder: ${\bf H} = \mathcal{E}({\bf X}, {\bf A}) = \{\vec{h}_1, \vec{h}_2, \dots, \vec{h}_N\}$.
	\item Obtain patch representations, $\vec{\widetilde{h}}_j$ for the negative example by passing it through the encoder: ${\bf \widetilde{H}} = \mathcal{E}({\bf \widetilde{X}}, {\bf \widetilde{A}}) = \{\vec{\widetilde{h}}_1, \vec{\widetilde{h}}_2, \dots, \vec{\widetilde{h}}_M\}$.
	\item Summarize the input graph by passing its patch representations through the readout function: $\vec{s} = \mathcal{R}({\bf H})$.
	\item Update parameters of $\mathcal{E}$, $\mathcal{R}$ and $\mathcal{D}$ by applying gradient descent to maximize Equation \ref{eqngan}.
\end{enumerate}

\begin{figure}
\centering 
\includegraphics[width=1.0\linewidth]{DGI.pdf} 
\caption{A high-level overview of Deep Graph Infomax. Refer to Section \ref{sec:algo} for more details.}\label{fig:dgi}
\end{figure}

This algorithm is fully summarized by Figure \ref{fig:dgi}.

\section{Classification performance}

We have assessed the benefits of the representation learnt by the DGI encoder on a variety of node classification tasks (transductive as well as inductive), obtaining competitive results. In each case, DGI was used to learn patch representations in a fully unsupervised manner, followed by evaluating the node-level classification utility of these representations. This was performed by directly using these representations to train and test a simple linear (logistic regression) classifier. 



\subsection{Datasets}

We follow the experimental setup described in \citet{kipf2016semi} and \citet{hamilton2017inductive} on the following benchmark tasks: (1) classifying research papers into topics on the Cora, Citeseer and Pubmed citation networks \citep{sen2008collective}; (2) predicting the community structure of a social network modeled with Reddit posts; and (3) classifying protein roles within protein-protein interaction (PPI) networks \citep{zitnik2017predicting}, requiring generalisation to unseen networks. 

\begin{table}
\small
\caption{Summary of the datasets used in our experiments.}
\label{datasets}
\begin{center}
\begin{tabular}{c c c c c c c}
\toprule 
{\bf Dataset} & {\bf Task} & {\bf Nodes} & {\bf Edges} & {\bf Features} &  {\bf Classes} & {\bf Train/Val/Test Nodes} \\ \midrule
{\bf Cora} & Transductive & 2,708 & 5,429 & 1,433 & 7 & 140/500/1,000\\
{\bf Citeseer} & Transductive & 3,327 & 4,732 & 3,703 & 6 & 120/500/1,000 \\
{\bf Pubmed} & Transductive & 19,717 & 44,338 & 500 & 3 & 60/500/1,000\\
{\bf Reddit} & Inductive & 231,443 & 11,606,919 & 602 & 41 & 151,708/23,699/55,334\\
\multirow{2}{*}{\bf PPI} & \multirow{2}{*}{Inductive} & 56,944 & \multirow{2}{*}{818,716} & \multirow{2}{*}{50} & 121 & 44,906/6,514/5,524 \\
& & (24 graphs) & & & (multilbl.) & (20/2/2 graphs)\\
\bottomrule
\end{tabular}
\end{center}
\end{table}

Further information on the datasets may be found in Table \ref{datasets} and Appendix \ref{app:data}.

\subsection{Experimental setup}\label{sec:expt}

For each of three experimental settings (transductive learning, inductive learning on large graphs, and multiple graphs), we employed distinct encoders and corruption functions appropriate to that setting (described below). 


\xhdr{Transductive learning} 
For the transductive learning tasks (Cora, Citeseer and Pubmed), our encoder is a one-layer Graph Convolutional Network (GCN) model \citep{kipf2016semi}, with the following propagation rule:
\begin{equation}
\label{eqngcn}
	\mathcal{E}({\bf X}, {\bf A}) = \sigma\left({\bf \hat{D}}^{-\frac{1}{2}}{\bf \hat{A}}{\bf \hat{D}}^{-\frac{1}{2}}{\bf X}{\bf \Theta}\right)
\end{equation}
where ${\bf \hat{A}} = {\bf A} + {\bf I}_N$ is the adjacency matrix with inserted self-loops and $\bf \hat{D}$ is its corresponding degree matrix; i.e. $\hat{D}_{ii} = \sum_j \hat{A}_{ij}$. For the nonlinearity, $\sigma$, we have applied the parametric ReLU (PReLU) function \citep{he2015delving}, and ${\bf \Theta} \in \mathbb{R}^{F \times F'}$ is a learnable linear transformation applied to every node, with $F' = 512$ features being computed (specially, $F' = 256$ on Pubmed due to memory limitations).

The corruption function used in this setting is designed to encourage the representations to properly encode structural similarities of different nodes in the graph; for this purpose, $\mathcal{C}$ preserves the original adjacency matrix (${\bf \widetilde{A}} = {\bf A}$), whereas the corrupted features, $\bf \widetilde{X}$, are obtained by row-wise shuffling of ${\bf X}$. That is, the corrupted graph consists of exactly the same nodes as the original graph, but they are located in different places in the graph, and will therefore receive different patch representations.  We demonstrate DGI is stable to other choices of corruption functions in Appendix \ref{app: corruption}, but we find those that preserve the graph structure result in the strongest features.

\xhdr{Inductive learning on large graphs}
For inductive learning, we may no longer use the GCN update rule in our encoder (as the learned filters rely on a fixed and known adjacency matrix); instead, we apply the \emph{mean-pooling} propagation rule, as used by GraphSAGE-GCN \citep{hamilton2017inductive}:
\begin{equation}
\label{eqnmeanp}
	\text{MP}({\bf X}, {\bf A}) = {\bf \hat{D}}^{-1}{\bf \hat{A}}{\bf X}{\bf \Theta}
\end{equation} 
with parameters defined as in Equation \ref{eqngcn}. Note that multiplying by ${\bf \hat{D}}^{-1}$ actually performs a normalized sum (hence the mean-pooling). While Equation \ref{eqnmeanp} explicitly specifies the adjacency and degree matrices, \emph{they are not needed}: identical inductive behaviour may be observed by a \emph{constant} attention mechanism across the node's neighbors, as used by the Const-GAT model \citep{velickovic2018graph}.

For Reddit, our encoder is a three-layer mean-pooling model with skip connections \citep{he2016deep}:
\begin{equation}
    \widetilde{\text{MP}}({\bf X}, {\bf A}) = \sigma\left({\bf X}{\bf \Theta'}\|\text{MP}({\bf X}, {\bf A})\right) \qquad \mathcal{E}({\bf X}, {\bf A}) = \widetilde{\text{MP}}_3(\widetilde{\text{MP}}_2(\widetilde{\text{MP}}_1({\bf X}, {\bf A}), {\bf A}), {\bf A})
\end{equation}
where $\|$ is featurewise concatenation (i.e. the central node and its neighborhood are handled separately). We compute $F'=512$ features in each MP layer, with the PReLU activation for $\sigma$.
\begin{figure}
    \centering
    \includegraphics[width=\linewidth]{flat-DGI.pdf}
    \caption{The DGI setup on large graphs (such as Reddit). Summary vectors, $\vec{s}$, are obtained by combining several subsampled patch representations, $\vec{h}_i$ (here obtained by sampling three and two neighbors in the first and second level, respectively).}
    \label{fig:subdgi}
\end{figure}

Given the large scale of the dataset, it will not fit into GPU memory entirely. Therefore, we use the subsampling approach of \cite{hamilton2017inductive}, where a minibatch of nodes is first selected, and then a subgraph centered around each of them is obtained by \emph{sampling node neighborhoods with replacement}. Specifically, we sample 10, 10 and 25 neighbors at the first, second and third level, respectively---thus, each subsampled patch has 1 + 10 + 100 + 2500 = 2611 nodes. Only the computations necessary for deriving the central node $i$'s patch representation, $\vec{h}_i$, are performed. These representations are then used to derive the summary vector, $\vec{s}$, for the minibatch (Figure \ref{fig:subdgi}). We used minibatches of 256 nodes throughout training.

To define our corruption function in this setting, we use a similar approach as in the transductive tasks, but treat each subsampled patch as a separate graph to be corrupted (i.e., we row-wise shuffle the feature matrices within a subsampled patch). Note that this may very likely cause the central node's features to be swapped out for a sampled neighbor's features, further encouraging diversity in the negative samples. The patch representation obtained in the central node is then submitted to the discriminator.

\xhdr{Inductive learning on multiple graphs} 
For the PPI dataset, inspired by previous successful supervised architectures \citep{velickovic2018graph}, our encoder is a three-layer mean-pooling model with dense skip connections \citep{he2016deep,huang2017densely}:
\begin{align}
	{\bf H}_1 &= \sigma\left(\text{MP}_1({\bf X}, {\bf A})\right)\\
	{\bf H}_2 &= \sigma\left(\text{MP}_2({\bf H}_1 + {\bf X}{\bf W}_{\text{skip}}, {\bf A})\right)\\
	\mathcal{E}({\bf X}, {\bf A}) &= \sigma\left(\text{MP}_3({\bf H}_2 + {\bf H}_1 + {\bf X}{\bf W}_{\text{skip}}, {\bf A})\right)
\end{align} 
where ${\bf W}_{\text{skip}}$ is a learnable projection matrix, and $\text{MP}$ is as defined in Equation \ref{eqnmeanp}. We compute $F' = 512$ features in each MP layer, using the PReLU activation for $\sigma$.

In this multiple-graph setting, we opted to use \emph{randomly sampled training graphs} as negative examples (i.e., our corruption function simply samples a different graph from the training set). We found this method to be the most stable, considering that over 40\% of the nodes have all-zero features in this dataset. To further expand the pool of negative examples, we also apply dropout \citep{srivastava2014dropout} to the input features of the sampled graph. We found it beneficial to standardize the learnt embeddings across the training set prior to providing them to the logistic regression model.

\xhdr{Readout, discriminator, and additional training details}
Across all three experimental settings, we employed identical readout functions and discriminator architectures. 

For the readout function, we use a simple averaging of all the nodes' features:
\begin{equation}
	\mathcal{R}({\bf H}) = \sigma\left(\frac{1}{N}\sum_{i=1}^N \vec{h}_i	\right)
\end{equation}
where $\sigma$ is the logistic sigmoid nonlinearity. While we have found this readout to perform the best across all our experiments, we assume that its power will diminish with the increase in graph size, and in those cases, more sophisticated readout architectures such as set2vec \citep{vinyals2015order} or DiffPool \citep{ying2018hierarchical} are likely to be more appropriate.

The discriminator scores summary-patch representation pairs by applying a simple bilinear scoring function (similar to the scoring used by \cite{oord2018representation}):
\begin{equation}
	\mathcal{D}(\vec{h}_i, \vec{s}) = \sigma\left(\vec{h}_i^T{\bf W}\vec{s}\right)
\end{equation}
Here, ${\bf W}$ is a learnable scoring matrix and $\sigma$ is the logistic sigmoid nonlinearity, used to convert scores into probabilities of $(\vec{h}_i, \vec{s})$ being a positive example.

All models are initialized using Glorot initialization \citep{glorot2010understanding} and trained to maximize the mutual information provided in Equation \ref{eqngan} on the available nodes (all nodes for the transductive, and training nodes only in the inductive setup) using the Adam SGD optimizer \citep{kingma2014adam} with an initial learning rate of 0.001 (specially, $10^{-5}$ on Reddit). On the transductive datasets, we use an early stopping strategy on the observed \emph{training} loss, with a patience of 20 epochs\footnote{
A reference DGI implementation may be found at \url{https://github.com/PetarV-/DGI}.}. On the inductive datasets we train for a fixed number of epochs (150 on Reddit, 20 on PPI).



\begin{table}[ht]
\caption{Summary of results in terms of classification accuracies (on transductive tasks) or micro-averaged F$_1$ scores (on inductive tasks). In the first column, we highlight the kind of data available to each method during training (${\bf X}$: features, ${\bf A}$: adjacency matrix, ${\bf Y}$: labels). ``GCN'' corresponds to a two-layer DGI encoder trained in a supervised manner.}
\label{transtable}
\begin{center}
\begin{tabular}{l l l l l}
\multicolumn{5}{c}{\textbf{\emph{Transductive}}}\\
\toprule
{\bf Available data} & {\bf Method} & {\bf Cora} & {\bf Citeseer} & {\bf Pubmed}\\ \midrule
${\bf X}$ & Raw features & 47.9 $\pm$ 0.4\% & 49.3 $\pm$ 0.2\% & 69.1 $\pm$ 0.3\%\\
${\bf A}, {\bf Y}$ & LP \citep{zhu2003semi} & 68.0\% & 45.3\% & 63.0\%\\
${\bf A}$ & DeepWalk \citep{perozzi2014deepwalk} & 67.2\% & 43.2\% & 65.3\%\\
${\bf X}, {\bf A}$ & DeepWalk + features & 70.7 $\pm$ 0.6\% & 51.4 $\pm$ 0.5\% & 74.3 $\pm$ 0.9\%\\\midrule
${\bf X}, {\bf A}$ & Random-Init (ours) & 69.3 $\pm$ 1.4\% & 61.9 $\pm$ 1.6\% & 69.6 $\pm$ 1.9\% \\
${\bf X}, {\bf A}$ & {\bf DGI} (ours) & {\bf 82.3} $\pm$ 0.6\% & {\bf 71.8} $\pm$ 0.7\% & {\bf 76.8} $\pm$ 0.6\%\\\midrule
${\bf X}, {\bf A}, {\bf Y}$ & GCN \citep{kipf2016semi} & 81.5\% & 70.3\% & 79.0\%\\
${\bf X}, {\bf A}, {\bf Y}$ & Planetoid \citep{yang2016revisiting} & 75.7\% & 64.7\% & 77.2\%\\
\bottomrule \end{tabular}
\begin{tabular}{l l l l}
\\
\multicolumn{4}{c}{\textbf{\emph{Inductive}}}\\
\toprule 
{\bf Available data} & {\bf Method} & {\bf Reddit} & {\bf PPI}\\ \midrule
${\bf X}$ & Raw features & 0.585 & 0.422 \\
${\bf A}$ & DeepWalk \citep{perozzi2014deepwalk} & 0.324 & --- \\
${\bf X}, {\bf A}$ & DeepWalk + features & 0.691 & --- \\ \midrule
${\bf X}, {\bf A}$ & GraphSAGE-GCN \citep{hamilton2017inductive} & 0.908 & 0.465 \\
${\bf X}, {\bf A}$ & GraphSAGE-mean \citep{hamilton2017inductive} & 0.897 & 0.486 \\
${\bf X}, {\bf A}$ & GraphSAGE-LSTM \citep{hamilton2017inductive} & 0.907 & 0.482 \\
${\bf X}, {\bf A}$ & GraphSAGE-pool \citep{hamilton2017inductive} & 0.892 & 0.502 \\\midrule
${\bf X}, {\bf A}$ & Random-Init (ours) & 0.933 $\pm$ 0.001 & {0.626} $\pm$ 0.002 \\
${\bf X}, {\bf A}$ & {\bf DGI} (ours) & {\bf 0.940} $\pm$ 0.001 & {\bf 0.638} $\pm$ 0.002  \\\midrule
${\bf X}, {\bf A}, {\bf Y}$ & FastGCN \citep{chen2018fastgcn} & 0.937 & ---\\
${\bf X}, {\bf A}, {\bf Y}$ & Avg. pooling \citep{zhang2018gaan} & 0.958 $\pm$ 0.001 & 0.969 $\pm$ 0.002\\
\bottomrule
\end{tabular}
\end{center}
\end{table}

\subsection{Results}
The results of our comparative evaluation experiments are summarized in Table \ref{transtable}. 

For the transductive tasks, we report the mean classification accuracy (with standard deviation) on the test nodes of our method after 50 runs of training (followed by logistic regression), and reuse the metrics already reported in \cite{kipf2016semi} for the performance of DeepWalk and GCN, as well as Label Propagation (LP) \citep{zhu2003semi} and Planetoid \citep{yang2016revisiting}---a representative supervised random walk method. Specially, we provide results for training the logistic regression on raw input features, as well as DeepWalk with the input features concatenated. 

For the inductive tasks, we report the micro-averaged F$_1$ score on the (unseen) test nodes, averaged after 50 runs of training, and reuse the metrics already reported in \cite{hamilton2017inductive} for the other techniques. Specifically, as our setup is unsupervised, we compare against the unsupervised GraphSAGE approaches. We also provide supervised results for two related architectures---FastGCN \citep{chen2018fastgcn} and Avg. pooling \citep{zhang2018gaan}.

Our results demonstrate strong performance being achieved across all five datasets. We particularly note that the DGI approach is competitive with the results reported for the GCN model \emph{with the supervised loss}, even exceeding its performance on the Cora and Citeseer datasets. We assume that these benefits stem from the fact that, indirectly, the DGI approach allows for every node to have access to structural properties of the entire graph, whereas the supervised GCN is limited to only two-layer neighborhoods (by the extreme sparsity of the training signal and the corresponding threat of overfitting). It should be noted that, while we are capable of outperforming equivalent supervised encoder architectures, our performance still does not surpass the current supervised transductive state of the art (which is held by methods such as GraphSGAN \citep{ding2018semi}). We further observe that the DGI method successfully outperformed all the competing unsupervised GraphSAGE approaches on the Reddit and PPI datasets---thus verifying the potential of methods based on local mutual information maximization in the inductive node classification domain. Our Reddit results are competitive with the supervised state of the art, whereas on PPI the gap is still large---we believe this can be attributed to the extreme sparsity of available node features (over 40\% of the nodes having all-zero features), that our encoder heavily relies on.

We note that a \emph{randomly initialized} graph convolutional network may already extract highly useful features and represents a strong baseline---a well-known fact, considering its links to the Weisfeiler-Lehman graph isomorphism test \citep{weisfeiler1968reduction}, that have already been highlighted and analyzed by \cite{kipf2016semi} and \cite{hamilton2017inductive}. As such, we also provide, as \emph{Random-Init}, the logistic regression performance on embeddings obtained from a randomly initialized encoder. Besides demonstrating that DGI is able to further improve on this strong baseline, it particularly reveals that, on the inductive datasets, previous random walk-based negative sampling methods may have been ineffective for learning appropriate features for the classification task.

Lastly, it should be noted that deeper encoders correspond to more pronounced \emph{mixing} between recovered patch representations, reducing the effective variability of our positive/negative examples' pool. We believe that this is the reason why shallower architectures performed better on some of the datasets. While we cannot say that these trends will hold in general, with the DGI loss function we generally found benefits from employing \emph{wider}, rather than \emph{deeper} models.

\section{Qualitative analysis}
We performed a diverse set of analyses on the embeddings learnt by the DGI algorithm in order to better understand the properties of DGI. We focus our analysis exclusively on the Cora dataset (as it has the smallest number of nodes, significantly aiding clarity).

\begin{figure}
\centering
\begin{subfigure}{0.33\textwidth}
  \centering
  \includegraphics[width=1.0\textwidth]{cora_raw_features_tsne.png}
\end{subfigure}\begin{subfigure}{0.33\textwidth}
  \centering
  \includegraphics[width=1.0\textwidth]{cora_random_init_features_tsne.png}
\end{subfigure}\begin{subfigure}{0.33\textwidth}
  \centering
  \includegraphics[width=1.0\textwidth]{cora_tsne.png}
\end{subfigure}
\caption{t-SNE embeddings of the nodes in the Cora dataset from the raw features ({\bf left}), features from a randomly initialized DGI model ({\bf middle}), and a learned DGI model ({\bf right}). The clusters of the learned DGI model's embeddings are clearly defined, with a Silhouette score of 0.234.}
\label{fig:cora_raw_and_random_features}
\end{figure}

A standard set of ``evolving'' t-SNE plots \citep{maaten2008visualizing} of the embeddings is given in Figure \ref{fig:cora_raw_and_random_features}. As expected given the quantitative results, the learnt embeddings' 2D projections exhibit discernible clustering in the 2D projected space (especially compared to the raw features and Random-Init), which respects the seven topic classes of Cora. The projection obtains a Silhouette score \citep{rousseeuw1987silhouettes} of 0.234, which compares favorably with the previous reported score of 0.158 for Embedding Propagation \citep{duran2017learning}.

We ran further analyses, revealing insights into DGI's mechanism of learning, isolating \emph{biased} embedding dimensions for pushing the negative example scores down and using the remainder to encode useful information about positive examples. We leverage these insights to retain competitive performance to the supervised GCN even after \emph{half} the dimensions are removed from the patch representations provided by the encoder. These---and several other---qualitative and ablation studies can be found in Appendix \ref{app:quali}.











\section{Conclusions}

We have presented Deep Graph Infomax (DGI), a new approach for learning unsupervised representations on graph-structured data. By leveraging local mutual information maximization across the graph's patch representations, obtained by powerful graph convolutional architectures, we are able to obtain node embeddings that are mindful of the global structural properties of the graph. This enables competitive performance across a variety of both transductive and inductive classification tasks, at times even outperforming relevant \emph{supervised} architectures.

\newpage
\subsubsection*{Acknowledgments}
We would like to thank the developers of PyTorch \citep{paszke2017automatic}. PV and PL have received funding from the European Union's Horizon 2020 research and innovation programme PROPAG-AGEING under grant agreement No 634821. We specially thank Hugo Larochelle and Jian Tang for the extremely useful discussions, and Andreea Deac, Arantxa Casanova, Ben Poole, Graham Taylor, Guillem Cucurull, Justin Gilmer, Nithium Thain and Zhaocheng Zhu for reviewing the paper prior to submission.



\begin{comment}
\begin{lemma}
Let $\{{\bf X}^{(k)}\}_{k = 1}^{|{\bf X}|}$ be a set of node representations drawn from an empirical probability distribution of graphs, $p({\bf X})$, with finite number of elements, $|{\bf X}|$, such that $p({\bf X}^{(k)}) = p({\bf X}^{(k')}) \ \forall k, k'$.
Let $\mathcal{S}(\cdot)$ be a deterministic function on graphs and $\vec{s} = \mathcal{S}({\bf X})$ be the summary vector with marginal distribution $p(\vec{s})$.
The optimal classifier between a balanced mixture between the joint distribution $p({\bf X}, \vec{s})$ and the product of marginals $p({\bf X})p(\vec{s})$ has an error rate of $\mathrm{Err} = \frac{1}{2} \sum_{k=1}^{|{\bf X}|} p(\vec{s}^{(k)})^2$.
\label{lemma}
\end{lemma}
\begin{proof}
As $\mathcal{S}(\cdot)$ is deterministic, samples from the joint, $({\bf X}^{(k)}, \vec{s}^{(k)})$ are drawn from the product of marginals with probability $p(\vec{s}^{(k)}) p({\bf X}^{(k)}) =  p(\vec{s}^{(k)}) \sum_{k'} p({\bf X}^{(k)}, \vec{s}^{(k')}) = \sum_{k'} \delta_{k, k'} p(\vec{s}^{(k')}) = p(\vec{s}^{(k)}) p(\vec{s}^{(k)}) = p(\vec{s}^{(k)})^2$, where $\delta$ is the Dirac delta.
The probability of drawing any sample of the joint from the product of marginals is then $\sum_{k=1}^{|{\bf X}|} p(\vec{s}^{(k)})^2$. 
As the probability of drawing $({\bf X}^{(k)}, \vec{s}^{(k)})$ from the joint is $p(\vec{s}^{(k)})$, we know that classifying these samples as coming from the joint has a lower error than classifying them as coming from the product of marginals.
The error rate of such a classifier then is the probability of drawing a sample from the joint as a sample from product of marginals under the mixture probability, or $\mathrm{Err} = \frac{1}{2} \sum_{k=1}^{|{\bf X}|} p(\vec{s}^{(k)})^2$.
\end{proof}
\end{comment}

\bibliography{iclr2019_conference}
\bibliographystyle{iclr2019_conference}

\appendix

\section{Further dataset details}\label{app:data}

\xhdr{Transductive learning}
We utilize three standard citation network benchmark datasets---Cora, Citeseer and Pubmed \citep{sen2008collective}---and closely follow the transductive experimental setup of \cite{yang2016revisiting}. In all of these datasets, nodes correspond to documents and edges to (undirected) citations. Node features correspond to elements of a bag-of-words representation of a document. Each node has a class label. We allow for only 20 nodes per class to be used for training---however, honouring the transductive setup, the unsupervised learning algorithm has access to all of the nodes' feature vectors. The predictive power of the learned representations is evaluated on 1000 test nodes.

\xhdr{Inductive learning on large graphs}
We use a large graph dataset (231,443 nodes and 11,606,919 edges) of Reddit posts created during September 2014 (derived and preprocessed as in \cite{hamilton2017inductive}). The objective is to predict the posts' community (\emph{``subreddit''}), based on the GloVe embeddings of their content and comments \citep{pennington2014glove}, as well as metrics such as score or number of comments. Posts are linked together in the graph if the same user has commented on both. Reusing the inductive setup of \cite{hamilton2017inductive}, posts made in the first 20 days of the month are used for training, while the remaining posts are used for validation or testing and are \emph{invisible} to the training algorithm.

\xhdr{Inductive learning on multiple graphs}
We make use of a protein-protein interaction (PPI) dataset that consists of graphs corresponding to different human tissues \citep{zitnik2017predicting}. The dataset contains 20 graphs for training, 2 for validation and 2 for testing. Critically, testing graphs remain \emph{completely unobserved} during training. To construct the graphs, we used the preprocessed data provided by~\cite{hamilton2017inductive}. Each node has 50 features that are composed of positional gene sets, motif gene sets and immunological signatures. There are 121 labels for each node set from gene ontology, collected from the Molecular Signatures Database \citep{subramanian2005gene}, and a node can possess several labels simultaneously.

\section{Further qualitative analysis}\label{app:quali}

\begin{figure}
\centering
\begin{subfigure}{0.5\textwidth}
  \centering
  \includegraphics[width=1.0\textwidth]{cora_dis_score_tsne.png}
\end{subfigure}\begin{subfigure}{0.5\textwidth}
  \centering
  \includegraphics[width=1.0\textwidth]{cora_neg_dis_score_tsne.png}
\end{subfigure}
\caption{Discriminator scores, $\mathcal{D}\left(\vec{h}_i, \vec{s}\right)$, attributed to each node in the Cora dataset shown over a t-SNE of the DGI algorithm. Shown for both the original graph ({\bf left}) and a negative sample ({\bf right}).}
\label{fig:cora_dis_score_tsne}
\end{figure}

\xhdr{Visualizing discriminator scores} 
After obtaining the t-SNE visualizations, we turned our attention to the discriminator---and visualized the scores it attached to various nodes, for both the positive and a (randomly sampled) negative example (Figure \ref{fig:cora_dis_score_tsne}). From here we can make an interesting observation---within the ``clusters'' of the learnt embeddings on the positive Cora graph, only a handful of ``hot'' nodes are selected to receive high discriminator scores. This suggests that there may be a clear distinction between embedding dimensions used for discrimination and classification, which we more thoroughly investigate in the next paragraph. In addition, we may observe that, as expected, the model is unable to find any strong structure within a negative example. Lastly, a few negative examples achieve high discriminator scores---a phenomenon caused by the existence of low-degree nodes in Cora (making the probability of a node ending up in an identical context it had in the positive graph non-negligible).

\begin{figure}
\centering
  \includegraphics[width=0.8\textwidth]{embeds.pdf}
  \caption{The learnt embeddings of the highest-scored positive examples (\emph{upper half}), and the lowest-scored negative examples (\emph{lower half}).}
  \label{fig:embeds}
\end{figure}

\begin{figure}
\centering
\includegraphics[width=0.49\linewidth]{classplot.pdf}
\includegraphics[width=0.49\linewidth]{discplot.pdf}
\caption{Classification performance (in terms of test accuracy of logistic regression; {\bf left}) and discriminator performance (in terms of number of poorly discriminated positive/negative examples; {\bf right}) on the learnt DGI embeddings, after removing a certain number of dimensions from the embedding---either starting with most distinguishing ($p\uparrow$) or least distinguishing ($p\downarrow$).}
\label{fig:cora_embs}
\end{figure}

\xhdr{Impact and role of embedding dimensions}
Guided by the previous result, we have visualized the embeddings for the top-scoring positive and negative examples (Figure \ref{fig:embeds}). The analysis revealed existence of distinct dimensions in which both the positive and negative examples are \emph{strongly biased}. We hypothesize that, given the random shuffling, the average \emph{expected} activation of a negative example is zero, and therefore strong biases are required to ``push'' the example down in the discriminator. The positive examples may then use the remaining dimensions to both counteract this bias and encode patch similarity. To substantiate this claim, we order the 512 dimensions based on how distinguishable the positive and negative examples are in them (using $p$-values obtained from a t-test as a proxy). We then remove these dimensions from the embedding, respecting this order---either starting from the most distinguishable ($p\uparrow$) or least distinguishable dimensions ($p\downarrow$)---monitoring how this affects both classification and discriminator performance (Figure \ref{fig:cora_embs}). The observed trends largely support our hypothesis: if we start by removing the biased dimensions first ($p\downarrow$), the classification performance holds up for much longer (allowing us to remove over \emph{half} of the embedding dimensions while remaining competitive to the supervised GCN), and the positive examples mostly remain correctly discriminated until well over half the dimensions are removed.

\section{Robustness to Choice of Corruption Function}\label{app: corruption}
Here, we consider alternatives to our corruption function, $\mathcal{C}$, used to produce negative graphs. We generally find that, for the node classification task, DGI is stable and robust to different strategies. However, for learning graph features towards other kinds of tasks, the design of appropriate corruption strategies remains an area of open research.  

Our corruption function described in Section \ref{sec:expt} preserves the original adjacency matrix (${\bf \widetilde{A}} = {\bf A}$) but corrupts the features, $\bf \widetilde{X}$, via row-wise shuffling of ${\bf X}$. In this case, the negative graph is constrained to be isomorphic to the positive graph, which should not have to be mandatory. We can instead produce a negative graph by directly \emph{corrupting} the adjacency matrix.  

Therefore, we first consider an alternative corruption function $\mathcal{C}$ which preserves the features ($\bf \widetilde{X} = \bf X$) but instead adds or removes edges from the adjacency matrix ($\bf \widetilde{A} \neq \bf A$). This is done by sampling, i.i.d., a \emph{switch} parameter ${\bf\Sigma}_{ij}$, which determines whether to corrupt the adjacency matrix at position $(i, j)$. Assuming a given \emph{corruption rate}, $\rho$, we may define $\mathcal{C}$ as performing the following operations:
\begin{align}
    {\bf\Sigma}_{ij} &\sim \text{Bernoulli}(\rho)\\
    {\bf \widetilde{A}} &= {\bf A} \oplus {\bf\Sigma}
\end{align}
where $\oplus$ is the XOR (exclusive OR) operation.

This alternative strategy produces a negative graph with the same features, but different connectivity.  Here, the corruption rate of $\rho=0$ corresponds to an unchanged adjacency matrix (i.e. the positive and negative graphs are \emph{identical} in this case). In this regime, learning is impossible for the discriminator, and the performance of DGI is in line with a randomly initialized DGI model. At higher rates of noise, however, DGI produces competitive embeddings.

We also consider \textit{simultaneous} feature shuffling ($\bf \widetilde{X} \neq \bf X$) and adjacency matrix perturbation (${\bf \widetilde{A}} \neq {\bf A}$), both as described before. We find that DGI still learns useful features under this compound corruption strategy---as expected, given that feature shuffling is already equivalent to an (isomorphic) adjacency matrix perturbation.

From both studies, we may observe that a certain lower bound on the positive graph perturbation rate is required to obtain competitive node embeddings for the classification task on Cora. Furthermore, the features learned for downstream node classification tasks are most powerful when the negative graph has similar levels of connectivity to the positive graph. 

The classification performance peaks when the graph is perturbed to a reasonably high level, but remains \emph{sparse}; i.e. the mixing between the separate 1-step patches is not substantial, and therefore the pool of negative examples is still \emph{diverse} enough. Classification performance is impacted only marginally at higher rates of corruption---corresponding to \emph{dense} negative graphs, and thus a less rich negative example pool---but still considerably outperforming the unsupervised baselines we have considered. This could be seen as further motivation for relying solely on feature shuffling, without adjacency perturbations---given that feature shuffling is a trivial way to guarantee a diverse set of negative examples, without incurring significant computational costs per epoch.

The results of this study are visualized in Figures \ref{fig:adj_only_corruption} and \ref{fig:adj_corruption}.

\begin{figure}
    \centering
    \includegraphics[width=0.7\linewidth]{corrstudy_1}
    \caption{DGI also works under a corruption function that modifies only the adjacency matrix (${\bf \widetilde{A}} \neq {\bf A}$) on the Cora dataset.  The left range ($\rho \rightarrow 0$) corresponds to no modifications of the adjacency matrix---therein, performance approaches that of the randomly initialized DGI model. As $\rho$ increases, DGI produces more useful features, but ultimately fails to outperform the feature-shuffling corruption function. {\bf N.B.} log scale used for $\rho$.}
    \label{fig:adj_only_corruption}
\end{figure}

\begin{figure}
    \centering
    \includegraphics[width=0.7\linewidth]{corrstudy_2}
    \caption{DGI is stable and robust under a corruption function that modifies \textit{both} the feature matrix ($\bf X \neq \bf \widetilde{X}$) and the adjacency matrix (${\bf \widetilde{A}} \neq {\bf A}$) on the Cora dataset. Corruption functions that preserve sparsity ($\rho\approx \frac{1}{N}$) perform the best. However, DGI still performs well even with large disruptions (where edges are added or removed with probabilities approaching 1). {\bf N.B.} log scale used for $\rho$.}
    \label{fig:adj_corruption}
\end{figure}

 
\end{document}
