\documentclass[11pt] {article}
\usepackage{ amsfonts}
\usepackage{ amsthm}
\usepackage{epsfig}
\usepackage{authblk}
\usepackage{cite}
\usepackage{url}


\usepackage{algorithmic,algorithm}

\usepackage{setspace} \onehalfspacing

\usepackage[english]{babel}

\usepackage[tight]{subfigure}

\usepackage[cmex10]{amsmath}
\usepackage{amsfonts,amssymb}
\interdisplaylinepenalty=2500
\sloppy 

\usepackage{bm}

\usepackage{array}

\usepackage{dsfont}



\usepackage{color}

\usepackage[letterpaper,top=.75in,bottom=.75in,left=0.65in,right=0.65in,bindingoffset=0in]{geometry}




\newcommand{\Reals}     {{{\mathrm I\!R}}}  \newcommand{\Cplx}      {{{\mathsf I}\!\!\!{\mathrm C}}} \newcommand{\NCplx}     {{{\mathcal{CN}}}} \newcommand{\Ints}      {{{\mathbb Z}}} \newcommand{\Rats}      {{{\mathsf I}\!\!\!{\mathrm Q}}}    \newcommand{\Nats}      {{{\mathrm{ I\!N}}}} \newcommand{\Tee}{      {{\mathbb T}}}
\newcommand{\ltwo}      {{\ell_2}}
\newcommand{\lone}      {{\ell_1}}
\newcommand{\Ltwo}      {{\mathbb L}^2}
\newcommand{\LtR}       {\Ltwo(\Reals)}
\newcommand{\Real}[1]   {{\mathrm{Re}\left\{#1\right\}}}
\newcommand{\Imag}[1]   {{\mathrm{Im}\left\{#1\right\}}}
\newcommand{\real}      {{\mathcal{R}} e}
\newcommand{\imag}      {{\mathcal{I}} m}

\newcommand{\ie}        {i.~e., \hspace{2pt}}      \newcommand{\eg}        {e.~g., \hspace{2pt}}      \newcommand{\define}    {\stackrel{\scriptscriptstyle\triangle}{=}}  \newcommand{\D}  {^{\dag}}               \newcommand{\T}  {{\mathsf{T}}}          \newcommand{\ct} {{\mathsf{*}}}          \newcommand{\half}{{{^1\!\!\scriptscriptstyle{/}\!}_2}}       \newcommand{\mrsss}[1]   {{\mathrm{\scriptscriptstyle{#1}}}}  \newcommand{\sth}     {{\mathrm{th}}}    \newcommand{\diag}    {{\mathrm{diag}}}  \newcommand{\sgn}     {{\mathrm{sgn}}}   \newcommand{\tr}      {{\mathrm{tr}}}    \newcommand{\Res}     {{\mathrm{Res}}}   \newcommand{\ld}      {{\mathrm{ld}}}    \newcommand{\barg}    {\overline{\gamma}}     \newcommand{\sqgb}    {\sqrt{\barg}}     \newcommand{\e}       {{\mathrm e}}      \newcommand{\E}       {{\mathrm E}}      \newcommand{\lNZ}     {{\lambda_{\mathsf{NZ}}}} \newcommand{\Nt}      {{N_{\!\mrsss{T}}}}\newcommand{\Nr}      {{N_{\!\mrsss{R}}}}\newcommand{\uple}    {{\mathrm{ul}}}    \newcommand{\upri}    {{\mathrm{ur}}}    \newcommand{\lole}    {{\mathrm{ll}}}    \newcommand{\lori}    {{\mathrm{lr}}}    
\newcommand{\Zrb}     {{\uwti 0}}      \newcommand{\Oneb}    {{\uwti 1}}      
\newcommand{\uwti}[1]{{\mathbf #1}}
\newcommand{\ab}{{\uwti a}}  \newcommand{\Ab}{{\uwti A}}
\newcommand{\bb}{{\uwti b}}  \newcommand{\Bb}{{\uwti B}}
\newcommand{\cb}{{\uwti c}}  \newcommand{\Cb}{{\uwti C}}
\newcommand{\db}{{\uwti d}}  \newcommand{\Db}{{\uwti D}}
\newcommand{\eb}{{\uwti e}}  \newcommand{\Eb}{{\uwti E}}
\newcommand{\fb}{{\uwti f}}  \newcommand{\Fb}{{\uwti F}}
\newcommand{\gb}{{\uwti g}}  \newcommand{\Gb}{{\uwti G}}
\newcommand{\hb}{{\uwti h}}  \newcommand{\Hb}{{\uwti H}}
\newcommand{\ib}{{\uwti i}}  \newcommand{\Ib}{{\uwti I}}
\newcommand{\jb}{{\uwti j}}  \newcommand{\Jb}{{\uwti J}}
\newcommand{\kb}{{\uwti k}}  \newcommand{\Kb}{{\uwti K}}
\newcommand{\lb}{{\uwti l}}  \newcommand{\Lb}{{\uwti L}}
\newcommand{\mb}{{\uwti m}}  \newcommand{\Mb}{{\uwti M}}
\newcommand{\nb}{{\uwti n}}  \newcommand{\Nb}{{\uwti N}}
\newcommand{\ob}{{\uwti o}}  \newcommand{\Ob}{{\uwti O}}
\newcommand{\pb}{{\uwti p}}  \newcommand{\Pb}{{\uwti P}}
\newcommand{\qb}{{\uwti q}}  \newcommand{\Qb}{{\uwti Q}}
\newcommand{\rb}{{\uwti r}}  \newcommand{\Rb}{{\uwti R}}
\renewcommand{\sb}{{\uwti s}}\newcommand{\Sb}{{\uwti S}} \newcommand{\tb}{{\uwti t}}  \newcommand{\Tb}{{\uwti T}}
\newcommand{\ub}{{\uwti u}}  \newcommand{\Ub}{{\uwti U}}
\newcommand{\vb}{{\uwti v}}  \newcommand{\Vb}{{\uwti V}}
\newcommand{\wb}{{\uwti w}}  \newcommand{\Wb}{{\uwti W}}
\newcommand{\xb}{{\uwti x}}  \newcommand{\Xb}{{\uwti X}}
\newcommand{\yb}{{\uwti y}}  \newcommand{\Yb}{{\uwti Y}}
\newcommand{\zb}{{\uwti z}}  \newcommand{\Zb}{{\uwti Z}}

\newcommand{\alphab}      {{\bm \alpha}}          \newcommand{\Alphab}   {{\uwti {\mathrm A}}}
\newcommand{\betab}       {{\bm \beta}}           \newcommand{\Betab}    {{\uwti {\mathrm B}}}
\newcommand{\gammab}      {{\bm \gamma}}          \newcommand{\Gammab}   {{\bm \Gamma}}
\newcommand{\deltab}      {{\bm \delta}}          \newcommand{\Deltab}   {{\bm \Delta}}
\newcommand{\epsilonb}    {{\bm \epsilon}}        \newcommand{\Epsilonb} {{\uwti {\mathrm E}}}
\newcommand{\varepsilonb} {{\bm \varepsilon}}
\newcommand{\vepsilonb}   {{\bm \varepsilon}}
\newcommand{\zetab}       {{\bm \zeta}}           \newcommand{\Zetab}    {{\uwti {\mathrm Z}}}
\newcommand{\etab}        {{\bm \eta}}            \newcommand{\Etab}     {{\uwti {\mathrm H}}}
\newcommand{\thetab}      {{\bm \theta}}          \newcommand{\Thetab}   {{\bm \Theta}}
\newcommand{\varthetab}   {{\bm \vartheta}}
\newcommand{\vthetab}     {{\bm \vartheta}}
\newcommand{\iotab}       {{\bm \iota}}           \newcommand{\Iotab}    {{\uwti {\mathrm I}}}
\newcommand{\kappab}      {{\bm \kappa}}          \newcommand{\Kappab}   {{\uwti {\mathrm K}}}
\newcommand{\lambdab}     {{\bm \lambda}}         \newcommand{\Lambdab}  {{\bm \Lambda}}
\newcommand{\mub}         {{\bm \mu}}             \newcommand{\Mub}      {{\uwti {\mathrm M}}}
\newcommand{\nub}         {{\bm \nu}}             \newcommand{\Nub}      {{\uwti {\mathrm N}}}
\newcommand{\xib}         {{\bm \xi}}             \newcommand{\Xib}      {{\bm \Xi}}
\newcommand{\omicronb}    {{\uwti {\mathrm o}}} \newcommand{\Omicronb} {{\uwti {\mathrm O}}}
\newcommand{\pib}         {{\bm \pi}}             \newcommand{\Pib}      {{\bm \Pi}}
\newcommand{\varpib}      {{\bm \varpi}}
\newcommand{\vpib}        {{\bm \varpi}}
\newcommand{\rhob}        {{\bm \rho}}            \newcommand{\Rhob}     {{\uwti {\mathrm P}}}
\newcommand{\varrhob}     {{\bm \varrho}}
\newcommand{\vrhob}       {{\bm \varrho}}
\newcommand{\sigmab}      {{\bm \sigma}}          \newcommand{\Sigmab}   {\uwti{\mathnormal\Sigma}}
\newcommand{\varsigmab}   {{\bm \varsigma}}
\newcommand{\vsigmab}     {{\bm \varsigma}}
\newcommand{\taub}        {{\bm \tau}}            \newcommand{\Taub}     {{\uwti {\mathrm T}}}
\newcommand{\upsilonb}    {{\bm \upsilon}}        \newcommand{\Upsilonb} {{\bm \Upsilon}}
\newcommand{\phib}        {{\bm \phi}}            \newcommand{\Phib}     {{\bm \Phi}}
\newcommand{\varphib}     {{\bm \varphi}}
\newcommand{\vphib}       {{\bm \varphi}}
\newcommand{\chib}        {{\bm \chi}}            \newcommand{\Chib}     {{\uwti {\mathrm X}}}
\newcommand{\psib}        {{\bm \psi}}            \newcommand{\Psib}     {{\bm \Psi}}
\newcommand{\omegab}      {{\bm \omega}}          \newcommand{\Omegab}   {{\bm \Omega}}


\newcommand{\Ac} {{\mathcal A}}         \newcommand{\Ak} {{\bm {\mathcal A}}}
\newcommand{\Bc} {{\mathcal B}}         \newcommand{\Bk} {{\bm {\mathcal B}}}
\newcommand{\Cc} {{\mathcal C}}         \newcommand{\Ck} {{\bm {\mathcal C}}}
\newcommand{\Dc} {{\mathcal D}}         \newcommand{\Dk} {{\bm {\mathcal D}}}
\newcommand{\Ec} {{\mathcal E}}         \newcommand{\Ek} {{\bm {\mathcal E}}}
\newcommand{\Fc} {{\mathcal F}}         \newcommand{\Fk} {{\bm {\mathcal F}}}
\newcommand{\Gc} {{\mathcal G}}         \newcommand{\Gk} {{\bm {\mathcal G}}}
\newcommand{\Hc} {\uwti{\mathcal H}}         \newcommand{\Hk} {{\bm {\mathcal H}}}
\newcommand{\Ic} {{\mathcal I}}         \newcommand{\Ik} {{\bm {\mathcal I}}}
\newcommand{\Jc} {{\mathcal J}}         \newcommand{\Jk} {{\bm {\mathcal J}}}
\newcommand{\Kc} {{\mathcal K}}         \newcommand{\Kk} {{\bm {\mathcal K}}}
\newcommand{\Lc} {{\mathcal L}}         \newcommand{\Lk} {{\bm {\mathcal L}}}
\newcommand{\Mc} {{\mathcal M}}         \newcommand{\Mk} {{\bm {\mathcal M}}}
\newcommand{\Nc} {{\mathcal N}}         \newcommand{\Nk} {{\bm {\mathcal N}}}
\newcommand{\Oc} {{\mathcal O}}         \newcommand{\Ok} {{\bm {\mathcal O}}}
\newcommand{\Pc} {{\mathcal P}}         \newcommand{\Pk} {{\bm {\mathcal P}}}
\newcommand{\Qc} {{\mathcal Q}}         \newcommand{\Qk} {{\bm {\mathcal Q}}}
\newcommand{\Rc} {{\mathcal R}}         \newcommand{\Rk} {{\bm {\mathcal R}}}
\newcommand{\Sc} {{\mathcal S}}         \newcommand{\Sk} {{\bm {\mathcal S}}}
\newcommand{\Tc} {{\mathcal T}}         \newcommand{\Tk} {{\bm {\mathcal T}}}
\newcommand{\Uc} {{\mathcal U}}         \newcommand{\Uk} {{\bm {\mathcal U}}}
\newcommand{\Vc} {{\mathcal V}}         \newcommand{\Vk} {{\bm {\mathcal V}}}
\newcommand{\Wc} {{\mathcal W}}         \newcommand{\Wk} {{\bm {\mathcal W}}}
\newcommand{\Xc} {{\mathcal X}}         \newcommand{\Xk} {{\bm {\mathcal X}}}
\newcommand{\Yc} {{\mathcal Y}}         \newcommand{\Yk} {{\bm {\mathcal Y}}}
\newcommand{\Zc} {{\mathcal Z}}         \newcommand{\Zk} {{\bm {\mathcal Z}}}


\newcommand{\Grb}   {{\uwti {\mathrm V}}}
\newcommand{\Pulk} {{\underline{{\bm {\mathcal P}}}}}
\newcommand{\Qulk} {{\underline{{\bm {\mathcal Q}}}}}
\newcommand{\Culk} {{\underline{{\bm {\mathcal C}}}}}
\newcommand{\Mulk} {{\underline{{\bm {\mathcal M}}}}}
\newcommand{\Bulk} {{\underline{{\bm {\mathcal B}}}}}
\newcommand{\Tulk} {{\underline{{\bm {\mathcal T}}}}}
\newcommand{\Iulk} {{\underline{{\bm {\mathcal I}}}}}
\newcommand{\Aulc} {{\underline{\mathcal A}}}
\newcommand{\Bulc} {{\underline{\mathcal B}}}
\newcommand{\Iulc} {{\underline{\mathcal I}}}
\newcommand{\Julc} {{\underline{\mathcal J}}}
\newcommand{\Gulc} {{\underline{\mathcal G}}}
\newcommand{\Culc} {{\underline{\mathcal C}}}
\newcommand{\Pulc} {{\underline{\mathcal P}}}
\newcommand{\Lulc} {{\underline{\mathcal L}}}
\newcommand{\Uulc} {{\underline{\mathcal U}}}
\newcommand{\Vulc} {{\underline{\mathcal V}}}
\newcommand{\Eulc} {{\underline{\mathcal E}}}
\newcommand{\Fulc} {{\underline{\mathcal F}}}
\newcommand{\Rulc} {{\underline{\mathcal R}}}
\newcommand{\Sulc} {{\underline{\mathcal S}}}
\newcommand{\Aul}  {{\underline A}}              \newcommand{\aul}  {{\underline a}}
\newcommand{\Bul}  {{\underline B}}              \newcommand{\bul}  {{\underline b}}
\newcommand{\Cul}  {{\underline C}}              \newcommand{\cul}  {{\underline c}}
\newcommand{\Dul}  {{\underline D}}              \newcommand{\dul}  {{\underline d}}
\newcommand{\Eul}  {{\underline E}}              \newcommand{\eul}  {{\underline e}}
\newcommand{\Ful}  {{\underline F}}              \newcommand{\ful}  {{\underline f}}
\newcommand{\Gul}  {{\underline G}}              \newcommand{\gul}  {{\underline g}}
\newcommand{\Hul}  {{\underline H}}              \newcommand{\hul}  {{\underline h}}
\newcommand{\Iul}  {{\underline I}}              \newcommand{\iul}  {{\underline i}}
\newcommand{\Jul}  {{\underline J}}              \newcommand{\jul}  {{\underline j}}
\newcommand{\Kul}  {{\underline K}}              \newcommand{\kul}  {{\underline k}}
\newcommand{\Lul}  {{\underline L}}              \newcommand{\lul}  {{\underline l}}
\newcommand{\Mul}  {{\underline M}}              \newcommand{\mull} {{\underline m}}
\newcommand{\Nul}  {{\underline N}}              \newcommand{\nul}  {{\underline n}}
\newcommand{\Oul}  {{\underline 0}}              \newcommand{\oul}  {{\underline o}}
\newcommand{\Pul}  {{\underline P}}              \newcommand{\pul}  {{\underline p}}
\newcommand{\Qul}  {{\underline Q}}              \newcommand{\qul}  {{\underline q}}
\newcommand{\Rul}  {{\underline R}}              \newcommand{\rul}  {{\underline r}}
\newcommand{\Sul}  {{\underline S}}              \newcommand{\sul}  {{\underline s}}
\newcommand{\Tul}  {{\underline T}}              \newcommand{\tul}  {{\underline t}}
\newcommand{\Uul}  {{\underline U}}              \newcommand{\uul}  {{\underline u}}
\newcommand{\Vul}  {{\underline V}}              \newcommand{\vul}  {{\underline v}}
\newcommand{\Wul}  {{\underline W}}              \newcommand{\wul}  {{\underline w}}
\newcommand{\Xul}  {{\underline X}}              \newcommand{\xul}  {{\underline x}}
\newcommand{\Yul}  {{\underline Y}}              \newcommand{\yul}  {{\underline y}}
\newcommand{\Zul}  {{\underline Z}}              \newcommand{\zul}  {{\underline z}}

\newcommand{\mc}[1]     {{\mathcal{#1}}}        \newcommand{\what}[1]   {\widehat{#1}}          \newcommand{\wtld}[1]   {\widetilde{#1}}        \newcommand{\Portho}[1] {\Pb_{#1}^{\perp}}      \newcommand{\ba}{\begin{array}}
\newcommand{\ea}{\end{array}}
 \setlength\arraycolsep{1pt}
\newtheorem{definition}{Definition}
\newtheorem{corollary}{Corollary}
\newtheorem{remark}{Remark}
\newtheorem{theorem}{Theorem}
\newtheorem{lemma}{Lemma}
\newtheorem{proposition}{Proposition}
\newtheorem{prof}{Proof}
\newtheorem{condition}{Condition}
\def\IR{{\mathbb R}}
\def\IC{{\mathbb C}}
\newcommand{\test}{\mbox{}}
\renewcommand{\baselinestretch}{1.6}
\begin{document}

\title{Multi-User MIMO Scheduling in the Fourth Generation Cellular Uplink}


\author{Narayan Prasad ~~~Honghai Zhang ~~~Hao Zhu ~~~
Sampath Rangarajan\thanks{Manuscript received May 23, 2012; revised November 6, 2012 and April
24, 2013; accepted June 12, 2013. The associate editor coordinating the review
of this paper and approving it for publication was N. Sagias.
A part of this paper has been accepted for presentation at the IEEE Asilomar
Conference on Signals, Systems, and Computers 2013. Copyright (c) 2013 IEEE. Personal use of this material is permitted. Permission from IEEE must be obtained for all other users, including reprinting/ republishing this material for advertising or promotional purposes, creating new collective works for resale or redistribution to servers or lists, or reuse of any copyrighted components of this work in other works.}
\thanks{ N. Prasad and S. Rangarajan are with NEC Labs America, 4 Independence
Way, Princeton, NJ, USA (e-mail: {prasad, sampath}@nec-labs.com). N.
Prasad is the corresponding author.
H. Zhang is with Google Inc. (e-mail: honghaiz@gmail.com).
H. Zhu is with the Univeristy of Illinois at Urbana Champaign (e-mail:
zhuh@umn.edu).}}

\date{}
\maketitle
\begin{abstract}
We consider Multi-User MIMO (MU-MIMO) scheduling in  the 3GPP LTE-Advanced (3GPP LTE-A) cellular uplink.   The 3GPP LTE-A  uplink  allows for precoded multi-stream (precoded MIMO) transmission from each scheduled user and also allows flexible multi-user (MU) scheduling wherein multiple users can be assigned the same time-frequency resource. However, exploiting these features is made challenging by   certain practical constraints that have been imposed in order to maintain a low signaling overhead. We show that while the scheduling problem in the 3GPP LTE-A cellular uplink is NP-hard, it can be formulated as the maximization of a submodular set function subject to one matroid and multiple knapsack constraints.    We then propose constant-factor polynomial-time   approximation  algorithms and demonstrate their superior performance via simulations.




\end{abstract}
\newpage

\section{Introduction}




 The 3GPP LTE-A based cellular network \cite{3gpp} together with the IEEE 802.16m based cellular network are the only two cellular networks classified as 4G cellular networks by the international telecommunications union. Some key attributes that a 4G uplink must possess  are the ability to support a peak spectral efficiency of 15 bps/Hz  and a cell average spectral efficiency of 2 bps/Hz,   ultra-low latency and  bandwidths of up to 100MHz. To achieve these ambitious specifications, the 3GPP LTE-A uplink is based on a modified form of the
orthogonal frequency-division multiplexing based multiple-access (OFDMA)  \cite{3gpp}.
 In addition,  it allows precoded multi-stream (precoded MIMO) transmission from each scheduled user as well as  flexible multi-user   scheduling. Notice that while OFDMA itself allows for significant spectral efficiency gains via channel dependent frequency domain scheduling,   multi-user multi-stream communication promises substantially higher degrees of freedom \cite{YuW:degfree}.
Our focus in this paper is on the 3GPP LTE-A uplink (UL) and in particular on MU MIMO scheduling for the  LTE-A UL. Predominantly, almost all of the 4G cellular systems that will be deployed will be based on the 3GPP LTE-A standard \cite{3gpp}.  This standard is an  enhancement of the basic LTE standard which is referred to in the industry as Release 8  and indeed deployments conforming to Release 8 are already underway. The scheduling  in the LTE-A UL is done in the frequency domain where in each scheduling interval the scheduler assigns one or more resource blocks (RBs)   to  each scheduled user. Each RB contains a pre-defined set of consecutive subcarriers and consecutive OFDM symbols and is the minimum allocation unit.




The goal of this work is to design practical uplink MU-MIMO resource
allocation algorithms for the  LTE-A cellular network, where the term resource
refers to RBs as well as precoding matrices. In particular, we consider the design of resource allocation algorithms via weighted sum rate utility maximization that account for   finite user queues (buffers) and finite precoding codebooks. In addition, the designed algorithms comply with all the main practical constraints on the assignment of RBs  and precoders to the scheduled users. We first capture all the key definitions used in this paper in Appendix \ref{app:defns}. Then, we list
our main contributions  in the following:

{\textbf 1)} We first assume that users can employ ideal Gaussian codes and that the base-station (BS) can employ an optimal receiver. We then enforce user rates to lie in a fundamental achievable rate region of the multiple access channel which is a polymatroid and show that the resulting resource allocation problem is NP-hard. We prove that the resource allocation problem can however be formulated as the maximization of a monotonic sub-modular set function subject to one matroid and multiple knapsack constraints, and can be solved using a  recently discovered polynomial time randomized constant-factor approximation  algorithm   \cite{bansal:sparse}. We also adapt a  simpler  deterministic greedy algorithm and show that it  yields a constant-factor approximation  for  scenarios of interest.

        {\textbf 2)} We then consider  scenarios where users employ codes constructed over finite alphabets. In this case the mutual information terms needed to specify  an achievable rate region   do not have closed form expressions. On the other hand the achievable rate region obtained for Gaussian alphabets can be a loose outer bound. Consequently, we obtain a tighter outer bound which is also a polymatroid.  As a result all algorithms developed for Gaussian alphabets can be reused after simple modifications. Finally, we
demonstrate the superior performance of our proposed algorithms via simulations using a realistic channel model.


An interesting corollary that follows  from our results is that a popular transmit antenna selection problem in point-to-point MIMO communications  can be posed as a sub-modular maximization problem that is NP-hard but can be approximately solved (with  at-least half optimality) by a simple greedy algorithm.




 \subsection{Related Work}
Resource allocation over  OFDMA networks has been widely studied
 \cite{YuW:dual,OFDMA:Game:Globecom:08,Lee:DLinfo} with  a large fraction of the   problems that have so far been  considered  being single-user (SU) scheduling problems, which attempt to maximize a system utility under  the constraint that scheduled users can only be assigned  non-overlapping  subcarriers. These problems  have been formulated as {\em continuous optimization problems}, and since they are in general non-linear and non-convex,
 many approaches including those
based on  game theory  \cite{OFDMA:Game:Globecom:08} and dual decomposition \cite{YuW:dual}  have been developed.
MU scheduling in the uplink has been considered in \cite{SDMAprasad} which investigates the tradeoff between fairness and efficiency, and from an information theoretic perspective in \cite{capacityPalomar}. In particular, \cite{capacityPalomar} derives a formulation of the capacity region of a discrete memoryless multiple access  channel (MAC) involving only one non-convex constraint and then proposes methods to   compute inner and outer bounds. A MIMO MAC with finite rate feedback is considered in \cite{beamDai}  and a joint user selection, beamforming and quantization strategy is proposed and comprehensively analyzed. 

Recent works have focused on emerging cellular standards and have formulated the respective resource allocation problems as constrained integer programs. A prominent example
 is \cite{Lee:DLinfo} which consider the design of downlink SU-MIMO schedulers for LTE  systems. In this context, we note that downlink frequency domain scheduling in LTE systems using quantized channel quality feedback has been analyzed in  \cite{Donthi:downlink}. On the other hand,  corresponding resource allocation problems for the cellular uplink have been examined in  \cite{multiserver:2009,Yang:ULinfo,prasad:globe11,Lee-UL-2009}. In particular, \cite{multiserver:2009,Yang:ULinfo,Lee-UL-2009} show  that the single-user UL LTE (Release 8) scheduling problem is NP-hard and provide  constant-factor approximation algorithms, whereas \cite{prasad:globe11} considers SU-MIMO LTE-A scheduling. The algorithms in \cite{multiserver:2009,Yang:ULinfo,prasad:globe11,Lee-UL-2009}   cannot incorporate MU scheduling  and also cannot incorporate knapsack constraints. MU scheduling for the LTE (Release 8) UL is considered in detail in \cite{prasad:wiopt12}. However, we emphasize that certain additional constraints imposed on LTE (Release 8) UL MU scheduling essentially ensure  that   algorithms optimized for LTE MU-scheduling are unsuitable for LTE-A MU-scheduling whereas algorithms optimized for LTE-A MU-scheduling (as presented in this paper) are not applicable to LTE MU-scheduling. 




\section{MU-MIMO Scheduling in the  LTE-A UL}\label{sec:musetup}
Consider a single-cell uplink with  users and one base-station (BS) which is assumed to have  receive antennas. Suppose that user  has  transmit antennas and its power budget is . We let   denote the total number of available resource blocks (RBs). For convenience and without loss of generality, in the following analysis we assume each RB to have unit size.  Then, let  denote the  channel matrix seen by the BS from user  on RB , which we assume is known perfectly to the BS. We let  denote a 3-tuple, where  denotes a user,  (such that ) denotes a precoder from a finite codebook  and  denotes a valid assignment of RBs chosen from the set  containing all possible valid assignments. In particular, each  is an length vector with binary-valued () entries and we say an RB  belongs to  () if  contains a one in its  position, i.e., . Next, we let   denote the ground set of all possible such 3-tuples. For any such 3-tuple we adopt the convention that

Suppose now that a subset  is selected or scheduled by the base-station. Then on each RB   the received signal vector at the BS can be modeled as the output of a MIMO multiple access channel, as

where
  is the additive Gaussian noise and  is the input vector corresponding to 3-tuple , i.e., the input vector transmitted by user  on RB .








We consider the problem of scheduling users in the frequency domain in a given scheduling interval. Let  denote the positive weight of the  user which is an input to the scheduling algorithm and is updated using the output of the scheduling algorithm in every scheduling interval, say according to the proportional fairness rule \cite{Liu-Knightly-2003}. Letting  denote the rate assigned to the  user (in bits per N RBs), we consider the following weighted sum rate utility maximization problem,

where the maximization is over the assignment of RBs and  precoders to the users
\textbf{subject to:}





  \textbf{Decodability constraint:} The rates assigned to the scheduled users should be decodable by the base-station receiver. Notice that unlike SU scheduling, MU scheduling allows for multiple users to be assigned the same RB. Thus, the rate that can be achieved for user  need not be only a function of the RBs, precoders and powers assigned to the  user but can also depend on  those assigned to the other users. 

 \textbf{One precoder and one power level per user:} Each scheduled user can be assigned any one precoding matrix from a finite codebook of such matrices  . In addition, each scheduled user can transmit with only one power level (or power spectral density (PSD))  on all its assigned RBs. This PSD is implicitly determined by the number of RBs assigned to that user, i.e., the user divides its total power equally among all its assigned RBs. The motivation behind these two constraints is that while they significantly decrease the signaling overhead involved in conveying the scheduling decisions to the users, they do not result in significant performance degradation. This is because the uplink channel between each user and the base station is typically highly correlated so that each user's set of preferred spatial directions can be regarded as being approximately frequency non-selective. Consequently, these preferred spatial directions can be reasonably well quantized using a single precoding matrix. Similarly,
    the multi-user diversity effect ensures that each user is scheduled on the set of RBs on which it has relatively good channels. A constant power allocation over such {\em good} channels results in a negligible loss \cite{YuW:Constant}.


  \textbf{At most two chunks per-user:} The set of RBs assigned to each scheduled user should form at-most two mutually non-contiguous chunks, where each chunk is a set of contiguous RBs.  We note here that in the LTE (Release 8) UL each scheduled user is assigned only one  chunk of contiguous RBs \cite{3gpp:rel8}.  Allowing only one chunk of contiguous  RBs to be assigned, together with the DFT spreading operation that each scheduled user must   employ, ensure a low transmit peak-to-average-power ratio (PAPR). In the LTE-A UL each user must employ the DFT spreading but can be assigned up-to two chunks. This relaxation in LTE-A is essentially a compromise between the need to provide more scheduling flexibility and the need to keep PAPR under check \cite{3gpp}.
  A feasible RB allocation and co-scheduling of users in  LTE-A multi-user uplink  is depicted in Fig \ref{fig:lteA}. Notice that each scheduled user is assigned at-most two mutually non-contiguous chunks. Also note that any two scheduled users can partially overlap, i.e., any subset  of the RBs assigned to a user can also be assigned to another user. This is in contrast to the LTE  UL in which any two scheduled users must either not overlap or must completely overlap \cite{3gpp:rel8}.

 \textbf{Finite buffers} We let   denote the size in bits  of the queue (buffer)  associated with the  user. Thus, the rate  assigned to user  cannot exceed .

In addition to the aforementioned constraints the following constraints can also be imposed.

 \textbf{Control channel overhead and interference limit constraints:} Every user that is  scheduled  must be informed about its transmission rate and the set of RBs on which it must transmit, along with the precoder it should employ. This information is sent on the DL control channel of limited capacity which in turn imposes constraints that the set of  scheduled users must respect. These constraints are further discussed in \cite{prasad:wiopt12}. On the other hand, the scheduling decisions that are made should also comply with interference limit constraints which ensure that the  interference caused to other cells does not exceed certain specified margins. 



























We will formulate the optimization problem in (\ref{eq:original}) as the {\em maximization of a monotonic submodular set function subject to one matroid and multiple knapsack   constraints}. Towards this end,  we first recall the key definitions from Appendix \ref{app:defns} and then
  enforce that   the non-zero entries in each  form at-most two non-contiguous chunks.
In addition, for each 3-tuple  we let  denote the associated power level (PSD).  This PSD can be computed as , where  denotes the number of ones (number of RBs) in . Further, let   denote the weight  and buffer (queue) size associated with the 3-tuple , respectively and let  denote the rate associated with the 3-tuple . We will use the phrase {\em selecting a 3-tuple  to imply that
the user  is scheduled to transmit on the RBs indicated in  with PSD  and
 precoder }. Thus,  {\em the constraints of one precoder and one power level per user
 along with at most two chunks per-user can be imposed by allowing the scheduler to select any subset of 3-tuples  such that  for each , where  denotes the indicator function.}
  Accordingly, we define   a family of subsets of , denoted by , as
  


We recall the model in (\ref{eq:propfinmodOr}) and next consider the decodability constraint after first assuming that each user can employ ideal Gaussian codes (i.e., codes for which the coded modulated symbols can be regarded as i.i.d. Gaussian) and that the BS can employ an optimal receiver. Subsequently, we will consider finite input alphabets. Recall that in DFT-Spread-OFDMA each user linearly transforms its codeword using a DFT matrix in order to reduce the PAPR. Note, however,  that under the assumption of ideal Gaussian codes  and optimal receiver, the DFT spreading operation performed by each user can be ignored.  Accordingly, we define a set function  as

It can be verified that  defined in (\ref{eq:firstSub}) is a submodular set function, i.e., it satisfies 
 for all  and .
Further since it is monotonic (i.e., ) and normalized , where  denotes the empty set, we can assert that   is a rank function. Consequently,
for each , the region
  
is a polymatroid \cite{edmonds:poly}. Note that for   each ,   is the fundamental achievable rate region of a  multiple access channel so that each rate-tuple  is achievable \cite{tse:poly}. Thus, {\em we can impose decodability constraints by imposing that the assigned rate-tuple satisfy  for any selected subset .}

Next, in order to impose buffer (queue) constraints, we define a box
 
{\em Thus, for a (tentative) choice , we can satisfy both decodability and buffer constraints by assigning only rate-tuples that lie in the region  }.
Clearly among all such rate-tuples we are interested in the one that maximizes the weighted sum rate. Hence, without loss of optimality with respect to (\ref{eq:original}), with each  we can associate a rate-tuple in  that maximizes the weighted sum rate. Accordingly, we define the following set function that determines the reward obtained upon selecting any subset of  .
We define the set function  as
 




  Leveraging  the arguments made in  \cite{prasad:wiopt12}, we can  represent the control channel overhead constraints as column-sparse knapsack constraints
 such that a subset  is feasible if and only if
 
 where  is a binary valued matrix for some integer  and  is an  length vector, referred to as the control channel budget vector,  whose entries are positive integers.  is a vector with an entry equal to one in each position corresponding to each 3-tuple  and zero elsewhere.
 Notice that the coefficients in  are not normalized and hence  and  together enforce the control channel overhead constraints. Moreover, the total number of non-zero coefficients in any column of  is no more than  an integer  which denotes the column sparsity level such that .


 Finally, let us consider the interference limit constraints. Suppose that the cell of interest is surrounded by  adjacent cells (or sectors). Let  be an length vector of binary valued entries which conveys the RBs such that the total interference caused to the  base station over all the RBs indicated in  should be no greater than a specified upper bound. In particular,
  let  be the (wide-band) correlation matrix of the channel seen at the  base station from the  user in the cell of interest.\footnote{We assume that the BS in the cell of interest also knows this correlation matrix by exchanging appropriate messages with BS  on the backhaul.} Then the total interference caused to the  base station over all the RBs indicated in , upon selecting 3-tuples in any set  is equal to
   
  Then, we are allowed to select   any set of 3-tuples  such that the resulting total interference imposed on the  base station over all the RBs indicated in  is
  no greater than a specified upper bound , i.e., such that .
{\em Thus, all the interference limit constraints can be represented as  generic knapsack constraints
 given by
 
 where  and  is a  length vector of ones.}










Summarizing the aforementioned results, we have formulated (\ref{eq:original})  as the following optimization problem:
 

 In (\ref{eq:original2}) we regard  as constants that are arbitrarily fixed, whereas  can scale polynomially in the cardinality of the ground set . Then, for a given number of users , number of RBs  and the codebook cardinality  (which together fix ), an instance
(or input) of the problem in  (\ref{eq:original2}) consists of a set of positive user weights  and queue sizes ,  per-user per-RB channel matrices , a codebook  (of cardinality ) along with a column sparse matrix , budget vector  and any matrix .
The output is a subset  along with a rate-tuple .
Note that   is .

We first introduce the following two results that will be invoked later.
\begin{lemma}\label{lem:Lem1}
The family of subsets  defined in (\ref{eq:Indfamily}) is an independence  family and    is a partition matroid.
\end{lemma}
\begin{proof} Let  denote the set of all  and notice that . Then, note that  can also be defined as , which is the definition of a partition matroid (cf. Appendix \ref{app:defns}).
\end{proof}

The proof  of the  following lemma  follows from basic definitions \cite{edmonds:poly} and is skipped for brevity.
 \begin{lemma}\label{lem:Lem2}
 The region  is a polymatroid characterized by the rank function  where
 
 \end{lemma}
We are now ready to offer our main result. Let us assume that computing  for any  incurs a unit cost (or equivalently is given by an oracle in a single query). We will show that even under this assumption the problem in (\ref{eq:original2}) is NP hard. Before proceeding it is useful to recall the definitions given in Appendix \ref{app:defns}.
 \begin{theorem}\label{thm:lteA}
 The optimization problem in (\ref{eq:original2}) is NP hard and is the maximization of a monotonic sub-modular set function subject to one matroid and multiple knapsack constraints.
  \end{theorem}
\proof Proved in Appendix \ref{app:lteA}. \endproof

\begin{theorem}
There is a randomized algorithm whose complexity scales polynomially in  and which yields a   approximation to (\ref{eq:original2}).
\end{theorem}
\begin{proof} The key observation is that the partition matroid constraint in (\ref{eq:original2}) can be expressed as  knapsack constraints (one for each user). Let  denote the resulting  matrix determined by these constraints, whose  row corresponds to the  user. Note that this row has ones in each position for which the corresponding 3-tuple  satisfies  and zeros elsewhere.
Together these  knapsack constraints are column-sparse knapsack constraints wherein in each column  a non-zero entry appears only once.  Thus, the total  knapsack constraints are column-sparse constraints in which each 3-tuple can appear in at-most  constraints so that each column can have at-most  non-zero coefficients.
 With this understanding, we can invoke the randomized algorithm from \cite{bansal:sparse} which is applicable to the maximization of any monotonic submodular set function subject to column-sparse knapsack constraints and obtain the guarantee claimed in the theorem.\end{proof}

Notice that since any monotonic submodular set function is also monotonic and sub-additive, we can infer the following result from  Theorem \ref{thm:lteA}.
\begin{lemma}\label{lem:lemH}
The function  defined in (\ref{eq:defnh}) is sub-additive, i.e.,

\end{lemma}






Practical implementation might demand a  simpler and combinatorial (deterministic) algorithm.  Unfortunately, as remarked in \cite{chandra:submod}, it is difficult to design combinatorial (deterministic) algorithms that can combine both matroid and knapsack constraints. Nevertheless in Algorithm I  we specialize a well known greedy algorithm to our problem of interest (\ref{eq:original2}).
 In this algorithm we maintain a set . In each iteration of  Algorithm I we add a 3-tuple (from the set of unselected 3-tuples) to  that yields the largest incremental gain among all feasible 3-tuples that have not yet been selected and where the offered incremental gain is strictly positive. Moreover a 3-tuple is deemed feasible in an iteration if it along with the already selected 3-tuples, satisfies all the constraints in (\ref{eq:original2}). The process continues until either no feasible 3-tuple offers a positive incremental gain or if there are no feasible 3-tuples left.

We now proceed to analyze the performance of Algorithm I and first introduce the following scenario that is of particular interest. We emphasize that this scenario is not required to implement Algorithm I but rather it is introduced since it has a fairly wide applicability and it allows for  a better approximation guarantee. Towards this end, we offer a simple sufficient condition for a knapsack constraint to be matroid constraint.
  \begin{lemma}\label{assump:1}
  The  knapsack constraint is a matroid constraint if all its strictly positive coefficients are identical,i.e., .
  \end{lemma}
 We  note that
necessary and sufficient conditions for a knapsack constraint (with rational valued coefficients) to be a matroid constraint have been derived in \cite{wolsey:knap} and an efficient algorithm to verify such conditions is given in \cite{barcia:knap}.
Then consider the scenario for which the following two conditions are met.
 \begin{condition}\label{assump1}
   The control channel overhead  constraints are modeled using  knapsack constraints,   where   now represents the number of orthogonal (non-overlapping) control channel regions. Each  user (and hence all its corresponding 3-tuples) is associated with only one of these regions. Further, each constraint corresponds  to a  cardinality constraint   which enforces that no more than a given number of  3-tuples among those associated with the corresponding control region can be scheduled. Notice then that these  control channel overhead constraints are sparse with  and since they satisfy Lemma \ref{assump:1} they are   matroid constraints as well. \end{condition}
   We will show in the sequel that when Condition \ref{assump1} is met, the intersection of the  control channel overhead constraints is itself a matroid constraint
  \begin{condition}\label{assump2}
  All the  interference limit knapsack constraints are matroid constraints.
  \end{condition}
  We note that a simplistic modeling of the interference limit constraints can ensure that Condition \ref{assump2} is met.
   For instance, considering the  interference limit knapsack constraint (corresponding to the adjacent  BS ) and recalling (\ref{eq:interf}), each 3-tuple   can be assigned to one of two sets using an appropriate threshold : one set comprising those which cause high interference  and the other one comprising those which do not. Then a cardinality constraint is imposed only on the set of 3-tuples that cause high interference, i.e., the coefficients (in the  interference limit knapsack constraint) of all 3-tuples belonging to the first set are set to   and the remaining ones are set to zero while the upper bound  is set to be the cardinality bound. Then, it can be seen that all resulting interference limit constraints (upon considering all the  adjacent BSs)  satisfy Lemma \ref{assump:1} and hence are   matroid constraints.

The following result provides the worst-case guarantee offered by Algorithm I.
\begin{theorem}\label{thmG1}
 The complexity of  Algorithm I is  and it yields a  approximation to (\ref{eq:original2}). Further, if Conditions \ref{assump1} and \ref{assump2} are satisfied  then
Algorithm I yields a constant-factor  approximation to (\ref{eq:original2}). \end{theorem}

\proof Proved in Appendix \ref{app:thmG1}.


\begin{remark}
Let us reconsider the submodular maximization problem defined in (\ref{eq:Newprob}). This problem in fact  also represents a popular transmit antenna selection problem in point-to-point MIMO communications \cite{sanayei:AS}. Indeed,  can be regarded as the total number of available transmit antennas while  then denotes the number of transmit antennas that have to be selected and a normalization  factor , where  denotes the SNR, can be absorbed into the matrix . Then, our result in Theorem \ref{thm:lteA}  proves that this transmit antenna selection problem is NP-hard. Next,   the greedy Algorithm I when specialized to this problem reduces to a known incremental successive transmit antenna selection algorithm \cite{sanayei:AS} but for which no approximation guarantees were as yet known. Notice that this problem satisfies Conditions 1 and 2 since the constraint in (\ref{eq:Newprob}) can be accommodated using just one control channel knapsack constraint that has  equal coefficients for all users. Then, invoking the result in Theorem  \ref{thmG1} (with ) we can infer that the greedy Algorithm I (or equivalently the incremental successive transmit antenna selection algorithm) offers a  approximation to the transmit antenna selection problem. An analogous observation for the receive antenna selection problem was made recently and independently in \cite{Txselectvaze}.  In addition, \cite{Txselectvaze}  considers a different version of the  transmit antenna selection problem   in which the number of antennas to be selected, , is not given as an input (but instead is an output) and classifies it as an open problem since it is not equivalent to a submodular maximization problem. We note here that  even for that version, we can obtain an approximation algorithm by sequentially running the greedy Algorithm  times, initialized with inputs  respectively, and picking the overall best among the  outputs. It is readily seen that such an algorithm will also yield a  approximation since the output of each run is within  of its respective optima.
\end{remark}
\begin{remark}
Recall that we have assumed that the BS employs an ideal receiver, which in practice can be closely approached by iterative Turbo receivers. However, when each user's queue is of infinite size (a.k.a infinitely backlogged case), the assigned rate-tuple   is a corner-point of the polymatroid in (\ref{eq:polreg}) (defined for the selected subset) and thus can be achieved using a simple MMSE-SIC receiver  \cite{VaranasiMK:ODF:Asil97}.
\end{remark}

 Notice that so far we have  assumed that computing  for any  incurs a unit cost. We can indeed show that Algorithm I has polynomial complexity under a stricter notion that computing  (instead of ) for any  incurs a unit cost.\footnote{This assumption results in no loss of generality  since the worst-case cost of computing  is .} To show this, it suffices to prove that  can be determined with a complexity
polynomial in .  A key observation towards this end is that for any ,  in (\ref{eq:deffp})  can be computed as

Then, since the function  is a submodular set function, we can  solve the minimization in (\ref{eq:newfp}) using submodular function minimization routines that have a complexity polynomial in  \cite{iwata:submin}.
Thus, from (\ref{eq:newexpH1}) we can conclude that  can indeed be determined with a complexity
polynomial in .
We now propose simple observations that can considerably speed up Algorithm I.
\begin{itemize}
\item {\em Lazy evaluations.} An important feature that speeds up the greedy algorithm substantially has been discovered and exploited in \cite{Minoux:greedy,krause:greedy}. In particular, due to the submodularity  of the objective function the incremental gain offered by a 3-tuple over any selected subset of 3-tuples not including it decreases monotonically as the selected subset grows larger.
    Thus, at any step in the algorithm, given a set of selected 3-tuples  and a 3-tuple  for which  has been evaluated, we do not have to evaluate  for another 3-tuple , if we can assert that  where  denotes the set of selected 3-tuples at a previous step. This results in no loss of optimality with respect to the original greedy algorithm.




\item {\em Exploiting subadditivity.}
Suppose that at any step of the greedy algorithm  we have a set of selected 3-tuples .
 Further, let  and   be two 3-tuples in  such that  and  comprise of only one chunk each and are mutually non-intersecting. Then, letting , we see that
 
   where the first inequality stems from the fact that  is monotonically increasing in the transmit PSD of   and the second inequality stems from the monotonicity and subadditivity of . Thus, we have that
   
 Then if   as well as  satisfy all the constraints,
  we can evaluate  and skip evaluating . By adopting this procedure over all 3-tuples in   , we can ensure that the 3-tuple selected will offer at-least  the gain yielded by the locally optimal 3-tuple. Then, using a well known result on the greedy algorithm with an approximately optimal selection at each step \cite{nemhaus:analysis} we can conclude that this variation of our greedy algorithm will yield an approximation guarantee of
  when Conditions \ref{assump1} and \ref{assump2} are satisfied.
\end{itemize}
Finally, in order to benchmark the performance of Algorithm I we derive two upper bounds. For convenience, we only consider the case where there are no knapsack constraints so that (\ref{eq:original2}) reduces to the maximization of a monotonic sub-modular set function  subject to one matroid constraint. Then,  we suppose that  and  denote the optimal solution and that returned by Algorithm I. We obtain our first bound by specializing an  upper bound from \cite{Minoux:greedy}   (see also \cite{krause:greedy}) which is applicable to any monotonic sub-modular set function maximization subject to one matroid constraint, as

where  have been defined in the proof of Lemma \ref{lem:Lem1}.
For our second bound we exhaustively enumerate each one of the  possible assignments of precoding matrices to users. Then, for each assignment we consider the weighted sum rate maximization over the uplink (\ref{eq:original}) after relaxing the per-user power constraint to one where only a per-user sum power constraint has to be satisfied, i.e., each user can be assigned any power value on any RB as long as it does not exceed its power budget. The latter problem can be efficiently solved via {\em convex optimization} \cite{yuWei:WF,mohseni:jsac}. Finally, we choose the largest weighted sum rate value across all assignments as the upper bound.



\section{Practical Modulation and Coding Schemes}


In the LTE-A uplink a scheduled user can be assigned one out of three modulations ( QAM) and an outer Turbo-code whose coding rate is one out of several available choices. Since the available outer codes are powerful and since the BS can employ near-optimal receivers (such as Turbo SIC) a reasonable choice for the achievable rate region is the following. Let  denote the constellation (with unit average energy and cardinality ) associated with 3-tuple . For any subset  and any RB , let  denote the mutual information evaluated for a point-to-point MIMO channel whose output can be modeled as

 where  is the additive Gaussian noise and  is the input symbol vector corresponding to 3-tuple  whose entries are independently and uniformly drawn from  and where  are mutually independent for any .
 Then, for any  an achievable rate region is given by
   
 Notice that in deriving (\ref{eq:region1}) we have assumed an ideal BS receiver as well as no DFT spreading by each user, both of which allow for higher achievable rates.\footnote{Neglecting the per-user  DFT spreading expands the rate region since the noise at the BS is assumed to be Gaussian and independent across RBs.}
 Unfortunately, no closed form expressions are available for 
  and the rate region in (\ref{eq:region1}) does not have a useful structure. Clearly the region defined before in (\ref{eq:polreg}) assuming Gaussian inputs is an outer bound which however can be loose. Here we obtain a tighter outer bound that also has a useful structure. We first offer the following result.
  \begin{proposition}\label{propfin}
  For any subset   and any , we have that
  
 Further the set function  defined as , is a rank function.
  \end{proposition}
  \begin{proof}
  Consider any  and the model in (\ref{eq:propfinmod}).
     Using the chain rule for mutual information along with the fact that the inputs corresponding to any two distinct 3-tuples of  are mutually independent, we can upper bound  as
     
      for any . Since the cardinality of the input corresponding to 3-tuple  is  we have that . Then using the fact   that  for any given input covariance, Gaussian inputs (with the same covariance) maximize the mutual information (over the Gaussian noise channel model in (\ref{eq:propfinmod})), we have that
      
       Since these arguments are valid for any subset , we can deduce that (\ref{eq:propfin1}) is true.
    The remaining result follows from basic definitions.
      \end{proof}

In this context, we note that the bound in (\ref{eq:propfin1}) is a non-trivial generalization of a bound on the finite alphabet mutual information over a point-to-point fading channel employed in \cite{fabregas:LB} to derive a tight lower bound on the outage probability. However, that bound when applied to our case would only yield  for any .

    Next, we   outer bound the region in (\ref{eq:region1}) as
    
  Invoking Proposition \ref{propfin} we use the fact that  is a rank function from which it follows that the region  is a polymatroid. Then invoking Lemma \ref{lem:Lem2} we can infer the following result.
   \begin{proposition}\label{propfin2}
  For any choice of selected 3-tuples , the  rate region
    is a polymatroid
 which is characterized by the rank function
  
  \end{proposition}









Then, upon by defining

 we consider the optimization problem
 
  As before, it can be shown that the optimization problem in (\ref{eq:orig3}) is the maximization of a monotonic submodular   function subject to one matroid and multiple knapsack constraints. Algorithm I and its associated results are thus applicable.





\section{Simulation Results}


In this section we present our simulation results.
We simulate an uplink  wherein the BS is equipped with four receive antennas and each user has up-to two transmit antennas.  The system has  sub-carriers out of which   sub-carriers  divided into 25 RBs (comprising of 12 consecutive sub-carriers each) are available as  data sub-carriers that are used for serving the users.
  We assume 10 active users, all of whom have identical maximum transmit powers and identical path loss factors. We then use the SCM Urban Macro channel model \cite{3gpp}  to  generate the channel between each user and the base-station in an independent identically distributed (i.i.d.) manner. The antenna spacing at the BS is set to be  while that at each user is set to be . In all the results given below  we assume that the BS employs the optimal receiver and each user can employ an unconstrained (Gaussian) input alphabet. Furthermore, unless otherwise mentioned, we assume an infinitely backlogged traffic model wherein each user has an infinite buffer size.  \footnote{We normalize the per-user channels and the noise variance at the BS appropriately and refer to the max transmit power of each user as the (transmit) SNR.} Also, the  per-user weights which are given as inputs to the scheduling algorithm are all set to one so that the objective in (\ref{eq:original}) reduces to the sum rate. We note that since the system considered is homogeneous, fairness among users will also be ensured.

   In Fig. \ref{fig_plot2}, we assume no interference limit or control channel overhead constraints. We first  consider the case where each user is equipped with just one transmit antenna
    and plot the average cell spectral efficiency curve  obtained   when Algorithm I is employed by the BS scheduler. We then consider the case where
    each user is equipped with two transmit antennas and can use an antenna  selection codebook, i.e.,  along with the case where an expanded codebook ( \cite{3gpp}) can be used for each user. For each curve, we plot a corresponding upper bound using (\ref{eq:UB}).  {\em We caution here that while the upper bound in (\ref{eq:UB}) is very easy to compute, indeed the additional complexity to compute the bound once the solution of Algorithm I is available scales only linearly in the number of users, the bound itself need not be achievable or tight. Its main purpose is to show that the average performance of Algorithm I is significantly superior to its worst-case guarantee, especially over large examples where computing the optimal solution via brute force enumeration is not tractable.} From the figure we observe that in each case, the performance of Algorithm I  is more than  of the  upper bound, which is   superior to the worst case guarantee  (obtained by specializing the result in Theorem \ref{thmG1}). Notice that  antenna selection yields a gain of about 1dB over the system with single transmit antenna users while the expanded codebook yields a further gain of about . However, this additional gain due to the expanded codebook requires an additional power amplifier at each user since simultaneous transmission from both transmit antennas needs to be supported by each user. While antenna selection can be realized with only one power amplifier at each user, in practise it  incurs a switching loss of about . Finally, we note here that the linear increase observed for the spectral efficiency is due to the fact that we have plotted the spectral efficiency versus SNR in dB (or equivalently the logarithm of the absolute SNR).


 In Fig. \ref{fig_plot4} we consider an uplink where each user is equipped with just one transmit antenna
    as well as the case where
    each user is equipped with two transmit antennas and can use an antenna  selection codebook.  We   plot the spectral efficiency obtained upon using Algorithm 1 when each user can be assigned at-most one chunk (enforced by defining the set of feasible RB allocations accordingly) as well as spectral efficiency obtained when each user can be assigned up-to two chunks. From the figure we see that the at-most one chunk restriction does not result in any significant degradation and indeed can be enforced to reduce scheduling complexity as well as to reduce the per-user PAPR. Higher bandwidths (translating to a greater number of available RBs exhibiting greater frequency selectivity) can bring more gain for allowing up-to two chunks per scheduled user.


In Fig. \ref{fig_newUB} we consider the uplink of Fig. \ref{fig_plot4} but where there are seven active users.  We   plot the spectral efficiency obtained upon using Algorithm 1 when each user can be assigned at-most one chunk, along with the corresponding convex optimization based upper bound described in Section \ref{sec:musetup} (referred to in the legend as Imp-UB). It is seen that the performance of Algorithm I is within  of this upper bound. While the convex optimization based upper bound is much tighter and reveals the  exceptional performance of Algorithm I, it is computationally demanding to obtain and seems infeasible for larger examples, such as the one in Fig. \ref{fig_plot2} with ten users  and an expanded codebook of  cardinality six.


 In Fig. \ref{fig_plot3} we consider an uplink where there are 15 RBs available for scheduling users and each user is equipped with two transmit antennas and can use an antenna  selection codebook. We impose  a constraint that no more than five users can be scheduled in each scheduling interval. We first plot the spectral efficiency obtained upon using Algorithm 1 with   one control channel overhead constraint to enforce the user limit. In particular, this  constraint has an equal coefficient of  for each user and a budget limit of . Then, we consider two user pre-selection strategies wherein a pool of 5 users is pre-selected in each interval and Algorithm 1 is then used on this pool without any constraints. The intention behind user pre-selection is to reduce scheduling complexity. In the first strategy a greedy rule is employed wherein the reward associated with selecting a user is set equal to the maximum rate that user can offer on any RB and the 5 users with the 5 largest rewards are pre-selected. In the second strategy 5 users are randomly pre-selected. From the figures it is evident that random pre-selection can result in a much degraded performance whereas greedy pre-selection seems a good method to achieve complexity reduction without significant performance degradation.

In the following set of figures we use the 6 path equal gain i.i.d. Rayleigh fading channel model to generate the channel between each user and the base-station.

In Fig. \ref{fig_plotincu} we consider the impact of the number of users () on the system performance
over an uplink which has   RBs available and wherein each user has one transmit antenna.  We consider two values of  transmit SNRs and first capture the cell spectral efficiency (obtained when Algorithm I is employed by the BS scheduler) as the number of users increases. We then depict the average per-user spectral efficiency.
  Notice first  that the cell spectral efficiency increases only  logarithmically in the number of users since the number of receive antennas is held fixed at four and consequently the per-user spectral efficiency is decreasing in the number of users (i.e., it is ). Moreover, we note that in all the cases considered for SNR , the performance of Algorithm I is more that  of the upper bound in (\ref{eq:UB}).


Next, in Figure \ref{fig_plotfb} we assess the impact of finite buffers over the uplink of Fig. \ref{fig_plotincu} but where there are  RBs available to service  users. In addition, each user can be assigned at-most one chunk of RBs. We assume a  fixed arrival rate per-user which is identical across all users and consider four different values for this arrival rate along with an SNR of . In each case we plot the cell spectral efficiency obtained when Algorithm I is employed by the BS scheduler, as well as that obtained when a heuristic scheduler is employed. In particular, the heuristic we consider is the one where Algorithm I is first employed assuming infinite buffer sizes. Then, the finite buffer size constraint is imposed separately on each scheduled user.
From the figure we note that at low arrival rates the system is not resource limited in that all users can be simultaneously assigned   rates equal to their respective buffer sizes and any simple scheduling algorithm will suffice. However, at moderate values of arrival rates directly incorporating the buffer sizes in the resource allocation step is quite beneficial. At large values of arrival rates the performance of the heuristic will again approach that of Algorithm I since the buffer size constraints will be increasingly irrelevant.

Finally, in Figure \ref{fig_plotcompnew} we compare the performance of Algorithm I with that of the other algorithms that have been proposed before. In this comparison, we assume that each user has one transmit antenna and can be assigned at-most one chunk and there are  RBs available to service the users. We have considered, to the best of our knowledge, all algorithms that   yield  feasible solutions to the problem at hand. In particular, we plot the performance of three algorithms that have been proposed for single-user scheduling over the LTE uplink. These include a greedy heuristic proposed in \cite{Lee-UL-2009}, an approximation algorithm referred to as benefit-doubling (BD) proposed in \cite{multiserver:2009} and another
approximation algorithm based on the local ratio test (LRT) proposed in \cite{Yang:ULinfo}. In addition, we also plot the performance of another approximation algorithm, referred to here as the enhanced local ratio test (ELRT) based algorithm \cite{prasad:wiopt12}, proposed for multi-user scheduling over the LTE uplink where up-to two users can be simultaneously scheduled on an RB provided that any pair of overlapping users are assigned the same set of RBs (a.k.a. the complete overlap constraint). From the figures, we see that Algorithm I yields very significant gains over the previously proposed algorithms. These gains stem from two facts. The first one is that multi-user scheduling over the LTE-A uplink enables substantial gains by allowing multiple users to be co-scheduled on an RB and by relaxing the complete overlap constraint. The second fact is that Algorithm I is near-optimal which allows it to capture almost all of the available gains.

\section{Conclusions}
We considered resource allocation in the 3GPP LTE-A  cellular uplink which allows for MIMO transmission from each scheduled user as well as multi-user  scheduling wherein multiple users can be assigned the same time-frequency resource.  We showed that the resulting resource allocation problem is NP-hard and then   proposed constant-factor polynomial-time   approximation  algorithms.


\appendix

\section{Definitions}\label{app:defns}
We capture some basic known definitions that are invoked in the paper.
\begin{definition}
Given a ground set , we define its power set  (i.e., the set containing all the subsets of  ) as . Then,
a non-negative real valued function defined on the subsets of ,
 is a {\em monotonic} set function if and only if it satisfies, . In addition,
the set function is also a
{\em submodular} set function if and only if

Furthermore,  the set function is also a
 {\em rank} function function if it is normalized, i.e., , where  denotes the empty set.
 Then, the region defined as  is a {\em polymatroid}.

A {\em knapsack constraint} on the elements of  is a constraint that can be expressed as
  for some non-negative scalars  and where  is an indicator variable which is one if element  is chosen and zero otherwise. Without loss of generality, we can assume that .
 \end{definition}
\begin{definition}
  , where  is a collection of some subsets of , is said to be a {\em matroid} if  is an {\em independence family}:
  \begin{itemize}
 \item  is downward closed, i.e., 
  \item For any two members  and  such that , there exists
    such that . This property is referred to as the exchange property.
\end{itemize}
\end{definition}
\begin{definition}
  is said to be
a {\em partition matroid} when   there exists a partition , where , along with integers  such that

\end{definition}
\begin{definition}
An optimization problem is said to be {\em NP-hard} if   any algorithm that returns an optimal solution to the problem at hand given any instance as an input, and whose worst-case complexity (over all instances) scales polynomially in the size of the ground set, can be used to construct such an algorithm for each NP-complete problem. Construction of such algorithms for the latter class of NP-complete problems has been a long standing open problem \cite{Karp_NP72} and indeed the existence of such algorithms is thought to be highly improbable.




A {\em constant factor  approximation algorithm} for a combinatorial optimization problem (in which the objective must be maximized), is an algorithm which returns a feasible solution   given any instance as an input such that the objective value obtained using the returned solution is no less than  times the optimal objective value for that instance. The factor  is referred to as the constant-factor and lies in the unit interval   and must be independent of the input instance. \end{definition}
















\section{Proof of Theorem \ref{thm:lteA}}\label{app:lteA}
\begin{proof} We will first show that (\ref{eq:original2}) is the maximization of a monotonic sub-modular set function subject to one matroid and multiple knapsack constraints. Invoking Lemma \ref{lem:Lem1}, it suffices to show that the function  is a monotonic submodular set function. From the definition of  in (\ref{eq:defnh}) it is readily seen that it is monotonic, i.e., . There are multiple ways to prove the submodularity of  and we detail one which directly shows that  satisfies  the property in (\ref{eq:submoddef}) for any two subsets  in  and any
 element . Towards this end,
let  denote an ordering function such that for any
 subset ,  is the 3-tuple having the  largest weight among the 3-tuples in . Hence we have that . Further, let us adopt the convention that for any subset ,
  . Defining ,
    we now invoke Lemma \ref{lem:Lem2} together with the important property that the {\em rate-tuple in each polymatroid that maximizes the weighted sum is determined by the corner point of that polymatroid in which the 3-tuples are arranged in the non-increasing order of their weights \cite{edmonds:poly,tse:poly}}. Thus, we can express  as

 Let  be the smallest integer in  for which  so that  whereas
   .
As a result, using (\ref{eq:newexpH1}) we obtain that
 
which can be re-written as
 
Consider now the set  and suppose that , where .
Now let  be the smallest integer in  for which  and clearly we have .
 Analogous to (\ref{eq:newdiffuexp}), we  express   as
  
Due to sub-modularity of  (cf. property in (\ref{eq:submoddef})) each of the terms corresponding to  in the summation in (\ref{eq:newdiffvexp}) is non-positive. Consequently, we can upper bound
  by first dropping the terms corresponding to  and then reducing the weights of the remaining terms as
   while .
 Next, we order and parse the remaining tuples in  as
 
Combining all terms that have common weights (post the reduction step) we obtain the upper bound to be

Finally, comparing (\ref{eq:newdiffu}) and (\ref{eq:newdiffv}) we note that  and . Consequently,
we can invoke the submodularity of  again to conclude that the upper bound in (\ref{eq:newdiffv}) is less than  so that , which establishes the submodularity of .




We will now show that (\ref{eq:original2}) is an NP hard problem.
We will consider instances of the problem where the number of RBs ,  all users have identical weights, unit powers, infinite queues and one transmit antenna each and where the codebook  is degenerate, i.e., .  Thus, we have . In addition, we assume that the number of receive antennas is equal to the number of users  so that a given  input of user channels forms a  matrix, denoted here by . Further, we will assume only one knapsack constraint which in particular is a cardinality constraint on the number of users that can be scheduled on the one available RB. We will show that the problem specialized to these instances is also NP-hard so that the original problem is NP-hard.
Note that the matroid constraint now becomes redundant and (\ref{eq:original2}) simplifies to  maximizing the sum rate under a cardinality constraint

where  is the input maximum cardinality.
Now using the determinant equality

together with the monotonicity of the objective function, we can re-write (\ref{eq:Newprob}) as

   Note that (\ref{eq:Newprob2}) is equivalent to determining the  principal sub-matrix of the positive definite matrix  having the maximum determinant. Note that for a given , an instance of the problem in (\ref{eq:Newprob2}) is the matrix  together with . We will prove that (\ref{eq:Newprob2}) is NP-hard via contradiction.
Suppose now that an efficient algorithm (with a complexity polynomial in ) exists that can optimally solve (\ref{eq:Newprob2}) for any input  matrix  and any .
This in turn would imply that there exists an efficient algorithm (with a complexity polynomial in )
that for any input  and any    positive definite matrix , can determine the   principal sub-matrix  of   having the maximum determinant. Invoking the reduction developed in \cite{ko:algo}, this would then contradict the NP hardness of the problem of determining whether a given input graph has a clique of a given input size.\end{proof}


\section{Proof of Theorem \ref{thmG1}}\label{app:thmG1}
We first consider the complexity of Algorithm I  and note that since the partition matroid constraint needs to be satisfied, there can be at-most  steps in repeat-until loop of the algorithm.
Also, recall that the  the size of the ground set  is . Then,  at each step we need to compute  for each  such that  satisfies all the constraints. Thus, the   worst-case complexity is .




Let us now consider the approximation guarantees.
Notice that due to the partition matroid constraint any optimal solution to (\ref{eq:original2}) cannot contain more that  3-tuples. Then, using the subadditivity of  shown in Lemma \ref{lem:lemH} together with the facts that Algorithm I is monotonic and in its first step selects the 3-tuple of   having the highest weighted rate, suffice to prove the  guarantee. On the other hand, suppose that Conditions \ref{assump1} and \ref{assump2} are satisfied (over all instances). Consider the  control channel constraints and  let   denote the set of 3-tuples involved in the  control channel constraint so that . Recall that  and notice that any set  that satisfies these  constraints can be expressed as , where , where  is the cardinality bound imposed by the  control channel constraint. Thus the  control channel constraints together are indeed one partition matroid.
More importantly, the intersection of this partition matroid with the one defined in Lemma \ref{lem:Lem1} is also one matroid. To see this, let  denote this intersection and recall the definitions given in Appendix \ref{app:defns}. It can readily be seen that  is downward closed. Then, we need to show that the exchange property holds. Consider any
  in  such that .  Clearly, the users corresponding to all 3-tuples in  must all be distinct since . In addition, each 3-tuple of  can   have a non-zero coefficient in only one control channel constraint. Similarly for . Then consider any 3-tuple  such that no 3-tuple in  contains the user . Notice that there must exist at-least one such 3-tuple. Clearly, for such a 3-tuple . Consequently,  only if
  a control channel constraint  is violated. Without loss of generality, suppose this constraint is the first control channel constraint. Then, since all non-zero coefficients in any control channel constraint are identical, we can deduce that there exists a 3-tuple    such that  but the user
    is not contained in any 3-tuple of . This observation together with the fact that  allows us to conclude that there exists an  such that   , which then yields the desired result.


Finally, combining this matroid with the  other  (interference limit) matroid constraints, we see that the feasible subsets belong to the intersection of  matroids and hence form a system where . Then invoking the guarantee offered by the greedy algorithm on a system \cite{nemhaus:analysis,nemhaus:algo}, proves the second part.\endproof











\bibliography{SCFDMA_bibU}
\bibliographystyle{ieeetr}
\bibliographystyle{IEEEtran}

























\begin{figure}
\centering
\includegraphics[width=0.9\linewidth]
{Feasible_allocationsMUlteA.eps} \caption{A Feasible RB Allocation in the LTE-A UL: The assignment of RBs to each user is represented by a shaded region.} \label{fig:lteA}
\end{figure}


\algsetup{indent=1em}
\begin{table}
\caption{{\bf Algorithm I: Greedy Algorithm  for LTE-A UL MU-MIMO}}\label{algo:glteA}
\begin{algorithmic}[1]
\STATE Initialize 
\STATE \textbf{Repeat}
\STATE Determine

  and set .
 \STATE \textbf{If}  \textbf{Then}
 \STATE 
 \STATE \textbf{End If}
\STATE   \textbf{Until}  or 
\STATE Output    .
\end{algorithmic}
\end{table}



\begin{table}
\begin{footnotesize}
\begin{center}
\hspace{-1cm}\caption[]{Symbol Definitions}\label{tab:defnsym}
\begin{tabular}{|c|p{4cm}|p{4cm}|p{4cm}|}\hline
    & Number of users &   & Number of RBs \\ \hline   & Number of TX antennas at each user &
    & Number of RX antennas at BS \\ \hline   & Number of column sparse knapsack constraints that model the control channel overhead constraints  &  & Matrix containing the coefficients of the column-sparse knapsack constraints   \\ \hline
    & column sparsity level in  &  &  length control channel budget vector       \\  \hline  & number of generic knapsack constraints &      & Matrix containing the normalized coefficients of the generic knapsack constraints   \\\hline
  & Weight of  user    &  & rate (bits/frame) assigned to user  \\ \hline    & Power budget of user  &  & Buffer size of user  \\\hline
      & -length vector representing a valid RB assignment containing at-most two chunks &     & Precoder matrix having unit Frobenius norm \\ \hline   & Finite codebook of all precoder matrices &
      & Set of all valid RB assignments \\ \hline   & 3-tuple denoting allocation of RB assignment  and precoder  to user  &  & Ground set containing all possible 3-tuples \\ \hline   & user in 3-tuple  &   & RB assignment in 3-tuple  \\ \hline   & precoder in 3-tuple  &
      & Collection of valid subsets of  \\ \hline   & Channel matrix seen from user  on RB   &  & Region defined by buffer sizes of 3-tuples in          \\  \hline
           & four different rank functions & ,   & Polymatroids determined by subset  and rank functions , respectively \\  \hline  &  Set function defined such that  yields the maximum weighted sum rate over polymatroid  &  &  Set function defined such that  yields the maximum weighted sum rate over polymatroid \\ \hline \end{tabular}
\end{center}
\end{footnotesize}
\end{table}







\begin{figure}[htb!]
\begin{center}
\centerline{\epsfig{file=SE2chunksexp.eps,width=.6\linewidth}}
\caption{Average spectral efficiency versus SNR (dB).}
\label{fig_plot2}
\end{center}
\end{figure}



\begin{figure}[htb!]
\begin{center}
\centerline{\epsfig{file=SE1vs2chunksexp.eps,width=.6\linewidth}}
\caption{Impact of the number of chunks per user.}
\label{fig_plot4}
\end{center}
\end{figure}

\begin{figure}[htb!]
\begin{center}
\centerline{\epsfig{file=LTEAnewUB.eps,width=.6\linewidth}}
\caption{Convex Optimization based Upper Bound}
\label{fig_newUB}
\end{center}
\end{figure}


\begin{figure}[htb!]
\begin{center}
\centerline{\epsfig{file=Plot_SCM_LTEA_userselection.eps,width=.6\linewidth}}
\caption{Impact of User Pre-Selection.}
\label{fig_plot3}
\end{center}
\end{figure}


\begin{figure}[htb!]
\begin{center}
\centerline{\epsfig{file=Users_vs_SE.eps,width=.6\linewidth}}
\centerline{\small (a)}
\centerline{\epsfig{file=Users_vs_peruserSE,width=.6\linewidth}}
\centerline{\small (b)}
\caption{Impact of the number of users: (a) Cell spectral efficiency (b) per-user spectral efficiency.}
\label{fig_plotincu}
\end{center}
\end{figure}



\begin{figure}[htb!]
\begin{center}
\centerline{\epsfig{file=FiniteQ.eps,width=.6\linewidth}}
\caption{Impact of finite buffers.}
\label{fig_plotfb}
\end{center}
\end{figure}

\begin{figure}[htb!]
\begin{center}
\centerline{\epsfig{file=LTEAcomplot1.eps,width=.6\linewidth}}
\centerline{\small (a)}
\centerline{\epsfig{file=LTEAcomplot2.eps,width=.6\linewidth}}
\centerline{\small (b)}
\caption{Comparison for varying number of users: (a) Average SNR=10dB (b) Average SNR=18dB .}
\label{fig_plotcompnew}
\end{center}
\end{figure}















\end{document}
