\documentclass[11pt]{article}

\usepackage[
  bookmarks=true,
  bookmarksnumbered=true,
  bookmarksopen=true,
  pdfborder={0 0 0},
  breaklinks=true,
  colorlinks=true,
  linkcolor=black,
  citecolor=black,
  filecolor=black,
  urlcolor=black,
]{hyperref}

\usepackage{amsthm}
\usepackage{subfigure}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage[capitalise]{cleveref}
\newcommand{\crefrangeconjunction}{--}
\usepackage{nicefrac}

\usepackage[margin=1in]{geometry}

\newtheorem{theorem}{Theorem}
\newtheorem{proposition}{Proposition}
\newtheorem{lemma}{Lemma}
\newtheorem{conjecture}{Conjecture}

\theoremstyle{definition}
\newtheorem{definition}{Definition}
\newtheorem{remark}{Remark}

\newcommand{\sfa}{\mathsf{a}}
\newcommand{\mv}{\mathtt{v}}
\newcommand{\existsv}{\exists{\mv}}
\newcommand{\existsZ}{\exists{0}}
\newcommand{\knownf}[1]{\ensuremath{F\node{#1}}}
\newcommand{\minval}[1]{\ensuremath{\mathit{Min}\node{#1}}}
\newcommand{\knownvals}[1]{\ensuremath{\mathit{Vals}\node{#1}}}
\newcommand{\knownlows}[1]{\ensuremath{\mathit{Lows}\node{#1}}}
\newcommand{\eqdef}{\triangleq}
\newcommand{\OptMin}{\mbox{}}
\newcommand{\OptMink}{\mbox{}}

\newcommand{\set}[1]{\{#1\}}
\newcommand{\bftext}[1]{{\bf #1}}
\newcommand{\Crash}{\mathsf{Crash}}
\def\emptyset{\mbox{\O}}

\newcommand{\defemph}[1]{\textbf{\textit{#1}}}
\newcommand{\sat}{\models}

\newcommand{\decideZ}{\mathsf{decide(0)}}
\newcommand{\decideO}{\mathsf{decide(1)}}
\newcommand{\decide}{\mathsf{decide}}

\newcommand{\gammacr}{\gamma^{\mathrm{cr}}}
\newcommand{\Proc}{\mathsf{Procs}}
\newcommand{\tee}{\,\defemph{t}}

\newcommand{\Pz}{P_0}
\newcommand{\UPz}{\mbox{}}
\newcommand{\OptZ}{\mbox{}}
\newcommand{\UOptZ}{\mbox{}}
\newcommand{\UOptMink}{\mbox{}}

\newcommand{\Fmodel}{{\cal F}}
\newcommand{\CG}{{\cal G}}
\newcommand{\Vals}{{\tt V}}
\newcommand{\Vecs}{\vec{\Vals}}
\newcommand{\dom}{\,{\preceq}\,}
\newcommand{\hmwopt}{P0_{\mathrm{opt}}}
\newcommand{\pdo}{unbeatable}
\newcommand{\FP}{\mathsf{F}}
\newcommand{\nnz}{\mathsf{never\hbox{-}known}(\exists 0)}
\newcommand{\node}[1]{\langle#1\rangle}
\newcommand{\Ga}{\CG_\alpha}
\newcommand{\dec}{\mathsf{d}}
\newcommand{\cw}{\exists\mathsf{correct}(\mathtt{w})}
\newcommand{\cv}{\exists\mathsf{correct}(\mathtt{v})}
\newcommand{\cz}{\exists\mathsf{correct}(0)}

\DeclareMathOperator{\Bary}{\sf Bary}
\DeclareMathOperator{\Star}{\sf St}
\DeclareMathOperator{\Car}{\sf Car}
\DeclareMathOperator{\Div}{\sf Div}
\DeclareMathOperator{\bdry}{\sf Bd}

\newcommand{\ang}[1]{\langle{#1}\rangle}

\newcommand{\cK}{\ensuremath{\mathcal{K}}}
\newcommand{\cL}{\ensuremath{\mathcal{L}}}
\newcommand{\cP}{\ensuremath{\mathcal{P}}}

\newcommand{\kAgreement}{{\bf \defemph{k}-Agreement}}
\newcommand{\Agreement}{{\bf Agreement}}
\newcommand{\UnikAg}{{\bf Uniform \defemph{k}-Agreement}}
\newcommand{\UniAg}{{\bf Uniform Agreement}}
\newcommand{\Decision}{{\bf Decision}}
\newcommand{\Validity}{{\bf Validity}}

\newcommand{\noactnv}{\mathsf{no\mbox{-}decided}(\bar\valv)}
\newcommand{\valv}{\veee}
\newcommand{\veee}{\mathtt{v}}
\newcommand{\decidei}{\mathsf{decide_i}}
\newcommand{\decideiZ}{\mathsf{decide(0)}}
\newcommand{\noactnO}{\mathsf{no\mbox{-}decided}(0)}
\newcommand{\notnz}{\mathsf{not\hbox{-}known}(\exists 0)}
\newcommand{\decideiO}{\mathsf{decide(1)}}
\newcommand{\fip}{{\it fip}}
\newcommand{\OptZs}{\mbox{}}
\newcommand{\KoP}{\mbox{{\bf K}{\it o}{\bf P}}\/}
\newcommand{\exZ}{\exists 0}
\newcommand{\val}{v}
\newcommand{\HC}[1]{\mathsf{HC}\node{#1}}

\newcommand{\noactv}{\mathsf{no\mbox{-}decided}(\valv)}

\hypersetup{
  pdfauthor      = {Armando Casta{\~n}eda <armando@im.unam.mx>, Yannai A. Gonczarowski <yannai@gonch.name>, and Yoram Moses <moses@ee.technion.ac.il>},
  pdftitle       = {Unbeatable Set Consensus via Topological and Combinatorial Reasoning},
}

\begin{document}

\title{Unbeatable Set Consensus via \\ Topological and Combinatorial Reasoning\thanks{
Part of the results of this paper
were announced
in~\cite{AYY-PODC-BA}.
}}

\author{Armando Casta\~{n}eda\thanks{Universidad Nacional Aut\'onoma de M\'exico (UNAM), \mbox{\emph{E-mail}: \href{mailto:armando@im.unam.mx}{armando@im.unam.mx}}.}
\and Yannai A.~Gonczarowski\thanks{The Hebrew University of Jerusalem and Microsoft Research, \mbox{\emph{E-mail}: \href{mailto:yannai@gonch.name}{yannai@gonch.name}}.}
\and Yoram Moses\thanks{Technion --- Israel Institute of Technology, \mbox{\emph{E-mail}: \href{mailto:moses@ee.technion.ac.il}{moses@ee.technion.ac.il}}.}}

\date{May 23, 2016}

\maketitle
\begin{abstract}
The \defemph{set consensus} problem has played an important role in the study of distributed systems for over two decades. Indeed, the search for lower bounds and impossibility results for this problem  spawned the topological approach to distributed computing, which has given rise to new techniques in the design and analysis of protocols. The design of efficient solutions to set consensus has also proven to be challenging.
In the synchronous crash failure model, the literature contains a sequence of solutions to set consensus, each improving upon the previous ones.

This paper presents an \defemph{unbeatable} protocol for nonuniform -set consensus in the synchronous crash failure model.
This is an efficient protocol whose decision times \emph{cannot} be improved upon.
Moreover, the description of our protocol is extremely succinct.
Proving unbeatability of this protocol is a nontrivial challenge.
We provide two proofs for its unbeatability: one is a subtle constructive combinatorial proof, and the other is a topological proof of a new style.
These two proofs provide new insight into the connection between  topological reasoning and combinatorial reasoning about protocols, which has long been a subject of interest. In particular, our topological proof  reasons in a novel way about subcomplexes of the protocol complex, and sheds light on an open question posed by Guerraoui and Pochon (2009).
Finally, using the machinery developed in the design of this unbeatable protocol, we propose a protocol for uniform -set consensus that beats all known solutions by a large margin.

\end{abstract}

\noindent
\textbf{Keywords}:
-set consensus; uniform -set consensus; optimality; unbeatability; topology; knowledge.

\section{Introduction}

The \defemph{k-set consensus} problem~\cite{Chaudhuri90}, which allows processes to decide on up to~ distinct values,
has played an important role in the study of distributed systems for more than two decades.
Its analysis provided deep insights into concurrency and solvability of tasks in fault-tolerant settings, both synchronous and asynchronous
(e.g. \cite{AGGT, BorowskyG93,CHLT, GGP,GHP, Herlihy:1999, SaksZ00}).
Whereas combinatorial techniques sufficed for the study of the traditional (1-set) consensus problem \cite{FLP},  establishing lower bounds and impossibility results for the more general
-set consensus has proven to be more challenging. Tackling these has given rise to the introduction of topological techniques to the theory of distributed systems, and these have become a central tool (see~\cite{Herlihy2013} for a detailed treatment of the subject).

In the synchronous message passing model, the literature distinguishes between uniform and  nonuniform variants of the classic consensus problem.  In nonuniform consensus only the correct processes (the ones that do not crash) are required to decide on the same value, while values decided on by processes who crash are allowed to deviate from the
value decided by
correct processes. In uniform consensus, however, all decisions must be the same. In asynchronous models the two variants coincide, since there is never a guarantee that a silent process has crashed.
Perhaps due to the fact that -set consensus was first studied in the asynchronous setting, only its uniform variant (in which the total number of distinct values decided by correct \emph{and faulty} processes is no greater than~) has been considered in the literature.

This paper is concerned with -set consensus in the synchronous message-passing model. In this setting, there are well-known bounds relating the degree of coordination that can be achieved (captured by the parameter~), the number of process crashes that occur
in a given execution (typically denoted by~), and the time required for decision, which is
 in the uniform case (see \cite{AGGT,GGP,GHP}).
Given an {\it a priori} bound of~ on the total number of crashes in a run, the worst-case lower bound for decision is 
\cite{CHLT}.

We consider both uniform and nonuniform variants of -set consensus. For the nonuniform case, we present a protocol
that we call
,
which is \defemph{unbeatable}, in the sense of \cite{AYY-DISC}. Unbeatability is a very strong form of optimality: A -set consensus protocol~ that always decides at least as soon as  cannot have even one process ever
decide
strictly earlier than
when that
process
decides
in .
For the uniform case, we present
a protocol that we call
,
which is built using methods similar to those used for
,
and which
strictly
beats
all known protocols, often by a large margin. In many cases,  decides in 2 rounds against an adversary for which the best known early-deciding protocols would decide in  rounds. Whether  is unbeatable remains an open problem.

The first unbeatable protocols for consensus (in both uniform and nonuniform variants) were presented in \cite{AYY-DISC}.
The analysis of those unbeatable consensus protocols
shows that the notion of a \defemph{hidden path} is central to the inability to decide in consensus.
Roughly speaking,
a hidden path w.r.t.\  a process~ at the end of round~ is a sequence
of processes that crash one after the other and
could inform
some process~
at time~ of an
initial
value
unknown to
.

Our improved -set consensus protocols are based on an observation that the time required for decision does not depend simply on the number of processes that crash in each round. Only failures that occur in a very specific
pattern, maintaining what we call a \defemph{hidden capacity} of~, can prevent processes from being able to decide.
The hidden capacity is a generalization of the notion of a hidden path, which, as mentioned above,
was shown in \cite{AYY-DISC} to play
an important role in consensus.

The main contributions of this paper are:

\begin{itemize}
\item We provide new solutions to -set
consensus
in the synchronous message passing model with crash failures. For the nonuniform case, we present the first unbeatable protocol for -set consensus, called : No protocol can
beat the decision times of
.
For uniform -set consensus, we present a protocol  that strictly
beats
all known early-deciding solutions in the literature \cite{AGGT, CHLT, GGP,GHP, RRT}, in some cases beating (all of) them by a large margin.

\item We identify a quantity called the hidden capacity
of
a given execution
w.r.t.\ a process  at time ,
which plays a major role in determining the decision times in runs of -set consensus. Roughly speaking, once its hidden capacity drops below~, process~ can decide. Maintaining a hidden capacity of~ requires at least~ processes to crash in every round. However, they must crash in a very particular fashion. In previous solutions to -set consensus in this model (see, e.g., \cite{GGP}),
a process that observes~ or more new failures per round will not decide. In our protocols,
decision can be delayed only as long as failures maintain a hidden capacity of~ or more.
\item Proving unbeatability has the flavor of a lower bound or impossibility proof.
Unsurprisingly, proving
the unbeatability of 
is extremely subtle. We present two different proofs of its unbeatability. One is a completely constructive, combinatorial proof, while the other is a nonconstructive, topological proof based on Sperner's lemma.
The latter is a new style of topological proof, since it addresses the local question of when an individual process can decide, rather than  the more global question of when the last decision is made.
This sheds light on the open problem and challenge posed by Guerraoui and Pochon in~\cite{GP09} regarding how topological reasoning can be used to obtain bounds on local decisions.
Topological lower bounds for -set consensus (e.g. \cite{CHLT,GHP}) have established that  connectivity (in addition to a Sperner coloring) precludes the possibility that all processes decide.
Our analysis provides further insight into the topological analysis for local decisions, illustrating  that hidden capacity of~ implies
 connectivity of a subcomplex of the protocol complex in a given round.
 The hidden capacity thus explains the source of topological connectivity that underlies the lower-bound proofs for -set consensus.
 To the best of our knowledge, this is the first time knowledge and topological techniques directly interact to obtain a topological characterization.
\end{itemize}

The appendix
contains the detailed technical analysis that supports the claims in the main part of the paper. This includes
full proofs of all technical claims. In particular, both the full combinatorial proof of unbeatability and
the corresponding
topological proof are presented in \cref{sec-proofs-k-set}.

\section{Preliminary Definitions}
\label{sec:model}

\subsection{Computation and Communication Model}
\label{sec:model-communication}

Our model of computation is a synchronous, message-passing model with
benign crash failures.
A system has~\mbox{} processes denoted by
.
Each pair of processes is connected by a two-way communication link,
and each message is tagged with the identity of the sender.
Processes
share a discrete global clock that starts
at time~ and
advances by increments of one. Communication in the system proceeds in
a sequence of \defemph{rounds}, with round~ taking place between
time~ and time~.
Each process starts in some \defemph{initial state} at time~,
usually with an \defemph{input value} of some kind.
In every round, each process first performs a local computation, and performs local actions,
then
it sends a set of messages to other processes, and finally receives messages sent to it
by other processes during the same round.
We consider the
local computations and sending actions of round~ as being performed at time~,
and the messages are received at time~.

A faulty process fails by \defemph{crashing} in some round~.
It behaves correctly in the first~ rounds and
sends no messages from round~ on.
During its crashing round~, the process may succeed in
sending messages on an arbitrary subset of its links.
At most~ processes fail in any given execution.

It is convenient to consider the state and behavior of processes at different (process-time) nodes, where a \defemph{node}  is a pair  referring to process~ at time~.
A \defemph{failure pattern} describes how processes fail in an execution.
It is a layered graph~ whose vertices are
all nodes
 for  and .
An edge has the form 
and it denotes the fact that a message sent by~ to~ in round~ would be delivered successfully.
Let~ denote the set of failure patterns in which
all failures are crash failures, and
at most~ crash failures can occur.
An \defemph{input vector} describes what input the processes receive in an
execution. The only inputs we consider are initial values that processes obtain at time~0.
An input vector is thus a tuple  where~ is the input to process~.
We think of the input vector and the failure pattern as being determined by an external scheduler, and thus a  pair  is called an
\defemph{adversary}.

A \defemph{protocol} describes what messages a process sends and what decisions it takes,
as a deterministic function
 of its local state at the start of the round.  Messages received during a round affect the local state at  the start of the next round.
We assume that a protocol~ has access to the number of processes~ and to the bound~,
typically passed to~ as parameters.

A \defemph{run} is a description of an infinite behavior of the system.
Given a run~ and a time~,
the \defemph{local state} of process~ at time~ in~
is denoted by ,
and the \defemph{global state} at time 
is defined to be .
A protocol~ and an adversary~ uniquely determine a run,
and we write .

Since we restrict attention to benign failure models and focus on decision times and solvability in this paper, Coan showed that it is sufficient to consider {\em full-information} protocols ({\em fip}'s for short), defined below \cite{Coan}.
There is a convenient way to consider such protocols in our setting.
With an adversary  we associate a \defemph{communication graph}
,
consisting of the graph~ extended by labeling the initial nodes  with the initial states  according to~.
With every node  we associate a subgraph   of~, which we think of as 's
\defemph{view} at .
Intuitively, this graph
represents
all nodes  from which  has heard, and the initial values it has seen.
Formally,  is defined by induction on~.
 consists of the node , labeled by the initial value~.
Assume that  have been defined, and let  be the set of processes~ such that  or  is an edge of~. Then
 consists of the node , the union of all graphs  with , and the edges
 for all .
We say that  is
\defemph{seen} by  if  is a node of . Note that this occurs exactly
if  allows a (Lamport) message chain from  to .

A full-information protocol  is one in which at every node  of a run  the process~ constructs  after receiving its round~ nodes, and sends  to all other processes in round~\mbox{}. In addition,  specifies what decisions  should take at  based on .
Full-information protocols thus differ only in the decisions taken at the nodes.
Finally, in a run , we define the local state  of a process~ at time~ to be the pair
, where  if  is undecided at time~, and if  in case~ has decided~
at or before time .

For ease of exposition and analysis, all of our  protocols are
\fip's.
However, in fact, they can all be implemented in such a way that any process sends any other
process a total of  bits throughout any execution
(see \cref{sec-com-eff}).

\subsection{Domination and Unbeatability}

A protocol~ is a \defemph{worst-case optimal} solution to a decision problem~ in a given model
if it solves~, and decisions in~ are always taken no later than the {\em worst-case} lower bound for decisions in this problem, in a given model of computation.
However, this protocol can be strictly improved upon by \defemph{early stopping} protocols,
which are also worst-case optimal, but can often decide much faster than the original ones.
In this paper, we are interested in protocols that are efficient in a much stronger sense.

Consider a  context , where  is a set of initial vectors.
A decision protocol  \defemph{dominates} a protocol~ in~, denoted by  if, for all adversaries  and every process~,
if  decides in~ at time~, then  decides in  at some time
. Moreover, we say that   \defemph{strictly dominates} 
if  and  . I.e., if it dominates~ and for some  there exists a process~ that decides in  {\em strictly before} it does so in .

Following \cite{HMT11},
a protocol~ is said to be an  \defemph{all-case optimal} solution to a decision task~ in a context~ if it solves~ and, moreover,  dominates every protocol~ that solves~ in~.
For the standard ({\em eventual}) variant of consensus, in which decisions are not required to occur simultaneously, Moses and Tuttle showed that no all-case optimal solution exists~\cite{MT}.
Consequently, Halpern, Moses and Waarts in \cite{HalMoWa2001} initiated the study of a natural notion of optimality
that is achievable by eventual consensus protocols:

\begin{definition}[\cite{HalMoWa2001}]
A protocol  is an \defemph{unbeatable} solution to a decision task~ in a context~ if  solves~ in~ and no protocol  solving~ in~ strictly dominates~.\footnote{Unbeatable protocols were called {\em optimal} in \cite{HalMoWa2001}. Following \cite{AYY-DISC},
we prefer the term {\em unbeatable} because ``optimal'' is used very broadly, and inconsistently, in the literature.}
\end{definition}

Thus,  is unbeatable if for all protocols~ that solve~, if there exist an adversary~ and process~ such that~
decides in  strictly earlier than it does in , then there must exist some adversary~ and process~ such that  decides strictly earlier in  than it does in . An unbeatable solution for~ is -minimal among the solutions of~.

\subsection{Set Consensus}

In the -set consensus problem, each process  starts out with an initial value .\footnote{The set of values in -set consensus is  often assumed to contain more than  values. We choose this set for ease of exposition. Our results apply equally well with minor modifications if a larger set of values is assumed. See \cref{more-values}.}
Denote by  the fact that at least one of the processes started out with initial value~.
In  a protocol for (nonuniform) -set consensus,
the following properties must hold in every run~:

\begin{itemize}
\item[]{\kAgreement:}
The set of values that correct processes decide on has cardinality at most~,
\item[]{\Decision:} Every correct process must decide on some value, and
\item[]{\Validity:} For every value~, a decision on~ is allowed only if~ holds.
\end{itemize}

In uniform -set consensus \cite{CBS-uni,Dutta-uni,H86,KR-uni,Raynal04-uni,WTC-uni}, the \kAgreement\ property is replaced by

\begin{itemize}
\item[]{\UnikAg:}
The set of values decided on
has cardinality at most~.
\end{itemize}

\noindent
In uniform -set consensus,
values decided on by failing processes
(before they have failed)
are counted, whereas in the nonuniform case they are not
counted.
The two notions coincide in asynchronous settings, since it is never possible to distinguish at a finite point in time between a crashed process and a very slow one.
Uniformity may be desirable
when elements outside the system can observe decisions, as in distributed databases when decisions correspond to commitments to values.

\section{Unbeatable (1-set) Consensus}
\label{sec:unB-consensus}

Before introducing our protocols for -set consensus, we briefly review the analysis and the unbeatable protocol for nonuniform (-set) consensus
 given in \cite{AYY-DISC}.
In this version of the problem, all processes start with binary initial values ,
decisions must satisfy the validity condition, and all correct processes decide on the same value. Recall that we are assuming that the processes follow a full-information protocol, so a protocol can be specified simply by giving the rules by which a process decides on value~, for .

By Validity,  is a necessary condition for deciding on a value~.
Consequently, a process cannot decide~ unless it knows that some process had initial value~.\footnote{This is an instance of the so-called {\em Knowledge of Preconditions} principle of~\cite{Moses-tark2015}, which states that if ~ is a necessary condition for process~ performing an action~, then  must {\em know}~ when it performs~. For more details on the use of this principle in our setting, see \cref{thm:knowprec} in \cref{sec:know}
and~\cite{AYY-DISC}.}
Clearly, a process knows  if it sees a value of~, either as its own initial value or reported in a message that the process receives. \cite{AYY-DISC} consider the design of a protocol that will decide on~0 as soon as possible, namely at the first point at which
a process
 knows~.
They proceed to consider when a process can decide~1, given that all processes
decide~0 if they ever come to know that~. Clearly, we should consider the possibility of deciding~1 only for processes that do not know that~.
By the (-)\Agreement\ property, correct processes must decide on the same value.
Thus, a process cannot decide~1 if another process is deciding~0. Let us consider when a process can know that nobody is deciding~0.

Our analyses will make use of the different types of information that a process~ at time~ can know about the state of a process  at time , in runs of an \fip. (We denote such process-time pairs by , , etc.) We say that  is \defemph{seen by} 
if~ has received a message by time~ containing the state at . We say that  is \defemph{guaranteed crashed} at  if~ has proof at time~ that~ crashed \emph{before} time~ ( heard from someone who did not hear from~ in some round~). Finally, we say that  is \defemph{hidden from}  if it is neither seen by  nor guaranteed crashed there.
As far as~ is concerned,  may have sent messages in round~, and since~ does not see , it may not know at~ what information 's messages contained.

\cref{fig-hidden-path} illustrates a case in which process~ does not know  at time~2, while process~ decides~0 at time~2. This is possible only if there is a \defemph{hidden path} with respect to ,  in the terminology of~\cite{AYY-DISC}: at each time~ from~0 up to the current time , there is a node  that is hidden from~.

\begin{figure}[t]
    \centering
        \subfigure[A hidden path w.r.t.\ .]{
            \label{fig-hidden-path:first}
	    \includegraphics[width=0.41\textwidth]{hidden-path-1}
        }
        \qquad\qquad\qquad
        \subfigure[A run  considers at  to be possible, in which  is held by a correct process at .]{
            \label{fig-hidden-path:second}
	    \includegraphics[width=0.41\textwidth]{hidden-path-2}
        }
        \vspace{-0.3cm}
        \caption{
            A hidden path at time  indicates that a value unknown to  may exist in the system.
        }
	\label{fig-hidden-path}
\end{figure}

In general, if there is a hidden path with respect to~ in a given execution, and process~ does not know  at time~, then~ cannot be guaranteed that no correct process is currently deciding~0. It thus cannot decide~1. If no such path exists, i.e., if there is some time  that contains no hidden node w.r.t.~, then  knows that nobody is deciding~0. Moreover, in that case~ knows that no value of~0 is known to any active process, and so nobody will ever decide~0. Based on this analysis, \cite{AYY-DISC} proposes the following protocol:

\vspace{\topsep}
\noindent
\underline{{\bf Protocol}~}
 (for an undecided process~ at time~)~\cite{AYY-DISC}:\.6ex]
\begin{tabular}{lll}
\quad {\bf if} &  is low or~ has hidden capacity  & {\bf then}~~
\end{tabular}
\vspace{\topsep}

Our protocol  directly generalizes the unbeatable consensus protocol . Being low in this case corresponds to seeing~0,
while  corresponds to there being
no hidden path.
Recall
that the decision rules of  may be thought of as follows: a process  decides on the value~ as soon as it knows that
some node had initial value~, and it decides on the value~ as soon as it knows that no correct process will ever decide on the value~
(hence \Agreement\ is not violated).
In , a process  decides on a low value~ (i.e., a value )
as soon as it knows that some node had initial
value~, and decides on
the high value  (indeed, for a high node , we have ) as soon as it knows that at most  values smaller than 
will ever be decided on by correct processes (thus satisfying \kAgreement).

Based on the above analysis, we obtain:\footnote{\label{more-values}We note that \cref{k-set-correct}, as well as all other the results that we present, including \cref{thm:OptMink,thm:last-decider,u-k-solve} below, as well as all proofs in the
appendix, hold verbatim even if the set of possible initial values is , for some . (In this case, all values in  are considered high.) In particular, the definition for this case of all protocols, including , is unchanged.}

\begin{proposition}
\label{k-set-correct}
 solves -set
consensus, and
all processes decide by time
.
\end{proposition}

\subsection{Unbeatability}

Proving that  is unbeatable
is nontrivial.\footnote{In particular, the challenges involved are significantly greater than those in involved in proving that  is unbeatable for (-set) consensus (as is often the case with problems regarding -set consensus vs.\ their (-set) consensus counterparts).} The main technical challenge along the way is,
roughly speaking, showing that, e.g., in the scenario depicted in \cref{fig-hidden-capacity}, each of the
hidden
processes at time  (i.e.,  for ) decides on the
unique low value () known to it, not merely in , but in \emph{any} protocol  that dominates . Indeed, in the scenario depicted in \cref{fig-hidden-capacity}, one could imagine a hypothetical protocol in which all active nodes decide at time  on some high value, say the initial value of process~, thus guaranteeing that  will not violate \kAgreement\ by deciding on this value immediately as well.
The claim that such a hypothetical protocol does not exist is made precise in \cref{two-face}
(see also a discussion in \cref{two-approaches}
below).

\begin{lemma}
\label{two-face}
Let  be a protocol solving nonuniform -set consensus.
Assume that in~, every process  that is low at any time~
must decide by time~ at the latest.
Let~ be a run of~,
let  be a process and let~ be a time.
If the following conditions hold in~:
\begin{enumerate}
\item\label{two-face-first-time}
 is low at~ for the first time,
\item
 has seen a single low value

by time~,
\item
, and
\item
there exist  distinct processes 
s.t.\ 
is high
and  is hidden from ,
for all .
\end{enumerate}
then  decides in~ on its unique low value  at time~.
\end{lemma}
\noindent
We note that for
, the nodes  in \cref{fig-hidden-capacity} indeed meet the requirements of \cref{two-face} at time . (E.g., for , we may take the processes called  in \cref{fig-hidden-capacity} to serve as the processes  in the statement of the \lcnamecref{two-face}.)
Given \cref{two-face}, using reasoning similar to our discussion above regarding the decision rules in , we conclude that
a high process with hidden capacity at least  (such as process~ at time  in \cref{fig-hidden-capacity}, for ) cannot decide in
any protocol  that dominates 
without risking violating \kAgreement\ (see \cref{k-set-cant-decide-before} in \cref{sec-proofs-k-set}), from which the
unbeatability
of  follows (indeed, all undecided nodes in  are high
and have hidden capacity at least ,
and are therefore undecided under  as well).

\begin{theorem}
\label{thm:OptMink}
 is an unbeatable protocol for non\-uniform -set consensus in the crash failure model.
\end{theorem}

We stress that  is implementable in such a way that each process sends
each other process  bits throughout the run, and each process requires  local steps in every round (see \cref{sec-com-eff}).
Thus, unbeatability for -set consensus is attainable at a modest price.

\subsubsection{Last-decider unbeatability}
In \cite{AYY-DISC} the authors also consider  a variation on the notion of unbeatability, called \defemph{last-decider unbeatability}, which compares runs in terms of the time at which the last correct process decides.
This notion neither implies, nor is implied by, unbeatability as defined above.
Interestingly,  is unbeatable in this sense as well (see \cref{sec-last-decider}):

\begin{theorem}
\label{thm:last-decider}
 is last-decider unbeatable for non\-uniform -set consensus in the crash failure model.
\end{theorem}

\subsection{A Constructive Combinatorial Approach vs.\texorpdfstring{\\}{ }A Nonconstructive Topological Approach}
\label{two-approaches}

In \cref{sec-proofs-k-set}, we provide
two proofs for \cref{two-face}. One is combinatorial and completely constructive,
devoid of any topological arguments, while the other
 is nonconstructive and topological, based on Sperner's lemma.
Our topological proof  reasons in a novel way about subcomplexes of the protocol complex.
Both proofs of
\cref{two-face} are by induction.
In both proofs, the induction hypothesis and the (proof of the) base case are the same.
The proofs differ only in
the induction step.

In the terminology of \cref{two-face},
both proofs start by showing that there exists a run that  finds possible in which each of the  nodes at
time  that are hidden from  holds a distinct low value other than ; therefore, by the induction hypothesis, had these  nodes not failed, they would have each  decided  on its unique low value. Hence, each of the nodes  must consider it possible that all of the hidden nodes that it sees from time  have actually decided and are correct. The challenge is to show, without any information about  except for the initial assumption that it dominates , that there must exist a run  of  that  finds possible (i.e., a way to adjust the messages received by  at time ) in which  collectively decide on all low values (including ) at time ; see \cref{fig-two-face}.\begin{figure}[t]
    \centering
        \subfigure[, as seen by .]{
            \label{fig-two-face:first}
	    \includegraphics[height=5.7cm]{two-face-1}
        }\quad
        \subfigure[The run .]{
            \label{fig-two-face:second}
	    \includegraphics[height=5.7cm]{two-face-2}
        }\quad
        \subfigure[, as seen by . The induction hypothesis dictates  decides on  at~.]{
            \label{fig-two-face:third}
	    \includegraphics[trim={0 0 6.5cm 0},clip,height=5.7cm]{two-face-3}
        }\quad
        \subfigure[We aim to adjust the messages received by  at  in , so that they collectively decide on all low values.]{
            \label{fig-two-face:fourth}
	    \includegraphics[height=5.7cm]{two-face-4}
        }
        \vspace{-0.3cm}
        \caption{
            The proof strategy for the induction step of \cref{two-face} (for , ).
        }
	\label{fig-two-face}
\end{figure}
 Therefore,  cannot decide on a high value without violating \kAgreement\ (and since it must decide, it must do so on a low value, and therefore on the only low value that is has seen, namely ).

Our combinatorial proof for the induction step constructively builds such a possible run  as required (providing a ``recipe'' for how to adjust the messages received by  at time  so that they collectively decide on all low values).
In contrast, our topological proof uses Sperner's
lemma to show that if process  does not decide on a low value, then there must exist a run of the protocol that violates \kAgreement\
(i.e., a run  as described above).
It is interesting that the topological proof essentially shows that
 is forced to decide on a low value in the run  because the star complex, denoted ,
of the node~ in the protocol complex  of the protocol~ at time , is -connected.
Intuitively,

is the ``part'' of  containing all executions
that are indistinguishable to .
That  is -connected is the reason why the proof can map a subdivision of
-simplexes
to process states; indeed, the subdivision is mapped to a subcomplex of .
Therefore,  has no other choice than to decide on a low value,
because if it does not do so, then its decision induces a Sperner coloring,
which ultimately (together with the connectivity of )  implies that the \kAgreement\ property is violated.

It is worth noticing that in this topological analysis we only
care about the connectivity of a proper subcomplex of the protocol complex,
contrary to all known time-complexity lower-bound proofs~\cite{GHP,HRT98}
for -set consensus, which care about the
connectivity of the whole protocol complex
in a given round.
While connectivity of the whole protocol complex is the ``right'' thing to consider for lower-bound proofs about when
\emph{all} processes can decide,
we show that for proving unbeatability, i.e., when
concerned with the time at which a \emph{single}
process can decide,
the ``right'' thing to consider is the connectivity of just
a subcomplex
(the star complex of a given process state).

This analysis sheds light on the open question posed by Guerraoui and Pochon in~\cite{GP09}
asking for extensions to previous topology techniques that deal with
optimality of protocols.
In summary, while all-decide lower bounds have to do with
the whole protocol complex (e.g.~\cite{HRT98}),
optimal-single-decision lower bounds have to do
with just subcomplexes of the protocol complex. Our topological proof of unbeatability
here is the first proof that we are aware of that makes this distinction.

Finally, we emphasize
that the connectivity properties of the
star
complex 
are due to
the hidden capacity of  in the hypothesis of \cref{two-face}.
Indeed,
one can formally relate
the connectivity of  to the hidden capacity of ,
as
we now show.

\begin{proposition}
\label{hidden-capacity-connectivity}
Let  be the -round protocol complex
containing all -round executions of
a \fip\ .
If  is a vertex of 
whose view corresponds to a local state with hidden capacity
at least  in each of the  rounds,
then the star complex  of  in  is -connected.
\end{proposition}

\cref{hidden-capacity-connectivity} speaks about a local property in protocol
complexes, which turns out to be important for optimality analysis.
It is unknown whether the converse of this lemma is true, namely,
whether
-connectivity of the star complex implies hidden capacity at least  in every round.

\section{Uniform Set Consensus}
\label{subsec-uni-k}

We now turn to consider {\em uniform} -set consensus.
In \cite{AYY-DISC}, the concepts of
hidden paths and hidden nodes
are used to present an unbeatable protocol  for (-set) uniform consensus.
In this section, we present a protocol called  that generalizes the unbeatable  to~ values (i.e.\ for , it behaves exactly like ).
As in the nonuniform case, the analysis of the case  is significantly more
subtle and challenging; in fact, generalizing the protocol statement in the uniform case is
considerably
more involved than in the nonuniform case.

While in the protocol  (which is defined in \cref{sec-set-consensus} for nonuniform consensus) an undecided process~ decides on its minimal value if and only if
 is low or has hidden capacity , in  we have to be more careful. Indeed, we must ensure that a value (even a low one) that process  decides upon  will not ``fade away''.
This could happen if~ is the only one knowing the value,  and if~ crashes without successfully communicating it to active processes.
The case analysis here is also significantly more subtle than in the case of (-set) uniform consensus. To phrase the exact conditions for decision, we begin with a definition; recall that~ is
an upper bound on the
number of faulty nodes in any given run, and is available to all processes; while curiously the knowledge of~ cannot be used to speed up , it is indeed useful for speeding up decisions in the uniform case.

\begin{definition}[\cite{AYY-DISC}]
Let  be a run and assume that  knows of  failures at time  in run . We say that   \defemph{knows that the value~ will persist} at time  if (at least) one of the following holds.
\begin{itemize}
\item
, and~ both is active at time~ and has seen the value~ by time , or
\item
 sees at least  distinct nodes  of time~ that have seen the value~.
\end{itemize}
\end{definition}
\noindent
As shown in~\cite{AYY-DISC}, if  knows at time~ that  will persist, then all active nodes at time~ will know .
Everyone's minimal value will be no larger than~ from that point on.

In ,  an undecided process~ decides on a value  if and only if  is the minimal value s.t.\  knows that both
\begin{itemize}
\item
 was at some stage the min value known to a process that was low or had hidden capacity~, and
\item
 will be known to all processes deciding strictly after~.
\end{itemize}
As mentioned above, designing  to check that these conditions hold requires
a careful
statement of the protocol, which we now present.

\vspace{\topsep}
\pagebreak
\noindent
\underline{{\bf Protocol}~}
 (for an undecided process~ at time~):\\mathtt{w} \in \bigl\{ \minval{h,\ell} \mid
\mbox{ is hidden from } \bigr\}.
v \in \knownvals{i_b^{\ell-1},\ell-1} \subseteq \knownvals{i,\ell-1} \cup \set{\mathtt{v}_b}
\subseteq \knownvals{i,\ell} \cup \set{\mathtt{v}_b}.w \in \bigl\{ \minval{h,\ell} \mid
\mbox{ is hidden from } \bigr\}.
As there are at most  processes hidden at  from ,
we conclude that no more than  distinct values lower than  are
decided upon, and the proof is complete.
\end{proof}

\section{Last-Decider Unbeatability}
\label{sec-last-decider}

We first formally define last-decider unbeatability.

\begin{definition}[Last-Decider Domination and Unbeatability]
\leavevmode
\begin{itemize}
\item
A decision protocol  \defemph{last-decider dominates} a protocol~ in~, denoted by  if, for all adversaries , if  the last decision in~ is at time , then all decisions in  are taken before or at . Moreover, we say that   \defemph{strictly last-decider dominates} 
if  and  . I.e., if for some  the last decision in  is {\em strictly before} the last decision in .
\item
A protocol  is a \defemph{last-decider unbeatable} solution to a decision task~ in a context~ if  solves~ in~ and no protocol  solving~ in~ strictly last-decider dominates~.
\end{itemize}
\end{definition}

\begin{remark}
\leavevmode
\begin{itemize}
\item
If , then . (But not the other way around.)
\item
None of the above forms of strict domination implies the other.
\item
None of the above forms of unbeatability implies the other.
\end{itemize}
\end{remark}

Last-decider domination does not imply domination in the sense of the rest of this paper (on which our proof is based).
Nonetheless, the specific property of protocols dominating  that we use to prove that these protocols are unbeatable, holds also for protocols that only last-decider dominate these protocols.

\begin{lemma}\label{last-dom-sufficient}
Let  satisfy \Decision. If  is low at  in a run  of , then  decides in  no later than at .
\end{lemma}

The main idea in the proof of \cref{last-dom-sufficient} is to show that  considers it possible that
all other active processes also know the fact stated in that part,
and so they must all decide by the current time in the corresponding run of the dominated protocol. Hence, the last decision decision in that run is made in the current time; thus, by last-decider domination,  must decide.

\begin{proof}[Proof of \cref{last-dom-sufficient}]
If , then there exists a run  of , s.t.~~\emph{i)} ,~~\emph{ii)} in  all initial values are , and~~\emph{iii)}  never fails in . Hence, in  all decisions
are taken at time , and therefore so is the last decision. Therefore, the last decision in  must be taken at time . As  never fails in , by \Decision\ it must decide at some
point during this run, and therefore must decide at  in . As ,  decides at  in  as well, as required.

If , then there exists a process  that is low at  in  and  is seen by . Thus, there exists a run  of ,
s.t.~~\emph{i)} , and~~\emph{ii)}  and  never fail in . Thus, all processes that are active at  in  see  and are therefore low.
Hence, in  all decisions are taken by time , and therefore so is the last decision. Therefore, the last decision in  must be taken no later than at time .
As  never fails in , by \Decision\ it must decide at some point during this run, and therefore must decide by  in . As ,  decides by  in  as well, as required.
\end{proof}

As explained above, \cref{thm:last-decider} follows from \cref{last-dom-sufficient}, and from the proof of \cref{thm:OptMink}.

\section{Efficient Implementation}\label{sec-com-eff}

Throughout this paper we have assumed that processes follow the \fip, and did not concern ourselves with implementation details. Notice that the only information that processes use in these protocols concerns the values that processes have seen and the failures that they observe. This determines which nodes are seen by, known to be crashed by, or hidden from a node . We now show that a more efficient protocol exists in which the processes obtain the same information about these three aspects of the run as in the \fip.

\begin{lemma}
For each of the protocols  and , there is a protocol with identical decision times for all adversaries, in which every process sends at most  bits overall to each other process.
\end{lemma}

\begin{proof}[Proof (Sketch)]
Moses and Tuttle in \cite{MT} show how to implement full-information protocols in the crash failure model with linear-size messages. In our case, a further improvement is possible, since decisions in all of the protocols depend only on the identity of hidden nodes and on the vector of initial values. In a straightforward implementation, we can have a process  report  ``{\tt value}'' once for every  whose initial value it discovers, and ``{\tt failed\_at}'' once where~ is the earliest failure round it knows for . In addition, it should send an ``{\tt I'm\_alive}'' message in every round in which it has nothing to report. Process~ can send at most one {\tt value} message and two
{\tt failed\_at} messages for every . Since {\tt I'm\_alive} is a constant-size message sent fewer than~ times, and since encoding~'s ID requires  bits, a process~ sends a total of  bits overall.
\end{proof}

We also note that it is straightforward to compute the hidden capacity of a node 
in a run with adversary~ based on the communication graph~. The hidden capacity
of  can also be very efficiently calculated from the hidden capacity of  using auxiliary
data calculated during the calculation of the latter.

\end{document}