\documentclass[11pt]{article}

\usepackage{graphicx,geometry,verbatim,color}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{float}

\floatstyle{ruled}
\newfloat{algorithm}{thp}{lop}[section]
\geometry{verbose,tmargin=1in,bmargin=1.5in,lmargin=1in,rmargin=1in}
\newenvironment{proof}{\noindent\textbf{Proof}}{\hfill\qed}
\newcommand{\qed}{\hfill}
\newtheorem{lem}{Lemma}
\newtheorem{theo}{Theorem}
\newtheorem{defi}{Definition}
\newenvironment{theorem}[1]{\vspace{-0.25cm}\begin{theo}#1}{\end{theo}\vspace{-0.3cm}}
\newenvironment{definition}[1]{\vspace{-0.25cm}\begin{defi}#1}{\end{defi}\vspace{-0.3cm}}
\newenvironment{lemma}[1]{\vspace{-0.25cm}\begin{lem}#1}{\end{lem}\vspace{-0.3cm}}

\begin{document}

\title{The Impact of Topology on Byzantine Containment in Stabilization}

\author{Swan Dubois\protect\footnote{Universit\'e Pierre et Marie Curie \& INRIA, France, swan.dubois@lip6.fr} \footnote{Contact author, Telephone: 33 1 44 27 87 67, Postal address: LIP6, Case 26/00-225, Campus Jussieu, 4 place Jussieu, 75252 Paris Cedex 5, France} \and Toshimitsu Masuzawa\protect\footnote{Osaka University, Japan, masuzawa@ist.osaka-u.ac.jp} \and S\'{e}bastien Tixeuil\protect\footnote{Universit\'e Pierre et Marie Curie \& INRIA, France, sebastien.tixeuil@lip6.fr}}
\date{}

\maketitle

\begin{abstract}
Self-stabilization is an versatile approach to fault-tolerance since it permits a distributed system to recover from any transient fault that arbitrarily corrupts the contents of all memories in the system. Byzantine tolerance is an attractive feature of distributed system that permits to cope with arbitrary malicious behaviors. 

We consider the well known problem of constructing a maximum metric tree in this context. Combining these two properties prove difficult: we demonstrate that it is impossible to contain the impact of Byzantine nodes in a self-stabilizing context for maximum metric tree construction (strict stabilization). We propose a weaker containment scheme called \emph{topology-aware strict stabilization}, and present a protocol for computing maximum metric trees that is optimal for this scheme with respect to impossibility result.
\end{abstract}

\paragraph{Keywords}
Byzantine fault, Distributed protocol, Fault tolerance,
Stabilization, Spanning tree construction

\section{Introduction}

The advent of ubiquitous large-scale distributed systems advocates that tolerance to various kinds of faults and hazards must be included from the very early design of such systems. \emph{Self-stabilization}~\cite{D74j,D00b,T09bc} is a versatile technique that permits forward recovery from any kind of \emph{transient} faults, while \emph{Byzantine Fault-tolerance}~\cite{LSP82j} is traditionally used to mask the effect of a limited number of \emph{malicious} faults. Making distributed systems tolerant to both transient and malicious faults is appealing yet proved difficult~\cite{DW04j,DD05c,NA02c} as impossibility results are expected in many cases.

Two main paths have been followed to study the impact of Byzantine faults in the context of self-stabilization:
\begin{itemize}
\item \emph{Byzantine fault masking.} In completely connected synchronous systems, one of the most studied problems in the context of self-stabilization with Byzantine faults is that of \emph{clock synchronization}. In~\cite{BDH08c,DW04j}, probabilistic self-stabilizing protocols were proposed for up to one third of Byzantine processes, while in \cite{DH07cb,HDD06c} deterministic solutions tolerate up to one fourth and one third of Byzantine processes, respectively.
\item \emph{Byzantine containment.} For \emph{local} tasks (\emph{i.e.} tasks whose correctness can be checked locally, such as vertex coloring, link coloring, or dining philosophers), the notion of \emph{strict stabilization} was proposed~\cite{NA02c,SOM05c,MT07j}. Strict stabilization guarantees that there exists a \emph{containment radius} outside which the effect of permanent faults is masked, provided that the problem specification makes it possible to break the causality chain that is caused by the faults. As many problems are not local, it turns out that it is impossible to provide strict stabilization for those.
\end{itemize}

\noindent\textbf{Our Contribution.} In this paper, we investigate the possibility of Byzantine containment in a self-stabilizing setting for tasks that are global (\emph{i.e.} for with there exists a causality chain of size , where  depends on  the size of the network), and focus on a global problem, namely maximum metric tree construction (see \cite{GS99c,GS03j}). As strict stabilization is impossible with such global tasks, we weaken the containment constraint by relaxing the notion of containment radius to containment area, that is Byzantine processes may disturb infinitely often a set of processes which depends on the topology of the system and on the location of Byzantine processes.

The main contribution of this paper is to present new possibility results for containing the influence of unbounded Byzantine behaviors. In more details, we define the notion of \emph{topology-aware strict stabilization} as the novel form of the containment and introduce \emph{containment area} to quantify the quality of the containment.
The notion of topology-aware strict stabilization is weaker than the strict stabilization but is stronger than the classical notion of self-stabilization (\emph{i.e.} every topology-aware strictly stabilizing protocol is self-stabilizing, but not necessarily strictly stabilizing).

To demonstrate the possibility and effectiveness of our notion of topology-aware strict stabilization, we consider \emph{maximum metric tree construction}. It is shown in \cite{NA02c} that there exists no strictly stabilizing protocol with a constant containment radius for this problem. In this paper, we provide a topology-aware strictly stabilizing protocol for maximum metric tree construction and we prove that the containment area of this protocol is optimal.

\section{Distributed System}

A \emph{distributed system}  consists of a set
 of processes and a set  of
bidirectional communication links (simply called links).
A link is an unordered pair of distinct processes.
A distributed system  can be regarded as a graph whose vertex set is 
and whose link set is , so we use graph terminology to describe a
distributed system .

Processes  and  are called \emph{neighbors} if .
The set of neighbors of a process  is denoted by , and its
cardinality (the \emph{degree} of ) is denoted by .
The degree  of a distributed system  is defined as
.
We do not assume existence of a unique identifier for each process.
Instead we assume each process can distinguish its neighbors from each other
by locally arranging them in some arbitrary order:
the -th neighbor of a process  is denoted by
. The \emph{distance} between two processes
 and  is the length of the shortest path between  and .

In this paper, we consider distributed systems of arbitrary topology.
We assume that a single process is distinguished as a \emph{root},
and all the other processes are identical.

We adopt the \emph{shared state model} as a communication model
in this paper, where each process can directly read the states
of its neighbors.

The variables that are maintained by processes denote process states.
A process may take actions during the execution of the system. An
action is simply a function that is executed in an atomic manner
by the process.
The actions executed by each process is described by a finite set
of guarded actions of the form
guardstatement.
Each guard of process  is a boolean expression involving
the variables of  and its neighbors.

A global state of a distributed system is called a \emph{configuration}
and is specified by a product of states of all processes.
We define  to be the set of all possible configurations
of a distributed system .
For a process set  and two configurations  and ,
we denote 
when  changes to  by executing an action of each process
in  simultaneously.
Notice that  and  can be different only in
the states of processes in .
For completeness of execution semantics, we should clarify
the configuration resulting from simultaneous actions of
neighboring processes.
The action of a process depends only on its state
at  and the states of its neighbors at ,
and the result of the action reflects on the state of the process
at .

A \emph{schedule} of a distributed system is an infinite sequence of
process sets.  Let   be a schedule,
where  holds for each .
An infinite sequence of configurations
 is called an \emph{execution} from
an initial configuration  by a schedule ,
if  satisfies 
for each .
Process actions are executed atomically, and we also assume
that a \emph{distributed daemon} schedules the actions of processes,
i.e. any subset of processes can simultaneously execute
their actions.

The set of all possible executions from
 is denoted by .
The set of all possible executions is denoted by , that is,
.
We consider \emph{asynchronous} distributed systems
where we can make no assumption
on schedules except that any schedule is \emph{weakly fair}:
every process is contained in infinite number of subsets
appearing in any schedule.

In this paper, we consider (permanent) \emph{Byzantine faults}:
a Byzantine process (i.e. a Byzantine-faulty process)
can make arbitrary behavior independently from its actions.
If  is a Byzantine process,
 can repeatedly change its variables arbitrarily.

\section{Self-Stabilizing Protocol Resilient to Byzantine Faults}\label{sec:stab}

Problems considered in this paper are so-called \emph{static problems}, 
i.e. they require the system to find static solutions.
For example, the spanning-tree construction problem is a static problem,
while the mutual exclusion problem is not.
Some static problems can be defined by a \emph{specification predicate}
(shortly, specification), , for each process :
a configuration is a desired one (with a solution) if 
every process satisfies .
A specification  is a boolean expression
on variables of  where  is the set of processes
whose variables appear in .
The variables appearing in the specification are
called \emph{output variables} (shortly, \emph{O-variables}).
In what follows, we consider a static problem defined by
specification .

\noindent\textbf{Self-Stabilization.} A \emph{self-stabilizing protocol} (\cite{D74j}) is a protocol
that eventually reaches a \emph{legitimate configuration},
where  holds at every process , regardless of the initial configuration.
Once it reaches a legitimate configuration, every process never
changes its O-variables and always satisfies .
 From this definition, a self-stabilizing protocol is expected to tolerate 
any number and any type of transient faults since it can eventually 
recover from any configuration affected by the transient faults.
However, the recovery from any configuration is guaranteed
only when every process correctly executes its action from 
the configuration, i.e., we do not consider existence of
permanently faulty processes.

\noindent\textbf{Strict stabilization.} When (permanent) Byzantine 
processes exist, Byzantine processes may not satisfy .
In addition, correct processes near the Byzantine processes
can be influenced and may be unable to satisfy .
Nesterenko and Arora~\cite{NA02c} define
a \emph{strictly stabilizing protocol} as a self-stabilizing protocol 
resilient to unbounded number of Byzantine processes.

Given an integer , a \emph{-correct process} is a process 
 defined as follows.

\begin{definition}[-correct process]
A process is -correct if it is correct (\emph{i.e.} not Byzantine) and located at distance more than  from any Byzantine process.
\end{definition}

\begin{definition}[-containment]
\label{def:cfcontained}
A configuration  is \emph{-contained} for specification
 if, given at most  Byzantine processes, in any execution
starting from , every -correct process  always satisfies  and never changes
its O-variables.
\end{definition}

The parameter  of Definition~\ref{def:cfcontained} refers to 
the \emph{containment radius} defined in \cite{NA02c}. 
The parameter  refers explicitly to the number of Byzantine processes, 
while \cite{NA02c} dealt with unbounded number of Byzantine faults 
(that is ).

\begin{definition}[-strict stabilization]
\label{def:cfstabilizing}
A protocol is \emph{-strictly stabilizing} for specification
 if, given at most  Byzantine processes, any execution
 contains a configuration  that
is -contained for .
\end{definition}

An important limitation of the model of \cite{NA02c}
is the notion of -\emph{restrictive} specifications. 
Intuitively, a specification is -restrictive if it prevents 
combinations of states that belong to two processes  and  
that are at least  hops away. 
An important consequence related to Byzantine tolerance is that 
the containment radius of protocols solving those specifications is 
at least . 
For some problems, such as the spanning tree construction we consider
in this paper,  can not be bounded to a constant.
We can show that there exists no -strictly stabilizing
protocol for the spanning tree construction.

\noindent\textbf{Topology-aware strict stabilization.} In the former paragraph, we saw that there exist a number of impossibility results on strict stabilization due to the notion of -restrictive specifications. To circumvent this impossibility result, we define here a new notion, which is weaker than the strict stabilization: the \emph{topology-aware strict stabilization} (denoted by TA-strict stabilization for short). Here, the requirement to the containment radius is relaxed, \emph{i.e.} the set of processes which may be disturbed by Byzantines ones is not reduced to the union of -neighborhood of Byzantines processes but can be defined depending on the topology of the system and on Byzantine processes location.

In the following, we give formal definition of this new kind of Byzantine containment. From now,  denotes the set of Byzantine processes and  (which is function of ) denotes a subset of  (intuitively, this set gathers all processes which may be disturbed by Byzantine processes).

\begin{definition}[-correct node]
A node is \emph{-correct} if it is a correct node (\emph{i.e.} not Byzantine) which not belongs to .
\end{definition}

\begin{definition}[-legitimate configuration]
A configuration  is \emph{-legitimate} for  if every -correct node  is legitimate for  (\emph{i.e.} if  holds).
\end{definition}

\begin{definition}[-topology-aware containment]
\label{def:SfTAcontained}
A configuration  is \emph{-topology-aware contained} for specification  if, given at most  Byzantine processes, in any execution , every configuration is -legitimate and every -correct process never changes its O-variables. 
\end{definition}

The parameter  of Definition~\ref{def:SfTAcontained} refers to the \emph{containment area}. Any process which belongs to this set may be infinitely disturbed by Byzantine processes. The parameter  refers explicitly to the number of Byzantine processes.

\begin{definition}[-topology-aware strict stabilization]
\label{def:SfTAStrictstabilizing}
A protocol is \emph{-topology-\\\noindent aware strictly stabilizing} for specification  if, given at most  Byzantine processes, any execution  contains a configuration  that is -topology-aware contained for .
\end{definition}

Note that, if  denotes the set of Byzantine processes and , then a -topology-aware strictly stabilizing protocol is a -strictly stabilizing protocol. Then, a TA-strictly stabilizing protocol is generally weaker than a strictly stabilizing one, but stronger than a classical self-stabilizing protocol (that may never meet its specification in the presence of Byzantine processes).

The parameter  is introduced to quantify the strength of fault containment, we do not require each process to know the actual definition of the set. Actually, the protocol proposed in this paper assumes no knowledge on this parameter.

\section{Maximum Metric Tree Construction}

In this work, we deal with maximum (routing) metric trees as defined in \cite{GS03j} (note that \cite{GS99c} provides a self-stabilizing solution to this problem). Informally, the goal of a routing protocol is to construct a tree that simultaneously maximizes the metric values of all of the nodes with respect to some total ordering . In the following, we recall all definitions and notations introduced in \cite{GS03j}. 

\begin{definition}[Routing metric]
A \emph{routing metric} (or just \emph{metric}) is a five-tuple   where:
\begin{enumerate}
\item  is a set of metric values,
\item  is a set of edge weights,
\item  is a metric function whose domain is  and whose range is ,
\item  is the maximum metric value in  with respect to  and is assigned to the root of the system,
\item  is a less-than total order relation over  that satisfies the following three conditions for arbitrary metric values , , and  in :
\begin{enumerate}
\item irreflexivity: ,
\item transitivity : if  and  then ,
\item totality:  or  or .
\end{enumerate}
\end{enumerate}
Any metric value  satisfies the \emph{utility condition} (that is, there exists  in  and  in  such that ).
\end{definition}

For instance, we provide the definition of three classical metrics with this model: the shortest path metric (), the flow metric (), and the reliability metric ().




\begin{definition}[Assigned metric]
An \emph{assigned metric} over a system  is a six-tuple   where  is a metric and  is a function that assigns to each edge of  a weight in .
\end{definition}

Let a rooted path (from ) be a simple path from a process  to the root . The next set of definitions are with respect to an assigned metric  over a given system .

\begin{definition}[Metric of a rooted path]
The \emph{metric of a rooted path} in  is the prefix sum of  over the edge weights in the path and .
\end{definition}

For example, if a rooted path  in  is  with , then the metric of  is  with  and .

\begin{definition}[Maximum metric path]
A rooted path  from  in  is called a \emph{maximum metric path} with respect to an assigned metric if and only if for every other rooted path  from  in , the metric of  is greater than or equal to the metric of  with respect to the total order . 
\end{definition}
 
\begin{definition}[Maximum metric of a node]
The \emph{maximum metric of a node}  (or simply \emph{metric value} of ) in  is defined by the metric of a maximum metric path from . The maximum metric of  is . 
\end{definition}

\begin{definition}[Maximum metric tree]
A spanning tree  of  is a \emph{maximum metric tree} with respect to an assigned metric over  if and only if every rooted path in  is a maximum metric path in  with respect to the assigned metric.
\end{definition}

The goal of the work of \cite{GS03j} is the study of metrics that always allow the construction of a maximum metric tree. More formally, the definition follow.

\begin{definition}[Maximizable metric]
A metric is \emph{maximizable} if and only if for any assignment of this metric over any system , there is a maximum metric tree for  with respect to the assigned metric.
\end{definition}

Note that \cite{GS99c} provides a self-stabilizing protocol to construct a maximum metric tree with respect to any maximizable metric. Moreover, \cite{GS03j} provides a fully characterization of maximizable metrics as follow.

\begin{definition}[Boundedness]
A metric  is \emph{bounded} if and only if: 
\end{definition}

\begin{definition}[Monotonicity]
A metric  is \emph{monotonic} if and only if:  
\end{definition}

\begin{theorem}[Characterization of maximizable metrics \cite{GS03j}]
A metric is maximizable if and only if this metric is bounded and monotonic.
\end{theorem}

\begin{figure}[t]
\noindent \begin{centering} \clearpage{}\ifx\JPicScale\undefined\def\JPicScale{0.75}\fi
\unitlength \JPicScale mm
\begin{picture}(165,95)(0,0)
\linethickness{0.3mm}
\put(50,85){\circle{10}}

\linethickness{0.3mm}
\put(30,65){\circle{10}}

\linethickness{0.3mm}
\put(70,65){\circle{10}}

\linethickness{0.3mm}
\put(30,45){\circle{10}}

\linethickness{0.3mm}
\put(70,45){\circle{10}}

\linethickness{0.3mm}
\put(50,25){\circle{10}}

\linethickness{0.3mm}
\multiput(30,70)(0.12,0.12){125}{\line(1,0){0.12}}
\linethickness{0.3mm}
\multiput(55,85)(0.12,-0.12){125}{\line(1,0){0.12}}
\linethickness{0.3mm}
\put(30,50){\line(0,1){10}}
\linethickness{0.3mm}
\multiput(30,40)(0.12,-0.12){125}{\line(1,0){0.12}}
\linethickness{0.3mm}
\multiput(55,25)(0.12,0.12){125}{\line(1,0){0.12}}
\linethickness{0.3mm}
\put(70,50){\line(0,1){10}}
\linethickness{0.3mm}
\put(35,65){\line(1,0){30}}
\linethickness{0.3mm}
\put(35,45){\line(1,0){30}}
\linethickness{0.3mm}
\multiput(35,65)(0.18,-0.12){167}{\line(1,0){0.18}}
\linethickness{0.3mm}
\put(140,85){\circle{10}}

\linethickness{0.3mm}
\put(120,65){\circle{10}}

\linethickness{0.3mm}
\put(160,65){\circle{10}}

\linethickness{0.3mm}
\put(120,45){\circle{10}}

\linethickness{0.3mm}
\put(160,45){\circle{10}}

\linethickness{0.3mm}
\put(140,25){\circle{10}}

\linethickness{0.3mm}
\multiput(120,70)(0.12,0.12){125}{\line(1,0){0.12}}
\linethickness{0.3mm}
\multiput(145,85)(0.12,-0.12){125}{\line(1,0){0.12}}
\linethickness{0.3mm}
\put(120,50){\line(0,1){10}}
\linethickness{0.3mm}
\multiput(120,40)(0.12,-0.12){125}{\line(1,0){0.12}}
\linethickness{0.3mm}
\multiput(145,25)(0.12,0.12){125}{\line(1,0){0.12}}
\linethickness{0.3mm}
\put(160,50){\line(0,1){10}}
\linethickness{0.3mm}
\put(125,65){\line(1,0){30}}
\linethickness{0.3mm}
\put(125,45){\line(1,0){30}}
\linethickness{0.3mm}
\multiput(125,65)(0.18,-0.12){167}{\line(1,0){0.18}}
\put(50,85){\makebox(0,0)[cc]{r}}

\put(140,85){\makebox(0,0)[cc]{r}}

\put(140,25){\makebox(0,0)[cc]{b}}

\put(50,25){\makebox(0,0)[cc]{b}}

\put(165,85){\makebox(0,0)[cc]{}}

\put(50,95){\makebox(0,0)[cc]{mr=0}}

\put(140,95){\makebox(0,0)[cc]{mr=0}}

\put(50,15){\makebox(0,0)[cc]{}}

\put(140,15){\makebox(0,0)[cc]{}}

\put(35,80){\makebox(0,0)[cc]{7}}

\put(65,80){\makebox(0,0)[cc]{6}}

\put(50,70){\makebox(0,0)[cc]{5}}

\put(75,55){\makebox(0,0)[cc]{4}}

\put(55,55){\makebox(0,0)[cc]{10}}

\put(50,40){\makebox(0,0)[cc]{8}}

\put(25,55){\makebox(0,0)[cc]{6}}

\put(65,30){\makebox(0,0)[cc]{32}}

\put(35,30){\makebox(0,0)[cc]{16}}

\linethickness{0.3mm}
\qbezier(25,30)(25.43,30.23)(30.48,32.17)
\qbezier(30.48,32.17)(35.53,34.11)(40,35)
\qbezier(40,35)(42.53,35.36)(44.98,35.21)
\qbezier(44.98,35.21)(47.43,35.05)(50,35)
\qbezier(50,35)(52.57,35.05)(55.02,35.21)
\qbezier(55.02,35.21)(57.47,35.36)(60,35)
\qbezier(60,35)(64.47,34.11)(69.52,32.17)
\qbezier(69.52,32.17)(74.57,30.23)(75,30)
\put(125,80){\makebox(0,0)[cc]{0}}

\put(155,80){\makebox(0,0)[cc]{0}}

\put(140,70){\makebox(0,0)[cc]{0}}

\put(165,55){\makebox(0,0)[cc]{0}}

\put(115,55){\makebox(0,0)[cc]{0}}

\put(155,30){\makebox(0,0)[cc]{0}}

\put(125,30){\makebox(0,0)[cc]{0}}

\put(140,40){\makebox(0,0)[cc]{0}}

\put(145,55){\makebox(0,0)[cc]{0}}

\linethickness{0.3mm}
\qbezier(115,80)(115.43,79.77)(120.48,77.83)
\qbezier(120.48,77.83)(125.53,75.89)(130,75)
\qbezier(130,75)(135.08,74.17)(140,74.17)
\qbezier(140,74.17)(144.92,74.17)(150,75)
\qbezier(150,75)(153.99,75.69)(157.63,77.04)
\qbezier(157.63,77.04)(161.26,78.4)(165,80)
\put(25,25){\makebox(0,0)[cc]{}}

\end{picture}
\clearpage{}
  \par\end{centering}
 \caption{Examples of containment areas for SP spanning tree construction.}
\label{fig:ExSP}
\end{figure}

\begin{figure}[t]
\noindent \begin{centering} \clearpage{}\ifx\JPicScale\undefined\def\JPicScale{0.75}\fi
\unitlength \JPicScale mm
\begin{picture}(173,95)(0,0)
\linethickness{0.3mm}
\put(50,85){\circle{10}}

\linethickness{0.3mm}
\put(30,65){\circle{10}}

\linethickness{0.3mm}
\put(70,65){\circle{10}}

\linethickness{0.3mm}
\put(30,45){\circle{10}}

\linethickness{0.3mm}
\put(70,45){\circle{10}}

\linethickness{0.3mm}
\put(50,25){\circle{10}}

\linethickness{0.3mm}
\multiput(30,70)(0.12,0.12){125}{\line(1,0){0.12}}
\linethickness{0.3mm}
\multiput(55,85)(0.12,-0.12){125}{\line(1,0){0.12}}
\linethickness{0.3mm}
\put(30,50){\line(0,1){10}}
\linethickness{0.3mm}
\multiput(30,40)(0.12,-0.12){125}{\line(1,0){0.12}}
\linethickness{0.3mm}
\multiput(55,25)(0.12,0.12){125}{\line(1,0){0.12}}
\linethickness{0.3mm}
\put(70,50){\line(0,1){10}}
\linethickness{0.3mm}
\put(35,65){\line(1,0){30}}
\linethickness{0.3mm}
\put(35,45){\line(1,0){30}}
\linethickness{0.3mm}
\multiput(35,65)(0.18,-0.12){167}{\line(1,0){0.18}}
\linethickness{0.3mm}
\put(140,85){\circle{10}}

\linethickness{0.3mm}
\put(120,65){\circle{10}}

\linethickness{0.3mm}
\put(160,65){\circle{10}}

\linethickness{0.3mm}
\put(120,45){\circle{10}}

\linethickness{0.3mm}
\put(160,45){\circle{10}}

\linethickness{0.3mm}
\put(140,25){\circle{10}}

\linethickness{0.3mm}
\multiput(120,70)(0.12,0.12){125}{\line(1,0){0.12}}
\linethickness{0.3mm}
\multiput(145,85)(0.12,-0.12){125}{\line(1,0){0.12}}
\linethickness{0.3mm}
\put(120,50){\line(0,1){10}}
\linethickness{0.3mm}
\multiput(120,40)(0.12,-0.12){125}{\line(1,0){0.12}}
\linethickness{0.3mm}
\multiput(145,25)(0.12,0.12){125}{\line(1,0){0.12}}
\linethickness{0.3mm}
\put(160,50){\line(0,1){10}}
\linethickness{0.3mm}
\put(125,65){\line(1,0){30}}
\linethickness{0.3mm}
\put(125,45){\line(1,0){30}}
\linethickness{0.3mm}
\multiput(125,65)(0.18,-0.12){167}{\line(1,0){0.18}}
\put(50,85){\makebox(0,0)[cc]{r}}

\put(140,85){\makebox(0,0)[cc]{r}}

\put(140,25){\makebox(0,0)[cc]{b}}

\put(50,25){\makebox(0,0)[cc]{b}}

\put(50,95){\makebox(0,0)[cc]{mr=10}}

\put(140,95){\makebox(0,0)[cc]{mr=10}}

\put(35,80){\makebox(0,0)[cc]{7}}

\put(65,80){\makebox(0,0)[cc]{6}}

\put(50,70){\makebox(0,0)[cc]{5}}

\put(75,55){\makebox(0,0)[cc]{4}}

\put(55,55){\makebox(0,0)[cc]{10}}

\put(25,55){\makebox(0,0)[cc]{6}}

\put(50,40){\makebox(0,0)[cc]{8}}

\put(65,30){\makebox(0,0)[cc]{32}}

\put(30,30){\makebox(0,0)[cc]{16}}

\put(140,15){\makebox(0,0)[cc]{}}

\put(50,15){\makebox(0,0)[cc]{}}

\put(120,30){\makebox(0,0)[cc]{11}}

\put(155,30){\makebox(0,0)[cc]{12}}

\put(155,80){\makebox(0,0)[cc]{10}}

\put(120,80){\makebox(0,0)[cc]{7}}

\put(165,55){\makebox(0,0)[cc]{13}}

\put(140,70){\makebox(0,0)[cc]{6}}

\put(145,55){\makebox(0,0)[cc]{5}}

\put(115,55){\makebox(0,0)[cc]{3}}

\put(140,40){\makebox(0,0)[cc]{1}}

\linethickness{0.3mm}
\qbezier(105,53.86)(105.43,54.17)(110.46,56.36)
\qbezier(110.46,56.36)(115.5,58.55)(120,58.86)
\qbezier(120,58.86)(124.01,58.43)(127.58,55.9)
\qbezier(127.58,55.9)(131.14,53.36)(135,53.86)
\qbezier(135,53.86)(139.98,55.48)(142.9,60.38)
\qbezier(142.9,60.38)(145.83,65.27)(150,68.86)
\qbezier(150,68.86)(152.33,70.57)(154.77,71.87)
\qbezier(154.77,71.87)(157.21,73.18)(160,73.86)
\qbezier(160,73.86)(162.53,74.5)(165.07,74.65)
\qbezier(165.07,74.65)(167.61,74.79)(170,73.86)
\put(173,68.71){\makebox(0,0)[cc]{}}

\linethickness{0.3mm}
\qbezier(20,75)(20.66,75.25)(27.63,75.98)
\qbezier(27.63,75.98)(34.6,76.72)(40,75)
\qbezier(40,75)(41.65,74.26)(42.8,72.89)
\qbezier(42.8,72.89)(43.96,71.52)(45,70)
\qbezier(45,70)(46.51,67.55)(47.23,64.72)
\qbezier(47.23,64.72)(47.94,61.9)(50,60)
\qbezier(50,60)(54.2,56.72)(59.43,55.56)
\qbezier(59.43,55.56)(64.65,54.39)(70,55)
\qbezier(70,55)(72.83,55.38)(75.26,56.81)
\qbezier(75.26,56.81)(77.68,58.25)(80,60)
\put(15,70){\makebox(0,0)[cc]{}}

\end{picture}
\clearpage{}
  \par\end{centering}
 \caption{Examples of containment areas for flow spanning tree construction.}
\label{fig:ExFlow}
\end{figure}

\begin{figure}[t]
\noindent \begin{centering} \clearpage{}\ifx\JPicScale\undefined\def\JPicScale{0.75}\fi
\unitlength \JPicScale mm
\begin{picture}(175,95)(0,0)
\linethickness{0.3mm}
\put(50,85){\circle{10}}

\linethickness{0.3mm}
\put(30,65){\circle{10}}

\linethickness{0.3mm}
\put(70,65){\circle{10}}

\linethickness{0.3mm}
\put(30,45){\circle{10}}

\linethickness{0.3mm}
\put(70,45){\circle{10}}

\linethickness{0.3mm}
\put(50,25){\circle{10}}

\linethickness{0.3mm}
\multiput(30,70)(0.12,0.12){125}{\line(1,0){0.12}}
\linethickness{0.3mm}
\multiput(55,85)(0.12,-0.12){125}{\line(1,0){0.12}}
\linethickness{0.3mm}
\put(30,50){\line(0,1){10}}
\linethickness{0.3mm}
\multiput(30,40)(0.12,-0.12){125}{\line(1,0){0.12}}
\linethickness{0.3mm}
\multiput(55,25)(0.12,0.12){125}{\line(1,0){0.12}}
\linethickness{0.3mm}
\put(70,50){\line(0,1){10}}
\linethickness{0.3mm}
\put(35,65){\line(1,0){30}}
\linethickness{0.3mm}
\put(35,45){\line(1,0){30}}
\linethickness{0.3mm}
\multiput(35,65)(0.18,-0.12){167}{\line(1,0){0.18}}
\linethickness{0.3mm}
\put(140,85){\circle{10}}

\linethickness{0.3mm}
\put(120,65){\circle{10}}

\linethickness{0.3mm}
\put(160,65){\circle{10}}

\linethickness{0.3mm}
\put(120,45){\circle{10}}

\linethickness{0.3mm}
\put(160,45){\circle{10}}

\linethickness{0.3mm}
\put(140,25){\circle{10}}

\linethickness{0.3mm}
\multiput(120,70)(0.12,0.12){125}{\line(1,0){0.12}}
\linethickness{0.3mm}
\multiput(145,85)(0.12,-0.12){125}{\line(1,0){0.12}}
\linethickness{0.3mm}
\put(120,50){\line(0,1){10}}
\linethickness{0.3mm}
\multiput(120,40)(0.12,-0.12){125}{\line(1,0){0.12}}
\linethickness{0.3mm}
\multiput(145,25)(0.12,0.12){125}{\line(1,0){0.12}}
\linethickness{0.3mm}
\put(160,50){\line(0,1){10}}
\linethickness{0.3mm}
\put(125,65){\line(1,0){30}}
\linethickness{0.3mm}
\put(125,45){\line(1,0){30}}
\linethickness{0.3mm}
\multiput(125,65)(0.18,-0.12){167}{\line(1,0){0.18}}
\put(50,85){\makebox(0,0)[cc]{r}}

\put(140,85){\makebox(0,0)[cc]{r}}

\put(140,25){\makebox(0,0)[cc]{b}}

\put(50,25){\makebox(0,0)[cc]{b}}

\put(175,70){\makebox(0,0)[cc]{}}

\put(50,95){\makebox(0,0)[cc]{mr=1}}

\put(50,15){\makebox(0,0)[cc]{}}

\put(140,95){\makebox(0,0)[cc]{mr=1}}

\put(140,15){\makebox(0,0)[cc]{}}

\put(70,80){\makebox(0,0)[cc]{0,75}}

\put(30,80){\makebox(0,0)[cc]{0,75}}

\put(70,30){\makebox(0,0)[cc]{0,75}}

\put(30,30){\makebox(0,0)[cc]{0,75}}

\put(50,40){\makebox(0,0)[cc]{1}}

\put(50,70){\makebox(0,0)[cc]{1}}

\put(50,60){\makebox(0,0)[cc]{0,8}}

\put(25,55){\makebox(0,0)[cc]{0,4}}

\put(75,55){\makebox(0,0)[cc]{0,3}}

\linethickness{0.3mm}
\qbezier(15,45)(15.38,45.46)(20.28,49.33)
\qbezier(20.28,49.33)(25.17,53.2)(30,55)
\qbezier(30,55)(33.69,55.98)(37.41,55.56)
\qbezier(37.41,55.56)(41.13,55.14)(45,55)
\qbezier(45,55)(51.45,55.23)(57.65,55.93)
\qbezier(57.65,55.93)(63.85,56.63)(70,55)
\qbezier(70,55)(74.83,53.2)(79.72,49.33)
\qbezier(79.72,49.33)(84.62,45.46)(85,45)
\put(120,80){\makebox(0,0)[cc]{0,25}}

\put(140,70){\makebox(0,0)[cc]{0,25}}

\put(160,80){\makebox(0,0)[cc]{0,75}}

\put(165,55){\makebox(0,0)[cc]{1}}

\put(145,55){\makebox(0,0)[cc]{0,5}}

\put(140,40){\makebox(0,0)[cc]{1}}

\put(110,55){\makebox(0,0)[cc]{0,25}}

\put(160,30){\makebox(0,0)[cc]{0,75}}

\put(120,30){\makebox(0,0)[cc]{0,5}}

\linethickness{0.3mm}
\qbezier(105,50)(105.87,50.46)(115.97,54.35)
\qbezier(115.97,54.35)(126.07,58.23)(135,60)
\qbezier(135,60)(137.59,60.19)(140.19,59.54)
\qbezier(140.19,59.54)(142.8,58.88)(145,60)
\qbezier(145,60)(147.18,61.68)(147.69,64.73)
\qbezier(147.69,64.73)(148.21,67.78)(150,70)
\qbezier(150,70)(152.05,72.01)(154.61,73.19)
\qbezier(154.61,73.19)(157.17,74.36)(160,75)
\qbezier(160,75)(162.5,75.52)(164.96,75.3)
\qbezier(164.96,75.3)(167.42,75.07)(170,75)
\put(15,40){\makebox(0,0)[cc]{}}

\end{picture}
\clearpage{}
  \par\end{centering}
 \caption{Examples of containment areas for reliability spanning tree construction.}
\label{fig:ExReliability}
\end{figure}

Given a maximizable metric , the aim of this work is to construct a maximum metric tree with respect to  which spans the system in a self-stabilizing way in a system subject to permanent Byzantine failures. It is obvious that these Byzantine processes may disturb some correct processes. It is why, we relax the problem in the following way: we want to construct a maximum metric forest with respect to . The root of any tree of this forest must be either the real root or a Byzantine process. 

Each process  has three O-variables: a pointer to its parent in its tree (), a level which stores its current metric value (), and a variable which stores its distance to the root of its tree (). Obviously, Byzantine process may disturb (at least) their neighbors. We use the following specification of the problem.

We introduce new notations as follows. Given an assigned metric  over the system  and two processes  and , we denote by  the maximum metric of node  when  plays the role of the root of the system and by  the weight of the edge  (that is, the value of ).

\begin{definition}[-path]
Given an assigned metric  over a system , a path  () of  is a \emph{-path} if and only if:
\begin{enumerate}
\item , , , and ,
\item , , and ,
\item , and
\item .
\end{enumerate}
\end{definition}

We define the specification predicate  of the maximum metric tree construction with respect to a maximizable metric  as follows.


Following discussion of Section \ref{sec:stab}, it is obvious that there exists no strictly stabilizing protocol for this problem. It is why we consider the weaker notion of topology-aware strict stabilization. First, we show an impossibility result in order to define the best possible containment area. Then, we provide a maximum metric tree construction protocol which is -TA-strictly stabilizing where  which match these optimal containment area, namely:



Figures from \ref{fig:ExSP} to \ref{fig:ExReliability} provide some examples of containment areas with respect to several maximizable metrics.

We introduce here a new definition that is used in the following.

\begin{definition}[Fixed point]
A metric value  is a \emph{fixed point} of a metric   if  and if for any value , we have: .
\end{definition}

\subsection{Impossibility Result}

In this section, we show that there exists some constraints on the containment area of any topology-aware strictly stabilizing for the maximum metric tree construction depending on the metric.

\begin{theorem}\label{th:impTAstrict}
Given a maximizable metric , even under the central daemon, there exists no -TA-strictly stabilizing protocol for maximum metric spanning tree construction with respect to  where .
\end{theorem}

\begin{proof}
Let  be a maximizable metric and  be a -TA-strictly stabilizing protocol for maximum metric spanning tree construction protocol with respect to  where . We must distinguish the following cases:

\begin{description}
\item[Case 1:] .\\
Denote by  the metric value such that . For any system and for any process , we have . Consequently,  for any system.

Consider the following system:  and  ( is a Byzantine process). As  and , we have:  or . Consider now the following configuration : , , , , ,  and  (see Figure \ref{fig:impTAstrict}, other variables may have arbitrary values). Note that  is -legitimate for  (whatever  is).

Assume now that  behaves as a correct process with respect to . Then, by convergence of  in a fault-free system starting from  which is not legitimate (remember that a strictly-stabilizing protocol is a special case of self-stabilizing protocol), we can deduce that the system reaches in a finite time a configuration  (see Figure \ref{fig:impTAstrict}) in which: , , , , , , ,  and . Note that processes  and  modify their O-variables in this execution. This contradicts the -TA-strict stabilization of  (whatever  is).

\begin{figure}[t]
\noindent \begin{centering} \clearpage{}\ifx\JPicScale\undefined\def\JPicScale{0.85}\fi
\unitlength \JPicScale mm
\begin{picture}(190,100)(0,0)
\linethickness{0.3mm}
\put(15,95){\circle{10}}

\linethickness{0.3mm}
\put(35,95){\circle{10}}

\linethickness{0.3mm}
\put(55,95){\circle{10}}

\linethickness{0.3mm}
\put(75,95){\circle{10}}

\linethickness{0.3mm}
\put(185,95){\circle{10}}

\linethickness{0.3mm}
\put(165,95){\circle{10}}

\linethickness{0.3mm}
\put(125,95){\circle{10}}

\linethickness{0.3mm}
\put(145,95){\circle{10}}

\put(0,95){\makebox(0,0)[cc]{}}

\put(0,65){\makebox(0,0)[cc]{}}

\linethickness{0.3mm}
\put(15,65){\circle{10}}

\linethickness{0.3mm}
\put(35,65){\circle{10}}

\linethickness{0.3mm}
\put(55,65){\circle{10}}

\linethickness{0.3mm}
\put(75,65){\circle{10}}

\linethickness{0.3mm}
\put(125,65){\circle{10}}

\linethickness{0.3mm}
\put(165,65){\circle{10}}

\linethickness{0.3mm}
\put(185,65){\circle{10}}

\linethickness{0.3mm}
\put(145,65){\circle{10}}

\put(110,95){\makebox(0,0)[cc]{}}

\put(110,65){\makebox(0,0)[cc]{}}

\put(15,95){\makebox(0,0)[cc]{r}}

\put(35,95){\makebox(0,0)[cc]{u}}

\put(55,95){\makebox(0,0)[cc]{v}}

\put(75,95){\makebox(0,0)[cc]{b}}

\put(15,65){\makebox(0,0)[cc]{r}}

\put(35,65){\makebox(0,0)[cc]{u}}

\put(55,65){\makebox(0,0)[cc]{v}}

\put(75,65){\makebox(0,0)[cc]{b}}

\put(125,95){\makebox(0,0)[cc]{r}}

\put(125,65){\makebox(0,0)[cc]{r}}

\put(145,95){\makebox(0,0)[cc]{u}}

\put(165,95){\makebox(0,0)[cc]{v}}

\put(165,65){\makebox(0,0)[cc]{v}}

\put(185,95){\makebox(0,0)[cc]{b}}

\put(185,65){\makebox(0,0)[cc]{b}}

\put(145,65){\makebox(0,0)[cc]{u}}

\linethickness{0.3mm}
\put(20,95){\line(1,0){10}}
\linethickness{0.3mm}
\put(130,95){\line(1,0){10}}
\linethickness{0.3mm}
\put(40,95){\line(1,0){10}}
\put(50,95){\vector(1,0){0.12}}
\linethickness{0.3mm}
\put(60,95){\line(1,0){10}}
\put(70,95){\vector(1,0){0.12}}
\linethickness{0.3mm}
\put(150,95){\line(1,0){10}}
\put(160,95){\vector(1,0){0.12}}
\linethickness{0.3mm}
\put(170,95){\line(1,0){10}}
\put(180,95){\vector(1,0){0.12}}
\linethickness{0.3mm}
\put(170,65){\line(1,0){10}}
\put(170,65){\vector(-1,0){0.12}}
\linethickness{0.3mm}
\put(150,65){\line(1,0){10}}
\put(150,65){\vector(-1,0){0.12}}
\linethickness{0.3mm}
\put(130,65){\line(1,0){10}}
\put(130,65){\vector(-1,0){0.12}}
\linethickness{0.3mm}
\put(60,65){\line(1,0){10}}
\put(60,65){\vector(-1,0){0.12}}
\linethickness{0.3mm}
\put(40,65){\line(1,0){10}}
\put(40,65){\vector(-1,0){0.12}}
\linethickness{0.3mm}
\put(20,65){\line(1,0){10}}
\put(20,65){\vector(-1,0){0.12}}
\put(25,100){\makebox(0,0)[cc]{}}

\put(135,100){\makebox(0,0)[cc]{w}}

\put(135,70){\makebox(0,0)[cc]{w}}

\put(155,100){\makebox(0,0)[cc]{w'}}

\put(155,70){\makebox(0,0)[cc]{w'}}

\put(175,100){\makebox(0,0)[cc]{w}}

\put(175,70){\makebox(0,0)[cc]{w}}

\put(15,85){\makebox(0,0)[cc]{m / 0}}

\put(35,85){\makebox(0,0)[cc]{m / 2}}

\put(55,85){\makebox(0,0)[cc]{m / 1}}

\put(75,85){\makebox(0,0)[cc]{m / 0}}

\put(15,55){\makebox(0,0)[cc]{m / 0}}

\put(35,55){\makebox(0,0)[cc]{m / 1}}

\put(55,55){\makebox(0,0)[cc]{m / 2}}

\put(75,55){\makebox(0,0)[cc]{m / 3}}

\put(125,85){\makebox(0,0)[cc]{mr / 0}}

\put(125,55){\makebox(0,0)[cc]{mr / 0}}

\put(185,85){\makebox(0,0)[cc]{mr / 0}}

\put(145,85){\makebox(0,0)[cc]{m / 2}}

\put(165,85){\makebox(0,0)[cc]{m / 1}}

\put(145,55){\makebox(0,0)[cc]{m / 1}}

\put(165,55){\makebox(0,0)[cc]{m / 2}}

\put(185,55){\makebox(0,0)[cc]{m / 3}}

\linethickness{0.3mm}
\put(15,20){\circle{10}}

\linethickness{0.3mm}
\put(35,20){\circle{10}}

\linethickness{0.3mm}
\put(55,30){\circle{10}}

\linethickness{0.3mm}
\put(55,10){\circle{10}}

\linethickness{0.3mm}
\put(75,20){\circle{10}}

\linethickness{0.3mm}
\put(125,20){\circle{10}}

\linethickness{0.3mm}
\put(145,20){\circle{10}}

\linethickness{0.3mm}
\put(165,30){\circle{10}}

\linethickness{0.3mm}
\put(165,10){\circle{10}}

\linethickness{0.3mm}
\put(185,20){\circle{10}}

\put(0,20){\makebox(0,0)[cc]{}}

\put(110,20){\makebox(0,0)[cc]{}}

\put(15,20){\makebox(0,0)[cc]{r}}

\put(125,20){\makebox(0,0)[cc]{r}}

\put(35,20){\makebox(0,0)[cc]{u}}

\put(145,20){\makebox(0,0)[cc]{u}}

\put(75,20){\makebox(0,0)[cc]{b}}

\put(185,20){\makebox(0,0)[cc]{b}}

\put(55,30){\makebox(0,0)[cc]{v}}

\put(165,30){\makebox(0,0)[cc]{v}}

\put(55,10){\makebox(0,0)[cc]{v'}}

\put(165,10){\makebox(0,0)[cc]{v'}}

\linethickness{0.3mm}
\multiput(60,30)(0.12,-0.12){83}{\line(1,0){0.12}}
\put(70,20){\vector(1,-1){0.12}}
\linethickness{0.3mm}
\multiput(60,10)(0.12,0.12){83}{\line(1,0){0.12}}
\put(70,20){\vector(1,1){0.12}}
\linethickness{0.3mm}
\put(20,20){\line(1,0){10}}
\put(20,20){\vector(-1,0){0.12}}
\linethickness{0.3mm}
\put(130,20){\line(1,0){10}}
\put(130,20){\vector(-1,0){0.12}}
\linethickness{0.3mm}
\multiput(150,20)(0.12,0.12){83}{\line(1,0){0.12}}
\put(150,20){\vector(-1,-1){0.12}}
\linethickness{0.3mm}
\multiput(150,20)(0.12,-0.12){83}{\line(1,0){0.12}}
\put(150,20){\vector(-1,1){0.12}}
\linethickness{0.3mm}
\multiput(170,30)(0.12,-0.12){83}{\line(1,0){0.12}}
\put(170,30){\vector(-1,1){0.12}}
\linethickness{0.3mm}
\multiput(170,10)(0.12,0.12){83}{\line(1,0){0.12}}
\linethickness{0.3mm}
\multiput(40,20)(0.12,0.12){83}{\line(1,0){0.12}}
\linethickness{0.3mm}
\multiput(40,20)(0.12,-0.12){83}{\line(1,0){0.12}}
\put(15,10){\makebox(0,0)[cc]{mr / 0}}

\put(25,25){\makebox(0,0)[cc]{w}}

\put(42.14,27.71){\makebox(0,0)[cc]{w'}}

\put(67.29,27.71){\makebox(0,0)[cc]{w}}

\put(62.14,18){\makebox(0,0)[cc]{w}}

\put(35,10){\makebox(0,0)[cc]{m / 1}}

\put(55,0){\makebox(0,0)[cc]{m / 1}}

\put(55,40){\makebox(0,0)[cc]{m / 1}}

\put(80,10){\makebox(0,0)[cc]{mr / 0}}

\put(125,10){\makebox(0,0)[cc]{mr / 0}}

\put(145,10){\makebox(0,0)[cc]{m / 1}}

\put(165,0){\makebox(0,0)[cc]{m' / 2}}

\put(165,40){\makebox(0,0)[cc]{m' / 2}}

\put(190,10){\makebox(0,0)[cc]{m'' / 3}}

\put(135,25){\makebox(0,0)[cc]{w}}

\put(153.29,28.29){\makebox(0,0)[cc]{w'}}

\put(157.29,18.29){\makebox(0,0)[cc]{w'}}

\put(177.29,28.29){\makebox(0,0)[cc]{w}}

\put(172.14,17.43){\makebox(0,0)[cc]{w}}

\put(47.57,18.71){\makebox(0,0)[cc]{w'}}

\end{picture}
\clearpage{}
  \par\end{centering}
 \caption{Configurations used in proof of Theorem \ref{th:impTAstrict}.}
\label{fig:impTAstrict}
\end{figure}

\item[Case 2:] .\\
By definition of a bounded metric, we can deduce that there exist  and  such that . Then, we must distinguish the following cases:
\begin{description}
\item[Case 2.1:]  is a fixed point of .\\
Consider the following system: , , , and  ( is a Byzantine process). As for any ,  (by definition of a fixed point), we have: . Since , we have:  or . Consider now the following configuration : , , , , , ,  and  (see Figure \ref{fig:impTAstrict}, other variables may have arbitrary values). Note that  is -legitimate for  (whatever  is).

Assume now that  behaves as a correct process with respect to . Then, by convergence of  in a fault-free system starting from  which is not legitimate (remember that a strictly-stabilizing protocol is a special case of self-stabilizing protocol), we can deduce that the system reaches in a finite time a configuration  (see Figure \ref{fig:impTAstrict}) in which: , , , , ,  (since  is a fixed point), , ,  and . Note that processes  and  modify their O-variables in this execution. This contradicts the -TA-strict stabilization of  (whatever  is).
\item[Case 2.2:]  is not a fixed point of .\\
This implies that there exists  such that:  (remember that  is bounded). Consider the following system: ,  , , and  ( is a Byzantine process). We can see that . Since , we have:  or . Consider now the following configuration : , , , , , ,  and  (see Figure \ref{fig:impTAstrict}, other variables may have arbitrary values). Note that  is -legitimate for  (whatever  is).

Assume now that  behaves as a correct process with respect to . Then, by convergence of  in a fault-free system starting from  which is not legitimate (remember that a strictly-stabilizing protocol is a special case of self-stabilizing protocol), we can deduce that the system reaches in a finite time a configuration  (see Figure \ref{fig:impTAstrict}) in which: , , ,  (or ), ,  , , , ,  and . Note that processes  and  modify their O-variables in this execution. This contradicts the -TA-strict stabilization of  (whatever  is).
\end{description}
\end{description}
\end{proof}

\subsection{Topology-Aware Strict Stabilizing Protocol}

In this section, we provide our self-stabilizing protocol that achieve optimal containment areas to permanent Byzantine failures for constructing a maximum metric tree for any maximizable metric . More formally, our protocol is -strictly stabilizing, that is optimal with respect to the result of Theorem \ref{th:impTAstrict}. Our protocol is borrowed from the one of \cite{GS99c} (which is self-stabilizing). The key idea of this protocol is to use the distance variable (upper bounded by a given constant ) to detect and break cycles of process which has the same maximum metric. The main modification we bring to this protocol follows. In the initial protocol, when a process modifies its parent, it chooses arbitrarily one of the "better" neighbors (with respect to the metric).  To achieve the -TA-strict stabilization, we must ensures a fair selection along the set of its neighbor. We perform this fairness with a round-robin order along the set of neighbors. Our solution is presented as Algorithm~\ref{algo:max}.

\begin{algorithm}
\caption{: A TA-strictly stabilizing protocol for maximum metric tree construction.}\label{algo:max}
\scriptsize
\begin{description}
\item{Data:}~\\
: totally ordered set of neighbors of .\\
: upper bound of the number of processes in a simple path.
\item{Variables:}~\\
: pointer on the parent of  in the tree.\\
: metric of the node.\\
: distance to the root.
\item{Macro:}~\\
For any subset ,  returns the first element of  which is bigger than  (in a round-robin fashion).
\item{Rules:}~\\


\\ 

\\

\\
\\

\end{description}
\end{algorithm}
\normalsize

In the following, we provide the proof of the TA-strict stabilization of . Remember that the real root  can not be a Byzantine process by hypothesis. Note that the subsystem whose set of nodes is  is connected respectively by boundedness of the metric.

\begin{lemma}\label{lem:goodProperty}
For any process , we have:

\end{lemma}

\begin{proof}
Let  be a process. By contradiction, assume that there exists a neighbor  of  such that:

Let  one of the process such that . Then, we have:

This contradicts the fact that  and shows us the result.
\end{proof}

Given a configuration  and a metric value , let us define the following predicate: 


\begin{lemma}\label{lem:Imclosed}
For any metric value , the predicate  is closed by actions of .
\end{lemma}

\begin{proof}
Let  be a metric value (). Let  be a configuration such that  and  be a configuration such that  is a step of .

If the root process  (respectively a Byzantine process ), then we have  (respectively ) in  by construction of  (respectively by definition of ). Hence,  (respectively ).

If a correct process  with , then there exists a neighbor  of  such that  in  (since ) and  and   in  (since  is activated during this step).

If we apply the Lemma \ref{lem:goodProperty} to  and to neighbor , we obtain the following property:
  

Consequently, we obtain that, in :


We can deduce that , that concludes the proof.
\end{proof}

Given an assigned metric to a system , we can observe that the set of metrics value  is finite and that we can label elements of  by  in a way such that .

We introduce the following notations:


\begin{lemma}\label{lem:LCmiclosed}
For any , the set  is closed by actions of .
\end{lemma}

\begin{proof}
Let  be a metric value from  and  be a configuration of . By construction, any process  satisfies  in . 

In particular, the root process satisfies: , , and . By construction of ,  is not enabled and then never modifies its O-variables (since the guard of the rule of  does not involve the state of its neighbors). 

In the same way, any process  satisfies: ,  , , and . Note that, as  and  holds in , we have:  and  by construction of . Hence, process  is not enabled in .

Assume that there exists a process  that take a step  in an execution starting from  (without loss of generality, assume that  is the first process of  that takes a step in this execution). Then, we know that . This activation implies that a neighbor  (since  is the first process of  to take a step) of  modified its  variable to a metric value  such that  in  (note that O-variables of  and  remain consistent since  is the first process to take a step in this execution).

Hence, we have . Moreover, the closure of  (established in Lemma \ref{lem:Imclosed}) ensures us that . By boundedness of , we can deduce that . Consequently, we obtain that . This is contradictory with the result of Lemma \ref{lem:goodProperty}.

In conclusion, any process  takes no step in any execution starting from  and then always satisfies . Then, the closure of  (established in Lemma \ref{lem:Imclosed}) concludes the proof.
\end{proof}

\begin{lemma}\label{lem:SBTAcontainedMax}
Any configuration of  is -TA contained for .
\end{lemma}

\begin{proof}
This is a direct application of the Lemma \ref{lem:LCmiclosed} to .
\end{proof}

\begin{lemma}\label{lem:CtoLCmr}
Starting from any configuration of , any execution of  reaches in a finite time a configuration of .
\end{lemma}

\begin{proof}
Let  be an arbitrary configuration. Then, it is obvious that  is satisfied. By closure of  (proved in Lemma \ref{lem:Imclosed}), we know that  remains satisfied in any execution starting from .

If  does not satisfy  in , then  is continuously enabled. Since the scheduling is weakly fair,  is activated in a finite time and then  satisfies  in a finite time. Denote by  the first configuration in which  holds. Note that  takes no step in any execution starting from .

The boundedness of  implies that  induces a connected subsystem. If , then we proved that  and we have the result.

Otherwise, observe that, for any configuration of an execution starting from , if all processes of  are not enabled, then all processes  of  satisfy . Assume now that there exists an execution  starting from  in which some processes of  takes infinitely many steps. By construction, at least one of these processes (note it ) has a neighbor  which takes only a finite number of steps in  (recall that  induces a connected subsystem and that  takes no step in ). After  takes its last step of , we can observe that  and  (otherwise,  is activated in a finite time that contradicts its construction). 

As  can execute consequently  only a finite number of times (since the incrementation of  is bounded by ), we can deduce that  executes  or  infinitely often. In both cases,  belongs to the set which is the parameter of function . By the fairness of this function, we can deduce that  in a finite time in . Then, the construction of  implies that  is never enabled in the sequel of . This is contradictory with the construction of .

Consequently, any execution starting from  reaches in a finite time a configuration such that all processes of  are not enabled. We can deduce that this configuration belongs to , that ends the proof.
\end{proof}

\begin{lemma}\label{lem:LCmitodistD}
For any  and for any configuration , any execution of  starting from  reaches in a finite time a configuration such that:

\end{lemma}

\begin{proof}
Let  be an arbitrary metric value of  and  be an arbitrary configuration of . Let  be an execution starting from .

Note that  satisfies  by construction. Hence, we have . The closure  of  (proved in Lemma \ref{lem:Imclosed}) ensures us that this property is satisfied in any configuration of . 

If any process  satisfies  in , then the result is obvious. Otherwise, we define the following variant function. For any configuration  of , we denote by  the set of processes  of  such that  in . Then, we define . We will prove the result by showing that there exists an integer  such that .

First, if a process  joins  (that is,  but ), then it takes a distance value greater or equals to  by construction of the protocol. We can deduce that the fact that some processes join  does not decrease . Moreover, the construction of the protocol implies that a process  such that  and  can not decrease its distance value in the step .

Then, consider for a given configuration  a process  such that . We distinguish the following cases:

\begin{description}
\item[Case 1:] \\
The fact that , the boundedness of  and the closure of  imply that  (and, hence that ). Then, by construction of , we know that  (otherwise, we do not have  since  has a smaller distance value). Consequently,  is enabled by  in  and  increase of at least 1 during the step  if this rule is executed.
\item[Case 2:] \\
The rule  is then enabled for . If this rule is executed during the step , one of the two following sub cases appears.
\begin{description}
\item[Case 2.1:] \\
Then,  does not belong to  by definition. 
\item[Case 2.2:] \\
Remind that the closure of  implies then that . By construction of , we have  in . Then, we can see that  increases of at least 1 during the step .
\end{description}
\end{description}

In all cases,  is enabled by  in  and the execution of this rule either increases strictly  or removes  from .

As  is finite and the scheduling is weakly fair, we can deduce that  increases in a finite time in any execution starting from . By repeating the argument at most  times, we can deduce that  contains a configuration  such that , that shows the result.
\end{proof}

\begin{lemma}\label{lem:distDtolevelmi}
For any  and for any configuration  such that
, any execution of  starting from  reaches in a finite time a configuration such that:

\end{lemma}

\begin{proof}
Let  be an arbitrary metric value and  be a configuration of  such that . Let  be an arbitrary execution starting from .

For any configuration  of , let us denote . By the closure of  (which holds by definition in ) established in Lemma \ref{lem:Imclosed}, we obtain the result if there exists a configuration  of  such that .

If there exists some processes  (and hence ) such that  and  in , then we can observe that these processes are continuously enabled by . As the scheduling is weakly fair,  activates this rule in a finite time and then,  and . In other words,  joins  for a given integer . We can conclude that there exists an integer  such that for any , either  or .

Then, we prove that, for any integer , we have . For the sake of contradiction, assume that there exists an integer  and a process  such that  and . Without loss of generality, assume that  is the smallest integer which performs these properties. Let us study the following cases:
\begin{description}
\item[Case 1:] If  activates  during the step , then we know that  in  (otherwise, we have a contradiction with the fact that ). But in this case, we have: . The boundedness of  implies that  in  that contradicts the fact that .
\item[Case 2:] If  activates either  or  during the step , then  chooses a new parent which has a distance smaller than  in . This implies that this new parent does not belongs to . Then, we have . The boundedness of  implies that  in  that contradicts the fact that .
\end{description}
In the two cases, our claim is satisfied. In other words, there exists a point of the execution afterwards the set  can not grow (this implies that, if a process leave the set , it is a definitive leaving).

Assume now that there exists a step  (with ) such that a process  is activated. Observe that the closure of  implies that  can not be activated by the rule . If  activates  during this step, then  modifies its level during this step (otherwise, we have a contradiction with the fact that ). The closure of  implies that  leaves the set  during this step. If  activates  during this step, then  chooses a new parent which has a distance smaller than  in . This implies that this new parent does not belongs to . Then, we have . The boundedness of  implies that  in . In other words, if a process of  is activated during the step , then it satisfies .

Finally, observe that the construction of the protocol and the construction of the bound  ensures us that any process  such that  is activated in a finite time. In conclusion, we obtain that there exists an integer  such that , that implies the result.
\end{proof}

\begin{lemma}\label{lem:CmitoIMmi+1}
For any  and for any configuration , any execution of  starting from  reaches in a finite time a configuration  such that  holds.
\end{lemma}

\begin{proof}
This result is a direct consequence of Lemmas \ref{lem:LCmitodistD} and \ref{lem:distDtolevelmi}.
\end{proof}

\begin{lemma}\label{lem:LCmitoLCmi+1}
For any  and for any configuration , any execution of  starting from  reaches in a finite time a configuration of .
\end{lemma}

\begin{proof}
Let  be a metric value of  and  be an arbitrary configuration of . We know by Lemma \ref{lem:CmitoIMmi+1} that any execution starting from  reaches in a finite time a configuration  such that  holds. By closure of  and of  (established respectively in Lemma \ref{lem:Imclosed} and \ref{lem:LCmiclosed}), we know that any configuration of any execution starting from  belongs to  and satisfies .

We know that  since  for any . Remind that  is connected by the boundedness of . Then, we know that there exists at least one process  of  which has a neighbor  in  such that . Moreover, Lemma \ref{lem:LCmiclosed} ensures us that any process of  takes no step in any executions tarting from .

Observe that, for any configuration of an execution starting from , if all processes of  are not enabled, then all processes  of  satisfy . Assume now that there exists an execution  starting from  in which some processes of  take infinitely many steps. By construction, at least one of these processes (note it ) has a neighbor  such that  which takes only a finite number of steps in  (recall the construction of ). After  takes its last step of , we can observe that  and  (otherwise,  is activated in a finite time that contradicts its construction). 

As  can execute consequently  only a finite number of times (since the incrementation of  is bounded by ), we can deduce that  executes  or  infinitely often. In both cases,  belongs to the set which is the parameter of function  (remind that  is satisfied and that  has the better possible metric along 's neighbors). By the construction of this function, we can deduce that  in a finite time in . Then, the construction of  implies that  is never enabled in the sequel of . This is contradictory with the construction of .

Consequently, any execution starting from  reaches in a finite time a configuration such that all processes of  are not enabled. We can deduce that this configuration belongs to , that ends the proof.
\end{proof}

\begin{lemma}\label{lem:convergenceLCMax}
Starting from any configuration, any execution of  reaches a configuration of  in a finite time.
\end{lemma}

\begin{proof}
Let  be an arbitrary configuration. We know by Lemma \ref{lem:CtoLCmr} that any execution starting from  reaches in a finite time a configuration of . Then, we can apply at most  times the result of Lemma \ref{lem:LCmitoLCmi+1} to obtain that any execution starting from  reaches in a finite time a configuration of , that proves the result.
\end{proof}

\begin{theorem}\label{th:SSMAXstrict}
 is a -TA-strictly stabilizing protocol for .
\end{theorem}

\begin{proof}
This result is a direct consequence of Lemmas \ref{lem:SBTAcontainedMax} and \ref{lem:convergenceLCMax}.
\end{proof}

Note that Theorem \ref{th:impTAstrict} ensures us that  is the optimal containment area for a topology-aware strictly stabilizing protocol for .

\section{Conclusion}

We introduced a new notion of Byzantine containment in self-stabilization: the topology-aware strict stabilization. This notion relaxes the constraint on the containment radius of the strict stabilization to a containment area. In other words, the set of correct processes which may be infinitely often disturbed by Byzantine processes is a function depending on the topology of the system and on the actual location of Byzantine processes. We illustrated the relevance of this notion by providing a topology-aware strictly stabilizing protocol for the maximum metric tree construction problem which does not admit strictly stabilizing solution. Moreover, our protocol performs the optimal containment area with respect to the topology-aware strict stabilization.

Our work raises some opening questions. Number of problems do not accept strictly stabilizing solution. Does any of them admit a topology-aware strictly stabilizing solution ? Is it possible to give a necessary and/or sufficient condition for a problem to admit a topology-aware strictly stabilizing solution ? What happens if we consider only bounded Byzantine behavior ?

\bibliographystyle{plain}
\bibliography{biblio}

\end{document}