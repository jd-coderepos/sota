\documentclass[JMC]{degruyter-journal}

\usepackage{boxedminipage}
\newtheorem{claim}{Claim}[section]






\volume{5}
\pubyear{2011}
\doi{XXX}
\communicated{Spyros Magliveras}
\received{4 May, 2011}
\revised{16 January, 2012}


\title{On  Bringer-Chabanne EPIR Protocol for Polynomial Evaluation}



\lastnameone{Chee}
\firstnameone{Yeow Meng}
\emailone{ymchee@ntu.edu.sg}
\addressone{\\Division of Mathematical Sciences, \\School of Physical and Mathematical Sciences, \\Nanyang Technological University, \\
21 Nanyang Link}
\countryone{ \\Singapore 637371}


\lastnametwo{Wang}
\firstnametwo{Huaxiong}
\emailtwo{hxwang@ntu.edu.sg}
\addresstwo{\\Division of Mathematical Sciences, \\School of Physical and Mathematical Sciences, \\Nanyang Technological University, \\
21 Nanyang Link}
\countrytwo{ \\Singapore 637371}


\lastnamethree{Zhang}
\firstnamethree{Liang Feng}
\emailthree{liangfeng.zhang@ntu.edu.sg}
\addressthree{\\Division of Mathematical Sciences, \\School of Physical and Mathematical Sciences, \\Nanyang Technological University, \\
21 Nanyang Link}
\countrythree{\\Singapore 637371}



\acknowledgments{The research is supported in part by the Singapore National
Research Foundation under Research Grant NRF-CRP2-2007-03.}


\abstract{
Extended private information retrieval (EPIR) was defined by
\cite{BCPT07}
at CANS'07 and generalized by
\cite{BC09}
at
AFRICACRYPT'09. In the generalized setting, EPIR allows a user to
evaluate a function on a database block such that the database
can learn neither which function has been evaluated nor on which
block the function has been evaluated and the user learns no more
information on the database blocks except for the expected result. An
EPIR protocol for evaluating  polynomials over a finite field 
was proposed by Bringer and Chabanne
 in \cite{BC09}.
We show that the protocol does not
satisfy the correctness requirement as they have claimed. In
particular, we show that it does not give the user the
expected result with large probability if one of the coefficients of
the polynomial to be evaluated is  primitive in  and the others
belong to   the prime subfield of .
}


\keywords{Extended private information retrieval, correctness}

\classification{94A60}

\begin{document}


\section{Introduction}


Extended private information retrieval (EPIR) was  motivated by
privacy-preserving biometric authentication and formally defined in
\cite{BCPT07}. It enables a user to privately evaluate a fixed and
public function with two inputs, one chosen block from a database
and one additional string. Two EPIR protocols were proposed in
\cite{BCPT07}. One is
 for testing
equality and the other is for computing weighted Hamming distance.
As a  cryptographic primitive, EPIR has been generalized by
\cite{BC09} in order to attain more flexibility. In the generalized
setting, the function to be evaluated is neither fixed nor public.
Instead, it is chosen from a set of public functions by the user. A
new EPIR protocol
 in the generalized setting was  proposed in \cite{BC09}.
As noted in \cite{BCPT07}, EPIR is indeed a combination of private
informatrion retrieval \cite{CGKS95} and general secure two-party
computation \cite{Gol04}.




{\bf Related Work.} Private information retrieval (PIR) was
introduced by \cite{CGKS95}. It allows a user to retrieve a data
item from a  database  such that
 the database cannot learn which item the user is interested in.
The requirement on the privacy of the identity of the retrieved data
item is  called {\em user privacy}. The main measure of the
efficiency of a PIR protocol is its  {\em communication complexity},
i.e., the total number of bits exchanged by the user and the
database for retrieving a {\em single bit}.
 PIR protocols have been constructed in both the {\em information-theoretic} setting
  \cite{CGKS95,Amb97,BIKR02,BIK05,WY05,Yek07,Efr09,IS10,CFLWZ10} and the {\em computational}
  setting \cite{CG97,KO97,CMS99,KO00,YS01,Chang04,GR05,Lip05,GKL10}.
In an information-theoretic PIR protocol, the database learns {\em
absolutely}  no information on which item the user is interested in
even if it has unlimited computing power. On the other hand, in a
computational PIR (CPIR) protocol, the identity of the retrieved
data item is not revealed only if the database is polynomial-time
and cannot efficiently solve certain number-theoretic problems,
i.e., certain cryptographic assumptions hold. For example, the PIR
protocol of \cite{CG97} is a {\em two-database} CPIR protocol in
which each database cannot figure out which item the user is
interested in under the assumption that one way functions exist.
EPIR protocols of \cite{BCPT07,BC09} are mostly close to the {\em
single-database} CPIR protocols. The first single-database CPIR
protocol was proposed by \cite{KO97}. It achieves the user privacy
under the assumption that deciding quadratic residuosity is hard and
has communication complexity  for any small constant ,
where  is the size of the database. Subsequently,  \cite{CMS99}
constructed  a single-database CPIR protocol of communication
complexity   under the  -hiding assumption.  So
far, the most efficient single-database CPIR protocol was obtained
by \cite{GR05} under the assumption that the decision subgroup problem
is hard.  It requires the user to exchange  bits with the
database for retrieving  bits, where  is the
security parameter.
Other constructions of single-database CPIR  protocols can
be found in \cite{KO00,YS01,Chang04,GKL10}.

PIR does not provide any privacy for the database. Typically, the
user may obtain  a large number of data items in an execution of a
PIR protocol. In order to prevent the user from obtaining more than
one data item in any execution of a PIR protocol, \cite{GIKM98}
introduced the notion of {\em data privacy} and proposed
transformations from information-theoretic PIR protocols to  the
so-called symmetrically private information retrieval (SPIR)
 protocols
 which meet the data privacy. The SPIR protocols of \cite{GIKM98} are in the information-theoretic setting.
SPIR can be defined  in the computational setting as well. Following
the security definition of general secure two-party and multi-party
computation \cite{Gol04}, in the computational setting, a PIR
protocol is said to achieve  data privacy if, for any query, the
user cannot tell whether it is interacting with a real-database
which has  data items or a simulator which only knows the
retrieved data item.
 Interestingly, single-database SPIR protocols in  the computational setting  are essentially
 communication-efficient 1-out-of- Oblivious transfer (OT)
 \cite{Rab81,EGL85,BCR87,GMW87,Kil88} protocols.
Oblivious transfer \cite{Rab81} is a fundamental  cryptographic
primitive, on which any secure two-party and multi-party computation
can be built  \cite{Kil88} in an unconditionally secure way. A
1-out-of- OT allows a receiver Bob to choose one of the 
secrets held by a sender Alice such that Alice learns no information
on Bob's choice and Bob cannot learn more except the secret he
chooses. \cite{NP99} proposed transformations from any PIR protocols
to SPIR protocols in the computational setting. Their transformation
requires only one execution of a given PIR protocol and 
executions of a 1-out-of-2 OT protocol. The notion of EPIR
\cite{BCPT07,BC09} is essentially a generalization of SPIR in the
computational setting.

EPIR is also  related to  selective private function evaluation
\cite{CIKRRW01}, oblivious polynomial evaluation  \cite{NP99} and
private keyword search \cite{FIPR05}. A selective private function
evaluation protocol \cite{CIKRRW01} allows a client to privately
evaluate a public function on the inputs  held by one or more
servers. Comparing with EPIR, the client  only decides on which
inputs the public function will be evaluated. An oblivious
polynomial evaluation protocol \cite{NP99} allows a receiver to
privately evaluate  a polynomial function on  his  input, where the
polynomial is held by a sender. Comparing with EPIR, the function to
be evaluated is not known to the receiver and the input on which the
function is evaluated is not known to the sender. A private keyword
search protocol  \cite{FIPR05} allows a client to privately search a
database with a keyword such that he learns the associated record if
the keyword is contained in the database and learns nothing
otherwise. In a sense, EPIR can  also be seen as a generalization of
the above problems.


{\bf Results.} The protocol described in Section 4.3 of \cite{BC09}
will be our main topic in this paper and termed as Bringer-Chabanne
EPIR protocol   from now on. It was claimed \cite{BC09} that the
protocol enables  a user to privately evaluate any polynomial
 on a chosen  database block , where  is the field extension of degree  of the prime field
. We study the correctness of the Bringer-Chabanne
EPIR protocol   and show that it may fail frequently. In particular,
we show that, by executing the protocol,  the user with input

 does not
learn the expected result (i.e., ) with a large probability
if , where .




{\bf Methodology.} Our argument is by contradiction. To simplify the
argument, we first give a restricted version of the Bringer-Chabanne
EPIR protocol.  In the restricted version, the database is
deterministic and only has one block, i.e., . We
note that if the Bringer-Chabanne EPIR protocol satisfies the
correctness requirement, then so does the restricted version. We
then show that the restricted version does not satisfy the
correctness requirement if the polynomial to be evaluated is in
. This result allows us to conclude that the
Bringer-Chabanne EPIR protocol   does not satisfy the correctness
requirement as \cite{BC09} has claimed.

{\bf Organization.} The remainder of this paper  is organized as
follows. In Section 2, we recall the definition and security model
of EPIR \cite{BC09}. In Section 3, we recall the Bringer-Chabanne
EPIR protocol. In Section 4, we give a restricted version of the
Bringer-Chabanne EPIR protocol   and   show that the restricted
version fails frequently if the polynomial to be evaluated is in
. At last, in Section 5, we conclude the paper.


\section{Preliminaries}



\subsection{Definition}

Following the definition of \cite{BC09}, a single-database EPIR
protocol is a protocol between a database  who has 
blocks    and a user
  who wants to  evaluate   for a function
 and an index ,  where  is a
 set of functions from  to  and public. Such a protocol allows
  to learn  but no more information on the database blocks while 
learns no information on .

The above definition of EPIR is a generalization of  \cite{BCPT07}
and provides the user with more flexibility of choosing the function
 from a large set  .
 In the context of this definition, the EPIR
for testing equality  \cite{BCPT07} has  , where  if  and 0
otherwise.
The
EPIR  for computing weighted Hamming distance \cite{BCPT07}
has , where

 (For every ,  and  are the -th bits of  and
, respectively).


\subsection{Security Model}\label{sec:security_model}

As in \cite{BC09,BCPT07}, we denote by  the
query made by a user with input .
Without further notice, algorithms are assumed to be
polynomial-time. If an algorithm  runs in 
stages,  then we shall write . The security is evaluated by an experiment between an
attacker and a challenger, where the challenger simulates the
protocol executions and answers the attacker's oracle queries.
 For  a probabilistic algorithm, we denote
by 
 the action to run  with access to any polynomial number of 
 queries
generated or answered (depending on the position of the attacker) by
the oracle . A function  is said to be {\em negilible} if for any polynomial ,
there is an integer  such that  for every
. If  is  negilible, then  is said to
be
{\em overwhelming}.\\
{\bf Correctness.} An EPIR protocol is said to be {\em correct} if
any query 
 returns the correct value of  with an overwhelming probability when  and
  follow the protocol specification.\\
{\bf User Privacy.} Informally, an EPIR protocol is said to {\em
respect  user privacy} if for any query ,
 learns no information on  . Formally, an EPIR
protocol is said to respect user privacy if any attacker
, acting as a malicious database, has only a
negligible advantage  in the
following experiment:


\vspace{-0.25cm}
 {\bf Database Privacy.} Informally, an EPIR protocol is
said to {\em respect database privacy}
 if a malicious user  cannot learn more information than  for
some   via a
query . This intuitive description  can be
formalized via simulation principle by saying that the user
 cannot determine whether he is interacting with a
simulator which takes  only  as input, or with . We
denote by  the database . Formally, an
EPIR protocol is said to respect database privacy if there is a
simulator
 ,  which receives  an
auxiliary input  from a
{\em hypothetical oracle}
  for every query
, such that any attacker , acting as a malicious user, has only
a negligible advantage  in the
following experiment:

 \vspace{-0.25cm}
 Remark: The hypothetical oracle  is assumed
to have unlimited computing resources, and
  always learns exactly the input related
to the request made by the attacker.



\section{Bringer-Chabanne EPIR Protocol  }

The EPIR protocols for testing equality and computing weighted
Hamming distance of \cite{BCPT07} are based on a  pre-processing
technique. Specifically, the user  sends an encryption of its input
 to , who then computes a temporary database
which contains  an encryption of . Finally, the user
executes a
 single-database CPIR protocol with  to retrieve the encryption of .
This technique does not
allow the evaluation of  generic functions and incurs heavy
computation during the computation of the temporary database. The
Bringer-Chabanne EPIR protocol   aims to
 avoid these deficiencies. It is based on  ElGamal encryption schemes  over the multiplicative groups
 of finite fields.




\subsection{ElGamal Encryption Scheme}\label{sec:elgamal}

Let  be a prime and  be the finite field of order
. Let  be the
 finite field of order   and  be its  multiplicative group  of order 
for an integer . Let  be a generator of .
The ElGamal encryption scheme over   is a triplet of  algorithms ,
where
\begin{enumerate}
\item  is a key generation algorithm which takes as input a security parameter  and proceeds as follows:
        \begin{enumerate}
             \item  generates the parameters  and ;
             \item  picks   and computes ;
            \item   outputs  as the public key and  as  the secret key.
       \end{enumerate}

\item  is an encryption algorithm which takes as input a plaintext , picks
   and outputs    as the ciphertext.
\item    is a decryption algorithm which  takes as input a ciphertext  and outputs
.
\end{enumerate}




\subsection{Requirements on Database Blocks and Functions}\label{sec:input_domain}

Following the notations  in Section \ref{sec:elgamal}, let
 be a primitive element of the field extension .
Then there is a  polynomial  of degree  such that
 .
Let  and   be the polynomial of degree  such that
.

For the Bringer-Chabanne EPIR protocol   to be correct, it is
required
 in \cite{BC09} that
 for every , the database block  should belong to  , where

The function to be evaluated by  can be any polynomial
over , i.e., .




\begin{figure}[t]
\begin{center}
\begin{boxedminipage}{12cm}
\begin{enumerate}
\itemsep=-0.1cm
\item :
Generates an ElGamal key pair , where , and  is randomly chosen from .
 also sends  to let  the possibility
to verify the validity of  as an ElGamal public key. In
practice, the validity of  can be certified by a TTP, and the
same  can be used by the user for all his queries.



\item : For any polynomial function 
and any index , computes  and
sends them to  where
\begin{enumerate}
\item[-] 
\item[-] and  for all  ,
\end{enumerate}
with randomly chosen . Each  can be written as  where  and  are polynomial over 
of degree at most .
\item : After reception of the , checks that they are nontrivial
ElGamal ciphertexts and computes 
by replacing each occurrence of  (resp.  for
all power ) with  (resp. with ).
\item  : {Performs the product of all the  together with a random encryption
of 1, say , sends
 to .}
\item :  Outputs  as .
\end{enumerate}
\end{boxedminipage}
\end{center}
\caption{Bringer-Chabanne EPIR protocol}
\label{fig:EPIR}
\end{figure}


\subsection{Bringer-Chabanne EPIR Protocol  }


Figure \ref{fig:EPIR} is the Bringer-Chabanne EPIR protocol, where  most notations are adopted from
 Section \ref{sec:elgamal} and Section \ref{sec:input_domain}.
The authors of the protocol expect to embed the description of the
polynomial  chosen by  into an ElGamal
ciphertext such that it can be evaluated by  in an
oblivious way.

\newpage

The correctness of the Bringer-Chabanne EPIR protocol was claimed in \cite{BC09} as follows.
\begin{claim}\label{clm:correctness}
{\em (Section 4.4 of \cite{BC09})} A query {\em (say )} gives the expected result
 {\em (i.e., )} as soon as there is no index  for which one
of the values  or  is zero, which may occur only
with a negligible probability in practice, leading to the
correctness of the EPIR protocol.
\end{claim}










\section{On the Incorrectness of Bringer-Chabanne EPIR Protocol}

In this section, we show that Bringer-Chabanne EPIR protocol does not satisfy the
correctness requirement defined in Section 2.2.   To simplify the
argument, we  give a  restricted version of Bringer-Chabanne EPIR protocol in which
 is deterministic and  . The restricted version
satisfies the correctness requirement as long as  Bringer-Chabanne EPIR protocol
 satisfies the correctness requirement. Then we turn to study  the incorrectness of the restricted version.






\subsection{Restricted Version}
At step (iv) of  the Bringer-Chabanne EPIR protocol,  is
randomizing the product   and sending
  to the user.
We  note that the user could have computed the same output if  merely
 sends  .
Therefore, we can safely modify step (iv) such that 
merely sends    to 
 with no impact on the correctness of the protocol. Let .
  Then we have the restricted version (see Figure \ref{fig:RV}).




\begin{figure}[ghp]
\begin{center}
\begin{boxedminipage}{12cm}
\begin{enumerate}
\itemsep=-0.1cm
\item :
Generates an ElGamal key pair , where , and  is randomly chosen from .
 also sends  to let  the possibility
to verify the validity of  as an ElGamal public key. In
practice, the validity of  can be certified by a TTP, and the
same  can be used by the user for all his queries.
\item : For any polynomial function ,
computes  and sends it to  where
  are randomly chosen. The ciphertext  can
be written as  where  and  are
polynomials over  of degree at most .
\item: After reception of  , checks that it is a  nontrivial
ElGamal ciphertext and computes  by replacing
each occurrence of  (resp.  for all power
) with  (resp. with ).
\item : Sends  to .
\item :  Outputs   as .
\end{enumerate}
\end{boxedminipage}
\end{center}
\caption{A restricted version of Bringer-Chabanne EPIR protocol}
\label{fig:RV}
\end{figure}



Clearly, if Claim \ref{clm:correctness} holds, then we have:
\begin{claim}\label{clm:correctness_restricted}
A query {\em (say )} in an execution of
the restricted version  gives
  the expected result {\em (i.e., )} for any  
 satisfying  and .
\end{claim}

\subsection{Counterexample}\label{sec:counterexample}
We show that Claim \ref{clm:correctness_restricted} does not holds
by a counterexample. Let 
and . Let  be a
generator of  with minimal polynomial . Figure \ref{fig:exeRV} is an  execution of
the restricted version  which does not give  the expected result.

\begin{figure}[ghp]
\begin{center}
\begin{boxedminipage}{12cm}
\begin{enumerate}
\itemsep=-0.1cm
\item : Picks a private key , sets  and .
 is a pair of public and private keys for  the ElGamal
encryption scheme over group .
  sends  to
 such that  can verify the validity of
 as an ElGamal public key. Clearly,  and
 for polynomials  of degree
less
 than 3.
The field elements  which satisfy  equality 
are  and .
\item  :  For a polynomial function , takes 
and computes the ciphertext  and sends it to .
Clearly,  we have that  and .
\item  : Sets the database block to be .  After receiving the
 ciphertext  from ,  checks that  is a  nontrivial
ElGamal ciphertext and computes  by replacing each occurrence of
 (resp.  for all power ) with 
(resp. with ).
\item  : Sends  to .
\item : Outputs  as , which is absurd (since ).
\end{enumerate}
\end{boxedminipage}
\end{center}
\caption{An execution of the restricted version}
\label{fig:exeRV}
\end{figure}





\subsection{Failure Probability}\label{sec:notations}

We have seen that the restricted version  may not give  the expected
result in Section \ref{sec:counterexample}. However, given the counterexample, we cannot conclude that
the Bringer-Chabanne EPIR protocol does not satisfy the correctness requirement defined in
Section \ref{sec:security_model}.
In fact, an EPIR protocol is said to be correct as long as it always gives  the expected
result for any fixed input  {\em except with a negligible probability}.
In other words, as a collection of probabilistic algorithms,
an EPIR protocol is {\em allowed to fail with a negligible probability}.
Therefore, to show that the Bringer-Chabanne EPIR protocol
does not satisfy the correctness requirement, it is necessary to compute the failure probability
of the protocol, i.e.,
the probability that
the protocol  does not give  the expected result.

In this section, we  study the
failure  probability of the restricted version. We show,
through  experimental results,  that the restricted version  does fail with large
probability for certain choices of  (e.g.,  ).


From now on, we fix  to be the characteristic of all related
finite fields. However, we stress that our methodology is applicable
to any characteristic
 .
Following the notations of Section \ref{sec:elgamal} and Section 
\ref{sec:input_domain}, let   and
 be the extension of  of degree  for an integer  .
  Let  be the multiplicative group
of  of order  and  be a generator of .
W.l.o.g., we suppose . Then  is the
polynomial of degree less than  such that .
 For every , let  be the polynomial of degree less than  such that
  .
We define

Then the set of database blocks which satisfy the requirements
imposed by Claim \ref{clm:correctness_restricted} (or in Section
\ref{sec:input_domain})  is


We say that an execution of the restricted version  is {\em parameterized} by
 if  and  are the private
key, the polynomial to be evaluated,  the randomness used at step (ii) of the restricted version 
and  the database block held by ,  respectively.
 Let  be the polynomials of degree less than 
such that  and . Then  the
execution of the restricted version  parameterized by  gives
 the expected result {if and only if}  and
, where

For an  execution of  the restricted version   parameterized by
,  we define

Then the execution  fails if and only if . Therefore, the probability that an execution of the restricted version
fails when  is the private key and    is the polynomial
 chosen by  is exactly

Since  and  are uniformly distributed, we have that

The probability that the restricted version   fails when  is the
polynomial
 chosen by 
is exactly


The   probabilities  for  and 
are quite large and  enumerated in Table \ref{table:failprob}.
\begin{table}[ghp]
\begin{center}
\begin{tabular}{|c|c|c||c|c|c|}\hline
 &    &   &  &    & 
\\ \hline \hline
2 &     &0.61111    & 6 &           & 0.87719         \\ \hline
3 &     & 0.74271   & 7 &                         & 0.87895   \\ \hline
4 &     & 0.81537   & 8 &       & 0.89809           \\ \hline
5 &   & 0.83630   & 9 &                     & 0.90358     \\ \hline
\end{tabular}
\end{center}
\caption{Failure probability}
\label{table:failprob}
\end{table}





\subsection{Bringer-Chabanne EPIR Protocol Fails Frequently When }\label{sec:BC_EPIR_fails_frequently_for_g}

In this section, we show that the restricted version  fails with large
probability when . Specifically, for every integer , we give lower bound on .

We follow the notations in Section \ref{sec:notations}. For every
, the set   is called a {\em cyclotomic coset} mod .   By
default,   is  represented by the smallest  number  and denoted as

The number  is called the {\em coset representative} of . Clearly, all distinct cyclotomic cosets mod  are pairwise
disjoint and form a partition of , i.e.,
, where  is the set of
coset representatives of all distinct cyclotomic cosets mod . For
every positive integer , we denote by  the  number of
monic irreducible polynomials of degree  in .
\begin{lemma}\label{lem:cyc}
{\em  (Lidl and Niederreiter \cite{LN97})}
The following statements hold:
\begin{enumerate}
\item For every , the cardinality of  is a divisor of
.
\item For every positive integer , the number of cyclotomic cosets
mod  of cardinality  is .
\item  For  every integer , we have that

\end{enumerate}
\end{lemma}
For every , we denote by

 the set of field elements  in  which share the same {\em minimal polynomial} over  with  .
For every , it is clear that there  is  a subset
 of coset representatives such that

\begin{lemma}\label{lem:Unotempty}
 For every  ,  we have that .
\end{lemma}


\begin{proof}
It follows from the fact that  and .
\end{proof}

Due to (\ref{eqn:Q_t}),  is  determined by the parameters

and . Next lemma shows that  and  only share a
very
 small number of roots in 
when .
\begin{lemma}\label{lem:rootQ}
Suppose  . Then for every  and , either  for every  or  has at most one root in .
\end{lemma}
\begin{proof}
If , then  for any
, i.e.,
  for every . Otherwise, we show that  has at most one root in
 .
Due to  (\ref{eqn:Q_t}), we have that

 Suppose that  has two different roots in  , say  and , where
 . Then

It follows that

Since , the above equality implies
  Since
 is primitive, we have . It follows that
 , which is a
contradiction.
\end{proof}

The following lemma gives  lower bound on  for
any private key .

\begin{lemma}\label{lem:lower_bound_epsilon}
For every , we have that 
\end{lemma}
\begin{proof}
Due to  (\ref{eqn:epsilon}) and
(\ref{eqn:database_elt}), we have that

Let  and  be arbitrary.  Due to Lemma
\ref{lem:rootQ}, for every , either  for every
, or  has at most one root in .
It follows that

Therefore,

\end{proof}






We want to bound  for various settings of  and .
As the first case, we suppose that  is a prime and have the following lemma:

\begin{lemma}\label{lem:lower_bound_eta_for_prime_n}
If  is  prime, then   for every 
\end{lemma}

\begin{proof}
Due to Lemma \ref{lem:cyc},  divides  for every
 and . Since  is prime, we have
that  or .
\begin{enumerate}
\item If , then  due to Lemma \ref{lem:Unotempty}. It is obvious that . By Lemma \ref{lem:lower_bound_epsilon},  we have

\item If  and , then we have that

\item If  and , then we have that

\end{enumerate}
\end{proof}




Below we lower bound  for {\bf any} integer  and  private key .
 For any positive integer , we
set
 
Due to Lemma \ref{lem:Unotempty} and the requirements on database
block  (imposed by Claim
 \ref{clm:correctness_restricted}),   belongs to the following set

where the coordinates of  and  are  indexed by
positive divisors of . Due to Lemma
\ref{lem:lower_bound_epsilon}, we have that

We turn to  upper bound the following function

on . Because this  is relatively hard, we turn to upper
bound the function

where   is taken from the following set

Let  be the maximum value of  on ,
i.e.,



\begin{lemma}\label{lem:lower_bound_large_x}
For every , we have that .
\end{lemma}
\begin{proof}
Clearly, . Due to
 (\ref{eqn:lower_bound_epsilon_any_x}), we have that
 for
every .
\end{proof}

Due to Lemma \ref{lem:lower_bound_large_x}, it is sufficient  to
upper bound .
\begin{lemma}\label{lem:omega_maximality}
Suppose that  for
. Then  .
Furthermore, if , then there is an integer  such
that  for every integer  and  for
every integer     .
\end{lemma}
\begin{proof}
It is trivial to verify that  for . Let .

\begin{enumerate}
\item  For every , it is easy to see that

which implies that  .


\item For every  (where ), it is easy to see that

which implies that .



\item Suppose   for some integer .  Let
 Then due to the maximality of
, we have that


The above inequalities  imply that
. Hence, we have
 



\item We claim that  for every . Otherwise, by (iii), we have that  and

which is a contradiction.



\item We claim  that  for every . Otherwise, by (iii), we have that  and

which is a contradiction.

\item
Finally, we show that  . Due to (iii), (iv) and (v), we have that

where .
Since , we have
  If , then

which is a contradiction. Therefore, .Then it is not
hard to verify that
 Therefore,  we
could have taken .
\end{enumerate}
\end{proof}


Due to Lemma  \ref{lem:omega_maximality}, for every integer , there is at least one integer  such that

Note that the integer  may be not unique. For every integer
, we define

to be the smallest integer  such that
(\ref{eqn:index_h}) holds.
 Next lemma shows that  is an increasing  function of .
\begin{lemma}\label{lem:h_n_is_increasing}
We have that  for every  integer .
\end{lemma}
\begin{proof}
Due to the definition of  by
(\ref{eqn:define_h_n}), it is not hard to see that

 for every
integer . Equivalently, we have that

for every integer . Due to 
(\ref{eqn:n_implication}), it is not hard to verify that

for every integer . In particular, 
(\ref{eqn:det_h_n_1}) holds for . This implies that .
\end{proof}

On the other hand,  is a decreasing function of :
\begin{lemma}\label{lem:omega_n_is_decreasing}
We have that  for every  integer
.
\end{lemma}
\begin{proof}
By Lemma \ref{lem:h_n_is_increasing}, we have that  .  If , then

If , then

where the first and third inequalities follow from the
definition of    by 
(\ref{eqn:define_h_n}).
\end{proof}













We enumerate  the values of  and  for some integers   in Table \ref{table:h_n}.

\begin{table}[t]
\begin{center}
    \begin{tabular}{|c|c|c||c|c|c||c|c|c|}\hline
   &  &  &   &  &  &   &  &  \\ \hline\hline
2 &   1    & 0.66667    &  12 &   4    & 0.24242  & 296 &  10    & 0.09996   \\ \hline
3 &   1    & 0.50000    &  20 &   5    & 0.19718  & 522 &  11 & 0.09089\\ \hline
4 &   2    & 0.42857    &  34 &   6    & 0.16547  & 934 &  12 & 0.08332\\ \hline
5 &   2    & 0.37500    &  57 &   7    & 0.14236  & 1681 &  13 & 0.07692\\ \hline
6 &   2    & 0.33333    &  98 &   8    & 0.12478  & 3058 &  14 & 0.07143\\ \hline
7 &   3    & 0.31250    &  169 &   9    & 0.11101 & 5596 &  15 & 0.06667\\ \hline
     \end{tabular}
    \end{center}
    \caption{The values of  and }
    \label{table:h_n}
\end{table}


\begin{lemma}\label{lem:compare_for_small_x}
For every integer ,
 we have that .
\end{lemma}
\begin{proof}
Due to Table 2 and Lemma \ref{lem:h_n_is_increasing}, we have that
 for every integer . It follows that

\end{proof}


At last, we have the following theorem.
\begin{theorem}\label{thm:lower_bound_eta_for_any_n}
We have that

\end{theorem}

\begin{proof}
Table \ref{table:h_n} shows that   for every integer .
Due to Lemma \ref{lem:lower_bound_eta_for_prime_n} and
Lemma \ref{lem:lower_bound_large_x},
we have that 
for ,  and  for .
Due to  (\ref{eqn:eta}), we have that


Due to Lemma \ref{lem:lower_bound_eta_for_prime_n}, Lemma \ref{lem:lower_bound_large_x}
and Lemma \ref{lem:compare_for_small_x},
we have that  if  is prime
and
 if  is composite.
 Due to  (\ref{eqn:eta}), we have that
  if  is prime and
   if  is composite.
\end{proof}






By Theorem \ref{thm:lower_bound_eta_for_any_n}, Lemma \ref{lem:omega_n_is_decreasing}
and Table \ref{table:h_n},  we see that
 is always non-negligible.
Hence, we have the following theorem.
\begin{theorem}\label{thm:BC_is_not_correct_for_g}
The restricted version  does not satisfy the correctness requirement if .
\end{theorem}





\subsection{Extension to A Set of Polynomials}

In this section, we extend Theorem \ref{thm:BC_is_not_correct_for_g}
to a set of polynomials
 . In particular, we follow the notations in Section \ref{sec:BC_EPIR_fails_frequently_for_g} and
  show that the restricted version   does not satisfy the correctness requirement
if  , where
\begin{center}

\end{center}
Note that the polynomial  we studied in Section
\ref{sec:BC_EPIR_fails_frequently_for_g} is in
 and satisfies Lemma \ref{lem:rootQ}, which is critical
for obtaining all subsequent  lemmas and theorems.
 Next lemma shows that Lemma \ref{lem:rootQ} holds for any polynomial
 as well.
\begin{lemma}\label{lem:F_t_in_POLY_are_good}
Let  . Then for every  and , either  for every
 or  has at most one root in .
\end{lemma}

\begin{proof}
If , then  for every
, i.e.,  for every . Otherwise, we have  for every . Suppose
 , where  is of order  and
  for every . We show that  has at most one root in , where
 
Suppose  has two different roots in , say  and ,
where . Then
 It
follows that

Let . Then it is not hard to see that
 Due to
(\ref{eqn:raise_to_high_power}), we have that

Since  is primitive, we have
 and therefore , which  is a
contradiction.
\end{proof}

Due to Lemma \ref{lem:F_t_in_POLY_are_good}, we note that all lemmas
and theorems subsequent to Lemma \ref{lem:rootQ} in Section
\ref{sec:BC_EPIR_fails_frequently_for_g} can be generalized  for any
polynomial . Therefore, we have that

\begin{theorem}\label{thm:BC_is_not_correct_for_gg}
The restricted version  does not satisfy the correctness requirement if .
\end{theorem}


\subsection{Extension to Any Characteristic }
We have stressed in Section \ref{sec:notations} that our methodology
is applicable when the characteristic of all related finite fields
is any prime . For example, it is obvious that
we have an analog of Lemma \ref{lem:lower_bound_large_x} for any
characteristic .
Let  be an analog of the
function  when the characteristic of all related finite
fields is a prime .
Then the following theorem holds as
well.
\begin{theorem}\label{thm:lower_bound_eta_for_any_n_p}

We have that  for every integer
, where  is primitive and  is an
arbitrary prime number.
\end{theorem}
It follows that Theorem \ref{thm:BC_is_not_correct_for_gg} also
holds when the  characteristic of all related finite fields is any
prime  .

\section{Conclusion}

In this paper, we  show that the Bringer-Chabanne EPIR protocol does not satisfy the correctness requirement.
 To simplify the argument, we give a restricted version of  the Bringer-Chabanne EPIR protocol   . If the original protocol satisfies the correctness requirement, then so does the restricted version.
We  show that the restricted version fails frequently   if the
polynomial to be evaluated has some special property. This allows us
to get the expected conclusion, i.e., the Bringer-Chabanne EPIR
protocol    does not satisfy the correctness requirement.





\begin{thebibliography}{00}

\bibitem{Amb97}
Ambainis, A.: Upper Bound on the Communication Complexity of Private
Information Retrieval. In:  Degano, P., Gorrieri, R.,
Marchetti-Spaccamela, A.   (eds.)  ICALP 1997. LNCS, vol. 1256,  pp.
401-407. Springer, Heidelberg (1997)


\bibitem{BIK05} Beimel, A., Ishai, Y., Kushilevitz, E.:
General Constructions for Information-Theoretic Private Information
Retrieval. Journal of Computer and System Sciences 71(2), pp.
213-247 (2005)

\bibitem{BIKR02}
Beimel, A., Ishai, Y., Kushilevitz, E., Raymond, J. F.: Breaking the
 Barrier for Information-Theoretic Private
Information Retrieval. In:  FOCS 2002,  pp. 261-270. IEEE, Los
Alamitos (2002)


\bibitem{BCR87}
Brassard, G., Cr{\'{e}}peau, C., Robert, J. M.: All-or-Nothing
Disclosure of Secrets. In:  Odlyzko, A. M. (ed.) CRYPTO 1986. LNCS,
vol. 263, pp. 234-238.  Springer, Heidelberg (1987)


\bibitem{BC09}
Bringer, J., Chabanne, H.: Another Look at Extended Private
Information Retrieval Protocols. In: Preneel B. (ed.) AFRICACRYPT
2009. LNCS, vol.  5580, pp. 305-322. Springer, Heidelberg (2009)

\bibitem{BCPT07}
Bringer, J., Chabanne, H.,  Pointcheval, D.,  Tang, Q.: Extended
Private Information Retrieval and Its Application in Biometrics
Authentications. In:  Bao, F., Ling, S.,  Okamoto, T., Wang, H.,
Xing, C. (eds.)  CANS 2007. LNCS, 6467, pp. 175-193.  Springer,
Heidelberg (2007)




\bibitem{CMS99}
Cachin, C., Micali, S., Stadler, M.: Computationally Private
Information Retrieval with Polylogarithmic Communication. In: Stern
J. (ed.) EUROCRYPT 1999. LNCS, vol. 1592, pp. 402-414.  Springer,
Heidelberg (1999)

\bibitem{CIKRRW01}
Canetti, R., Ishai, Y., Kumar, R., Reiter, M.K., Rubinfeld,
R.,Wright, R.N.: Selective Private Function Evaluation with
Applications to Private Statistics. In:  PODC 2001, pp. 293-304.
ACM, New York  (2001)




\bibitem{Chang04}
Chang, Y. C.: Single Database Private Information Retrieval with
Logarithmic Communication. In: Wang, H.,  Pieprzyk, J.,
Varadharajan, V. (eds.)  ACISP 2004. LNCS, vol. 3108, pp. 50-61.
Springer, Heidelberg (2004)



\bibitem{CFLWZ10}
Chee, Y. M., Feng, T., Ling, S., Wang, H.,  Zhang, L. F.:
Query-Efficient Locally Decodable Codes of Subexponential Length.
CoRR abs/1008.1617 (2010)

\bibitem{CG97}
Chor, B., Gilboa, N.: Computationally Private Information Retrieval.
In: STOC 1997, pp. 304-313. ACM, New York  (1997)


\bibitem{CGKS95}
Chor, B., Goldreich, O., Kushilevitz, E., Sudan, M.:
 Private Information Retrieval.
In: FOCS 1995, pp. 41-50. IEEE, Los Alamitos (1995)





\bibitem{Efr09}
Efremenko, K.: 3-Query Locally Decodable Codes of Subexponential
Length. In: STOC 2009, pp. 39-44. ACM, New York  (2009)


\bibitem{EGL85}
Even, S., Goldreich, O., Lempel, A.: A Randomized Protocol for
Signing Contracts. Communications of the ACM 28 (6), pp.  637-647
(1985)

\bibitem{FIPR05}
Freedman, M.J., Ishai, Y., Pinkas, B., Reingold, O.: Keyword Search
and Oblivious Pseudorandom Functions. In:  Kilian  J. (ed.) TCC
2005. LNCS, vol. 3378, pp. 303-324.  Springer, Heidelberg (2005)

\bibitem{GR05}
Gentry, C., Ramzan, Z.: Single-Database Private Information
Retrieval with Constant Communication Rate. In: Caires, L.,
Italiano, G. F.,  Monteiro, L., Palamidessi, C., Yung, M. (eds.)
ICALP 2005. LNCS, vol.  3580,  pp. 803-815. Springer, Heidelberg
(2005)

\bibitem{GIKM98}
Gertner, Y., Ishai, Y., Kushilevitz, R., Malkin, T.: Protecting Data
Privacy in Private Information Retrieval Schemes. In:  STOC 1998,
pp. 151-160. ACM, New York (1998)


\bibitem{Gol04}
Goldreich, O.: Foundations of Cryptography: Basic Applications, vol.
2. Cambridge University Press, Cambridge (2004)





\bibitem{GMW87}
Goldreich, O., Micali, S., Wigderson, A: How to Play Any Mental Game
or A Completeness Theorem for Protocols with Honest Majority. In:
STOC 1987, pp. 218-229. ACM, New York (1987)



\bibitem{GKL10}
Groth, J., Kiayias, A., Lipmaa, H.: Multi-query
Computationally-Private Information Retrieval with Constant
Communication Rate. In:  Nguyen, P. Q., Pointcheval, D. (eds.) PKC
2010. LNCS, vol. 6056,  pp. 107-123.   Springer, Heidelberg (2010)


\bibitem{IS10}
Itoh, T., Suzuki, Y.: New Constructions for Query-Efficient Locally
Decodable Codes of Subexponential Length. IEICE Transactions on
Information and Systems E93-D(2), pp.  263-270 (2010)


\bibitem{Kil88}
Kilian, J.: Founding Cryptography on Oblivious Transfer. In:  STOC
1988, pp. 20-31. ACM, New York (1988)

\bibitem{KO97}
Kushilevitz, E., Ostrovsky, R.: Replication Is Not Needed: Single
Database, Computationally-Private Information Retrieval. In: FOCS
1997, pp. 364-373. IEEE, Los Alamitos (1997)

\bibitem{KO00}
Kushilevitz, E., Ostrovsky, R.: One-Way Trapdoor Permutations Are
Sufficient for Non-trivial Single-Server Private Information
Retrieval. In: Preneel B. (ed.)  EUROCRYPT 2000. LNCS, vol. 1807,
pp. 104-121. Springer, Heidelberg  (2000)

\bibitem{LN97}
Lidl, R., Niederreiter, H.: Finite Fields, Second edition, Cambridge
University Press (1997)


\bibitem{Lip05}
Lipmaa, H.: An Oblivious Transfer Protocol with Log-Squared
Communication. In: Zhou, J.,  Lopez, J.,  Deng, R. H., Bao, F.
(eds.) ISC 2005. LNCS, vol. 3650, pp. 314-328. Springer, Heidelberg
(2005)


\bibitem{NP99}
Naor, M., Pinkas, B.: Oblivious Transfer and Polynomial Evaluation.
In: STOC 1999, pp. 245-254. ACM, New York (1999)





\bibitem{Rab81}
Rabin, M. O.: How to Exchange Secrets by Oblivious Transfer.
Technical Report TR-81, Aiken Computation Laboratory, Harvard
University (1981)

\bibitem{WY05}
Woodruff, D. P., Yekhanin, S.: A Geometric Approach to
Information-Theoretic Private Information Retrieval. In: CCC 2005,
pp. 275-284. IEEE, Los Alamitos  (2005)






\bibitem{YS01}
Yamamura, A., Saito, T.: Private Information Retrieval Based on the
Subgroup Membership Problem. In: Varadharajan, V., Mu, Y. (eds.)
ACISP 2001. LNCS, vol 2119,  pp. 206-220.  Springer, Heidelberg
(2001)





\bibitem{Yek07}
Yekhanin, S.: Towards 3-Query Locally Decodable Codes of
Subexponential Length. In: STOC 2007, pp. 266-274. ACM, New York
(2007)


\end{thebibliography}






\end{document} 