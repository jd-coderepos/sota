\documentclass[a4paper,11pt]{article}

\usepackage{color}
\usepackage{latexsym,amssymb,amsmath}
\usepackage{amsthm}
\usepackage{graphicx}
\usepackage{enumerate}
\usepackage[noadjust]{cite}
\usepackage{url}

\usepackage{wrapfig}

\usepackage[top=2.54cm, bottom=2.54cm, left=2.54cm, right=2.54cm]{geometry}

\newtheorem{theorem}{Theorem}[section]
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{conjecture}[theorem]{Conjecture}
\newtheorem{observation}[theorem]{Observation}
\newtheorem{claim}[theorem]{Claim}
\newtheorem{operation}{Operation}


\graphicspath{{figures/},{figures/boxes}}

\newcommand{\noproof}{~\hfill}
\newcommand{\qedopt}{}

\newcommand{\ShoLong}[2]{#2} 

\title{Flip Distance Between Triangulations of a Simple Polygon is NP-Complete\thanks{Preliminary versions appeared as O.\@ Aichholzer, W.\@ Mulzer, and
A.\@ Pilz, \emph{Flip Distance Between Triangulations of a Simple 
Polygon is NP-Complete} in Proc.\@ 29th EuroCG, pp.~115--118, 2013, and
in Proc.\@ 21st ESA, pp.~13--24, 
2013~\cite{eurocg_version,esa_version}.
The final publication is available at Springer via
\protect\url{http://dx.doi.org/10.1007/s00454-015-9709-7}.}
}

\author{Oswin Aichholzer\thanks{Institute for Software Technology, Graz 
University of Technology, Austria.
Partially supported by the ESF EUROCORES
programme EuroGIGA - ComPoSe, Austrian Science Fund (FWF): I~648-N18.
\texttt{oaich@ist.tugraz.at.}}
\and Wolfgang Mulzer\thanks{
Institute of Computer Science, Freie Universit\"at Berlin, Germany.
Supported in part by DFG project MU/3501/1.
\texttt{mulzer@inf.fu-berlin.de.}}
\and Alexander Pilz\thanks{Recipient of a DOC-fellowship of the Austrian
Academy of Sciences at the Institute for Software Technology, Graz University
of Technology, Austria.
Part of this work has been done while this author was visiting the 
Departamento de Matem\'aticas, Universidad de Alcal\'a, Spain.
\texttt{apilz@ist.tugraz.at.}}
}


\begin{document}

\maketitle

\begin{abstract}
Let  be a triangulation of a simple polygon.
A \emph{flip} in~ is the operation of replacing one diagonal of~
by a different one such that the resulting graph is again
a triangulation.  The \emph{flip distance} between two triangulations is the smallest
number of flips required to transform one triangulation into the
other.
For the special case of convex polygons,
the problem of determining the shortest flip distance between two triangulations is equivalent to determining the rotation distance between two binary trees, 
a central problem which is still open after over 25 years of intensive study.

We show that computing the flip distance between two
triangulations of a simple polygon is NP-hard.  This complements a recent
result that shows APX-hardness of determining the flip distance between two
triangulations of a planar point set.
\end{abstract}

\section{Introduction}
Let  be a simple polygon in the plane, that is, a closed region bounded by a 
piece-wise linear, simple cycle.  A \emph{triangulation} of~ is a geometric 
(straight-line) maximal outerplanar graph whose outer face is the complement 
of~ and whose vertex set consists of the vertices of~.  The edges
that are not on the outer face are called \emph{diagonals}.  Let  be a diagonal
whose removal creates a convex quadrilateral. Replacing  with the
other diagonal of the quadrilateral yields another triangulation of~.
This operation is called a \emph{flip}.
The \emph{flip graph} of~ is the abstract graph whose vertices are the
triangulations of~ and in which two triangulations are adjacent if and only if
they differ by a single
flip.  We 
study the \emph{flip distance}, i.e., the minimum number
of flips required to transform a given source triangulation into a target
triangulation.

Edge flips became popular in the context of Delaunay
triangulations.  Lawson~\cite{lawson_connected} proved that any triangulation
of a planar -point set can be transformed into any other by  flips. 
Hence, for every planar -point set the flip graph 
is connected with diameter .
Later, Lawson showed that in fact every triangulation can be transformed to the Delaunay
triangulation by  flips that locally fix the Delaunay 
property~\cite{lawson_delaunay}. 
Hurtado, Noy, and Urrutia~\cite{hurtado_noy_urrutia} gave an example where the 
flip distance is , 
and they showed that the same bounds hold for triangulations of simple polygons.
They also proved that if the polygon has  reflex vertices, then
the flip graph has diameter . In particular, the flip graph of
any planar polygon has diameter .  Their result also generalizes the
well-known fact that the flip distance between any two triangulations of a
convex polygon is at most , for . This was shown by Sleator, Tarjan, and Thurston~\cite{sleator} in their work on the flip distance in convex polygons.
The latter case is particularly 
interesting due to the correspondence between flips in triangulations of
convex polygons and rotations in binary trees:
The dual graph of such a triangulation is a binary tree, and a flip 
corresponds to a rotation in that tree; conversely, for every 
binary tree, a triangulation can be constructed.

We mention two further remarkable results on 
flip graphs for point sets.  Hanke, Ottmann, and
Schuierer~\cite{edge_flipping_distance} showed that the flip distance between
two triangulations is bounded by the number of crossings in their overlay. 
Eppstein~\cite{eppstein} gave a
polynomial-time algorithm for calculating a lower bound on the flip distance.
His bound is tight for point sets with no empty 5-gons; however, except for
small instances, such point sets are not in general position (i.e.,
they must contain collinear triples)~\cite{empty5gon}. 
A recent survey on flips is provided by Bose and Hurtado~\cite{survey}.

Recently, the problem of finding the flip distance between two triangulations of a
point set was shown to be NP-hard by Lubiw and
Pathak~\cite{lubiw} and, independently, by Pilz~\cite{point_set_hard}.
The latter proof was later improved to show APX-hardness of the problem.
A recent paper shows that the problem is fixed-parameter tractable~\cite{flip_distance_fpt}.
Here, we show that the corresponding problem remains NP-hard even for simple polygons.
This can be seen as a further step towards settling the complexity
of deciding the flip distance between triangulations of convex polygons or, equivalently, the rotation distance between binary trees.
This variant of the problem was probably first addressed by Culik and 
Wood~\cite{tree_similarity} in 1982 (showing a flip distance of ) in the context of similarity measures between trees.

We now give the formal problem definition:
given a simple polygon~, two triangulations 
 and  of~, and an integer , decide whether
 can be transformed into  by at most  flips.
We call this decision problem \textsc{PolyFlip}.
To show NP-hardness, we give a polynomial-time reduction from
the problem \textsc{Rectilinear Steiner Arborescence} to \textsc{PolyFlip}.
\textsc{Rectilinear Steiner Arborescence} was shown to be NP-hard by Shi and Su~\cite{shi_su}.
In Section~\ref{sec:RSA}, we describe the problem in detail. 
We present the well-known \emph{double chain}
(used by Hurtado, Noy, and Urrutia~\cite{hurtado_noy_urrutia} for giving their lower bound), a major 
building block in our reduction, in Section~\ref{sec:double_chain}.
Finally, in Section~\ref{sec_reduction}, we describe our reduction
and prove that it is correct.

\section{The Rectilinear Steiner Arborescence Problem}
\label{sec:RSA}
Let  be a set of~ points in the plane whose coordinates are nonnegative integers. 
The points in~ are called \emph{sinks}. 
A \emph{rectilinear tree}  is a connected acyclic collection of horizontal 
and vertical line segments that intersect only at their endpoints.
The \emph{length} of~ is the total length of all segments in~ 
(cf.~\cite[p.~205]{hwang}).
The tree  is a \emph{rectilinear Steiner tree} for  if every sink in 
 appears as an endpoint of a segment in~. 
We call  a \emph{rectilinear Steiner arborescence} (RSA) for  if (i)  is 
rooted at the origin; (ii) every leaf of~ lies at a sink in~; and (iii) for 
each , the length of the path in~ from the origin to  
equals , i.e., all edges in~ point north or east, as seen from the origin~\cite{rao}.
In the problem 
\textsc{Rectilinear Steiner Arborescence}, we are given a set of sinks  and an integer~. The question
is whether there is an RSA for  of length at most . 
Shi and Su showed that \textsc{Rectilinear Steiner Arborescence} is strongly 
NP-complete; in particular, it 
remains NP-complete if  is contained in an  grid, with  
polynomially bounded in~, the number of
sinks~\cite{shi_su}.\footnote{Although a  polynomial-time algorithm was 
claimed~\cite{trubin}, it has later been shown to be incorrect~\cite{rao}.}

We will need the following important structural property of the RSA.
Let  be an RSA for a set  of sinks. 
Let  be a vertical segment in~ that does not contain a sink. 
Suppose there is a horizontal segment  incident to the upper endpoint  of~.
Since  is an arborescence,  is the left endpoint of~.
Suppose further that  is not the lower endpoint of another vertical edge.
Take a copy  of~ and translate it to the right until  hits a sink 
or another segment endpoint (this will certainly happen at the right
endpoint of~); see \figurename~\ref{fig_arborescence_slide}.
The segments  and  define a rectangle~.
The upper and left side of~ are completely covered by  and (a part of) .
Since  has only two incident segments, every sink-root path in~ that goes through 
 or  contains these two sides of~, entering the boundary of~ 
at the upper right corner  and leaving it at the lower left corner~.
We reroute every such path at  to continue clockwise along the boundary of 
 until it meets  again (this certainly happens at~), and we 
delete  and the part of~ on .
In the resulting tree we subsequently remove all unnecessary 
segments (this happens if there are no more root-sink paths through~) 
to obtain another RSA  for~.
Then  is not longer than~.
This operation is called \emph{sliding  to the right}.
If similar conditions apply to a horizontal edge, we can \emph{slide it upwards}.
The \emph{Hanan grid} for a point set is the set of all vertical and horizontal 
lines through its points.
Through repeated segment slides in a shortest RSA, one
can obtain the following theorem.
\begin{theorem}[\cite{rao}]\label{thm_slide}
Let  be a set of sinks. There is a minimum-length RSA  for
 such that
all segments of~ are on the Hanan
grid for .\noproof
\end{theorem}
\begin{figure}
\centering
\includegraphics[width=\textwidth]{arborescence_slide}
\caption{The slide operation. The dots depict sinks; the 
rectangle~ is drawn gray.
The dotted segments are deleted, since they do no longer lead to a sink.
}
\label{fig_arborescence_slide}
\end{figure}

We use a restricted version of \textsc{Rectilinear Steiner Arborescence}, 
called YRSA.
An instance  of YRSA differs from an instance for \textsc{Rectilinear
  Steiner Arborescence}
in that we require that no two sinks in~ have the 
same -coordinate.
\ShoLong{The NP-hardness of YRSA follows by a simple perturbation argument; 
see the full version for all omitted proofs.}
{}

\begin{theorem}\label{thm_yrsa}
\textup{YRSA} is strongly \textup{NP}-complete.
\end{theorem}


\begin{proof}
Due to Theorem~\ref{thm_slide}, YRSA and 
\textsc{Rectilinear Steiner Arborescence} 
are in NP~\cite{shi_su}.
We now show how to transform an instance
 of \textsc{Rectilinear Steiner Arborescence} to an
instance of YRSA. 
We may assume that , and we number the sinks as  in an arbitrary fashion.
For , let  be the coordinates of~ and define .
We set .
The -coordinates of the sinks in~ are pairwise distinct.
We will show that there is an RSA for  of length at most 
if and only if there is an RSA for  of length at most
. 

Let  be a rectilinear Steiner arborescence for  of length at most .
We scale  by  and draw a vertical segment from each leaf to the sink in 
above it.
This gives an RSA for  of length at most .

Conversely, let  be an RSA for  of length at most .
Due to Theorem~\ref{thm_slide}, we can assume that  is on the Hanan grid.
We round the -coordinate of every segment endpoint in 
 down to the next multiple of  (possibly removing segments of length 0).
The resulting drawing remains connected; every path to the origin 
remains monotone; and since the segments of  lie on the
Hanan grid of , no new cycles are introduced. 
Thus, the resulting drawing constitutes an arborescence  for 
the set  of sinks obtained by scaling  by .
Since  lies on the Hanan grid, it is a union of~ paths, each with
at most  vertical segments. 
The rounding operation increases the length of
each such vertical segment by at most .
Thus, the total length of  is at most
. By Theorem~\ref{thm_slide}
there exists an optimum arborescence  for
 that lies on the Hanan grid. The
length of  is a multiple of , and thus
at most , since  for .
 It follows that  has an RSA of length at most .


Therefore,  is a yes-instance for \textsc{Rectilinear Steiner
Arborescence} if and only if  is a yes-instance for
YRSA. Since  can be computed in polynomial time 
from , and since the coordinates in
 are polynomially bounded in the coordinates of~, it follows that 
YRSA is strongly NP-complete.
\qedopt
\end{proof}

Due to Theorem~\ref{thm_slide}, we get the following technical corollary, which will be useful later.

\begin{corollary}\label{cor_blow_up}
YRSA remains strongly NP-complete even if the sinks have coordinates that are a multiple of a positive integer whose value is polynomial in~.
\end{corollary}

\section{Double Chains}\label{sec:double_chain}
Our definitions (and illustrations) follow~\cite{point_set_hard}.  A \emph{double
chain}  is a polygon
that consists of two chains, an \emph{upper chain} and a \emph{lower chain}.
There are  vertices on each chain,  on the
upper chain and  on the lower chain,
both numbered from left to right, and  is defined by .
Any point on one chain sees every point on the other chain, and any quadrilateral formed by three vertices of one chain and one vertex of the other chain is non-convex;
see \figurename~\ref{fig_dc_triangulations_wedges}~(left).
We call the triangulation  of~ where  has maximum degree the
\emph{upper extreme triangulation}; observe that this triangulation is unique.  
The triangulation  of~ where  has maximum degree
is called the \emph{lower extreme triangulation}.  The two extreme triangulations
are used to show that the diameter of the flip graph is quadratic; see \figurename~\ref{fig_dc_triangulations_wedges}~(right).

\begin{theorem}[Hurtado, Noy, Urrutia~\cite{hurtado_noy_urrutia}]\label{thm_dc}
The flip distance between  and  is~\mbox{}.\noproof
\end{theorem}

Through a slight modification of~, we can make the flip distance between the upper and the lower extreme triangulation linear.
This will enable us in our reduction to impose a certain structure on short flip sequences.
To describe this modification, we first define the \emph{flip-kernel} of a double chain.

\begin{figure}
\centering
\includegraphics[width=\textwidth]{dc_triangulations_wedges}
\caption{
Left: The polygon and the hourglass (gray) of a double chain. The diamond-shaped
flip-kernel can be extended arbitrarily by flattening the chains.
Right: The upper extreme triangulation  and the lower extreme triangulation . 
}
\label{fig_dc_triangulations_wedges}
\end{figure}

Let  be the wedge defined by the lines through  and
 whose interior contains no vertex of~ but intersects the segment .
Define  analogously by the lines through  and .
We call  the \emph{hourglass of~}.
The unbounded set  is defined by four rays and the two chains.
The \emph{flip-kernel} of~ is the intersection of the four closed half-planes below the lines through  and  and above the lines through  and .\footnote{The flip-kernel of~ might not be completely inside the polygon~.
This is in contrast to the ``visibility kernel'' of a polygon.}

\begin{figure}
\centering
\includegraphics[width=\textwidth]{dc_steiner_small}
\caption{The extra point~ in the flip-kernel of~ allows flipping one extreme triangulation
of~ to the other in  flips.}
\label{fig_dc_steiner}
\end{figure}

\begin{definition}\label{def_p_d_plus}
\sloppypar{
Let  be a double chain and let  be a point in the flip-kernel of~ to the right
of the directed line .
The polygon given by the sequence  is called a \emph{double chain extended by~}.
The upper and the lower extreme triangulation of such a polygon contain the edge  as a diagonal and are otherwise defined in the same way as for~.
}
\end{definition}

The flip distance between the two extreme
triangulations of  extended by a point~ is much
smaller than for ~\cite{problemas}.
\figurename~\ref{fig_dc_steiner} shows how to 
transform them into each other with  flips.
The next lemma shows that this is optimal, even for more general polygons.
The lemma is a slight generalization of a lemma by Lubiw and Pathak~\cite{lubiw} on double chains of constant size.

\begin{lemma}\label{lem_lower_bound}
\begin{sloppypar}
Suppose that  and
consider a polygon that contains  and has  and  as part of 
its boundary.
Let  and  be two triangulations that contain the upper
extreme triangulation and the lower extreme triangulation of~ as a
sub-triangulation, respectively.  Then  and  have flip distance at
least .
\end{sloppypar}
\end{lemma}
\begin{proof}
We slightly generalize a proof by Lubiw and Pathak~\cite{lubiw} for
double chains of constant size.

Let  be the upper chain and  be the lower
chain of .
The triangulation  has  triangles
with an edge on  or on .
These triangles are called \emph{anchored},
and the vertex not incident to the edge on  or on  
is called the \emph{apex}.
For each anchored triangle with an edge on ,
the apex must move from  to~, and similarly for .
We distinguish three
types of flips depending on whether the convex quadrilateral whose diagonal
is flipped has (1) four; (2) three; or
(3) at most two vertices on .
A flip of type (1) moves the apex
of two anchored triangles by one; a flip of type (2) moves the apex of one 
anchored triangle from
 to a point outside  or back again; and a flip of type (3)
does not move any apex of an anchored triangle along  or between a vertex 
of~ and a vertex not in~.

We say that an anchored triangle is of type (1) if its apex is moved
only by flips of type (1). It is of type (2) if its apex
is moved by at least one flip of type (2). Every anchored triangle
is either of type (1) or of type (2).
A type (1) triangle must be involved
in at least  flips of type (1), and each of these flips
can affect at most one other type (1) triangle.
A type (2) triangle must be involved in at least 
flips of type (2), and each of these flips can affect
no other anchored triangle.
Thus, if we have  type (1) triangles and  type (2)
triangles, we need at least
 flips.
For , we have
,
as claimed.
\qedopt
\end{proof}

The following result can be seen as a special case of~\cite[Proposition~1]{point_set_hard}.

\begin{lemma}\label{lem_empty_wedge}
\begin{sloppypar}
Consider a polygon that contains~ and has  as part of 
its boundary. Let  and  be two triangulations that contain the upper and 
the lower extreme triangulation of~ as a sub-triangulation, respectively.
Let  be a flip sequence from  to  such that there is no triangulation in~ containing a triangle with one vertex at the upper chain, the other vertex at the lower chain, and the third vertex at a point in the interior of the hourglass of~.
Then .
\end{sloppypar}
\end{lemma}
\begin{proof}
Our reasoning is similar to the proof of Lemma~\ref{lem_lower_bound}, 
see also~\cite{lubiw}. As before, let  and 
be the upper and lower chain of~, and call a
triangle with an edge on  or on  \emph{anchored},
the third vertex being the \emph{apex}.
Any triangulation of the given polygon has  anchored triangles.

We will argue that for each triangulation of~ there 
exists a line~ that separates  from 
and that intersects all anchored triangles.
This is clear if the apices of all anchored triangles
lie on the other chain or outside the hourglass.
Now consider a triangulation of the sequence~ where 
at least one anchored triangle has its apex at a 
vertex  inside the hourglass.
Let  be a ray that starts at a point on  and 
passes through~ such that the supporting line of~ separates 
 from  (such a ray must exist 
since  is inside the hourglass).
Then  intersects at least one triangle that 
is not anchored, because the triangle whose interior is intersected 
by~ before reaching  cannot be anchored.
Let  be the first non-anchored triangle whose 
interior is intersected by~.
Then  has one vertex on 
and one vertex on . By assumption, the 
third vertex of~  cannot be inside the hourglass,
so it must lie outside.
This means that one of the vertices 
of~ has to be either  or~.
This  implies that either all anchored triangles at  or
or all anchored triangles , 
respectively, have their apex at the opposite chain.
Thus, also for this triangulation there exists a line~ 
that separates  from  and that 
intersects all anchored triangles. Observe that every such line
intersects the anchored triangles in the same order.

Now we proceed similarly as in the proof 
of Hurtado, Noy, and Urrutia~\cite{hurtado_noy_urrutia}: 
we observe that an anchored triangle at   and an anchored triangle 
at  can change their relative position 
along~ only if they have an edge in common and this edge is flipped.
This results in an overall number of  flips.
\qedopt
\end{proof}

\section{The Reduction}\label{sec_reduction}
We reduce YRSA to \textsc{PolyFlip}.
Let  be a set of~ sinks.
By Corollary~\ref{cor_blow_up}, we can assume that the coordinates of sinks of~ are multiples of a factor~ in .
Further, we can restrict ourselves to YRSA instances of the form .
Thus, we imagine that the sinks are embedded on a  grid.
The reasons for the choice of~ will become clear below.

We construct a polygon~ and two triangulations ,  in~ such that a shortest flip sequence from  to  corresponds to a shortest RSA for .
To this end, we will describe how to interpret any triangulation of~ as a \emph{chain path}, a path in the integer grid that starts at the root and uses only edges that go north or east.
It will turn out that flips in~ essentially correspond to moving the endpoint of the chain path along the grid.
We choose , , and  in such a way that a shortest flip sequence between  and  moves the endpoint of the chain path according to an Eulerian traversal of a shortest RSA for~.
To force the chain path to visit all sinks, we use the observations from Section~\ref{sec:double_chain}: the polygon  contains a double chain for each sink, so that only for certain triangulations of~ it is possible to flip the double chain quickly.
These triangulations will be exactly the triangulations that correspond to the chain path visiting
the appropriate sink.
To force the sinks to be visited, we, with foresight, fix the number of points in each of the two chains of a double chain representing a sink to  (recall that  is polynomial in~).

\subsection{The Construction}
\label{sec_construction}
\sloppypar{
We take a double chain~ with  vertices on each chain such that the flip-kernel of~ extends to the right of .
We add a point  to that part of the flip-kernel, and we let  be the polygon defined by , i.e., a double chain extended by~ (recall Definition~\ref{def_p_d_plus}).
}
Next, we add double chains to  in order to encode the sinks in .
For each sink , we remove the edge , and we replace it by a (rotated) double chain  with  vertices on each chain, such that  and  become the last point on the lower and the upper chain of , respectively.
We orient  in such a way that  is the only point inside the hourglass of  and so that  lies in the flip-kernel of ; see \figurename~\ref{fig_installing_sites}.
We refer to the added double chains as the \emph{sink gadgets}, and
we call the resulting polygon .
Since the -coordinates in~ are pairwise distinct, there is at most one sink gadget per edge of the lower chain of~.
Since , no two sink gadgets are placed on neighboring edges of~, and can be constructed such that they do not overlap.
Hence,  is a simple polygon.
The precise placement of the sink gadgets is flexible, so given an appropriate embedding of~, we can make all coordinates integers whose value is polynomial in the input size;
see Appendix~\ref{apx_coordinates} for details.

\begin{figure}
\centering
\includegraphics[width=\textwidth]{installing_sites}
\caption{
The sink gadget for a sink  is obtained by replacing the edge
 by a double chain with  vertices on
each chain. The double chain is oriented such that  is the
only point inside its hourglass and its flip-kernel. }
\label{fig_installing_sites}
\end{figure}

Next, we describe the source and target triangulation for .
In the source triangulation , the interior of~ is triangulated 
such that all edges are incident to~. 
The sink gadgets are all triangulated with the upper extreme triangulation.
The target triangulation  is similar, but now the sink gadgets 
are all triangulated with the lower extreme triangulation.


To get from  to , we must go from one extreme
triangulation to the other for each sink gadget . 
By Lemma~\ref{lem_empty_wedge},
this requires  flips, unless the flip sequence creates a
triangle that allows us to use the vertex in the flip-kernel of
. In this case, we say that the flip sequence \emph{visits}
the sink .
The main idea is that, since the value chosen for~ is large, a shortest flip sequence must visit all sinks, 
and we  will show that this induces an RSA for~ of comparable length.
Conversely, we will show how to derive a flip sequence from an 
RSA.
The precise statement is given in the following theorem.

\begin{theorem}\label{thm:YRSA<->FlipDist}
Let , and
set .
Let  be a set of  sinks such that
the coordinates of
the sinks are multiples of  in , where  is polynomially bounded in~.
Set  and let  be the simple polygon and  and 
the two triangulations of~ as described above.
Then for any , the flip distance between  and
 w.r.t.~ is at most  if and only
if
 has an RSA of length at most .
\end{theorem}

We will prove Theorem~\ref{thm:YRSA<->FlipDist} in the following
sections. But first, let us show how to use it for our NP-completeness
result.
\begin{theorem}
\textup{\textsc{PolyFlip}} is \textup{NP}-complete.
\end{theorem}
\begin{proof}
As mentioned in the introduction, the flip distance in polygons is
polynomially bounded, so \textsc{PolyFlip} is in NP. 
We reduce from YRSA.
Let  be an instance of YRSA as above. 
We construct  and ,  as described above.
This takes polynomial time (see Appendix~\ref{apx_coordinates} for details on the coordinate representation).
By Theorem~\ref{thm:YRSA<->FlipDist}, 
there exists an RSA for  of length at most~ if and only if there exists a flip sequence between  and  of length at most
. 
\qedopt
\end{proof}



\subsection{Chain Paths}
\label{sec:triangulation_structure}

Now we introduce the \emph{chain path}, our main tool to
establish a correspondence between flip sequences and RSAs.
Let  be a triangulation of~ (i.e., the polygon  
without the sink gadgets, cf. Section~\ref{sec_construction}).
A \emph{chain edge} is an edge of~ between the upper and the lower 
chain of~. 
A \emph{chain triangle} is a triangle of~ that contains two chain edges.
Let  be the chain edges, sorted from left to 
right according to their intersection with a line
that separates the upper from the lower chain.
For , write  and set .
In particular, .
Since  is a triangulation, any two consecutive edges ,  share one endpoint, while the other endpoints are adjacent on the corresponding chain.
Thus,  dominates  and .
It follows that  is an - and -monotone path, 
beginning at the root.
It is called the \emph{chain path} for .
Each vertex of the chain path corresponds to a chain edge, and each 
edge of the chain path corresponds to a chain triangle. Conversely,
every chain path induces a triangulation  of~;
see \figurename~\ref{fig_chain_path}.
In the following, we let  denote the upper right endpoint of the 
chain path.
\begin{figure}
\centering
\includegraphics{chain_path}
\caption{A triangulation of~ and its
chain path. Flipping edges to and from  moves the endpoint  along
the grid.
A flip between chain triangles changes a bend. 
}
\label{fig_chain_path}
\end{figure}
\ShoLong{}{We now investigate how flipping edges in~ affects the chain path.

\begin{observation}\label{obs_chain_path_monotone}
Suppose we flip an edge that is incident to~.
Then the chain path is extended by moving  north or east.\noproof
\end{observation}

\begin{observation}
Suppose that  contains at least one chain triangle.
When we flip the rightmost chain edge, we shorten the chain path at .\noproof
\end{observation}

Finally, we can flip an edge between two chain triangles.
This operation is called a \emph{chain~flip}.

\begin{observation}\label{lem_bend_chain_flip}
A chain flip changes a bend from east to north to a bend from north to east, or vice versa.
\end{observation}
\begin{proof}
If a chain edge  is incident to two chain triangles and is flippable, then the two triangles must be of the form  and
, or  and .
Thus, flipping  corresponds exactly to the claimed change in the chain path.
\qedopt
\end{proof}
}\ShoLong{}{\begin{corollary}
A chain flip does not change the length of the chain path.\noproof
\end{corollary}
}
\ShoLong{The next lemma describes how the chain path is affected by flips;
see Fig.~\ref{fig_chain_path}.
}
{We summarize the results of this section in the following lemma:
}
\begin{lemma}\label{lem:structure}
Any triangulation  of~ uniquely determines a chain path, and vice versa.
A flip in~ corresponds to one of the following operations on the chain path:
(i) move the endpoint  north or east;
(ii) shorten the path at ;
(iii) change an east-north bend to a north-east bend, or vice versa.\noproof
\end{lemma}

\subsection{From an RSA to a Short Flip Sequence}
Using the notion of a chain path, we now prove the
``if'' direction of Theorem~\ref{thm:YRSA<->FlipDist}.

\begin{lemma}\label{lem:YRTSP->flip_tour}
Let  and  an RSA for  of length .
Then the flip distance between  and  w.r.t.~ is at 
most .
\end{lemma}
\begin{proof}
The triangulations  and  both contain a triangulation of~ 
whose chain path has its endpoint   at the root.
We use Lemma~\ref{lem:structure} to generate flips inside  so
that  traverses  in a depth-first manner.
This needs  flips.

Each time  reaches a sink , we move  north.
This creates a chain triangle that allows the edges in
the sink gadget  to be flipped to the auxiliary vertex
in the flip-kernel of . The triangulation of  can then be changed
with  flips; see Lemma~\ref{lem_lower_bound}.
Next, we move  back south and continue the traversal.
Moving  at~ needs two additional flips, so we take  flips per sink,
for a total of  flips.
\qedopt
\end{proof}


\subsection{From a Short Flip Sequence to an RSA}
Finally, we consider the ``only if'' direction in Theorem~\ref{thm:YRSA<->FlipDist}.
Let  be a flip sequence on~.
We say that  \emph{visits} a sink  if  has at least one triangulation that contains the chain 
triangle .
We call  a \emph{flip traversal} for~ if (i)  begins and ends in the triangulation whose corresponding chain path has its endpoint~ at the root and (ii)  visits every sink in~.
The following lemma shows that every short flip sequence~ in~ can be mapped to a flip traversal (where with ``short'', we mean ).

\begin{lemma}\label{lem:flip_traversal}
Let  be a flip sequence from  to  w.r.t.~ 
with .
Then there is a flip traversal  for  
with .
\end{lemma}
\begin{proof}
We show how to obtain a flip traversal  for
 from~.
Let  be a triangulation of~.
A triangle of~ is an \emph{inner triangle} if all its sides are 
diagonals. 
It is an \emph{ear} if two of its sides are polygon edges.
By construction, every inner triangle of~ must have
(i) one vertex incident to  (the rightmost vertex of~), 
or (ii) two vertices incident to a sink gadget (or both).
There can be only one triangle of type (ii) per sink gadget.
The weak (graph theoretic) dual of~ is a tree 
in which ears correspond to leaves and inner triangles have degree .

For a sink~, let  be the corresponding sink gadget.
It lies between the vertices  and  and has exactly  in its flip kernel.
For brevity, we will write  for ,  for , and  for .
We define a triangle   for .
Consider the bottommost edge~ of~, and let  be the triangle of~ that is incident to .
By construction,  is either an ear of~, or it is the triangle defined by  and .
In the latter case, we set .
In the former case, we claim that  has an inner triangle  with two vertices on :
follow the path from  in the weak dual of~;
while the path does not encounter an inner triangle, the next triangle must have an edge of  as a side.
There is only a limited number of such edges, so eventually we must meet an inner triangle .
We then set ; see \figurename~\ref{fig_delta_s}.
Note that  might be .


\begin{figure}
\centering
\includegraphics{delta_s}
\caption{Triangulations of  in~ with  (left),
and with  being an ear (red) and  an inner triangle (right).
The fat tree indicates the dual.
}
\label{fig_delta_s}
\end{figure}

For each sink , let the polygon  consist of  extended by the vertex~ (cf.~Definition~\ref{def_p_d_plus}).
Let  be a triangulation of~.
We show how to map  to a triangulation  of~ and to triangulations  of , for each~.

We first describe .
It contains every triangle of~ with all three vertices in~.
For each triangle  in~ with two vertices on  and one vertex on the left chain of a sink gadget , we replace the vertex on  by~.
Similarly, if the third vertex of  is on the right chain of , we replace it by .
For every sink , the triangle  has one vertex at a point  of the upper chain.
In , we replace  by the triangle .
No two triangles in  overlap, and they cover all of~.
Thus,  is indeed a triangulation of~.

Now we describe how to obtain , for a sink .
Each triangle of~ with all vertices on  is also in~. 
Each triangle with two vertices on  and one vertex not in 
 is replaced in  by a triangle whose 
third vertex is moved to
 in  (note that this includes~);
see \figurename~\ref{fig_local_triangulations}. Again, all triangles
cover  and no two triangles overlap.

\begin{figure}
\centering
\includegraphics[width=\textwidth]{local_triangulations}
\caption{Obtaining  and  from .}
\label{fig_local_triangulations}
\end{figure}

Finally, we show that a flip in~ corresponds to at most one flip either in  or in precisely one  for some sink~.
We do this by considering all the possibilities for two triangles that share a common flippable edge.
By construction, no two triangles that are mapped to two different triangulations  and  for sinks  can share an edge.

\textbf{Case 1.}  We flip an edge between two triangles that are either both mapped to  or to  and are different from .
This flip clearly happens in at most one triangulation.

\textbf{Case 2.} We flip an edge between a triangle~ that is mapped to  and a triangle~ that is mapped to , such that both  and  are different from~.
This results in a triangle  that is incident to the same edge of  as , and a triangle~ having the same vertices of~
as~.
Since the apex of~ is a vertex of the upper chain or~
(otherwise, it would not share an edge with ), it is
mapped to , as is the apex of~.  Also, the apex of~ is on
the same chain of~ as the one of~.  Hence, the flip affects neither  nor~.

\textbf{Case 3.}
We flip the edge between a triangle  mapped to  and
.
By construction, this can only happen if  is an inner triangle.
The flip affects only , because the new inner triangle
 is mapped to the same triangle in  as , since both
apexes are moved to .

\textbf{Case 4.}
We flip the edge between a
triangle  of  and . Similar to Case~3, this
affects only , because the new
triangle~ is mapped to the same triangle in  as~, 
since the two corners are always
mapped to  and .

Thus,  induces a flip sequence
 in~ and flip sequences  in each 
so that .
Furthermore, each flip sequence  transforms 
from one extreme triangulation to the other.
Since , Lemma~\ref{lem_empty_wedge} tells us that the 
triangulations~ have to be transformed so that  has a vertex at  at some point. Moreover, by Lemma~\ref{lem_lower_bound}, we have
 for each .
Thus,  is a flip traversal,
and , as claimed.
\qedopt
\end{proof}

In order to obtain a static RSA from a changing flip traversal,
we use the notion of a \emph{trace}.
A \emph{trace} is a domain on the grid.
It consists  of \emph{edges} and \emph{boxes}: an edge is a line segment of 
length  whose endpoints have positive integer coordinates; a box is a 
square of side length~ whose corners have positive integer coordinates.
Similar to arborescences, we require that a trace  (i) is (topologically) 
connected; (ii) contains the root ; and (iii) from every grid point 
contained in~ there exists an - and -monotone path to the root 
that lies completely in~.
We say  is a \emph{covering trace} for~ (or,  \emph{covers} ) if every sink in~ is covered by~ (i.e., incident to a box or an edge in~).

Let  be a flip traversal as in Lemma~\ref{lem:flip_traversal}.
By Lemma~\ref{lem:structure}, each triangulation in~ 
corresponds to a chain path.
This gives a covering trace  for  in the following way.
For every flip in  that extends 
the chain path, we add the corresponding edge to .
For every flip in  that changes a bend, we add the corresponding 
box to . Afterwards, we remove from  all edges that coincide 
with a side of a box in~.
Clearly,  is (topologically) connected. Since  is a 
flip traversal for , every sink
is covered by~.
Note that every grid point  in~ is connected to the root by an 
- and -monotone path on , since at some point  belonged
to a chain path in~.
Hence,  is indeed a trace, the unique \emph{trace of~}.
Note that not only a flip traversal but any flip sequence starting with a zero-length chain path defines a trace in this way.

Next, we define the \emph{cost} of a trace , , so that 
if  is the trace of a flip traversal~, then  
gives a lower bound on . 
An edge has cost .
Let  be a box in~.
A \emph{boundary side} of~ is a side that is not part of another box.
The cost of~ is~ plus the number of boundary sides of~.
Then,  is the total cost over all boxes and edges in~.
For example, the cost of a tree is twice the number of its edges, and the cost of 
a rectangle is its area plus its perimeter.
An edge can be interpreted as a degenerated box, having two boundary 
sides and no interior.

\begin{proposition}\label{prp_cost}
Let  be a flip traversal and
 the trace of  . Then .
\end{proposition}
\begin{proof}
Let  be the sequence of the first  triangulations of~,  the trace defined by~, and let  be the length of the chain path for the th triangulation.
We will show by induction on  that , for .
Since , , and , this gives the desired result.

After the first flip,  is an edge (so ), and , which fulfills the invariant.
Consider the th flip.
If the flip extends the chain path, the cost of the trace increases by at most~2, and the length of the chain path increases by~1, fulfilling the invariant.
If the flip contracts the chain path, the trace does not change, but the length of the chain path is decreased by~1, again fulfilling the invariant.
We are therefore left with the case where the flip is a chain flip.
We have , so we have to show that .
We may assume that the flip adds a box~ to  (otherwise,
the cost of the trace remains unchanged).
Consider the intersection of the boundary of~ with the one of~.
This intersection contains at least two elements, as the chain path is part of~.
An edge in the intersection becomes a boundary side in~, reducing the cost by~.
A boundary side in the intersection vanishes in~, also reducing the cost by~.
Thus, adding  creates a box and at most two boundary sides, causing a cost 
of at most~3, but it simultaneously reduces the cost by at least~.
See the examples in \figurename~\ref{fig_boundary_cost}.
The overall cost increases at most by~, and the invariant is maintained.
\qedopt
\end{proof}

\begin{figure}[ht]
\centering
\includegraphics[scale=1.2]{boundary_cost}
\caption{Examples of how boundary sides (red) are added to a trace.
To a trace of cost 16 (a) a box (gray) is added (b), which transforms 
two edges in boundary sides and adds two boundary sides, resulting in 
an overall cost of 17.
The next box removes one boundary side and one edge and adds three 
boundary sides (c), the cost becomes 18.
A box might also remove more than two elements (d), reducing the overall 
cost to 17.
}
\label{fig_boundary_cost}
\end{figure}

Now we relate the length of an RSA for  to the cost of a covering trace for , and thus to the length of a flip traversal.
Since each sink is connected in~ to the root by an - and -monotone path, traces can be regarded as generalized RSAs.
In particular, we make the following observation.

\begin{observation}\label{obs_arborescence_in_trace}
Let  be a covering trace for  that contains no boxes, and
let  be a shortest path tree in~ from the root to
all sinks in~.
Then   is an RSA for~.\noproof
\end{observation}

If  contains no flips that change bends, the corresponding trace  has no boxes. 
Then,  contains an RSA  with , by Observation~\ref{obs_arborescence_in_trace}.
The next lemma shows that, due to the fact that~ is even, there is always a shortest covering trace for  that does not contain any boxes.

\begin{lemma}\label{lem:eliminate_chain_phase}
Let  be a flip traversal of~.
Then there exists a covering trace  for  
such that  does not contain a box and such that .
\end{lemma}
To prove the lemma, we investigate the structure of minimal covering traces.
There exists at least one trace of cost at most , namely the trace of .
Let  be the set of all covering traces for  that have minimum cost.
Let  be those covering traces among  that contain the  minimum number of boxes.
If  contains a trace without boxes, we are done, as every covering trace in  fulfills the requirements of Lemma~\ref{lem:eliminate_chain_phase}.
We show that this is actually the case by assuming, for the sake of contradiction, that every covering trace in  contains at least one box.

Let   and suppose that~ contains a box.
Let  be a \emph{maximal} box in~, i.e.,  has no other box whose lower left corner has 
both - and -coordinate at least as large as the lower left corner of~.
In order to prove Lemma~\ref{lem:eliminate_chain_phase}, we need several lemmata on traces of minimum cost.

\begin{figure}
\begin{center}
\includegraphics[width=\textwidth]{arborescence_ops}
\end{center}
\caption{
Parts of traces to be modified; the boundary sides are shown in red.
(a) A box that has a corner  with no incident elements can be removed.
(b) Two adjacent boxes that have a shared corner  without any incident elements can be removed.
(c) Replacing a single edge.
(d) Sliding an edge.
}
\label{fig:tree_operations}
\end{figure}


\begin{lemma}\label{lem:no_dangling_corner}
Let  be a maximal box and let  a corner of  that is not the root .
Then  is incident either to a sink, an edge, or another box.
\end{lemma}
\begin{proof}
Suppose there exists a corner~ for which this is not the case.
Note that such a~ cannot be the lower left corner of~, as there has to be an - and -monotone path to the root.
Hence, we could remove  and  while keeping the sides of~ not incident to~ as edges, if necessary;
see \figurename~\ref{fig:tree_operations}(a).
In the resulting structure, every element still has an - and -monotone path to the root:
If  is the lower right or upper left corner, any path initially passing through  could be rerouted to pass through the corner opposite of~ in~.
If  is the upper right corner of~, no path is passing through~.
Hence, the resulting structure would be a covering trace with smaller cost, contradicting the choice of~.
\qedopt
\end{proof}

\begin{lemma}\label{lem:no_double_box}
Suppose  shares a horizontal side with another box .
Let  be the right endpoint of the common side.
Then  is incident either to a sink, an edge, or another box.
\end{lemma}
\begin{proof}
Suppose this is not the case.
Then we could remove  and  from  while keeping the sides not incident to  as edges, if necessary; see \figurename~\ref{fig:tree_operations}(b).
This results in a valid trace that has no higher cost but less boxes than , contradicting the choice of~.
\qedopt
\end{proof}

\begin{lemma}\label{lem:no_vertical_edge}
Let  be the lower right corner of~.
Then  has no incident vertical edge.
\end{lemma}
\begin{proof}
Such an edge would be redundant, since  already has an - and -monotone path to the root that goes through the lower left corner of~.
\qedopt
\end{proof}

\begin{proof}[Proof of Lemma~\ref{lem:eliminate_chain_phase}]
Using the Lemmata~\ref{lem:no_dangling_corner}, \ref{lem:no_double_box}, and \ref{lem:no_vertical_edge}, we derive a contradiction from the choice of~ and the maximal box~.
Note that since  is even, all sinks in~ have even - and -coordinates.
We distinguish two cases.

\noindent\textbf{Case 1}.
There exists a maximal box  whose top right corner  does 
not have both coordinates even.
Suppose that the -coordinate of~ is odd. (Otherwise, 
mirror the plane at the line  to swap the - and the -axis.
Note that the property of being a trace is invariant under mirroring 
the plane along the line ;
in particular, the choice of~ in~ as a maximal box remains valid)
By Lemma~\ref{lem:no_dangling_corner},
there is at least one edge incident to the top right corner of~ 
(it cannot be a box by the choice of~, and it cannot be a sink 
because of the current case). 
Recall the slide operation for an edge in an arborescence. This operation 
can easily be adapted in an analogous way to traces.
If there is a vertical edge  incident to~, it cannot be incident
to a sink. Thus, we could slide  
to the right (together with all other 
vertical edges that are above  and on the supporting line of~).
Hence, we may assume that  is incident to a single horizontal edge~;
see \figurename~\ref{fig:tree_operations}(c).
By Lemma~\ref{lem:no_dangling_corner}, the bottom right corner  
of~ must be incident to an element.
We know that  cannot be the top right corner of another box 
(Lemma~\ref{lem:no_double_box}), nor can it be incident to a vertical
segment (Lemma~\ref{lem:no_vertical_edge}). Thus,  is incident to
an element~ that is either a horizontal edge or a box with top left corner~.
But then~ could be replaced by a vertical segment  incident to~,
and afterwards   could be removed as in the proof of
Lemma~\ref{lem:no_dangling_corner}, contradicting the choice of~.

\noindent\textbf{Case 2}.
The top right corner of each maximal box has even coordinates.
Let  be the rightmost maximal box.
As before, let  be the bottom right corner of~.
The -coordinate of~ is odd; see \figurename~\ref{fig:tree_operations}(d).
By the choice of~, we know that  is not the top left corner of another box: this would imply that there is another maximal box to the right of~.
We may assume that  is not incident to a horizontal edge, as we could slide such an edge up, as in Case 1.
Furthermore,  cannot be incident to a vertical edge (Lemma~\ref{lem:no_vertical_edge}), nor be the top right corner of another box (Lemma~\ref{lem:no_double_box}).
Thus,  violates Lemma~\ref{lem:no_dangling_corner}, and Case~2 also leads to a contradiction.

Thus, the choice of~ forces a contradiction in either case.
Hence, the minimum number of boxes in a minimum covering trace for~ is~.
\end{proof}

\noindent
Now we can finally complete the proof of Theorem~\ref{thm:YRSA<->FlipDist} by giving the second direction of the correspondence.

\begin{lemma}\label{lem:flip_tour->YRTSP}
Let  and
let  be a flip sequence on  from  to
 with .
Then there exists an RSA for~ of length at most~.
\end{lemma}
\begin{proof}
Trivially, there always exists an RSA on  of length less than , so we may assume that 
.  Hence (recall that  and ),
 
for  and positive~.
Thus,  meets the requirements of Lemma~\ref{lem:flip_traversal}, and therefore
we can obtain a flip traversal  for~ with .
By Lemma~\ref{lem:eliminate_chain_phase} and Observation~\ref{obs_arborescence_in_trace},
we can conclude that there is an RSA  for  
that has length at most . 
By Theorem~\ref{thm_slide}, there is an RSA~ for  that is not 
longer than  and that lies on 
the Hanan grid for . The length of  must be a multiple of~.
Thus, since , we get that  has length at most .
\qedopt
\end{proof}

\section{Conclusion}
In this paper, we showed NP-hardness of determining a shortest flip sequence between two triangulations of a simple polygon.
This complements the recent hardness results for point sets (obtained by reduction from variants of \textsc{Vertex Cover}).
However, while for point sets the problem is hard to approximate as well, our reduction does not rule out the existence of a polynomial-time approximation
scheme (PTAS), since a PTAS is known for the RSA problem~\cite{rsa_ptas}.
When problems that are hard for point sets are restricted to simple polygons, the application of standard techniques---like dynamic programming---often gives polynomial-time algorithms.
This is, for example, the case for the construction of the minimum weight triangulation.
Our result illustrates that determining the flip distance is a different, harder type of problem.
Is there a PTAS for the flip distance between triangulations of a polygon?
Even a constant-factor approximation would be interesting.

For convex polygons (or, equivalently, points in convex position), the complexity of the problem remains unknown.
Our construction heavily relies on the double chain construction, using many reflex vertices.
Does the problem remain hard if we restrict the number of reflex vertices to some constant fraction?


\bibliographystyle{spmpsci}
\bibliography{bibliography}

\newpage
\appendix


\section{A Note on Coordinate Representation}\label{apx_coordinates}
Since it is necessary for the validity of the proof that the input polygon can be represented in size polynomial in the size of the YRSA instance, we give a possible method to embed the polygon with vertices at rational coordinates whose numerator and denominator are polynomial in~.
By an additional perturbation argument we can guarantee integer coordinates whose values are polynomial in~ (which slightly strengthens the result).
We first introduce the general technique used for the embedding, and then give further details on how the sink gadgets are constructed (using methods similar to~\cite{point_set_hard}).
Finally, we explain how the construction can be transformed to integer points in general position.

\subsection{Placing Points on Arcs}

The main idea of the construction is to place all vertices on rational points on circular arcs.
There are two large arcs where we place the vertices of the upper and the lower chain, and smaller arcs on which we place the vertices of the sink gadgets.
All these circular arcs are chosen from \emph{rational circles}, i.e., circles that are defined by three rational points.
Similarly, a \emph{rational line} is a line trough a rational point with rational slope (or, equivalently, a line defined by two rational points).
It is well-known that, if one of the two intersection points of a rational line with a rational circle is a rational point, then the other intersection point is rational as well (see, e.g.,~\cite[p.~5]{husemoeller}).
Hence, given a rational point~ on a rational circle, we can obtain an arbitrary number of rational points on the circle via different rational lines through~.

Let us apply this for one possible way of constructing the double chain~.
The construction is shown in \figurename~\ref{fig_exact_construction}~(left).
We place the  points of the lower chain on the unit circle (with center at the origin).
Let  be the line through  with slope .
For , we get  rational points on the upper-left quadrant of the unit circle from the intersections with this family of lines.
We can do the analogous construction for points on the upper-right quadrant by choosing lines through  with a negative slope .
In this way, we obtain the vertices of the lower chain of~.
For the upper chain, we place points on the unit circle with origin  analogously.
Note that line  passes through , so when picking rational points on the lower-right and lower-left quadrant of the second unit circle for the upper chain, the resulting point set is indeed the vertex set of a double chain in which the line through  and  is~.
Finally, note that all slopes used in the construction have numerators and denominators that are polynomial in~.
Hence, this also holds for the coordinates of the vertices of~.
Note that this is, essentially, the parametrization of the unit circle, as discussed in~\cite{canny}.

\begin{figure}
\centering
\includegraphics{exact_construction}
\caption{Left: Construction of the main double chain~.
Right: Picking points on a circular arc inside a triangle. The line  is tangent to the corresponding circle.}
\label{fig_exact_construction}
\end{figure}


Clearly, this method is not restricted to unit circles.
We now discuss the following main building block for constructing the sink gadgets.
Given three rational points , we construct a circular arc on a rational circle that starts at , ends at  and is completely contained inside the triangle .
Then, we choose an arbitrary number of rational points on that circular arc.
This is illustrated in \figurename~\ref{fig_exact_construction}~(right).
W.l.o.g, let the inner angle of the triangle at  be less than or equal to the one at~.
Let  be the circle through  and  such that the line  is a tangent of~.
Clearly,  is well-defined, and the arc between  and  is inside the triangle.
The circle  is rational.
(Consider the line that is perpendicular to the line  and passes through~.
When mirroring  with that line as an axis, the resulting point  is rational and also on~.)
We can now choose any number of rational points on the circular arc by selecting a family of lines through .
To this end, we choose a set of equidistant points on the segment , which, together with  define this family of rational lines.
Again, the numerators and the denominators are polynomial in those of , , and~, and the number of points chosen.

\subsection{Constructing Sink Gadgets}
We now construct the sink gadgets.
See \figurename~\ref{fig_coordinates} for an accompanying illustration.
Recall that, since  is even, there are no small double chains on neighboring positions on the lower chain.
Hence, for each sink we w.l.o.g.\ can define an orthogonal region within which we can safely draw the small double chain; we call this region the \emph{bin} of the sink (outlined gray in \figurename~\ref{fig_coordinates}).
Consider a sink~.
The vertical line bounding the left side of its bin passes through the edge  (e.g., at the midpoint of the edge), and the right side of the bin is defined analogously.
(Recall that, since , there is no sink at .)
Pick a rational point  on the boundary of the bin that is to the left of the directed line  and to the right of the directed line~.
Similarly, choose a point  that is to the right of the line  and to the left of the line .
As an additional constraint let  be to the left of the line~.
Note that such points always exist, and can be easily chosen along the boundary of the bin.
It remains to choose a triangular region with  as one side in which we can place the chain of the sink gadget that contains~.
For the second chain, the construction is analogous.

For the chain to be visible from  but not from , the triangular region has to be to the left of the line , and also to the left of the line .
Further, to be visible from all vertices of the other chain, it has to be to the left of the lines  and .
Let  be the apex of the triangle that is defined by these constraints, and observe that  is the intersection of two of the four lines.
We can now add a chain of points on a circular arc inside the triangle , as described above.

\begin{figure}
\centering
\includegraphics{coordinates}
\caption{Construction of a small double chain for a sink.}
\label{fig_coordinates}
\end{figure}

The coordinates are rational, and since every point can be constructed using only a constant number of other points, the numerator and denominator of each point are polynomial.

\subsection{General Position and Integer Coordinates}
The ways in which a simple polygon can be triangulated is determined by the \emph{order type} of the vertices, i.e., the vector that indicates for
each triple of vertices whether it is oriented clockwise or counterclockwise.
Up to now, we did not care whether the point set is in general position, so there might also be collinear point triples among vertices that are not directly related in the reduction.
By simply multiplying all coordinates by all denominators used, we would obtain integer coordinates with exponential values.
To obtain integer coordinates bounded by a polynomial in the input size and a point set in general position, we can use the following lemma.\footnote{The exact time bounds shown in the proof are irrelevant for the NP-hardness reduction (which even requires a different model of computation).
We mention them only as they may be of general interest.}

\begin{lemma}\label{lem_integer_coordinates}
Let~ be a point set with rational coordinates whose numerators and denominators have absolute values of at most~.
Then there is a point set~ with integer coordinates bounded by~ and a bijection between  and  such that for every ordered triple of non-collinear points in~, the orientation of the corresponding triple in~ is the same.
In particular, if  is in general position, then  and  have the same order type.
Further,  can be constructed in  time.
\end{lemma}
\begin{proof}
Consider the set~ of lines that are defined by all pairs of points of~.
Choose  and  such that the horizontal distance  between  and  is minimal among all such distances (which is non-zero as  is not on ). Then  is rational, with numerator and denominator in~.
Further, our choice required .
When multiplying all -coordinates by , this distance is at least~.
The basic idea is to round the -coordinates.
The crucial observation is that  has a -coordinate that is between the ones of  and , as otherwise one of  and , say, , would be horizontally closer to the line through  and .
For an ordered triple of points to change its orientation (from, say, clockwise to counterclockwise), the horizontal distance between the point whose -coordinate is between those of the other two points would have to be reduced by more than~.
We can therefore safely round the -coordinates, which, in the worst case, reduces the horizontal distance between  and  by at most~.
Hence, for every non-collinear ordered triple of points in~, the orientation of the corresponding triple in the resulting point set is the same.
We repeat the process analogously for the -coordinates, obtaining~.

The horizontal or vertical distance  can easily be found by checking all triples of points.
We can improve this cubic time bound by considering the dual line arrangement~ of~ (in which a point  corresponds to the dual line ).
The dual arrangement can be constructed in quadratic time~\cite{power_of_duality,constructing_arrangements}.
The shortest vertical distance in the primal corresponds to the shortest vertical distance of a vertex and a side of a triangle defined by three dual lines.
Clearly, the shortest distance can only occur inside a triangle that is not intersected by another line.\footnote{Actually, any dual transform will do.
When thinking of the rounding process as a continuous transformation, a change of the order type would involve a collapsing triangular cell of the dual arrangement, indicating a ``close'' point triple.}
Hence, we only need to test the  triangular cells of~.
\end{proof}

Hence, if we construct the vertices with rational coordinates such that the vertices are in general position, we can apply Lemma~\ref{lem_integer_coordinates} to have all vertices on the integer grid in general position.

General position can easily be obtained by applying a simple technique used in~\cite[Appendix~A]{point_set_hard}.
Observe first that the vertices of  are in general position.
We take special care when placing the  points of each chain of a sink gadget to not produce collinear points.
Note that the final polygon  will have  vertices.
Instead of  points, we choose  \emph{candidate points} on the circular arc for the chain.
Consider any line through two already placed points.
This line intersects the circular arc in at most two points, so there are at most two candidate points that may not be points of the double chain because of that line.
As there are less than  such lines, there are always enough candidate points left for selecting the  points for the chain among them.
Thus, the vertices we obtain are in general position.


\end{document}
