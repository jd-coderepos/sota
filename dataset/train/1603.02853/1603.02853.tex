\documentclass[11pt, a4paper]{article}
\usepackage[centering]{geometry}
\usepackage[english]{babel}
\usepackage{amsmath,amsfonts,amssymb,graphicx,amsthm}

\usepackage[mathlines]{lineno}


\usepackage{makeidx}
\usepackage{cite}
\usepackage{chngcntr}

\graphicspath{{./fig/}}
\newcommand{\eps}{\varepsilon}
\newcommand{\N}{\mathbb{N}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\etal}{\emph{et al.}\xspace}

\usepackage[ruled,noend,linesnumbered,algosection]{algorithm2e}
\newenvironment{alg}{
  \begin{algorithm}[htbp]
    \DontPrintSemicolon
    \SetKwInput{KwIn}{input}
    \SetKwInput{KwOut}{output}
  }{\end{algorithm}}
   
\newtheorem{theorem1}{Theorem}{\bfseries}{\itshape}
\counterwithin{theorem1}{section}
\newtheorem{lem}[theorem1]{Lemma}{\bfseries}{\itshape}
\newtheorem{thm}[theorem1]{Theorem}{\bfseries}{\itshape}
\newtheorem{obs}[theorem1]{Observation}{\bfseries}{\itshape}
\newtheorem{cor}[theorem1]{Corollary}{\bfseries}{\itshape}


\title{A Time-Space Trade-off for Computing the -Visibility 
Region of a Point in a Polygon\footnote{
A preliminary version appeared as 
Y.~Bahoo, B.~Banyassady, P.~Bose, S.~Durocher, and 
W.~Mulzer. \emph{Time-Space Trade-off for Finding 
the -Visibility Region of a Point in a Polygon}. Proc.~11th WALCOM, 
2017.  This work was partially 
supported by DFG project MU/3501-2, ERC StG 757609, and by the 
Natural Sciences and Engineering Research Council of Canada (NSERC).}}

\author{Yeganeh Bahoo\thanks{Department of Computer Science,
        University of Manitoba, \{bahoo, durocher\}@cs.umanitoba.ca}
        \and
        Bahareh Banyassady\thanks{Institut f\"ur Informatik, Freie 
	Universit\"at Berlin,
        {\{bahareh, mulzer\}@inf.fu-berlin.de}}
        \and
        Prosenjit K. Bose\thanks{School of Computer Science,
        Carleton University, {jit@scs.carleton.ca}}
        \and 
        Stephane Durocher
        \and 
        Wolfgang Mulzer
        }
\date{}
\begin{document}
\maketitle

\begin{abstract}
Let  be a simple polygon with  vertices, and let 
 be a point in . Let . 
A point  is \emph{-visible} from  
if and only if the line segment  crosses the 
boundary of  at most  times. The \emph{-visibility 
region} of  in  is the set of all points that 
are -visible from .  We study the problem of 
computing the -visibility region in the 
limited workspace model, where the input resides 
in a random-access read-only memory of  words, 
each with  bits. The algorithm can read 
and write  additional words of workspace, 
where  is a parameter of the model. The 
output is written to a write-only stream. 

Given a simple polygon  with  vertices and 
a point , we present an
algorithm that reports the -visibility region 
of  in  in  
expected time using  words of workspace. 
Here,  is the number of 
\emph{critical vertices} of  for  where the 
-visibility region of  may change. We 
generalize this result for polygons with holes 
and for sets of non-crossing line segments.\\
\linebreak\textbf{Keywords:} Limited workspace model, 
-visibility region, 
Time-space trade-off
\end{abstract}

\section{Introduction}
Memory constraints on mobile devices and 
distributed sensors have led to an increasing 
focus on algorithms that use their memory 
efficiently. One common approach to capture 
this notion is the \emph{limited workspace model}~\cite{asano2013memory}. 
Here, the input is provided in a random-access read-only 
array of  words. Each word has 
 bits. Additionally, there is a 
read/write memory with  words, where 
 is a parameter of the model. 
This is called the \emph{workspace} of the 
algorithm. The output is written to a write-only 
stream. 

Let  be a simple polygon with  vertices and  edges,
and let  be a point in . Let
.
A point  is \emph{-visible} from  
if and only if the line segment  has at most 
 proper intersections with the boundary 
 of  ( and  do not count toward
the number of intersections).\footnote{For , the
whole polygon is -visible from , so there is no
reason to consider .} The set of -visible 
points in  from  is called the 
\emph{-visibility region} of  in ;
see Figure~\ref{fig:fig1}.
We denote it by . For , this 
notion corresponds to classic visibility in polygons. 

Visibility problems have played a major role 
in computational geometry since the very beginning
of the field. 
Thus, there is a rich history of previous results;
see the book by Ghosh~\cite{ghosh2007visibility} for 
an overview. The concept of -visibility first appeared 
in a work by Dean~\etal~\cite{dean1988recognizing} as far
back as 1988. In the related 
\emph{superman problem}~\cite{MouawadSh94}, we are
given two polygons  and  such that
, and a point . 
The goal is to find the minimum
number of edges in  that need to be made opaque in
order to make  invisible from . 
More general -visibility, for ,
is more recent. Since 2009, this variant of visibility has been
explored more widely due to its relevance in wireless networks. 
In particular, it 
models the coverage 
areas of wireless devices whose radio signals can penetrate 
up to  walls~\cite{aichholzer2009modem,fabila2009modem}. 
This makes the problem particularly interesting for the 
limited workspace model, since these wireless devices are typically 
equipped with only a small amount of memory for computational tasks 
and may need to determine their coverage region using the 
few resources at their disposal.

The notion of -visibility has previously been considered
in the context of art-gallery-style questions~\cite{ballinger2013coverage,eppstein2007guard,
fulek2009intersecting,
o2012computational} and in the definition
of certain geometric graphs~\cite{dean2005bar,
felsner2008parameters,hartke2007further}.
While the -visibility region is always connected,
the -visibility region may have several components.
Bajuelos~\etal~\cite{bajuelos2012hybrid} present an 
algorithm for a slightly different notion of 
-visibility. It computes the region of the \emph{plane} 
which is -visible from  in the presence of a 
simple polygon  with  vertices, using  
time and  space. In this setting, the 
-visibility region is connected. We believe that our 
ideas are also applicable for this notion and lead to an
improvement of their result.\footnote{The algorithm of 
Bajuelos~\etal~\cite{bajuelos2012hybrid} essentially first computes  
a complete arrangement of quadratic size that encodes the whole 
visibility information, and then extracts the -visible region from 
this arrangement. Our algorithms, on the other hand, use a 
plane sweep so that only the relevant parts of this arrangement are 
considered. Thus, when  words of workspace are available, 
we achieve a running time of .}

\paragraph{Related work.}
The optimal classic algorithm for computing the 
-visibility region needs  time and  
space~\cite{joe1987corrections}. In the 
\emph{constant-workspace model} (i.e., for ), the
-visibility region of a point  can
be reported in  time, where 
 is the number of \emph{reflex} vertices 
of  that occur in the output,
as shown by Barba~\etal~\cite{barba2014computing}.
This algorithm scans the boundary 
in counterclockwise order, and it reports the 
maximal subchains of  that are 
-visible from . More precisely, this 
works as follows: we find a vertex
 of  that is -visible 
from . Walking from , we 
then go until the next reflex vertex
 that is -visible from ,
in counterclockwise direction.
This takes  time. The first intersection 
of the ray  with  is 
called the \emph{shadow} of . 
Now, the end vertex of the maximal counterclockwise 
visible chain starting at  is either 
 or its shadow. In each case, 
the next maximal visible chain starts at the other
of the two vertices ( or its shadow). Thus, we  can
find a maximal visible chain and a new starting 
point in  time. 
The number of iterations is , the number 
of reflex vertices that are -visible from .
This gives an algorithm with  running 
time and  workspace. 

Now suppose that the number of reflex vertices in
 with respect to  is . If the 
available workspace is , for 
, Barba~\etal~\cite{barba2014computing} 
show how to find the -visibility region 
of  in  in  
deterministic time or  
expected time. Their method is recursive. 
It uses the previous algorithm as the base,
and in each step of the recursion, it splits a 
chain on  into two subchains that each 
contains roughly half of the visible reflex vertices 
of the original chain. Since the -visibility region 
and the -visibility region of  for  have 
different properties, there seems to be no 
straightforward way to generalize this approach
to our setting.
Later, Barba~\etal~\cite{barba2015space} provided
a general method for obtaining time-space trade-offs for
\emph{stack-based} algorithms. 
This gives an alternative trade-off for 
computing the -visibility region:
there is an algorithm that 
runs in  
time for  and 
in  time for .\footnote{The 
actual trade-off is more nuanced, 
but we simplified the bound to make it more digestible for the
casual reader.}
Again,
this approach does not seem to be directly applicable
to our setting.

Abrahamsen~\cite{Abrahamsen13} presents a constant workspace
algorithm that computes the visible part of one edge
from another edge in a simple polygon  in  time,
where  is the number of vertices in .
This gives an algorithm that needs  
time and  words of workspace to compute
the weak visibility region of one edge in .
The parameter  denotes the size of the resulting
weak visibility polygon.

\paragraph{Our Results.}
We look at the more general problem of 
computing the -visibility region of a simple 
polygon  for a given point .
We give a constant workspace algorithm for this
problem, and we establish a time-space trade-off. 
Our first algorithm runs in  time
using  words of space, and our second 
algorithm requires  
expected time and  words of workspace. 
Here,  is the number of 
\emph{critical vertices} of  for , where the 
-visibility region of  may change. A precise
definition is given later. 

We generalize this result for polygons with holes 
and for sets of non-crossing line segments.
More precisely, we show that in a polygon 
with  holes, we can report the -visibility
region of a point  in expected time 

using  words of workspace. In an
arrangement of  pairwise non-crossing line
segments, this takes  
deterministic time.

\section{Preliminaries and Definitions}

Let  be the amount of available workspace,
measured in words.
We assume that the input polygon  is given 
as a sequence of  vertices in counterclockwise (CCW) 
order along .
The input also contains the query point  and
the visibility parameter . The aim is to 
report , using  words 
of workspace. We require that the input is in \emph{weak 
general position}, i.e., the query point  does not lie on any 
line through two distinct vertices of . Without loss of generality, 
we assume that  is even: if  is odd, we 
can just compute , which is the same as
, by definition. The boundary  of 
 consists of pieces of  and chords 
of  that connect two such pieces; see Figure~\ref{fig:fig1}.

\begin{figure}
 \centering 
 \includegraphics{1}
\caption{An example with . 
The hatched regions are not -visible for .
The vertices  are critical for .
More precisely,  are 
start vertices, and  
are end vertices.  is 
partitioned into  disjoint chains, e.g, 
the counterclockwise chain .}
\label{fig:fig1}
\end{figure}


We fix a coordinate system with origin .
For , we denote by  the ray 
that emanates from  and has CCW-angle  with the 
-axis. An edge of  that intersects  is called 
an \emph{intersecting edge} of . The \emph{edge list} 
of  is defined as the list of intersecting edges of 
, sorted according to their intersection with ,
in increasing distance from . The  element of this 
list is denoted by . We also say that  has
\emph{rank}  in the edge list of , or simply on .

The \emph{angle} of a vertex  of 
refers to the angle  at which 
 encounters . Suppose  stabs a vertex  of .
We call  a \emph{critical}
vertex if its incident edges lie on the same side of , and
a \emph{non-critical} vertex otherwise. 
We can check in constant time whether a given vertex of  is 
critical. We use  to denote the number of 
critical vertices in . Let  be a critical 
vertex. We call  a 
\emph{start vertex} if both incident edges lie counterclockwise
of , and an \emph{end vertex} otherwise; see 
Figure~\ref{fig:fig1}.
A \emph{chain} is a sequence of edges of  
(in CW or CCW order along ) which starts at a start vertex
and ends at an end vertex and contains no other
critical vertices. Note that every ray  
intersects each chain at most once. Thus, we will sometimes
talk of \emph{chains} that appear in the edge list of 
a ray .

Suppose we continuously increase  from  to .
The edge list of  only changes when  
encounters a vertex  of . This change only involves 
the two edges incident to .
At a non-critical vertex , the edge list is updated by
replacing one incident edge of  with the other. The other edges and
their order in the edge list do not change.
At a critical vertex , the edge list is updated by
adding or removing both incident edges of , depending
on whether  is a start vertex or an end vertex. The other edges 
and their order in the edge list are not affected; see 
Figure~\ref{fig:fig1}. 
If  stabs a start vertex of , we define the edge list 
of  to be the edge list of , for a 
small enough . 
If  stabs an end vertex or a non-critical vertex of , 
we define the edge list 
of  to be the edge list of , for a 
small enough .

For any ,
only the first  elements 
in the edge list of  are -visible from  in
direction . While increasing , as
long as  does not encounter a 
critical vertex, the -visible chains in direction  do not change.
However, if  encounters a critical vertex , then 
this may affect which chains are visible from .
This happens if at least one of the incident edges to  is among the 
first  elements in the edge list of . 
In other words, if  is -visible from , which means that  
does not lie after  on . 
The next lemma shows that in this case a segment on  may 
occur on . 

\begin{lem}\label{lem:window}
Let  such that 
 stabs a -visible end or start vertex . Then, the 
segment on  between  and 
 is an edge of ,
provided that these two edges exist.
\end{lem}
\begin{proof}
Suppose that  is a -visible end vertex. 
As mentioned above, right after  encounters
, two consecutive edges are removed from the
edge list of .
Since  is -visible, these edges are among
the first  entries in the edge list.
Thus, right after , the -visibility region of  extends
to  (recall that the indices refer to
the situation just before ). Before , the
-visibility region extends to .
This means that the segment between  and 
on  belongs to 
. In particular, this includes the case that
 and  are incident to .
The situation for a -visible start vertex  is symmetric. 
Note that in this case, the indices in the edge list refer 
to the situation just after ; see Figure~\ref{fig:fig2}.
\end{proof}

\begin{figure}
 \centering 
 \includegraphics{2}
\caption{An example with . 
The hatched regions are not 4-visible for .
(a) The ray  encounters the end vertex .
The -visibility region of  right before 
extends to  and right after  extends to .
(b) The ray  encounters the start vertex .
The -visibility region of  right before 
extends to  and right after  extends to .
The segment  in both figures is the window of .}
\label{fig:fig2}
\end{figure}


Lemma~\ref{lem:window} leads to the following definition: 
let  such that
 stabs a -visible end or start
vertex . The segment on  between 
 and 
, if these edges exist, is called the \emph{window} 
of ; see Figure~\ref{fig:fig2}.

\begin{obs}\label{obs:complexity}
The -visibility region  has  vertices.
\end{obs}
\begin{proof}
The boundary  consists of subchains  
of  and of windows. Thus, a vertex of  is 
either a vertex of  or an endpoint of a window. Since each 
critical vertex causes at most one window, since each
window has two endpoints, and since there are at most  critical 
vertices, the total number of 
vertices of  is .
\end{proof}
\section{A Constant-Memory Algorithm}\label{sec:constant-memory algorithm}

First, we assume that a constant amount of workspace is 
available. 
If the input polygon  has no critical vertex, there 
is no window, and . This can be checked
in  time by a simple scan through the input.
Thus, we assume that 
 has at least one critical vertex . 
Again,  can be found in  time with a single scan.
We choose our coordinate system such that
 is the origin and such that  lies on the positive -axis.
We number the critical vertices of  as  in the order that the ray 
encounters them. Let  be the angle for .
We simplify our notation and write  instead
of , and we let  denote the 
 entry in the edge list of the ray . 

We start with the ray , and we find 
the edge  in  time using  words of workspace. 
For this, we perform a simple \emph{selection} subroutine as follows:
we scan the input  times, and in each pass, we find
the next intersecting edge of  until 
. If  is -visible, i.e., if it is not after  
 on , we report the window of 
, as given by Lemma~\ref{lem:window} (if it exists). 
Since the window is defined by  and , 
it can be found in two more scans over the input.

Next, we find  by a single scan of .
Then, we determine . 
This can be done in  time 
by using  as a starting point: we know that 
if  is an end
vertex, the two incident chains of  disappear
in the edge list of . If  is a start
vertex, the two incident chains of  appear 
in the edge list of .
All other chains are not affected, and they intersect  and 
 in the same order. 
Using this, we first find the edge  that has
rank  in the edge list of the ray  just after
. Depending on the type and position of ,
 is either  or , and it can
be found in  time. Then,
by scanning  starting from , we can
find the edge  on the chain of  that intersects
the ray  just before , again
in  time. Depending on the type and position of , 
the edge  is either  or . 
Thus, we can find  using  in  time; 
see Figure~\ref{fig:fig3}.

\begin{figure}
 \centering 
 \includegraphics{3}
\caption{Two cases for going from  to , with
. 
(a) Both  and  are end vertices. We
use  to find  and follow the chain until
.
(b) Both  and  are start vertices.
We follow the chain of  until , and
then use it to find .
We report the window from  to .}
\label{fig:fig3}
\end{figure}


If  is -visible, we report the window of 
 in  time, as described above.
Finally, we
report the subchains of  between  
and  by scanning . More precisely, 
we walk along  in counterclockwise direction.
Whenever we enter the counterclockwise cone between  and ,
we check whether the intersection between  and
 or  occurs at or before  or , respectively.
If so, we report the subchain of  until
we leave the cone again.

We repeat this procedure until all critical vertices 
have been processed; see Algorithm~\ref{alg:pseudocode1}. 
Here and in the following algorithms, if there are 
less than  intersecting edges on , we store the 
last intersecting edge together with its rank.
We use this edge instead of
, in the procedure above, to find  or the
last intersecting edge of  and its rank.
The number of 
critical vertices is . For each of them, we spend
 time. Additionally, the selection subroutine for 
 takes  time. 
This leads to the following theorem:

\begin{alg}
 \KwIn{Simple polygon , point , }
 \KwOut{The boundary of the -visibility region of  in ,
 }
 \If { has no critical vertex}{
    return \;
 }
  a critical vertex of \;
 Find  using selection\;
 \; 
 \Repeat{}{
 	\If { lies on or before  on }{
 		Report the window of  (if it exists)\;
 	}
 	 the next counterclockwise critical vertex after 
	\;
 	Find  using \;
 	Report the part of  between  and \;
 	
 	}	
 \caption{The constant workspace algorithm for computing
}\label{alg:pseudocode1}
\end{alg}


\begin{thm}\label{thm:constant-memory}
Given a simple polygon  with  vertices, a 
point , and a parameter , 
we can
report the -visibility region of  in  in  time using  
words of workspace, where  is the number of critical vertices of .
\end{thm}
\section{Time-Space Trade-Offs}

In this section, we assume that we have  words of workspace 
at our disposal, and we show how to exploit this additional 
workspace to compute the -visibility region faster. We describe 
two algorithms. The first algorithm is a little simpler, and it is meant to 
illustrate the main idea behind the trade-off. Our main contribution 
is in the second algorithm, which is more complicated but achieves 
a better running time. In the first algorithm, we process the 
vertices in angular order in contiguous batches of size . In each 
iteration, we find the next batch of  vertices, and using the 
edge list of the last processed vertex, we construct a data 
structure that is used to output the windows of the batch. Using the 
windows, we report  between the first and the last 
ray of the batch.\footnote{We emphasize that 
is not necessarily reported in order, but we ensure that the union 
of the reported line segments constitutes the boundary of the
-visibility region.
}
In the second algorithm, we improve the running time by skipping the 
non-critical vertices. Specifically, in each iteration, we find the 
next batch of  adjacent critical vertices, and as before, we 
construct a data structure for finding the windows. We need a more 
involved approach in order to maintain this data structure. 
The next lemma shows how to obtain the contiguous batches of 
vertices in angular order efficiently.  The procedure is taken  
from the work of Chan and Chen~\cite{chan2007multi} (see the second 
paragraph in the proof of Theorem 2.1 in~\cite{chan2007multi}).

\begin{lem}\label{lem:s-smallest}
Suppose we are given a read-only array  with  pairwise distinct 
elements from a totally ordered universe and an element . For 
any given parameter , there is an 
algorithm that runs in  time and uses  words of workspace 
and that finds the set of the first  elements in  that follow 
 in the sorted order. 
\end{lem}

\begin{proof}
Let  be the subsequence of  that contains exactly the 
elements in  that are larger than .
The algorithm makes a single pass over  and processes the 
elements in batches.
In the first step, we insert the first  elements of  
into our workspace (without sorting them). We select the median 
of these  elements using  time and space, and we remove 
the elements which are larger than the median. In the next step, we 
insert the next batch of  elements from  into the 
workspace, and we again find the median of the resulting  
elements and remove those elements that are larger than the median. 
We repeat the latter step until all the elements of  have 
been processed. Clearly, at the end of each step, the  smallest 
elements of  that we have seen so far reside in memory. 
Since the number of steps is  and since each step needs 
 time, the running time of the 
algorithm is . By construction, it uses  words 
of workspace.
\end{proof}

\begin{lem}\label{lem:k-selection}
Suppose we are given a read-only array  with  elements from 
a totally ordered universe and a number . 
For any given parameter , there is an 
algorithm that runs in  time and uses 
 words of workspace and that finds the  smallest 
element in .
\end{lem}
\begin{proof}
We  again process the elements of  in batches.
In the first step, we apply Lemma~\ref{lem:s-smallest} to find the 
first batch with the  smallest elements in  and to put it into 
our workspace. This needs  time and  words of workspace. 
If , we select the  smallest element in the 
workspace in  time; otherwise, we find the largest element  
in the workspace, and we apply Lemma~\ref{lem:s-smallest} to find 
the set of  elements following . In step , we apply 
Lemma~\ref{lem:s-smallest} to find
the  batch of  elements 
in the sorted order of  and to insert this set of elements into the workspace. 
If , we select the  smallest 
element in the workspace in  time and we output it; otherwise, 
we find the largest element in the workspace and we continue. 
The element being sought is in the  
batch. Therefore, we can find it in 
 time using  words of workspace.
\end{proof}

In addition to the simple algorithm in Lemma~\ref{lem:k-selection}, 
there are several other results on selection in the read-only model; 
see Table~1 of \cite{chan2014selection}. In particular, there is a
 expected time randomized algorithm for 
selection using  words of workspace in the 
limited workspace model~\cite{chan2010comparison,munro1996selection}. 
Depending 
on , , and , we will choose the latter algorithm or 
the algorithm that we presented in Lemma~\ref{lem:k-selection}. 
In conclusion, the running time of selection in the 
limited workspace model using  words of workspace, 
denoted by , is 
 expected time. 

\subsection{First Algorithm: Processing All the Vertices}\label{sec:algo1}

Let  be some vertex of . 
We choose our coordinate system such that
 is the origin and such that  lies on the positive -axis.
We apply Lemma~\ref{lem:s-smallest} to find the batch of  
vertices with the smallest positive angles, and we 
sort them in workspace in  time. Let  
denote these vertices in sorted order. We use the 
selection subroutine (with  words of workspace) to find 
 on , and if  is a -visible vertex, i.e., if 
it does not occur after  on , we report
its window (if it exists).  Recall that if there are less than 
intersecting edges on , we store the last intersecting edge 
together with its rank.

Then, we apply Lemma~\ref{lem:s-smallest} four times in order to find 
the at most  intersecting edges with ranks in 
 on 
(Lemma~\ref{lem:s-smallest} can be applied, because we have 
 at hand). We insert these edges 
into a balanced binary search tree , sorted according to 
their ranks on . The edges in  are candidates for having 
rank  on the next  rays . This is because,
as we explained in Section~\ref{sec:constant-memory algorithm}, 
if  belongs to the edge list of , there is at 
most one edge between  and  in the edge 
list of .
Therefore, if  appears in the edge list of , 
there are at most  edges between  and
 in the edge list of . 

Now the algorithm proceeds as follows: we go to the next vertex 
, and we update  depending on the types of  and  
: if  is a non-critical vertex, we may need to exchange one 
incident edge of  with another in ; if  is an end vertex, 
we may need to remove its incident edges from ; and if 
 is a start vertex, we may need to 
insert its incident edges into .
In all other case, no action is necessary.
The insertion and/or deletion is performed only for the edges
whose ranks are between the smallest and the 
largest rank in  (with respect to ). The update of   
takes  time. Afterwards, we can find  and the 
window of  (if it exists) in  time, using the position 
of  or its neighbors in , as explained in 
Section~\ref{sec:constant-memory algorithm}.
See Figure~\ref{fig:fig4} for an example.

\begin{figure}
 \centering 
 \includegraphics{4}
\caption{The first batch  of  vertices 
  in angular order. The edge  is the second neighbor to the 
  right of  on , because  is an end vertex. 
  The edge  is the second neighbor to the left of  
  which is inserted in  before processing . 
  The edge  is exchanged with , after processing 
  , because  is a non-critical vertex.}
\label{fig:fig4}
\end{figure}


We repeat this procedure for . We use, for 
, the binary search tree  and the previous edge 
 in order to determine the next edge  and 
the window of . This takes   total time. 
Whenever we find and report a window, we insert its endpoints into 
a balanced binary search tree . This takes  time 
per window. The endpoints in  are sorted according to 
their counterclockwise order along . For reporting 
the part of  between  and , we use 
 and the sequence 
of edges of rank . 

For an edge  of , the 
\emph{-segment} of  is the subsegment of  that lies between
 and . If a -segment does not contain an endpoint 
of a window, then it is either completely -visible or completely 
not -visible. 
Thus, we can walk along  and, simultaneously, along the 
window endpoints in . For each edge  of , we 
can check if the endpoints of the -segment of  are -visible
or not. We can do this in  time using . With the help 
of the parallel traversal of , we can also check 
if there is a window endpoint on . This takes  
time, where  is the number of window endpoints on . With 
this information, we can report the -visible subsegments of 
the -segment of . Since there are  window 
endpoints by Observation~\ref{obs:complexity},
and since we check each window endpoint once,
it follows that we need  time
to report the -visible part of  between  and 
.

After processing , we apply 
Lemma~\ref{lem:s-smallest} to find the next batch of  
vertices following  in angular order. We sort them in 
 time, using  words of workspace. The search tree 
 for the previous
batch is not useful anymore, because it does not necessarily contain 
any right or left neighbor of  on . Applying 
Lemma~\ref{lem:s-smallest} four times as before, we find the at most 
 intersecting edges with ranks in 
on , and we insert them into . 
Then, as before, for each , we find  and 
its corresponding window while maintaining , , and . 
After that, we report the -visible part of  between
 and , where  is the ray for the last vertex 
in the batch, in sorted order. If  is not divisible by ,
the last batch wraps around, taking the indices modulo , 
but we report only the part of  before ; 
see Algorithm~\ref{pseudocode2}. 

\begin{alg}
 \KwIn{Simple polygon , point , , }
 \KwOut{The boundary of -visibility region of  in , 
   }
  a vertex of \;
  (using the selection subroutine with  workspace)\;
 ,  an empty balanced binary search tree\;
 \;
 \Repeat{}{
 	 sorted list of  vertices following   in angular order \;
 	\;
 	\For { to }{
 		\If { lies on or before  on }{
 			Report the window of  (if it exists) \;
			Insert the endpoints of the window into  (according to their 
              position on )\;
		}
		Update  according to the types of  and \;
 		 (find it using  and )\;
	}
	Report the part of  between  and  (using  and )\;
 	\;
 }	
 
 \caption{Computing  using  words of workspace}\label{pseudocode2}
\end{alg}


Overall, we need  time for a batch. 
We repeat this procedure for  iterations, until all 
vertices are processed. 
Moreover, we run the selection subroutine in the first batch. 
Thus, the running time of the algorithm is 
. Since  
is dominated by the other terms, we obtain the following theorem.

\begin{thm}\label{thm:limited-workspace}
Let .
Given a simple polygon  with  vertices in a read-only array, 
a point  and a parameter , we
can report the -visibility region of  in  in 
 time using  words of workspace.
\end{thm}
\subsection{Second Algorithm: Processing only the Critical Vertices}
\label{algo2}

As in Section~\ref{sec:algo1}, we process the vertices in 
batches, but now we focus only on the critical vertices.
The new algorithm is similar to the algorithm in
Section~\ref{sec:algo1}, but it handles 
the data structure for the intersecting edges differently. In each 
iteration, we find the next batch of  \emph{critical} vertices,
and we sort them in  time using  words of 
workspace. As in the previous algorithm, we construct a data structure 
 that contains the possible candidates for the edges of rank 
 on the rays for the  critical vertices of the batch. 
In each step, we process the next critical vertex. We use  
to find the corresponding window, and we update .
For updating , we consider only the changes in the edge list
that are caused by the critical vertices. This is because
the non-critical vertices do not change the chains that appear in the 
edge list of the ray; they only affect the actual edge that intersects
it.\footnote{The algorithm in the published version of this
article is slightly different and relies on an
additional data structure  to update .
Unfortunately, our running time analysis of this update strategy
was not correct. To fix this, we changed the update strategy
to the lazy method described here.}

More precisely, we use a \emph{lazy} strategy for updating :
instead of always maintaining the edges that intersect the current ray, we
only store some edge on their corresponding chains, and we determine
the precise intersecting edges only when the need arises; see below, 
and Figure~\ref{fig:fig5} for an illustration.
After finding all the windows of the batch, we report 
the -visible part of  between the first and the last 
ray of the batch.

As in Section~\ref{sec:constant-memory algorithm}, if  has 
no critical vertex, then . This can be checked
in  time by a simple scan through the input.
Thus, we let  be some critical vertex, and 
we choose our coordinate system such that
 is the origin and such that  lies on the positive -axis.
In the first iteration, we compute , 
the list of  critical vertices after , sorted in angular 
order. Using Lemma~\ref{lem:s-smallest} and a traditional sorting 
algorithm, this takes  time and  words of 
workspace.

Then, we process one critical vertex in each step.
In step~, we find  using our selection subroutine, and 
the at most  intersecting edges with rank in 
 on . We insert them into a balanced 
binary search tree , ordered according to their rank on . 
This takes  time.
We use  and  to find and report the window of  
(if it exists).

\begin{figure}
 \centering 
 \includegraphics{5}
\caption{The first batch  of  critical vertices 
  in angular order. The edge  intersects only  and .
  However, it is in the edge list of  as a representative for .
  Similarly,  is a representative for  in the edge list 
  of .}
\label{fig:fig5}
\end{figure}


In step~, 
we update  according to the types of  
and  , so that  contains representatives for 
the chains that intersect : if 
 is an end vertex, and if its incident edges are in ,
we remove those edges from ;
if  is a start vertex, we insert the two incident edges
of  
(as representatives of the corresponding chains)
into , provided that their ranks on  
are in the correct rank interval for the edges in .
For finding the rank of the incident edges of  on , we 
perform a 
search in  to compare the positions of these edges and the
elements of  on .
Whenever a comparison needs to be 
done with an edge  stored in , we check whether 
intersects . If not, we follow the corresponding chain of 
until we find such an edge.
Thus, it takes  time to update , where
 denotes the number of non-critical vertices that are traversed
to find the correct edges for comparisons during the update
operations. 

Now,  contains 
at most  intersecting chains of . To determine  
, we walk along the chain of either  
or its neighbors in , until we meet the edge that 
intersects .
Having  and , we find and report
the window of  (if it exists), again using our lazy strategy.
Finding  and the window of 
takes  time, where  is the number of non-critical
vertices that are traversed during the search. 

In step , we repeat the same procedure
as in step . We update  for the edges that are incident
to the critical vertices  
and . The only difference is that, if  is an end vertex,
checking whether its chains are in , and identifying
their representative edge in , are not as straightforward as in step~.
The problem is that we do not know which edge of each
chain has been stored in  as its representative. To resolve this problem,
for any chain  in , we additionally store another edge of 
that is called the \emph{guide edge} and that is defined as follows:
if  intersects , the edge on  that intersects 
is a \emph{type~} guide edge;
and if  has been inserted into  in one of the
steps~, the first edge of  is a \emph{type~} guide edge.

We store the type~ guide edges in an array , sorted according
to their rank on , i.e., we copy the sorted elements of  in step~ 
into .
The type~ guide edges are stored in another array ,
sorted according to the step in which they have been inserted into , 
i.e., the angle of the start vertex of the chain.
Therefore, in each step that new edges are inserted into , 
those edges will also be added to  in  time.
The keys for the elements in  will be the corresponding rays
. (since
both arrays have length , we can reserve memory for them
in advance.
The elements in  and  have 
cross-pointers to their corresponding entries in .

To find the corresponding elements of the chains of an end vertex
 in , we walk backward on each chain, until
we either encounter an edge that intersects  (a type~1 guide edge),
or the first edge of that chain (a type 2~guide edge). 
Then, by a binary search in  or  in  time,
and using the cross-pointer to the elements in , we identify 
the corresponding entries in .
Therefore, we can remove them from  in  time.
Now,  contains the chain list of  and can be used
to find  with the help of . Finally, we
report the window of  (if it exists), as in step .
In total, processing the changes in  for a batch 
takes  time, where 
 is the number of non-critical vertices that lie between 
 and .

While processing the batch, we insert all , 
, into . Also, whenever we find and report 
a window, we insert its endpoints, sorted according to their 
counterclockwise order along , into a balanced binary search 
tree , in  time. After processing all the vertices 
of the batch, we use  and  to report the part of 
 between  and , as in 
Section~\ref{sec:algo1}. The only difference is that now we 
keep track of the visibility of the whole chains between  and 
instead of individual edges. As before, this takes  time.

In the subsequent iteration, we repeat the same procedure for the next 
batch of  critical vertices. We repeat until all critical 
vertices are processed; see Algorithm~\ref{alg:pseudocode3}.
By construction, each non-critical vertex 
is handled in exactly one iteration. Since there 
are  iterations, updating  
takes  time in total. All together, we get a 
total running time of , in addition to 
 in the first batch. This leads to the 
following theorem:

\begin{thm}\label{thm:improved-limited-workspace}
Let .
Given a simple polygon  with  vertices in a read-only array, 
a point  and a parameter , we can 
report the -visibility region of  in  in 
 
expected time using  words of workspace, 
where  is the number of critical vertices of  for .
\end{thm}

\begin{alg}
 \KwIn{Simple polygon , point , , }
 \KwOut{The boundary of -visibility region of  in , }
  a critical vertex of \;
  (using the selection subroutine with  workspace)\;
 ,  an empty balanced binary search tree\; 
 \;
 \;
 \Repeat{}{
 	 sorted list of  critical 
	vertices following   in angular order \;
  	\;
     the sorted elements of \;
 	\For { to }{
 		\If { lies on or before  on }{
 			Report the window of  (if it exists) \;
			Insert the endpoints of the window into  (sorted by position on )\;
		}
		\If { is an end vertex}{
			Find the guide edges of chains of  (by walking along the chains)\;
			\If{the guide edges exist in  or }{
				Use their cross-pointers to find the corresponding elements in \;
			Remove those corresponding elements from 
			}
		}
		\If { is a start vertex}{
			\Repeat{rank of the chains of  on  are determined}{
				Take the next edge  along the 
				search path in \;
				\If { does not intersect }{
					Walk along the chain of  until
					the edge  that intersects \;
					Exchange  with  in \;
				}
				Compare the position of  with  on \;
			}
			\If {the rank of the chains of  are valid for }{
				Insert the chains of  into  according to their rank on \;
				Append the chains of  to \;
			}
		}
	Find  by walking along  or its neighbors in \;
	Append  to \;	
	}
	Report subchains of  between  and  (using  and )\;
 	\;
 }	 
 \caption{Computing  using  words of workspace}\label{alg:pseudocode3}
\end{alg}
\section{Variants and Extensions}

Our results can be extended in several ways; for example, computing 
the -visibility region of a point  inside a polygon , where 
 may have holes, or computing the -visibility region of a 
point  in a planar arrangement of  non-crossing segments 
inside a bounding box (the bounding box is only for bounding the 
-visibility region). Concerning the first extension, all the properties
we showed to hold for the algorithms for simple polygons
also hold for the case with holes. The only noteworthy 
issue is the use of  to 
report the -visible segments of . In the case of 
polygons with holes, after walking on the outer part of 
, we walk on the boundaries of the holes one by one and 
we apply the same procedures for them. If there is no window on the 
boundary of a hole, then it is either completely -visible or 
completely non--visible. For such a hole, we check if it is 
-visible and, if so, we report it completely. 
This leads to the following corollary:

\begin{cor}\label{cor:polygon with holes}
Let .
Given a polygon  with  holes and  vertices in a 
read-only array, a point  and a parameter 
, we can report the -visibility region of  in  in  
 
expected time using  words of workspace. Here,  is the 
number of critical vertices of  for the point .
\end{cor}

Concerning the second problem, for a planar arrangement of  non-crossing 
segments inside a bounding box, the output consists of the 
-visible parts of the segments. All the segments endpoints 
are critical vertices and should be processed. In the parts of the 
algorithm where a walk on the boundary is needed, a sequential scan 
of the input leads to similar results. Similarly, there may be some 
segments with no window endpoints. For these, we only need to check 
visibility of an endpoint to decide whether they are completely 
-visible or completely non--visible. 
This leads to the following corollary:

\begin{cor}\label{cor:segments}
Let .
Given a set  of  non-crossing planar segments in a read-only 
array that lie in a bounding box , a point  and a 
parameter , there is an algorithm that 
reports the -visible subsets of segments in  from  in
 time using  words of workspace.
\end{cor}

\section{Conclusion}
We have proposed algorithms for a class of -visibility problems 
in the limited workspace model, and we have provided time-space 
trade-offs for these problems. We leave it as an open question 
whether the presented algorithms are optimal. Also, it 
would be interesting to see whether there exists an output sensitive 
algorithm whose running time depends on the number of windows in 
the -visibility region, instead of the critical vertices in the input polygon.

Finally, our ideas are also applicable to the slightly
different definition of -visibility used by Bajuelos et 
al.~\cite{bajuelos2012hybrid}. Thus, our techniques can be used to 
improve their result, achieving  running time if 
 words of workspace are available.

\bibliographystyle{abbrv}
\bibliography{ref}

\end{document}
