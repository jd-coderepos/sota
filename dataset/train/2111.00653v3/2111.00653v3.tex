\documentclass{article}

\PassOptionsToPackage{numbers}{natbib}





\usepackage[final]{neurips_2021}



\usepackage[utf8]{inputenc} \usepackage[T1]{fontenc}    \usepackage{hyperref}       \usepackage{url}            \usepackage{booktabs}       \usepackage{amsfonts}       \usepackage{nicefrac}       \usepackage{microtype}      \usepackage{xcolor}         

\usepackage{color}
\usepackage{multirow}
\usepackage{caption}
\usepackage{graphicx, subfigure}
\usepackage{amsmath}
\usepackage{bm}
\usepackage{booktabs}
\newcommand\BibTeX{B\textsc{ib}\TeX}
\usepackage{wrapfig}

\title{SADGA: Structure-Aware Dual Graph Aggregation Network for Text-to-SQL}

\author{ 
\textbf{Ruichu Cai}, 
\textbf{Jinjie Yuan}, 
\textbf{Boyan Xu}\thanks{Corresponding author} , 
\textbf{Zhifeng Hao} \\
 School of Computer Science, Guangdong University of Technology, Guangzhou, China\\
 Peng Cheng Laboratory, Shenzhen, China\\
 College of Science, Shantou University, Shantou, China\\
\texttt{cairuichu@gdut.edu.cn, yuanjinjie0320@gmail.com}\\
\texttt{hpakyim@gmail.com, zfhao@gdut.edu.cn}
}

\begin{document}

\maketitle

\begin{abstract}
The Text-to-SQL task, aiming to translate the natural language of the questions into SQL queries, has drawn much attention recently.  One of the most challenging problems of Text-to-SQL is how to generalize the trained model to the unseen database schemas, also known as the cross-domain Text-to-SQL task. The key lies in the generalizability of (i) the encoding method to model the question and the database schema and (ii) the question-schema linking method to learn the mapping between words in the question and tables/columns in the database schema. Focusing on the above two key issues, we propose a \emph{Structure-Aware Dual Graph Aggregation Network} (SADGA) for cross-domain Text-to-SQL. In SADGA, we adopt the graph structure to provide a unified encoding model for both the natural language question and database schema. Based on the proposed unified modeling, we further devise a structure-aware aggregation method to learn the mapping between the question-graph and schema-graph. The structure-aware aggregation method is featured with \emph{Global Graph Linking}, \emph{Local Graph Linking} and \emph{Dual-Graph Aggregation Mechanism}. 
We not only study the performance of our proposal empirically but also achieved 3rd place on the challenging Text-to-SQL benchmark Spider at the time of writing.
\end{abstract}

\section{Introduction}
\label{introduction}
Structured Query Language (SQL) has become the standard database query language for a long time, but the difficulty of writing still hinders the non-professional user from using SQL. The Text-to-SQL task tries to alleviate the hinders by automatically generating the SQL query from the natural language question. With the development of deep learning technologies, Text-to-SQL has achieved great progress recently \citep{cai2017encoder, hwang2019comprehensive, yu2018typesql, xu2017sqlnet}.

Many existing Text-to-SQL approaches have been proposed for particular domains, which means that both training and inference phases are under the same database schema. However, it is hard for database developers to build the Text-to-SQL model for each specific database from scratch because of the high annotation cost. Therefore, cross-domain Text-to-SQL, aiming to generalize the trained model to the unseen database schema, is proposed as a more promising solution \citep{guo2019towards, bogin2019representing, bogin2019global, wang2020rat, chen2021shadowgnn, rubin2021smbop, lin2020bridging, cao-etal-2021-lgesql}. The core issue of cross-domain Text-to-SQL lies in building the linking between the natural language question and database schema, well-known as the question-schema linking problem \citep{guo2019towards, wang2020rat, lin2020bridging, lei2020re, yu2021grappa}.

\begin{figure*}[!t]
  \centering
  \includegraphics[width=\textwidth]{figures/intro_case.pdf} 
  \caption{
  A toy example.
  The left part is about some existing approaches, e.g., IRNet \citep{guo2019towards}, RATSQL \citep{wang2020rat}, which usually treat the question as a sequence and apply the string matching method or attention mechanism to build the question-schema linking, causing that word ``age'' has a strong linking with both column ``age'' of table ``Student'' and column ``age'' of table ``Professor'' \textbf{(the red arrow)}. 
  The right part is about our SADGA. We treat both the question and schema as the graph structure to eliminate the structure gap during linking, and use SADGA to explore the local structure to help build the linking, successfully removing the candidate linking between word ``age'' and column ``age'' of table ``Professor'' \textbf{(the green arrow)}.
  } 
  \label{intro_case}
\end{figure*}

There are two categories of efforts to solve the aforementioned question-schema linking problem --- matching-based method \citep{guo2019towards} and learning-based method \citep{wang2020rat, lin2020bridging, lei2020re, cao-etal-2021-lgesql}. IRNet \citep{guo2019towards} is a typical matching-based method, which uses a simple yet effective string matching approach to link question words and tables/columns in the schema. RATSQL \citep{wang2020rat} is a typical learning-based method, which applies a relation-aware transformer to globally learn the linking over the question and schema with predefined relations. However, both of the above two categories of methods still suffer from the problem of insufficient generalization ability. There are two main reasons for the above problem: 
first, the structure gap between the encoding process of the question and database schema: as shown in Figure \ref{intro_case}, most of the existing approaches treat the question as a sequence and learn the representation of the question by sequential encoders \citep{guo2019towards, bogin2019representing, bogin2019global} or transformers \citep{wang2020rat, xu2021optimizing, lin2020bridging}, while the database schema is the structured data whose representation is learned based on graph encoders \citep{cao-etal-2021-lgesql, bogin2019representing, bogin2019global} or transformers with predefined relations \citep{wang2020rat, xu2021optimizing}. Such the structure gap leads to difficulty in adapting the trained model to the unseen schema.
Second, highly relying on predefined linking maybe result in unsuitable linking or the latent linking to be undetectable. Recalling the example in Figure \ref{intro_case}, some existing works highly rely on the predefined relations or self-supervised learning on question-schema linking, causing the wrong strong linking between word ``age'' and column ``age'' of table ``Professor'' while based on the semantics of the question, word ``age'' should be only linked to the table ``Student''.
Regarding the latent association, it refers to the fact that some tables/columns do not attend exactly in the question while they are strongly associated with the question, which is difficult to be identified. Such undetected latent association also leads to the low generalization ability of the model.

Aiming to alleviate these above limitations, we propose a Structure-Aware Dual Graph Aggregation Network (SADGA) for cross-domain Text-to-SQL to fully take advantage of the structural information of both the question and schema. We adopt a unified graph neural network encoder to model both the natural language question and schema. On the question-schema linking across question-graph and schema-graph, SADGA is featured with \emph{Global Graph Linking}, \emph{Local Graph Linking} and \emph{Dual-Graph Aggregation Mechanism}. In the \emph{Global Graph Linking} phase, the query nodes on question-graph or schema-graph calculate the attention with the key nodes of the other graph. In the \emph{Local Graph Linking} phase, the query nodes will calculate the attention with neighbor nodes of each key node across the dual graph. In the \emph{Dual-Graph Aggregation mechanism}, the above two-phase linking processes are aggregated in a gated-based mechanism to obtain a unified structured representation of nodes in question-graph and schema-graph. 
The contributions are summarized as follows:

\begin{itemize}
 \item We propose a unified dual graph framework SADGA to interactively encode and aggregate structural information of the question and schema in cross-domain Text-to-SQL.
 \item In SADGA, the structure-aware dual graph aggregation is featured with \emph{Global Graph Linking}, \emph{Local Graph Linking} and \emph{Dual-Graph Aggregation Mechanism}.
 \item We conduct extensive experiments to study the effectiveness of SADGA. Especially, SADGA outperforms the baseline methods and achieves 3rd place on the challenging Text-to-SQL benchmark Spider \footnote {\url{https://yale-lily.github.io/spider}} \citep{yu2018spider} at the time of writing. Our implementation will be open-sourced at \url{https://github.com/DMIRLAB-Group/SADGA}.
\end{itemize}


\section{Model Overview}
We provide the overview of our proposed overall model in Figure~\ref{model_overview}. As shown in the figure, our model follows the typical encoder-decoder framework.
There are two components of the encoder, Structure-Aware Dual Graph Aggregation Network (SADGA) and Relation-Aware Transformer (RAT) \citep{wang2020rat}. 

The proposed SADGA consists of dual-graph construction, dual-graph encoding and structure-aware aggregation. In the workflow of SADGA, we first construct the question-graph based on the contextual structure and dependency structure of the question, and build the schema-graph based on database-specific relations. Second, a graph neural network is employed to encode the question-graph and schema-graph separately. Third, the structure-aware aggregation method learns the alignment across the dual graph through two-stages linking, and the information is aggregated in a gated-based mechanism to obtain a unified representation of each node in the dual graph.

\begin{figure*}[!thb]
  \centering
  \includegraphics[width=\textwidth]{figures/model_overview.pdf} 
  \caption{
  The overview of the proposed model.
  } 
  \label{model_overview}
\end{figure*}

RAT \citep{wang2020rat} tries to further unify the representations learned by our SADGA by encoding the question words and tables/columns with the help of predefined relations. RAT is an extension of Transformer \citep{vaswani2017attention}, which introduces prior knowledge relations to the self-attention mechanism (see Appendix~\ref{app_relation_aware_transformer}). Different from the work of \citet{wang2020rat} with more than 50 predefined relations, the RAT of our work only uses 14 predefined relations, the same as those used by SADGA (Section~\ref{dual_graph_construction}). The small number of predefined relations also ensures the generalization ability of our method.

In the decoder, we follow the tree-structured architecture of \citet{yin2017syntactic}, which transforms the SQL query to an abstract syntax tree in depth-first traversal order. First, we apply an LSTM \citep{hochreiter1997long} to output a sequence of actions that generates the abstract syntax tree; then, the abstract syntax tree is transformed to the sequential SQL query. These LSTM output actions are either schema-independent (the grammar rule) or schema-specific (table/column). Readers can refer to Appendix~\ref{app_decoder_details} for details.

\section{Structure-Aware Dual Graph Aggregation Network}
In this section, we will delve into the Structure-Aware Dual Graph Aggregation Network (SADGA), including Dual-Graph Construction, Dual-Graph Encoding and Structure-Aware Aggregation.
The aggregation method consists of \emph{Global Graph Linking}, \emph{Local Graph Linking} and \emph{Dual-Graph Aggregation Mechanism}. These three steps introduce the global and local structure information on question-schema linking. The details of each component are as follows. 

\subsection{Dual-Graph Construction}
\label{dual_graph_construction}
In SADGA, we adopt a unified dual-graph structure to model the question, schema and predefined linkings between question words and tables/columns in the schema. The details of the generation of question-graph, schema-graph and predefined cross-graph relations are as follows.

\paragraph{Question-Graph} A question-graph can be represented by , where the node set  represents the words in the question and the set  represents the dependencies among words. As shown on the left side of Figure~\ref{graph_construction}, there are three different types of links, 1-order word distance dependency (i.e., two adjacent words have this relation), 2-order word distance dependency, and the parsing-based dependency.
The parsing-based dependency is to capture the specific grammatical relationships among words in the natural language question, such as the clausal modifier of noun relationship in the left side of Figure~\ref{graph_construction}, which is constructed by applying Stanford CoreNLP toolkit \citep{manning2014stanford}.

\paragraph{Schema-Graph} Similarly, a schema-graph can be represented by , where the node set  represents the tables/columns in the database schema and the edge set  represents the structural relations among tables/columns in the schema. We use some typical database-specific relations, such as the primary-foreign key for column-column pairs. The right side of Figure~\ref{graph_construction} shows an example of a schema-graph, where we focus only on the linking from the column ``professor\_id''.

\begin{figure*}[!thb]
  \centering
  \includegraphics[width=\textwidth]{figures/graph_construction.pdf} 
  \caption{
  The construction of Question-Graph and Schema-Graph.
  } 
  \label{graph_construction}
\end{figure*}

\paragraph{Cross-Graph} We also introduce cross-graph relations to capture the connection between question-graph and schema-graph. There are two main rules to generate relations, exact string match and partial string match, which are borrowed from RATSQL \citep{wang2020rat}. We use these two rules for word-table and word-column pairs to build relations. Besides, for word-column pairs, we also use the value match relation, which means if the question presents a value word in the database column, there is the value match relation between the value word and the corresponding column.
Note that these cross-graph relations are used only in Structure-Aware Aggregation (Section \ref{structure_aware_aggregation}).

Moreover, all predefined relations in dual-graph construction are undirected. These relations are described in detail in Appendix~\ref{app_relations_of_dual_graph_construction}.

\subsection{Dual-Graph Encoding}
\label{dual_graph_encoding}
After the question-graph and schema-graph are constructed, we employ a Gated Graph Neural Network (GGNN) \citep{li2015gated} to encode the node representation of the dual graph by performing message propagation among the self-structure before building the linking across the dual graph. The details of the GGNN we apply are presented in Appendix~\ref{app_gated_graph_neural_network}. Inspired by \citet{beck2018graph}, instead of representing multiple relations on edges, we represent the predefined relations of question-graph and schema-graph on nodes to reduce trainable parameters. Concretely, if node A and node B have a relation R, we introduce an extra node R into the graph and link R to both A and B using undirected edges. There is no linking across the dual graph in this phase. Each relation node is initialized to the learnable vector of the corresponding relation. In addition, we define three basic edge types for GGNN updating, i.e., bidirectional and self-loop.

\subsection{Structure-Aware Aggregation}
\label{structure_aware_aggregation}
\begin{figure}
  \centering                
  \includegraphics[width=\textwidth]{figures/graph_aggregation.pdf} 
  \caption{The Structure-Aware Aggregation procedure.
  We show the case when the 1st node in the query-graph acts as the query node. The query node attends to the key node and the neighbor nodes of the key node.} 
  \label{graph_aggregation_figure}
\end{figure}

Following with dual-graph encoding, we devise a structure-aware aggregation method on question-schema linking between question-graph  and schema-graph . The aggregation process is formulated as


As shown in Eq.~\ref{eq_ga}, the structure-aware aggregation method is applied to aggregate information from schema-graph  and question-graph  to the other graph, respectively. We illustrate the detailed approach in the manner of query-graph  and key-graph , i.e., 


Let  be a set of node embedding in the query-graph  and  be a set of node embedding in the key-graph  , which both learned by dual-graph encoding.
Figure~\ref{graph_aggregation_figure} shows the whole procedure of the structure-aware aggregation method regarding how the information from the key-graph is utilized to update the query-graph at the global and local structure level. First, we use global-average pooling on the node embedding  of query-graph  to get the global query-graph embedding . Then, in order to capture globally relevant information, the key node embedding  is updated as follows:

where , ,  are trainable parameters and  is a sigmoid function.
 represents the relevance score between the -th key node and the global query-graph. The above aggregation process is inspired by \citet{zhang2020comprehensive}. Our proposed structure-aware aggregation method further introduces the global and local structural information through three primary phases, including \emph{Global Graph Linking}, \emph{Local Graph Linking} and \emph{Dual-Graph Aggregation Mechanism}.

\paragraph{Global Graph Linking}
\emph{Global Graph Linking} is to learn the linking between each query node and the global structure of the key-graph. Inspired by the relation-aware attention \citep{wang2020rat}, we calculate the global attention score  between query node embedding  and key node embedding  as follows:

where  is a nonlinear activation function and  is the learned feature to represent the predefined cross-graph relation between -th query node and -th key node. 
The cross-graph relations have already been introduced in Cross-Graph of Section~\ref{dual_graph_construction}.

\paragraph{Local Graph Linking}
\emph{Local Graph Linking} is designed to introduce local structure information on dual graph linking. In this phase, the query node calculates the attention with neighbor nodes of the key node across the dual graph. Specifically, we calculate the local attention score  between -th query node and -th neighbor node of -th key node, formulated as


where  represents the neighbors of the -th key node. 

\paragraph{Dual-Graph Aggregation Mechanism}
\emph{Global Graph Linking} and \emph{Local Graph Linking} phase process are aggregated with \emph{Dual-Graph Aggregation Mechanism} to obtain the unified structured representation of each node in the query-graph.
First, we aggregate the neighbor information with the local attention scores , and then apply a gate function to extract essential features among the key node self and the neighbor information. The process is formulated as

where  represents the neighbor context vector and  indicates the -th key node neighbor-aware feature toward -th query node. 
Finally, each query node aggregates the structure-aware information from all key nodes with the global attention score :

where  indicates how much information the query node should receive from the key-graph.
Consequently, we obtain the final query node representation  with the structure-aware information of the key-graph.

\section{Experiments}
In this section, we conduct experiments on the Spider dataset \citep{yu2018spider}, the benchmark of cross-domain Text-to-SQL, to evaluate the effectiveness of our model.

\subsection{Experiment Setup}

\paragraph{Dataset and Metrics}
The Spider has been so far the most challenging benchmark on cross-domain Text-to-SQL, which contains 9 traditional specific-domain datasets, such as ATIS \citep{dahl1994expanding}, GeoQuery \citep{zelle1996learning}, WikiSQL \citep{zhongSeq2SQL2017}, IMDB \citep{yaghmazadeh2017sqlizer} etc. It is split into the train set (8659 examples), development set (1034 examples) and test set (2147 examples), which are respectively distributed across 146, 20 and 40 databases. Since the fair competition, the Spider official has not released the test set for evaluation. Instead, participants must submit the model to obtain the test accuracy for the official non-released test set through the submission scripts provided officially by \citet{yu2018spider}.\footnote {Only submit up to two models per submission (at least two months before the next submission).}

\begin{table*}[hbt]
    \caption{Accuracy results on the Spider development set and test set.}
    \label{accuracy} 
    \renewcommand\arraystretch{1.1}
    \footnotesize
    \centering
    \begin{tabular}{lcc|lcc}
        \toprule
        \textbf{Approach} & \textbf{Dev} & \textbf{Test} & \textbf{Approach} & \textbf{Dev} & \textbf{Test} \\ 
        \hline\hline 
        GNN \citep{bogin2019representing}                            & 40.7                          & 39.4          
        & RATSQL-HPFT + BERT-large                                   & 69.3                          & 64.4          \\
        
        Global-GNN \citep{bogin2019global}                           & 52.7                          & 47.4          
        & YCSQL  + BERT-large                                        & -                             & 65.3          \\
        
        IRNet v2 \citep{guo2019towards}                              & 55.4                          & 48.5          
        & DuoRAT  + BERT-large \citep{scholak2021duorat}             & 69.4                          & 65.4        \\
        
        RATSQL \citep{wang2020rat}                                  & 62.7                          & 57.2          
        & RATSQL + BERT-large \citep{wang2020rat}                   & 69.7                          & 65.6          \\
        
        \textbf{SADGA}                                                & \textbf{64.7}                 & -             
        & \textbf{SADGA + BERT-large}                                 & \textbf{71.6}                 & \textbf{66.7}             \\
        \hline\hline     
        EditSQL + BERT-base \citep{zhang2019editing}                 & 57.6                          & 53.4          
        & ShadowGNN + RoBERTa \citep{chen2021shadowgnn}              & 72.3                          & 66.1          \\   
        
        GNN + Bertrand-DR \citep{kelkar2020bertrand}                 & 57.9                          & 54.6          
        & RATSQL + STRUG \citep{deng2021structure}                  & 72.6                          & 68.4          \\
        
        IRNet v2 + BERT-base \citep{guo2019towards}                  & 63.9                          & 55.0          
        & RATSQL + GraPPa \citep{yu2021grappa}                      & \textbf{73.4}                 & 69.6          \\
        
        RATSQL + BERT-base \citep{wang2020rat}                      & 65.8                          & -             
        & RATSQL + GAP \citep{shi2021learning}                      & 71.8                          & 69.7          \\
        
        \textbf{SADGA + BERT-base}                                    & \textbf{69.0}                 & -             
        & \textbf{SADGA + GAP}                                        & 73.1                          & \textbf{70.1}           \\
        \bottomrule
    \end{tabular}
\end{table*}

\paragraph{Embedding Initialization}
The pre-trained methods initialize the input embedding of question words and tables/columns. Specifically, in terms of the pre-trained vector, GloVe \citep{pennington2014glove} is a common choice for the embedding initialization. And regarding the pre-trained language model (PLM), BERT \citep{devlin2018bert} is also the mainstream embedding initialization method. In detail, BERT-base, BERT-large are applied according to the model scale. Additionally, the specific-domain pre-trained language models, e.g., GAP \citep{shi2021learning}, GraPPa \citep{yu2021grappa}, STRUG \citep{deng2021structure} are also applied for better taking advantage of prior Text-to-SQL knowledge. Due to the limited resources, we conducted experiments with four pre-trained methods, GloVe, BERT-base, BERT-large and GAP, to understand the significance of SADGA.

\begin{wraptable}{r}{.5\textwidth}
    \setlength\tabcolsep{2pt}
    \caption{The \textbf{BERT-large} accuracy results on Spider development set and test set compared to RATSQL by hardness levels defined by \citet{yu2018spider}.}
    \label{result_levs} 
    \renewcommand\arraystretch{1.1}
    \centering
    \footnotesize
    \begin{tabular}{lccccc}
        \toprule
        \textbf{Model}                              & \textbf{Easy}         & \textbf{Medium}      & \textbf{Hard}        & \textbf{Extra Hard}   & \textbf{All}                   \\ 
        \hline\hline
        \emph{Dev:} \\
        \quad RATSQL                     & 86.4            & \textbf{73.6}  & 62.1           & 42.9           & 69.7                     \\
        \quad \textbf{SADGA}              & \textbf{90.3}         & 72.4                 & \textbf{63.8}        & \textbf{49.4}         & \textbf{71.6}                      \\
        \emph{Test:} \\
        \quad RATSQL                     & 83.0            & 71.3  & \textbf{58.3}           & 38.4           & 65.6                     \\
        \quad \textbf{SADGA}              & \textbf{85.1}         & \textbf{72.1}                 & 57.0        & \textbf{41.7}         & \textbf{66.7}                      \\
        \bottomrule 
    \end{tabular}
\end{wraptable}

\paragraph{Implementation}
We trained our models on one server with a single NVIDIA GTX 3090 GPU. We follow the original hyperparameters of RATSQL \citep{wang2020rat} that uses batch size 20, initial learning rate , max steps 40,000 and the Adam optimizer \citep{kingma2014adam}. For BERT, the initial learning rate is adjusted to , and the max training step is increased to 90,000.  We also apply a separate learning rate of  to fine-tune BERT. For GAP, we follow the original settings in \citet{shi2021learning}. In addition, we stack \textbf{3}-layer SADGA followed by \textbf{4}-layer RAT. More details about the hyperparameters are included in Appendix~\ref{app_hyperparameters}.

\subsection{Overall Performance}
The exact match accuracy results are presented in Table~\ref{accuracy}. 
Almost all results of the baselines are obtained from the official leaderboard. Except, RATSQL \citep{wang2020rat} does not provide BERT-base as PLM results on the development set, we have experimented with official implementation. As shown as the table, the proposed SADGA model is competitive with the baselines in the identical sub-table. Specifically, regarding the development set, our raw SADGA, SADGA + BERT-base, SADGA + BERT-large and SADGA + GAP all outperform their corresponding baselines. And with the GAP enhancement, our model is competitive with RATSQL + GraPPa as well. While regarding the test set, our models, only available for the BERT-large one and the GAP one, also surpass their competitors. At the time of writing, our best model SADGA + GAP achieved 3rd on the overall leaderboard. Note that our focus lies in developing an efficient base model but not a specific solution for the Spider dataset.

To better demonstrate the effectiveness, our SADGA is evaluated on the development set and test set compared with RATSQL according to the parsing difficulty level defined by \citet{yu2018spider}.
In the Spider dataset, the samples are divided into four difficulty groups based on the number of components selections and conditions of the target SQL queries. As shown in Table~\ref{result_levs}, our SADGA outperforms the baseline on the \textbf{Extra-Hard} level by 6.5\% and 3.3\% on the development set and test set, respectively, which implies that our model can handle more complicated SQL parsing. This is most likely due to the fact that SADGA adopts a unified dual graph modeling method to consider both the global and local structure of the question and schema, which is more efficient for capturing the complex semantics of questions and building more exactly linkings in hard cases. 
The result also indicates that SADGA and RATSQL achieved the best of \textbf{Medium} and \textbf{Hard} on the test set, respectively, but in the development set it is switched. It is an interesting finding that SADGA and RATSQL are adversarial and preferential in \textbf{Medium} and \textbf{Hard} levels data. After the statistics, we found that the distribution of data in the \textbf{Medium} and \textbf{Hard} levels changed from the development set to the test set (\textbf{Medium} 43.1\% to 39.9\%, \textbf{Hard} 16.8\% to 21.5\%), which is one of the reasons. And another reason we guess is that the target queries for these two types of data are relatively close to each other. Both \textbf{Medium} and \textbf{Hard} levels are mostly the join queries, but the \textbf{Extra-Hard} level is mostly nested queries.

\subsection{Ablation Studies}

\begin{table*}[hbt]
    \setlength\tabcolsep{2pt}
    \caption{Accuracy of ablation studies on the Spider development set by hardness levels.}
    \label{ablation_studies_result} 
    \renewcommand\arraystretch{1.1}
    \centering
    \footnotesize
    \begin{tabular}{lccccc}
        \toprule
        \textbf{Model}                                                                      & \textbf{Easy}         & \textbf{Medium}       & \textbf{Hard}        & \textbf{Extra Hard}   & \textbf{All}\\ 
        \hline\hline
        \textbf{SADGA}                                                                      & \textbf{82.3}         & \textbf{67.3}         & \textbf{54.0}        & \textbf{42.8}          &\textbf{64.7}\\
        \quad w/o Local Graph Linking                                                       & 83.5(+1.2)            & 64.8(-2.5)            & 53.4(-0.6)           & 38.6(-4.2)             & 63.2(-1.5)\\
        \quad w/o Structure-Aware Aggregation                                               & 83.5(+1.2)            & 62.1(-5.2)            & 55.2(+1.2)           & 42.2(-0.6)             & 62.9(-1.8)\\
        \quad w/o                        & 83.1(+0.8)            & 64.1(-3.2)            & 52.3(-1.7)           & 40.4(-2.4)             & 62.9(-1.8)\\
        \quad w/o                        & 79.0(-3.3)            & 63.7(-3.6)            & 50.0(-4.0)           & 41.6(-1.2)             & 61.5(-3.2)\\
        \quad Q-S Linking via Dual-Graph Encoding                                           & 82.3(-0)              & 63.7(-3.6)            & 51.1(-2.9)           & 45.2(+2.4)             & 63.1(-1.6)\\
        \quad w/o Relation Node (replace with edge types)                                   & 79.4(-2.9)            & 63.5(-3.8)            & 54.6(+0.6)           & 40.4(-2.4)             & 62.1(-2.6)\\
        \quad w/o Global Pooling (Eq.~\ref{global_updated_1} and Eq.~\ref{global_updated_2})& 82.7(+0.4)            & 64.3(-3.0)            & 54.0(-0)             & 41.6(-1.2)             & 63.5(-1.2)\\
        \quad w/o Aggregation Gate (Eq.~\ref{eq_n_5}, )             & 81.9(-0.4)            & 60.1(-7.2)            & 54.6(+0.6)           & 40.4(-2.4)             & 61.2(-3.5)\\
        \quad w/o Relation Feature in Aggregation                & 79.4(-2.9)            & 64.3(-3.0)            & 54.6(+0.6)           & 41.6(-1.2)             & 62.7(-2.0)\\
        \hline\hline      
        \textbf{SADGA + BERT-base}                                                          & \textbf{85.9}         & \textbf{71.7}         & \textbf{58.0}        & \textbf{47.6}          &\textbf{69.0}\\
        \quad w/o Local Graph Linking                                                       & 85.5(-0.4)            & 69.5(-2.2)            & 54.0(-4.0)           & 42.8(-4.8)             & 66.4(-2.6)\\
        \quad w/o Structure-Aware Aggregation                                               & 85.9(-0)              & 68.8(-2.9)            & 57.5(-0.5)           & 41.0(-6.6)             & 66.5(-2.5)\\
        \bottomrule 
    \end{tabular}
\end{table*}

To validate the effectiveness of each component of SADGA, ablation studies are conducted on different parsing difficulty levels. The major model variants are as follows:

\textbf{w/o Local Graph Linking}
Discard the \emph{Local Graph Linking} phase (i.e., Eq.~\ref{eq_n_1} \textasciitilde ~\ref{eq_n_6}), which means  in Eq.~\ref{eq_20} is replaced by . There is no structure-aware ability during the dual graph aggregation.

\textbf{w/o Structure-Aware Aggregation}
Remove the whole structure-aware aggregation module to examine the effectiveness of our designed graph aggregation method.

Other fine-grain ablation experiments are also conducted on our raw SADGA. The ablation experimental results are presented in Table~\ref{ablation_studies_result}. As the table shows, all components are necessary to SADGA. According to the results on the \textbf{All} level, our models, no matter the raw SADGA or the one with BERT-base enhancing, decrease by about 1.5\% and 1.8\% or 2.6\% and 2.5\% while discarding the \emph{Local Graph Linking} phase and the entire structure-aware aggregation method, which indicates the positive contribution to SADGA. Especially on the \textbf{Extra-Hard} level, discarding the \emph{Local Graph Linking} and the aggregation respectively both lead to a large decrease of accuracy, suggesting that these two major components strongly help SADGA deal with more complex cases. Interestingly, on the \textbf{Easy} level, the results indicate that these two components have no or slight negative influence on our raw model. This phenomenon is perhaps due to the fact that the \textbf{Easy} level samples do not require capturing the local structure of our dual graph while building the question-schema linking, but the structure-aware ability is highly necessary for the complicated SQL on the \textbf{Extra-Hard} level. Regarding other fine-grain ablation experiments, we give a further introduction and discussion on these ablation variants in Appendix~\ref{app_fine_grained_ablation_studies}.

\subsection{Case Study}

To further understand our method, in this section, we conduct a detailed analysis of the case in which the question is ``\textit{What is the first name of every student who has a dog but does not have a cat?}''. 

\paragraph{Global Graph Linking Analysis}
We show the alignment figure between question words and tables/columns on the \emph{Global Graph Linking} phase when the question-graph acts as the query-graph. As shown in Figure~\ref{alignment}, we can obtain the interpretable result. For example, the question word ``student'' has a strong activation with the tables/columns related to the student, which helps better build the cross graph linking between the question and schema. Furthermore, we can observe that the column ``pet\_type'' is successfully inferred by the word ``dog'' or ``cat''.

\begin{wrapfigure}{r}{0pt}
    \includegraphics[width=.5\textwidth]{figures/alignment.pdf}
    \caption{Alignment between question words and tables/columns on the \emph{Global Graph Linking} phase.}
    \label{alignment}
\end{wrapfigure}

\paragraph{Local Graph Linking Analysis}
On the \emph{Local Graph Linking} phase, we compute the attention between the query node and the neighbors of the key node, which allows question words (tables/columns) to attend to the specific structure of the schema-graph (question-graph). In Figure~\ref{case_study}, two examples about the neighbor attention on the \emph{Local Graph Linking} phase are presented. As shown in the upper part of the Figure~\ref{case_study}, the column ``first\_name'' of table ``Student'' attends to neighbors of word ``name'' in the question, where word ``first'' and word ``student'' obtain a high attention score, indicating that the column ``first\_name'' attends to the specific structure inside the dashed box.

Some tables/columns are difficult to be identified via matching-based alignment since they do not attend explicitly in the question, but they have a strong association with the question, e.g., table ``Have\_pet'' in this case, which is also not identified in \emph{Global Graph Linking}. Interestingly, as shown on the lower part of Figure~\ref{case_study} shows, table ``Have\_pet'' acquires a high attention weight when the question word ``student'' attends to table ``Student'' and its neighbors. 
With the help of SADGA, the latent association between table ``Have\_pet'' and word ``student'' can be detected, which corresponds exactly to the semantics of the question.

We also provide more samples in different database schemas compared to the baseline RATSQL and some corresponding discussions in Appendix~\ref{app_case_study_against_baseline}.

\begin{figure*}[hbt]
\centering
  \includegraphics[width=.9\textwidth]{figures/case_study.pdf}
  \caption{Analysis on the \emph{Local Graph Linking} phase.} 
  \label{case_study}
\end{figure*}

\section{Related Work}
\paragraph{Cross-Domain Text-to-SQL}
Recent architectures proposed for cross-domain Text-to-SQL show increasing complexity in both the encoder and the decoder.
IRNet \citep{guo2019towards} encodes the question and schema separately via LSTM with the string-match strategy and proposes to decode an abstracted intermediate representation (IR). RATSQL \citep{wang2020rat} proposes a unified encoding mechanism to improve the joint representation of question and schema. BRIDGE \citep{lin2020bridging} serializes the question and schema into a tagged sequence and maximally utilizes BERT \citep{devlin2018bert} and the database content to capture the question-schema linking. SmBoP \citep{rubin2021smbop} presents the first semi-autoregressive bottom-up semantic parser for the decoding phase in Text-to-SQL.

Besides, the graph encoder has been widely applied in cross-domain Text-to-SQL. \citet{bogin2019representing} is the first to encode the database schema using graph neural networks (GNNs). Global-GNN \citep{bogin2019global} applies GNNs to softly select a subset of tables/columns for the output query. ShadowGNN \citep{chen2021shadowgnn} presents a graph project neural network to abstract the representation of the question and schema. LGESQL \citep{cao-etal-2021-lgesql} utilizes the line graph to update the edge features in the heterogeneous graph for Text-to-SQL, which further considers both local and non-local, dynamic and static edge features. Differently, our SADGA not only adapts a unified dual graph framework for both the question and database schema, but also devises a structure-aware graph aggregation mechanism to sufficiently utilize the global and local structure information across the dual graph on the question-schema linking. 

\paragraph{Graph Aggregation}
The global-local graph aggregation module \citep{zhang2020comprehensive} is proposed to model inter-actions across graphs and aggregate heterogeneous graphs into a holistic graph representation in the video titling task. Nevertheless, this graph aggregation method is only at the node level, i.e., it does not consider the structure during aggregation, indicating that nodes in the graph are a series of unstructured entities. Instead of simply using the node-level aggregation, our SADGA considers the local structure information in the aggregation process, contributing a higher-order graph aggregation method with structure-awareness.

\paragraph{Pre-trained Models}
Inspired by the success of pre-trained language models, some recent works have tried to apply pre-trained objectives for text-table data. TAPAS \citep{herzig2020tapas} and TaBERT \citep{yin2020tabert} leverage the semi-structured table data to enhance the representation ability of language models. For Text-to-SQL, GraPPa \citep{yu2021grappa} is pre-trained on the synthetic data generated by the synchronous context-free grammar, STRUG \citep{deng2021structure} leverages a set of novel prediction tasks using a parallel text-table corpus to help solve the question-schema linking challenge. GAP \citep{shi2021learning} explores the direction of utilizing the generators to generate pre-trained data for enhancing the joint question and structured schema encoding ability. Moreover, \citet{Scholak2021:PICARD} proposes a method PICARD for constraining auto-regressive decoders of pre-trained language models through incremental parsing.

\section{Conclusions}
In this paper, we propose a Structure-Aware Dual Graph Aggregation Network (SADGA) for cross-domain Text-to-SQL. SADGA not only introduces a unified dual graph encoding for both natural language question and database schema, but also devises a structure-aware aggregation mechanism of SADGA to take full advantage of the global and local structure information of the dual graph in the question-schema linking. Experimental results show that our proposal achieves 3rd on the challenging Text-to-SQL benchmark Spider at the time of writing. This study shows that both the dual-graph encoding and structure-aware dual graph aggregation method are able to improve the generalization ability of the cross-domain Text-to-SQL task. As future work, we will extend SADGA to other heterogeneous graph tasks and other alignment tasks.

\section*{Acknowledgements}
We thank Tao Yu and Yusen Zhang for their evaluation of our work in the Spider Challenge.
We also thank the anonymous reviewers for their helpful comments. This research was supported in part by  National Key R\&D Program of China (2021ZD0111501), National Science Fund for Excellent Young Scholars (62122022), Natural Science Foundation of China (61876043, 61976052), Science and Technology Planning Project of Guangzhou (201902010058).

\bibliographystyle{plainnat}
\bibliography{reference} 

\clearpage

\appendix
\section{Preliminaries}
Gated Graph Neural Networks \citep{li2015gated} and Relation-Aware Transformer \citep{wang2020rat} are two critical components of our proposed model. 
The preliminaries of these two components are introduced as follows.

\subsection{Gated Graph Neural Network}
\label{app_gated_graph_neural_network}
Gated Graph Neural Networks (GGNNs) have been proposed by \citet{li2015gated}, which adopt the Gated Recurrent Unit (GRU) \citep{cho2014learning} layer to encode the nodes in graph neural networks. Given a graph  including nodes  and directed label edges  where  denotes the source node,  denotes the destination node, and  denotes the edge type. 
The process of GGNN computing the representation  at step  for the -th node on  is divided into two stages. First, aggregating the neighbor node representation  of -th node, formulated as

where  and  are trainable parameters for each edge type . 
Second, aggregated vector  will be fed into a vanilla GRU layer to update the node representation at last step , noted as:


\subsection{Relation-Aware Transformer}
\label{app_relation_aware_transformer}
Relation-Aware Transformer (RAT) \citep{wang2020rat} is an extension of Transformer \citep{vaswani2017attention}, which introduces prior relation knowledge to the self-attention mechanism. Given a set of inputs  where  and   
relation representation   between any two elements  and  in . The RAT layer (consisting of  heads attention) can output an updated representation  with relational information for , formulated as
\begin{small}

\end{small}
where  is head index, , ,  are trainable parameters, FC is a fully-connected layer, and LayerNorm is layer normalization \citep{ba2016layer}.
Here  means that the attention score between  and  of head . 

\section{Relations of Dual-Graph Construction}
\label{app_relations_of_dual_graph_construction}
All predefined relations used in the construction of the dual-graph and the cross-graph relations are summarized in Table~\ref{relation_table}. 

\newcommand{\tabincell}[2]{\begin{tabular}{@{}#1@{}}#2\end{tabular}}  
\begin{table*}[hbt]
\footnotesize
\centering
\caption{The predefined relations for Dual-Graph Construction. }
\begin{tabular}{c|c|c|c}
\hline 
\textbf{} & \textbf{Node A} & \textbf{Node B} & \textbf{Predefined Relation} \\ 
\hline
\multirow{3}{*}{\textbf{\tabincell{c}{Question-Graph \\ Construction}}} & \multirow{3}{*}{Word}     & \multirow{3}{*}{Word}             & 1-order Word Distance \\
                                                                        &                           &                                   & 2-order Word Distance \\
                                                                        &                           &                                   & Parsing-based Dependency    \\ 
\hline 
\multirow{5}{*}{\textbf{\tabincell{c}{Schema-Graph \\ Construction}}}   & \multirow{2}{*}{Column}   & \multirow{2}{*}{Column}           & Same Table Match      \\   
                                                                        &                           &                                   & Primary-Foreign Key   \\
                                                                        \cline{2-4}
                                                                        &\multirow{3}{*}{Column}    & \multirow{3}{*}{Table}            & Foreign Key           \\   
                                                                        &                           &                                   & Primary Key           \\
                                                                        &                           &                                   & Table-Column Match    \\   
                                                                        \cline{2-4}
                                                                        & Table                     & Table                             & Primary-Foreign Key   \\                         
\hline                             
\multirow{5}{*}{\textbf{Cross-Graph}}                                   & \multirow{2}{*}{Word}     & \multirow{2}{*}{Table}            & Exact String Match    \\   
                                                                        &                           &                                   & Partial String Match  \\   
                                                                        \cline{2-4} 
                                                                        & \multirow{3}{*}{Word}     & \multirow{3}{*}{Column}           & Exact String Match    \\    
                                                                        &                           &                                   & Partial String Match  \\
                                                                        &                           &                                   & Value Match           \\
\hline
\end{tabular}
\label{relation_table}
\end{table*}

The predefined relations of Question-Graph are summarized as follows:
\begin{itemize}
    \item \textbf{1-order Word Distance}
Word A and word B are adjacent to each other in the question. 
    \item \textbf{2-order Word Distance}
Word A and word B are spaced one word apart in the question.
    \item \textbf{Parsing-based Dependency}
The specific grammatical relation between word A and word B generated by the Stanford CoreNLP toolkit \citep{manning2014stanford}.  
\end{itemize}
   
The predefined relations of Schema-Graph are summarized as follows:
\begin{itemize}
    \item \textbf{Same Table Match}
Both column A and column B belong to the same table. 
    \item \textbf{Primary-Foreign Key (Column-Column)}
Column A is a foreign key for a primary key column B of another table.   
    \item \textbf{Foreign Key}
Column A is a foreign key of table B.  

    \item  \textbf{Primary Key}
Column A is a primary key of table B. 

    \item \textbf{Table-Column Match}
Column A belongs to table B.    

    \item \textbf{Primary-Foreign Key (Table-Table)}
Table A has a foreign key column for a primary key column of table B.   
\end{itemize}

The predefined relations of Cross-Graph are summarized as follows:
\begin{itemize}
    \item \textbf{Exact String Match (Word-Table)}
Word A is part of table B, and the question contains the name of table B. 

    \item \textbf{Partial String Match (Word-Table)}
Word A is part of table B, and the question does not contain the name of table B.      

    \item \textbf{Exact String Match (Word-Column)}
Word A is part of column B, and the question contains the name of column B.   

    \item \textbf{Partial String Match (Word-Column)}
Word A is part of column B, and the question does not contain the name of column B.      

    \item \textbf{Value Match}
Word A is part of the cell values of column B.
\end{itemize} 


\section{Decoder Details}
\label{app_decoder_details}
The decoder in our model aims to output a sequence of rules (actions) that generates the corresponding SQL syntax abstract tree (AST) \citep{yin2017syntactic}.
Given the final representations ,  and , of the question words, tables and columns respectively from the encoder.
Let .
Formally,

where  are all the previous rules. We apply an LSTM \citep{hochreiter1997long} to generate the rule sequence.
The LSTM hidden state  and the cell state  at step  are updated as:

Similar to \citet{wang2020rat}, the LSTM input  is constructed by:

where  is the representation of the previous rule,  is the context vector calculated using the attention on  over , and  is the learned representation of the current node type.
In addition,  is the step corresponding to generating the parent node in the AST of the current node.

With the LSTM output , all rule scores at step   are calculated.
The candidate rules are either schema-independent, e.g., the grammar rule, or schema-specific, e.g., the table/column.
For the schema-independent rule , we compute its score as:

where  is a 2-layer MLP with the \emph{tanh} activation.
To select the table/column rule, we first build the alignment matrices ,  between entities (question word, table, column) and tables, columns respectively with the relation-aware attention as a pointer mechanism:

where , . Then, we calculate the score of the -th column/table:


\section{Hyperparameters}
\label{app_hyperparameters}
The hyperparameters of our model under different pre-trained models are listed in Table~\ref{Hyper_parameters}.

\begin{table*}[hbt]
    \setlength\tabcolsep{1pt}
    \caption{Hyperparameters for GloVe, BERT-base, BERT-large and GAP setting.}
    \label{Hyper_parameters} 
    \renewcommand\arraystretch{1.1}
    \centering
    \footnotesize
    \begin{tabular}{lccccc}
        \toprule
        \textbf{Hyper-paramter}        & \textbf{GloVe}     & \textbf{BERT-base}         & \textbf{BERT-large}      & \textbf{GAP}          \\ 
        \hline\hline
        Size                     & 300    & 768            & 1024           & 1024                  \\
        Batch size                & 20   & 24             & 24             & 24                  \\
        Max step                & 40k    & 90k            & 81k            & 61k                  \\
        Learning rate           & 7.44e-4    & 3.44e-4        & 2.44e-4        & 1e-4                  \\
        Learning rate scheduler  & Warmup polynomial   & Warmup polynomial               & Warmup polynomial           & Warmup polynomial                  \\
        Warmup steps             & 2k    & 10k            & 10k            & 5k                  \\
        Bert learning rate       & -   & 3e-6        & 3e-6        & 1e-5                  \\
        Clip gradient            & -    & 2              & 1              & 1                  \\
        Number of SADGA layers    & 3  & 3              & 3              & 3                  \\
        Number of RAT layers    & 4    & 4              & 4              & 4                  \\
        RAT heads               & 8   & 8              & 8              & 8                  \\
        Number of GGNN layers    & 2   & 2              & 2              & 2                  \\
        SADGA dropout            & 0.5   & 0.5            & 0.5            & 0.5                  \\
        RAT dropout             & 0.1    & 0.1            & 0.1            & 0.1                  \\
        Encoder hidden dim       & 256   & 768            & 1024           & 1024                  \\
        Decoder LSTM size          & 512    & 512            & 512            & 512                  \\
        Decoder dropout          & 0.21  & 0.21            & 0.21            & 0.21                  \\
        
        \bottomrule 
    \end{tabular}
\end{table*}

\section{Fine-grained Ablation Studies}
\label{app_fine_grained_ablation_studies}

Due to page limitations, we cannot further discuss the fine-grained ablation studies in the main paper. Therefore, the fine-grained ablation studies are discussed in this section. Firstly, all the ablation variants are presented in detail as follows:

\paragraph{w/o Local Graph Linking}
Discard the \emph{Local Graph Linking} phase (Eq.~\ref{eq_n_1} \textasciitilde ~\ref{eq_n_6}), i.e.,
 in Eq.~\ref{eq_20} is replaced by . There is no structure-aware ability during the dual graph aggregation.

\paragraph{w/o Structure-Aware Aggregation}
Remove the entire Structure-Aware Aggregation module in SADGA to examine the effectiveness of our designed graph aggregation method.

\paragraph{w/o }
Remove the aggregation process from the question-graph  to the schema-graph  in Structure-Aware Aggregation, signifying that the nodes in the schema-graph could not obtain the structure-aware information from the question-graph.

\paragraph{w/o }
Similar to w/o .

\paragraph{Q-S Linking via Dual-Graph Encoding}
In contrast to variant \textbf{w/o Structure-Aware Aggregation}, which removes the entire aggregation module in SADGA, we preserve the predefined cross-graph relations during dual-graph encoding. This variant guarantees the ability of question-schema (Q-S) linking, and its performance variation better reflects the contribution of Structure-Aware Aggregation.

\paragraph{w/o Relation Node (replace with edge types)}
Remove the relation node in Dual-Graph Encoding. 
Regrading how to use the information of the prior relationship in the question-graph and schema-graph, we represent the predefined relations with the edge types, introducing more trainable parameters.

\paragraph{w/o Global Pooling (Eq.~\ref{global_updated_1} and Eq.~\ref{global_updated_2})}
Remove the global pooling step during the Structure-Aware Aggregation, i.e., Eq.~\ref{global_updated_1} and Eq.~\ref{global_updated_2}, to examine whether the global information of the query-graph is helpful for graph aggregation.

\paragraph{w/o Aggregation Gate (Eq.~\ref{eq_n_5})}
Discard the gate mechanism between the global information and the local information in \emph{Dual-Graph Aggregation Mechanism}.
Instead of the gating mechanism, we average the weight of the global information and the local information, i.e.,  in Eq.~\ref{eq_n_5}.

\paragraph{w/o Relation Feature in Aggregation }
Remove the cross-graph relation bias between the question word and table/column in the attention step of Structure-Aware Aggregation. 
This model variant does not utilize any predefined cross-graph relations.

\begin{table*}[hbt]
    \setlength\tabcolsep{2pt}
    \caption{Accuracy of ablation studies on Spider development set by hardness levels.}
    \label{app_ablation_studies_result} 
    \renewcommand\arraystretch{1.1}
    \centering
    \footnotesize
    \begin{tabular}{lccccc}
        \toprule
        \textbf{Model}                                                                      & \textbf{Easy}         & \textbf{Medium}       & \textbf{Hard}        & \textbf{Extra Hard}   & \textbf{All}\\ 
        \hline\hline
        \textbf{SADGA}                                                                      & \textbf{82.3}         & \textbf{67.3}         & \textbf{54.0}        & \textbf{42.8}          &\textbf{64.7}\\
        \quad w/o Local Graph Linking                                                       & 83.5(+1.2)            & 64.8(-2.5)            & 53.4(-0.6)           & 38.6(-4.2)             & 63.2(-1.5)\\
        \quad w/o Structure-Aware Aggregation                                               & 83.5(+1.2)            & 62.1(-5.2)            & 55.2(+1.2)           & 42.2(-0.6)             & 62.9(-1.8)\\
        \quad w/o                        & 83.1(+0.8)            & 64.1(-3.2)            & 52.3(-1.7)           & 40.4(-2.4)             & 62.9(-1.8)\\
        \quad w/o                        & 79.0(-3.3)            & 63.7(-3.6)            & 50.0(-4.0)           & 41.6(-1.2)             & 61.5(-3.2)\\
        \quad Q-S Linking via Dual-Graph Encoding                                           & 82.3(-0)              & 63.7(-3.6)            & 51.1(-2.9)           & 45.2(+2.4)             & 63.1(-1.6)\\
        \quad w/o Relation Node (replace with edge types)                                   & 79.4(-2.9)            & 63.5(-3.8)            & 54.6(+0.6)           & 40.4(-2.4)             & 62.1(-2.6)\\
        \quad w/o Global Pooling (Eq.~\ref{global_updated_1} and Eq.~\ref{global_updated_2})& 82.7(+0.4)            & 64.3(-3.0)            & 54.0(-0)             & 41.6(-1.2)             & 63.5(-1.2)\\
        \quad w/o Aggregation Gate (Eq.~\ref{eq_n_5}, )             & 81.9(-0.4)            & 60.1(-7.2)            & 54.6(+0.6)           & 40.4(-2.4)             & 61.2(-3.5)\\
        \quad w/o Relation Feature in Aggregation                & 79.4(-2.9)            & 64.3(-3.0)            & 54.6(+0.6)           & 41.6(-1.2)             & 62.7(-2.0)\\
        \hline\hline      
        \textbf{SADGA + BERT-base}                                                          & \textbf{85.9}         & \textbf{71.7}         & \textbf{58.0}        & \textbf{47.6}          &\textbf{69.0}\\
        \quad w/o Local Graph Linking                                                       & 85.5(-0.4)            & 69.5(-2.2)            & 54.0(-4.0)           & 42.8(-4.8)             & 66.4(-2.6)\\
        \quad w/o Structure-Aware Aggregation                                               & 85.9(-0)              & 68.8(-2.9)            & 57.5(-0.5)           & 41.0(-6.6)             & 66.5(-2.5)\\
        \bottomrule 
    \end{tabular}
\end{table*}

As shown in Table~\ref{app_ablation_studies_result} (Table~\ref{ablation_studies_result} of the main paper), all the components are necessary to SADGA. 
Regrading \textbf{w/o Local Graph Linking} and \textbf{w/o Structure-Aware Aggregation}, we have discussed these two major ablation variants in detail in the main paper.
When compared to \textbf{w/o Structure-Aware Aggregation}, SADGA gets worse results when it retains one-way aggregation, i.e., \textbf{w/o } and \textbf{w/o }. We guess that this observation occurs because the update of dual graph node representation is imbalanced in one-way aggregation. 
The downgraded performance of \textbf{Q-S Linking via Dual-Graph Encoding} better demonstrates the necessity and effectiveness of our proposed structure-aware aggregation method for question-schema linking.
The downgraded performance of \textbf{w/o Relation Node} is due to the increase of relational edge type, which leads to the increase of trainable parameters. 
The downgraded performance of \textbf{w/o Aggregation Gate} indicates the advantages of the gated-based aggregation mechanism, which provides the flexibility to filter out useless local structure information.
The downgraded performance of \textbf{w/o Global Pooling} indicates that the global information of question-graph or schema-graph is beneficial to another graph.
Our SADGA \textbf{w/o Relation Feature in Aggregation} is comparable with RATSQL \citep{wang2020rat} (62.7\%), which reflects the effectiveness of the structure-aware aggregation method to learn the relationship between the question and database schema without relying on prior relational knowledge at all.

\section{Case Study Against Baseline}
\label{app_case_study_against_baseline}
In Figure~\ref{more_case_study}, We show some cases generated by our SADGA and RATSQL \citep{wang2020rat} from the \textbf{Hard} or \textbf{Extra Hard} level samples of Spider Dataset \citep{yu2018spider}. Both SADGA and RATSQL are trained under the pre-trained model GAP \citep{shi2021learning}. In Case 1 and Case 2, RATSQL misaligned the word ``museum'' and ``rank'', resulting in the incorrect selection of tables and columns in the generated query. RATSQL utilizes the predefined relationship based on a string matching strategy to cause the above misalignment problem. 
Our SADGA is able to link the question words and tables/columns correctly in the hard cases of multiple entities, which is beneficial from the local structural information introduced by the proposed structure-aware aggregation method. 
In Cases 36, RATSQL generates semantically wrong query statements, especially when the target is a complex query, such as a nested query. Compared with RATSQL, SADGA adopts a unified dual-graph modeling method to consider both the global and local structure of the question and schema, which is more efficient for capturing the complex semantics of questions and building more exactly linkings in hard cases. 

\begin{figure*}[bp]
  \centering
  \includegraphics[width=\textwidth]{figures/more_case_study.pdf} 
  \caption{
  More cases at the \textbf{Hard} or \textbf{Extra Hard} level in different database schemas. (RATSQL + GAP vs. SADGA + GAP)
  } 
  \label{more_case_study}
\end{figure*}

\end{document}