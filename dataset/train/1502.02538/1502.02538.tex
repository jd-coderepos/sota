\documentclass[11pt]{article}
\usepackage{graphicx}
\usepackage[margin=1in]{geometry}
\usepackage{amsmath,amsthm,amssymb}
\usepackage{verbatim}
\usepackage{algorithm}
\usepackage{paralist}
\usepackage{color}

\newtheorem{theorem}{Theorem}
\numberwithin{theorem}{section}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{remark}{Remark}
\newtheorem{conclusion}[theorem]{Conclusion}
\newtheorem{Lemma}[theorem]{Lemma}
\newtheorem{assumption}[theorem]{Assumption}
\newtheorem{definition}{Definition}
 
\newcommand{\stronger}{\succeq}
\newcommand{\tab}{\hspace{5mm}}
\newcommand{\FD}{D}
\newcommand{\DP}{\Diamond\mathcal{P}}
\newcommand{\set}[1]{\left\{#1\right\}}
\newcommand{\AFD}{AFD}
\DeclareMathOperator*{\argmin}{arg\,min}

\title{Consensus using Asynchronous Failure Detectors}
\author{Nancy Lynch \\
CSAIL, MIT
\and Srikanth Sastry\footnote{The author is currently affiliated with Google Inc.}\\
CSAIL, MIT}
\date{}

\begin{document}

\maketitle

\begin{abstract}
The FLP result shows that crash-tolerant consensus is impossible to solve in asynchronous systems, and several solutions have been proposed for crash-tolerant consensus under alternative (stronger) models. One popular approach is to augment the asynchronous system with appropriate failure detectors, which provide (potentially unreliable) information about process crashes in the system, to circumvent the FLP impossibility.  

In this paper, we demonstrate the exact mechanism by which (sufficiently powerful) asynchronous failure detectors enable solving crash-tolerant consensus. Our approach, which borrows arguments from the FLP impossibility proof and the famous result from \cite{chan:twfdf}, which shows that  is a weakest failure detector to solve consensus, also yields a natural proof to  as a weakest asynchronous failure detector to solve consensus. The use of I/O automata theory in our approach enables us to model execution in a more detailed fashion than \cite{chan:twfdf} and also addresses the latent assumptions and assertions in the original result in \cite{chan:twfdf}.
\end{abstract}

\section{Introduction}



In~\cite{cornejoetalAFD,cornejoetalAFD-TR}
we introduced a new formulation of failure detectors.  Unlike the
traditional failure detectors of~\cite{chan:ufdfr, chan:twfdf}, ours are modeled as
asynchronous automata, and defined in terms of the general I/O
automata framework for asynchronous concurrent systems.
To distinguish our failure detectors from the traditional ones, we
called ours ``Asynchronous Failure Detectors (AFDs)''.

In terms of our model, we presented many of the standard results of
the field and some new results.
Our model narrowed the scope of failure detectors sufficiently so that
AFDs satisfy several desirable properties, which are not true of the
general class of traditional failure detector. For example,
(1) AFDs are self-implementable; (2) if an AFD  is strictly stronger
than another AFD , then  is sufficient to solve a strict superset
of the problems solvable by . See \cite{cornejoetalAFD-TR} for details. 
Working entirely within an asynchronous framework allowed us to take
advantage of the general results about I/O automata and to prove
our results rigorously without too much difficulty.

In this paper, we investigate the role of asynchronous failure detectors in circumventing the impossibility of crash-tolerant consensus in asynchronous systems (FLP) \cite{FLP}. Specifically, we demonstrate exactly how sufficiently strong AFDs circumvent
the FLP impossibility.  We borrow ideas from the important related result by Chandra, Hadzilacos,
and Toueg~\cite{chan:twfdf} that says that the failure detector  is a
``Weakest Failure Detector'' that solves the consensus
problem. Incidentally, the proof in \cite{chan:twfdf} make certain implicit assumptions
and assertions which are entirely reasonable and true, respectively. However, for
the purpose of rigor, it is desirable that these assumptions be explicit
and these assertions be proved. Our demonstration of how sufficiently strong AFDs circumvent FLP dovetails effortlessly with an analogous proof of  ``weakest AFD'' for consensus.


While our proof generally follows the proof in~\cite{chan:twfdf}, we
state the (implicit) assumptions and assertions from \cite{chan:twfdf} explicitly.
Since our framework is entirely asynchronous and all our definitions are based
on an established concurrency theory foundation, we are able to provide
rigorous proofs for the (unproven) assertions from \cite{chan:twfdf}. In order to prove the main result of this paper, we modified certain definitions from \cite{cornejoetalAFD-TR}. However, these modifications do not invalidate any of the results from \cite{cornejoetalAFD,cornejoetalAFD-TR}.


The rest of this paper is organized as follows. Section \ref{sec:approachAndContributions} outlines the approach that we use in this paper and its major contributions. In section \ref{sec:comarisonWithCHT}, we compare our proof with the original CHT proof in \cite{chan:twfdf}. Sections \ref{sec:ioautomata} through~\ref{sec:solvingProblems} introduce I/O automata and the definitions of a problem, of an asynchronous system, and of AFDs; much of the material is summarized
from~\cite{cornejoetalAFD,cornejoetalAFD-TR}. Section \ref{sec:observations} introduces the notion of \emph{observations} of AFD behavior, which are a key part of showing that  is a weakest AFD to solve consensus; this section proves several useful properties of observations which are central to the understanding of the proof and are a contribution of our work. In Section \ref{subsec:treeOfExec}, we introduce \emph{execution trees} for any asynchronous system that uses an AFD; we construct such trees from observations introduced in Section \ref{sec:observations}. We also prove several properties of such execution trees, which may be of independent interest and useful in analysis of executions in any AFD-based system. In Section \ref{sec:consensusAndAFD}, we formally define the consensus problem and use the notions of observations and execution trees to demonstrate how sufficiently strong AFDs enable asynchronous systems to circumvent the impossibility of fault tolerant consensus in asynchronous systems \cite{FLP}; Section \ref{sec:consensusAndAFD} defines and uses \emph{decision gadgets} in an execution tree to demonstrate this; it also shows that the set of such decision gadgets is countable, and therefore, any such execution tree contains a ``first'' decision gadget. Furthermore, Section \ref{sec:consensusAndAFD} also shows that each decision gadget is associated with a location that is live and never crashes; we call it the \emph{critical location} of the decision gadget. In Section \ref{sec: wfd}, we show that  is a weakest AFD to solve consensus by presenting a distributed algorithm that simulates the output of . The algorithm constructs observations and execution trees, and it eventually identifies the ``first'' decision gadget and its corresponding critical location; the algorithm outputs this critical location as the output of the simulated  AFD, thus showing that  is a weakest AFD for consensus. 



\section{Approach and contributions}\label{sec:approachAndContributions}
To demonstrate our results, we start with a complete definition of asynchronous systems and AFDs. Here, we modified the definitions of AFD from \cite{cornejoetalAFD,cornejoetalAFD-TR}, but we did so without invalidating earlier results. We argue that the resulting definition of AFDs is more natural and models a richer class of behaviors in crash-prone asynchronous systems. Next, we introduce the notion of \emph{observations} of AFD behavior (Section \ref{sec:observations}), which are DAGs that model a partial ordering AFD outputs are different processes; importantly, the knowledge of this partial order can be gained by any process through asynchronous message passing alone. \emph{Observations as a tool for modeling AFD behavior is of independent interest}, and we prove several important properties of observations that are used in our later results.

From such observations, we construct trees of executions of arbitrary AFD-based systems; again, \emph{such trees are of independent interest}, and we prove several important properties of such trees that are used later.

Next, we define the consensus problem and the notion \emph{valence}. Roughly speaking, a finite execution of a system is univalent if all its fair extensions result in the same decision value and the execution is bivalent if some fair extension results in a decision value  and another fair extension results in a decision value . We present our first important result using observations and execution trees; \emph{we show that a sufficiently powerful AFD guarantees that in the execution tree constructed from any viable\footnote{Informally, an observation is viable if it can be constructed from an AFD trace.} observation of AFD outputs, the events responsible for the transition from a bivalent execution to a univalent execution must occur at location that does not crash}. Such transitions to univalent executions correspond to so-called ``decision gadgets'', and the live location corresponding to such transitions is called the ``critical location'' of the decision gadgets.

Next, we use the aforementioned result to show that  is a weakest AFD to solve consensus. In order to do so, we first define a metric function that orders all the decision gadgets. This metric function satisfies an important stability property which guarantees the following. Given the decision gadget with the smallest metric value in a given infinite execution tree, for any sufficiently large, but finite, subtree, the same decision gadget will have the smallest metric value within that subtree. Note that the original proof in \cite{chan:twfdf} did not provide such a metric function, and we contend that this is an essential compoenent for completing this proof. We then construct an emulation algorithm (similar to the one in \cite{chan:twfdf}) that uses an AFD sufficiently powerful to solve consensus and simulates the output of . In this algorithm processes exchange AFD outputs and construct finite observations and corresponding finite execution trees. The aforementioned stability property ensures that eventually forever, each process that does not crash identifies the same decision gadget as the one with the smallest metric value. Recall that the critical location of any decision gadget is guaranteed to not crash. Therefore, eventually forever, each process that does not crash identifies the same correct process and outputs that correct process as the output of the simulated  AFD.


\section{Comparisons with the original CHT proof}\label{sec:comarisonWithCHT}
Our proof has elements that are very similar to the the original CHT proof from~\cite{chan:twfdf}. However, despite the similarity in our arguments, our proof deviates from the CHT proof in some subtle, but significant ways.

\subsection{Observations}
In \cite{chan:twfdf}, the authors introduce DAGs with special properties that model the outputs of a failure detector at different processes and establishes partial ordering of these outputs. In our proof, the analogous structure is an observation (See Section \ref{sec:observations}). However, our notion of an observation is much more general than the DAG introduced in \cite{chan:twfdf}.

First, the DAG in \cite{chan:twfdf} is an infinite graph and cannot model failure detector outputs in finite executions. In contrast, observations may be finite or infinite. Second, we also introduce the notion of a sequence of finite observations that can be constructed from progressively longer finite executions that enable us to model the evolution of observations and execution trees as failure detector outputs become available. Such detailed modeling and analysis does not appear in \cite{chan:twfdf}.

\subsection{Execution trees}
In \cite{chan:twfdf}, each possible input to consensus gives rise to a unique execution tree from the DAG. Thus, for  processes, there are  possible trees that constitute a forest a trees. In contrast, our proof constructs exactly one tree that models the executions of all possible inputs to consensus. This change is not merely cosmetic. It simplifies analysis and makes the proof technique more general in the following sense.

The original proof in \cite{chan:twfdf} cannot be extended to understanding long-lived problems such as iterative consensus or mutual exclusion. The simple reason for this is that the number of possible inputs for such problems can be uncountably infinite, and so the number of trees generated by the proof technique in \cite{chan:twfdf} is also uncountably infinite. This introduces significant challenges in extracting any structures within these trees by a distributed algorithm. In contrast, in our approach, the execution tree will remain virtually the same; only the rules for determining the action tag values at various edges change.

\subsection{Determining the ``first'' decision gadget}
In \cite{chan:twfdf} and in our proof, a significant result is that there are infinite, but countable number of decision gadgets, and therefore there exists a unique enumeration of the decision gadgets such that one of them is the ``first'' one. This result is then used in \cite{chan:twfdf}  to claim that all the emulation algorithms converge to the same decision gadget. However, \cite{chan:twfdf} does not provide any proof of this claim. Furthermore, we show that this proving this claim in non-trivial.

The significant gap in the original proof in \cite{chan:twfdf} is the following. During the emulation, each process constructs only finite DAGs, that are subgraphs of some infinite DAG with the required special properties. However, since the DAGs are finite, the trees of executions constructed from this DAG could incorrectly detect certain parts of the trees as being decision gadgets, when in the execution tree of the infinite DAG, these are not decision gadgets. Each such pseudo decision gadget, is eventually deemed to not be a decision gadget, as the emulation progresses. However, there can be infinitely many such pseudo gadgets. Thus, given any arbitrary enumeration of decision gadgets, it is possible that such pseudo decision gadgets appears infinitely often, and are enumerated ahead of the ``first'' decision gadget. Consequently, the emulation never stabilizes to the first decision gadget.

In our proof, we address is gap by carefully defining metric functions for nodes and decision gadgets so that eventually, all the pseudo decision gadgets are ordered after the eventual ``first'' decision gadget.

\section{I/O Automata}\label{sec:ioautomata}

We use the I/O Automata framework~\cite{lynch:hapf,lynch:aiti,lync:da}
for specifying the system model and failure detectors. 
Briefly, an I/O automaton models a component of a distributed system
as a (possibly infinite) state machine that interacts with other state
machines through discrete actions. 
This section summarizes the I/O-Automata-related definitions that we
use in this paper. 
See \cite[Chapter 8]{lync:da} for a thorough description of I/O
Automata.

\subsection{Automata Definitions}
\label{sec: IOA: automata-defs}

An \emph{I/O automaton}, which we will usually refer to as simply an
``automaton'', consists of five components:
a signature, a set of states, a set of initial states, a
state-transition relation, and a set of tasks. 
We describe these components next.

\paragraph{Actions, Signature, and Tasks.} 
The state transitions of an automaton are associated with named
\emph{actions}; we denote the set of actions of an automaton  by
.
Actions are classified as \emph{input}, \emph{output}, or
\emph{internal}, and this classification constitutes the
\emph{signature} of the automaton. 
We denote the sets of input, output, and internal actions of an
automaton  by , , and ,
respectively. 
Input and output actions are collectively called the \emph{external}
actions, denoted , and output and internal actions are
collectively called the \emph{locally controlled} actions. 
The locally controlled actions of an automaton are partitioned into
\emph{tasks}. 
Tasks are used in defining fairness conditions on executions of the
automaton, as we describe in Section~\ref{sec: IOA: fairness}.

Internal actions of an automaton are local to the automaton itself
whereas external (input and output) actions are available for
interaction with other automata.
Locally controlled actions are initiated by the automaton itself,
whereas input actions simply arrive at the automaton from the outside, 
without any control by the automaton.

\paragraph{States.} 
The states of an automaton  are denoted by ; some
(non-empty) subset  is designated as the
set of \emph{initial states}. 

\paragraph{Transition Relation.}
The state transitions of an automaton  are defined by a
\emph{state-transition relation} , which is a set
of tuples of the form  where  and . 
Each such tuple  is a \emph{transition}, or a \emph{step},
of .
Informally speaking, each step  denotes the following
behavior:  automaton , in state , performs action  and
changes its state to . 

For a given state  and action , if  contains some step
of the form , then  is said to be \emph{enabled} in
. 
We assume that every input action in  is enabled in every state of
; that is, for every input action  and every state ,
 contains a step of the form .
A task , which is a set of locally controlled actions, is said to
be \emph{enabled} in a state  iff some action in  is enabled in
.

\paragraph{Deterministic Automata.}
The general definition of an I/O automaton permits multiple locally
controlled actions to be enabled in any given state. 
It also allows the resulting state after performing a given action to
be chosen nondeterministically. 
For our purposes, it is convenient to consider a class of I/O automata
whose behavior is more restricted. 

We define an action  (of an automaton ) to be
\emph{deterministic} provided that, for every state , 
contains at most one transition of the form .
We define an automaton  to be \emph{task deterministic} iff (1) for
every task  and every state  of , at most one action in 
is enabled in , and (2) all the actions in  are deterministic. 
An automaton is said to be \emph{deterministic} iff it
is task deterministic, has exactly one task, and has a unique start
state.

\subsection{Executions, Traces, and Schedules}

Now we define how an automaton executes. 
An \emph{execution fragment} of an automaton  is a finite sequence
, or an infinite sequence
, of alternating
states and actions of  such that for every ,  is in .
A sequence consisting of just a state is a special case of an
execution fragment and is called a \emph{null execution fragment}. 
Each occurrence of an action in an execution fragment is called an 
\emph{event}. 

An execution fragment that starts with an initial state (that is, ) is called an \emph{execution}. 
A null execution fragment consisting of an initial state is called a
\emph{null execution}.
A state  is said to be \emph{reachable} if there exists a finite
execution that ends with . 
By definition, any initial state is reachable.

We define concatenation of execution fragments.
Let  and  be two execution fragments of an I/O
automaton such that  is finite and the final state of
 is also the starting state of , and let
 denote the sequence obtained by deleting the first state
in . 
Then the expression  denotes the execution
fragment formed by appending  after .

It is sometimes useful to consider just the sequence of events that
occur in an execution, ignoring the states.
Thus, given an execution , the \emph{schedule} of  is
the subsequence of  that consists of all the events in
, both internal and external.
The \emph{trace} of an execution includes only the externally
observable behavior;
formally, the trace  of an execution  is the subsequence of
 consisting of all the external actions. 

More generally, we define the \emph{projection} of any sequence on a
set of actions as follows.
Given a sequence  (which may be an execution fragment, schedule, or
trace) and a set  of actions, the projection of  on , denoted
by , is the subsequence of  consisting of all the events from
.


We define concatenation of schedules and traces. 
Let  and  be two sequences of actions of some I/O automaton
where  is finite; then  denotes the sequence
formed by appending  after .

To designate specific events in a schedule or trace, we use the
following notation:
if a sequence  (which may be a schedule or a trace) contains at
least  events, then  denotes the  event in the
sequence , and otherwise, . 
Here,  is a special symbol that we assume is different from the
names of all actions. 

\subsection{Operations on I/O Automata}

\paragraph{Composition.} 
A collection of I/O automata may be composed by matching output
actions of some automata with the same-named input actions of
others.\footnote{Not all collections of I/O automata may be
  composed. For instance, in order to compose a collection of I/O
  automata, we require that no two automata have a common output
  action.  See \cite[chapter 8]{lync:da} for details.}
Each output of an automaton may be matched with inputs of any number
of other automata. 
Upon composition, all the actions with the same name are performed
together.

Let  be an execution of the
composition of automata . 
The \emph{projection} of  on automaton , where , is denoted by  and is defined to be the
subsequence of  obtained by deleting each pair 
for which  is not an action of  and replacing each remaining
state  by automaton 's part of . 
Theorem~8.1 in~\cite{lync:da} states that if  is an execution
of the composition , then for each ,
 is an execution of . 
Similarly, if  is a trace of of , then for
each ,  is an trace of .



\paragraph{Hiding.} 
In an automaton , an output action may be ``hidden'' by
reclassifying it as an internal action. 
A hidden action no longer appears in the traces of the automaton.

\subsection{Fairness}
\label{sec: IOA: fairness}

When considering executions of an I/O automaton, we will often be
interested in those executions in which every task of the automaton
gets infinitely many turns to take steps; we call such executions
``fair''.
When the automaton represents a distributed systems, the notion of
fairness can be used to express the idea that all system components
continue to get turns to perform their activities.

Formally, an execution fragment  of an automaton  is said
to be \emph{fair} iff the following two conditions hold for
every task  in . (1) If  is finite, then no action in
 is enabled in the final state of . (2) If  is
infinite, then either (a)  contains infinitely many events
from , or (b)  contains infinitely many occurrences of
states in which  is not enabled.

A schedule  of  is said to be \emph{fair} if it is the
schedule of a fair execution of . 
Similarly, a trace  of  is said to be \emph{fair} if it is the
trace of a fair execution of .



\section{Crash Problems}

In this section, we define problems, distributed problems,
crash problems, and failure-detector problems.
We also define a particular failure-detector problem corresponding to
the leader election oracle  of~\cite{chan:twfdf}.

\subsection{Problems} 
\label{subsec:problems}

We define a \emph{problem}  to be a tuple , where
 and  are disjoint sets of actions and  is a set of
(finite or infinite) sequences over these actions such that there
exists an automaton  where , , and
the set of fair traces of  is a subset of .  
In this case we state that  \emph{solves} .
We include the aforementioned assumption of solvability to satisfy a non-triviality
property, which we explain in Section~\ref{sec:solvingProblems}.

\paragraph{Distributed Problems.}
Here and for the rest of the paper, we introduce a fixed finite set
 of  location IDs; we assume that  does not contain the
special symbol . We assume a fixed total ordering  on .
We also assume a fixed mapping  from actions to ; for an action , if , then we say that 
\emph{occurs at} . 
A problem  is said to be \emph{distributed} over  if, for every
action , . 
We extend the definition of  by defining .


Given a problem  that is distributed over , and a location ,  and  denote the set of actions in 
and , respectively, that occur at location ;
that is,  and . 



\paragraph{Crash Problems.}
We assume a set  of crash
events, where . 
That is,  represents a crash that occurs at location .
A problem  that is distributed over  is said
to be a \emph{crash problem} iff . 
That is,  for every .

Given a (finite or infinite) sequence ,  denotes
the set of locations at which a  event occurs in . 
Similarly,  denotes the set of
locations at which a  event does not occur in . 
A location in  is said to be \emph{faulty} in , and
a location in  is said to be \emph{live} in . 



\subsection{Failure-Detector Problems}
\label{subsec:FDproblems}

Recall that a failure detector is an oracle that provides information
about crash failures. 
In our modeling framework, we view a failure detector as a special
type of crash problem.
A necessary condition for a crash problem  to
be an asynchronous failure detector (AFD) is \emph{crash exclusivity},
which states that ; that is, the actions  are
exactly the  actions. 
Crash exclusivity guarantees that the only inputs to a failure
detector are the  events, and hence, failure detectors
provide information only about crashes. 
An AFD must also satisfy additional properties, which we describe next.

Let  be a crash problem satisfying
crash exclusivity. 
We begin by defining a few terms that will be used in the definition of
an AFD. Let  be an arbitrary sequence over .

\paragraph{Valid sequence.} 
The sequence  is said to be \emph{valid} iff 
(1) for every , no event in  (the set of
actions in  at location ) occurs after a  event
in , and 
(2) if no  event occurs in , then  contains infinitely
many events in .

Thus, a valid sequence contains no output events at a location 
after a  event, and contains infinitely many output events at
each live location.

\paragraph{Sampling.} 
A sequence  is a \emph{sampling} of  iff (1)  is a
subsequence of , (2) for every location , (a) if  is
live in , then , and (b) if
 is faulty in , then   contains the first  event in
, and  is a prefix of .

A sampling of sequence  retains all events at live locations.
For each faulty location , it may remove a suffix of the outputs at
location .  It may also remove some crash events, but must retain
the first crash event.

\paragraph{Constrained Reordering.}
Let  be a valid permutation of events in ;  is a
\emph{constrained reordering} of  iff the following is true. For
every pair of events  and , if (1)  precedes  in , and
(2) either (a)  and , or (b)  and , then  precedes
 in  as well.\footnote{Note that the definition of constrained reordering is less restrictive than the definition in \cite{cornejoetalAFD,cornejoetalAFD-TR}; specifically, unlike in \cite{cornejoetalAFD,cornejoetalAFD-TR}, this definition allow crashes to be reordered with respect to each other. However, this definition is ``compatible'' with the earlier definition in the sense that the results presented in \cite{cornejoetalAFD,cornejoetalAFD-TR} continue to be true under this new definition.}

A constrained reordering of sequence  maintains the relative
ordering of events that occur at the same location and maintains the
relative order between any  event and any subsequent event.

\paragraph{Crash Extension.} Assume that  is a finite sequence. A
crash extension of  is a (possibly infinite) sequence  such
that  is a prefix of  and the suffix of  following  is a
sequence over .

In other words, a crash extension of  is obtained by extending 
with  events.

\paragraph{Extra Crashes.} 
An \emph{extra crash} event in  is a  event in , for
some , such that  contains a preceding . 

An extra crash is a crash event at a location that has already
crashed.

\paragraph{Minimal-Crash Sequence.} 
Let  denote the subsequence of  that contains all the
events in , except for the extra crashes;  is called
the \emph{minimal-crash sequence} of .

\paragraph{Asynchronous Failure Detector.}
Now we are ready to define asynchronous failure detectors.
A crash problem of the form 
(which satisfies crash exclusivity) is an \emph{asynchronous failure
  detector} (AFD, for short) iff  satisfies the following
properties. 
\begin{enumerate}
\item \textbf{Validity.}
Every sequence  is valid.

\item \textbf{Closure Under Sampling}. For every sequence , every sampling of  is also in .

\item \textbf{Closure Under Constrained Reordering.} For every
  sequence , every constrained reordering  is also
  in . 

\item \textbf{Closure Under Crash Extension.} For every sequence , for every prefix  of , for every crash
  extension  of , the following are true. (a) If  is finite, then  is a
  prefix of some sequence in . (b) If ,
  then  is in .

\item \textbf{Closure Under Extra Crashes.} 
For every sequence , every sequence  such that
 is also in .
\end{enumerate}

Of the properties given here, the first three---validity and closure
under sampling and constrained reordering---were also used in our
earlier papers~\cite{cornejoetalAFD,cornejoetalAFD-TR}.
The other two closure properties---closure under crash extension and
extra crashes---are new here.  

A brief motivation for the above properties is in order. The validity
property ensures that (1) after a location crashes, no outputs occur
at that location, and (2) if a location does not crash, outputs occur
infinitely often at that location. Closure under sampling permits a
failure detector to ``skip'' or ``miss'' any suffix of outputs at a faulty
location. Closure under constrained reordering permits ``delaying''
output events at any location. Closure under crash extension permits a
crash event to occur at any time. Finally, closure under extra crashes
captures the notion that once a location is crashed, the occurrence of
additional crash events (or lack thereof) at that location has no
effect.

\begin{comment}
From the closure-under-constrained-reordering property of AFDs, it follows that given any AFD trace  in  for an AFD , we can move the  events in  ``earlier in time'' and obtain a new trace , and if  is a valid sequence, then  is guaranteed to be in . This property is formalized in the following Lemma.
\begin{lemma}\label{prop:moveCrashEarlier}
Let  be an AFD, and let  be a trace in . Suppose that  is a valid sequence obtained by permuting the events from  such that . Suppose that, for every  event  in  such that  for some pair of positive integers  and , we have . Then  is in .
\end{lemma}



\begin{proof}
Fix ,  and  as in the hypothesis of the Lemma statement.
We prove the Lemma by showing that  is a constrained reordering of . 

Since  is a permutation of events in , there exists a bijection  that maps positions in  to position in  such that for any positive integer ,  and  are the same event.

\emph{Claim:}  For any positive integer , if  is an event from  then .
\begin{proof}
Suppose for contradiction that there exists a positive integer  such that  is an event from  and . Fix the smallest such .
Therefore, for every , such that  is an event from , . Note that by construction, for every , such that  is an event from , .

Since , by pigeon-hole principle, there exists a  (that is,  is in the prefix of  ending with event ) such that  is not in the prefix of  ending with event ; in other words . Fix such a . By construction, we know that for any  such that  is from , ; therefore  cannot be from  and must  be from .  However, note that since , for every  such that  is from , we know that  occurs before , and therefore,  must be in the prefix of  ending with event ; therefore,  is not from . We have a contradiction.
\end{proof}

Fix  and  to be a pair of events in  such that  precedes  in ; that is,   and  such that . Consider the following two cases: (a)   and , and (b) 
 and . 

\emph{Case (a).} Let  and . Since ,  precedes  in .

\emph{Case (b).} Let  and . Note that , and . By construction, we know that , and from the claim above, we know that . Since , we conclude that ; that is,   precedes  in .

From cases (a) and (b), we conclude that if (1)  precedes  in , and
(2) either (a)  and , or (b)  and , then  precedes
 in  as well. By hypotheses,  is a valid sequence.
Therefore,  is a constrained reordering of . Since  is in , by closure under constrained reordering, we know that  is in .
\end{proof}
\end{comment}

We define one additional constraint, below.
This contraint is a formalization of an implicit assumption made in 
\cite{chan:twfdf}; namely, for any AFD , any ``sampling'' (as
defined in \cite{char:isolt}) of a failure detector sequence in 
is also in . 


\paragraph{Strong-Sampling AFDs.}
Let  be an AFD, . 
A subsequence  of  is said to be a \emph{strong sampling} of
 if  is a valid sequence.
AFD  is said to satisfy \emph{closure under strong sampling} if,
for every trace , every strong sampling of  is also in
. Any AFD that satisfies closure under strong sampling is said to
be a \emph{strong-sampling} AFD.

Although the set of strong-sampling AFDs are a strict subset of all AFDs, we conjecture that restricting our discussion to strong sampling AFDs does not weaken our result. Specifically, we assert without proof that for any AFD , we can construct an ``equivalent'' strong-sampling AFD . This notion of equivalence is formally discussed in  Section \ref{subsec:solvingFDproblemsWithAnother}.





\subsection{The Leader Election Oracle.} 
\label{subset:omegaDef}

An example of a strong-sampling AFD is the leader election oracle
~\cite{chan:twfdf}.
Informally speaking,  continually outputs a location ID at
each live location; eventually and permanently,  outputs the
ID of a unique live location at all the live locations.
The  failure detector was shown in \cite{chan:twfdf} to be a
``weakest'' failure detector to solve crash-tolerant consensus, in a
certain sense. 
We will present a version of this proof in this paper.

We specify our version  of 
as follows.
The action set , where, for
each , . 
 is the set of all valid sequences  over  that satisfy the following property:  
if , then there exists a location  and a suffix  of  such that
 is a sequence over the set .

\begin{algorithm}\footnotesize
\caption{Automaton that implements the  AFD}
\label{alg:OmegaAutomaton}
The automaton 

\textbf{Signature:}

\tab input ,  

\tab output , 


\textbf{State variables:}

\tab , a subset of , initially 

\textbf{Transitions:}

\tab input 

\tab effect

\tab \tab 

\tab

\tab output 

\tab precondition

\tab \tab 

\tab effect

\tab \tab none

\textbf{Tasks:}

\tab One task per location  defined as follows:

\tab \tab 

\end{algorithm}
 
Algorithm \ref{alg:OmegaAutomaton} shows an automaton whose set of
fair traces is a subset of ; it follows that 
satisfies our formal definition of a ``problem''.
It is easy to see that 
satisfies all the properties of an AFD, and furthermore, note that
 also satisfies closure under strong sampling. 
The proofs of these observations are left as an exercise.

\paragraph{AFD .}  Here, we introduce , where  is a natural number, as a generalization of . In this paper, we will show that  is a weakest strong-sampling AFD that solves fault-tolerant consensus if at most  locations are faulty.
Informally speaking,  denotes the AFD
that behaves exactly like  in traces that have at most 
faulty locations. Thus,   is the AFD .

Precisely, , where
 is the set of all valid sequences  over  such that, if , then .
This definition implies that  contains all the valid
sequences over   such that .

It is easy to see that  is a strong-sampling AFD.

\section{System Model and Definitions}
\label{sec:systemModel}

We model an asynchronous system as the composition of a collection of
I/O automata of the following kinds:  process automata, channel
automata, a crash automaton, and an environment automaton.
The external signature of each automaton and the interaction among
them are described in Section \ref{subsec:systemInteraction}. 
The behavior of these automata is described in Sections
\ref{subsec:processAutomata}---\ref{subsec:environmentAutomaton}. 

For the definitions that follow, we assume an alphabet 
of messages.

\subsection{System Structure}
\label{subsec:systemInteraction}

A system contains a collection of process automata, one for each
location in .
We define the association with a mapping , which maps each
location  to a process automaton .
Automaton  has the following external signature. 
It has an input action , which is an output from the crash
automaton,  
a set of output actions , 
and a set of input actions .  
A process automaton may also have other external actions with which it
interacts with the external environment or a failure detector; the set
of such actions may vary from one system to another. 

For every ordered pair  of distinct locations, the system
contains a channel automaton , which models the channel that
transports messages from process  to process . 
Channel  has the following external actions. 
The set of input actions  is , which is a subset of outputs of the process automaton
.
The set of output actions  is , which is a subset of inputs to .

The crash automaton  models the occurrence of crash
failures in the system.
Automaton  has  as
its set of output actions, and no input actions.

The environment automaton  models the external world with
which the distributed system interacts. The automaton  is a composition of  automata .
For each location , the set of input actions to automaton  includes the action .
In addition,  may have input and output actions corresponding
(respectively) to any outputs and inputs of the process automaton  that
do not match up with other automata in the system.


We assume that, for every location , every external action of
 and , respectively, occurs at , that is,  for every external
action  of  and .

We provide some constraints on the structure of the various automata
below.

\subsection{Process Automata}
\label{subsec:processAutomata}

The process automaton at location , , is an I/O automaton
whose external signature satisfies the constraints given above, and
that satisfies the following additional properties.
\begin{enumerate}
\item
Every internal action of  occurs at , that is,
 for every internal action  of .  
We have already assumed that every external action of  occurs
at ; now we are simply extending this requirement to the internal
actions.



\item
Automaton  is deterministic, as defined in Section~\ref{sec:
  IOA:  automata-defs}.

\item
When  occurs, it permanently disables all locally controlled
actions of .  
\end{enumerate}

We define a \emph{distributed algorithm}  to be a collection of
process automata, one at each location; formally, it is simply a
particular  mapping.  
For convenience, we will usually write  for the process automaton
.

\subsection{Channel Automata}
\label{subsec:channelAutomata}

The channel automaton for  and , , is an I/O automaton
whose external signature is as described above.
That is, 's input actions are  and its output actions are .

Now we require  to be a specific I/O automaton---a
\emph{reliable FIFO channel}, as defined in~\cite{lync:da}.
This automaton has no internal actions, and all its output actions are
grouped into a single task.
The state consists of a FIFO queue of messages, which is initially empty.
A  input event can occur at any time. 
The effect of an event  is to add  to the end of the
queue. 
When a message  is at the head of the queue, the output action
 is enabled, and the effect is to remove  from the
head of the queue.
Note that this automaton  is deterministic.

\subsection{Crash Automaton}
\label{subsec:crashAutomaton}

The crash automaton  is an I/O automaton with
 as its set of output actions,
and no input actions.

Now we require the following constraint on the behavior of
:  Every sequence over  is a fair trace of the
crash automaton.
That is, any pattern of crashes is possible.
For some of our results, we will consider restrictions on the number of locations that crash.

\subsection{Environment Automaton}
\label{subsec:environmentAutomaton}
The environment automaton  is an I/O automaton whose
external signature satisfies the constraints described in Section \ref{subsec:systemInteraction}. Recall that  is a composition of  automata . For each location , the following is true.
\begin{enumerate}
\item  has a unique initial state.
\item  has tasks , where  ranges
over some fixed task index set .
\item  is task-deterministic.
\item When  occurs, it permanently disables all locally controlled
actions of .
\end{enumerate}
In addition, in some specific cases we will require the traces of
 to satisfy certain ``well-formedness'' restrictions,
which will vary from one system to another.
We will define these specifically when they are needed, later in the
paper.

\begin{figure}[htpb]
	\centering
\includegraphics[scale=0.35,page=1]{figs}
	\caption{Interaction diagram for a message-passing asynchronous distributed system augmented with a failure detector automaton.}
	\label{fig:interaction_diagram}
\end{figure}




\section{Solving Problems}
\label{sec:solvingProblems}

In this section we define what it means for a distributed algorithm
to solve a crash problem in a particular environment.
We also define what it means for a distributed algorithm to solve one
problem  using another problem . 
Based on these definitions, we define what it means for an AFD to
be sufficient to solve a problem.


\subsection{Solving a Crash Problem}
\label{subsec:solvingCrashProblems}

An automaton  is said to be an \emph{environment for} 
if the input actions of  are , and the output
actions of  are .
Thus, the environment's inputs and outputs ``match'' those of the
problem, except that the environment doesn't provide the problem's
 inputs.

If  is an environment for a crash problem , then an I/O automaton  is said to \emph{solve} 
in environment  provided that the following conditions
hold:
\begin{enumerate}
\item
.
\item
.
\item
The set of fair traces of the composition of , , and
the crash automaton is a subset of .
\end{enumerate}

A distributed algorithm  \emph{solves} a crash problem  in an
environment  iff the automaton , which is
obtained by composing  with the channel automata, solves  in
. 
A crash problem  is said to be \emph{solvable} in an environment
 iff there exists a distributed algorithm  such
that  solves  in . 
If crash problem  is not solvable in environment , then
it is said to be \emph{unsolvable} in .

\subsection{Solving One Crash Problem Using Another}

Often, an unsolvable problem  may be solvable if the system
contains an automaton that solves some \emph{other} (unsolvable) crash
problem . We describe the relationship between  and  as
follows.

Let  and  be two
crash problems with disjoint sets of actions (except for 
actions).
Let  be an environment for .
Then a distributed algorithm  \emph{solves} crash problem  using
crash problem  in environment  iff the following are
true:
\begin{enumerate}
\item
For each location , . 
\item
For each location , .
\item
Let  be the composition of  with the channel automata,
the crash automaton, and the environment automaton . 
Then for every fair trace  of , 
if , then . 

In effect, in any fair execution of the system, if the sequence
of events associated with the problem  is consistent with the
specified behavior of , then the sequence of events associated
with problem  is consistent with the specified behavior of .
\end{enumerate}

Note that requirement 3 is vacuous if for every fair trace  of
, . 
However, in the definition of a problem , the requirement
that there exist some automaton whose set of fair traces is a subset
of  ensures that there are ``sufficiently many'' fair traces 
of , such that .


We say that a crash problem  
\emph{is sufficient to solve} a crash problem 
in environment , denoted  iff
there exists a distributed algorithm  that solves  using  in
. If , then also we say that
 \emph{is solvable using}  in . If no such
distributed algorithm exists, then we state that  is
\emph{unsolvable} using  in , and we denote it as .

\subsection{Using and Solving Failure-Detector Problems}
\label{subsec:solvingFDproblemsWithAnother}

Since an AFD is simply a kind of crash problem, the definitions above
automatically yield definitions for the following notions.
\begin{enumerate}
\item 
A distributed algorithm  solves an AFD  in environment .
\item 
A distributed algorithm  solves a crash problem  using an AFD
 in environment .
\item 
An AFD  is sufficient to solve a crash problem  in environment
.
\item 
A distributed algorithm  solves an AFD  using a crash problem
 in environment .
\item 
A crash problem  is sufficient to solve an AFD  in environment
.
\item 
A distributed algorithm  solves an AFD  using another AFD
.
\item 
An AFD  is sufficient to solve an AFD .
\end{enumerate}

Note that, when we talk about solving an AFD, the environment
 has no output actions because the AFD has no input
actions except for , which are inputs from the crash
automaton. 
Therefore, we have the following lemma.

\begin{lemma}
Let  be a crash problem and  an AFD.
If  in some environment 
(for ), then for any other environment  for ,
. 
\end{lemma}

Consequently, when we refer to an AFD  being solvable using a crash
problem (or an AFD) , we omit the reference to the environment
automaton and simply say that  is sufficient to solve ; we
denote this relationship by . 
Similarly, when we say that an AFD  is unsolvable using , we
omit mention of the environment, and write simply .

Finally, if an AFD  is sufficient to solve another AFD  (notion 7 in the list above), then
we say that  \emph{is stronger than} , and we denote this
by . 
If , but , then we
say that  is \emph{strictly stronger} than , and we denote this
by . Also, if   and , then we say that  is \emph{equivalent} to .

We conjecture that for any AFD , there exists a strong sampling AFD  such that  is equivalent to ; thus, if a non-strong-sampling AFD  is a weakest to solve consensus, then there must exist an equivalent AFD  that is also a weakest to solve consensus. Therefore, it is sufficient to restrict our attention to strong-sampling AFDs.



\section{Observations}\label{sec:observations}



In this section, fix  to be an AFD.
We define the notion of an observation  of  and present
properties of observations.
Observations are a key part of the emulation algorithm used to prove
the ``weakest failure detector'' result, in Section~\ref{sec: wfd}.



\subsection{Definitions and Basic Properties}
\label{subsec:observationDef}

An \emph{observation} is a DAG , where the set  of
vertices consists of triples of the form  where  is a location,  is a positive integer, and  is an action
from ; we refer to , , and  as the location, index,
and action of , respectively. 
Informally, a vertex  denotes that  is the -th AFD
output at location , and the observation represents a partial
ordering of AFD outputs at various locations. 
We say that an observation  is \emph{finite} iff the set  (and therefore the set ) is finite; otherwise,  is said to be \emph{infinite}.

We require the set  to satisfy the following properties.
\begin{enumerate}
\item 
For each location  and each positive integer ,  contains at
most one vertex whose location is  and index is .
\item 
If  contains a vertex of the form  and , then 
also contains a vertex of the form .
\end{enumerate}
Property 1 states that at each location , for each positive integer , there is at most
one -th AFD output. 
Property 2 states that for any  and , if the -th AFD output occurs at ,
then the first  AFD outputs also occur at .

The set  of edges imposes a partial ordering on the occurrence of
AFD outputs.  We assume that it satisfies the following properties.
\begin{enumerate}
\setcounter{enumi}{2}
\item 
For every location  and natural number , if  contains
vertices of the form  and , then 
contains an edge from  to . 
\item 
For every pair of distinct locations  and  such that 
contains an infinite number of vertices whose location is , the
following is true. 
For each vertex  in  whose location is , there is a vertex
 in  whose location is  such that there is an edge from
 to  in .
\item 
For every triple , ,  of vertices such that 
contains both an edge from  to  and an edge from  to
,  also contains an edge from  to . 
That is, the set of edges of  is closed under transitivity.
\end{enumerate}
Property 3 states that at each location , the -th output at  occurs before the
-st output at . 
Property 4 states that for every pair of locations  and  such that infinitely many AFD outputs occur at , for every AFD output event  at  there exists some AFD output event  at  such that  occurs before
. 
Property 5 is a transitive closure property that simply captures the
notion that if event  happens before event  and 
happens before event , then  happens before .

Given an observation , if  contains an infinite number
of vertices of the form  for some particular , then  is
said to be \emph{live} in . 
We write  for the set of all the locations that are live in .

\begin{lemma}
\label{prop:liveImpliesAllIndices}
Let  be an observation,  a location in .
Then for every positive integer ,  contains exactly one vertex
of the form .
\end{lemma}
\begin{proof}
Follows from Properties 1 and 2 of observations.
\end{proof}

\begin{lemma}
\label{prop:outgoingEdgesToLiveVertices}
Let  and  be distinct locations with .
Let  be a vertex in  whose location is .
Then there exists a positive integer  such that for every positive
integer ,  contains an edge from  to some vertex of
the form .
\end{lemma}

\begin{proof}
Follows from Lemma \ref{prop:liveImpliesAllIndices}, and
Properties 3, 4, and 5 of observations.
\end{proof}




\begin{lemma}
\label{prop:outgoingEdgesToCrashedVertices}
Let  and  be distinct locations with  and ; that is,  contains infinitely many vertices whose
location is  and only finitely many vertices whose location is .
Then there exists a positive integer  such that for every , there is no edge from any vertex of the form  to any
vertex whose location is .
\end{lemma}

\begin{proof}
Fix  and  as in the hypotheses.
Let  be the vertex in  whose location is  and whose index
is the highest among all the vertices whose location is .
From Lemma \ref{prop:outgoingEdgesToLiveVertices} we know that
there exists a positive integer  such that for every positive
integer ,  contains an edge from  to some vertex of the
form . 
Since  is a DAG, there is no edge from any vertex of the form
,  to . 
Applying Properties 3 and 5 of observations, we conclude that
there is no edge from any vertex of the form  to any vertex
whose location is .
\end{proof}

\begin{lemma}
\label{prop:finiteIncomingEdges}
Let  be an observation.
Every vertex  in  has only finitely many incoming edges in .
\end{lemma}

\begin{proof}
For contradiction, assume that there exists a vertex  with
infinitely many incoming edges, and let  be the location of .
Then there must be a location  such that there are
infinitely many vertices whose location is  that have an outgoing
edge to .   
Fix such a location . 
Note that  must be live in .

Since there are infinitely many vertices whose location is , by
Property 4 of observations, we know that  has an outgoing edge to
some vertex . 
Since infinitely many vertices of the form
 have an outgoing edge to , fix some such . 
By Properties 3 and 5 of observations, we know that there exists a
edge from  to . 
Thus, we see that there exist edges from  to , 
from  to , and from  to , which yield a
cycle. 
This contradicts the assumption that  is a DAG. 
\end{proof}

\subsection{Viable Observations}

Now consider an observation . 
If  is any sequence of vertices in , then we define
the \emph{event-sequence} of  to be the sequence obtained
by projecting  onto its second component.

We say that a trace  is \emph{compatible} with an
observation  provided that  is the event sequence of some
topological ordering of the vertices of .  
 is a \emph{viable} observation if there exists a trace 
that is compatible with .

\begin{lemma}
\label{prop:liveInObsAndTrace}
Let  be a viable observation, and suppose that  is
compatible with . 
For each location ,  is live in  iff .
\end{lemma}

We now consider paths in an observation DAG, and their connection with
strong sampling, as defined in Section~\ref{subsec:FDproblems}. A \emph{path} in a observation is a sequence of vertices, where for each pair of consecutive vertices  in a path,  is an edge of the observation.


A \emph{branch} of an observation  is a maximal path in .
A \emph{fair branch}  of  is a branch of  that satisfies the
additional property that, for every  in , if  is live in , then
 contains an infinite number of vertices whose location is .


\begin{lemma}
\label{prop:sampledSubsequence}
\label{prop:pathIsTrace}
Let  be a viable observation, and suppose that  is
compatible with . 
Suppose  is a fair branch of , and let  be the event
sequence of . 
Then
\begin{enumerate}
\item
There exists a strong sampling  of  such that
. 
\item
If  is a strong-sampling AFD, then there exists  
such that  is a strong sampling of  and .
\end{enumerate}
\end{lemma}
\begin{proof}
Fix , , ,  and  from the hypotheses of the Lemma statement.
 
\emph{Proof of Part 1.}
Since  is a fair branch of , for each location  that is live in ,  contains an infinite number of outputs at . Furthermore, for each location , the projection of  on the events at  is a subsequence of the projection of  on the AFD outputs at . Therefore, by deleting all the AFD output events from  that do not appear in , we obtain a strong-sampling  of  such that .

\emph{Proof of Part 2.}
In Part 2, assume  is a strong-sampling AFD. From Part 1, we have already established that there exists a strong-sampling  of  such that . Fix such a . By closure under strong-sampling, since , we conclude that  as well.
\end{proof}


Lemma \ref{prop:sampledSubsequence} is crucial to our results. In Section \ref{sec: wfd}, we describe an emulation algorithm that uses outputs from an AFD to produce viable observations, and the emulations consider paths of the observation and simulate executions of a consensus algorithm with AFD outputs from each path in the observation. Lemma \ref{prop:sampledSubsequence} guarantees that each fair path in the observation corresponds to an actual sequence of AFD outputs from some trace of the AFD. In fact, the motivation for closure-under-strong-sampling property is to establish Lemma \ref{prop:sampledSubsequence}. 

\subsection{Relations and Operations on Observations}\label{subsec:OperationsOnObservations}

The emulation construction in Section~\ref{sec: wfd} will require
processes to manipulate observations.  To help with this, we define
some relations and operations on DAGs and observations. 

\paragraph{Prefix.}
Given two DAGs  and ,  is said to be a
\emph{prefix} of  iff  is a subgraph of  and for every
vertex  of , the set of incoming edges of  in  is equal
to the set of incoming edges of  in .

\paragraph{Union.}
Let  and  be two observations. 
Then the \emph{union}  of  and , denoted , is
the graph .
Note that, in general, this union need not be another observation.
However, under certain conditions, wherein the observations are finite and ``consistent'' in terms of the vertices and incoming edges at each vertex, the union of two observations is also an observation. We state this formally in the following Lemma.

\begin{lemma}
\label{prop:obs:union}
Let  and  be two finite observations. 
Suppose that the following hold:
\begin{enumerate}
\item
There do not exist  and 
with .  
\item
If  then  has the same set of incoming edges (from
the same set of other vertices) in  and .
\end{enumerate}
Then  is also an observation. 
\end{lemma}

\begin{proof}
Straightforward.
\end{proof}





\paragraph{Insertion.}
Let  be a finite observation,  a location, and  the
largest integer such that  contains a vertex of the form .
Let  be a triple .
Then , the result of inserting  into , is a new graph 
, where  and 
. 
That is,  is obtained from  by adding vertex  and adding
edges from every vertex in  to .



\begin{lemma}
\label{prop:insertVertexYeildsObservation}
Let  be a finite observation,  a location.
Let  be the largest integer such that  contains a vertex of the
form .
Let  be a triple .
Then  is a finite observation.
\end{lemma}

\subsection{Limits of Sequences of Observations}

Consider an infinite sequence  of finite observations,
where each is a prefix of the next.
Then the \emph{limit} of this sequence is the graph  defined as follows:
\begin{itemize}
\item
.
\item
.
\end{itemize}

\begin{lemma}\label{lem:GxIsPrefixOfGInfty}
For each positive integer , 
 is a prefix of .
\end{lemma}

Under certain conditions, the limit of the infinite sequence of observations  is also an observation; we note this in Lemma  \ref{lem:obs:limitObs}.
\begin{lemma}
\label{lem:obs:limitObs}
Let  be the limit of the infinite sequence  of finite observations,
where each is a prefix of the next.
Suppose that the sequence satisfies the following property:
\begin{enumerate}
\item
For every vertex  and any location ,
there exists a vertex  with location
 such that   contains the edge .
\end{enumerate}
Then  is an observation.
\end{lemma}

\begin{proof}
All properties are straightforward from the definitions, except for
Property 4 of observations, which follows from the assumption of the
lemma.
\end{proof}

We define an infinite sequence  of finite observations, where each is a prefix of the next, to be to be \emph{convergent} if the limit  of this sequence is an observation.

\section{Execution Trees}
\label{subsec:treeOfExec}

In this section, we define a tree representing executions of a system
 that are consistent with a particular observation  of a
particular failure detector .
Specifically, we define a tree that describes executions of
 in which the sequence of AFD outputs is exactly the event-sequence
of some path in observation .

Section \ref{subsec:TreeExecutionSystem} defines the system  for which the tree is defined.
The tree is constructed in two parts: Section \ref{subsec:taskTree} defines a ``task tree'', and Section \ref{subsec:TheAugmentedTree} adds tags to the nodes and edges of the task tree to yield the final execution tree. Additionally, Sections \ref{subsec:taskTree}  and \ref{subsec:TheAugmentedTree} prove certain basic properties of execution trees, and they establish a correspondence between the nodes in the tree and finite executions of .
 Section \ref{subsec:taggedTreeProps} defines that two nodes in the execution tree are ``similar'' to each other if they have the same tags, and therefore correspond to the same execution of ; the section goes on to prove certain useful properties of nodes in the subtrees rooted at any two similar nodes. 
 Section \ref{subsec:PropertiesOfSimilarModuloNodes} defines that two nodes in the execution tree are ``similar-modulo-'' to each other if the executions corresponding to the two nodes are indistinguishable for process automata at any location except possibly the the process automaton at ; the section goes on to prove certain useful properties of nodes in the subtrees rooted at any two similar-modulo- nodes. 
 Section \ref{subset:PropertiesOfTreesFromPrefixObservations} establishes useful properties of nodes that are in different execution trees that are constructed using two observations, one of which is a prefix of another. Finally, Section \ref{subset:FairBranchesOfExecutionTrees} proves that a ``fair branch" of infinite execution trees corresponds to a fair execution of system . The major results in this section are used in Sections \ref{sec:consensusAndAFD} and \ref{sec: wfd}, which show that  is a weakest strong-sampling AFD to solve consensus if at most  locations crash.


\subsection{The System}\label{subsec:TreeExecutionSystem}

Fix  to be a system consisting of a distributed algorithm , channel
automata, and an environment automaton  such that  solves
a crash problem  using  in . 


The system  contains the following tasks.
The process automaton at  contains a single task . 
Each channel automaton , where 
contains a single task, which we also denote as ;  the actions in task  are of the form , which results in a message received at location . 
Each automaton  has tasks , where  ranges
over some fixed task index set .
Let  denote the set of all the tasks of .

Each task has an associated location, which is the location of all the
actions in the task.
The tasks at location  are , , 
and .


Recall from Section \ref{sec:systemModel} that each process automaton, each channel automaton, and the environment automaton have unique initial states. Therefore, the system  has a unique initial state. From the definitions of the constituent automata of , we obtain the following lemma.

\begin{lemma}\label{lem:addCrashAfterLastEvent}
 Let  be an execution of system , and let  be the trace of  such that for some location ,  does not contain any locally-controlled actions at  and . Then, there exists an execution  of system  such that  is the trace of . 
\end{lemma}
\begin{proof}
Fix ,  and  as in the hypothesis of the claim.
Let  be the prefix of  whose trace is . Let  be the final state of .
Let  be the execution , where  is the state of  when  is applied to state .

Note that  disables all locally-controlled actions at  and , and it does not change the state of any other automaton in . Therefore, the state of all automata in  except for  and  are the same in state  and . Also, note that  does not contain any locally-controlled action at  or , and  can be applied to state . Therefore,  can also be applied to , thus extending  to an execution  of . By construction, the trace  of  is .
\end{proof}



\subsection{The Task Tree}\label{subsec:taskTree}
For any observation , we define a tree  that describes all executions of 
in which the sequence of AFD output events is the event-sequence of
some path in .





We describe our construction in two stages.
The first stage, in this subsection, defines the basic structure of
the tree, with annotations indicating where particular system tasks and
observation vertices occur.  
The second stage, described in the next subsection, adds information
about particular actions and system states.

The task tree is rooted at a special node called ``'' which
corresponds to the initial state of the system .
The tree is of height ; if  is infinite, the tree has infinite height.\footnote{The intuitive reason for limiting the depth of the tree to  is the following.
If  is a finite observation, then none of the locations in  are live in . In this case, we want all the branches in the task tree to be finite.
	On the other hand, if  is an infinite observation, then some location in  is live in , and in this case we want all the branches in the task tree to be infinite.
	On way to ensure these properties is to restrict the depth of the tree to .} 
Every node  in the tree that is at a depth  is a leaf
node. All other nodes are internal nodes. 
Each edge in the tree is labeled by an element from . 
Intuitively, the label of an edge corresponds to a task being given a
``turn'' or an AFD event occurring. 
An edge with label  is said to be an -edge, for short. 
The child of a node  that is connected to  by an edge labeled
 is said to be an -child of .

In addition to labels at each edge, the tree is also augmented with
a \emph{vertex tag}, which is a vertex in , at each node and edge. 
We write  for the vertex tag at node  and  for the vertex
tag at edge . Intuitively, each vertex tag denotes the latest
AFD output that occurs in the execution of  corresponding to 
the path in the tree from the root to node  or the head node of edge  (as appropriate).
The set of outgoing edges from each node  in the tree is determined by the vertex tag . 

We describe the labels and vertex tags in the task tree recursively,
starting with the  node. 
We define the vertex tag of  to be a special placeholder element
, representing a ``null vertex'' of .
For each internal node  with vertex tag , the outgoing edges
from  and their vertex tags are as follows.
\begin{itemize}
\item
\emph{Outgoing , , and  edges.}
For every task  in , the task tree contains exactly one outgoing
edge  from  with label  from , \textit{i.e.}, an -edge. 
The vertex tag  of  is . 
\item
\emph{Outgoing -edges.} 
If , then for every vertex  of , the task tree includes an edge  from  with label  and vertex tag . 
For every location  such that  contains no vertices with location , the task tree includes a single outgoing edge  from  with label  and vertex tag .

Otherwise, ( is a vertex of ) for every vertex (say)  of  that has an edge in  from
vertex , the task tree includes an outgoing edge  from  with
label  and vertex tag . 
For every location  such that there is no edge in  from  to
any vertex whose location is , the task tree includes an outgoing edge
 from  with label  and vertex tag .
\end{itemize}
For each node  that is a child of  and whose incoming edge is
, .

A \emph{path} in a rooted tree is an alternating sequence of nodes and edges,
  beginning and ending with a node, where (1) each node is incident to
  both the edge that precedes it and the edge that follows it in the
  sequence, and (2) the nodes that precede and follow an edge are the
  end nodes of that edge.
  
A \emph{branch} in a rooted tree is a maximal path in the tree that starts at the root. 


The following two Lemmas follow from the construction of the task tree.
\begin{lemma}\label{prop:allLabelsExist}
For each label , each internal node  in  has at
least one outgoing -edge.
\end{lemma}


\begin{lemma}
Let  be a path in the tree that begins at the root node.
Let  be the sequence of distinct non- vertex tags of edges in path .
Then there exists some path  in  such that  is the sequence of vertices along .
\end{lemma}

\subsection{The Augmented Tree}\label{subsec:TheAugmentedTree}



Now we augment the task tree produced in the previous section to
include additional tags --- configuration tags  at the nodes, which are states of
the system , and action tags  at the edges, which are actions of 
or . However, the action tags cannot be  actions.
The resulting tagged tree is our execution tree . Intuitively, the configuration tag  of a node  denotes a state of system , and the action tag  for an edge  with label  from node  denotes an action  from task  that occurs when system  is in state . It is easy to see that for any path in the execution tree, the sequence of alternating configuration tags and action tags along the path represents an execution fragment of .

We define the tags recursively, this time starting from the
already-defined task tree.
For the  node, the configuration tag is the initial state of
.
For each internal node  with configuration tag  and vertex tag ,
the new tags are defined as follows:


\begin{itemize}
\item
\emph{Outgoing -edges.} 
For every edge  from node  with label , the action tag
 is determined as follows.
If the vertex tag , then .
If , then .

Essentially, if , then 
this corresponds to the action  of  occurring when  is in state ; we model this by setting  to . Otherwise,  and no event from  occurs  when  is in state ; we mode this by setting  to . 

\item
\emph{Outgoing  and  edges.} 
For every edge  from node  with label  for some
location , the action tag  is determined as follows.
If (1) some action  in task  is enabled in state ,  and (2) either 
(a)  is a vertex of  and  contains an edge from  to a vertex with location , or (b)  and  has a vertex with location , then
 is ; otherwise  is . 
Note that since each process automaton and each constituent automaton of the environment automaton in  is task-deterministic, for each location  at most one
action in the  task is enabled in  and, for each location  and each , at most one action in the  task is enabled in . Therefore, at most one action  in task  is enabled in state , and thus  is well-defined.

Fix node  in  and a location . Observe that if the action tag of an  edge from  is , then for all  edges that are descendants of , their action tag is . The condition (2) above for determining  for a  or  edge  from  implies that, if no AFD output events at  follow  in the maximal subtree of  rooted at , then no  event of  event follows  in that subtree either; we formalize this claim is Lemma \ref{lem:crashedLocationNoActionsInSubtree}. 



\item
\emph{Outgoing  edges.}
For every edge  from node  with label , the action tag  is determined as
follows:
If some action  in task  is enabled in state , then ; otherwise . 
Note that since all automata in  are task deterministic, at most
one action in task  is enabled in . Informally, we state that if some action in task  is enabled in state , then that event occurs along the edge ; otherwise, no event occurs along the edge .
\end{itemize}


Each node  that is a child of  and whose incoming edge is
 is tagged as follows. 
If the action tag  then . 
Otherwise,  is the state of  resulting from applying the
action  to state . 








The following Lemmas establish various relationships between nodes,
paths, and branches in
. Note that these Lemmas following immediately
from the construction.



 For each node , let  be the path from the root node 
 to  in the tree . 
Let  be the sequence of alternating config tags and action
tags along  such that  contains exactly the
non- action tags and their preceding config tags in  and
ends with the config tag . 



\begin{lemma}\label{prop:nodeFiniteExe}
 For each node  in , the sequence  is a finite execution of the system  that ends in state  and if  is non-empty (and therefore,  is a vertex of ), then  is the event-sequence of the vertices in  for some path to .
\end{lemma}

\begin{lemma}\label{prop:botChild}\label{prop:nonBotChild}
Let  be a node, let  be a child of , and let  be the edge from  to  in . Then the following are true.
 \begin{enumerate}
 \item If , then ,  and .
 \item If , then .
 \end{enumerate}
\end{lemma}

\begin{lemma}\label{prop:ancesterPrefix}\label{prop:ancesterPrefixAFDEvents}
 For each node  in  and any descendant  of ,  is a prefix of  and  is a prefix of .
\end{lemma}
\begin{proof}
 Follows from repeated application of Lemmas \ref{prop:botChild} along the path from  to .
\end{proof}

\begin{lemma}\label{lem:childNodeUniqueByLabelAndVertexTag}
For each node  in , each child node  of  is uniquely determined by the label  of the edge from  to  and the vertex tag .
\end{lemma}
\begin{proof}
The proof follows from the construction of . Fix . If two outgoing edges  and  from  have the same label, then that label must be from . However, for each location , each of the outgoing -edges from  have a different vertex tag, and the vertex tag of an  -child  of  is the same as the vertex tag of the edge from  to . Hence, for any no two child nodes of , either the label of the edge from  to each of the child nodes is distinct, or the vertex tag of each of the child nodes is distinct. 
\end{proof} 

\begin{lemma}\label{prop:FDchildVertexEdgeExists}
For each node  in  and any child  of  such that the edge  from  to
 has the label  (for some location ) and the action tag  of the edge is non-, the following
is true. (1) , (2)  is the action of , and (3) if , then there is an edge
from  to  in .
\end{lemma}

\begin{lemma}\label{prop:sameVertexTag}
For each node  in  and any descendant  of  such that there is no -edge in the path from  to , .
\end{lemma}
\begin{proof}
The proof is by induction on the length of the path from  to .
\end{proof}

\begin{lemma}\label{lem:descendantVertexTagEdge}
For each node  in  and for any descendant  of , either , or if , then there is an edge from  to  in .
\end{lemma}
\begin{proof}
Fix  and  as in the hypothesis of the lemma. Let the path from  to  contain  edges. We prove the lemma by strong induction on .

\emph{Inductive hypothesis.} For any pair of nodes  and  such that  is a descendant of  in , and the path from  to  contains  edges,  either , or if , then  there is an edge from  to  in .

\emph{Inductive step.} Fix  and . If , note that , and therefore ; therefore the lemma is satisfied. For ,  is a child of , and let  be the edge from  to . If , the the lemmas is satisfied. Assume  and ; note that if , then by construction  is an FD-edge and . Invoking Lemma \ref{prop:FDchildVertexEdgeExists}, we know that there is an edge from  to  in .


For any , there exists at least one node  in the path from  to . Fix . By construction, the path from  to  contains fewer than  edges, and the path from  to  contains fewer than  edges. Invoking the inductive hypothesis for nodes  and , we know that either  or, if , then there is an edge from  to  in . Similarly, invoking the inductive hypothesis for nodes  and , we know that either  or, if ,  there is an edge from  to  in . Therefore, either (1) , or (2) if , then , and there is a path from   to  in . In case (1) the induction is complete. In case (2), invoking the transitive closure property of , we know that there is an edge from  to  in , and the induction is complete.

\end{proof}


\begin{lemma}\label{prop:liveLocationNonBotAction}
For each label  where  is live in , every -edge in  has a non- action tag.
\end{lemma}



\begin{lemma}\label{lem:fairBranchUnfairExe}
For every branch  of ,  is an execution of system .
\end{lemma}
\begin{proof}
Fix a branch  of . Let , where each  is an edge in  and each  is a node in ,
denote the sequence of nodes that constitute . By definition,
 is the limit of the prefix-ordered sequence
, , , ; note that this sequence might be infinite. Note that
 is a prefix of
, and from Lemma
\ref{prop:ancesterPrefixAFDEvents}, we know that   is
a prefix of  for any positive integer
. Therefore, the limit of the prefix-ordered sequence
, , , 
exists, and this limit is . By Lemma
\ref{prop:nodeFiniteExe}, we know that  and each
, where  is a positive integer, is a finite execution of
, and therefore,  is an execution of . 
\end{proof}
\begin{lemma}\label{lem:crashedLocationNoOutgoingActions}
For any node  in , any location  and any -edge  outgoing from , if , then for each outgoing -edge or -edge  from , .
\end{lemma}
\begin{proof}
Fix , , and  as in the hypothesis of the Lemma; thus, . From the construction of , we know that  iff either  is not a vertex in  and there  is no vertex in  whose location is , or there is no edge in  from  to any vertex whose location is .

Fix  to be either a -edge or -edge outgoing from . From the construction of  , we know that if  either 
(a)  is a vertex of  and  contains no edges from  to a vertex with location , or (b)  and  has a no vertex with location , then  is . 
\end{proof}

For any node  in ,  let  denote the maximal subtree of  rooted at .


\begin{lemma}\label{lem:crashedLocationNoActionsInSubtree}
For any node  in , any location  and any -edge  outgoing from , if , then for each -edge or -edge  in  ,  .
\end{lemma}
\begin{proof}
Fix  and  as in the hypothesis of the Lemma; thus, an outgoing -edge  from , . From the construction of , we know that  iff either  is not a vertex in  and there is no vertex in  whose location is , or there is no edge in  from  to any vertex whose location is .

Fix  to be any node in . By construction,  is a descendant of . From the construction of , note that for every descendant  of  in , if  is a vertex in , then  is a descendant of . Thus, either there is no vertex in  whose location is , or  does not have any outgoing edges to a vertex in  whose location is . From the construction of , we see that   for an outgoing -edge  from . From Lemma \ref{lem:crashedLocationNoOutgoingActions}, we know that  for each outgoing -edge or -edge  from , .
\end{proof}


Next, we establish the relationship between traces compatible with  and the action tags of -edges in . Specifically, we show that
the following is true. 
For any node  in  such that the vertex tag  is a vertex in , let  be the event of , and assume that some -edge of  has a non- action tag. Then  in any trace  compatible with , and for any location , no  event precedes  in .

\begin{lemma}\label{lem:noCrashIUntilBot}
 Let  be any node in  such that  contains .
Let there exist an -edge  in  such that . Then for any arbitrary trace in  that is compatible with , no  event precedes the event of  in .
\end{lemma}
\begin{proof}
Fix , , and  as in the hypotheses of the lemma. Let  denote the upper endpoint of .
Since  is in ,  is a descendant of , and consequently, there exists a path from  to  in . Since , we know that  has an outgoing edge to some vertex  in , fix ; note that  is the event of . Since we have a path from  to  in  and an edge from  to  in , we have a path from  to  in .
Therefore, in every topological sort of ,  follows .

Now consider , and assume for contradiction that  precedes the event of  in .
Since  is a topological sort of , the event  of  follows the event of  in .
Then  precedes the event  of  in . Recall that  is an  edge and therefore . In other words,  precedes an  event in ; thus,  is not a valid sequence. This contradicts our assumption that  is a trace in , because all traces in  are valid.
\end{proof}

We define a \emph{non-} node. A node  in  is said to be a \emph{non-} node iff the path from the root to  does not contain any edges whose action tag is . In the subsequent sections, non- nodes play a significant role, and so we prove some useful properties about non- nodes next.

\begin{lemma}\label{lem:nonBotNodeUniqueExe}
Suppose  and  are a non- nodes in  such that (1)  and  are at the same depth ,  (2) the projection of the paths from  to  and  to  on the set of labels are equal, (3) the projection of  the paths from  to  and  to  on the vertex tags are also equal. Then .
\end{lemma}
\begin{proof}
The proof is a straightforward induction on .
\end{proof}

The inductive extension of Lemma \ref{lem:childNodeUniqueByLabelAndVertexTag} is that each non- node  in  is uniquely determined by the sequence of labels and vertex tags of the edges from  to . We prove this next.

\begin{lemma}\label{lem:LabelsAndVertexAgsDenoteUniqueNode}
Each non- node  in  is uniquely determined by the sequence of labels and vertex tags of the edges from  to .
\end{lemma}
\begin{proof}
The proof is by induction the depth  of .

\emph{Base case.} , and there is unique  node in .

\emph{Inductive Hypothesis.} For some positive integer , each non- node  in  at depth  is uniquely determined by the sequence of labels and vertex tags of the edges from  to .

\emph{Inductive step.} Fix  to be any non- node in  at depth . By construction, there is an edge whose lower endpoint is  and whose upper end point is a node  at depth . By Lemma \ref{lem:childNodeUniqueByLabelAndVertexTag}, we know that given ,  is uniquely determined by the label  of the edge from  to  and the vertex tag . However, by the inductive hypothesis,  is uniquely determined by the sequence of labels and vertex tags of the edges from  to . Therefore,  is uniquely determined in  by the sequence of labels and vertex tags of the edges from  to . This completes the induction.
\end{proof}





\subsection{Properties of ``Similar'' Nodes in Execution Trees}
\label{subsec:taggedTreeProps}

For any two nodes  and  in  such that  and , the following lemmas establish a
relationship between the descendants of  and . Informally,
these lemmas establish that the maximal subtrees of 
rooted at  and  are in some sense similar to each other.
Lemma \ref{lem:sameConfigSameChild} establishes that for every child
 of  there exists a child  of  that is
``similar'' to . Lemma \ref{lem:sameConfigSameExtensionLength}
extends such similarity to arbitrary descendants of ; that is,
for any descendant  of , there exist ``similar'' descendants
of . Lemma \ref{lem:everyDescendantNoBot} states that for any descendant  of , there exists a descendant  of  that is ``similar'' to , but the path from  to  does not contain any edges with a  action tag.

The proofs use
the notion of ``distance'' between a node and its descendant as
defined next. The \emph{distance} from a node  to its descendant
 is the number of edges in the path from  to
. Note that if the distance from  to  is ,
then  is a child of .





\begin{lemma}\label{lem:sameConfigSameChild}
 Let  and  be two nodes in  such that  and . Let  be an arbitrary label in
 . Let   and  be an -edge and the
 corresponding -child of , respectively. There exists an
 -edge  of  and the corresponding -child
  of  such that , ,
 , and . 
\end{lemma}

\begin{proof}
 Fix , , , , and  as in the hypotheses of the lemma. We consider two cases:  is in , and  is in . 

 \emph{Case 1.} . Since , , and the system is task deterministic, we know that there exists an outgoing  edge  from  such that . Let  be the -child of  connected by edge . Since  is obtained by applying  to , and  is obtained by applying  to , we see that . Also, by construction,  and ; therefore,  and .

 
 \emph{Case 2.}  is of the form , for some particular . Then we consider two subcases: (a)  and (b) .
 
 \emph{Subcase 2(a).} . Then either (i)  and  has no vertices with location , or (ii)  is a vertex of  and  has no vertices with location  to which  has an outgoing edge. In both cases (i) and (ii), by construction, . Since , from the construction of , we know that there is an -edge  of  such that , and we also know that for the -child  of  that is connected to  by , . Therefore,  and .

\emph{Subcase 2(b).} . Then either (i)  and  has a vertex  of the form , or (ii)  is a vertex of  and  has a vertex  of the form  to which  has an outgoing edge such that . Since , in both cases (i) and (ii), from the construction of , we know that there is an -edge  of  such that  and , and we also know that for the -child  of  that is connected to  by , . Therefore,   and .

In both subcases, since  is obtained by applying  to , and  is obtained by applying  to , we see that .  
 \end{proof}
 
  
 \begin{lemma}\label{lem:sameConfigSameExtensionLength}
 Let  and  be two nodes in  such that  and , and let  be a descendant of . There exists a descendant  of  such that the following is true.
 \begin{enumerate}
 \item .
 \item . 
 \item Let the path from  to  be  and the path from  to  be . Then,  and  are of the same length.
\item The suffix of  following  is identical to the suffix of  following .
  \end{enumerate}
\end{lemma}
\begin{proof}
The lemma is a simple inductive extension of Lemma \ref{lem:sameConfigSameChild}. The proof follows from a straightforward induction on the length of the path from  to .
\end{proof}

\begin{comment}
\begin{proof}
 Fix  and  as in the hypothesis of the lemma.
 The proof is by induction on the distance from  to .
 
 \emph{Base Case.} Let the distance between  and  be . That is, . Trivially, we see that  satisfies the lemma.

 
 \emph{Inductive Hypothesis.}
 For every descendant  of  at a distance  from , there exists a descendant  of ,  
 such that , the suffix of  following  is identical to the suffix of  following , and the path  from  to  does not contain any edges whose action tag is .
 
 \emph{Inductive Step.} 
 Fix  to be a descendant of  at a distance  from . Let  be the parent of . Note that, by construction,  is a descendant of  at a distance  from .
 Let  be the label of the edge  connecting  and . 
 
 By the inductive hypothesis, there exists a descendant  of  
 such that , the suffix of  following  is identical to the suffix of  following , and the path from  to  does not contain any edge whose action tag is .
 
 If the action tag of edge  (connecting  and ) is , then by Lemma \ref{prop:botChild}, we know that  and . Let  be . Therefore,  is a descendant of  such that , the suffix of  following  is identical to the suffix of  following , and the path from  to  does not contain any edge whose action tag is , as needed.
 
 On the other hand, if the action tag of the edge  (connecting  and ) is not , then we apply Lemma \ref{lem:sameConfigSameChild} to fix  to be an -child of  and  to be the -edge connecting  and  such that , , and .
 By Lemma \ref{prop:nonBotChild},  and . Also recall that the suffix of  following  is identical to the suffix of  following . Therefore, the suffix of  following  is identical to the suffix of  following , as needed. 

 This completes the induction and the proof.
\end{proof}
\end{comment}

Next, we show that for any node  and any descendant  of , there exists a node  of  that is ``similar'' to , and the path from  to  does not contain any edges with a  action tag.

\begin{lemma}\label{lem:everyDescendantNoBot}
 Let  be an arbitrary node in . For every descendant  of , there exists a descendant  of  such that  , the suffix of  following  is identical to the suffix of  following , and the path  from  to  does not contain any edges whose action tag is .
\end{lemma}
\begin{proof}
Fix  and  as in the hypothesis of the lemma. Let  be the path from  to . If  does not contain any edges whose action tag is , then the lemma is satisfied when . Otherwise, the following arguments hold.

Let  be the suffix of  following , starting with the state . Let  denote the trace of , and let  denote the sequence of tasks in  such that for each ,  is an action in task . By construction, there exists a path from  whose projection on the labels is , and furthermore, since  is the trace of , and the starting state of  is , there exists path  from  whose projection on action tags is ; fix such a path . Note that, by construction,  does not contain any  elements. Thus, path  has no edges with  action tag, and the suffix of  following  is identical to the suffix of  following .
\end{proof}

\begin{comment}
\begin{lemma}\label{lem:sameConfigSameExtension}
 Let  and  be two nodes in  such that  and , and let  be a descendant of . There exists a descendant  of  such that , the suffix of  following  is identical to the suffix of  following , and the path  from  to  does not contain any edges whose action tag is .
\end{lemma}
\begin{proof}
 Fix  and  as in the hypothesis of the lemma.
 The proof is by induction on the distance from  to .
 
 \emph{Base Case.} Let the distance between  and  be . That is, . Trivially, we see that  satisfies the lemma.

 
 \emph{Inductive Hypothesis.}
 For every descendant  of  at a distance  from , there exists a descendant  of ,  
 such that , the suffix of  following  is identical to the suffix of  following , and the path  from  to  does not contain any edges whose action tag is .
 
 \emph{Inductive Step.} 
 Fix  to be a descendant of  at a distance  from . Let  be the parent of . Note that, by construction,  is a descendant of  at a distance  from .
 Let  be the label of the edge  connecting  and . 
 
 By the inductive hypothesis, there exists a descendant  of  
 such that , the suffix of  following  is identical to the suffix of  following , and the path from  to  does not contain any edge whose action tag is .
 
 If the action tag of edge  (connecting  and ) is , then by Lemma \ref{prop:botChild}, we know that  and . Let  be . Therefore,  is a descendant of  such that , the suffix of  following  is identical to the suffix of  following , and the path from  to  does not contain any edge whose action tag is , as needed.
 
 On the other hand, if the action tag of the edge  (connecting  and ) is not , then we apply Lemma \ref{lem:sameConfigSameChild} to fix  to be an -child of  and  to be the -edge connecting  and  such that , , and . Note that only one such edge  exists, and therefore, only one such  exists.
 By Lemma \ref{prop:nonBotChild},  and . Also recall that the suffix of  following  is identical to the suffix of  following . Therefore, the suffix of  following  is identical to the suffix of  following , as needed. Finally, the path from  to  does not contain any edge whose action tag is , as needed.
 
 This completes the induction and the proof.
\end{proof}
\end{comment}

\begin{corollary}\label{cor:NonBotNodesExist}
For each node  in , there exists a non- node  in  such that , .
\end{corollary}
\begin{proof}
 Follows by applying Lemma \ref{lem:everyDescendantNoBot} to the root node and noting that  is a descendant of the root node.
\end{proof}




\subsection{Properties of Similar-Modulo- Nodes in Execution Trees}\label{subsec:PropertiesOfSimilarModuloNodes}
Next, we establish properties of  with respect to nodes
whose configuration tags and vertex tags are indistinguishable at all process automata
except one. The aforementioned relation between nodes is formalized as
the \emph{similar-modulo-} relation (where  is a location).
Intuitively, we say that node  is \emph{similar-modulo- to}  if
the only process automaton that can distinguish state  from state
 is the process automaton at . 
The formal definition follows.

Given two nodes  and  in  and a location ,
 is said to be \emph{similar-modulo- to}  (denoted )
if the following are true. 
\begin{enumerate}
\item .
\item For every location , the state of
        is the same in  and .
\item For every location , the state of  is the same in  and . 
\item For every pair of distinct locations ,
      the state of  is the same in  and . 
\item For every location , the contents of
      the queue in  in state  is a prefix of the contents
      of the queue in  in state .
\end{enumerate}

 Note that due to property 5, the  relation is not symmetric; that is,  does not imply . However, the relation is reflexive; that is,  for any node .

Also note that if , then the states of , , and  for all  may be different in  and . Furthermore, the states of  for all  may also be different in  and , but it is required that the messages in transit from  to  in state  form a prefix of the messages in transit from  to  in state .

We define a node  to be a \emph{post-} node, where  is a location,  if the following property is satisfied. If , then there are no vertices in  whose location is . Otherwise, there are no outgoing edges in  from  to any vertex whose location is . Note that if  contains any post- node, then  is not live in . Furthermore, if a node  in  is a post- node, and there exists a node  such that , then  is also a post- node.
 
 \begin{lemma}\label{lem:similarModuloChild}
 Let  and  be two post- nodes in  for some location  in , such that . Let  be any label, and let
  be an -child of . Then, one of the following is true: (1) , or (2) there exists an -child  of  such that  and  are post- nodes and .
\end{lemma}

\begin{proof}
 Fix , , , , and  as in the hypotheses of the lemma. Let  be the -edge from  to , and let  be the action tag of . 
 
 If , then by Lemma \ref{prop:botChild}, we know that  and . Therefore, , and the lemma is satisfied. For the remainder of this proof, we assume .
 
 Note that label  is an element of .
  
  \emph{Case 1.} . From the definition of a post- node, we know that there are no vertices with location  that have an incoming edge from  (). Therefore, from the construction of , we see that . In this case, we have already established that .
  
  \emph{Case 2.} . We know that there are no vertices with location  that have an incoming edge from , and therefore, . In this case, we have already established that .
  
For the remainder of the cases, let  be the -child of  connected to  by edge . Note that since , we know that .  


  
 \emph{Case 3.} . From the definition of the  relation, we know that the state of   is the same in states  and , and similarly, the state of  is the same in states  and . Therefore, . Consequently, the state of   is the same in  and , and the state of  is the same in  and . 
 
 Also, from the definition of the  relation, we know that for every location , the state of  is the same in  and . Therefore, from state , if  changes the state of  for some , then we know that the state of  is the same in  and . 
 
Thus, the states of all other automata in  are unchanged. We have already established that , and we can verify that .
 


\emph{Case 4.} . Since , we see that . Applying  to  and applying  to , and recalling that we have already established , we can verify that .

 
 \emph{Case 5.} Let  be  where  and . Recall that we have already established . 
 We consider three subcases: (a) , (b)  and , (c) .
 
 \emph{Case 5(a).} Let  be  where . Since the definition of  does not restrict the state of  or the state of the process automaton at , we see that .
 
 \emph{Case 5(b).} Let  be  where  and . From the definition of the  relation, we know that the state of  is the same in  and . Therefore, .
 
 Thus, we see that the state of  is the same in  and . Similarly, since  and , we see that the state of the process automaton at  is also the same in  and . The states of all other automata in  are unchanged.
 Thus, we can verify that .
 
 \emph{Case 5(c).} Let  be  where . 
 Since we have assumed ,  must be the action  for some message . From the definition of the  relation, we know that the queue of messages in  in state  is a prefix of the queue of messages in  in state , and the state of the process automaton at  is also the same in  and . Therefore, action  is enabled in state  , and  is in task ; therefore .
 
 Consequently, the queue of messages in  in state  is a prefix of the queue of messages in  in state . 
 Recall that the state of the process automaton at  is the same in  and . 
 Therefore, the state of the process automaton at  is the same in states  and . The states of all other automata in  are unchanged.
 Thus, we can verify that . Furthermore, note that by construction, if a node  is a post- node, then all its descendants are post- nodes. Therefore,  and  are post- nodes.
 \end{proof}


\begin{theorem}\label{thm:similarModuloDescendant}
 Let  and  be two post- nodes in  for some location  in  such that . For every descendant  of , there exists a descendant  of  such that  and  are post- nodes and .
\end{theorem}
\begin{proof}
 Fix , , and  as in the hypothesis of the lemma; thus,  and  are post- nodes and . The proof is by induction on the distance from  to .
 
 \emph{Base Case.} 
 Let the distance from  to  be . That is, . Trivially, we see that  satisfies the lemma.
 
 \emph{Inductive Hypothesis.} 
 For every descendant  of  at a distance  from , there exists a descendant  of  such that  and  are post- nodes and .
 
 \emph{Inductive Step.}
 Fix  to be a descendant of  at a distance  from . Let  be the parent of . Note that, by construction,  is a descendant of  at a distance  from . Let  be the label of edge  that connects  and .
 By the inductive hypothesis, there exists a descendant  of  such that  and  are post- nodes and .
  Invoking Lemma \ref{lem:similarModuloChild}, we know that at least one of the following is true. (1) . (2) there exists an -child  of  such that  and  are post- nodes and . In other words, there exists a descendant  of  such that   and  are post- nodes and .
 
 This completes the induction and the proof.
\end{proof}





\subsection{Properties of Task Trees from Different Observations}\label{subset:PropertiesOfTreesFromPrefixObservations}
Next, we present the properties of task trees from two observations  and , where  is a prefix of . Lemma \ref{lem:prefixObsYieldsSubtree} states that for every path in  that does not contain any edges with  action tags, a corresponding path of the same length with the same tags and labels on the corresponding nodes and edges exists in . Corollaries \ref{cor:prefixObsPrefixExe} and \ref{cor:NonBotExistsFromPrefix} state that for every node in , there exist nodes in  such that both nodes represent the same execution of the system . Lemma \ref{lem:UniqueNodeMappingFromPrefixObsToSuperObs} proves a stronger property about non- nodes; specifically, it shows that for every non- node in , there is a corresponding node, called a ``replica'', in  such that both the nodes have the identical paths from the  node in their respective execution trees.

Lemma \ref{lem:superObsYieldsSuperTree} states that for every path  in  such that the sequence of distinct non- vertex labels in  is a path in , there exists a corresponding path in  of the same length with the same tags and labels on the corresponding nodes and edges. 

We extend the result from Lemma \ref{lem:UniqueNodeMappingFromPrefixObsToSuperObs} to execution trees constructed from a sequence of observations, where each is a prefix of the next observation in the sequence; in Lemma \ref{lem:nodePersistsOneHop}, we show that non- nodes persist from one execution tree to the next, and in Lemma \ref{lem:nodePersistsForEver}, we show that they persist in an infinite suffix of the execution trees. 

\begin{lemma}\label{lem:prefixObsYieldsSubtree}
Let an observation  be a prefix of an observation . Fix any path  in  that starts at the root node and does not contain edges with  action tags. Let the length of  be  edges. Then there exists a ``corresponding'' path  in  of length  such that the following is true. 
(1) For every positive integer , let  be the -th node in  and let  be the -th node in . Then the tags of  are identical to the tags of . (2) For any positive integer , let  be the -th edge in , and let  be the -th edge in . Then the tags and labels of  are identical to the tags and labels of .
\end{lemma}
\begin{proof}
Fix  and  as in the hypothesis of the lemma. The proof follows from a simple induction on the length  of path .

\emph{Base case.} . There exists a single path  consisting of  edges that starts at the root node of . Let  be the root node of  with vertex tag  and config tag  is the start state of  system . Similarly, there exists a single path  consisting of  edges that starts at the root node of  and contains no edges.  is the root node of  with vertex tag  and config tag  is the start state of  system .

\emph{Inductive hypothesis.} For some non-negative integer , for every path  consisting of  edges in  that starts at the root node and does not contain edges with  action tags. Then there exists a ``corresponding'' path  in  consisting of  edges such that the following is true. 
(1) For every positive integer , let  be the -th node in  and let  be the -th node in . Then the tags of  are identical to the tags of . (2) For any positive integer , let  be the -th edge in , and let  be the -th edge in . Then the tags and labels of  are identical to the tags and labels of .

\emph{Inductive step.} Fix any path  consisting of  edges that starts at the root node of  and does not contain edges with  action tags. Let  be the prefix of  that consists of  edges. By the inductive hypotheses, there exists a ``corresponding'' path  in  consisting of  edges such that the following is true. 
(1) For every positive integer , let  be the -th node in  and let  be the -th node in . Then the tags of  are identical to the tags of . (2) For any positive integer , let  be the -th edge in , and let  be the -th edge in . Then the tags and labels of  are identical to the tags and labels of .

The last node of  and  are  and , respectively. By the inductive hypotheses,  and . Consider the node  that is the last node of path . By construction, there is an edge  from  to , and furthermore, . Let the label of  be . Note that either (1)  is of the form , or (2)  is a task in system . We consider each case separately.

\emph{Case 1.}  is of the form . Since , we know from the construction of the task tree that the vertex tags ,  is of the form , where  is a location and  is a positive integer. Furthermore, we know that  is a vertex in ', and either (a)  or (b)  contains an edge from  to . 
From the inductive hypothesis we know that . Since  is a prefix of , we know that  contains the vertex . 

If , then . Otherwise,  contains an edge from  to , and since  is a prefix of ,  contains an edge from  to .
In both cases, we see that, from the construction of the task tree,  contains an -edge  from  to a node  such that  and . From the inductive hypothesis, we know that .  Since  is obtained by applying  to , and  is obtained by applying  to , we see that .

\emph{Case 2.} . Since , , and the system is task deterministic, we know that there exists an outgoing  edge  from  to a node  such that . Since  is obtained by applying  to , and  is obtained by applying  to , we see that . Also, by construction,  and ; therefore,  and .

Therefore, in all cases there exists an -edge  of  to a node  in  such that  the tags  of  and  are identical, and the tags and labels of  and  are identical. Recall that  is an -edge from  to .


Recall that  is a path consisting of  edges whose prefix is path  consisting of  edges starting from the root node in   and does not contain edges with  action tags, and  is a path consisting of  edges starting from the root node in   and does not contain edges with  action tags. Furthermore, the last node of  is  and the last node of  is . Also recall that, (1) for every positive integer , the tags of  are identical to the tags of , and (2) for every positive integer , the tags and labels of  are identical to the tags and labels of . Therefore, we extend  by edge  to obtain a path  such that the following is true.

(1) For every positive integer , let  be the -th node in  and let  be the -th node in . Then the tags of  are identical to the tags of . (2) For any positive integer , let  be the -th edge in , and let  be the -th edge in . Then the tags and labels of  are identical to the tags and labels of .

This completes the induction.
\end{proof}


\begin{corollary}\label{cor:prefixObsPrefixExe}
If an observation  is a prefix of an observation , then for every node  in , there exists a node  in  such that  and .
\end{corollary}
\begin{proof}
Fix a node  in . By Lemma \ref{lem:everyDescendantNoBot}, we know that there exists a node  in  such that  and , and the path from the root to  does not contain any edges with  action tag. Invoking Lemma \ref{lem:prefixObsYieldsSubtree}, we know that there exists a node  in  such that the path from the root to  in  and the path from root to  in  contain the same sequence of action tags and vertex tags. Therefore,  and . Therefore,  and .
\end{proof}



\begin{corollary}\label{cor:NonBotExistsFromPrefix}
If an observation  is a prefix of an observation , then for every node  in , there exists a non- node  in  such that  and .
\end{corollary}
\begin{proof}
Fix ,  and  as in the hypotheses of the corollary. Invoking Lemma \ref{cor:prefixObsPrefixExe}, we know there exists a node  in  such that  and . Invoking Corollary \ref{cor:NonBotNodesExist} on node , we know that there exists a non- node  in  such that  and . In other words, there exists a non- node  in  such that  and .
\end{proof}

\begin{lemma}\label{lem:UniqueNodeMappingFromPrefixObsToSuperObs}
If an observation  is a prefix of an observation , then for every node non- node  in , there exists a unique non- node  in  such that the sequence of labels and vertex tags of the edges from  to  in  is identical to the sequence of labels and vertex tags of the edges from  to  in .
\end{lemma}
\begin{proof}
Fix , , and  as in the hypothesis of the lemma. Applying Lemma \ref{lem:prefixObsYieldsSubtree} to the path in  from  to  we conclude at least one non- node  in  such that the sequence of labels and vertex tags of the edges from  to  in  is identical to the sequence of labels and vertex tags of the edges from  to  in . Fix any such node . Applying Lemma \ref{lem:LabelsAndVertexAgsDenoteUniqueNode} to , we conclude that  is unique.
\end{proof}

\begin{lemma}\label{lem:superObsYieldsSuperTree}
Let an observation  be a prefix of an observation . Fix any path  in  such that (1)  starts at the root node and (2) the sequence of distinct non- vertex tags in  is the sequence of vertices in some path in . Let the length of  be  edges. 
Then there exists a ``corresponding'' path  in  of length  such that the following is true. 
(1) For every positive integer , let  be the -th node in  and let  be the -th node in . Then the tags of  are identical to the tags of .
(2) For any positive integer , let  be the -th edge in , and let  be the -th edge in . Then the tags and labels of  are identical to the tags and labels of .
\end{lemma}
\begin{proof}
The proof follows from a simple induction on the length  of path . 
\end{proof}

Given any pair of observations  and  such that  is a prefix of , and given a non- node  in , we define the \emph{replica} of  from  in  to be the unique node  in  that satisfies Lemma  \ref{lem:UniqueNodeMappingFromPrefixObsToSuperObs}. We use this notion of a replica node to talk about a non- node ``persisting'' over task trees constructed from a sequence observations such that each observation in the sequence is a prefix of each succeeding observation.

Given a non- node  in a tree  and its replica  in a tree , since the sequence of labels and vertex tags of the edges from  to  in  is identical to the sequence of labels and vertex tags of the edges from  to  in , we refer to any non- node  and its replicas as .

Let  be an infinite sequence of finite observations such that (1) for any positive integer ,  is a prefix of , and (2) the sequence of observations converge to some observation .
\begin{lemma}\label{lem:nodePersistsOneHop}
Fix a positive integer  and suppose  is a non- node  . Then  contains .
\end{lemma}
\begin{proof}
Follows from Lemma \ref{lem:UniqueNodeMappingFromPrefixObsToSuperObs}.
\end{proof}

\begin{lemma}\label{lem:nodePersistsForEver}
Fix a positive integer  and suppose  is a non- node  . Then for any ,  contains .
\end{lemma}
\begin{proof}
The proof follows from a simple induction on .
\end{proof}
 
\subsection{Fair Branches of Execution Trees}\label{subset:FairBranchesOfExecutionTrees}




In this subsection, we define fair branches of execution trees, and we establish the correspondence between fair branches
in the execution trees and fair traces of system .\footnote{Recall that  consists of the process automata, the environment automaton, and the the channel automata.} 

We define a branch of an infinite task tree  of the observation  to be a \emph{fair branch} if, for each label , the branch contains an infinite number of edges labeled . Therefore, a fair branch satisfies the following properties. 
\begin{lemma}\label{lem:fairTreeBranchProperties}
For each location , and each fair branch  of , the following are true.
\begin{enumerate}
\item Branch  contains infinitely many ,  and  edges (for all ) (regardless of whether  is live or not live in ).
\item If  is live in , then (a) every  edge in  has a non- action tag and (b) some infinite subset of the  events contained in  occur in .\footnote{Note that  is not guaranteed to contain all the  events contained in .}
\item If  is not live in , then there exists a suffix of  such that the action tag of each , , and  edge (for all ) is .
\end{enumerate}
\end{lemma}
For any location  and fair branch  of ,  may contain a  or an  edge  such that  for either of two reasons. (1) If  is not live in , then it may be the case that there is no outgoing edge from  to any vertex whose location is . (2) There is no enabled action from the corresponding task in , where  is the node immediately preceding  in ; this is regardless of whether  is live in  or otherwise.






The main result of this subsection is Theorem \ref{thm:fairBranchFairExec}, which says that, if  is a strong-sampling AFD, then for any viable observation  of  and for every fair branch  in , (1) the projection of  on the actions of the system  corresponds to a fair trace of system , and (2) the projection of  on the AFD actions corresponds to a trace in .
We use  multiple helper lemmas to prove the main result, which we summarize after the following definitions.


 For the remainder of this section, fix  to be a strong-sampling AFD and fix  to be an infinite observation of . 
 Consider a branch  in ; since  is an infinite observation,  must also be of infinite length. Let the sequence of nodes in
 be  in that order. The sequence  is
the limit of the prefix-ordered infinite sequence ,
, , .\footnote{Note that we have 
  overloaded the function  to map both nodes and branches to sequences 
  of alternating states and actions. Since the domains of all the instances
  of the  function are disjoint, we can refer to  or    
  without any ambiguity.} Note that  may be a finite
or an infinite sequence.
Let  denote the trace of the execution .
Recall that for any node  in ,   denotes the maximal subtree of  rooted at .
  
In Lemma \ref{lem:fairBranchEventSequence}, we show that for any fair branch  in ,  is the event-sequence of some fair branch in . 
However, note that even if  is a fair branch of ,  need not be a fair execution of ; also, even if  is viable for , the projection of  on  need not be in . The primary reason for these limitations is that the tree  does not contain any  events. We rectify this omission  in Lemma \ref{lem:fairExe}; we insert  events in  to obtain a trace  of  such that  is a fair trace of , and if  is viable for , then  is compatible with .
Lemma \ref{lem:fairExe} implies Theorem \ref{thm:fairBranchFairExec}.


\begin{lemma}
\label{lem:fairBranchEventSequence}
For every fair branch  of ,  is the
event-sequence of some fair branch in .
\end{lemma}
\begin{proof}
Fix  to  be a fair branch of .
Let , where for each natural number ,  is a node in  and  is an edge with lower endpoint  in .
Applying Lemma \ref{prop:nodeFiniteExe}, we know that
for any positive integer , if , then  is the empty sequence, and otherwise,  ends with the event of 
. Note that since  is an infinite observation and  is a fair branch of , there exists a positive integer  such that for all , \footnote{
We know such a positive integer  exists for the following reason. Since  is an infinite observation,  has some live location . By Lemma \ref{lem:fairTreeBranchProperties}, we know that every  edge in  has a non- action tag, and this can happen only if for each  edge, the vertex tag of the node preceding that edge is not . Since  is a fair branch,  contains infinitely many such nodes; fix any such a node . By Lemma \ref{prop:FDchildVertexEdgeExists}, we know that for each descendant  of  in ,  is a vertex in  and therefore, .}.
Applying Lemma \ref{prop:ancesterPrefixAFDEvents}, we
know that for any positive integer ,  is a prefix of
. Therefore,  is the limit of the event-sequence of 
. By the construction of , this means that,  is the
event-sequence of some branch  in . It
remains to show that  is a fair branch in . 
Recall that  is a fair branch if for every location  that is live in ,  contains an infinite number of vertices whose location is .

Fix a location . Since  is a fair branch of , there are infinitely many edges in  whose
label is ; for each such -edge, applying Lemma
\ref{prop:liveLocationNonBotAction}, we know that the action tag of
the -edge is non-. Therefore, the sequence  contains infinitely many
vertices whose location is . Thus, by definition,  is a fair branch
in . Therefore,  is the event-sequence of , which is a fair
branch in .
\end{proof}


Next, we assume that  is a viable observation for . 
In Lemma \ref{lem:fairExe}, for each fair branch  of , we insert  events in  to get a trace  of the system  such that  and .

\begin{lemma}
\label{lem:fairExe}
For every fair branch  of , there exists a fair
execution   of the system  such that  and .
\end{lemma}

\begin{proof}
Fix a fair branch  of . Let , where for each natural number ,  is a node in  and  is an edge with lower endpoint  in .
By Lemma \ref{lem:fairBranchUnfairExe}, we know that  is an execution of system . 
We construct a new execution  of system  by starting with , and inserting  events as permitted by Lemma \ref{lem:addCrashAfterLastEvent}; we then define  to be an execution whose trace . In order to invoke Lemma \ref{lem:addCrashAfterLastEvent} we must ascertain the specific positions within  where we may insert  events. We determine these positions, by deriving a trace  such that the sequence of AFD output events in  is the projection of  on AFD output events. We then use the positions of  events in  to determine the positions in  where  events are inserted.

Recall that  is a viable observation for . By Lemma \ref{lem:fairBranchEventSequence}, we know that  is the event-sequence of some fair branch  in . Let  be compatible with , and we assume that  has no extra crashes.\footnote{Note that for any trace  that is compatible with , the trace  is also compatible with  and does not contain any extra crashes. So, it is reasonable to assume that  does not contain any extra crashes.}
By Lemma \ref{prop:sampledSubsequence}, we know that there exists  such that  is a strong sampling of  and  is the event sequence of . Fix such a trace . By construction,  and . Note that  does not contain any extra crashes.

For each location  that is not live in , let  be the earliest event from  that follows the  event in .

We construct  by iteratively applying Lemma \ref{lem:addCrashAfterLastEvent} to , once for each location  that is not live in , as follows. Starting with  , for each location  that is not live in , insert  immediately before event . If more than one crash event is inserted in the same position in , order these crash events in the order in which they appear in .
Let the trace, thus obtained, be . 

Note that by construction . Therefore,  is a strong sampling of . For each location  that is not live in , let vertex  be the vertex corresponding to event ; since  is a strong sampling of ,  precedes  in , and therefore, there are no edges from  to any vertex whose location is . Therefore, by construction of , for any node  whose vertex tag is , and for any outgoing -edge  from , . Therefore, by Lemma \ref{lem:crashedLocationNoOutgoingActions}, we know that for outgoing ,  and  edges from the descendants  of , their action tags are also . Therefore, in , for each location  that is not live in , there are no , , or  events following .
Therefore, starting with  and iteratively applying Lemma \ref{lem:addCrashAfterLastEvent} for each  event inserted, we conclude that there exists an execution  of  whose trace is .

It remains to show that (1)  and (2)  is a fair execution of . We prove each part separately.

\emph{Claim 1.} .
\begin{proof}
Note that by construction  and therefore, .
\end{proof}






\emph{Claim 2.}
 is a fair execution of .

\begin{proof}
By construction,  is an execution of . In order to show that  is a fair execution of , we have to show the following. 
(a) If  is finite, then for each task ,  is not enabled in the final state of ; and (b) if  is infinite, then for each task ,  contains either infinitely many events from  or infinitely many occurrences of states in which  is not enabled. (Recall that  is the set of tasks in .)

\emph{Case (a)}  is finite. We show that this is impossible as follows. Assume for contradiction that  is finite. Since  is an infinite observation, there exists a location  such that there are infinitely many vertices in  whose location is . Since  is a fair branch of ,  we know that  contains infinitely many  edges. Applying Lemma \ref{prop:liveLocationNonBotAction}, we conclude that the action tag of each -edge in  is non-, and therefore,  is infinite. Therefore,  is infinite. Since  is obtained by inserting events into ,  is infinite, and consequently  is infinite. Thus, we have a contradiction.

\emph{Case (b)}  is infinite. For contradiction, assume that  is not a fair execution. Therefore, there must exist a task  such that   contains only finitely many events from  and only finitely many occurrences of states in which  is not enabled. Fix such an . We consider each possible value of .

\begin{itemize}
\item . From the construction of , we know that for each -edge  from a node  in , if some action  in  is enabled in , then . Furthermore, note that in any execution  of , if some action  in  is enabled in a state  of ,  remains enabled in the suffix of  following  until  occurs. By assumption, since there are only finitely many events from  in , and  (the trace of ) is constructed by inserting events into , it follows that in some infinite suffix of , for each node , no action from  is enabled in . Since inserting  events does not change the state of the channel automata, it follows that no action from  is enabled in some infinite suffix of . This contradicts our assumption that  contains only finitely many occurrences of states in which  is not enabled.

\item  . Fix the location of  to be . We consider two subcases: (i)  is not live in , and (ii)  is live in .
  \begin{itemize}
  \item  is not live in . By construction,  contains only finitely many -edges whose action tags are non-, and by construction of , we know that  contains a  event, following which there are no events from task . In other words,  contains only finitely many events from . However, recall that a  event disables all the actions from  forever thereafter. Therefore, in the suffix of  following a  event, no action from  is enabled. This contradicts our assumption that     contains only finitely many events from  and only finitely many occurrences of states in which  is not enabled.
  
  \item  is live in . Therefore  contains infinitely many vertices whose location is . Note that in , -edges occur infinitely often. By construction of the tree , we know that for each node  in  that immediately precedes an -edge , either  is not a vertex in  and  contains infinitely many vertices whose location is , or  has an outgoing edge to some vertex in  whose location is ; consequently, if some action in  is enabled in , then . Therefore, if  contains only finitely many events from , then it must have only finitely many occurrences of states in which  is enabled; in other words,  contains infinitely many occurrences of states in which  is not enabled. 
  
  By construction of , we know that  does not contain a  event. Since  (the trace of ) is obtained from  by inserting only  events and  does not contain any  events, we know that the projection of  on the states of  and  is equal to the projection of  on the states of  and . Therefore, if  contains infinitely many occurrences of states in which  is not enabled, then  contains infinitely many occurrences of states in which  is not enabled. Thus we have a contradiction.
  \end{itemize}
\end{itemize} 
Thus, we have proved that  is a fair execution of .
\end{proof}

The proof follows from Claims 1 and 2.
\end{proof}


\begin{theorem}\label{thm:fairBranchFairExec}
Let  be a strong-sampling AFD. Let  be a viable observation for .
For every fair branch  of , there exists a fair
trace  of  such that  and .
\end{theorem}



\begin{proof}
 Fix  and  as in the hypotheses of the theorem statement. The proof follows directly from Lemma \ref{lem:fairExe}.
\end{proof}




\section{Consensus Using Strong-Sampling AFDs}
\label{sec:consensusAndAFD}



In this section, we show how a strong-sampling AFD sufficient to solve 
crash-tolerant  consensus circumvents the impossibility of consensus
in asynchronous systems. We use this result in the next section to
demonstrate that  is a weakest strong-sampling AFD to
solve -crash-tolerant binary consensus, which is defined next.



\subsection{Crash-Tolerant Binary Consensus}
\label{subsec:consensusDef} 

For any   in , the \emph{-crash-tolerant binary consensus} problem  is specified as follows. The set  is , and the set  is . Before defining the set of sequences , we provide the following auxiliary definitions. 

Let  be an arbitrary (finite or infinite) sequence over . The following definitions apply to the sequence . 

\paragraph{Decision value.} If an event  occurs for some  in sequence , then  is said to be a \emph{decision value} of . 


\paragraph{Environment well-formedness:} 
The \emph{environment well-formedness} property states that (1) the environment provides each location with 
at most one input value, (2) the environment does not provide any input values at a location after a crash event at that location, and (3) the environment provides each live location with exactly one input value. 
Precisely, (1) for each location 
at most one event from the set  occurs in , (2) for each location  no event from the set  follows a  event in , and (3) for each location  exactly one event from the set  occurs in .

\paragraph{-crash limitation:} The \emph{-crash limitation} property states that at most  locations crash. Precisely, there exist at most  locations  such that  occurs in . 

\paragraph{Crash validity:} The \emph{crash validity} property states that no location decides after crashing.  That is, for every location , no event from the set  follows a  event in .

\paragraph{Agreement:} The \emph{agreement} property states that no two locations decide differently. That is, if two events  and  occur in , then . 

\paragraph{Validity:} The \emph{validity} property states that any decision value at any location must be an input value at some location. That is, for each location , if an event  occurs in , then there exists a location  such that the event  occurs in . 


\paragraph{Termination:} The \emph{termination} property states that each location decides at most once, and each live location decides exactly once. That is, for each location , at most one event from the set  occurs in , and for each location , exactly one event from the set  occurs in . 


Using the above definitions, we define the set  for -crash-tolerant binary consensus as follows.

\paragraph{The set .}  is the set of all sequences  over  such that, if  satisfies  environment well-formedness and -crash limitation,
then  satisfies crash validity, agreement, validity, and termination. Note that  contains all the sequences over  in which more than  locations crash; informally, -crash-tolerant consensus provides no guarantees if more than  locations crash.


\subsection{A Well-formed Environment Automaton for Consensus}\label{subsec:conEnvDef}
Given an environment automaton  whose set of input actions is  and set of output actions is ,  is said to be a \emph{well-formed environment} iff every fair trace  of  satisfies environment well-formedness. For our purpose, we assume a specific well-formed environment  defined next.


The automaton  is a composition of  automata . Each automaton  has two output actions  and , three input actions , , and , and no internal actions. Each output action constitutes a separate task. Action , where , permanently disables actions  and . The  input action disables  actions  and . The automaton  is shown in Algorithm \ref{alg:ConsensusEnv}.

Next, we show that  is a well-formed environment automaton. Observe that the automaton  satisfies the following Lemma.



\begin{algorithm}\footnotesize
\caption{Automaton , where . The composition of  constitutes the environment automaton  for consensus.}
\label{alg:ConsensusEnv}

\textbf{Signature:}

\tab input , , 

\tab output , 

\textbf{Variables:}

\tab : Boolean, initially 


\textbf{Actions:}

\tab input 

\tab effect

\tab \tab  := 

\tab

\tab input , 

\tab effect

\tab \tab *none*

\tab

\tab output , 

\tab precondition

\tab \tab 

\tab effect

\tab \tab  := 

\tab

\textbf{Tasks:}

\tab , 

\end{algorithm}



Note that for each location , each action  (where  and ) in  constitutes a separate task  in .

\begin{lemma}\label{prop:proposeDisables}
 In , action  (where  and ) permanently disables the actions  and .
\end{lemma}
\begin{proof}
 Fix  and . From the pseudocode in Algorithm \ref{alg:ConsensusEnv}, we know that the precondition for actions  and  is . We also see that the effect of action  is to set  to . Thus, the Lemma follows.
\end{proof}

\begin{theorem}\label{thm:environmentWellFormed}
 Automaton  is a well-formed environment.
\end{theorem}
\begin{proof}
 To establish the theorem, we have to prove the following three claims for every fair trace  of . (1) For each location , at most one event from the set  occurs in . (2) For each location , no event from the set  follows a  event in . (3) For each location , exactly one event from the set  occurs in .
 
 \textit{Claim 1.} For each location , at most one event from the set  occurs in .
 \begin{proof}
 Fix .
 If no event from  occurs in , then the claim is satisfied. For the remainder of the proof of this claim, assume some event from  occurs in ; let  be the earliest such event. Let  be the prefix of  that ends with . After event  occurs, we know from Lemma \ref{prop:proposeDisables} that  disables all actions in  . Therefore, the suffix of  following , no event from  occurs.
 \end{proof}
 
 \textit{Claim 2.} For each location , no event from the set  follows a  event in .
 \begin{proof}
 Fix  to be a location in . From the pseudocode in Algorithm \ref{alg:ConsensusEnv}, we know that action  sets  to . Furthermore, no action sets  to . Also, observe that the precondition for actions in   is . Therefore, actions in  do not follow a  event in .
 \end{proof}
 
 \textit{Claim 3.}
 For each location , exactly one event from the set  occurs in .
 
 \begin{proof}
 Fix  to be a location in .  In Algorithm \ref{alg:ConsensusEnv}, we see that  is initially , and is not set to true until either  occurs or an event from  occurs. Since , we know that  does not occur in .
 Since  is a fair trace, actions in  remain enabled until one of the actions occur. After one event from  occurs, from Claim 1, we know that no more events from  occur.
 \end{proof}
 
 The theorem follows from Claims 1, 2, and 3.
\end{proof}

\subsection{System Definition}
\label{subsec:consensusSystem}

For the remainder of this section, fix a strong-sampling AFD , a distributed algorithm , and a natural number  () such that  solves -crash-tolerant
binary consensus using AFD  in environment .
Let  be a system that is composed of distributed
algorithm , channel automata, and the well-formed environment
automaton .

Based on the properties of -crash-tolerant binary consensus and
system , we have the following Lemma which
restricts the number of decision values in an execution of
.



\begin{lemma}
\label{lem:fairExecExactlyOneDecision}
For every
 fair execution  of , where
 and 
satisfies -crash-limitation,  has exactly
one decision value.
\end{lemma}





\begin{proof}
Fix  to be a fair execution of  such that
 and 
satisfies -crash-limitation. Recall that  consists of
a distributed algorithm  that solves -crash-tolerant binary
consensus using AFD , the channel automata, and
. Since , we know
from the definition of ``solving a problem using an AFD'' that
.


Recall that  is the set of all sequences  over 
such that if  satisfies environment well-formedness and -crash
limitation, then  satisfies crash validity, agreement, validity,
and termination. We assumed that  satisfies
-crash limitation.

From Theorem \ref{thm:environmentWellFormed}, we know that
 is a well-formed environment. Therefore,  satisfies environment well-formedness. Consequently,
 satisfies agreement and termination. By the
agreement property we know that  contains at
most one decision value. Since , we know that there is at least one location for which no crash event occurs, and therefore, by the
termination property, we know that at least one location decides. In
other words,   has exactly one decision value.
\end{proof}

\subsection{Trees of Executions}\label{subsec:consensusTree}
For the remainder of this section, fix  to be an arbitrary
viable observation of  such that at most  locations are not
live in . Recall the construction of the execution trees from Section \ref{subsec:treeOfExec}; construct
the tree  for system . 

The primary reasons for fixing  to be a viable observation are the following. Lemmas \ref{prop:fairBranchOneDecision}, \ref{prop:eachNodeAtMostOneDecision}, and \ref{prop:eachNodeAtMostOneDecisionInAllGs}, which talk about possible decision values in branches of , are true only for viable observations. Furthermore, the notion of ``valence'' defined in Section \ref{subsec:valence} is applicable only when Lemmas \ref{prop:fairBranchOneDecision}, \ref{prop:eachNodeAtMostOneDecision}, and \ref{prop:eachNodeAtMostOneDecisionInAllGs} hold, and consequently, ``valence'' makes sense only for viable observations. Since the rest of Section \ref{sec:consensusAndAFD} discusses the properties of branches of the execution trees and their valences, we must fix  to be a viable observation for the remainder of the section.



Since  is a viable observation of , by definition, there exists a trace  such that
 is the event sequence of some topological ordering of the
vertices in . Fix such a trace  for the remainder of this section.

The set  of labels in   is . 

Recall from Section \ref{subsec:consensusDef} that in any sequence 
over , if an event  occurs, then  is
said to be a decision value of . We extend this definition to
arbitrary sequences; for any sequence , if  contains an element
 (where  and ), then  is
said to be a \emph{decision value} of .

The next Lemma follows immediately from Theorem \ref{thm:fairBranchFairExec} and Lemma \ref{lem:fairExecExactlyOneDecision}.
\begin{lemma}\label{prop:fairBranchOneDecision}
 For each fair branch  in ,  has exactly one decision value.
\end{lemma}
\begin{proof}
Fix a fair branch  in . Invoking Theorem \ref{thm:fairBranchFairExec}, we know that there exists a fair trace  of  such that  and . Let  be an execution of  whose trace is , and let . Since , we know that . Invoking Lemma \ref{lem:fairBranchUnfairExe}, we know that  is the event-sequence of some fair branch in . Therefore,  is the event-sequence of some fair branch in .
 
Since at most  locations are not live in , there are at most  locations  such that  has only finitely many events from . Since , we know that  has at most  locations that are not live in . Recall that , and therefore, there are at most  locations that are not live in . In other words,  
satisfies -crash-limitation. Thus, invoking Lemma \ref{lem:fairExecExactlyOneDecision}, we know that  has exactly one decision value. Since , we know that , and therefore , has exactly one decision value.
\end{proof}
\begin{lemma}\label{prop:eachNodeAtMostOneDecision}
 For each node  in ,  has at most one decision value.
\end{lemma}
\begin{proof}
Fix node  of . Fix  to be a fair branch that contains node . By construction  is a prefix of . Invoking Lemma \ref{prop:fairBranchOneDecision} yields that  has exactly one decision value. Therefore,  must have at most one decision value.
\end{proof}

Fix a convergent sequence of finite observations  that converge to ; that is, for each positive integer ,  is a prefix of , and . Construct the sequence of trees  for system 


\begin{lemma}\label{prop:eachNodeAtMostOneDecisionInAllGs}
 For each observation , for each node  in ,  has at most one decision value.
\end{lemma}
\begin{proof}
Fix an observation  and a node  as in the hypothesis of the lemma. For contraction, assume that  has more than one decision value.

Recall that every observation in  is a prefix of , and therefore,  is a prefix of . Therefore, by Lemma \ref{cor:NonBotExistsFromPrefix}, we know that  has a node  such that . Since  has more than one decision value,  must also have more than one decision value. However, this contradicts Lemma \ref{prop:eachNodeAtMostOneDecision}.
\end{proof}


\subsection{Valence}\label{subsec:valence}

For any arbitrary observation  and any arbitrary node  in , we define the notion of ``valence" as follows. From Lemma
\ref{prop:nodeFiniteExe}, we know that  is a finite execution
of system . Node  is said to be \emph{bivalent} in  if
there exist two descendants  and  of  such that
 has a decision value  and  has a decision
value ; recall from Lemma
\ref{prop:eachNodeAtMostOneDecisionInAllGs} that every node has at most one
decision value.  Similarly,  is said to be -valent in  if there exists a descendant
 of  such that  is a decision value of , and for
every descendant  of , it is not the case that  is a
decision value of . If  is either -valent or
-valent, then it is said to be \emph{univalent}.

\subsubsection{Valence of nodes in execution trees of }
Here we show the following properties related to valence for any arbitrary observation  and any arbitrary node  in . If  is bivalent in , then it does not have a decision value (Lemma \ref{prop:bivalentNoDecisionValue}). If a non- node  is bivalent in  for some , then for all ,  remains a non- bivalent node in  and in  (Lemma \ref{lem:bivalentNodeStableInNextG} and Corollaries  \ref{cor:bivalentNodeStableInNextG} and \ref{cor:bivalentNodeStableInAllGs}). If a non- node  is bivalent in , then for some positive integer  and all ,  remains a non- bivalent node in  (Lemma \ref{lem:bivalentNodeFiniteTimeInAllGs} and Corollary \ref{cor:bivalentNodeFiniteTimeInAllGs}). Finally, if a non- node  is univalent in , then for some positive integer  and all ,  remains a non- univalent node in  (Lemma \ref{lem:univalentNodeFiniteTimeInAllGs}).



\begin{lemma}\label{prop:bivalentNoDecisionValue}
 Fix  to be an arbitrary observation in . Then, for every bivalent node  in ,  does not have a decision value in .
\end{lemma}
\begin{proof}
Fix  be a bivalent node in . By Lemma
\ref{prop:eachNodeAtMostOneDecisionInAllGs},  has at most one
decision value. For contradiction, let  have a decision value
(say) . Then, every descendant  of  also has exactly one decision
value . However, since  is bivalent, some descendant  of  must
have a decision value . Thus, we have a contradiction.
\end{proof}

Applying Lemma \ref{lem:nodePersistsForEver} to the sequence , we conclude the following. For each positive integer , for each non- node  in , for each positive integer ,  contains node .

\begin{lemma}\label{lem:bivalentNodeStableInNextG}
For each positive integer , if a non- node  is bivalent in , then  node  in  is a non- node and is bivalent.
\end{lemma}
\begin{proof}
Fix  and  as in the hypotheses of the lemma.  
Since  is bivalent, there exists some descendant  of  in  such that the decision value of  is , and there exists some descendant  of  in  such that the decision value of  is . Applying Lemma \ref{cor:NonBotNodesExist}, we know that there exist descendants  and  such that decision value of  is , and the decision value of  is , and in the paths from  to  and from  to , there is no edge whose action tag is . In other words,  and  are non- nodes. 

Thus, in , the path from root to , from root to , and from root to  does not contain any edge whose action tag is . Recall that  is a prefix of . 
Applying Lemma \ref{lem:prefixObsYieldsSubtree}, we know that  contains the non- nodes , , and . That is, node  in  is bivalent.
\end{proof}

\begin{corollary}\label{cor:bivalentNodeStableInNextG}
For each positive integer , if a non- node  is bivalent in , then for all positive integers , node  in  is a non- node and is bivalent.
\end{corollary}
\begin{proof}
The Corollary is an inductive extension of Lemma \ref{lem:bivalentNodeStableInNextG}, where the induction is on .
\end{proof}

\begin{corollary}\label{cor:bivalentNodeStableInAllGs}
For each positive integer , if a non- node  is bivalent in , then  is a non- node and is bivalent in .
\end{corollary}

\begin{lemma}\label{lem:bivalentNodeFiniteTimeInAllGs}
If a non- node  is bivalent in , then there exists a positive integer  such that  is a non- node and is bivalent in .
\end{lemma}
\begin{proof}
Fix  as in the hypotheses of the lemma. Since  is bivalent in , there exist descendants  and  of  such that  has a decision value  and  has a decision value  in . 

Let  be the depth of node  in , and let  be the depth of node  in . Let  denote . Since  is the limit of  as  tends to , we know that there exists a positive integer  such that  contains vertices  and . Since  is live in , there exists a positive integer  such that  contains at least  vertices. Let  be , and therefore,  both  and  are prefixes of . Therefore,  contains vertices  and ; therefore,  contains at least  vertices, and hence, the sequence of distinct non- vertex tags in the paths from the root to  and from the root to  in  is also a path in . By Lemma \ref{lem:superObsYieldsSuperTree}, we know that  contains nodes , , and . Furthermore, we conclude that  is bivalent in .
\end{proof}

\begin{corollary}\label{cor:bivalentNodeFiniteTimeInAllGs}
For each non- bivalent node  in , there exists a positive integer  such that for all positive integers , node  is non- bivalent in .
\end{corollary}
\begin{proof}
Fix  as in the hypothesis of the corollary. From Lemma \ref{lem:bivalentNodeFiniteTimeInAllGs} , we know that there exists a positive integer  such that  is a non- bivalent node in . For any , we know that 
 is a prefix of .
Applying Lemma \ref{lem:prefixObsYieldsSubtree}, we conclude that  is a non- bivalent node in .
\end{proof}

\begin{lemma}\label{lem:univalentNodeFiniteTimeInAllGs}
If a node  is univalent in , then there exists a positive integer  such that for all positive integers , node  is univalent in .
\end{lemma}
\begin{proof}
Fix  as in the hypotheses of the lemma. Let  be -valent for some .
Let  be the smallest positive integer such that there exists some some descendant  of  in  such that  is at depth  and  has a decision value . Since  is -valent, we know that  exists. 

Let  be the smallest positive integer such that the following is true. (1)  contains the vertices  and . (2) For each location  that is live in ,  contains at least  vertices whose location is . (3) For each location  that is not live in , the set of vertices of  whose location is  is identical to the set of vertices of  whose location is . Therefore, the sequence of distinct non- vertex tags in the paths from the root to  is also a path in .

Fix a positive integer . Recall that  is a prefix of , and invoking Lemma \ref{lem:superObsYieldsSuperTree}, we know that  contains nodes , and .


Note that since  is -valent in , there exists no descendant  of  such that  has a decision value . By the contrapositive of  Corollary \ref{cor:prefixObsPrefixExe}, we know that  does not contain any descendant  of  such that  has a decision value . By definition,  is -valent in .
\end{proof}

\subsubsection{Valence of nodes in }

Now consider only the viable observation . For every fair branch  in , we know from Lemma
\ref{prop:fairBranchOneDecision} that  has exactly one
decision value. Since every node  is a node in some fair branch
, we conclude the following.

\begin{lemma}\label{prop:everyNodeIsBiOrUnivalent}
 Every node  in  is either bivalent or univalent.
\end{lemma}








\begin{lemma}\label{prop:initialBivalent}
 The root node , of , is bivalent.
\end{lemma}
\begin{proof}
Let .
Note that by construction there exists a path  of edges from . Let  be a fair path that contains  as its prefix. By Lemma \ref{prop:fairBranchOneDecision}, we know  contains a single decision value. By Theorem \ref{thm:fairBranchFairExec}, we know that there exists a fair trace  of  such that  . By the validity property we know that the decision value of  must be .

Similar to the above construction, there exists a path  of edges from . Let  be a fair path whose prefix is . By Lemma \ref{prop:fairBranchOneDecision}, we know  contains a single decision value. By Theorem \ref{thm:fairBranchFairExec}, we know that there exists a fair trace  of  such that  . By the validity property we know that the decision value of  must be .

In other words,  contains two nodes  (in ) and  () such that  has a decision value  and  has a decision value . By definition,  is bivalent.
\end{proof}
Based on the properties of the -crash-tolerant binary consensus
problem, we have the following lemma.

\begin{lemma}\label{lem:univalentDescendentIsUnivalent}
For each node  in , if  is -valent, then for
every descendant  of ,  is also -valent.
\end{lemma}
\begin{proof}
Fix  and  as in the hypothesis of the lemma. Let  be an arbitrary descendant of . By construction, every descendant of  is also a descendant of . Since  is -valent, for every descendant  of , it not the case that  is the decision value of ; therefore, for every descendant  of , it not the case that  is the decision value of . Fix some fair branch  in  that contains the node . By Lemma \ref{prop:fairBranchOneDecision}, we know that  has exactly one decision value. Let  be a node in  that occurs after  such that  has a decision value. We have already established that this decision value cannot be ; therefore the decision value must be . In other words,  is -valent.
\end{proof}

\subsection{Gadgets}
Consider the system , which
consists of a distributed algorithm , the channel automata, and the environment automaton  such that solves -crash-tolerant
consensus using  in . In this section, we define ``gadgets" and ``decision gadgets", which are structures within  that demonstrate how executions
of a system  evolve from being bivalent to becoming
univalent.



A \emph{gadget} is a tuple of the form  or , where  is a node,  and  are distinct labels, , , , and  are edges, such that the following properties are satisfied.
\begin{enumerate}
\item  and  are -edges of .
 \item  is an -edge of .
 \item  is an -edge of , where  is the node to which  is the incoming edge.
\end{enumerate}

Let  be a decision gadget; , which is either of the form  or of the form , said to be a \emph{non- gadget} if  is a non- node.\footnote{Recall that a node  is a non- node iff the path from  to node  in  does not contain an edge whose action tag is .}

 A gadget is said to be a \emph{decision gadget} iff the gadget is either a ``fork'' or a ``hook'': Section \ref{subsubsec:ForkProperties} defines a ``fork'' and establishes properties of a fork, Section \ref{subsubsec:HookProperties} defined a ``hook'' and the establishes properties of a hook.   In both cases, we show that a decision gadget must have what we call a ``critical location", which is guaranteed to be live in G.










\subsubsection{Forks}
\label{subsubsec:ForkProperties}

In the tree , a \emph{fork} is a gadget  such that the following are true.
\begin{enumerate}
 \item  is bivalent.
 \item For some , the lower endpoint  of  is -valent and the lower endpoint  of  is -valent.
\end{enumerate}
 
 \begin{lemma}\label{lem:forkTaskFD}
For every fork  in , .
\end{lemma}
\begin{proof}
Fix a fork  in . 
From the construction of , we know that for each label  in , node  has exactly one -edge. For each label  in , node  has at least one -edge. Therefore, .
\end{proof}


Any fork  in  satisfies three properties: (1) the action tags  and  are not , (2) the locations of the action tags  and  are the same location (say) , and (3) location , called the \emph{critical location} of the hook, must be live in . We prove each property separately.

For the remainder of this subsection fix a fork  from ,;we use the following convention from the definition of a fork:  denotes the -child of  connected by the edge , and  denotes the -child of  connected by the edge .

\begin{lemma}\label{lem:forkEventTagsNotBot}
The action tags  and  are not .
\end{lemma}
\begin{proof}
Without loss of generality, assume, for contradiction, that the action tag  is . 
From Lemma \ref{lem:forkTaskFD}, we know ; fix a location  such that . 
From the definition of a fork we know that  has at least two  edges. 
From the construction of , we know that an -edge of  has an action tag  iff either  has no vertices whose location is  or  has no outgoing edge in  to a vertex whose location is . In both cases,  has exactly one  edge. However, this contradicts our earlier conclusion that  has at least two  edges.
\end{proof}

\begin{lemma}\label{thm:forkSameCriticalProcess}
The locations of the action tags  and  are the same.
\end{lemma}
\begin{proof}
Note that for any label , the actions associated with  occur in a single location. Since  and  have the same label , and from Lemma \ref{lem:forkEventTagsNotBot} we know that the action tags  and  are not , we conclude that the location of  and  must be the same location.
\end{proof}

Next, we present the third property of a fork. Before stating this property, we have to define a \emph{critical location} of a fork. The \emph{critical location} of the fork  is the location of  and ; from Lemma \ref{thm:forkSameCriticalProcess}, we know that this is well-defined.

Next, we show that the critical location of the fork  must be live. We use the following helper lemma.

\begin{lemma}\label{lem:forkSimilarModuloCriticalLocation}
, where  is the critical location of .
\end{lemma}
\begin{proof}
By construction, the following is true of states of automata in system . For each location , the state of the process automaton  is the same in states  and ; similarly, the state of the environment automaton  is the same in states  and . For every pair of distinct locations , the state of the channel automaton  is the same in states  and . Therefore, we conclude that .
\end{proof}


\begin{lemma}\label{thm:forkCriticalProcessCorrect}
The critical location of  is in .
\end{lemma}
\begin{proof}
 Let  be the critical location of . Applying Lemma \ref{lem:forkTaskFD} we conclude that  is . Since  and  are -children of , we note that the states of all automata in system  in states  and  are the same, except for the state of the process automaton at . Recall that  and  are the vertex tags of  and , respectively. From Lemma \ref{lem:forkEventTagsNotBot} we know that the action tags  and  are not . Therefore,  and  are vertices in .
Note that  is -valent for some  and  is -valent. In order to show that  is in , we have to show that  contains infinitely many vertices whose location is .


For contradiction assume that the critical location  of  is not in . Then by definition,  contains only finitely many vertices whose location is . 
Recall that  is a viable observation of  such that at most  locations are not live in . Since ,
we conclude that at least one location is live in . Fix such a location .

From Lemma \ref{prop:outgoingEdgesToCrashedVertices} we know that there exists a positive integer  such that for every positive integer , there is no edge from any vertex of the form  to any vertex whose location is . Fix such a positive integer , and fix the corresponding vertex .

From Lemma \ref{prop:outgoingEdgesToLiveVertices}, we know that there exists a positive integer  such that there are outgoing edges from  and  to a vertex ; fix such a vertex .

From the construction of , we know that there exist -edges  and  from  and , respectively, whose action tag is  and vertex tag is . Let  and  be the -children of  and , respectively, connected to their parent by edges  and , respectively. By construction, . 



By Lemma \ref{lem:forkSimilarModuloCriticalLocation} we know that . Since the action tags of  and  are the same, we conclude that the states of all automata in system  in states  and  are the same, except for the state of the process automaton . Therefore, . We have already established that , and there are no outgoing edges from  to vertices whose location is . Thus, by definition,  and  are post- nodes\footnote{Recall from Section \ref{subsec:PropertiesOfSimilarModuloNodes} that a node  is a \emph{post-} node if the following property is satisfied. If , then there are no vertices in  whose location is . Otherwise, there are no outgoing edges in  from  to any vertex whose location is .}





Recall that  is -valent and  is -valent. Therefore, applying Lemma \ref{lem:univalentDescendentIsUnivalent}, we know that  is -valent and   is -valent. Let  be a fair branch of  that contains nodes ,  and .

Since  is bivalent, from Lemma \ref{prop:bivalentNoDecisionValue}, we know that  does not have a decision value. Since  is , we know that  and  do not have decision values. From Lemma \ref{prop:fairBranchOneDecision} we know that  has exactly one decision value, and since  is -valent, the decision value is . 
 That is, there exists an edge  and a node  such that  occurs in  after ,  is , and  is the node that precedes  in . 
 
  Since  and  are post- nodes, , and  is a descendant of , we apply Theorem \ref{thm:similarModuloDescendant} to conclude that there exists a descendant  of  such that . From the definition of  we know that the state of the process automaton at  is the same in  and . Since the action  is enabled at the process automaton at  in state , we know that action  is enabled in state . Therefore, the -child  of  has a decision value . However, since   is -valent and  is a descendant of , by Lemma \ref{lem:univalentDescendentIsUnivalent}, we know that  is -valent. Thus, we have contradiction.
\end{proof}






\subsubsection{Hooks}
\label{subsubsec:HookProperties}

In the tree , a \emph{hook} is a gadget  such that the following is true.
\begin{enumerate}
 \item  is bivalent.
 \item For some , the lower endpoint  of  is -valent and the lower endpoint  of  is -valent.  
\item .
\end{enumerate}


Any hook  in  satisfies three properties. (1) the action tags of  and  cannot be , (2) the locations of the action tags  and  must be the same location (say) , and (3) location , called the \emph{critical location} of the hook, must be live in . We prove each property separately.

For the remainder of this subsection, fix a hook  in ; we use the following convention from the definition of a hook:  denotes the -child of  connected by the edge ,  denotes the -child of  connected by the edge , and  denotes the -child of  connected by the edge .


\begin{lemma}\label{thm:hookEventTagsNotBot}
The action tags  and  are not .
\end{lemma}
\begin{proof} 
From the definition of a hook, we know that . It remains to show that .

For contradiction, assume  is .
Then, by construction,  and . Recall that  is bivalent and its descendant  is -valent. From the definition of valence, we know there exists a descendant  of  (and therefore a descendant of ) such that the decision value of  is .

 Applying Lemma \ref{lem:sameConfigSameExtensionLength} to  and , we know that there exists a descendant  of  such that the suffix of  following  is identical to the suffix of  following . Since   is bivalent, by Lemma \ref{prop:bivalentNoDecisionValue} it does not have a decision value; it follows that some event in the suffix of  following  must be of the form  (where ). Therefore, the decision value of  is . But since  is -valent, we have a contradiction. 
\end{proof}

\begin{lemma}\label{thm:sameCriticalProcess}
The locations of the action tags  and  are the same.
\end{lemma}

\begin{proof}
For the purpose of contradiction, we assume that the location  of the action tag  is different from the location  of the action tag ; that is, .
This assumption implies that  and . From Lemma \ref{thm:hookEventTagsNotBot}, we know that  and  are both enabled actions in state . 

A simple case analysis for all possible values of  and  (while noting that ) establishes the following. Extending  by applying  followed by  will yield the same final state as applying , followed by , to . Intuitively, the reason is that  and  occur at different locations, and therefore, may be applied in either order to  and result in the same final state. The above observation implies that  has an -edge  whose action tag  is the action ; let  be the -child of  connected by .
Observe that  and .


Recall that since  is a hook,  is -valent and  is -valent for some . Since  is a descendant of , by Lemma \ref{lem:univalentDescendentIsUnivalent},  is also -valent. Let  be a descendant of  such that  has a decision value . 
Applying Lemma \ref{lem:sameConfigSameExtensionLength},  we know that there exists a descendant  of  such that  and the suffix of  following  is identical to the suffix of  following .

Note that since  is bivalent, by Lemma \ref{prop:bivalentNoDecisionValue},  has no decision value.

\emph{Claim 1.}  is not a  action.
\begin{proof}
For contradiction, assume  is a  action. Since  contains the event  and  is -valent, it follows that  is a  action. However, recall that ,  contains the event ; therefore,  contains a  event. However,  is -valent. Thus, we have a contradiction.
\end{proof}

\emph{Claim 2.}  is not a decide action.
\begin{proof}
Similar to the proof of Claim 1.
\end{proof}

 From Claims 1 and 2, we know that for each of  's -edge, 's -edge, 's -edge, and 's -edge, their action tags cannot be a . Therefore, since  has a decision value , the suffix of  following  contains an event of the form . In other words, the suffix of  following  contains an event of the form . However, this is impossible because  is -valent.
\end{proof}



Next, we present the third property of a hook. Before stating this property, we have to define a \emph{critical location} of a hook. Given the hook , the \emph{critical location} of the hook is the location of  and ; from Lemma \ref{thm:sameCriticalProcess}, we know that this is well-defined. 

\begin{lemma}\label{thm:criticalProcessCorrect}
The critical location of  is in .
\end{lemma}

\begin{proof}
Note that  is -valent for some  and  is -valent. 
Let  be the critical location of the hook . 
In order to show that  is in , we have to show that  contains infinitely many vertices whose location is .

For the purpose of contradiction, we assume that  contains only finitely many vertices whose location is . Recall that  is a viable observation of  such that at most  locations are not live in . Since , we conclude that least one location is live in . Fix such a location .



From Lemma \ref{prop:outgoingEdgesToCrashedVertices} we know that there exists a positive integer  such that for each positive integers , there is no edge from any vertex of the form  to any vertex whose location is . Fix such a positive integer , and fix the corresponding vertex .

Next we fix a vertex  in  such that, roughly speaking, the event  of  is an event at  and ``occurs'' after the events of , ,  and after location  is ``crashed''; precisely,  is fixed as follows. Let  be ; that is,  is the maximal subset of  such that each vertex in  is a vertex  of . If  is non-empty, then from Lemma \ref{prop:outgoingEdgesToLiveVertices}, we know that there exists a positive integer  such that there are outgoing edges from each vertex in  to a vertex ; fix  to be such a vertex . If  is empty, then fix  to be any vertex in  of the form , where .

From the construction of , we know that there exist -edges , , and  from ,  and , respectively, whose action tag is  and vertex tag is . Let , , and  be the -children of ,  and , respectively, connected to their parent by edges ,  and , respectively. By construction, . See Fig. \ref{fig:extendPathsByFDEdges} for reference. 

Also recall that in  there is no edge from the vertex of the form  to any vertex whose location is , and since , we know that is no edge from  to any vertex whose location is . Therefore, , , and  are \emph{post-} nodes\footnote{Recall from Section \ref{subsec:PropertiesOfSimilarModuloNodes} that a node  is a \emph{post-} node if the following property is satisfied. If , then there are no vertices in  whose location is . Otherwise, there are no outgoing edges in  from  to any vertex whose location is .}.


\begin{figure}[hptb]
 \centering
\includegraphics[scale=0.4,page=4]{treefigs}
 \caption{This figure shows how the nodes , , and  are determined in the proof of Lemma \ref{thm:criticalProcessCorrect}.}
 \label{fig:extendPathsByFDEdges}
\end{figure}


Note that by construction, the following is true of states of automata in system . For each location , the state of the process automaton  is the same in states , , and ; similarly, the state of the environment automaton  is the same in states , , and . For every pair of distinct locations , the state of the channel automaton  is the same in states , , and . Finally, for every location , the messages in transit in the channel automaton  from  to  in state  is a prefix of the messages in transit in  in state  and in state . Therefore, we conclude that  and .

Recall that  is -valent and  is -valent. Therefore, applying Lemma \ref{lem:univalentDescendentIsUnivalent}, we know that  is -valent and   is -valent. Also recall that  is bivalent. 

Let  be a fair branch of  that contains nodes  and . 
By Lemma \ref{prop:fairBranchOneDecision}, we know that  has exactly one decision value (say) ; note that either  or . We consider each case.

\emph{Case 1.} . There exists an edge  in  such that, the action tag of  is . Let  be the node preceding  in . Note that  is descendant of . 
Recall that  and  are \emph{post-} nodes.
By Theorem \ref{thm:similarModuloDescendant}, we know that there exists a descendant  of  such that .

From the definition of  we know that the state of the process automaton at  is the same in  and . Since the action  is enabled at the process automaton at  in state , we know that action  is enabled in state . Therefore, the -child  of  has a decision value . However, since   is -valent and  is a descendant of , by Lemma \ref{lem:univalentDescendentIsUnivalent}, we know that  is -valent. Thus, we have a contradiction.

\emph{Case 2.} . This is analogous to Case 1 except that we replace   with .
\end{proof}

\subsubsection{Decision Gadgets}
Recall that a decision gadget is a gadget that is either a fork or a hook. We have seen that both forks and hooks contain a critical location that must be live in . 
Thus, we have seen that if a tree  contains a decision gadget, then we know that the critical location of that decision gadget must be live in . 



\subsection{Existence of a Decision Gadget} 
\label{subsubsec:existanceOfHook}
The previous subsection demonstrated interesting properties of decision gadgets in . However, it did not demonstrate that , in fact, does contain decision gadgets. We address this here.
Recall that  is viable for , and at most  locations are not live in .  
 



\begin{lemma}\label{lem:bivalentToMonovalent}
There exists a bivalent node  in tree  and a label  such that for every descendant  of  (including ), every -child of  is univalent.
\end{lemma}

\begin{proof}
 For contradiction, assume that for every bivalent node  in the tree , and every label , there exists a descendant  of , such that some -child of  is bivalent. 
Therefore, from any bivalent node  in the tree , we can choose any label  and find a descendant  of  such that (1)  is bivalent, and (2) the path between  and  contains an edge with label . 

Recall that the  node is bivalent (Lemma \ref{prop:initialBivalent}).  Applying Lemma \ref{prop:allLabelsExist}, we know that each node in  has an -edge for each label . Thus, by choosing labels in a round-robin fashion, we can construct a fair branch  starting from the  node such that every node in that branch is bivalent. Fix such a . We will use  to get a contradiction to the fact that the distributed algorithm  solves -crash-tolerant consensus. using .


By Theorem \ref{thm:fairBranchFairExec}, we know that there exists a fair trace  of  such that  and . Since  and , we know that at most  locations are not live in ; therefore,  satisfies -crash limitation. Let  be a fair execution of  whose trace is . Since  satisfies -crash limitation,  also satisfies -crash limitation. Invoking Lemma \ref{lem:fairExecExactlyOneDecision}, we know that  has exactly one decision value. Since , and  is the trace of , we know that  has exactly one decision value. In other words,  has exactly one decision value.  Therefore, there exists a node  in  such that  has a decision value. However, this contradicts our conclude that every node in  is bivalent.
\end{proof}






\begin{lemma}\label{lem:bivalentTo1ValentAnd0Valent}
 There exists a bivalent node  in tree , a descendant  of  (possibly  itself), a label , and  such that (1) 
 for every descendant  of , each -child of  is univalent, (2) some -child of  is -valent, and (3) some -child of  is -valent.
\end{lemma}
\begin{proof}
Invoking Lemma \ref{lem:bivalentToMonovalent}, we fix a pair  of node  and label  such that (1)  is bivalent, and (2) for every descendant  of  (including ), every -child of  is univalent. Let an -child of  be -valent for some . Since  is bivalent, there must exist some descendant  of  such that  has a decision value ; that is,  is -valent. By Lemma \ref{lem:univalentDescendentIsUnivalent}, it follows that any -child of  is -valent.
\end{proof}

\begin{lemma}\label{lem:hookExists}
 There exists a bivalent node  such that at least one of the following holds true. (1) There exists a label  and a pair of edges  and  such that  is a fork. (2) There exist a pair of labels  and edges ,, and  such that  is a hook. 
\end{lemma}
\begin{proof}
 Applying Lemma \ref{lem:bivalentTo1ValentAnd0Valent}, we know that there exists some node  in tree , a descendant  of , and a label  such that (1)  is bivalent, (2) for every descendant  of , every -child of  is univalent, (3) some -child of  (denoted )
is -valent, where , and (4) some -child of   (denoted )
is -valent.

Extend the path from  to  to  yielding a path . 
Let  be the first -edge on , let  be the upper endpoint of , and let  be the lower endpoint of . Thus, the path from  to  does not contain any -edge.
Note that following:  (1)  is a descendant of  and is -valent, (2)  is either  or a descendant of , and (3) by Lemma \ref{lem:bivalentTo1ValentAnd0Valent},  is univalent. Thus, we conclude that  is -valent. See Figure \ref{fig:hookExistence} for reference.

\begin{figure}[htpb]
 \centering
\includegraphics[scale=0.4,keepaspectratio=true,page=3]{treefigs}
 \caption{Construction that shows the existence of a ``fork'' or a ``hook'' in the proof for Lemma \ref{lem:hookExists}. }
 \label{fig:hookExistence}
\end{figure}





Note that for each node  from  to , each -child  of  is univalent. 
Recall that , which is an -child of  is -valent and , which is an -child of , is -valent. Therefore, there exists a label  and an -edge  from a node  to a node  in the path from  to  (inclusive) such that some -child  of  is -valent and some -child  of  is -valent. Let  denote the edge connecting  and . (See Figure \ref{fig:hookExistence}.)





We consider two cases: (1) , and (2)  .

(1) If , then by definition,  is a hook. 

(2) Otherwise, ; therefore,  and . Applying Lemma \ref{lem:sameConfigSameChild}, we know that there exists an -child   of  such that  and . Since  is -valent,  is also -valent. In other words,  has two -children  and , and  is -valent and  is -valent. 
Thus,  is a fork, where  is the edge from  to .
\end{proof}


Thus, we arrive at the main result of this section.


\begin{theorem}\label{thm:ViableGHasDecisionGadgets}
 For every observation  that is viable for  such that  contains at least  locations, the directed tree  contains at least one decision gadget. For each decision  gadget in , the critical location of the decision gadget is live in .
\end{theorem}
\begin{proof}
 Fix . From Lemma \ref{lem:hookExists}, we know that  has at least one decision gadget. For each decision gadget that is a fork, from Lemma \ref{thm:forkCriticalProcessCorrect} we know that the critical location of that decision gadget is live in , and for each decision gadget that is a hook, from Lemma \ref{thm:criticalProcessCorrect} we know that the critical location of that decision gadget is live in .
\end{proof}

\begin{theorem}\label{thm:ViableGHasNonBotDecisionGadgets}
For every observation  that is viable for  such that  contains at least  locations, the directed tree  contains at least one non- decision gadget.
\end{theorem}
\begin{proof}
Fix . From Theorem \ref{thm:ViableGHasDecisionGadgets} we know that  contains at least one decision gadget. Fix  to be such a decision gadget. Let node  be the first element in the tuple . Applying Corollary \ref{cor:NonBotNodesExist}, we know that there exists a non- node  such that , . Applying Lemma \ref{lem:everyDescendantNoBot} to the descendants of  and , we know that there exists a non- decision gadget  whose first element is .
\end{proof}


Theorem \ref{thm:ViableGHasNonBotDecisionGadgets} establishes an important property of any strong-sampling AFD that is sufficient to solve consensus. It demonstrates that in any fair execution of a system that solves consensus using an AFD, some prefix of the execution is bivalent whereas eventually, a longer prefix becomes univalent. The transition from a bivalent to a univalent execution must be the consequence of an event at a \emph{correct} location.


\subsection{Decision gadgets for execution trees in a convergent sequence of observations}
Recall that  is a viable observation of  such that at most  locations are not
live in ;  is a a trace that is compatible with . Finally,  is a sequence of observations that converge to . Next we show the ``persistence'' of non- decision gadgets across the sequence of execution trees .

\begin{lemma}\label{lem:decisionGadgetStableInAllGs}
Let  be a non- decision gadget in . There exists a positive integer  such that for all positive integers ,  is a non- decision gadget in .
\end{lemma}
\begin{proof}
Fix  to be a non- decision gadget in . We consider two cases: (1)  is a fork, and (2)  is a hook.

\emph{Case 1.} Let  be a fork  in . Let  be the -child of  whose incoming edge is , and let  be the -child of  whose incoming edge is . Let  be -valent, and let  be -valent for some . 

Invoking Corollary \ref{cor:bivalentNodeFiniteTimeInAllGs}, we know that there exists a positive integer  such that for all ,  is a non- bivalent node in .
Invoking Lemma \ref{lem:univalentNodeFiniteTimeInAllGs}, we know that there exists a positive integer  such that for all ,  is -valent and   is -valent in .
Let . By construction, for each ,  is a non- fork in .

\emph{Case 2.} Let  be a hook  in . Let  be the -child of  whose incoming edge is . Let  be the -child of  whose incoming edge is . Let  be the -child of  whose incoming edge is . Let  be -valent, and let  be -valent for some . 

Invoking Corollary \ref{cor:bivalentNodeFiniteTimeInAllGs}, we know that there exists a positive integer  such that for all ,  isa non-  bivalent node in . Invoking Lemma \ref{lem:univalentNodeFiniteTimeInAllGs}, we know that there exists a positive integer  such that for all ,  is -valent and   is -valent in .
Let . By construction, for each ,  is a non- hook in .
\end{proof}


\begin{lemma}\label{lem:nonDecisionGadgetStableInAllGs}
For each gadget  in  that is not a non- decision gadget, the following is true.
 There exists a positive integer  such that for all positive integers ,  is a gadget in , but  is not a non- decision gadget in .
\end{lemma}
\begin{proof}
Fix  as in the hypotheses of the lemma. Since  is a gadget in , by construction, there exists a positive integer  such that for all positive integers ,  is a gadget in . 

We consider two cases: (1)  is a tuple , and (2)  is a tuple .

\emph{Case 1.}  is a tuple . 
Let  and  be the nodes to which  and  are the incoming edges, respectively.
Since  is not a non- decision gadget, one of the following is true: (1) the path from root to  contains an edge with  action tag, (2)  is univalent,  or (3) at least one of  and  is bivalent in . 

If the path from root to  contains an edge with  action tag, then by Lemma \ref{lem:superObsYieldsSuperTree}, we know that  exists a positive integer  such that for every positive integer , the path from root to  contains an edge with  action tag in . Therefore,  cannot be a non- decision gadget in .


If  is univalent in , then by Lemma \ref{lem:univalentNodeFiniteTimeInAllGs}, we know that there exists a positive integer  such that for every positive integer ,  is univalent in . Therefore, for any positive integer ,  cannot be a decision gadget in .

If  (or , respectively) is bivalent in , then by Corollary \ref{cor:bivalentNodeFiniteTimeInAllGs}, we know that there a positive integer  such that for all positive integers , node  (or , respectively) is bivalent in , and consequently,  is not a decision gadget in . 

Thus, if  is a tuple , then there exists a positive integer  such that for all positive integers ,  is a gadget in , but  is not a non- decision gadget in .

\emph{Case 2.}  is a tuple . Let  be the node to which  is the incoming edge.
Let  be the node to which  is the incoming edge. Since  is not a decision gadget, one of the following is true: (1) the path from root to  contains an edge with  action tag, (2)  is univalent,  or (3) at least one of  and  is bivalent in .

If the path from root to  contains an edge with  action tag, then by Lemma \ref{lem:superObsYieldsSuperTree}, we know that  exists a positive integer  such that for every positive integer , the path from root to  contains an edge with  action tag in . Therefore,  cannot be a non- decision gadget in .


If  is univalent in , then as in Case 1, by Lemma \ref{lem:univalentNodeFiniteTimeInAllGs}, we know that there exists a positive integer  such that for every positive integer ,  is univalent in . Therefore, for any positive integer ,  cannot be a decision gadget in .

Similarly, if  (or , respectively) is bivalent in , then as in Case 1,  there exists a positive integer  such that for all positive integers ,  (or , respectively) is bivalent in , and  is not a decision gadget in . 

Thus, if  is a tuple , then there exists a positive integer  such that for all positive integers ,  is a gadget in , but  is not a non- decision gadget in .
\end{proof}










\subsection{Ordering the Decision Gadgets.}



In this subsection, we show
that a ``first'' decision gadget exists in . However, to define the ``first'' decision gadget, we first define a metric function 
in four steps: (1) We order the elements in each of the following sets: , and
. (2) We order the vertices in . (3) We use the aforementioned orders to define a metric function for each node  in  and for each edge outgoing from . (4) Finally, we define the metric function for each gadget.

\paragraph{Ordering the elements in .}
Recall that the locations in  are totally ordered by the  relation. For simplicity, we assume that  is the set of integers in  and . Thus,  is totally ordered by the  relation.



\paragraph{Ordering the elements in .}
Informally, we order  as follows.    \\  .

Formally, we define   to be a mapping from all the labels in  to the set of integers in  as follows. For each element  in  and each element  in , . Note that  consists of   tasks,   tasks, and   tasks. For each  task , each  task  and each  task , .

For each location , recall that we assume . For a  task, . For an  task, , and for an  task, .
For a  task, . It is easy to see that  is a bijection from  to . 
We define the mapping from  as follows. . Therefore,  is a bijection from  to .
Thus, the tasks in  are totally ordered by the range of  and the  relation on integers.



Based on ordering the elements in , we can order any pair of distinct sequences of labels by their lexicographic ordering.

\paragraph{Ordering vertices in .}
We order the vertices  in  first by their index , and break the ties among vertices with the same index by their location .
We define a mapping , where  as follows. Note that for any vertex , there are potentially infinitely many vertices in  with the same location  and at most  vertices in  whose index is . Based on the above observation, we order all the vertices  by defining , where ; note that by this definition,  and for any , . Thus, the vertices in  are totally ordered by the range of  and the  relation on integers.

\paragraph{Ordering outgoing edges from each node in .}
Fix any node  in . We define a total order over the set of edges outgoing from  as follows. Note that  has exactly one outgoing edge for each label in , and potentially infinitely many outgoing edges for each label in . Also note that . By Lemma \ref{lem:childNodeUniqueByLabelAndVertexTag}, we know that for each outgoing -edge, where  is a location, its vertex tag is distinct from the vertex tag of all other   edges. Therefore, for a given vertex tag, there can be only finitely many outgoing edges from : there is at most one outgoing  edge for each location  with a given vertex tag, and there is at most one -edge outgoing from  for any non- label . It follows that there is at most one outgoing edge from  for a given vertex tag and task label.

Thus, we first order all the edges by their vertex tags, and for a given vertex tag, we order all edges with the same vertex tag by their task label. Formally, this ordered is captured by the metric function  for the outgoing edges  from any node : . 

Note that the range of  is . The lexicographic ordering of the range of  induces a total order on outgoing edges from each node in .







\paragraph{Ordering all the non- nodes in .}
Recall that each non- node  in  can be uniquely identified by the sequence of labels from  to  and the sequence of distinct vertex tags in the path from  to . Also, note that nodes that contain a  action tag in the path from  to  cannot be uniquely identified using the above information. However, for our purposes, it is sufficient to order non- nodes.

Fix a non- node  in . Let  denote the depth of the node, and let  denote the index of ; that is, , where . Let  denote the sequence of edges in the path from  to . We define the metric function for each node  in  as follows: .

Thus, given two nodes  and  in , we say that  is ordered before  if either of the following is true.
\begin{itemize}
\item .
\item Assuming , let  be the smallest integer such that at least one of  and  exists, and if  also exists, then  . Then, . Informally,  is ordered before  if the sequence of edges from  to  is lexicographically less than the sequence of sequence of edges from  to . 
\end{itemize}

Next, we show that the metric function  imposes a total order on the non- nodes in , and there exists a node with the minimum metric value among all the nodes in .
In Lemma \ref{lem:distinctMetricValueDistinctNodes}, we show that distinct non- nodes must have distinct metric values, which implies that the metric function  establishes a total order over all the non- nodes in  (Lemma \ref{lem:totallyOrderedNodesInTree}).
By implication,  establishes a total order over any non-empty subset of non- nodes in  (Corollary \ref{cor:totallyOrderedNodesInSubset}).
In Lemma \ref{lem:finitelyManyNodesWithSmallerMetric}, we show that for any non- node  there are only finitely many nodes whose metric value is lexicographically smaller than the metric value of  (we use Lemma \ref{lem:OnlyFinitelyManyNodesWithDPlusK} as a helper lemma to prove this). 
Corollary \ref{cor:finitelyManyNodesWithSmallerMetricInSubset} immediately follows from Lemma \ref{lem:finitelyManyNodesWithSmallerMetric};  Corollary \ref{cor:finitelyManyNodesWithSmallerMetricInSubset} states that in any non-empty subset of non- nodes in , for each node , there are only finitely many nodes with a smaller metric value. Lemma \ref{lem:totallyOrderedNodesInTree} and Corollary \ref{cor:finitelyManyNodesWithSmallerMetricInSubset} together imply Corollary \ref{cor:NodesWithSmallestMetricInSubset}, which states that any non-empty subset  of non- nodes in  contains a unique node with the minimum metric value.

\begin{lemma}\label{lem:distinctMetricValueDistinctNodes}
For any pair ,  of distinct non- nodes in , .
\end{lemma}
 \begin{proof}
Fix  and  as in the hypothesis of the lemma. For contradiction, assume . Therefore, the sequence of labels in the path from  to  and from  to  are identical (consequently, both  and  are at the same depth), and . Invoking Lemma \ref{lem:nonBotNodeUniqueExe}, we know that . This contradicts the hypothesis that  and  are distinct.
 \end{proof}



\begin{lemma}\label{lem:totallyOrderedNodesInTree}
The non- nodes in  are totally ordered by their metric function .
\end{lemma}
\begin{proof}
By Lemma \ref{lem:distinctMetricValueDistinctNodes}, we know that each non- node in  has a distinct metric value. By definition the range of the metric function  of nodes in  are totally ordered (by lexicographic ordering).
Therefore, the non- nodes in  are totally ordered by their metric value.
\end{proof}

\begin{corollary}\label{cor:totallyOrderedNodesInSubset}
For any non-empty subset  of non- nodes in , the nodes in  are totally ordered by their metric function .
\end{corollary}
\begin{proof}
Follows from Lemma \ref{lem:totallyOrderedNodesInTree}.
\end{proof}

\begin{lemma}\label{lem:OnlyFinitelyManyNodesWithDPlusK}
For any non- node  in , there are only finitely many nodes  such that .
\end{lemma}
\begin{proof}
We use the following two claims to prove the main lemma.

\emph{Claim 1.} For any vertex  in , there are only finitely many paths in  that end with .
\begin{proof}
Fix a vertex  in . 
For contradiction, assume that  contains infinitely many paths ending in .
Therefore, there are infinitely many vertices  in  such that there is a path from  to .
By the transitive closure property of , it implies that there are infinitely many vertices  such that there is an edge in  from  to .
This contradicts Lemma \ref{prop:finiteIncomingEdges}.
\end{proof}

\emph{Claim 2.} For any pair of positive integers  and , there are only finitely many nodes  such that  and .
\begin{proof}
Fix  and . By construction of , there are at most  vertices  of the form  in ; let  be the set of all such vertices. For each , by Claim 1, there are only finitely many paths  in  that end with ; let  denote all the paths in  that end with some vertex in . For each , there are only finitely many sequences  of length  consisting of only the vertices in ; let  denote the set of all sequences over the vertices in some . Note that  is finite.

Let  be the set of all sequences of length  over . Note that  is finite.

For each non- node  in  such that  and ; let  denote the sequence of edges from  to . By Lemma \ref{lem:LabelsAndVertexAgsDenoteUniqueNode}, we know that the projection of  on the sequence of vertex tags and labels is unique, and by construction, this projection is an element of . Since  and  are finite, we conclude that there are only finitely many nodes  such that  and .
\end{proof}

Fix a non- node  in . Let . We apply Claim 2 for all values of  and , where  is in  and  is in , respectively, to conclude that there are only finitely many nodes  such that .
\end{proof}

\begin{lemma}\label{lem:finitelyManyNodesWithSmallerMetric}
For any non- node  in , there are only finitely many non- nodes  such that .
\end{lemma}
\begin{proof}
Fix  as in the hypothesis of the lemma. 
Recall that the first element in  of any node  is . Therefore, for any non- node  such that , .
Invoking Lemma \ref{lem:OnlyFinitelyManyNodesWithDPlusK}, we know that there are only finitely many nodes  such that . Therefore, there are only finitely many non- nodes  such that .
\end{proof}

\begin{corollary}\label{cor:finitelyManyNodesWithSmallerMetricInSubset}
For any non-empty subset  of non- nodes in , for any non- node  in , there are only finitely many non- nodes  such that .
\end{corollary}
\begin{proof}
Follows from Lemma \ref{lem:finitelyManyNodesWithSmallerMetric}.
\end{proof}

\begin{corollary}\label{cor:NodesWithSmallestMetricInSubset}
For any non-empty subset  of non- nodes in , there exists a unique non- node  such that for all , .
\end{corollary}
\begin{proof}
Fix  as in the hypothesis of the corollary. For contradiction, assume that for every node , there exists a node  such that . By Corollary \ref{cor:totallyOrderedNodesInSubset}, we know that the nodes in  are totally ordered by their metric value. Therefore, for any node , there must exist an infinite number of nodes  such that . However, this contradicts  Corollary \ref{cor:finitelyManyNodesWithSmallerMetricInSubset}.
\end{proof}

\paragraph{Ranking non- nodes in .}
From Lemma \ref{lem:totallyOrderedNodesInTree}, we know that the metric function  for non- nodes establishes a total order over the set of non- nodes in . By Corollaries \ref{cor:finitelyManyNodesWithSmallerMetricInSubset} and  \ref{cor:NodesWithSmallestMetricInSubset}, we map the non- nodes to the set of natural numbers by a function  defined as follows.

Let  be the set of all non- nodes in .
For any non-negative integer , if  is node with the -th smallest metric value among the nodes in , then . 

This notion of ``rank'' is used to define the metric value of non- gadgets.

\paragraph{Metric value of non- gadgets.} 
Given a non- gadget of the form , it can be uniquely identified by ,  and , where  is the lower endpoint of  and  is the lower endpoint of . Similarly, given a non- gadget of the from , it can be uniquely identified by ,  and , where  is the lower endpoint of  and  is the lower endpoint of .

For a non- decision gadget , the metric value of the gadget is defined as , where  is the Cantor pairing function \cite{cantor:ueed}\footnote{Recall that Cantor pairing function  is a bijection from  to  and is defined by .}.
Similarly, for a non- decision gadget , the metric value of the gadget is defined as .



\begin{lemma}\label{lem:distinctGadgetsDistinctMetricValue}
For any pair of distinct non- gadgets  and , .
\end{lemma}
\begin{proof}
Follows from the properties of the Cantor pairing function.
\end{proof}

The \emph{first non- decision gadget} in  is the non- decision gadget with the smallest metric value among all non- decision gadgets in . Next, we show that such a decision gadget exists.

\begin{lemma}\label{lem:finitelyManySmallerGadgets}
For any any non- gadget  in , there are only finitely many non- gadgets  in  such that .
\end{lemma}
\begin{proof}
The lemma follows directly from the properties of the Cantor pairing function.
\end{proof}

Next, we show that  has a first non- decision gadget.
\begin{theorem}\label{thm:smallestGadget}
 contains a non- decision gadget  such that the metric
value of any other non- decision gadget  is strictly greater than the
metric value of .
\end{theorem}
\begin{proof}
Let  be the set of all non- decision gadgets in .
Fix an arbitrary . By Lemma \ref{lem:finitelyManySmallerGadgets}, we know that there are only finitely many  such that . Let . Since  is a finite set, let . By construction,  is a non- decision gadget such that the metric
value of any other non- decision gadget  is strictly greater than the
metric value of .
\end{proof}



Given an observation  that is viable for , let
 denote the first non- decision gadget in .

Recall that at most  locations are not
live in ;  is a a trace that is compatible with , and  is a sequence of observations that converge to . Next we show the `persistence' of non- decision gadgets across the sequence of execution trees .

\begin{lemma}
\label{lem:finitelyManySmallerGadgetsInPrefix}
For any , for any any non- gadget  in , there are only finitely many non- gadgets  in  such that .
\end{lemma}
\begin{proof}
The lemma follows directly from the properties of the Cantor pairing function.
\end{proof}


Let  denote : this first non- decision gadget in .


\begin{lemma}\label{lem:minGadgetFoundInAllGs}
There exists a positive integer  such that for all positive integers ,  is the first non- decision gadget in .
\end{lemma}
\begin{proof}
Applying Lemma \ref{lem:decisionGadgetStableInAllGs}, we know that there exists a positive integer  such that for all positive integers ,  is a non- decision gadget in . Fix .

By Lemma \ref{lem:finitelyManySmallerGadgetsInPrefix}, we know that there are only finitely many non- gadgets  in  such that .
Let  denote the set of all such gadgets .
By construction all the gadgets in  are not non- decision gadgets (that is, they are either  decision gadgets, or not decision gadgets at all) in . 
By Lemma \ref{lem:nonDecisionGadgetStableInAllGs}, we know that for each   there exists a positive integer  such that for all positive integers ,  is not a non- decision gadget in ; fix an  for each such . Let  denote the largest such ; since  is a finite set, we know that  is exists.

Thus, for all ,  is the first non- decision gadget in .
\end{proof}


















\section{A Weakest AFD for Consensus}
\label{sec: wfd}



In \cite{chan:twfdf}, Chandra et al. showed that  is a weakest
failure detector for solving -crash-tolerant consensus. We use
similar arguments to show that AFD   (defined in Section
\ref{subset:omegaDef}), which is a generalization of the  AFD,
is a weakest strong-sampling AFD to solve
-crash-tolerant consensus in all well-formed environments. Although
the assumption about strong-sampling AFDs seems to weaken our result
with respect to the result in \cite{chan:twfdf}, in fact, a similar
assumption was implicitly used in \cite{chan:twfdf}.



Recall that , where , denotes the AFD that
behaves exactly like  in traces that have at most  faulty
locations, and in traces that have more than  faulty locations, the outputs by  are unconstrained.
In order to show that  is weakest to solve
-crash-tolerant consensus, first we have to show that
-crash-tolerant consensus can be solved using  in any
well-formed environment. Since  behaves exactly like
 in executions where at most  locations crash, we see that
the algorithm in \cite{chan:ufdfr} can be modified trivially to solve
-crash-tolerant consensus using  in any well-formed
environment. It remains to show that, for every strong-sampling AFD
, if  is sufficient to solve -crash-tolerant consensus in
any well-formed environment,  then  is stronger than . 

For the remainder of this section, fix  to be a positive integer not exceeding .

In Section \ref{subsec:omegaExtraction}, we present an algorithm that
solves  using any arbitrary strong-sampling AFD that solves
-crash-tolerant consensus, and in Section
\ref{subsec:omegaExtractionCorrectness}, we present the proof of
correctness. Since we know that  is sufficient to solve
-crash-tolerant consensus, we thus establish that  is a
weakest AFD to solve -crash-tolerant consensus.

\subsection{Algorithm for Solving }\label{subsec:omegaExtraction}

Let  be an AFD sufficient to solve -crash-tolerant consensus,
where , in the well-formed environment 
from Section \ref{subsec:conEnvDef}. By definition, there exists a
distributed algorithm  that uses  to solve
-crash-tolerant consensus in . Using , we
construct an algorithm  that uses  to solve
. 


In , each process automaton keeps track of the outputs
provided by AFD  and exchanges this information with all other
process automata (at other locations).
Each process uses this information to maintain an observation  (a local variable), and sends this observation to the other process automata. Initially, the observation 
at each process automaton is empty, and the local variable , which
counts the number of AFD events that have occurred at that location,
is . Each process also maintains a local variable  which may be viewed as the automaton's current estimate of the output of the AFD  that it implements; initially, at each process , the value of  is . Next, we describe the actions of the process automaton at a location
(say) . 

When an AFD output  occurs at location , the input action
 occurs in ; in this action, the process automaton does 
the following.
It increments  by  (which updates the number of AFD events that
have occurred at ) and inserts a new vertex  into its local variable ; the insert operation is defined in Section \ref{subsec:OperationsOnObservations}.
A copy of the updated observation  is appended to  for every
other location to be sent out to all other locations. The process automaton
constructs the directed tree  for the current value of  (as described in Section \ref{subsec:treeOfExec}). If  contains a non- gadget, then it determines the first non- decision gadget in 
 and
updates  to the critical location of that decision gadget. Finally, the automaton adds
 to .

If the front element of  is a pair consisting of an observation 
and  location , then the output action  is enabled. When this
action occurs, the front element of  is deleted (and a message is
send to  that contains the observation ).

When the process automaton at  receives a message from another
location  with the observation , the input event 
occurs, and the process automaton updates  with the union of 
and ; the union operation is defined in Section \ref{subsec:OperationsOnObservations}.

If the front element of  is a pair , where  is a location,
the output action  is enabled. When this action occurs, 
the front element of  is deleted.

Note that  contains both the observations that are sent to other locations and the value of the  AFD output events. This is because we model process automata as having a single task. Alternatively, we could have modeled process automata as having multiple tasks and used separate data structures to store the AFD outputs and the observations to be sent to other locations.



 The pseudocode for the algorithm is given in Algorithm \ref{alg:exchangeFD}.

\begin{algorithm}\footnotesize
\caption{Algorithm for solving }
\label{alg:exchangeFD}
The automaton  at each location .



\textbf{Signature:}

\tab input 

\tab input : 

\tab input 

\tab output 

\tab output 

\tab 

\textbf{Variables:}

\tab : a finite observation, initially empty \hfill \emph{Finite observation maintained at all locations}

\tab : integer, initially  \hfill \emph{Denotes the number of AFD outputs occurred so far}

\tab : queue of pairs , where  is either an observation or a location, and  is a location, initially empty. 

\tab : , initially  \hfill \emph{Location ID output by the  AFD output actions}

\tab : Boolean, initially  \hfill \emph{When true, the process automaton is crashed}


\tab 


\textbf{Actions:}

\tab input 

\tab effect

\tab \tab  := 

\tab


\tab input : 

\tab effect

\tab \tab if not faulty, then

\tab \tab \tab  :=  



\tab \tab \tab insert vertex  into  \hfill \emph{The insert operation is defined in Section \ref{subsec:OperationsOnObservations}.}

\tab \tab \tab foreach 

\tab \tab \tab \tab append  to 

\tab \tab \tab if  contains a non- decision gadget, then

\tab \tab \tab \tab  :=  \hfill \emph{Recall that  is the first non- decision gadget in }



\tab \tab \tab \tab  := critical location of 

\tab \tab \tab append  to 


\tab

\tab input 

\tab effect

\tab \tab if not faulty, then

\tab \tab \tab  := \hfill \emph{The union operation is defined in Section \ref{subsec:OperationsOnObservations}.}


\tab

\tab output 

\tab precondition

\tab \tab 

\tab effect

\tab \tab delete head of 



\tab

\tab output 

\tab precondition

\tab \tab  

\tab effect

\tab \tab delete head of 

\end{algorithm}


\subsection{Correctness}
\label{subsec:omegaExtractionCorrectness}



Fix an arbitrary fair execution  of the system consisting of
, the channel automata, the crash automaton, and the
well-formed environment  such that  and at most  locations crash in . Let
. Recall that AFD  behaves
exactly like  if at most  locations crash.
Thus, it remains to show that .
 
 
 The remainder of this section uses the following notation. Recall
 that an execution is a sequence of alternating states and actions. In
 execution ,  denotes the -th state in
 , and  denotes the value of the observation
  in state . We assume that the initial state of , denoted , is the -th state in .
 
 The proof is divided into three parts. 
In Section~\ref{subsubsec:proofPartOne}, we prove some basic properties of
the graphs , where  is a location, that are used in the
remainder of the proof. 
In Section~\ref{subsubsec:proofGisAreObs}, we show that each
, where  is a positive integer and  is a
location, is a viable observation for .
In Section~\ref{subsubsec:proofLimitObsIsViable}, we show that for all
live locations , the limits  of , as 
approaches , are identical and a viable observation for
; therefore, we denote all  (for all locations ) as . 
Finally, in Section~\ref{subsubsec:proofSmallestDecisionGadget}, we
identify the ``first'' non- decision gadget  in  and show that
for each live location , eventually,  is also the first
non- decision gadget for . 
Since each live process eventually detects the same decision gadget as
the ``first'', each live process eventually and permanently outputs
the same live location as the output of
. This completes the proof. 
  
\subsubsection{Properties of the graphs  at each location }
\label{subsubsec:proofPartOne}



Here we present some basic properties of the  graphs\footnote{Although  for each location  is an observation, we have not yet shown this to be the case. Consequently, we refer to them merely as ``graphs''. We prove that the s are observations in Theorem \ref{thm:GiIsObs}.}.
Lemma \ref{prop:subgraphNext} states that the value of  in any state is a subgraph of its value in any later state.
For a triple  that exists in some , let  be the smallest positive integer such that  contains the vertex  for some location ; then, vertex  said to ``appear'' in  at index .
Lemma \ref{lem:vertexFirstAtHomeLocation} establishes that when a new vertex  ``appears'' in  at index ,  is inserted into ; that is,  contains . 
Lemma \ref{lem:vertexInsertionProp} establishes that  when  first ``appears'' in  at index  (1)  precedes the state  in , (2) the value of  is , (3)  is the -th  event in , (4)  does not contain any other vertex of the form , and (5)  contains vertices of the form  for all . Lemma \ref{lem:edgeFirstAtHomeLocation} establish that when a vertex  ``appears'' in , all the incoming edges to  are fixed and do not change thereafter. Lemma \ref{lem:containsVertexContainsSubgraph} establishes that if  ``appears'' in  at index , then for all ,  is a subgraph of . Finally, Lemma \ref{lem:edgeHappensBefore} establishes that if an edge  occurs in any graph , then the event of  precedes the event of  in .

\begin{lemma}
\label{prop:subgraphNext}
For each positive integer  and each location ,  is a subgraph of .
\end{lemma}  

\begin{proof}
Fix  and  as in the hypotheses of the Lemma. The proof follows from the observation that no vertex and no edge in  is deleted in , by any action.
\end{proof}
\begin{corollary}\label{cor:subgraphFuture}
For each positive integer , each location , for all positive integers ,  is a subgraph of .
\end{corollary}



\begin{lemma}
\label{lem:vertexFirstAtHomeLocation}
For any vertex , let  be the smallest integer such that
for some location ,  contains the vertex
. Then (1)  and (2) event  immediately precedes  in .
\end{lemma} 

\begin{proof}
Fix , , and  as in the hypotheses of the lemma. Therefore,
 does not contain the vertex  and
 contains the vertex . Let  be the action
that occurs between states  and  in
.

First, we prove part 1 of the lemma.
From the pseudocode, we know that  is either an action in 
or an action of the form . In the former case, we
see that . We show that the latter case is impossible.

For contradiction, assume that  is an action of the form
. From the pseudocode, we see that 
contains vertex . However, from the reliable FIFO behavior of
the channel automata, we know the process automaton at  must have
sent the message  containing vertex  before state
 in . Let this occur in state ,
where . Therefore,  contains vertex
, which contradicts our assumption that  is the smallest
integer such that for some location ,  contains
the vertex ; this establishes part 1 of the lemma. 

Also, we see 
that  must be an action in , and from the pseudocode,
we conclude that ; this establishes part 2 of the lemma.
\end{proof}

 \begin{lemma}\label{lem:vertexInsertionProp}
 For any vertex , let  be the smallest integer such that  contains the vertex .
The following are true.
\begin{enumerate}
\item .
\item 
\item  does not contain any other vertex of the form .
\item For each positive integer ,  contains one vertex of the form .
\end{enumerate}
\end{lemma}
\begin{proof}
Fix ,  and  as in the hypotheses of the lemma. We prove the lemma by induction on .

\emph{Base Case.} Let . When the first event  from 
occurs in , from the pseudocode, we see that the vertex
 is added to . Therefore, for vertex , let 
be the smallest integer such that  contains the
vertex . From the pseudocode, we see that (1) .
Since  is the first event from , (2) . Note that (3)  does not contain any vertex of the form . Property 4 is satisfied vacuously.

\emph{Inductive Hypothesis.}  For any vertex , let  be the
smallest integer such that  contains the vertex
. Then the following is true.
\begin{enumerate}
\item .
\item .
\item  does not contain any other vertex of the form .
\item For each positive integer ,  contains one vertex of the form .
\end{enumerate}

\emph{Inductive Step.} 
Let  be the smallest integer such that  contains the vertex
 for some . Applying Lemma \ref{lem:vertexFirstAtHomeLocation}, we know that for every other location  and all ,  does not contain the vertex  and the event preceding  is event .
From the pseudocode, we see that , and since any action from  increments  by , we conclude that (1) . Also, since  is updated only when an action from  occurs, , and when  occurs, vertex  is inserted to , we conclude that (2) . 

From the inductive hypothesis we know that . Since , and any action from  increments , we know that . We have already established that . Therefore,  is the earliest event from  that follows . That is, (3) .

By the inductive hypothesis, we know that each positive integer ,  contains one vertex of the form . We have established that  is the earliest event from  that follows . Therefore,  contains exactly one event of the form , which is . Therefore, (4) for each positive integer ,  contains one vertex of the form .
\end{proof}
 

 
 




\begin{lemma}\label{lem:edgeFirstAtHomeLocation}
For any location , any positive integer , and any pair of
vertices  and  such that  contains
the edge , the following is true. Let  be the smallest
positive integer such that  contains the vertex
. 
Then  contains the edge .
\end{lemma}



\begin{proof}
Fix , , , , and  as in the hypotheses of the
lemma. Let  be the smallest positive integer such that for
some location ,  contains the edge
. Applying Lemma \ref{lem:vertexFirstAtHomeLocation}, 
we know that . If , then note that the edge
 is added to  by an action of the form
, where  contains the edge
. However, this implies that for some ,
 contains the edge , and this
contradicts the definition of . Therefore, . Applying Lemma \ref{lem:vertexFirstAtHomeLocation}, 
we know that
. Therefore,  contains the edge .
\end{proof}


\begin{lemma}\label{lem:containsVertexContainsSubgraph}
For any vertex , let  be the smallest integer such that
for some location ,  contains the vertex
. For any location  and any positive integer  such
that  contains the vertex ,
 is a subgraph of .
\end{lemma}

\begin{proof}
Fix , , and  as in the hypotheses of the lemma. Applying Lemma \ref{lem:vertexFirstAtHomeLocation} we know that .


For contradiction, assume there exists a location  and a positive integer  such that  contains the vertex , but  is not a subgraph of . Fix the smallest such  and the corresponding location  such that  contains the vertex . 

From the definition of  we know that . Applying Corollary \ref{cor:subgraphFuture}, we know that  is a subgraph of , and therefore  . 

Since  is the smallest integer such that  contains the vertex  and , we conclude that the action preceding  in  is an action of the form , where  contains the vertex  and  is not a subgraph of . Fix the location . Therefore, there exists a positive integer  such that  contains the vertex  and  is not a subgraph of . This contradicts the definition of .
\end{proof}

\begin{lemma}
\label{lem:edgeHappensBefore}
For any edge  in , the event  occurs
before event  in , where  and .
\end{lemma}

\begin{proof}
Fix  and , as in the hypotheses of the lemma.

Applying Lemma \ref{lem:vertexFirstAtHomeLocation}, we know that there
exists a positive integer  such that (1) 
contains vertex , (2) for each positive integer ,
 does not contain , and (3) for each
positive integer  and every other location ,
 does not contain the vertex .

Similarly, applying Lemma \ref{lem:vertexFirstAtHomeLocation}, we know
that there exists a positive integer  such that (1)
 contains vertex , (2) for each positive
integer ,  does not contain the
vertex , and (3) for each positive integer  and
every other location ,  does not contain the
vertex . From Lemma \ref{lem:edgeFirstAtHomeLocation} we know
that  also contains the edge .

Therefore,  contains vertex  and does not
contain , whereas  contains vertices 
and . Applying Lemma \ref{lem:containsVertexContainsSubgraph}, we
know that   is a subgraph of
. From the definition of  and , we
know that . Note that  is added to
 when event  occurs in  after
state , and similarly,  is added to
 when event  occurs in  after
state . Therefore,  occurs before  in
.
\end{proof}










\subsubsection{For each location ,  is an observation}
\label{subsubsec:proofGisAreObs}

In this subsection, we prove in Theorem \ref{thm:GiIsObs} that for each location  and each positive
integer ,  is an observation for . We use two three lemmas to prove the main result. In Lemma \ref{lem:insertYeildsObservation}, we prove that for any location , if the graph  is an observation and an event from  occurs, then in the resulting state,  is an observation. In Lemma \ref{lem:sameIndexSameEvent}, we show that for any two graphs  and , and for every vertex  from , either  also contains , or  does not contain any vertex of the form . In Lemma \ref{lem:sameVertexSameIncomingEdges}, we show that for any two graphs  and , for any vertex  that is in both  and ,  has the same set of incoming edges in both  and .

\begin{lemma}\label{lem:insertYeildsObservation}
For any location  and a positive integer , if  is an observation and the event  between  and  in  is an event from   then  is an observation.
\end{lemma}
\begin{proof}
Fix , , and  from the hypothesis of the lemma.
From the pseudocode, we know that when  occurs, a vertex  of the form  is added to , and for each vertex  in , the edge  is added to  as well.
From Lemma \ref{lem:vertexInsertionProp}, we know that  and  does not contain any vertex of the form . 
Therefore, ; invoking Lemma \ref{prop:insertVertexYeildsObservation}, we conclude that  is an observation.
\end{proof}


\begin{lemma} \label{lem:sameIndexSameEvent}
For any pair of positive integers  and , and any pair of locations  and , if  contains a vertex , then it is not the case that  contains a vertex  where .
\end{lemma}
\begin{proof}
Fix a pair of positive integers  and , and a pair of locations  and , such that  contains a vertex ,  contains a vertex . We complete the proof by showing that .

Let  be the smallest positive integer such that for some location ,  contains the vertex , and let  be the smallest positive integer such that for some location ,  contains the vertex . Invoking Lemma \ref{lem:vertexFirstAtHomeLocation}, we know that . Invoking Lemma \ref{lem:vertexInsertionProp}, we know that  and ; that is, .
\end{proof}

\begin{lemma}\label{lem:sameVertexSameIncomingEdges}
For any pair of positive integers  and , and any pair of locations  and , for every vertex  in  and , If an edge  is in , then the edge  exists in .
\end{lemma}
\begin{proof}
Fix a pair of positive integers  and , and a pair of locations  and . If the set of vertices of  and  are disjoint, then the lemma is satisfied vacuously. For the remainder of the proof, assume that there exists at least one vertex in both  and . Fix such a vertex . Fix  to be any vertex in  such that  is an edge in . We show that the edge  exists in .

Let  be the smallest positive integer such that  contains the vertex . Invoking Lemma \ref{lem:edgeFirstAtHomeLocation}, we know that  contains the edge . Invoking Lemma \ref{lem:containsVertexContainsSubgraph}, we know that  is a subgraph of , and therefore,  contains the edge .
\end{proof}

\begin{theorem}
\label{thm:GiIsObs}
For each location , for each positive integer ,  is an observation.
\end{theorem}
\begin{proof}
We prove the theorem by strong induction on .

\emph{Inductive Hypothesis.} For each location , and each positive integer ,  is an observation.

\emph{Inductive Step.} Fix a location . We know that for ,  is the empty graph, and is therefore an observation. The remainder of the proof assumes . We know from Lemma \ref{prop:subgraphNext} that  is a subgraph of . Therefore, either , or . In the former case, we apply the inductive hypothesis to conclude that  is an observation. In the latter case, the following argument holds.

From the pseudocode, we know that the event  between  and  in  is either (1) an event from  or (2) an event of the form  for some .

\emph{Case 1.} Let  be an event from . Recall that by the inductive hypothesis,  is an observation. Invoking Lemma \ref{lem:insertYeildsObservation}, we conclude that  is an observation.

\emph{Case 2.} Let  be an event of the form  for some . From the FIFO property of the channels, we know that an event  occurred in  before event , From the pseudocode, we know that for some , . By the inductive hypothesis, we conclude that  and  are observations. Also, from the pseudocode, we know that when even  occurs,  is updated to . Therefore,  . 
By Lemma \ref{lem:sameIndexSameEvent}, we know that for each vertex  in , it is not the case that  contains a vertex  where , and invoking Lemma \ref{lem:sameVertexSameIncomingEdges}, we know that for every vertex  in both  and ,  has the same set of incoming edges in both  and .
Therefore, we can invoke Lemma \ref{prop:obs:union} to conclude that  is an observation. This completes the induction.
\end{proof}










\subsubsection{The limit of the 's is a viable observation}
\label{subsubsec:proofLimitObsIsViable}



For each location , we define  to be the limit of  as  tends to . In this subsection, we show that
for each pair of live locations  and , , and this limiting observation is viable for .

Recall that the limit  is defined as follows. Let  for each natural number . Then,  and .



\begin{lemma}
\label{lem:prefixOfFutureObs}
For each location , for every pair of integers ,, where
,   is a prefix of .
\end{lemma} 

\begin{proof}
Fix , , and , as in the hypotheses of the lemma. Applying Theorem
\ref{thm:GiIsObs}, we know that  and  are
observations.
From Corollary \ref{cor:subgraphFuture} we know that  is a
subgraph of . Applying Lemma
\ref{lem:edgeFirstAtHomeLocation}, we conclude that for each vertex in
, the set of incoming edges of  is the same in
 and . Therefore, 
is a prefix of .
\end{proof}







\begin{corollary}\label{cor:ObsPrefixOfLimit}
For each location  and each positive integer , 
is a prefix of .
\end{corollary}

Next, Lemma \ref{lem:limitGraphs} shows that for any pair  of live locations . We use Lemma \ref{lem:subgraphFutureLiveLocation}, which shows at any given point in the execution, the value of  is a prefix of the value of  at some later point in the execution, as a helper.



\begin{lemma}\label{lem:subgraphFutureLiveLocation}
For each positive integer , every pair of locations  and 
that are live in , there exists a positive integer  such that
 is a prefix of .
\end{lemma}

\begin{proof}
Fix , , and  as in the hypotheses of the lemma.
Since  is live, there exist a positive integers  and
 such that  contains
, and therefore, eventually the event
 occurs which sends 
to . By Lemma \ref{lem:prefixOfFutureObs},
we know that
 is a prefix of . From the
properties of the channel automata we know that eventually event
 occurs in state (say)
, where , and from the pseudocode, we know
that  is . Invoking Theorem \ref{thm:GiIsObs}, we know that  is an observation. 
Since we have already established that  is a prefix
of , we conclude that  is a
prefix of . Thus the lemma is satisfied for
.
\end{proof}

\begin{lemma}
\label{lem:limitGraphs}
For every pair of locations  and  that are live in ,
.
\end{lemma}

\begin{proof}
Fix  and  as in the hypotheses of the lemma. Fix  to be
either an edge or a vertex in . By definition, there
exists a positive integer  such that  contains
. By Lemma \ref{lem:subgraphFutureLiveLocation}, we know that there
exists a positive integer  such that  contains
; applying Corollary \ref{cor:subgraphFuture}, we conclude that for
all ,  contains . In other words,
 contains . Therefore,  is a subgraph of 
.

Reversing the roles of  and , we see that  is a subgraph of
. Therefore, .
\end{proof}

Lemma \ref{lem:limitGraphs} allows us to define  to be the
graph  for any location  that is live in .




\begin{lemma}
\label{lem:GinftyEdges}
For every location  such that  contains an infinite number of
vertices whose location is , for each vertex  in , there exists
a vertex  in  whose location is  and the edge  is in
.
\end{lemma} 

\begin{proof}
Fix  and  as in the hypotheses of the lemma. 
Since  contains an infinite number of vertices whose location is , we know that  is live in , and therefore, an infinite number of events from  occur in .

Since  is in , we know that there exists a positive integer  such that  is a vertex . Fix  to be the first event from  following  in . Let the state preceding  in  be . From the pseudocode, we know that when  occurs, a vertex of the form  is inserted in . Let this vertex be . From the insertion operation, we know that an edge  is added to . Therefore,  contains the edge . From Corollary \ref{cor:ObsPrefixOfLimit}, we know that  is a prefix of . Therefore, there exists
a vertex  in  whose location is  and the edge  is in
.
\end{proof}





 Finally, in Theorem \ref{thm:GinftyIsObs}, we establish that  is an observation, and in Theorem \ref{thm:GinftyIsViable}, we establish that it is a viable observation.
 
 \begin{theorem}\label{thm:GinftyIsObs}
  is an observation.
 \end{theorem}
 \begin{proof}
 For any live location , we know from Lemma \ref{lem:prefixOfFutureObs} that  is an infinite sequence of finite observations, where  is a prefix of  for each natural number . By definition, 
we know that   is the limit of the infinite sequence , and we know that .
 
 By Lemma \ref{lem:GinftyEdges}, we know that for every vertex  and any location ,
there exists a vertex  with location
 and  contains an edge from  to .
 Therefore, invoking Lemma \ref{lem:obs:limitObs}, we conclude that  is an observation.
 \end{proof}





 Next we establish that  is a viable observation. Intuitively, the proof is as follows. Recall that . For any live location ,  contains all the AFD output events from  that occur at  and in the same order in which they occur at . For any non-live location ,  contains some prefix of all the AFD output events from  that occur at  and in the same order in which they occur at . Also, there is an edge from a vertex  to another vertex  in  only if  occurs before  in . Therefore, there must exist some sampling  of  such that  is a topological sort of . Invoking closure under sampling, we conclude that  must be in , and therefore  is viable. The formal theorem statement and proof follows.
 
 \begin{theorem}\label{thm:GinftyIsViable}
  is a viable observation for .
 \end{theorem}

\begin{proof}
Recall that . We complete the proof by showing that there exists a trace  that is compatible with ; specifically, we show that there exists a topological sort  of the vertices of  and a sampling  of  such that , where  is the event-sequence of .

Let  be the set of all topological sorts of the vertices of , and let  be the set of all event-sequences such that each . From the pseudocode, we see that  is the set of all  such that (1) for each location ,  is a prefix of , and (2) for each location  that is live in , .

For any edge  in  we know that there exists a location  and a positive integer  such that  contains the edge ; applying Lemma \ref{lem:edgeHappensBefore}, the event of  occurs before the event of
. Therefore, in , for every edge , the event
of  occurs before the event of . Therefore, (3) for every pair of vertices  of , it is not the case that the event of  occurs before the event of  in the event sequence  of every topological sort  of the vertices of , and the event of  does not occur before the event of  in .

From (1), (2), and (3), we conclude that there must exist an event-sequence , such that (1) for each location ,  is a prefix of , (2) for each location  that is live in , , and (3) for every pair of events  in , if  occurs before  in , then  occurs before  in . Therefore, there exists a sampling  of  such that  .
By closure under sampling we know that . 
Thus, by definition,  is viable for .
\end{proof}



We have seen so far that in any fair execution  of the system, at
each live location ,  evolves as an ever growing observation such that
the limit  of  in  is a viable observation for . 




\subsubsection{Identifying the smallest decision gadget}\label{subsubsec:proofSmallestDecisionGadget}
Next, we show that  has at least one non- decision gadget. Let  be the first non- decision gadget in . We show that at
each live location , eventually,  will contain the decision gadget , and importantly, eventually forever,  remains the first non- decision gadget of . By Theorem \ref{thm:ViableGHasDecisionGadgets}, we know that the critical location of  is a live location. However, since for all the live processes , the first non- decision gadget of  converges to , we know that all the live locations converge to the same live location, which is output of the . Thus,  solves  using AFD .

\begin{corollary}\label{cor:GinftyHasDecisionGadget}
 contains at least one decision gadget.
\end{corollary}
\begin{proof}
Follows from Theorems \ref{thm:ViableGHasDecisionGadgets} and \ref{thm:GinftyIsViable}.
\end{proof}

Applying the above Corollary, we know that  contains a decision gadget. Applying  Theorem \ref{thm:smallestGadget}, let  be  (the first non- decision gadget in ).

\begin{lemma}\label{lem:minGadgetFound}
For each location  that is live in , there exists a positive integer  such that for all positive integers ,  is the first non- decision gadget in .
\end{lemma}
\begin{proof}
Fix a location  that is live in .
Invoking Theorem \ref{thm:GiIsObs}, we know that for each positive integer ,  is an observation.
Since  is a viable observation for  and  is compatible with , we invoke Lemma \ref{lem:prefixOfFutureObs} to conclude that  is an infinite sequence of finite observations that converge to .

Thus, the conclusion follows immediately from the application of Lemma \ref{lem:minGadgetFoundInAllGs}.

\end{proof}

\begin{theorem}
The algorithm  solves  using AFD , where .
\end{theorem}
\begin{proof}
Fix a fair execution  of the system consisting of , the channel automata, and the crash automaton such that  and at most  locations crash in . Denote  as . For each location  that is live in , let  denote . Applying Lemma \ref{lem:limitGraphs}, we know that for each location  that is live in , . By Theorem \ref{thm:GinftyIsViable}, we know that  is a viable observation for . By Corollary \ref{cor:GinftyHasDecisionGadget}, we know that  contains at least one decision gadget. Applying  Theorem \ref{thm:smallestGadget} let  be the first non- decision gadget in . Applying Lemma \ref{lem:minGadgetFound}, we know that for each location  that is live in , eventually and permanently,  is the first non- decision gadget of . Thus, for each location  that is live in , eventually and permanently, when an event from  occurs in ,  is appended to , where  is the critical location of . Therefore, for each location  that is live in , some suffix of  is the infinite sequence over . Applying Theorem \ref{thm:ViableGHasDecisionGadgets}, we know that  is live in , and therefore,  is live in . In other words, .
\end{proof}

 

\section{Conclusion}\label{sec:conclusion}

We have shown that for any strong sampling AFD sufficient to solve consensus, the executions of the system that solves consensus using this AFD must satisfy the following property. For any fair execution, the events responsible for the transition from a bivalent execution to a univalent execution must occur at location that does not crash.
Using the above result, we have shown that  is a weakest strong-sampling AFD to solve consensus. The proof is along the lines similar to the original proof from \cite{chan:twfdf}. However, our proof is much more rigorous and does not make any implicit assumptions or assertions. Furthermore, the notion of observations and tree of executions introduced in Sections \ref{sec:observations}  and \ref{subsec:treeOfExec} and their properties may be of independent interest themselves.

\bibliographystyle{plain}
\bibliography{ref}


\end{document}
