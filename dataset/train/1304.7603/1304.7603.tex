\documentclass{article}
   
\newif\ifshorter\shortertrue
 
\usepackage{graphicx}
\usepackage{amsmath,amsfonts,amssymb}
\usepackage{amsthm}
\usepackage{algorithmic,multirow}
\let\algorithm\relax
\let\endalgorithm\relax
\usepackage[ruled,vlined,linesnumbered]{algorithm2e}
\usepackage{tikz}
\usepackage{url}
\usepackage{enumitem}
\usepackage{lhelp}

\def\C {\ensuremath{\mathbb{C}}}
\def\I {\ensuremath{\mathcal{I}}}
\def\J {\ensuremath{\mathcal{J}}}
\def\K {\ensuremath{\mathbf{k}}}
\def\L {\ensuremath{\mathbb{L}}}
\def\N {\ensuremath{\mathcal{N}}}
\def\Q {\ensuremath{\mathbb{Q}}}
\def\R {\ensuremath{\mathbb{R}}}
\def\T {\ensuremath{\mathfrak{T}}}
\def\S {\ensuremath{\mathfrak{S}}}
\def\SS {\mathhexbox278}
\def\Z {\ensuremath{\mathbb{Z}}}

\newtheorem{definition}{Definition}
\newtheorem{theorem}{Theorem}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{remark}[theorem]{Remark}

\bibliographystyle{plain}

\usepackage{authblk}
\usepackage{rotating}

\begin{document}


\title{Cylindrical Algebraic Decompositions \\ for Boolean Combinations}

\author[*]{Russell Bradford}
\author[*]{James H. Davenport}
\author[*]{Matthew England}
\author[**]{Scott McCallum}
\author[*]{David Wilson}
\affil[*]{University of Bath}
\affil[**]{Macquarie University}

\date{Email: \texttt{ \{R.J.Bradford, J.H.Davenport, M.England, D.J.Wilson\}@bath.ac.uk}, {\tt Scott.McCallum@mq.edu.au} }

\maketitle

\begin{abstract} 
This article makes the key observation that when using cylindrical algebraic decomposition  (CAD) to solve a problem with respect to a set of polynomials, it is not always the signs of those polynomials that are of paramount importance but rather the truth values of certain quantifier free formulae involving them. This motivates our definition of a Truth Table Invariant CAD (TTICAD).
We generalise the theory of equational constraints to design an algorithm which will efficiently construct a TTICAD for a wide class of problems, producing stronger results than when using equational constraints alone. The algorithm is implemented fully in {\sc Maple} and we present promising results from experimentation.
\end{abstract}





\section{Introduction}
\label{sec:Intro}

Cylindrical algebraic decompositions (CADs) are a key tool in real algebraic geometry, both for their original motivation, solving quantifier elimination problems, but also for use in many other applications ranging from robot motion planning \cite[etc.]{SchwartzSharir1983b} to programming with complex functions \cite[etc.]{DBEW12}.  Traditionally CADs are produced sign-invariant to a given set of polynomials, (the signs of the polynomials do not vary on the cells of the decomposition).  However, this gives far more information than required for most problems.  The idea of a truth invariant CAD (the truth of a formula does not vary on each cell) was defined in \cite{Brown98} for use in simplifying CADs.  The key contribution of this paper is an approach to construct CADs which are truth invariant without having to first build a sign-invariant CAD.  Actually, we directly build CADs which are truth table invariant, (the truth values of various quantifier free formulae do not vary).  

We present an algorithm to efficiently produce TTICADs for a wide class of problems, utilising the theory of equational constraints \cite{McCallum1999a}.  The algorithm goes further than equational constraints by allowing the creation of smaller CADs in a wider variety of cases; for example disjunctive normal form where each individual conjunction has an equational constraint but no single explicit equational constraint is present for the formula.  The problem of decomposing complex space according to a set of branch cuts for the purpose of algebraic simplification (\cite[etc.]{Phisanbutetal2010a}) is of this case.  

\subsection{Background on CAD}

We briefly remind the reader about the theory of CAD, first proposed by Collins in \cite{Collins1975}.
\begin{definition}
A {\em Tarski formula\/}  is a Bool\-ean combination () of statements about the signs, (, but therefore  as well), of certain integral polynomials .  We use {\em QFF} to denote a quantifier free Tarski formula.
\end{definition}
CAD was developed as a tool for the problem of quantifier elimination over the reals: given a quantified Tarski formula

(where  and  is a QFF), produce an equivalent QFF . Collins proposed to decompose  cylindrically such that each cell was sign-invariant for all  occurring in . Then  would be the disjunction of the defining formulae of those cells  in  such that (\ref{eq:QT}) was true over the whole of , which is the same as saying that (\ref{eq:QT}) is true at any one ``sample point'' of .
\par
Collins' algorithm has two phases.  The first, \textit{projection}, applies a projection operator repeatedly to a set of polynomials, each time producing another set in one fewer variables.  Together these sets contain the {\em projection polynomials}.
These are then used in the second phase, \textit{lifting}, to build the CAD incrementally.  First  is decomposed into cells which are points and intervals corresponding to the real roots of the univariate polynomials.  Then  is decomposed by repeating the process over each cell using the bivariate polynomials at a sample point.  The output for each cell consists of {\em sections} (where a polynomial vanishes) and {\em sectors} (the regions between). Together these form a {\em stack} over the cell, and taking the union of these stacks gives the CAD of .  This is repeated until a CAD of  is produced.  
\par
To conclude that a CAD produced in this way is sign-invariant we need delineability.  A polynomial is {\em delineable} in a cell if the portion of its zero set in the cell consists of disjoint sections.  A set of polynomials are {\em delineable} in a cell if each is delineable and the sections of different polynomials in the cell are either identical or disjoint.  The projection operator used must be defined so that over each cell of a sign-invariant CAD for projection polynomials in  variables, the polynomials in  variables are delineable.
\par
The output of a CAD algorithm depends on the variable ordering.  We usually work with polynomials in  with the variables, , in ascending order (so we first project with respect to  and continue to reach  univariate polynomials in ).  The \textit{main variable} of a polynomial () is the greatest variable present with respect to the ordering. 
\par
Major directions of work since 1975 includes the following:
\begin{enumerate}[itemsep=-5pt,topsep=-8pt]
\item Improvements in Collins' main algorithms by \cite[and many others]{McCallum1988}. These have focussed on reducing the projection sets required as 
discussed further later. 
\item Complexity theory of CAD \cite{BrownDavenport2007,DavenportHeintz1988}.
\item Partial CAD, introduced in \cite{CollinsHong1991}, where the structure of  is used to lift only when required to deduce .
\item The theory of equational constraints, 
\cite{McCallum1999a,McCallum2001,BrownMcCallum2005} discussed in Section \ref{subsec:EC}.  This is related to the previous direction but differs by using more efficient projections.  \item CAD via Triangular Decomposition \cite{Chenetal2009d}: a radically different approach for computing a sign-invariant CAD which is used for \textsc{Maple}'s inbuilt CAD command.
\end{enumerate}

\subsection{TTICAD}
\label{sec:Problem}

We define a new type of CAD, the topic of this paper.
\begin{definition}
Let  be a list of QFFs.
We say a cylindrical algebraic decomposition  is a {\em Truth Table Invariant} CAD for  (TTICAD) if the Boolean value of each  is constant (either true or false) on each cell of .
\end{definition}

A full sign-invariant CAD for the set of polynomials occurring in the formulae of  would clearly be a TTICAD.  However, we aim to produce an algorithm that will construct smaller TTICADs for certain . We will achieve this using the theory of equational constraints (first suggested in \cite{Collins1998} with the key theory developed in \cite{McCallum1999a}).
\begin{definition}
Suppose some quantified formula is given:

where the  are quantifiers and  is quantifier free.
An equation  is called an {\bf equational constraint} of  if  is logically implied by  (the quantifier-free part of ). 
Such a constraint may be either explicit or implicit.
\end{definition}
We suppose that we are given a formula list  in which every QFF  has a designated explicit equational constraint .
We will construct TTICADs by generalising McCallum's reduced projection operator for equational constraints (as in \cite{McCallum1999a}) so that we may make use of the equational constraints.

\subsection{Worked Example}
\label{workedexample}

We will provide details for the following worked example.


\noindent Consider the polynomials:

which are plotted in Figure \ref{fig:workedexample1}.
We wish to solve the following problem: find the regions of  where the formula

is true.  Assume that we are using the variable ordering  (so the 1-dimensional CAD is with respect to ).

Both \textsc{Qepcad} \cite{Brown03} and \textsc{Maple} 16 \cite{Chenetal2009d} produce a full sign-invariant CAD for the polynomials with 317 cells.  At first glance it seems that the theory of equational constraints \cite{McCallum1999a,McCallum2001,BrownMcCallum2005} is not applicable here as neither  nor  is logically implied by .  However, while there is no explicit equational constraint we can observe that  is an {\em implicit} constraint of .  Using \textsc{Qepcad} with this declared gives a CAD with 249 cells.  Later, in Section \ref{subsec:workedexample2} we demonstrate how a TTICAD with 105 cells can be produced.

\begin{figure}
\caption{The polynomials from Section~\ref{workedexample}.}\label{fig:workedexample1}
\begin{center}
\includegraphics[scale=0.2]{WE1.jpg}
\end{center}
\vskip-20pt
\end{figure}



\section{Projection Operators}
\label{sec:Project}

\subsection{Equational Constraints}
\label{subsec:EC}

We use two key theorems from McCallum's work on projection and equational constraints.  Both theorems use CADs which are not just sign-invariant but have the stronger property of order-invariance.  A CAD is {\em order-invariant} with respect to a set of polynomials if each polynomial has constant order of vanishing within each cell.

Let  be the McCallum projection operator \cite{McCallum1988}, which produces coefficients, discriminant and cross resultants from a set of polynomials.  We assume the usual trivial simplifications such as removal of constants, exclusion of entries identical to a previous entry (up to constant multiple), and using only the necessary coefficients. 
Recall that a set  is an {\em irreducible basis}
if the elements of  are of positive degree in the main variable, irreducible and pairwise relatively prime. 
The main theorem underlying  follows. 

\begin{theorem}[\cite{McCallum1998}]\label{DJW:theorem:SMcCTheorem1}
Let  be an irreducible basis in  and let  be a connected submanifold of . Suppose each element of   is order-invariant in .
\noindent Then each element of  either vanishes identically on  or is analytic delineable on , (a slight variant on traditional delineability, see \cite{McCallum1998}). The sections of  not identically vanishing are pairwise disjoint, and each element of  not identically vanishing is order-invariant in such sections.  
\end{theorem}

The main mathematical result underlying the reduction of  in the presence of an equational constraint  is as follows.

\begin{theorem}[\cite{McCallum1999a}]\label{DJW:theorem:SMcCTheorem2}
Let  be integral polynomials with positive degree in , 
let  be their resultant, and suppose .
Let  be a connected subset of 
such that  is delineable on  and  is order-invariant in . 
Then  is {\em sign-invariant} in every section of  over .
\end{theorem}

Figure \ref{fig:theorem2} gives a graphical representation of the question answered by Theorem \ref{DJW:theorem:SMcCTheorem2}.  Here we consider polynomials  and  of positive degree in  whose resultant  is non-zero, and a connected subset  in which  is order-invariant.  We further suppose that  is delineable on  (noting that Theorem 1 with  and  provides sufficient conditions for this).  We ask whether  is sign-invariant in the sections of  over .  Theorem \ref{DJW:theorem:SMcCTheorem2} answers this question affirmatively:  the real variety of  either aligns with a given section of  exactly (as for the bottom section of  in Figure \ref{fig:theorem2}), or has no intersection with such a section (as for the top). The situation at the middle section of  cannot happen.    
Theorem \ref{DJW:theorem:SMcCTheorem2} thus suggests a reduction of the projection operator  relative to an equational constraint  for the first projection step, as in \cite{McCallum1999a}.

\begin{figure}
\caption{Graphical representation of Theorem \ref{DJW:theorem:SMcCTheorem2}}\label{fig:theorem2}
\begin{center}
\includegraphics[scale=0.45]{smccfig1a}
\end{center}
\vskip-10pt
\end{figure}

\subsection{A Projection Operator for TTICAD}
\label{subsec:ProjOper}

In \cite{McCallum1999a} the central concept is that of the reduced projection
of a set  of integral polynomials relative to a nonempty subset  of  and it is an extension of this which is central here.
For simplicity in \cite{McCallum1999a}, the concept is first defined for the case when  is an irreducible basis and by analogy we start with a similar special case.
Let  be a list of irreducible bases 
and let  be a list of nonempty subsets
. 
Put  and   (we will use the convention of uppercase Roman letters for sets and calligraphic letters for sequences). 
\begin{definition}\label{def:reducedproj}
We define the {\em reduced projection of  with respect to }, denoted by , as follows:

where 

\end{definition}
In Section \ref{subsec:alg} we build Algorithm \ref{algorithm:TTICADalgorithm} to apply the reduced projection operator for less special input sets by considering contents and irreducible factors of positive degree.


\begin{definition}\label{def:excproj}
The {\em excluded projection polynomials} of  
are those in  but excluded from :

The total set of excluded polynomials, denoted , consists of all the , along with the cross resultants of  with all of  for . 
\end{definition}

\noindent The following theorem is an analogue of Theorem 2.3 of \cite{McCallum1999a},
and provides the foundation for our algorithm in Section \ref{subsec:alg}.

\begin{theorem}\label{DJW:theorem:SMcC3corrected}
  Let  be a connected submanifold of . Suppose each element of  is order invariant in . Then each  either vanishes identically on  or is analytically delineable on , the sections over  of the  which do not vanish identically are pairwise disjoint, and each element  which does not vanish identically is order-invariant in such sections.
  
{\em Moreover}, for each , with , every  is sign-invariant in each section over  of every  which does not vanish identically. 
\end{theorem}

\begin{proof}
The crucial observation is that 
 To see this, recall equation \eqref{eqn:reducedproj} and note that we can write


We can therefore apply Theorem \ref{DJW:theorem:SMcCTheorem1} to the set  and obtain the first three conclusions immediately.

There remains the final conclusion to prove. Let  be in the range , let  and let ; suppose  does not vanish identically on . Now , and so is order-invariant in S by hypothesis. Further, we already concluded that  is delineable. Therefore by Theorem \ref{DJW:theorem:SMcCTheorem2},  is sign-invariant in each section of  over . 
\end{proof}

In the following section we can use Theorem \ref{DJW:theorem:SMcC3corrected} as the key tool for our implementation of TTICAD, so long as the equational constraint  does not vanish identically on the lower dimensional manifold, .  When working with a polynomial  considered in  variables that vanishes identically at a point   we say that  is {\em nullified} at .

\begin{remark}
It is clear that the reduced projection  will lead to fewer (or the same) projection polynomials than the full projection .  
One may consider instead using the reduced projection  of \cite{McCallum1999a}, (with  and  as above).  In the context of Section \ref{sec:Problem} this corresponds to using  as an implicit equational constraint for a single formula.  Note that  also contains fewer polynomials than  in general since  contains all resultants res where  (and ), while  contains only those with  (and ).
\end{remark}

\subsection{Worked Example}
\label{subsec:workedexample2}

In Section \ref{sec:Implementation} we will discuss how to use these results to define an algorithm for TTICAD. First we illustrate the potential savings with our worked example from Section \ref{workedexample}.

In the notation introduced above we have:

We construct the reduced projection sets for each ,

and the cross-resultant set


\begin{figure}
\caption{The polynomials from the worked example along with the solutions to the projection sets.}
\label{fig:workedexample4}
\begin{center}
\includegraphics[scale=0.22]{WE2}
\end{center}
\vskip-10pt
\end{figure}

 is then the union of these three sets.  In Figure \ref{fig:workedexample4} we plot the polynomials (solid curves) and identify the 12 real solutions of  (solid vertical lines).  We can see the solutions align with the asymptotes of the s and the important intersections (those of  with  and  with ).   

If we were to instead use a projection operator based on an implicit equational constraint  then in the notation above we would construct  from  and .  This set provides an extra 4 solutions (the dashed vertical lines) which align with the intersections of  with  and  with .  
Finally, if we were to consider  then we gain another 4 solutions (the dotted vertical lines) which align with the intersections of  and  and the asymptotes of the s.  
In Figure \ref{fig:workedexample5} we magnify a region
to show explicitly that the point of intersection between  and  is identified in , whereas the intersection points of  with both  and  are ignored.

\begin{figure}
\caption{Magnified region of Figure \ref{fig:workedexample4}}\label{fig:workedexample5}
\begin{center}
\includegraphics[scale=0.25]{WE3}
\end{center}
\vskip-20pt
\end{figure}

Hence the 1-dimensional CAD produced using  has 25 cells compared to 33 when using  and 41 when using .  However, it is important to note that this reduction is amplified after lifting (using Theorem \ref{DJW:theorem:SMcC3corrected} and and Algorithm \ref{algorithm:TTICADalgorithm}).  The full dimensional TTICAD has 105 cells, the CAD invariant with respect to the implicit equational constraint has 249 cells  and the full sign-invariant CAD has 317.


\section{Implementation}
\label{sec:Implementation}

\subsection{Algorithm Description and Proof} 
\label{subsec:alg}

We describe carefully Algorithm \ref{algorithm:TTICADalgorithm}.  This will create a TTICAD of  for a list of QFFs, , in variables  where each  has a designated equational constraint  of positive degree.  
We use a subalgorithm \texttt{CADW}, fully specified and validated in \cite{McCallum1998}.  The input of {\tt CADW} is: , a positive integer and , a set of -variate integral polynomials. The output is a Boolean  which if true is accompanied by an order-invariant CAD for  (a list of indices  and sample points ). 

Let  be the set of all polynomials occurring in ,
put , and let  and 
be the lists of the  and , respectively.
Our algorithm effectively defines the reduced projection of  
with respect to  using the special case
of this definition from the previous section. The definition amounts to using 
 for ,
where  is the set of contents of all the elements of all the ,
 is the list 
, such that  is the finest squarefree
basis for the set 
of primitive parts of elements of  which have 
positive degree, and  is the list
, such that  is the finest squarefree basis
for . (The reader will notice that this notation and the 
definition of  is analogous to the work in Section 5 of \cite{McCallum1999a}.)

\begin{algorithm}[h!]\label{algorithm:TTICADalgorithm}


\SetKwInOut{Input}{Input}\SetKwInOut{Output}{Output}
\Input{A list of quantifier-free formulae  in variables . Each  has a designated equational constraint .
}
\Output{Either 
  A TTICAD of  for  (described by lists  and 
   of cell indices and sample points, respectively); or \qquad \qquad  {\ } 
~{\bf FAIL}: If  is not well oriented
(Def. \ref{def:tticadwellorientedness}).
}
\BlankLine
\For{}{
Set .
Compute the finest squarefree basis  for \;
} 
Set \;
\eIf{}{
Isolate in  the real roots of the product of the polynomials in \label{alg:step:base1}\;
\Return  and  for \label{alg:step:base2}\;
}
{
\For{}{
Extract the set  of polynomials in  \; 
Compute the set  of contents of the elements of ; 
Compute the set , the finest squarefree basis for \;
} 
Set ,
 and 
 \;
Construct the projection set:  \;


Attempt to construct a lower-dimensional CAD: \label{alg:step:cadw}\;
\If{}{
\Return {\bf FAIL} ( not well oriented)\label{alg:step:fail}\;
}
\label{TTICADn-1dimstep}

; \label{step:lifting1}\;
\For{each cell }{
\;
\For{}{
\eIf{ is nullified on }{
\eIf{}{
\Return {\bf FAIL} \label{notwellor2}  ( not well oriented)\;}{
\label{addthebi}\;}
}{
\;
}
}
Lift over  using : construct cell indices and sample points for the stack over  of the polynomials in , adding them to  and \label{step:lifting2}\;
}

\Return  and  for \;
\caption{{TTICAD Algorithm}}
}
\end{algorithm}

We shall prove that, provided  and  are well-oriented as in Definition \ref{def:tticadwellorientedness}, the output of  Algorithm \ref{algorithm:TTICADalgorithm} is indeed a TTICAD for .
Note that this condition is specialised and new, introduced for this paper.  Its requirement is due to both the use of \texttt{CADW} from \cite{McCallum1998} and the introduction of our new reduced projection operator.

We first recall the more general notion of well-orientedness from \cite{McCallum1998}.  A set  of
-variate polynomials is said to be {\em well oriented} if whenever ,
every  is nullified by at most a finite number of points
in , and (recursively)  is well-oriented.  The Boolean output of \texttt{CADW} is false if the input set was not well-oriented in this sense. 
Now we define our new notion of well-orientedness for the set lists  and  defined above, and hence .
\begin{definition}\label{def:tticadwellorientedness}
We say  is {\em well oriented with respect to}  (and that  is {\em well oriented}) if whenever , every constraint polynomial  is nullified by at most a finite number of points in , and  
(hence  in the algorithm) is well-oriented in the sense of \cite{McCallum1998}.
\end{definition}
\begin{theorem}
The output of Algorithm \ref{algorithm:TTICADalgorithm} is as specified.  
\end{theorem}
\begin{proof}
We must show that when  is well-oriented the output is a Truth Table Invariant CAD, (each  has constant truth value in each cell of ), and \textbf{FAIL} otherwise.

If the input was univariate then it is trivially well-oriented.  The algorithm will construct a CAD  of  using the roots of the irreducible factors of the constraint polynomials (steps \ref{alg:step:base1} to \ref{alg:step:base2}).
At each 0-cell all the polynomials in each  trivially have constant signs, and hence every  has constant truth value.  In each 1-cell no constraint polynomial has a root, so every  has constant truth value .

Now suppose .  
If  is not well-oriented in the sense of \cite{McCallum1998} then \texttt{CADW} returns  as false.  In this case the input  is not well oriented in the sense of Definition \ref{def:tticadwellorientedness} and Algorithm \ref{algorithm:TTICADalgorithm} correctly returns \textbf{FAIL}.  Otherwise,  is well-oriented and at step \ref{alg:step:cadw} we have .  Further,  and  specify a CAD, , order-invariant with respect to .
Let , a submanifold of , be a cell of .

Suppose first that the dimension of  is positive.
If any constraint polynomial  vanishes identically on  then  is not well oriented in the sense of Definition \ref{def:tticadwellorientedness} and the algorithm correctly returns \textbf{FAIL} at step \ref{notwellor2}.  
Otherwise, we know that  is certainly well-oriented.  Since no constraint polynomial  vanishes then no element of the basis  vanishes identically on  either.  Hence, by Theorem \ref{DJW:theorem:SMcC3corrected}, applied with  and , each element of  is delineable on , and the sections over  of the elements of  are pairwise disjoint.
Thus the sections and sectors over  of the elements of  comprise
a stack  over .  Furthermore, Theorem \ref{DJW:theorem:SMcC3corrected} assures us that, for each , every element of  is sign-invariant in each section over  of every element of .

Let . Consider first a section  of the stack .
We shall show that  has constant truth value in .
Now the constraint polynomial  is a product of its content  
and some elements of the basis .
But , an element of ,
is sign-invariant in the whole cylinder  which includes . Moreover all of the elements of  are sign-invariant in , as noted previously. Therefore  is sign-invariant in .
If  is positive or negative in  then
 has constant truth value  in .

Suppose that  throughout .
It follows that  must be a section of some element of the basis .
Let  be a non-constraint polynomial in .
Now, by the definition of , we see  can be written as 
 where . 
But , in ,
is sign-invariant in the whole cylinder  including .
Moreover each  is sign-invariant in , as noted previously.
Hence  is sign-invariant in .  (Note that in the case where  does not have main variable  then  and the conclusion still holds).
Since  was an arbitrary element of ,
it follows that all polynomials in  are sign-invariant in ,
and hence that  has constant truth value in .

Next consider a sector  of the stack , and notice that
at least one such sector exists.
As observed above,  is sign-invariant in ,
and  does not vanish identically on .
Hence  is non-zero throughout . Moreover
each element of the basis  is delineable on .
Hence the constraint polynomial  is nullified by no point of .
It follows from this that the algorithm does not return \textbf{FAIL}
during the lifting phase.
It follows also that  throughout .
Therefore  has constant truth value  in .

It remains to consider the case in which the dimension of  is 0.
In this case the roots of the polynomials in the lifting set  constructed
by the algorithm determine a stack  over .
Each  trivially has constant truth
value in each section (0-cell) of this stack,
and the same can routinely be shown for each sector (1-cell) of this stack.
\end{proof}

\begin{remark}
When the input to Algorithm \ref{algorithm:TTICADalgorithm} is a single QFF then it produces a CAD which is invariant with respect to the sole equational constraint.  This may be shown using the results of \cite{McCallum1999a} alone.  However, we note that  Algorithm \ref{algorithm:TTICADalgorithm} is actually more efficient in the lifting stage than the modified QEPCAD algorithm discussed in \cite{McCallum1999a} since the lifting set excludes some non-equational constraint input polynomials.
\end{remark} 

Algorithm \ref{algorithm:TTICADalgorithm} and Definition \ref{def:tticadwellorientedness} have been kept conceptually simple to aid readability. However in practice the algorithm may sometimes be unnecessarily cautious.  
In \cite{Brown2005}, several cases where non-well oriented input can still lead to an order-invariant CAD are discussed. Similarly here, we can sometimes allow the nullification of an equational constraint on a positive dimensional cell.

\begin{lemma}\label{lemma:constpolys}
Let  be an equational constraint which vanishes identically on a cell  constructed during Algorithm \ref{algorithm:TTICADalgorithm}. If all polynomials in  are constant on  then any  will be delineable over . 
\end{lemma}

\begin{proof}
Suppose first that  and  satisfy the simplifying conditions from Section \ref{subsec:ProjOper}. Rearranging \eqref{eqn:exclprojeqn} we see
  

However, given the conditions of the lemma, this is equivalent (after the removal of constants which do not affect CAD construction) to  on .  So here  is a subset of  and we can conclude by Theorem \ref{DJW:theorem:SMcCTheorem1} that all elements of  vanish identically on  or are delineable over . 

In the more general case we can still draw the same conclusion because .
\end{proof}

Hence we can use Lemma \ref{lemma:constpolys} to safely extend step \ref{addthebi} to also apply in such cases. In particular, we can allow equational constraints  which do not have main variable  in such cases. We have included this in our implementation discussed in Section \ref{MapleSec}.
In  theory, we may be able to go further and allow step \ref{addthebi} to apply in cases where the polynomials in  are not necessarily all constant, but have no real roots within the cell . However, identifying such cases would require answering a separate quantifier elimination question, which may not be trivial. 

\subsection{TTICAD via the ResCAD Set}

In Algorithm \ref{algorithm:TTICADalgorithm} the lifting stage (steps \ref{step:lifting1} to \ref{step:lifting2}) varies according to whether an equational constraint is nullified.  When this does not occur there is an alternative implementation of TTICAD which would be simpler to introduce into existing CAD algorithms.  
Define the {\em ResCAD Set} of  as


\begin{theorem} \label{THEOREM:PROJEQUALSRES}
   Let  be a list of irreducible bases 
and let  be a list of non-empty subsets
.   
  For the McCallum projection operator , \cite{McCallum1988} we have:
  
\end{theorem}
The proof is straightforward and so omitted here.  


\begin{corollary}\label{corollary:rescad}
If no  is nullified by a point in  then inputting  into any algorithm which produces a sign-invariant CAD using McCallum's projection operator, will result in the TTICAD for  produced by Algorithm \ref{algorithm:TTICADalgorithm}.
\end{corollary}

Hence Corollary \ref{corollary:rescad} gives us a simple way to compute TTICADs using existing CAD implementations, such as {\sc Qepcad}, but this cannot be applied as widely as Algorithm \ref{algorithm:TTICADalgorithm}.

\subsection{Implementation in Maple} 
\label{MapleSec}

There are various implementations of CAD available but none guarantee order-invariance, required for proving the validity of our TTICAD algorithm.  
Hence we needed to construct our own implementation to obtain experimental results.  We built an implementation of McCallum projection, so that we could reproduce {\tt CADW} and modified the existing stack generation commands in \textsc{Maple} from \cite{Chenetal2009d} so they could be used more widely.  Together these allowed us to fully implement Algorithm \ref{algorithm:TTICADalgorithm}.  The CAD implementation grew to a \textsc{Maple} package \texttt{ProjectionCAD} which gathers together algorithms for producing CADs via projection and lifting to complement the existing CAD commands in \textsc{Maple} which use triangular decomposition, giving the same representation of sample points using regular chains.  For further details (along with free access to the code) see \cite{ProjectionCAD}.



\subsection{Formulating a Problem for TTICAD} 
\label{subsection:heuristic}

When formulating a problem for TTICAD there may be choices for the input, such as choosing which equational constraint to designate in a QFF when more than one is present.  Other possibilities include choosing whether conjunctions of formulae should be split into separate QFFs.  Usually it will be preferable to minimise the number of QFFs, but if for example a designated equational constraint has many intersections with another polynomial which could be ignored by using separate QFFs, then the cost of the extra polynomials in the projection set may be outweighed by the complexity of those removed.  
Hence it is worth taking care in how we formulate the TTICAD.  
A simple problem of the form

has six acceptable choices for the composition of .

We have started exploring heuristics for choosing the best composition. The metric  {\tt sotd} (sum of total degrees) as defined in \cite{Dolzmannetal2004a} may be used to approximate the complexity of polynomials. 
We first considered using \texttt{sotd} and found that while it was fairly well correlated with the number of cells produced by Algorithm \ref{algorithm:TTICADalgorithm} it was not always fine enough to separate compositions leading to TTICADs with significantly different numbers of cells.  Hence we prefer a stronger heuristic, \texttt{sotd} where  is the complete set of projection polynomials obtained by repeatedly applying .  

For the problems in Section \ref{sec:Experiment} we used the QFFs imposed by the disjunctions of formulae using this heuristic to choose which equational constraints are designated when there was a choice. For these problems the heuristic computation time was negligible compared to the overall time, but for larger problems this would not be the case.  Work on heuristics is ongoing with a more detailed report available in \cite{BDEW13}. 







\section{Experimental Results}
\label{sec:Experiment}

\subsection{Description of experiments}

Our timings were obtained on a Linux desktop (3.1GHz Intel processor, 8.0Gb total memory) with {\sc Maple} 16 (command line interface), {\sc Mathematica} 9 (graphical interface) and {\sc Qepcad-B} 1.69.  
For each experiment we produce a CAD and give the time taken and number of cells (cell count). The first is an obvious metric while the second is crucial for applications performing operations on each cell.  

For {\sc Qepcad} the options {\tt +N500000000} and {\tt +L200000} were provided, the initialization included in the timings and explicit equational constraints declared when present with the product of those from the individual QFFs declared otherwise.  
In {\sc Mathematica} the output is not a CAD but a formula constructed from one \cite{Strzebonski10}, with the actual CAD not available to the user.  Cell counts for the algorithms were provided by the author of the {\sc Mathematica} code. 

TTICADs are calculated using our implementation described in Section \ref{MapleSec}, which is simple and not optimized.  The results in this section are not presented to claim that our implementation is state of the art, but to demonstrate the power of the TTICAD theory over the the conventional theory, and how it can allow even a simple implementation to compete.  Hence the cell counts are of most interest.

The time is measured to the nearest tenth of a second, with a time out (T/O) set at  seconds.   When {\bf F} occurs it indicates failure due to a theoretical reason such as not well-oriented (in either sense).  The occurrence  of Err indicates an error in an internal subroutine of {\sc Maple}'s \texttt{RegularChains} package, used by \texttt{ProjectionCAD}.  This error is not theoretical but a bug, 
beyond our control. 

We considered examples originating from \cite{BuchbergerHong1991}.  However these problems (and most others in the literature) involve conjunctions of conditions, chosen as such to make them amenable to existing technologies.
These problems can be tackled using TTICAD, but they do not demonstrate its full strength. Hence we introduced new examples, denoted with a , which are adapted from \cite{BuchbergerHong1991} to have disjuncted QFFs.

Two examples came from the application of branch cut analysis for simplification.  These problems require a decomposition according to branch cuts of the form , and then go on to test the validity of a simplification on each cell, \cite[etc.]{Phisanbutetal2010a}.  We need to consider the disjunction of the branch cuts making such problems suitable for Algorithm \ref{algorithm:TTICADalgorithm}.  We included a key example from Kahan \cite{Kahan1987b}, along with the problem induced by considering the validity of the double angle formulae for arcsin.  Finally we considered the worked example from Section \ref{workedexample} and its generalisation to three dimensions.
Note that A and B following the problem name indicate different variable orderings.  Full details for all examples can all be found in the CAD repository \cite{Wilsonetal2012b}
available freely online at \texttt{http://opus.bath.ac.uk/29503}.
 
\subsection{Results}

We present our results in Table \ref{table:CADW:TTICAD}.  For each problem we give the name used in the repository,  the number of variables,  the maximum degree of polynomials involved and  the number of QFFs used for TTICAD.  We then give the time taken and number of cells produced by each algorithm.  

We first compare our TTICAD implementation with the sign-invariant CAD generated using \texttt{ProjectionCAD} with McCallum's projection operator \cite{ProjectionCAD}.  Since these use the same architecture the comparison makes clear the benefits of the TTICAD theory.  The experiments confirm the fact that  
the cell count for TTICAD will always be less than or equal to that of a sign-invariant CAD produced using the same implementation.  Ellipse A is not well-oriented in the sense of \cite{McCallum1998}, and so both methods return {\bf FAIL}.  Solotareff A and B are well-oriented in this sense but not in the stronger sense of Definition \ref{def:tticadwellorientedness} and hence TTICAD fails while the full sign-invariant CADs can be produced.  The only example with equal cell counts is Collision A in which the non-equational constraints were so simple that the projection polynomials were unchanged.  Examining the results for the worked example and its generalisation we start to see the true power of TTICAD. In 3D Example A we see a 759-fold reduction in time and a 50-fold reduction in cell count. 

\begin{sidewaystable*}
\caption{Comparing TTICAD to the full CAD built with the same architecture and other CAD algorithms.} \begin{center}
\label{table:CADW:TTICAD}
\begin{tabular}{lccc|rr|rr|rr|rr|rr}
  \multicolumn{4}{c|}{Problem} 
& \multicolumn{2}{|c|}{Full-CAD} & \multicolumn{2}{|c|}{TTICAD} 
& \multicolumn{2}{|c|}{{\sc Qepcad}} & \multicolumn{2}{|c|}{{\sc Maple}}  
& \multicolumn{2}{|c}{{\sc Mathematica}} \\
Name & n & d & t
                        &  Time      &  Cells      &  Time      &  Cells       
                        &  Time      &  Cells      &  Time      &  Cells       
                        &  Time      &  Cells \\
\hline
Intersection A          & 3 & 2 & 1
						& 360.1     &  3707       &  1.7       &  269         
						& 4.5       &  825        &  ---       &  Err     
						& 0.0 & 3   \\
Intersection B          & 3 & 2 & 1
						& 332.2     &  2985       &  1.5       &  303         
						& 4.5       &  803        &  50.2      &  2795    
						& 0.0 & 3   \\
Random A                & 3 & 3 & 1
						& 268.5     &  2093       &  4.5       &  435         
						& 4.6       &  1667       &  23.0      &  1267    
						& 0.1 & 657 \\
Random B                & 3 & 3 & 1
						& 442.7     &  4097       &  8.1       &  711         
						& 5.4       &  2857       &  48.1      &  1517    
						& 0.0 & 191 \\ 
Intersection A & 3 & 2 & 2
						&  360.1     &  3707       &  68.7      &  575         
						&  4.8       &  3723       &  ---       &  Err     
						& 0.1 & 601 \\
Intersection B & 3 & 2 & 2
						&  332.2     &  2985       &  70.0      &  601         
						&  4.7       &  3001       &  50.2      &  2795    
						& 0.1 & 549 \\
Random A       & 3 & 3 & 2
						&  268.5     &  2093       &  223.4     &  663         
						&  4.6       &  2101       &  23.0      &  1267    
						& 0.2 & 808 \\
Random B       & 3 & 3 & 2
						&  442.7     &  4097       &  268.4     &  1075        
						&  142.4     &  4105       &  48.1      &  1517    
						& 0.2 & 1156 \\
Ellipse A      & 5 & 4 & 2
						&  ---       &  {\bf F}    &  ---       &  {\bf F}     
						&  291.6     &  500609     &  1940.1    &  81193   
						& 11.2 & 80111 \\
Ellipse B      & 5 & 4 & 2
						&  T/O       &  ---        &  T/O       &  ---         
						&  T/O       &  ---        &  T/O       &  ---     
						& 2911.2 & 16603131 \\
Solotareff A   & 4 & 3 & 2
						&  677.6     &  54037      &  46.1      &  {\bf F}    
						&  4.9       &  20307      &  1014.2    &  54037   
						& 0.1 & 260 \\   
Solotareff B   & 4 & 3 & 2
						&  2009.2    &  154527     &  123.8     &  {\bf F}     
						&  6.3       &  87469      &  2951.6    &  154527  
						& 0.1 & 762 \\
Collision A    & 4 & 4 & 2
						&  264.6     &  8387       &  267.7     &  8387        
						&  5.0       &  7813       &  376.4     &  7895    
						& 3.6 & 7171 \\ 
Collision B    & 4 & 4 & 2
						&  ---       &  Err        &  ---         &  Err       
						& T/O        &  ---        &  T/O       &  ---     
						& 591.5 & 1234601 \\
Kahan A                 & 2 & 4 & 7
						&  10.7      &  409        &  0.3       &  55          
						&  4.8       &  261        &  15.2      &  409     
						& 0.0 & 72 \\       
Kahan B                 & 2 & 4 & 7
						&  87.9      &  1143       &  0.3       &  39        
						&  4.8       &  1143       &  154.9     &  1143    
						& 0.1 & 278 \\
Arcsin A                & 2 & 4 & 4
						&  2.5       &  225        &  0.3       &  57          
						&  4.6       &  225        &  3.3       &  225     
						& 0.0 & 175 \\       
Arcsin B                & 2 & 4 & 4
						&  6.5       &  393        &  0.2       &  25          
						&  4.5       &  393        &  7.8       &  393     
						& 0.0 & 79 \\
2D Example A            & 2 & 2 & 2
						&  5.7       &  317        &  1.2       &  105         
						&  4.7       &  249        &  6.3       &  317     
						& 0.0 & 24 \\
2D Example B            & 2 & 2 & 2
						&  6.1       &  377        &  1.5       &  153         
						&  4.5       &  329        &  7.2       &  377     
						& 0.0 & 175 \\
3D Example A            & 3 & 3 & 2
						&  3795.8    &  5453       &  5.0       &  109         
						&  5.3       &  739        &  ---       &  Err     
						& 0.1 & 44 \\
3D Example B            & 3 & 3 & 2
						&  3404.7    &  6413       &  5.8       &  153         
						&  5.7       &  1009       &  ---       &  Err     
						& 0.1 & 135 \\
\end{tabular}
\end{center}
\vskip-20pt
\end{sidewaystable*}

We next compare our implementation of TTICAD with the state of the art in CAD: {\sc Qepcad} \cite{Brown03}, {\sc Maple} \cite{Chenetal2009d} and {\sc Mathematica} \cite{Strzebonski06, Strzebonski10}.  {\sc Mathematica} is the quickest, however TTICAD often produces fewer cells.  We note that {\sc Mathematica}'s algorithm uses powerful heuristics and so actually used Gr\"obner bases on the first two problems, causing the cell counts to be so low.  When all implementations succeed TTICAD usually produces far fewer cells than {\sc Qepcad} or {\sc Maple}, especially impressive given {\sc Qepcad} is producing partial CADs for the quantified problems, while TTICAD is only working with the polynomials involved.  
For Collision A the TTICAD theory offers no benefit allowing the better optimized alternatives to have a lower cell count.
 
Reasons for the TTICAD implementation struggling to compete on speed in general are that the {\sc Mathematica} and {\sc Qepcad} algorithms are largely implemented directly in {\tt C}, have had far more optimization, and in the case of {\sc Mathematica} use validated numerics for lifting \cite{Strzebonski06}.  However, the strong performance in cell counts is very encouraging, both due its importance for applications where CAD is part of a wider algorithm (such as branch cut analysis) and for the potential if TTICAD theory were implemented elsewhere.



\section{Conclusions}
\label{sec:Conc}

We have defined Truth Table Invariant CADs, which can be more closely aligned to the needs of problems than traditional sign-invariant CADs.  Theorem \ref{DJW:theorem:SMcC3corrected} extended the theory of equational constraints allowing us to develop Algorithm \ref{algorithm:TTICADalgorithm} to construct TTICADs efficiently for a large range of problems.  The algorithm has been implemented in {\sc Maple} giving promising experimental results.  TTICADs in general have less cells than full sign-invariant CADs using the same implementation and we showed that this allows even a simple implementation of TTICAD to compete with the state of the art CAD implementations.  It is anticipated that future implementations of TTICAD could be far better optimized leading to lower times for the same cell counts.  We also note that the benefits of TTICAD increase with the number of QFFs in a problem and so larger problems may be susceptible to TTICAD when other approaches fail.
 
We hope that these results inspire other implementations of TTICAD, with Corollary \ref{corollary:rescad} showing a particularly easy way to adapt existing CAD implementations.    

\subsection{Future Work}

There is scope for optimizing the algorithm and extending it to allow less restrictive input.  Lemma \ref{lemma:constpolys} gives one extension that is included in our implementation while other possibilities include removing some of the caution implied by well-orientedness, analogous to \cite{Brown2005}.  Also, work developing heuristics for composing the input is underway in \cite{BDEW13}.  

Of course, the implementation of TTICAD used here could be improved in many ways, but perhaps more desirable would be for TTICAD to be incorporated into existing state of the art CAD implementations.  In particular, we would like to use the existing {\sc Maple} CAD commands \cite{Chenetal2009d} but this requires first understanding when they give order-invariance, a key question currently under consideration.  
We see several possibilities for the theoretical development of TTICAD:
\begin{itemize}[itemsep=-4.5pt,topsep=-10pt]
\item Can we apply the theory recursively instead of only at the top level?  For example by widening the projection operator to 
conclude order-invariance, as in \cite{McCallum2001}.  
\item Can we apply TTICAD to forms of QFF other than ``one equality and other items''?
For example, can we generalise the theory of bi-equational constraints?
\item Can we make use of the ideas behind partial CAD to avoid unnecessary lifting once the truth value of a QFF on a cell is determined? 
\item Can anything be done when  is not well oriented?
\item Can we implement the lifting algorithm in parallel?
\end{itemize}

\subsection*{Acknowledgements}
We are grateful to A.~Strzebo\'nski for assistance in performing the Mathematica tests and to the anonymous referees for useful comments.  We also thank the rest of the Triangular Sets seminar at Bath (A.~Locatelli, G.~Sankaran and N.~Vorobjov) for their input, and the team at Western University (C.~Chen, M.~Moreno Maza, R.~Xiao and Y.~Xie) for access to their {\sc Maple} code and helpful discussions. This work was supported by the EPSRC grant: EP/J003247/1.



\bibliography{jhd-edit}

\end{document}
