\documentclass[preprint]{elsarticle}

\usepackage{amsmath,epsfig}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{fullpage}
\usepackage{listings}
\lstset{
  basicstyle=\ttfamily,
  mathescape
}

\usepackage[ruled,vlined,linesnumbered]{algorithm2e}
\usepackage{qtree}
\usepackage{subfigure}
\usepackage{url}


\usepackage[usenames,dvipsnames]{pstricks}
\usepackage{epsfig}
\usepackage{pst-grad} \usepackage{pst-plot} 
\newtheorem{theorem}{Theorem}[section]
\newtheorem{lemma}{Lemma}[section]
\newtheorem{definition}{Definition}[section]
\newtheorem{observation}{Observation}[section]
\newtheorem{fact}{Fact}[section]

\newcommand{\qedsymb}{\hfill{\rule{2mm}{2mm}}}
\newenvironment{proofsketch}{\begin{trivlist}
\item[\hspace{\labelsep}{\noindent Proof Sketch: }]
}{\qedsymb\end{trivlist}}


\newcommand{\st}{:}


\newcommand{\remove}[1]{}

\DeclareMathOperator{\sus}{\mathit{SUS}}
\DeclareMathOperator{\lsus}{\mathit{LSUS}}
\DeclareMathOperator{\sa}{\mathit{SA}}
\DeclareMathOperator{\rank}{\mathit{Rank}}
\DeclareMathOperator{\lcp}{\mathit{LCP}}
\DeclareMathOperator{\sls}{\mathit{SLS}}
\DeclareMathOperator{\can}{\mathit{Candidate}}
\DeclareMathOperator{\lr}{\mathit{LR}}
\DeclareMathOperator{\llr}{\mathit{LLR}}
\DeclareMathOperator{\llrs}{\mathit{LLRS}}
\DeclareMathOperator{\lrs}{\mathit{LRS}}

\DeclareMathOperator{\e}{E}
\DeclareMathOperator{\var}{Var}




\begin{document}

\begin{frontmatter}

  \title{On Longest Repeat Queries\tnoteref{t1}}

 \tnotetext[t1]{Author names are in alphabetical order. 
}

\author[a1]{Atalay Mert \.{I}leri}
\address[a1]{Massachusetts Institute of Technology, USA}
\ead{atalay@mit.edu}

\author[a2]{M. O\u{g}uzhan  K\"{u}lekci}
\address[a2]{Istanbul Medipol University, Turkey}
\ead{okulekci@medipol.edu.tr}

\author[a3]{Bojian Xu\corref{c1}} 
\address[a3]{
Eastern Washington University, USA}
\ead{bojianxu@ewu.edu} \cortext[c1]{Corresponding author. Mailing address: 319F CEB,
  Eastern Washington University,
  Cheney, WA 99004, USA. Phone:
  +1 (509) 359-2817. Fax: +1 (509) 359-2215. 
}



\begin{abstract} 
  Repeat finding in strings has important applications in subfields
  such as computational biology. Surprisingly, all prior work on
  repeat finding did not consider the constraint on the locality of
  repeats. In this paper, we propose and study the problem of finding
  longest repetitive substrings covering particular string positions.
  We propose an  time and space algorithm for finding the
  longest repeat covering every position of a string of size . Our
  work is optimal since the reading and the storage of an input string
  of size  takes  time and space.  Because any
  substring of a repeat is also a repeat, our solution to longest
  repeat queries effectively provides a ``stabbing'' tool for
  practitioners for finding most of the repeats that cover particular string
  positions.
 \end{abstract}







\begin{keyword}
   information retrieval\sep string processing \sep repeats \sep
   regularities \sep repetitive structures
 \end{keyword}


\end{frontmatter}



\section{Introduction}

Repetitive structures and regularities finding in genomes and proteins
is important as these structures play important roles in the 
biological functions of genomes and proteins~\cite{Gus97}.  It is
well known that overall about one-third of the whole human genome
consists of repeated subsequences~\cite{McC1993}; about 10--25\% of
all known proteins have some form of repetitive
structures~\cite{LW06}. In addition, a number of significant problems
in molecular sequence analysis can be reduced to repeat
finding~\cite{Mar83}. Another motivation for finding repeats is to
compress the DNA sequences, which is known as one of the most
challenging tasks in the data compression field. DNA sequences consist
only of symbols from {\tt \{ACGT\}} and therefore can be represented
by two bits per character. Standard compressors such as {\tt gzip} and
{\tt bzip} usually use more than two bits per character and therefore
cannot reach good compression. Many modern genomic sequence data
compression techniques highly rely on the repeat finding in the
sequences~\cite{MR04,BF05}.







The notion of maximal repeat and super maximal
repeat~\cite{Gus97,KVX-BIBM2010,KVX-tcbb2012,BBO-spire2012} captures
all the repeats of the whole string in a space-efficient manner, but
it does not track the locality of each repeat and thus can not support
the finding of repeats that cover a particular string position.
In this paper, we propose and study the problem of finding longest
repetitive substrings covering any particular string positions.
Because any substring of a repeat is also a repeat, the solution to
longest repeat queries effectively provides a ``stabbing'' tool for
practitioners for finding most of the repeats that cover particular
string positions.
\remove{
The recent study of finding shortest unique substrings (SUS) covering
particular string positions~\cite{PWY-ICDE2013,
TIBT2014,IKX-CPM2014} may help find some repeats
covering particular string positions, because any extension of a SUS
must be a repeat.  However, such trivial reduction does not guarantee
the finding of the longest repeat that covers an arbitrary string
position. In fact, it is not yet well understood how to reduce longest
repeat finding to SUS finding.
}

In this paper, we propose an  time and space algorithm that can
find the \emph{leftmost} longest repeat of every string
position. We view our solution to be optimal in both time and space, 
because one has to spend  time and space to read
and store the input string.








\section{Preliminary}
\label{sec:prelim}
We consider a {\bf string} ,
where each character  is
drawn from an alphabet .
A {\bf substring} 
of  represents  if ,
and is an empty string if .
String  is a {\bf proper substring} of another string
 if  and . 
The {\bf length} of a non-empty substring , denoted as
, is . We define the length of an empty string
as zero. 
A {\bf prefix} of  is a substring 
for some , . 
A {\bf proper prefix}  is a prefix of  where .
A {\bf suffix} of  is a substring
 for some , .  
A {\bf proper suffix}  is a suffix of  where .
We say the character  occupies the string {\bf position} .
We say the substring  {\bf covers} the th position of
, if .  
For two strings  and , we write  (and say  is {\bf
  equal} to ), if  and  for 
.  
We say  is lexicographically smaller than ,
denoted as , if (1)  is a proper prefix of , or (2)
, or (3) there exists an integer  such that
 for all  but .
A substring
 of  is {\bf unique}, if there does not exist
another substring  of , such that 
 but . 
A substring is a {\bf repeat} if it is not unique.
A character  is a {\bf singleton}, if it appears only once in
.


\begin{definition}
\label{def:lr}
For a particular string position ,  
the {\bf longest repeat (LR) covering position} , denoted
as , is 
a repeat substring , such that: (1) , and 
(2) there does not exist  another repeat substring , such
that  and . 
\end{definition}

\begin{definition}
\label{def:llr}
For a particular string position , the
{\bf left-bounded longest repeat (LLR) starting at position },
denoted as , is a repeat ,
such that either  or  is unique. 
\end{definition}


Obviously, 
for any string position , if  is not a singleton, both
 and 
must exist, because at least  itself is a repeat. 
Further, there might be multiple choices for . For
example, if , then  can be either
 or .
However, if  does exist, it
must have only one choice, because  is a fixed string position and
the length of  must be as long as possible.




The {\bf suffix array}  of the string  is a
permutation of , such that for any  and ,
, we have .
That is,  is the starting position of the th suffix in
the sorted order of all the suffixes of .
The {\bf rank array}  is the inverse of the suffix
array. That is,  iff . 
The {\bf longest common prefix (lcp) array}  is an
array of  integers, such that for ,  is
the length of the lcp of the two suffixes  and
. We set .  In the literature,
the lcp array is often defined as an array of  integers. We include
an extra zero at  is only to simplify the description 
of our upcoming
algorithms.  
Table~\ref{tab:suflcp}
in the appendix 
shows the suffix array and the lcp
array of the example string {\tt mississippi}.




The next Lemma~\ref{lem:llr} shows that, by using the rank array and
the lcp array of the string , it is easy to calculate any  if
it exists or to detect the fact that it does not exist. 




\begin{lemma}
\label{lem:llr}
For : 

where .
\end{lemma}

\begin{proof}
  Note that  is the length of the lcp between the suffix
   and any other suffix of .  If , it means
  substring  is the lcp among  and any
  other suffix of . So  is .  Otherwise
  (), the letter  is a singleton, so  does not
  exist.
\end{proof}



\section{Longest repeat finding for one position}   
\label{sec:one}
In this section, we want to find  for a given string position
, using  time and space.  We present the solution to this
setting
here in 
case the practitioners have only a smaller number of 
string positions, for which they want to find the longest repeats, 
and thus this light-weighted solution will suffice.
We will start with finding the leftmost  if the string position
 is covered by multiple LRs. In the end of the section, we will
show a trivial extension to find all LRs covering position  with
the same time and space complexities, if  has multiple LRs.

\begin{lemma}
\label{lem:lr-llr}
Every LR is an LLR.
\end{lemma}

\begin{proof}
Assume that  is not an LLR. Note that  is a repeat starting from position . If  is not
an LLR, it means  can be extend to some position
, so that  is still a repeat and  also covers
position . That says, .
However, the contradiction is that  is already the longest repeat
covering position . 
\end{proof}

\begin{lemma}
\label{lem:llr-cover}
For any three string positions , , and , : if
 does not exist or does not cover position ,  does
not exist or does not cover position  either.
\end{lemma}

\begin{proof}
  (1) If  does not exist, then  is a singleton.  If
   does exist and covers position , then  also covers
 position , which yields a contradiction that 
  the substring  includes the singleton  but is a repeat. 
(2) If  does exist but does not cover position
  , then  is unique and . If 
  exists and covers position , say , 
  , it means  is a substring of a repeat
  , because , so 
  is also a repeat. This contradicts to the fact that
   is unique. So    does not exist or does not
  cover position . 
\end{proof}

The idea behind the algorithm for finding the LR covering a given
position is straightforward.  Algorithm~\ref{algo:one} shows the
pseudocode, where the found LR is returned as a tuple
, representing the starting position and the length of
the LR, respectively. 
If the LR that is being searched for does not
exist,  is returned by Algorithm~\ref{algo:one}.
 We know that any longest repeat covering
position  must be an LLR (Lemma~\ref{lem:lr-llr}), starting between
indexes  to  inclusive.
What we need to do is to simply compute every individual of  using Lemma~\ref{lem:llr} and check whether it covers
position  or not.  We will just choose the longest LLR that covers
position  and resolve the tie by picking the leftmost one if  is
covered by multiple LRs (Line~\ref{line:tie}).
Due to Lemma~\ref{lem:llr-cover}, a practical speedup is possible via
an early stop (Line~\ref{line:break}) by computing and checking from
 down to  (Line~\ref{line:for}). 
   
\begin{algorithm}[t]
{\small
  \caption{Find . Return the leftmost one if  has multiple LRs.}
\label{algo:one}
\KwIn{The position index , and the rank array and 
      the lcp array of the string } 
\KwOut{ or find no such LR. The leftmost one will be returned if  has multiple
LRs.}

\smallskip 

;  
\tcp*{start position and length of }

\For{ down to \label{line:for}}{
  \tcp*{Length
    of }

  \If(\tcp*[f]{ does not exist or does not cover .}){ or }{break\tcp*{Early stop}\label{line:break}}
  \ElseIf(\tcp*[f]{Tie is resolved by picking the leftmost one.}){\label{line:tie}}{; \;}
}
Print \;
}\end{algorithm}


\begin{lemma}
\label{lem:one}
Given the rank array and the lcp
array of the string ,
for any position  in the string , Algorithm~\ref{algo:one} 
can find  or the
fact that it does not exist, using
 time and  space.  If there are multiple candidates for
, the leftmost one is returned.
 \end{lemma}

 \begin{proof}
   The algorithm clearly has no more than  steps and each step
   takes  time, so it costs a total of  time. The space cost is primarily
  from the rank array and the lcp array, which altogether is ,
   assuming each integer in these arrays costs a constant number of
   bytes.  

 \end{proof}

\begin{theorem}
\label{thm:one}
For any position  in the string , we can find  or the
fact that it does not exist, using
 time and  space.  If there are multiple candidates for
, the leftmost one is returned.
\end{theorem}

\begin{proof}
  The suffix array of  can be constructed by existing algorithms
  using  time and space (For ex., \cite{KA-SA2005}). After the
  suffix array is constructed, the rank array can be trivially created
  using  time and space.  We can then use the suffix array and
  the rank array to construct the lcp array using another  time
  and space~\cite{KLAAP01}.  Given the rank array and the lcp array,
  the time cost of Algorithm~\ref{algo:one} is 
  (Lemma~\ref{lem:one}). So altogether, we can find  or the
  fact that it does not exists using  time and space.
If multiple LRs cover position , the leftmost LR will be returned
  as is guaranteed by Line~\ref{line:tie} of
  Algorithm~\ref{algo:one}. 
\end{proof}



\smallskip 
\noindent
{\bf Extension: Find all LRs covering a given position.} 
It is trivial to extend Algorithm~\ref{algo:one} to find all the LRs
covering any given position  as follows. We can first use
Algorithm~\ref{algo:one} to find the leftmost . If  does
exist, then we will start over again to recheck  down to
 and return those whose length is equal to the length of
. Due to Lemma~\ref{lem:llr-cover}, the same early stop as we
have in Algorithm~\ref{algo:one} can be used for a practical
speedup. 
The pseudocode of this
procedure is provided in Algorithm~\ref{algo:one-all} in the appendix, which 
clearly costs an extra  time. Combining
Theorem~\ref{thm:one}, we have:



\begin{theorem}
\label{thm:one-all}
We can find all the LRs covering any given position  using  time
and space.
\end{theorem}





\section{Longest repeat finding for every position}   
\label{sec:every}
In this section, we want to find  of every position
. 
If any position  is covered by multiple LRs, the
leftmost one will be returned.  
A natural solution is to iteratively use Algorithm~\ref{algo:one} as a
subroutine to find every , for . However, the
total time cost of this solution will be , where  captures the time cost for the construction of
the rank array and the lcp array and  is the total
time cost for the  instances of Algorithm~\ref{algo:one}. We want to
have a solution that costs a total of  time and space, which follows
that the amortized cost for finding each LR is .

\subsection{A conceptual algorithm}
\label{subsec:overall}
We will first calculate  using
Lemma~\ref{lem:llr}, and save the results in an array . Each LLR is represented by a tuple , the starting
position and the length of the LLR. We assign zero as the length of
any non-existing LLR, which does not cover any string position. We
then sort the  array in the descending order of the lengths of
the LLRs, using a stable and linear-time sorting procedure such as the
counting sort.  

\begin{definition}
\label{def:p}
After the  array is stably sorted, let 
denote the string positions that are covered by , and ,
, denote the string positions that are covered by
 but are not covered by any of . Let
 denote the number of string positions belonging to .
\end{definition}

Note that any , , can possibly be empty. 
Our conceptual algorithm will then assign  as the LR of
those string positions belonging to , if  is not empty, for
. We store the LRs that we have calculated in an array
 of  tuples, where
 and  and  represent the
starting position and length of .  If  does not exist,
the tuple  will be assigned to , which
can be done during the initialization of the  array.  Early stop
can be made when (1) we meet an  array element whose length is
zero, which indicates that all the remaining  array elements
also have lengths of zero; or (2) every string position has had their
LR calculated. Algorithm~\ref{algo:concept} shows the pseudocode of
this conceptual algorithm.






\begin{algorithm}[t]
{\small
  \caption{The conceptual algorithm for finding the leftmost LR for
    every non-singleton string position of .}
\label{algo:concept}
\KwIn{The rank array and the lcp array of the string } 
\KwOut{The leftmost LR covering every non-singleton string position of .}

\smallskip 

\tcc{Calculate the  array using Lemma~\ref{lem:llr}. 
Initialize the  array..}
\For{}{
  
  \tcp*{, in the format of }
   \tcp*{, in the format of }
}

\smallskip 

Stably sort  in the descending order of its second
dimension \label{line:sort}\tcp*{e.g.: counting sort.} 

\bigskip 

\tcc{Find the leftmost LR for every position}

 \tcp*{The number of non-singleton string positions that have their
  LRs calculated.} 

\For{}{
  \lIf{ \emph{or} }{
    break \tcp*{Early stop}
  }
  \lIf{}{continue\;}

  \lForEach{}{
      
    \tcp*{Calculate the LRs of the positions belonging to .}
  }
  \;
 }

 \Return{}

}\end{algorithm}







\begin{lemma}
\label{lem:concept}
Algorithm~\ref{algo:concept} finds the LR for every position that does not
contain a singleton. It finds the leftmost LR if any
position is covered by multiple LRs.
\end{lemma}
	    
\begin{proof}
\remove{
  We prove the lemma by induction. 
  We first assume every string
  position has at most one LR and will deal with the case where one
  position can be possibly covered by multiple LRs in the end of the
  proof. 
}
The proof of the lemma is obvious. 
Recall that every LR must be an LLR (Lemma~\ref{lem:lr-llr}) and we
process all LLRs in descending order of their lengths.
For , if  is not empty, 
then for each position in , 
the  substring  is the
longest LLR that covers that position,
i.e.,  is the LR of
that position. 
\remove{
  Base case: We
  first observe that  is the longest repeat among
  , unless every string position in 
  contains a singleton. Therefore,   is the LR of every position in .

  Let's assume the conceptual algorithm produces correct LRs for
  positions that are covered by .  We will
  then show that it will produce correct LRs for positions that
  are covered by  but are not covered by
  . For the purpose of proof based on
  contradiction, we assume that  is
  not an LR for all those positions that are not covered by  but are covered by , then this implies
there exists at lease one position  of those positions, such that 
 is covered by an LR that is longer than .
From Lemma~\ref{lem:lr-llr}, we know that longer LR is also
  an LLR. Because we are processing LLRs in non-increasing order, 
  that longer LLR should appear before . This contradicts
  with the fact that position  is not covered by
  . So,  is the LR of those
  positions that are covered by  but are not covered
  by . 
}
In the case where any position in 
  has multiple LRs,  must be the leftmost LR because
  of the stable sorting of the  array. 
\end{proof}




\subsection{High-level strategy for a fast implementation}
\label{subsec:table}
The challenge is to implement the conceptual algorithm
(Algorithm~\ref{algo:concept}) efficiently. Our goal is to use 
time and space only, which is optimal since we have to spend 
time and space to report all the LRs of all the  distinct string
positions.
We start with some property of each  (Definition~\ref{def:p}).
Recall that, in Algorithm~\ref{algo:concept}, we process all the LLRs
in the descending order of their lengths, and also all LLRs start from
distinct string positions. Therefore, after the  array is
sorted (Line~\ref{line:sort}, Algorithm~\ref{algo:concept}),
none of
 can be a substring of ,  for any . This yields the following fact.


\begin{fact}
\label{fact:p}
Every non-empty , , is a continuous chunk of
string positions, i.e., every non-empty  is an integer range ,
where  and  are the starting
and ending string positions of . 
\end{fact}
In the case where  is empty, we set .
In order to achieve an overall -time implementation of
Algorithm~\ref{algo:concept}, we need a mechanism that can quickly
find  using  time when processing each . Then, if
, due to Fact~\ref{fact:p}, we can just linearly walk from
string position  through the position , which is either the
right boundary of  or a string position whose next
neighboring position has had its LR calculated, whichever one
is reached first.  We will then set the LR of each visited position
during the walk to be , achieving an overall  time
implementation of Algorithm~\ref{algo:concept}.

When we process a non-empty  and calculate its , there
are two cases.  Case 1: The string position  has not
had its LR calculated, then obviously .  Case 2:
The string position  has already had its LR
calculated, then it is either  (if  is not
empty) or  (if  is empty). In this case, it will not be
efficient to find  by simply walking from  toward
 until we reach  or a string position whose LR has not been
calculated. It is not immediately clear how to calculate
 using  time. This leads to the design of our following
mechanism that enables us to calculate every  in Case 2 using
 time.




\subsection{The two-table system: the  and  arrays}
\remove{
\begin{definition}
  \label{def:alpha-k}
  For any string position  that has had its LR calculated during
  the run of Algorithm~\ref{algo:concept}, we use  to denote
  the first string position that is after  and has not had its LR
  calculated, if such string position exists; otherwise, we set
  , where  is the length of the string .
\end{definition}
}


Our mechanism is built upon two integer arrays,  and
.  We
update the two arrays online when we process the sorted  array
elements in the calculation of the LR of every string position.
\emph{Ideally}, we want to maintain these two arrays, such that for
any string position  that has had its LR calculated,
 is either the next after- string position
whose LR is not calculated yet or  if no such after- string
position exists.  Then, when we process a particular non-empty
, if the string position  has had its LR
calculated, we can either directly get  or find the fact that all
string positions covered by  have had their LRs calculated,
by comparing  and
 (the right boundary of ).
However, it is not clear how to achieve such an ideal maintenance of
the  and  arrays in a time-efficient manner. This motivates
us to maintain these two arrays \emph{approximately}, which is to
maintain the following invariance. We will show later that such
approximate maintenance of the  and  arrays can still help
calculate every  using  time.

\subsubsection{Invariance.}
We initialize every element of both  and  arrays to be .
Recall that after the  array
is sorted in descending order of the lengths of the LLRs, we process
every , for . After we have finished the
processing of , for any , we want to
maintain the following invariance for the  and  arrays when processing .

\begin{enumerate}
\item If  has already had its LR calculated but , then:
  


\item If  but  (i.e.:  is not
  empty), then  is
  larger than the index of the right boundary of . That is,
   
\end{enumerate}


\subsubsection{Using the invariance.}
Recall that when we process a particular non-empty , we want
to calculate  quickly. The hard case is when the string position
 has already had its LR calculated.  Provided with the
above invariance of the  and  arrays, when we process a non-empty , we will first check the
value of . If it is not equal to ,
the hard case occurs. Then, if
 (the right boundary of ), we can assert
; otherwise, we
can assert  is empty and thus will simply skip .



\subsection{Maintaining the two-table system.}
\label{subsec:maintain}
In the following, we will first describe how we update the  and
 arrays when processing every . In the end, we will
explain why the invariance is maintained using an overall  time.
Remind that the whole algorithm will early stop if  is
empty, so we will only need to describe the algorithmic for
processing a non-empty .  We first initialize every element
in both  and  arrays to be .  We will use the word
\emph{bucket} to denote a maximal and continuous area in the 
array where all entries share the same positive value.  So initially,
there is no bucket presented in the  array.  Because all the
 array elements have been sorted in the descending order of
their lengths, the maintenance of the two-table system will only have
the following five cases to consider (Figure~\ref{fig:cases}).  We use
 and  to denote the indexes of the left and right
boundary of the . That is,



\begin{figure}[t]
  \centering
\begin{minipage}[c]{3.6in}
\scalebox{0.7} {
\begin{pspicture}(0,-2.3819044)(21.78787,2.4219043)
\psframe[linewidth=0.04,dimen=outer,fillstyle=solid](4.008242,2.2831345)(1.8482422,2.0431347)
\psframe[linewidth=0.04,dimen=outer,fillstyle=solid,fillcolor=black](3.9282422,1.2831343)(1.7682422,1.0431347)
\psframe[linewidth=0.04,dimen=outer,fillstyle=solid](5.448242,0.96313477)(3.8882422,0.72313434)
\psframe[linewidth=0.04,dimen=outer,fillstyle=solid,fillcolor=black](9.848242,1.3231347)(7.688242,1.0831347)
\psframe[linewidth=0.04,dimen=outer,fillstyle=solid](10.888242,1.0031346)(9.1282425,0.7631345)
\psframe[linewidth=0.04,dimen=outer,fillstyle=solid,fillcolor=black](5.608242,0.28313467)(3.4482422,0.043134566)
\psframe[linewidth=0.04,dimen=outer,fillstyle=solid](3.4882421,0.0031346655)(1.9282422,-0.23686534)
\psframe[linewidth=0.04,dimen=outer,fillstyle=solid,fillcolor=black](10.928242,0.24313462)(8.768242,0.0031346157)
\psframe[linewidth=0.04,dimen=outer,fillstyle=solid](9.488242,-0.07686538)(7.7282424,-0.31686538)
\psframe[linewidth=0.04,dimen=outer,fillstyle=solid,fillcolor=black](5.5869923,-0.79686534)(3.6482422,-1.0219043)
\psframe[linewidth=0.04,dimen=outer,fillstyle=solid](3.6669922,-1.1568655)(2.9682422,-1.3819042)
\psframe[linewidth=0.04,dimen=outer,fillstyle=solid,fillcolor=black](2.9869921,-0.79686534)(1.5682422,-1.0368654)
\psframe[linewidth=0.04,dimen=outer,fillstyle=solid,fillcolor=black](11.968243,-0.71686566)(9.808242,-0.9568653)
\psframe[linewidth=0.04,dimen=outer,fillstyle=solid,fillcolor=black](9.186993,-0.71686566)(7.626992,-0.9419043)
\psframe[linewidth=0.04,dimen=outer,fillstyle=solid](10.186993,-1.0368652)(9.146992,-1.3019043)
\psframe[linewidth=0.04,dimen=outer,fillstyle=solid,fillcolor=black](11.946992,2.3231347)(7.528242,2.0831347)
\psframe[linewidth=0.04,dimen=outer,fillstyle=solid](10.768242,1.9631345)(9.008243,1.7231345)
\usefont{T1}{ptm}{m}{n}
\rput(0.58564454,2.2030957){Case 1:}
\usefont{T1}{ptm}{m}{n}
\rput(6.4656444,2.2430956){Case 4:}
\usefont{T1}{ptm}{m}{n}
\rput(0.6856445,1.1630957){Case 2.1:}
\usefont{T1}{ptm}{m}{n}
\rput(6.6056447,1.1630957){Case 2.2:}
\usefont{T1}{ptm}{m}{n}
\rput(0.6856445,0.1630957){Case 3.1:}
\usefont{T1}{ptm}{m}{n}
\rput(6.6456447,0.123095706){Case 3.2:}
\psframe[linewidth=0.04,dimen=outer,fillstyle=solid,fillcolor=black](5.5469923,-1.7968653)(3.6482422,-2.0219042)
\psframe[linewidth=0.04,dimen=outer,fillstyle=solid](3.6669922,-2.1568654)(2.5469923,-2.3819044)
\psframe[linewidth=0.04,dimen=outer,fillstyle=solid,fillcolor=black](2.9869921,-1.7968653)(1.5682422,-2.0368652)
\psframe[linewidth=0.04,dimen=outer,fillstyle=solid,fillcolor=black](11.968243,-1.7168657)(9.808242,-1.9568653)
\psframe[linewidth=0.04,dimen=outer,fillstyle=solid,fillcolor=black](9.186993,-1.7168657)(7.626992,-1.9419043)
\psframe[linewidth=0.04,dimen=outer,fillstyle=solid](10.066992,-2.0368652)(8.946992,-2.3019042)
\usefont{T1}{ptm}{m}{n}
\rput(0.64564455,-0.8769043){Case 5.1:}
\usefont{T1}{ptm}{m}{n}
\rput(6.6456447,-1.9169043){Case 5.4:}
\usefont{T1}{ptm}{m}{n}
\rput(6.6456447,-0.9969043){Case 5.2:}
\usefont{T1}{ptm}{m}{n}
\rput(0.7256445,-1.9569043){Case 5.3:}
\psframe[linewidth=0.04,dimen=outer,fillstyle=solid](16.906992,1.0580957)(15.506992,0.8180957)
\psframe[linewidth=0.04,dimen=outer,fillstyle=solid,fillcolor=black](16.866993,2.3231347)(15.448242,2.0831347)
\usefont{T1}{ptm}{m}{n}
\rput(16.098047,1.7230957){positions whose LRs have been calculated}
\usefont{T1}{ptm}{m}{n}
\rput(17.298643,0.5230957){string positions that are covered by  being processed}
\end{pspicture} 
}
\end{minipage}
\begin{minipage}[c]{2.2in}
\vspace*{15mm}
  \caption{Possible cases regarding the relationship between the coverage of 
  and other string positions whose LRs have been calculated}
\label{fig:cases}

\end{minipage}

\end{figure}



{\footnotesize
\begin{lstlisting}
    left   LLRS[i].start; // the left boundary of LLRS[i]
    right  LLRS[i].start + LLRS[i].length - 1; // the right boundary of LLRS[i]
\end{lstlisting}
}




\noindent{\bf Case 1:} The coverage of  does not connect to or
overlap with any string positions whose LRs have been calculated.  We
will create a bucket in the  array covering the string positions
that are covered by  and set up the corresponding 
array entry to be the string position that is right after the coverage
of . The following code shows the case condition and the update
made to the  and  arrays.

\smallskip 

\begin{tabular}{l}
{\footnotesize
\begin{lstlisting}
if ptr[left] = -1 and ptr[right] = -1 and (left = 1 or ptr[left-1] = -1)
                  and (right = n or ptr[right+1] = -1)  //case 1
   for j = left...right: ptr[j]  i;
   next[i]  right + 1;
\end{lstlisting}
}
\end{tabular}

\smallskip 

\noindent{\bf Case 2:} The coverage of  connects to or overlaps
with the right side of a string position area whose LRs have been
calculated. We will extend that area's corresponding  array bucket to
the coverage of  and update the corresponding  array entry 
to be the string position that is right after the new bucket.

\smallskip 

\begin{tabular}{l}
{\footnotesize
\begin{lstlisting}
else if (ptr[left] = -1 and left  1 and ptr[left-1]  -1) and ptr[right] = -1
                        and (right = n or ptr[right+1] = -1) //case 2.1
   for j = left...right: ptr[j]  ptr[left-1];
   next[ptr[left-1]]  right + 1;

else if (ptr[left]  -1) and ptr[right] = -1
                         and (right = n or ptr[right+1] = -1)  //case 2.2
   for j = next[ptr[left]]...right: ptr[j]  ptr[left];
   next[ptr[left]]  right + 1;
\end{lstlisting}
}
\end{tabular}

\smallskip

\noindent{\bf Case 3:} The coverage of  connects to or
overlaps with the left side of an existing string position area whose
LRs have been calculated. We will left-extend that area's corresponding  array
bucket to the coverage of . We need not to update the
corresponding  array entry, since the string position that is
right after the new  bucket does not change.


\smallskip

\begin{tabular}{l}
{\footnotesize
\begin{lstlisting}
else if (ptr[right] = -1 and right  n and ptr[right+1]  -1) and ptr[left] = -1
                         and (left = 1 or ptr[left-1] = -1) //case 3.1 
   for j = left...right: ptr[j]  ptr[right+1];

else if (ptr[right]  -1) and ptr[left] = -1 
                          and (left = 1 or ptr[left-1] = -1) //case 3.2
   j  left;
   while ptr[j] = -1: ptr[j]  ptr[right]; j++;
\end{lstlisting}
}
\end{tabular}

\smallskip



\noindent{\bf Case 4: } Every string position covered by  has
its LR calculated already. In this case, we simply do nothing. 

\smallskip 

\begin{tabular}{l}
{\footnotesize
\begin{lstlisting}
else if ptr[left]  -1 and next[ptr[left]] > right: do nothing; //case 4
\end{lstlisting}
}
\end{tabular}

\smallskip

\noindent{Case 5:} The coverage of  bridges two 
string position areas whose LRs have been calculated. 
We will extend the left area's corresponding  array bucket up to
the left boundary of the
right area and update the  array entry of the left area to be the
one of the right area. 

\smallskip

\begin{tabular}{l} 
{\footnotesize
\begin{lstlisting}
else
   if ptr[left] = -1: j  left; ptr_entry  ptr[left-1]; //case 5.1, 5.2
   else:              j  next[ptr[left]]; ptr_entry  ptr[left]; //case 5.3, 5.4
   while ptr[j] = -1: ptr[j]  ptr_entry; j++;
   next[ptr[ptr_entry]]  next[ptr[j]];
\end{lstlisting}
}
\end{tabular}





\smallskip

\begin{lemma}[Correctness]
\label{lem:table-correct}
The two-table system's invariance is maintained.
\end{lemma}

\begin{proofsketch}
  Let us call a  array bucket  as a \emph{tail
    bucket} if  or .  (1) We first prove that the
  invariance is maintained on tail buckets.  Observe that any tail
   bucket is created in Case 1 (Figure~\ref{fig:cases}) and can
  be extended in Case 2 as well as in Case 3 if the black bucket in
  Case 3 was also a tail bucket.  The update to the tail bucket as
  well as the corresponding  array entry guarantees that, for
  any  belonging to the coverage of a tail bucket,
   is \emph{ideally} equal to the index of the
  string position that is right after the bucket (or  if no such
  string position exists). So obviously the invariance is maintained.
  (2) We now prove the invariance is also maintained on non-tail
  buckets.  Observe that any non-tail bucket is created in Case 5 from
  the merge of the left black bucket and the new 's
  coverage. After such non-tail bucket is created, for any position
   belonging to a non-tail bucket,  is at
  least as large as the index of the string position that is following
  the right black bucket in Case 5. That means  is larger than the size of any unprocessed  array
  element. This guarantee is maintained, because every
   only monotonically increases.  So, the
  invariance is also maintained for non-tail buckets. (3) Because the
  invariance is well maintained for all  buckets, it is safe to
  have the condition checking as we have written for Case 4.
\end{proofsketch}






\begin{lemma}[Time complexity]
\label{lem:table-time}
  The two-table system is maintained using a total of  time
  over the course of the processing of the  array elements. 
\end{lemma}


\begin{proofsketch}
  Observe that the updates to the  array are made only to those
  entries whose values were  and the new values from the updates
  are all positive. So there are no more than  updates
  to the  array. It is obvious that the number of updates made to
  the  array is no more than the number of updates made to the
   array. Other than  and  array updates, the rest of
  the maintenance work for the two-table system when processing each
   array element takes  time.  So the total time cost
  in maintaining the two-table system over the course of the
  processing of the whole  array is .
\end{proofsketch}




\subsection{The final  time and space algorithm.}
\label{subsec:final}








\begin{algorithm}[t]
{\small
  \caption{The  time and space algorithm for finding the
    leftmost LR for every non-singleton string position of .}
\label{algo:every-one}
\KwIn{The rank array and the lcp array of the string } 
\KwOut{The leftmost LR covering every non-singleton string position of .}

\smallskip 

\tcc{Calculate the  array using Lemma~\ref{lem:llr}. \newline
Initialize the  array  and the auxiliary  and 
  arrays.}
\For{\label{line:init-start}}{
  
  \tcp*{, in the format of }
   \tcp*{, in the format of }
  ; \ \ \   
  \label{line:init-end} \;
}

\smallskip 

Stably sort  in the descending order of its second
dimension\label{line:sort-2} \tcp*{e.g.: counting sort.} 


\bigskip 

\tcc{Find the leftmost LR for every position}

 \tcp*{The number of non-singleton string positions that have their
  LRs calculated.} 

\For{\label{line:for-2}}{
  \lIf{ \emph{or} }{
    break\label{line:earlystop} \tcp*{Early stop}
  }

\smallskip

    ;\ \ 
    ; \tcp{The boundaries of .}


  \tcc{ of  if  is not empty.}

  \lIf{}{
    ;
  }
  \lElse{
    \label{line:si}\;
  }

\smallskip 


  \lIf{}{
    continue \tcp*{Detect the fact that  is empty.\label{line:detect}}
  }

\smallskip

\tcc{Calculate the the leftmost LR of every position in .}
   \label{line:lr-start}\;
   \While{ \emph{and} }{
     ;
;
      \label{line:lr-end}\;
    }

    \smallskip 
    
    Update the two-table system here using the code presented in Section~\ref{subsec:maintain}\label{line:2-table}.
 }
    \Return{}
}\end{algorithm}



By combining the conceptual Algorithm~\ref{algo:concept}, the
high-level strategy for the fast implementation, and the two-table
system's maintenance mechanism, we are ready to produce the final
 time and space algorithm that can find the leftmost LR of every
string position. Algorithm~\ref{algo:every-one} shows the pseudocode.
It starts with the calculation of the  array and the
initialization of the , , and  arrays
(Line~\ref{line:init-start}--\ref{line:init-end}).  It then sorts the
 array in the descending order of the lengths of the array
elements using a linear and stable sorting procedure
(Line~\ref{line:sort-2}). It then uses the {\tt for} loop
(Line~\ref{line:for-2}) to process every  array element with
possible early stop (Line~\ref{line:earlystop}).  Using the two-table
system, the value of  is calculated by Line~\ref{line:si} if
 is not empty; otherwise, the fact that  is empty will also
be detected by Line~\ref{line:detect}. After  is calculated,
finding the LR of each position in  becomes obvious
(Line~\ref{line:lr-start}--\ref{line:lr-end}). After the LR finding
work is done, we will update the two-table system (Line~\ref{line:2-table}) using
the code presented in Section~\ref{subsec:maintain}.





\begin{lemma}
\label{lem:every-one}  
Given the lcp array and the rank array, Algorithm~\ref{algo:every-one}
calculates the leftmost LR of every non-singleton position of a string 
of size  using a total  time and space.
\end{lemma}

\begin{proofsketch}
  (1)\emph{Correctness.} The correctness of Algorithm~\ref{algo:every-one} immediately
  follows from of Lemma~\ref{lem:concept} and
  Lemma~\ref{lem:table-correct}.  (2) All data structures that are
  being involved are the , , , , , and
   arrays.  Altogether they use  space.  (3) The time cost
  for the initialization
  (Line~\ref{line:init-start}--\ref{line:init-end}) takes  time.
  the stable sorting (Line~\ref{line:sort-2}) uses  time.  The
  rest of the work (Line~\ref{line:for-2}--\ref{line:2-table}) also
  takes  time, because we update every  array element no
  more than once and the two-table system maintenance also takes
   time (Lemma~\ref{lem:table-time}). So the total time cost
  is .
\end{proofsketch}



\begin{theorem}
\label{thm:every-one}  
Given a string  of size , we can calculate the leftmost LR of every of string position 
using  time and space.   
\end{theorem}

\begin{proofsketch}
  We can construct the suffix array of the string  in a total of
   time and space using existing algorithms (For ex.,
  \cite{KA-SA2005}).  The rank array is just the inverse suffix array
  and can be directly obtained from SA using  time and
  space. Then we can obtain the lcp array from the suffix array and
  rank array using another  time and space~\cite{KLAAP01}. So
  the total time and space costs for preparing the rank and lcp arrays
  are . The proof of the theorem can then immediately follow
  from  Lemma~\ref{lem:every-one}.
\end{proofsketch}




\remove{

\subsection{Extension: finding all LRs of every string position (REMOVE IT !)}
\label{subsec:ext}

It is possible that a particular position can have multiple LRs.  For
example, if , then  can be either
 or .  However,
Algorithm~\ref{algo:every-one} only returns one of them and resolve
the tie by picking the leftmost one. However, it is easy to modify
Algorithm~\ref{algo:every-one} to return all the LRs of every string
position, without changing the mechanism that maintains the
two-table system.

Idea: 

When processing an ,

(1) if its left-end has its lr already calculated in the past, simply
travel from  toward the
left end of  and will stop when seeing a position whose lr's
length is larger than . Those positions travelled
through will have another LR just calculated as .

(2) similarly handle the right side. 

}




\section{Conclusion}
In this paper, we proposed the problem of finding longest repeats
covering particular string positions, motivated by its applications in
subfields such as computational biology. We proposed optimal
algorithms for finding the (leftmost) longest repeat of every string
position using a total of  time and space based on a novel
two-table system that we designed. We have implemented our
algorithms. Future work can be an
experimental study of the implementation.

 
\section*{References}

\small 

\bibliographystyle{elsarticle-num}

\bibliography{bibjsv,repeat,pm}


\newpage

\appendix 




\section*{Appendix}

\begin{table}[h!]
\center
\def\0{\phantom{0}}
{\footnotesize
\begin{tabular}{c|c|c|l}
\hline 
 &   &  & suffixes\\
\hline
\hline
\01 & 0 & 11\0  &{\tt i}\\
\02 & 1 & \08\0  & {\tt  ippi}\\
\03 & 1 & \05\0  & {\tt  issippi}\\
\04 & 4 & \02\0  & {\tt  ississippi}\\
\05 & 0 & \01\0  & {\tt  mississippi}\\
\06 & 0 & 10\0  & {\tt  pi}\\
\07 & 1 &  \09\0  & {\tt ppi}\\
\08 & 0 & \07\0  & {\tt sippi}\\
\09 & 2  & \04\0  & {\tt sissippi}\\
10 & 1  & \06\0  & {\tt ssippi}\\
11 & 3 & \03\0  & {\tt ssissippi}\\
12 & 0 & -- & --\\
\hline
\end{tabular}
}
\bigskip
\caption{The suffix array and the lcp array of an example string .}
\label{tab:suflcp}
\end{table}


\begin{algorithm}[h!]
{\small
  \caption{Find all LRs that cover a given position }
\label{algo:one-all}
\KwIn{The position index , and the rank array and 
      the lcp array of the string } 
\KwOut{All LRs that cover position  or find no such LR.}

\smallskip 

\tcc{Find the length of .}
\;
\For{ down to }{
  \tcp*{Length
    of }

  \If(\tcp*[f]{ does not exist or does not cover .}){ or }{break\tcp*{Early stop}}
  \ElseIf{}
   {\;}
}


\smallskip 

\tcc{Print all LRs that cover position .}

\If(\tcp*[f]{ does exist.}){}{
  \For{ down to }{
    \tcp*{Length
      of }
   \If(\tcp*[f]{ does not exist or does not cover .}){ or }{break\tcp*{Early stop}}
    \ElseIf{}
    {Print \;}
  }
}
\lElse{Print \tcp*{ does not exist.}}
}\end{algorithm}


\end{document}
