\documentclass[copyright,creativecommons]{eptcs}
\providecommand{\event}{F. Bonchi, D. Grohmann, P. Spoletini, and E. Tuosto:\\ ICE'09 Structured Interactions} \providecommand{\volume}{nnn}
\providecommand{\anno}{2009}
\providecommand{\firstpage}{57}
\providecommand{\eid}{4}


\usepackage[latin9]{inputenc}
\usepackage{amsmath,amssymb,amsthm}
\usepackage{graphicx}
\usepackage{url}
\usepackage{tabularx}
\usepackage{subfigure}
\usepackage{array}
\usepackage{pgf}
\usepackage{tikz}
\usepackage[all]{xy}


\newtheorem{definition}{Definition}
\newtheorem{theorem}{Theorem}
\newtheorem{remark}{Remark}
\newtheorem{example}{Example}

\renewcommand{\labelenumi}{(\alph{enumi})}


\newcommand{\Set}{\ensuremath{\mathbf{Set}}}
\newcommand{\PA}{\ensuremath{\mathbf{PortAut}}}
\newcommand{\Connector}{\ensuremath{\mathbf{Connector}}}
\newcommand{\one}{\ensuremath{\mathbf{1}}}
\newcommand{\Sem}{\ensuremath{\mathcal{S}em}}
\newcommand{\N}{\ensuremath{\mathcal{N}}}
\newcommand{\A}{\ensuremath{\mathcal{A}}}
\newcommand{\C}{\ensuremath{\mathcal{C}}}
\newcommand{\Q}{\ensuremath{\mathcal{Q}}}
 
\usetikzlibrary{arrows,shapes,automata,backgrounds,fit,automata,petri}

\definecolor{cblue}{rgb}{0.87,0.91,0.95}
\tikzstyle{cbox} = [fill=cblue,draw=gray,thick,rounded corners,
                    inner sep=3mm,outer xsep=1.5mm] 
\tikzstyle{every state}=[node distance=2.0cm,inner sep=0pt,minimum
size=6mm,draw=black,fill=white,initial text=,font=\footnotesize]

\tikzstyle{place}=[circle,thick,draw=black,fill=white,minimum size=3mm]
\tikzstyle{transition}=[rectangle,thick,draw=black,
  			  fill=black!20,minimum size=3mm]
\tikzstyle{every token}=[minimum size=1.1mm]
\tikzstyle{pre}=[thick,bend angle=32,<-]
\tikzstyle{post}=[thick,bend angle=32,->]


\newcommand{\tl}[1]{\scriptsize{\ensuremath{\mathsf{#1}}}}
 
\title{Integrated Structure and Semantics for Reo~Connectors~and~Petri~Nets}
\author{Christian Krause
	\footnote{Supported by NWO projects WoMaLaPaDiA and SYANCO.}
	\email{c.krause@cwi.nl}
	\institute{
  		CWI, P.O. Box 94079, 1090GB Amsterdam, The Netherlands
	}
}

\def\titlerunning{Integrated Structure and Semantics for Reo~Connectors~and~Petri~Nets}
\def\authorrunning{Christian Krause}

\begin{document}

\maketitle

\begin{abstract}
In this paper, we present an integrated structural and behavioral
model of Reo connectors and Petri nets, allowing a direct comparison 
of the two concurrency models. 
For this purpose, we introduce 
a notion of \emph{connectors}
which consist of a number of interconnected, 
user-defined primitives with fixed behavior.
While the structure of connectors resembles
hypergraphs, their semantics is given
in terms of so-called
\emph{port automata}. We define both
models in a categorical setting where composition
operations can be elegantly defined and
integrated. Specifically, we formalize structural gluings of
connectors as pushouts, and joins of port automata as
pullbacks. We then define a semantical functor from the connector to
the port automata category which
preserves this composition. We further show how to encode
Reo connectors and Petri nets into this model and indicate
applications to dynamic reconfigurations modeled using 
double pushout graph transformation.
\end{abstract}


\section{Introduction}

Reo~\cite{Arbab04} is a channel-based coordination language which
has its main application area in component and service composition.
The idea in Reo is to construct complex, so-called \emph{connectors}
out of a set of user-defined primitives, most commonly channels.
Among a number of sophisticated features, such as mobility~\cite{SABB06}, 
context-dependency~\cite{CCA07,BCS09}\nocite{Tiles}\nocite{Clarke07} and dynamic
reconfigurability~\cite{KMLA10}, on a more basic level Reo can be 
seen also as a model of concurrency. 
Comparing Reo with Petri nets, the first obvious commonality is the fact that
they both use a graph-based model, i.e. their structure can be modeled using 
typed graphs. Moreover, both models combine control-flow and data-flow
aspects. In this paper, we are particularly interested in
the concurrency properties of the two models, i.e.
parallel or synchronized actions vs. interleaved or mutually
excluded actions. To understand the relationship between
Reo connectors and Petri nets, we follow an approach in
this paper where we map both models to so-called \emph{port automata}~\cite{KC09},
which serve as our common semantical domain. We can thereby gain an integrated
view on structure and semantics of Reo connectors and Petri nets and moreover 
compare both models.

As a motivating example, Fig.~\ref{fig:examples} depicts a Reo connector,
a Petri net and a port automaton, all modeling the same simple protocol.
If considering the initial state also as final, the accepted language
is . Port automata model explicitly synchronization of actions.
This is witnessed by the fact that the transitions in the automaton are 
\emph{sets} of truly concurrent actions. Such a port automaton transition
corresponds to a concurrent firing of transitions in a Petri net, or a synchronized activity
on nodes in a Reo connector. This is our starting point for
using port automata as a common semantical models for the structural
models of Reo connectors and Petri nets. Our general idea is to compose 
-- potentially user-defined -- primitives into a graph-structure which we will
refer to as \emph{connector}. While in Reo, these primitives are communication channels,
in Petri nets we consider places as primitives.
Moreover our approach emphasizes compositionality, i.e.
the port automata semantics of primitives is predefined, but the semantics 
of connectors is derived using a join-operation.



\begin{figure}[t]
\centering
\subfigure[Reo connector]{
\includegraphics[height=3.1cm]{figures/po4}
\label{fig:examples:connector}
}
\subfigure[Petri net]{
\begin{tikzpicture}[node distance=0.85cm,auto,>=latex]

  \begin{scope}
    \node [place] (w1)                                    {};
    \node [place,tokens=1] (c1) [below of=w1]                      {};
    \node [place] (s)  [below of=c1] {};

    \node [transition] (e1) [left of=w1,label=above:\tl{A}] {}
      edge [post]                  (w1)
      edge [pre,bend right]      (c1);

    \node [transition] (t2) [left of=s,label=below:\tl{C}] {}
      edge [post]                (s)
      edge [pre,bend left]      (c1);
      
    \node [transition] (e3) [right of=w1,label=above:\tl{B}] {}
      edge [pre]                  (w1)
      edge [post,bend left]      (c1);

    \node [transition] (t2) [right of=s,label=below:\tl{D}] {}
      edge [pre]                (s)
      edge [post,bend right]      (c1);


  \end{scope}

  \begin{pgfonlayer}{background}
    \node [cbox,fit=(w1) (e3) (s) (e1),minimum height=3.05cm] {};
  \end{pgfonlayer}
\end{tikzpicture}
\label{fig:examples:petrinet}
}
\subfigure[Port automaton]{
\begin{tikzpicture}
  
  \begin{scope}[>=latex',->,node distance=0.8cm];

  \node[state,initial] (s0) {};
  \node[state]         (s2) [below left of=s0,yshift=-4mm]  {};
  \node[state]         (s3) [below right of=s0,yshift=-4mm]  {};
  \path    	(s0) edge[bend right=15] node [above left, inner sep=1pt]
            {\tl{\{A\}}} (s2) 
            (s2) edge[bend right=15] node [below right, inner sep=1pt]
          	{\tl{\{B\}}} (s0) 
          	(s0) edge[bend right=15] node [below left, inner sep=1pt]
          	{\tl{\{C\}}} (s3) 
          	(s3) edge[bend right=15] node [above right, inner sep=1pt]
          	{\tl{\{D\}}} (s0) ;

  \end{scope}
  
  \begin{pgfonlayer}{background}
    \node [cbox,fit=(s0) (s2) (s3), minimum height=3.05cm] {}; 
  \end{pgfonlayer}
  
\end{tikzpicture}
\label{fig:examples:automaton}
}
 \caption{Three descriptions of the same protocol.}
\label{fig:examples}
\end{figure}

We make the following contributions in this paper. We present
a model of connectors which combines 
structural and behavioral descriptions.
The structure of connectors resembles hypergraphs and their
semantics is defined using port automata. 
Our most important result is the compositionality of the model 
in the following sense: a structural gluing of connectors 
corresponds to a join of the corresponding port automata.
For this purpose, we define the categories {\Connector} and 
{\PA}, and a contravariant functor .
In categorical terms, our compositionality result means that this
functor sends pushouts of connectors to pullbacks of the 
corresponding port automata, i.e. for connectors ,  and
:

Furthermore we show how Reo connectors and Petri nets can be modeled
directly in our framework. While for Petri nets, compositionality results 
similar to ours exist already, this paper constitutes the first 
formal integration of the graph structure and the automata semantics 
of Reo connectors. Further it is a starting point for synthesis 
algorithms and in particular for semantics of graph transformation 
based reconfigurations.  Specifically, our composition operation fits into the 
double pushout approach~\cite{DPO,EEPT06} for graph transformation,
which has been used for instance to model reconfigurations 
of Reo connectors in~\cite{KMLA10}, and of Petri nets 
in~\cite{PER01}.


\paragraph{Organization.} The rest of the paper is organized
as follows. We start with the semantical model by introducing
port automata in Section~\ref{sec:port-automata}. Based on this,
we then define our notion of connectors in Section~\ref{sec:connectors}.
Section~\ref{sec:semantics} contains our main compositionality
result and Section~\ref{sec:encodings} shows how Reo connectors
and Petri nets can be encoded in our connector model.
Finally, Section~\ref{sec:discussion} contains a discussion and 
future work, and Section~\ref{sec:related-work} includes related work.



 
\vspace{0.5cm}
\section{Port automata}
\label{sec:port-automata}

Port automata are an operational model for connectors
and have been mainly studied in the context of Reo.
They are an abstraction of so-called \emph{constraint automata}~\cite{BSAR06}
which is the quasi-standard semantics of Reo.
Port automata describe the synchronization on sets
of ports, depending on the internal state of the connector.
The model abstracts from both the direction and content
of data flow. For a proper modeling of data we refer to the
constraint automata model.

In this paper, we present port automata
in a categorical setting, i.e., we consider
them as objects in a category which we will denote with~\PA.
We now give the definition for port automata.
\vspace{0.2cm}
\begin{definition}[Port automaton] 
A port automaton  consists of a set of states , 
a set of port names , a transition relation  and an initial state .
\end{definition}
We denote transitions often as 
with  and . 
The interpretation is that there is concurrent activity
at the ports  and no activity at the rest of the ports . 
The model permits -transitions, namely whenever . Hence,
there can be silent steps without any action. In the following we define
a notion of port automata morphism.
\vspace{0.2cm}
\begin{definition}[Port automata morphism]
A morphism of port automata  is a pair of functions 
with  and , such that: 
 and 
for all transitions  in 
there exists a transition  in  with

\end{definition}

\vfill

Port automata morphisms can be seen as a kind of simulation.
The definition uses
a function for relating the states of the automata instead of a relation, which
one might expect for a simulation of automata. However, in our categorical
context, especially when mapping connector morphisms to (inverse) simulations,
this definition is sufficient and easier to handle.
Note further that the port names are mapped in the opposite direction and
that condition~(\ref{equ:aut-mor}) defines  as the restricted preimage of
. The following example illustrates this notion of automata morphisms.

\vfill

\begin{example}
An example of a port automata morphism is depicted in
Fig.~\ref{fig:automata-morphism}. States  are both mapped to , and
 is mapped to . The port names function is the inclusion map in the
opposite direction. The transition via  in the source corresponds
to the transition via , and  to
the -step in the target automaton.
\end{example}

\vfill

\begin{figure}[h]
	\begin{center}
	
\begin{tikzpicture}

  \begin{scope}[>=latex',->];

  \node[state,initial] (q0)                {};
  \node[state]         (q1) [right of=q0]  {};
  \path		(q0) edge [bend left=15]	node [above,name=A] {\tl{\{A\}}} (q1);
  
  \node[state]         (q2) [below of=A,node distance=1.5cm]  {};
  \path     (q1) edge [bend left=15]	node [below right, inner sep=1pt]
  {\tl{\{B,C\}}} (q2) (q2) edge [bend left=15]	node [below left, inner sep=1pt]
            {\tl{\{C\}}} (q0) ;

  \node[state,initial] (p0) [right of=q1,node distance=3.25cm,yshift=-3.5mm] 
  {}; \node[state] (p1) [right of=p0]   {};
  \path		(p0) edge [bend left=15]	node [above,name=A'] {\tl{\{A\}}} (p1)
		         edge [loop above]      node[above,name=tau2] {\tl{ \emptyset } } ()
            (p1) edge [bend left=15]	node [below] {\tl{\{B\}}} (p0);

  \end{scope}
  
  \begin{pgfonlayer}{background}
    \node [cbox,fit=(q0) (q1) (q2) (A),minimum width=4cm,minimum
    height=2.5cm,name=source,outer xsep=1.5mm] {};
    \node [cbox,right of=source,node distance=5.25cm,minimum width=4cm,minimum
    height=2.5cm,name=target,outer xsep=1.5mm] {}; 
  \end{pgfonlayer}

  \draw[->,thick,gray] (source) -- (target);
  
\end{tikzpicture}


 	\end{center}
\caption{A morphism of port automata.}
\label{fig:automata-morphism}
\end{figure}

\vfill

Note that if the port name map  is the identity, a morphism also gives
rise to a language inclusion. If there is no confusion, we abuse notation and
write  for both  and .
If there is a morphism between two port automata  and , we
may also write  for short.
Similarly, if there exists a (categorical) isomorphism, we denote
this by . Note that this notion of behavioral equivalence is
stronger than usual definitions, e.g. using bisimulations.
\vfill
Composition and identity of port automata morphisms are defined
componentwise in \Set. The resulting category of port automata is denoted by
{\PA}. The port automaton with one state, an empty port names set and
a -transition is the final object in this category, denoted by .
At this point, we already make use of our categorical setting
and define composition of port automata using pullbacks.

\newpage
\begin{theorem}[Pullbacks of port automata]
\label{thm:pullbacks}
The category  has pullbacks and they can be constructed componentwise
in \Set. For a cospan , the pullback object
is  where\\
\begin{minipage}{0.3\textwidth}

\vspace{3mm}
\end{minipage}
\hfill
\begin{minipage}{0.65\textwidth}
\begin{itemize}
\item  (pullback in \Set)
\item  (pushout in \Set)
\item 
\item if  and ,
such that

then
	
in .
\end{itemize}
\end{minipage}
\end{theorem}
\begin{proof}[Proof sketch]
It is sufficient to show that the componentwise construction of  and
 yields valid morphisms of port automata, i.e. that
condition (\ref{equ:aut-mor}) holds. A detailed proof is
given in the appendix.
\end{proof}


\begin{example}
An example of a port automata pullback is depicted in
Fig.~\ref{fig:port-automata-pullback}. The state maps are
indicated by the indices, e.g.  is mapped to 
and  are all mapped to .
The resulting automaton on the bottom right is the automaton from
our previous example in Fig.~\ref{fig:examples}. Note that
it actually includes more states which are not shown 
here because they are unreachable.
\end{example}

\begin{figure}[t]
	\begin{center}
	

\begin{tikzpicture}
  
  \begin{scope}[>=latex',->];

  \node[state,initial] (q2)                {};
  \node[state]         (q3) [below of=q2]  {};
  \node[state]         (q4) [right of=q2]  {};
  \node[state]         (q5) [right of=q3]  {};
  \path		(q2) edge[bend right=15] node [left,name=c] {\tl{\{A\}}} (q3)
  			(q3) edge[bend right=15] node [right] {\tl{\{B\}}} (q2)
          	(q2) edge[bend left=15] node [above,name=a] {\tl{\{C\}}} (q4) 
          	(q4) edge[bend left=15] node [below] {\tl{\{D\}}} (q2) 
          	(q3) edge[bend left=15] node [above] {\tl{\{D\}}} (q5) 
          	(q5) edge[bend left=15] node [below] {\tl{\{C\}}} (q3) 
          	 ;

  \node[state]         (q1) [left of=c,node distance=2.5cm]  {};
  \node[state,initial] (q0) [left of=q1]   {};
  \path	(q0) edge [bend left=60] node [above] {\tl{ \{A\} }} (q1)
  		(q0) edge [bend left=15] node [above] {\tl{ \{C\} }} (q1)
        (q1) edge [bend left=15] node [below] {\tl{ \{D\} }} (q0)
        (q1) edge [bend left=60] node [below] {\tl{ \{B\} }} (q0);

  \node[state,initial] (r0) [below of=q0, node distance=3.5cm]  {};
  \node[state]         (r1) [right of=r0]  {};
  \node[state]         (r2) [below of=r0]  {};
  \node[state]         (r3) [below of=r1]  {};
  \path		(r0) edge[bend left=15] node [above] {\tl{\{C\}}} (r1)
  			(r1) edge[bend left=15] node [below] {\tl{\{D\}}} (r0)
          	(r0) edge[bend right=15] node [left] {\tl{\{A\}}} (r2) 
          	(r2) edge[bend right=15] node [right] {\tl{\{B\}}} (r0) 
          	(r1) edge[bend right=15] node [left] {\tl{\{B\}}} (r3) 
          	(r3) edge[bend right=15] node [right,name=c2] {\tl{\{A\}}} (r1) 
          	 ;

  \node[state,initial] (s0) [below of=q2, node distance=4.5cm]  {};
  \node[state]         (s2) [below of=s0]  {};
  \node[state]         (s3) [right of=s0]  {};
  \path (s0) edge[bend right=15] node [left] {\tl{\{A\}}} (s2) 
        (s2) edge[bend right=15] node [right] {\tl{\{B\}}} (s0) 
        (s0) edge[bend left=15] node [above] {\tl{\{C\}}} (s3) 
        (s3) edge[bend left=15] node [below] {\tl{\{D\}}} (s0) ;


  \end{scope}
  
  \begin{pgfonlayer}{background}
    \node [cbox,fit=(q0) (q1),minimum width=4cm,minimum
           height=3.6cm,name=A1,outer sep=1.5mm] {}; 
    \node [cbox,fit=(q2) (q5),minimum width=4cm,minimum
           height=3.6cm,name=A2,outer sep=1.5mm] {};
    \node [cbox,fit=(r0) (r3),minimum width=4cm,minimum
           height=3.6cm,name=A3,outer sep=1.5mm] {};
    \node [cbox,right of=A3,node distance=5.0cm, minimum width=4cm,minimum
           height=3.6cm,name=A4,outer sep=1.5mm] {};
  \end{pgfonlayer}

  \draw[->,thick,gray] (A2) -- (A1);
  \draw[->,thick,gray] (A3) -- (A1);
  \draw[->,thick,gray] (A4) -- (A2);
  \draw[->,thick,gray] (A4) -- (A3);
  
\end{tikzpicture}


 	\end{center}
\caption{A pullback of port automata.}
\label{fig:port-automata-pullback}
\vspace{-2mm}
\end{figure}


We use the default notation for pullbacks of port automata, i.e.
.
This notion of composition generalizes the join-operation
in~\cite{KC09} for port automata and in~\cite{BSAR06} for constraint automata
since it allows a composition along a common interface automaton. In
the traditional approaches, automata are joined only along a common set of port
names. Moreover, the categorical construction using pullbacks includes the
morphisms into the original automata and thereby relates them with the
result using simulations. Note also, that we have indirectly shown that 
{\PA} has general limits, since it has pullbacks and a final object.

In the following theorem, we phrase a basic compatibility result for port
automata morphisms, which is a direct consequence of the pullback construction.
\begin{theorem}[Compatibility with simulations]
Given two cospans of simulations  and 
,
then
\begin{enumerate}
  \item for three morphisms  with :
  \vspace{2mm}
  \begin{itemize} 
    \item if  and  then .
  \end{itemize} 
  \vspace{2mm}
  \item if  and  then 
  .
\end{enumerate}
\end{theorem}
\begin{proof}
Consider the following diagram where  and  are pullbacks of the given
cospans:
\vspace{-3mm}

The precondition of \emph{(a)} states that the top-face and the back-face 
commute and  commutes as it is a pullback. Hence . The morphism  is then
uniquely determined by the pullback  and hence . 
For  we take  the final object and automatically obtain
the precondition of . Thereby:
.
\end{proof}

Based on the given semantical model, we are now able to enrich it
with structural aspects. We do so by introducing our notion of 
connectors in the following section.

 

\section{Connectors}
\label{sec:connectors}

The model that we use here is motivated by the 
idea of constructing complex connectors out of 
a set of primitives with predefined behavior.
In our context, the primitives are specified
as port automata and connectors are just
collections of port automata with overlapping
port names.
\begin{definition}[Connector] \label{def:connector}
A connector  consists of a set of port 
automata  and a set of nodes , such that  for all
.
\end{definition}
Port names can now be interpreted as nodes and the port automata
as edges in a hypergraph. We will refer to the port automata
in a connector as \emph{primitives}. As mentioned already,
the idea is to construct arbitrarily complex connectors 
out of a fixed class of primitives, e.g. the set of 
standard channels in Reo.
\begin{definition}[Connector morphism] \label{def:connector-morphism}
A connector morphism  is a pair of functions

such that for all  there exists a port automata
morphism  with .
\end{definition}
A connector morphism consists of a map of nodes and a map of primitives 
from the source to the target connector.
Moreover, for all mapped primitives there must exist simulations in the
opposite direction, and the port name map must be compatible with the
nodes map.
It is worth mentioning at this point, that the existence of 
an inverse simulation has the consequence that a primitive can 
in principle be mapped to primitive with potentially
different interface (port name sets) and behavior 
(port automaton itself). Due to this property, connector morphisms 
permit a refinement of primitives.

Composition and identity of connector morphisms are again defined 
componentwise in \Set. We denote the category of connectors and their
morphisms as {\Connector}. 
We use pushouts to compose connectors. This makes the approach particularly
interesting for applying algebraic graph transformation techniques for modeling
reconfigurations (cf.~\cite{KMLA10,KAV09}). 

\begin{theorem}[Pushouts of connectors]
\label{thm:connector-pushouts}
The category {\Connector} has pushouts. 
For a span of connectors  the pushout object is given by  with\\
\begin{minipage}{0.25\textwidth}

\vspace{3mm}
\end{minipage}
\hfill
\begin{minipage}{0.7\textwidth}
\vspace{3mm}
\begin{itemize}
\item  (pushout in \Set)
\item  (pushout in \Set)
\vspace{3mm}
\item for all ,  and :

\item for all 

\end{itemize}
\end{minipage}
\end{theorem}
\begin{proof}
Due to the componentwise construction in {\Set} and {\PA} again
we have to show only that the construction yields a valid connector 
and valid connector morphisms  and . The connector  is valid
since 

in case (\ref{equ:connector-pushout-1}) and  in case (\ref{equ:connector-pushout-2}).
Moreover, for every  there exists a port automata morphism
. In case (\ref{equ:connector-pushout-2}) it is the identity
and in (\ref{equ:connector-pushout-1}) it is the projection of the pullback.
Since the port name maps in  and  are both constructed as the injections
into  and  respectively,  holds as well.
Hence,  are valid connector morphisms. Validity of 
can be shown analogously.
\end{proof}
\begin{figure}[t]
	\begin{center}
	
\begin{tabular}{ m{30mm}  m{10mm}  m{30mm}}
\includegraphics[width=30mm]{figures/po1} &
	\tikz{ \draw[->,thick,gray] (0,0) -- (1,0);} &
	\includegraphics[width=30mm]{figures/po3} \\
\hspace{13mm} \tikz{ \draw[->,thick,gray] (0,1) -- (0,0);} & &
	\hspace{13mm} \tikz{ \draw[->,thick,gray] (0,1) -- (0,0);} \\
\includegraphics[width=30mm]{figures/po2} &
	\tikz{ \draw[->,thick,gray] (0,0) -- (1,0);} &
	\includegraphics[width=30mm]{figures/po4} \\
\end{tabular}

 	\end{center}
\caption{A pushout of Reo connectors.}
\label{fig:connector-pushout}
\end{figure}

\begin{example}
A pushout of Reo connectors in purely structural notation is depicted
in Fig.~\ref{fig:connector-pushout}. In this notation, nodes (which correspond
to port names) are depicted as filled circles. The port automata semantics for
the different channel types are given in Fig.~\ref{fig:primitives}.
So-called  channels are asynchronous channels with a buffer of size one.
They are represented as arrows with a rectangle in the middle.
There are in fact two versions of this channel type: with and
without a token, respectively called  and . Circles with a
cross denote two dual primitives: the  (left of the )
and the  (right of it). Both have in total three ports and the same
semantics (cf.~Fig.~\ref{fig:primitives} for their port automata semantics).

Note that we abused notation in this example, in the sense that there are two hidden
nodes between the , the  and the .
The resulting connector on the bottom right is the initial example from
Fig.~\ref{fig:examples}. It consists in total of five primitives (three
s, one  and one ) and six nodes (-, plus two hidden ones).
\end{example}


 
\section{Compositional Semantics}
\label{sec:semantics}

In this section we show how to compute the port automaton for 
a connector using its primitives' semantics. We extend 
this mapping to a functor and show compositionality.

\begin{remark}
In the following definitions we use the fact that the product
is associative and commutative, i.e. there exist
natural isomorphisms  
and .
\end{remark}
\begin{definition}[Connector semantics] 
\label{def:connector-sem}
Given a connector  with  and 
 for . We define
 
where  is given by:

\end{definition}
Note that the nodes of the connector become the port names
of the resulting port automaton. The definition further
implies that all actions on a (shared) node are synchronized. 
This corresponds to so-called Hoare-style synchronizations, as
opposed to Milner-style synchronizations where exactly one
input end is synchronized with one output end.
We extend now the given connector semantics to a functor
.

\begin{theorem}[Semantics functor]
\label{def:functor}
Let  
a connector morphism, 
 and 
 
where 
with 
and .
Let

then there also exists a projection .
Defining 
as 
gives rise to a contravariant functor 
.
\end{theorem}
\begin{proof}
 is the product of the state sets of those primitives
in  that are in the image of , and
 the projection to the product of the state sets 
of these reached primitives.
The states map of  preserves the transitions
of , since both  and  do.
Hence,  is a valid port automata morphism.
For showing that  is a functor we
observe that composition is preserved: , and analogously for the identity.
\end{proof}
This result in particular shows that a (structural) morphism
of connectors corresponds to an inverse simulation on the
semantical level. 
We now phrase our main result, i.e., the compositionality
of the port automata semantics for connectors.
\begin{theorem}[Compositionality of semantics]
\label{thm:compositionality}
The functor  maps pushouts of connectors to pullbacks of port automata,
i.e.

\end{theorem}
\begin{proof}
Both in {\Connector} and {\PA} the port name sets
are composed using pushouts in \Set, and  
preserves these sets.  Hence, the port names are 
correctly mapped.
The primitives in the connector pushout
 are either of the form
 (case (\ref{equ:connector-pushout-1}))
or  with 
(case (\ref{equ:connector-pushout-2})). The primitives' state
sets are of the same form, i.e. they can be all 
written as pullbacks. {\Sem} sends these 
state sets to their product. Now, since 

the state set of the resulting automaton 
is of the form  where  is the state
set of , and  of  and
 of .  Hence, the (initial) states 
are also correctly mapped.
Moreover, the transition structure is preserved, 
since (\ref{rule:connector-sem}) implies (\ref{equ:caut-po})
and the port name sets on transitions are in both cases
composed by taking their union.
\end{proof}

 
\section{Applications}
\label{sec:encodings}

In this section, we show how Reo connectors and Petri nets
are modeled by our notion of connectors. This enables us
also to do a direct comparison of the two models.

\subsection{Modeling Reo connectors}

Reo connectors are directly modeled by our notion of connectors.
The primitives used in this paper are summarized in 
Fig.~\ref{fig:primitives}. It includes in particular 
the channel types ,  and .
Note also that all primitives
explicitly include -steps to 
allow interleavings, i.e. other parts of the connector
can fire independently without (observable) activity of such 
a primitive. 

\begin{figure}[t]
\centering
\subfigure[
]{
	\tikz[>=latex',->]{
	\node[state,initial] (q0) {}; 
	\draw[>=latex',->] 
	(q0) edge[loop above] node[above,name=A] {\tl{ \{A,B\} } } ()
	     edge[loop right] node[right,name=tau] {\tl{ \emptyset } } ();
	\begin{pgfonlayer}{background}
    \node [cbox,fit=(q0) (A),minimum width=2.6cm, minimum
    height=2cm,inner sep=1mm] {};
  	\end{pgfonlayer}
	}
}
\subfigure[
]{ \tikz[>=latex',->]{
	\node[state,initial] 							(q0) {};
	\node[state,right of=q0,node distance=1.5cm] 	(q1) {}; 
	\draw (q0) edge[bend left=10] node[above,name=A] {\tl{\{A\}}} (q1)
		       edge[loop above] node[above,name=tau1] {\tl{ \emptyset } } ();	
	\draw (q1) edge[bend left=10] node[below,name=B] {\tl{\{B\}}} (q0)
		       edge[loop above] node[above,name=tau2] {\tl{ \emptyset } } ();	
	\begin{pgfonlayer}{background}
    \node [cbox,fit=(q0) (q1) (A) (B) (tau1),minimum height=2cm,minimum
    width=3.8cm,xshift=-1.5mm,inner sep=1mm] {};
  	\end{pgfonlayer}
	}
}
\subfigure[
]{ 
	\tikz[>=latex',->]{
	\node[state,initial] (q0) {}; 
	\draw[>=latex',->] 
	(q0) edge[in=140,out=110,loop] node[above,name=A,xshift=-1mm] {\tl{\{A,B\}}}() 
	     edge[in=40,out=70,loop] node[above,name=B,xshift=1mm] {\tl{\{A,C\}}}() 
	     edge[loop right] node[right,name=tau] {\tl{ \emptyset } } ();
	\begin{pgfonlayer}{background}
    \node [cbox,fit=(q0) (A) (B),minimum height=2cm, minimum width=3.4cm,
    inner sep=1mm] {};
  	\end{pgfonlayer}
	}
}
 \caption{Port automata for some Reo primitives.}
\label{fig:primitives}
\end{figure}

While channels are user-defined
entities, Reo defines a fixed semantics for nodes.
A node in Reo merges input from all target ends
ends and replicates it to all source ends. This
can be seen as a  synchronization, 
as opposed the Hoare-style synchronizations
in our framework, where basically all
coinciding channel ends (no matter if source or target) 
are synchronized.
As a consequence we have to model the merging 
explicitly using a primitive. The ,
denoted by a circle with a cross in Fig.~\ref{fig:examples},
is used for this purpose. It has two source and one target end
and is therefore not a channel. We also define the dual
of this primitive, called . It has the same semantics
but its ends are inverse. Note again, that in the example
of Fig.~\ref{fig:primitives} and~\ref{fig:connector-pushout}
there are two hidden nodes between the , the 
and the , which are not relevant here.

The pushout diagram in Fig.~\ref{fig:connector-pushout} shows
a gluing of two Reo connectors along a common subconnector.
Note that this gluing is of a purely structural nature, 
although -- in principle -- it could also include a refinement of
primitives, i.e., if one of the primitive simulations is not 
an isomorphism. The port automata corresponding to the 
connectors in this example are depicted in
Fig.~\ref{fig:port-automata-pullback}. As we have shown 
in Theorem~\ref{thm:compositionality}, they form a pullback.
Note again, that we omitted unreachable states in the result.


\subsection{Modeling Petri nets}

Petri nets can also be modeled directly with our connector notion. As illustrated in the
motivating example in Fig.~\ref{fig:examples}, transitions in a Petri net
should be interpreted as nodes in this setting. Hence, places
become the primitives in the connector model. They are basically unbounded buffers
without ordering constraints (as opposed to the \emph{FIFO} channel in Reo). 


Formally, the port automaton
 for a place  with  and  respectively 
the sets of incoming and outgoing transitions\footnote{This can be seen
as the dual of the usual notion of \emph{pre}- and \emph{post}-sets of Petri net transitions.}
of  is defined in the following way:
\begin{itemize}
  \item  is the set of all markings of , e.g. the natural numbers, or a
  finite set for places with capacities.
  \item  whenever a concurrent firing of
  the transitions  turns the marking  into . 
  \item  the initial marking of .
\end{itemize}
This encoding works because the transitions in a Petri net also do a basic
Hoare-style synchronization. Without giving a proof, we claim that the port
automaton  of a Petri net  correctly models its behavior, in the
sense that it has the set of all possible markings of the net as states and
transitions that correspond to a concurrent firing of net transitions.

Our notion of connector morphisms requires that the ports of primitives are preserved.
Since we interprete places as primitives (and transitions as nodes) our connectors
correspond to the following Petri net model:
\vspace{-0.2cm}

Note that in the literature~(see e.g.~\cite{PER01}) one often finds
a similar but different model of Petri nets, where instead of the maps  
functions  are used. However, this only modifies the
notion of net morphism, but not the Petri net model itself. A comparison of the
two types of Petri net morphisms is out of the scope of this paper.


\subsection{Comparing Reo connectors and Petri nets}

As made evident in this paper, one can compare the basic version of Reo nodes, which
does only a primitive synchronization, with the transition concept in Petri nets.
On the other hand, primitives in our framework correspond to the places in a Petri net
and the channels, mergers, routers etc. in a Reo connector. Reo is more expressive
in the sense that it allows unbuffered  primitives, such as synchronous communication 
channels. In Petri nets, the primitives, i.e., the places are always buffered. 
From our point of view, this is the most important difference between Reo connectors 
and Petri nets: while in Petri nets synchronizations happen always locally at transitions,
in Reo synchronous primitives can be used to \emph{propagate} synchrony through the 
connector. Other features of Reo, such as context-dependency and priority go
beyond the focus of this paper.

\subsection{Modeling Reconfigurations}

Graph rewriting techniques, such as the double pushout (DPO) approach~\cite{DPO},
are a powerful tool for modeling rule-based reconfigurations. 
As a motivating example we return to the
pushout of Reo connectors in Fig.~\ref{fig:connector-pushout}. This diagram can
be interpreted as a reconfiguration in the following sense. The upper two
connectors together with the morphism between them is interpreted as a
(structural) reconfiguration rule. An application of this rule creates a
new  between the nodes  and .
The bottom two connectors can be regarded as an application of this rule.
In the bottom left is the connector before, and in the bottom right after the
rule application.

In our approach we can now perform this reconfiguration directly on the
corresponding automata. This becomes particularly interesting when
executing such a Reo connector as a state machine and reconfiguring it at
runtime. A prototypic implementation of this approach exists already.
A typical question in such scenarios is what the state of the connector
after a reconfiguration is, and whether it is actually valid. 
We can make this clear in the corresponding automata pullback in
Fig.~\ref{fig:port-automata-pullback}. For instance, if the connector 
before the reconfiguration is in state , we can see that in the 
connector after the reconfiguration the state  is mapped to 
by the constructed morphism. Thus, we can use this morphism to identify
the state after a reconfiguration step. However, we can see also in this example
that  has a preimage in the target automaton that is an unreachable state.
This indicates that a reconfiguration in this state produces an invalid system
state. In our example first  and then  fired, and then
the reconfiguration was performed. The problem here is essentially that at this point
there are two tokens in the connector. 



 
\section{Conclusions and Future Work}
\label{sec:discussion}

We have presented an integrated structural and behavioral
model of connectors and showed compositionality with
respect to gluing constructions. We have then shown how Reo 
connectors and Petri nets can be modeled in this framework.

As future work, we would like to consider the traditional model 
of simulations for port automata morphisms, i.e. instead
of functions we want to use a notion of upward-closed relations 
for relating the states. With this change, the model will cover 
a wider class of connector morphisms. Moreover, we are 
interested in further properties of the semantical functor.

\section{Related work}
\label{sec:related-work}

Padberg et al. provide compositional semantics of Petri nets
in~\cite{PER01}. Their results are based on 
\emph{pre}/\emph{post}-net morphisms and a marking graph semantics,
and they cover a wider class of Petri nets. Moreover, the 
authors show preservation of general colimits, as opposed 
to our work were we consider only pushouts.

A wide range of automata semantics for Petri nets exist. 
For instance, Droste 
and Shortt consider so-called \emph{automata
with concurrency relations} in~\cite{DS02}, which are more 
restrictive than port automata. Essentially, a concurrent 
firing of two net transitions always implies the existence 
of an interleaved execution of the two net-transitions 
(parallel independence).The authors show that there is a
coreflection between the category of Petri nets and automata 
with concurrency.
Pushouts or general colimits are not considered.
They further also use a non-standard notion of net morphisms.

A compositional automata semantics for Reo,
called \emph{constraint automata}, is
given by Baier et al. in~\cite{BSAR06}. 
Our port automata are an abstraction of 
constraint automata. The main difference
is the used notion of compositionality.
In~\cite{BSAR06}, with compositionality 
the authors mean that the semantics of a 
connector can be computed out of the semantics
of its constituent primitives. However, our
notion of compositionality really combines
the structural level with the semantical,
in the sense that we show how a gluing of
connectors corresponds to a join operation
of their behaviors. In particular, we generalize
the join operation of~\cite{BSAR06} by allowing
to join two automata along a common interface 
automaton.

\nocite{BCEH05}

 
\bibliographystyle{eptcs} \bibliography{ice02}

\appendix

\section{Proofs}
\label{sec:proofs}

\begin{proof}[Theorem~\ref{thm:pullbacks}]
Let . The pullback morphisms  consist of
the projections  and the injections . We will denote both of them with  if there is no confusion. We have
to show first that  and  are in fact \PA-morphisms.
Condition~(\ref{equ:aut-mor}) in the morphism definition reads for :  

We show this here only for , since the other case is analogously:
\vspace{3mm}\\

\vspace{-3mm}
\setlength{\extrarowheight}{2mm}

Now, the arrow  exists and is unique due to the componentwise construction in \Set. What is left
to show is that  is also a valid \PA-morphism.
We know for all  in 
there exist transitions  in  with

since the  are by assumption valid morphisms. Moreover we know that  maps
a state  in the automaton  to the state

in the pushout object . Now we have to show that there exists a transition 
 in  with 

We construct  in the following way:

We have constructed  and it fulfills the required property.
The last step is to show that this transition in fact exists in , which means that 
(\ref{equ:caut-po}) holds. Recall that  and  are valid morphisms:

We can follow that:
\begin{itemize}
\item 
\item 
\end{itemize}
and unify both equations:

and we have shown (\ref{equ:caut-po}).
\end{proof}
 
\end{document}
