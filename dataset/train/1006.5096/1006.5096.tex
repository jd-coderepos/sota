\documentclass{eptcs}



\newif\ifereader

\ereaderfalse

\ifereader
\newcommand{\ereaderWidth}{4.20in}
\newcommand{\ereaderLength}{5.42in}

\usepackage
    [ pdftex,
papersize={\ereaderWidth,\ereaderLength},
      twoside,
      bindingoffset=0pt,
      top=-0.3ex,bottom=1ex,
      left=0pt,right=0pt
    ]{geometry}

\fi

\providecommand{\event}{QAPL 2010} \providecommand{\volume}{??}
\providecommand{\anno}{2010}
\providecommand{\firstpage}{1}
\providecommand{\eid}{??}







\usepackage{ifthen}
\usepackage{stmaryrd}
\usepackage{amssymb} \usepackage{amsthm} 
\usepackage{amsmath} \usepackage{graphicx}

\DeclareMathAlphabet{\mathcal}{OMS}{cmsy}{m}{n}


\usepackage[Euler]{upgreek}

\theoremstyle{plain}
\newtheorem{theorem}{Theorem}[section]
\newtheorem{lemma}[theorem]{Lemma}

\theoremstyle{definition}
\newtheorem{definition}[theorem]{Definition}

\newcommand{\Nat}{\ensuremath{\mathbb N}}
\newcommand{\Real}{\ensuremath{\mathbb R}}
\newcommand{\RealPos}{\ensuremath{\Real_\geq}}
\newcommand{\Rat}{\ensuremath{\mathbb Q}}

\newcommand{\lit}[1]{\ensuremath{\mathit{#1}}}

\newcommand{\littt}[1]{\ensuremath{\mathtt{#1}}}

\newcommand{\Set}[2][]
    { \ensuremath{\ifthenelse{\equal{#1}{}}{\lit{#2}}{\lit{#2_{#1}}} }}

\newcommand{\Expr}[1][]{\Set[#1]{Expr}}
\newcommand{\BExpr}[1][]{\Set[#1]{BExpr}}

\newcommand{\sint}[1]{\littt{#1}}

\newcommand{\Vars}{X}
\newcommand{\Prg}{P}
\newcommand{\Init}{\mbox{\small\ensuremath{\mathcal{I}}}}
\newcommand{\CGs}{C}
\newcommand{\Tau}{\mbox{\small\ensuremath{\mathcal{T}}}\!}
\newcommand{\Mu}{\ensuremath{\mathcal{M}}}
\newcommand{\totype}{\ensuremath{\ra}}

\newcommand{\CS}{\lit{\mathbb{C}S}}
\newcommand{\HS}{\lit{\mathbb{H}S}}
\newcommand{\TS}{\lit{\mathbb{T}S}}
\newcommand{\ES}{\lit{\mathbb{E}S}}
\newcommand{\GenTau}{\mathbb{G}\Tau}
\newcommand{\Power}{\lit{\mathbb{P}}} \newcommand{\PowerNonEmpty}{\lit{\mathbb{P}^+}}
\newcommand{\Def}{\ensuremath{\triangleq}}
\newcommand{\Subst}[2][]
	{ \ensuremath{\ifthenelse{\equal{#1}{}}{\langle #2 \rangle}{\langle #1\mapsto #2 \rangle} }}

\newcommand{\Sem}[1]{\ensuremath{\llbracket #1\hspace{0.2ex} \rrbracket}}

\newcommand{\ra}{\ensuremath{\rightarrow}}

\newcommand{\dotsep}{\mbox{\raisebox{0.4ex}{\tiny\ensuremath{\:\;\bullet\;\:}}}}


\newcommand{\Eq}{\ensuremath{\mathop{\:\equiv\:}}}
\renewcommand{\And}{\ensuremath{\mathop{\:\wedge\;}}}
\newcommand{\Or}{\ensuremath{\mathop{\;\vee\;}}}
\newcommand{\Impl}{\ensuremath{\Rightarrow}}
\newcommand{\Not}{\ensuremath{\neg}} 
\newcommand{\Neq}{\ensuremath{\mathop{\:\not\equiv\:}}}

\newcommand{\Const}[1]{\ensuremath{\underline{#1}}} 
\newcommand{\SubPr}[1]{\ensuremath{\overline{#1}}} 

\newcommand{\Wp}{\lit{wp}}
\newcommand{\Mod}{\lit{\ mod\ }}
\newcommand{\Min}{\ensuremath{\sqcap}}

\newcommand{\SKIP}[0]{\textbf{skip}}
\newcommand{\ABORT}[0]{\textbf{abort}}
\newcommand{\IF}[0]{\textbf{if}}
\newcommand{\THEN}[0]{\textbf{then}}
\newcommand{\ELSE}[0]{\textbf{else}}
\newcommand{\FI}[0]{\textbf{fi}}
\newcommand{\DO}[0]{\textbf{do}}
\newcommand{\OD}[0]{\textbf{od}}

\newcommand{\True}[0]{\textsf{true}}
\newcommand{\False}[0]{\textsf{false}}

\newcommand{\slq}{\ensuremath{\sqsubseteq}}
\newcommand{\slqn}{\subseteq}


\newcommand{\elq}{\ensuremath{\Rrightarrow}}

\newcommand{\aelq}{\ensuremath{\Rrightarrow^\sharp}}

\setlength{\marginparwidth}{2.3cm}
\let\oldmarginpar\marginpar
\renewcommand\marginpar[1]{\-\oldmarginpar[\raggedleft\footnotesize #1]{\raggedright\footnotesize #1}}
\newcommand{\remark}[2]{}
\newcommand{\remarkN}[1]{\remark{N}{#1}}
\newcommand{\remarkD}[1]{\remark{D}{#1}}

\newcommand{\noi}[0]{\noindent}

\def\lastname{Barsotti-Wolovick, \revision}

\title{
  Automatic Probabilistic Program Verification through Random Variable Abstraction
}

\author{
  Dami\'an Barsotti
\thanks{Granted by MinCyT PID2008, Gobierno de la Provincia de C\'ordoba.}
\and
  Nicol\'as Wolovick
  \footnotemark[1]
\end{tabular}\ f.X \Def [x\neq 0]\times \Wp.(x:=0 \oplus_{\frac{1}{2}} x:=1; i:=i+1).X + [x=0]\times i  \textit{Inv} \Def (a_1 i + a_0) [x=0] + (b_1 i + b_0) [x\neq0]  f.\textit{Inv} = (1 i + 0) [x=0] + (\tfrac{a_1+b_1}{2}i + \tfrac{a_0+a_1+b_0+b_1}{2}) [x\neq0]\enspace.  f^\sharp.((a_1,a_0),(b_1,b_0)) = ((1,0),(\tfrac{a_1+b_1}{2},\tfrac{a_0+a_1+b_0+b_1}{2})) \enspace.
	\Wp.\ABORT.\beta &\Def \Const{0} \\
	\Wp.\SKIP.\beta &\Def \beta \\
	\Wp.E.\beta &\Def \beta\Subst{E} \\
	\Wp.(P_0;P_1).\beta &\Def \Wp.P_0.(\Wp.P_1.\beta) \\
	\Wp.(P_0 \oplus_p P_1).\beta &\Def p\times\Wp.P_0.\beta + (1-p)\times\Wp.P_1.\beta \\ 
	\Wp.(\IF\ G\ \THEN\ P_0\ \ELSE\ P_1\ \FI).\beta &\Def \Wp.(P_0\oplus_{[G]}P_1).\beta \\ 
	\Wp.(P_0 \Min P_1).\beta &\Def \Wp.P_0.\beta \Min \Wp.P_1.\beta \\ 
	\Wp.(\DO\ G\ra P\ \OD).\beta &\Def (\mu X \dotsep [G]\times \Wp.P.X + [\Not G] \times \beta)
 \Prg' = \{ I:\PowerNonEmpty{[0..l)}, i:I \dotsep (A_I \ra  E^i_1 @ p^i_1 | \cdots | E^i_{k_i} @ p^i_{k_i} ) \}  \label{eq:guard_atoms} 
A_I = (\land i:I \dotsep G_i) \land (\land i:[0..l)\!-\!I \dotsep \neg G_i)\enspace.

\label{eq:wp_sint}
\Wp{}.\Prg'.\beta \Def \left( \sum I:\PowerNonEmpty[0..l) \dotsep
	[A_I] \times \left( \bigsqcap i:I \dotsep
				\left( \sum j:[1..k_i] \dotsep p_i^j\times \beta\Subst{E_i^j} \right)
			  \right)
\right)\enspace.

\label{eq:wp_sem}\textstyle
	\Wp{}.\Tau.\beta.s \Def \left(\bigsqcap \Delta : \Tau.s \dotsep {\textstyle{\displaystyle\int}_{\!\!\!\Delta}} \beta\right)\enspace.

	{\textstyle{\int}_{\!\!\!\Delta_i}} \beta & = (\textstyle{\sum} s':S \dotsep \beta.s'\times \Delta_i.s') & \\
	& =  ( \textstyle{\sum} s':S \dotsep \beta.s'\times (\sum j: [1..k_i] \mid E_j^i.s = s' \dotsep p_j^i) ) & \mbox{\{ definition  \}}\\
	& =  ( \textstyle{\sum} s':S, j: [1..k_i] \mid E_j^i.s = s' \dotsep \beta.s' \times p_j^i ) & \mbox{\{ distributivity \}} \\
	& =  ( \textstyle{\sum} j: [1..k_i] \dotsep p_j^i \times \beta.(E_j^i.s) ) & \mbox{\{  is a function of  \}} \\
	& =  ( \textstyle{\sum} j: [1..k_i] \dotsep p_j^i \times (\beta\Subst{E_j^i}).s ) & \mbox{\{ definition of substitution \}} \\
 \Wp{}.\Tau.\beta.s = \left( \Min i:I \dotsep \left(\sum j: [1..k_i] \dotsep p_j^i \times (\beta\Subst{E_j^i}\right).s\right)\enspace. 
  \Wp.\DO\ G \ra P'\ \OD.\beta 
  = (\mu X \dotsep [G] \times \Wp.P'.X + [\Not G] \times \beta)
 \label{eq:back_propag_def}
    f.X \Def [G] \times \Wp.P.X + [\Not G] \times \beta \enspace.
   \label{eq:initialization_vc}
    \alpha \elq \mu.f \enspace.
  
            [G] \times \varphi &\elq \Wp.P.\varphi\\
\text{and } [\Not G] \times \varphi &\elq \beta \enspace,

( \forall x : X,\: x^\sharp : X^\sharp \;\;|\;\; 
  \gamma.x^\sharp \slq x 
  \;\:\dotsep\:\;
  \gamma.(f^\sharp.x^\sharp) \slq f.x
)\enspace.

        \gamma.(f^{\sharp (i+1)}.\bot_\sharp) 
            &= \gamma.(f^\sharp.(f^{\sharp (i)}.\bot_\sharp)) & \\
            &\slq f.(\mu.f) 
                 &\mbox{\{ inductive hypothesis, 
                           Definition \ref{def:b-abstraction_of} \}} \\
               &= \mu.f 
                 &\mbox{\{  is fixed point of  \}}
       \label{eq:concr_func}
\gamma.((q_0^1,\cdots,q_n^1), \cdots, (q_0^m,\cdots,q_n^m))
\Def
\textstyle
(\sum i : [1..m] \;\dotsep\; 
  (q_0^i + (\sum j : [1..n] \dotsep q_j^i \times x_j) \times [\phi_i]))

( \forall x : \ES, i : \Nat \;\;|\;\; 
  \gamma.(f^{\sharp (i)}.\bot_\sharp) \elq x 
  \;\:\dotsep\:\;
  \gamma.(f^{\sharp (i+1)}.\bot_\sharp) \elq f.x
)\enspace.
\label{eq:sup_fabst}
\gamma.(f^{\sharp (i+1)}.\bot_\sharp) \elq f.(\gamma.(f^{\sharp(i)}.\bot_\sharp))

\gamma.(f^{\sharp (i)}.\bot_\sharp) \elq x 
  &\;\Impl\; f.(\gamma.(f^{\sharp (i)}.\bot_\sharp)) \elq f.x
    &\mbox{\{  monotone \}} 
\\&\;\Eq\; \gamma.(f^{\sharp (i+1)}.\bot_\sharp) \elq f.(\gamma.(f^{\sharp(i)}.\bot_\sharp)) 
  \\ &\qquad \And f.(\gamma.(f^{\sharp (i)}.\bot_\sharp)) \elq f.x
    &\mbox{\{ by supposition (\ref{eq:sup_fabst}) \}}
\\&\;\Impl\; \gamma.(f^{\sharp (i+1)}.\bot_\sharp) \elq f.x
    &\mbox{\{ by transitivity of  \}}

f.(\gamma.(f^{\sharp(i)}.\bot_\sharp)) 
  &= 
\textstyle
[G] \times
\Wp.P.
(\sum i : [1..m] \dotsep 
  (q_0^i + (\sum j : [1..n] \dotsep q_j^i \times x_j) \times [\phi_i]))
\\  &\quad + [\Not G] \times \gamma.\beta^\sharp
      & \mbox{\{ by (\ref{eq:concr_func}) and (\ref{eq:back_propag_def}) \}}
\

\noi Then, we restrict the above result within each domain defined by
predicates  obtaining a set of expectations.
Although, these expectations are not necessarily linear, if the program is
linear (we have only linear assignments ), each of them can be
lower bounded by linear functions  agreeing~(\ref{eq:sup_fabst}). Also,
we choose each function  such that they are greater or equal than  ensuring monotonicity of the
constructed chain. So, each  must be bounded above and below:

\sloppy Note that it is always possible to find these bounded expectations  because
 is monotone (then ) and the lower bound  defines an hyperplane over the set of
states . Also, as  are linear functions, we can find the parameters
\mbox{} such that each . Then we define
. Thus, we abstract
 by choosing a lower expectation that
could be accurately represented in .

\noi Henceforth, by applying this method we can reach a fixed point
 in the abstract domain provided that exists a pre-fixed point
of transformer  (condition from Theorem~\ref{thm:abst_fp}). By
Theorem~\ref{thm:abst_fp}(\ref{it:abst_fp_is_lq}), expectation
 is a lower bound of  and can be used to prove the
correctness of the program regarding \mbox{post-expectation}~. Also, if we can
check  is a pre-fixed point of  then, by
Theorem~\ref{thm:abst_fp}(\ref{it:abst_fp_is_fp}), it is the least fixed point of
 and our abstraction works accurately.

The following section shows an example using this method.

\section{Martingale Example}\label{case_study}

In this section we give a more detailed example of our probabilistic program verification through random variable abstraction, computing the average capital a gambler would expect from a typical martingale betting system (Fig.~\ref{fig:martingale}).
The gambler starts with a capital  and bets initially one unit.
While the bet  is lower than the remaining capital , a fair coin is tossed and if it is a win, the player obtain one hundred percent gain and stops gambling, otherwise it doubles the bet and continues.
\begin{figure}[!ht]
\begin{center}
\begin{minipage}{\textwidth}
\begin{tabbing}
	\  \= \ \=  \\
	\>; \>  \=  \\
	\>\>	\> \ \=  \\
	\>\>	\> ; \>  \\
	\>\> 
\end{tabbing}
\end{minipage}
\end{center}
\caption{Martingale.}
\label{fig:martingale}
\end{figure}
The expected gain of this strategy is given by  .

Following Section \ref{subsec:rva} we first define the set of variables  and the set of disjoint convex linear predicates .
For the variables we take the whole set  since both participate in the control flow.
The predicates involved should, in principle, include the guard  and its negation as it is customary in PA.
However the update operations in the program produce movements in the bidimensional state space that cannot be accurately captured by this two regions.
We propose an abstraction that divides the two dimensional space  into six different regions (predicates).
The regions are defined by the four atoms given by the inequalities , , plus two other inequalities that define the six total orders between  and .
The concretization function  of the abstract domain  is the sum of a linear function on  in each region.

If we disregard the initialization and coalesce the two assignments, the program can be transformed into an equivalent , but following the syntax of Section~\ref{concrete_semantics}.
It consists of just one guard:

The fixed point computation is  with \mbox{post-expectation} .
The term  is given by (\ref{eq:wp_sint}) and the other summand is given by the final state condition on the \mbox{post-expectation}.

The function  is b-abstraction of  that we are going to calculate now.
We apply  to the concretization function  over generic coefficients, and obtain three blocks of summands given by the left assignment, the right assignment and the \mbox{post-expectation}.

Clearly the first three summands do not fit into the abstraction given by predicates ,
however we can give linear lower bounds on each of them that can be accurately represented in the abstract domain  as stated in Section \ref{subsec:rva}.
The region  includes  or in terms of random variables , so we keep the linear function in the smaller region.
The other two regions ,  form a partition of .
It is needed to find a plane that in  is below  and in  is below .
The two planes form a wedge (Fig.~\ref{fig:cuna}), so our lower bounding plane would put a base on it.
In the region  the function simplifies to  and the minimum in the region is  when .
For  the minimum is  achieved in .
\begin{figure}[!ht]
\begin{center}
\includegraphics[trim=0 1.1cm 0 1.1cm, clip, scale=0.75]{1raCuna.pdf}
\caption{Piecewise linear function to be minimized by a plane.}
\label{fig:cuna}
\end{center}
\end{figure}
Putting it all together we obtain the final linear expression that bounds  from below and it is in terms of the original predicates:

Note that doing this we comply with Eq. \ref{eq:sup_fabst}, and this in turn implies that  is a \mbox{b-abstraction}.
We explicitly write down  and iterate it up-to fixed point convergence in Table~\ref{table:fp_martingale}.
As expected,  do not contribute in the fixed point computation since  is a program invariant, so we do not include them:

\begin{table}[!ht]
\begin{small}
\begin{center}
\begin{tabular}{|c||c|l|c|}
\hline
& \multicolumn{3}{|c|}{Coefficients} \\
\hline
Iter. & (, , ) & (, , ) & (, , )  \\
\hline
0  &  (0, 0, 0) & (0, 0, 0) & (0, 0, 0) \\
1  &  (1, 0, 0) & (0.5, 0.5, 0) & (1, 0, 0) \\
2  &  (1, 0, 0) & (0.75, 0.25, 0) & (1, 0, 0) \\
3  &  (1, 0, 0) & (0.875, 0.125, 0) & (1, 0, 0) \\
4  &  (1, 0, 0) & (0.9375, 0.0625, 0) & (1, 0, 0) \\
5  &  (1, 0, 0) & (0.96875, 0.03125, 0) & (1, 0, 0) \\
6  &  (1, 0, 0) & (0.984375, 0.015625, 0) & (1, 0, 0) \\
7  &  (1, 0, 0) & (0.9921875, 0.0078125, 0) & (1, 0, 0) \\
\vdots & \vdots & \phantom{(1,}\hspace{0.9ex}\vdots & \vdots  \\
55  &  (1, 0, 0) & (1, 0, 0)  & (1, 0, 0) \\
\hline
\end{tabular}
\end{center}
\end{small}
\caption{Iteration for the martingale.}
\label{table:fp_martingale}
\end{table}





We can see , so the under approximation  tends from below to .


The initialization  does the rest obtaining a lower bound on the expected remaining capital, that is precisely .
It can be proven that  is a prefix point of  (in fact it is a fixed point),
and using Theorem~\ref{thm:abst_fp}~(\ref{it:abst_fp_is_fp}), we establish , therefore our approximation is exact.
Moreover, as the program is purely probabilistic,  is the expectation of  with respect to . 


\section{Aims and conclusions}\label{conclusions}

\iffalse
The problem of automatic verification of quantitative properties has been a
subject of investigation over the last decades. Research in this area include
model checking
techniques~\cite{vardi85auto,hansson94pctl,bianco95mcp,hinton06prism,hermannsWZ08cegar},
theorem proving~\cite{hurd05mech,celiku06mech} and recently, automatic
quantitative invariant generation~\cite{katoen09linear}. To the author's
knowledge, neither of them can tackle this problem over unbounded quantitative
properties.
\fi


This paper presents a technique for computing the expectation of unbounded random
variables tailored to performance measures, like expected number of rounds of a
probabilistic algorithm or expected number of detections in anonymity protocols.
Our method can check quantitative linear properties on any denumerable state space using
iterative backwards fixed point calculation.



Perhaps the main drawback of the method is that it is semi-computable but it covers cases
where previous work cannot be applied (geometric distribution,
martingales). Besides, it seems hard to bound expectations of programs syntactically since a
minor (linear) modification in the geometric distribution algorithm leads to a
unbounded expectation for a program that halts with probability .

\bigskip

In future work we would like to build tool support for our approach. This would
involve, among other tasks, the mechanization of the weakest pre-expectation
calculus in the abstract domain, as well as the maximization problem that involves computing a lower linear function in each iteration.
As our technique works on linear domains, this later task would be easily solved by known linear programming techniques.

We also plan to analyze more complex programs.
The Crowds anonymity protocol modeled as in~\cite{shmatikov04crowds} is a good candidate for our automatic quantitative program analysis, since its essential anonymity properties are expressed as the expected number of times the message initiator is observed by the adversary with respect to the observations obtained for the rest of the crowd.
It is also planned to reproduce the results of Rabin and Lehmann's probabilistic dining-philosophers algorithm~\cite{mciver02expected}.



\smallskip

\textit{Acknowledgements.} We would like to thank Pedro D'Argenio for his support in this project, as well as Joost-Pieter Katoen for handing us an early draft of~\cite{katoen09linear}.



\bibliographystyle{eptcs}
\bibliography{bibliography}

\end{document}
