\pdfoutput=1
\documentclass[11pt]{article}
\usepackage{acl}
\usepackage{times}
\usepackage{latexsym}
\renewcommand{\UrlFont}{\ttfamily\small}
\usepackage{microtype}

\usepackage{subcaption}

\usepackage{multirow}
\usepackage{amsmath}
\usepackage{capt-of}
\usepackage{tabularx}
\usepackage{epsfig}
\usepackage{amssymb}
\usepackage{amsfonts}
\usepackage{booktabs}
\usepackage{scalerel}
\usepackage[inline]{enumitem}
\usepackage{listings}
\usepackage{varwidth}
\usepackage[export]{adjustbox}
\usepackage{tikz}
\usetikzlibrary{tikzmark}
\usepackage{cleveref}
\newcommand{\crefrangeconjunction}{--}
\usepackage{stmaryrd}
\usepackage{bbm}

\newcommand{\tabincell}[2]{\begin{tabular}{@{}#1@{}}#2\end{tabular}}
\newcommand{\tx}[1]{``\textit{#1}''}
\newcommand{\sptk}[1]{\texttt{[#1]}}
\newcommand{\eqform}[1]{Equation~(\ref{#1})}



\usepackage{algorithm}
\usepackage[noend]{algpseudocode}

\definecolor{deepblue}{rgb}{0,0,0.5}
\definecolor{officeblue}{RGB}{0,102,204}
\definecolor{deepred}{rgb}{0.6,0,0}
\definecolor{deepgreen}{rgb}{0,0.5,0}
\definecolor{mybrickred}{RGB}{182,50,28}
\newcommand\mybox[2][]{\tikz[overlay]\node[inner sep=1pt, anchor=text, rectangle, rounded corners=1mm,#1] {#2};\phantom{#2}}
\definecolor{fillcolor}{RGB}{216,217,252}
\newcommand\bg[1]{\mybox[fill=blue!20]{#1}}
\newcommand\rg[1]{\mybox[fill=red!20]{#1}}

\renewcommand{\algorithmicrequire}{\textbf{Input:}}
\algnewcommand\algorithmicrequireb{{\hspace{0.85cm}}}
\algnewcommand\INPTDESCB{\item[\algorithmicrequireb]}
\renewcommand{\algorithmicensure}{\textbf{Output:}}
\algnewcommand\algorithmicfuncdesc{\textbf{Function:}}
\algnewcommand\FUNCDESC{\item[\algorithmicfuncdesc]}
\algnewcommand\algorithmicfuncdescb{{\hspace{1.48cm}}}
\algnewcommand\FUNCDESCB{\item[\algorithmicfuncdescb]}
\algnewcommand{\algorithmicgoto}{\textbf{goto}}
\algnewcommand{\Goto}[1]{\algorithmicgoto~\ref{#1}}
\newcommand*\Let[2]{\State {#1  #2}}
\newcommand*\LineLet[2]{#1  #2}
\newcommand*\AddOne[1]{\State #1 }
\newcommand*\LineComment[1]{\Statex  #1}
\newcommand*\LineFor[2]{\State {\algorithmicfor~#1~\algorithmicdo~~~~#2}}
\newcommand*\LineIf[2]{\State {\algorithmicif~#1~\algorithmicthen~~~~#2}}
\newcommand*\AlgCommentInLine[1]{{\color{deepblue}{ \textit{#1}}}}
\newcommand*\AlgComment[1]{\State{\AlgCommentInLine{#1}}}


\newcommand\mycode[1]{\textsf{\fontsize{10}{12}\selectfont #1}}
 

\usepackage{amsmath,amsfonts,bm}

\newcommand{\figleft}{{\em (Left)}}
\newcommand{\figcenter}{{\em (Center)}}
\newcommand{\figright}{{\em (Right)}}
\newcommand{\figtop}{{\em (Top)}}
\newcommand{\figbottom}{{\em (Bottom)}}
\newcommand{\captiona}{{\em (a)}}
\newcommand{\captionb}{{\em (b)}}
\newcommand{\captionc}{{\em (c)}}
\newcommand{\captiond}{{\em (d)}}

\newcommand{\newterm}[1]{{\bf #1}}


\def\figref#1{figure~\ref{#1}}
\def\Figref#1{Figure~\ref{#1}}
\def\twofigref#1#2{figures \ref{#1} and \ref{#2}}
\def\quadfigref#1#2#3#4{figures \ref{#1}, \ref{#2}, \ref{#3} and \ref{#4}}
\def\secref#1{section~\ref{#1}}
\def\Secref#1{Section~\ref{#1}}
\def\twosecrefs#1#2{sections \ref{#1} and \ref{#2}}
\def\secrefs#1#2#3{sections \ref{#1}, \ref{#2} and \ref{#3}}
\def\eqref#1{equation~\ref{#1}}
\def\Eqref#1{Equation~\ref{#1}}
\def\plaineqref#1{\ref{#1}}
\def\chapref#1{chapter~\ref{#1}}
\def\Chapref#1{Chapter~\ref{#1}}
\def\rangechapref#1#2{chapters\ref{#1}--\ref{#2}}
\def\algref#1{algorithm~\ref{#1}}
\def\Algref#1{Algorithm~\ref{#1}}
\def\twoalgref#1#2{algorithms \ref{#1} and \ref{#2}}
\def\Twoalgref#1#2{Algorithms \ref{#1} and \ref{#2}}
\def\partref#1{part~\ref{#1}}
\def\Partref#1{Part~\ref{#1}}
\def\twopartref#1#2{parts \ref{#1} and \ref{#2}}

\def\ceil#1{\lceil #1 \rceil}
\def\floor#1{\lfloor #1 \rfloor}
\def\1{\bm{1}}
\newcommand{\train}{\mathcal{D}}
\newcommand{\valid}{\mathcal{D_{\mathrm{valid}}}}
\newcommand{\test}{\mathcal{D_{\mathrm{test}}}}

\def\eps{{\epsilon}}


\def\reta{{\textnormal{}}}
\def\ra{{\textnormal{a}}}
\def\rb{{\textnormal{b}}}
\def\rc{{\textnormal{c}}}
\def\rd{{\textnormal{d}}}
\def\re{{\textnormal{e}}}
\def\rf{{\textnormal{f}}}
\def\rg{{\textnormal{g}}}
\def\rh{{\textnormal{h}}}
\def\ri{{\textnormal{i}}}
\def\rj{{\textnormal{j}}}
\def\rk{{\textnormal{k}}}
\def\rl{{\textnormal{l}}}
\def\rn{{\textnormal{n}}}
\def\ro{{\textnormal{o}}}
\def\rp{{\textnormal{p}}}
\def\rq{{\textnormal{q}}}
\def\rr{{\textnormal{r}}}
\def\rs{{\textnormal{s}}}
\def\rt{{\textnormal{t}}}
\def\ru{{\textnormal{u}}}
\def\rv{{\textnormal{v}}}
\def\rw{{\textnormal{w}}}
\def\rx{{\textnormal{x}}}
\def\ry{{\textnormal{y}}}
\def\rz{{\textnormal{z}}}

\def\rvepsilon{{\mathbf{\epsilon}}}
\def\rvtheta{{\mathbf{\theta}}}
\def\rva{{\mathbf{a}}}
\def\rvb{{\mathbf{b}}}
\def\rvc{{\mathbf{c}}}
\def\rvd{{\mathbf{d}}}
\def\rve{{\mathbf{e}}}
\def\rvf{{\mathbf{f}}}
\def\rvg{{\mathbf{g}}}
\def\rvh{{\mathbf{h}}}
\def\rvu{{\mathbf{i}}}
\def\rvj{{\mathbf{j}}}
\def\rvk{{\mathbf{k}}}
\def\rvl{{\mathbf{l}}}
\def\rvm{{\mathbf{m}}}
\def\rvn{{\mathbf{n}}}
\def\rvo{{\mathbf{o}}}
\def\rvp{{\mathbf{p}}}
\def\rvq{{\mathbf{q}}}
\def\rvr{{\mathbf{r}}}
\def\rvs{{\mathbf{s}}}
\def\rvt{{\mathbf{t}}}
\def\rvu{{\mathbf{u}}}
\def\rvv{{\mathbf{v}}}
\def\rvw{{\mathbf{w}}}
\def\rvx{{\mathbf{x}}}
\def\rvy{{\mathbf{y}}}
\def\rvz{{\mathbf{z}}}

\def\erva{{\textnormal{a}}}
\def\ervb{{\textnormal{b}}}
\def\ervc{{\textnormal{c}}}
\def\ervd{{\textnormal{d}}}
\def\erve{{\textnormal{e}}}
\def\ervf{{\textnormal{f}}}
\def\ervg{{\textnormal{g}}}
\def\ervh{{\textnormal{h}}}
\def\ervi{{\textnormal{i}}}
\def\ervj{{\textnormal{j}}}
\def\ervk{{\textnormal{k}}}
\def\ervl{{\textnormal{l}}}
\def\ervm{{\textnormal{m}}}
\def\ervn{{\textnormal{n}}}
\def\ervo{{\textnormal{o}}}
\def\ervp{{\textnormal{p}}}
\def\ervq{{\textnormal{q}}}
\def\ervr{{\textnormal{r}}}
\def\ervs{{\textnormal{s}}}
\def\ervt{{\textnormal{t}}}
\def\ervu{{\textnormal{u}}}
\def\ervv{{\textnormal{v}}}
\def\ervw{{\textnormal{w}}}
\def\ervx{{\textnormal{x}}}
\def\ervy{{\textnormal{y}}}
\def\ervz{{\textnormal{z}}}

\def\rmA{{\mathbf{A}}}
\def\rmB{{\mathbf{B}}}
\def\rmC{{\mathbf{C}}}
\def\rmD{{\mathbf{D}}}
\def\rmE{{\mathbf{E}}}
\def\rmF{{\mathbf{F}}}
\def\rmG{{\mathbf{G}}}
\def\rmH{{\mathbf{H}}}
\def\rmI{{\mathbf{I}}}
\def\rmJ{{\mathbf{J}}}
\def\rmK{{\mathbf{K}}}
\def\rmL{{\mathbf{L}}}
\def\rmM{{\mathbf{M}}}
\def\rmN{{\mathbf{N}}}
\def\rmO{{\mathbf{O}}}
\def\rmP{{\mathbf{P}}}
\def\rmQ{{\mathbf{Q}}}
\def\rmR{{\mathbf{R}}}
\def\rmS{{\mathbf{S}}}
\def\rmT{{\mathbf{T}}}
\def\rmU{{\mathbf{U}}}
\def\rmV{{\mathbf{V}}}
\def\rmW{{\mathbf{W}}}
\def\rmX{{\mathbf{X}}}
\def\rmY{{\mathbf{Y}}}
\def\rmZ{{\mathbf{Z}}}

\def\ermA{{\textnormal{A}}}
\def\ermB{{\textnormal{B}}}
\def\ermC{{\textnormal{C}}}
\def\ermD{{\textnormal{D}}}
\def\ermE{{\textnormal{E}}}
\def\ermF{{\textnormal{F}}}
\def\ermG{{\textnormal{G}}}
\def\ermH{{\textnormal{H}}}
\def\ermI{{\textnormal{I}}}
\def\ermJ{{\textnormal{J}}}
\def\ermK{{\textnormal{K}}}
\def\ermL{{\textnormal{L}}}
\def\ermM{{\textnormal{M}}}
\def\ermN{{\textnormal{N}}}
\def\ermO{{\textnormal{O}}}
\def\ermP{{\textnormal{P}}}
\def\ermQ{{\textnormal{Q}}}
\def\ermR{{\textnormal{R}}}
\def\ermS{{\textnormal{S}}}
\def\ermT{{\textnormal{T}}}
\def\ermU{{\textnormal{U}}}
\def\ermV{{\textnormal{V}}}
\def\ermW{{\textnormal{W}}}
\def\ermX{{\textnormal{X}}}
\def\ermY{{\textnormal{Y}}}
\def\ermZ{{\textnormal{Z}}}

\def\vzero{{\bm{0}}}
\def\vone{{\bm{1}}}
\def\vmu{{\bm{\mu}}}
\def\vtheta{{\bm{\theta}}}
\def\va{{\bm{a}}}
\def\vb{{\bm{b}}}
\def\vc{{\bm{c}}}
\def\vd{{\bm{d}}}
\def\ve{{\bm{e}}}
\def\vf{{\bm{f}}}
\def\vg{{\bm{g}}}
\def\vh{{\bm{h}}}
\def\vi{{\bm{i}}}
\def\vj{{\bm{j}}}
\def\vk{{\bm{k}}}
\def\vl{{\bm{l}}}
\def\vm{{\bm{m}}}
\def\vn{{\bm{n}}}
\def\vo{{\bm{o}}}
\def\vp{{\bm{p}}}
\def\vq{{\bm{q}}}
\def\vr{{\bm{r}}}
\def\vs{{\bm{s}}}
\def\vt{{\bm{t}}}
\def\vu{{\bm{u}}}
\def\vv{{\bm{v}}}
\def\vw{{\bm{w}}}
\def\vx{{\bm{x}}}
\def\vy{{\bm{y}}}
\def\vz{{\bm{z}}}

\def\evalpha{{\alpha}}
\def\evbeta{{\beta}}
\def\evepsilon{{\epsilon}}
\def\evlambda{{\lambda}}
\def\evomega{{\omega}}
\def\evmu{{\mu}}
\def\evpsi{{\psi}}
\def\evsigma{{\sigma}}
\def\evtheta{{\theta}}
\def\eva{{a}}
\def\evb{{b}}
\def\evc{{c}}
\def\evd{{d}}
\def\eve{{e}}
\def\evf{{f}}
\def\evg{{g}}
\def\evh{{h}}
\def\evi{{i}}
\def\evj{{j}}
\def\evk{{k}}
\def\evl{{l}}
\def\evm{{m}}
\def\evn{{n}}
\def\evo{{o}}
\def\evp{{p}}
\def\evq{{q}}
\def\evr{{r}}
\def\evs{{s}}
\def\evt{{t}}
\def\evu{{u}}
\def\evv{{v}}
\def\evw{{w}}
\def\evx{{x}}
\def\evy{{y}}
\def\evz{{z}}

\def\mA{{\bm{A}}}
\def\mB{{\bm{B}}}
\def\mC{{\bm{C}}}
\def\mD{{\bm{D}}}
\def\mE{{\bm{E}}}
\def\mF{{\bm{F}}}
\def\mG{{\bm{G}}}
\def\mH{{\bm{H}}}
\def\mI{{\bm{I}}}
\def\mJ{{\bm{J}}}
\def\mK{{\bm{K}}}
\def\mL{{\bm{L}}}
\def\mM{{\bm{M}}}
\def\mN{{\bm{N}}}
\def\mO{{\bm{O}}}
\def\mP{{\bm{P}}}
\def\mQ{{\bm{Q}}}
\def\mR{{\bm{R}}}
\def\mS{{\bm{S}}}
\def\mT{{\bm{T}}}
\def\mU{{\bm{U}}}
\def\mV{{\bm{V}}}
\def\mW{{\bm{W}}}
\def\mX{{\bm{X}}}
\def\mY{{\bm{Y}}}
\def\mZ{{\bm{Z}}}
\def\mBeta{{\bm{\beta}}}
\def\mPhi{{\bm{\Phi}}}
\def\mLambda{{\bm{\Lambda}}}
\def\mSigma{{\bm{\Sigma}}}

\DeclareMathAlphabet{\mathsfit}{\encodingdefault}{\sfdefault}{m}{sl}
\SetMathAlphabet{\mathsfit}{bold}{\encodingdefault}{\sfdefault}{bx}{n}
\newcommand{\tens}[1]{\bm{\mathsfit{#1}}}
\def\tA{{\tens{A}}}
\def\tB{{\tens{B}}}
\def\tC{{\tens{C}}}
\def\tD{{\tens{D}}}
\def\tE{{\tens{E}}}
\def\tF{{\tens{F}}}
\def\tG{{\tens{G}}}
\def\tH{{\tens{H}}}
\def\tI{{\tens{I}}}
\def\tJ{{\tens{J}}}
\def\tK{{\tens{K}}}
\def\tL{{\tens{L}}}
\def\tM{{\tens{M}}}
\def\tN{{\tens{N}}}
\def\tO{{\tens{O}}}
\def\tP{{\tens{P}}}
\def\tQ{{\tens{Q}}}
\def\tR{{\tens{R}}}
\def\tS{{\tens{S}}}
\def\tT{{\tens{T}}}
\def\tU{{\tens{U}}}
\def\tV{{\tens{V}}}
\def\tW{{\tens{W}}}
\def\tX{{\tens{X}}}
\def\tY{{\tens{Y}}}
\def\tZ{{\tens{Z}}}


\def\gA{{\mathcal{A}}}
\def\gB{{\mathcal{B}}}
\def\gC{{\mathcal{C}}}
\def\gD{{\mathcal{D}}}
\def\gE{{\mathcal{E}}}
\def\gF{{\mathcal{F}}}
\def\gG{{\mathcal{G}}}
\def\gH{{\mathcal{H}}}
\def\gI{{\mathcal{I}}}
\def\gJ{{\mathcal{J}}}
\def\gK{{\mathcal{K}}}
\def\gL{{\mathcal{L}}}
\def\gM{{\mathcal{M}}}
\def\gN{{\mathcal{N}}}
\def\gO{{\mathcal{O}}}
\def\gP{{\mathcal{P}}}
\def\gQ{{\mathcal{Q}}}
\def\gR{{\mathcal{R}}}
\def\gS{{\mathcal{S}}}
\def\gT{{\mathcal{T}}}
\def\gU{{\mathcal{U}}}
\def\gV{{\mathcal{V}}}
\def\gW{{\mathcal{W}}}
\def\gX{{\mathcal{X}}}
\def\gY{{\mathcal{Y}}}
\def\gZ{{\mathcal{Z}}}

\def\sA{{\mathbb{A}}}
\def\sB{{\mathbb{B}}}
\def\sC{{\mathbb{C}}}
\def\sD{{\mathbb{D}}}
\def\sF{{\mathbb{F}}}
\def\sG{{\mathbb{G}}}
\def\sH{{\mathbb{H}}}
\def\sI{{\mathbb{I}}}
\def\sJ{{\mathbb{J}}}
\def\sK{{\mathbb{K}}}
\def\sL{{\mathbb{L}}}
\def\sM{{\mathbb{M}}}
\def\sN{{\mathbb{N}}}
\def\sO{{\mathbb{O}}}
\def\sP{{\mathbb{P}}}
\def\sQ{{\mathbb{Q}}}
\def\sR{{\mathbb{R}}}
\def\sS{{\mathbb{S}}}
\def\sT{{\mathbb{T}}}
\def\sU{{\mathbb{U}}}
\def\sV{{\mathbb{V}}}
\def\sW{{\mathbb{W}}}
\def\sX{{\mathbb{X}}}
\def\sY{{\mathbb{Y}}}
\def\sZ{{\mathbb{Z}}}

\def\emLambda{{\Lambda}}
\def\emA{{A}}
\def\emB{{B}}
\def\emC{{C}}
\def\emD{{D}}
\def\emE{{E}}
\def\emF{{F}}
\def\emG{{G}}
\def\emH{{H}}
\def\emI{{I}}
\def\emJ{{J}}
\def\emK{{K}}
\def\emL{{L}}
\def\emM{{M}}
\def\emN{{N}}
\def\emO{{O}}
\def\emP{{P}}
\def\emQ{{Q}}
\def\emR{{R}}
\def\emS{{S}}
\def\emT{{T}}
\def\emU{{U}}
\def\emV{{V}}
\def\emW{{W}}
\def\emX{{X}}
\def\emY{{Y}}
\def\emZ{{Z}}
\def\emSigma{{\Sigma}}

\newcommand{\etens}[1]{\mathsfit{#1}}
\def\etLambda{{\etens{\Lambda}}}
\def\etA{{\etens{A}}}
\def\etB{{\etens{B}}}
\def\etC{{\etens{C}}}
\def\etD{{\etens{D}}}
\def\etE{{\etens{E}}}
\def\etF{{\etens{F}}}
\def\etG{{\etens{G}}}
\def\etH{{\etens{H}}}
\def\etI{{\etens{I}}}
\def\etJ{{\etens{J}}}
\def\etK{{\etens{K}}}
\def\etL{{\etens{L}}}
\def\etM{{\etens{M}}}
\def\etN{{\etens{N}}}
\def\etO{{\etens{O}}}
\def\etP{{\etens{P}}}
\def\etQ{{\etens{Q}}}
\def\etR{{\etens{R}}}
\def\etS{{\etens{S}}}
\def\etT{{\etens{T}}}
\def\etU{{\etens{U}}}
\def\etV{{\etens{V}}}
\def\etW{{\etens{W}}}
\def\etX{{\etens{X}}}
\def\etY{{\etens{Y}}}
\def\etZ{{\etens{Z}}}

\newcommand{\pdata}{p_{\rm{data}}}
\newcommand{\ptrain}{\hat{p}_{\rm{data}}}
\newcommand{\Ptrain}{\hat{P}_{\rm{data}}}
\newcommand{\pmodel}{p_{\rm{model}}}
\newcommand{\Pmodel}{P_{\rm{model}}}
\newcommand{\ptildemodel}{\tilde{p}_{\rm{model}}}
\newcommand{\pencode}{p_{\rm{encoder}}}
\newcommand{\pdecode}{p_{\rm{decoder}}}
\newcommand{\precons}{p_{\rm{reconstruct}}}

\newcommand{\laplace}{\mathrm{Laplace}} 

\newcommand{\E}{\mathbb{E}}
\newcommand{\Ls}{\mathcal{L}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\emp}{\tilde{p}}
\newcommand{\lr}{\alpha}
\newcommand{\reg}{\lambda}
\newcommand{\rect}{\mathrm{rectifier}}
\newcommand{\softmax}{\mathrm{softmax}}
\newcommand{\sigmoid}{\sigma}
\newcommand{\softplus}{\zeta}
\newcommand{\KL}{D_{\mathrm{KL}}}
\newcommand{\Var}{\mathrm{Var}}
\newcommand{\standarderror}{\mathrm{SE}}
\newcommand{\Cov}{\mathrm{Cov}}
\newcommand{\diag}{\mathrm{diag}}
\newcommand{\normlzero}{L^0}
\newcommand{\normlone}{L^1}
\newcommand{\normltwo}{L^2}
\newcommand{\normlp}{L^p}
\newcommand{\normmax}{L^\infty}

\newcommand{\parents}{Pa} 

\DeclareMathOperator*{\argmax}{arg\,max}
\DeclareMathOperator*{\argmin}{arg\,min}

\DeclareMathOperator{\sign}{sign}
\DeclareMathOperator{\Tr}{Tr}
\let\ab\allowbreak
 
\newcommand\our{\makebox{\textsc{XLM-E}}}
\newcommand\xlmr{\textsc{XLM-R}}
\newcommand\ele{\textsc{ELECTRA}}
\newcommand{\tblidx}[1]{{\scriptsize \texttt{[#1]}}}

\usepackage{pifont}\newcommand{\cmark}{{\color{blue}\ding{51}}}\newcommand{\xmark}{{\color{red}\ding{55}}}


\title{XLM-E: Cross-lingual Language Model Pre-training via ELECTRA}

\newcommand*\samethanks[1][\value{footnote}]{\footnotemark[#1]}

\author{Zewen Chi\thanks{\ \ Equal contribution. Zewen Chi contributes during internship at Microsoft Research.},~~Shaohan Huang,~~Li Dong,~~Shuming Ma,~~Bo Zheng\textbf{,}
\textbf{Saksham Singhal}\\~~\textbf{Payal Bajaj}\textbf{,}~~\textbf{Xia Song}\textbf{,}~~\textbf{Xian-Ling Mao}\textbf{,}~~\textbf{Heyan Huang}\textbf{,}~~\textbf{Furu Wei}\\
~Beijing Institute of Technology \\
~Microsoft Corporation \\
\url{https://github.com/microsoft/unilm} \\}

\date{}

\begin{document}
\maketitle
\begin{abstract}
In this paper, we introduce ELECTRA-style tasks~\cite{electra} to cross-lingual language model pre-training. Specifically, we present two pre-training tasks, namely multilingual replaced token detection, and translation replaced token detection. Besides, we pretrain the model, named as \our{}, on both multilingual and parallel corpora. Our model outperforms the baseline models on various cross-lingual understanding tasks with much less computation cost. Moreover, analysis shows that \our{} tends to obtain better cross-lingual transferability.
\end{abstract}


\section{Introduction}
\label{sec:intro}

It has become a de facto trend to use a pretrained language model~\cite{bert,unilm,xlnet,unilmv2} for downstream NLP tasks.
These models are typically pretrained with masked language modeling objectives, which learn to generate the masked tokens of an input sentence.
In addition to monolingual representations, the masked language modeling task is effective for learning cross-lingual representations.
By only using multilingual corpora, such pretrained models perform well on zero-shot cross-lingual transfer~\cite{bert,xlmr}, i.e., fine-tuning with English training data while directly applying the model to other target languages.
The cross-lingual transferability can be further improved by introducing external pre-training tasks using parallel corpus, such as translation language modeling~\cite{xlm}, and cross-lingual contrast~\cite{infoxlm}.
However, previous cross-lingual pre-training based on masked language modeling usually requires massive computation resources, rendering such models quite expensive.
As shown in Figure~\ref{fig:speedup}, our proposed XLM-E achieves a huge speedup compared with well-tuned pretrained models.


\begin{figure}[t]
\centering
\includegraphics[scale=0.5]{intro.pdf}
\caption{The proposed XLM-E pre-training (red line) achieves 130 speedup compared with an in-house pretrained XLM-R augmented with translation language modeling (XLM-R + TLM; blue line), using the same corpora and code base. The training steps are shown in the brackets. We also present XLM-R~\cite{xlmr}, InfoXLM~\cite{infoxlm}, and XLM-Align~\cite{xlmalign}. The compared models are all in Base size.}
\label{fig:speedup}
\end{figure}


In this paper, we introduce ELECTRA-style tasks~\cite{electra} to cross-lingual language model pre-training.
Specifically, we present two discriminative pre-training tasks, namely multilingual replaced token detection, and translation replaced token detection. 
Rather than recovering masked tokens, the model learns to distinguish the replaced tokens in the corrupted input sequences.
The two tasks build input sequences by replacing tokens in multilingual sentences, and translation pairs, respectively. 
We also describe the pre-training algorithm of our model, \our{}, which is pretrained with the above two discriminative tasks.
It provides a more compute-efficient and sample-efficient way for cross-lingual language model pre-training.

We conduct extensive experiments on the XTREME cross-lingual understanding benchmark to evaluate and analyze \our{}. Over seven datasets, our model achieves competitive results with the baseline models, while only using 1\% of the computation cost comparing to XLM-R.
In addition to the high computational efficiency, our model also shows the cross-lingual transferability that achieves a reasonably low transfer gap.
We also show that the discriminative pre-training encourages universal representations, making the text representations better aligned across different languages.

Our contributions are summarized as follows:
\begin{itemize}
\item We explore ELECTRA-style tasks for cross-lingual language model pre-training, and pretrain \our{} with both multilingual corpus and parallel data.
\item We demonstrate that \our{} greatly reduces the computation cost of cross-lingual pre-training.
\item We show that discriminative pre-training tends to encourage better cross-lingual transferability.
\end{itemize}


\section{Background: \ele{}}
\label{sec:ele}

\ele{}~\cite{electra} introduces the replaced token detection task for language model pre-training, with the goal of distinguishing real input tokens from corrupted tokens.
That means the text encoders are pretrained as discriminators rather than generators, which is different from the previous pretrained language models, such as BERT~\cite{bert}, that learn to predict the masked tokens.
The ELECTRA pre-training task has shown good performance on various data, such as language~\cite{hao-etal-2021-learning}, and vision~\cite{Fang2022CorruptedIM}.

\ele{} trains two Transformer~\cite{transformer} encoders, serving as generator and discriminator, respectively.
The generator  is typically a small BERT model trained with the masked language modeling (MLM;~\citealt{bert}) task. Consider an input sentence

containing  tokens. MLM first randomly selects a subset  as the positions to be masked, and construct the masked sentence  by replacing tokens in  with \texttt{[MASK]}.
Then, the generator predicts the probability distributions of the masked tokens . The loss function of the generator  is:

The discriminator  is trained with the replaced token detection task. Specifically, the discriminator takes the corrupted sentences  as input, which is constructed by replacing the tokens in  with the tokens sampled from the generator :

Then, the discriminator predicts whether  is original or sampled from the generator. The loss function of the discriminator  is

where  represents the label of whether  is the original token or the replaced one.
The final loss function of \ele{} is the combined loss of the generator and discriminator losses, .

Compared to generative pre-training, ELECTRA uses more model parameters and training FLOPs per step, because it contains a generator and a discriminator during pre-training.
However, only the discriminator is used for fine-tuning on downstream tasks, so the size of the final checkpoint is similar to BERT-like models in practice.


\section{Methods}
\label{sec:methods}

\begin{figure*}[t]
\centering
\includegraphics[width=1.0\textwidth]{rtd.pdf}
\caption{Overview of two pre-training tasks of \our{}, i.e., multilingual replaced token detection, and translation replaced token detection. The generator predicts the masked tokens given a masked sentence or a masked translation pair, and the discriminator distinguishes whether the tokens are replaced by the generator.}
\label{fig:rtd}
\end{figure*}

Figure~\ref{fig:rtd} shows an overview of the two discriminative tasks used for pre-training \our{}.
Similar to \ele{} described in Section~\ref{sec:ele}, \our{} has two Transformer components, i.e., generator and discriminator. The generator predicts the masked tokens given the masked sentence or translation pair, and the discriminator distinguishes whether the tokens are replaced by the generator.


\subsection{Pre-training Tasks}

The pre-training tasks of \our{} are multilingual replaced token detection (MRTD), and translation replaced token detection (TRTD).

\paragraph{Multilingual Replaced Token Detection}

The multilingual replaced token detection task requires the model to distinguish real input tokens from corrupted multilingual sentences.
Both the generator and the discriminator are shared across languages.
The vocabulary is also shared for different languages.
The task is the same as in monolingual ELECTRA pre-training (Section~\ref{sec:ele}). The only difference is that the input texts can be in various languages.

We use uniform masking to produce the corrupted positions.
We also tried span masking~\cite{spanbert,unilmv2} in our preliminary experiments. The results indicate that span masking significantly weakens the generator's prediction accuracy, which in turn harms pre-training.


\paragraph{Translation Replaced Token Detection}

Parallel corpora are easily accessible and proved to be effective for learning cross-lingual language models~\cite{xlm,infoxlm}, while it is under-studied how to improve discriminative pre-training with parallel corpora. We introduce the translation replaced token detection task that aims to distinguish real input tokens from translation pairs. Given an input translation pair, the generator predicts the masked tokens in both languages. Consider an input translation pair . We construct the input sequence by concatenating the translation pair as a single sentence.
The loss function of the generator  is:

where  is the operator of concatenation, and  stand for the randomly selected masked positions for  and , respectively. This loss function is identical to the translation language modeling loss (TLM;~\citealt{xlm}).
The discriminator  learns to distinguish real input tokens from the corrupted translation pair. The corrupted translation pair  is constructed by replacing tokens with the tokens sampled from  with the concatenated translation pair as input. Formally,  is constructed by

The same operation is also used to construct . Then, the loss function of the discriminator  can be written as

where  represents the label of whether the -th input token is the original one or the replaced one. The final loss function of the translation replaced token detection task is .

\subsection{Pre-training \our{}}

The \our{} model is jointly pretrained with the masked language modeling, translation language modeling, multilingual replaced token detection and the translation replaced token detection tasks. The overall training objective is to minimize

over large scale multilingual corpus  and parallel corpus .
We jointly pretrain the generator and the discriminator from scratch.
Following \citet{electra}, we make the generator smaller to improve the pre-training efficiency. 

\subsection{Gated Relative Position Bias}
\label{sec:grep}

We propose to use gated relative position bias in the self-attention mechanism.
Given input tokens , let  denote their hidden states in Transformer.
The self-attention outputs  are computed via:

where  represents gated relative position bias, each  is linearly projected to a triple of query, key and value using parameter matrices , respectively.

Inspired by the gating mechanism of Gated Recurrent Unit (GRU; \citealt{gru}), we compute gated relative position bias  via:

where  is learnable relative position bias, the vectors  are parameters,  is a sigmoid function, and  is a learnable value.

Compared with relative position bias~\cite{parikh-etal-2016-decomposable,t5,unilmv2}, the proposed gates take the content into consideration, which adaptively adjusts the relative position bias by conditioning on input tokens.
Intuitively, the same distance between two tokens tends to play different roles in different languages.


\subsection{Initialization of Transformer Parameters}
\label{sec:init}

Properly initializing Transformer parameters is critical to stabilize large-scale training.
First, all the parameters are randomly initialized by uniformly sampling from a small range, such as .
Second, for the -th Transformer block\footnote{Each block contains a self-attention layer and a feed-forward network layer.}, we rescale the attention output weight and the feed-forward network output matrix by . Notice that the Transformer block after the embedding layer is regarded the first one.


\section{Experiments}
\label{sec:exp}

\subsection{Setup}

\paragraph{Data}

We use the CC-100~\cite{xlmr} dataset for the replaced token detection task. CC-100 contains texts in 100 languages collected from the CommonCrawl dump. We use parallel corpora for the translation replaced token detection task, including translation pairs in 100 languages collected from MultiUN~\cite{multiun}, IIT Bombay~\cite{iit}, OPUS~\cite{opus}, WikiMatrix~\cite{wikimatrix}, and CCAligned~\cite{el2019ccaligned}.

Following XLM~\cite{xlm}, we sample multilingual sentences to balance the language distribution. Formally, consider the pre-training corpora in  languages with  examples for the -th language.
The probability of using an example in the -th language is

The exponent  controls the distribution such that a lower  increases the probability of sampling examples from a low-resource language. In this paper, we set .

\paragraph{Model}

We use a Base-size -layer Transformer~\cite{transformer} as the discriminator, with hidden size of , and FFN hidden size of .
The generator is a -layer Transformer using the same hidden size as the discriminator~\cite{cocolm}.
See Appendix~\ref{appendix:params_model} for more details of model hyperparameters.


\paragraph{Training}

We jointly pretrain the generator and the discriminator of \our{} from scratch, using the Adam~\cite{adam} optimizer for 125K training steps.
We use dynamic batching of approximately 1M tokens for each pre-training task.
We set , the weight for the discriminator objective to 50.
The whole pre-training procedure takes about 1.7 days on 64 Nvidia A100 GPU cards. See Appendix~\ref{appendix:params_pretrain} for more details of pre-training hyperparameters.
 

\begin{table*}[t]
\centering
\scalebox{0.81}{
\renewcommand\tabcolsep{5.0pt}
\begin{tabular}{lcccccccccccccccccc}
\toprule
\multirow{2}{*}{\bf Model} & \multicolumn{2}{c}{\bf Structured Prediction} & \multicolumn{3}{c}{\bf Question Answering} & \multicolumn{2}{c}{\bf Classification} & \multirow{2}{*}{\bf Avg} \\
& POS & NER & XQuAD & MLQA & TyDiQA & XNLI & PAWS-X & \\ \midrule
Metrics & F1 & F1 & F1 / EM & F1 / EM & F1 / EM & Acc. & Acc. & \\ 
\midrule
\multicolumn{9}{l}{~~\textit{Pre-training on multilingual corpus}} \\
\textsc{mBert}~\cite{xtreme} & 70.3 & 62.2 & 64.5 / 49.4 & 61.4 / 44.2 & 59.7 / 43.9 & 65.4 & 81.9 & 63.1 \\
\textsc{mT5}~\cite{mt5} & - & 55.7 & 67.0 / 49.0 & 64.6 / 45.0 & 57.2 / 41.2 & \bf 75.4 &  86.4 & - \\
\textsc{XLM-R} & \bf 75.6 & 61.8 & 71.9 / 56.4 & 65.1 / 47.2 & 55.4 / 38.3 & 75.0 & 84.9 & 66.4 \\
\our{} (w/o TRTD) & 74.2 & \bf 62.7 & \bf 74.3 / 58.2 & \bf 67.8 / 49.7 & \bf 57.8 / 40.6 & 75.1 & \bf 87.1 & \bf 67.6 \\ \midrule
\multicolumn{9}{l}{~~\textit{Pre-training on both multilingual corpus and parallel corpus}} \\
\textsc{XLM}~\cite{xtreme}  & 70.1 & 61.2 & 59.8 / 44.3 & 48.5 / 32.6 & 43.6 / 29.1 & 69.1 & 80.9 & 58.6 \\
\textsc{InfoXLM}~\cite{infoxlm} & - & - & -~~~/~~~- & 68.1 / 49.6 & -~~~/~~~- & 76.5 & - & - \\
\textsc{XLM-Align}~\cite{xlmalign} & \bf 76.0 & \bf 63.7 & 74.7 / 59.0 & 68.1 / \textbf{49.8} &  62.1 / 44.8 &  76.2 & 86.8 & 68.9 \\
\our{} &  75.6 & 63.5 & \bf 76.2 / 60.2 & \bf 68.3 / 49.8 & \bf 62.4 / 45.7 & \bf 76.6 & \bf 88.3 & \bf 69.3 \\
\bottomrule
\end{tabular}}
\caption{Evaluation results on XTREME cross-lingual understanding tasks. We consider the cross-lingual transfer setting, where models are only fine-tuned on the English training data but evaluated on all target languages.
The compared models are all in Base size.
Results of \our{} and XLM-R are averaged over five runs.}
\label{table:overview}
\end{table*}

\subsection{Cross-lingual Understanding}

We evaluate \our{} on the XTREME~\cite{xtreme} benchmark, which is a multilingual multi-task benchmark for evaluating cross-lingual understanding. The XTREME benchmark contains seven cross-lingual understanding tasks, namely part-of-speech tagging on the Universal Dependencies v2.5~\cite{udpos}, NER named entity recognition on the Wikiann~\cite{panx,rahimi2019} dataset, cross-lingual natural language inference on XNLI~\cite{xnli}, cross-lingual paraphrase adversaries from word scrambling (PAWS-X;~\citealt{pawsx}), and cross-lingual question answering on MLQA~\cite{mlqa}, XQuAD~\cite{xquad}, and TyDiQA-GoldP~\cite{tydiqa}.

\paragraph{Baselines}

We compare our \our{} model with the cross-lingual language models pretrained with multilingual text, i.e., Multilingual BERT (\textsc{mBert};~\citealt{bert}), \textsc{mT5}~\cite{mt5}, and XLM-R~\cite{xlmr}, or pretrained with both multilingual text and parallel corpora, i.e., XLM~\cite{xlm}, \textsc{InfoXLM}~\cite{infoxlm}, and \textsc{XLM-Align}~\cite{xlmalign}. 
The compared models are all in Base size. In what follows, models are considered as in Base size by default.


\paragraph{Results}

We use the cross-lingual transfer setting for the evaluation on XTREME~\cite{xtreme}, where the models are first fine-tuned with the English training data and then evaluated on the target languages.
In Table~\ref{table:overview}, we report the accuracy, F1, or Exact-Match (EM) scores on the XTREME cross-lingual understanding tasks. The results are averaged over all target languages and five runs with different random seeds.
We divide the pretrained models into two categories, i.e., the models pretrained on multilingual corpora, and the models pretrained on both multilingual corpora and parallel corpora. For the first setting, we pretrain \our{} with only the multilingual replaced token detection task.
From the results, it can be observed that \our{} outperforms previous models on both settings, achieving the averaged scores of 67.6 and 69.3, respectively. Compared to \textsc{XLM-R}, \our{} (w/o TRTD) produces an absolute 1.2 improvement on average over the seven tasks. For the second setting, compared to \textsc{XLM-Align}, \our{} produces an absolute 0.4 improvement on average. 
\our{} performs better on the question answering tasks and sentence classification tasks while preserving reasonable high F1 scores on structured prediction tasks. 
Despite the effectiveness of \our{}, our model requires substantially lower computation cost than \textsc{XLM-R} and \textsc{XLM-Align}. A detailed efficiency analysis in presented in Section~\ref{sec:eff}.

\begin{table}[t]
\centering
\small
\scalebox{0.95}{
\renewcommand\tabcolsep{3.5pt}
\begin{tabular}{lcc}
\toprule
\bf Model & \bf XNLI & \bf MLQA \\
\midrule
XLM (reimplementation) & 73.4 & 66.2 / 47.8  \\
~~~TLM & 70.6 & 64.0 / 46.0 \\ \midrule
\our{} & \bf 76.6 & \bf 68.3 / 49.8 \\
~~~TRTD & 75.1 & 67.8 / 49.7  \\ 
~~~TRTDGated relative position bias &  75.2 & 67.4 / 49.2 \\
\bottomrule
\end{tabular}
}
\caption{Ablation studies of \our{}. We studies the effects of the main components of \our{}, and compare the models with XLM under the same pre-training setup, including training steps, learning rate, etc.}
\label{table:ablation}
\end{table}

\subsection{Ablation Studies}

For a deeper insight to \our{}, we conduct ablation experiments where we first remove the TRTD task and then remove the gated relative position bias. Besides, we reimplement XLM that is pretrained with the same pre-training setup with \our{}, i.e., using the same training steps, learning rate, etc. Table~\ref{table:ablation} shows the ablation results on XNLI and MLQA. Removing TRTD weakens the performance of \our{} on both downstream tasks. On this basis, the results on MLQA further decline when removing the gated relative position bias. This demonstrates that \our{} benefits from both TRTD and the gated relative position bias during pre-training.
Besides, \our{} substantially outperform XLM on both tasks. Notice that when removing the two components from \our{}, our model only requires a multilingual corpus, but still achieves better performance than XLM, which uses an additional parallel corpus.


\begin{table}[t]
\centering
\small
\begin{tabular}{lcccc}
\toprule
\bf Model & \bf Size & \bf Params & \bf XNLI & \bf MLQA \\
\midrule
\our{} & Base & 279M & 76.6 & 68.3 / 49.8 \\
\our{} & Large & 840M & 81.3 & 72.7 / 54.2 \\
\our{} & XL & 2.2B & \bf 83.7 & \bf 76.2 / 57.9 \\ \midrule
XLM-R & XL  & 3.5B & 82.3 & 73.4 / 55.3 \\
\textsc{mT5} & XL  & 3.7B & 82.9 & 73.5 / 54.5 \\
\bottomrule
\end{tabular}
\caption{Results of scaling-up the model size.}
\label{table:scaleup}
\end{table}

\subsection{Scaling-up Results}
\label{sec:scaleup}

Scaling-up model size has shown to improve performance on cross-lingual downstream tasks~\cite{mt5,xlmr-scaleup}.
We study the scalability of \our{} by pre-training \our{} models using larger model sizes. 
We consider two larger model sizes in our experiments, namely Large and XL. Detailed model hyperparameters can be found in Appendix~\ref{appendix:params_model}.
As present in Table~\ref{table:scaleup}, XLM-E achieves the best performance while using significantly fewer parameters than its counterparts. Besides, scaling-up the \our{} model size consistently improves the results, demonstrating the effectiveness of \our{} for large-scale pre-training.


\subsection{Training Efficiency}
\label{sec:eff}

\begin{table}[t]
\centering
\small
\renewcommand\tabcolsep{3.5pt}
\begin{tabular}{lccc}
\toprule
\bf Model & \bf XTREME & \bf Params & \bf FLOPs \\
\midrule
\textsc{mBERT} & 63.1 & 167M & 6.4e19 \\
XLM-R & 66.4 & 279M & 9.6e21 \\
\textsc{InfoXLM}* & - & 279M & 9.6e21 + 1.7e20 \\
\textsc{XLM-Align}* & 68.9 & 279M & 9.6e21 + 9.6e19 \\
\our{} & 69.3 & 279M & 9.5e19 \\
~~~TRTD & 67.6 & 279M & 6.3e19 \\
\bottomrule
\end{tabular}
\caption{Comparison of the pre-training costs.
The models with `*' are continue-trained from XLM-R rather than pre-training from scratch.}
\label{table:eff}
\end{table}

We present a comparison of the pre-training resources, to explore whether \our{} provides a more compute-efficient and sample-efficient way for pre-training cross-lingual language models.
Table~\ref{table:eff} compares the XTREME average score, the number of parameters, and the pre-training computation cost.
Notice that \textsc{InfoXLM} and \textsc{XLM-Align} are continue-trained from XLM-R, so the total training FLOPs are accumulated over XLM-R.

Table~\ref{table:eff} shows that \our{} substantially reduces the computation cost for cross-lingual language model pre-training.
Compared to XLM-R and \textsc{XLM-Align} that use at least 9.6e21 training FLOPs, \our{} only uses 9.5e19 training FLOPs in total while even achieving better XTREME performance than the two baseline models.
For the setting of pre-training with only multilingual corpora, \our{} (w/o TRTD) also outperforms XLM-R using 6.3e19 FLOPs in total.
This demonstrates the compute-effectiveness of \our{}, i.e., \our{} as a stronger cross-lingual language model requires substantially less computation resource.



\subsection{Cross-lingual Alignment}

To explore whether discriminative pre-training improves the resulting cross-lingual representations, we evaluate our model on the sentence-level and word-level alignment tasks, i.e., cross-lingual sentence retrieval and word alignment.


\begin{table}
\centering
\small
\scalebox{0.94}{
\renewcommand\tabcolsep{5.0pt}
\begin{tabular}{lccccc}
\toprule
\multirow{2}{*}{\bf Model} & \multicolumn{2}{c}{\bf Tatoeba-14} & \multicolumn{2}{c}{\bf Tatoeba-36} \\
& en  xx & xx  en & en  xx & xx  en \\ \midrule
\textsc{XLM-R} & 59.5 & 57.6 & 55.5 & 53.4 \\
\textsc{InfoXLM} & \bf 80.6 & \bf 77.8 & \bf 68.6 & \bf 67.3 \\
\our{} & 74.4 & 72.3 & 65.0 & 62.3 \\
~~~TRTD & 55.8 & 55.1 & 46.4 & 44.6 \\
\bottomrule
\end{tabular}}
\caption{Average accuracy@1 scores for Tatoeba cross-lingual sentence retrieval. The models are evaluated under two settings with 14 and 36 of the parallel corpora for evaluation, respectively.
}
\label{table:tat}
\end{table}


We use the Tatoeba~\cite{tatoeba} dataset for the cross-lingual sentence retrieval task, the goal of which is to find translation pairs from the corpora in different languages.
Tatoeba consists of English-centric parallel corpora covering 122 languages. Following \citet{infoxlm} and \citet{xtreme}, we consider two settings where we use 14 and 36 of the parallel corpora for evaluation, respectively.
The sentence representations are obtained by average pooling over hidden vectors from a middle layer. Specifically, we use layer-7 for XLM-R and layer-9 for \our{}. Then, the translation pairs are induced by the nearest neighbor search using the cosine similarity.
Table~\ref{table:tat} shows the average accuracy@1 scores under the two settings of Tatoeba for both the xx  en and en  xx directions. \our{} achieves 74.4 and 72.3 accuracy scores for Tatoeba-14, and 65.0 and 62.3 accuracy scores for Tatoeba-36, providing notable improvement over \textsc{XLM-R}. \our{} performs slightly worse than \textsc{InfoXLM}. We believe the cross-lingual contrast~\cite{infoxlm} task explicitly learns the sentence representations, which makes \textsc{InfoXLM} more effective for the cross-lingual sentence retrieval task.

\begin{table}
\centering
\small
\scalebox{0.98}{
\renewcommand\tabcolsep{5.0pt}
\begin{tabular}{lcccccc}
\toprule
\multirow{2}{*}{\bf Model} & \multicolumn{4}{c}{\bf Alignment Error Rate } & \multirow{2}{*}{\bf Avg} \\
 & en-de & en-fr & en-hi & en-ro &  \\ \midrule
fast\_align & 32.14 & 19.46 & 59.90 & - & - \\
\textsc{XLM-R} & {17.74} & 7.54 & {37.79} & 27.49 & {22.64} \\
\textsc{XLM-Align} & 16.63 & 6.61 & 33.98 & 26.97 & 21.05 \\
\our{} & \bf 16.49 & \bf 6.19 & \bf 30.20 & \bf 24.41 & \bf 19.32 \\
~~~TRTD & 17.87 & 6.29 & 35.02 & 30.22 & 22.35 \\
\bottomrule
\end{tabular}}
\caption{Alignment error rate scores (lower is better) for the word alignment task on four language pairs. Results of the baseline models are from \citet{xlmalign}. We use the optimal transport method to obtain the resulting word alignments, where the sentence representations are from the -th layer of \our{}.
}
\label{table:wa}
\end{table}

For the word-level alignment, we use the word alignment datasets from EuroParl\footnote{\url{www-i6.informatik.rwth-aachen.de/goldAlignment/}}, WPT2003\footnote{\url{web.eecs.umich.edu/~mihalcea/wpt/}}, and WPT2005\footnote{\url{web.eecs.umich.edu/~mihalcea/wpt05/}}, containing 1,244 translation pairs annotated with golden alignments. The predicted alignments are evaluated by alignment error rate~(AER; \citealt{och2003systematic}):

where  and  stand for the predicted alignments, the annotated sure alignments, and the annotated possible alignments, respectively.
In Table~\ref{table:wa} we compare \our{} with baseline models, i.e., fast\_align~\cite{fastalign}, XLM-R, and \textsc{XLM-Align}. The resulting word alignments are obtained by the optimal transport method~\cite{xlmalign}, where the sentence representations are from the -th layer of \our{}. Over the four language pairs, \our{} achieves lower AER scores than the baseline models, reducing the average AER from  to 19.32. It is worth mentioning that our model requires substantial lower computation costs than the other cross-lingual pretrained language models to achieve such low AER scores. 
See the detailed training efficiency analysis in Section~\ref{sec:eff}.
It is worth mentioning that \our{} shows notable improvements over \our{} (w/o TRTD) on both tasks, demonstrating that the translation replaced token detection task is effective for cross-lingual alignment.

\subsection{Universal Layer Across Languages}

We evaluate the word-level and sentence-level representations over different layers to explore whether the \our{} tasks encourage universal representations.


\begin{figure}
\centering
\includegraphics[width=0.42\textwidth]{tat.pdf}
\caption{Evaluation results on Tatoeba cross-lingual sentence retrieval over different layers. For each layer, the accuracy score is averaged over all the 36 language pairs in both the xx  en and en  xx directions. }
\label{fig:tat}
\end{figure}


As shown in Figure~\ref{fig:tat}, we illustrate the accuracy@1 scores of \our{} and XLM-R on Tatoeba cross-lingual sentence retrieval, using sentence representations from different layers. For each layer, the final accuracy score is averaged over all the 36 language pairs in both the xx  en and en  xx directions. 
From the figure, it can be observed that \our{} achieves notably higher averaged accuracy scores than XLM-R for the top layers. The results of \our{} also show a parabolic trend across layers, i.e., the accuracy continuously increases before a specific layer and then continuously drops.
This trend is also found in other cross-lingual language models such as XLM-R and XLM-Align~\cite{simalign,xlmalign}. Different from XLM-R that achieves the highest accuracy of 54.42 at layer-7, \our{} pushes it to layer-9, achieving an accuracy of 63.66. At layer-10, XLM-R only obtains an accuracy of 43.34 while \our{} holds the accuracy score as high as 57.14.


\begin{figure}
\centering
\includegraphics[width=0.42\textwidth]{wa.pdf}
\caption{Evaluation results of cross-lingual word alignment over different layers. Layer-0 stands for the embedding layer.}
\label{fig:wa}
\end{figure}


Figure~\ref{fig:wa} shows the averaged alignment error rate (AER) scores of \our{} and XLM-R on the word alignment task. We use the hidden vectors from different layers to perform word alignment, where layer-0 stands for the embedding layer. The final AER scores are averaged over the four test sets in different languages. Figure~\ref{fig:wa} shows a similar trend to that in Figure~\ref{fig:tat}, where \our{} not only provides substantial performance improvements over XLM-R, but also pushes the best-performance layer to a higher layer, i.e., the model obtains the best performance at layer-9 rather than a lower layer such as layer-7. 

On both tasks, \our{} shows good performance for the top layers, even though both \our{} and XLM-R use the Transformer~\cite{transformer} architecture. 
Compared to the masked language modeling task that encourages the top layers to be language-specific, discriminative pre-training makes \our{} producing better-aligned text representations at the top layers.
It indicates that the cross-lingual discriminative pre-training encourages universal representations inside the model.

\begin{table}[t]
\centering
\small
\scalebox{0.90}{
\renewcommand\tabcolsep{3.0pt}
\begin{tabular}{lccccc}
\toprule
\bf Model & \textbf{XQuAD} & \textbf{MLQA} & \textbf{TyDiQA} & \bf XNLI & \bf PAWS-X \\ \midrule
\textsc{mBERT} & 25.0 & 27.5 & 22.2 & 16.5 & 14.1 \\
XLM-R & 15.9 & 20.3 & 15.2 & 10.4 & 11.4 \\
\textsc{InfoXLM} & - & 18.8 & - & \bf 10.3 & - \\
\textsc{XLM-Align} & \bf 14.6 & 18.7 & \bf 10.6 & 11.2 & 9.7\\
\our{} & 14.9 & 19.2 & 13.1 & 11.2 & \bf 8.8 \\
~~~TRTD & 16.3 & \bf 18.6 & 16.3 & 11.5 & 9.6 \\
\bottomrule
\end{tabular}}
\caption{The cross-lingual transfer gap scores on the XTREME tasks. A lower transfer gap score indicates better cross-lingual transferability. We use the EM scores to compute the gap scores for the QA tasks.}
\label{table:gap}
\end{table}

\subsection{Cross-lingual Transfer Gap}
We analyze the cross-lingual transfer gap~\cite{xtreme} of the pretrained cross-lingual language models. The transfer gap score is the difference between performance on the English test set and the average performance on the test set in other languages. This score suggests how much end task knowledge has not been transferred to other languages after fine-tuning. A lower gap score indicates better cross-lingual transferability. Table~\ref{table:gap} compares the cross-lingual transfer gap scores on five of the XTREME tasks.
We notice that \our{} obtains the lowest gap score only on PAWS-X. Nonetheless, it still achieves reasonably low gap scores on the other tasks with such low computation cost, demonstrating the cross-lingual transferability of \our{}. 
We believe that it is more difficult to achieve the same low gap scores when the model obtains better performance.

\section{Related Work}

Learning self-supervised tasks on large-scale multilingual texts has proven to be effective for pre-training cross-lingual language models. 
Masked language modeling (MLM;~\citealt{bert}) is typically used to learn cross-lingual encoders such as multilingual BERT (mBERT;~\citealt{bert}) and XLM-R~\cite{xlmr}.
The cross-lingual language models can be further improved by introducing external pre-training tasks using parallel corpora.
XLM~\cite{xlm} introduces the translation language modeling (TLM) task that predicts masked tokens from concatenated translation pairs. ALM~\cite{alm} utilizes translation pairs to construct code-switched sequences as input. 
InfoXLM~\cite{infoxlm} considers an input translation pair as cross-lingual views of the same meaning, and proposes a cross-lingual contrastive learning task.
Several pre-training tasks utilize the token-level alignments in parallel data to improve cross-lingual language models~\cite{Cao2020Multilingual,zhao2020inducing,hu2020explicit,xlmalign}.

In addition, parallel data are also employed for cross-lingual sequence-to-sequence pre-training.
XNLG~\cite{xnlg} presents cross-lingual masked language modeling and cross-lingual auto-encoding for cross-lingual natural language generation, and achieves the cross-lingual transfer for NLG tasks. VECO~\cite{veco} utilizes cross-attention MLM to pretrain a variable cross-lingual language model for both NLU and NLG. mT6~\cite{mt6} improves mT5~\cite{mt5} by learning the translation span corruption task on parallel data. LM~\cite{deltalm} proposes to align pretrained multilingual encoders to improve cross-lingual sequence-to-sequence pre-training.


\section{Conclusion}

We introduce \our{}, a cross-lingual language model pretrained by \ele{}-style tasks.
Specifically, we present two pre-training tasks, i.e., multilingual replaced token detection, and translation replaced token detection.
\our{} outperforms baseline models on cross-lingual understanding tasks although using much less computation cost.
In addition to improved performance and computational efficiency, we also show that \our{} obtains the cross-lingual transferability with a reasonably low transfer gap.


\section{Ethical Considerations}
Our work introduces ELECTRA-style tasks for cross-lingual language model pre-training, which requires much less computation cost than previous models and substantially reduces the energy cost.

\bibliographystyle{acl_natbib}
\bibliography{xlme}

\newpage
\appendix

\section*{Appendix}

\section{Model Hyperparameters}
\label{appendix:params_model}

Table~\ref{table:g-hparam} and Table~\ref{table:d-hparam} shows the model hyperparameters of \our{} in the sizes of Base, Large, and XL. 
For the Base-size model, we use the same vocabulary with XLM-R~\cite{xlmr} that consists of 250K subwords tokenized by SentencePiece~\cite{sentencepiece}. For the models in Large size and XL size, we use VoCap~\cite{vocap} to allocate a 500K vocabulary for models in Large size and XL size.

\begin{table}[ht]
\centering
\small
\renewcommand\tabcolsep{2.8pt}
\begin{tabular}{lrrr}
\toprule
Hyperparameters & Base & Large & XL \\ \midrule
Layers & 4 & 6 & 8 \\
Hidden size & 768 & 1,024 & 1,536 \\
FFN inner hidden size & 3,072 & 4,096 & 6,144 \\
Attention heads & 12 & 16 & 24 \\
\bottomrule
\end{tabular}
\caption{Model hyperparameters of \our{} generators in different sizes.}
\label{table:g-hparam}
\end{table}

\begin{table}[ht]
\centering
\small
\renewcommand\tabcolsep{3.5pt}
\begin{tabular}{lrrr}
\toprule
Hyperparameters & Base & Large & XL \\ \midrule
Layers & 12 & 24 & 48 \\
Hidden size & 768 & 1,024 & 1,536 \\
FFN inner hidden size & 3,072 & 4,096 & 6,144 \\
Attention heads & 12 & 16 & 24 \\
\bottomrule
\end{tabular}
\caption{Model hyperparameters of \our{} discriminators in different sizes.}
\label{table:d-hparam}
\end{table}

\section{Hyperparameters for Pre-Training}
\label{appendix:params_pretrain}
As shown in Table~\ref{table:pt-hparam}, we present the hyperparameters for pre-training \our{}.
We use the batch size of 1M tokens for each pre-training task. In multilingual replaced token detection, a batch is constructed by 2,048 length-512 input sequences, while the input length is dynamically set as the length of the original translation pairs in translation replaced token detection.

\begin{table}[ht]
\centering
\small
\renewcommand\tabcolsep{3.5pt}
\begin{tabular}{lr}
\toprule
Hyperparameters & Value \\ \midrule
Training steps & 125K \\
Batch tokens per task & 1M \\
Adam  & 1e-6 \\
Adam  & (0.9, 0.98) \\
Learning rate & 5e-4 \\
Learning rate schedule & Linear \\
Warmup steps & 10,000 \\
Gradient clipping & 2.0 \\
Weight decay & 0.01 \\
\bottomrule
\end{tabular}
\caption{Hyperparameters used for pre-training \our{}.
}
\label{table:pt-hparam}
\end{table}


\section{Hyperparameters for Fine-Tuning}

In Table~\ref{table:hparam}, we report the hyperparameters for fine-tuning \our{} on the XTREME end tasks.

\begin{table*}[t]
\centering
\small
\begin{tabular}{lrrrrrrr}
\toprule
& POS & NER & XQuAD & MLQA & TyDiQA & XNLI & PAWS-X \\ \midrule
Batch size & \{8,16,32\} & 8 & 32 & 32 & 32 & 32 & 32 \\
Learning rate & \{1,2,3\}e-5 & \{5,...,9\}e-6 & \{2,3,4\}e-5 & \{2,3,4\}e-5 & \{2,3,4\}e-5 & \{5,...,8\}e-6 & \{8,9,10,20\}e-6 \\
LR schedule & Linear & Linear & Linear & Linear & Linear & Linear & Linear \\
Warmup & 10\% & 10\% & 10\% & 10\% & 10\% & 12,500 steps & 10\% \\
Weight decay & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\
Epochs & 10 & 10 & 4 & \{2,3,4\} & \{10,20,40\} & 10 & 10\\
\bottomrule
\end{tabular}
\caption{Hyperparameters used for fine-tuning on the XTREME end tasks.}
\label{table:hparam}
\end{table*}

\end{document}
