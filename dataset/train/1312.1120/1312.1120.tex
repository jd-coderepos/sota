\documentclass[a4paper,11pt]{article}

\usepackage[Postscipt=dvips]{diagrams}
\usepackage{latexsym}
\usepackage{amssymb}
\usepackage{stmaryrd}
\usepackage{proof}

\title{A Game Semantics for Generic Polymorphism}

\author{Samson Abramsky\\
Oxford University Computing Laboratory\\
\and
Radha Jagadeesan\\
DePaul University}
\date{}



\newcommand{\gequiv}{\approx}
\newcommand{\lsem}{\llbracket}
\newcommand{\rsem}{\rrbracket}
\newcommand{\eqdef}{\stackrel{\vartriangle}{=}}
\newcommand{\UU}{\mathcal{U}}
\newtheorem{proposition}{Proposition}[section]
\newtheorem{lemma}[proposition]{Lemma}
\newtheorem{theorem}[proposition]{Theorem}
\newtheorem{corollary}[proposition]{Corollary}
\newcommand{\GG}[1]{\mathcal{G}(#1)}
\newcommand{\GasS}{\mathbf{Games}}
\newcommand{\numoccs}[2]{\mathsf{numoccs}(#1 , #2 )}
\newcommand{\parity}{\mathsf{parity}}
\newcommand{\restrict}{{\upharpoonright}}
\newcommand{\llwith}{\, \& \,}
\newcommand{\domapprox}{\, \sqsubseteq \,}
\newcommand{\ginc}{\, \trianglelefteq \,}
\newcommand{\Occ}{\mathcal{O}}
\newcommand{\PInv}[1]{\mathsf{PInv}(#1)}
\newcommand{\twist}{\mathsf{twist}}
\newcommand{\Rel}[1]{\mathsf{Rel}(#1)}
\newcommand{\pow}[1]{\mathcal{P}(#1)}
\newcommand{\invcomp}{\bowtie}
\newcommand{\rconv}[1]{#1^{\mathsf{c}}}
\newcommand{\rdconv}[1]{#1^{\mathsf{c}\, \mathsf{c}}}
\newcommand{\preord}{\lessapprox}
\newcommand{\ident}{\mathsf{id}}
\newcommand{\ICC}{\mathcal{C}}
\newcommand{\CCC}{\mathbf{CCC}}
\newcommand{\CCB}{\ICC_{B}}
\newcommand{\GB}[1]{\mathcal{G}_{B}(#1)}
\newcommand{\GU}[1]{\mathcal{G}_{\UU}(#1)}
\newcommand{\SubU}{\mathsf{Sub}(\UU )}
\newcommand{\SubB}{\mathsf{Sub}(B)}
\newcommand{\Base}{\mathbb{B}}
\newcommand{\List}[1]{\mathsf{List}[#1]}
\newcommand{\Pref}{\mathsf{Pref}}
\newcommand{\ie}{\textit{i.e.}\ }
\newcommand{\pfnarrow}{\; - \! \! \! \rightharpoonup \;}
\newcommand{\al}{\mathtt{p}}
\newcommand{\ar}{\mathtt{q}}
\newcommand{\fr}{\mathtt{r}}
\newcommand{\fl}[1]{\mathtt{l}_{#1}}
\newcommand{\hext}[1]{#1^{\dagger}}
\newcommand{\MM}{\mathcal{M}}
\newenvironment{proof}{\textsc{Proof}\ }{}

\newcommand{\bangindex}[1]{\mathtt{k}_{#1}}
\newcommand{\linearfl}{\mathtt{l}}
\newcommand{\tensorfl}{\mathtt{l^t}}
\newcommand{\tensorfr}{\mathtt{r^t}}
\newcommand{\tensor}{\otimes}
\newcommand{\linimpl}{\multimap}
\newcommand{\LUU}{\mathcal{U'}}
\newcommand{\SubLU}{\mathsf{Sub}(\LUU )}
\newcommand{\linearMM}{\mathcal{M'}}
\newcommand{\lambdaomega}{\lambda\Omega}
\newcommand{\nf}{\mathtt{nf}_{\beta\eta}}
\newcommand{\lang}{\langle}
\newcommand{\rang}{\rangle}


\begin{document}


\maketitle

\begin{center}
\textit{Dedicated to Helmut Schwichtenberg on the occasion of his
  sixtieth birthday. His commitment to the highest scientific
  standards, coupled with a wise and kind humanity, is a continuing
  source of inspiration.}
\end{center}

\begin{abstract}
Genericity is the idea that the same program can work at many
different data types.  Longo, Milstead and Soloviev proposed to capture the
inability of generic programs to probe the structure of their
instances by the following equational principle: if two generic
programs, viewed as terms of type , are equal
at any given instance , then they are equal at all
instances. They proved that this rule is admissible in a certain
extension of System F, but finding a semantically motivated model
satisfying this principle remained an open problem.

In the present paper, we construct a categorical
model of polymorphism, based on game semantics, which contains a
large collection of generic types. This model builds on two novel
constructions:
\begin{itemize}
\item A direct interpretation of variable types as games, with a
  natural notion of substitution of games. This allows moves in
  games  to be decomposed into the generic part from , and
  the part pertaining to the instance . This leads to a
  simple and natural notion of generic strategy.

\item A ``relative polymorphic product''
   which expresses quantification over the type variable
   in the variable type  with respect to a ``universe'' which
  is explicitly given as an additional parameter . We then solve a
  recursive equation involving this relative product to obtain a
  universe in a suitably ``absolute'' sense.
  \end{itemize}
Full Completeness for ML types (universal closures of
quantifier-free types) is proved for this model.
\end{abstract}


\section{Introduction}
We begin with an illuminating quotation from G\'erard Berry \cite{Ber00}:
\begin{quotation}
Although it is not always made explicit, the \textit{Write Things
  Once} or WTO principle is clearly the basis for loops, procedures,
higher-order functions, object-oriented programming and inheritance,
concurrency \textit{vs.} choice between interleavings, etc.
\end{quotation}
In short, much of the search for high-level structure in programming
can be seen as the search for concepts which allow commonality to be expressed. An important facet of this
quest concerns \emph{genericity}: the idea that the same program can
work at many different data types.

For illustration, consider the abstraction step involved in passing
from list-processing programs which work on data types  for
specific types , to programs which work generically on .
Since lists can be so clearly visualized,
\begin{figure}
\begin{center}

\begin{picture}(400,60)(-50,-30)
\put(-40,10){\vector(1,0){40}}                  \multiput(0,0)(100,0){2}{\line(1,0){40}}       \multiput(0,20)(100,0){2}{\line(1,0){40}}       \multiput(0,0)(100,0){2}{\line(0,1){20}}        \multiput(20,0)(100,0){2}{\line(0,1){20}}       \multiput(40,0)(100,0){2}{\line(0,1){20}}       \multiput(10,10)(100,0){2}{\vector(0,-1){40}}  \multiput(30,10)(100,0){2}{\vector(1,0){70}}    \multiput(205,10)(10.00000,0.00000){8}{\line( 1, 0){5.000}}
\put(260,10){\vector(1,0){40}}                  \put(320,0){\line(1,1){20}}                    \put(320,20){\line(1,-1){20}}                  \put(300,0){\line(1,0){40}}                   \put(300,20){\line(1,0){40}}                 \put(300,0){\line(0,1){20}}        \put(320,0){\line(0,1){20}}       \put(340,0){\line(0,1){20}}       \put(310,10){\vector(0,-1){40}}     \end{picture}

\end{center}
\caption{`Generic' list structure}
\end{figure}
it is easy to see what this should mean (see Figure 1). A generic program cannot
probe the internal structure of the list elements. Thus e.g. list
concatenation and reversal are generic, while summing a list is
not. However, when we go beyond lists and other concrete data structures,
to higher-order types and beyond, what genericity or
type-independence should mean becomes much less clear.

One very influential proposal for a general understanding of the
\emph{uniformity} which generic programs should exhibit with respect
to the  type instances has been John Reynolds' notion of
\emph{relational parametricity} \cite{Rey83}, which requires that
relations between  instances be preserved in a suitable sense
by generic programs. This has led to numerous further
developments, e.g. \cite{MR92,ACC93,PA93}.

Relational parametricity is a beautiful and important notion. However,
in our view it is not the whole story. In particular:
\begin{itemize}
\item It is a ``pointwise'' notion, which gets at genericity
  indirectly, via a notion of uniformity applied to the family of
  instantiations of the program, rather than directly
  capturing the idea of a  program written at the generic level,
  which necessarily cannot probe the structure
  of an instance.
\item It is closely linked to strong extensionality principles, as
  shown e.g. in \cite{ACC93,PA93}, whereas the intuition of generic programs not
  probing the structure of instances is \textit{prima facie} an
intensional notion---a constraint on the behaviour of processes.
\end{itemize}
An interestingly different analysis of genericity with different
formal consequences was proposed by Giuseppe Longo, Kathleen Milsted
and Sergei Soloviev \cite{LMS93,Lon95}. Their idea
was to capture the inability of generic programs to probe the
structure of their instances by the following equational principle: if
two generic programs, viewed as terms ,  of type , are
equal at \emph{any} given instance , then they are equal at
\emph{all} instances:

This principle can be stated even more strongly when second-order
polymorphic quantification over type variables is used. For :

We call this the \emph{Genericity Rule}.
In one of the most striking syntactic results obtained for System F
(\ie the polymorphic second-order -calculus \cite{Gir72,Rey74}), Longo, Milsted
and Soloviev proved in \cite{LMS93} that the Genericity Rule is admissible in the system
obtained by extending System F with the following axiom scheme:

While many of the known semantic models of System F satisfy axiom (C),
\emph{there is no known naturally occurring model which satisfies the
  Genericity principle} (\ie in which the  rule of
  Genericity is valid). In fact, in the strong form given above, the
  Genericity rule is actually \emph{incompatible} with
  well-pointedness and parametricity, as observed by Longo. Thus if we
  take the standard polymorphic terms representing the Boolean values

then if the type  has only one
inhabitant --- as will be the case in a parametric model --- then by
well-pointedness the Boolean values will be equated at this instance,
while they cannot be equated in general on pain of inconsistency.

However, we can state a more refined version. Say that a type  is
\emph{a generic instance} if for all types :

This leads to the following problem posed by Longo in  \cite{Lon95}, and
still, to the best of our knowledge, open:
\begin{quotation}
Open Problem 2. Construct, at least, some (categorical) models that
contain a collection of ``generic'' types. \ldots If our intuition
about constructivity is correct, infinite objects in categories of
(effective) sets should satisfy this property.
\end{quotation}

In the present paper, we present a solution to this problem by
constructing a categorical model of polymorphism which contains a
large collection of generic types. The model is based on game
semantics; more precisely, it extends the ``AJM games'' of \cite{AJM00} to
provide a model for generic polymorphism. Moreover, Longo's intuition
as expressed above is confirmed in the following sense: our main
sufficient condition for games (as denotations of types) to be generic
instances is that they have plays of arbitrary length. This can be
seen as an intensional version of Longo's intuition about infinite
objects.

In addition to providing a solution to this problem, the present paper
also makes the following contributions.
\begin{itemize}
\item We interpret variable types in a simple and direct way, with a
  natural notion of \emph{substitution of games into variable
    games}. The crucial aspect of this idea is that it allows moves in
  games  to be decomposed into the generic part from , and
  the part pertaining to the instance . This in turn allows the
  evident content of genericity in the case of concrete data
  structures such as lists to be carried over to arbitrary
  higher-order and polymorphic types. In particular, we obtain a
  simple and natural notion of \emph{generic strategy}. This extends
  the notion of history-free strategy from \cite{AJM00}, which is
  determined by a function on moves, to that of a generic strategy,
  which is determined by a function on \emph{the generic part of the move only},
and simply acts as the identity on the part pertaining to the
instance. This captures the intuitive idea of a generic program, existing ``in
advance'' of its instances, in a rather direct way.

\item We solve the size problem inherent in modelling System F in a
  somewhat novel way. We define a ``relative polymorphic product''
   which expresses quantification over the type variable
   in the variable type  with respect to a ``universe'' which
  is explicitly given as an additional parameter . We then solve a
  recursive equation involving this relative product to obtain a
  universe in a suitably ``absolute'' sense: a game 
  with the requisite closure properties to provide a model for System
  F.

\item We prove Full Completeness for the ML types (\ie the universal
  closures of quantifier-free types).

\end{itemize}


\section{Background}

\subsection{Syntax of System F}
We briefly review the syntax of System F. For further background
information we refer to \cite{GLT89}.

\subsubsection*{Types (Formulas)}



\subsubsection*{Typing Judgements}
Terms in context have the form

\textbf{Assumption}


\noindent \textbf{Implication}


\noindent \textbf{Second-order Quantification}

The  rule is subject to the usual eigenvariable
condition, that  does not occur free in .

\noindent The following isomorphism is definable in System F:

This allows us to use the following normal form for types:

where each  is inductively of the same form.

\subsection{Notation}
We write  for the set of natural numbers.

If  is a set,  is the set of finite sequences (words, strings)
over .  We use , , ,  to denote sequences, and ,
, , , ,  to denote elements of these sequences.
Concatenation of sequences is indicated by juxtaposition, and we don't
distinguish notationally between an element and the corresponding unit
sequence. Thus  denotes the sequence with first element  and
tail
. However, we will sometimes write  or  to
give the name  to the first or last element of a sequence.

If  then  is the
unique
monoid homomorphism extending .  We write  for the length of a
finite sequence, and  for the th element of ,
. We write  for the number of occurrences of  in the sequence .

We write  for the disjoint union of sets , .

If  and , we write  for the
sequence obtained by deleting all elements not in  from . In
practice, we use this notation in the context where , and
by abuse of notation we take , {\ie}\ we
elide the use of injection functions.
We also use several variations on the notion of projection onto a sub-sequence, defining any which are not obvious from the context.

We
write  if  is a prefix of , {\em i.e.}\ 
for some . We write  if  is an even-length prefix of .
 is the set of prefixes of elements of .
 is {\em prefix-closed} if .




\section{Variable Games and Substitution}
\subsection{A Universe of Moves}
We fix an algebraic signature consisting of the following set of
\emph{unary} operations:

We take  to be the algebra over this signature freely generated
by . Explicitly,  has the following ``concrete syntax'':

For any algebra  and map , there is a unique
homomorphism  extending , defined
by:

We now define a number of maps on  by this means.
\begin{itemize}
\item
The \emph{labelling map} .
The polarity algebra on the carrier  interprets ,
,  as the identity, and each  as the involution
, where , . The map on the
generators is the constant map sending each  to .

\item
The map  sends each move to the
unique generator occurring in it. All the unary operations are
interpreted as the identity, and the map on generators is the
identity.

\item
The substitution map. For each move , there is a map

induced by the constant map on  which sends each  to
. We write  for .

\item
An alternative form of substitution is written . This is
induced by the map which sends  to , and is the identity on
all .
\end{itemize}

\begin{proposition}
Substitution is associative and left-cancellative:

\end{proposition}
Note that substitution is right-cancellative \emph{only up to
  permutation of generators}:


\begin{proposition}
\label{sublr}
Substitution interacts with  and  as follows.

\end{proposition}

\noindent We extend the notions of substitution pointwise to sequences and sets
of sequences of moves in the evident fashion.

\noindent We say that  are \emph{unifiable} if for
some , . A set  is
\emph{unambiguous} if whenever  are unifiable, .

\begin{proposition}
\label{unamb}
If  is unambiguous,
and for each  the set  is unambiguous, then so is the
following set:

\end{proposition}
\begin{proof}
Suppose that . We must show
that . By associativity, . Since  is unambiguous, this implies that
. By left cancellativity, this implies that . Since  is unambiguous, this implies that
.
\end{proof}

\noindent Given a subset  and , we write


\noindent We define a notion of projection of a sequence of moves 
onto a
move  inductively as follows:


\noindent Dually, given an unambiguous set of moves , and a
sequence of moves  in which every move has the form  for some  (necessarily unique since  is unambiguous), we define a
projection  inductively as follows:


\subsection{Variable Games}
A \emph{variable game} is a structure

where:
\begin{itemize}
\item
 is an unambiguous  set of moves: the
\emph{occurrences} of . We then define:
\begin{itemize}
\item .
\item .
\item .
\end{itemize}

\item  is a non-empty prefix-closed subset of 
  satisfying the following form of \emph{alternation condition}: the
  odd-numbered moves in a play are \emph{moves by }, while the
  even-numbered moves are \emph{by }. Here we regard the first, third,
  fifth, \ldots occurrences of a move  in a sequence as being by
  , while the second, fourth, sixth \ldots occurrences
  are by the other player.


\item  is an equivalence relation on  such that:

Here  holds if

and the correspondence  is bijective and
preserves  and . We
write

to give the name  to the bijective correspondence .
\end{itemize}

\noindent
A move , , is an \emph{occurrence} of the type
variable , while  is a \emph{bound occurrence}.

The set of variable games is denoted by . The set of
those games  for which the range of  is included in  is denoted by . Note that if , then

 is the set of \emph{closed games}.

\paragraph{Comparison with AJM games}
The above definition of game differs from that in \cite{AJM00} in
several respects.
\begin{enumerate}
\item The notion of bracketing condition, requiring a classification
  of moves as \emph{questions} or \emph{answers}, has been
  omitted. This is because we are dealing here with pure type
  theories, with no notion of ``ground data types''.
\item The alternation condition has been modified: we still have
  strict -alternation of moves, but now successive occurrences of
  moves within a sequence are regarded as themselves having
  alternating polarities. Since in the PCF games in \cite{AJM00} moves
  in fact only occur once in any play, they do fall within the present
  formulation. The reason for the revised formulation is that moves
  in variable games are to be seen as \emph{occurrences} of type variables,
  which can be expanded into plays at an instance. Another motivation
  comes from considering copy-cat strategies, in which (essentially)
  the same moves are
  played alternately by  and .

Technically, modifying the alternation condition in this way simplifies
the definition of substitution (see Section 3.4) and of the games
 corresponding to type variables (see Section 3.5).

\item We have replaced the condition  from \cite{AJM00}
  with a stronger condition, which is in fact satisfied by the games in
  \cite{AJM00}.
\end{enumerate}

\subsection{Constructions on games}
Since variable games are essentially just AJM games with some
additional structure on moves, the cartesian closed structure on AJM games
can be lifted straighforwardly to variable games.

\subsubsection*{Unit type}
The unit type  is the empty game.


\subsubsection*{Product}
The product  is the disjoint union of games.





\subsubsection*{Function Space}
The function space  is defined as follows.



\noindent  is defined to be the set of all sequences in
 satisfying the alternation condition, and
such that:
\begin{itemize}
\item .
\item .
\end{itemize}
Let . Note that
 is unambiguous. Given a permutation  on , we
define

The equivalence relation  is defined by
the condition

This is essentially identical to the definition in \cite{AJM00}. The
only difference is that we use the revised version of the alternation
condition in defining the positions, and that we define  directly, rather than via the linear connectives  and
.


\subsection{Substitution}

Given , and , we define
 as follows.





Here by convenient abuse of notation we write  for .

\begin{proposition}  is a well-defined game. In particular:
\begin{enumerate}
\item  is unambiguous.
\item  satisfies the alternation condition.
\item  satisfies \textbf{(e1)}--\textbf{(e3)}.
\end{enumerate}
\end{proposition}
\begin{proof}
\begin{enumerate}
\item This follows directly from Proposition~\ref{unamb}, since by assumption  and each  are unambiguous.

\item We begin by  formulating the alternation condition more precisely. We define the parity function

Also, for the purposes of this argument we shall interpret  as  and 
 as . We can now define the alternation condition on a sequence  as follows:

We now consider a play .
Note firstly that if , there is nothing more to prove, since in that case  satisfies the alternation condition by assumption, and hence, since , so does .

Otherwise, . We shall use the following identities to verify the alternation condition for this play.

Of these, (1)--(3) are easily verified; (4) follows from Proposition~\ref{sublr}; and (5) and (6) hold by assumption for plays in  and each  respectively. Now


\item We verify \textbf{(e3)}. Suppose that  and .
This implies that  and . By \textbf{(e3)} for , for
some , , and clearly if , then . If , there is nothing more to prove.
Otherwise, if , , then , and . By \textbf{(e3)} for , for some
, . Clearly , as required.
\end{enumerate}
\end{proof}

\subsubsection{Variants of substitution}
Firstly, note that the above definitions would still make sense if we
took  and/or , so that, for example, there is a
well-defined operation

In practice, the finitary versions will be more useful for our purposes
here, as they correspond to the finitary syntax of System F.

More importantly, it is useful to define an operation of substitution
for one type variable only. We write this as

where  is being substituted for the 'th type variable , .

The definition is a simple variation on that of  given
  above. Nevertheless, we give it explicitly, as we will make
  significant use of this version of substitution.






\subsection{Properties of substitution}


\begin{proposition}
\label{sub00}
If , , and , then:

\end{proposition}
\begin{proof}
We show firstly that

Expanding the definitions, we can write the occurrence set of the LHS
of the equation as follows:
 using the
notation .

Similarly, the occurrence set of the RHS can be expanded to
 Equating terms, the equality of these two sets follows from the
fact that , and hence ,
and that , and hence ..

Next we show that the conditions on plays on the two sides of the
equation are equivalent. Expanding the condition on plays on the LHS of the equation we see that  if:
\begin{enumerate}
\item 
\item 
\item 
\end{enumerate}
Similarly, expanding the condition on plays on the RHS yields:
\begin{enumerate}
\item 
\item 
\item .
\end{enumerate}
Note firstly that for any , for some ,  for , .
Now equating terms, we see that the equivalence of the two conditions is implied by the following equations:

These equations are easily verified from the definitions of the
projection operations. Firstly, note that every move in these
games has the form (1) , where for some , : , , and ; or the
form (2) , where ; or (3) , where , . The LHS
of equation (1) projects  a move (1) firstly onto , then
onto , whereas the RHS projects it directly onto . Moves of
the form (2) are left unchanged in both cases; while moves of the
form (3) are projected onto  in both cases.
In
equation (2), the effect of  the projection operations on both sides
of the equation is to
restrict the sequence to moves of the form , and to
project each such move onto . Finally, the effect of both sides
of equation (3) is to project  onto .

The argument for the coincidence of the equivalence relations is
similar.
\end{proof}


\noindent For each  we define the variable game  as follows.


\begin{proposition}
\label{sub0}
\begin{enumerate}
\item For all , : .
\item For all : .
\end{enumerate}
\end{proposition}



\begin{proposition}
\label{sub1}
The cartesian closed structure commutes with substitution:
\begin{enumerate}
\item .
\item .
\end{enumerate}
\end{proposition}
Combining Propositions~\ref{sub0} and \ref{sub1}, we obtain:

\begin{proposition}
The cartesian closed constructions can be obtained by substitution
from their generic forms:

\end{proposition}

\section{Constructing a Universe for Polymorphism}
\label{order}
\subsection{Two Orders on Games}
We will make use of two partial orders on games.

\begin{itemize}
\item The \emph{approximation order} . This will be
  used in constructing games as solutions of recursive equations.

\item The \emph{inclusion order} . This will be used to
  define a notion of ``subgame'' within a suitable ``universal game''
  in our construction of a model of System F.
\end{itemize}

\subsubsection{The Approximation Order}
We define  if:
\begin{itemize}
\item 
\item 
\item 
\end{itemize}
Thus if we are given  and , then  is
completely determined by the requirement that . Note
that if  and , then .

This order was studied in the context of AJM games in \cite{AM95}, and the
theory of recursively defined games was developed there and shown to
work very smoothly, in direct analogy with the treatment of recursion
on Scott information systems \cite{Win93}. All of this theory carries over
to the present setting essentially unchanged. The main facts which we
will need can be summarized as follows.
\begin{proposition}
\label{domapprox}
\begin{enumerate}
\item  is a (large) cpo, with least upper
  bounds of directed sets being given by componentwise unions.
\item All the standard constructions on games, in particular
  product and function space, are monotonic and continuous with
  respect to the approximation order.
\item If a function  is
  -monotonic, and continuous on move-sets, then it is
  -continuous.
\end{enumerate}
\end{proposition}

\noindent Thus if

is continuous, we can solve the recursive equation

using the least fixed point theorem in the standard fashion to
construct a least solution in .

\subsubsection{The Inclusion Order}
We define  by:
\begin{itemize}
\item 
\item 
\item 
\end{itemize}
Thus the only difference between the two orders is the condition
on plays. Note that

The inclusion order is useful in the following context. Suppose we fix
a ``big game''  to serve as a ``universe''. Define a
\emph{sub-game} of  to be a game of the form

where , and

Thus sub-games of  are completely determined by their sets of
positions. We write  for the set of sub-games of
. Note that, for :

\begin{proposition}
\label{SubU}
\begin{enumerate}
\item  is a complete lattice, with meets and joins given by
  intersections and unions respectively.
\item If , then the least sub-game 
  such that  is defined by

\end{enumerate}
\end{proposition}

\noindent It is straightforward to verify that function space and product are
monotonic with respect to the inclusion order. This leads to the
following point, which will be important for our model construction.
\begin{proposition}
\label{Uclos}
Suppose that  is such that

Then  is closed under these constructions.
\end{proposition}
\begin{proof} Firstly,

by -monotonicity of . But  by assumption, and since , , \ie .
Similarly,  is closed under products.
\end{proof}

We also note the following for future reference.
\begin{proposition}
\label{submon}
Substitution  is both -monotonic and -monotonic in  and each , .
\end{proposition}
\begin{proof}
We show -monotonicity for plays. Suppose  and . If , then , and for , , , and hence, since ,

\end{proof}

\paragraph{Adjoints of substitution}
Let  be a variable game, and .  We can use the
substitution structure to compute the \emph{least} instance  (with
respect to )  such
that . We define


\begin{proposition}
\label{inv}
With notation as in the preceding paragraph, let .
\begin{enumerate}
\item .
\item .
\end{enumerate}
\end{proposition}
\begin{proof}
Fix . For ,,

By Proposition~\ref{SubU}(2),  is the least  containing this set.
\end{proof}

\subsection{The Relative Polymorphic Product}
Given  and , we define the relative
polymorphic product  (the ``second-order quantification over  in the
variable type  relative to the universe '') as follows.



To understand the definition of , it is helpful to
consider the following alternative, inductive definition (\textit{cf.}
\cite{Abr96}):

The first clause in the definition of 
is the basis of the induction.
The second clause refers to positions in which it is Opponent's turn to move.
It says that Opponent may play in any way which is valid in {\em some}
instance. The final clause refers
to positions in which it is Player's turn to move.
It says that Player can only move in a fashion which is valid in {\em every}
possible instance. The equivalence of this definition to the one given
above follows easily from Proposition~\ref{inv}.

Intuitively, this definition says that initially, nothing is known about which instance we are playing in.
Opponent progressively reveals the ``game board'' ;
at each stage, Player is constrained to play within the instance
{\em thus far revealed} by Opponent.

The advantage of the definition we have given above is that it avoids
quantification over subgames of  in favour of purely local
conditions on the plays.

\begin{proposition}
\label{sub2}
The relative polymorphic product commutes with substitution.
\begin{enumerate}
\item .
\item If  and ,  then:

\end{enumerate}
\end{proposition}
\begin{proof}
We prove (2). Firstly, we compare the occurrence sets.
Expanding the definitions on the LHS of the equation, we obtain

Similarly, on the RHS we obtain

Since , we conclude that these two sets are equal.

We now show the equivalence of the conditions on plays. In similar fashion to the proof of associativity of substitution (Proposition~\ref{sub00}), this is a straightforward matter of expanding the definitions. The main point is to show the equivalence of the conditions restricting plays in the polymorphic products. This reduces to showing that

which in turn reduces to showing that

and finally to showing that for ,

This holds because the projection  projects moves of the form   with ,  , onto , and leaves the sub-sequence of elements of the form  unchanged.
Finally, we note that projecting  with  or  yields identical results.
\end{proof}

\begin{proposition}
\label{prodcont}
The relative polymorphic product  is
-monotonic and -continuous as a function

\end{proposition}
\begin{proof}
For -monotonicity, suppose  and . By Proposition~\ref{submon}, . For , the further conditions on plays , for , depend only on the sets

which depend only on  and not on .

For -continuity, we use Proposition~\ref{domapprox}(3), by
which it suffices to show continuity on occurrence sets. The action of
 on occurrence sets is just that of substitution, which is defined
pointwise and hence preserves unions.
\end{proof}

\subsection{A Domain Equation for System F}

We define a variable game  of System F types by the following
recursive equation:

Explicitly,  is being defined as the least fixed point of a function . This function is continuous by Propositions~\ref{domapprox} and~\ref{prodcont}.

We can then define second-order quantification by:

Although it is not literally the case that

for trivial reasons of how disjoint union is defined, with a
little adjustment of definitions we can arrange things so that we
indeed have

Thus we get a direct inductive definition of the types of System F as
sub-games of .

Moreover, if  and  are (the variable games corresponding to)
System F types, then a simple induction on the structure of  using
Propositions~\ref{sub0}, \ref{sub1} and~\ref{sub2} shows
that

and similarly for simultaneous substitution.



\section{Strategies}


Fix a variable game . Let

be a partial
function. We can extend  to a partial function

by

Now we can define a set of plays 
inductively as follows:

For all , we can define the restriction of
 to  by:

(Note that
 in this notation.)
We say that  is a \emph{generic strategy} for , and write
, if the following \emph{restriction condition} is satisfied:
\begin{itemize}
\item  for all , so that the restrictions are well-defined.
\end{itemize}
Note that  has the following properties.
\begin{itemize}
\item  is a non-empty set of even-length sequences, closed
  under even-length prefixes.
\item  is \emph{deterministic}, meaning that

\item  is \emph{history-free}, meaning that

\item  is \emph{generic}:

\end{itemize}
These conditions imply that

Moreover, for any set  satisfying
the above conditions, there is a
least partial function  such that
. This function can be defined explicitly by


The equivalence  on plays can be lifted to a partial equivalence (\ie a symmetric and transitive relation) on strategies on , which we also write as . This is defined most conveniently in terms of a partial pre-order (transitive relation) , which is defined as follows.

We can then define

A basic well-formedness condition on strategies  is that they
satisfy this relation, meaning . Note that for
a generic strategy , using the
equivalence on plays in :

A cartesian closed category of games is constructed by taking \emph{partial equivalence classes} of strategies, \ie strategies modulo , as morphisms. See \cite{AJM00} for details.

\subsection{Copy-Cat Strategies}
One additional property of strategies will be important for
our purposes. A partial function  is said to be a
\emph{partial involution} if it is symmetric, \ie if

It is \emph{fixed-point free} if we never have .
Note that fixed-point free partial involutions on a set  are in
bijective correspondence with pairwise disjoint families  of two-element subsets of  (\ie the set of
pairs  such that , and hence also ). Thus they can thought of as ``abstract systems of axiom links''.
See \cite{AL00,AL01} where a combinatory algebra of partial
involutions is introduced, and an extensive study is made of
realizability over this combinatory algebra.

For us, the important correspondence is with \emph{copy-cat strategies},
first  identified in \cite{AJ94a} as central to the game-semantical
analysis of proofs (and so-named there).
We say that  is a \emph{copy-cat strategy} if  where  is a fixed-point free partial involution.

\begin{lemma}[The Copy-Cat Lemma]
Let  be a generic copy-cat strategy. If , then for all
:

\end{lemma}
\begin{proof}
By induction on . The base case is immediate.
Suppose that  and that . By the partial involution property of ,

In the first case,

where the middle equation follows from the induction hypothesis.

\noindent In the second case,

where the middle equation again follows from the induction hypothesis.
\end{proof}

\subsection{Cartesian Closed Structure}
The required operations on morphisms to give the structure of a
cartesian closed category can be defined exactly as for AJM games
\cite{AJM00}. We give the basic definitions, referring to
\cite{AJM00} for motivation and technical details.

We write  for the set of partial involutions on a set .

\begin{proposition}
\begin{enumerate}
\item If  and , then .
\item If , then .
\item Partial involutions are closed under conjugation by
  isomorphisms:

\end{enumerate}
\end{proposition}
Our basic examples of partial involutions will be
``twist maps'' (\ie symmetries) on
disjoint unions:

More generally, to get a partial involution on  we will
specify  and  such
that:

We then define a partial involution by conjugation by the indicated
isomorphism  of the evident disjoint union of  twist maps. The partial involution is undefined on
.


\paragraph{Identity}
For identity morphisms ,

Define .
Then

so we obtain the required partial involution as a twist map. This is
the basic example of a copy-cat strategy.

\paragraph{Projections}
Take for example .

Define

Then , and we obtain the required
partial involution by conjugating the twist map by the evident
isomorphism.

\paragraph{Pairing}
Suppose we are given partial involutions


Using some bijection ,

Then , and conjugating by the indicated isomorphism yields the
required partial involution.

\paragraph{Application}
For application


yielding the required partial involution.

\paragraph{Currying}
Suppose that .

Conjugating   by the indicated isomorphism yields the required
partial involution.

\paragraph{Composition}
Finally, we consider composition. We begin with some preliminaries on
partial involutions.
We write  for the set of relations on a set , \ie
. Note that . We assume the usual regular algebra operations on relations:
composition , union , and reflexive transitive
closure: .

Any  can be written as a disjoint union

where

Now given , , we define  as follows:


\begin{proposition}
\label{invcomp}
\begin{enumerate}
\item  is associative, with identity given by the twist map.
\item If  and , then .
\end{enumerate}
\end{proposition}
\begin{proof}
For (1), see \cite{AJ94a}. For (2), we write  for relational
converse. Note that

If , then

Now if :

using the regular algebra identity .
The other cases are handled similarly.
\end{proof}

\noindent Now suppose we are given


Now , but using some bijection ,

Let  be the conjugation of  by the
indicated isomorphism. Then

as required.

We show that composition is compatible with genericity at the level of
partial involutions. Recall that . Note that if , .
\begin{proposition}
If  and , then

\end{proposition}
\begin{proof}
This is immediate from the definition of , since  distributes over composition and union:

\end{proof}

Next, we give a direct definition of composition on strategies as sets
of plays.
If  and , we
define


\begin{proposition}
.
\end{proposition}
\begin{proof}
See \cite{AJ94a}.
\end{proof}

\noindent Finally, we show the compatibility of composition with
restrictions to instances.
\begin{proposition}
.
\end{proposition}

\paragraph{Remark} The arbitrariness involved in the choice of
bijections  and  and the use of  as  a particular element of 
in the above definitions is factored out by the partial equivalence
, as explained in \cite{AJM00}.
Note that all the other ingredients used in constructing the above
isomorphisms are canonical, arising from the symmetric monoidal
structures of cartesian product and disjoint union on the category of sets, and the
distributivity of cartesian product over disjoint union. For the
general axiomatics of the situation, see \cite{AHS02}.

\section{The Model}

We shall use the hyper-doctrine formulation of model of System F, as
originally proposed by Seely \cite{See87} based on Lawvere's notion
of hyperdoctrines \cite{Law70}, and simplified by Pitts \cite{Pit88};
a good textbook presentation can be found in \cite{Cro93}.

We begin with a key definition:

where  is the universe of System F types constructed in Section~6.

\subsection{The Base Category}
We firstly define a base category . The objects are natural
numbers. A morphism  is an -tuple
 Composition of  with  is by substitution:

The identities are given by:

Note that variables act as projections:

and we can define pairing by

where

Thus this category has finite products, and is generated by the object
, in the sense that all objects are finite powers of .


\subsection{The Indexed CCC}
Next, we define a functor

where  is the category of cartesian closed categories with
\emph{specified} products and exponentials, and functors preserving
this specified structure.

The cartesian closed category  has as objects . Note
that the objects of  are the morphisms ; this
is part of the Seely-Pitts definition.

The cartesian closed structure at the object level is given by the
constructions on variable games which we have already defined: , , . Note that  is closed under these constructions by Proposition~\ref{Uclos}.

A morphism  in  is a generic copy-cat strategy
. Recall that this is actually defined at
the ``global instance'' :

More precisely, morphisms are partial equivalence classes of strategies modulo .

The cartesian closed structure at the level of morphisms was
described in Section~5.2.

\subsubsection*{Reindexing}
It remains to describe the functorial action of morphisms in . For
each , we must define a cartesian closed
functor

We define:

If ,

For functoriality, note that

By Proposition~\ref{sub1},  preserves the cartesian
closed structure.

\subsection{Quantifiers as Adjoints}
The second-order quantifiers are interpreted as right adjoints to
projections.
For each , we have the projection morphism

in . This yields a functor

We must specify a right adjoint

to this functor.
For , we define

To verify the universal property, for each  we must
establish a bijection

Concretely, note firstly that

Next, note that in both hom-sets the strategies are subsets of . In the case of generic strategies
   into
  , these are subject to the constraint of the \emph{restriction
    condition}: that is, for each instance ,

In the case of
  strategies  into , these are subject to the
  constraint that for each instance ,

Thus if we show that these conditions are equivalent, the required
correspondence between these hom-sets is simply the identity (which
also disposes of the naturality requirements)!

Suppose firstly that  satisfies the restriction
condition. Assuming that , we must show that
. But if we let , then by Proposition~\ref{inv}(1),

and the restriction condition implies that

For the converse, suppose that . To show that  satisfies the restriction
condition, choose an instance . Suppose that  and . We must show that
. Let . Then by definition of ,
    , and by Proposition~\ref{inv}(2), . Hence by Proposition~\ref{submon},  as required. 

\paragraph{Naturality (Beck-Chevalley)}
Finally, we must show that the family of right adjoints  form
an indexed (or fibred) adjunction. This amounts to the following: for
each  in , we must show that

Concretely, if , we must show that for each ,

This is Proposition~\ref{sub2}.

\paragraph{Remark}
We are now in a position to understand the logical significance of the relative polymorphic product . We could define

and obtain an indexed category  based on  instead of . We would still have an adjunction

However, in general  would not have sufficiently strong closure
properties to give rise to a model of System F. Obviously, 
must be closed under the cartesian closed operations of product and
function space. More subtly,  must be closed under the
polymorphic product . (This is, essentially, the
``small completeness'' issue \cite{Hyl88}, although our ambient category of
games does not have the requisite exactness properties to allow our
construction to be internalised in the style of realizability
models.\footnote{However, by the result of Pitts \cite{Pit88}, \emph{any}
hyperdoctrine model can be fully and faithfully embedded in an
(intuitionistic) set-theoretic model.}) This circularity, which directly reflects the impredicativity of System F, is resolved by the recursive definition of .

\section{Homomorphisms}
We shall now view games as \emph{structures}, and introduce a natural
notion of homomorphism between games. These will serve as a useful
auxiliary tool in obtaining our results on genericity.

A homomorphism  is a function

which is
\begin{itemize}
\item \emph{length-preserving}: 
\item \emph{prefix-preserving}: 
\item \emph{equivalence-preserving}: .
\end{itemize}

There is an evident category  with  variable games as objects, and
homomorphisms as arrows.

\begin{lemma}[Play Reconstruction Lemma]
Let ,  be variable games. If we are given ,
and for each , a play  with ,
then there is a unique  such
  that:

\end{lemma}
\begin{proof}
We can define  explicitly by:

where  is the 'th position in  at which  occurs.
\end{proof}

This Lemma makes it easy to define a functorial action of variable
games on homomorphisms. Let   be a variable game, and  a homomorphism.
We define

by
,
where


\begin{lemma}[Functoriality Lemma]
 is a well-defined homomorphism, and moreover this action is
functorial:

\end{lemma}

\noindent The second important property is that \emph{homomorphisms preserve plays of
generic strategies}.

\begin{lemma}[Homomorphism Lemma]
Let  be a variable game,   a generic strategy, and  a homomorphism. Then

\end{lemma}
\begin{proof}
By induction on . The base case is trivial. For the inductive
step, let

By induction hypothesis, .
By the Copy-Cat Lemma, . Let . Then
, which is in
 by genericity of .
\end{proof}

\section{Genericity}

Our aim in this section is to show that there are generic types in our
model, and indeed that, in a sense to be made precise, \emph{most
  types are generic}.

We fix a variable game . Out aim is to find conditions
on variable games  which imply that, for generic strategies :
 Since, as
explained in Section~5,

this reduces to proving the implication

Our basic result is the following.

\begin{lemma}[Genericity Lemma]
\label{infgenericity}
If there is a homomorphism , then  is
generic.
\end{lemma}
\begin{proof}
We assume that , and show that
; a symmetric argument shows that .

\noindent Suppose then that

Let

Then since  is a homomorphism,

By the Homomorphism Lemma,

Since by assumption , there exists
 such that:

Since  is generic, this implies that

It remains to show that , where

Since by assumption

and  implies that ,
it suffices to show that .
But by the Copy-Cat Lemma,

But

and the proof is complete.
\end{proof}

\paragraph{Remark} The Genericity Lemma applies to \emph{any} variable
type ; in particular, it is \emph{not} required that  be a
sub-game of . Thus our analysis of genericity is quite robust,
and in particular is not limited to System F.

We define the \emph{infinite plays} over a game  as follows:
 if every finite prefix of  is in .
We can use this notion to give a simple sufficient condition for the
hypothesis of the Genericity Lemma to hold.
\begin{lemma}
If , then B is generic.
\end{lemma}
\begin{proof}
Suppose . Let  be the restriction of
 to the first  elements. We define 
by: . It is trivially verified that this is a
homomorphism. Genericity of  then follows by the Genericity Lemma.
\end{proof}

We now apply these ideas to the denotations of System F types, the
objective being to show that ``most'' System F types denote generic
instances in the model.
Firstly, we define a notion of \emph{length} for games, which we then
transfer to types via their denotations as games.

\noindent We define

Note that .

We now show that any System F type whose denotation admits plays of
length greater than 2 is in fact generic!

\begin{lemma}[One, Two, Infinity  Lemma]
If , then  is generic.
\end{lemma}
\begin{proof}
Consider the normal form of , which can be written as

If , then there is a play of length three, in which the
first move must be made in the rightmost occurrence of , the second
in a copy of some  (by the definition of plays in the polymorphic product),
and the third must also be played in that same copy of  (by the usual
switching conditions). But then the second and third moves can be
repeated arbitrarily often in different copies of , giving rise
to an infinite play.
\end{proof}

We now give explicit syntactic conditions on System F types which
imply that they are generic.

\begin{proposition}
Let .
\begin{enumerate}
\item If for some , , then  is generic.
\item If for some , , and for some , , where  is \textbf{either} some ,
\textbf{or} , \textbf{or} some , then  is generic.
\end{enumerate}
\end{proposition}
\begin{proof}
It is easily seen that types of the shapes described in the statement
of the Proposition have
plays of length 3. Indeed in the first case  plays in the rightmost
occurrence of  in ,  responds in the rightmost occurrence of  in
the given , and then  can respond in that same occurrence of
.
In the second case,  plays in ,  plays in , and then 
can play in . We then apply the previous Lemma.
\end{proof}

\noindent We apply this to the simple and familiar case of ``ML types''.
\begin{corollary}
Let , where  is built from the type variable
 and . If  is non-trivial (i.e. it is not just
), then  is generic.
\end{corollary}

\paragraph{Examples}
The following are all examples of generic types.
\begin{itemize}
\item 
\item 
\item .
\end{itemize}

\paragraph{Non-examples}
The following illustrate the (rather pathological) types which do not
fall under the scope of the above results. Note that the
first two both have length 1; while the third has length 2.
\begin{itemize}
\item 
\item .
\item 
\end{itemize}

\paragraph{Remark} An interesting point illustrated by these examples is that our
conditions on types are orthogonal to the issue of whether the types
are inhabited in System F. Thus the type  is not inhabited in System F, but is generic in the
games model, while the type  is inhabited in System F, but does not satisfy our
conditions for genericity.




\section{Full Completeness}


In this section, we prove full completeness for ML types.  The
full completeness proof exploits the decomposition of Intuitionist
implication into Linear connectives.  We give the basic
definitions, referring to \cite{AJM00} for motivation and
technical details.



\subsection{Linear Structure} The required operations on
morphisms to give the categorical structure required to model the
connectives of intuitionist multiplicative exponential linear
logic can be defined exactly as for AJM games \cite{AJM00}.

We fix an algebraic signature consisting of the following set of
\emph{unary} operations:

We take  to be the algebra over this signature freely
generated by . Explicitly,  has the following
``concrete syntax'':

The \emph{labelling map} . The polarity algebra on the carrier 
interprets , ,  and each
 as the identity, and  as the involution
, where , . The map on the
generators is the constant map sending each  to .

\subsubsection*{Bang:  }
 is defined as follows.



\noindent  is defined to be the set of all sequences in
 satisfying the alternation condition, and such
that:
\begin{itemize}
\item .
\end{itemize}
Let . Given a
permutation  on , we define

The equivalence relation  is
defined by the condition

This is essentially identical to the definition in \cite{AJM00}.
The only difference is that we use the revised version of the
alternation condition in defining the positions.

\subsubsection*{Linear function space: }
The linear function space  is defined as follows.



\noindent  is defined to be the set of all
sequences in  satisfying the alternation
condition, and such that:
\begin{itemize}
\item .
\item .
\end{itemize}
Let . The equivalence relation  is defined
by the condition

\subsubsection*{Tensor: }
The tensor  is defined as follows.


 \noindent  is defined to be the
set of all sequences in  satisfying the
alternation condition, and such that:
\begin{itemize}
\item .
\item .
\end{itemize}
Let . The equivalence relation  is defined by
the condition


\subsection{Domain equation}
Define the two orders  on games as before
(Section~\ref{order}).   We define a variable game  of second order types by the following recursive
equation:

Explicitly,  is being defined as
the least fixed point of a continuous function .

We first summarize the key facts required to relate  and
.  Define .
\begin{proposition} \hfill
\begin{itemize}
\item  , , Substitution and Relative Polymorphic
Product are all -monotone.
\item  is a complete lattice.
\end{itemize}
\end{proposition}
From this proposition, it is clear that  is essentially a
subgame of , with the proviso that the universe of moves
underlying  is different from the universe of moves in
.  More precisely, consider a \emph{renaming map} , that interprets , ,  of
 as the operations with the same name on , and
 as . The map on the
generators is the ``identity'' map sending each  to . Modulo this renaming map,  is a subgame of
.

The genericity results for  carry over to , in
particular the analog of lemma~\ref{infgenericity}.
\begin{lemma}\label{LUUgenericity} If
, then B is generic.
\end{lemma}
In this light, since  is essentially a subgame of , a
full completeness result for  implies full completeness for
.

\subsection{Full completeness}


Consider an ML (universal closures of quantifier-free types) type
, \ie , where  is quantifier-free.  
In the light of lemma~\ref{LUUgenericity}, it suffices to
prove the result when the type variables are instantiated with a
game  such that . Explicitly, suppose that given a strategy  of
type , we can find a term  such that . Then genericity implies that , and hence that , as required.

We define  as a well-opened subgame of , to enable us
to directly adopt the proofs from~\cite{AJM00}.  A game  is
{\em well-opened}~\cite{AJM00} if the opening moves of  can
\emph{only} appear as O-moves in opening positions. That is, for all 
, if
 then


For notational convenience, we define  as a subgame of
.  By the earlier discussion, there is a variant of 
that is a subgame of .  Consider the System F type .  Let .
Consider the infinite position  given by:
 Define  as the minimum game
under the  order containing all the finite prefixes of .
This is constructed as in Lemma~\ref{SubU}.  Explicitly,  is
given  as  the set of positions that are equivalent to
finite prefixes of
 in .  An examination of the equivalence
in  reveals that  is well-opened.

Consider an ML type in which all type variables are instantiated
by .  We now relate strategies in such types  to
-normal forms in the simply typed lambda calculus
built on a single base type  with a constant  at
each type.  is interpreted in the model as the strategy
 which only contains the empty sequence. For completeness,
we record the  -normal forms.
\begin{itemize}
\item For all types ,  and   are  normal forms.
\item Let  be -normal forms at types , .  Let  be of type .   Then  is a -normal form.
\end{itemize}

The statement of the decomposition theorem requires some further
notation from~\cite{AJM00}.   Consider
 where
 If for some  and each  we have
 then we define
 by


With this notation, we are ready to state the decomposition lemma.
\begin{proposition}[Decomposition Lemma]\label{decomp}
Let  be
any strategy, where  We write
.
(Notation : if , then
.)

Then exactly one of the following cases applies.
\begin{itemize}
\item[(i)] 
\item[(ii)]
   where , and

\end{itemize}
\end{proposition}
The proof follows standard arguments~\cite{AJM00,AL00}. In
particular, since  is well-opened, the Bang Lemma
(Proposition 3.3.4 of~\cite{AJM00}) applies. The remainder of the
proof follows Proposition 3.4.5 of~\cite{AJM00}.

The Decomposition Lemma provides for one step of decomposition of
an arbitrary strategy into a form matching that of 
normal forms in the  calculus. However, infinite
strategies such as the  combinator  will not admit a well-founded
inductive decomposition process.

We conclude by describing a ``finiteness'' notion on strategies to
identify the strategies for which the decomposition terminates. We
define a notion of positive occurrences of , following the
usual definition of positive occurrences of variables in a
formula. Consider a linear type built out of  and
type variables.  We define positive and negative occurrences of
 by structural induction.
\begin{itemize}
\item In , the positive occurrences of  are the positive
occurrences in
 and the outermost .  The negative occurrences of  in
 are the negative occurrences in .
\item In , the positive occurrences of  are the
positive occurrences in  and the negative occurrences in .
The negative occurrences of  are the negative occurrences in
 and positive occurrences in .
\end{itemize}
For any linear type  built out of  and , consider  obtained by erasing the positive occurrences
of  from .  There is a canonical morphism 
built by structural induction from dereliction maps (at the positive
occurrences of ) and identities (everywhere else). A strategy
 for an ML type  is \emph{finite} if
there is a finite partial involution  inducing
.

The decomposition process is well-founded for \emph{finite}
strategies.
\begin{theorem}
For any ML type , every finite strategy 
is definable by a  term in -normal form.
\end{theorem}

Stronger results can be proved, although we will not enter into details
here because of space restrictions. Firstly, if we extend the syntax of
 terms to allow \emph{infinite} terms (\ie we take the
ideal completion under the -match ordering), then we can
remove the finiteness hypothesis in the Theorem.
Secondly, if we refine the game model to introduce a notion of
winning infinite play, and use this to restrict to \emph{winning
strategies}, as in \cite{Abr96}, then we can obtain a full completeness
result for the ML types of System F itself, without any need to introduce 
into the syntax.
 
\section{Related Work}
A game semantics for System F was developed by Dominic Hughes in his D.Phil. thesis
\cite{Hug99}. A common feature of his approach with
our's is that both give a direct interpretation of open types as certain games,
and of type substitution as an operation on games. However, his approach is in a sense rather closer to syntax; it
involves carrying type information in the moves, and the resulting model
is much more complex. For example, showing that strategies in the
model are closed under composition is a major undertaking. Moreover,
the main result in \cite{Hug99} is a full completeness theorem
essentially stating that the model is isomorphic to the term model of
System F (with -equivalence), modulo types being reduced to
their normal forms. As observed by Longo \cite{Lon95}, the term model
of System F \emph{does not satisfy Genericity}; in fact, it does not
satisfy Axiom (C). It seems that the presence of explicit type
information in the moves will preclude the model in \cite{Hug99} from
having  genericity properties comparable to those we have established for
our model.

The D.Phil thesis of Andrzej Murawski \cite{Mur01} takes a broadly similar approach
to modelling polymorphism to that of \cite{Hug99}, although the main
focus in \cite{Mur01} is on modelling Light Linear Logic.

\paragraph{Acknowledgements.}  Samson Abramsky was supported in part
by UK EPSRC GR/R88861. Radha Jagadeesan was supported in part by NSF
CCR-0244901.

\begin{thebibliography}{DDDD88}

\bibitem[ACC93]{ACC93}
M. Abadi, L. Cardelli and P.-L. Curien.
Formal Parametric Polymorphism.
In {\em Proc. 20th ACM Symposium on Principles of Programming
  Languages}, 1993.

\bibitem[Abr96]{Abr96}
S. Abramsky.
Semantics of Interaction.
In {\em Semantics and Logics of Computation},
edited by A. Pitts and P. Dybjer, Cambridge University Press 1997,
1--32.

\bibitem[AHS02]{AHS02}
S. Abramsky, E. Haghverdi and P. Scott.
Geometry of Interaction and linear combinatory algebras.
{\em Math. Struct. in Comp. Science} 12:625--665, 2002.

\bibitem[AJ94a]{AJ94a} S. Abramsky, R. Jagadeesan. Games and Full Completeness for
 Multiplicative Linear Logic,  {\em J. of Symbolic  Logic} {\bf 59}(2), 1994, 543--574.


\bibitem[AJM00]{AJM00} S. Abramsky, R. Jagadeesan, P. Malacaria. Full Abstraction
for PCF,  {\em Inf. and Comp.} {\bf 163}, 2000, 409--470.



\bibitem[AL00]{AL00}
 S. Abramsky, M. Lenisa. A Fully-Complete PER Model for ML Polymorphic Types,  {\em CSL'00} Conf. Proc., P. Clote, H.Schwichtenberg eds., LNCS {\bf 1862},
 2000, 140--155.





\bibitem[AL01]{AL01} S. Abramsky, M. Lenisa. A Fully Complete Minimal
  PER Model for the Simply Typed -calculus, {\em CSL'01}
  Conf. Proc., LNCS 2001.

\bibitem[AM95]{AM95}
S. Abramsky and G. McCusker.
Games for Recursive Types.
In C. Hankin, I. Mackie and R. Nagarajan, eds. {\em Theory and Formal
  Methods of Computing 1994}. Imperial College Press, 1995.

\bibitem[Ber00]{Ber00}
G. Berry.
The Foundations of Esterel.
In {\em Proof, Language and Interaction: Essays in honour of Robin
  Milner}, eds. G. Plotkin, C. Stirling and M. Tofte.
MIT Press 2000, 425--454.

\bibitem[Cro93]{Cro93} R. Crole, {\em Categories for Types}, Cambridge University Press, 1993.

\bibitem[Gir72]{Gir72} J.Y. Girard. Interpr\'etation functionelle et \'elimunation des coupures de l'arithm\`etique d'ordre sup\'erieur, Th\`ese d'Etat, Universit\'e Paris VII, 1972.

\bibitem[GLT89]{GLT89}
J.-Y. Girard, Y. Lafont and P. Taylor.
{\em Proofs and Types}.
Cambridge University Press 1989.

\bibitem[Hug99]{Hug99} D. J. D. Hughes.  {\em Hypergame Semantics:
    Full Completeness for System F}. D.Phil. thesis, University of
  Oxford, 1999.

\bibitem[Hyl88]{Hyl88} J. M. E. Hyland. A small complete
  category. {\em Annals of Pure and Applied Logic}, 40, 1988.

\bibitem[HRR90]{HRR90} J. M. E. Hyland, E. Robinson,
  G. Rosolini. Algebraic types in PER models, {\em MFPS} Conf. Proc.,
  M. Main {\em et al.} eds, LNCS {\bf 442},
1990, 333--350.

\bibitem[Law70]{Law70} F. W. Lawvere. Equality in hyperdoctrines and the comprehension schema as an adjoint functor,  Proc.  Symp. on Applications of Categorical Logic, 1970.

\bibitem[LMS93]{LMS93} G. Longo, K. Milsted, S. Soloviev.
The Genericity Theorem and Parametricity
in the Polymorphic -Calculus, TCS 121(1\&2):323--349,  1993.

\bibitem[Lon95]{Lon95}
G. Longo. Parametric and Type-Dependent Polymorphism.
{\em Fundamenta Informaticae} 22(1/2):69--92.

\bibitem[MR92]{MR92}
Q.-Q. Ma and J. C. Reynolds.
Types, Abstraction and Parametric Polymorphism, Part 2.
In S. Brookes et al. editors, {\em Mathematical Foundations of
Programming Language Semantics}. LNCS {\bf 598}, 1992.

\bibitem[Mur01]{Mur01}
A. Murawski.
{\em On Semantic and Type-Theoretic Aspects of Polynomial-Time Computability.}
D.Phil thesis, University of Oxford, 2001.

\bibitem[Pit88]{Pit88} A. Pitts. Polymorphism is set-theoretic constructively,
 {\em CTCS'88} Conf. Proc., D.Pitt ed., LNCS {\bf 283}, 1988.

\bibitem[PA93]{PA93} G. Plotkin, M. Abadi. A Logic for Parametric
Polymorphism, {\em TLCA'93} Conf. Proc., LNCS, 1993.

\bibitem[Rey74]{Rey74} J. C. Reynolds.
Towards a Theory of Type Structure.
Programming Symposium, Proceedings, Paris 1974. LNCS {\bf 19}, 1974.

\bibitem[Rey83]{Rey83}
J. C. Reynolds.
Types, Abstraction and Parametric Polymorphism.
{\em Information Processing 83}, pp. 513--523, Elsevier
(North-Holland), 1983.

\bibitem[See87]{See87}
R. A. G. Seely.
Categorical semantics for higher-order polymorphic lambda calculus.
{\em Journal of Symbolic Logic}, 52(4):969--989, 1987.

\bibitem[Win93]{Win93}
G. Winskel.
{\em The Formal Semantics of Programming Languages}.
MIT Press, 1993.

\end{thebibliography}

\end{document} 
