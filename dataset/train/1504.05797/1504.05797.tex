\documentclass{LMCS}

\def\dOi{11(3:3)2015}
\lmcsheading {\dOi}
{1--37}
{}
{}
{Feb.~27, 2014}
{Aug.~13, 2015}
{}

\ACMCCS{[{\bf Theory of computation}]: Logic --- Constraint and logic programming; Semantics and reasoning --- Program reasoning --- Program specifications; [\textbf{Information systems}]:  World Wide Web --- Web services --- Service discovery and interfaces}



\usepackage{microtype}
\usepackage[english]{babel}
\usepackage{engord}

\usepackage{style/document-structure}
\usepackage{style/lists}
\usepackage{style/dashes}
\usepackage{style/acronyms}

\usepackage{macros/todo}
\usepackage{macros/align}
\usepackage{macros/delimiters}
\usepackage{macros/arrows}
\usepackage{macros/relop}
\usepackage{macros/sets}
\usepackage{macros/categories}
\usepackage{macros/comma-categories}
\usepackage{macros/indexed-categories}
\usepackage{macros/orchestrations}
\usepackage{macros/orchestrations/PE}
\usepackage{macros/orchestrations/ARN}
\usepackage{tikz}
\usepackage{macros/tikz/orchestrations}
\usepackage{macros/tikz/automata}
\usepackage{macros/institutions}
\usepackage{macros/institutions/FOL}
\usepackage{macros/institutions/POA}
\usepackage{macros/institutions/LTL}
\usepackage{macros/institutions/ALTL}
\usepackage{macros/substitutions}
\usepackage{macros/substitutions/FOL}
\usepackage{macros/substitutions/OrcScheme}
\usepackage{macros/quantified-sentences}
\usepackage{macros/LP}
\usepackage{macros/modularization}
\usepackage{macros/SL}

\usepackage[all, cmtip]{xy}


\usepackage{rotating}
\setlength\rotFPtop{0pt plus 1fil}
\setlength\rotFPbot{0pt plus 1fil}
\usepackage{array}
\usepackage{booktabs}

\usepackage{hyperref}



\begin{document}

\title[Service-Oriented Logic Programming]{Service-Oriented Logic Programming\rsuper*}

\author[I.\ \c{T}u\c{t}u]{Ionu\c{t} \c{T}u\c{t}u\rsuper a}
\address{{\lsuper a}Department of Computer Science, Royal Holloway University of London \newline
  Institute of Mathematics of the Romanian Academy, Research group of the project ID-3-0439}
\email{ittutu@gmail.com}

\author[J.\,L.\ Fiadeiro]{Jos\'{e} Luiz Fiadeiro\rsuper b}
\address{{\lsuper b}Department of Computer Science, Royal Holloway University of London}
\email{jose.fiadeiro@rhul.ac.uk}

\keywords{Logic programming, Institution theory, Service-oriented computing, Orchestration schemes, Service discovery and binding}

\titlecomment{{\lsuper*}A preliminary version of this work was presented at CALCO 2013~\cite{Tutu-Fiadeiro:A-logic-programming-semantics-of-services-2013}.}

\begin{abstract}
  \noindent We develop formal foundations for notions and mechanisms needed to support service-oriented computing.
  Our work builds on recent theoretical advancements in the algebraic structures that capture the way services are orchestrated and in the processes that formalize the discovery and binding of services to given client applications by means of logical representations of required and provided services.
  We show how the denotational and the operational semantics specific to conventional logic programming can be generalized using the theory of institutions to address both static and dynamic aspects of service-oriented computing.
  Our results rely upon a strong analogy between the discovery of a service that can be bound to an application and the search for a clause that can be used for computing an answer to a query; they explore the manner in which requests for external services can be described as service queries, and explain how the computation of their answers can be performed through service-oriented derivatives of unification and resolution, which characterize the binding of services and the reconfiguration of applications.
\end{abstract}

\maketitle


\section{Introduction}

\begin{minisection}{Service-Oriented Computing.}Service-oriented computing is a modern computational paradigm that deals with the execution of programs over distributed information-processing infrastructures in which software applications can discover and bind dynamically, at run time, to services offered by providers.
  Whereas the paradigm has been effectively in use for a more than a decade in the form of Web services~\cite{Alonso-Casati-Kuno-Machiraju:Web-Services-2004} or Grid computing~\cite{Foster-Kesselman:The-Grid-2-2004}, research into its formal foundations has lagged somewhat behind, partly because of our lack of understanding of (or agreement on) what is really new about the paradigm, especially in relation to distributed computing in general (see, for example,~\cite{Vogels:Web-services-are-not-distributed-objects-2003}).

  It is fair to say that significant advances have been made towards formalizing new forms of distributed computation that have arisen around the notion of service (e.g.\ choreography~\cite{Su-Bultan-Fu-Zhao:Web-service-choreographies-2007}), notably through several variants of the \nb-calculus.  However, service-oriented computing raises more profound challenges at the level of the structure of  systems due to their ability to discover and bind dynamically, in a non-programmed manner, to other systems.  The structure of the systems that we are now creating in the virtual space of computational networks is intrinsically dynamic, a phenomenon hitherto unknown. Formalisms such as  the \nb-calculus do not address these structural properties of systems.
  This prevents us from fully controlling and developing trust in the systems that are now operating in cyberspace, and also from exploiting the power of the paradigm beyond the way it is currently deployed.

  Towards that end, we have investigated algebraic structures that account for modularity (e.g.~\cite{Fiadeiro-Lopes-Bocchi:Algebraic-semantics-of-service-component-modules-2007,Fiadeiro-Schmitt:Structured-cospans-2007}) -- referring to the way services are orchestrated as composite structures of components and how binding is performed through interaction protocols -- and the mechanisms through which discovery can be formalized in terms of logical specifications of required/provided services and constraint optimisation for service-level agreements (e.g.~\cite{Fiadeiro-Lopes-Bocchi:An-abstract-model-for-service-discovery-and-binding-2011,Fiadeiro-Lopes:Dynamic-reconfiguration-in-service-oriented-architectures-2013}).
  In the present paper, we take further this research to address the operational aspects behind \emph{dynamic} discovery and binding, i.e.\ the mechanisms through which applications discover and bind, at run time, to services.  Our aim is to develop an abstract, foundational setting -- independent of the specific technologies that are currently deployed, such as \newacronym{SOAP}{Simple Object Access protocol} for message-exchange protocols and \newacronym{UDDI}{Universal Description, Discovery and Integration} for description, discovery, and integration -- that combines both the \emph{denotational} and the \emph{operational} semantics of services. 
  The challenge here is to define an integrated algebraic framework that accounts for
  \begin{inlinenum}

  \item logical specifications of services,
    
  \item the way models of those specifications capture orchestrations of components that may depend on externally provided services  to be discovered, and
    
  \item the way the discovery of services and the binding of their orchestrations to client applications can be expressed in logical/algebraic terms.
    
  \end{inlinenum}
\end{minisection}

\begin{minisection}{Logic Programming.}The approach that we propose to develop to meet this challenge builds on the relational variant of (Horn-clause) logic programming -- the paradigm that epitomizes the integration of declarative and operational aspects of logic.  In conventional logic programming, clauses have a declarative semantics as universally quantified implications that express relationships over a domain (the Herbrand universe), and an operational semantics that derives from resolution and term unification: definite clauses (provided by a given logic program) are used to resolve logic-programming queries (expressed as existentially quantified conjunctions) by generating new queries and, through term unification, computing partial answers as substitutions for the variables of the original query. 

  In a nutshell, the analogy between service-oriented computing and conventional logic programming that we propose to systematically examine in this paper unfolds as follows:
  \begin{itemize}

  \item The Herbrand universe consists of those service orchestrations that have no dependencies on external services -- what we refer to as ground orchestrations.
    
  \item Variables and terms correspond to dependencies on external services that need to be discovered and to the actual services that are made available by orchestrations.

  \item Service clauses express conditional properties of services required or provided by orchestrations, thus capturing the notion of service module described in~\cite{Fiadeiro-Lopes-Bocchi:An-abstract-model-for-service-discovery-and-binding-2011}.  Their declarative semantics is that, when bound to the orchestrations of other service clauses that ensure the required properties, they deliver, through their orchestration, services that satisfy the specified properties.

  \item Service queries express properties of orchestrations of services that an application requires in order to fulfil its goal -- what we describe in~\cite{Fiadeiro-Lopes-Bocchi:An-abstract-model-for-service-discovery-and-binding-2011} as activity modules.

  \item Logic programs define service repositories as collections of service modules.

  \item Resolution and term unification account for service discovery by matching required properties with provided ones and the binding of required with provided services.

  \end{itemize}
\end{minisection}

\begin{minisection}{The structure of the paper.}Our research into the logic-programming semantics of service-oriented computing is organized in two parts.
  In Section~\ref{section:orchestration-schemes} we present a new categorical model of service orchestrations, called \emph{orchestration scheme}, that enables us to treat orchestrations as fully abstract entities required to satisfy only a few elementary properties.
  This framework is flexible enough to accommodate, for example, orchestrations in the form of program expressions, as considered in~\cite{Fiadeiro:The-many-faces-of-complexity-in-software-design-2012}, or as asynchronous relational networks similar to those defined in~\cite{Fiadeiro-Lopes:An-interface-theory-for-service-oriented-design-2013}.
  In our study, such schemes play an essential role in managing the inherent complexity of orchestrations whilst making available, at the same time, the fundamental building blocks of service-oriented logic programming.
  In Section~\ref{section:service-discovery-and-binding}, we define a logical system of orchestration schemes over which we can express properties that can be further used to guide the interconnection of orchestrations.
  We recall from~\cite{Tutu-Fiadeiro:Institution-independent-logic-programming-2015} the algebraic structures that underlie institution-independent logic programming, in particular the substitution systems that are characteristic of relational logic programming, and prove that the resulting logic of orchestration schemes constitutes a \emph{generalized substitution system}.
  This result is central to our work, not only because it provides the declarative semantics of our approach to service-oriented computing, but also because it gives a definite mathematical foundation to the analogy between service-oriented computing and conventional logic programming outlined above.
  Building on these results, we show how clauses, queries, unification and resolution can be defined over the generalized substitution system of orchestration schemes, providing in this way the corresponding operational semantics of service-oriented computing.
\end{minisection}

The work presented herein continues our investigation on logic-independent foundations of logic programming reported in~\cite{Tutu-Fiadeiro:Institution-independent-logic-programming-2015}. As such, it is based on the theory of institutions of Goguen and Burstall~\cite{Goguen-Burstall:Institutions-1992}; although familiarity with the institution-independent presentation of logic programming is not essential, some knowledge of basic notions of institution theory such as institution, (co)morphism of institutions, and also of the description of institutions as functors into the category of rooms~\cite{Diaconescu:Institution-Independent-Model-Theory-2008,Sannella-Tarlecki:Foundations-of-Algebraic-Specification-2011} is presumed.


\section{Orchestration Schemes}
\label{section:orchestration-schemes}

The first step in the development of the particular variant of logic programming that we consider in this paper consists in determining appropriate categorical abstractions of the structures that support service-oriented computing.  These will ultimately allow us to describe the process of service discovery and binding in a way that is independent of any particular formalism (such as various forms of automata, transition systems or process algebras).

Our approach is grounded on two observations: first, that orchestrations can be organized as a category whose arrows, or more precisely, cospans of arrows, can be used to model the composition of service components (as defined, for example, in~\cite{Fiadeiro-Lopes-Bocchi:Algebraic-semantics-of-service-component-modules-2007,Fiadeiro-Lopes-Bocchi:An-abstract-model-for-service-discovery-and-binding-2011,Fiadeiro-Lopes:Dynamic-reconfiguration-in-service-oriented-architectures-2013}); second, that the discovery of a service to be bound to a given client application can be formalized in terms of logical specifications of required and provided properties, ensuring that the specification of the properties offered by the service provider refines the specification of the properties requested by the client application. To this end, we explore the model-theoretic notion of refinement advanced in~\cite{Sannella-Tarlecki:Formal-development-of-programs-from-algebraic-specifications-1988}, except  that, in the present setting, the structures over which specifications are evaluated are morphisms into ground orchestrations, i.e.\ into orchestrations that have no dependencies on external services. The motivation for this choice is that, in general, the semantics of non-ground orchestrations is open: the (observable) behaviour exhibited by non-ground orchestrations varies according to the external services that they may procure at run time.
With these remarks in mind, we arrive at the following concept of orchestration scheme.

\begin{defi}[Orchestration scheme]
  An \emph{orchestration scheme} is a quadruple  consisting of
  \begin{itemize}
    
  \item a category  of \emph{orchestrations} and \emph{orchestration morphisms},

  \item a functor  that defines a set  of \emph{service specifications} over  for every orchestration ,

  \item a full subcategory  of \emph{ground orchestrations}, and

  \item a functor  that defines a natural subset \footnote{By describing the set  as a \emph{natural subset} of  we mean that the family of inclusions  defines a natural transformation from  to .} of \emph{properties} of  (specifications that are guaranteed to hold when evaluated over  for every ground orchestration .
    
  \end{itemize}
\end{defi}

\noindent To illustrate our categorical approach to orchestrations, we consider two main running examples: program expressions as discussed in~\cite{Fiadeiro:The-many-faces-of-complexity-in-software-design-2012} (see also~\cite{Morgan:Programming-from-Specifications-1994}), which provide a way of constructing structured (sequential) programs through design-time discovery and binding, and the theory of asynchronous relational networks put forward in~\cite{Fiadeiro-Lopes:An-interface-theory-for-service-oriented-design-2013}, which emphasizes the role of services as an interface mechanism for software components that can be composed through run-time discovery and binding.


\subsection{Program Expressions}
\label{subsection:program-expressions}

The view that program expressions can be seen as defining `service orchestrations' through which structured programs can be built in a compositional way originates from~\cite{Fiadeiro:The-many-faces-of-complexity-in-software-design-2012}.
Intuitively, we can see the rules of the Hoare calculus~\cite{Hoare:An-axiomatic-basis-for-computer-programming-1969} as defining `clauses' in the sense of logic programming, where unification is controlled through the refinement of pre/post-conditions as specifications of provided/required services, and resolution binds program statements (terms) to variables in program expressions.
In Figure~\ref{figure:program-modules} we depict Hoare rules in a notation that is closer to that of service modules, which also brings out their clausal form: the specification (a pair of a pre- and a post-condition) on the left-hand side corresponds to the consequent of the clause (which relates to a `provides-point' of the service), while those on the right-hand side correspond to the antecedent of the clause (i.e.\ to the `requires-points' of the service) -- the specifications of what remains to be discovered and bound to the program expression (the `service orchestration' inside the box) to produce a program.
In Figure~\ref{figure:program-derivation}, we retrace Hoare's original example of constructing a program that computes the quotient and the remainder resulting from the division of two natural numbers as an instance of the unification and resolution mechanisms particular to logic programming.
We will further discuss these mechanisms in more detail in Subsection~\ref{subsection:resolution-as-service-discovery-and-binding}.

\begin{figure}[h]
  \centering
  
  \begin{minipage}{.44\textwidth}
    \centering
    
    \begin{tikzpicture}
      \node (skip) {};
      
      \node (orc) [fit=(skip)] {};

      \node [provides-point] (pspec) [left=.5em of orc.west] {\mathstrut\hspace{.5em}};
      
      \coordinate (north) at ();
      \coordinate (south) at ();
      \coordinate (west)  at ();
      \coordinate (east)  at ();
      
      \begin{pgfonlayer}{background} 
        \node [orchestration] [fit=(orc) (north) (south) (west) (east)] {};
      \end{pgfonlayer}
    \end{tikzpicture}
    
    \vskip 1ex

    (empty statement)

    \vskip 4ex

    \begin{tikzpicture}
      \node (assign)  {};
      
      \node (orc) [fit=(assign)] {};

      \node [provides-point] (pspec) [left=.5em of orc.west] {\hspace{.5em}};

      \coordinate (north) at ();
      \coordinate (south) at ();
      \coordinate (west)  at ();
      \coordinate (east)  at ();
      
      \begin{pgfonlayer}{background} 
        \node [orchestration] [fit=(orc) (north) (south) (west) (east)] {};
      \end{pgfonlayer}
    \end{tikzpicture}

    \vskip 1ex

    (assignment)

    \vskip 4ex

    \begin{tikzpicture}
      \node        (comp)                     {};
      \node [pvar] (pgm1) [left=0em of comp]  {};
      \node [pvar] (pgm2) [right=0em of comp] {};
      
      \coordinate (onorth) at ();
      \coordinate (osouth) at ();
      \coordinate (owest)  at (pgm1.west);
      \coordinate (oeast)  at (pgm2.east);

      \node (orc) [fit=(onorth) (osouth) (owest) (oeast)] {};

      \node [provides-point] (pspec) [left=.5em of orc.west] {\hspace{.5em}};

      \node [requires-point] (rspec1) [above right=1ex and .5em of orc.east, minimum width=3.25em] {};
      \draw (pgm1) |- (rspec1.west);
      \node [requires-point] (rspec2) [below right=1ex and .5em of orc.east, minimum width=3.25em] {};
      \draw (pgm2) |- (rspec2.west);

      \coordinate (north) at ();
      \coordinate (south) at ();
      \coordinate (west)  at ();
      \coordinate (east)  at ();

      \begin{pgfonlayer}{background} 
        \node [orchestration] [fit=(orc) (north) (south) (west) (east)] {};
      \end{pgfonlayer}
    \end{tikzpicture}

    \vskip 1ex

    (sequence)
    
  \end{minipage}
  \hfill
  \begin{minipage}{.55\textwidth}
    \centering

    \begin{tikzpicture}
      \node        (if)                                                                    {};
      \node [pvar] (pgm1)  [below right=0ex and 1em of if.south west, anchor=north west]   {};
      \node        (else)  [below left=0ex and 1em of pgm1.south west, anchor=north west]  {};
      \node [pvar] (pgm2)  [below right=0ex and 1em of else.south west, anchor=north west] {};
      \node        (endif) [below left=0ex and 1em of pgm2.south west, anchor=north west]  {};

      \coordinate (onorth) at (if.north);
      \coordinate (osouth) at (endif.south);
      \coordinate (owest)  at (if.west);
      \coordinate (oeast)  at (if.east);

      \node (orc) [fit=(onorth) (osouth) (owest) (oeast)] {};

      \node [provides-point] (pspec) [left=.5em of orc.west] {\hspace{.5em}};

      \node [requires-point] (rspec1) [above right=1.5ex and .5em of orc.east, minimum width=6.75em] {};
      \draw (pgm1) -| (rspec1.west);
      \node [requires-point] (rspec2) [below right=1.5ex and .5em of orc.east, minimum width=6.75em] {};
      \draw (pgm2) -| (rspec2.west);

      \coordinate (north) at ();
      \coordinate (south) at ();
      \coordinate (west)  at ();
      \coordinate (east)  at ();

      \begin{pgfonlayer}{background} 
        \node [orchestration] [fit=(orc) (north) (south) (west) (east)] {};
      \end{pgfonlayer}
    \end{tikzpicture}

    \vskip 1ex

    (selection)

    \vskip 4ex
    
    \begin{tikzpicture}
      \node        (while)                                                                  {};
      \node [pvar] (pgm)   [below right=0ex and 1em of while.south west, anchor=north west] {};
      \node        (done)  [below left=0ex and 1em of pgm.south west, anchor=north west]    {};

      \coordinate (onorth) at (while.north);
      \coordinate (osouth) at (done.south);
      \coordinate (owest)  at (while.west);
      \coordinate (oeast)  at (while.east);

      \node (orc) [fit=(onorth) (osouth) (owest) (oeast)] {};

      \node [provides-point] (pspec) [left=.5em of orc.west] {\hspace{.5em}};

      \node [requires-point] (rspec) [right=.5em of orc.east] {};
      \draw (pgm) -| (rspec.west);

      \coordinate (north) at ();
      \coordinate (south) at ();
      \coordinate (west)  at ();
      \coordinate (east)  at ();

      \begin{pgfonlayer}{background} 
        \node [orchestration] [fit=(orc) (north) (south) (west) (east)] {};
      \end{pgfonlayer}
    \end{tikzpicture}

    \vskip 1ex

    (iteration)

  \end{minipage}
  
  \caption{Program modules}
  \label{figure:program-modules}
\end{figure}

\begin{sidewaysfigure}
  \centering

  \begin{tikzpicture}


    \node [pvar] (app) {};
    
    \node (app-orc) [fit=(app)] {};

    \node [requires-point] (app-rspec) [right=.5em of app-orc.east] {};
    \draw (app) |- (app-rspec.west);
    
    \coordinate (app-north) at ();
    \coordinate (app-south) at ();
    \coordinate (app-west)  at ();
    \coordinate (app-east)  at ();

    \node (app-rspecr) [right=0em of app-rspec] {\hspace{.6em}};
    


    \node [provides-point] (seq1-pspec) [below=25ex of app-orc.south west, anchor=north west] {\hspace{.25em}};
    \draw [dotted, thick] (app-rspecr)
    -- ()
    -- ()
    -| ()
    -- ()
    -- (seq1-pspec.west);
    
    \path () -- (seq1-pspec.west);

    \node [pvar] (seq1-pgm1) [right=.5em of seq1-pspec.east] {};
    \node        (seq1-comp) [right=0em of seq1-pgm1]        {};
    \node [pvar] (seq1-pgm2) [right=0em of seq1-comp]        {};
    
    \coordinate (seq1-onorth) at ();
    \coordinate (seq1-osouth) at ();
    \coordinate (seq1-owest)  at (seq1-pgm1.west);
    \coordinate (seq1-oeast)  at (seq1-pgm2.east);

    \node (seq1-orc) [fit=(seq1-onorth) (seq1-osouth) (seq1-owest) (seq1-oeast)] {};

    \node [requires-point] (seq1-rspec1) [above right=8ex and .125em of seq1-orc.east] {};
    \draw (seq1-pgm1) |- (seq1-rspec1.west);
    \node [requires-point] (seq1-rspec2) [below right=8ex and .125em of seq1-orc.east] {};
    \draw (seq1-pgm2) |- (seq1-rspec2.west);

    \coordinate (seq1-north) at ();
    \coordinate (seq1-south) at ();
    \coordinate (seq1-west)  at ();
    \coordinate (seq1-east)  at ();



    \node [provides-point] (seq2-pspec) [right=2em of seq1-rspec1.east] {\hspace{.25em}};
    \path (seq1-rspec1) -- node {\hspace{.5em}} (seq2-pspec);

    \node [pvar] (seq2-pgm1) [right=.5em of seq2-pspec.east] {};
    \node        (seq2-comp) [right=0em of seq2-pgm1]        {};
    \node [pvar] (seq2-pgm2) [right=0em of seq2-comp]        {};
    
    \coordinate (seq2-onorth) at ();
    \coordinate (seq2-osouth) at ();
    \coordinate (seq2-owest)  at (seq2-pgm1.west);
    \coordinate (seq2-oeast)  at (seq2-pgm2.east);

    \node (seq2-orc) [fit=(seq2-onorth) (seq2-osouth) (seq2-owest) (seq2-oeast)] {};

    \node [requires-point] (seq2-rspec1) [above right=3ex and .125em of seq2-orc.east] {};
    \draw (seq2-pgm1) |- (seq2-rspec1.west);
    \node [requires-point] (seq2-rspec2) [below right=3ex and .125em of seq2-orc.east] {};
    \draw (seq2-pgm2) |- (seq2-rspec2.west);

    \coordinate (seq2-north) at ();
    \coordinate (seq2-south) at ();
    \coordinate (seq2-west)  at ();
    \coordinate (seq2-east)  at ();



    \node [provides-point] (assign1-pspec) [right=2em of seq2-rspec1.east] {\hspace{.25em}};
    \path (seq2-rspec1) -- node {\hspace{.5em}} (assign1-pspec);

    \node (assign1) [right=.5em of assign1-pspec.east] {};
    
    \node (assign1-orc) [fit=(assign1)] {};

    \coordinate (assign1-north) at ();
    \coordinate (assign1-south) at ();
    \coordinate (assign1-west)  at ();
    \coordinate (assign1-east)  at ();



    \node [provides-point] (assign2-pspec) [right=2em of seq2-rspec2.east] {\hspace{.25em}};
    \path (seq2-rspec2) -- node {\hspace{.5em}} (assign2-pspec);

    \node (assign2) [right=.5em of assign2-pspec.east] {};
    
    \node (assign2-orc) [fit=(assign2)] {};

    \coordinate (assign2-north) at ();
    \coordinate (assign2-south) at ();
    \coordinate (assign2-west)  at ();
    \coordinate (assign2-east)  at ();



    \node [provides-point] (iter-pspec) [right=2em of seq1-rspec2.east] {\hspace{.25em}};
    \path (seq1-rspec2) -- node {\hspace{.5em}} (iter-pspec);

    \node [pvar] (iter-pgm)   [right=1.5em of iter-pspec.east]                                   {};
    \node        (iter-while) [above left=0ex and 1em of iter-pgm.north west, anchor=south west] {};
    \node        (iter-done)  [below left=0ex and 1em of iter-pgm.south west, anchor=north west] {};

    \coordinate (iter-onorth) at (iter-while.north);
    \coordinate (iter-osouth) at (iter-done.south);
    \coordinate (iter-owest)  at (iter-while.west);
    \coordinate (iter-oeast)  at (iter-while.east);

    \node (iter-orc) [fit=(iter-onorth) (iter-osouth) (iter-owest) (iter-oeast)] {};
    
    \node [requires-point] (iter-rspec) [right=.125em of iter-orc.east] {};
    \draw (iter-pgm) -| (iter-rspec.west);

    \coordinate (iter-north) at (iter-rspec.north);
    \coordinate (iter-south) at (iter-rspec.south);
    \coordinate (iter-west)  at ();
    \coordinate (iter-east)  at ();



    \node [provides-point] (seq3-pspec) [right=2em of iter-rspec.east] {\hspace{.25em}};
    \path (iter-rspec) -- node {\hspace{.5em}} (seq3-pspec);

    \node [pvar] (seq3-pgm1) [right=.5em of seq3-pspec.east] {};
    \node        (seq3-comp) [right=0em of seq3-pgm1]        {};
    \node [pvar] (seq3-pgm2) [right=0em of seq3-comp]        {};
    
    \coordinate (seq3-onorth) at ();
    \coordinate (seq3-osouth) at ();
    \coordinate (seq3-owest)  at (seq3-pgm1.west);
    \coordinate (seq3-oeast)  at (seq3-pgm2.east);

    \node (seq3-orc) [fit=(seq3-onorth) (seq3-osouth) (seq3-owest) (seq3-oeast)] {};

    \node [requires-point] (seq3-rspec1) [above right=3ex and .125em of seq3-orc.east] {};
    \draw (seq3-pgm1) |- (seq3-rspec1.west);
    \node [requires-point] (seq3-rspec2) [below right=3ex and .125em of seq3-orc.east] {};
    \draw (seq3-pgm2) |- (seq3-rspec2.west);

    \coordinate (seq3-north) at ();
    \coordinate (seq3-south) at ();
    \coordinate (seq3-west)  at ();
    \coordinate (seq3-east)  at ();
    


    \node [provides-point] (assign3-pspec) [right=2em of seq3-rspec1.east] {\hspace{.25em}};
    \path (seq3-rspec1) -- node {\hspace{.5em}} (assign3-pspec);

    \node (assign3) [right=.5em of assign3-pspec.east] {};
    
    \node (assign3-orc) [fit=(assign3)] {};

    \coordinate (assign3-north) at ();
    \coordinate (assign3-south) at ();
    \coordinate (assign3-west)  at ();
    \coordinate (assign3-east)  at ();
    


    \node [provides-point] (assign4-pspec) [right=2em of seq3-rspec2.east] {\hspace{.25em}};
    \path (seq3-rspec2) -- node {\hspace{.5em}} (assign4-pspec);

    \node (assign4) [right=.5em of assign4-pspec.east] {};
    
    \node (assign4-orc) [fit=(assign4)] {};

    \coordinate (assign4-north) at ();
    \coordinate (assign4-south) at ();
    \coordinate (assign4-west)  at ();
    \coordinate (assign4-east)  at ();
    
    \begin{pgfonlayer}{background} 
      \node [orchestration] [fit=(app-orc) (app-north) (app-south) (app-west) (app-east)] {};
      \node [orchestration] [fit=(seq1-orc) (seq1-north) (seq1-south) (seq1-west) (seq1-east)] {};
      \node [orchestration] [fit=(seq2-orc) (seq2-north) (seq2-south) (seq2-west) (seq2-east)] {};
      \node [orchestration] [fit=(assign1-orc) (assign1-north) (assign1-south) (assign1-west) (assign1-east)] {};
      \node [orchestration] [fit=(assign2-orc) (assign2-north) (assign2-south) (assign2-west) (assign2-east)] {};
      \node [orchestration] [fit=(iter-orc) (iter-north) (iter-south) (iter-west) (iter-east)] {};
      \node [orchestration] [fit=(seq3-orc) (seq3-north) (seq3-south) (seq3-west) (seq3-east)] {};
      \node [orchestration] [fit=(assign3-orc) (assign3-north) (assign3-south) (assign3-west) (assign3-east)] {};
      \node [orchestration] [fit=(assign4-orc) (assign4-north) (assign4-south) (assign4-west) (assign4-east)] {};
    \end{pgfonlayer}
  \end{tikzpicture}
  
  \caption{The derivation of a program that computes the quotient  and the remainder  obtained from the division of  by }
  \label{figure:program-derivation}

  
\end{sidewaysfigure}

The formal description of program expressions that we consider here follows the presentation given in~\cite{Goguen-Malcolm:Algebraic-Semantics-of-Imperative-Programs-1996} of the algebraic semantics of programs except that, instead of the theory of many-sorted algebra, we rely on the theory of preordered algebra developed in~\cite{Diaconescu-Futatsugi:CafeOBJ-Report-1998}, whose institution we denote by .
In this context, signatures are ordinary algebraic signatures whose denotation is defined over the category of preorders rather than that of sets, with models interpreting the sorts as preordered sets and the operation symbols as monotonic functions.  The sentences are built as in first-order logic based on two kinds of atoms: \emph{equational atoms}  and \emph{preorder atoms} , where  and  are terms of the same sort; the latter are satisfied by a preordered algebra  if and only if the interpretations of  and  in  belong to the preorder relation of the carrier of their sort.

In order to fully define the orchestration scheme of program expressions we assume that the programming language we have chosen to analyse is specified through a many-sorted signature  equipped with
\begin{itemize}

\item a distinguished set of sorts  corresponding to the types of executable expressions supported by the language, and sorts  capturing the states of the programs and the various configurations that may arise upon their execution, respectively;

\item operation symbols  and  for sorts , which we regard as constructor operators for the sort ;

\item a (sortwise infinite) \nb-indexed set  of program variables, and state variables , used to refer to the states that precede or result from executions; and

\item a preordered \nb-algebra  that describes the semantics of the programming language through the preorder relation associated with the sort .\footnote{Alternatively, one could use a theory presentation or a structured specification instead of the algebra .}

\end{itemize}

\begin{exa}
  \label{example:structured-programs}
  The premises that we consider within this subsection are weak enough to allow the proposed algebraic framework to accommodate a wide variety of programming languages.
  For instance, the program expressions underlying the modules depicted in Figure~\ref{figure:program-modules} are simply terms of sort  that can be formed based on the following five operation symbols (written using the mixfix notation of \CafeOBJ~\cite{Diaconescu-Futatsugi:CafeOBJ-Report-1998} and \CASL~\cite{Mosses:CASL-RM-2004}):
  \begin{iflalign*}
    \text{(empty statement)} \quad & \opname{skip} \colon \to \stname{Pgm}, & \\
    \text{(assignment)}      \quad & \_ \coloneqq \_ \colon \stname{Id}\, \stname{AExp} \to \stname{Pgm}, \\
    \text{(sequence)}        \quad & \_ \comp \_ \colon \stname{Pgm}\, \stname{Pgm} \to \stname{Pgm}, \\
    \text{(selection)}       \quad & \opname{if}\,\_\,\opname{then}\,\_\,\opname{else}\,\_\,\opname{endif} \colon \stname{Cond}\, \stname{Pgm}\, \stname{Pgm} \to \stname{Pgm}, \\
    \text{(iteration)}       \quad & \opname{while}\,\_\,\opname{do}\,\_\,\opname{done} \colon \stname{Cond}\, \stname{Pgm} \to \stname{Pgm}.
  \end{iflalign*}
  
  To simplify our presentation, we omit the details associated with the sorts  of identifiers,  of arithmetic expressions and  of conditions;  we also tacitly assume that the signature under consideration  declares the usual operation symbols associated with the names of identifiers, the addition, subtraction and multiplication of arithmetic expressions, and with the atoms and Boolean connectives specific to conditions.
  Moreover, we assume the essential sorts  and  to be defined, as well as the operation symbols  and .
\end{exa}

Algebraic signatures having the aforementioned additional structure induce orchestration schemes in a canonical way, as follows.

\begin{minisection}{Orchestrations.}The \emph{orchestrations} are program expressions, that is \nb-terms , usually denoted simply by  if there is no danger of confusion, such that  is a sort in .
  The arrows through which they are linked  generalize the subterm relations; in this sense, a \emph{morphism}  between programs  and  consists of 
  \begin{itemize}

  \item a substitution , mapping the variables that occur in  to program expressions defined over the variables of , together with

  \item a position  in , i.e.\ a sequence of natural numbers that precisely identifies a particular occurrence of a subterm  of ,

  \end{itemize}
  such that .\footnote{Here, we let  denote the canonical extension of the substitution  from variables to terms.}
  Their \emph{composition} is defined componentwise, in a way that ensures the commutativity of the following diagram.
  
\end{minisection}

\begin{minisection}{Specifications.}For each program expression , a \emph{(program) specification} is a triple of the form , where  is a position in  indicating the `subprogram' of  whose behaviour is being analysed,\footnote{The first component of specifications may be encountered in the literature (e.g.\ in~\cite{Morgan:Programming-from-Specifications-1994}) with a different meaning: the set of identifiers whose values may change during the execution of the program.} and  and  are \emph{pre-} and \emph{post-conditions} associated with , formalized as (quantifier-free) \nb-sentences over the signature .
  The intuitive interpretation is the usual one: 
  \begin{quotation}
    \noindent Whenever the program  is executed in an initial state that satisfies the pre-condition , and the execution terminates, the resulting final state satisfies the post-condition .
  \end{quotation}
  Note, however, that specifications cannot be evaluated over arbitrary program expressions because, due to the presence of program variables (from , some of the programs may not support a well-defined notion of execution.
  We will address this aspect in Section~\ref{section:service-discovery-and-binding} by taking into account translations of specifications along morphisms whose codomains are ground program expressions.
  For now, it suffices to mention that the translation of a program specification  of  along a morphism  is defined as the specification  of .
\end{minisection}

\begin{minisection}{Ground orchestrations and properties.}As expected, \emph{ground program expressions} are just program expressions that do not contain variables: \nb-terms  whose sort  belongs to .
  Consequently, they have a well-defined operational semantics, which means that we can check whether or not they meet the requirements of a given specification.

  A specification  is a \emph{property} of a ground program expression  if and only if the following satisfaction condition holds for the preordered algebra :
  
  To keep the notation simple and, at the same time, emphasize the roles of  and , we used  in the above \nb-sentence as another name for , while  is the sentence derived from  by replacing the variable  with .\footnote{Formally, the sentences  and  are obtained by translating  and  along the \nb-substitutions  given by  and , respectively.}
  The same notational convention is used in Figure~\ref{figure:program-modules} to represent the specification attached to the assignment expression.  In that case,  is assumed to be a sentence defined not only over , but also over a variable ; the sentences  and  are then derived from  by replacing  with  and  (regarded as an atomic arithmetic expression), respectively.
  Another notation used in Figure~\ref{figure:program-modules} (and also in Figure~\ref{figure:program-derivation}) is , where  is a term of sort ; this follows Iverson's convention (see~\cite{Iverson:A-Programming-Language-1962}, and also~\cite{Graham-Knuth-Patashnik:Concrete-Mathematics-1994}), and corresponds to an atomic \nb-sentence that captures the semantics of the condition .
  
  We conclude the presentation of orchestrations as program expressions with Proposition~\ref{proposition:orchestration-scheme-of-program-expressions} below, which guarantees that properties form natural subsets of the sets of specifications; in other words, the morphisms of ground programs preserve properties.
  

  \begin{prop}
    \label{proposition:orchestration-scheme-of-program-expressions}
    Let  be a morphism of ground programs.
    For every property  of , the specification  is a property of .
  \end{prop}
  
  \proof
  By the definition of the translation of specifications along morphisms of program expressions,  is a property of  if and only if
  
  To prove this, notice that all morphisms of ground program expressions share the same underlying substitution: the identity of .
  Therefore, , , and , from which we immediately deduce that both the evaluation of  in  and that of  in  correspond to the satisfaction by  of the same \nb-sentence.
  \qed
\end{minisection}


\subsection{Asynchronous Relational Networks}
\label{subsection:asynchronous-relational-networks}

Asynchronous relational networks as developed in~\cite{Fiadeiro-Lopes:An-interface-theory-for-service-oriented-design-2013} uphold a significantly different perspective on services:  the emphasis is put not on the role of services in addressing design-time organisational aspects of complex, interconnected systems, but rather on their role in managing the run-time interactions that are involved in such systems.
In this paper, we consider a variant of the original theory of asynchronous relational networks that relies on hypergraphs instead of graphs, and uses \nb-automata~\cite{Thomas:Automata-on-infinite-objects-1990} (see also~\cite{Perrin-Pin:Infinite-Words-2004}) instead of sets of traces as models of behaviour.

The notions discussed within this context depend upon elements of linear temporal logic, and are introduced through dedicated syntactic structures that correspond to specific temporal signatures and signature morphisms.
However, the proposed theory is largely independent of any logical framework of choice -- similarly to the way in which program expressions can be defined over a variety of algebraic signatures -- and can be easily adapted to any institution for which
\begin{enumerate}

\item\label{assumption:ARN-first} the category of signatures is (finitely) cocomplete;

\item there exist cofree models along every signature morphism, meaning that the reduct functors determined by signature morphisms admit right adjoints;

\item the category of models of every signature has (finite) products;

\item\label{assumption:ARN-last} all model homomorphisms reflect the satisfaction of sentences.

\end{enumerate}

In addition to the above requirements, we implicitly assume, as is often done in institutions (see, for example,~\cite{Diaconescu:Institution-Independent-Model-Theory-2008} and~\cite{Sannella-Tarlecki:Foundations-of-Algebraic-Specification-2011} for more details), that the considered logical system is closed under isomorphisms, meaning that the satisfaction of sentences is invariant with respect to isomorphisms of models.  This property holds in most institutions; in particular, it holds in the variant of temporal logic that we use here as a basis for the construction of the orchestration scheme of asynchronous relational networks.


\subsubsection*{Linear Temporal Logic}

In order to capture a more operational notion of service orchestration, we work with an automata-based variant of the institution  of linear temporal logic~\cite{Fiadeiro-Costa:A-duality-between-specifications-and-models-of-process-behaviour-1996}.  This logical system, denoted , has the same syntax as , which means that signatures are arbitrary sets of \emph{actions}, and that signature morphisms are just functions.  With respect to sentences, for any signature , the set of \nb-sentences is defined as the least set containing the actions in  that is closed under standard Boolean connectives\footnote{For convenience, we assume that disjunctions, denoted , and conjunctions, denoted , are defined over arbitrary finite sets of sentences , and we abbreviate  as  and  as .} and under the temporal operators \emph{next} ( and \emph{until} (.
As usual, the derived temporal sentences  and  stand for  and , respectively.

{\sloppy The semantics of  is defined over (non-deterministic
  finite-state) Muller automata \cite{Muller:Infinite-sequences-and-finite-machines-1963} instead of the more conventional temporal models.  This means that, in the present setting, the models of a signature  are \emph{Muller automata} , which consist of a (finite) set  of \emph{states}, an \emph{alphabet} , a \emph{transition relation} , a subset  of \emph{initial states}, and a subset  of (non-empty) \emph{final-state sets}.}

The satisfaction relation is based on that of : an automaton  satisfies a sentence  if and only if every trace accepted by  satisfies  in the sense of .
To be more precise, let us first recall that a \emph{trace} over  is an (infinite) sequence , and that a \emph{run} of an automaton  defined as above on a trace  is a state sequence  such that  and  for every .
A run  is said to be \emph{successful} if its infinity set, i.e.\ the set of states that occur infinitely often in , denoted , is a member of .
Then a trace  is \emph{accepted} by  if and only if there exists a successful run of  on .
Finally, given a trace  (that can be presumed to be accepted by  and , we use the notation  to indicate the suffix of  that starts at .
The satisfaction of temporal sentences by traces can now be defined by structural induction, as follows:
\begin{iflalign*}[\parindent]
  & \lambda \models a\ \text{if and only if}\ a \in \infsat{\lambda}{0}, && \\
  & \lambda \models \plnot \rho\ \text{if and only if}\ \lambda \nmodels \rho, & \\
  & \lambda \models \textstyle \bigplor E\ \text{if and only if}\ \lambda \models \rho\ \text{for some}\ \rho \in E, & \\
  & \lambda \models \ltlnext \rho\ \text{if and only if}\ \infssuffix{\lambda}{1} \models \rho,\ \text{and} & \\
  & \lambda \models \rho_{1} \ltluntil \rho_{2}\ \text{if and only if}\ \infssuffix{\lambda}{i} \models \rho_{2}\ \text{for some}\ i \in \omega,\ \text{and}\ \infssuffix{\lambda}{j} \models \rho_{1}\ \text{for all}\ j < i, &
\end{iflalign*}
where  is an action in , ,  and  are \nb-sentences, and  is a set of \nb-sentences.

One can easily see that the first of the hypotheses~\ref{assumption:ARN-first}--\ref{assumption:ARN-last} that form the basis of the present study of asynchronous relational networks is satisfied by , as it corresponds to a well-known result about the existence of small colimits in .
In order to check that the remaining three properties hold as well, let us first recall that a \emph{homomorphism}  between Muller automata  and  (over the same alphabet) is a function  such that  whenever , , and .
We also note that for any map , i.e.\ for any signature morphism, and any Muller automaton , the \emph{reduct}  is the automaton  with the same states, initial states and final-state sets as , and with the transition relation given by .

The following results enable us to use the institution  as a foundation for the subsequent development of asynchronous relational networks.
In particular, Proposition~\ref{proposition:cofree-models-in-aLTL} ensures the existence of cofree Muller automata along signature morphisms; Proposition~\ref{proposition:products-of-models-in-aLTL} allows us to form products of Muller automata based on a straightforward categorical interpretation of the fact that the sets of traces accepted by Muller automata, i.e.\ regular \nb-languages, are closed under intersection; and finally, Proposition~\ref{proposition:reflection-of-the-satisfaction-of-sentences-in-aLTL} guarantees that all model homomorphisms reflect the satisfaction of temporal sentences.

\begin{prop}
  \label{proposition:cofree-models-in-aLTL}
  For every morphism of \nb-signatures , the reduct functor  admits a right adjoint, which we denote by .
\end{prop}

\proof
According to a general result about adjoints, it suffices to show that for any automaton  over the alphabet  there exists a universal arrow from  to .

Let us thus consider a Muller automaton  over .
We define the automaton  over the alphabet  by

It is straightforward to verify that the identity map  defines a homomorphism of automata : for any transition , by the definition of the reduct functor , there exists a set  such that  and ; given the definition above of , it follows that , and hence .


Let us now assume that  is another homomorphism of automata, with .
Then for any transition , by the definition of the functor , we have .
Based on the homomorphism property of , it follows that , which further implies, by the definition of , that .
As a result, the map  is also a homomorphism of automata .
Even more, it is obviously the unique homomorphism  (in the category of automata over  such that  in the category of automata over .
\qed

\begin{prop}
  \label{proposition:products-of-models-in-aLTL}
  For any set of actions , the category  of Muller automata defined over the alphabet  admits (finite) products.
\end{prop}

\proof
Let  be a (finite) family of Muller automata over the alphabet , with  given by . We define the automaton  by
\begin{iflalign*}
  Q & = \textstyle \prod_{i \in J} Q_{i}, & \\
  \Delta & = \cbr{\rbr{p, \alpha, q} \st \rbr{p\rbr{i}, \alpha, q\rbr{i}} \in \Delta_{i}\ \text{for all}\ i \in J}, \\
  I & = \textstyle \prod_{i \in J} I_{i},\ \text{and} \\
  \FS & = \cbr{S \subseteq Q \st \pi_{i}\rbr{S} \in \FS_{i}\ \text{for all}\ i \in J},
\end{iflalign*}
where the functions  are the corresponding projections of the Cartesian product .
By construction, it immediately follows that for every , the map  defines a homomorphism of automata .
Even more, one can easily see that for any other family of homomorphisms , with , the unique map  such that  for all  defines a homomorphism of automata as well.
Therefore, the automaton  and the projections  form the product of .
\qed

\begin{prop}
  \label{proposition:reflection-of-the-satisfaction-of-sentences-in-aLTL}
  Let  be a homomorphism between automata defined over an alphabet .
  Every temporal sentence over  that is satisfied by  is also satisfied by .
\end{prop}

\proof
Suppose that , for .
Since the map  defines a homomorphism of automata, for every successful run  of  on a trace , the composition  yields a successful run of  on .
As a result,  accepts all the traces accepted by , which further implies that  satisfies all temporal sentences that are satisfied by .
\qed


\subsubsection*{Service Components}

Following~\cite{Fiadeiro-Lopes:An-interface-theory-for-service-oriented-design-2013}, we regard service components as networks of processes that interact asynchronously by exchanging messages through communication channels.
Messages are considered to be atomic units of communication.  They can be grouped either into sets of messages that correspond to processes or channels, or into specific structures, called ports, through which processes and channels can be interconnected.

The ports can be viewed as sets of messages with attached polarities.  As in~\cite{Brand-Zafiropulo:Communicating-finite-state-machines-1983,Benatallah-Casati-Toumani:Representing-analysing-and-managing-Web-service-protocols-2006} we distinguish between outgoing or published messages (labelled with a minus sign), and incoming or delivered messages (labelled with a plus sign).

\begin{defi}[Port]
  A \emph{port}  is a pair  of disjoint (finite) sets of \emph{published} and \emph{delivered messages}.
  The set of all \emph{messages} of  is given by  and is often denoted simply by .
  Every port  defines the set of \emph{actions} , where
  \begin{itemize}
    
  \item  is the set  of \emph{publication actions}, and
    
  \item  is the set  of \emph{delivery actions}.
    
  \end{itemize}
\end{defi}

Processes are defined by sets of interaction points labelled with ports and by automata that describe their behaviour in terms of observable publication and delivery actions.

\begin{defi}[Process]
  \label{definition:process}
  A \emph{process} is a triple  that consists of a (finite) set  of \emph{interaction points}, each point  being labelled with a port , and a Muller automaton  over the alphabet , where  is the port given by
  
\end{defi}

\begin{exa}
  \label{example:journey-planner-process}
  In Figure~\ref{figure:journey-planner-process} we depict a process  (for Journey Planner) that provides directions from a source to a target location. The process interacts with the environment by means of two ports, named  and .
  The first port is used to communicate with potential client processes -- the request for directions (including the source and the target locations) is encoded into the incoming message , while the response is represented by the outgoing message .
  The second port defines messages that  exchanges with other processes in order to complete its task -- the outgoing message  can be seen as a query for all possible routes between the specified source and target locations, while the incoming messages  and  define the result of the query and the timetables of the available transport services for the selected routes.

  \begin{figure}[h]
    \centering
    
    \begin{tikzpicture}
      \node [align=center, minimum height=9ex, minimum width=4em] (JP) {
         \\Lambda_{\processname{JP}}\dmsgr{planJourney}\pmsgr{directions}\portname{JP_{1}}\pmsgl{getRoutes}\dmsgl{routes}\dmsgl{timetables}\portname{JP_{2}}\processname{JP}\processname{JP}q_{0}q_{5}\processname{JP}\msgname{planJourney}\msgname{getRoutes}q_{0}q_{1}q_{3}q_{2}q_{5}q_{4}\plnot \dact{\msgname{planJourney}}\dact{\msgname{planJourney}}\pact{\msgname{getRoutes}}\plnot \dact{\msgname{routes}} \pland \plnot \dact{\msgname{timetables}}\begin{array}{c}
            \dact{\msgname{routes}} \pland {} \\
            \dact{\msgname{timetables}}
          \end{array}\plnot \dact{\msgname{routes}} \pland \dact{\msgname{timetables}}\dact{\msgname{routes}} \pland \plnot \dact{\msgname{timetables}}\dact{\msgname{routes}}\plnot \dact{\msgname{routes}}\dact{\msgname{timetables}}\plnot \dact{\msgname{timetables}}\plnot \pact{\msgname{directions}}\pact{\msgname{directions}}\Lambda_{\processname{JP}}\thetaMM'A_{\theta} \colon A_{M} \to A_{M'}\aLTL\theta\pact{m}\pact{\theta\rbr{m}}\dact{m}\dact{\theta\rbr{m}}\abr{X, \rbr{M_{x}}_{x \in X}, \Lambda}\rbr{x.\_ \colon A_{M_{x}} \to A_{M}}_{x \in X}\aLTL\abr{X, \rbr{\iota_{x} \colon \Sigma_{x} \to \Sigma}_{x \in X}, \Lambda}Xx \in X\Sigma_{x}\Sigma\iota_{x} \colon \Sigma_{x} \to \Sigmax \in X\Lambda\Sigma\abr{M, \Lambda}M\Lambda\Pset\rbr{A_{M}}A_{M}A_{M}^{-} \cup A_{M}^{+}A_{M}^{-} = \cbr{\pact{m} \st m \in M}A_{M}^{+} = \cbr{\dact{m} \st m \in M}\abr{M, \Lambda, \rbr{\mu_{x} \colon M \pto M_{x}}_{x \in X}}\rbr{M_{x}}_{x \in X}\abr{M, \Lambda}\rbr{\mu_{x} \colon M \pto M_{x}}_{x \in X}M = \bigcup_{x \in X} \dom\rbr{\mu_{x}}x \in X
    \mu_{x}^{-1}\rbr{M_{x}^{\mp}} \subseteq \bigcup_{y \in X \setminus \cbr{x}} \mu_{y}^{-1}\rbr{M_{y}^{\pm}}.
    M_{x}x \in XM_{y}y \in X \setminus \cbr{x}\processname{JP}\connectionname{C}\portname{JP_{2}}\portname{R_{1}}\portname{R_{2}}\pmsgl{getRoutes}\dmsgl{routes}\dmsgl{timetables}\portname{JP_{2}}\dmsgr{getRoutes}\pmsgr{routes}\portname{R_{1}}\dmsgr{routes}\pmsgr{timetables}\portname{R_{2}}\connectionname{C}1ex]
          
        } (JP2 -| R1.west);
      \end{tikzpicture}

      \caption{The Journey Planner's connection}
      \label{figure:journey-planner-connection}
    \end{figure}
    
    The underlying channel of  is given by the set of messages  together with the automaton  that specifies the delivery of all published messages without any delay;  can be built as the product of the automata , for , whose transition map is depicted in Figure~\ref{figure:connection-LM-automaton}, and whose sets of states are all marked as final.

    \begin{figure}[h]
      \centering
      
      \begin{tikzpicture}[automaton]
        \node[state, initial, initial text={}] (q0)                   {};
        \node[state]                           (q1) [right=5em of q0] {};

        \path [every node/.style={font=\scriptsize}]
        (q0) edge [loop above] node {}                (q0)
        (q0) edge [bend left]  node {}                      (q1)
        (q1) edge [loop above] node {}       (q1)
        (q1) edge [bend left]  node {} (q0);
      \end{tikzpicture}

      \caption{The automaton }
      \label{figure:connection-LM-automaton}
    \end{figure}

    The channel is attached to the ports ,  and  through the partial injections
    \begin{itemize}
      
    \item  given by ,  and ,
      
    \item  given by  and , and
      
    \item  given by  and .
      
    \end{itemize}
    These injections specify the actual senders and receivers of messages.  For instance, the message  is delivered only to the port  (because  is not defined on , whereas  is simultaneously delivered to both  and .
  \end{exa}

  As already suggested in Examples~\ref{example:journey-planner-process} and~\ref{example:journey-planner-connection}, processes and connections have dual roles, and they interpret the polarities of messages accordingly. In this sense, processes are responsible for publishing messages (i.e.\ they regard delivered messages as inputs and published messages as outputs), while connections are responsible for delivering messages.
  This dual nature of connections can be made explicit by taking into account, for every connection , partial translations  of the actions defined by the channel into actions defined by the ports, as follows:
  \begin{iflalign*}
    \dom\rbr{A_{\mu_{x}}} & = \cbr{\pact{m} \st m \in \mu_{x}^{-1}\rbr{M_{x}^{-}}} \cup \cbr{\dact{m} \st m \in \mu_{x}^{-1}\rbr{M_{x}^{+}}}, & \\
    A_{\mu_{x}}\rbr{\pact{m}} & = \pact{\mu_{x}\rbr{m}}\ \text{for all messages}\ m \in \mu_{x}^{-1}\rbr{M_{x}^{-}}, \\
    A_{\mu_{x}}\rbr{\dact{m}} & = \dact{\mu_{x}\rbr{m}}\ \text{for all messages}\ m \in \mu_{x}^{-1}\rbr{M_{x}^{+}}.
  \end{iflalign*}
  We usually designate the partial maps  simply by  if there is no danger of confusion.

  \begin{rem}
    \label{remark:abstract-connection}
    Just as in the case of processes, we can define connections based on an arbitrary logical system, without relying on messages.
    To achieve this goal, note that, in , every connection  determines a family of spans 
    
    indexed by points .
    Then we can consider connections more generally as triples  in which the signature  and the model  of  abstract the \emph{channel} component, and the spans of signature morphisms  provide the means of attaching port signatures to the channel.
  \end{rem}

  We can now define asynchronous networks of processes as hypergraphs having vertices labelled with ports and hyperedges labelled with processes or connections.

  \begin{defi}[Hypergraph]  
    A \emph{hypergraph}  consists of a set  of \emph{vertices} or \emph{nodes}, a set  of \emph{hyperedges}, disjoint from , and an \emph{incidence map} , defining for every hyperedge  a non-empty set  of vertices it is incident with.

    A hypergraph  is said to be \emph{edge-bipartite} if it admits a distinguished partition of  into subsets  and  such that no adjacent hyperedges belong to the same part, i.e.\ for every  such that , either  and , or  and .
  \end{defi}

  Hypergraphs have been used extensively in the context of graph-rewriting-based approaches to concurrency, including service-oriented computing (e.g.~\cite{Bruni-Gadducci-LluchLafuente:A-graph-syntax-for-processes-and-services-2009,Ferrari-Hirsch-Lanese-Montanari-Tuosto:Synchronised-hyperedge-replacement-2005}).  We use them instead of graphs~\cite{Fiadeiro-Lopes:An-interface-theory-for-service-oriented-design-2013} because they offer a more flexible mathematical framework for handling the notions of variable and variable binding required in Section~\ref{section:service-discovery-and-binding}.

  \begin{defi}[Asynchronous relational network -- \newacronym{ARN}{Asynchronous relational network}]
    \label{definition:ARN}
    An \emph{asynchronous relational network}  consists of a (finite) edge-bipartite hypergraph  of \emph{points} , \emph{computation hyperedges}  and \emph{communication hyperedges} , and of
    \begin{itemize}
      
    \item a port  for every point ,
      
    \item a process  for every hyperedge , and
      
    \item a connection  for every hyperedge .
      
    \end{itemize}
  \end{defi}

  \begin{exa}
    \label{example:journey-planner}
    By putting together the process and the connection presented in Examples~\ref{example:journey-planner-process} and~\ref{example:journey-planner-connection}, we obtain the \acn{ARN}  depicted in Figure~\ref{figure:journey-planner-ARN}.  Its underlying hypergraph consists of the points , ,  and , the computation hyperedge , the communication hyperedge , and the incidence map  given by  and .

    \begin{figure}[h]
      \centering

      \begin{tikzpicture}


        \node [align=center, minimum height=9ex, minimum width=4em] (JP) {
           \\Lambda_{\processname{JP}}\dmsgr{planJourney}\pmsgr{directions}\portname{JP_{1}}\pmsgl{getRoutes}\dmsgl{routes}\dmsgl{timetables}\portname{JP_{2}}\dmsgr{getRoutes}\pmsgr{routes}\portname{R_{1}}\dmsgr{routes}\pmsgr{timetables}\portname{R_{2}}\connectionname{C}1ex]
          
        } (JP2 -| R1.west);

        \begin{pgfonlayer}{background}
          \node [process] [fit=(JP)] {};
        \end{pgfonlayer}
      \end{tikzpicture}

      \caption{The \acn{ARN} }
      \label{figure:journey-planner-ARN}
    \end{figure}
  \end{exa}


  \subsubsection*{The Orchestration Scheme of Asynchronous Relational Networks}

  Let us now focus on the manner in which \acn{ARN}s can be organized to form an orchestration scheme.
  We begin with a brief discussion on the types of points of \acn{ARN}s, which will enable us to introduce notions of morphism of \acn{ARN}s and ground \acn{ARN}.

  An \emph{interaction point} of an \acn{ARN}  is a point of  that is not bound to both computation and communication hyperedges.
  We distinguish between two types of interaction points, called requires- and provides-points, as follows.

  \begin{defi}[Requires- and provides-point]
    A \emph{requires-point} of an \acn{ARN}  is a point of  that is incident only with a communication hyperedge.
    Similarly, a \emph{provides-point} of  is a point incident only with a computation hyperedge.
  \end{defi}

  \noindent For the \acn{ARN}  depicted in Figure~\ref{figure:journey-planner-ARN}, the points  and  are requires-points (incident with the communication hyperedge , whereas  is a provides-point (incident with the computation hyperedge .

  \begin{minisection}{Orchestrations.}In order to describe \acn{ARN}s as orchestrations we first need to equip them with appropriate notions of morphism and composition of morphisms.
    Morphisms of \acn{ARN}s correspond to injective homomorphisms between their underlying hypergraphs, and are required to preserve all labels, except those associated with points that, like the requires-points, are not incident with computation hyperedges.

    \begin{defi}[Homomorphism of hypergraphs]
      A \emph{homomorphism}  between hypergraphs  and  consists of functions  and \footnote{To simplify the notation, we denote both the translation of vertices and of hyperedges simply by .} such that for any vertex  and hyperedge ,  if and only if .
    \end{defi}

    \begin{defi}[Morphism of \acn{ARN}s]
      Given two \acn{ARN}s  and , a \emph{morphism}  consists of
      \begin{itemize}
        
      \item an injective homomorphism  between the underlying hypergraphs of  and  such that  and , and
        
      \item a family  of polarity-preserving injections , for ,
        
      \end{itemize}
      such that
      \begin{itemize}

      \item for every point  incident with a computation hyperedge, ,
        
      \item for every computation hyperedge , , and
        
      \item for every communication hyperedge , ,  and the following diagram commutes, for every point .
        

      \end{itemize}
    \end{defi}

\noindent    It is straightforward to verify that the morphisms of \acn{ARN}s can be composed in terms of their components.
    Their composition is associative and has left and right identities given by morphisms that consists solely of set-theoretic identities.
    We obtain in this way the first result supporting the construction of an orchestration scheme of \acn{ARN}s.

    \begin{prop}
      The morphisms of \acn{ARN}s form a category, denoted .
      \qed
    \end{prop}
    \vspace{-\topsep}
\end{minisection}

  \begin{minisection}{Specifications.}To define specifications over given \acn{ARN}s, we label their points with linear temporal sentences, much in the way we used pre- and post-conditions as labels for positions in terms when defining specifications of program expressions.

    \begin{defi}[Specification over an \acn{ARN}]
      For any \acn{ARN} , the set  of \emph{\nb-specifications} is the set of pairs , usually denoted , where  is a point of  and  is an \nb-sentence over , i.e.\ over the set of actions defined by the port that labels .
    \end{defi}
    
    The \emph{translation} of specifications along morphisms of \acn{ARN}s presents no difficulties: for every morphism  , the map  is given by
    
    for each point  of  and each \nb-sentence  over the actions of .
    Furthermore, it can be easily seen that it inherits the functoriality of the translation of sentences in , thus giving rise to the functor  that we are looking for.
\end{minisection}

  \begin{minisection}{Ground orchestrations.}Morphisms of \acn{ARN}s can also be regarded as refinements, as they formalize the embedding of networks with an intuitively simpler behaviour into networks that are more complex.  This is achieved essentially by mapping each of the requires-points of the source \acn{ARN} to a potentially non-requires-point of the target \acn{ARN}, a point which can be looked at as the `root' of a particular subnetwork of the target \acn{ARN}.
    To explain this aspect in more detail we introduce the notions of dependency and \acn{ARN} defined by a point.

    \begin{defi}[Dependency]
      Let  and  be points of an \acn{ARN} .
      The point  is said to be \emph{dependent} on  if there exists a path from  to  that begins with a computation hyperedge, i.e.\ if there exists an alternating sequence  of (distinct) points and hyperedges of the underlying hypergraph  of  such that , ,  for every , and .
    \end{defi}

    \begin{defi}[Network defined by a point]
      The \emph{\acn{ARN} defined by a point}  of an \acn{ARN}  is the full sub-\acn{ARN}  of  determined by  and the points on which  is dependent.
    \end{defi}

    One can now see that any morphism of \acn{ARN}s  assigns to each requires-point  of the source network  the sub-\acn{ARN}  of  defined by .

    \begin{exa}
      \label{example:journey-planner-net}
      In Figure~\ref{figure:journey-planner-net-ARN} we outline an extension of the \acn{ARN}  discussed in Example~\ref{example:journey-planner} that is obtained by attaching the processes  (for Map Services) and  (for Transport System) to the requires-points  and  of .
      Formally, the link between  and the resulting \acn{ARN}  is given by a morphism  that preserves all the labels, points and hyperedges of , with the exception of the requires-points  and , which are mapped to  and , respectively.

      In this case,  only depends on itself, hence the sub-\acn{ARN} of  defined by , i.e.\ the \acn{ARN} assigned to the requires-point  of , is given by the process  and its port .
      In contrast, the point  depends on all the other points of , and thus it defines the entire \acn{ARN} .

      \begin{figure}[h]
        \centering

        \begin{tikzpicture}


          \node [align=center, minimum height=9ex, minimum width=4em] (JP) {
             \\Lambda_{\processname{JP}}\dmsgr{planJourney}\pmsgr{directions}\portname{JP_{1}}\pmsgl{getRoutes}\dmsgl{routes}\dmsgl{timetables}\portname{JP_{2}}\dmsgr{getRoutes}\pmsgr{routes}\portname{MS_{1}}\processname{MS}1ex]
            
          };



          \node [port] (TS1) [below right=0ex and 3em of JP2, align=right] {
             \\
            
          };
          \node [port-label] [above=.5ex of TS1] {};

          \node [align=center, minimum height=7ex, minimum width=4em] (TS) [right=0em of TS1] {
             \\Lambda_{\processname{TS}}\connectionname{C}1ex]
            
          } (JP2 -| MS1.west);

          \begin{pgfonlayer}{background}       
            \node [process] [fit=(JP)] {};
            \node [process] [fit=(MS)] {};
            \node [process] [fit=(TS)] {};
          \end{pgfonlayer}
        \end{tikzpicture}

        \caption{The \acn{ARN} }
        \label{figure:journey-planner-net-ARN}
      \end{figure}
    \end{exa}

    In view of the above observation, we may consider the requires-points of networks as counterparts of the variables used in program expressions, and their morphisms as substitutions. 
    This leads us to the following definition of ground \acn{ARN}s.

    \begin{defi}[Ground \acn{ARN}]
      An \acn{ARN} is said to be \emph{ground} if it has no requires-points.
    \end{defi}
    \vspace{-\topsep}
\end{minisection}

  \begin{minisection}{Properties.}The evaluation of specifications with respect to ground \acn{ARN}s relies on the concepts of diagram of a network and automaton (i.e.\ \nb-model) defined by a point, whose purpose is to describe the observable behaviour of a ground \acn{ARN} through one of its points.
    We start by extending Remarks~\ref{remark:abstract-process} and~\ref{remark:abstract-connection} to \acn{ARN}s.

    \begin{fact}[Diagram of an \acn{ARN}]
      Every \acn{ARN}  defines a diagram  as follows:
      \begin{itemize}
        
      \item  is the free preordered category given by the set of objects
        
        and the arrows
        \begin{itemize}
          
        \item  for computation hyperedges, and
          
        \item  for communication hyperedges;
          
        \end{itemize}
        
      \item  is the functor that provides the sets of actions of ports, processes and channels, together with the appropriate mappings between them.
        For example, given a communication hyperedge  and a point ,
        \begin{itemize}
          
        \item , , ,
          
        \item , and
          
        \item .
          
        \end{itemize}
        
      \end{itemize}
    \end{fact}

\noindent     We define the signature of an \acn{ARN} by taking the colimit of its diagram, which is guaranteed to exist because the category , i.e.\ , is finitely cocomplete.

    \begin{defi}[Signature of an \acn{ARN}]
      The signature of an \acn{ARN}  is the colimiting cocone  of the diagram .
    \end{defi}

    The most important construction that allows us to define properties of ground \acn{ARN}s is the one that defines the observed behaviour of a (ground) network at one of its points.

    \begin{defi}[Automaton defined by a point]
      \label{definition:observed-automaton}
      Let  be a point of a ground \acn{ARN} .
      The \emph{observed automaton}  at  is given by the reduct , where
      \begin{itemize}
        
      \item  is the sub-\acn{ARN} of  defined by ,
        
      \item  is the signature of ,
        
      \item  is the product automaton , and
        
      \item  is the cofree expansion of  along , for any hyperedge .
        
      \end{itemize}
    \end{defi}

    \begin{exa}
      Consider once again the (ground) \acn{ARN} represented in Figure~\ref{figure:journey-planner-net-ARN}.
      The automaton defined by the point  is just ; this follows from the observation that the \acn{ARN} defined by  consists exclusively of the process  and the port .
      On the other hand, in order to obtain the automaton defined by the provides-point  one needs to compute the product of the cofree expansions of all four automata , ,  and .
      Based on Propositions~\ref{proposition:cofree-models-in-aLTL} and~\ref{proposition:products-of-models-in-aLTL}, the resulting automaton has to accept precisely the projections to  of those traces accepted by  that are compatible with traces accepted by ,  and , in the sense that together they give rise, by amalgamation, to traces over the alphabet of the network.
    \end{exa}

    We now have all the necessary concepts for defining properties of ground \acn{ARN}s.

    \begin{defi}[Property of an \acn{ARN}]
      Let  be a specification over a ground \acn{ARN} .
      Then  is a \emph{property} of  if and only if the automaton  observed at the point  in  satisfies (according to the definition of satisfaction in  the temporal sentence .
      
    \end{defi}

    \begin{rem}
      It is important to notice that not only the signature of an \acn{ARN}, but also the various cofree expansions and products considered in Definition~\ref{definition:observed-automaton} are unique only up to an isomorphism.  Consequently, the automaton defined by a point of a ground \acn{ARN} is also unique only up to an isomorphism, which means that the closure of  under isomorphisms plays a crucial role in ensuring that the evaluation of specifications with respect to ground \acn{ARN}s is well defined.
    \end{rem}

    All we need now in order to complete the construction of the orchestration scheme of \acn{ARN}s is to show that the morphisms of ground \acn{ARN}s preserve properties.
    This result depends upon the last of the four hypotheses we introduced at the beginning of the subsection: the reflection of the satisfaction of sentences by the model homomorphisms of the institution used as foundation for the construction of \acn{ARN}s.

    \begin{prop}
      \label{orchestration-scheme-of-ARNs}
      For every morphism of ground \acn{ARN}s  and every property  of , the specification  is a property of .
    \end{prop}

    \proof
    Let  and  be the sub-\acn{ARN}s of  and  determined by  and  respectively, and let us also assume that  and that  is the signature of , for .
    Since  is a property of , we know that the automaton  observed at the point  in  satisfies .
    We also know that  defines the \nb-signature morphism  as the identity of  (because  is ground); hence, the automaton  observed at  in  is also a model of .

    By Proposition~\ref{proposition:reflection-of-the-satisfaction-of-sentences-in-aLTL}, \nb-model homomorphisms reflect the satisfaction of sentences; therefore, in order to prove that  satisfies  -- and in this way, that  is a property of  -- it suffices to determine the existence of a homomorphism .

    Recall that  and  are the reducts  and , where, for ,
    \begin{itemize}
      
    \item  is the product , equipped with projections , and

    \item , for , is the cofree expansion of  along , for which we denote the universal morphism from  to  by .
      
    \end{itemize}
    According to the description of the \acn{ARN}s defined by given points, we can restrict  to a morphism of \acn{ARN}s from  to .
    Since  is ground, we further obtain, based on this restriction, a functor  that makes the following diagram commutative.
    
    This allows us to define the derived cocone , whose components are given, for example, by .
    Since  is the colimit of  it follows that there exists a (unique) morphism of cocones , i.e.\ an \nb-signature morphism  that satisfies, in particular,  for every hyperedge .

    We obtain in this way, for every hyperedge , the composite morphism  from  to .
    
    Given that  is the cofree expansion of  along , we deduce that there exists a (unique) morphism  such that the above diagram is commutative.
    This implies, by the universal property of the product , the existence of a (unique) morphism  such that  for every .
    
    It follows that the reduct  is a morphism from  to .  Then, to complete the proof, we only need to notice that  and .
    \qed
\end{minisection}


  \section{A Logical View on Service Discovery and Binding}
  \label{section:service-discovery-and-binding}

  Building on the results of Section~\ref{section:orchestration-schemes}, let us now investigate how the semantics of the service overlay can be characterized using fundamental computational aspects of the logic-programming paradigm such as unification and resolution.
  Our approach is founded upon a simple and intuitive analogy between concepts of service-oriented computing like service module and client application~\cite{Fiadeiro-Lopes-Bocchi:An-abstract-model-for-service-discovery-and-binding-2011}, and concepts such as clause and query that are specific to (the relational variant of) logic programming~\cite{Lloyd:Foundations-of-Logic-Programming-1987}.
  In order to clarify this analogy we rely on the institutional framework that we put forward in~\cite{Tutu-Fiadeiro:Institution-independent-logic-programming-2015} to address the model-theoretic foundations of logic programming.

  We begin by briefly recalling the most basic structure that underlies both the denotational and the operational semantics of relational logic programming: the substitution system of (sets of) variables and substitutions over a given (single-sorted) first-order signature.
  Its definition relies technically on the category  of \emph{institution rooms} and \emph{corridors} (see e.g.~\cite{Mossakowski:Comorphism-based-Grothendieck-logics-2002}). The objects of  are triples  consisting of a set  of \emph{sentences}, a category  of \emph{models}, and a \emph{satisfaction relation} . They are related through corridors  that abstract the change of notation within or between logics by defining a \emph{sentence-translation function}  and a \emph{model-reduction functor}  such that the following condition holds for all  and :
  

  \begin{defi}[Substitution system]
    A \emph{substitution system} is a triple , often denoted simply by , that consists of
    \begin{itemize}
      
    \item a category  of \emph{signatures of variables} and \emph{substitutions}, 
      
    \item a room  of \emph{ground sentences} and \emph{models}, and 
      
    \item a functor , defining for every signature of variables  the corridor  from  to the room  of \emph{\nb-sentences} and \emph{\nb-models}.

    \end{itemize}
  \end{defi}

  \begin{exa}
    \label{example:FP-substitution-system}
    In the case of conventional logic programming, every single-sorted first-order signature  determines a substitution system 
    \aFOLssneq
where  is simply the category whose objects are sets of variables (defined over the signature , and whose arrows are first-order substitutions.  The room  accounts for the (ground) atomic sentences given by , the models of , as well as the standard satisfaction relation between them.  And finally, the functor  maps every signature (i.e.\ set) of variables  to the corridor ,
    
    where  and  are the translation of sentences and the reduction of models that correspond to the inclusion of signatures .
  \end{exa}

  Substitution systems are particularly useful when reasoning about the semantics of clauses and queries.
  For instance, the above substitution system can be used to define (definite) clauses over  as syntactic structures , also written
  
  such that  is a signature of variables,  is sentence over , and  is a (finite) set of sentences over .\footnote{Note that, in relational logic programming, the variables are often distinguished from other symbols through notational conventions; for this reason, the set  of variables is at times omitted.}
  The semantics of such a construction is given by the class of models of , i.e.\ of ground models of the substitution system, whose expansions to  satisfy  whenever they satisfy all sentences in  -- this reflects the usual interpretation of logic-programming clauses as universally quantified sentences .

  Similarly to institutions, the axiomatic approach to logic programming on which we rely in this paper is parameterized by the signature used.
  In categorical terms, this means that the morphisms of signatures induce appropriate morphisms between their corresponding substitution systems, and moreover, that this mapping is functorial.
  As regards our inquiry on the semantics of the service overlay, it suffices to recall that the category  of substitution systems results from the Grothendieck construction~\cite{Tarlecki-Burstall-Goguen:Fundamental-algebraic-tools-III-1991} for the functor  that maps
  \begin{itemize}

  \item every category  and room  to the category of functors ,

  \item every functor  and corridor  to the canonical composition functor 
    .

  \end{itemize}
  This allows us to introduce the next notion of generalized substitution system.

  \begin{defi}[Generalized substitution system]
    A \emph{generalized substitution system} is a pair  given by a category  of \emph{signatures}, and a functor .
  \end{defi}

  \noindent In order to provide a better understanding of the complex structure of generalized substitution systems, we consider the following notational conventions and terminology:
  \begin{itemize}[label=]

  \item For every signature  of a generalized substitution system , we denote the (local) substitution system  by , and we refer to the objects and morphisms of  as \emph{signatures of \nb-variables} and \emph{\nb-substitutions}.
    The room  is assumed to comprise the set  of \emph{ground \nb-sentences}, the category  of \emph{\nb-models}, and the \emph{\nb-satisfaction relation} .

  \item On objects,  maps every signature of \nb-variables  to the corridor  from  to the room  of \emph{\nb-sentences} and \emph{\nb-models}.
    

  \item On arrows,  maps every \nb-substitution  to the corridor  from  to , which satisfies, by definition, .
    

  \item With respect to signature morphisms, every  determines a morphism of substitution systems  in the form of a triple , where  is a functor ,  is a corridor , and for every signature of \nb-variables ,  is a (natural) corridor .
    

  \end{itemize}
 \noindent In addition, we adopt notational conventions that are similar to those used for institutions.
  For example, we may use superscripts as in  is order to avoid potential ambiguities; or we may drop the subscripts of  when there is no danger of confusion.
  Also, we will often denote the functions ,  and  by ,  and , respectively, and the functors ,  and  by ,  and .

  \begin{exa}
    Relational logic programming is based upon the generalized substitution system  of the atomic fragment of single-sorted first-order logic  without equality.
    
    In this case, the category  is just the category of single-sorted first-order signatures.
    Every signature  is  mapped to a substitution system  as described in Example~\ref{example:FP-substitution-system}, while every signature morphism  resolves to a morphism of substitution systems for which  is the obvious translation of \nb-substitutions along , and  is the corridor .
    A more detailed presentation of first-order generalized substitution systems can be found in~\cite{Tutu-Fiadeiro:Institution-independent-logic-programming-2015}.
  \end{exa}


  \subsection{A Generalized Substitution System of Orchestration Schemes}

  What is essential about orchestration schemes with respect to the development of the service-oriented variant of logic programming is that they can be organized as a category  from which there exists a functor  into  that allows us to capture some of the most basic aspects of service-oriented computing by means of logic-programming constructs.
  More precisely, orchestration schemes form the signatures of a generalized substitution system
  
  through which the notions of service module, application, discovery and binding emerge as particular instances of the abstract notions of clause, query, unification and resolution.
  In this sense,  and  can be regarded as structures having the same role in the description of service-oriented and relational logic programming, respectively.

  Morphisms of orchestration schemes are, intuitively, a way of encoding orchestrations.
  In order to understand how they arise in practice, let us consider a morphism  between two algebraic signatures  and  used in defining program expressions.  For instance, we may assume  to be the signature of structured programs discussed in Example~\ref{example:structured-programs}, and  its extension with a new operation symbol .
  Then, it is easy to notice that the translation of \nb-terms (over a given set of program variables) along  generalizes to a functor  between the categories of program expressions defined over  and .
  Moreover, the choice of  enables us to define a second functor , from program expressions over  to program expression over , based on the derived signature morphism (see e.g.~\cite{Sannella-Tarlecki:Foundations-of-Algebraic-Specification-2011})  that encodes the  operation as the term .\footnote{In this context,  and  are variables corresponding to the arguments of the derived operation.}
  The functor  is clearly a right inverse of  with respect to ground program expressions, whereas in general, for every program expression  over  we actually obtain a morphism  as a result of the potential renaming of program variables; thus, the morphism  accounts for translation of the program variables of  along .
  Furthermore, for every program expression  over , the translation of \nb-sentences determined by  extends to a map between the specifications over  and the specifications over , which, as we will see, can be used to define a translation of the specifications over a program expression  (given by  to specifications over .
  With respect to the semantics, it is natural to expect that every program expression  over  has the same behaviour as  and, even more, that every program expression  over  (that may be built using , behaves in the same way as .
  These observations lead us to the following formalization of the notion of morphism of orchestration schemes.

  \begin{defi}[Morphism of orchestration schemes]
    \label{definition:morphism-of-orchestration-schemes}
    A \emph{morphism} between orchestration schemes  and  is a tuple , where
    
    \begin{itemize}

    \item  and  are functors as depicted above such that  and ,

    \item  is a natural transformation  such that  for every , and
      
    \item  is a natural transformation  such that for every ground orchestration  and specification ,
      

    \end{itemize}
  \end{defi}

  \begin{exa}
    \label{example:morphisms-of-orchestration-schemes-of-ARNs}
    Let  and  be two institutions suitable for defining orchestration schemes of \acn{ARN}s (according to the hypotheses introduced in Subsection~\ref{subsection:asynchronous-relational-networks}), and let  be a morphism of institutions  such that  is cocontinuous and  preserves cofree expansions and products.
    If  and  admit sections, that is if there exist a functor  such that  and a natural transformation  such that , then  gives rise to a morphism  between the orchestration schemes of \acn{ARN}s defined over  and .
    In particular, the functor  maps the diagram and the models that label an \acn{ARN} defined over  to their images under  and ; similarly,  maps \acn{ARN}s defined over  according to  and ; the natural transformation  is just an identity, and  extends the \nb-translation of sentences to specifications. The additional properties of  and  are essential for ensuring that the observable behaviour of ground networks is preserved.

    One may consider, for instance, the extension of  (in the role of  with new temporal modalities such as \emph{previous} and \emph{since}, as in~\cite{Knapp-Marczynski-Wirsing-Zawlocki:A-heterogeneous-approach-to-service-oriented-systems-specification-2010}; this naturally leads to a morphism of orchestration schemes for which both  and  would be identities.
    Alternatively, one may explore the correspondence between deterministic weak \nb-automata -- which form a subclass of Muller automata -- and sets of traces that are both B\"{u}chi and co\nb-B\"{u}chi deterministically recognizable -- for which a minimal automaton can be shown to exist (see e.g.~\cite{Maler-Staiger:Syntactic-congruences-for-omega-languages-1997,Loding:Efficient-minimization-of-deterministic-weak-omega-automata-2001}). In this case, in the roles of  and  we could consider variants of  with models given by sets of traces and deterministic weak automata, respectively;\footnote{Note that, to ensure that model reducts are well defined for deterministic automata, one may need to restrict signature morphisms to injective maps.}  and  would be identities,  would define the language recognized by a given automaton, and  would capture the construction of minimal automata.
  \end{exa}

  It it easy to see that the morphisms of orchestration schemes compose in a natural way in terms of their components, thus giving rise to a category of orchestration schemes.

  \begin{prop}
    The morphisms of orchestration schemes can be composed as follows:
    
    Under this composition, orchestration schemes and their morphisms form a category .
    \qed
  \end{prop}

  The definition of the functor  is grounded on two simple ideas:
  \begin{enumerate}

  \item Orchestrations can be regarded as signatures of variables; they provide sentences in the form of specifications, and models as morphisms into ground orchestrations -- which can also be seen, in the case of \acn{ARN}s, for example, as collections of ground networks assigned to the `variables' of the considered orchestration.  In addition, we can define a satisfaction relation between the models and the sentences of an orchestration based of the evaluation of specifications with respect to ground orchestrations.  In this way, every orchestration scheme yields an institution whose composition resembles that of the so-called institutions of extended models~\cite{Schroder-Mossakowski-Luth:Type-class-polymorphism-2004}.

  \item There is a one-to-one correspondence between institutions and substitution systems defined over the initial room  -- the room given by the empty set of sentences, the terminal category , and the empty satisfaction relation.  The effect of this is that a clause can be described as `correct' whenever it is satisfied by the sole model of ; therefore, we obtain precisely the notion of correctness of a service module~\cite{Fiadeiro-Lopes-Bocchi:An-abstract-model-for-service-discovery-and-binding-2011}: all models of the underlying signature of variables, i.e.\ of the orchestration, that satisfy the antecedent of the clause satisfy its consequent as well.

  \end{enumerate}
  Formally,  results from the composition of two functors,  and , that implement the general constructions outlined above.
  
  The functor  carries most of the complexity of , and is discussed in detail in Theorem~\ref{theorem:osIns}.
  Concerning , we recall from~\cite{Tutu-Fiadeiro:Institution-independent-logic-programming-2015} that the category  of institution comorphisms can also be described as the category  of functors into , and that any functor  can be extended to a functor  that is given essentially by the right-composition with .
  In particular, the isomorphism  that maps every room  to the unique corridor  generates an isomorphism of categories between , i.e.\ , and .  The latter is further embedded into , defining in this way, by composition, the required functor .
  To sum up,  maps every institution  to the substitution system  for which , for every signature , is the unique corridor between  and .

  \begin{thm}
    \label{theorem:osIns}
    The following map defines a functor .
    \begin{itemize}

    \item For any orchestration scheme ,  is the institution whose category of signatures is , sentence functor is , model functor is , and whose family of satisfaction relations is given by
      
      for every orchestration , every \nb-model , i.e.\ every morphism of orchestrations  such that  is ground, and every specification  over .\footnote{Moreover,  is exact, because the functor  is continuous (see e.g.~\cite{Meseguer:General-logics-1989}).}

    \item For any morphism of orchestration schemes , with  as above and  given by ,  is the comorphism of institutions  defined by
      
      for every orchestration , where  is the natural transformation given by  for every orchestration  and every object or arrow  of the comma category .

    \end{itemize}
  \end{thm}

  \proof
  For the first part, all we need to show is that the satisfaction condition holds; but this follows easily since for every morphism of orchestrations , every \nb-specification  and every \nb-model ,
  

  As regards the second part of the statement, let us begin by noticing that  and  are the natural transformations  and , respectively.
  Then, in order to verify that  is indeed a comorphism , consider an orchestration  in , a model  of , and a specification  over .
  Assuming that  is the family of satisfaction relations of , we deduce that
  \models'_{F\rbr{\orc}}\alpha_{\orc}\sigma\Prop\rbr{U\rbr{\grc'}} = \sigma_{\grc'}^{-1}\rbr{\Prop'\rbr{\grc'}}\models_{\orc}\beta_{\orc}

\noindent  Finally, it is easy to see that  preserves identities.
  To prove that it also preserves composition, let  and  be  morphisms of orchestration schemes as below, and suppose that  and .
  
  In addition, let  and  be the natural transformations involved in the definitions of  and , respectively.
  Based on the composition of morphisms of orchestration schemes and on the definition of , it follows that  is a comorphism of institutions of the form , where  and  are given by
  
  In order to complete the proof we need to show that  and .
  Each of these equalities follows from a sequence of straightforward calculations that relies on the naturality of  (in the case of , or on the naturality of  (in the case of .
  

  \begin{cor}
    The pair  defines a generalized substitution system.
    \qed
  \end{cor}

  We recall from~\cite{Tutu-Fiadeiro:Institution-independent-logic-programming-2015} that, in order to be used as semantic frameworks for logic programming, generalized substitution systems need to ensure a weak model-amalgamation property between the models that are ground and those that are defined by signatures of variables.
  This property entails that the satisfaction of quantified sentences (and in particular, of clauses and queries) is invariant under change of notation.
  In the case of , this means, for example, that the correctness property of service modules does not depend on the actual orchestration scheme over which the modules are defined.

  \begin{defi}[Model amalgamation]
    A generalized substitution system  has \emph{weak model amalgamation} when for every signature morphism  and every signature of \nb-variables , the diagram depicted below is a weak pullback.
    
  \end{defi}

  \noindent This means that for every model \nb-model  and every \nb-model  such that  there exists a \nb-model  that satisfies  and .

  \begin{prop}
    \label{proposition:weak-model-amalgamation-in-OrcScheme}
    The generalized substitution system  has weak model amalgamation.
  \end{prop}

  \proof
  Let  be a morphism  between orchestration schemes  and  as in Definition~\ref{definition:morphism-of-orchestration-schemes}, and let  be an orchestration of .
  Since orchestrations define substitution systems over the initial room , we can redraw the diagram of interest as follows:
  
  It is easy to see that the above diagram depicts a weak pullback if and only if  is surjective on objects.
  By Theorem~\ref{theorem:osIns}, we know that  for every object  in .
  Therefore, for every  in  we obtain 
  \eta\eta_{\grc}
  \qed

  \begin{rem}
    \label{remark:preservation-of-satisfaction-in-OrcScheme}
    In addition to model amalgamation, it is important to notice that, similarly to , in  the satisfaction of sentences is preserved by model homomorphisms.
    This is an immediate consequence of the fact that, in every orchestration scheme, the morphisms of ground orchestrations preserve properties: given an orchestration , a specification  over , and a homomorphism  between \nb-models  and  as depicted below, if  is a property of  then  is a property of ; therefore,  implies .
    
  \end{rem}


  \subsection{The Clausal Structure of Services}

  Given the above constructions, we can now consider a service-oriented notion of clause, defined over the generalized substitution system  rather than .
  Intuitively, this means that we replace first-order signatures with orchestration schemes, sets of variables with orchestrations, and first-order sentences (over given sets of variables) with specifications.  Furthermore, certain orchestration schemes allow us to identify structures that correspond to finer-grained notions like variable and term: in the case of program expressions, variables and terms have their usual meaning (although we only take into account executable expressions), whereas in the case of \acn{ARN}s, variables and terms materialize as requires-points and sub-\acn{ARN}s defined by provides-points.

  The following notion of service clause corresponds to the concept of service module presented in~\cite{Fiadeiro-Lopes-Bocchi:An-abstract-model-for-service-discovery-and-binding-2011}, and also to the concept of orchestrated interface discussed in~\cite{Fiadeiro-Lopes:An-interface-theory-for-service-oriented-design-2013}.

  \begin{defi}[Service clause]
    A \emph{(definite) service-oriented clause} over a given orchestration scheme  is a structure , also denoted
    
    where  is an orchestration of ,  is a specification over  -- called the \emph{provides-interface} of the clause -- and  is a finite set of specifications over  -- the \emph{requires-interface} of the clause.
  \end{defi}

  The semantics of service-oriented clauses is defined just as the semantics of first-order clauses, except they are evaluated within the generalized substitution system  instead of .
  As mentioned before, this means that we can only distinguish whether or not a clause is correct.

  \begin{defi}[Correct clause]
    A service-oriented clause  is \emph{correct} if for every morphism  such that  is a ground orchestration and  consists only of properties of , the specification  is also a property of .
  \end{defi}

  \noindent In other words, a service clause is correct if the specification given by its provides-interface is ensured by its orchestration and the specifications of its requires-interface.

  \begin{exa}
    \label{example:journey-planner-module}
    We have already encountered several instances of service clauses in the form of the program modules depicted in Figure~\ref{figure:program-modules}.  Their provides- and requires-interfaces are placed on the left- and right-hand side of their orchestrations, and are represented using symbolic forms that are traditionally associated with services.

    To illustrate how service modules can be defined as clauses over \acn{ARN}s, notice that the network  introduced in Example~\ref{example:journey-planner} can orchestrate a module named Journey Planner that consistently delivers the requested directions, provided that the routes and the timetables can be obtained whenever they are needed.
    This can be described in logical terms through the following (correct) service-oriented clause:
    
    where ,  and  correspond to the \nb-sentences
    ,
     and
    , respectively.
  \end{exa}

  Client applications are captured in the present setting by service-oriented queries.
  The way they are defined is similar to that of service clauses, but their semantics is based on an existential quantification, not on a universal one.

  \begin{defi}[Service query]
    A \emph{service-oriented query} over an orchestration scheme  is a structure , also written
    
    such that  is an orchestration of , and  is a finite set of specifications over  that defines the \emph{requires-interface} of the query.
  \end{defi}

  \begin{defi}[Satisfiable query]
    A service-oriented query  is said to be \emph{satisfiable} if there exists a morphism of orchestrations  such that  is ground and all specifications in  are properties of .
  \end{defi}

  \begin{exa}
    \label{example:traveller-application}
    Figure~\ref{figure:client-ARN} outlines the \acn{ARN} of a possible client application for the service module Journey Planner discussed in Example~\ref{example:journey-planner-module}.  We specify the actual application, called Traveller, through the service query
    
    given by the \nb-sentence .

    \begin{figure}[h]
      \centering

      \begin{tikzpicture}


        \node [align=center, minimum height=7ex, minimum width=4em] (T) {
           \\Lambda_{\processname{T}}\pmsgl{getRoute}\dmsgl{route}\portname{T_{1}}\dmsgr{getRoute}\pmsgr{route}\portname{R_{1}}\connectionname{C}\Lambda_{\connectionname{C}}\arnname{Traveller}\pspec{\iota_{1}}{\rho_{1}}{\rho_{1}'}\pspec{\iota_{2}}{\rho_{2}}{\rho_{2}'}\ptm_{1} \colon \pexp_{1}\ptm_{2} \colon \pexp_{2}\pspec{\iota_{2}}{\rho_{2}}{\rho_{2}'}\pspec{\iota_{1}}{\rho_{1}}{\rho_{1}'}
  \xymatrix @C+2em {
    {\ptm_{1} \colon \pexp_{1}}
    \ar [r] ^-{\abr{\psi_{1}, \pi_{1}}}
    & {\ptm \colon \pexp}
    & {\ptm_{2} \colon \pexp_{2}}
    \ar [l] _-{\abr{\psi_{2}, \pi_{2}}}
  }
  \ptm \colon \pexp\pi_{1} \cdot \iota_{1} = \pi_{2} \cdot \iota_{2}\psi_{2}\rbr{\rho_{2}}\psi_{1}\rbr{\rho_{1}}\psi_{2}\rbr{\rho_{2}'}\psi_{1}\rbr{\rho_{1}'}
  \psi_{1}\rbr{\rho_{1}} \models^{\POA} \psi_{2}\rbr{\rho_{2}}
  \qquad \text{and} \qquad
  \psi_{2}\rbr{\rho_{2}'} \models^{\POA} \psi_{1}\rbr{\rho_{1}'}.
  \pspec{\iota_{1}}{\rho_{1}}{\rho_{1}'} \sqsubseteq \pspec{\iota_{2}}{\rho_{2}}{\rho_{2}'}\lsen{x_{1}}{\rho_{1}}\arnet_{1}\lsen{x_{2}}{\rho_{2}}\arnet_{2}\abr{\theta_{1} \colon \arnet_{1} \to \arnet, \theta_{2} \colon \arnet_{2} \to \arnet}\theta_{1}\rbr{x_{1}} = \theta_{2}\rbr{x_{2}}\theta^{\arnpt}_{2, x_{2}}\rbr{\rho_{2}} \models^{\aLTL} \theta^{\arnpt}_{1, x_{1}}\rbr{\rho_{1}}\osp_{1}\osp_{2}\orc_{1}\orc_{2}\abr{\osp_{1}, \osp_{2}}
    \xymatrix {
      {\orc_{1}}
      \ar [r] ^-{\theta_{1}}
      & {\orc}
      & {\orc_{2}}
      \ar [l] _-{\theta_{2}}
    }
    \osp_{1}\osp_{2}\theta_{2}\rbr{\osp_{2}} \models^{\OrcScheme} \theta_{1}\rbr{\osp_{1}}\abr{\theta_{1}, \theta_{2}}\osp_{1}\osp_{2}\delta \colon \orc \to \grc\grc\SSpec\rbr{\theta_{2} \comp \delta}\rbr{\osp_{2}}g\SSpec\rbr{\theta_{1} \comp \delta}\rbr{\osp_{1}}\query{\orc_{1}}{Q_{1}}\dclause{\orc_{2}}{P_{2}}{R_{2}}\query{\orc}{Q}\query{\orc_{1}}{Q_{1}}\dclause{\orc_{2}}{P_{2}}{R_{2}}\theta_{1} \colon \orc_{1} \to \orc
    \xymatrix @H=4ex @R=0ex @C-2em {
      {\mathrlap{\arrquery{\orc_{1}}{
            Q_{1}
          }
        }}
      && {\mathllap{\arrclause{\orc_{2}}{
            P_{2}
          }{
            R_{2}
          }
        }} \\
      & {\arrquery{\orc}{
          \theta_{1}\rbr{Q_{1} \setminus \cbr{\osp_{1}}} \cup \theta_{2}\rbr{R_{2}}
        }}
      \ar @{-} [ul]!DL-<1ex,0ex>;[ur]!DR+<1ex,0ex> |>/1em/*[r]{\theta_{1}}
    }
    \theta_{1}\abr{\theta_{1}, \theta_{2}}\osp_{1} \in Q_{1}P_{2}Q\theta_{1}\theta_{2}Q_{1} \setminus \cbr{\osp_{1}}R_{2}\lsen{\portname{R_{1}}}{\rho^{\arnname{T}}_{1}}\lsen{\portname{JP_{1}}}{\rho^{\arnname{JP}}}\abr{\theta_{1}, \theta_{2}}
    \xymatrix {
      {\arnname{Traveller}}
      \ar [r] ^-{\theta_{1}} 
      & {\arnname{JourneyPlannerApp}}
      & {\arnname{JourneyPlanner}}
      \ar [l] _-{\theta_{2}}
    }
    \arnname{JourneyPlannerApp}\theta_{1}\portname{R_{1}}\portname{JP_{1}}\connectionname{C}\connectionname{CJP}\msgname{getRoute}\msgname{route}M_{\portname{R_{1}}}\msgname{planJourney}\msgname{directions}\arnname{Traveller}\theta_{2}\arnname{JourneyPanner}\arnname{JourneyPlannerApp}\processname{T}1ex]
          
        };
        
        \node [port] (T1) [right=0em of T, align=left] {
           \\
          
        };
        \node [port-label] [above=.5ex of T1] {};



        \node [port] (JP1) [right=3em of T1, align=right] {
           \\
          
        };
        \node [port-label] [above=.5ex of JP1] {};

        \node [align=center, minimum height=9ex, minimum width=4em] (JP) [right=0em of JP1] {
           \\Lambda_{\processname{JP}}\pmsgl{getRoutes}\dmsgl{routes}\dmsgl{timetables}\portname{JP_{2}}\dmsgr{getRoutes}\pmsgr{routes}\portname{R_{1}}\dmsgr{routes}\pmsgr{timetables}\portname{R_{2}}\connectionname{CJP}\Lambda_{\connectionname{CJP}}\connectionname{C}1ex]
          
        } (JP2 -| R1.west);

        \begin{pgfonlayer}{background}       
          \node [process] [fit=(T)] {};
          \node [process] [fit=(JP)] {};
        \end{pgfonlayer}
      \end{tikzpicture}
      
      \caption{The \acn{ARN} }
      \label{figure:journey-planner-app-ARN}
    \end{figure}

    \noindent It follows that we can derive by resolution a new service query defined by the network  and the requires-specifications  and .

    
  \end{exa}

  \begin{minisection}{The logic-programming framework of services.}The crucial property of the above notions of service clause, query, and resolution is that, together with the generalized substitution system  used to define them, they give rise to a logic-programming framework~\cite{Tutu-Fiadeiro:Institution-independent-logic-programming-2015}.
    The construction is to a great extent self-evident, and it requires little additional consideration apart from the fact that, from a technical point of view, in order to define clauses and queries as quantified sentences, we need to extend  by closing the sets of sentences that it defines under propositional connectives such as implication and conjunction.
    It should be noted, however, that the properties that guarantee the well-definedness of the resulting logic-programming framework such as the fact that its underlying generalized substitution system has weak model amalgamation (ensured by Proposition~\ref{proposition:weak-model-amalgamation-in-OrcScheme}), and also the fact that the satisfaction of specifications is preserved by model homomorphisms (detailed in Remark~\ref{remark:preservation-of-satisfaction-in-OrcScheme}), are far from trivial, especially when taking into account particular orchestration schemes (see e.g.\ Proposition~\ref{orchestration-scheme-of-ARNs}).
\end{minisection}

  By describing service discovery and binding as instances of unification and resolution (specific to the logic-programming framework of services) we obtain not only a rigorously defined analogy between service-oriented computing and relational logic programming, but also a way to apply the general theory of logic programming to the particular case of services.
  For example, we gain a concept of solution to a service query that reflects the rather intuitive service-oriented notion of solution and, moreover, through Herbrand's theorem, a characterization of satisfiable queries as queries that admit solutions.

  \begin{defi}[Solution]
    A \emph{solution}, or \emph{correct answer}, to a service-oriented query  consists of a morphism of orchestrations  such that  has models, and every one of them satisfies the \nb-translations of the specifications in .
  \end{defi}

  \begin{prop}
    \label{proposition:characterization-of-satisfiable-service-queries}
    A service query is satisfiable if and only if it admits a solution.
    \qed
  \end{prop}

  Even more significant is the fact that logic programming provides us with a general search procedure that can be used to compute solutions to queries.
  The search is triggered by a query  and consists in the iterated application of resolution, that is of service discovery and binding, until the requires-interface of the derived service query consists solely of trivial specifications (tautologies); these are specifications whose translation along morphisms into ground orchestrations always gives rise to properties.
  Thus, whenever the search procedure successfully terminates we obtain a \emph{computed answer} to the original query by sequentially composing the resulting computed morphisms.
  This is the process that led, for example, to the derivation of the program that calculates the quotient and the remainder obtained on dividing two natural numbers illustrated in Figure~\ref{figure:program-derivation}.
  The computed answer is given in this case by the sequence of substitutions
  1ex]
         & {\begin{array}{rl}
              {} \mapsto \rbr{q \coloneqq 0 \comp r \coloneqq x} \comp {} & \opname{while}\, y \leq r\, \opname{do} \\
                                                                          & \hspace{1em} q \coloneqq q + 1 \comp r \coloneqq r - y \\
                                                                          & \opname{done}.
            \end{array}}
  \end{array}
  \processname{MS}\processname{TS}\processname{T}1ex]
        
      };
      
      \node [port] (T1) [right=0em of T, align=left] {
         \\
        
      };
      \node [port-label] [above=.5ex of T1] {};



      \node [port] (TR1) [right=3em of T1, align=right] {
         \\
        
      };
      \node [port-label] [above=.5ex of TR1] {};



      \draw [rounded corners]
      ()
      to ()
      to ()
      to ()
      to ()
      to ();
      
      \path (T1) -- node [connection] {
         \\
        
      } (T1 -| TR1.west);
      


      \node (Tapp-orc) [fit=(T) (T1) (TR1), inner sep=1.05em] {};



      \node [requires-point] (Tapp-rspec) [right=.5em of TR1.east] {};

      \coordinate (Tapp-north) at ();
      \coordinate (Tapp-south) at ();
      \coordinate (Tapp-west)  at ();
      \coordinate (Tapp-east)  at ();

      \node (Tapp-rspecr) [right=0em of Tapp-rspec] {\hspace{.6em}\reflectbox{}};
      
      




      \node [provides-point] (JPmod-pspec) [below=25ex of Tapp-orc.south west, anchor=north west] {\hspace{.25em}};
      \draw [dotted, thick] (Tapp-rspecr)
      -- ()
      -- ()
      -| ()
      -- ()
      -- (JPmod-pspec.west);

      


      \node [port] (JP1) [right=.25em of JPmod-pspec, align=right] {
         \\
        
      };
      \node [port-label] [above=0ex of JP1] {};

      \node [align=center, minimum height=9ex, minimum width=4em] (JP) [right=0em of JP1] {
         \\Lambda_{\processname{JP}}\pmsgl{getRoutes}\dmsgl{routes}\dmsgl{timetables}\portname{JP_{2}}\dmsgr{getRoutes}\pmsgr{routes}\portname{R_{1}}\dmsgr{routes}\pmsgr{timetables}\portname{R_{2}}\connectionname{C}1ex]
        
      } (JP2 -| JPR1.west);



      \node (JPmod-orc) [fit=(JP) (JP1) (JP2) (JPR1) (JPR2), inner sep=1.5em] {};
      


      \node [requires-point] (JPmod-rspec1) [right=.5em of JPR1.east] {};
      \node [requires-point] (JPmod-rspec2) [right=.5em of JPR2.east] {};

      \coordinate (JPmod-north) at ();
      \coordinate (JPmod-south) at ();
      \coordinate (JPmod-west)  at ();
      \coordinate (JPmod-east)  at ();






      \node [provides-point] (MSmod-pspec) [right=2em of JPmod-rspec1.east] {\hspace{.25em}};
      \path (JPmod-rspec1) -- node {\hspace{.5em}\reflectbox{}} (MSmod-pspec);
      


      \node [port] (MS1) [right=.25em of MSmod-pspec, align=right] {
         \\
        
      };
      \node [port-label] [above=0ex of MS1] {};

      \node [align=center, minimum height=7ex, minimum width=4em] (MS) [right=0em of MS1] {
         \\Lambda_{\processname{MS}}\lsen{\portname{TS_{1}}}{\rho^{\arnname{TS}}}\models\dmsgr{routes}\pmsgr{timetables}\portname{TS_{1}}\processname{TS}1ex]
        
      };



      \node (TSmod-orc) [fit=(TS) (TS1), inner sep=1.05em] {};

      \coordinate (TSmod-north) at ();
      \coordinate (TSmod-south) at ();
      \coordinate (TSmod-west)  at ();
      \coordinate (TSmod-east)  at ();


      \begin{pgfonlayer}{background}
        \node [orchestration] (Tapp-border) [fit=(Tapp-orc) (Tapp-north) (Tapp-south) (Tapp-west) (Tapp-east)] {};
        \node [below=1ex of Tapp-border.south] {Traveller};
        \node [process] [fit=(T)] {};
        \node [orchestration] (JPmod-border) [fit=(JPmod-orc) (JPmod-north) (JPmod-south) (JPmod-west) (JPmod-east)] {};
        \node [below=1ex of JPmod-border.south] {Journey Planner};
        \node [process] [fit=(JP)] {};
        \node [orchestration] (MSmod-border) [fit=(MSmod-orc) (MSmod-north) (MSmod-south) (MSmod-west) (MSmod-east)] {};
        \node [below=1ex of MSmod-border.south] {Map Services};
        \node [process] [fit=(MS)] {};
        \node [orchestration] (TSmod-border) [fit=(TSmod-orc) (TSmod-north) (TSmod-south) (TSmod-west) (TSmod-east)] {};
        \node [below=1ex of TSmod-border.south] {Transport System};
        \node [process] [fit=(TS)] {};
      \end{pgfonlayer}
    \end{tikzpicture}
    
    \caption{The derivation of an answer to the Traveller application}
    \label{figure:service-oriented-derivation}

    
  \end{sidewaysfigure}

  The soundness of resolution, detailed in Proposition~\ref{proposition:soundness-of-service-oriented-resolution} below, entails that the search for solutions is sound as well, in the sense that every computed answer to  is also a solution to .  This fundamental result, originally discussed in~\cite{Tutu-Fiadeiro:Institution-independent-logic-programming-2015} in the context of abstract logic programming, ensures, in combination with Proposition~\ref{proposition:characterization-of-satisfiable-service-queries}, that the operational semantics of the service overlay given by discovery and binding is sound with respect to the notion of satisfiability of a service query.

  \begin{prop}
    \label{proposition:soundness-of-service-oriented-resolution}
    Let  be a service query derived by resolution from  and  using the computed morphism .
    If  is correct then, for any solution  to , the composed morphism  is a solution to .
    \qed
  \end{prop}


  \section{Conclusions}

  We have shown how the integration of the declarative and the operational semantics of conventional logic programming can be generalized to service-oriented computing, thus offering a unified semantics for the static and the dynamic aspects of this paradigm.  That is, we have provided, for the first time, an algebraic framework that accounts for the mechanisms through which service interfaces can be orchestrated, as well as for those mechanisms that allow applications to discover and bind to services.

  The analogy that we have established is summarized in Table~\ref{table:correspondence-between-relational-and-service-oriented-logic-programming}.
  Our approach to the logic-programming semantics of services is based on the identification of the binding of terms to variables in logic programming with the binding of orchestrations of services to those of software applications in service-oriented computing; the answer to a service query -- the request for external services -- is obtained through resolution using service clauses -- orchestrated service interfaces -- that are available from a repository.
  This departs from other works on the logic-programming semantics of service-oriented computing such as~\cite{Kona-Bansal-Gupta:Automatic-composition-of-semantic-Web-services-2007} that actually considered implementations of the service discovery and binding mechanisms based on constraint logic programming.

  \begin{sidewaystable}
    \centering
    \caption{Correspondence between concepts of relational and service-oriented logic programming}
    \label{table:correspondence-between-relational-and-service-oriented-logic-programming}

    \vskip \abovecaptionskip

    \renewcommand{\arraystretch}{1.4}
    \overfullrule=0 pt
    \begin{tabular}{@{}
      >{\raggedright}p{.11\textwidth}
      >{\centering\arraybackslash}p{.23\textwidth}
      >{\centering\arraybackslash}p{.28\textwidth}
      >{\centering\arraybackslash}p{.33\textwidth}
      @{}}
      \toprule
      & Relational logic programming
      & \multicolumn{2}{c}{Service-oriented logic programming}
      \\
      \cmidrule(lr){2-2} \cmidrule(l){3-4}
      Concept
      & over a signature 
      & over program expressions
      & over asynchronous relational networks
      \\
      \midrule
      Variable
      & pair 
      & program variable 
      & requires-point 
      \\
      Term
      & structure 
      & program statement

        \vskip .5\baselineskip
        
        \begin{tikzpicture}
          \node        (while)                                                                  {};
          \node [pvar] (pgm)   [below right=0ex and 1em of while.south west, anchor=north west] {};
          \node        (done)  [below left=0ex and 1em of pgm.south west, anchor=north west]    {};
        \end{tikzpicture}
      & subnetwork determined by a point
        
        \vskip .5\baselineskip
        
        \begin{tikzpicture}


          \node [port] (MS1) [align=right] {
             \\
            
          };
          \node [port-label] [above=0ex of MS1] {};

          \node [align=center, minimum height=7ex, minimum width=4em] (MS) [right=0em of MS1] {
             \\Lambda_{\processname{MS}}\arrclause{X}{C}{H}\comp\bullet\bullet\rho, \rho''\rho, \rho'\rho', \rho''\bullet\processname{JP}\bullet\bullet\bullet\connectionname{C}\lsen{\portname{JP_{1}}}{\rho^{\arnname{JP}}}\lsen{\portname{R_{1}}}{\rho^{\arnname{JP}}_{1}}\lsen{\portname{R_{2}}}{\rho^{\arnname{JP}}_{2}}\arrquery{X}{Q}\bullet\rho, \rho'\processname{T}\bullet\bullet\connectionname{C}\lsen{\portname{R_{1}}}{\rho^{\arnname{T}}_{1}}\aLTL, we obtain sentences as linear-temporal-logic sentences expressing properties observed at given interaction points of a network, and models in the form of ground orchestrations of Muller automata.  Other logics (with corresponding model theory) could have been used instead of the automata-based variant of linear temporal logic, more specifically any institution such that
  \begin{inlinenum}

  \item the category of signatures is (finitely) cocomplete;

  \item there exist cofree models along every signature morphism;

  \item the category of models of every signature has (finite) products; and

  \item model homomorphisms reflect the satisfaction of sentences.

  \end{inlinenum}
  Moreover, the formalism used in defining orchestrations can change by means of morphisms of orchestration schemes.  We could consider, for instance, an encoding of the hypergraphs of processes and connections discussed in this paper into graph-based structures similar to those of~\cite{Fiadeiro-Lopes:Dynamic-reconfiguration-in-service-oriented-architectures-2013}; or we could change their underlying institution by adding new temporal modalities (along the lines of Example~\ref{example:morphisms-of-orchestration-schemes-of-ARNs}) or by considering other classes of automata, like the closed reduced B\"{u}chi automata used in~\cite{Alpern-Schneider:Recognizing-safety-and-liveness-1987,Fiadeiro-Lopes:An-interface-theory-for-service-oriented-design-2013}.
  This encourages us to further investigate aspects related to the heterogeneous foundations of service-oriented computing based on the proposed logical system of orchestration schemes.


  \section*{Acknowledgements}

  The work of the first author has been supported by a grant of the Romanian National Authority for Scientific Research, CNCS-UEFISCDI, project number PN-II-ID-PCE-2011-3-0439.
  The authors also wish to thank Fernando Orejas for suggesting the use of hypergraphs, Ant\'{o}nia Lopes for many useful discussions that led to the present form of this paper, and the anonymous referees for their careful study of the original manuscript.


  \bibliographystyle{alpha}
  \bibliography{references}
\vspace{-30 pt}
\end{document}
