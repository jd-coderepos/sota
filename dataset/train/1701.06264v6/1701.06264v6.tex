\documentclass[11pt,fullpage, letterpaper,twoside]{article}
\usepackage{helvet}
\usepackage{epsfig} \usepackage{subfigure}
\usepackage{cite}




\let\proof\relax
\let\endproof\relax




\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amssymb}

\usepackage{dsfont}

\usepackage{multirow}
\usepackage{booktabs}
\usepackage{hhline}
\usepackage{multirow}
\usepackage{url}
\usepackage[margin=1in]{geometry}

\newcommand{\theHalgorithm}{\arabic{algorithm}}
\newtheorem{theorem}{Theorem}
\newtheorem{lemma}{Lemma}
\newtheorem{assumption}{Assumption}
\newtheorem{corollary}{Corollary}
\newtheorem{remark}{Remark}
\newcommand{\1}[1]{\mathds{1}_{\left[#1\right]}}

\usepackage{CJK}
\usepackage{indentfirst}
\usepackage[colorlinks,linkcolor=red,anchorcolor=blue,citecolor=green]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}
\fancyhf{}
\fancyhead[LO]{Loss-Sensitive Generative Adversarial Networks on Lipschitz Densities}
\fancyhead[RE]{G.-J. Qi}
\fancyfoot[C]{\thepage}
\renewcommand{\headrulewidth}{0.6pt}
\begin{document}

\title{Loss-Sensitive Generative Adversarial Networks on Lipschitz Densities}




\author{Guo-Jun Qi \\
Laboratory for {\bf MA}chine {\bf P}erception and {\bf LE}arning \\
\url{http://maple.cs.ucf.edu}\\
University of Central Florida\\
\tt\small guojun.qi@ucf.edu          }





\date{}

\maketitle

\begin{abstract}

In this paper, we present the Lipschitz regularization theory and algorithms for a novel Loss-Sensitive Generative Adversarial Network (LS-GAN). Specifically, it trains a loss function to distinguish between real and fake samples by designated margins, while learning a generator alternately to produce realistic samples by minimizing their losses.
The LS-GAN further regularizes its loss function with a Lipschitz regularity condition on the density of real data, yielding a regularized model that can better generalize to produce new data from a reasonable number of training examples than the classic GAN.
We will further present a Generalized LS-GAN (GLS-GAN) and show it contains a large family of regularized GAN models, including both LS-GAN and Wasserstein GAN, as its special cases.  Compared with the other GAN models, we will conduct experiments to show both LS-GAN and GLS-GAN exhibit competitive ability in generating new images in terms of the Minimum Reconstruction Error (MRE) assessed on a separate test set.
We further extend the LS-GAN to a conditional form for supervised and semi-supervised learning problems, and demonstrate its outstanding performance on image classification tasks.\\
{\noindent {\bf Keywords}: Generative Adversarial Nets (GANs), Lipschitz regularity, Minimum Reconstruction Error (MRE)}

\end{abstract}





\maketitle








\section{Introduction}

A classic Generative Adversarial Net (GAN) \cite{goodfellow2014generative} learns a discriminator and a generator by playing a two-player minimax game to generate samples from a data distribution. The discriminator is trained to distinguish real samples from those generated by the generator, and it in turn guides the generator to produce realistic samples that can fool the discriminator.






However, from both theoretical and practical perspectives, a critical question is {\em whether the GAN can generate realistic samples from arbitrary data distribution without any prior? If not, what kind of prior ought to be imposed on the data distribution to regularize the GAN?} Indeed,
the classic GAN \cite{goodfellow2014generative} imposes no prior on the data distribution.  This represents an ambitious goal to
generate samples from any distributions. However, it in turn requires a non-parametric discriminator to prove the distributional consistency between generated and real samples by assuming the model has infinite capacity (see Section 4 of \cite{goodfellow2014generative}).

This is a too strong assumption to establish the theoretical basis for the GAN. Moreover, with such an assumption, its generalizability becomes susceptible.
Specifically, one could argue the learned generator may be overfit by an unregularized discriminator in an non-parametric fashion by merely memorizing or interpolating training examples. In other words, it could lack the generalization ability to generate new samples out of existing data. Indeed, Arora et al. \cite{arora2017generalization} have shown that the GAN minimizing the Jensen-Shannon distance between the distributions of generated and real data could fail to generalize to produce new samples with a reasonable size of training set.
Thus, a properly regularized GAN is demanded to establish provable generalizability by focusing on a restricted yet still sufficiently large family of data distributions.

\subsection{Objective: Towards Regularized GANs}
In this paper, we attempt to develop regularization theory and algorithms for a novel Loss-Sensitive GAN (LS-GAN).
Specifically, we introduce a loss function to quantify the quality of generated samples. A constraint is imposed so that the loss of a real sample should be smaller than that of a generated counterpart. Specifically, in the learning algorithm, we will define margins to separate the losses between generated and real samples. Then, an optimal generator will be trained to produce realistic samples with minimum losses. The loss function and the generator will be trained in an adversarial fashion until generated samples become indistinguishable from real ones.


We will also develop new theory to analyze the LS-GAN on the basis of Lipschitz regularity.  We note that the reason of making non-parametric assumption of infinite capacity on the discriminator in the classic GAN is due to its ambitious goal to generate data from any arbitrary distribution.  However,
no free lunch \cite{wolpert1996lack} principle reminds us of the need to impose a suitable prior on the data distribution from which real samples are generated.  This inspires us to impose a
Lipschitz regularity condition by assuming the data density does not change abruptly.
Based on this mild condition, we will show that the density of generated samples by LS-GAN can exactly match that of real data.

More importantly, the Lipschitz regularity allows us to prove the LS-GAN can well generalize to produce new data from training examples.
To this end, we will provide a Probably Approximate Correct (PAC)-style theorem by showing the empirical LS-GAN model trained with a reasonable number of examples can be sufficiently close to the oracle LS-GAN trained with hypothetically known data distribution, thereby proving the generalizability of LS-GAN in generating samples from any Lipschitz data distribution.

We will also make a non-parametric analysis of the LS-GAN. It does not rely on any parametric form of the loss function to characterize its optimality in the space of Lipschtiz functions. It gives both the upper and lower bounds of the optimal loss, which are cone-shaped with non-vanishing gradient. This suggests that the LS-GAN can provide sufficient gradient to update its LS-GAN generator even if the loss function has been fully optimized, thus avoiding the vanishing gradient problem that could occur in training the GAN \cite{arjovsky2017towards}.


\subsection{Extensions: Generalized and Conditional LS-GANs}

We further present a generalized form of LS-GAN (GLS-GAN) and conduct experiment to demonstrate it has the best generalization ability. We will show this is not a surprising result as the GLS-GAN contains a large family of regularized GANs with both LS-GAN and Wasserstein GAN (WGAN) \cite{wgan17} as its special cases.
Moreover, we will extend a Conditional LS-GAN (CLS-GAN) that can generate samples from given conditions.  In particular, with class labels being conditions, the learned loss function can be used as a classifier for both supervised and semi-supervised learning.  The advantage of such a classifier arises from its ability of exploring generated examples to uncover intrinsic variations for different classes. Experiment results demonstrate competitive performance of the CLS-GAN classifier compared with the state-of-the-art models.




\vspace{-2mm}
\subsection{Paper Structure}
The remainder of this paper is organized as follows. Section~\ref{sec:related} reviews the related work, and the proposed LS-GAN is presented in Section~\ref{sec:lsgan}.  In Section~\ref{sec:theory}, we will analyze the LS-GAN by proving the distributional consistency between generated and real data with the Lipschitz regularity condition on the data distribution. In Section~\ref{sec:alg}, we will discuss the generalizability problem arising from using sample means to approximate the expectations in the training objectives. We will make a comparison with Wasserstein GAN (WGAN) in Section~\ref{sec:wgan}, and present a generalized LS-GAN with both WGAN and LS-GAN as its special cases in Section~\ref{sec:glsgan}. A non-parametric analysis of the algorithm is followed in Section~\ref{sec:nonparam}.
Then we will show how the model can be extended to a conditional model for both supervised and semi-supervised learning in Section~\ref{sec:clsgan}. Experiment results are presented in Section~\ref{sec:exp}, and we conclude in Section~\ref{sec:concl}.

\noindent{\bf Source codes.} The source codes for both LS-GAN and GLS-GAN are available at \url{https://github.com/maple-research-lab}, in the frameworks of torch, pytorch and tensorflow. LS-GAN is also supported by Microsoft CNTK at \url{https://www.cntk.ai/pythondocs/CNTK_206C_WGAN_LSGAN.html}.







\section{Related Work}\label{sec:related}


Deep generative models, especially the Generative Adversarial Net (GAN) \cite{goodfellow2014generative}, have attracted many attentions recently due to their demonstrated abilities of generating real samples following the underlying data densities.  In particular, the GAN attempts to learn a pair of discriminator and generator by playing a maximin game to seek an equilibrium, in which the discriminator is trained by distinguishing real samples from generated ones and the generator is optimized to produce samples that can fool the discriminator.

A family of GAN architectures have been proposed to implement this idea.  For example, recent progresses \cite{radford2015unsupervised,salimans2016improved} have shown impressive performances on synthesizing photo-realistic images by constructing multiple strided and factional-strided convolutional layers for discriminators and generators.  On the contrary, \cite{denton2015deep} proposed to use a Laplacian pyramid to produce high-quality images by iteratively adding multiple layers of noises at different resolutions. \cite{im2016generating} presented to train a recurrent generative model by using adversarial training to unroll gradient-based optimizations to create high quality images.

In addition to designing different GAN networks, research efforts have been made to train the GAN by different criteria. For example,
\cite{zhao2016energy} presented an energy-based GAN by minimizing an energy function to learn an optimal discriminator, and an auto-encoder structured discriminator is presented to compute the energy.  The authors also present a theoretical analysis by showing this variant of GAN can generate samples whose density can recover the underlying true data density.  However, it still needs to assume the discriminator has infinite modeling capacity to prove the result in a non-parametric fashion, and its generalizability of producing new data out of training examples is unknown without theoretical proof or empirical evidence.
In addition, \cite{nowozin2016f} presented to analyze the GAN from information theoretical perspective, and they seek to minimize the variational estimate of f-divergence, and show that the classic GAN is included as a special case of f-GAN. In contrast, InfoGAN \cite{chen2016infogan} proposed another information-theoretic GAN to learn disentangled representations capturing various latent concepts and factors in generating samples. Most recently, \cite{wgan17} propose to minimize the Earth-Mover distance between the density of generated samples and the true data density, and they show the resultant Wasserstein GAN (WGAN) can address the vanishing gradient problem that the classic GAN suffers.

Besides the class of GANs, there exist other models that also attempt to generate natural images. For example, \cite{gatys2015neural} rendered images by matching features in a convolutional network with respect to reference images.  \cite{dosovitskiy2015learning} used deconvolutional network to render 3D chair models in various styles and viewpoints.  \cite{gregor2015draw} introduced a deep recurrent neutral network architecture for image generation with a sequence of variational auto-encoders to iteratively construct complex images.


Recent efforts have also been made on leveraging the learned representations by deep generative networks to improve the classification accuracy when it is too difficult or expensive to label sufficient training examples.  For example, \cite{kingma2014semi} presented variational auto-encoders \cite{kingma2013auto} by combining deep generative models and approximate variational inference to explore both labeled and unlabeled data.
\cite{salimans2016improved} treated the samples from the GAN generator as a new class, and explore unlabeled examples by assigning them to a class different from the new one. \cite{rasmus2015semi} proposed to train a ladder network \cite{valpola2015neural} by minimizing the sum of supervised and unsupervised cost functions through back-propagation, which avoids the conventional layer-wise pre-training approach. \cite{springenberg2015unsupervised} presented an approach to learning a discriminative classifier by trading-off mutual information between observed examples and their predicted classes against an adversarial generative model. \cite{dumoulin2016adversarially} sought to jointly distinguish between not only real and generated samples but also their latent variables in an adversarial process. Recently, \cite{qi2017global} presented a novel paradigm of localized GANs to explore the local consistency of classifiers in local coordinate charts, as well as showed an intrinsic connection with Laplace-Beltrami operator along the manifold. These methods have shown promising results for classification tasks by leveraging deep generative models.





\section{Loss-Sensitive GAN}\label{sec:lsgan}
The classic GAN consists of two players -- a generator producing samples from random noises,
and a discriminator distinguishing real and fake samples. The generator and discriminator are trained in an adversarial fashion to reach an equilibrium in which generated samples become indistinguishable from their real counterparts.



On the contrary, in the LS-GAN we seek to learn a {\em loss function}  parameterized with  by assuming that a real example ought to have a smaller loss than a generated sample by a desired margin. Then the generator
can be trained to generate realistic samples by minimizing their losses.

Formally, consider a generator function  that produces a sample   by transforming a noise input  drawn from a simple distribution  such as uniform and Gaussian distributions.
Then for
a real example  and a generated sample , the loss function can be trained to distinguish them with the following constraint:

where  is the margin measuring the difference between  and . This constraint requires a real sample be separated from a generated counterpart in terms of their losses by at least a margin of .

The above hard constraint can be relaxed by introducing a nonnegative slack variable 
that quantifies the violation of the above constraint. This results in the following minimization problem to learn the loss function  given a fixed generator ,

where  is a positive balancing parameter, and  is the data distribution of real samples.  The first term minimizes the expected loss function over data distribution since a smaller loss is preferred on real samples. The second term is the expected error caused by the violation of the constraint. Without loss of generality, we require the loss function should be nonnegative.






Given a fixed loss function , on the other hand, one can solve the following minimization problem to find an optimal generator .


We can use  and  to denote the density of samples generated by  and  respectively, with  being drawn from . However, for the simplicity of notations, we will use  and  to denote  and  without explicitly mentioning  and  that should be clear in the context.










Finally, let us summarize the above objectives. The LS-GAN optimizes  and  alternately by seeking an equilibrium  such that  minimizes

which is an equivalent form of (\ref{eq:loss}) with , and  minimizes

In the next section, we will show the consistency between  and  for LS-GAN.








\section{Theoretical Analysis: Distributional Consistency}\label{sec:theory}

Suppose  is a Nash equilibrium that jointly solves  (\ref{eq:theta}) and (\ref{eq:phi}).  We will show that as , the density distribution  of the samples generated by  will converge to the real data density .



First, we have the following definition.

{\noindent {\bf Definition.} \em For any two samples  and , the loss function  is Lipschitz continuous with respect to a distance metric  if

with a bounded Lipschitz constant , i.e, .
}



To prove our main result, we assume the following regularity condition on the data density. \begin{assumption}\label{asp}
The data density  is supported in a compact set , and it is Lipschitz continuous wrt  with a bounded constant .
\end{assumption}



The set of Lipschitz densities with a compact support contain a large family of distributions that are dense in the space of continuous densities.
For example, the density of natural images are defined over a compact set of pixel values, and it can be consider as Lipschitz continuous, since the densities of two similar images are unlikely to change abruptly at an unbounded rate. If real samples are distributed on a manifold (or  is supported in a manifold), we only require the Lipschitz condition hold on this manifold.  This makes the Lipschitz regularity applicable to the data densities on a thin manifold embedded in the ambient space.


Let us show the existence of Nash equilibrium
such that both the loss function  and the density  of generated samples are Lipschitz. Let  be the class of functions over  with a bounded yet sufficiently large Lipschitz constant  such that  belongs to .
It is not difficult to show that the space  is convex and compact
if its member functions are supported in a compact set.
In addition, we note both  and  are convex in  and in .
Then, according to the Sion's theorem \cite{sion1958general}, with  and  being optimized over , there exists a Nash equilibrium .  Thus, we have the following lemma.





\begin{lemma}\label{lem2}
Under Assumption~\ref{asp}, there exists a Nash equilibrium  such that both  and  are Lipschitz.
\end{lemma}



Now we can prove the main lemma of this paper. The Lipschitz regularity relaxes the strong non-parametric assumption on the GAN's discriminator with infinite capacity to the above weaker Lipschitz assumption for the LS-GAN. This allows us to show the following lemma that establishes the distributional consistency between the optimal  by Problem~(\ref{eq:theta})--(\ref{eq:phi}) and the data density .











\begin{lemma}\label{lem1}
{Under Assumption~\ref{asp}, for a Nash equilibrium  in Lemma~\ref{lem2}, we have

Thus,  converges to  as .}
\end{lemma}
The proof of this lemma is given in Appendix~\ref{proof_a}.
\begin{remark}
By letting  go infinitely large, the density  of generated samples should exactly match the real data density .  Equivalently, we can simply disregard the first loss minimization term in (\ref{eq:theta}) as it plays no role as .
\end{remark}






Putting the above two lemmas together, we have the following theorem.
\begin{theorem}\label{thm3}
Under Assumption~\ref{asp}, a Nash equilibrium  exists such that\\
(i)  and  are Lipschitz.\\
(ii) , as .\\
\end{theorem}















\section{Learning and Generalizability}\label{sec:alg}
The minimization problems (\ref{eq:theta}) and (\ref{eq:phi}) cannot be solved directly since the expectations over the distributions of true data  and noises  are unavailable or intractable.  Instead, one can approximate them with empirical means on a set of finite real examples  and noise vectors  drawn from  and  respectively.

This results in the following two alternative problems.

and

where the random vectors  used in (\ref{eq:phi1}) can be different from  used in (\ref{eq:theta1}).

The sample mean in the second term of Eq.~(\ref{eq:theta1}) is computed over pairs  randomly drawn from real and generated samples, which is an approximation to the second expectation term in Eq.~(\ref{eq:theta}).










\subsection{Generalizability}\label{sec:gen}

We have proved the density of generated samples by the LS-GAN is consistent with the real data density in Theorem~\ref{thm3}. This consistency is established based on the two oracle objectives (\ref{eq:theta}) and (\ref{eq:phi}).  However, in practice, the population expectations in these two objectives cannot be computed directly over  and . Instead, they are approximated in (\ref{eq:theta1}) and (\ref{eq:phi1}) by sample means on a finite set of real and generated examples.

This raises the question about the generalizability of the LS-GAN model.  We wonder, with more training examples, if the empirical model trained with finitely many examples can generalize to the oracle model. In particular, we wish to estimate the sample complexity of how many examples are required to sufficiently bound the generalization difference between the empirical and oracle objectives.



Arora et al. \cite{arora2017generalization} has proposed a neural network distance to analyze the generalization ability for the GAN. However, this neural network distance cannot be directly applied here, as it is not related with the objectives that are used to train the LS-GAN. So the generalization ability in terms of the neural network distance does not imply the LS-GAN could also generalize. Thus, a direct generalization analysis of the LS-GAN is required based on its own objectives.

First, let us consider the generalization in terms of .
This objective is used to train the loss function  to distinguish between real and generated samples.
Consider the oracle objective  (\ref{eq:theta}) with the population expectations

and the empirical objective (\ref{eq:theta1}) with the sample means



We need to show if and how fast the difference  would eventually vanish as the number  of training examples grows.


To this end, we need to define the following notations about the model complexity.
\begin{assumption}\label{asp:loss}
We assume that for LS-GAN,
\begin{itemize}
\item[I.] the loss function  is -Lipschitz in its parameter , i.e.,  for any ;
\item[II.]  is -Lipschitz in , i.e.,  for any ;
\item[III.] the distance between two samples is bounded, i.e., .
\end{itemize}
\end{assumption}

Then we can prove the following generalization theorem in a Probably Approximately Correct (PAC) style.
\begin{theorem}\label{thm:generalization}
Under Assumption~\ref{asp:loss}, with at least probability , we have

when the number of samples

where  is a sufficiently large constant, and  is the number of parameters of the loss function such that .
\end{theorem}
The proof of this theorem is given in Appendix~\ref{sec:gen_proof}. This theorem shows the sample complexity to bound the difference between  and  is polynomial in the model size , as well as both Lipschitz constants  and .




Similarly, we can establish the generalizability to train the generator function by considering the empirical objective

and the oracle objective

over empirical and real distributions, respectively.

We use the following notions to characterize the complexity of the generator.
\begin{assumption}\label{asp:generator}
We assume that
\begin{itemize}
\item[I.] The generator function  is -Lipschitz in its parameter , i.e.,  for any ;
\item[II.] Also, we have  is -Lipschitz in , i.e., ;
\item[III.] The samples 's drawn from  are bounded, i.e., .
\end{itemize}
\end{assumption}

Then we can prove the following theorem to establish the generalizability of the generator in terms of .
\begin{theorem}Under Assumption~\ref{asp:generator}, with at least probability , we have

when the number of samples

where  is a sufficiently large constant, and  is the number of parameters of the generator function such that .
\end{theorem}

\subsection{Bounded Lipschitz Constants for Regularization}

Our generalization theory  in Theorem~\ref{thm:generalization} conjectures that the required number of training examples is lower bounded by a polynomial of Lipschitz constants  and  of the loss function wrt  and . This suggests us to bound both constants to reduce the sample complexity of the LS-GAN to improve its generalization performance.



Specifically, bounding the Lipschitz constants  and  can be implemented by adding two gradient penalties (I)  and (II) 
to the objective (\ref{eq:theta}) as the surrogate of the Lipschitz constants. For simplicity, we  ignore the second gradient penalty (II) for  in experiments, as the sample complexity is only log-linear in it, whose impact on generalization performance is negligible compared with that of . Otherwise, penalizing (II) needs to compute its gradient wrt , which is  with a Hessian matrix , and this is usually computationally demanding.

Note that the above gradient penalty differs from that used in \cite{gulrajani2017improved} that aims to constrain the Lipschitz constant  close to one as in the definition of the Wasserstein distance \cite{wgan17}. However, we are motivated to have lower sample complexity by directly minimizing the Lipschitz constant rather than constraining it to one.  Two gradient penalty approaches are thus derived from different theoretical perspectives, and also make practical differences in experiments.




\section{Wasserstein GAN and Generalized LS-GAN}
In this section, we discuss two issues about LS-GAN.  First, we discuss its connection with the Wasserstein GAN (WGAN), and then show that the WGAN is a special case of a generalized form of LS-GAN.



\subsection{Comparison with Wasserstein GAN}\label{sec:wgan}
We notice that the recently proposed Wasserstein GAN (WGAN) \cite{wgan17} uses the Earth-Mover (EM) distance to address the vanishing gradient and saturated JS distance problems in the classic GAN by showing the EM distance is continuous and differentiable almost everywhere.  While both the LS-GAN and the WGAN address these problems from different perspectives that are independently developed almost simultaneously, both turn out to use the Lipschitz regularity in training their GAN models. This constraint plays vital but different roles in the two models.  In the LS-GAN, the Lipschitz regularity naturally arises from the Lipschitz assumption on the data density and the generalization bound. Under this regularity condition, we have proved in Theorem~\ref{thm3} that the density of generated samples matches the underlying data density. On the contrary, the WGAN introduces the Lipschitz constraint from the Kantorovich-Rubinstein duality of the EM distance but it is {\em not} proved in \cite{wgan17} if the density of samples generated by WGAN is consistent with that of real data.

Here we assert that the WGAN also models an underlying Lipschitz density.  To prove this, we restate the WGAN as follows. The WGAN seeks to find a critic  and a generator  such that

and


Let  be the density of samples generated by . Then, we prove the following lemma about the WGAN in Appendix~\ref{appendixC}.

\begin{lemma}\label{lem:wgan}
{Under Assumption~\ref{asp}, given an optimal solution  to the WGAN such that  is Lipschitz, we have
}
\end{lemma}

This lemma shows both the LS-GAN and the WGAN are based on the same Lipschitz regularity condition.

Although both methods are derived from very different perspectives, it is interesting to make a comparison between their respective forms. Formally, the WGAN seeks to maximize the difference between the first-order moments of  under the densities of real and generated examples. In this sense, the WGAN can be considered as a kind of {\em first-order moment} method. Numerically, as shown in the second term of Eq.~(\ref{eq:critic}),  tends to be minimized to be arbitrarily small over generated samples, which could make  be unbounded above. This is why the WGAN must be trained by clipping the network weights of  on a bounded box to prevent  from becoming unbounded above.

On the contrary, the LS-GAN treats real and generated examples in pairs, and maximizes the difference of their losses up to a data-dependant margin. Specifically, as shown in the second term of Eq.~(\ref{eq:theta}), when the loss of a generated sample  becomes too large wrt that of a paired real example , the maximization of  will stop if the difference  exceeds . This prevents the minimization problem (\ref{eq:theta}) unbounded below, making it better posed to solve.

More importantly, paring real and generated samples in  prevents their losses from being decomposed into two separate first-order moments like in the WGAN. The LS-GAN makes pairwise comparison between the losses of real and generated samples, thereby enforcing real and generated samples to coordinate with each other to learn the optimal loss function. Specifically, when a generated sample becomes close to a paired real example, the LS-GAN will stop increasing the difference  between their losses.



Below we discuss a Generalized LS-GAN (GLS-GAN) model in Section~\ref{sec:glsgan}, and show that both WGAN and LS-GAN are simply two special cases of this GLS-GAN.



\subsection{GLS-GAN: Generalized LS-GAN}\label{sec:glsgan}

In proving Lemma~\ref{lem1}, it is noted that we only have used two properties of  in the objective function  training the loss function : 1)  for any ; 2)  for . This inspires us to generalize the LS-GAN with any alternative cost function  satisfying these two properties, and this will yield the Generalized LS-GAN (GLS-GAN).

We will show that {\bf both LS-GAN and WGAN can be seen as two extreme cases of this GLS-GAN } with two properly defined cost functions.

Formally, if a cost function  satisfies
\begin{itemize}
\item[(I)]  for any  and
\item[(II)]  for any ,
\end{itemize}
given a fixed generator , we use the following objective

to learn , with  highlighting its dependency on a chosen cost function .

For simplicity, we only involve the second term in (\ref{eq:theta}) to define the generalized objective . But it does not affect the conclusion as the role of the first term in (\ref{eq:theta}) would vanish with  being set to . Following the proof of Lemma~\ref{lem1}, we can prove the following lemma.
\begin{lemma}\label{lem5}
Under Assumption~\ref{asp}, given a Nash equilibrium  jointly minimizing  and  with a cost function  satisfying the above conditions (I) and (II), we have

\end{lemma}

In particular, we can choose a leaky rectified linear function for this cost function, i.e.,  with a slope . As long as , it is easy to verify  satisfies these two conditions.


Now the LS-GAN is a special case of this Generalized LS-GAN (GLS-GAN) when , as . We denote this equivalence as

\vspace{1mm}
\centerline{\bf LS-GAN = GLS-GAN()}
\vspace{1mm}

What is more interesting is the WGAN, an independently developed GAN model with stable training performance, also becomes a special case of this GLS-GAN with .  Indeed, when , , and

Since the last term  is a const, irrespective of , it can be discarded without affecting optimization over . Thus, we have


By comparing this  with  in (\ref{eq:critic}), it is not hard to see that the WGAN is equivalent to the GLS-GAN with , with the critic function  being equivalent to  \footnote{the minus sign exists as the  is maximized over  in the WGAN. On the contrary, in the GLS-GAN,  is minimized over .}. Thus we have

\vspace{1mm}\centerline{\bf WGAN = GLS-GAN()}\vspace{1mm}

Therefore, by varying the slope  in , we will obtain a family of the GLS-GANs with varied  beyond the LS-GAN and the WGAN.
Of course, it is unnecessary to limit  to a leaky rectified linear function. We can explore more cost functions as long as they satisfy the two conditions (I) and (II).

In experiments, we will demonstrate the GLS-GAN has competitive generalization performance on generating new images (c.f. Section~\ref{sec:eval_gen}).











\section{Non-Parametric Analysis}\label{sec:nonparam}
Now we can characterize the optimal loss functions learned from the objective (\ref{eq:theta1}), and this will provide us an insight into the LS-GAN model.

We generalize the non-parametric maximum likelihood method in \cite{carando2009nonparametric} and consider non-parametric solutions to the optimal loss function by minimizing (\ref{eq:theta1}) over the whole class of Lipschitz loss functions.




Let , i.e., the first  data points are real examples and the rest  are generated samples.  Then we have the following theorem.
\begin{theorem}\label{thm_nonparam}
The following functions  and  both minimize  in :

with the parameters . They are supported in the convex hull of , and we have

for , i.e., their values coincide on .
\end{theorem}
The proof of this theorem is given in the appendix.


From the theorem, it is not hard to show that any convex combination of these two forms attains the same value of , and is also a global minimizer.  Thus, we have the following corollary.

\begin{corollary}
All the functions in

 minimize  in .
\end{corollary}

\begin{figure}[t!]
    \centering
        \includegraphics[width=0.5\linewidth]{fun_L.png}
        \caption{Comparison between two optimal loss functions  and  in  for LS-GAN. They are upper and lower bounds of the class of optimal loss functions  to Problem (\ref{eq:theta1}). Both the upper and the lower bounds are cone-shaped, and have non-vanishing gradient almost everywhere. Specifically,
        in this one-dimensional example, both bounds are piecewise linear, having a slope of  almost everywhere.}\label{fig:fun_L}
\end{figure}

This shows that the global minimizer is not unique. Moreover, through the proof of Theorem \ref{thm_nonparam}, one can find that  and  are the upper and lower bound of any optimal loss function solution to the problem (\ref{eq:theta1}). In particular, we have the following corollary.
\begin{corollary}\label{cor2}
For any  that minimizes , the corresponding  and  are the lower and upper bounds of , i.e.,

\end{corollary}
The proof is given in Appendix~\ref{proof_b}.


The parameters  in (\ref{eq:param}) can be sought by minimizing

where  is short for , and the constraints are imposed to ensure the learned loss functions stay in .
With a greater value of , a larger class of loss function will be sought.  Thus, one can control the modeling ability of the loss function by setting a proper value to .

Problem (\ref{eq:theta_param}) is a typical linear programming problem. In principle, one can solve this problem to obtain a non-parametric loss function for the LS-GAN.
Unfortunately, it consists of a large number of constraints, whose scale is at an order of . This prevents us from using (\ref{eq:theta_param}) directly to solve an optimal non-parametric LS-GAN model with a very large number of training examples.
On the contrary, a more tractable solution is to use a parameterized network to solve the optimization problem (\ref{eq:theta1}) constrained in , and iteratively update parameterized  and  with the gradient descent method.


Although the non-parametric solution cannot be solved directly, it is valuable in shedding some light on what kind of the loss function would be learned by a deep network. It is well known that the training of the classic GAN generator suffers from vanishing gradient problem as the discriminator can be optimized very quickly.  Recent study \cite{wgan17} has revealed that this is caused by using the Jensen-Shannon (JS) distance that becomes locally saturated and gets vanishing gradient to train the GAN generator if the discriminator is over-trained. Similar problem has also been found in the energy-based GAN (EBGAN) \cite{zhao2016energy} as it minimizes the total variation that is not continuous or (sub-)differentiable if the corresponding discriminator is fully optimized \cite{wgan17}.

On the contrary, as revealed in Theorem~\ref{thm_nonparam} and illustrated in Figure~\ref{fig:fun_L}, both the upper and lower bounds of the optimal loss function of the LS-GAN are cone-shaped (in terms of  that defines the Lipschitz continuity), and have non-vanishing gradient almost everywhere. Moreover, Problem (\ref{eq:theta_param}) only contains {\em linear objective and constraints}; this is contrary to the classic GAN that involves logistic loss terms that are prone to saturation with vanishing gradient. Thus, an optimal loss function that is properly sought in  as shown in Figure~\ref{fig:fun_L} is unlikely to saturate between these two bounds, and it should be able to provide sufficient gradient to update the generator by descending (\ref{eq:phi1}) even if it has been trained till optimality. Our experiment also shows that, even if the loss function is quickly trained to optimality, it can still provide sufficient gradient to continuously update the generator in the LS-GAN (see Figure~\ref{fig:gradG}).



\section{Conditional LS-GAN}\label{sec:clsgan}
The LS-GAN can easily be generalized to produce a sample based on a given condition , yielding a new paradigm of Conditional LS-GAN (CLS-GAN).

For example, if the condition is an image class, the CLS-GAN seeks to produce images of the given class; otherwise, if a text description is given as a condition, the model attempts to generate images aligned with the given description.  This gives us more flexibility in controlling what samples to be generated.

Formally, the generator of CLS-GAN takes a condition vector  as input along with a noise vector  to produce a sample .
To train the model, we define a loss function  to measure the degree of the misalignment between a data sample  and a given condition .

For a real example  aligned with the condition , its loss function should be smaller than that of a generated sample by a margin of .  This results in the following constraint,







Like the LS-GAN, this type of constraint yields the following non-zero-sum game to train the CLS-GAN, which seeks a Nash equilibrium  so that
 minimizes

and  minimizes

where  denotes either the joint data distribution over  in (\ref{eq:clsgantheta}) or its marginal distribution over  in (\ref{eq:clsganphi}).


Playing the above game will lead to a trained pair of loss function  and generator .
We can show that the learned generator  can produce samples whose distribution follows the true data density  for a given condition .

To prove this, we say a loss function  is Lipschitz if it is Lipschitz continuous in its first argument . We also impose the following regularity condition on the conditional density .
\begin{assumption}\label{asp2}
For each , the conditional density  is Lipschitz, and is supported in a convex compact set of .
\end{assumption}

Then it is not difficult to prove the following theorem, which shows that the conditional density  becomes  as . Here  denotes the density of samples generated by  with sampled random noise .

\begin{theorem}\label{thm4}
Under Assumption~\ref{asp2}, a Nash equilibrium  exists such that\\
(i)  is Lipschitz continuous in  for each ;\\
(ii)  is Lipschitz continuous;\\
(iii) .
\end{theorem}

In addition, similar upper and lower bounds can be derived to characterize the learned conditional loss function  following the same idea for LS-GAN.

A useful byproduct of the CLS-GAN is one can use the learned loss function  to predict the label of an example  by


The advantage of such a CLS-GAN classifier is it is trained with both labeled and generated examples, the latter of which can improve the training of the classifier by revealing more potential variations within different classes of samples. It also provides a way to evaluate the model based on its classification performance. This is an objective metric we can use to assess the quality of feature representations learned by the model.

For a classification task, a suitable value should be set to .  Although Theorem~\ref{thm4} shows  would converge to the true conditional density  by increasing , it only ensures it is a good generative rather than classification model.  However, a too large value of  tends to ignore the first loss minimization term of (\ref{eq:clsgantheta}) that plays an important role in minimizing classification error.  Thus, a trade-off should be made to balance between classification and generation objectives.



\subsection{Semi-Supervised LS-GAN}\label{sec:ssl}
The above CLS-GAN can be considered as a fully supervised model to classify examples into different classes.
It can also be extended to a Semi-Supervised model by incorporating unlabeled examples.

Suppose we have  classes indexed by . In the CLS-GAN, for each class, we choose a loss function that, for example, can be defined as the negative log-softmax,

where  is the th activation output from a network layer.

Suppose we also have unlabeled examples available, and we can define a new loss function for these unlabeled examples so that they can be involved in training the CLS-GAN. Consider an unlabeled example , its groundtruth label is unknown.  However, the best guess of its label can be made by choosing the one that minimizes  over , and this inspires us to define the following loss function for the unlabeled example as

Here we modify  to  so  can be viewed as the probability that  does not belong to any known label.

Then we have the following loss-sensitive objective that explores unlabeled examples to train the CLS-GAN,


This objective is combined with  defined in (\ref{eq:clsgantheta}) to train the loss function network by minimizing

where  is a positive hyperparameter balancing the contributions from labeled and labeled examples.

The idea of extending the GAN for semi-supervised learning has been proposed by Odena \cite{odena2016semi} and
Salimans et al. \cite{salimans2016improved}, where generated samples are assigned to an artificial class, and unlabeled examples are treated as the negative examples.
Our proposed semi-supervised learning differs in creating a new loss function for unlabeled examples from the losses for existing classes, by minimizing which we make the best guess of the classes of unlabeled examples. The guessed labeled will provide additional information to train the CLS-GAN model, and the updated model will in turn improve the guess over the training course.
The experiments in the following section will show that this approach can generate very competitive performance especially when the labeled data is very limited.

\section{Experiments}\label{sec:exp}

Objective evaluation of a data generative model is not an easy task as there is no consensus criteria to quantify the quality of generated samples.  For this reason, we will make a qualitative analysis of generated images, and use image classification to quantitatively evaluate the resultant LS-GAN model.

First, we will assess the quality of generated images by the LS-GAN in comparison with the classic GAN model. Then, we will make an objective evaluation on the CLS-GAN to classify images. This task evaluates the quality of feature representations learned by the CLS-GAN in terms of its classification accuracy directly. 

Finally, we will assess the generalizability of various GAN models in generating new images out of training examples by proposing the Minimum Reconstruction Error (MRE) on a separate test set.


\subsection{Architectures}



\begin{table}[t]
\caption{The Network architecture used in CLS-GAN for training CIFAR-10 and SVHN, where BN stands for batch normalization, LeakyReLU for Leaky Rectifier with a slope of 0.2 for negative value, and
``3c1s96o Conv." means a  convolution kernel with stride  and  outputs, while "UpConv." denotes the fractionally-stride convolution.}
\label{tab:arch}
\begin{center}
\subtable[Loss Function Network]{
\begin{tabular}{c}    \toprule
Input \\\midrule
3c1s96o Conv. BN LeakyReLU\\
3c1s96o Conv. BN LeakyReLU\\
4c2s96o Conv. BN LeakyReLU\\\midrule
3c1s192o Conv. BN LeakyReLU\\
3c1s192o Conv. BN LeakyReLU\\
4c2s192o Conv. BN LeakyReLU\\\midrule
3c1s192o Conv. BN LeakyReLU\\
3c1s192o Conv. BN LeakyReLU\\
1c1s192o Conv. BN LeakyReLU\\\midrule
global meanpool\\\midrule
Output \\\bottomrule
\end{tabular}}\vspace{2mm}
\subtable[Generator Network]{
\begin{tabular}{c}    \toprule
Input -D random vector + -D one-hot vector\\\midrule
4c1s512o UpConv. BN LeakyReLU\\
4c2s256o UpConv. BN LeakyReLU\\
4c2s128o UpConv. BN LeakyReLU\\
4c2s3o UpConv. BN LeakyReLU\\\midrule
Elementwise Tanh\\\midrule
Output \\\bottomrule
\end{tabular}}
\end{center}
\end{table}

We adopted the ideas behind the network architecture for the DCGAN \cite{radford2015unsupervised} to build the generator and the loss function networks.  Compared with the conventional CNNs, maxpooling layers were replaced with strided convolutions in both networks, and fractionally-strided convolutions were used in the generator network to upsample feature maps across layers to finer resolutions.  Batch-normalization layers were added in both networks between convolutional layers, and fully connected layers were removed from these networks.

However, unlike the DCGAN, the LS-GAN model (unconditional version in Section~\ref{sec:lsgan}) did not use a sigmoid layer as the output for the loss function network.  Instead, we removed it and directly output the activation before the removed sigmoid layer.




On the other hand, for the loss function network in CLS-GAN, a global mean-pooling layer was added on top of convolutional layers.  This produced a  feature map that output the conditional loss  on different classes .
In the generator network, Tanh was used to produce images whose pixel values are scaled to . Thus, all image examples in datasets were preprocessed to have their pixel values in .
More details about the design of network architectures can be found in literature \cite{radford2015unsupervised}.

Table~\ref{tab:arch} shows the network architecture for the CLS-GAN model on CIFAR-10 and SVHN datasets in the experiments.  In particular, the architecture of the loss function network was adapted from that used in \cite{springenberg2015unsupervised} with nine hidden layers.




\subsection{Training Details}
The models were trained in a mini-batch of  images, and their weights were initialized from a zero-mean Gaussian distribution with a standard deviation of . The Adam optimizer \cite{kingma2014adam} was used to train the network with initial learning rate and  being set to  and  respectively, while the learning rate was annealed every  epochs by a factor of . The other hyperparameters such as  and  were chosen based on an independent validation set held out from training examples.


\begin{figure}[t]
\centering
\subfigure[Inception]{
\begin{minipage}{0.35\linewidth}
\begin{center}
	   \includegraphics[width=0.7\linewidth]{InceptionMargin.jpg}
\end{center}
\end{minipage}}\subfigure[VGG-16]{
\begin{minipage}{0.35\linewidth}
\begin{center}
	   \includegraphics[width=0.7\linewidth]{VGGMargin.jpg}\end{center}
\end{minipage}}
\caption{Images generated by the LS-GAN on the CelebA dataset, in which the margin is computed as the distance between the features extracted from the Inception and VGG-16 networks. Images are resized to  to fit the input size of both networks.}\label{fig:inception_vgg}
\end{figure}

We also tested various forms of loss margins  between real and fake samples.
For example, we tried the  distance between image representations as the margin, and found the best result can be achieved when .
The distance between convolutional features was supposed to capture perceptual dissimilarity between images.
But we should avoid a direct use of the convolutional features from the loss function network, since we found they would tend to collapse to a trivial point as the loss margin vanishes.
The feature maps from a separate pretrained deep network, such as Inception and VGG-16 networks, could be a better choice to define the loss margin. Figure~\ref{fig:inception_vgg} shows the images generated by LS-GAN on CelebA with the inception and VGG-16 margins.

However, for a fair comparison, we did not use these external deep networks in other experiments on image generation and classification tasks. We simply used the distance between raw images as the loss margin, and it still achieved competitive results. This demonstrates the robustness of the proposed method without having to choose a sophisticated loss margin. This is also consistent with our theoretical analysis where we do not assume any particular form of loss margin to prove the results.



For the generator network of LS-GAN, it took a -dimensional random vector drawn from Unif as input. For the
CLS-GAN generator, an one-hot vector encoding the image class condition was concatenated with the sampled random vector. The CLS-GAN was trained by involving both unlabeled and labeled examples as in Section~\ref{sec:clsgan}. This was compared against the other state-of-the-art supervised and semi-supervised models.

\subsection{Generated Images by LS-GAN}

First we made a qualitative comparison between the images generated by the DCGAN and the LS-GAN on the celebA dataset.

Figure~\ref{fig:celebA} compares the visual quality of images generated by LS-GAN and DCGAN after they were trained for  epochs, and
there was no perceptible difference between the qualities of their generated images.

\begin{figure}[t!]
\centering
\subfigure[DCGAN]{
\begin{minipage}{0.35\linewidth}
\begin{center}
	   \includegraphics[width=0.7\linewidth]{DCGAN_Tensorflow_105_64.png}\end{center}
\end{minipage}}\subfigure[LS-GAN]{
\begin{minipage}{0.35\linewidth}
\begin{center} \includegraphics[width=0.7\linewidth]{lsgan_BN.png}\end{center}
\end{minipage}}
\caption{Images generated by the DCGAN and the LS-GAN on the CelebA dataset. The results are obtained after  epochs of training the models.}\label{fig:celebA}
\end{figure}

However, the DCGAN architecture has been exhaustively fine-tuned in terms of the classic GAN training criterion to maximize the image generation performance. It was susceptible that its architecture could be fragile if we make some change to it. Here we tested if the LS-GAN can be more robust than the DCGAN when a structure change was made.

For example, one of the most key components in the DCGAN is the batch normalization inserted between the fractional convolution layers in the generator network. It has been reported in literature \cite{salimans2016improved} that the batch normalization not only plays a key role in training the DCGAN model, but also prevents the mode collapse of the generator into few data points.

The results were illustrated in Figure~\ref{fig:celebA_noBN}. If one removed the batch normalization layers from the generator, the DCGAN would collapse without producing any face images.  On the contrary, the LS-GAN still performed very well even if these batch normalization layers were removed, and there was { no perceived deterioration or mode collapse of the generated images}. This shows that the LS-GAN was more resilient than the DCGAN.

\begin{figure}[t]
\centering
\subfigure[DCGAN]{
\begin{minipage}{0.35\linewidth}
\begin{center}
	   \includegraphics[width=0.7\linewidth]{celebA_dcgan_noBN.jpg}
\end{center}
\end{minipage}}\subfigure[LS-GAN]{
\begin{minipage}{0.35\linewidth}
\begin{center}
	   \includegraphics[width=0.7\linewidth]{lsgan_noBN.png}\end{center}
\end{minipage}}
\caption{Images generated by the DCGAN and the LS-GAN on the CelebA dataset without batch normalization for the generator networks. The results are obtained after  epochs of training the models.}\label{fig:celebA_noBN}
\end{figure}





We also analyzed the magnitude ( norm) of the generator's gradient (in logarithmic scale) in Figure~\ref{fig:gradG} over iterations. With the loss function being updated every iteration, the generator was only updated every , , and  iterations.
From the figure, we note that the magnitude of the generator's gradient, no matter how frequently the loss function was updated, gradually increased until it stopped at the same level. This implies the objective function to update the generator tended to be linear rather than saturated through the training process, which was consistent with our non-parametric analysis of the optimal loss function. Thus, it provided sufficient gradient to continuously update the generator. Furthermore, we compared the images generated with different frequencies of updating the loss function in Figure~\ref{fig:freq_gen}, where there was no noticeable difference in the visual quality.  This shows the LS-GAN was not affected by over-trained loss function in experiments.

\begin{figure}[t!]
    \centering
        \includegraphics[width=0.6\linewidth, trim={0cm 8cm 0cm 8cm},clip=true]{gradG.pdf}
        \caption{The log of the generator's gradient norm over iterations. The generator is updated every 1, 3, and 5 iterations while the loss function is updated every iteration.  The loss function can be quickly updated to be optimal, and the figure shows the generator's gradient does not vanish even if the loss function is well trained.}\label{fig:gradG}
\end{figure}

\begin{figure}[t]
\centering
\subfigure[]{
\begin{minipage}{0.35\linewidth}
\begin{center}
	   \includegraphics[width=0.7\linewidth]{LSGAN_Tensorflow_F3_105_64.png}
\end{center}
\end{minipage}}\subfigure[]{
\begin{minipage}{0.35\linewidth}
\begin{center} \includegraphics[width=0.7\linewidth]{LSGAN_Tensorflow_F5_105_64.png}\end{center}
\end{minipage}}
\caption{Images generated by the LS-GAN on CelebA, where its generator is updated every three times (a) and every five times (b) the discriminator is updated.}\label{fig:freq_gen}
\end{figure}



\subsection{Image Classification}
We conducted experiments on CIFAR-10 and SVHN to compare the classification accuracy of LS-GAN with the other approaches.



\subsubsection{CIFAR-10}



\begin{table}[]
\caption{Classification accuracies on CIFAR-10 dataset. Accuracies with all training examples labeled (all) and with only 400 labeled examples per class (400) are reported. The best result is highlighted in bold.
}
\label{tab:cifar10}
\begin{center}
\begin{tabular}{c||c|c}    \toprule
\emph{Methods} & \emph{All}& \emph{400 per class}   \\\midrule
1 Layer K-means \cite{radford2015unsupervised}& 80.6\% & 63.7\% ( 0.7\%) \\
3 Layer K-means Learned RF \cite{coates2011selecting}& 82.0\% & 70.7\%( 0.7\%)  \\
View Invariant K-means \cite{hui2013direct}& 81.9\% & 72.6\%( 0.7\%) \\
Examplar CNN \cite{dosovitskiydiscriminative}& 84.3\% & 77.4\%( 0.2\%) \\
Conditional GAN \cite{mirza2014conditional} & 83.6\% & 75.5\%( 0.4\%)\\
DCGAN \cite{radford2015unsupervised}& 82.8\% & 73.8\%( 0.4\%) \\
Ladder Network \cite{rasmus2015semi} &  -- & 79.6\%( 0.5\%)\\
CatGAN \cite{springenberg2015unsupervised} & -- & 80.4\%( 0.4\%) \\
ALI \cite{dumoulin2016adversarially} & -- & 81.7\%\\
Improved GAN \cite{salimans2016improved} & -- & 81.4\%( 2.3\%) \\\midrule
CLS-GAN & \bf 91.7\% & \bf 82.7\%( 0.5\%) \\\bottomrule
\end{tabular}
\end{center}
\end{table}

The CIFAR dataset \cite{krizhevsky2009learning} consists of 50,000 training images and  test images on ten image categories.
We tested the proposed CLS-GAN model with class labels as conditions.  In the supervised training, all labeled examples were used to train the CLS-GAN.


We also conducted experiments with  labeled examples per class, which was a more challenging task as much fewer labeled examples were used for training. In this case, the remaining unlabeled examples were used to train the model in a semi-supervised fashion as discussed in Section~\ref{sec:clsgan}. In each mini-batch, the same number of labeled and unlabeled examples were used to update the model by stochastic gradient descent. The experiment results on this task were reported by averaging over ten subsets of labeled examples.

Both hyperparameters  and  were chosen via a five-fold cross-validation on the labeled examples from  and  respectively. Once they were chosen, the model was trained with the chosen hyperparameters on the whole training set, and the performance was reported based on the results on the test set. As in the improved GAN, we also adopted the weight normalization and feature matching mechanisms for the sake of the fair comparison.




We compared the proposed model with the state-of-the-art methods in literature.  In particular, we compared with the conditional GAN \cite{mirza2014conditional} as well as the DCGAN \cite{radford2015unsupervised}. For the sake of fair comparison, the conditional GAN shared the same architecture as the CLS-GAN.
On the other hand, the DCGAN algorithm \cite{radford2015unsupervised} max-pooled
the discriminator's convolution features from all layers to  grids as the image features, and a L2-SVM was then trained to classify images. The DCGAN was an unsupervised model which had shown competitive performance on generating photo-realistic images. Its feature representations were believed to reach the state-of-the-art performance in modeling images with no supervision.







We also compared with the other recently developed supervised and semi-supervised models in literature, including the baseline 1 Layer K-means feature extraction pipeline, a multi-layer extension of the baseline model (3 Layer K-means Learned RF \cite{coates2011selecting}), View Invariant K-means \cite{hui2013direct}, Examplar CNN \cite{dosovitskiydiscriminative}, Ladder Network \cite{rasmus2015semi}, as well as CatGAN \cite{springenberg2015unsupervised}.  In particular, among the compared semi-supervised algorithms, the improved GAN \cite{salimans2016improved} had recorded the best performance in literature.  Furthermore, we also compared with the ALI \cite{dumoulin2016adversarially} that extended the classic GAN by jointly generating data and inferring their representations, which achieved comparable performance to the Improved GAN. This pointed out an interesting direction to extend the CLS-GAN by directly inferring the data representation, and we will leave it in the future work.


Table~\ref{tab:cifar10} compares the experiment results, showing the CSL-GAN successfully outperformed the compared algorithms in both fully-supervised and semi-supervised settings.



\subsubsection{SVHN}

\begin{table}[t]
\caption{Classification errors on SVHN dataset with  labeled examples. The best result is highlighted in bold.}
\label{tab:svhn}
\begin{center}
\begin{tabular}{c||c}    \toprule
\emph{Methods} & \emph{Error rate} \\\midrule
KNN \cite{radford2015unsupervised}& 77.93\%\\
TSVM \cite{radford2015unsupervised}& 66.55\%\\
M1+KNN \cite{kingma2014semi}& 65.63\%\\
M1+TSVM \cite{kingma2014semi}& 54.33\%\\
M1+M2 \cite{kingma2014semi}& 36.02\%\\\midrule
SWWAE w/o dropout \cite{zhao2015stacked}& 27.83\%\\
SWWAE with dropout \cite{zhao2015stacked}& 23.56\%\\
DCGAN \cite{radford2015unsupervised}& 22.48\%\\
Conditional GAN \cite{mirza2014conditional}& 21.85\%0.38\%\\
Supervised CNN \cite{radford2015unsupervised}& 28.87\%\\
DGN \cite{kingma2014semi} &36.02\%0.10\%\\
Virtual Adversarial \cite{miyato2015distributional} &24.63\%\\
Auxiliary DGN \cite{maaloe2016auxiliary} &22.86\%\\
Skip DGN \cite{maaloe2016auxiliary}&16.61\%0.24\%\\
ALI \cite{dumoulin2016adversarially} & 7.3\%\\
Improved GAN \cite{salimans2016improved}&8.11\%1.3\%\\\midrule
CLS-GAN & {\bf 5.98\% 0.27\%}\\\bottomrule
\end{tabular}
\vspace{-2mm}
\end{center}
\end{table}

The SVHN (i.e., Street View House Number) dataset \cite{netzer2011reading} contains  color images of house numbers collected by Google Street View. They were roughly centered on a digit in a house number, and the objective is to recognize the digit.  The training set has  digits while the test set consists of .

To test the model,  labeled digits were used to train the model, which are uniformly selected from ten digit classes, that is  labeled examples per digit class. The remaining unlabeled examples were used as additional data to enhance the generative ability of CLS-GAN in semi-supervised fashion.
We expect a good generative model could produce additional examples to augment the training set.

We used the same experiment setup and network architecture for CIFAR-10 to train the LS-GAN on this dataset.  Table~\ref{tab:svhn} reports the result on the SVHN, and it shows that the LS-GAN performed the best among the compared algorithms.



\subsubsection{Analysis of Generated Images by CLS-GAN}

\begin{figure*}[t]
\centering
\subfigure[MNIST]{
\begin{minipage}{0.28\linewidth}
\begin{center}
	   \includegraphics[width=1.0\linewidth]{mnist.png}
\end{center}
\end{minipage}}\hspace{4mm}
\subfigure[CIFAR-10]{
\begin{minipage}{0.28\linewidth}
\begin{center}
	   \includegraphics[width=1.0\linewidth]{cifar10.jpg}
\end{center}
\end{minipage}}\hspace{4mm}
\subfigure[SVHN]{
\begin{minipage}{0.28\linewidth}
\begin{center}
	   \includegraphics[width=1.0\linewidth]{svhn2.jpg}
\end{center}
\end{minipage}}
\caption{Images generated by CLS-GAN for MNIST, CIFAR-10 and SVHN. Images in a column are generated for the same class. In particular, the generated images on CIFAR-10 are airplane, automobile, bird, cat, deer, dog, frog, horse, ship and truck from the leftmost to the rightmost column.}\label{fig:generation}
\label{Fig:dRNN}
\end{figure*}

Figure~\ref{fig:generation} illustrates the generated images by CLS-GAN for MNIST, CIFAR-10 and SVHN datasets. On each dataset, images in a column were generated for the same class. On the MNIST and the SVHN, both handwritten and street-view digits are quite legible. Both also cover many variants for each digit class. For example, the synthesized MNIST digits have various writing styles, rotations and sizes, and the generated SVHN digits have various lighting conditions, sizes and even different co-occurring digits in the cropped bounding boxes.  On the CIFAR-10 dataset, image classes can be recognized from the generated images although some visual details are missing. This is because the images in the CIFAR-10 dataset have very low resolution ( pixels), and most details are even missing from input examples.

We also observe that if we set a small value to the hyperparameter , the generated images would become very similar to each other within each class. As illustrated in Figure~\ref{fig:collapse}, the images were generated by halving  used for generating images in Figure~\ref{fig:generation}.
A smaller  means a relatively large weight was placed on the first loss minimization term of (\ref{eq:theta1}), which tends to collapse generated images to a single mode as it aggressively minimizes their losses to train the generator. This is also consistent with Theorem~\ref{thm4} where the density of generated samples with a smaller  could have a larger deviation from the underlying density.
One should avoid the collapse of trained generator since
diversifying generated images can improve the classification performance of the CLS-GAN by revealing more intra-class variations.  This will help improve the model's generalization ability as these variations could appear in future images.


\begin{figure*}[t]
\centering
\subfigure[MNIST]{
\begin{minipage}{0.28\linewidth}
\begin{center}
	   \includegraphics[width=1.0\linewidth]{mnist_collapse.jpg}
\end{center}
\end{minipage}}\hspace{4mm}
\subfigure[CIFAR-10]{
\begin{minipage}{0.28\linewidth}
\begin{center}
	   \includegraphics[width=1.0\linewidth]{cifar10_collapse.jpg}
\end{center}
\end{minipage}}\hspace{4mm}
\subfigure[SVHN]{
\begin{minipage}{0.28\linewidth}
\begin{center}
	   \includegraphics[width=1.0\linewidth]{svhn_collapse.jpg}
\end{center}
\end{minipage}}
\caption{Illustration of generated images that are collapsed to a single mode of the underlying image density on MNIST, CIFAR-10 and SVHN.}\label{fig:collapse}
\end{figure*}

However, one should also avoid setting too large value to .  Otherwise, the role of the first loss minimization term could be underestimated, which can also adversely affect the classification results without reducing the training loss to a satisfactory level.  Therefore, we choose a proper value for  by cross-validation on the training set in the experiments.


In brief, the comparison between Figure~\ref{fig:generation} and Figure~\ref{fig:collapse} reveals a trade-off between image generation quality and classification accuracy through the hyperparameter . Such a trade-off is intuitive: while a classification task usually focuses on learning class-invariant representations that do not change within a class, image generation should be able to capture many variant factors (e.g., lighting conditions, viewing angles, and object poses) so that it could diversify generated samples for each class. Although diversified examples can augment training dataset, it comes at a cost of trading class-invariance for modeling variant generation factors. Perhaps, this is an intrinsic dilemma between supervised learning and data generation that is worth more theoretical and empirical studies in future.

\subsection{Evaluation of Generalization Performances}\label{sec:eval_gen}






Most of existing metrics like Inception Score \cite{salimans2016improved} for evaluating GAN models focus on comparing the qualities and diversities of their generated images. However, even though a GAN model can produce diverse and high quality images with no collapsed generators, it is still unknown if the model can generate {\em unseen} images out of given examples, or simply memorizing existing ones.  While one of our main pursuits in this paper is a generalizable LS-GAN, we were motivated to propose the following Minimum Reconstruction Error (MRE) to compare its generalizability with various GANs.







Specifically, for an unseen test image , we aim to find an input noise  that can best reconstruct  with the smallest error, i.e.,

where  is the GAN generator under evaluation. Obviously, if  is adequate to produce new images, it should have a small reconstruction error on a separate test set that has not been used in training the model.




We assessed the GAN's generalizability on CIFAR-10 and tiny ImageNet datasets. On CIFAR-10, we split the dataset into 50\% training examples, 25\% validation examples and 25\% test examples; the tiny ImageNet was split into training, validation and test sets in a ratio of 10:1:1. For a fair comparison, all the hyperparameters, including the number of epochs, were chosen based on the average MREs on the validation set, and the test MREs were reported for comparison. The optimal 's were iteratively updated on the validation and test sets by descending the gradient of the reconstruction errors.




\begin{figure*}
\centering
\subfigure[CIFAR-10]{
\begin{minipage}{0.49\linewidth}
\begin{center}
	   \includegraphics[width=0.98\linewidth]{cifar10_test_mre2.png}\vspace{1mm}
\end{center}
\end{minipage}}\subfigure[tiny ImageNet]{
\begin{minipage}{0.49\linewidth}
\begin{center} \includegraphics[width=0.98\linewidth]{tiny_test_mre.png}\vspace{1mm}\end{center}
\end{minipage}}
   \caption{The change of test MREs on CIFAR-10 and tiny ImageNet over epochs. Image pixels were scaled to  to compute the MREs. }\label{fig:cifar10_mre}
\end{figure*}

\begin{figure*}[h]
\centering
\subfigure[Original test images]{
\begin{minipage}{0.25\linewidth}
\begin{center}
	   \includegraphics[width=1.0\linewidth]{images_cifar10_mre.jpg}\vspace{1mm}
\end{center}
\end{minipage}}\subfigure[LS-GAN(0.1166)]{
\begin{minipage}{0.25\linewidth}
\begin{center}
	   \includegraphics[width=1.0\linewidth]{lsgan_cifar10_mre.jpg}\vspace{1mm}
\end{center}
\end{minipage}}\subfigure[\bf GLS-GAN(0.1089)]{
\begin{minipage}{0.25\linewidth}
\begin{center}
	   \includegraphics[width=1.0\linewidth]{glsgan_cifar10_mre.jpg}\vspace{1mm}
\end{center}
\end{minipage}}\\\subfigure[WGAN-GP(0.1149)]{
\begin{minipage}{0.25\linewidth}
\begin{center}
	   \includegraphics[width=1.0\linewidth]{wgangp_cifar10_mre.jpg}\vspace{1mm}
\end{center}
\end{minipage}}\subfigure[WGAN(0.1109)]{
\begin{minipage}{0.25\linewidth}
\begin{center}
	   \includegraphics[width=1.0\linewidth]{wgan_cifar10_mre.jpg}\vspace{1mm}
\end{center}
\end{minipage}}
\subfigure[DCGAN(0.1506)]{
\begin{minipage}{0.25\linewidth}
\begin{center}
	   \includegraphics[width=1.0\linewidth]{dcgan_cifar10_mre.jpg}\vspace{1mm}
\end{center}
\end{minipage}}
\caption{The figure illustrates the images reconstructed by various GANs on CIFAR-10 with their MREs on the test set in the parentheses. }\label{fig:reconstructed_cifar10}
\end{figure*}

\begin{figure*}[h]
\centering
\subfigure[Original test images]{
\begin{minipage}{0.25\linewidth}
\begin{center}
	   \includegraphics[width=1.0\linewidth]{images_tiny_mre.jpg}\vspace{1mm}
\end{center}
\end{minipage}}\subfigure[LS-GAN(0.2093)]{
\begin{minipage}{0.25\linewidth}
\begin{center}
	   \includegraphics[width=1.0\linewidth]{lsgan_tiny_mre.jpg}\vspace{1mm}
\end{center}
\end{minipage}}\subfigure[\bf GLS-GAN(0.2085)]{
\begin{minipage}{0.25\linewidth}
\begin{center}
	   \includegraphics[width=1.0\linewidth]{glsgan_tiny_mre.jpg}\vspace{1mm}
\end{center}
\end{minipage}}\\\subfigure[WGAN-GP(0.2210)]{
\begin{minipage}{0.25\linewidth}
\begin{center}
	   \includegraphics[width=1.0\linewidth]{wgangp_tiny_mre.jpg}\vspace{1mm}
\end{center}
\end{minipage}}\subfigure[WGAN(0.2219)]{
\begin{minipage}{0.25\linewidth}
\begin{center}
	   \includegraphics[width=1.0\linewidth]{wgan_tiny_mre.jpg}\vspace{1mm}
\end{center}
\end{minipage}}
\subfigure[DCGAN(0.2413)]{
\begin{minipage}{0.25\linewidth}
\begin{center}
	   \includegraphics[width=1.0\linewidth]{dcgan_tiny_mre.jpg}\vspace{1mm}
\end{center}
\end{minipage}}
\caption{The figure illustrates the images reconstructed by various GANs on tiny ImageNet with their MREs on the test set in the parentheses.}\label{fig:reconstructed_cifar10}
\end{figure*}

In Figure~\ref{fig:cifar10_mre}, we compare the test MREs over  epochs by LS-GAN, GLS-GAN, WGAN \cite{wgan17}, WGAN-GP \cite{gulrajani2017improved} and DCGAN \cite{radford2015unsupervised} on CIFAR-10 respectively.
For the sake of a fair comparison, all models were trained with the network architecture used in \cite{radford2015unsupervised}.
The result clearly shows the regularized models, including GLS-GAN, LS-GAN, WGAN-GP and WGAN, have apparently better generalization performances than the unregularized DCGAN based on the classic GAN model. On CIFAR-10, the test MRE was reduced from  by DCGAN to as small as  and  by WGAN and GLS-GAN respectively; on tiny ImageNet, the GLS-GAN reaches the smallest test MRE of  among all compared regularized and unregularized GANs.



In addition, the DCGAN exhibited fluctuating MREs on the CIFAR-10, while the regularized models steadily decreased the MREs over epochs. This implies regularized GANs have more stable training than the classic GAN. 






We illustrate some examples of reconstructed images by different GANs on the test set along with their test MREs in Figure~\ref{fig:reconstructed_cifar10}.
The results show the GLS-GAN achieved the smallest test MRE of 0.1089 and 0.2085 with a LeakyReLU cost function of slope  and  on CIFAR-10 and tiny ImageNet, followed by the other regularized GAN models.
This is not a surprising result since it has been shown in Section~\ref{sec:glsgan} that the other regularized GANs such as LS-GAN and WGAN are only special cases of the GLS-GAN model that covers larger family of models. Here we only considered LeakyReLU as the cost function for GLS-GAN. Of course, there exist many more cost functions satisfying the two conditions in Section~\ref{sec:glsgan}  to expand the family of regularized GANs, which should have potentials of yielding even better generalization performances.

















\section{Conclusions}\label{sec:concl}
In this paper, we present a novel Loss-Sensitive GAN (LS-GAN) approach to generate samples from a data distribution.  The LS-GAN learns a loss function to distinguish between generated and real samples, where the loss of a real sample should be smaller by a margin than that of a generated sample.
Our theoretical analysis shows the distributional consistency between the real and generated samples based on the Lipschitz regularity.
This no longer needs a non-parametric discriminator with infinite modeling ability in the classic GAN, allowing us to search for the optimal loss function in a smaller functional space with a bounded Lipschitz constant.
Moreover, we prove the generalizability of LS-GAN by showing its required number of training examples is polynomial in its complexity. This suggests the generalization performance can be improved by penalizing the Lipschitz constants (via their gradient surrogates) of the loss function to reduce the sample complexity.
Furthermore, our non-parametric analysis of the optimal loss function shows its lower and upper bounds are cone-shaped with non-vanishing gradient almost everywhere, implying the generator can be continuously updated even if the loss function is over-trained.
Finally, we extend the LS-GAN to a Conditional LS-GAN (CLS-GAN) for semi-supervised tasks, and demonstrate it reaches competitive performances on both image generation and classification tasks.





\bibliographystyle{spmpsci}      \bibliography{LSGAN}   



\appendix

\section{Proof of Lemma~\ref{lem1}}\label{proof_a}
To prove Lemma~\ref{lem1}, we need the following lemma.

\begin{lemma}\label{lem3}
For two probability densities  and , if  almost everywhere, we have

for .
\end{lemma}
\begin{proof}
We have the following equalities and inequalities:

This completes the proof.
\end{proof}

Now we can prove Lemma~\ref{lem1}.
\begin{proof}
Suppose  is a Nash equilibrium for the problem (\ref{eq:theta}) and (\ref{eq:phi}).

Then, on one hand, we have

where the first inequality follows from .

We also have  for any  as  minimizes . In particular, we can replace  in  with , which yields


Applying this inequality into (\ref{eq:lower1}) leads to

where the last inequality follows as  is nonnegative.





On the other hand, consider a particular loss function

When  is a sufficiently small positive coefficient,  is a nonexpansive function (i.e., a function with Lipschitz constant no larger than .). This follows from the assumption that   and  are Lipschitz.  In this case, we have


By placing this  into , one can show that

where the first equality uses Eq.~(\ref{eq:nonex}), and the second equality is obtained by substituting   in Eq.~(\ref{eq:L}) into the equation.


Assuming that  on a set of nonzero measure, the above equation would be strictly upper bounded by  and we have


This results in a contradiction with Eq.~(\ref{eq:lower2}).
Therefore, we must have

for almost everywhere.  By Lemma~\ref{lem3}, we have


Let , this leads to

This proves that  converges to  as .
\end{proof}

\section{Proof of Lemma~\ref{lem:wgan}}\label{appendixC}
\begin{proof}
Suppose a pair of  jointly solve the WGAN problem.

Then, on one hand, we have

where the inequality follows from  by replacing  with .

Consider a particular .  Since  and  are Lipschitz by assumption, when  is sufficiently small, it can be shown that .

Substituting this  into , we get


Let us assume  on a set of nonzero measure, we would have

This leads to a contradiction with (\ref{eq:lem_wgan1}), so we must have

almost everywhere.

Hence, by Lemma~\ref{lem3}, we prove the conclusion that

\end{proof}



\section{Proof of Theorem \ref{thm:generalization}}\label{sec:gen_proof}
For simplicity, throughout this section, we disregard the first loss minimization term in  and , since the role of the first term would vanish as  goes to . However, even if it is involved, the following proof still holds with only some minor changes.





To prove Theorem~\ref{thm:generalization}, we need the following lemma.
\begin{lemma}
For all loss functions , with at least the probability of , we have

when the number of samples 
with a sufficiently large constant .
\end{lemma}
The proof of this lemma needs to apply the McDiarmid's inequality and the fact that  is an 1-Lipschitz
to bound the difference  for a loss function.  Then, to get the union bound over all loss functions, a standard -net \cite{arora2017generalization} will be constructed to yield finite points that are dense enough to cover the parameter space of the loss functions. The proof details are given below.
\begin{proof}
For a loss function , we compute  over a set of  samples  drawn from  and  respectively.

To apply the McDiarmid's inequality, we need to bound the change of this function when a sample is changed.  Denote by  when the th sample is replaced with  and . Then we have

where the first inequality uses the fact that  is -Lipschitz, the second inequality follows from that
 is bounded by  and  is -Lipschitz in .

Now we can apply the McDiarmid's inequality. Noting that

we have

The above bound applies to a single loss function .  To get the union bound, we consider a -net , i.e., for any , there is a  in this net so that . This standard net can be constructed to contain finite loss functions such that , where  is the number of parameters in a loss function. Note that we implicitly assume the parameter space of the loss function is bounded so we can construct such a net containing finite points here.

Therefore, we have the following union bound for all  that, with probability ,

when .

The last step is to obtain the union bound for all loss functions beyond . To show that, we consider the following inequality

where the first inequality uses that fact that  is -Lipschitz again, and the second inequality follows from that  is -Lipschitz in .
Similarly, we can also show that

Now we can derive the union bound over all loss functions. For any , by construction we can find a  such that .
Then, with probability , we have

This proves the lemma.
\end{proof}



Now we can prove Theorem~\ref{thm:generalization}.
\begin{proof}
First let us bound .  Consider  that minimizes . Then with probability , when , we have

where the first inequality follows from the inequality  as  may not minimize , and the second inequality is a direct application of the above lemma.
Similarly, we can prove the other direction. With probability , we have




Finally, a more rigourous discussion about the generalizability should consider that  is updated iteratively. Therefore we have a sequence of  generated over  iterations for .  Thus, a union bound over all generators should be considered in (\ref{eq:mcdiarmid}), and this makes the required number of training examples  become

However, the iteration number  is usually much smaller than the model size  (which is often hundreds of thousands), and thus this factor will not affect the above lower bound of .
\end{proof}






\section{Proof of Theorem~\ref{thm_nonparam} and Corollary~\ref{cor2}}\label{proof_b}
We prove Theorem~\ref{thm_nonparam} as follows.

\begin{proof}
First, the existence of a minimizer follows from the fact that the functions in  form a compact set, and the objective function is convex.

To prove the minimizer has the two forms in (\ref{eq:param}), for each , let us consider


It is not hard to verify that  and  for .

Indeed, by noting that  has its Lipschitz constant bounded by , we have , and thus

Because  by the assumption (i.e., it is lower bounded by zero), it can be shown that for all 

Hence, by the definition of  and taking the maximum over  on the left hand side, we have


On the other hand,  we have

because  for any , and it is true in particular for .  This shows .

Similarly, one can prove . To show this, we have

by the Lipschitz continuity of . By taking the minimum over , we have

On the other hand, we have  by the definition of .  Combining these two inequalities shows that .

Now we can prove for any function , there exist  and  both of which attain the same value of  as , since  only depends on the values of  on the data points . In particular, this shows that any global minimum in  of  can also be attained by the corresponding functions of the form (\ref{eq:param}). By setting  for , this completes the proof.
\end{proof}

Finally, we prove Corollary~\ref{cor2} that bounds  with  and  constructed above.
\begin{proof}
By the Lipschitz continuity, we have

Since , it follows that

Taking the maximum over  on the left hand side, we obtain

This proves the lower bound.

Similarly, we have by Lipschitz continuity

which, by taking the minimum over  on the left hand side, leads to

This shows the upper bound.
\end{proof}




\end{document}
