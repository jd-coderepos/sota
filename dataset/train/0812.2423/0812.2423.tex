
\documentclass{LMCS}



\usepackage{epic, eepic, epsf, epsfig, pst-node,pstricks,pst-grad}
\usepackage{gastex,color,empheq}
\usepackage{amsmath,amssymb,latexsym}
\usepackage{xspace}
\usepackage{dsfont}
\usepackage{cite}
\usepackage[mathscr]{euscript}
\usepackage{enumerate,hyperref}

\def\doi{4 (4:16) 2008}
\lmcsheading {\doi}
{1--35}
{}
{}
{Sep.~\phantom{0}3, 2007}
{Dec.~24, 2008}
{}   
\begin{document}



\newcommand{\qedclaim}{\qed}

\newcommand{\redc}[1]{#1}
\newcommand{\greenc}[1]{#1}
\newcommand{\whitec}[1]{\textcolor{white}{#1}}

\newcommand{\oa}{{\overline{a}}}
\newcommand{\ob}{{\overline{b}}}

\renewcommand{\uplus}{\mathrel{\mathaccent\cdot\cup}}

\newcommand{\rightone}{\mathrel{\curvearrowright}}
\newcommand{\leftone}{\mathrel{\curvearrowleft}}
\newcommand{\righttwo}{\mathrel{\rotatebox[origin=cc]{180}{}}}
\newcommand{\lefttwo}{\mathrel{\rotatebox[origin=cc]{180}{}}}
\newcommand{\rightthree}{\mathrel{\stackrel{3}{\curvearrowright}}}
\newcommand{\leftthree}{\mathrel{\stackrel{3}{\curvearrowleft}}}

\newcommand{\rightright}{\mathrel{\leadsto}}
\newcommand{\rightleft}{\mathrel{\rotatebox[origin=cc]{90}{\,\,}}}
\newcommand{\leftleft}{\mathrel{\reflectbox{}}}
\newcommand{\leftright}{\mathrel{\rotatebox[origin=cc]{-90}{\,\,}}}

\newcommand{\rightk}{\mathrel{\stackrel{\stack}{\curvearrowright}}}
\newcommand{\leftk}{\mathrel{\stackrel{\stack}{\curvearrowleft}}}

\newcommand{\lra}{\longrightarrow}
\newcommand{\crSigma}{\widetilde{\Sigma}}
\newcommand{\ncrSigma}{\widehat{\Sigma}}
\newcommand{\cSigma}{\Sigma_c}
\newcommand{\rSigma}{\Sigma_r}
\newcommand{\intSigma}{\Sigma_{\mathit{int}}}

\newcommand{\signNW}{\tau_{\crSigma}}
\newcommand{\signG}{\tau_{\mathit{Grids}}}

\newcommand{\Init}{Q_I}

\newcommand{\hinv}{h'}

\newcommand{\NW}{\mathbb{NW}}
\newcommand{\infNW}{\mathbb{NW}^\omega}
\newcommand{\Grids}{\mathbb{G}}

\newcommand{\LSigma}{{\bf{\Sigma}}}

\newcommand{\Contents}{\mathit{Cont}}

\newcommand{\dom}{\mathrm{dom}}
\newcommand{\codom}{\mathrm{co}\textup{-}\mathrm{dom}}

\newcommand{\dist}{d}
\newcommand{\radius}{r}

\newcommand{\succord}{\mathord{\lessdot}}
\newcommand{\succrel}{\mathrel{\lessdot}}
\renewcommand{\succ}[2]{#1 \mathrel{\lessdot} #2}
\renewcommand{\epsilon}{\varepsilon}

\renewcommand{\mod}{~\mathrm{mod}~}

\newcommand{\modit}{\mathit{mod}}

\newcommand{\Sph}[3]{#1\text{-}\mathrm{Sph}(#2,#3)}

\newcommand{\simulate}[4]{#3 \mathrel{\equiv^{#1}_{#2}} #4}
\newcommand{\wsimulate}[4]{#3 \mathrel{\sqsubseteq^{#1}_{#2}} #4}
\newcommand{\notwsimulate}[4]{#3 \mathrel{\not\sqsubseteq^{#1}_{#2}} #4}
\newcommand{\edge}[1]{\mathrel{\leftrightarrow}_{#1}}
\newcommand{\redge}[1]{\mathrel{\rightarrow}_{#1}}

\newcommand{\Nat}{N}
\newcommand{\infDom}{\N_{+}}
\newcommand{\posN}{\N_{+}}

\newcommand{\sphere}{S}
\newcommand{\esphere}{E}

\newcommand{\call}{\mu^{-1}}
\newcommand{\ret}{\mu}

\newcommand{\cdelta}{\delta_c}
\newcommand{\rdelta}{\delta_r}
\newcommand{\intdelta}{\delta_{\mathit{int}}}
\newcommand{\crdelta}{\langle\cdelta,\rdelta,\intdelta\rangle}

\newcommand{\stack}{s}
\newcommand{\nstack}{K}

\newcommand{\Lang}{\mathcal{L}}

\renewcommand{\phi}{\varphi}

\newcommand{\nword}{W}
\newcommand{\str}{\mathrm{string}}
\newcommand{\nested}{\mathrm{nested}}

\newcommand{\Aut}{\mathcal{A}}
\newcommand{\PA}{\mathcal{A}}
\newcommand{\WA}{\mathcal{B}}

\newcommand{\MVPA}{\textsc{Mvpa}\xspace}
\newcommand{\MNWA}{\textsc{Mnwa}\xspace}
\newcommand{\GMNWA}{\textsc{GMnwa}\xspace}

\newcommand{\MSO}{\textup{MSO}}
\newcommand{\FO}{\textup{FO}}
\newcommand{\EMSO}{\textup{EMSO}}

\newcommand{\tVPA}{2\textsc{vpa}\xspace}
\newcommand{\tNWA}{2\textsc{nwa}\xspace}

\newcommand{\isom}{\cong}

\newcommand{\N}{\mathds{N}}


\newcommand{\gdown}{\mathord{\mathrm{succ}_1}}
\newcommand{\gright}{\mathord{\mathrm{succ}_2}}
\newcommand{\succone}{\mathord{\mathrm{succ}_1}}
\newcommand{\succtwo}{\mathord{\mathrm{succ}_2}}
\newcommand{\succk}{\mathord{\mathrm{succ}_k}}


\newcommand{\foequiv}[1]{\mathrel{\equiv}_{#1}}
\newcommand{\inffoequiv}[1]{\mathrel{\equiv}_{#1}^\infty}
\newcommand{\threquiv}[2]{\mathrel{\leftrightarrows}_{#1,#2}}
\newcommand{\infthrequiv}[2]{\mathrel{\leftrightarrows}_{#1,#2}^\infty}

\newtheorem{myclaim}[thm]{Claim}{\bfseries}{\rmfamily}


\renewcommand{\arraystretch}{1.4}


\newcommand{\state}{\sphere}
\newcommand{\cstate}{\sphere_c}

\newcommand{\Buchi}{B{\"u}chi\xspace}

\newcommand{\AllSpheres}{\mathit{Spheres}}
\newcommand{\Spheres}{\mathit{Spheres}}

\newcommand{\AlleSpheres}{\mathit{eSpheres}}

\newcommand{\core}{\mathit{core}}
\newcommand{\espheremap}{\mathit{esphere}}
\newcommand{\labeling}{\mathit{label}}
\newcommand{\inst}{\mathit{col}}
\newcommand{\col}{\mathit{col}}
\newcommand{\const}{\#\mathit{Col}}

\newcommand{\State}{\mathcal{E}}
\newcommand{\cState}{\mathcal{E}_c}


\newcommand{\tW}{{\widetilde{W}}}
\newcommand{\tn}{\widetilde{n}}
\newcommand{\tsuccord}{\widetilde{\succord}}
\newcommand{\tmu}{\widetilde{\mu}}
\newcommand{\tlambda}{\widetilde{\lambda}}
\newcommand{\trho}{\widetilde{\rho}}

\newcommand{\maxN}{\mathit{maxSize}(r)}

\newcommand{\Dir}{\Delta}


\newcommand{\Wleadsto}[4]{#3 \mathrel{{\xhookrightarrow{#2~}}_{#1}} #4}
\newcommand{\Wleadstoeq}[4]{#3 \mathrel{{\xRightarrow{~#2~}}_{#1}} #4}
\newcommand{\longWleadstoeq}[4]{#3 \mathrel{{\xRightarrow{#2~}}_{#1}} #4}

\newcommand{\eWleadsto}[5]{#3 \mathrel{{\xhookrightarrow[{#5}]{#2}}}
#4}



\newcommand{\Paths}{\mathit{Paths}}


\title[On the Expressive Power of 2-Stack Visibly Pushdown Automata]{On
  the Expressive Power of\\2-Stack Visibly Pushdown Automata}

\author[B.~Bollig]{Benedikt Bollig}
 \address{LSV, ENS Cachan, CNRS ---
   61, avenue du Pr{\'e}sident Wilson,
   94235 Cachan Cedex, France}
\email{bollig@lsv.ens-cachan.fr}

\keywords{visibly pushdown automata, multiple stacks, nested words, monadic
  second-order logic} \subjclass{F.4.3}




\begin{abstract}
  Visibly pushdown automata are input-driven pushdown automata that recognize
  some non-regular context-free languages while preserving the nice closure
  and decidability properties of finite automata. Visibly pushdown automata
  with multiple stacks have been considered recently by La Torre, Madhusudan,
  and Parlato, who exploit the concept of visibility further to obtain a rich
  automata class that can even express properties beyond the class of
  context-free languages. At the same time, their automata are closed under
  boolean operations, have a decidable emptiness and inclusion problem, and
  enjoy a logical characterization in terms of a monadic second-order logic
  over words with an additional nesting structure. These results require a
  restricted version of visibly pushdown automata with multiple stacks whose
  behavior can be split up into a fixed number of phases.

  In this paper, we consider 2-stack visibly pushdown automata (i.e., visibly
  pushdown automata with two stacks) in their unrestricted form. We show that
  they are expressively equivalent to the existential fragment of monadic
  second-order logic. Furthermore, it turns out that monadic second-order
  quantifier alternation forms an infinite hierarchy wrt.\ words with multiple
  nestings. Combining these results, we conclude that 2-stack visibly pushdown
  automata are not closed under complementation.

  Finally, we discuss the expressive power of \Buchi 2-stack visibly pushdown
  automata running on infinite (nested) words. Extending the logic by an
  infinity quantifier, we can likewise establish equivalence to existential
  monadic second-order logic.
\end{abstract}

\maketitle







\section{Introduction}\label{sec:intro}

The notion of a regular word language has ever played an important r\^ole in
computer science, as it constitutes a robust concept that enjoys manifold
representations in terms of finite automata, regular expressions, monadic
second-order logic, etc. Generalizing regular languages towards richer classes
and more expressive formalisms is often accompanied by the loss of robustness
and decidability properties. It is, for example, well-known that the class of
context-free languages, represented by pushdown automata, is not closed under
complementation and that universality, equivalence, and inclusion are
undecidable problems \cite{Hopcroft2000}.

\emph{Visibly pushdown languages} have been introduced by Alur and Madhusudan
to overcome this deficiency while subsuming many interesting and useful
context-free properties \cite{AM2004}. Visibly pushdown languages are
represented by special pushdown automata whose stack operations are driven by
the input. More precisely, the underlying alphabet of possible actions is
partitioned into (1) call, (2) return, and (3) internal actions, which, when
reading an action, indicates if (1) a stack symbol is pushed on the stack, (2)
a stack symbol is read and popped from the stack, or (3) the stack is not
touched at all, respectively. Such a partition gives rise to a
\emph{call-return alphabet}. Though this limits the expressive power of
pushdown automata, the such defined class of visibly pushdown languages is
rich enough to model various interesting non-regular properties for program
analysis. Even more, this class preserves some important closure properties of
regular languages, such as the closure under boolean operations, and it
exhibits decidable problems, such as inclusion, that are undecidable in the
context of general pushdown automata. Last but not least, the visibly pushdown
languages are captured by a monadic second-order logic that makes use of a
binary nesting predicate. Such a logic is suitable in the context of
visibility, as the nesting structure of a word is uniquely determined,
regardless of a particular run of the pushdown automaton. The logical
characterization smoothly extends the classical theory of regular languages
\cite{Buechi:60,Elgot1961}. For context-free languages, quantification over
\emph{matchings}, which are not implicitly given when we do not have
visibility, is necessary to obtain a logical characterization
\cite{Schwentick94}.

Visibly pushdown automata with multiple stacks have been considered recently
and independently by La Torre, Madhusudan, and Parlato \cite{Madhusudan2007},
as well as Carotenuto, Murano, and Peron \cite{Murano2007}. The aim of these
papers is to exploit the concept of visibility further to obtain even richer
classes of non-regular languages while preserving important closure properties
and decidability of verification-related problems such as emptiness and
inclusion.

In \cite{Madhusudan2007}, the authors consider visibly pushdown automata with
arbitrarily many stacks. To retain the nice properties of visibly pushdown
automata with only one stack, the idea is to restrict the domain, i.e., the
possible inputs, to those words that can be divided into at most  phases
for a predefined . In every phase, pop actions correspond to one and the
same stack. These restricted visibly pushdown automata have a decidable
emptiness problem, which is shown by a reduction to the emptiness problem for
finite tree automata, and are closed under union, intersection, and
complementation (wrt.\ the domain of -phase words). Moreover, a word
language is recognizable if, and only if, it can be defined in monadic
second-order logic where the usual logic over words is expanded by a matching
predicate that matches a push with its corresponding pop event. As mentioned
above, such a matching is unique wrt.\ the underlying call-return alphabet.
The only negative result in this regard is that multi-stack visibly pushdown
automata cannot be determinized.

The paper \cite{Murano2007} considers visibly pushdown automata with two
stacks and call-return alphabets that appear more general than those of
\cite{Madhusudan2007}: Any stack is associated with a partition of one and the
same alphabet into call, return, and local transitions so that an action might
be both a call action for the first stack and, at the same time, a return
action for the second. In this way, both stacks can be worked on
simultaneously. Note that, if we restrict to the alphabets of
\cite{Madhusudan2007} where the stack alphabets are disjoint, the models from
\cite{Murano2007} and \cite{Madhusudan2007} coincide. Carotenuto et al.\ show
that the emptiness problem of their model is undecidable. Their approach to
gain decidability is to exclude simultaneous pop operations by introducing an
ordering constraint on stacks, which is inspired by \cite{multi96} (see also
\cite{ABH-dlt08}). More precisely, a pop operation on the second stack is only
possible if the first stack is empty. Under these restrictions, the emptiness
problem turns out to be decidable in polynomial time (note that the number of
stacks is fixed).\footnote{In \cite{Murano2007}, the authors argue that
  2-stack visibly pushdown automata without restriction are closed under
  complementation, but their proof makes use of the incorrect assumption that
  these automata are determinizable. In fact, \mbox{2-stack} visibly pushdown
  automata can in general not be determinized \cite{Madhusudan2007}. In the
  present paper, we show that 2-stack visibly pushdown automata are actually
  not closed under complementation.}

In this paper, we consider 2-stack visibly pushdown automata (i.e., visibly
pushdown automata with two stacks) where each action is exclusive to one of
the stacks, unless we deal with an internal action, which does not affect the
stacks at all. Thus, we adopt the model of \cite{Madhusudan2007}, though we
have to restrict to two stacks for our main results. One of these results
states that the corresponding language class is precisely characterized by the
existential fragment of monadic second-order logic where a first-order kernel
is preceded by a block of existentially quantified second-order variables. In
a second step, we show that the full monadic second-order logic is strictly
more expressive than its existential fragment so that we conclude that 2-stack
visibly pushdown automata are not closed under complementation. Note that our
model has an undecidable emptiness problem, as can be easily seen.

The key technique in our proofs is to consider words over call-return
alphabets as relational structures, called \emph{nested words} \cite{AlurM06}.
Nested words augment ordinary words with a nesting relation that, as the
logical atomic predicate mentioned above, relates push with corresponding pop
events. More precisely, we consider a nested word to be a graph whose nodes
are labeled with actions and are related in terms of a matching and an
immediate-predecessor relation. We thus deal with structures of bounded
degree: every node has at most two incoming edges (one from the immediate
predecessor and one from a push event if we deal with a pop event operating on
the non-empty stack) and, similarly, at most two outgoing edges. As there is a
one-to-one correspondence between words and their nested counterpart, we may
consider nested-word automata \cite{AlurM06}, which are equivalent to visibly
pushdown automata but operate on the enriched word structures. There have been
several notions of automata on graphs and partial orders
\cite{Tho-automata-ttp,ThoPOMIV96} that are similar to nested-word automata
and have one idea in common: the state that is taken after executing some
event depends on the states that have been visited in neighboring events. Such
defined automata may likewise operate on models for concurrent-systems
executions such as Mazurkiewicz traces \cite{Droste2000} and message sequence
charts \cite{BolligJournal}. In the framework of nested-word automata, to
determine the state after executing a pop operation, we therefore have to
consider both the state of the immediate-predecessor position and the state
that had been reached after the execution of the corresponding push event. To
obtain a logical characterization of nested-word automata over two stacks, we
adopt a technique from \cite{BolligJournal}: for a natural number , we
compute a nested-word automaton  that computes the \emph{sphere}
of radius  around any event , i.e., the restriction of the input
word to those events that have distance at most  from . Once we
have this automaton, we can apply Hanf's Theorem, which states that
satisfaction of a given first-order formula depends on the number of these
local spheres counted up to a threshold that depends on the quantifier-nesting
depth of the formula \cite{Hanf1965}. This finally leads us to a logical
characterization of 2-stack visibly pushdown automata in terms of existential
monadic second-order logic. Note that our construction of  is
close to the nontrivial technique applied in \cite{BolligJournal}. In the
context of nested words, however, the correctness proof is more complicated.
The fact that we deal with two stacks only is crucial, and the construction
fails as soon as a third stack comes into play.

Then, we exploit the concept of nested words to show that full monadic
second-order logic is more expressive than its existential fragment. This is
done by a first-order interpretation of nested words over two stacks into
grids, for which the analogous result has been known \cite{MST02}.

An extension of Hanf's Theorem has been established to cope with infinite
structures \cite{LSV:06:11}. This allows us to apply the automaton
 to also obtain a logical characterization of the canonical
extension of 2-stack visibly pushdown automata towards \Buchi automata running
on infinite words.

\paragraph{Outline of the paper} In Section~\ref{sec:MVPA}, we introduce
multi-stack visibly pushdown automata, running on words, as well as
multi-stack nested-word automata, which operate on nested words. We establish
expressive equivalence of these two models. Section~\ref{sec:MSO} recalls
monadic second-order logic over relational structures and, in particular,
nested words. There, we also state Hanf's Theorem, which provides a normal
form of first-order definable properties in terms of spheres. The construction
of the sphere automaton , which is, to some extent, the core
contribution of this paper, is the subject of Section~\ref{sec:sphereaut}. By
means of this automaton, we can show expressive equivalence of 2-stack visibly
pushdown automata and existential monadic second-order logic
(Section~\ref{subsect:maintheorem}). Section~\ref{sec:grids} establishes the
gap between this fragment and the full logic, from which we conclude that
2-stack visibly pushdown automata cannot be complemented in general. By
slightly modifying our logic, we obtain, in Section~\ref{sec:buechi}, a
characterization of \Buchi 2-stack visibly pushdown automata, running on
infinite words. We conclude with Section~\ref{sec:openproblems} stating some
related open problems.




\section{Multi-Stack Visibly Pushdown Automata}\label{sec:MVPA}

The set  of natural numbers is denoted by , the set
 of positive natural numbers by . We call any finite
set an \emph{alphabet}. For a set , we denote by ,
, and  the sets of finite, nonempty finite, and
infinite strings over , respectively.\footnote{From now on, to avoid
  confusion with nested words, we use the term ``string'' rather than ``word''
  if we deal with elements from .} The empty
string is denoted by . For a natural number , we let
 stand for the set  (i.e.,  is the empty set). In
this paper, we will identify isomorphic structures and we use  to
denote isomorphism.

Let  be a positive natural number. A (-stack)
\emph{call-return alphabet} is a collection
 of pairwise disjoint alphabets.
Intuitively,  contains the actions that call the stack
,  is the set of returns of stack , and
 is a set of internal actions, which do not involve any stack
operation.

We fix  and a -stack call-return alphabet
. Moreover, we set , , and .

\subsection{Multi-Stack Visibly Pushdown Automata}

\begin{defi}
  A \emph{multi-stack visibly pushdown automaton} (\MVPA) over  is a
  tuple  where
\begin{enumerate}[]
\item  is its finite set of \emph{states},
\item  is the set of \emph{initial states},
\item  is the set of \emph{final states},
\item  is the finite \emph{stack alphabet} containing a special symbol
   that will represent the empty stack, and
\item  provides the \emph{transitions} in terms of a triple 
  with

\end{enumerate}

A \emph{2-stack visibly pushdown automaton} () is an \MVPA that is
defined over a 2-stack alphabet (i.e., ).
\end{defi}

A transition , say with , is a
push transition meaning that, being in state , the automaton can read ,
push the symbol  onto the -th stack,
and go over to state . A transition , say with , allows us to pop  from the -th stack
when reading , while the control changes from state  to state . If,
however, , then the stack is not touched, i.e.,  is never
popped. Finally, a transition  is applied when reading
internal actions . They do not involve any stack operation
and, actually, do not even allow us to read from the stack.

Let us formalize the behavior of the \MVPA . A \emph{stack contents} is a
nonempty finite sequence from . The leftmost symbol is thus the top symbol of the stack
contents. A configuration of  consists of a state and a stack contents
for every stack. Hence, it is an element of .
Consider a string . A \emph{run} of  on
 is a sequence 
such that ,  for each stack , and, for all , the following hold:
\begin{enumerate}[\hbox to6 pt{\hfill}]
\item\noindent{\hskip-11 pt\bf [Push]:}\ If  for , then
  there is a stack symbol  such that
  , , and  for
  every .
\item\noindent{\hskip-11 pt\bf [Pop]:}\ If  for , then
  there is a stack symbol  such that ,  for every , and either  and
  , or  and
  .
\item\noindent{\hskip-11 pt\bf [Internal]:}\ If , then , and  for every .
\end{enumerate}
The run  is accepting if . A string  is
accepted by  if there is an accepting run of  on . The set of
accepted strings forms the (string) language of , which is a subset of
 and denoted by .\footnote{To simplify the presentation, the
  empty word  is excluded from the domain.}

\begin{exa}\label{ex:mvpa}
  There is no \MVPA that recognizes the context-sensitive language
  , no matter which call-return alphabet we chose.
  Note that, however, with the more general notion of a call-return alphabet
  from \cite{Murano2007}, it is possible to recognize this language by means
  of two stacks. Now consider the 2-stack call-return alphabet 
  given by , , , , and . The language
   can be recognized by
  some \tVPA over , even by the restricted model of 2-phase \tVPA
  from \cite{Madhusudan2007}, as every word from  can be split into at most
  two return phases. In the following, we define a \tVPA
  ,\bot\},\delta,\{q_0\},\{q_0\})\crSigmaL(\PA) = L^+\delta,q_2) & ~~~~~~ & \rdelta: & (q_3, \oa ,\,q_1) & & & (q_3, \oa ,\bot,q_4)\\
    & (q_1, a ,\,q_4)\\
    & (q_2, b,\(( a b)^+ \oa ^+ \ob ^+)^+a\oaa\}
\drawloop[loopCW=y,loopdiam=5,loopangle=180,ELside=l](q4){a,\}
\drawedge[ELside=l](q3,q4){}
\drawedge[ELside=l](q4,q0){}

\drawedge[curvedepth=2,ELside=l](q2,q1){a,\
  A ::= &~ aAb ~\mid~ AA ~\mid~ \varepsilon ~\mid~ c
\left\{
 \begin{array}{rll}
   (\rho(\mu^{-1}(i)),\rho(i-1),\lambda(i),\rho(i)) & \!\!\!\in \delta_2 &~~ \text{~if~}
   \mu^{-1}(i) \text{~is~defined}\\
   (\rho(i-1),\lambda(i),\rho(i)) & \!\!\!\in \delta_1 &~~ \text{~otherwise}
 \end{array}
\right.
 \hspace{-2em}\begin{array}{rlcrl}
    \delta_1: & (q_0, a ,q_2) & ~~~~~~ & \delta_2: & (q_2,q_3, \oa ,q_3) \\
    & (q_2, b ,q_1) & & & (q_3,q_4, \ob ,q_4)\\
    & (q_1, a ,q_2) & & & (q_1,q_4, \ob ,q_4)\\
    & (q_2, b ,q_3)\\
    & (q_3, \oa ,q_4)\\
    & (q_4, \ob ,q_0)
  \end{array}\overline{\textup{b}}'[\stack] = \left\{
    \begin{array}{cl}
      2 & ~~ \text{~if~} \overline{\textup{b}}[\stack] \in \{1,2\}\\
      1 & ~~ \text{~if~} \overline{\textup{b}}[\stack]  = 0 \text{~and~} a \in \cSigma^\stack
      \text{~and~} q' \in C\\
      0 & ~~ \text{~otherwise}
 \end{array}
\right.
\overline{\textup{b}}'[\stack] = \left\{
    \begin{array}{cl}
      0 & ~~ \text{~if~} \overline{\textup{c}}[\stack]  = 1\\
      \overline{\textup{b}}[\stack] & ~~ \text{~otherwise}
 \end{array}
\right.

  \phi ::= &~ P(x_1,\ldots,x_m) ~\mid~ x_1 = x_2 ~\mid~ x \in X ~\mid~ \neg
  \phi ~\mid~ \phi_1 \vee \phi_2 ~\mid~ \exists x \phi ~\mid~ \exists X \phi
\exists^{=t}x\, \chi(x) \text{~~~and~~~}
  \exists^{>t}x\, \chi(x)W \models \phi \text{~~~iff~~~} W \models \psi.\AllSpheres_\radius(\crSigma) := \{\Sph{\radius}{W}{i} \mid W \in
\NW(\crSigma) \text{~and~} i \text{~is a node of } W\}\,.\ncrSigma=\langle\{(\cSigma^1 \times 2^{[m]},\rSigma^1 \times
  2^{[m]}),(\cSigma^2 \times 2^{[m]},\rSigma^2 \times 2^{[m]})\},\intSigma
  \times 2^{[m]}\ranglewe set )
\item there is  such that, for every
  ,
  \\begin{array}{ccccccccccc} & & & & \!\!j_{\ell + 1} & \edge{E_i} & \ldots &
    \edge{E_i} & j_{d+1} & = & j\vspace{-1.2ex}\\ \gamma_i = j_0 \edge{E_i}
    & \ldots
    & \edge{E_i} j_\ell \!\!\!\!\! &
    \rotatebox{-45}{}\hspace{-1.5em}\rotatebox{45}{} &
    & & & & \rotatebox{-90}{\!\!\!\!\!\!\mbox{}} & &
    \vspace{-1.7ex}\\ & & & & \!\!j_{2(d+1)-\ell} & \edge{E_i} & \ldots & \edge{E_i}
    & j_{d+2} & = & j'
\end{array}
\modit(k) = \left\{
    \begin{array}{cl}
      k & ~~ \text{~if~} k \le D\\
      ((k - \ell) \mod (D - \ell + 1)) + \ell & ~~ \text{~if~} k > D
    \end{array}
\right.

e_k = \left\{
    \begin{array}{cl}
      \rightarrow & ~~ \text{~if~} j_k \succrel_i j_{\modit(k+1)}\\
      \leftarrow & ~~ \text{~if~} j_{\modit(k+1)} \succrel_i j_k\\
      \rightone & ~~ \text{~if~} \lambda_i(j_k) \in \cSigma^1 \text{~and~}
      (j_k,j_{\modit(k+1)}) \in \mu_i
      \text{~and~} j_k \not\succrel_i j_{\modit(k+1)}\\
      \leftone & ~~ \text{~if~} \lambda_i(j_k) \in \rSigma^1 \text{~and~}
      (j_{\modit(k+1)},j_k) \in \mu_i
      \text{~and~} j_{\modit(k+1)} \not\succrel_i j_k\\
      \righttwo & ~~ \text{~if~} \lambda_i(j_k) \in \cSigma^2 \text{~and~}
      (j_k,j_{\modit(k+1)}) \in \mu_i
      \text{~and~} j_k \not\succrel_i j_{\modit(k+1)}\\
      \lefttwo & ~~ \text{~if~} \lambda_i(j_k) \in \rSigma^2 \text{~and~}
      (j_{\modit(k+1)},j_k) \in \mu_i
      \text{~and~} j_{\modit(k+1)} \not\succrel_i j_k
    \end{array}
\right.
\Phi(G(n,m)) := \left\{
 \begin{array}{ll}
   \nested\Bigl(a^n \bigl[(\overline{a} b)^n (\overline{b}
   a)^n\bigr]^{(m-1)/2~}\overline{a}^n\Bigr) & \text{~if~}  m
   \text{~is~odd}\vspace{0.5ex}\\
   \nested\Bigl(a^n \bigl[(\overline{a} b)^n (\overline{b} a)^n\bigr]^{m/2-1}
   (\overline{a} b)^n \overline{b}~\!\!^n\Bigr)  & \text{~if~}  m \text{~is~even}
 \end{array}
\right.

\nodemap(i,j) = \left\{
  \begin{array}{ll}
      \pos_a(\Phi(G(n,m)),n \cdot [(j+1)/2 - 1] + i) & ~~ \text{~if~} j \text{~is~odd}\\
      \pos_b(\Phi(G(n,m)),n \cdot [j/2 - 1] + (n + 1 - i)) & ~~ \text{~if~} j \text{~is~even}
    \end{array}
\right.
\psi(x_1,x_2) = \mu(x_1,x_2)~.\tag{2}\Phi(G(n,m)) \models \psi[\fullmap(k_1,u_1),\fullmap(k_2,u_2)]
\text{~iff~} ((k_1,u_1),(k_2,u_2)) = ((1,u_1),(2,u_1))~.
\phi^{\lambda_c}_\kappa(x) = \left\{
    \begin{array}{cl}
      P_c(x) & ~~ \text{~if~} c \in \{a,b\} \text{~and~} \kappa = 1\\
      P_{\overline{c}}(x) & ~~ \text{~if~} c \in \{\overline{a},\overline{b}\} \text{~and~} \kappa = 2\\
      \mathit{false} & ~~ \text{~otherwise}
    \end{array}
  \right.\tag{3}
G(n,m) \models \phi^{\lambda_c}_\kappa(x)[u] \text{~iff~} \Phi(G(n,m))
\models (\lambda(x) = c)[\fullmap(\kappa,u)]~.
\phi^{\succord}_\kappa(x_1,x_2) = \left\{
    \begin{array}{cl}
      \succone(x_1,x_2) \mathrel{\wedge} \neg \exists z~ \succtwo(z,x_1) & ~~ \text{~if~} \kappa = (1,1)\\
      \left(\begin{array}{rl} & P_a(x_1) \mathrel{\wedge} \succone(x_2,x_1) \mathrel{\wedge} \neg
          \exists z~ \succtwo(x_1,z)\\
          \vee & P_b(x_1) \mathrel{\wedge} \succone(x_1,x_2) \mathrel{\wedge} \neg
          \exists z~ \succtwo(x_1,z)
        \end{array}\right) & ~~ \text{~if~} \kappa = (2,2)\\
      \left(\begin{array}{rl} & (x_1 = x_2) \mathrel{\wedge} P_a(x_1) 
          \mathrel{\wedge} \neg \exists z~ \succone(x_1,z)\\
          \vee & (x_1 = x_2) \mathrel{\wedge} P_b(x_1)
          \mathrel{\wedge} \neg \exists z~ \succone(z,x_1)\\
          \vee & P_a(x_1) \mathrel{\wedge} P_b(x_2)
          \mathrel{\wedge} \exists z~ (\succone(z,x_1) \mathrel{\wedge}  \succtwo(z,x_2))\\
          \vee & P_b(x_1) \mathrel{\wedge} P_a(x_2)
          \mathrel{\wedge} \exists z~ (\succone(z,x_1) \mathrel{\wedge}  \succtwo(x_2,z))
        \end{array}\right) & ~~ \text{~if~} \kappa = (1,2)\\
      \left(\begin{array}{rl} & P_a(x_1) \mathrel{\wedge} P_b(x_2)
          \mathrel{\wedge} \succtwo(x_1,x_2)\\ \vee & P_b(x_1) \mathrel{\wedge} P_a(x_2)
          \mathrel{\wedge} \succtwo(x_1,x_2)\end{array}\right) & ~~ \text{~if~} \kappa = (2,1)
    \end{array}
  \right.
G(n,m) \models \phi^{\succord}_\kappa(x_1,x_2)[u_1,u_2] \text{~iff~} \Phi(G(n,m))
\models (x_1 \succrel
x_2)[\fullmap(\kappa(1),u_1),\fullmap(\kappa(2),u_2)]~.
\phi^{\mu}_\kappa(x_1,x_2) = \left\{
    \begin{array}{cl}
      x_1 = x_2 & ~~ \text{~if~} \kappa = (1,2)\\
      \mathit{false} & ~~
      \text{~otherwise}
    \end{array}
  \right.
G(n,m) \models \phi^{\mu}_\kappa(x_1,x_2)[u_1,u_2] \text{~iff~} \Phi(G(n,m))
\models (\mu(x_1,x_2))[\fullmap(\kappa(1),u_1),\fullmap(\kappa(2),u_2)]~.\phi^{P_a}(x) = (\lambda(x) = a) \text{~~and~~} \phi^{P_b}(x) = (\lambda(x)
= b)~.\tag{4}G(n,m) \models P_c(x)[u] \text{~iff~} \Phi(G(n,m))
\models (\phi^{P_c})[\fullmap(1,u)]~.\phi^{\succone}(x_1,x_2) = \left(\begin{array}{rl} & \lambda(x_1) = a
    \mathrel{\wedge} \lambda(x_2) = a
    \mathrel{\wedge} (x_1 \succrel x_2 \mathrel{\vee} \exists z~ (x_1 \succrel z
    \mathrel{\wedge} z \succrel x_2))\\ \vee & \lambda(x_1) = b
    \mathrel{\wedge} \lambda(x_2) = b
    \mathrel{\wedge} \exists z~ (x_2 \succrel z
    \mathrel{\wedge} z \succrel x_1) \end{array}\right)\phi^{\succtwo}(x_1,x_2) = \exists z~(\mu(x_1,z) \mathrel{\wedge} z \succrel
x_2)~.G(n,m) \models \succk(x_1,x_2)[u_1,u_2] \text{~iff~} \Phi(G(n,m)) \models
(\phi^{\succk})[\fullmap(1,u_1),\fullmap(1,u_2)]~.\begin{array}{rrl} \forall x_1,x_2,y_1,y_2~ \Bigl( & & \lambda(x_1) =
  \lambda(x_2) \mathrel{\wedge} \mu(x_1,y_1) \mathrel{\wedge} \mu(x_2,y_2)\\
  & \rightarrow &
\begin{array}[t]{rl}
  &  \bigl(\lambda(x_1) = a \mathrel{\wedge} x_2 - x_1 = 1 ~\mathrel{\rightarrow}~ y_1 - y_2 \in \{1,2\} \bigr)\\
  \wedge &  \bigl(\lambda(y_1) = \overline{a} \mathrel{\wedge} y_1 - y_2 = 1
  ~\mathrel{\rightarrow}~ x_2 - x_1 \in \{1,2\} \bigr)\\
  \wedge &  \bigl(\lambda(y_1) = \overline{b} \mathrel{\wedge} y_1 - y_2 = 1
  ~\mathrel{\rightarrow}~ x_2 - x_1 = 2 \bigr)\\
  \wedge &  \bigl(x_2 - x_1 = 2 \mathrel{\wedge} \lambda(x_1 + 1) \neq \lambda(x_1)
  ~\mathrel{\rightarrow}~ y_1 - y_2 \in \{1,2\} \bigr)\\
  \wedge &  \bigl(y_1 - y_2 = 2 \mathrel{\wedge} \lambda(y_2 + 1) \neq \lambda(y_2)
  ~\mathrel{\rightarrow}~ x_2 - x_1 \in \{1,2\} \bigr)\Bigr)
\end{array}
\end{array}\left\{
 \begin{array}{rll}
   (\rho(\mu^{-1}(i)),\rho(i-1),\lambda(i),\rho(i)) & \!\!\!\in \delta_2 &~~ \text{~if~}
   \lambda(i) \in \rSigma \text{~and~} \mu^{-1}(i) \text{~is~defined}\\
   (\rho(i-1),\lambda(i),\rho(i)) & \!\!\!\in \delta_1 &~~ \text{~otherwise}
 \end{array}
\right.
 
  \phi ::= &~ \lambda(x)=a ~\mid~ \succ{x}{y} ~\mid~ \mu(x,y) ~\mid~ x = y ~\mid~ x \in X ~\mid~ \\
  &~ \neg \phi ~\mid~ \phi_1 \vee \phi_2 ~\mid~ \exists x \phi ~\mid~
  \exists^\infty x \phi ~\mid~ \exists X \phi
\exists^{=t}x\, \chi(x)
  \text{~~~and~~~} \exists^{>t}x\, \chi(x) \text{~~~and~~~}
  \exists^{<\infty}x\, \chi(x) \text{~~~and~~~} \exists^{=\infty}x\, \chi(x)W \models \phi \text{~~~iff~~~} W \models \psi.2{ETIME}-complete.
\newblock In {\em {P}roceedings of the 12th {I}nternational {C}onference on
  {D}evelopments in {L}anguage {T}heory (DLT 2008)}, volume 5257 of {\em
  Lecture Notes in Computer Science}, pages 121--133. Springer, 2008.

\bibitem{LSV:06:11}
B.~Bollig and D.~Kuske.
\newblock {M}uller message-passing automata and logics.
\newblock {\em Information and Computation}, 206(9-10):1084--1094, 2008.

\bibitem{BolligJournal}
B.~Bollig and M.~Leucker.
\newblock Message-passing automata are expressively equivalent to {EMSO} logic.
\newblock {\em Theoretical Computer Science}, 358(2-3):150--172, 2006.

\bibitem{multi96}
L.~Breveglieri, A.~Cherubini, C.~Citrini, and S.~{Crespi Reghizzi}.
\newblock Multi-push-down languages and grammars.
\newblock {\em International Journal of Foundations of Computer Science},
  7(3):253--292, 1996.

\bibitem{Buechi:60}
J.~B{\"u}chi.
\newblock Weak second order logic and finite automata.
\newblock {\em Z. Math. Logik Grundlag. Math.}, 5:66--62, 1960.

\bibitem{Murano2007}
D.~Carotenuto, A.~Murano, and A.~Peron.
\newblock 2-visibly pushdown automata.
\newblock In {\em Proceedings of the 11th International Conference on
  Developments in Language Theory (DLT 2007)}, volume 4588 of {\em Lecture
  Notes in Computer Science}, pages 132--144. Springer, 2007.

\bibitem{Droste2000}
M.~Droste, P.~Gastin, and D.~Kuske.
\newblock Asynchronous cellular automata for pomsets.
\newblock {\em Theoretical Computer Science}, 247(1-2):1--38, 2000.

\bibitem{Elgot1961}
C.~C. Elgot.
\newblock Decision problems of finite automata design and related arithmetics.
\newblock {\em Trans. Amer. Math. Soc.}, 98:21--52, 1961.

\bibitem{Hanf1965}
W.~Hanf.
\newblock Model-theoretic methods in the study of elementary logic.
\newblock In J.~W. Addison, L.~Henkin, and A.~Tarski, editors, {\em The Theory
  of Models}. North-Holland, Amsterdam, 1965.

\bibitem{Hopcroft2000}
J.~E. Hopcroft, R.~Motwani, and J.~D. Ullman.
\newblock {\em Introduction to Automata Theory, Languages and Computability}.
\newblock Addison-Wesley, 2000.

\bibitem{Madhusudan2007}
S.~{La Torre}, P.~Madhusudan, and G.~Parlato.
\newblock A robust class of context-sensitive languages.
\newblock In {\em Proceedings of the 22nd IEEE Symposium on Logic in Computer
  Science (LICS 2007)}, pages 161--170. IEEE Computer Society Press, 2007.

\bibitem{TACAS08}
S.~{La Torre}, P.~Madhusudan, and G.~Parlato.
\newblock Context-bounded analysis of concurrent queue systems.
\newblock In {\em Proceedings of the 14th International Conference on Tools and
  Algorithms for the Construction and Analysis of Systems (TACAS 2008)},
  Lecture Notes in Computer Science, pages 299--314. Springer, 2008.

\bibitem{Schwentick94}
C.~Lautemann, Th. Schwentick, and D.~Therien.
\newblock Logics for context-free languages.
\newblock In {\em {Proceedings of the 1994 Annual Conference of the European
  Association for Computer Science Logic (CSL 1994)}}, volume 933 of {\em
  Lecture Notes in Computer Science}, pages 205--216, 1995.

\bibitem{Libkin2004}
L.~Libkin.
\newblock {\em {E}lements of {F}inite {M}odel {T}heory}.
\newblock Springer, 2004.

\bibitem{MST02}
O.~Matz, N.~Schweikardt, and W.~Thomas.
\newblock The monadic quantifier alternation hierarchy over grids and graphs.
\newblock {\em Information and Computation}, 179(2):356--383, 2002.

\bibitem{ThoPOMIV96}
W.~Thomas.
\newblock Elements of an automata theory over partial orders.
\newblock In {\em Proceedings of Workshop on Partial Order Methods in
  Verification (POMIV 1996)}, volume~29 of {\em DIMACS}. AMS, 1996.

\bibitem{Tho-automata-ttp}
W.~Thomas.
\newblock Automata theory on trees and partial orders.
\newblock In {\em Proceedings of Theory and Practice of Software Development
  (TAPSOFT 1997), 7th International Joint Conference CAAP/FASE}, volume 1214 of
  {\em Lecture Notes in Computer Science}, pages 20--38. Springer, 1997.

\bibitem{Tho97handbook}
W.~Thomas.
\newblock Languages, automata and logic.
\newblock In A.~Salomaa and G.~Rozenberg, editors, {\em Handbook of Formal
  Languages}, volume 3, Beyond Words, pages 389--455. Springer, 1997.

\end{thebibliography}





















\end{document}
