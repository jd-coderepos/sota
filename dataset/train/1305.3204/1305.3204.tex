\documentclass{llncs}

\usepackage{pslatex,amssymb,pgf,tikz,lscape,amsmath,cite,mathrsfs,latexsym}
\usetikzlibrary{arrows,automata}

\bibliographystyle{alpha}
\newcommand{\Fig}[1]{Figure \ref{fig:#1}}
\newenvironment{Ref}{\smallskip \noindent {\sc References}\\ \small }{}

\newcommand{\step}[1]{\mbox{}}
\newcommand{\Step}[2]{\mbox{~~}}

\newcommand{\fif}{\rmiff}
\newcommand{\rmall}{\mathrel{\mbox{for all}~}}
\newcommand{\rmsome}{\mathrel{\mbox{for some}~}}
\newcommand{\rmand}{\mathbin{~\mbox{and}~}}
\newcommand{\rmiff}{\mathbin{~\mbox{iff}~}}

\newcommand{\ul}{\underline}
\newcommand{\concept}{\textbf}
\newcommand{\name}{\textsf}
\newcommand{\class}{\textsc}
\newcommand{\auth}{\textsf}
\newcommand{\book}{\textit}
\newcommand{\homepage}{\tt http://}
\newcommand{\jour}{\textsl}
\newcommand{\vol}{}
\newcommand{\nr}[1]{(#1)}
\newcommand{\edt}[1]{(\auth{#1}, ed.)}
\newcommand{\eds}[1]{(\auth{#1}, eds.)}
\newcommand{\pub}[2]{ (#1, #2)}
\newcommand{\yr}[1]{, #1}
\newcommand{\pp}[2]{, #1--#2}

\newcommand{\defn}{\mathrel{\mbox{}}}
\newcommand{\true}{\top}
\newcommand{\false}{\bot}
\newcommand{\undef}{\textbf{u}}
\newcommand{\tv}{\textbf{t}}
\newcommand{\fv}{\textbf{f}}
\newcommand{\limplies}{\supset}
\newcommand{\eqvt}{\Leftrightarrow}
\newcommand{\lcompl}{\overline}
\newcommand{\capover}{{\displaystyle \bigcap}}
\newcommand{\cupover}{{\displaystyle \bigcup}}
\newcommand{\sumover}[1]{{\displaystyle \Sigma_{#1}}}
\newcommand{\orover}{{\displaystyle \bigvee}}
\newcommand{\andover}{{\displaystyle \bigwedge}}
\newcommand{\eps}{\varepsilon}
\newcommand{\Lt}{\leftarrow}
\newcommand{\Rt}{\to}


\newcommand{\Bhat}{\mbox{}}

\newcommand{\alphbt}{\mbox{}}
\newcommand{\Arho}{\mbox{}}

\newcommand{\calB}{{\mathcal B}}
\newcommand{\calH}{{\mathcal H}}
\newcommand{\calR}{{\mathcal R}}
\newcommand{\calL}{{\mathcal L}}
\newcommand{\calJ}{{\mathcal J}}
\newcommand{\nR}{\mbox{}}
\newcommand{\eH}{\mbox{}}
\newcommand{\eR}{\mbox{}}
\newcommand{\eL}{\mbox{}}
\newcommand{\eJ}{\mbox{}}
\newcommand{\gR}{\mbox{}}
\newcommand{\lR}{\mbox{}}
\newcommand{\gL}{\mbox{}}
\newcommand{\gJ}{\mbox{}}
\newcommand{\gtJ}{\mbox{}}
\newcommand{\lJ}{\mbox{}}

\newcommand{\suc}{\mbox{}}
\newcommand{\incr}[2]{\mbox{}}
\newcommand{\num}{\mathit{Num}}
\newcommand{\nodes}{\mbox{}}
\newcommand{\mnodes}{\mbox{}}
\newcommand{\lnodes}{\mbox{}}
\newcommand{\rnodes}{\mbox{}}
\newcommand{\handle}{\mbox{}}
\newcommand{\lhandle}{\mbox{}}
\newcommand{\rhandle}{\mbox{}}
\newcommand{\anc}{\mbox{}}
\newcommand{\lanc}{\mbox{}}
\newcommand{\ranc}{\mbox{}}
\newcommand{\pat}{\mbox{}}
\newcommand{\lpat}{\mbox{}}
\newcommand{\rpat}{\mbox{}}
\newcommand{\extend}{\mbox{}}
\newcommand{\lprop}{\mbox{}}
\newcommand{\rprop}{\mbox{}}
\newcommand{\lskip}{\mbox{}}
\newcommand{\rskip}{\mbox{}}
\newcommand{\rchg}{\mbox{}}
\newcommand{\opr}{\mbox{}}
\newcommand{\sub}{\mbox{}}
\newcommand{\intv}{\mbox{}}
\newcommand{\val}{\mbox{}}
\newcommand{\pos}{\mbox{}}
\newcommand{\lpos}{\mbox{}}
\newcommand{\cpos}{\mbox{}}
\newcommand{\rpos}{\mbox{}}
\newcommand{\until}{\textsf{U}}
\newcommand{\since}{\textsf{S}}
\newcommand{\fut}{\textsf{F}}
\newcommand{\past}{\textsf{P}}
\newcommand{\nextt}{\textsf{X}}
\newcommand{\prev}{\textsf{Y}}
\newcommand{\nexta}{\mbox{}}
\newcommand{\preva}{\mbox{}}
\newcommand{\ltl}{\mbox{}}
\newcommand{\ltlbin}{\mbox{\/}}
\newcommand{\ltlun}{\mbox{\/}}
\newcommand{\ltlunsuc}{\mbox{\/}}
\newcommand{\ltlunfut}{\mbox{\/}}
\newcommand{\point}{\mathit{pt}}
\newcommand{\unit}{\mathit{unit}}
\newcommand{\duringa}{\during{a}}
\newcommand{\prefix}{\mbox{}}
\newcommand{\suffix}{\mbox{}}
\newcommand{\prefpt}{\mbox{}}
\newcommand{\sufpt}{\mbox{}}
\newcommand{\after}{\mbox{}}
\newcommand{\before}{\mbox{}}
\newcommand{\rightext}{\mbox{}}
\newcommand{\leftext}{\mbox{}}
\newcommand{\chopp}[1]{\mbox{}}
\newcommand{\chopa}{\chopp{a}}
\newcommand{\chopu}{\chopp{u}}
\newcommand{\first}[1]{\mbox{}}
\newcommand{\firstp}[1]{\mbox{}}
\newcommand{\firstm}[1]{\mbox{}}
\newcommand{\last}[1]{\mbox{}}
\newcommand{\lastp}[1]{\mbox{}}
\newcommand{\lastm}[1]{\mbox{}}
\newcommand{\firsta}{\first{a}}
\newcommand{\firstu}{\first{u}}
\newcommand{\firstpa}{\firstp{a}}
\newcommand{\firstma}{\firstm{a}}
\newcommand{\firstuav}{\first{u\underline{a}v}}
\newcommand{\lasta}{\last{a}}
\newcommand{\lastu}{\last{u}}
\newcommand{\lastpa}{\lastp{a}}
\newcommand{\lastma}{\lastm{a}}
\newcommand{\lastuav}{\last{u\underline{a}v}}
\newcommand{\itl}{\mbox{}}
\newcommand{\uitl}{\mbox{}}
\newcommand{\unl}{\mbox{}}
\newcommand{\uptl}{\mbox{}}
\newcommand{\hs}{\mbox{}}
\newcommand{\fo}{\mbox{}}
\newcommand{\fosuc}{\mbox{\/}}
\newcommand{\foless}{\mbox{\/}}
\newcommand{\fotwo}{\mbox{\/}}
\newcommand{\fotwoless}{\mbox{\/}}
\newcommand{\fothree}{\mbox{\/}}
\newcommand{\fop}{\mbox{\/}}
\newcommand{\fotwosuc}{\mbox{\/}}
\newcommand{\fosuctwo}{\mbox{\/}}
\newcommand{\bless}[1]{\mbox{\/}}
\newcommand{\deltatwo}{\mbox{\/}}
\newcommand{\deltathree}{\mbox{\/}}
\newcommand{\deltaless}[1]{\mbox{\/}}
\newcommand{\pitwo}{\mbox{\/}}
\newcommand{\pitwosuc}{\mbox{\/}}
\newcommand{\sigmatwo}{\mbox{\/}}
\newcommand{\sigmatwoless}{\mbox{\/}}
\newcommand{\sigmatwosuc}{\mbox{\/}}
\newcommand{\btwoless}{\mbox{\/}}
\newcommand{\deltatwosuc}{\mbox{\/}}
\newcommand{\deltatwoless}{\mbox{\/}}
\newcommand{\pitwoless}{\mbox{\/}}
\newcommand{\sigmaone}{\mbox{\/}}
\newcommand{\sigmaonesuc}{\mbox{\/}}


\newcommand{\tran}{\mbox{}}
\newcommand{\tranp}{\mbox{}}
\newcommand{\tranm}{\mbox{}}
\newcommand{\tranlr}[2]{\mbox{}}
\newcommand{\tranl}[1]{\mbox{}}
\newcommand{\tranb}{\tranl{x}}
\newcommand{\tranbe}{\tranlr{\beta}{\eps}}
\newcommand{\midpt}{\mbox{}}
\newcommand{\midlr}[2]{\mbox{}}
\newcommand{\midbe}{\midlr{\beta}{\eps}}
\newcommand{\mtran}{\mbox{}}
\newcommand{\mtranlr}[2]{\mbox{}}
\newcommand{\mtranbe}{\mtranlr{\beta}{\eps}}

\newcommand{\aut}{{\mathcal M}}
\newcommand{\reachl}[1]{{\mathcal L}(#1)}
\newcommand{\reachr}[1]{{\mathcal R}(#1)}
\newcommand{\match}{{\mathcal C}}
\newcommand{\matchl}{\mbox{}}
\newcommand{\matchr}{\mbox{}}
\newcommand{\autadlr}[4]{\mbox{}}
\newcommand{\autadbe}{\autadlr{B}{d}{\beta}{\eps}}
\newcommand{\autalbe}{\autadlr{B}{\Lt}{\beta}{\eps}}
\newcommand{\autarbe}{\autadlr{B}{\Rt}{\beta}{\eps}}
\newcommand{\autalr}[3]{\mbox{}}
\newcommand{\autabe}{\autalr{B}{\beta}{\eps}}
\newcommand{\matchb}{\mbox{}}
\newcommand{\matche}{\mbox{}}
\newcommand{\POTDFAO}{\mbox{}}
\newcommand{\POTDFA}{\mbox{}}
\newcommand{\fscan}[2]{#1 \stackrel{#2}{\rightarrow}}
\newcommand{\bscan}[2]{#1 \stackrel{#2}{\leftarrow}}
\newcommand{\funit}[1]{1 \stackrel{#1}{\rightarrow}}
\newcommand{\bunit}[1]{1 \stackrel{#1}{\leftarrow}}
\newcommand{\sem}[1]{ #1 }
\newcommand{\BMCITL}{\uitl}

\newcommand{\oomit}[1]{}
\newcommand{\df}{\defn}
\newcommand{\st}{.~}
\newcommand{\pti}{\mathit{pt}}
\newcommand{\ptp}[1]{\lceil #1 \rceil^0}
\newcommand{\alp}[1]{\lceil #1 \rceil^*}
\newcommand{\ali}[1]{\lceil #1 \rceil^+}

\newcommand{\lcceil}{\hbox{}}
\newcommand{\rcceil}{\hbox{}}
\newcommand{\aloo}[1]{\lceil #1 \rceil}
\newcommand{\alcc}[1]{\lcceil #1 \rcceil}
\newcommand{\aloc}[1]{\lceil #1 \rcceil}
\newcommand{\alco}[1]{\lcceil #1 \rceil}
\newcommand{\alcom}[1]{\lcceil #1 \rceil^-}
\newcommand{\alcod}{\alco{\lnot d}}
\newcommand{\alccd}{\alcc{\lnot d}}
\newcommand{\alunit}[1]{\aloo{#1}^1}
\newcommand{\alcunit}[1]{\alco{#1}^1}




\newcommand{\BMCITLPL}{\mbox{}}
\newcommand{\follow}{\, \stackrel{\rightarrow}{\bigcirc} \,}
\newcommand{\precede}{\, \stackrel{\leftarrow}{\bigcirc} \,}

\newcommand{\fsearch}[1]{\stackrel{#1}{\rightarrow}}
\newcommand{\bsearch}[1]{\stackrel{#1}{\leftarrow}}
\newcommand{\fstep}{\stackrel{1}{\rightarrow}}
\newcommand{\bstep}{\stackrel{1}{\leftarrow}}
\newcommand{\chop}{\frown}
\newcommand{\rend}{\triangleleft}
\newcommand{\lend}{\triangleright}
\newcommand{\lnode}{n_{\lend}}
\newcommand{\rnode}{n_{\rend}}

\newcommand{\litl}{LITL}
\newcommand{\pt}{pt}
\newcommand{\potdfal}{PO2DFAL}
\newcommand{\nmatchesf}[3]{(#1[#2,*] \not= #3) }
\newcommand{\nmatchesb}[3]{(#1[*,#2] \not= #3)}
\newcommand{\ndiamondf}{\stackrel{\rightarrow}{\Diamond}}
\newcommand{\ndiamondb}{\stackrel{\leftarrow}{\Diamond}}
\newcommand{\smartqed}



\newcommand{\succr}{\oplus}
\newcommand{\predr}{\ominus}
\newcommand{\hand}{H}
\newcommand{\lchg}{\mbox{}}
\newcommand{\ure}{{\em unambiguous monomial}}
\newcommand{\anf}{ANF}
\newcommand{\snd}{SND}
\newcommand{\psnd}{pointed-SND}
\newcommand{\prsnd}{Propagated-SND}
\newcommand{\scp}{Scope_w}


\newcommand{\potdla}{{\mbox{}}}
\newcommand{\str}[1]{\mbox{}}
\newcommand{\uu}{\mathcal U}
\newcommand{\vv}{\mathcal V}
\newcommand{\Sigbar}{\overline{\Sigma}}
\newcommand{\abar}{\overline{a}}
\newcommand{\lmatch}{\models_L}
\newcommand{\rmatch}{\models_R}
\newcommand{\pre}[1]{Pre({#1})}
\newcommand{\suf}[1]{Suf({#1})}
\newcommand{\matchesf}[3]{({#1}[{#2},*]={#3})}
\newcommand{\matchesb}[3]{({#1}[*,{#2}]={#3})}
\newcommand{\matchesbf}[3]{({#1}[*,{#2},*]={#3})}
\newcommand{\nmatchesbf}[3]{({#1}[*,{#2},*]\neq{#3})}
\newcommand{\ndiamond}{\overline{\Diamond}}
\newcommand{\faut}[1]{\lceil\vert{#1}\vert\rceil}

\newcommand{\eqm}{\equiv_M}
\newcommand{\edg}{\mathcal E_M}
\newcommand{\epos}{pos_M}
\newcommand{\merger}{{\em merger}}


\newcommand{\ETE}{ETE}

\newcommand{\ap}{\mbox{}}
\newcommand{\tss}{\mbox{}}
\newcommand{\tw}{\mbox{}}
\newcommand{\mtlus}{\mbox{}}
\newcommand{\mtlfp}{\mbox{}}
\newcommand{\mitlus}{\mbox{}}
\newcommand{\bmtlus}{\mbox{}}
\newcommand{\bmtlfp}{\mbox{}}
\newcommand{\mitlfp}{\mbox{}}
\newcommand{\bmitlus}{\mbox{}}
\newcommand{\bmitlfp}{\mbox{}}
\newcommand{\tptlus}{\mbox{}}
\newcommand{\tptlfp}{\mbox{}}
\newcommand{\tptlf}{\mbox{}}

\newcommand{\potdta}{\mbox{}}
\newcommand{\tuitl}{\mbox{}}
\newcommand{\tuil}{\tuitl}
\newcommand{\DHTL}{\mbox{}}
\newcommand{\unite}{\otimes}
\newcommand{\cmodels}{\models_{\nu}}
\newcommand{\dep}{Depth}
\newcommand{\frz}{Freeze}
\newcommand{\tete}{Timed-ETE}
\newcommand{\ges}{Guarded-Event-Set}
\newcommand{\autm}{\mathcal A}
\newcommand{\tutl}{\mtlfp}
\newcommand{\Ututl}{\mitlfp}
\newcommand{\Btutl}{\bmitlfp}
\newcommand{\ubil}{\bmitlfp}
\newcommand{\diamplus}{\overrightarrow{\diamond}}
\newcommand{\diamminus}{\overleftarrow{\diamond}}
\newcommand{\diampm}{\overline{\diamond}}
\newcommand{\bool}{\mathcal B}
\newcommand{\potdfa}{\POTDFA}
\newcommand{\twodta}{\mbox{}}
\newcommand{\RBTDTA}{\mbox{}}
\newcommand{\gef}{Guarded-Event-Function}

\newcommand{\stl}{\mbox{}}
\newcommand{\stls}{\mbox{}}
\newcommand{\conc}{\mathcal C}
\newcommand{\utl}{\mbox{}}
\newcommand{\pnf}{\textit{normal form}}
\newcommand{\nf}{normal form}
\newcommand{\gabar}[1]{G_{\overline{#1}}}
\newcommand{\habar}[1]{H_{\overline{#1}}}
\newcommand{\untl}{\mbox{}}
\newcommand{\mmr}{\mbox{}}
\newcommand{\mmtl}{\mbox{}}
\newcommand{\ete}{\mbox{}}
\newcommand{\sdef}[2]{^{#1}_{\subseteq{#2}}}
\newcommand{\Dp}[1]{\mathcal D_w^{{#1}}}
\newcommand{\Fp}[1]{\mathcal F_w^{{#1}}}
\newcommand{\Lp}[1]{\mathcal L_w^{{#1}}}

\newcommand{\ttl}{\mbox{}}

\newcommand{\ssp}{\mbox{}}
\newcommand{\ddp}{\mbox{}}
\newcommand{\aaa}{\mathcal A}
\newcommand{\bbb}{\mathcal B}
\newcommand{\lra}{\leftrightarrow}
\newcommand{\gameeq}[1]{\approx_{#1}}
\newcommand{\formeq}[1]{\equiv_{#1}}


\newcommand{\maxint}{\mbox{}}

\newcommand{\form}{\mathcal F}
\newcommand{\dir}{D}

\newcommand{\diff}{\approx}


\newcommand{\ttlxy}{\mbox{}}
\newcommand{\mtlu}{\mbox{}}
\newcommand{\mtlf}{\mbox{}}
\newcommand{\tptlu}{\mbox{}}


\newcommand{\rlpos}{{\mathbb{R}_{0}}}
\newcommand{\qpos}{{\mathbb{Q}_{0}}}
\newcommand{\zpos}{{\mathbb{Z}_{0}}}
\newcommand{\zsem}{{\mathbb{Z}}}
\newcommand{\cvalspace}{{\mathbb{R}_{0}^C}}

\newcommand{\INTV}{\mbox{}}
\newcommand{\zintv}{\mathbb{Z}I}
\newcommand{\extintv}{\mathbb{Z}IExt}
\newcommand{\bintv}{Bd\mathbb{Z}I}
\newcommand{\bextintv}{Bd\mathbb{Z}IExt}
\newcommand{\deltabar}{{\overline{\delta}}}


\newcommand{\sttl}{\mbox{}}
\newcommand{\sttls}{\mbox{}}
\newcommand{\weakx}[1]{\widetilde{X}_{#1}} 
\newcommand{\weaky}[1]{\widetilde{Y}_{#1}}
\newcommand{\xunit}{X_1}
\newcommand{\yunit}{Y_1}
\newcommand{\pfless}{\mathcal P^{<}}
\newcommand{\pfleq}{\mathcal P^{\leq}}
\newcommand{\pfgreat}{\mathcal P^{>}}
\newcommand{\pfgeq}{\mathcal P^{\geq}}


\newcommand{\stuitl}{\mbox{}}
\newcommand{\stfirst}[1]{\overline{F}_{#1}}
\newcommand{\stlast}[1]{\overline{L}_{#1}}
\newcommand{\lalpha}{\alpha_L}
\newcommand{\ralpha}{\alpha_R}
\newcommand{\spf}{\mbox{}}
\newcommand{\scf}{\mbox{}}

\newcommand{\tlxy}{\mbox{}}
\newcommand{\mitlf}{\mbox{}}
\newcommand{\mitlp}{\mbox{}}
\newcommand{\mitlfpinf}{\mbox{}}
\newcommand{\mitlusinf}{\mbox{}}
\newcommand{\mitlfpb}{\bmitlfp}
\newcommand{\mtlusb}{\bmtlus}
\newcommand{\mitlfb}{\mbox{}}
\newcommand{\potdtar}{\mbox{}}
\newcommand{\mitl}{\mbox{}}
\newcommand{\tptl}{\mbox{}}
\newcommand{\mtl}{\mbox{}}
\newcommand{\ltlus}{\mbox{}}
\newcommand{\ltlfp}{\mbox{}}
\newcommand{\mitluszinf}{\mbox{}}
\newcommand{\mitlfpzinf}{\mbox{}}
\newcommand{\mitlfzinf}{\mbox{}}
\newcommand{\mitlfinf}{\mbox{}}
\newcommand{\mitlfpz}{\mbox{}}
\newcommand{\mitlfz}{\mbox{}}
\newcommand{\mitlfbz}{\mbox{}}


\newcommand{\pspace}{\mbox{}}
\newcommand{\expspace}{\mbox{}}
\newcommand{\nexptime}{\mbox{}}
\newcommand{\conp}{\mbox{}}
\newcommand{\np}{\mbox{}}
\newcommand{\nexp}{\mbox{}}

\newcommand{\tul}{\mbox{}}


\newcommand{\uintv}[1]{ \hat{#1}}

\newcommand{\idx}{\mathit{Idx}}
\newcommand{\frst}{{\mathcal F}}
\newcommand{\lst}{{\mathcal L}}

\newcommand{\rbtdta}{\mbox{}}

\newcommand{\rectl}{\mbox{}}
\newcommand{\tlrecr}{\mbox{}}
\newcommand{\detltl}{\mbox{}}
\newcommand{\detuntil}[1]{\mbox{}}
\newcommand{\detsince}[1]{\mbox{}}
\newcommand{\bl}{\mbox{}}
\newcommand{\af}{\mbox{}}
\newcommand{\at}{\mbox{}}
\newcommand{\uitlpm}{\mbox{}}

\newcommand{\tab}{\hspace*{1cm}}
\newcommand{\leafn}{\mathit{Leaf}}
\newcommand{\dfnd}{\mathit{Def}}

\newcommand{\srchr}{\mbox{}}
\newcommand{\srchl}{\mbox{}}
\newcommand{\rwithin}{\mbox{}}
\newcommand{\lwithin}{\mbox{}}

\newcommand{\mtluss}{\mbox{}}
\newcommand{\mtluc}{\mbox{}}
\newcommand{\mtlusc}{\mbox{}}
\newcommand{\mitlusc}{\mbox{}}
\newcommand{\mtlfpc}{\mbox{}}
\newcommand{\mtlussc}{\mbox{}}
\newcommand{\mitlussc}{\mbox{}}
\newcommand{\mtluspw}{\mbox{}}
\newcommand{\mtlupw}{\mbox{}}
\newcommand{\mtlusspw}{\mbox{}}
\newcommand{\tptlusc}{\mbox{}}
\newcommand{\tptluspw}{\mbox{}}


\newcommand{\Conv}{\mathit{Conv}}
\newcommand{\Rank}{\mathit{Ranker}}


\newcommand{\da}{\mbox{}} 

\begin{document}
\title{The Unary Fragments of Metric Interval Temporal Logic: Bounded versus Lower bound Constraints\\ (Full Version)}
\author{Paritosh K.~Pandya and Simoni S.~Shah}
\institute{Tata Institute of Fundamental Research,
Colaba, Mumbai \textit{400005}, India}
\pagestyle{empty} 

\maketitle

\begin{abstract}
\footnote{This is the full version of the paper of the same name presented at ATVA, 2012 (doi: 10.1007/978-3-642-33386-6)}
We study two unary fragments of the well-known metric interval temporal logic  that was
originally proposed by Alur and Henzinger, and we pin down their expressiveness
as well as satisfaction complexities. We show that  which has unary
modalities with only lower-bound constraints is (surprisingly) expressively complete for Partially Ordered 2-Way Deterministic Timed Automata () and the reduction from logic to automaton gives us its NP-complete satisfiability. We also show that the fragment  having unary modalities with only bounded intervals has \nexptime-complete satisfiability. But strangely, 
\mitlfpb\/ is strictly less expressive than \mitlfpinf. 
We provide a comprehensive picture of the decidability and expressiveness of various unary fragments of \mitl.
\end{abstract}


\section{Introduction}
Temporal logics are a well known notation for specifying properties of reactive systems.
Reductions between temporal logics and finite state automata have been very influential in formulating decision procedures and model checking of temporal logic properties. 
However, extending this paradigm to real-time logics and timed automata has been challenging.


Metric Temporal Logic  is a well established logic for specifying quantitative properties of  timed behaviors in real-time. 
In this logic, the temporal modalities  and  are time constrained by a time interval . 
A formula  holds at a position  provided
there exists a strictly later position  where  holds and  must hold for all in between positions. Moreover the ``time distance'' between  and  must be in the interval . 
Interval  has integer valued endpoints  and it can be open, closed, half open, or singular (i.e. ). It can even be unbounded, i.e. of the form .  Unary modalities  and  can be defined as  and  , respectively. 
Unfortunately, satisfiability of  formulae and their model checking (against timed automata) are both undecidable in general \cite{AH93,Hen91}.

In their seminal paper \cite{AFH96}, the authors proposed the sub logic  having only non-punctual (or non-singular) intervals.  Alur and Henzinger \cite{AFH96,AH92} showed that the logic \mitlus\/ has \expspace-complete satisfiability\footnote{This assumes that the time constants occurring in the formula are written in binary. We follow the same convention throughout this paper.}. 
In another significant paper \cite{BMOW08}, Bouyer {\em et al} showed that sublogic of  with only bounded intervals, denoted , also has \expspace-complete satisfiability. These results are practically significant since many real time properties can be stated with bounded or non-punctual interval constraints.

In quest for more efficiently decidable timed logics, Alur and Henzinger considered the fragment \mitluszinf\/ consisting only of ``one-sided'' intervals, and showed that it  has \pspace-complete satisfiability. Here, allowed intervals are of the form    or  thereby enforcing either an upper bound or a lower bound time constraint in each modality.  

Several real-time properties of systems may be specified by using the unary \emph{future} and \emph{past} modalities alone. In the untimed case of finite words, the unary fragment of logic \ltlus\/ has a  special position: the  unary temporal logic  has NP-complete satisfiability 
\cite{EVW02} and it expresses exactly the unambiguous star-free languages which are characterized by Partially ordered 2-Way Deterministic Finite Automata (\potdfa) \cite{STV01}. 
On the other hand, the \pspace-complete satisfiability of   drops to \np-complete satisfiability for unary temporal logic \/ \cite{EVW02}.
Automata based characterizations for the above two logics are also well known: \ltlus\/- definable languages are exactly the star-free regular languages  which are characterized by counter-free automata, where as \ltlfp\/- definable languages exactly correspond to the unambiguous star-free languages \cite{TT02} which are characterized by Partially ordered 2-Way Deterministic Automata (\potdfa) \cite{STV01}. 


Inspired by the above, in this paper, we investigate several ``unary'' fragments of \mitlus\/ and we pin down their exact decision complexities as well as expressive powers.
\oomit{
Metric temporal logic can be defined over various classes of time frames, such as point-wise or continuous time. Moreover, the behaviors may be infinite or finite. The decidability and expressiveness of  changes very significantly with the nature of time \cite{OW07,DP07}. }
\emph{In this paper, we confine ourselves to point-wise  with finite strictly monotonic time}, i.e. the models are finite timed words where no two letters have the same time stamp. 

\oomit{
Metric temporal logic can be defined over various classes of behaviors. Point-wise metric temporal logic has timed words as its models.
Additionally, these can be constrained to be finite timed words or infinite timed words. Moreover, these words can either be weakly monotonic, permitting a finite sequence of events occurring at the same time point, or strictly monotonic.
An alternative to point-wise  is continuous timed  where models are timed state sequences (or equivalently finitely variable signals).
The expressiveness and decidability properties the logic depends very significantly on the underlying model class \cite{OW07,DP07}. 
For example, the future only fragment  over finite point-wise time (i.e. finite timed words) was shown to be decidable with NPR complexity by Ouaknine and Worrell \cite{OW07} where as logics  over infinite words, continuous time  over finite (but unbounded) timed state sequences and  over finite point-wise time all turn out to have undecidable satisfiability. 
The \expspace-complete satisfiability of  over continuous time (i.e. timed state sequences) was shown by Alur and Henzinger \cite{AH92} as well as Raskin, Henzinger and Schobbens \cite{HRS98} using several different forms of automata. Rabinovich and Hirshfeld established the same result using a  non-automata theoretic technique \cite{HR04}. It is widely accepted that  over point-wise time also has \expspace-complete satisfiability and  has \pspace-complete satisfiability for both weakly and strictly monotonic timed words. (The hardness proofs carry over quite straightforwardly from the continuous timed case. See Appendix.)
}


As our main results, we identify two fragments of unary logic  for which a remarkable drop in complexity of checking satisfiability is observed, and we study their automata as well as expressive powers. These fragments are as follows.
\begin{itemize} 
\item  Logic  embodying only unary ``lower-bound'' interval constraints of the form  and . We show that satisfiability of this logic is \np-complete.
\item Logic  having only unary modalities  and  with bounded and non-singular interval constraints  where ().
We show that satisfiability of this logic is \nexptime-complete.
\end{itemize}
In both cases, an automata theoretic decision procedure is given as a language preserving reduction from the logic  to  Partially Ordered 2-Way Deterministic Timed Automata (\potdta). These automata are a subclass of the 
2Way Deterministic Timed Automata  of Alur and Henzinger \cite{AH92} and they incorporate the notion of partial-ordering of states. 
They define a subclass of timed regular languages called unambiguous timed regular languages (\tul) (see \cite{PS10}).
\potdta\/ have several attractive features: they are boolean closed (with linear blowup only) and  their non-emptiness checking is \np-complete.
\oomit{ The
\potdta\/ have several attractive features: they are boolean closed and each boolean operation gives rise to linear blowup in their size.
Moreover,  their non-emptiness is NP-complete and language containment is \conp-complete  \cite{PS10}.
}
The  properties of \potdta\/ together with our reductions give the requisite decision procedures for satisfiability checking of logics \mitlfpinf\/ and \mitlfpb. \oomit{Both the reductions rely upon a novel scheme of  clocking (freezing) the times of first and last occurrences of subformulas in a pre-determined finite set of time intervals  to evaluate the truth of the formula. This can be done in  an inductive, bottom up fashion in successive passes of the two way automaton. 
}

The reduction from  to \potdta\/ uses a nice optimization which becomes possible in this sublogic: truth of a formula at any point can be determined as a simple condition between times of first and last occurrences of its modal subformulas and current time. A much more sophisticated but related optimization is required for the logic  with both upper and lower bound constraints: truth of a formula at any point in a unit interval can be related to the times of first and last occurrences  of its immediate modal subformulas in some ``related'' unit intervals. The result is an inductive bottom up evaluation of the first and last occurrences of subformulas which is carried out in successive passes of the two way deterministic timed automaton.

For both the logics, we show that  our decision procedures are optimal.
\oomit{ the hardness of these and other related logics is established by reduction of a suitable tiling problem to the satisfiability of the concerned unary \mitl\/ fragment.}  
We also verify that the logic  consisting only of the unary future fragment of   already exhibits \expspace-complete satisfiability. Moreover, the unary future fragment  with only upper bound constraints has \pspace-complete satisfiability, whereas   with only lower bound constraints has \np-complete satisfiability.
A comprehensive picture of decision complexities of fragments of  is obtained and summarized in Figure \ref{fig:complexity}.

We also study the expressive powers of logics \mitlfpinf\/ and \mitlfpb.
We establish that \mitlfpinf\/  is expressively complete for \potdta, and hence it can define all unambiguous timed regular languages (\tul). 
This is quite  surprising as  include guards with simultaneous upper and lower bound constraints as well as punctual constraints, albeit only occurring deterministically. Expressing these in , which has only lower bound constraints, is tricky.
\oomit{This \ttlxy\/ logic embodies the freeze quantification (of \tptlus)  and it has both punctual and unbounded constraints, albeit occurring only within deterministic modalities. 
We now show that   can express all  formulas, and the two logics are expressively equivalent. The reduction from  to \mitlfpinf\/ is a variant of another such encoding into the more expressive logic \mitlfp\/ given earlier (see \cite{PS11}).}
We remark that  is a rare instance of a precise logic automaton connection within the \mtlus\/ family of timed logics.


We also establish that   is strictly more expressive than the bounded unary logic . Combining these results with decision complexities, we conclude that , although less expressive, is exponentially more succinct as compared to the logic . Completing the picture, we show that, for expressiveness, . For each logic, we give a sample property that cannot be expressed in the contained logic (see Figure \ref{fig:unaryexpress}). The inexpressibility of these properties in lower logics are proved using an EF theorem for  formulated earlier \cite{PS11}. 


For logic , the reduction relies on the property that checking truth of a unary modal formula  at any position  of a given unit interval  can be formulated as simple condition over  and the times of
first and last occurrences of  in some related unit intervals (such as
. We call this the horizontal stacking of unit intervals
Some remarks on our reductions are appropriate here.
It should be noted that these logics have both future and past modalities and these naturally translate to the two-wayness of the automata. An important feature of our reduction is that checking of satisfiability of a modal subformula  reduces searching for ``last'' occurrence of   within some specified subintervals, and remembering its time stamp. This can be carried out by one backward scan of the automaton.  Similarly, for the past formula  we need a forward scan.


\begin{figure}
\begin{tikzpicture}[scale=0.9,transform shape]
\draw(0,0) -- (14,0); \draw(0,1.5) -- (14,1.5);\draw(0,3) -- (14,3);\draw(0,4.5) -- (14,4.5);\draw(0,6) -- (14,6);
\draw [dashed] (3,0) -- (3,6);
\draw (0.5,0.7) node{\np-complete}; \draw (1,2.2) node{\pspace-complete}; \draw(1,3.5)node{\nexp-complete}; \draw (1,5.2) node{\expspace-complete};

\draw (9,1) node (A) [rectangle,draw] {\mitlfpinf};
\draw (12,0.5) node (L) [rectangle] {\mitlfinf};
\draw (5,1) node (B) [rectangle] {\ttl};
\draw (12,1.9) node (C) [rectangle] {\mitlfz};
\draw (9,2.3) node (K) [rectangle] {\mitlfpzinf};
\draw (5,2.7) node (D) [rectangle] {\mitluszinf};
\draw (12.5,3.5) node (E) [rectangle] {\mitlfb};
\draw (8,3.8) node (F) [rectangle,draw] {\mitlfpb};
\draw (6.7,4.8) node (G) [rectangle] {\mtlusb};
\draw (12,4.8) node (H) [rectangle] {\mitlf};
\draw (9,5.3) node (I) [rectangle] {\mitlfp};
\draw (4.3,5.8) node (J) [rectangle] {\mitlus};
\draw (5,1.8) node (M) [rectangle] {\mitlusinf};

\draw [->](J)-- (I);
\draw [->] (I)-- (H);
\draw [->](H)-- (E);
\draw [->](I)-- (F);
\draw [->](G)-- (F);
\draw [->](F)-- (E);
\draw [->](K)-- (A);
\draw [->](D)-- (K);
\draw [->](K)-- (C);
\draw [->](A)-- (L);
\draw [->](D)-- (M);
\draw [->](M)-- (A);
\draw [->](J)--(D);
\end{tikzpicture}
\caption{Unary MITL: fragments with satisfiability complexities. Arrows indicate syntactic inclusion. The boxed logics are the two main fragments studied in this chapter.}
\label{fig:complexity}
\end{figure}


\begin{figure}
\begin{tikzpicture}[scale = 0.9, transform shape]
 \draw [rounded corners] (0,0) rectangle (10.5,5);
\draw (5,4.6) node {\mitlfp};
\draw (10,3) node {};

 \draw [rounded corners] (0.5,0.5) rectangle (9.5,4.4);
\draw (4.5,4) node {\mitlfpzinf};
\draw (9,2.5) node {};

 \draw [rounded corners] (1,1) rectangle (8.2,3.5);
\draw (4.4,3.2) node {\potdta  \ttl\/  \mitlfpinf};
\draw (7.7,1.7) node {};

\draw [rounded corners] (1.5,1.5) rectangle (6,2.5);
\draw (3.7,2.2) node{\mitlfpb};
\draw (5.5,1.8) node {};

\draw (13,4.5) node {};
\draw (13,3.5) node {};
\draw (13,2.5) node {};
\draw (13,1.5) node {};

\end{tikzpicture}
\caption{Expressiveness of Unary \mitl\/ fragments}
\label{fig:unaryexpress}
\end{figure}


\section{Unary \mitl\/ and its fragments}
\label{sec:mitlsem}
\begin{definition}{[Timed Words]}
A finite timed word over an alphabet  is a finite sequence , of event-time stamp pairs 
such that  and the 
sequence of time stamps is non-decreasing: . This gives weakly monotonic timed words. If
time stamps are strictly increasing, i.e. , the timed word is strictly monotonic.
\end{definition}
The length of  is denoted by , and . For convenience, we assume  that  as
this simplifies the treatment of the initial semantics of timed logics. The timed word  can alternately be represented as 
 with  and 
. Let
 be the untimed word of  and  be the set of events that occur in . Let  for some  be the factor of  given by .
Let  be the set of timed words over the alphabet .


The logic MTL \cite{Koy90,AH91} extends Linear Temporal Logic by adding timing
constraints to the "Until" and "Since" modalities of LTL, using timed intervals. We consider the unary fragment of this logic called \mtlfp. Let  range over the set of intervals with non-negative integers as end-points. The syntax of \mtlfp\/ is as follows:


\begin{remark}
In this paper, we study \mtl\/ with interval constraints given by timed intervals with integer end-points. In literature, \mtl\/ with interval constraints with rational end-points are often considered. However, it is important to note that properties expressed by the latter may also be expressed by the former, by scaling the intervals as well as the timestamps in the timed word models appropriately.
\end{remark}

Let  be a timed word and let
. The semantics of \mtlfp\/ formulas over pointwise models is as below:

The language of an \mtlfp\/ formula  is given by .\\


\mitlfp\/ is the fragment of \mtlfp\/ which allows only non-punctual intervals to constrain the  and  modalities. Some fragments of \mitlfp\/ that we shall consider in this paper are as follows. See Figure \ref{fig:unaryexpress} for examples.
\begin{itemize}
\item \mitlfpzinf allows only interval constraints of the form  or . Thus, each modality enforces either an upper bound or a lower bound constraint.  
\item \mitlfpb\/ is \mitlfp\/ with the added restriction that all interval constraints are bounded intervals of the form  with . 
\item \mitlfpinf\/ is the fragment of \mitlfp\/ where all interval constraints are ``lower bound'' constraints of the form . 
\item \mitlfpz\/ is the fragment in which all interval constraints (whether bounded or unbounded) are ``upper bound'' constraints of the form .
\item \mitlf, \mitlfzinf, \mitlfb, \mitlfinf\/ and \mitlfz\/ are the corresponding \emph{future}-only fragments. 
\end{itemize}

\paragraph{Size of \mitlfp\/ formulas}
Consider any \mitlfp\/ formula , represented as a DAG. Let  be the number of modal operators in the DAG of . Let  be the product of all constants that occur in . Then the \emph{modal-DAG size}  of , whose constants are presented in some logarithmic encoding (e.g. binary) is within constant factors of . 



\begin{definition}{[Normal Form for \mitlfp]}
\label{def:norm}
Let  denote a {\em boolean} combination of formulas from the finite set . Then a normal form formula  is given by 


\end{definition}
A subformula  in normal form is said to be an -type \emph{modal argument (or modarg in brief)} if it occurs within an -modality (as ).  It is a -type modarg if it occurs as . Each  is said to be a \emph{modal sub formula}.

\begin{proposition}\label{prop:norm}
Every \mitlfp\/ formula  may be expressed as an equivalent normal form formula  of modal-DAG size linear in the  modal-DAG size of .
\end{proposition}
\begin{proof}
Given , consider the equivalent formula . Transform this formula in disjunctive normal form treating modal subformulas as atomic. Now apply reductions such as 
 (if ) and  otherwise. The resulting formula is equivalent to .
Note that  DNF representation does not increase the modal-DAG size of the formula. Apply the same reduction to modargs recursively.  
\end{proof}



\subsection{\potdta}
In \cite{PS10}, we defined a special class of \twodta\/ called Partially-ordered 2-way Deterministic Timed Automata (\potdta). The only loops allowed in the transition graph of these automata are self-loops. This condition naturally defines a partial order on the set of states (hence the name). Another restriction is that clock resets may occur only on progress edges. THese are a useful class of automata for the following reasons: 
\begin{itemize}
\item The ``two-way'' nature of the automata naturally allows the simultaneous treatment of \textit{future} and \textit{past} modalities in timed temporal logics.
\item Since they are deterministic, complementation may be achieved trivially. In fact, the deterministic and two-way nature of the automata allow for boolean operations to be achieved with only a linear blow-up in the size of the automaton.
\item The size of the small model of a \potdta\/ is polynomial in the size of the automaton. Hence, language emptiness of a \potdta\/ is decidable with \np-complete complexity.
\end{itemize} 

\potdta\/ are formally defined below.

Let  be a finite set of clocks. A \emph{guard}  is a timing constraint on the clock values and has the form:\\
\tab  \approx\in \{<,\leq, >,\geq,=\}c\in\mathbb{N}.\footnote{Note that the guards  and  implicitly include the conditions  and  respectively.}\\

Here,  denotes the current time value. Let  be the set of all guards over . A clock valuation is a function which assigns to each clock a non-negative real number. Let  denote that a valuation  satisfies the guard  when  is assigned a real value . If  is a clock valuation  and , let  denote a valuation such that  and . Two guards  and  are said to be disjoint if for all valuations  and all reals , 
we have . A special valuation  maps all clocks to 0.

Two-way automata ``detect'' the ends of a word, by appending the word with special \emph{end-markers} on either side. Hence, if  then the run of a \potdta\/ is defined on a timed word .

\begin{definition}[Syntax of \potdta]
Fix an alphabet  and let . Let  be a finite set of clocks. A po2DTA over alphabet  is a tuple  where  is a partially
ordered and finite set of states such that  are the only minimal elements and  is the only maximal  element. Here,  is the initial state,  the accept state and  the reject state. The set  is partitioned into  and  (states which are \emph{entered from} the left and right respectively).  The progress transition function is a partial function 
which specifies the progress transitions of the automaton, such that if  then  and  is the subset of clocks that is reset to the current time stamp.
Every state  in  has a default \textit{``else''} self-loop transition which is taken in all
such configurations for which no progress transition is enabled. 
Hence, the automaton continues to loop in a given state  and scan the timed word in a single direction (right or left, depending on whether  or  respectively), until one of the progress transitions is taken. Note that there are no transitions from the terminal states  and . 

\end{definition}

\begin{definition}[Run]
Let  be a given timed word. 
The configuration of a po2DTA at any instant is given by  where  is the current state, the current value of the clocks is given by the valuation function  and the current head 
position is . In this configuration, the head reads the letter  and the time stamp  .

The run of a po2DTA on the timed word  with and starting head position  and starting 
valuation  is the (unique) sequence of configurations    such  that
\begin{itemize}
 \item Initialization: ,  and . The automaton always starts in the initial
 state .
\item  If the automaton is in a configuration  such that . If there exists a (unique) transition  such that . Then,
\begin{itemize}
 \item 
\item  for all clocks , and  otherwise.
\item  if ,  if  and   if 
\end{itemize}
\item If the automaton is in a configuration  (and ) and there does not exist a transition  such that  and . Then,
\begin{itemize}
 \item 
\item  for all clocks  and
\item  if  and  if 
\end{itemize}
\item Termination: . The run is accepting if  and rejecting if .
\end{itemize}
Let  be a function such that  gives the final configuration
 of the unique run of  on  starting with the configuration .
The language accepted by an automaton  is given by 
. 
\end{definition}

The transition function satisfies the following conditions.
\begin{itemize}
\item For all  and , there exists  such that  and  such that  . This prevents the head from falling off the end-markers. 
\item (Determinism) For all  and , if there exist distinct transitions 
 and , then  and  are disjoint.
\end{itemize}

\begin{example}
\label{exam:potdta}
Figure \ref{exam:autex1} shows an example po2DTA. 
This automaton accepts timed words with the following property: 
There is   in the interval  and a  occurs before it such that, if  is the position of 
the first  in the 
interval  then there is a  exactly at the timestamp .
\end{example}
\begin{figure}
\begin{tikzpicture}[
        scale=0.7, transform shape, auto,
        node distance=4cm,
semithick,
initial text=]
      \tikzstyle{every state}=[thick]
      
\node[state,initial](S){};
\node[state](A)[right of=S]{};
\node[state](B)[right of = A]{};
\node[state](C)[right of = B]{};

\path[->]
(S) edge node[above] {} (A)
(S) edge node[below] {} (A)
(A) edge node[above] {} (B)
(A) edge  [bend left] node[below] {} (C)
;
\end{tikzpicture}
\caption{Example of po2DTA}
\label{exam:autex1}
\end{figure}


\begin{definition}{[Timed Unambiguous Languages]}
The languages accepted by \potdta\/ are called Timed Unambiguous Languages (TUL).
\end{definition}



\section{From \mitlfp-fragments to \potdta}
In this section, we explore reductions from some fragments of Unary  to \potdta. A powerful optimization becomes possible when dealing with the unary sublogics such as \mitlfpb\/ and \mitlfpinf. The truth of a modal formula  for a time point  in an interval  can be reduced to a simple condition involving time differences between  and the times of \emph{first} and \emph{last} occurrences of  within some  related intervals. We introduce some notation below.

\paragraph{Marking timed words with first and last -positions\\}
Consider a formula  in normal form, a timed word  and an interval . Let  . Given set  of positions in  let  and  denote the smallest and largest positions in , with the convention that
 and . Let  and    denote 
the times of first and last occurrence of  within interval  in word .
If the subscript  is omitted, it is assumed to be the default interval .\\

The logic-automata translations that we give in this chapter are based on the following concepts:
\begin{itemize}
\item[i] In \cite{BMOW07}, the authors consider  and show that the satisfiability problem for  over point-wise models is EXPSPACE-complete. This is done via translation to ATA. In \cite{BMOW08}, they show a similar result for continuous models, using model-theoretic methods, in which they construct a tableaux for the bounded formulas. The bounded size of the tableaux relies on the fact that there is a bound on the interval within which the truth of every subformula has to be evaluated. Our translation from \mitlfpb\/ also uses this concept.
\item[ii] On the other hand, \cite{MNP06} gives the translation of \mitl\/ formulas to ``Timed Transducers''. A key concept used here, is the fact that the variability within a unit interval of the truth of a subformula with non-punctual interval constraints is limited. 
\item[iii] Further, it is known that unary LTL (called Unary Temporal Logic) is expressively equivalent to \potdfa. In \ref{SShah12}, we gave a constructive reduction from \utl\/ to \potdfa. The novel concept used here is that for every \utl\/ subformula, it is sufficient to know the first and last positions in a word, where the subformula holds true. It is this concept, which justifies the expressive equivalence between the seemingly different properties of unaryness (of \utl) and determinism (of \potdfa). 
\end{itemize}
We combine the concepts (i), (ii) and (iii) described above to give translations from \mitlfpinf\/ to \potdta\/ and from \mitlfpb\/ to \potdta\/.


\subsection{From \mitlfpinf\/ to \potdta}
Fix an \mitlfpinf\/ formula  in normal form. We shall construct a language-equivalent \potdta\/  by an inductive bottom-up construction. But first we assert an important property on which our automaton construction is based. \begin{lemma}\label{lem:inftychar} Given a timed word  and ,
\begin{enumerate}
 \item  
 \item  
 \item  
 \item  
\end{enumerate}
\end{lemma}
\begin{proof} We give the proof only for part (1). Remaining parts can be proved similarly.
\paragraph{Case 1} . Let .
Then, . Now, \\

\paragraph{Case 2} . We show that both LHS and RHS are false. For any  we have,  . Also, . Hence,  conjunct  of RHS does not hold.
\end{proof}


The above lemma shows that truth of  (or ) at a position can be determined by knowing the value of  (respectively, ). Hence for each -type modarg  of , we introduce a clock  to freeze the value  and -type modarg  of , we introduce a clock  to freeze the value .

\begin{figure}
\begin{minipage}{0.4\linewidth}
\begin{tabular}{|l|l|}
\hline
&\\
[-1.5ex]
 &  \\ 
\hline
 &  \\ 
\hline 
 &  \\ 
\hline 
 &  \\ 
\hline 
 &  \\ 
\hline 
\end{tabular}
\end{minipage}
\begin{minipage}{0.5\linewidth}
\begin{tikzpicture}[scale = 0.7, transform shape, auto,
        node distance=4cm,
semithick,
initial text=]
\tikzstyle{every state}=[thick]
      
\node[state,initial](S){};
\node[state](A)[right of=S]{};
\node[state](B)[right of=A]{};

\path[->]
(S) edge node[above] {} (A)


(A) edge[bend right] node[below] {} (B)
(A) edge[bend left] node[above] {} (B)
(A) edge node[above] {} (B)
;
\end{tikzpicture}
\end{minipage}
\caption{Table for  and automaton  for an -type .}
\label{fig:infty}
\end{figure}


Now we give the inductive step of automaton construction. 
Consider an -type modarg . The automaton  is as shown in Figure \ref{fig:infty}. 
If , then for every , we derive the guard  which is the guard on the transition labelled by  in , such that the transition is enabled is taken if and only if  is satisfied at that position. This is given by .
To define , let variable  denote the time stamp of current position. Then, the condition for checking truth of a modal subformula  is a direct encoding of the conditions in lemma \ref{lem:inftychar} and is given in the table in figure \ref{fig:infty}.
 It is now straightforward to see that  clocks exactly the last position in the word, where  holds.  A symmetrical construction can be given for  -type modarg , for which  clocks the first position in the word where  holds.
The following lemma states its key property which is obvious from
the construction. Hence we omit its  proof.
\begin{lemma}\label{lem:infty}
Given a  modarg   and any timed word , let  be a valuation where  and 
 for each modarg subformula  of , and  and . If
 is the clock valuation at the end of the run of  starting with , then
,  for each , and additionally,
\begin{itemize}
\item if  is  modarg then .
\item  if  is  modarg then .
\end{itemize}
\end{lemma}
\oomit{
\begin{proof}
Consider an -type modarg . The automaton  is as shown in figure \ref{fig:infty}. 
If , then for the clock , and , we derive the guard  which is the guard on the transition labelled by  in , and which resets . This is given by .  It is now straightforward to see that  clocks exactly the last position in the word, where  holds. 
\end{proof}
}\begin{theorem}
For any \mitlfpinf\/ formula , there is a language-equivalent \potdta\/  whose size is linear in the modal-DAG size of the formula. Hence, satisfiability of  is in \np.
\end{theorem}
\begin{proof}
Assume that  is in the normal form as described in Definition \ref{def:norm}. Note that reduction to normal form results in a linear blow-up in the modal-DAG size of the formula (Proposition \ref{prop:norm}). 
The construction of the complete automaton  is as follows.
In an initial pass, all the  clocks are
set to . Then, the component automata  for clocking modargs () are composed in sequence with innermost modargs being evaluated first. This bottom-up construction, gives us the initial-valuation conditions at every level of induction, as required in Lemma \ref{lem:infty}. Finally, the validity of  at the first position may be checked. 

This construction, gives a language-equivalent \potdta\/ whose number of states is linear in the number of nodes in the DAG of  and the largest constant in the guards of  is equal to the largest constant in the interval constraints of . From \cite{PS10}, we know that the non-emptiness of  may be checked in \np-time. Hence we can conclude that satisfiability of \mitlfpinf\/ formulas is decidable in \np-time.
\end{proof}
 


\subsection{From \potdta\/ to \mitlfpinf}
\begin{theorem}
Given a \potdta\/ , we may derive an equivalent \mitlfpinf\/ formula  such that 
\end{theorem}


We shall first illustrate the reduction of  to  by giving a language 
equivalent \mitlfpinf\/ formula for the \potdta\/ in Example \ref{exam:potdta}. This \potdta\/ first scans in the forward direction and clocks the first  in the time interval  (this is a bounded constraint), and then checks if there is a  exactly 1 time unit to its past by a backward scan (this is a punctual constraint).
The automaton contains guards with both upper and lower bound constraints as well as a punctual constraints. It is critical for our reduction that the progress transitions are satisfied at unique positions in the word. 

Consider the following \mitlfpinf\/ formulas. Define  as the formula which holds only at the first position in the word.\\
\hspace*{1cm}
\\
\hspace*{1cm}
\\
\hspace*{1cm}
 \\
The formula  holds at any  within the time interval . The formula  holds at the \textit{unique} first  in . The formula  holds at the initial position in a word iff the first  in  has a  exactly 1 time unit behind it. Note that the correctness of  relies on the \emph{uniqueness} of the position where  holds. The uniqueness of the positions at which the progress transitions are taken, is the key property that allows us to express even punctual constraints (occurring in the guards of progress transitions) using only lower-bound constraints as interval constraints in the formula. It is easy to verify that the \mitlfpinf\/ formula  exactly accepts the timed words that are accepted by the \potdta\/ in example \ref{exam:potdta}.

\paragraph{Translation from \potdta\/ to \mitlfpinf\\}
Consider  \potdta\/ . We shall derive a language-equivalent \mitlfpinf\/ formula  for the automaton. Since \potdta\/ run on words that are delimited by end-markers, for the sake of simplicity in presentation, we shall derive the corresponding \mitlfpinf\/ formula over the extended alphabet . However a language equivalent formula over  may be derived with minor modifications to the construction described below.

\begin{theorem}
Given a \potdta\/ , we may derive an \mitlfpinf\/ formula  such that . The size of the formula is exponential in the size of the automaton.
\end{theorem}

Given any path  of progress edges starting from the start state  of , we shall derive an \mitlfpinf\/ formula  such that the following lemma holds.

\begin{lemma}
If  is a path of progress edges in  which begins from the start state, we may construct an \mitlfpinf\/ formula  such that for any timed word , there exists a partial run of  on  which traverses exactly the progress edges in  and whose last transition is enabled at position  if and only if .
\end{lemma}
\begin{proof}
We shall derive  by induction on the length of . For the empty path (denoted as ), we have  which holds exactly at position 0 in . Now, let us inductively assume that the formula  for some path  in  (as shown in Figure \ref{fig:autm2form}) is appropriately constructed. We shall construct , where  denotes the path  that is appended with the edge .   For each   in , let  denote the set of event-guard pairs , over which a progress transition from  is defined. 

Firstly, assume that each clock in  is reset at most once\footnote{Due to the partial-ordering of the \potdta\/ and the restriction of resetting clocks only on progress edges, it is easy to see that every \potdta\/ can be reduced to one which resets every clock at most once.}. Now let  denote the prefix of  which ends with the transition that resets . Hence,\\
\begin{tabular}{l|l}
& if  is not reset on any edge in \\
 =&\\
&, which is a prefix of  such that  is reset on .\\
\end{tabular}

\medskip
Now, given a guard , we derive an \mitlfpinf\/ formula  using Table \ref{tab:guard1}. Abbreviate  as \\
\begin{table}
\begin{center}
\begin{tabular}{|l|l|}
\hline
   &       \\
\hline
\hline
 & \\  
\hline
 & \\
\hline
 & \\
\hline
 & \\
\hline
 & \\
\hline
 & \\
\hline
 & \\
\hline  
\end{tabular}
\caption{Construction of }
\label{tab:guard1}
\end{center}
\end{table}
\begin{proposition}
\label{prop:guard}
Given any timed word  such that there is a partial run  of  on  and  is the clock valuation of at the end of  then  if and only if . 
\end{proposition}
The proof of this proposition is directly apparent from the inductive hypothesis and the semantics of the automata. 

We may now derive  as follows. Let .\\
\begin{itemize}
\item If  then\\
 \\
\tab \tab 
\item If  then\\
\\
\tab \tab 
\end{itemize}
The correctness of the above formulas may be verified by closely observing the construction. Consider the three conjuncts of the formula  in either of the above cases. The first ensures that the current position (at which the formula is evaluated) has the letter  and satisfies the guard  (see Proposition \ref{prop:guard}). The second conjunct ensures that the current position is to the right of (or to the left of) the position at which the partial run  terminates (depending on whether  or , respectively). The third conjunct ensures that if  is the current position and  is the position at which  terminates, then for all positions  strictly between  and , none of the edges in  may be enabled. Note that this is the requirement for the automaton to loop in state  for all positions .
\end{proof}

\begin{figure}
\begin{center}
\begin{tikzpicture}
[
        scale=0.7, transform shape, auto,
        node distance=4cm,
semithick,
initial text=]
      \tikzstyle{every state}=[thick]
      
\draw (1,3) node(S) [circle,draw] {};
\draw (5,3) node(Q) [circle,draw] {};
\draw (7,5) node(Q1) [circle,draw] {};
\draw (7,3) node(Qi) [circle,draw] {};
\draw (7,1) node(Qn) [circle,draw] {};

\draw [dotted,->] (S)-- node{} (Q);
\draw [->] (Q)--(Q1);
\draw [->] (Q)--(Qi);
\draw [->] (Q)--(Qn);

\draw (6.4,2.8) node{};
\draw (6,3.1) node {};


\end{tikzpicture}
\caption{From \potdta\/ to \mitlfpinf}
\label{fig:autm2form}
\end{center}
\end{figure}

The formula  may now be given by:\\
\\
where  is any path of progress edges in  from  to .\\


\section{Embedding \mitlfpb\/ into \potdta}
We show a language-preserving conversion of an \mitlfpb\/ formula to a language-equivalent \potdta. 


Consider an \mitlfpb\/ formula  in the normal form.
We can inductively relate the truth of a subformula  or
 within a unit interval  to the values  
and  of its sub-formula  for suitable unit-length intervals 
, by the following lemma\footnote{ We
shall use convention  to denote generic interval which can be open, closed or half open. Moreover, we use subscripts  fix the openness/closeness and give generic conditions such as . This instantiates to  and  and  and . Interval  is empty. The same variables may also be used for inequalities. Hence, if  or  is open, then  and  denote the strict inequalities  and  respectively. If  or  is open, then  and  denote the non-strict inequalities  and  respectively.}. 
\begin{lemma} 
\label{lem:embedtwo}
Given a timed word  and integers  and  we have:
\begin{itemize}
\item  with  iff
\begin{itemize}
\item (1a)  OR 
\item (1b)  \\
\end{itemize}
\item  with  iff
\begin{itemize} 
\item (2a)  OR
\item (2b)  
\end{itemize}
\end{itemize}
\end{lemma}
\begin{proof}
This lemma may be verified using the figure \ref{fig:bmitlpo2fig1}. We consider the case of  omitting the symmetric case of . Let .
Fix a timed word .\\
\textbf{Case 1}:  (1a) holds. (We must show that  and ). Since conjunct 1 holds, clearly  and it has max element  such that  and  and . Also, by second conjunct of (1a) . Hence, by examination of Figure \ref{fig:bmitlpo2fig1},   and hence . \\
\textbf{Case 2}:  (1b) holds. (We must show that  and ). Since conjunct 1 holds, clearly  and it has min element  such that  and . From Figure \ref{fig:bmitlpo2fig1},  is a witness such that for all  such that , we have . Therefore, by second conjunct of (1b) , we may infer that . Hence  and .\\
\textbf{Case 3}:  and  and  first conjunct of (1b) does not hold. (We must show that (1a) holds.) Since  we have . \\
Since  for some , there is some  s.t.  and  as well as , and 
. Hence, we have  which from Figure
\ref{fig:bmitlpo2fig1} gives us that . Also, we can see that . Hence (1a) holds.\\
\textbf{Case 4}:  and  and first conjunct of (1b) holds but the second conjunct of (1b) does not hold. (We must show that (1a) holds.)
As  for some , there is some  s.t.  and . \\
Since  we have
. However, second conjunct of
(1b) does not hold. Hence,  and .
By examination of Figure \ref{fig:bmitlpo2fig1}, we conclude that 
 and . Hence, .
 This gives us that
 (see Figure \ref{fig:bmitlpo2fig1}).
Thus, (1a) holds.
\end{proof}


\begin{figure}
\begin{tikzpicture}[scale=0.74, transform shape]
\draw[dotted](-1,5) -- (0,5);
\draw(0,5) node{I} -- (4,5) node{I}; \draw[dotted](4,5)-- (7,5) node{I}; \draw (7,5) -- (11,5) node{I} -- (15,5) node{I};
\draw(0,4.7) node{}; \draw(4,4.7) node{}; \draw(7,4.7) node{}; \draw(11,4.7) node{}; \draw(15,4.7) node{};
\draw[dotted](1.5,5) --(1.5,6) node{}; \draw[dotted](2.5,5) --(2.5,5.5) node{}; \draw[dotted](8.5,5) --(8.5,6) node{}; \draw[dotted](13.5,5) --(13.5,5.5) node{};
\draw[dotted](1.5,5) --(1.5,4); \draw[dotted](2.5,5) --(2.5,4); \draw[dotted](-1,5) --(-1,4);\draw[dotted](5.5,5) --(5.5,4); \draw[dotted](8.5,5) --(8.5,4); \draw (8.4,3.7) node{}; \draw[dotted](13.5,5) --(13.5,4); \draw (13.5,3.7) node{};
\draw(0.2,4) node{}; \draw(4.3,4) node{}; 
\draw[<->] (1.5,4) -- (2.5,4);\draw (-1,4.3) -- (1.5,4.3); \draw (2.5,4.3) -- (5.5,4.3); \draw[(-)] (8.5,4.2) -- (13.5,4.2);
\draw (-0.9,4.3) node{};
\draw (1.6,4.3) node{};
\draw (2.6,4.3) node{};
\draw (5.6,4.3) node{};
\draw (2,3.7) node{};
\draw (11,4) node{};
\end{tikzpicture}
\caption{Case of }
\label{fig:bmitlpo2fig1}
\end{figure}


\begin{figure}
\begin{tikzpicture}[scale=0.8, transform shape]
\draw(0,5) node{I} -- (4,5) node{I} -- (8,5) node{I};  \draw[dotted](8,5)-- (11,5)node{I};  \draw (11,5) -- (15,5) node{I}; \draw[dotted](15,5)-- (16,5) node{};
\draw(0,4.7) node{}; \draw(4,4.7) node{}; \draw(8,4.7) node{}; \draw(11,4.7) node{}; \draw(15,4.7) node{};
\draw[dotted](12.5,5) --(12.5,6) node{}; \draw[dotted](13.5,5) --(13.5,5.5) node{}; \draw[dotted](1.5,5) --(1.5,6) node{}; \draw[dotted](6.5,5) --(6.5,5.5) node{};
\draw[dotted](12.5,5) --(12.5,4); \draw[dotted](13.5,5) --(13.5,4); \draw[dotted](9.5,5) --(9.5,4);\draw[dotted](16,5) --(16,4); \draw[dotted](1.5,5) --(1.5,4) node{}; \draw[dotted](6.5,5) --(6.5,4) node{};
\draw(11.2,4) node{}; \draw(15.3,4) node{}; 
\draw[<->] (12.5,4) -- (13.5,4);\draw (9.5,4.3) -- (12.5,4.3); \draw (13.5,4.3) -- (16,4.3); \draw[<->] (1.7,4.2) -- (6.3,4.2);
\draw (9.6,4.3) node{};
\draw (12.6,4.3) node{};
\draw (13.6,4.3) node{};
\draw (16.1,4.3) node{};
\draw (13,3.7) node{};
\draw (4,4) node{};
\end{tikzpicture}
\caption{Case of }
\label{fig:bmitlpo2fig2}
\end{figure}


From Lemma \ref{lem:embedtwo}, we can see that in order to determine the truth of a formula of the form  at any time stamp in , it is sufficient to clock the first and last occurrences of  in the intervals  and . Similarly, in order to determine the truth of a formula of the form  at any time stamp in , it is sufficient to clock the first and last occurrences of  in the intervals  and .



\usetikzlibrary{automata}\usetikzlibrary{positioning}
\begin{figure}
\begin{tikzpicture}[
        scale=0.9, transform shape, auto,
        node distance=3.5cm,
semithick,
initial text=]
      \tikzstyle{every state}=[thick]
      
\node[state,initial](S){};
\node[state](A)[right of=S]{};
\node[state](B2)[right of=A]{};
\node[state](C2)[right of=B2]{};
\node[state](T)[right of=C2]{};

\path[->]
(S) edge node[above] {} (A)
(A) edge[out=100, in=100, looseness=0.5] node {} (T)

(A) edge[bend right] node[above] {} (B2)
(A) edge[bend right] node[swap] {} (B2)



(B2) edge node[above] {} (C2)


(B2) edge node[above] {} (C2)
(C2) edge[bend right] node[above]  {} (T)
(C2) edge[bend right] node[swap]{} (T)
;
\end{tikzpicture}
\caption{ Automaton }
\label{bmitlfp:autm}
\end{figure}


The automaton  is constructed in an inductive, bottom-up manner as follows.
For every modarg  of , we first inductively evaluate the set of unit intervals within which its truth must be evaluated. Each such requirement is denoted by a tuple . This is formalized as a closure set of a subformula with respect to an interval.  For an interval , let  denote a partition set of , into unit length intervals. For example, if  then . The closure set may be built using the following rules.
\begin{itemize}
\item ,\\
where  is the set of immediate modal subformulas of .
 \item 
\item 
 \item 
 \item 
\end{itemize}
Define strict closure . The following lemma states the key property of .


\begin{table}
\begin{center}
\begin{tabular}{|l|l|}
\hline
&\\
[-1.5ex]
 &  \\ 
[1ex]
\hline
&\\
[-1.5ex]
 &  \\
                       & \\ 
[1ex]
\hline 
&\\
[-1.5ex]
 &  \\
                       &  \\ 
[1ex]
\hline 
&\\
[-1.5ex]
 &  \\
[1ex]
\hline 
&\\
[-1.5ex]
 &  \\
[1ex]
\hline 
\end{tabular}
\caption{Construction of }
\label{tab:guard}
\end{center}
\end{table}




\begin{lemma}
\label{lem:embedtwob}
For any modarg  in normal form, timed word  and integer , we construct an automaton  such that, if the initial clock valuation is , with 
 and  for all  and  and , then 
the automaton  will accept  and terminate with a valuation  such that
\begin{itemize}
 \item 
 \item   and
\item , for all other clocks.
\end{itemize}
\end{lemma}

\begin{proof}[Proof sketch]
The automaton  is given in Figure \ref{bmitlfp:autm}. For each ,  uses the  clock values of  and  in its guards, and it resets the clocks  and . 

For every , which is an immediate modal subformula of , we derive  as given in Table \ref{tab:guard}. The first two rows in Table \ref{tab:guard} are directly adapted from Lemma \ref{lem:embedtwo}. The last two rows, may be easily inferred from the semantics of \mitlfpb. Hence, we may infer that  if  then  iff . Now, if , then the guard on the transitions labelled by , which reset  and  (as in figure \ref{bmitlfp:autm}) is given by . It is straightforward to see that  if  and  then  iff . By observing the \potdta\/ in figure  \ref{bmitlfp:autm},  we can infer that it clocks the first and last -positions in the unit interval , and respectively assigns it to  and . 
\end{proof}

\begin{theorem}
Given any \mitlfpb\/ formula , we may construct a \potdta\/ which is language-equivalent to . Satisfiability of \mitlfpb\/ formulas is decidable in \nexp-time.
\end{theorem}
\begin{proof}
Firstly,  is reduced to the normal form, as described in section \ref{sec:mitlsem}. The automaton is given by  \footnote{The operator ``;'' denotes sequential composition of \potdta}.  The \potdta\/  makes a pass to the end of the word and resets all  (for all ) to the value . The bottom-up arrangement of  is the sequence of elements  of the set in bottom-up order of the subformulas  (in any arbitrary ordering of the intervals).  sequentially composes  in the bottom-up sequence of . This bottom-up sequence ensures that the conditions for the initial valuation of each of the component automata, as required in lemma \ref{lem:embedtwob}, are satisfied.
Finally,  checks if the clock value , thereby checking the validity of  at the first position in the word. 

\noindent
\emph{Complexity}: Assuming DAG representation of the formula, reduction to normal form only gives a linear blow up in size of the DAG. Observe that the   for  or   contains  number of elements of the form , where  is the length of the interval . Hence, if interval constraints are encoded in binary, it is easy to see that the size of  is , where  is the modal DAG-size of . 
Since each   has a constant number of states, we may infer that the number of states in  is . 
Since the non-emptiness of a \potdfa\/ may be decided with NP-complete complexity, we conclude that satisfiability of a \mitlfpb\/ formula is decidable with NEXPTIME complexity. 
\end{proof}


\section{Decision Complexities for \mitlfp\/ Fragments}
Figure \ref{fig:complexity} depicts the satisfaction complexities of various unary sublogics of \mitl\/ that are studied in this chapter.
We shall use tiling problems (\cite{vEB97},\cite{Fur83}) to derive lower bounds for satisfiability problems of the logics considered.
A tiling system   consists of a finite set of tile types  
with .  Tiling of a rectangular region of size 
 is a map  
such that  and . These are called 
horizontal and vertical matching constraints. An instance of the tiling problem 
specifies the region to be tiled  with a given tiling system and additional 
constraints on tiling, if any (such as ).

We reduce tiling problems to satisfiability of  formulae. Thus, a tiling 
is represented by a timed word  over the alphabet  such that the sequence of letters is just catenation of rows of  separated by a fresh separator letter . Hence, length of  and  occurs at positions  with . Depending upon the logic in consideration, various schemes are selected for time stamping the 
letters of   so that horizontal and vertical matching constraints can be enforced. We shall use abbreviations  and  and  in the formulae.



\paragraph{\expspace-hard tiling problem} Given a problem instance consisting of a tiling system
, a natural number  and first and final tiles  and , the solution of the problem is a tiling  of a rectangle of size  such that  and , for some natural number . This tiling problem is known to be \expspace-hard in .\\

\begin{theorem}\label{theo:expspacehard} 
Satisfiability of  (and hence ) is \expspace-hard.
\end{theorem}
\begin{proof}
We represent a tiling  by a timed word  where the time stamps of the letters are exactly . Consider the  formula  as conjunction  of formulae given below. 

\medskip

\noindent \\
\\
\\
\\ 
\\

\medskip

Conjunct  ensures that letters occur exactly at integer time points. Formula  indicates that the first separator  occurs at time-point  and subsequently  repeats exactly after a time distance of .  and  respectively encode horizontal and vertical matching rules.
 Note that a letter and its vertically above letter occur at time distance  and this is used for enforcing vertical compatibility.
It is clear from the formula construction that  
is satisfiable iff the original tiling problem has a solution. The size of  is linear in  since we use binary encoding of time constants. Hence, we conclude that satisfiability of  is \expspace-hard.
\end{proof}

\paragraph{\nexptime-hard tiling problem} Given a problem instance consisting of a tiling system
, a natural number  and a sequence  of leftmost  tiles in bottom row, a solution to the problem is a tiling  of a square of size  such that  for . This tiling problem is known to be \nexptime-hard in .

\begin{theorem} 
\label{theo:nexptimehard} Satisfiability of  (hence
)  is \nexptime-hard.
\end{theorem}
\begin{proof}
The encoding of a tiling in timed word is exactly same as in Theorem \ref{theo:expspacehard}. Thus, letters occur at successive integer times and
the first  letters encode
the tiling. Remaining letters (if any) are arbitrary and ignored. 
The timestamp of  ending the last row of tiling is . All the letters denoting the last row occur in the closed interval  and letters denoting non-last row occur in the half open time interval . 

The formula  is  similar to formula  but
all unbounded modalities  and  are replaced by bounded modalities  and  and  is omitted. Instead we use time interval  so that  and so on.
\medskip

\noindent
\\
\\
\\
\\

\medskip

Conjunct  (together with ) ensures that letters in interval  occur only at integer time points.  ensures that the first  tiles match . Remaining conjuncts are similar to those in Theorem \ref{theo:expspacehard}.


It is easy to see that  is satisfiable iff the original tiling problem 
has a solution. The size of  is linear in  since constant  
can be coded in binary in size linear in . Hence, we  conclude that satisfiability 
of  is \nexptime-hard. 
\end{proof}


\paragraph{\pspace-hard tiling problem} (Corridor Tiling) A problem instance of the Corridor Tiling problem consists of a tiling system  and a natural number , subsets  of tiles which can occur on left and right boundaries of the tiling region, and sequences \textit{top}= and \textit{bottom}= of tiles of length  each. A solution to this problem is a tiling  of a rectangle of size , for some natural number , such that the bottom row is \textit{bottom}, and the top row is \textit{top}. Moreover only tiles from  and  can occur at the start and end of a row respectively. This problem is known to be \pspace-hard in .

\begin{theorem} \label{theo:pspacehard} 
Satisfiability of  (and hence also  and ) is \pspace-hard.
\end{theorem}
\begin{proof}
We represent a tiling  by a timed word  where the first letter is at time  and time distance between successive letters is within the open interval . Consider the  formula  as conjunction of formulae given below. Note that over strictly monotonic time words  is equivalent to .
 \begin{itemize}
 \item  ensures that successive events occur at time distance .
 \item A row is of length  \\

\item
 Horizontal Compatibility: 
 \item
 Vertical Compatibility:  Formula   denotes a tile  in  row other than the last row. Hence \\
  
 \item Matching the bottom row:\\
   .
 \item Matching the top segment:\\
   .
 \item Matching white on the left side of the tiling:\\
  
 \item Matching white on the right side of the tiling:\\
 
\end{itemize}  
It is clear from the formula construction that  
is satisfiable iff the original tiling problem has a solution. The size of  is linear in . Hence, satisfiability of  is 
\pspace-hard. 
\end{proof}


\section{Expressiveness of \mitlfp\/ Fragments}
\label{app:express}
The relative expressiveness of the fragments of Unary \mitlfp\/ is as depicted in Figure \ref{fig:unaryexpress}. The figure also indicates the languages considered to separate the logics expressively.


\begin{theorem}
\label{thm:express1}
\mitlfpb\/  \mitlfpinf.
\end{theorem}
\begin{proof}
(i) \mitlfpb\/  \mitlfpinf.\\
This is evident from the translation of \mitlfpb\/ formulas to equivalent \potdfa, and the equivalence between \potdfa, \ttl\/ and \mitlfpinf.\\
(ii) \mitlfpinf  \mitlfpb\\
Consider the \mitlfpinf\/ formula . We can show that there is no equivalent \mitlfpb\/ formula to .
We shall prove this using a \mitlfpb\/ EF game \cite{PS11}, with  rounds and , for any . In such a game, the \ssp\/ is allowed to choose only non-singular intervals of the form , such that . Let .  and  two families of words such that  and each  occurs at integer timestamps from  to , and  occurs beyond  in  and before  in . Then,  and . Since, the \ssp\/ will be unable to place its pebble on the last , the \ddp\/ has a copy-cat winning strategy for an -round \mitlfpb\/ EF game with , over the two words. 
\end{proof}



\begin{theorem}
\mitlfpzinf  \mitlfp
\end{theorem}
\begin{proof}
Consider the \mitlfp\/ formula . Note that this formula requires any  in the word to be followed by a  within  time units from it. While either one of the bounds of the interval  (either lower bound of 1 t.u. or upper bound of 2 t.u.) may be specified by a \mitlfpzinf\/ modality (such as  or  respectively), both these can not be asserted together when the  modality is within the scope of an unbounded () modality. We shall prove this by showing that here is no \mitlfpzinf\/ formula for , using an \mitlfpzinf\/ EF game (as described below).

Let . Consider two families of words  and  with . Both families of words have all events except the initial , occurring beyond the timestamp . Hence, all the letters are at a time distance in  from the origin. The intuition behind this is to disallow the \ssp\/ to distinguish integer boundaries between events. 
We shall call each -pair a \emph{segment}. The words are depicted in Figure \ref{fig:expressgame2}. Let  be such that . Consider the word  such that the segments occur beyond  as follows. A segment begins with the occurrence of an  at some time stamp (say ), and has a  occurring at . The following segment begins at . Since each  has a  from its own segment within time distance  time units and a  from the following segment at a time distance  time units and successive 's are separated by a time distance  time units, it is easy to verify that .

The timed word  is identical to  except for the positioning of  in the  segment, which is at a time distance  from the  of the middle  segment, for some . Due to this  which is at a time distance within  time units from the middle , we can conclude that .

Now consider an  round \mitlfpzinf- EF game, with . We shall say that the game in a given round is in \emph{identical configurations} if the initial configuration of the round is of the form . For , denote the  and  of the  segment by  and  respectively. Consider the following strategy for the \ddp.
\begin{itemize}
\item Starting from identical configurations, the \ddp\/ may mimic the \ssp's moves at all times and maintain identical configurations except in the following cases, which lead to non-identical configurations (these are depicted by dotted arrows in Figure \ref{fig:expressgame2}).
\begin{itemize}
\item Starting from the identical configuration  in the middle segment, the \ssp\/ chooses the interval  and chooses  in  then the \ddp\/ must respond by choosing  in . 
\item Starting from the identical configuration  in the middle segment, the \ssp\/ chooses the interval  and chooses  in  then the \ddp\/ must respond by choosing  in .
\item Starting from the identical configuration , the \ssp\/ chooses the interval  and chooses  in  then the \ddp\/ must respond by choosing  in .
\item Starting from the identical configuration , the \ssp\/ chooses the interval  and chooses  in  then the \ddp\/ must respond by choosing  in .
\end{itemize}
Note that the only position where the two words differ is in the timestamp of  and the only position from which they can be differentiated by an integeral time distance is from . Hence starting from identical configurations, the only way in which a non-identical configuration may be achieved is by one of the above possibilities and the resulting configuration has a segment difference of 1.
\item The segment difference of a non-identical configuration is . Starting from a non-identical configuration, we have the following possibilities
\begin{itemize}
\item If the initial configuration includes  or  in , then the \ssp\/ may choose a suitable interval and choose the position  or  respectively. This increases the segment difference of the configuration by 1. For example, if the initial configuration is  (this may be achieved, for instance, when the \ssp\/ chooses the interval (0,1) for two successive ``future rounds'', starting from an initial non-identical configuration of ), and the \ssp\/ chooses the interval (0,2) and chooses  in  then the \ddp\/ is forced to choose , resulting in a segment difference of 2.
\item For any other choice of positions by the \ssp\/, the \ddp\/ may ``copy'' the \ssp\/'s moves by moving exactly the number of positions that is moved by the \ssp. This will result in non-identical configuration with segment difference less than or equal to the initial segment difference in the round.
\end{itemize}
\end{itemize}
It is now easy to argue that the above strategy is a winning strategy for the \ddp\/ for an -round \mitlfpzinf\/ game with . By observing the two words, we can see that the only way the \ssp\/ can win a round is by beginning with non-identical configurations at either end of the words (at time distance  from either the beginning or end of the sequence of segments), such that the \ssp\/ may have an  or a  to chooses in one of the words, while the \ddp\/ wouldn't. However, the first time a non-identical configuration is achieved, is in the middle segment (as discussed above). The \ssp\/ has two choices- (i) to increase the segment difference by repeatedly choosing the middle segment configurations, or (ii) to maintain the segment difference and move towards either end of the word. In order to maintain a segment difference  and reach either end of the word, the \ssp\/ can move a maximum time distance of  time units (if it chooses an interval larger than that, the \ddp\/ may be able to achieve identical configurations). Hence the \ssp\/ requires at least  rounds to reach either end of the word whilst maintaining non-identical configurations. Since the game is only of  rounds, the \ssp\/ will not have enough rounds to first establish a non-zero segment difference and maintain it, while traversing to either end of the words. Hence, the above strategy is a winning strategy for the \ddp\/ for an -round \mitlfpzinf\/ EF-game with .
\end{proof}


\begin{figure}
\begin{tikzpicture}[scale=0.9, transform shape]
\draw (0,4) node{};
\draw[dotted] (0.2,4)--(1,4); \draw[dotted] (15.2,4)--(16,4);
\draw(1,4) node{x}-- (3.6,4) node{l}-- (4,4) node{x}--(4.4,4) node{l}-- (4.8,4) node{o}-- (7.4,4) node{l} --(7.8,4) node{o}--(8.2,4) node{l}-- (8.6,4) node{I}-- (10.8,4) node{o}-- (11.2,4) node{l}-- (11.6,4) node{I}--(12,4) node{l}-- (12.4,4) node{T}-- (14.6,4) node{I}-- (15,4) node{l}-- (15.4,4) node{T} -- (15.6,4) node{};
\draw(1,4.3) node{}; \draw (3.6,4.3) node{}; \draw (4.8,4.3) node{}; \draw  (7.4,4.3) node{}; \draw (8.6,4.3) node{}; \draw (11.2,4.3) node{}; \draw (12.4,4.3) node{}; \draw (15,4.3) node{};

\draw (0,2) node{};
\draw[dotted] (0.2,2)--(1,2); \draw[dotted] (15.2,2)--(16,2);
\draw(1,2) node{x}-- (3.6,2) node{l}-- (4,2) node{x}--(4.4,2) node{l}-- (4.8,2) node{o}-- (7.4,2) node{l} --(7.8,2) node{o}--(8.2,2) node{l}-- (8.6,2) node{I}-- (10.8,2) node{o}-- (11.2,2) node{l}-- (11.6,2) node{I}--(12,2) node{l}-- (12.4,2) node{T}-- (14.6,2) node{I}-- (15,2) node{l}-- (15.4,2) node{T} -- (15.6,2) node{};
\draw(1,2.3) node{}; \draw (3.6,2.3) node{}; \draw (4.8,2.3) node{}; \draw  (7.4,2.3) node{}; \draw (8.6,2.3) node{}; \draw (10.7,2.3) node{}; \draw (12.4,2.3) node{}; \draw (15,2.3) node{};

\draw(4.8,3.6) node {};
\draw(4.8,1.6) node {};
\draw(8.6,3.6) node {};
\draw(8.6,1.6) node {};
\draw(11.2,3.6) node {};
\draw(10.7,1.6) node {};
\draw(7.4,3.6) node {};
\draw(7.4,1.6) node {};
\draw (1,1.6) node{};
\draw (15,1.6) node{};

\draw [arrows= -triangle 45,dotted] (10.7,2.5)--(7.4,3.3);
\draw [arrows= -triangle 45,dotted] (11.2,3.3)--(15,2.5);
\draw [arrows= -triangle 45,dotted] (4.8,2.5)--(8.6,3.3);
\draw [arrows= -triangle 45,dotted] (4.8,3.3)--(1,2.5);
\end{tikzpicture}
\caption{\mitlfpzinf\/ EF game to show that \mitlfpzinf  \mitlfp}
\label{fig:expressgame2}
\end{figure}


\begin{theorem}
\label{thm:fpexpress}
\mitlfpinf\/  \mitlfpzinf
\end{theorem}
\begin{proof}
Logic \mitlfpinf\/ is a syntactic fragment of \mitlfpzinf. We shall now show that it is strictly less expressive than \mitlfpzinf\/ by showing that there is no \potdta\/ which accepts the language given by the formula . The proof relies on the idea that since a \potdta\/ may be normalized to one that has a bounded number of clocks (bounded by the number of progress edges), and every edge may reset a clock at most once on a given run, the \potdta\/ cannot ``check'' every   for its matching  in a timed word which has sufficiently many  pairs.

Assuming to contrary, let  be a \potdta\/ with  number of progress edges , such that . Now consider the word  consisting of the event sequence  where the   pair gives the timed subword . Thus, each  is  units away from the preceding . Hence, . 
Consider the run of  over . 
There are a maximum number of  clocks in  that are reset, in the run over .

By a counting argument (pigeon-hole principle), there are at least  (possibly overlapping but distinct) subwords of  of the form , none of whose elements have been ``clocked'' by . Call each such subword a group. Enumerate the groups sequentially.
Let  be a word identical to  except that the  group is altered, such that its middle  is shifted by 0.7 t.u. to the left, so that  satisfies the property required in . Note that there are at least  such distinct 's and for all , . \\
Given a , if there exists a progress edge  of  such that in the run of  on ,  is enabled on the altered , then for all ,  is not enabled on the altered  of . This is because, due to determinism, the altered  in  must satisfy a guard which neither of its two surrounding 's in its group can satisfy. \\
From the above claim, we know that the  clocks in , may be clocked on at most  of the altered words . However, the family  has at least  members. Hence, there exists a  such that the altered  of , (and the  group) is not reachable 
by  in  or any of the . Hence  iff . But this is
a contradiction as  and  with . \\
Therefore, there is no \potdta\/ which can express the language .
\end{proof}



\section{Discussion}
We have shown how unaryness, coupled with timing restrictions, yields interesting fragments of \mitl, that are placed lower in the hierarchy, in terms of expressiveness and decidability complexities.
\begin{itemize}
\item We have a \emph{B\"uchi-like logic-automaton characterization} for a fragment of \mtl. \potdta\/ are closed under complementation, and have the key ingredients required, for convenient logic-automata conversions. Moreover, the exact characterization of \potdta, in terms of an \mtl\/ fragment (i.e. \mitlfpinf) has been identified.
\item The embedding of \mitlfpb\/ into \potdta, and the conversion from \potdta\/ to \mitlfpinf\/ formulas shows us how even properties like punctuality and boundedness, when coupled with determinism, may be expressed by a unary and non-punctual fragment, i.e. \mitlfpinf.
\item Unary fragments \mitlus\/ and \mitluszinf\/ do not result in a gain in satisfiability complexity and there is a significant gain (from \pspace-complete to \np-complete), when \mitlusinf\/ is compared to its unary-counterpart, \mitlfpinf.
\item While satisfiability of \mitlfz\/ is \pspace-complete, the satisfiability of \mitlfpinf\/ is \np-complete. This asymmetry in decision complexities of logics with one-sided constraints, and on finite words, has been observed.
\item An \nexptime-complete fragment of \mitl\/ has been recognized: \mitlfpb, which combines the restrictions of unaryness, punctuality, as well as boundedness is a rather restrictive logic in terms of expressiveness, but more succinct than \mitlfpinf.  In general, for the unary fragments of \mitl, one-sided interval constraints prove to yield much better decision complexities than bounded interval constraints.
\end{itemize}

In this chapter, our logic-automata reductions rely on strict monotonicity of the pointwise models. We believe that the results may be extended to the weakly-monotonic case, by using some concepts similar to the untimed case and still maintaining the decision complexities. 


\bibliography{mybib}

\end{document}