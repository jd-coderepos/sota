




\documentclass[12pt,onecolumn,draftclsnofoot]{IEEEtran}





\usepackage{cite} 

\usepackage{graphicx} 






\usepackage{subfigure} 

\usepackage{url} 



\usepackage{amssymb}
\usepackage{amsfonts}
\usepackage{amsmath} 


























\hyphenation{op-tical net-works semi-conduc-tor}


\begin{document}
\title{Decoding the Golden Code: a VLSI design}
\author{Barbara~Cerato, {\em Student Member, IEEE},~ Guido~Masera, {\em Member,
IEEE}\\ and Emanuele~Viterbo, {\em Senior Member, IEEE}}






\maketitle


\begin{abstract}
Multiple-input multiple-output (MIMO) systems are among the most
promising transmission techniques to achieve high data rate and high
reliability transmission over wireless channels. The recently
proposed Golden code is an optimal space-time block code for 
MIMO systems. The aim of this work is the design of a VLSI decoder for
a MIMO system coded with the Golden code. The architecture is based
on a rearrangement of the sphere decoding algorithm that achieves
maximum-likelihood (ML) decoding performance. Compared to other approaces,
the proposed  solution exhibits an inherent flexibility in terms of
QAM modulation size and this makes our architecture 
particularly suitable for adaptive modulation schemes.
Relying on the flexibility of this
approach two different architectures are proposed: a
parametric one able to achieve high decoding throughputs
(165 Mbps) while keeping low overall decoder complexity (45 KGates),
 with respect to other proposed solutions; a flexible
implementation able to dynamically adapt to the modulation scheme
(4-,16-,64-QAM) retaining the low complexity and high throughput
features. In addition, a deep analysis of finite precision effects
on the performance is presented in this work for both 16 and 64 QAM.

\end{abstract}

\begin{keywords}
VLSI, digital architectures, Golden code, MIMO, sphere decoding
\end{keywords}


\IEEEpeerreviewmaketitle



\section{Introduction}
\PARstart{T}{he} hardware implementation of high data rate and high
reliability wireless communication systems is one of the most
widely investigated topics within the scientific community and has
raised new engineering and research challenges for many years.
Higher transmission reliability demands for higher levels of
processing complexity in the mobile terminal, while faster data
rates require increased throughput: both evolutive trends are
strong driving forces for the search of novel efficient
architectures implementing the most critical base-band processing
functions. In particular new standards proposed to regulate Wireless
Local Area Networks (WLAN) and Metropolitan Area Networks (MAN) are
significant examples of very challenging applications from the
implementation point of view.




There are two main objectives on which research is actually
focused. The first goal is to make wireless communication data rate comparable
to that
of wired communications: recent results show it is possible to approach 1Gb/s
data rate\cite{gigabit, gigabit2} . The second one is to improve reliability,
by combating multipath,
noise and interference effects. The recourse to multiple-input multiple-
output (MIMO) systems seems to be one of the most promising solutions to reach both
these results.

Traditionally, MIMO systems were conceived with the purpose of dealing with one of these two
objectives, by means of transmit antenna diversity combined with space-time
coding.
More recently great efforts have been made in unifying both goals and
some new space-time codes are now able to reach the best tradeoff between data rate
and diversity gain, although they require more sophisticated detection schemes
at the receiver \cite{LD-STBC, CODES2, CODES3, Golden1, Golden2, Golden3}.

The main contribution of this work is in the hardware design of a
decoder for this kind of codes, in particular for the decoding of a
 MIMO signal coded with the {\em Golden code}
\cite{Golden1}. Golden code is a recently proposed full-rate and
full-diversity space-time block code, chosen for its good energy
efficiency. The maximum-likelihood (ML) decoding algorithm for the Golden
code is based on the \emph{Sphere Decoder}, which has already been
widely addressed in the literature also from a hardware
implementation point of view~\cite{ControCompl}-\cite{Kbest}.


Several architectures have been proposed for the efficient
implementation of the sphere decoding architecture, but they are
optimized for specific modulation schemes and do not support
reconfigurability features. In \cite[ASIC-I]{ethvlsi}, in order
to reach high throughput dedicated multipliers and parallel
computations are used adopting a so called ``one node per cycle''
architecture. Other architectures instead take advantage of suboptimal algorithms: good examples of this
approach are given in \cite[ASIC-II]{ethvlsi},
where the -norm is implemented as an alternative to the more expensive
-norm, and in~\cite{lundvlsi}, where the K-Best algorithm allows for
performance-complexity trade-offs.
These choices lead to fully optimized architectures,
achieving high throughput; however, they are not ML 
(the loss is about 1.4 dB in the case of  \cite[ASIC-II]{ethvlsi}) and have
been proposed for specific modulation and transmission schemes, 
although in~\cite{ethvlsi} the possibility to adapt the proposed solution to 
different modulations is also mentioned.
In this work we
overcome these limitations, proposing two novel architectures
designed with VHDL as a reusable intellectual property (IP)
macrocell: the first one is parametrized with respect to the
fixed-point representation of data and to the addressed modulation
scheme; in order to enable comparisons with previous
implementations, synthesis results are provided for this
architecture in the case of 16 QAM. The second architecture is
flexible, meaning that it can be dynamically configured to cover
multiple modulation schemes. We note that both these hardware
implementations can be equivalently used in a  uncoded MIMO system~\cite{gigabit2}.


 In Section \ref{GC} we briefly explain properties,
construction and detection of Golden code, Section \ref{SD} is
dedicated to reviewing the sphere decoding algorithm. In
section \ref{FIX} the effects of fixed-point precision on the code
performance are derived. A short introduction to the overall scheme
of the MIMO receiver is given in Section \ref{Preproc}, with
particular attention to QR decomposition preprocessing unit; the
detailed descriptions of the two hardware implementations are then
carried out in \ref{HW1} and \ref{HW2}. In the last two sections
results and conclusions are presented.





\section{Golden code}
\label{GC}
The Golden code is a space-time (ST) code for a  coherent MIMO channel,
it was found independently by \cite{Golden1, Golden2, Golden3}.

Number theoretical methods have been widely employed to construct
full-rate and full-diversity codes for coherent MIMO systems. These
methods are based on the rank and the determinant criteria. In a
Rayleigh fading channel the pairwise error probability (PWEP)
expression \cite{Criterion} shows that the error probability can be
minimized operating mainly on two aspects: {\em diversity} and {\em
coding gain}. In \cite{Criterion} it was proved that these
parameters are related to the so called codeword difference matrix
, which is constructed as the difference between two
codewords. In order to maximize the diversity gain, the space-time
code must be designed so that the difference matrix between any two
codewords is full rank (\emph {rank criterion}). On the other hand,
the coding gain, depends on the determinant of 
and high coding gain is achieved maximizing the minimum of this
determinant over all codeword pairs (\emph{determinant
criterion}).

Golden code satisfies both the rank and the determinant criterion
and in particular, differently from previously known codes, presents
the non-vanishing determinant property, i.e., its minimum
determinant is 1/5 and does not depend on the size of the signal
constellation. For this reason it can be successfully employed in
systems with adaptive selection of the modulation.

Besides these properties, the Golden code has also the peculiarity
to be energy efficient. It is constructed using a rotated version of
the   complex lattice, so that there is no loss due
to shaping~\cite{Golden1}.

The codewords  of the Golden code are  complex
matrices of the following form 



\noindent where  are the information symbols chosen in a -QAM=-PAM constellation,
 (Golden number), , \cite{GoldenPage}.


\subsection{The  MIMO System Model}
In order to model the 
MIMO channel, its impulse response can be used. Assuming
 as the time-varying channel fading coefficients between the
-th transmit antenna and the -th receive antenna, the
MIMO channel is described through a 22 matrix:



\noindent where .
Assuming the ``Block Fading'' channel model, each transmitted codeword will be
affected by an independently varying channel matrix .
Then, the  received matrix is

where  is the additive white gaussian noise matrix with entries
.

We note that each codeword is sent in two channel uses of the two
transmit antennas, for a total of four component signals. It is
convenient to represent the codeword  in vectorized form
where, furthermore, real and imaginary components are separated,
resulting in a  real vector . The channel
matrix  can be consequently rearranged in a
88 real-valued matrix . It can be seen that
, where
 is a  orthogonal matrix
() and  with entries from a
-PAM constellation, \cite{GoldenPage}.

The vectorized system model can so be expressed as:

\noindent where  is the 81 received real vector and
 is a 8-dimensional i.i.d. (independent and identically 
distributed) zero
mean gaussian noise real vector.


\subsection{Decoding the Golden code}
Decoding the Golden code is equivalent to decoding an 8-dimensional lattice
with generator matrix .
Provided that  is perfectly known at the
receiver, the optimal detector for a MIMO channel,
which minimizes the codeword error rate, is the maximum-likelihood (ML) detector.
It solves the following equation:


\noindent where  is the cardinality of the search space and .

The above expression represents a discrete least-square (LS) minimization problem. Exhaustive search
of the ML solution has exponential complexity and in this particular case it has
 possible solutions.
Sphere decoding algorithms have then been proposed in order to decrease
the decoder complexity.


\section{Sphere Decoding Algorithm}

\label{SD}

\emph{Sphere decoding algorithms}  denote a family of algorithms,
which aim at lowering the complexity of the
minimization~(\ref{MLeq}) by analyzing only a subset of the solution
space \cite{Caire&ot1}. These algorithms, in a certain range of
parameters which is not too far from those of real systems, show a
polynomial average complexity.
Although other work \cite{ControCompl} denies this theoretical
proof, computer simulations still confirm the practical result. This
behavior is due to the fact that  is not an
arbitrary vector, but it is given by the transmitted vector
 with a small offset due to additive
noise .

Sphere decoding algorithms look at the set of  possible solutions as
points of a lattice and try to find the closest point to the
received vector. In particular, a hypersphere is constructed around
the received vector and only points inside it are taken into
account, since the others are actually too far. This constraint can
be written as:

where  is the square radius of the
hypersphere~\cite{Pohst,Viterbo93,Viterbo99}.  In the following we
describe a method to  easily compute distances between received
signals and lattice points.

\subsubsection{Tree construction}
With a linear transformation of the matrix , such as
QR or Cholesky decomposition, it is possible to rewrite
 as a product of two matrices, one of which upper
triangular \cite{Caire&ot1}. In this work, QR decomposition has been
employed so that, given ,
(\ref{MLeq}) can be rewritten as:

where we have exploited the orthogonality of  and
 represents the
zero-forcing (ZF) solution. The upper triangular structure of the
factored matrix enables to take every component separately into
account for the computation of the distance between the two points.
The distance  can also be computed recursively as follows. Let
us define the partial metric as in~\cite{ethvlsi}

where , and

\noindent with . Then we can
write .

One of the most interesting consequences of this interpretation is
that the exploration of the lattice can be thought as a tree
traversal. This tree has  levels and every node at each level has
\emph{Q} sons. At every level the radius
constraint~(\ref{sphere_const}) must be verified and satisfied,
otherwise the branch is pruned. Figure \ref{Tree} depicts a two
level tree for a QPSK modulation.  is the partial distance metric at
level  in (\ref{MetrEq}); at the lowest level, final metrics are explicitly
calculated for this simple case.

\begin{figure*}[t!]
\begin{center}
\setlength{\unitlength}{0.85mm}
\begin{picture}(150,80) \thicklines \put(75,80){\line(-3,-2){45}} \put(75,80){\line(3,-2){45}} \put(75,80){\circle*{2}}
\put(69,83){}
\put(30,50){\line(-1,-1){30}}
\put(30,50){\line(1,-1){30}}
\put(30,50){\circle*{2}}
\put(120,50){\line(-1,-1){30}}
\put(120,50){\line(1,-1){30}}
\put(120,50){\circle*{2}}
\put(0,20){\circle*{2}}
\put(90,20){\circle*{2}}
\put(60,20){\circle*{2}}
\put(150,20){\circle*{2}}


\put(25,72){}
\put(110,72){}




\put(-8,52){}
\put(122,52){}

\put(-5,32){}
\put(50,32){}

\put(85,32){}


\put(140,32){}

\put(-15,15){ =} \put(-15,2){}

\put(35,15){ =} \put(35,2){}

\put(85,15){ =} \put(85,2){}

\put(135,15){ =} \put(135,2){}

\end{picture}
\end{center}
\caption{Two level tree for QPSK modulation, where , , , , , }
\label{Tree}
\end{figure*}

\subsubsection{Tree exploration}
Several algorithms have been studied in order to make the tree
traversal efficient. First algorithm, proposed by Pohst in
\cite{Pohst}, needs to chose explicitly an initial radius. This is a
very critical choice: if the radius is chosen too large, too many
points fall into the hypersphere, while for a too small radius no
points are left inside it. A more efficient algorithm has been proposed by
Schnorr and Euchner (SE) \cite{SE}. 
The SE algorithm has intrinsically variable throughput and this makes it
not very suitable for hardware implementation. The key to make this
algorithm efficient or, at least, with predictable throughput, is to
make an effective pruning. A lot of theoretical studies can be found
in recent literature, which aim at finding techniques to reach this
goal \cite{Kbest}. Although some of them give very interesting
ideas, none of them seems to be effective nowadays, with a strong
theoretical demonstration and a simple realization.



\section{Fixed-point analysis}
\label{FIX}
The study of finite precision effects is a mandatory preliminary step in the
design and hardware implementation of complex processing tasks.
Although several implementations of the sphere decoding algorithm have been
proposed, studies on finite precision effects are not available in literature.
In this work, a wide range of simulations have been carried out in order to determine the
effects of different fixed-point representations
on the performance for both 16 and 64-QAM modulation schemes.

The main conclusion that can be derived from 
results reported in Figure \ref{BER_Meno} is that the
required number of bits increases when
higher--order modulations are used. There are two reasons for
this increase:
\begin{itemize}
\item with higher order modulations, Euclidean distances between
constellation points decrease and a larger number of bits must be 
allocated in the fractional part to discriminate distances; 
\item signal amplitudes are higher in higher order modulations, 
thus more bits need to be allocated also in the integer part.
\end{itemize}
Simulation results show that a total of 12 bits lead to performance 
very close to the floating-point case for 16-QAM modulation,
while 14 bits are necessary in the detection of 64-QAM signals.
\begin{figure}[ht]
    \begin{center}
    \includegraphics[angle=270, width=\linewidth]{ber_FixedMenoVsFloating.eps}
    \caption{System bit error rate (BER) using 16 and 64-QAM: lowering the total number of bits.}
    \label{BER_Meno}
    \end{center}
\end{figure}





Finally, Figures \ref{IT_64QAM_16} shows that the
fixed-point approximation does not affect significantly the number
of visited nodes of the algorithm. The plotis given as a function of the codeword error rate.
\begin{figure}[ht]
    \begin{center}
    \includegraphics[angle=270, width=\linewidth]{it_FixedVsFloating64QAM_Meno.eps}
    \caption{Number of visited nodes using 64 QAM, with different partitioning between integer and fractional part.}
    \label{IT_64QAM_16}
    \end{center}
\end{figure}

\section{Preprocessing}

\label{Preproc} In this section we discuss the implementation issues
related to pre-processing, which is required before the tree-search.
This computation operates on the lattice generator matrix ; since the code generator matrix is constant, the computation
must be repeated at the channel estimation update frequency.

The update frequency for the channel estimation can change
significantly according to the scenario, but it is generally one or
two orders of magnitude lower than the signalling rate.
\begin{figure*}[t!]
    \begin{center}
    \includegraphics[height=3cm, width=\linewidth ]{System.eps} \caption{Golden Code MIMO System.}
    \label{System}
    \end{center}
\end{figure*}
Figure \ref{System} depicts a block diagram of a MIMO system adopting
the Golden code; dashed blocks implement modulation and
demodulation functions in a generic MIMO-OFDM system. The Golden
code decoding phase is made of three functions: {\em
QR decomposition, column reordering} and {\em tree search}.

While column reordering is an optional operation able to reduce the
tree-search complexity, QR decomposition is mandatory because it
allows constructing the tree and finding the ZF solution, possible
techniques to perform the QR decomposition in hardware are reviewed
in order to estimate the overall complexity of the receiver.


\subsection{QR decomposition}

As already outlined, a linear transformation of the channel matrix ,
such as QR or Cholesky decomposition is needed in order to construct the tree.

QR decomposition is a well studied numerical algorithm and widely
used in many applications such as matrix inversion, adaptive
beamforming and filtering. The QR decomposition based - Recursive Least
Squares (QRD-RLS) methods are routinely adopted in applications such
as multiuser detection in CDMA communications, adaptive equalization
of radio channels etc. The method is well suited to VLSI realization
and it can be implemented in a stable manner using relatively short
word length arithmetic.

Hardware realization of this technique implies the choice between
Householder transformation and Givens rotation based algorithms
\cite{MxCom}. This second approach can be accomplished by a sequence
of rotation operations to annihilate elements under the main
diagonal of the matrix. Givens rotations require a larger number of
flops compared to Householder method in order to compute QR
decomposition, nevertheless they may be implemented using highly
parallel systolic arrays and for this reason they are usually
preferred for hardware implementation.

These arrays typically present linear, triangular, or square
structure; the rotation angle is computed in boundary or diagonal
processors and dispatched to other processors for rotation. The
choice of the organization can be made on the basis of area and
throughput considerations. The main parameters of this architecture
are listed in Table \ref{Table: QRcomp}, for a  matrix:
number of {\it processing elements} (PE), latency and throughput. It is
assumed that every processing element takes one or more clock cycles
to perform its computation.

\begin{table*}
\centering
\caption{QR decomposition: different array organization parameters - number of processing elements (PE),
latency and throughput}
\begin{tabular}{|c||c|c|c|} \hline
{\bf Architecture} &{\bf \# of PEs}& {\bf latency of single QR}& {\bf Throughput}\\ \hline \hline
Triangular &  &  & \\ \hline
 & &  & \\
Linear &  & & \\
& &  & \\ \hline
Single Element & 1 &  &  \\ \hline\end{tabular}
\label{Table: QRcomp}
\end{table*}


Every single processing element must perform the angle calculation
and the rotation to annihilate the matrix elements. Several
alternatives exist to accomplish these two tasks, and the two main
ones are:

\begin{enumerate}
\item {\it Sine} and {\it cosine} of the angle are computed by means of
operations including also square root and division.
\item Direct calculation of the angle and then rotation using a CORDIC
processor~\cite{CORDIC1}.
\end{enumerate}

The main advantage of the first approach is that primitives can be
optimized resulting in an efficient although expensive
implementation. The second technique is less expensive, but outputs
are generated with longer latencies and data-dependency between
operations slows down the CORDIC algorithm. Many strategies have
been adopted in order to alleviate the effects of data-dependencies, such as
reordering look-ahead\cite{Annih1, Annih2, ReorgCORDIC1} or
redundant arithmetic \cite{RedundantQR}.

For lower data-rates, architectures that reuse the processing elements
on different data have been proposed in~\cite{Alternat1, Alternat2}.
These architectures represent probably the best
tradeoff for the applications addressed in this work.

\section{First Hardware Implementation: \\
Parametrizable Solution}

\label{HW1}

The tree-search algorithm is considered as the most computationally intensive 
processing block in a MIMO detector, although 
column reordering and QR decomposition can also be heavy processing tasks.
However,  since the rate of updating for channel estimation is usually one
or two orders of magnitude lower than the signalling rate, design constraints
tend to be more stringent for the tree-search unit than for
column reordering and the QR decomposition.
Thus the focus of this work is on the hardware realization of
the tree-search algorithm.

As guidelines for the design of the architecture, two main
objectives have been taken into account. The first requirement was a
certain degree of flexibility in the choice of both modulation
scheme. The second main design
objective was a high decoding throughput, compliant with 
needs of modern wireless communication standards.


In the developed architecture, the datapath width, the size
of the search tree and the modulation scheme are tunable
parameters that can be statically configured to make the detector
adaptable to different systems. Although the system is
described with reference to the special case of the Golden code, it
can be also used to decode a  uncoded MIMO scheme.
The key elements of the developed architecture
are described in the following paragraphs.
\subsection{A flexible hardware solution}


The key processing task in the tree exploration algorithm is given by
(\ref{MetrEq}), where we recall that
,
is the -th entry of an  elements vector 
, where  is the tree level we are referring to. 
At level , the generic -th entry of this vector can be decomposed in a 
recursive manner 
through the following expression

\noindent where  is in the range  while the level  decreases from  to . 

The whole  can therefore be updated by means of 
   
 \noindent where  is the -th column of 
and the initial value is given by                                   .

In order to minimize the
final metric  with a greedy algorithm, at each level of the tree the
minimum  value between all sons must be
selected. More precisely,
at each tree node, placed at level , three main operations have to be accomplished:
\begin{enumerate}
\item the  that minimizes the difference  is selected
\item the partial metric  is calculated according to~(\ref{MetrEq}).
\item for each ,  is evaluated for the selected  value,
according to~(\ref{psiEq})
\end{enumerate}
Thus the straightforward minimization of partial metrics 
requires the difference computation for all
the possible values of . This technique becomes increasingly expensive 
with high order modulations, due to the large number of required
operations. 

In the proposed architecture, the minimization of 
is rearranged in two steps. 
In the first processing step, the value of  that minimizes
the difference  is directly selected by means of a division;
the obtained  is then used to generate  amounts in~(\ref{psiEq}),
for all .
At the second step, 
(\ref{MetrEq}) is finally evaluated  to obtain the actual metric
value  for the selected son.
Two functional blocks, \textbf{U\_psi}
and \textbf{Metric\_compute} units, are allocated to perform the indicated 
processing steps.\\

In order to find the value of  able to
minimize  , \textbf{U\_psi} unit (shown in Figure~\ref{U_psi}) 
receives as inputs the
 derived at the upper tree level, together with the
-th diagonal element of matrix . The result of the division 
 is approximated to the closest odd integer.
This approximation is equivalent to the selection of the closest
point in a -PAM  constellation. 

The resulting value
directly provides the desired  for the analyzed node.
The new  values are then evaluated in parallel, to be used at the 
lower tree level. 

\begin{figure}[ht]
    \begin{center}
    \includegraphics[height=8.0cm]{U_psi.eps}
    \caption{U\_psi Unit datapath}
    \label{U_psi}
    \end{center}
\end{figure}
Vector  is stored in a dedicated memory, 
which will be later referred to as \textbf{Psi memory} in
the global architecture given in Figure~\ref{Architecture}. 

The  output in Figure~\ref{U_psi} is defined as

\noindent and it represents the correction term to be applied to the division result in order 
to take the closest point in the equivalent PAM constellation. The use of  will be described 
later in this Section.\\

The \textbf{Metric\_compute} unit realizes the second processing step, 
evaluating the new metric  for the selected son.
Figure~\ref{Metric_block} shows the block architecture: from the upper tree level,
 is received as input, together with the  value generated
by \textbf{U\_psi} unit; the obtained  is propagated to the lower tree level.
\begin{figure}[ht]
    \begin{center}
    \includegraphics[height=8.0cm]{Metric_Compute.eps}
    \caption{Architecture of the \textbf{Metric\_compute} unit}
    \label{Metric_block}
    \end{center}
\end{figure}

The described approach, and particularly the use of a division to obtain the 
optimal , allows avoiding multiple metric computations; thus it
offers low complexity and, at the same time, flexibility in terms of
supported modulation schemes.
As a matter of fact, a parallel architecture tailored on a given search tree
is able to achieve high processing speed, while
the sequential computation of a single metric at each cycle
makes it easier for the decoder to adapt to different
structures of the search tree, so providing support to multiple modulation
schemes. Similarly to what is done in a software implementation, sequential 
operations compute a single metric at every cycle, so that the same processing 
platform can easily adapt to different structures of the search tree by
simply varying the number of search steps in the tree.

On the other hand, differently from what was implemented in previous
detectors, multiplications cannot be reduced to add and shift
procedures since operands are not fixed and as a consequence general
purpose multipliers have been allocated.


It is worth noting that, although the described technique introduces
the division , only a few values of this ratio
are of interest for the algorithm, those that correspond to the equivalent PAM
constellation points . As a consequence, a
general purpose hardware divisor is not necessary and the required
operation can be executed by means of a simplified component able only to
find the closest integer solution of this division and to determine
if the approximation is by defect or by excess: the first 
steps of a successive subtraction divider~\cite{ArithBook} can be
employed to this purpose, where  is the number of signals in
the QAM constellation. This divider has a very simple architecture
that employs only shifts and subtractions; although it tends to be
very slow for a complete division, this solution can be effectively
used when only a few shift and add steps are required. The divider employs a
dichotomous process to find the requested value after 
steps. In the block diagram of Figure \ref{Divisor}, the multiplexer
selects the dividend at the first step and the subtraction result 
in the following ones; the -bit variable shifter is
used to shift the divider by a number of positions that changes from
the initial value of  down to 0. The subtractor
returns the result one bit per iteration, starting from
the most significant one.
\begin{figure}[t!]
    \begin{center}
    \includegraphics[height=5cm ]{Divisor.eps} \caption{Block diagram of the divisor}
    \label{Divisor}
    \end{center}
\end{figure}


\subsection{Parallelism and pipelining}

The desired functional flexibility cannot be achieved at the
expenses of processing throughput, but the final architecture must
properly conjugate both features of flexibility and high data rates.
Among effective techniques that can be used to increase throughput,
parallelism and pipelining have been considered. In previous
works, high throughput is obtained resorting to
parallel architectures and two different kinds of parallelism are
usually  employed:
\begin{itemize}
\item Parallelism at the level of tree exploration
\item Parallelism at the level of the metric computation
      for all sons of a given node and in the
      selection of the most probable son.
\end{itemize}
 The first technique can be used only with some suboptimal algorithms \cite{Kbest}
and it becomes unfeasible when optimal algorithms are adopted,
since it requires large amounts of hardware resources.
The second approach
is feasible only with low order QAM modulation schemes as it implies many
concurrent multiplications. Thus these techniques are not viable for the implementation of parametric architectures.
As a consequence, in this work,
the pipelining technique has been investigated.

In order to ensure that a new node is expanded at each clock cycle,
a new, alternative metric must be
available also after a pruning operation has taken place. As a
consequence, when the metrics of a given father node are evaluated, two
``candidate'' nodes are concurrently computed: the first one is a direct son
of the current node and it is processed by the \textbf{U\_psi} unit,
while the alternative node, placed at a higher level in the tree, 
is concurrently computed by the 
\textbf{U\_psi\_step} sub-circuit (see Figure \ref{U_psi_step_block}). Both of 
them generate novel  values for the next step in the tree traversal.
\begin{figure}[t!]
    \begin{center}
    \includegraphics[width=8cm]{U_psi_step.eps} \caption{Architecture of the U\_psi\_step unit}
    \label{U_psi_step_block}
    \end{center}
\end{figure}

\textbf{U\_psi} and \textbf{U\_psi\_step} units share a very similar architecture,
however the latter does not need to perform the division, as the second best choice for 
(and thus for the alternative node)
can be easily derived as follows. When \textbf{U\_psi} unit computes the division, the result is 
approximated either by defect or by excess to the nearest PAM constellation point:
the best choice for  is given by (see Figure~\ref{method})

\noindent where  is the correction term provided as output by the 
\textbf{U\_psi} unit (Figure~\ref{U_psi}).

The sign of  is used by \textbf{U\_psi\_step} unit to take the second
(and following) nearest point in the PAM constellation, according to the 
following rule, implemented in the top block of Figure~\ref{U_psi_step_block}

\noindent where  is the distance between two consecutive points and the initial value,
, is the closest point given in equation~(\ref{delta_def}).

Figure \ref{method} shows the sequence of alternative 
nodes selected at a given tree level, after the occurrence of pruning.
\begin{figure}[t!]
    \begin{center}
    \includegraphics[width=0.9\linewidth]{method.eps} \caption{Method used to select alternative nodes in U\_psi\_step unit}
    \label{method}
    \end{center}
\end{figure}
Depending on the values assumed by the father node metric, the algorithm
descends along the tree, reaching the son node, or it moves to the 
alternative node on the same level.
It is worth noting that the computations of the  values for both
son and alternative nodes
are performed concurrently with the elaboration of the  metric for the
father node.
In other words, while the current metric is computed for the father node,
the next node to be visited is identified choosing
between the son and the alternative node. Additionally, the
related  value is computed to be used at the following step
in order to obtain the proper metric  .

This approach also provides a significant speed-up to the inherently
serial SE Sphere Decoding algorithm and  has a limited impact on
complexity.

\subsection{Global architecture}

The block scheme of the SE tree-traversal circuit showing the architecture 
derived from the design criteria outlined in previous paragraphs is depicted 
in Figure \ref{Architecture}.
Four fundamental processing blocks can be identified in this architecture:


\begin{itemize}
\item \textbf{U\_psi} unit, which selects the most probable son of the current 
node and computes updated  through expression~(\ref{boldpsieq}) 
(see also Figure~\ref{U_psi});
\item \textbf{U\_psi\_step} unit, which selects the alternative node to be 
expanded and computes for this node the same amount;

\item \textbf{Metric\_compute} unit, which computes metric of the current node 
, 
as in equation (\ref{MetrEq});

\item \textbf{C.U.}, control unit devoted to the proper selection of the
tree search direction.
\end{itemize}

The {\bf C.U.} constitutes the core of the tree traversal algorithm
and it must also carry-out two further tasks: to verify the pruning
condition and, on the basis of this verification, to properly
dispatch data between the other units. Symbols given in Figure~\ref{Architecture}
are related to the case of a node expanded in the depth-first mode, with
no pruning: as a consequence, inputs of the \textbf{Metric\_compute} unit 
are fed with outputs provided by \textbf{U\_psi} block. When a pruning
occurs, multiplexers are switched and metrics related to the alternative node
are selected.

Finally, \textbf{Psi Memory} stores  vectors 
from one step to the following one.

\begin{figure}[ht]
    \begin{center}
    \includegraphics[width=0.8\linewidth]{Architecture2.eps}
    \caption{{\it Sphere decoder} block scheme (case of a node expanded in the depth-first mode, with
no pruning). }
    \label{Architecture}
    \end{center}
\end{figure}
\section{Second Hardware Implementation: Flexible Modulation Solution}

\label{HW2}

The capability of managing more than one modulation
scheme in order to adaptively select the most efficient one according to user
needs and channel conditions, is one of the most important requirements of
modern wireless communications systems.
The Golden code, thanks to the non-vanishing determinant property, is
very well suited for such application since it achieves the best performance
independently of the QAM size.
In order to take full advantage of this Golden code feature, an enhanced 
implementation has been realized to allow run-time choice of the modulation 
scheme.

This implementation relies on the same architecture described in the previous 
section, with an additional parameter that allows the run-time selection of 
the constellation.
The requirement of supporting multiple modulation schemes basically impacts on 
the control logic, while the other architecture components remain the same as 
in the first hardware implementation.

At each level of the tree, the C.U., besides the pruning condition
verification, also carries out a second verification task, related to the {\it mapping constraint}:
it verifies if a certain value of  still belongs to the specified constellation
and uses this information to drive the processing.

This {\it mapping constraint} must also be taken into account in the
division . As the number of acceptable values for
this operation depends on the adopted modulation, 
the constellation parameter is used to dynamically drive the
iterations of the dichotomic division algorithm.\\

Although the architecture deals with the implementation of the Golden Code where ,
it is also scalable in terms of . Increasing the number of transmitting and 
receiving antennas: a larger value of the  parameter
can be set in the VHDL code to synthesize detectors for larger STBcodes. 
Of course a larger  implies a more expensive architecture: particularly
the value of  mainly affects:
\begin{itemize}
\item the number of  values to be evaluated in parallel in Figures 6 and 9
\item the depth of the tree 
\item the size of  memory.
\end{itemize}
The complexity of processing blocks in Figures~\ref{U_psi} and \ref{U_psi_step_block} 
grows almost linearly 
with ; the memory size increases as , because  values of  have to
be stored for  tree levels. Finally the throughput is expected to decrease
with , since the number of visited nodes grows, but this effect is strongly
dependent also on the supported code.


\section{Synthesis results}
\label{sec:Result}

The first proposed architecture, tailored to process the 16-QAM case,
has been synthesized on both m and m
CMOS Standard Cell technologies, using the Synopsys Version Z-2007.03-SP1; 
synthesis on m technology has been performed
for the second flexible architecture.
A commercial low-power library has been chosen.

In order to enable the direct comparison with existing hardware realizations~\cite{ethvlsi}, I and II ASIC,
\cite{lundvlsi}, a 16 bit datapath has been chosen and the overall decoder has
also been simulated with the uncoded 44 MIMO system and throughput
figures reported in Table~\ref{SynthTable} refer to this configuration.
\begin{table*}[t]
\renewcommand{\arraystretch}{1.3}
\centering
\caption{Synthesis results and comparisons (16 bits)}
\vspace {1pt}
\label{SynthTable}
\begin{tabular}{|c||c|c|c|c|c|c|} \hline
& & & & \multicolumn{3}{c|}{This work}\\\hline
Reference & ASIC-I \cite{ethvlsi} & ASIC-II \cite{ethvlsi} & \cite{lundvlsi} & \multicolumn{2}{c|}{PARAMETRIZABLE IMP.} & FLEXIBLE IMPL. \\ \hline\hline

Antennas & \multicolumn{3}{c|} {44} &
\multicolumn{3}{c|}{22 per two channel uses}\\ \hline
Modulation & 16-QAM & 16-QAM & 16-QAM & \multicolumn{2}{c|}{16-QAM} & 4,16,64-QAM\\ \hline
Detector & depth-first & & K-best & \multicolumn{3}{c|}{depth-first}\\
& sphere & sphere & sphere & \multicolumn{3}{c|}{sphere} \\ \hline
BER Perf. & ML & Close to ML & Close to ML & \multicolumn{3}{c|}{ML} \\ \hline
Tech. [m]& 0.25 & 0.25 & 0.35 & 0.25 & 0.13 & 0.13 \\ \hline
Core Area [GE] & 117K & 50K & 91K & 56K & 45K & 55K \\
 & +preproc. & +preproc. & +preproc. & +preproc. & +preproc. & +preproc.\\ \hline
Max. Clock & 51 MHz & 71 MHz & 100 MHz & 109 MHz & 250 MHz & 217 MHz \\ \hline
Throughput & 73 Mbps & 169Mbps & 52 Mbps & 73 Mbps & 167 Mbps & 146 Mbps\\
& @SNR=20 dB & @SNR=20 dB & & @SNR=20 dB & @SNR=20 dB & @SNR=20 dB \\ \hline
\end{tabular}
\end{table*}

The comparison of the described architectures to existing implementations tend 
to be quite difficult to carry out, because different approaches have been
adopted: particularly, our solution implements the ML detection algorithm by means of 
a serial architecture, while the first ASIC in \cite{ethvlsi} maps the same algorithm
onto a parallel structure and the second ASIC in \cite{ethvlsi} makes use of a
serial scheme to realize a close to ML algorithm. These differences must
be carefully evaluated while reading results in Table~\ref{SynthTable}.\\

Comparing the parameterizable architecture to parallel implementations
in Table~\ref{SynthTable}, the solution described in~\cite{lundvlsi} and 
the first ASIC presented in \cite{ethvlsi},
it can be observed that a single metric computation is performed at
each cycle, instead of multiple parallel metric computations. This
characteristic justifies both the reduced complexity and the inherent
flexibility of the proposed architecture.
At the same time, thanks to the adopted pipelined architecture, a
remarkable average decoding throughput is achieved without any 
highly specialized structure.

Implementation cost is slightly higher than for the second ASIC 
proposed in~\cite{ethvlsi}, where a serial approach is also adopted, in conjunction with 
a close to ML algorithmic approach. 

On the other hand, the flexible implementation in the last column of Table~\ref{SynthTable} 
prove the limited complexity and performance overhead associated to the 
capability of dynamically adapting to different modulations (4-,
16- and 64-QAM).\\

Finally, the results presented in Section~\ref{FIX} on the finite precision
analysis of the decoding algorithm have been exploited to derive
additional post synthesis figures for the flexible architecture:
these results, referred to different datapath widths, are given in
Table~\ref{Table:DP Width Synth}. A total of 14 bits are enough for
the 64-QAM modulation (6 bits for the integer part and 8 for the
fractional one) and the two saved bits grant a complexity reduction
of 8 Kgates.


\begin{table}
\centering
\caption{Different datapath width synthesis results}
\begin{tabular}{|c||c|c|c|c|} \hline
DP Width&Area[kG]&Period[ns]&Freq.[MHz]&Through.[Mbps]\\ \hline\hline
12 & 41 & 4.3 & 232 & 155 (16-QAM)\\ \hline
14 & 47 & 4.45 & 224 & 150 (16-QAM)\\ \hline
16 & 55 & 4.6 & 217 & 146 (16-QAM)\\ \hline\end{tabular}
\label{Table:DP Width Synth}
\end{table}


\section{Conclusions}
A novel approach has been presented for the hardware implementation 
of a Sphere Decoder detector: the proposed solution uses a single metric computation per cycle and
is well suited for pipelining, breaking the sequential nature of SD
algorithm.

The main element of novelty of the described approach is in its 
inherent flexibility that makes it suitable for the implementation of
an adaptive modulation scheme.
Two different hardware architectures have been designed: the first 
implementation is a parametrizable one,
while the second is able to adapt on the fly to different modulation
schemes.

The data representation format adopted in both implementations is
based on exhaustive analysis of finite precision effects
collected for 16 and 64 QAM modulations.

Final synthesis results of the proposed architectures are listed in
Table \ref{SynthTable} and show a significant complexity reduction
(approx.  for 16 QAM modulation) with respect to parallel
structures. This is mainly due to the single metric computation per
cycle. A remarkable average decoding throughput can be achieved with
both implementations, thanks to the pipelining technique, even if
the hardware was not tailored on a single modulation scheme as all
previously proposed solutions.

\bibliographystyle{IEEEtran}

\begin{thebibliography}{10}

\bibitem{Golden1}
J.-C. Belfiore, G.~Rekaya, and E.~Viterbo, ``The Golden code: A
 full-rate space-time code with non-vanishing
determinants,'' \emph{{IEEE} Trans. Inform. Theory}, vol.~51, no.~4,
pp.~1432--1436, April 2005.

\bibitem{ethvlsi}
A.~Burg, M.~Borgmann, M.~Wenk, M.~Zellwegger, W.~Fichtner, and
H.~B{\"o}Loki's, ``{VLSI} implementation of {MIMO} detection using
the sphere decoding   algorithm,'' \emph{{NE'ER} J. Solid-State
Circuits}, vol.~40, no.~7, pp.~1566--1577, July 2005.

\bibitem{Annih2}
Z.~Chi, J.~Ma, and K.~K. Parhi, ``Hybrid annihilation transformation
{(HAT)}  for pipelining {QRD}-based least-square adaptive filter,''
\emph{{IEEE}  Trans. Circuits Syst. {II}}, vol.~48, no.~7, pp.
661--674, July 2001.

\bibitem{CODES2}
M.~Damen, A.~Tewfik, and J.-C. Belfiore, ``A construction of a
space-time code based on number theory,'' \emph{{IEEE} Trans.
Inform. Theory}, vol.~48, no.~3, pp.~753--760, March 2002.

\bibitem{Caire&ot1}
M.~O. Damen, H.~{El Gamal}, and G.~Caire, ``On maximum-likelihood
detection and  the search of the closest lattice point,''
\emph{{IEEE} Trans. Inform. Theory}, vol.~49, no.~10,
pp.~2389--2402, October 2003.

\bibitem{Golden3}
P.~Dayal and M.~Varanasi, ``An optimal two transmit antenna
space-time code and   its stacked extensions,'' in \emph{Proc. of
Asilomar Conf. on Signals, Systems and Computers}, November 2003.

\bibitem{Alternat1}
F.~Edman and V.~{\"O}wall, ``Implementation of a scalable matrix
inversion architecture for triangular matrices,'' in \emph{14th IEEE
Proc. Personal, Indoor and Mobile Radio Communications, 2003. PIMRC
2003}, Sept. 2003, pp.~2558--2562.

\bibitem{RedundantQR}
M.~D. Ercegovac and T.~Lang, ``Redundant and on-line {CORDIC}:
application to  matrix triangularization and {SVD},'' \emph{{IEEE}
Trans. Comput.}, vol.~39, no.~6, pp.~725--740, June 1990.

\bibitem{Pohst}
U.~Fincke and M.Pohst, ``Improved methods for calculating vectors of
short length in a lattice, including a complexity analysis,''
\emph{Math. Computat.}, vol.~44, no. 170, pp. 463--471, April 1985.

\bibitem{MxCom}
G.~H. Golub and C.~F. {Van Loan}, \emph{Matrix Computations}.
 The John Hopkins University Press, 1996.

\bibitem{lundvlsi}
Z.~Guo and P.~Nilsson, ``A {VLSI} architecture for the
{S}chnorr-{E}uchner decoder for {MIMO} systems,'' in \emph{Proc.
{IEEE CAS} {S}ymp. {E}merging {T}echnologies}, June 2004,
pp.~65--68.

\bibitem{CORDIC1}
B.Haller, J.G{\"o}tze, and J.~Cavallaro, ``Efficient implementation
of rotation  operations for high performance {QRD-RLS} filtering,''
in \emph{Proc. IEEE   International Conference on
Application-Specific Systems, Architectures and   Processors}, 14-16
July 1997, pp. 162--174.

\bibitem{Alternat2}
B.Haller, J.G{\"o}tze, and J.~Cavallaro, ``Area and power efficient
{VLSI}  architecture for computing pseudo inverse of channel matrix
in a MIMO  wireless system,'' in \emph{19th Intern. Conf. VLSI
Design, 2006.}, 03-07 January 2006, pp. 734--737.

\bibitem{ReorgCORDIC1}
R.~Hamill and R.~L. Walke, ``Online {CORDIC} implementation and
{VLSI} architecture for implementing qr-array processors,''
\emph{{IEEE} Trans. Signal Processing}, vol.~48, no.~2, pp.
592--1598, February 2000.

\bibitem{LD-STBC}
B.~Hassibi and B.~Hochwald, ``High-rate codes that are linear in
space and time,'' \emph{{IEEE} Trans. Inform. Theory}, vol.~48,
no.~7, pp. 1804--1824, July 2002.

\bibitem{ControCompl}
J.~Jalden and B.~Ottersten, ``On the complexity of sphere decoding
in digital  communications,'' \emph{{IEEE} Trans. Signal
Processing}, vol.~53, no.~4, pp.~1474--1484, April 2005.

\bibitem{Annih1}
J.~Ma, K.~K. Parhi, and E.~F. Deprettere, ``Annihilation-reordering
look-ahead pipelined {CORDIC}-based {RLS} adaptive filters and their
application to   adaptive beanforming,'' \emph{{IEEE} Trans. Signal
Processing}, vol.~48,  no.~8, pp.~2414--2431, August 2000.

\bibitem{ArithBook}
B.~Parhami, \emph{Computer Arithmetic. Algorithms and hardware
designs}. Oxford University Press, 2000.

\bibitem{gigabit}
A.~Paulraj, D.~Gore, R.~Nabar, and H.~B{\"o}lcskei, ``An overview of
{MIMO} communications - a key to {G}igabit wireless,''
\emph{Proceedings of the IEEE}, vol.~92, no.~2, pp. 198--218,
February 2004.

\bibitem{SE}
C.~Schnorr and M.~Euchner, ``Lattice basis reduction: inmproved
practical  algorithms and solving subset sum problems,'' \emph{Math.
Programming}, vol.~66, no.~2, pp. 181--191, September 1994.

\bibitem{CODES3}
B.~A. Sethuraman, B.~S. Rajan, and V.~Shashidhar, ``Full-diversity,
highrate space-time block codes from division algebras,''
\emph{{IEEE} Trans. Inform. Theory}, vol.~49, no.~10,
pp.~2596--2616, Oct. 2003.

\bibitem{Criterion}
V.~Tarokh, N.~Seshandri, and A.~Calderbank, ``Space-time codes for
high data  rate wireless communication: Performance criterion and
code construction,''   \emph{{IEEE} Trans. Inform. Theory}, vol.~44,
no.~2, pp. 744--765, Mar. 1998.

\bibitem{Viterbo93}
E.~Viterbo and E.~Biglieri, ``A universal decoding algorithm for
lattice codes,'' in \emph{Quatorzieme colloque GRETSI}, Sept. 1993.

\bibitem{Viterbo99}
E.~Viterbo and J.~Boutros, ``A universal lattice code decoder for
fading channels,'' \emph{{IEEE} Trans. Inform. Theory}, vol.~45,
no.~5, pp.~1639--1642, July 1999.

\bibitem{GoldenPage}
E.~Viterbo. (2006) The Golden Code Homepage. [Online]. Available:\\
  \url{http://www1.tlc.polito.it/~viterbo/perfect_codes/Golden_Code.html}

\bibitem{Golden2}
H.~Yao and G.~Wornell, ``Achieving the full {MIMO}
diversity-multiplexing frontier with rotation-based space-time
codes,'' in \emph{Proc. of Allerton   Conf. on Communication,
Control and Computing}, October 2003.

\bibitem{gigabit2}
P.~W. Wolniansky, G.~J. Foschini, G.~D. Golden, and R.~A.
Valenzuela,  ``{V-BLAST}: An architecture for realizing very high
data rates over the   rich-scattering wireless channel,'' in
\emph{Int. Symp. Signals, Systems, and Electronics}, October 1998,
pp. 295--300.

\bibitem{Kbest}
K.~Wong, C.~Tsui, R.~S. Cheng, and W.~Mow, ``A {VLSI} architecture
of a K-best lattice decoding algorithm for {MIMO} channels,'' in
\emph{Proc. IEEE ISCAS'02}, 2002, pp. 273--276.

\end{thebibliography}






















\end{document}
