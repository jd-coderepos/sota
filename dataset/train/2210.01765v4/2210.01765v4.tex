
\documentclass{article} \usepackage[dvipsnames]{xcolor}
\usepackage{camera_ready,times}



\usepackage{amsmath,amsfonts,bm}

\usepackage{mathtools}
\usepackage{amssymb}
\usepackage{latexsym}
\usepackage{dsfont}
\usepackage{mathrsfs}
\usepackage{amssymb}
\usepackage{xspace}
\usepackage{amsthm}

\newcommand{\figleft}{{\em (Left)}}
\newcommand{\figcenter}{{\em (Center)}}
\newcommand{\figright}{{\em (Right)}}
\newcommand{\figtop}{{\em (Top)}}
\newcommand{\figbottom}{{\em (Bottom)}}
\newcommand{\captiona}{{\em (a)}}
\newcommand{\captionb}{{\em (b)}}
\newcommand{\captionc}{{\em (c)}}
\newcommand{\captiond}{{\em (d)}}

\newcommand{\newterm}[1]{{\bf #1}}


\def\figref#1{figure~\ref{#1}}
\def\Figref#1{Figure~\ref{#1}}
\def\twofigref#1#2{figures \ref{#1} and \ref{#2}}
\def\quadfigref#1#2#3#4{figures \ref{#1}, \ref{#2}, \ref{#3} and \ref{#4}}
\def\secref#1{section~\ref{#1}}
\def\Secref#1{Section~\ref{#1}}
\def\twosecrefs#1#2{sections \ref{#1} and \ref{#2}}
\def\secrefs#1#2#3{sections \ref{#1}, \ref{#2} and \ref{#3}}
\def\eqref#1{equation~\ref{#1}}
\def\Eqref#1{Equation~\ref{#1}}
\def\plaineqref#1{\ref{#1}}
\def\chapref#1{chapter~\ref{#1}}
\def\Chapref#1{Chapter~\ref{#1}}
\def\rangechapref#1#2{chapters\ref{#1}--\ref{#2}}
\def\algref#1{algorithm~\ref{#1}}
\def\Algref#1{Algorithm~\ref{#1}}
\def\twoalgref#1#2{algorithms \ref{#1} and \ref{#2}}
\def\Twoalgref#1#2{Algorithms \ref{#1} and \ref{#2}}
\def\partref#1{part~\ref{#1}}
\def\Partref#1{Part~\ref{#1}}
\def\twopartref#1#2{parts \ref{#1} and \ref{#2}}

\def\ceil#1{\lceil #1 \rceil}
\def\floor#1{\lfloor #1 \rfloor}
\def\1{\bm{1}}
\newcommand{\train}{\mathcal{D}}
\newcommand{\valid}{\mathcal{D_{\mathrm{valid}}}}
\newcommand{\test}{\mathcal{D_{\mathrm{test}}}}

\def\eps{{\epsilon}}


\def\reta{{\textnormal{}}}
\def\ra{{\textnormal{a}}}
\def\rb{{\textnormal{b}}}
\def\rc{{\textnormal{c}}}
\def\rd{{\textnormal{d}}}
\def\re{{\textnormal{e}}}
\def\rf{{\textnormal{f}}}
\def\rg{{\textnormal{g}}}
\def\rh{{\textnormal{h}}}
\def\ri{{\textnormal{i}}}
\def\rj{{\textnormal{j}}}
\def\rk{{\textnormal{k}}}
\def\rl{{\textnormal{l}}}
\def\rn{{\textnormal{n}}}
\def\ro{{\textnormal{o}}}
\def\rp{{\textnormal{p}}}
\def\rq{{\textnormal{q}}}
\def\rr{{\textnormal{r}}}
\def\rs{{\textnormal{s}}}
\def\rt{{\textnormal{t}}}
\def\ru{{\textnormal{u}}}
\def\rv{{\textnormal{v}}}
\def\rw{{\textnormal{w}}}
\def\rx{{\textnormal{x}}}
\def\ry{{\textnormal{y}}}
\def\rz{{\textnormal{z}}}

\def\rvepsilon{{\mathbf{\epsilon}}}
\def\rvtheta{{\mathbf{\theta}}}
\def\rva{{\mathbf{a}}}
\def\rvb{{\mathbf{b}}}
\def\rvc{{\mathbf{c}}}
\def\rvd{{\mathbf{d}}}
\def\rve{{\mathbf{e}}}
\def\rvf{{\mathbf{f}}}
\def\rvg{{\mathbf{g}}}
\def\rvh{{\mathbf{h}}}
\def\rvu{{\mathbf{i}}}
\def\rvj{{\mathbf{j}}}
\def\rvk{{\mathbf{k}}}
\def\rvl{{\mathbf{l}}}
\def\rvm{{\mathbf{m}}}
\def\rvn{{\mathbf{n}}}
\def\rvo{{\mathbf{o}}}
\def\rvp{{\mathbf{p}}}
\def\rvq{{\mathbf{q}}}
\def\rvr{{\mathbf{r}}}
\def\rvs{{\mathbf{s}}}
\def\rvt{{\mathbf{t}}}
\def\rvu{{\mathbf{u}}}
\def\rvv{{\mathbf{v}}}
\def\rvw{{\mathbf{w}}}
\def\rvx{{\mathbf{x}}}
\def\rvy{{\mathbf{y}}}
\def\rvz{{\mathbf{z}}}

\def\erva{{\textnormal{a}}}
\def\ervb{{\textnormal{b}}}
\def\ervc{{\textnormal{c}}}
\def\ervd{{\textnormal{d}}}
\def\erve{{\textnormal{e}}}
\def\ervf{{\textnormal{f}}}
\def\ervg{{\textnormal{g}}}
\def\ervh{{\textnormal{h}}}
\def\ervi{{\textnormal{i}}}
\def\ervj{{\textnormal{j}}}
\def\ervk{{\textnormal{k}}}
\def\ervl{{\textnormal{l}}}
\def\ervm{{\textnormal{m}}}
\def\ervn{{\textnormal{n}}}
\def\ervo{{\textnormal{o}}}
\def\ervp{{\textnormal{p}}}
\def\ervq{{\textnormal{q}}}
\def\ervr{{\textnormal{r}}}
\def\ervs{{\textnormal{s}}}
\def\ervt{{\textnormal{t}}}
\def\ervu{{\textnormal{u}}}
\def\ervv{{\textnormal{v}}}
\def\ervw{{\textnormal{w}}}
\def\ervx{{\textnormal{x}}}
\def\ervy{{\textnormal{y}}}
\def\ervz{{\textnormal{z}}}

\def\rmA{{\mathbf{A}}}
\def\rmB{{\mathbf{B}}}
\def\rmC{{\mathbf{C}}}
\def\rmD{{\mathbf{D}}}
\def\rmE{{\mathbf{E}}}
\def\rmF{{\mathbf{F}}}
\def\rmG{{\mathbf{G}}}
\def\rmH{{\mathbf{H}}}
\def\rmI{{\mathbf{I}}}
\def\rmJ{{\mathbf{J}}}
\def\rmK{{\mathbf{K}}}
\def\rmL{{\mathbf{L}}}
\def\rmM{{\mathbf{M}}}
\def\rmN{{\mathbf{N}}}
\def\rmO{{\mathbf{O}}}
\def\rmP{{\mathbf{P}}}
\def\rmQ{{\mathbf{Q}}}
\def\rmR{{\mathbf{R}}}
\def\rmS{{\mathbf{S}}}
\def\rmT{{\mathbf{T}}}
\def\rmU{{\mathbf{U}}}
\def\rmV{{\mathbf{V}}}
\def\rmW{{\mathbf{W}}}
\def\rmX{{\mathbf{X}}}
\def\rmY{{\mathbf{Y}}}
\def\rmZ{{\mathbf{Z}}}

\def\ermA{{\textnormal{A}}}
\def\ermB{{\textnormal{B}}}
\def\ermC{{\textnormal{C}}}
\def\ermD{{\textnormal{D}}}
\def\ermE{{\textnormal{E}}}
\def\ermF{{\textnormal{F}}}
\def\ermG{{\textnormal{G}}}
\def\ermH{{\textnormal{H}}}
\def\ermI{{\textnormal{I}}}
\def\ermJ{{\textnormal{J}}}
\def\ermK{{\textnormal{K}}}
\def\ermL{{\textnormal{L}}}
\def\ermM{{\textnormal{M}}}
\def\ermN{{\textnormal{N}}}
\def\ermO{{\textnormal{O}}}
\def\ermP{{\textnormal{P}}}
\def\ermQ{{\textnormal{Q}}}
\def\ermR{{\textnormal{R}}}
\def\ermS{{\textnormal{S}}}
\def\ermT{{\textnormal{T}}}
\def\ermU{{\textnormal{U}}}
\def\ermV{{\textnormal{V}}}
\def\ermW{{\textnormal{W}}}
\def\ermX{{\textnormal{X}}}
\def\ermY{{\textnormal{Y}}}
\def\ermZ{{\textnormal{Z}}}

\def\vzero{{\bm{0}}}
\def\vone{{\bm{1}}}
\def\vmu{{\bm{\mu}}}
\def\vtheta{{\bm{\theta}}}
\def\va{{\bm{a}}}
\def\vb{{\bm{b}}}
\def\vc{{\bm{c}}}
\def\vd{{\bm{d}}}
\def\ve{{\bm{e}}}
\def\vf{{\bm{f}}}
\def\vg{{\bm{g}}}
\def\vh{{\bm{h}}}
\def\vi{{\bm{i}}}
\def\vj{{\bm{j}}}
\def\vk{{\bm{k}}}
\def\vl{{\bm{l}}}
\def\vm{{\bm{m}}}
\def\vn{{\bm{n}}}
\def\vo{{\bm{o}}}
\def\vp{{\bm{p}}}
\def\vq{{\bm{q}}}
\def\vr{{\bm{r}}}
\def\vs{{\bm{s}}}
\def\vt{{\bm{t}}}
\def\vu{{\bm{u}}}
\def\vv{{\bm{v}}}
\def\vw{{\bm{w}}}
\def\vx{{\bm{x}}}
\def\vy{{\bm{y}}}
\def\vz{{\bm{z}}}

\def\evalpha{{\alpha}}
\def\evbeta{{\beta}}
\def\evepsilon{{\epsilon}}
\def\evlambda{{\lambda}}
\def\evomega{{\omega}}
\def\evmu{{\mu}}
\def\evpsi{{\psi}}
\def\evsigma{{\sigma}}
\def\evtheta{{\theta}}
\def\eva{{a}}
\def\evb{{b}}
\def\evc{{c}}
\def\evd{{d}}
\def\eve{{e}}
\def\evf{{f}}
\def\evg{{g}}
\def\evh{{h}}
\def\evi{{i}}
\def\evj{{j}}
\def\evk{{k}}
\def\evl{{l}}
\def\evm{{m}}
\def\evn{{n}}
\def\evo{{o}}
\def\evp{{p}}
\def\evq{{q}}
\def\evr{{r}}
\def\evs{{s}}
\def\evt{{t}}
\def\evu{{u}}
\def\evv{{v}}
\def\evw{{w}}
\def\evx{{x}}
\def\evy{{y}}
\def\evz{{z}}

\def\mA{{\bm{A}}}
\def\mB{{\bm{B}}}
\def\mC{{\bm{C}}}
\def\mD{{\bm{D}}}
\def\mE{{\bm{E}}}
\def\mF{{\bm{F}}}
\def\mG{{\bm{G}}}
\def\mH{{\bm{H}}}
\def\mI{{\bm{I}}}
\def\mJ{{\bm{J}}}
\def\mK{{\bm{K}}}
\def\mL{{\bm{L}}}
\def\mM{{\bm{M}}}
\def\mN{{\bm{N}}}
\def\mO{{\bm{O}}}
\def\mP{{\bm{P}}}
\def\mQ{{\bm{Q}}}
\def\mR{{\bm{R}}}
\def\mS{{\bm{S}}}
\def\mT{{\bm{T}}}
\def\mU{{\bm{U}}}
\def\mV{{\bm{V}}}
\def\mW{{\bm{W}}}
\def\mX{{\bm{X}}}
\def\mY{{\bm{Y}}}
\def\mZ{{\bm{Z}}}
\def\mBeta{{\bm{\beta}}}
\def\mPhi{{\bm{\Phi}}}
\def\mLambda{{\bm{\Lambda}}}
\def\mSigma{{\bm{\Sigma}}}

\DeclareMathAlphabet{\mathsfit}{\encodingdefault}{\sfdefault}{m}{sl}
\SetMathAlphabet{\mathsfit}{bold}{\encodingdefault}{\sfdefault}{bx}{n}
\newcommand{\tens}[1]{\bm{\mathsfit{#1}}}
\def\tA{{\tens{A}}}
\def\tB{{\tens{B}}}
\def\tC{{\tens{C}}}
\def\tD{{\tens{D}}}
\def\tE{{\tens{E}}}
\def\tF{{\tens{F}}}
\def\tG{{\tens{G}}}
\def\tH{{\tens{H}}}
\def\tI{{\tens{I}}}
\def\tJ{{\tens{J}}}
\def\tK{{\tens{K}}}
\def\tL{{\tens{L}}}
\def\tM{{\tens{M}}}
\def\tN{{\tens{N}}}
\def\tO{{\tens{O}}}
\def\tP{{\tens{P}}}
\def\tQ{{\tens{Q}}}
\def\tR{{\tens{R}}}
\def\tS{{\tens{S}}}
\def\tT{{\tens{T}}}
\def\tU{{\tens{U}}}
\def\tV{{\tens{V}}}
\def\tW{{\tens{W}}}
\def\tX{{\tens{X}}}
\def\tY{{\tens{Y}}}
\def\tZ{{\tens{Z}}}


\def\gA{{\mathcal{A}}}
\def\gB{{\mathcal{B}}}
\def\gC{{\mathcal{C}}}
\def\gD{{\mathcal{D}}}
\def\gE{{\mathcal{E}}}
\def\gF{{\mathcal{F}}}
\def\gG{{\mathcal{G}}}
\def\gH{{\mathcal{H}}}
\def\gI{{\mathcal{I}}}
\def\gJ{{\mathcal{J}}}
\def\gK{{\mathcal{K}}}
\def\gL{{\mathcal{L}}}
\def\gM{{\mathcal{M}}}
\def\gN{{\mathcal{N}}}
\def\gO{{\mathcal{O}}}
\def\gP{{\mathcal{P}}}
\def\gQ{{\mathcal{Q}}}
\def\gR{{\mathcal{R}}}
\def\gS{{\mathcal{S}}}
\def\gT{{\mathcal{T}}}
\def\gU{{\mathcal{U}}}
\def\gV{{\mathcal{V}}}
\def\gW{{\mathcal{W}}}
\def\gX{{\mathcal{X}}}
\def\gY{{\mathcal{Y}}}
\def\gZ{{\mathcal{Z}}}

\def\sA{{\mathbb{A}}}
\def\sB{{\mathbb{B}}}
\def\sC{{\mathbb{C}}}
\def\sD{{\mathbb{D}}}
\def\sF{{\mathbb{F}}}
\def\sG{{\mathbb{G}}}
\def\sH{{\mathbb{H}}}
\def\sI{{\mathbb{I}}}
\def\sJ{{\mathbb{J}}}
\def\sK{{\mathbb{K}}}
\def\sL{{\mathbb{L}}}
\def\sM{{\mathbb{M}}}
\def\sN{{\mathbb{N}}}
\def\sO{{\mathbb{O}}}
\def\sP{{\mathbb{P}}}
\def\sQ{{\mathbb{Q}}}
\def\sR{{\mathbb{R}}}
\def\sS{{\mathbb{S}}}
\def\sT{{\mathbb{T}}}
\def\sU{{\mathbb{U}}}
\def\sV{{\mathbb{V}}}
\def\sW{{\mathbb{W}}}
\def\sX{{\mathbb{X}}}
\def\sY{{\mathbb{Y}}}
\def\sZ{{\mathbb{Z}}}

\def\emLambda{{\Lambda}}
\def\emA{{A}}
\def\emB{{B}}
\def\emC{{C}}
\def\emD{{D}}
\def\emE{{E}}
\def\emF{{F}}
\def\emG{{G}}
\def\emH{{H}}
\def\emI{{I}}
\def\emJ{{J}}
\def\emK{{K}}
\def\emL{{L}}
\def\emM{{M}}
\def\emN{{N}}
\def\emO{{O}}
\def\emP{{P}}
\def\emQ{{Q}}
\def\emR{{R}}
\def\emS{{S}}
\def\emT{{T}}
\def\emU{{U}}
\def\emV{{V}}
\def\emW{{W}}
\def\emX{{X}}
\def\emY{{Y}}
\def\emZ{{Z}}
\def\emSigma{{\Sigma}}

\newcommand{\etens}[1]{\mathsfit{#1}}
\def\etLambda{{\etens{\Lambda}}}
\def\etA{{\etens{A}}}
\def\etB{{\etens{B}}}
\def\etC{{\etens{C}}}
\def\etD{{\etens{D}}}
\def\etE{{\etens{E}}}
\def\etF{{\etens{F}}}
\def\etG{{\etens{G}}}
\def\etH{{\etens{H}}}
\def\etI{{\etens{I}}}
\def\etJ{{\etens{J}}}
\def\etK{{\etens{K}}}
\def\etL{{\etens{L}}}
\def\etM{{\etens{M}}}
\def\etN{{\etens{N}}}
\def\etO{{\etens{O}}}
\def\etP{{\etens{P}}}
\def\etQ{{\etens{Q}}}
\def\etR{{\etens{R}}}
\def\etS{{\etens{S}}}
\def\etT{{\etens{T}}}
\def\etU{{\etens{U}}}
\def\etV{{\etens{V}}}
\def\etW{{\etens{W}}}
\def\etX{{\etens{X}}}
\def\etY{{\etens{Y}}}
\def\etZ{{\etens{Z}}}

\newcommand{\pdata}{p_{\rm{data}}}
\newcommand{\ptrain}{\hat{p}_{\rm{data}}}
\newcommand{\Ptrain}{\hat{P}_{\rm{data}}}
\newcommand{\pmodel}{p_{\rm{model}}}
\newcommand{\Pmodel}{P_{\rm{model}}}
\newcommand{\ptildemodel}{\tilde{p}_{\rm{model}}}
\newcommand{\pencode}{p_{\rm{encoder}}}
\newcommand{\pdecode}{p_{\rm{decoder}}}
\newcommand{\precons}{p_{\rm{reconstruct}}}

\newcommand{\laplace}{\mathrm{Laplace}} 

\newcommand{\E}{\mathbb{E}}
\newcommand{\Ls}{\mathcal{L}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\emp}{\tilde{p}}
\newcommand{\lr}{\alpha}
\newcommand{\reg}{\lambda}
\newcommand{\rect}{\mathrm{rectifier}}
\newcommand{\softmax}{\mathrm{softmax}}
\newcommand{\sigmoid}{\sigma}
\newcommand{\softplus}{\zeta}
\newcommand{\KL}{D_{\mathrm{KL}}}
\newcommand{\Var}{\mathrm{Var}}
\newcommand{\standarderror}{\mathrm{SE}}
\newcommand{\Cov}{\mathrm{Cov}}
\newcommand{\normlzero}{L^0}
\newcommand{\normlone}{L^1}
\newcommand{\normltwo}{L^2}
\newcommand{\normlp}{L^p}
\newcommand{\normmax}{L^\infty}

\newcommand{\parents}{Pa} 

\DeclareMathOperator*{\argmax}{arg\,max}
\DeclareMathOperator*{\argmin}{arg\,min}

\DeclareMathOperator{\sign}{sign}
\DeclareMathOperator{\Tr}{Tr}
\let\ab\allowbreak





\newcommand{\eq}[1]{(\ref{#1})}
\newcommand{\mymatrix}[2]{\left[\begin{array}{#1} #2 \end{array}\right]}
\newcommand{\mychoose}[2]{\left(\begin{array}{c} #1 \\ #2 \end{array}\right)}
\newcommand{\mydet}[1]{\det\left[ #1 \right]}
\newcommand{\myspan}[1]{\mathrm{span}\cbr{#1}}
\newcommand{\smallfrac}[2]{{\textstyle \frac{#1}{#2}}}
\newcommand{\pwrt}[1]{\frac{\partial}{\partial #1}}
\newcommand{\ppwrt}[1]{\frac{\partial^2}{(\partial #1)^2}}
\newcommand{\aleq}{\preccurlyeq}
\newcommand{\ageq}{\succcurlyeq}




\newcommand{\rbr}[1]{\left(#1\right)}
\newcommand{\sbr}[1]{\left[#1\right]}
\newcommand{\cbr}[1]{\left\{#1\right\}}
\newcommand{\nbr}[1]{\left\|#1\right\|}
\newcommand{\abr}[1]{\left|#1\right|}
\newcommand{\abs}[1]{\left|#1\right|}
\newcommand{\inner}[2]{\left\langle #1,#2 \right\rangle}
\newcommand{\dual}[2]{\left\langle #1;#2 \right\rangle}
\newcommand{\ccc}[1]{|\!|\!|#1|\!|\!|}
\newcommand{\sembrack}[1]{[\![#1]\!]}
\newcommand{\norm}[1]{\left\|#1\right\|}
\newcommand{\dualnorm}[1]{\left\|#1\right\|_{\circ}}


\newcommand{\one}{\mathbf{1}}  \newcommand{\zero}{\mathbf{0}} \newcommand{\half}{\frac{1}{2}}
\newcommand{\sqrttwo}{\sqrt{2}}
\newcommand{\shalf}{\textstyle\frac{1}{2}}
\newcommand{\invsqrttwo}{\frac{1}{\sqrt{2}}}
\newcommand*\diff{\mathop{}\!\mathrm{d}}
\DeclareMathOperator{\poly}{\mathsf{poly}}
\newcommand{\face}[1][F]{\mathfrak{#1}}



\newcommand{\sigmab}{\bm{\sigma}}
\newcommand{\Sigmab}{\mathbf{\Sigma}}

\newcommand{\val}{\vec{\alpha}}
\newcommand{\vbeta}{\vec{\beta}}
\newcommand{\vde}{\vec{\delta}}
\newcommand{\vga}{\vec{\gamma}}
\newcommand{\vsig}{\vec{\sigma}}
\newcommand{\vth}{\vec{\theta}}
\newcommand{\veta}{\vec{\eta}}
\newcommand{\vnu}{\vec{\nu}}
\newcommand{\vpsi}{\vec{\psi}}
\newcommand{\vpi}{\vec{\pi}}
\newcommand{\vphi}{\vec{\phi}}
\newcommand{\vxi}{\vec{\xi}}
\newcommand{\vze}{\vec{\zeta}}

\newcommand{\valbar}{\bar{\val}}
\newcommand{\valhat}{\hat{\val}}
\newcommand{\valtil}{\tilde{\val}}
\newcommand{\vthtil}{\tilde{\vth}}
\newcommand{\vthhat}{\hat{\vth}}
\newcommand{\vthbar}{\bar{\vth}}
\newcommand{\vbetatil}{\tilde{\vbeta}}
\newcommand{\vbetahat}{\hat{\vbeta}}

\newcommand{\alphavec}{\val}
\newcommand{\alphavecbar}{\bar{\val}}
\newcommand{\alphavechat}{\hat{\val}}
\newcommand{\alphavectil}{\tilde{\val}}
\newcommand{\betavec}{\vec{\beta}}
\newcommand{\gammavec}{\vec{\gamma}}
\newcommand{\deltavec}{\vec{\delta}}
\newcommand{\etavec}{\vec{\eta}}
\newcommand{\phivec}{\vec{\phi}}
\newcommand{\psivec}{\vec{\psi}}
\newcommand{\thetavec}{\vec{\theta}}
\newcommand{\varphivec}{\vec{\varphi}}
\newcommand{\muvec}{\vec{\mu}}
\newcommand{\xivec}{\vec{\xi}}
\newcommand{\chivec}{\vec{\chi}}
\newcommand{\lambdavec}{\vec{\lambda}}
\newcommand{\rhovec}{\vec{\rho}}

\newcommand{\alphab}{\boldsymbol{\alpha}}
\newcommand{\betab}{\boldsymbol{\beta}}
\newcommand{\gammab}{\boldsymbol{\gamma}}
\newcommand{\thetab}{\boldsymbol{\theta}}
\newcommand{\mub}{\boldsymbol{\mu}}
\newcommand{\xib}{\boldsymbol{\xi}}
\newcommand{\Deltab}{\boldsymbol{\Delta}}
\newcommand{\Pib}{\boldsymbol{\Pi}}
\newcommand{\etab}{\boldsymbol{\eta}}
\newcommand{\taub}{\boldsymbol{\tau}}
\newcommand{\lambdab}{\boldsymbol{\lambda}}
\newcommand{\pitil}{\tilde{\pi}}
\newcommand{\elltil}{\tilde{\ell}}
\newcommand{\rhob}{\boldsymbol{\rho}}

\newcommand{\delhat}{\hat{\delta}}
\newcommand{\phihat}{\hat{\phi}}
\newcommand{\delbar}{\bar{\delta}}
\newcommand{\alphahat}{\hat{\alpha}}
\newcommand{\alphatil}{\tilde{\alpha}}
\newcommand{\mubar}{\bar{\mu}}
\newcommand{\thetahat}{\hat{\theta}}
\newcommand{\thetabar}{\bar{\theta}}
\newcommand{\betahat}{\hat{\beta}}

\newcommand{\xibar}{\bar{\xi}}
\newcommand{\lambdavectil}{\tilde{\vec{\lambda}}}
\newcommand{\thetatil}{\tilde{\theta}}
\newcommand{\betatil}{\tilde{\beta}}


\newcommand{\arow}[2]{#1_{#2\cdot}}
\newcommand{\acol}[2]{#1_{\cdot#2}}
\newcommand{\expunder}[1]{\mathop{\EE}\limits_{#1}}
\newcommand{\mean}[1]{\mathop{\EE}\sbr{{#1}}}
\newcommand{\vars}[2]{\var_{{#1}}\sbr{{#2}}}
\newcommand{\expec}[2]{\mathop{\EE}_{{#1}}\sbr{{#2}}}

\newcommand{\gstar}{g^{\star}}
\newcommand{\fstar}{f^{\star}}
\newcommand{\hstar}{h^{\star}}
\newcommand{\Astar}{A^{\star}}
\newcommand{\Kstar}{K^{\star}}


\newcommand{\gradtil}{{\tilde{\grad}}}
\newcommand{\MED}{{\text{MED}}}
\newcommand{\where}{{\quad \text{where} \quad}}
\newcommand{\lcg}{{\textit{l.c.g}}}
\newcommand{\relu}{{\mathrm{ReLU}}}
\newcommand{\cp}{\mathrm{cp}}
\newcommand{\err}{\mathrm{err}}
\newcommand{\wvechat}{\hat{\vec{w}}}

\newcommand{\ydiff}[2]{\delta(#1, #2)}
\newcommand{\ykdiff}[2]{\delta(#1, #2)^{\kappa}}
\newcommand{\myfdiff}[2]{\Delta f(#1, #2)}

\newcommand{\supp}{\mathrm{supp}}
\newcommand{\blue}[1]{\textcolor[rgb]{0.00,0.00,1.00}{#1}}
\newcommand{\red}[1]{\textcolor[rgb]{1.00,0.00,0.00}{#1}}
\newcommand{\green}[1]{\textcolor[rgb]{0.00,1.00,0.00}{#1}}
\newcommand{\black}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\vardef}{\stackrel{\triangle}{=}}
\newcommand{\smallonevec}{{\scriptsize\mathbf 1}}
\newcommand{\smallwvec}{{\scriptsize\mathbf w}}
\newcommand{\smallqvec}{{\scriptsize\mathbf q}}
\newcommand{\smallyvec}{{\scriptsize\mathbf y}}
\newcommand{\smallepsvec}{{\mbox{\boldmath\scriptsize }}}
\newcommand{\smallzetavec}{{\mbox{\boldmath\scriptsize }}}
\newcommand{\smallmuvec}{{\mbox{\boldmath\scriptsize }}}
\newcommand{\smallnuvec}{{\mbox{\boldmath\scriptsize }}}
\newcommand{\smallxivec}{{\mbox{\boldmath\scriptsize }}}
\newcommand{\smalllambdavec}{{\mbox{\boldmath\scriptsize }}}
\newcommand{\smallthetavec}{{\mbox{\boldmath\scriptsize }}}
\newcommand{\smallalphavec}{{\mbox{\boldmath\scriptsize }}}
\newcommand{\smallbetavec}{{\mbox{\boldmath\scriptsize }}}
\newcommand{\smalletavec}{{\mbox{\boldmath\scriptsize }}}
\newcommand{\smallomegavec}{{\mbox{\boldmath\scriptsize }}}
\newcommand{\smallLambdavec}{{\mbox{\boldmath\scriptsize }}}
\newcommand{\epsvec}{{\mbox{\boldmath }}}
\newcommand{\ellvec}{{\mbox{\boldmath }}}
\newcommand{\nuvec}{{\mbox{\boldmath }}}
\newcommand{\omegavec}{{\mbox{\boldmath }}}
\newcommand{\zetavec}{{\mbox{\boldmath }}}
\newcommand{\hinge}{{\textit{hinge}}}
\newcommand{\loss}{{\textit{loss}}}
\newcommand{\etahinge}[1]{{{#1}\mbox{-}\hinge}}
\newcommand{\robust}{{\textit{robust}}}
\newcommand{\regrobust}{{f_{\scriptsize\textit{rob}}}}
\newcommand{\regetahinge}{{f_{\scriptsize\textit{hng}}}}
\newcommand{\looerr}{{\textit{loo\_err}}}
\newcommand{\makevector}[1]{{\mathbf #1}}
\newcommand{\zerovec}{{\makevector{0}}}

\newcommand{\cc}[1]{\mathrm{\overline{conv}}#1}
\newcommand{\qcc}[1]{\mathrm{\overline{qconv}}#1}
\newcommand{\Diag}{\mathrm{Diag}}
\newcommand{\Ker}{\ensuremath{\mathrm{Ker}}}
\newcommand{\Img}{\ensuremath{\mathrm{Im}}}
\newcommand{\Ball}[1]{\mathsf{B}_{#1}}
\newcommand{\ran}{\mathrm{ran}}
\newcommand{\qq}{\mathsf{q}}
\newcommand{\ccp}{\Gamma_0}
\newcommand{\fl}{\mathsf{FL}}
\newcommand{\gl}{\mathsf{GL}}
\newcommand{\env}[2][\eta]{\mathsf{M}^{#1}_{#2}}
\newcommand{\SC}[1][\eta]{\mathsf{SC}_{#1}}
\renewcommand{\SS}[1][\eta]{\mathsf{SS}_{1/#1}}
\newcommand{\prox}[2][\eta]{\mathsf{P}^{#1}_{#2}}
\newcommand{\pa}[1][\eta]{\mathsf{A}^{#1}}
\newcommand{\Ltwobar}{\overline{M^2}}




\newcommand{\atil}{\tilde{a}}
\newcommand{\btil}{\tilde{b}}
\newcommand{\ctil}{\tilde{c}}
\newcommand{\dtil}{\tilde{d}}
\newcommand{\etil}{\tilde{e}}
\newcommand{\ftil}{\tilde{f}}
\newcommand{\gtil}{\tilde{g}}
\newcommand{\htil}{\tilde{h}}
\newcommand{\itil}{\tilde{i}}
\newcommand{\jtil}{\tilde{j}}
\newcommand{\ktil}{\tilde{k}}
\newcommand{\ltil}{\tilde{l}}
\newcommand{\mtil}{\tilde{m}}
\newcommand{\ntil}{\tilde{n}}
\newcommand{\otil}{\tilde{o}}
\newcommand{\ptil}{\tilde{p}}
\newcommand{\qtil}{\tilde{q}}
\newcommand{\rtil}{\tilde{r}}
\newcommand{\stil}{\tilde{s}}
\newcommand{\ttil}{\tilde{t}}
\newcommand{\util}{\tilde{u}}
\newcommand{\vtil}{\tilde{v}}
\newcommand{\wtil}{\tilde{w}}
\newcommand{\xtil}{\tilde{x}}
\newcommand{\ytil}{\tilde{y}}
\newcommand{\ztil}{\tilde{z}}

\newcommand{\ahat}{\hat{a}}
\newcommand{\bhat}{\hat{b}}
\newcommand{\chat}{\hat{c}}
\newcommand{\dhat}{\hat{d}}
\newcommand{\ehat}{\hat{e}}
\newcommand{\fhat}{\hat{f}}
\newcommand{\ghat}{\hat{g}}
\newcommand{\hhat}{\hat{h}}
\newcommand{\ihat}{\hat{i}}
\newcommand{\jhat}{\hat{j}}
\newcommand{\khat}{\hat{k}}
\newcommand{\lhat}{\hat{l}}
\newcommand{\mhat}{\hat{m}}
\newcommand{\nhat}{\hat{n}}
\newcommand{\ohat}{\hat{o}}
\newcommand{\phat}{\hat{p}}
\newcommand{\qhat}{\hat{q}}
\newcommand{\rhat}{\hat{r}}
\newcommand{\shat}{\hat{s}}
\newcommand{\that}{\hat{t}}
\newcommand{\uhat}{\hat{u}}
\newcommand{\vhat}{\hat{v}}
\newcommand{\what}{\hat{w}}
\newcommand{\xhat}{\hat{x}}
\newcommand{\yhat}{\hat{y}}
\newcommand{\zhat}{\hat{z}}

\newcommand{\abar}{\bar{a}}
\newcommand{\bbar}{\bar{b}}
\newcommand{\cbar}{\bar{c}}
\newcommand{\dbar}{\bar{d}}
\newcommand{\ebar}{\bar{e}}
\newcommand{\fbar}{\bar{f}}
\newcommand{\gbar}{\bar{g}}
\newcommand{\hbr}{\bar{h}}
\newcommand{\ibar}{\bar{i}}
\newcommand{\jbar}{\bar{j}}
\newcommand{\kbar}{\bar{k}}
\newcommand{\lbar}{\bar{l}}
\newcommand{\mbar}{\bar{m}}
\newcommand{\nbar}{\bar{n}}
\newcommand{\obar}{\bar{o}}
\newcommand{\pbar}{\bar{p}}
\newcommand{\qbar}{\bar{q}}
\newcommand{\rbar}{\bar{r}}
\newcommand{\sbar}{\bar{s}}
\newcommand{\tbar}{\bar{t}}
\newcommand{\ubar}{\bar{u}}
\newcommand{\vbar}{\bar{v}}
\newcommand{\wbar}{\bar{w}}
\newcommand{\xbar}{\bar{x}}
\newcommand{\ybar}{\bar{y}}
\newcommand{\zbar}{\bar{z}}

\newcommand{\abf}{\mathbf{a}}
\newcommand{\bbf}{\mathbf{b}}
\newcommand{\cbf}{\mathbf{c}}
\newcommand{\dbf}{\mathbf{d}}
\newcommand{\ebf}{\mathbf{e}}
\newcommand{\fbf}{\mathbf{f}}
\newcommand{\gbf}{\mathbf{g}}
\newcommand{\hbf}{\mathbf{h}}
\newcommand{\ibf}{\mathbf{i}}
\newcommand{\jbf}{\mathbf{j}}
\newcommand{\kbf}{\mathbf{k}}
\newcommand{\lbf}{\mathbf{l}}
\newcommand{\mbf}{\mathbf{m}}
\newcommand{\nbf}{\mathbf{n}}
\newcommand{\obf}{\mathbf{o}}
\newcommand{\pbf}{\mathbf{p}}
\newcommand{\qbf}{\mathbf{q}}
\newcommand{\rbf}{\mathbf{r}}
\newcommand{\sbf}{\mathbf{s}}
\newcommand{\tbf}{\mathbf{t}}
\newcommand{\ubf}{\mathbf{u}}
\newcommand{\vbf}{\mathbf{v}}
\newcommand{\wbf}{\mathbf{w}}
\newcommand{\xbf}{\mathbf{x}}
\newcommand{\ybf}{\mathbf{y}}
\newcommand{\zbf}{\mathbf{z}}

\newcommand{\abftil}{\tilde{\abf}}
\newcommand{\bbftil}{\tilde{\bbf}}
\newcommand{\cbftil}{\tilde{\cbf}}
\newcommand{\dbftil}{\tilde{\dbf}}
\newcommand{\ebftil}{\tilde{\ebf}}
\newcommand{\fbftil}{\tilde{\fbf}}
\newcommand{\gbftil}{\tilde{\gbf}}
\newcommand{\hbftil}{\tilde{\hbf}}
\newcommand{\ibftil}{\tilde{\ibf}}
\newcommand{\jbftil}{\tilde{\jbf}}
\newcommand{\kbftil}{\tilde{\kbf}}
\newcommand{\lbftil}{\tilde{\lbf}}
\newcommand{\mbftil}{\tilde{\mbf}}
\newcommand{\nbftil}{\tilde{\nbf}}
\newcommand{\obftil}{\tilde{\obf}}
\newcommand{\pbftil}{\tilde{\pbf}}
\newcommand{\qbftil}{\tilde{\qbf}}
\newcommand{\rbftil}{\tilde{\rbf}}
\newcommand{\sbftil}{\tilde{\sbf}}
\newcommand{\tbftil}{\tilde{\tbf}}
\newcommand{\ubftil}{\tilde{\ubf}}
\newcommand{\vbftil}{\tilde{\vbf}}
\newcommand{\wbftil}{\tilde{\wbf}}
\newcommand{\xbftil}{\tilde{\xbf}}
\newcommand{\ybftil}{\tilde{\ybf}}
\newcommand{\zbftil}{\tilde{\zbf}}

\newcommand{\abfhat}{\hat{\abf}}
\newcommand{\bbfhat}{\hat{\bbf}}
\newcommand{\cbfhat}{\hat{\cbf}}
\newcommand{\dbfhat}{\hat{\dbf}}
\newcommand{\ebfhat}{\hat{\ebf}}
\newcommand{\fbfhat}{\hat{\fbf}}
\newcommand{\gbfhat}{\hat{\gbf}}
\newcommand{\hbfhat}{\hat{\hbf}}
\newcommand{\ibfhat}{\hat{\ibf}}
\newcommand{\jbfhat}{\hat{\jbf}}
\newcommand{\kbfhat}{\hat{\kbf}}
\newcommand{\lbfhat}{\hat{\lbf}}
\newcommand{\mbfhat}{\hat{\mbf}}
\newcommand{\nbfhat}{\hat{\nbf}}
\newcommand{\obfhat}{\hat{\obf}}
\newcommand{\pbfhat}{\hat{\pbf}}
\newcommand{\qbfhat}{\hat{\qbf}}
\newcommand{\rbfhat}{\hat{\rbf}}
\newcommand{\sbfhat}{\hat{\sbf}}
\newcommand{\tbfhat}{\hat{\tbf}}
\newcommand{\ubfhat}{\hat{\ubf}}
\newcommand{\vbfhat}{\hat{\vbf}}
\newcommand{\wbfhat}{\hat{\wbf}}
\newcommand{\xbfhat}{\hat{\xbf}}
\newcommand{\ybfhat}{\hat{\ybf}}
\newcommand{\zbfhat}{\hat{\zbf}}

\newcommand{\abfbar}{\bar{\abf}}
\newcommand{\bbfbar}{\bar{\bbf}}
\newcommand{\cbfbar}{\bar{\cbf}}
\newcommand{\dbfbar}{\bar{\dbf}}
\newcommand{\ebfbar}{\bar{\ebf}}
\newcommand{\fbfbar}{\bar{\fbf}}
\newcommand{\gbfbar}{\bar{\gbf}}
\newcommand{\hbfbar}{\bar{\hbf}}
\newcommand{\ibfbar}{\bar{\ibf}}
\newcommand{\jbfbar}{\bar{\jbf}}
\newcommand{\kbfbar}{\bar{\kbf}}
\newcommand{\lbfbar}{\bar{\lbf}}
\newcommand{\mbfbar}{\bar{\mbf}}
\newcommand{\nbfbar}{\bar{\nbf}}
\newcommand{\obfbar}{\bar{\obf}}
\newcommand{\pbfbar}{\bar{\pbf}}
\newcommand{\qbfbar}{\bar{\qbf}}
\newcommand{\rbfbar}{\bar{\rbf}}
\newcommand{\sbfbar}{\bar{\sbf}}
\newcommand{\tbfbar}{\bar{\tbf}}
\newcommand{\ubfbar}{\bar{\ubf}}
\newcommand{\vbfbar}{\bar{\vbf}}
\newcommand{\wbfbar}{\bar{\wbf}}
\newcommand{\xbfbar}{\bar{\xbf}}
\newcommand{\ybfbar}{\bar{\ybf}}
\newcommand{\zbfbar}{\bar{\zbf}}

\newcommand{\asf}{\mathsf{a}}
\newcommand{\bsf}{\mathsf{b}}
\newcommand{\csf}{\mathsf{c}}
\newcommand{\dsf}{\mathsf{d}}
\newcommand{\esf}{\mathsf{e}}
\newcommand{\fsf}{\mathsf{f}}
\newcommand{\gsf}{\mathsf{g}}
\newcommand{\hsf}{\mathsf{h}}
\newcommand{\isf}{\mathsf{i}}
\newcommand{\jsf}{\mathsf{j}}
\newcommand{\ksf}{\mathsf{k}}
\newcommand{\lsf}{\mathsf{l}}
\newcommand{\msf}{\mathsf{m}}
\newcommand{\nsf}{\mathsf{n}}
\newcommand{\osf}{\mathsf{o}}
\newcommand{\psf}{\mathsf{p}}
\newcommand{\qsf}{\mathsf{q}}
\newcommand{\rsf}{\mathsf{r}}
\newcommand{\ssf}{\mathsf{s}}
\newcommand{\tsf}{\mathsf{t}}
\newcommand{\usf}{\mathsf{u}}
\newcommand{\vsf}{\mathsf{v}}
\newcommand{\wsf}{\mathsf{w}}
\newcommand{\xsf}{\mathsf{x}}
\newcommand{\ysf}{\mathsf{y}}
\newcommand{\zsf}{\mathsf{z}}

\newcommand{\att}{\mathtt{a}}
\newcommand{\btt}{\mathtt{b}}
\newcommand{\ctt}{\mathtt{c}}
\newcommand{\dtt}{\mathtt{d}}
\newcommand{\ett}{\mathtt{e}}
\newcommand{\ftt}{\mathtt{f}}
\newcommand{\gtt}{\mathtt{g}}
\newcommand{\htt}{\mathtt{h}}
\newcommand{\itt}{\mathtt{i}}
\newcommand{\jtt}{\mathtt{j}}
\newcommand{\ktt}{\mathtt{k}}
\newcommand{\ltt}{\mathtt{l}}
\newcommand{\mtt}{\mathtt{m}}
\newcommand{\ntt}{\mathtt{n}}
\newcommand{\ott}{\mathtt{o}}
\newcommand{\ptt}{\mathtt{p}}
\newcommand{\qtt}{\mathtt{q}}
\newcommand{\rtt}{\mathtt{r}}
\newcommand{\stt}{\mathtt{s}}
\newcommand{\ttt}{\mathtt{t}}
\newcommand{\utt}{\mathtt{u}}
\newcommand{\vtt}{\mathtt{v}}
\newcommand{\wtt}{\mathtt{w}}
\newcommand{\xtt}{\mathtt{x}}
\newcommand{\ytt}{\mathtt{y}}
\newcommand{\ztt}{\mathtt{z}}

\newcommand{\abld}{\boldsymbol{a}}
\newcommand{\bbld}{\boldsymbol{b}}
\newcommand{\cbld}{\boldsymbol{c}}
\newcommand{\dbld}{\boldsymbol{d}}
\newcommand{\ebld}{\boldsymbol{e}}
\newcommand{\fbld}{\boldsymbol{f}}
\newcommand{\gbld}{\boldsymbol{g}}
\newcommand{\hbld}{\boldsymbol{h}}
\newcommand{\ibld}{\boldsymbol{i}}
\newcommand{\jbld}{\boldsymbol{j}}
\newcommand{\kbld}{\boldsymbol{k}}
\newcommand{\lbld}{\boldsymbol{l}}
\newcommand{\mbld}{\boldsymbol{m}}
\newcommand{\nbld}{\boldsymbol{n}}
\newcommand{\obld}{\boldsymbol{o}}
\newcommand{\pbld}{\boldsymbol{p}}
\newcommand{\qbld}{\boldsymbol{q}}
\newcommand{\rbld}{\boldsymbol{r}}
\newcommand{\sbld}{\boldsymbol{s}}
\newcommand{\tbld}{\boldsymbol{t}}
\newcommand{\ubld}{\boldsymbol{u}}
\newcommand{\vbld}{\boldsymbol{v}}
\newcommand{\wbld}{\boldsymbol{w}}
\newcommand{\xbld}{\boldsymbol{x}}
\newcommand{\ybld}{\boldsymbol{y}}
\newcommand{\zbld}{\boldsymbol{z}}

\newcommand{\Atil}{\tilde{A}}
\newcommand{\Btil}{\tilde{B}}
\newcommand{\Ctil}{\tilde{C}}
\newcommand{\Dtil}{\tilde{D}}
\newcommand{\Etil}{\tilde{E}}
\newcommand{\Ftil}{\tilde{F}}
\newcommand{\Gtil}{\tilde{G}}
\newcommand{\Htil}{\tilde{H}}
\newcommand{\Itil}{\tilde{I}}
\newcommand{\Jtil}{\tilde{J}}
\newcommand{\Ktil}{\tilde{K}}
\newcommand{\Ltil}{\tilde{L}}
\newcommand{\Mtil}{\tilde{M}}
\newcommand{\Ntil}{\tilde{N}}
\newcommand{\Otil}{\tilde{O}}
\newcommand{\Ptil}{\tilde{P}}
\newcommand{\Qtil}{\tilde{Q}}
\newcommand{\Rtil}{\tilde{R}}
\newcommand{\Stil}{\tilde{S}}
\newcommand{\Ttil}{\tilde{T}}
\newcommand{\Util}{\tilde{U}}
\newcommand{\Vtil}{\tilde{V}}
\newcommand{\Wtil}{\tilde{W}}
\newcommand{\Xtil}{\tilde{X}}
\newcommand{\Ytil}{\tilde{Y}}
\newcommand{\Ztil}{\tilde{Z}}

\newcommand{\Ahat}{\hat{A}}
\newcommand{\Bhat}{\hat{B}}
\newcommand{\Chat}{\hat{C}}
\newcommand{\Dhat}{\hat{D}}
\newcommand{\Ehat}{\hat{E}}
\newcommand{\Fhat}{\hat{F}}
\newcommand{\Ghat}{\hat{G}}
\newcommand{\Hhat}{\hat{H}}
\newcommand{\Ihat}{\hat{I}}
\newcommand{\Jhat}{\hat{J}}
\newcommand{\Khat}{\hat{K}}
\newcommand{\Lhat}{\hat{L}}
\newcommand{\Mhat}{\hat{M}}
\newcommand{\Nhat}{\hat{N}}
\newcommand{\Ohat}{\hat{O}}
\newcommand{\Phat}{\hat{P}}
\newcommand{\Qhat}{\hat{Q}}
\newcommand{\Rhat}{\hat{R}}
\newcommand{\Shat}{\hat{S}}
\newcommand{\That}{\hat{T}}
\newcommand{\Uhat}{\hat{U}}
\newcommand{\Vhat}{\hat{V}}
\newcommand{\What}{\hat{W}}
\newcommand{\Xhat}{\hat{X}}
\newcommand{\Yhat}{\hat{Y}}
\newcommand{\Zhat}{\hat{Z}}

\newcommand{\Abar}{\bar{A}}
\newcommand{\Bbar}{\bar{B}}
\newcommand{\Cbar}{\bar{C}}
\newcommand{\Dbar}{\bar{D}}
\newcommand{\Ebar}{\bar{E}}
\newcommand{\Fbar}{\bar{F}}
\newcommand{\Gbar}{\bar{G}}
\newcommand{\Hbar}{\bar{H}}
\newcommand{\Ibar}{\bar{I}}
\newcommand{\Jbar}{\bar{J}}
\newcommand{\Kbar}{\bar{K}}
\newcommand{\Lbar}{\bar{L}}
\newcommand{\Mbar}{\bar{M}}
\newcommand{\Nbar}{\bar{N}}
\newcommand{\Obar}{\bar{O}}
\newcommand{\Pbar}{\bar{P}}
\newcommand{\Qbar}{\bar{Q}}
\newcommand{\Rbar}{\bar{R}}
\newcommand{\Sbar}{\bar{S}}
\newcommand{\Tbar}{\bar{T}}
\newcommand{\Ubar}{\bar{U}}
\newcommand{\Vbar}{\bar{V}}
\newcommand{\Wbar}{\bar{W}}
\newcommand{\Xbar}{\bar{X}}
\newcommand{\Ybar}{\bar{Y}}
\newcommand{\Zbar}{\bar{Z}}

\newcommand{\Abf}{\mathbf{A}}
\newcommand{\Bbf}{\mathbf{B}}
\newcommand{\Cbf}{\mathbf{C}}
\newcommand{\Dbf}{\mathbf{D}}
\newcommand{\Ebf}{\mathbf{E}}
\newcommand{\Fbf}{\mathbf{F}}
\newcommand{\Gbf}{\mathbf{G}}
\newcommand{\Hbf}{\mathbf{H}}
\newcommand{\Ibf}{\mathbf{I}}
\newcommand{\Jbf}{\mathbf{J}}
\newcommand{\Kbf}{\mathbf{K}}
\newcommand{\Lbf}{\mathbf{L}}
\newcommand{\Mbf}{\mathbf{M}}
\newcommand{\Nbf}{\mathbf{N}}
\newcommand{\Obf}{\mathbf{O}}
\newcommand{\Pbf}{\mathbf{P}}
\newcommand{\Qbf}{\mathbf{Q}}
\newcommand{\Rbf}{\mathbf{R}}
\newcommand{\Sbf}{\mathbf{S}}
\newcommand{\Tbf}{\mathbf{T}}
\newcommand{\Ubf}{\mathbf{U}}
\newcommand{\Vbf}{\mathbf{V}}
\newcommand{\Wbf}{\mathbf{W}}
\newcommand{\Xbf}{\mathbf{X}}
\newcommand{\Ybf}{\mathbf{Y}}
\newcommand{\Zbf}{\mathbf{Z}}

\newcommand{\Abftil}{\tilde{\Abf}}
\newcommand{\Bbftil}{\tilde{\Bbf}}
\newcommand{\Cbftil}{\tilde{\Cbf}}
\newcommand{\Dbftil}{\tilde{\Dbf}}
\newcommand{\Ebftil}{\tilde{\Ebf}}
\newcommand{\Fbftil}{\tilde{\Fbf}}
\newcommand{\Gbftil}{\tilde{\Gbf}}
\newcommand{\Hbftil}{\tilde{\Hbf}}
\newcommand{\Ibftil}{\tilde{\Ibf}}
\newcommand{\Jbftil}{\tilde{\Jbf}}
\newcommand{\Kbftil}{\tilde{\Kbf}}
\newcommand{\Lbftil}{\tilde{\Lbf}}
\newcommand{\Mbftil}{\tilde{\Mbf}}
\newcommand{\Nbftil}{\tilde{\Nbf}}
\newcommand{\Obftil}{\tilde{\Obf}}
\newcommand{\Pbftil}{\tilde{\Pbf}}
\newcommand{\Qbftil}{\tilde{\Qbf}}
\newcommand{\Rbftil}{\tilde{\Rbf}}
\newcommand{\Sbftil}{\tilde{\Sbf}}
\newcommand{\Tbftil}{\tilde{\Tbf}}
\newcommand{\Ubftil}{\tilde{\Ubf}}
\newcommand{\Vbftil}{\tilde{\Vbf}}
\newcommand{\Wbftil}{\tilde{\Wbf}}
\newcommand{\Xbftil}{\tilde{\Xbf}}
\newcommand{\Ybftil}{\tilde{\Ybf}}
\newcommand{\Zbftil}{\tilde{\Zbf}}

\newcommand{\Abfhat}{\hat{\Abf}}
\newcommand{\Bbfhat}{\hat{\Bbf}}
\newcommand{\Cbfhat}{\hat{\Cbf}}
\newcommand{\Dbfhat}{\hat{\Dbf}}
\newcommand{\Ebfhat}{\hat{\Ebf}}
\newcommand{\Fbfhat}{\hat{\Fbf}}
\newcommand{\Gbfhat}{\hat{\Gbf}}
\newcommand{\Hbfhat}{\hat{\Hbf}}
\newcommand{\Ibfhat}{\hat{\Ibf}}
\newcommand{\Jbfhat}{\hat{\Jbf}}
\newcommand{\Kbfhat}{\hat{\Kbf}}
\newcommand{\Lbfhat}{\hat{\Lbf}}
\newcommand{\Mbfhat}{\hat{\Mbf}}
\newcommand{\Nbfhat}{\hat{\Nbf}}
\newcommand{\Obfhat}{\hat{\Obf}}
\newcommand{\Pbfhat}{\hat{\Pbf}}
\newcommand{\Qbfhat}{\hat{\Qbf}}
\newcommand{\Rbfhat}{\hat{\Rbf}}
\newcommand{\Sbfhat}{\hat{\Sbf}}
\newcommand{\Tbfhat}{\hat{\Tbf}}
\newcommand{\Ubfhat}{\hat{\Ubf}}
\newcommand{\Vbfhat}{\hat{\Vbf}}
\newcommand{\Wbfhat}{\hat{\Wbf}}
\newcommand{\Xbfhat}{\hat{\Xbf}}
\newcommand{\Ybfhat}{\hat{\Ybf}}
\newcommand{\Zbfhat}{\hat{\Zbf}}

\newcommand{\Abfbar}{\bar{\Abf}}
\newcommand{\Bbfbar}{\bar{\Bbf}}
\newcommand{\Cbfbar}{\bar{\Cbf}}
\newcommand{\Dbfbar}{\bar{\Dbf}}
\newcommand{\Ebfbar}{\bar{\Ebf}}
\newcommand{\Fbfbar}{\bar{\Fbf}}
\newcommand{\Gbfbar}{\bar{\Gbf}}
\newcommand{\Hbfbar}{\bar{\Hbf}}
\newcommand{\Ibfbar}{\bar{\Ibf}}
\newcommand{\Jbfbar}{\bar{\Jbf}}
\newcommand{\Kbfbar}{\bar{\Kbf}}
\newcommand{\Lbfbar}{\bar{\Lbf}}
\newcommand{\Mbfbar}{\bar{\Mbf}}
\newcommand{\Nbfbar}{\bar{\Nbf}}
\newcommand{\Obfbar}{\bar{\Obf}}
\newcommand{\Pbfbar}{\bar{\Pbf}}
\newcommand{\Qbfbar}{\bar{\Qbf}}
\newcommand{\Rbfbar}{\bar{\Rbf}}
\newcommand{\Sbfbar}{\bar{\Sbf}}
\newcommand{\Tbfbar}{\bar{\Tbf}}
\newcommand{\Ubfbar}{\bar{\Ubf}}
\newcommand{\Vbfbar}{\bar{\Vbf}}
\newcommand{\Wbfbar}{\bar{\Wbf}}
\newcommand{\Xbfbar}{\bar{\Xbf}}
\newcommand{\Ybfbar}{\bar{\Ybf}}
\newcommand{\Zbfbar}{\bar{\Zbf}}

\newcommand{\Asf}{\mathsf{A}}
\newcommand{\Bsf}{\mathsf{B}}
\newcommand{\Csf}{\mathsf{C}}
\newcommand{\Dsf}{\mathsf{D}}
\newcommand{\Esf}{\mathsf{E}}
\newcommand{\Fsf}{\mathsf{F}}
\newcommand{\Gsf}{\mathsf{G}}
\newcommand{\Hsf}{\mathsf{H}}
\newcommand{\Isf}{\mathsf{I}}
\newcommand{\Jsf}{\mathsf{J}}
\newcommand{\Ksf}{\mathsf{K}}
\newcommand{\Lsf}{\mathsf{L}}
\newcommand{\Msf}{\mathsf{M}}
\newcommand{\Nsf}{\mathsf{N}}
\newcommand{\Osf}{\mathsf{O}}
\newcommand{\Psf}{\mathsf{P}}
\newcommand{\Qsf}{\mathsf{Q}}
\newcommand{\Rsf}{\mathsf{R}}
\newcommand{\Ssf}{\mathsf{S}}
\newcommand{\Tsf}{\mathsf{T}}
\newcommand{\Usf}{\mathsf{U}}
\newcommand{\Vsf}{\mathsf{V}}
\newcommand{\Wsf}{\mathsf{W}}
\newcommand{\Xsf}{\mathsf{X}}
\newcommand{\Ysf}{\mathsf{Y}}
\newcommand{\Zsf}{\mathsf{Z}}

\newcommand{\Att}{\mathtt{A}}
\newcommand{\Btt}{\mathtt{B}}
\newcommand{\Ctt}{\mathtt{C}}
\newcommand{\Dtt}{\mathtt{D}}
\newcommand{\Ett}{\mathtt{E}}
\newcommand{\Ftt}{\mathtt{F}}
\newcommand{\Gtt}{\mathtt{G}}
\newcommand{\Htt}{\mathtt{H}}
\newcommand{\Itt}{\mathtt{I}}
\newcommand{\Jtt}{\mathtt{J}}
\newcommand{\Ktt}{\mathtt{K}}
\newcommand{\Ltt}{\mathtt{L}}
\newcommand{\Mtt}{\mathtt{M}}
\newcommand{\Ntt}{\mathtt{N}}
\newcommand{\Ott}{\mathtt{O}}
\newcommand{\Ptt}{\mathtt{P}}
\newcommand{\Qtt}{\mathtt{Q}}
\newcommand{\Rtt}{\mathtt{R}}
\newcommand{\Stt}{\mathtt{S}}
\newcommand{\Ttt}{\mathtt{T}}
\newcommand{\Utt}{\mathtt{U}}
\newcommand{\Vtt}{\mathtt{V}}
\newcommand{\Wtt}{\mathtt{W}}
\newcommand{\Xtt}{\mathtt{X}}
\newcommand{\Ytt}{\mathtt{Y}}
\newcommand{\Ztt}{\mathtt{Z}}

\newcommand{\Abld}{\boldsymbol{A}}
\newcommand{\Bbld}{\boldsymbol{B}}
\newcommand{\Cbld}{\boldsymbol{C}}
\newcommand{\Dbld}{\boldsymbol{D}}
\newcommand{\Ebld}{\boldsymbol{E}}
\newcommand{\Fbld}{\boldsymbol{F}}
\newcommand{\Gbld}{\boldsymbol{G}}
\newcommand{\Hbld}{\boldsymbol{H}}
\newcommand{\Ibld}{\boldsymbol{I}}
\newcommand{\Jbld}{\boldsymbol{J}}
\newcommand{\Kbld}{\boldsymbol{K}}
\newcommand{\Lbld}{\boldsymbol{L}}
\newcommand{\Mbld}{\boldsymbol{M}}
\newcommand{\Nbld}{\boldsymbol{N}}
\newcommand{\Obld}{\boldsymbol{O}}
\newcommand{\Pbld}{\boldsymbol{P}}
\newcommand{\Qbld}{\boldsymbol{Q}}
\newcommand{\Rbld}{\boldsymbol{R}}
\newcommand{\Sbld}{\boldsymbol{S}}
\newcommand{\Tbld}{\boldsymbol{T}}
\newcommand{\Ubld}{\boldsymbol{U}}
\newcommand{\Vbld}{\boldsymbol{V}}
\newcommand{\Wbld}{\boldsymbol{W}}
\newcommand{\Xbld}{\boldsymbol{X}}
\newcommand{\Ybld}{\boldsymbol{Y}}
\newcommand{\Zbld}{\boldsymbol{Z}}

\newcommand{\Acal}{\mathcal{A}}
\newcommand{\Bcal}{\mathcal{B}}
\newcommand{\Ccal}{\mathcal{C}}
\newcommand{\Dcal}{\mathcal{D}}
\newcommand{\Ecal}{\mathcal{E}}
\newcommand{\Fcal}{\mathcal{F}}
\newcommand{\Gcal}{\mathcal{G}}
\newcommand{\Hcal}{\mathcal{H}}
\newcommand{\Ical}{\mathcal{I}}
\newcommand{\Jcal}{\mathcal{J}}
\newcommand{\Kcal}{\mathcal{K}}
\newcommand{\Lcal}{\mathcal{L}}
\newcommand{\Mcal}{\mathcal{M}}
\newcommand{\Ncal}{\mathcal{N}}
\newcommand{\Ocal}{\mathcal{O}}
\newcommand{\Pcal}{\mathcal{P}}
\newcommand{\Qcal}{\mathcal{Q}}
\newcommand{\Rcal}{\mathcal{R}}
\newcommand{\Scal}{\mathcal{S}}
\newcommand{\Tcal}{\mathcal{T}}
\newcommand{\Ucal}{\mathcal{U}}
\newcommand{\Vcal}{\mathcal{V}}
\newcommand{\Wcal}{\mathcal{W}}
\newcommand{\Xcal}{\mathcal{X}}
\newcommand{\Ycal}{\mathcal{Y}}
\newcommand{\Zcal}{\mathcal{Z}}

\newcommand{\Abb}{\mathbb{A}}
\renewcommand{\Bbb}{\mathbb{B}}
\newcommand{\Cbb}{\mathbb{C}}
\newcommand{\Dbb}{\mathbb{D}}
\newcommand{\Ebb}{\mathbb{E}}
\newcommand{\Fbb}{\mathbb{F}}
\newcommand{\Gbb}{\mathbb{G}}
\newcommand{\Hbb}{\mathbb{H}}
\newcommand{\Ibb}{\mathbb{I}}
\newcommand{\Jbb}{\mathbb{J}}
\newcommand{\Kbb}{\mathbb{K}}
\newcommand{\Lbb}{\mathbb{L}}
\newcommand{\Mbb}{\mathbb{M}}
\newcommand{\Nbb}{\mathbb{N}}
\newcommand{\Obb}{\mathbb{O}}
\newcommand{\Pbb}{\mathbb{P}}
\newcommand{\Qbb}{\mathbb{Q}}
\newcommand{\Rbb}{\mathbb{R}}
\newcommand{\Sbb}{\mathbb{S}}
\newcommand{\Tbb}{\mathbb{T}}
\newcommand{\Ubb}{\mathbb{U}}
\newcommand{\Vbb}{\mathbb{V}}
\newcommand{\Wbb}{\mathbb{W}}
\newcommand{\Xbb}{\mathbb{X}}
\newcommand{\Ybb}{\mathbb{Y}}
\newcommand{\Zbb}{\mathbb{Z}}

\renewcommand{\vec}[1]{\mathbf{\boldsymbol{#1}}}

\newcommand{\avec}{\vec{a}}
\newcommand{\bvec}{\vec{b}}
\newcommand{\cvec}{\vec{c}}
\newcommand{\dvec}{\vec{d}}
\newcommand{\evec}{\vec{e}}
\newcommand{\fvec}{\vec{f}}
\newcommand{\gvec}{\vec{g}}
\newcommand{\hvec}{\vec{h}}
\newcommand{\ivec}{\vec{i}}
\newcommand{\jvec}{\vec{j}}
\newcommand{\kvec}{\vec{k}}
\newcommand{\lvec}{\vec{l}}
\newcommand{\mvec}{\vec{m}}
\newcommand{\nvec}{\vec{n}}
\newcommand{\ovec}{\vec{o}}
\newcommand{\pvec}{\vec{p}}
\newcommand{\qvec}{\vec{q}}
\newcommand{\rvec}{\vec{r}}
\newcommand{\svec}{\vec{s}}
\newcommand{\tvec}{\vec{t}}
\newcommand{\uvec}{\vec{u}}
\newcommand{\vvec}{\vec{v}}
\newcommand{\wvec}{\vec{w}}
\newcommand{\xvec}{\vec{x}}
\newcommand{\yvec}{\vec{y}}
\newcommand{\zvec}{\vec{z}}

\newcommand{\Avec}{\vec{A}}
\newcommand{\Bvec}{\vec{B}}
\newcommand{\Cvec}{\vec{C}}
\newcommand{\Dvec}{\vec{D}}
\newcommand{\Evec}{\vec{E}}
\newcommand{\Fvec}{\vec{F}}
\newcommand{\Gvec}{\vec{G}}
\newcommand{\Hvec}{\vec{H}}
\newcommand{\Ivec}{\vec{I}}
\newcommand{\Jvec}{\vec{J}}
\newcommand{\Kvec}{\vec{K}}
\newcommand{\Lvec}{\vec{L}}
\newcommand{\Mvec}{\vec{M}}
\newcommand{\Nvec}{\vec{N}}
\newcommand{\Ovec}{\vec{O}}
\newcommand{\Pvec}{\vec{P}}
\newcommand{\Qvec}{\vec{Q}}
\newcommand{\Rvec}{\vec{R}}
\newcommand{\Svec}{\vec{S}}
\newcommand{\Tvec}{\vec{T}}
\newcommand{\Uvec}{\vec{U}}
\newcommand{\Vvec}{\vec{V}}
\newcommand{\Wvec}{\vec{W}}
\newcommand{\Xvec}{\vec{X}}
\newcommand{\Yvec}{\vec{Y}}
\newcommand{\Zvec}{\vec{Z}}

\newcommand{\yvecbar}{\bar{\vec{y}}}
\newcommand{\wvecbar}{\bar{\vec{w}}}
\newcommand{\xvecbar}{\bar{\vec{x}}}
\newcommand{\yvectil}{\tilde{\vec{y}}}
\newcommand{\yvechat}{\hat{\vec{y}}}

 
\usepackage[utf8]{inputenc} \usepackage[T1]{fontenc}    \definecolor{mydarkblue}{rgb}{0,0.08,0.45}
\usepackage[colorlinks, anchorcolor=white, linkcolor=mydarkblue, urlcolor=mydarkblue, citecolor=mydarkblue]{hyperref}       \usepackage{url}            \usepackage{booktabs}       \usepackage{amsfonts}       \usepackage{nicefrac}       \usepackage{microtype}      \usepackage{wrapfig}
\usepackage{graphicx}
\usepackage{fancyhdr}
\usepackage{tikz}
\usepackage{mathrsfs}
\usepackage{amsmath,amsfonts,graphicx,amssymb,bm,amsthm, bbm}
\usepackage{color}
\usepackage{multirow}
\usepackage{diagbox}
\usepackage{pifont}
\usepackage{mathrsfs}
\usepackage{threeparttable}
\usepackage{comment}
\usepackage[linesnumbered,ruled,vlined]{algorithm2e}
\usepackage{amsthm}
\usepackage{enumitem}
\usepackage[noabbrev,capitalise]{cleveref}
\usepackage{footnote}
\usepackage{subcaption}
\usepackage{cleveref} 
\usepackage{makecell}
\makesavenoteenv{tabular}
\makesavenoteenv{table}
\usetikzlibrary{arrows,automata}

\usepackage{tikz}
\usepackage{tcolorbox}
\newtcbox{\alertinline}[1][black]
  {on line, arc = 0pt, outer arc = 0pt,
    colback = #1!20!white, colframe = #1!50!black,
    boxsep = 0pt, left = 1pt, right = 1pt, top = 2pt, bottom = 2pt,
    boxrule = 0pt, bottomrule = 1pt, toprule = 1pt}
    
\newcommand{\attn}[1]{\mathrm{Attn}\rbr{#1}}
\newcommand{\aggr}[1]{\mathrm{AGGREGATE}\rbr{#1}}
\newcommand{\comb}[1]{\mathrm{COMBINE}\rbr{#1}}
\newcommand{\ffn}[1]{\mathrm{FFN}\rbr{#1}}

\newcommand{\sj}[1]{\textcolor{blue}{SJ: #1}}
\newcommand{\cmark}{\text{\ding{51}}}
\newcommand{\xmark}{\text{\ding{55}}}

\title{One Transformer Can Understand \\ Both 2D \& 3D Molecular Data}



\author{Shengjie Luo, \quad\qquad Tianlang Chen\thanks{These two authors contributed equally to this project}, \qquad Yixian Xu, \\ \textbf{Shuxin Zheng}\textbf{,}\quad\qquad \textbf{Tie-Yan Liu}\textbf{,}\quad\qquad\ \quad  \textbf{Liwei Wang}\thanks{Correspondence to: Di He <\texttt{dihe@pku.edu.cn}> and Liwei Wang <\texttt{wanglw@pku.edu.cn}>.}\textbf{,}\quad\qquad \textbf{Di He}\\
National Key Laboratory of General Artificial Intelligence,\ \ School of Intelligence Science\\and Technology, Peking University\ \ \ School of EECS, Peking University\ \ Microsoft Research\\Center for Data Science, Peking University\quad\quad\quadShanghai Artificial Intelligence Laboratory\\
\texttt{\footnotesize luosj@stu.pku.edu.cn, tlchen@pku.edu.cn, xyx050@stu.pku.edu.cn}\\
\texttt{\footnotesize \{shuz, tyliu\}@microsoft.com, \{wanglw, dihe\}@pku.edu.cn} \\
}



\newcommand{\fix}{\marginpar{FIX}}
\newcommand{\new}{\marginpar{NEW}}

\iclrfinalcopy \begin{document}

\vspace{-18pt}
\maketitle
\vspace{-22pt}
\begin{abstract}
\vspace{-6pt}
Unlike vision and language data which usually has a unique format, molecules can naturally be characterized using different chemical formulations. One can view a molecule as a 2D graph or define it as a collection of atoms located in a 3D space. For molecular representation learning, most previous works designed neural networks only for a particular data format, making the learned models likely to fail for other data formats. We believe a general-purpose neural network model for chemistry should be able to handle molecular tasks across data modalities. To achieve this goal, in this work, we develop a novel Transformer-based Molecular model called Transformer-M, which can take molecular data of 2D or 3D formats as input and generate meaningful semantic representations. Using the standard Transformer as the backbone architecture, Transformer-M develops two separated channels to encode 2D and 3D structural information and incorporate them with the atom features in the network modules. When the input data is in a particular format, the corresponding channel will be activated, and the other will be disabled. By training on 2D and 3D molecular data with properly designed supervised signals, Transformer-M automatically learns to leverage knowledge from different data modalities and correctly capture the representations. We conducted extensive experiments for Transformer-M. All empirical results show that Transformer-M can simultaneously achieve strong performance on 2D and 3D tasks, suggesting its broad applicability. The code and models will be made publicly available at \url{https://github.com/lsj2408/Transformer-M}.
\end{abstract}
\vspace{-16pt}
\section{Introduction}
\vspace{-6pt}
\label{sec-intro}
Deep learning approaches have revolutionized many domains, including computer vision~\citep{he2016deep}, natural language processing~\citep{devlin2019bert,brown2020language}, and games~\citep{mnih2013playing,silver2016mastering}. Recently, researchers have started investigating whether the power of neural networks could help solve important scientific problems in chemistry, e.g., predicting the property of molecules and simulating the molecular dynamics from large-scale training data~\citep{hu2020open,hu2021ogb, zhang2018deep,chanussot2020open}. 

One key difference between chemistry and conventional domains such as vision and language is the multimodality of data. In vision and language, a data instance is usually characterized in a particular form. For example, an image is defined as RGB values in a pixel grid, while a sentence is defined as tokens in a sequence. In contrast, molecules naturally have different chemical formulations. A molecule can be represented as a sequence~\citep{weininger1988smiles}, a 2D graph~\citep{wiswesser1985historic}, or a collection of atoms located in a 3D space. 2D and 3D structures are the most popularly used formulations as many valuable properties and statistics can be obtained from them~\citep{chmiela2017machine,stokes2020deep}. However, as far as we know, most previous works focus on designing neural network models for either 2D or 3D structures, making the model learned in one form fail to be applied in tasks of the other form. 

We argue that a general-purpose neural network model in chemistry should at least be able to handle molecular tasks across data modalities. In this paper, we take the first step toward this goal by developing Transformer-M, a versatile Transformer-based Molecular model that performs well for both 2D and 3D molecular representation learning. Note that for a molecule, its 2D and 3D forms describe the same collection of atoms but use different characterizations of the structure. Therefore, the key challenge is to design a model expressive and compatible in capturing structural knowledge in different formulations and train the parameters to learn from both information. Transformer is more favorable than other architectures as it can explicitly plug structural signals in the model as bias terms (e.g., positional encodings~\citep{vaswani2017attention,raffel2019exploring}). We can conveniently set 2D and 3D structural information as different bias terms through separated channels and incorporate them with the atom features in the attention layers. 

\textbf{Architecture.}\quad The backbone network of our Transformer-M is composed of standard Transformer blocks. We develop two separate channels to encode 2D and 3D structural information. The 2D channel uses degree encoding, shortest path distance encoding, and edge encoding extracted from the 2D graph structure, following~\citet{ying2021transformers}. The shortest path distance encoding and edge encoding reflect the spatial relations and bond features of a pair of atoms and are used as bias terms in the softmax attention. The degree encoding is added to the atom features in the input layer. For the 3D channel, we follow~\citet{shi2022benchmarking} to use the 3D distance encoding to encode the spatial distance between atoms in the 3D geometric structure. Each atom pair's Euclidean distance is encoded via the Gaussian Basis Kernel function~\citep{scholkopf1997comparing} and will be used as a bias term in the softmax attention. For each atom, we sum up the 3D distance encodings between it and all other atoms, and add it to atom features in the input layer. See Figure~\ref{fig:model} for an illustration.

\textbf{Training.}\quad Except for the parameters in the two structural channels, all other parameters in Transformer-M (e.g., self-attention and feed-forward networks) are shared for different data modalities. We design a joint-training approach for Transformer-M to learn its parameters. During training, when the instances in a batch are only associated with 2D graph structures, the 2D channel will be activated, and the 3D channel will be disabled. Similarly, when the instances in a batch use 3D geometric structures, the 3D channel will be activated, and the 2D channel will be disabled. When both 2D and 3D information are given, both channels will be activated. In such a way, we can collect 2D and 3D data from separate databases and train Transformer-M with different training objectives, making the training process more flexible. We expect a single model to learn to identify and incorporate information from different modalities and efficiently utilize the parameters, leading to better generalization performance.

\textbf{Experimental Results.}\quad We use the PCQM4Mv2 dataset in the OGB Large-Scale Challenge (OGB-LSC)~\citep{hu2021ogb} to train our Transformer-M, which consists of 3.4 million molecules of both 2D and 3D forms. The model is trained to predict the pre-computed HOMO-LUMO gap of each data instance in different formats with a pre-text 3D denoising task specifically for 3D data. With the pre-trained model, we directly use or fine-tune the parameters for various molecular tasks of different data formats. First, we show that on the validation set of the PCQM4Mv2 task, which only contains 2D molecular graphs, our Transformer-M surpasses all previous works by a large margin. The improvement is credited to the joint training, which effectively mitigates the overfitting problem. Second, On PDBBind~\citep{wang2004pdbbind,wang2005pdbbind} (2D\&3D),  the fine-tuned Transformer-M achieves state-of-the-art performance compared to strong baselines. Lastly, on QM9~\citep{ramakrishnan2014quantum} (3D) benchmark, the fine-tuned Transformer-M models achieve competitive performance compared to recent methods. All results show that our Transformer-M has the potential to be used as a general-purpose model in a broad range of applications in chemistry.

\vspace{-8pt}
\section{Related Works}
\vspace{-8pt}
\label{sec-related}
\looseness=-1\textbf{Neural networks for learning 2D molecular representations. }
Graph Neural Network (GNN) is popularly used in molecular graph representation learning~\citep{kipf2016semi,hamilton2017inductive,gilmer2017neural,xu2018how,velivckovic2018graph}. A GNN learns node and graph representations by recursively aggregating (i.e., message passing) and updating the node representations from neighbor representations. Different architectures are developed by using different aggregation and update strategies. We refer the readers to \citet{wu2020comprehensive} for a comprehensive survey. Recently, many works extended the Transformer model to graph tasks~\citep{dwivedi2020generalization,kreuzer2021rethinking,ying2021transformers,luo2022your,kim2022pure,rampavsek2022recipe,park2022grpe,hussain2022global,zhang2023rethinking}. Seminal works include Graphormer~\citep{ying2021transformers}, which developed graph structural encodings and used them in a standard Transformer model.

\textbf{Neural networks for learning 3D molecular representations. }
Learning molecular representations with 3D geometric information is essential in many applications, such as molecular dynamics simulation. Recently, researchers have designed architectures to preserve invariant and equivariant properties for several necessary transformations like rotation and translation. \citet{schutt2017schnet} used continuous-filter convolutional layers to  model quantum interactions in molecules. \citet{thomas2018tensor} used filters built from spherical harmonics to construct a rotation- and translation-equivariant neural network. \citet{klicpera2020directional} proposed directional message passing, which ensured their embeddings to be rotationally equivariant. \citet{liu2022spherical,wang2022comenet} use spherical coordinates to capture geometric information and achieve equivariance. \citet{hutchinson2021lietransformer, tholke2021equivariant} built Transformer models preserving equivariant properties. \cite{shi2022benchmarking} extended \cite{ying2021transformers} to a 3D Transformer model which attains better results on large-scale molecular modeling challenges~\citep{chanussot2020open}. 

\textbf{Multi-view learning for molecules. } 
\looseness=-1
The 2D graph structure and 3D geometric structure can be considered as different views of the same molecule. Inspired by the contrastive pre-training approach in vision~\citep{chen2020simple,he2020momentum,radford2021learning}, many works studied pre-training methods for molecules by jointly using the 2D and 3D information. \citet{stark20223d} used two encoders to encode the 2D and 3D molecular information separately while maximizing the mutual information between the representations. \citet{liu2021pre} derived the GraphMVP framework, which uses contrastive learning and reconstruction to pre-train a 2D encoder and a 3D encoder. \citet{zhu2022unified} unified the 2D and 3D pre-training methods above and proposed a 2D GNN model that can be enhanced by 3D geometric features. Different from these works, we aim to develop a single model which is compatible with both 2D and 3D molecular tasks. Furthermore, all the above works train models using paired 2D and 3D data, while such paired data is not a strong requirement to train our model.

\textbf{General-purpose models. }
Building a single agent that works for multiple tasks, even across modalities, is a recent discovery in deep learning. In the early years, researchers found that a single multilingual translation model can translate tens of languages using the same weights and perform better than a bilingual translation model for rare languages~\citep{lample2019cross,conneau2019unsupervised,xue2020mt5,liu2020multilingual}. Large-scale language model~\citep{devlin2019bert,brown2020language} is another example that can be applied to different downstream tasks using in-context learning or fine-tuning. \citet{reed2022generalist} further pushed the boundary by building a single generalist agent, Gato. This agent uses the same network with the same weights but can play Atari, caption images, and make conversations like a human. Our work also lies in this direction. We focus on developing a general-purpose model in chemistry, which can take molecules in different formats as input and perform well on various molecular tasks with a small number of additional training data.

\vspace{-10pt}
\section{Transformer-M}
\label{sec-method}
\vspace{-8pt}
In this section, we introduce Transformer-M, a versatile Transformer serving as a general architecture for 2D and 3D molecular representation learning. First, we introduce notations and recap the preliminaries in the backbone Transformer architecture (Section~\ref{sec-notations}). After that, we present the proposed Transformer-M model with two structural channels for different data modalities (Section~\ref{sec-interaction_encoding}).

\vspace{-8pt}
\subsection{Notations and the Backbone Transformer}
\label{sec-notations}
\vspace{-2pt}
A molecule  is made up of a collection of atoms held together by attractive forces. We denote  as the atoms with features, where  is the number of atoms, and  is the feature dimension. The structure of  can be represented in different formulations, such as 2D graph structure and 3D geometric structure. For the 2D graph structure, atoms are explicitly connected by chemical bonds, and we define , where  denotes the edge feature (i.e., the type of the bond) between atom  and  if the edge exists. For the 3D geometric structure, for each atom , its position  in the Cartesian coordinate system is provided. We define , where  and . Our goal is to design a parametric model which can take either  or  (or both of them) as input, obtain contextual representations, and make predictions on downstream tasks. 

\textbf{Transformer layer.}\quad The backbone architecture we use in this work is the Transformer model~\citep{vaswani2017attention}. A Transformer is composed of stacked Transformer blocks. A Transformer block consists of two layers: a self-attention layer followed by a feed-forward layer, with both layers having normalization (e.g., LayerNorm~\citep{ba2016layer}) and skip connections~\citep{he2016deep}. Denote  as the input to the -th block and define . For an input , the -th block works as follows:





where , , .  is the number of attention heads,  is the dimension of each head, and  is the dimension of the hidden layer.  is usually referred to as the attention matrix.

\textbf{Positional encoding.}\quad Another essential component in the Transformer is positional encoding. Note that the self-attention layer and the feed-forward layer do not make use of the order of input elements (e.g., word tokens), making the model impossible to capture the structural information. The original paper~\citep{vaswani2017attention} developed effective positional encodings to encode the sentence structural information and explicitly integrate them as bias terms into the model. Shortly, many works realized that positional encoding plays a crucial role in extending standard Transformer to more complicated data structures beyond language. By carefully designing structural encoding using domain knowledge, Transformer has successfully been applied to the image and graph domain and achieved impressive performance~\citep{dosovitskiy2020image,liu2021Swin,ying2021transformers}.    

\vspace{-4pt}
\subsection{Transformer-M and Training Strategy}
\label{sec-interaction_encoding}
\vspace{-4pt}
As we can see, the two molecular formulations defined in Section~\ref{sec-notations} use the same atom feature space but different characterizations of the structure (graph structure  v.s. geometric structure ). Therefore, the key challenge is to design a compatible architecture that can utilize either structural information in  or  (or both) and incorporate them with the atom features in a principled way. 

The Transformer is a suitable backbone to achieve the goal as we can encode structural information as bias terms and properly plug them into different modules. Furthermore, with Transformer, we can treat  and  in a unified way by decomposing the structural information into pair-wise and atom-wise encodings. Without loss of generality, we choose to use the encoding strategies in the graph and geometric Transformers proposed by~\citet{ying2021transformers,shi2022benchmarking}. For the sake of completeness, we briefly introduce those structural encodings and show how to leverage them in Transformer-M. Note that our design methodology also works with other encoding strategies~\citep{hussain2022global,park2022grpe, tholke2021equivariant}. See Appendix~\ref{appendix-more-analysis} for the detailed results.  

\textbf{Encoding pair-wise relations in .}\quad 
We use two terms to encode the structural relations between any atom pairs in the graph. First, we encode the shortest path distance (SPD) between two atoms to reflect their spatial relation. Let  denote the SPD encoding between atom  and , which is a learnable scalar determined by the distance of the shortest path between  and . Second, we encode the edge features (e.g., the chemical bond types) along the shortest path between  and  to reflect the bond information. For most molecules, there exists only one distinct shortest path between any two atoms. Denote the edges in the shortest path from  to  as , and the edge encoding between  and  is defined as , where  are learnable vectors of the same dimension as the edge feature. Denote  and  as the matrix form of the SPD encoding and edge encoding, both of which are of shape  .

\textbf{Encoding pair-wise relations in . }
We encode the Euclidean distance to reflect the spatial relation between any pair of atoms in the 3D space. For each atom pair , we first process their Euclidean distance with the Gaussian Basis Kernel function~\citep{scholkopf1997comparing}, , where  is the number of Gaussian Basis kernels. Then the 3D Distance encoding  is obtained according to  , where ,  are learnable parameters.  are learnable scalars indexed by the pair of atom types, and  are learnable kernel center and learnable scaling factor of the -th Gaussian Basis Kernel. Denote  as the matrix form of the 3D distance encoding, whose shape is .

\begin{figure}[t]
    \centering
    \includegraphics[width=0.9\textwidth]{Figures/arch.pdf}
    \caption{An illustration of our Transformer-M model architecture. We build two channels on the backbone Transformer. The red channel is activated for data with 2D graph structures to incorporate degree, shortest path distance, and edge information. The purple channel is activated for data with 3D geometric structures to leverage Euclidean distance information. Different encodings are located in appropriate modules. }
    \label{fig:model}
    \vspace{-6pt}
\end{figure}

\alertinline{\textbf{Integrating ,  and  in Transformer-M. }} All pair-wise encodings defined above capture the interatomic information, which is in a similar spirit to the relative positional encoding for sequential tasks~\citep{raffel2019exploring}. Therefore, we similarly locate those pair-wise signals in the self-attention module to provide complementary information to the dot-product term . For simplicity, we omit the index of attention head  and layer , and the modified attention matrix is defined as:


\textbf{Encoding atom-wise structural information in . } For atom ,
Eqn. (4) computes the normalized weights according to the semantic (first term) and spatial relation (last three terms) between  and other atoms. However, the information is still not sufficient. For example, the importance (i.e., centrality) of each atom is missing in the attention. For each atom , we use its degree as the centrality information. Formally, let  denote the degree encoding of the atom , which is a -dimensional learnable vector determined by the degree of the atom. Denote  as the centrality encoding of all the atoms, which is of shape .

\textbf{Encoding atom-wise structural information in . }
Similar to the 2D atom-wise centrality encoding, for geometric data, we encode the centrality of each atom in the 3D space. For each atom , we sum up the 3D Distance encodings between it and all other atoms. Let  denote the centrality encoding of atom , we have , where  is a learnable weight matrix. Similarly, we define  as the encoding of all atoms, whose shape is .

\alertinline{\textbf{Integrating  and  in Transformer-M. }} We add the atom-wise encodings of 2D and 3D structures to the atom features in the input layer. Formally, the input   is modified as:

Through this simple way, the structural information of molecules in both 2D and 3D formats is integrated into one Transformer model. It is easy to check that Transformer-M preserves equivariant properties for both data formats. 

\textbf{Training.} The next step is to learn the parameters in Transformer-M to capture meaningful representations from each data format. To achieve this goal, we develop a simple and flexible joint training method to learn Transformer-M. We first collect datasets in different formats (2D/3D) and define supervised/self-supervised tasks (e.g., energy regression) on each format, and train the model on all the data toward each objective, respectively. To be concrete, during training, if a data instance comes from a dataset in the 2D format, the 2D channel is activated, and the 3D channel is disabled. The model parameter will be optimized to minimize the corresponding (i.e., 2D) objective. When a data instance comes from a dataset in the 3D format, only the 3D channel is activated, and the model will learn to minimize the 3D objective. Both channels are activated if the model takes molecules in both 2D and 3D formats as input. Compared with the multi-view learning approaches, we can train Transformer-M using unpaired 2D and 3D data, making the training process more flexible. 

The Transformer-M may generalize better due to the joint training. Several previous works~\citep{liu2021pre} observed that 2D graph structure and 3D geometric structure contain complementary chemical knowledge. For example, the 2D graph structure only contains bonds with bond type, while the 3D geometric structure contains fine-grained information such as lengths and angles. As another example, the 3D geometric structures are usually obtained from computational simulations like Density Functional Theory (DFT)~\citep{burke2012perspective}, which could have approximation errors. The 2D graphs are constructed by domain experts, which to some extent, provide references to the 3D structure. By jointly training using 2D and 3D data with parameter sharing, our model can learn more chemical knowledge instead of overfitting to data noise and perform better on both 2D and 3D tasks. 

\textbf{Future Directions.} As an initial attempt, our Transformer-M opens up a way to develop general-purpose molecular models to handle diverse chemical tasks in different data formats. We believe it is a starting point with more possibilities to explore in the future. For example, in this work, we use a simple way and linearly combine the structural information of 2D and 3D structures, and we believe there should be other efficient ways to fuse such encodings. Our model can also be combined with previous multi-view contrastive learning approaches. It is worth investigating how to pre-train our model using those methods.

\vspace{-6pt}
\section{Experiments}
\label{sec-exp}
\vspace{-6pt}
In this section, we empirically study the performance of Transformer-M. First, we pre-train our model on the PCQM4Mv2 training set from OGB Large-Scale Challenge~\citep{hu2021ogb} (Section~\ref{sec-exp-pretrain}). With the pre-trained model, we conduct experiments on molecular tasks in different data formats and evaluate the versatility and effectiveness of our Transformer-M. Due to space limitation, we study three representative tasks,  PCQM4Mv2 (2D, Section \ref{sec-exp-pcq}), PDBBind (2D \& 3D, Section \ref{sec-exp-pdbbind}) and QM9 (3D, Section \ref{sec-exp-qm9}). Ablation studies are presented in Section \ref{sec-exp-ablation}. All codes are implemented based on the official codebase of Graphormer~\citep{ying2021transformers} in PyTorch~\citep{paszke2019pytorch}.

\vspace{-4pt}
\subsection{Large-Scale Pre-training}
\label{sec-exp-pretrain}
\vspace{-4pt}
Our Transformer-M is pre-trained on the training set of PCQM4Mv2 from the OGB Large-Scale Challenge~\citep{hu2021ogb}. The total number of training samples is 3.37 million. Each molecule is associated with its 2D graph structure and 3D geometric structure. The HOMO-LUMO energy gap of each molecule is provided as its label, which is obtained by DFT-based methods~\citep{burke2012perspective}. 

We follow \citet{ying2021transformers} and employ a 12-layer Transformer-M model. The dimension of hidden layers and feed-forward layers is set to 768. The number of attention heads is set to 32. The number of Gaussian Basis kernels is set to 128. To train Transformer-M, we provide three modes for each data instance: (1) activate the 2D channels and disable the 3D channels (2D mode); (2) activate the 3D channels and disable the 2D channels (3D mode); (3) activate both channels (2D+3D mode). The mode of each data instance during training is randomly drawn on the fly according to a pre-defined distribution, implemented similarly to Dropout~\citep{srivastava2014dropout}. In this work, we use two training objectives. The first one is a supervised learning objective, which aims to predict the HOMO-LUMO energy gap of each molecule. Besides, we also use a self-supervised learning objective called 3D Position Denoising~\citep{godwin2022simple,zaidi2022pre}, which is particularly effective. During training, if a data instance is in the 3D mode, we add Gaussian noise to the position of each atom and require the model to predict the noise from the noisy input. The model is optimized to minimize a linear combination of the two objectives above. Details of settings are in Appendix~\ref{appendix:pre-train}.
\vspace{-8pt}
\subsection{PCQM4Mv2 Performance (2D)}
\label{sec-exp-pcq}
\vspace{-6pt}
After the model is pre-trained, we evaluate our Transformer-M on the validation set of PCQM4Mv2. Note that the validation set of PCQM4Mv2 consists of molecules in the 2D format only. Therefore, we can use it to evaluate how well Transformer-M performs on 2D molecular data. The goal of the task is to predict the HOMU-LUMO energy gap, and the evaluation metric is the Mean Absolute Error (MAE). As our training objectives include the HOMO-LUMO gap prediction task, we didn't fine-tune the model parameters on any data. During inference, only the 2D channels are activated. We choose several strong baselines covering message passing neural network (MPNN) variants and Graph Transformers. Detailed descriptions of baselines are presented in Appendix~\ref{app:pcq}.

\begin{table}[t]
\small
\centering
\vspace{-6pt}
\caption{Results on PCQM4Mv2 validation set in OGB Large-Scale Challenge~\citep{hu2021ogb}. The evaluation metric is the Mean Absolute Error (MAE) [eV]. We report the official results of baselines from OGB and use  to indicate our implemented results. Bold values indicate the best performance. }
\label{tab:pcq-table}
\resizebox{0.80\textwidth}{!}{
\begin{tabular}{l|c|c}
\toprule
method            & \#param.     & Valid MAE      \\ \hline
MLP-Fingerprint~\citep{hu2021ogb} & 16.1M & 0.1753 \\

GCN~\citep{kipf2016semi}  & 2.0M  & 0.1379  \\

GIN~\citep{xu2018how} & 3.8M & 0.1195 \\ 

GINE-{\scriptsize VN}~\citep{brossard2020graph,gilmer2017neural} & 13.2M & \ \ 0.1167* \\

GCN-{\scriptsize VN}~\citep{kipf2016semi,gilmer2017neural} & 4.9M  & 0.1153 \\

GIN-{\scriptsize VN}~\citep{xu2018how,gilmer2017neural} & 6.7M  & 0.1083 \\  

DeeperGCN-{\scriptsize VN}~\citep{li2020deepergcn,gilmer2017neural} & 25.5M & \ \ 0.1021* \\

\hline 
GraphGPS~\citep{rampavsek2022recipe} & 6.2M & 0.0938 \\

CoAtGIN~\citep{cui2022coatgin} & 5.2M & 0.0933 \\

TokenGT~\citep{kim2022pure} & 48.5M & 0.0910 \\

GRPE~\citep{park2022grpe} & 46.2M & 0.0890 \\

EGT~\citep{hussain2022global} & 89.3M & 0.0869 \\

GRPE~\citep{park2022grpe} & 46.2M & 0.0867 \\

Graphormer~\citep{ying2021transformers,shi2022benchmarking} & 47.1M & 0.0864  \\

GraphGPS~\citep{rampavsek2022recipe} & 19.4M & 0.0858 \\

\hline


Transformer-M (ours) & 47.1M & \textbf{0.0787} \\

\bottomrule
\end{tabular}
}
\vspace{-4pt}
\end{table}


The results are shown in Table~\ref{tab:pcq-table}. It can be easily seen that our Transformer-M surpasses all baselines by a large margin, e.g.,  relative MAE reduction compared to the previous best model~\citep{rampavsek2022recipe}, establishing a new state-of-the-art on PCQM4Mv2 dataset. Note that our general architecture is the same as the Graphormer model \citep{ying2021transformers}. The only difference between Transformer-M and the Graphormer baseline is that Graphormer is trained on 2D data only, while Transformer-M is trained using both 2D and 3D structural information. Therefore, we can conclude that Transformer-M performs well on 2D molecular data, and the 2D-3D joint training with shared parameters indeed helps the model learn more chemical knowledge.
\vspace{-6pt}
\subsection{PDBBind Performance (2D \& 3D)}
\label{sec-exp-pdbbind}
\vspace{-6pt}
To verify the compatibility of our Transformer-M, we further fine-tune our model on the PDBBind dataset (version 2016,~\citet{wang2004pdbbind,wang2005pdbbind}), one of the most widely used datasets for structure-based virtual screening~\citep{jimenez2018k,stepniewska2018development,2019OnionNet}. PDBBind dataset consists of protein-ligand complexes as data instances, which are obtained in bioassay experiments associated with the  (or , ) affinity values. For each data instance, the 3D geometric structures are provided and the 2D graph structures are constructed via pre-defined rules. The task requires models to predict the binding affinity of protein-ligand complexes, which is extremely vital for drug discovery. After pre-trained on the PCQM4Mv2 training set, our Transformer-M model is fine-tuned and evaluated on the core set of the PDBBind dataset.

We compare our model with competitive baselines covering classical methods, CNN-based methods, and GNNs. All experiments are repeated five times with different seeds. Average performance is reported. Due to space limitation, we present the details of baselines and experiment settings in Appendix~\ref{app:pdbbind}. The results are presented in Table~\ref{tab:pdb-table}. Our Transformer-M consistently outperforms all the baselines on all evaluation metrics by a large margin, e.g.,  absolute improvement on Pearson's correlation coefficient (R). It is worth noting that data instances of the PDBBind dataset are protein-ligand complexes, while our model is pre-trained on simple molecules, demonstrating the transferability of Transformer-M.

\begin{table}[t]
\small
\centering
\caption{Results on PDBBind core set (version 2016)~\citep{wang2004pdbbind,wang2005pdbbind}. The evaluation metrics include Pearson's correlation coefficient (R), Mean Absolute Error (MAE), Root-Mean Squared Error (RMSE), and Standard Deviation (SD). We report the official results of baselines from~\citet{li2021structure}. Bold values indicate the best performance.}
\label{tab:pdb-table}
\setlength\tabcolsep{5pt}
\addtolength{\tabcolsep}{-2pt}
\begin{tabular}{l|llll}
\toprule
\multicolumn{1}{c|}{\multirow{2}{*}{Method}}                    & \multicolumn{4}{c}{PDBBind core set}                                   \\
\cline{2-5}
\multicolumn{1}{c|}{}                                           & R    & MAE    & RMSE  & SD  \\
\hline
LR                                                               & 0.671  & 1.358      & 1.675     & 1.612   \\
SVR                                                              & 0.727 & 1.264    & 1.555     & 1.493  \\
RF-Score~\citep{Ballester2010A}                  & 0.789  & 1.161     & 1.446    & 1.335  \\
\hline
Pafnucy~\citep{stepniewska2018development}       & 0.695  & 1.284      & 1.585     & 1.563   \\
OnionNet~\citep{2019OnionNet}                    & 0.768  & 1.078      & 1.407     & 1.391   \\
\hline
GraphDTA~\citep{2020GraphDTA}     & 0.613  & 1.343      & 1.735     & 1.719   \\
GraphDTA~\citep{2020GraphDTA}     & 0.601  & 1.354      & 1.765     & 1.740   \\
GraphDTA~\citep{2020GraphDTA}     & 0.667  & 1.261      & 1.640    & 1.621   \\
GraphDTA~\citep{2020GraphDTA} & 0.697 & 1.191     & 1.562    & 1.558   \\
\hline
GNN-DTI~\citep{2019Predicting}                   & 0.736  & 1.192      & 1.492     & 1.471   \\
DMPNN~\citep{2019Analyzing}                      & 0.729  & 1.188     & 1.493     & 1.489   \\
SGCN~\citep{danel2020spatial}                    & 0.686  & 1.250      & 1.583      & 1.582    \\
MAT~\citep{maziarka2020molecule}                 & 0.747   & 1.154     & 1.457     & 1.445    \\
DimeNet~\citep{klicpera2020directional}          & 0.752   & 1.138       & 1.453      & 1.434    \\
CMPNN~\citep{2020Communicative}                  & 0.765   & 1.117      & 1.408      & 1.399    \\
SIGN~\citep{li2021structure}                     & 0.797   & 1.027       & 1.316    & 1.312    \\
\hline
Transformer-M (ours)                                              & \textbf{0.830}              & \textbf{0.940 }                  & \textbf{1.232 }                & \textbf{1.207}

\\
\bottomrule
\end{tabular}
\end{table}

\begin{table}[ht]
\large
\centering
\caption{Results on QM9~\citep{ramakrishnan2014quantum}. The evaluation metric is the Mean Absolute Error (MAE). We report the official results of baselines from~\citet{tholke2021equivariant,godwin2022simple,jiao20223d}. Bold values indicate the best performance. }
\label{tab:qm9-table}
\setlength\tabcolsep{5pt}
\renewcommand{\arraystretch}{1.0}
\resizebox{\textwidth}{!}{
\begin{tabular}{l|cccccccccccc}
\toprule
method            &  &   &  &  &  &  & ZPVE &  & U & H & G &  \\ \hline
EdgePred ~\citep{hamilton2017inductive}& 0.039 & 0.086 & 37.4 & 31.9 & 58.2 & 0.112 & 1.81 & 14.7 & 14.2 & 14.8 & 14.5 & 0.038 \\
AttrMask~\citep{hu2019strategies} & 0.020 & 0.072 & 31.3 & 37.8 & 50.0 & 0.423 & 1.90 & 10.7 & 10.8 & 11.4 & 11.2 & 0.062 \\
InfoGraph~\citep{sun2019infograph} & 0.041 & 0.099 & 48.1 & 38.1 & 72.2 & 0.114 & 1.69 & 16.4 & 14.9 & 14.5 & 16.5 & 0.030 \\
GraphCL~\citep{you2020graph} & 0.027  & 0.066 & 26.8 & 22.9 & 45.5 & 0.095 & 1.42 & 9.6 & 9.7 & 9.6 & 10.2 & 0.028 \\
GPT-GNN~\citep{hu2020gpt} & 0.039 & 0.103 & 35.7 & 28.8 & 54.1 & 0.158 & 1.75 & 12.0 & 24.8 & 14.8 & 12.2 & 0.032 \\
GraphMVP~\citep{jing2021graph} & 0.031 & 0.070 & 28.5 & 26.3 & 46.9 & 0.082 & 1.63 & 10.2 & 10.3 & 10.4 & 11.2 & 0.033 \\
GEM~\citep{fang2021chemrl} & 0.034 & 0.081 & 33.8 & 27.7 & 52.1 & 0.089 & 1.73 & 13.4 & 12.6 & 13.3 & 13.2 & 0.035 \\
3D Infomax~\citep{stark20223d} & 0.034 & 0.075 & 29.8 & 25.7 & 48.8 & 0.122 & 1.67 & 12.7 & 12.5 & 12.4 & 13.0 & 0.033 \\
PosPred~\citep{jiao20223d} & 0.024 & 0.067 & 25.1 & 20.9 & 40.6 & 0.115 & 1.46 & 10.2 & 10.3 & 10.2 & 10.9 & 0.035 \\
3D-MGP~\citep{jiao20223d} & 0.020 & 0.057 & 21.3 & 18.2 & 37.1 & 0.092 & 1.38 & 8.6 & 8.6 & 8.7 & 9.3 & 0.026 \\
\hline
Schnet~\citep{schutt2017schnet} & 0.033 & 0.235 & 41 & 34 & 63 & 0.073 & 1.7 & 14 & 19 & 14 & 14 & 0.033 \\
PhysNet~\citep{unke2019physnet} & 0.0529 & 0.0615 & 32.9 & 24.7 & 42.5 & 0.765 & 1.39 & 8.15 & 8.34 & 8.42 & 9.4 & 0.028 \\
Cormorant~\citep{anderson2019cormorant} & 0.038 & 0.085 & 34 & 38 & 61 & 0.961 & 2.027 & 22 & 21 & 21 & 20 & 0.026 \\
DimeNet++~\citep{klicpera2020directional} & 0.0297 & 0.0435 & 24.6 & 19.5 & 32.6 & 0.331 & 1.21 & 6.32 & 6.28 & 6.53 & 7.56 & 0.023 \\
PaiNN~\citep{schutt2021equivariant} & 0.012 & 0.045 & 27.6 & 20.4 & 45.7 & 0.066 & 1.28 & \textbf{5.85} & \textbf{5.83} & \textbf{5.98} & \textbf{7.35} & 0.024 \\
LieTF~\citep{hutchinson2021lietransformer} & 0.041 & 0.082 & 33 & 27 & 51 & 0.448 & 2.10 & 17 & 16 & 17 & 19 & 0.035 \\
TorchMD-Net~\citep{tholke2021equivariant} & \textbf{0.011} & 0.059 & 20.3 & 17.5 & 36.1 & \textbf{0.033} & 1.84 & 6.15 & 6.38 & 6.16 & 7.62 & 0.026 \\ 
EGNN~\citep{satorras2021n} & 0.029 & 0.071 & 29 & 25 & 48 & 0.106 & 1.55 & 11 & 12 & 12  & 12 & 0.031 \\ NoisyNode~\citep{godwin2022simple} & 0.025 & 0.052 & 20.4 & 18.6 & 28.6 & 0.70 & \textbf{1.16} & 7.30 & 7.57 & 7.43  & 8.30 & 0.025
\\
\hline
Transformer-M (ours) & 0.037 & \textbf{0.041}  & \textbf{17.5} &\textbf{16.2} & \textbf{27.4} & 0.075 & 1.18 & 9.37 & 9.41 & 9.39 & 9.63 & \textbf{0.022} \\

\bottomrule
\end{tabular}
}
\end{table}

\vspace{-4pt}
\subsection{QM9 Performance (3D)}
\label{sec-exp-qm9}
\vspace{-4pt}
We use the QM9 dataset~\citep{ramakrishnan2014quantum} to evaluate our Transformer-M on molecular tasks in the 3D data format. QM9 is a quantum chemistry benchmark consisting of 134k stable small organic molecules. These molecules correspond to the subset of all 133,885 species out of the GDB-17 chemical universe of 166 billion organic molecules. Each molecule is associated with 12 targets covering its energetic, electronic, and thermodynamic properties. The 3D geometric structure of the molecule is used as input. Following \citet{tholke2021equivariant}, we randomly choose 10,000 and 10,831 molecules for validation and test evaluation, respectively. The remaining molecules are used to fine-tune our Transformer-M model. We observed that several previous works used different data splitting ratios or didn't describe the evaluation details. For a fair comparison, we choose baselines that use similar splitting ratios in the original papers. The details of baselines and experiment settings are presented in Appendix~\ref{app:qm9}.

The results are presented in Table~\ref{tab:qm9-table}. It can be seen that our Transformer-M achieves competitive performance compared to those baselines, suggesting that the model is compatible with 3D molecular data. In particular, Transformer-M performs best on HUMO, LUMO, and HUMO-LUMO predictions. This indicates that the knowledge learned in the pre-training task transfers better to similar tasks. Note that the model doesn't perform quite well on some other tasks. We believe the Transformer-M can be improved in several aspects, including employing a carefully designed output layer~\citep{tholke2021equivariant} or pre-training with more self-supervised training signals.

\vspace{-4pt}
\subsection{Ablation Study}
\label{sec-exp-ablation}
\vspace{-4pt}
In this subsection, we conduct a series of experiments to investigate the key designs of our Transformer-M. In this paper, we use two training objectives to train the model, and we will ablate the effect of the two training objectives. Besides, we use three modes to activate different channels with a pre-defined distribution, and we will study the impact of the distribution on the final performance. Due to space limitation, we present more analysis on our Transformer-M model in Appendix~\ref{appendix-more-analysis}.

\begin{table}[h]
\caption{Impact of pre-training tasks and mode distribution on Transformer-M. All other hyperparameters are kept the same for a fair comparison.}
  \vspace{-4px}
  \label{tab:ab-pcq-qm9}
  \centering
  \resizebox{0.9\textwidth}{!}{ \renewcommand{\arraystretch}{1.0}
  \small
    \begin{tabular}{ccc|cccc}
    \toprule
    \multicolumn{2}{c}{Tasks}  & 
    \multirow{3}{*}{\thead{Mode Distribution \\ }} &
    \multicolumn{1}{c}{PCQM4Mv2} &
    \multicolumn{3}{c}{QM9} \\ 
    \thead{2D-3D joint \\ Pre-training} & \thead{3D Position \\ Denoising} & & Valid MAE &  &  &  \\ \midrule
    \xmark & \xmark & - & 0.0878 & 26.5 & 23.8 & 42.3 \\
    \cmark & \xmark & 1:2:1 & 0.0811 & 20.1 & 19.3 & 31.2 \\
    \cmark & \cmark & 1:2:1 & 0.0787 & 17.5 & 16.2 & 27.4 \\
    \cmark & \cmark & 1:1:1 & 0.0796 & 18.1 & 16.9 & 27.9 \\
    \cmark & \cmark & 1:2:2 & 0.0789 & 17.8 & 16.6 & 27.5 \\
    \bottomrule
    \end{tabular}
    }
\end{table}

\looseness=-1 \textbf{Impact of the pre-training tasks.} As stated in Section~\ref{sec-exp-pretrain}, our Transformer-M model is pre-trained on the PCQM4Mv2 training set via two tasks: (1) predicting the HOMO-LUMO gap of molecules in both 2D and 3D formats. (2) 3D position denoising. We conduct ablation studies on both PCQM4Mv2 and QM9 datasets to check whether both objectives benefit downstream tasks. In detail, we conduct two additional experiments. The first experiment is training Transformer-M models from scratch on PCQM4Mv2 using its 2D graph data and QM9 using its 3D geometric data to check the benefit of the overall pre-training method. The second experiment is pre-training Transformer-M without using the 3D denoising task to study the effectiveness of the proposed 2D-3D joint pre-training approach. The results are shown in Table~\ref{tab:ab-pcq-qm9}. It can be seen that the joint pre-training significantly boosts the performance on both PCQM4Mv2 and QM9 datasets. Besides, the 3D Position Denoising task is also beneficial, especially on the QM9 dataset in the 3D format.

\textbf{Impact of mode distribution.} Denote  as the probability of the modes mentioned in Section~\ref{sec-exp-pretrain}. We conduct experiments to investigate the influence of different distributions on the model performance. We select three distribution with  being: 1:1:1, 1:2:2, and 1:2:1. The results are presented in Table \ref{tab:ab-pcq-qm9}. We obtain consistent conclusions on both PCQM4Mv2 and QM9 datasets: 1) for all three configurations, our Transformer-M model achieves strong performance, which shows that our joint training is robust to hyperparameter selection; 2) Using a slightly larger probability on the 3D mode achieves the best results.
\vspace{-4pt}
\section{Conclusion}
\label{sec-conclusion}
\vspace{-4pt}
\looseness=-1
In this work, we take the first step toward general-purpose molecular models. The proposed Transformer-M offers a promising way to handle molecular tasks in 2D and 3D formats. We use two separate channels to encode 2D and 3D structural information and integrate them into the backbone Transformer. When the input data is in a particular format, the corresponding channel will be activated, and the other will be disabled. Through simple training tasks on 2D and 3D molecular data, our model automatically learns to leverage chemical knowledge from different data formats and correctly capture the representations. Extensive experiments are conducted, and all empirical results show that our Transformer-M can achieve strong performance on 2D and 3D tasks simultaneously. The potential of our Transformer-M can be further explored in a broad range of applications in chemistry.

\section*{Acknowledgements}
We thank Shanda Li for the helpful discussions. We also thank all the anonymous reviewers for the very careful and detailed reviews as well as the valuable suggestions. Their help has further enhanced our work. This work is supported by National Key R\&D Program of China (2022ZD0114900) and National Science Foundation of China (NSFC62276005). This work is partially supported by the Shanghai Committee of Science and Technology (Grant No. 21DZ1100100).

\bibliography{iclr2023_conference}
\bibliographystyle{iclr2023_conference}

\newpage
\appendix
\section{Implementation Details of Transformer-M}
\vspace{-4pt}
\textbf{2D-3D joint Pre-training.} 
To effectively utilize molecular data in both 2D and 3D formats, we use a simple strategy. During training, each data instance in a batch has three modes: (1) activate the 2D channels, and disable the 3D channels (2D mode); (2) activate the 3D channels, and disable the 2D channels (3D mode); (3) activate both the 2D and 3D channels (2D+3D mode). The mode of each data instance during training is randomly drawn on the fly according to a pre-defined distribution , implemented similarly to Dropout~\citep{srivastava2014dropout}. For each data instance, the model is required to predict its HOMO-LUMO energy gap across the above three modes.

\textbf{Prediction head for position output.} \textbf{(3D Position Denoising)}
Following~\cite{godwin2022simple,zaidi2022pre}, we further adopt the 3D Position Denoising task as a self-supervised learning objective. During training, if a data instance is in the 3D mode, we add Gaussian noise to the positions of each atom. The model is required to predict the noise from the noisy input. Formally, let  denote the atom positions of a molecule, and the noisy version of the atom positions is denoted by , where  is the scaling factor of noise and . The prediction of the model is denoted by . Following~\cite{shi2022benchmarking}, we use an SE(3) equivariant attention layer as the prediction head:



where  is the output of the last Transformer block,  is the attention score between atom  and  calculated by Eqn.\ref{eqn:interaction-encoding},  is the k-th element of the directional vector  between atom  and , and  are learnable weight matrices. The denoising loss of a batch of molecules  is calculated by the cosine similarity between the predicted noises and the ground-truth noises as: 



\textbf{Prediction head for scalar output.}
We follow~\citet{ying2021transformers} to add a pseudo atom to each molecule and make connections between the pseudo atom and other atoms individually. The bias terms in the self-attention layer between this pseudo atom and other atoms are set to the same learnable scalar. For molecule-level prediction, we can simply use the representation of this pseudo atom to predict targets. 
\vspace{-4pt}
\section{Experimental Details}
\vspace{-4pt}
\subsection{Large-Scale Pre-training}
\label{appendix:pre-train}
\textbf{Dataset.} 
Our Transformer-M model is pre-trained on the training set of PCQM4Mv2 from the OGB Large-Scale Challenge~\citep{hu2021ogb}. PCQM4Mv2 is a quantum chemistry dataset originally curated under the PubChemQC project~\citep{maho2015pubchemqc,nakata2017pubchemqc}. The total number of training samples is 3.37 million. Each molecule in the training set is associated with both 2D graph structures and 3D geometric structures. The HOMO-LUMO energy gap of each molecule is provided, which is obtained by DFT-based geometry optimization~\citep{burke2012perspective}. According to the OGB-LSC~\citep{hu2021ogb}, the HOMO-LUMO energy gap is one of the most practically-relevant quantum chemical properties of molecules since it is related to reactivity, photoexcitation, and charge transport. Being the largest publicly available dataset for molecular property prediction, PCQM4Mv2 is considered to be a challenging benchmark for molecular models.

\textbf{Settings.} Our Transformer-M model consists of 12 layers. The dimension of hidden layers and feed-forward layers is set to 768. The number of attention heads is set to 32. The number of Gaussian Basis kernels is set to 128. We use AdamW~\citep{kingma2014adam} as the optimizer and set its hyperparameter  to 1e-8 and  to (0.9,0.999). The gradient clip norm is set to 5.0. The peak learning rate is set to 2e-4. The batch size is set to 1024. The model is trained for 1.5 million steps with a 90k-step warm-up stage. After the warm-up stage, the learning rate decays linearly to zero. The dropout ratios for the input embeddings, attention matrices, and hidden representations are set to 0.0, 0.1, and 0.0 respectively. The weight decay is set to 0.0. We also employ the stochastic depth~\citep{huang2016deep} and set the probability to 0.2. The probability  of each data instance entering the three modes mentioned in Section~\ref{sec-exp-pretrain} is set to . The scaling factor  of added noise in the 3D Position Denoising task is set to 0.2. The ratio of the supervised loss to the denoising loss is set to 1:1. All models are trained on 4 NVIDIA Tesla A100 GPUs.

\vspace{-5pt}
\subsection{PCQM4Mv2}
\label{app:pcq}
\vspace{-5pt}
\textbf{Baselines.}
We compare our Transformer-M with several competitive baselines. These models fall into two categories: message passing neural network (MPNN) variants and Graph Transformers.

For MPNN variants, we include two widely used models, GCN~\citep{kipf2016semi} and GIN~\citep{xu2018how}, and their variants with virtual node (VN)~\citep{gilmer2017neural,hu2020open}. Additionally, we compare GINE-{\scriptsize VN}~\citep{brossard2020graph} and DeeperGCN-{\scriptsize VN}~\citep{li2020deepergcn}. GINE is the multi-hop version of GIN. DeeperGCN is a 12-layer GNN model with carefully designed aggregators. The result of MLP-Fingerprint~\citep{hu2021ogb} is also reported.

We also compare several Graph Transformer models. Graphormer~\citep{ying2021transformers} developed graph structural encodings and integrated them into a standard Transformer model. It achieved impressive performance across several world competitions~\citep{ying2021first,shi2022benchmarking}. CoAtGIN~\citep{cui2022coatgin} is a hybrid architecture combining both Convolution and Attention. TokenGT~\citep{kim2022pure} adopted the standard Transformer architecture without graph-specific modifications. GraphGPS~\citep{rampavsek2022recipe} proposed a framework to integrate the positional and structural encodings, local message-passing mechanism, and global attention mechanism into the Transformer model. GRPE~\citep{park2022grpe} proposed a graph-specific relative positional encoding and considerd both node-spatial and node-edge relations. EGT~\citep{hussain2022global} exclusively used global self-attention as an aggregation mechanism rather than static localized convolutional aggregation, and utilized edge channels to capture structural information. 

\vspace{-5pt}
\subsection{PDBBIND}
\vspace{-5pt}
\label{app:pdbbind}
\textbf{Dataset.} 
PDBBind is a well-known dataset that provides a comprehensive collection of experimentally measured binding affinity data for biomolecular complexes deposited in the Protein Data Bank (PDB)~\citep{2005The}. The task requires models to predict the binding affinity value  (or , ) of protein-ligand complexes, which is extremely vital for drug discovery. In our experiment, we use the PDBBind v2016 dataset, which is widely used in recent works~\citep{li2021structure}. The PDBBind dataset includes three overlapped subsets called the general, refined, and core sets. The general set contains all 13,283 protein-ligand complexes, while the 4,057 complexes in the refined set are selected out of the general set with better quality. Moreover, the core set serves as the highest quality benchmark for testing. To avoid data leakage, we remove the data instances in the core set from the refined set. After training, we evaluate our model on the core set. The evaluation metrics include Pearson's correlation coefficient (R), Mean Absolute Error (MAE), Root-Mean Squared Error (RMSE), and Standard Deviation (SD).
 
\textbf{Baselines.}
We compare our Transformer-M with several competitive baselines. These models mainly fall into three categories: classic Machine Learning methods, Convolution Neural Network (CNN) based methods, Graph Neural Network (GNN) based methods.

First, we report the results of LR, SVR, and RF-Score~\citep{Ballester2010A}, which employed traditional machine learning approaches to predict the binding affinities. Second, inspired by the success of CNNs in computer vision,~\citet{stepniewska2018development} proposed the Pafnucy model that represents the complexes via a 3D grid and utilizes 3D convolution to produce feature maps.~\citet{2019OnionNet} introduced OnionNet, which also used CNNs to extract features based on rotation-free element-pair specific contacts between 
atoms of proteins and ligands.

There are also several works that leverage GNNs to improve the performance of the PDBBind dataset. GraphDTA~\citep{2020GraphDTA} represented protein-ligand complexes as 2D graphs and used GNN models to predict the affinity score. GNN-DTI~\citep{2019Predicting} incorporated the 3D structures of protein-ligand complexes into GNNs. DMPNN~\citep{2019Analyzing} operated over a hybrid representation that combines convolutions and descriptors. SGCN~\citep{danel2020spatial} is a GCN-inspired architecture that leverages node positions. MAT~\citep{maziarka2020molecule} augmented the attention mechanism in the standard Transformer model with inter-atomic distances and molecular graph structures. DimeNet~\citep{klicpera2020directional} developed the atom-pair embeddings and utilized directional information between atoms. CMPNN~\citep{2020Communicative} introduced a communicative kernel and a message booster module to strengthen the message passing between atoms. SIGN~\citep{li2021structure}) proposed polar-inspired graph attention
layers and pairwise interactive pooling layers to utilize the biomolecular structural information. 

\textbf{Settings.} We fine-tune the pre-trained Transformer-M on the PDBBind dataset. We use AdamW~\citep{kingma2014adam} as the optimizer and set its hyperparameter  to 1e-8 and  to (0.9,0.999). The gradient clip norm is set to 5.0. The peak learning rate is set to 2e-4. The total number of epochs is set to 30. The ratio of the warm-up steps to the total steps is set to 0.06. The batch size is set to 16. The dropout ratios for the input embeddings, attention matrices, and hidden representations are set to 0.0, 0.1, and 0.0 respectively. The weight decay is set to 0.0. Following~\citep{ying2021transformers}, We use FLAG~\citep{kong2020flag} with minor modifications for graph data augmentation. In particular, except for the step size  and the number of adversarial attack steps , we also employ a projection step in~\citet{zhu2020freelb} with maximum perturbation . These hyperparaters are set to the following configurations: . All models are trained on 2 NVIDIA Tesla V100 GPUs.

\vspace{-5pt}
\subsection{QM9}
\label{app:qm9}
\textbf{Dataset. }
QM9~\citep{ramakrishnan2014quantum} is a quantum chemistry benchmark consisting of 134k stable small organic molecules. These molecules correspond to the subset of all 133,885 species out of the GDB-17 chemical universe of 166 billion organic molecules. Each molecule is associated with 12 targets covering its energetic, electronic, and thermodynamic properties. The 3D geometric structure of the molecule is used as input. Following \citet{tholke2021equivariant}, we randomly choose 10,000 and 10,831 molecules for validation and test evaluation, respectively. The remaining molecules are used to fine-tune our Transformer-M model.

\textbf{Baselines.} 
We comprehensively compare our Transformer-M with both pre-training methods and 3D molecular models. First, we follow~\citet{jiao20223d} to compare several pre-training methods. ~\citet{hu2019strategies} proposed a strategy to pre-train GNNs via both node-level and graph-level tasks.~\citet{sun2019infograph} maximized the mutual information between graph-level representations and substructure representations as the pre-training tasks.~\citet{you2020graph} instead used contrastive learning to pre-train GNNs. There are also several works that utilize 3D geometric structures during pre-training.~\citet{jing2021graph} maximized the mutual information between 2D and 3D representations.~\citet{fang2021chemrl} proposed a strategy to learn spatial information by utilizing both local and global 3D structures.~\citet{stark20223d} used two encoders to capture 2D and 3D structural information separately while maximizing the mutual information between 2D and 3D representations.~\citet{jiao20223d} adopted an equivariant energy-based model and developed a node-level pretraining loss for force prediction. We report the results of these methods from~\citep{jiao20223d} for comparison.

Second, we follow~\citet{tholke2021equivariant} to compare 3D molecular models.~\citet{schutt2017schnet} used continuous-filter convolution layers to model quantum interactions in molecules.~\citet{anderson2019cormorant} developed a GNN model equipped with activation functions being covariant to rotations.~\citet{klicpera2020directional} proposed directional message passing, which uses atom-pair embeddings and utilizes directional information between atoms.~\citet{schutt2021equivariant} proposed the polarizable atom interaction neural network (PaiNN) that uses an equivariant message passing mechanism.~\citet{hutchinson2021lietransformer} built upon the Transformer model consisting of attention layers that are equivariant to arbitrary Lie groups and their discrete subgroups.~\citet{tholke2021equivariant} also developed a Transformer variant with layers designed by prior physical and chemical knowledge.~\citet{satorras2021n} proposed the EGNN model which does not require computationally expensive higher-order representations in immediate layers to keep equivariance, and can be easily scaled to higher-dimensional spaces.~\citet{godwin2022simple} proposed the 3D position denoising task and verified it on the Graph Network-based Simulator (GNS) model~\citep{pmlr-v119-sanchez-gonzalez20a}.

\textbf{Settings. } We fine-tune the pre-trained Transformer-M on the QM9 dataset. Following~\citet{tholke2021equivariant}, we adopt the Mean Squared Error (MSE) loss during training and use the Mean Absolute Error (MAE) loss function during evaluation. We also adopt label standardization for stable training. We use AdamW as the optimizer, and set the hyper-parameter  to 1e-8 and  to (0.9,0.999). The gradient clip norm is set to 5.0. The peak learning rate is set to 7e-5. The batch size is set to 128. The dropout ratios for the input embeddings, attention matrices, and hidden representations are set to 0.0, 0.1, and 0.0 respectively. The weight decay is set to 0.0. The model is fine-tuned for 600k steps with a 60k-step warm-up stage. After the warm-up stage, the learning rate decays linearly to zero. All models are trained on 1 NVIDIA A100 GPU.

\subsection{More Analysis}
\label{appendix-more-analysis}
\textbf{Investigation on the generality of the design methodology of Transformer-M.} In this work, we develop our Transformer-M model based on the Transformer backbone and integrate separate 2D and 3D channels (implemented by encoding methods) to encode the structural information of 2D and 3D molecular data. As stated in Section~\ref{sec-interaction_encoding}, it is a general design methodology for handling molecular data in different forms, which works well with different structural encoding instantiations. To demonstrate its generality and effectiveness, we further conduct experiments with other structural encodings from GRPE~\citep{park2022grpe} and EGT~\citep{hussain2022global}, which are competitive baselines on the PCQM4Mv2 benchmark as shown in Table~\ref{tab:pcq-table}. All the hyperparameters are kept the same as the settings in Appendix~\ref{appendix:pre-train} for a fair comparison. The results are presented in Table~\ref{tab:ab-pcq-encoding}. It can be easily seen that our Transformer-M model equipped with different encoding methods can consistently obtain significantly better performance than the corresponding vanilla 2D models, which indeed verifies the generality and effectiveness of the design methodology of Transformer-M.

\begin{table}[h]
\caption{Performance of Transformer-M with different structural encodings on PCQM4Mv2 validation set. The evaluation metric is the Mean Absolute Error (MAE) [eV]. For a fair comparison, all hyperparameters are kept the same as the settings in Appendix~\ref{appendix:pre-train}.}
\vspace{-4pt}
  \label{tab:ab-pcq-encoding}
  \centering
  \resizebox{1.0\textwidth}{!}{ \renewcommand{\arraystretch}{1.0}
  \small
    \begin{tabular}{l|ccc}
    \toprule
    Structural Encodings  & 
    \thead{Training in \\ the vanilla setting (2D only)} &
    \thead{Training in \\ the Transformer-M framework} & \\ 
    \midrule
    Graphormer~\citep{ying2021transformers} & 0.0878 & 0.0787 & 10.4\% \\
    GRPE~\citep{park2022grpe} & 0.0884 & 0.0798 & 9.7\% \\
    EGT\citep{hussain2022global} & 0.0876 & 0.0794 & 9.4\% \\
    \bottomrule
    \end{tabular}
    }
\end{table}

\begin{table}[h]
\caption{Ablation study on the impact of 3D conformers calculated by different methods. Experiments are conducted on the PCQM4Mv2 dataset. The evaluation metric is the Mean Absolute Error (MAE) [eV]. For a fair comparison, all hyperparameters are kept the same as the settings in Appendix~\ref{appendix:pre-train}.}
\vspace{-4pt}
  \label{tab:ab-pcq-conformer}
  \centering
  \resizebox{0.8\textwidth}{!}{ \renewcommand{\arraystretch}{1.0}
  \small
    \begin{tabular}{cccc}
    \toprule
    2D & 
    \thead{3D Conformer \\ {[}by RDKit~\citep{Landrum2016RDKit2016_09_4}{]}} &
    \thead{3D Conformer \\ {[}by DFT, from PCQM4Mv2~\citep{hu2021ogb}{]}} & Valid MAE\\ 
    \midrule
    \cmark & \xmark & \xmark & 0.0878 \\
    \cmark & \cmark & \xmark & 0.0872 \\
    \cmark & \cmark & \cmark & 0.0792 \\
    \cmark & \xmark & \cmark & 0.0787 \\
    \bottomrule
    \end{tabular}
    }
\end{table}

\textbf{Investigation on the impact of 3D conformers calculated by different methods.} 
Besides the versatility to handle molecules in different formats, our Transformer-M further achieves strong performance on various challenging molecular tasks, as shown in Section~\ref{sec-exp}. On PCQM4Mv2 validation set (2D only), our Transformer-M establishes a new state-of-the-art, which mainly credits to the newly introduced 2D-3D joint training strategy in Section~\ref{sec-interaction_encoding}. The chemical knowledge in the 3D geometric structure can be leveraged during joint training and boost the performance of 2D tasks. Since the benefits of the 3D geometric structure are observed, it is natural to ask how the quality of calculated 3D conformers influences the performance of Transformer-M. 

\looseness=-1 To investigate this question, we additionally use the RDKit~\citep{Landrum2016RDKit2016_09_4} to generate one 3D conformed for each molecule in the training set of PCQM4Mv2. Compared to officially provided DFT-optimized geometric structures, the structures are less costly to obtain by using RDKit while also being less accurate. Thus, each molecule has its 2D molecular graph, 3D conformer calculated by DFT, and 3D conformer calculated by RDKit. Based on such a dataset, we conduct three additional experiments. Firstly, we train our Transformer-M model only using 2D molecular graphs. In this experiment, only the 2D channels are activated. Secondly, we train our Transformer-M model using both 2D molecular graphs (encoded by 2D channels) and 3D conformers generated by RDKit (encoded by 3D channels). Thirdly, we train our Transformer-M model using 2D molecular graphs, 3D conformers generated by RDKit, and 3D conformers calculated by DFT. In this experiment, we use two sets of 3D channels to separately encode structural information of 3D RDKit conformers and 3D DFT conformers. During training, when a data instance enters 3D or 2D+3D modes, both sets of 3D channels are activated and integrated. For all three experiments, the hyperparameters of Transformer-M are kept the same as the settings in Appendix~\ref{appendix:pre-train}. The results are presented in Table~\ref{tab:ab-pcq-conformer}.

\looseness=-1 We can see that the quality of the 3D conformer matters in the final performance: leveraging 3D conformers generated by RDKit (second line) brings minor gains compared to using 2D molecular graphs only (first line). On the contrary, when leveraging 3D conformers calculated by DFT, the improvement is significant (the last two lines). From the practical view, it will be interesting to investigate the influence of 3D conformers calculated by methods that are more accurate than RDKit while more efficient than DFT, e.g., semiempirical methods~\citep{dral2016semiempirical}, which we leave as future work.

\textbf{Investigation on the effectiveness of Transformer-M pre-training.} We provide additional results on the effectiveness of our model on both PDBBind (2D+3D) and QM9 (3D) downstream datasets. 

Firstly, to verify the effectiveness of Transformer-M pre-training on the PDBBind dataset, we further pre-train the Graphormer model~\citep{ying2021transformers} on the same PCQM4Mv2 dataset as a competitive pre-trained baseline. Since the Graphormer model can only handle graph data, we only use the 2D molecular graph of each data instance. All hyperparameters are kept the same as the settings in Appendix~\ref{appendix:pre-train}. The results are presented in Table~\ref{tab:pdb-more-results}.

\begin{table}[h]
\small
\centering
\caption{Investigation on the effectiveness of Transformer-M pre-training on PDBBind core set (version 2016). The evaluation metrics include Pearson's correlation coefficient (R), Mean Absolute Error (MAE), Root-Mean Squared Error (RMSE), and Standard Deviation (SD).}
\label{tab:pdb-more-results}
\setlength\tabcolsep{5pt}
\addtolength{\tabcolsep}{-2pt}
\begin{tabular}{l|llll}
\toprule
\multicolumn{1}{c|}{\multirow{2}{*}{Method}}                    & \multicolumn{4}{c}{PDBBind core set}                                   \\
\cline{2-5}
\multicolumn{1}{c|}{}                                           & R    & MAE    & RMSE  & SD  \\
\hline
SIGN~\citep{li2021structure} (the best baseline in Table~\ref{tab:pdb-table})                    & 0.797   & 1.027       & 1.316    & 1.312    \\
Graphormer~\citep{ying2021transformers}                     & 0.804   & 0.998       & 1.285    & 1.271    \\
Transformer-M (ours)                                              & \textbf{0.830}              & \textbf{0.940 }                  & \textbf{1.232 }                & \textbf{1.207}\\
\bottomrule
\end{tabular}
\end{table}

We can draw the following conclusions: (1) pre-training is helpful (e.g., 0.797 (R of SIGN model, the best baseline) -> 0.804 (R of pre-trained Graphormer model)); (2) our pre-training method is more significant (e.g., 0.804 -> 0.830), which indeed demonstrate the effectiveness of our framework.

\looseness=-1 Secondly, we demonstrate that our pre-training strategy helps learn a better Transformer model on downstream QM9 dataset. We conduct two additional experiments on the QM9 dataset. In the first experiment, we train the 3D geometric Transformer model (Transformer-M with 3D channel only) from scratch. In the second experiment, we use the 3D Position Denoising task as the objective to pre-train the 3D geometric Transformer on the PCQM4Mv2 and fine-tune the pre-trained checkpoint on QM9. Due to the time limits and constrained resources, we selected six QM9 targets for comparison. All the hyperparameters of pre-training and fine-tuning are kept the same. The results are presented in Table~\ref{tab:qm9-more-results}. 

\begin{table}[h]
\large
\centering
\caption{Investigation on the effectiveness of Transformer-M pre-training on QM9~\citep{ramakrishnan2014quantum}. The evaluation metric is the Mean Absolute Error (MAE).}
\label{tab:qm9-more-results}
\setlength\tabcolsep{5pt}
\renewcommand{\arraystretch}{1.0}
\resizebox{\textwidth}{!}{
\begin{tabular}{l|cccccc}
\toprule
Method            &  &  &  & U & H & G
\\ \hline
No Pre-training & 26.5 & 23.8 & 14.78 & 14.56 & 14.82 & 14.95 \\
3D Position Denoising only & 18.8 & 17.6 & 10.26 & 10.18 & 10.33 & 10.27
\\
2D-3D joint Pre-training + 3D Position Denosing & \textbf{17.5} & \textbf{16.2}  & \textbf{9.37} &\textbf{9.41} & \textbf{9.39} & \textbf{9.63}
\\

\bottomrule
\end{tabular}
}
\end{table}

It can be easily seen that our pre-training methods consistently and significantly improve the downstream performance on all six tasks, which indeed demonstrates the effectiveness of our general framework for 3D molecular data. We are aware that we achieve competitive rather than SOTA performance compared with baselines (5 best performance out of 12 targets, see Table~\ref{tab:qm9-table}). For U0, U, H, and G, there still exists a performance gap between our Transformer-M and some latest baselines, which use pretty complicated neural architectures. We believe that exploring more model alternatives and leveraging the wisdom in those networks into our Transformer-M will further improve the performance, which we will keep working on.

\end{document}