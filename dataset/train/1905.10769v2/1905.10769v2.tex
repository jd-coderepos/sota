\documentclass{article}

\PassOptionsToPackage{numbers, compress}{natbib}






\usepackage[final]{neurips_2019}



\usepackage[utf8]{inputenc} \usepackage[T1]{fontenc}    \usepackage{hyperref}       \usepackage{url}            \usepackage{booktabs}       \usepackage{amsfonts}       \usepackage{nicefrac}       \usepackage{microtype}      \usepackage{todonotes}

\usepackage{amsmath}
\usepackage{mathtools}
\usepackage[linesnumbered,ruled]{algorithm2e}
\usepackage{multirow}
\usepackage{makecell}

\usepackage{xcolor}
\usepackage[normalem]{ulem}
\newcommand\redsout{\bgroup\markoverwith{\textcolor{red}{\rule[0.5ex]{2pt}{0.4pt}}}\ULon}
\newcommand\mytodo[1]{\textcolor{red}{#1}}
\newcommand\jiaqi[1]{\textcolor{blue}{#1}}

\newcommand{\vpara}[1]{\vspace{0.05in}\noindent\textbf{#1 }}

\newcommand{\reals}{\mathbb{R}}

\newcommand\distas{\stackrel{\mathclap{\tiny{\mbox{i.i.d}}}}{\sim}} 

\usepackage{amsmath,amsfonts,bm}

\newcommand{\figleft}{{\em (Left)}}
\newcommand{\figcenter}{{\em (Center)}}
\newcommand{\figright}{{\em (Right)}}
\newcommand{\figtop}{{\em (Top)}}
\newcommand{\figbottom}{{\em (Bottom)}}
\newcommand{\captiona}{{\em (a)}}
\newcommand{\captionb}{{\em (b)}}
\newcommand{\captionc}{{\em (c)}}
\newcommand{\captiond}{{\em (d)}}

\newcommand{\newterm}[1]{{\bf #1}}


\def\figref#1{figure~\ref{#1}}
\def\Figref#1{Figure~\ref{#1}}
\def\twofigref#1#2{figures \ref{#1} and \ref{#2}}
\def\quadfigref#1#2#3#4{figures \ref{#1}, \ref{#2}, \ref{#3} and \ref{#4}}
\def\secref#1{section~\ref{#1}}
\def\Secref#1{Section~\ref{#1}}
\def\twosecrefs#1#2{sections \ref{#1} and \ref{#2}}
\def\secrefs#1#2#3{sections \ref{#1}, \ref{#2} and \ref{#3}}
\def\eqref#1{equation~\ref{#1}}
\def\Eqref#1{Equation~\ref{#1}}
\def\plaineqref#1{\ref{#1}}
\def\chapref#1{chapter~\ref{#1}}
\def\Chapref#1{Chapter~\ref{#1}}
\def\rangechapref#1#2{chapters\ref{#1}--\ref{#2}}
\def\algref#1{algorithm~\ref{#1}}
\def\Algref#1{Algorithm~\ref{#1}}
\def\twoalgref#1#2{algorithms \ref{#1} and \ref{#2}}
\def\Twoalgref#1#2{Algorithms \ref{#1} and \ref{#2}}
\def\partref#1{part~\ref{#1}}
\def\Partref#1{Part~\ref{#1}}
\def\twopartref#1#2{parts \ref{#1} and \ref{#2}}

\def\ceil#1{\lceil #1 \rceil}
\def\floor#1{\lfloor #1 \rfloor}
\def\1{\bm{1}}
\newcommand{\train}{\mathcal{D}}
\newcommand{\valid}{\mathcal{D_{\mathrm{valid}}}}
\newcommand{\test}{\mathcal{D_{\mathrm{test}}}}

\def\eps{{\epsilon}}


\def\reta{{\textnormal{}}}
\def\ra{{\textnormal{a}}}
\def\rb{{\textnormal{b}}}
\def\rc{{\textnormal{c}}}
\def\rd{{\textnormal{d}}}
\def\re{{\textnormal{e}}}
\def\rf{{\textnormal{f}}}
\def\rg{{\textnormal{g}}}
\def\rh{{\textnormal{h}}}
\def\ri{{\textnormal{i}}}
\def\rj{{\textnormal{j}}}
\def\rk{{\textnormal{k}}}
\def\rl{{\textnormal{l}}}
\def\rn{{\textnormal{n}}}
\def\ro{{\textnormal{o}}}
\def\rp{{\textnormal{p}}}
\def\rq{{\textnormal{q}}}
\def\rr{{\textnormal{r}}}
\def\rs{{\textnormal{s}}}
\def\rt{{\textnormal{t}}}
\def\ru{{\textnormal{u}}}
\def\rv{{\textnormal{v}}}
\def\rw{{\textnormal{w}}}
\def\rx{{\textnormal{x}}}
\def\ry{{\textnormal{y}}}
\def\rz{{\textnormal{z}}}

\def\rvepsilon{{\mathbf{\epsilon}}}
\def\rvtheta{{\mathbf{\theta}}}
\def\rva{{\mathbf{a}}}
\def\rvb{{\mathbf{b}}}
\def\rvc{{\mathbf{c}}}
\def\rvd{{\mathbf{d}}}
\def\rve{{\mathbf{e}}}
\def\rvf{{\mathbf{f}}}
\def\rvg{{\mathbf{g}}}
\def\rvh{{\mathbf{h}}}
\def\rvu{{\mathbf{i}}}
\def\rvj{{\mathbf{j}}}
\def\rvk{{\mathbf{k}}}
\def\rvl{{\mathbf{l}}}
\def\rvm{{\mathbf{m}}}
\def\rvn{{\mathbf{n}}}
\def\rvo{{\mathbf{o}}}
\def\rvp{{\mathbf{p}}}
\def\rvq{{\mathbf{q}}}
\def\rvr{{\mathbf{r}}}
\def\rvs{{\mathbf{s}}}
\def\rvt{{\mathbf{t}}}
\def\rvu{{\mathbf{u}}}
\def\rvv{{\mathbf{v}}}
\def\rvw{{\mathbf{w}}}
\def\rvx{{\mathbf{x}}}
\def\rvy{{\mathbf{y}}}
\def\rvz{{\mathbf{z}}}

\def\erva{{\textnormal{a}}}
\def\ervb{{\textnormal{b}}}
\def\ervc{{\textnormal{c}}}
\def\ervd{{\textnormal{d}}}
\def\erve{{\textnormal{e}}}
\def\ervf{{\textnormal{f}}}
\def\ervg{{\textnormal{g}}}
\def\ervh{{\textnormal{h}}}
\def\ervi{{\textnormal{i}}}
\def\ervj{{\textnormal{j}}}
\def\ervk{{\textnormal{k}}}
\def\ervl{{\textnormal{l}}}
\def\ervm{{\textnormal{m}}}
\def\ervn{{\textnormal{n}}}
\def\ervo{{\textnormal{o}}}
\def\ervp{{\textnormal{p}}}
\def\ervq{{\textnormal{q}}}
\def\ervr{{\textnormal{r}}}
\def\ervs{{\textnormal{s}}}
\def\ervt{{\textnormal{t}}}
\def\ervu{{\textnormal{u}}}
\def\ervv{{\textnormal{v}}}
\def\ervw{{\textnormal{w}}}
\def\ervx{{\textnormal{x}}}
\def\ervy{{\textnormal{y}}}
\def\ervz{{\textnormal{z}}}

\def\rmA{{\mathbf{A}}}
\def\rmB{{\mathbf{B}}}
\def\rmC{{\mathbf{C}}}
\def\rmD{{\mathbf{D}}}
\def\rmE{{\mathbf{E}}}
\def\rmF{{\mathbf{F}}}
\def\rmG{{\mathbf{G}}}
\def\rmH{{\mathbf{H}}}
\def\rmI{{\mathbf{I}}}
\def\rmJ{{\mathbf{J}}}
\def\rmK{{\mathbf{K}}}
\def\rmL{{\mathbf{L}}}
\def\rmM{{\mathbf{M}}}
\def\rmN{{\mathbf{N}}}
\def\rmO{{\mathbf{O}}}
\def\rmP{{\mathbf{P}}}
\def\rmQ{{\mathbf{Q}}}
\def\rmR{{\mathbf{R}}}
\def\rmS{{\mathbf{S}}}
\def\rmT{{\mathbf{T}}}
\def\rmU{{\mathbf{U}}}
\def\rmV{{\mathbf{V}}}
\def\rmW{{\mathbf{W}}}
\def\rmX{{\mathbf{X}}}
\def\rmY{{\mathbf{Y}}}
\def\rmZ{{\mathbf{Z}}}

\def\ermA{{\textnormal{A}}}
\def\ermB{{\textnormal{B}}}
\def\ermC{{\textnormal{C}}}
\def\ermD{{\textnormal{D}}}
\def\ermE{{\textnormal{E}}}
\def\ermF{{\textnormal{F}}}
\def\ermG{{\textnormal{G}}}
\def\ermH{{\textnormal{H}}}
\def\ermI{{\textnormal{I}}}
\def\ermJ{{\textnormal{J}}}
\def\ermK{{\textnormal{K}}}
\def\ermL{{\textnormal{L}}}
\def\ermM{{\textnormal{M}}}
\def\ermN{{\textnormal{N}}}
\def\ermO{{\textnormal{O}}}
\def\ermP{{\textnormal{P}}}
\def\ermQ{{\textnormal{Q}}}
\def\ermR{{\textnormal{R}}}
\def\ermS{{\textnormal{S}}}
\def\ermT{{\textnormal{T}}}
\def\ermU{{\textnormal{U}}}
\def\ermV{{\textnormal{V}}}
\def\ermW{{\textnormal{W}}}
\def\ermX{{\textnormal{X}}}
\def\ermY{{\textnormal{Y}}}
\def\ermZ{{\textnormal{Z}}}

\def\vzero{{\bm{0}}}
\def\vone{{\bm{1}}}
\def\vmu{{\bm{\mu}}}
\def\vtheta{{\bm{\theta}}}
\def\va{{\bm{a}}}
\def\vb{{\bm{b}}}
\def\vc{{\bm{c}}}
\def\vd{{\bm{d}}}
\def\ve{{\bm{e}}}
\def\vf{{\bm{f}}}
\def\vg{{\bm{g}}}
\def\vh{{\bm{h}}}
\def\vi{{\bm{i}}}
\def\vj{{\bm{j}}}
\def\vk{{\bm{k}}}
\def\vl{{\bm{l}}}
\def\vm{{\bm{m}}}
\def\vn{{\bm{n}}}
\def\vo{{\bm{o}}}
\def\vp{{\bm{p}}}
\def\vq{{\bm{q}}}
\def\vr{{\bm{r}}}
\def\vs{{\bm{s}}}
\def\vt{{\bm{t}}}
\def\vu{{\bm{u}}}
\def\vv{{\bm{v}}}
\def\vw{{\bm{w}}}
\def\vx{{\bm{x}}}
\def\vy{{\bm{y}}}
\def\vz{{\bm{z}}}

\def\evalpha{{\alpha}}
\def\evbeta{{\beta}}
\def\evepsilon{{\epsilon}}
\def\evlambda{{\lambda}}
\def\evomega{{\omega}}
\def\evmu{{\mu}}
\def\evpsi{{\psi}}
\def\evsigma{{\sigma}}
\def\evtheta{{\theta}}
\def\eva{{a}}
\def\evb{{b}}
\def\evc{{c}}
\def\evd{{d}}
\def\eve{{e}}
\def\evf{{f}}
\def\evg{{g}}
\def\evh{{h}}
\def\evi{{i}}
\def\evj{{j}}
\def\evk{{k}}
\def\evl{{l}}
\def\evm{{m}}
\def\evn{{n}}
\def\evo{{o}}
\def\evp{{p}}
\def\evq{{q}}
\def\evr{{r}}
\def\evs{{s}}
\def\evt{{t}}
\def\evu{{u}}
\def\evv{{v}}
\def\evw{{w}}
\def\evx{{x}}
\def\evy{{y}}
\def\evz{{z}}

\def\mA{{\bm{A}}}
\def\mB{{\bm{B}}}
\def\mC{{\bm{C}}}
\def\mD{{\bm{D}}}
\def\mE{{\bm{E}}}
\def\mF{{\bm{F}}}
\def\mG{{\bm{G}}}
\def\mH{{\bm{H}}}
\def\mI{{\bm{I}}}
\def\mJ{{\bm{J}}}
\def\mK{{\bm{K}}}
\def\mL{{\bm{L}}}
\def\mM{{\bm{M}}}
\def\mN{{\bm{N}}}
\def\mO{{\bm{O}}}
\def\mP{{\bm{P}}}
\def\mQ{{\bm{Q}}}
\def\mR{{\bm{R}}}
\def\mS{{\bm{S}}}
\def\mT{{\bm{T}}}
\def\mU{{\bm{U}}}
\def\mV{{\bm{V}}}
\def\mW{{\bm{W}}}
\def\mX{{\bm{X}}}
\def\mY{{\bm{Y}}}
\def\mZ{{\bm{Z}}}
\def\mBeta{{\bm{\beta}}}
\def\mPhi{{\bm{\Phi}}}
\def\mLambda{{\bm{\Lambda}}}
\def\mSigma{{\bm{\Sigma}}}

\DeclareMathAlphabet{\mathsfit}{\encodingdefault}{\sfdefault}{m}{sl}
\SetMathAlphabet{\mathsfit}{bold}{\encodingdefault}{\sfdefault}{bx}{n}
\newcommand{\tens}[1]{\bm{\mathsfit{#1}}}
\def\tA{{\tens{A}}}
\def\tB{{\tens{B}}}
\def\tC{{\tens{C}}}
\def\tD{{\tens{D}}}
\def\tE{{\tens{E}}}
\def\tF{{\tens{F}}}
\def\tG{{\tens{G}}}
\def\tH{{\tens{H}}}
\def\tI{{\tens{I}}}
\def\tJ{{\tens{J}}}
\def\tK{{\tens{K}}}
\def\tL{{\tens{L}}}
\def\tM{{\tens{M}}}
\def\tN{{\tens{N}}}
\def\tO{{\tens{O}}}
\def\tP{{\tens{P}}}
\def\tQ{{\tens{Q}}}
\def\tR{{\tens{R}}}
\def\tS{{\tens{S}}}
\def\tT{{\tens{T}}}
\def\tU{{\tens{U}}}
\def\tV{{\tens{V}}}
\def\tW{{\tens{W}}}
\def\tX{{\tens{X}}}
\def\tY{{\tens{Y}}}
\def\tZ{{\tens{Z}}}


\def\gA{{\mathcal{A}}}
\def\gB{{\mathcal{B}}}
\def\gC{{\mathcal{C}}}
\def\gD{{\mathcal{D}}}
\def\gE{{\mathcal{E}}}
\def\gF{{\mathcal{F}}}
\def\gG{{\mathcal{G}}}
\def\gH{{\mathcal{H}}}
\def\gI{{\mathcal{I}}}
\def\gJ{{\mathcal{J}}}
\def\gK{{\mathcal{K}}}
\def\gL{{\mathcal{L}}}
\def\gM{{\mathcal{M}}}
\def\gN{{\mathcal{N}}}
\def\gO{{\mathcal{O}}}
\def\gP{{\mathcal{P}}}
\def\gQ{{\mathcal{Q}}}
\def\gR{{\mathcal{R}}}
\def\gS{{\mathcal{S}}}
\def\gT{{\mathcal{T}}}
\def\gU{{\mathcal{U}}}
\def\gV{{\mathcal{V}}}
\def\gW{{\mathcal{W}}}
\def\gX{{\mathcal{X}}}
\def\gY{{\mathcal{Y}}}
\def\gZ{{\mathcal{Z}}}

\def\sA{{\mathbb{A}}}
\def\sB{{\mathbb{B}}}
\def\sC{{\mathbb{C}}}
\def\sD{{\mathbb{D}}}
\def\sF{{\mathbb{F}}}
\def\sG{{\mathbb{G}}}
\def\sH{{\mathbb{H}}}
\def\sI{{\mathbb{I}}}
\def\sJ{{\mathbb{J}}}
\def\sK{{\mathbb{K}}}
\def\sL{{\mathbb{L}}}
\def\sM{{\mathbb{M}}}
\def\sN{{\mathbb{N}}}
\def\sO{{\mathbb{O}}}
\def\sP{{\mathbb{P}}}
\def\sQ{{\mathbb{Q}}}
\def\sR{{\mathbb{R}}}
\def\sS{{\mathbb{S}}}
\def\sT{{\mathbb{T}}}
\def\sU{{\mathbb{U}}}
\def\sV{{\mathbb{V}}}
\def\sW{{\mathbb{W}}}
\def\sX{{\mathbb{X}}}
\def\sY{{\mathbb{Y}}}
\def\sZ{{\mathbb{Z}}}

\def\emLambda{{\Lambda}}
\def\emA{{A}}
\def\emB{{B}}
\def\emC{{C}}
\def\emD{{D}}
\def\emE{{E}}
\def\emF{{F}}
\def\emG{{G}}
\def\emH{{H}}
\def\emI{{I}}
\def\emJ{{J}}
\def\emK{{K}}
\def\emL{{L}}
\def\emM{{M}}
\def\emN{{N}}
\def\emO{{O}}
\def\emP{{P}}
\def\emQ{{Q}}
\def\emR{{R}}
\def\emS{{S}}
\def\emT{{T}}
\def\emU{{U}}
\def\emV{{V}}
\def\emW{{W}}
\def\emX{{X}}
\def\emY{{Y}}
\def\emZ{{Z}}
\def\emSigma{{\Sigma}}

\newcommand{\etens}[1]{\mathsfit{#1}}
\def\etLambda{{\etens{\Lambda}}}
\def\etA{{\etens{A}}}
\def\etB{{\etens{B}}}
\def\etC{{\etens{C}}}
\def\etD{{\etens{D}}}
\def\etE{{\etens{E}}}
\def\etF{{\etens{F}}}
\def\etG{{\etens{G}}}
\def\etH{{\etens{H}}}
\def\etI{{\etens{I}}}
\def\etJ{{\etens{J}}}
\def\etK{{\etens{K}}}
\def\etL{{\etens{L}}}
\def\etM{{\etens{M}}}
\def\etN{{\etens{N}}}
\def\etO{{\etens{O}}}
\def\etP{{\etens{P}}}
\def\etQ{{\etens{Q}}}
\def\etR{{\etens{R}}}
\def\etS{{\etens{S}}}
\def\etT{{\etens{T}}}
\def\etU{{\etens{U}}}
\def\etV{{\etens{V}}}
\def\etW{{\etens{W}}}
\def\etX{{\etens{X}}}
\def\etY{{\etens{Y}}}
\def\etZ{{\etens{Z}}}

\newcommand{\pdata}{p_{\rm{data}}}
\newcommand{\ptrain}{\hat{p}_{\rm{data}}}
\newcommand{\Ptrain}{\hat{P}_{\rm{data}}}
\newcommand{\pmodel}{p_{\rm{model}}}
\newcommand{\Pmodel}{P_{\rm{model}}}
\newcommand{\ptildemodel}{\tilde{p}_{\rm{model}}}
\newcommand{\pencode}{p_{\rm{encoder}}}
\newcommand{\pdecode}{p_{\rm{decoder}}}
\newcommand{\precons}{p_{\rm{reconstruct}}}

\newcommand{\laplace}{\mathrm{Laplace}} 

\newcommand{\E}{\mathbb{E}}
\newcommand{\Ls}{\mathcal{L}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\emp}{\tilde{p}}
\newcommand{\lr}{\alpha}
\newcommand{\reg}{\lambda}
\newcommand{\rect}{\mathrm{rectifier}}
\newcommand{\softmax}{\mathrm{softmax}}
\newcommand{\sigmoid}{\sigma}
\newcommand{\softplus}{\zeta}
\newcommand{\KL}{D_{\mathrm{KL}}}
\newcommand{\Var}{\mathrm{Var}}
\newcommand{\standarderror}{\mathrm{SE}}
\newcommand{\Cov}{\mathrm{Cov}}
\newcommand{\normlzero}{L^0}
\newcommand{\normlone}{L^1}
\newcommand{\normltwo}{L^2}
\newcommand{\normlp}{L^p}
\newcommand{\normmax}{L^\infty}

\newcommand{\parents}{Pa} 

\DeclareMathOperator*{\argmax}{arg\,max}
\DeclareMathOperator*{\argmin}{arg\,min}

\DeclareMathOperator{\sign}{sign}
\DeclareMathOperator{\Tr}{Tr}
\let\ab\allowbreak

\newcommand{\Ymiss}{\mY_{\rm{miss}}}
\newcommand{\Yobs}{\mY_{\rm{obs}}}
\newcommand{\rYmiss}{\rmY_{\rm{miss}}}
\newcommand{\rYobs}{\rmY_{\rm{obs}}}
\def\vphi{{\bm{\phi}}}
\usepackage{amssymb}
 
\title{A Flexible Generative Framework for Graph-based Semi-supervised Learning}



\author{Jiaqi Ma\thanks{The two authors contribute equally to this paper.}  \thanks{School of Information, University of Michigan}\\
    \texttt{jiaqima@umich.edu} \\
    \And
    Weijing Tang\footnotemark[1]  \thanks{Department of Statistics, University of Michigan}\\
    \texttt{weijtang@umich.edu} \\
    \And
    Ji Zhu\footnotemark[3]\\
    \texttt{jizhu@umich.edu} \\
    \And
    Qiaozhu Mei\footnotemark[2]  \thanks{Department of EECS, University of Michigan}\\
    \texttt{qmei@umich.edu} \\
}

\begin{document}

\maketitle

\begin{abstract}
We consider a family of problems that are concerned about making predictions for the majority of unlabeled, graph-structured data samples based on a small proportion of labeled samples.  Relational information among the data samples, often encoded in the graph/network structure, is shown to be helpful for these semi-supervised learning tasks. However, conventional graph-based regularization methods and recent graph neural networks do not fully leverage the interrelations between the features, the graph, and the labels. In this work, we propose a flexible generative framework for graph-based semi-supervised learning, which approaches the joint distribution of the node features, labels, and the graph structure. Borrowing insights from random graph models in network science literature, this joint distribution can be instantiated using various distribution families. For the inference of missing labels, we exploit recent advances of scalable variational inference techniques to approximate the Bayesian posterior. We conduct thorough experiments on benchmark datasets for graph-based semi-supervised learning. Results show that the proposed methods outperform the state-of-the-art models in most settings. 

\end{abstract}

\section{Introduction}
\label{sec:intro}

Traditional machine learning methods typically treat data samples as independent and approximate a mapping function from the features to the outcome of each individual sample. However, many real-world data, such as social media or scientific articles, often come with richer relational information among the individual samples. We consider a family of such scenarios where the relational information is stored in a graph structure with the data samples as nodes, and the learning task is to predict the outcomes of unlabeled nodes based on the node features, the graph structure, as well as the labels of a subset of nodes. In these scenarios, breaking the independence assumption and utilizing such relational information in the prediction models have been shown to be helpful~\cite{zhu2003semi,zhou2004learning,belkin2006manifold,kipf2016semi,hamilton2017inductive,mei2008general,li2019prediction}. However, there lacks a principled way to best synergize and utilize the relational information stored in the graph together with the information stored in individual nodes. In this paper, we consider the problem of graph-based semi-supervised learning and try to approach this problem by presenting a flexible generative framework that explicitly models the joint relationship among the three key types of information in this context: features, outcomes (or labels), and the graph. 

There are two major classes of existing methods for graph-based semi-supervised learning. The first class includes the graph-based regularization methods~\cite{zhu2003semi,zhou2004learning,belkin2006manifold,mei2008general,li2019prediction}, where explicit regularizations are posed to smooth the predictions or feature representations over local neighborhoods. This class of methods share an assumption that some kind of smoothness (e.g., the outcomes of adjacent nodes are likely to be the same) should present in the local and global graph structure. The second class consists of graph neural networks~\cite{kipf2016semi,hamilton2017inductive,velivckovic2017graph}, where the node features within a local neighborhood are aggregated into a hidden representation for the ego node and predictions are made on top of the hidden representations. These existing methods either do not treat the graph as a random variable (but rather as a fixed observation) or do not jointly model the data features, graph, and outcomes.  

While having not been well-explored in graph-based semi-supervised learning, we believe that modeling the joint distribution of the data, graph, and labels with generative models has several unique advantages over the above methods. 

First, generative models can learn succinct underlying structures of the graph data. Rich literature in network science~\cite{newman2010networks} has shown that underlying structures often exist in real-world graph data. And there have been many probabilistic generative models~\cite{holland1983stochastic,hoff2002latent} that can learn the underlying structures well from observed graph data. Most of the existing graph-based semi-supervised learning methods described above view the graph as a fixed observation and treat it as ground truth. In reality, however, an observed graph is often noisy. We expect that through treating features, outcomes, and graph as random variables, a generative model can capture more general patterns among these entities and learn low-dimensional representations of the data that can take account for the noise in the graph.  

Second, modeling the joint distribution can extract more general relationship among features, outcomes, and the graph. We argue that both classes of the existing graph-based semi-supervised learning methods only utilize restricted relationships among them. The graph-based regularization methods usually make strong assumptions about smoothness over adjacent nodes. Such assumptions often restrict the model capacity, making the models fail to fully utilize the relational information. The graph neural networks, although more flexible in aggregating node features through the graph structure, usually implicitly assume conditional independence over the outcomes given node features and the graph. This might be sub-optimal in utilizing the relational information. Directly modeling the joint distribution with flexible models allows us to better utilize the relational information.

Moreover, generative models can better handle the missing-data situation. In real-world applications, we are often faced with imperfect data, where either node features or edges in the graph are missing. Generative models excel in such situations.

A few previous studies~\cite{zhang2018bayesian} trying to apply generative models to graph-based semi-supervised learning have been restricted to relatively simple model families due to the difficulty in efficient training of generative models. Thanks to recent advances of scalable variational inference techniques~\cite{kingma2013auto,kingma2014semi}, we are able to propose a flexible generative framework for graph-based semi-supervised learning. In this work, we use neural networks, latent space models~\cite{hoff2002latent}, and stochastic block models~\cite{holland1983stochastic} to form the generative models. And we use graph neural networks as the approximate posterior models in the scalable variational inference. We refer such instantiations of the proposed framework as GNN (Generative Graph models with Graph Neural Networks as approximate posterior). We evaluate the proposed framework with four variants of GNN on three semi-supervised classification benchmark datasets. Experiments show that our models achieve better performances than the state-of-the-art models under most settings. 

 \section{Related Work}
\label{sec:related}
This paper mainly focuses on the problem of graph-based semi-supervised learning, where the data samples are connected by a graph and the outcome labels are only available for part of the samples. The goal is to infer the unobserved labels based on both the labeled and unlabeled data as well as the graph structure.

\subsection{Graph-based Regularization for Semi-supervised Learning}
One of the most popular types of graph-based semi-supervised learning methods is the graph-based regularization methods. The general assumption of such methods is that the data samples are located in a low-dimensional manifold where each local neighborhood is a high-dimensional Euclidean space, and the graph stores the similarity or proximity of these data samples. Various graph regularizations are posed to smooth the outcome predictions of the model or the feature representations of the data samples over the local neighborhood in the graph. Suppose there are  data samples in total and  of them are labeled, the graph-based regularization methods generally conduct semi-supervised learning by optimizing the following objective function:

where  is the supervised loss function of sample ;  is a regularization function and  is a graph-based coefficient;  could be the outcome predictions~\cite{zhu2003semi,zhou2004learning,belkin2006manifold} or the feature representations~\cite{mei2008general,weston2012deep,li2019prediction} of nodes  and ;  is a hyper-parameter trading-off the supervised loss and the graph-based regularization. Different methods can have different variants of the regularization term. Most commonly, it is set as a graph Laplacian regularizer~\cite{zhu2003semi,zhou2004learning,belkin2006manifold,mei2008general,weston2012deep}. Such type of models heavily rely on the smoothness assumption over the graph, which restricts the modeling capacity~\cite{kipf2016semi}.  

\subsection{Graph Neural Networks for Semi-supervised Learning}
Another class of methods that have gained great attention recently are the graph neural networks~\cite{kipf2016semi,hamilton2017inductive,velivckovic2017graph}. A graph neural network aggregates the node features within a local neighborhood into a hidden representation for the central node. Such aggregation operations can also be stacked on top of the hidden representations to form deeper neural networks. Generally, a single aggregation operation for node  at depth  can be represented as follows,

where  is the hidden representation of  at  layer;  is the neighbor set of ;  is a learnable linear transformation matrix;  is an element-wise nonlinear activation function; and different models have different definitions of . For Graph Convolutional Networks~\cite{kipf2016semi},  or , where  is the number of neighbors of . For Graph Attention Networks~\cite{velivckovic2017graph},  is defined as an attention function between  and . Finally, the predictions of each node are made on top of hidden representations in the last layer. Such methods usually model the mapping from the features and the graph to the outcome of an individual node, which assume the outcomes are conditionally independent given the features and the graph. This assumption prevents the model from utilizing the joint relationship among the outcomes over the graph. Our framework models the joint distribution of the features, outcomes, and the graph, and it is not restricted to this assumption. A concurrent work~\cite{qu2019gmnn} also tries to mitigate this assumption. They take a statistical relational learning point of view and model the outcome dependency with a Markov network conditioned on the graph, while we take a generative model point of view and instantiate the joint distribution with random graph models.

\subsection{Generative Methods for Graph-based Semi-supervised Learning}

Most methods from the above two classes treat the graph as fixed observation and only a few methods~\cite{ng2018bayesian,zhang2018bayesian,liu2019statistical} treat the graph as a random variable and model it with generative models. Among them, \citet{ng2018bayesian} focused more on an active learning setting on graphs; \citet{zhang2018bayesian} modeled the graph along with a stochastic block model and did not consider the interaction between the graph and the features or the labels in the generative model of the graph; \citet{liu2019statistical} shares the most similar generative model with our framework, but considers a supervised learning setting where the labels are fully observed. To our best knowledge, our work is the first to propose a generative framework for graph-based semi-supervised learning that models the joint distribution of features, outcomes, and the graph with flexible nonlinear models. 

Finally, as a side note, there is a recently active area of deep generative models for graphs~\cite{kipf2016variational,de2018molgan}. But these models focus more on generating realistic graph topology structures and are less related to the graph-based semi-supervised learning, which is the problem of interest in this work.

 \section{Approach}
\label{sec:approach}

\subsection{Problem Setup}
We start by formally introducing the problem of graph-based semi-supervised learning. Given a set of data samples ,  and  are the feature and outcome vectors of sample  respectively. We further denote  and  as the matrices formed by feature and outcome vectors. The dataset also comes with a graph  with the data samples as nodes, where  is the set of nodes and  is the set of edges. In the semi-supervised learning setting, only  samples have observed their outcome labels and the outcome labels of other samples are missing. Without loss of generality, we assume the outcomes of the samples  are observed and that of  are missing. Therefore we can partition the outcome matrix as 


The goal of graph-based semi-supervised learning is to infer  based on . For discriminative methods, we are learning the conditional distribution of . This is usually done by learning a prediction model  using empirical risk minimization, optionally with regularizations:

where  is a loss function,  is a graph-based regularization term, and  is a hyper-parameter controlling the strength of the regularization. Then  is used to predict .

There are two specific learning settings, namely transductive learning and inductive learning, which are common in graph-based semi-supervised learning. Transductive learning assumes that  and  are fully observed during both the learning stage and the inference stage while inductive learning assumes  and the nodes of  in  are missing during the learning stage but available during the inference stage. In the following of this paper, we will mainly focus on the transductive learning setting but our method can also be extended to the inductive learning setting.

\subsection{A Flexible Generative Framework for Graph-based Semi-supervised Learning}

In discriminative methods, the graph  is usually viewed as a fixed observation. In reality, however, there is usually considerable noise in the graph. Moreover, we want to take advantage of the underlying structure among , , and  to improve the prediction performance under this semi-supervised learning setting. In this work, we propose a flexible generative framework that can model a wide range of the forms of the joint distribution , where , , and  are the random variables corresponding to , , and . We also denote  and  as the random variable counterparts of  and . 

\vpara{Generation process.} Inspired by the random graph models from the area of network science~\cite{newman2010networks}, we assume the graph is generated based on the node features and outcomes. The generation process can be illustrated by the following factorization of the joint distribution:
	
where the conditional probabilities  and  will be modeled by some flexible parametric families distributions  and  with parameters . By "flexible" we mean that the only restriction on the PMFs of these conditional probabilities is that they need to be differentiable almost everywhere w.r.t. ; and we do not assume the integral of the marginal distribution  is tractable. For simplicity, we do not specify the distribution  and everything will be conditioned on  later in this paper.

\vpara{Model inference.} To infer the missing outcomes , we would need the posterior distribution , which is usually intractable under many flexible generative models. Following the recent advances in scalable variational inference~\cite{kingma2013auto,kingma2014semi}, we introduce a recognition model  parameterized by  to approximate the true posterior . 

\vpara{Model learning.} We train the model parameters  and  by optimizing the Evidence Lower BOund (ELBO) of the observed data  conditioned on . The negative ELBO loss  is defined as follows,

And the optimal model parameters are obtained by minimizing the above loss:


\subsection{GNN Instantiations}

For practical use, it remains to specify the parametric forms of the generative model  and , and the approximate posterior model . In this section, we instantiate the Generative Graph model with two types of random graph models, and adopt two types of Graph Neural Networks as the approximate posterior model, which leads to four variants of GNN. As proof of the effectiveness of our general framework, we intend to instantiate its components with simple models and leave room for optimizing its performance with more complex instantiations. The generative framework proposed above does not restrict the type of outcomes. As proof of concept, we focus on multi-class classification outcomes in the following of the paper and denote the number of classes as .  

\subsubsection{Instantiations of the Generative Model}

For  in the generative model, we simply instantiate it with a multi-layer perceptron. For  in the generative model, we have come up with two instantiations inspired by the generative network models from network science literature. There are two major classes of generative models for complex networks: the latent space models (LSM)~\cite{hoff2002latent} and the stochastic block models (SBM)~\cite{holland1983stochastic}. We instantiate a simple model from each class as our generative models. 

A general assumption used by both classes of generative models for networks is that the edges are conditionally independent. Let  be the binary edge random variable between node  and .  indicates the edge between  and  exists and  otherwise. Based on the conditional independence assumption of edges, the conditional probability of the graph  can be factorized as

Next we will specify the instantiations of .

\vpara{Instantiation with an LSM.} The latent space model assumes that the nodes lie in a latent space and the probability of  only depends the representation of nodes  and . i.e., . We assume it follows a logistic regression model:

where  is the sigmoid function;  are the learnable parameters of the logistic regression model;  is a linear transformation matrix with learnable parameters (e.g., word embedding when  is a bag-of-words feature); the class labels  are represented as one-hot vectors, and we concatenate the transformed features and the class labels of a pair of nodes as input of the logistic regression model. All the learnable parameters are included in .

\vpara{Instantiation with an SBM.} The stochastic block model assumes there are  types of nodes and each node  has a (latent) type variable  and the probability of edge  only depends on node types  and . In a general SBM, we have , and the  for all  form a probability matrix  and are free parameters to be fitted. 

In our model, we assume the node types are the class labels, i.e.,  and  being the corresponding class of , and . Note that in our notation  is a one-hot vector. We specify  with the simplest SBM, which is also called the planted partition model. That is,

This means the probability matrix  has all the diagonal elements equal to a constant  and all the off-diagonal elements equal to another constant .

\subsubsection{Instantiations of the Approximate Posterior Model}

For the approximate posterior model , in principle we need a strong function approximator that takes  as the input and outputs the probability of . Here we consider two recently invented graph neural networks: the Graph Convolutional Network (GCN)~\cite{kipf2016semi} and the Graph Attention Network (GAT)~\cite{velivckovic2017graph}. Note that by doing this we are making a further approximation from  to , as the graph neural networks by design only take  as the input. This approximation is known as the mean-field method, which is commonly used in variational inference~\cite{blei2017variational}. 

\subsection{Training}
Finally, we end this section by introducing two practical details of model training.

\vpara{Supervised loss.}
As our main task is to conduct classification with the approximate posterior model, similar with \citet{kingma2014semi}, we add an additional supervised loss to better train the approximate posterior model:

The total loss is controlled by a weight hyper-parameter , 


We could rewrite the total loss in an alternative way as follows,

which provides a connection between the proposed generative framework and existing graph neural networks. The fourth term  provides supervised information from labeled data for the approximate posterior GCN or GAT, while the other three terms can be viewed as additional regularizations: the learned GCN or GAT is encouraged to support the generative model of the graph, and not to go far away from .

\vpara{Negative edge sampling.}
For both LSM and SBM based models, the probability  factorizes to the production of probabilities of all possible edges. Calculating the log-likelihood of it requires enumeration of all possible  pairs where , which results in a  computational cost at each epoch. In practice, instead of going through all  pairs, we only calculate the probabilities of the edges observed in the graph and a set of "negative edges" randomly sampled from the  pairs where edges do not exist. This practical trick, named negative sampling, is commonly used in the training of word embeddings~\cite{mikolov2013efficient} and graph embeddings~\cite{tang2015line}. 
 \section{Experiments}
\label{sec:exp}

In this section, we evaluate the proposed variants of GNN on several benchmark datasets for graph-based semi-supervised learning. We test the models under both the standard benchmark setting \cite{yang2016revisiting} as well as two data-scarce settings.  

\subsection{Standard Benchmark Setting}

We first consider a standard benchmark setting in recent graph-based semi-supervised learning literature~\cite{yang2016revisiting,kipf2016semi,velivckovic2017graph}. 

\begin{table}[tb]
\centering
\caption{Summary of benchmark datasets.}
\label{tbl:dataset}
\begin{tabular}{ccccc}
\toprule
Dataset & \# Classes & \# Nodes & \# Edges & Avg. 2-Neighborhood Size\\
\midrule
Cora & 7& 2,708& 5,278& 35.8\\
Pubmed & 3& 19,717& 44,324& 59.1\\
Citeseer & 6& 3,327& 4,552& 14.1\\
\bottomrule
\end{tabular}

\end{table}

\vpara{Datasets.}
We use three standard semi-supervised learning benchmark datasets for graph neural networks, Citeseer, Cora, and Pubmed~\cite{sen2008collective,yang2016revisiting}. The graph  of each dataset is a citation network with documents as nodes and citations as edges. The feature vector of each node is a bag-of-words representation of the document and the class label represents the research area this document belongs to. We adopt these datasets from the PyTorch-Geometric library~\cite{fey2019fast} in our experiments\footnote{The datasets loaded by the PyTorch-Geometric data loader have slightly less edges than those reported in \citet{yang2016revisiting}, which is believed due to the existence of duplicate edges in the original datasets.}. For each dataset, we summarize number of classes, number of nodes, number of edges, and average number of nodes within the 2-hop neighborhood of each node in Table~\ref{tbl:dataset}. In this standard benchmark setting, we closely follow the dataset setup in \citet{yang2016revisiting} and \citet{kipf2016semi}. 

\vpara{Models for comparison.}
For the proposed framework, we implement four variants () of GNN by combining the two generative model instantiations with the two approximate posterior model instantiations: LSM-GCN, SBM-GCN, LSM-GAT, SBM-GAT.

For baselines, we compare against two state-of-the-art models for the graph-based semi-supervised learning, GCN~\cite{kipf2016semi} and GAT~\cite{velivckovic2017graph}. We also include a multi-layer perceptron (MLP), which is a fully connected neural network without using any graph information, as a reference. 

We use the original architectures of GCN and GAT models in both the baselines and the proposed methods. We grid search the number of hidden units from  and the learning rate from . GAT uses a multi-head attention mechanism. In our experiments, we fix the number of heads as 8 and try to set the total number of hidden units as  and to set the number of hidden units of a single head as . In the proposed methods, we set the generative model for  as a two-layer MLP having the same number of hidden units as the corresponding GCN or GAT in the posterior model. For the MLP baseline, we also set the number of layers as 2 and grid search the number of hidden units and learning rate like other models. For the proposed generative models, we grid search the coefficient of the supervised loss  from . The number of negative edges is set to be the number of the observed edges in the graph. For LSM models, the dimensions of the feature transformation matrix  is fixed to , where  is the feature size. For SBM models, we use two settings of :  and . We use Adam optimizer to train all the models and apply early stopping with the cross-entropy loss on the validation set. We adopt the implementations of GCN and GAT from the PyTorch-Geometric~\cite{fey2019fast} library in all our experiments.

\begin{table}[tb]
\centering
\caption{Classification accuracy under the standard benchmark setting. The upper block lists the discriminative baselines. The lower block lists the proposed variants of GNN. The \textbf{bold} marker denotes the best performance on each dataset. The \underline{underline} marker denotes that the generative model outperforms its discriminative counterpart, e.g., LSM-GCN outperforms GCN; and the asterisk~(*) marker denotes the difference is statistically significant by a t-test at significance level 0.05. The ()~error bar denotes the standard deviation of the test performance of 10 independent trials.}
\label{tbl:standard}
\begin{tabular}{clll}
\toprule
{} &                                            Cora &                              Pubmed &                                        Citeseer \\
\midrule
MLP     &                       0.583  \small{0.009} &           0.734  \small{0.002} &                       0.569  \small{0.008} \\
GCN     &                       0.815  \small{0.002} &  \textbf{0.794}  \small{0.004} &                       0.718  \small{0.003} \\
GAT     &                       0.825  \small{0.005} &           0.785  \small{0.004} &                       0.715  \small{0.007} \\
\hline
LSM\_GCN &           \underline{0.825}  \small{0.002}* &           0.779  \small{0.004} &           \underline{0.744}  \small{0.003}* \\
LSM\_GAT &  \underline{\textbf{0.829}}  \small{0.003} &           0.776  \small{0.007} &           \underline{0.731}  \small{0.005}* \\
SBM\_GCN &           \underline{0.822}  \small{0.002}* &           0.784  \small{0.006} &  \underline{\textbf{0.745}}  \small{0.004}* \\
SBM\_GAT &           \underline{0.829}  \small{0.003} &           0.774  \small{0.004} &           \underline{0.740}  \small{0.003}* \\
\bottomrule
\end{tabular}

\end{table}

\vpara{Results.}
The performance of the baselines and proposed models under the standard benchmark setting is summarized in Table~\ref{tbl:standard}. We report the mean and the standard deviation of the test accuracy of 10 independent trials for each model. The results show that on all datasets except for Pubmed, the proposed methods achieve the best test accuracy on the standard benchmark setting. Notably, every instantiation model of the proposed generative framework outperforms their corresponding discriminative baseline (GCN or GAT) in most cases. We also note that GCN performs better than GAT and the proposed models on Pubmed. We conjecture that, when the number of classes is small and the graph is relatively dense, GCN may be already quite capable of propagating feature information from neighbors (see the average size of 2-hop neighborhoods in Table~\ref{tbl:dataset}). When there are more classes or the graph is relatively sparse (e.g., Cora, Citeseer, and the missing-edge setting of Pubmed in Section~\ref{sec:me}), the advantage of our proposed method is more evident.



\subsection{Data-Scarce Settings}
Generative models usually have better sample efficiency than discriminative models. Therefore, we expect the proposed generative framework to show bigger advantage when data are scarce. Next, we evaluate the models on the citation datasets under two such settings: missing-edge setting and reduced-label setting. 

\begin{table}[tb]
\centering
\caption{Classification accuracy under the missing-edge setting. The \textbf{bold} marker, the \underline{underline} marker, the asterisk~(*) marker, and the ()~error bar share the same definitions in Table~\ref{tbl:standard}.}
\label{tbl:missing}
\begin{tabular}{clll}
\toprule
{} &                                            Cora &                                          Pubmed &                                        Citeseer \\
\midrule
MLP     &                       0.583  \small{0.009} &                       0.734  \small{0.002} &                       0.569  \small{0.008} \\
GCN     &                       0.665  \small{0.007} &                       0.746  \small{0.004} &                       0.652  \small{0.005} \\
GAT     &                       0.682  \small{0.004} &                       0.744  \small{0.006} &                       0.642  \small{0.004} \\
\hline
LSM\_GCN &           \underline{0.711}  \small{0.005}* &  \underline{\textbf{0.766}}  \small{0.006}* &           \underline{0.704}  \small{0.002}* \\
LSM\_GAT &           \underline{0.710}  \small{0.007}* &           \underline{0.766}  \small{0.004}* &           \underline{0.691}  \small{0.005}* \\
SBM\_GCN &  \underline{\textbf{0.718}}  \small{0.004}* &           \underline{0.762}  \small{0.005}* &  \underline{\textbf{0.716}}  \small{0.004}* \\
SBM\_GAT &           \underline{0.716}  \small{0.007}* &           \underline{0.761}  \small{0.005}* &           \underline{0.709}  \small{0.008}* \\
\bottomrule
\end{tabular}

\end{table}

\subsubsection{Missing-Edge Setting}
\label{sec:me}

In the standard benchmark setting, we assume that all samples are connected to the graph identically and the training, validation, and test set are split randomly in the datasets. In practice, however, the samples we are interested in the test period may not be well connected to the graph. For example, we may not have connection for new users in a social network other than their profile information. In this cold-start situation, one may expect to make predictions purely based on the profile information. However, we believe that the relational information stored in the graph of the training data can still help us learn a better and more generalizable model even if some of the predictions are made only based on the node features. And we expect the proposed generative models to work better than the discriminative baselines in this case because they can better distill the relationship among the data. 

To mimic such situations, we create a missing-edge setting, where we remove all the edges of the test nodes from the graph. Note that this setting is different from the inductive learning setting in previous works \cite{hamilton2017inductive,velivckovic2017graph} where the edges for the test data are absent during the training stage but present during the test stage. In the missing-edge setting, the edges for the test data are absent during both stages. We follow the same experimental setup as in the standard benchmark setting except for the modification of the graph. 



\vpara{Results.}
The performance under the missing-edge setting is shown in Table~\ref{tbl:missing}. Not surprisingly, as we lose part of the graph information, the performances of all models except for MLP (which does not use the graph at all) drop compared to the standard benchmark setting in Table~\ref{tbl:standard}. However, the proposed generative models perform better than their corresponding discriminative baselines by a large margin. Remarkably, even without knowing any edges of out-of-sample nodes, the accuracy of SBM-GCN on Citeseer can achieve the state-of-the-art level of GCN under the standard benchmark setting.

\subsubsection{Reduced-Label Setting}
Another common data-scarce situation is the lack of labeled data. Therefore, we create a reduced-label setting, where we drop half of the training labels for each class compared to the standard benchmark setting. All other experiment and model setups are the same as the standard benchmark setting.

\vpara{Results.}
The performance under the reduced-label setting is shown in Table~\ref{tbl:reduced}. As can be seen from the results, the proposed generative models achieve the best test accuracy on Cora and Citeseer again. And the gap of the performances between the proposed generative models and the corresponding discriminative models are larger on Cora and Citeseer. 

\begin{table}[tb]
\centering
\caption{Classification accuracy under the reduced-label setting. The \textbf{bold} marker, the \underline{underline} marker, the asterisk~(*) marker, and the ()~error bar share the same definitions in Table~\ref{tbl:standard}.}
\label{tbl:reduced}
\begin{tabular}{clll}
\toprule
{} &                                            Cora &                              Pubmed &                                        Citeseer \\
\midrule
MLP     &                       0.498  \small{0.004} &           0.674  \small{0.005} &                       0.493  \small{0.010} \\
GCN     &                       0.750  \small{0.003} &  \textbf{0.724}  \small{0.005} &                       0.666  \small{0.003} \\
GAT     &                       0.771  \small{0.004} &           0.711  \small{0.006} &                       0.675  \small{0.005} \\
\hline
LSM\_GCN &           \underline{0.777}  \small{0.002}* &           0.709  \small{0.003} &           \underline{0.691}  \small{0.005}* \\
LSM\_GAT &           \underline{0.792}  \small{0.004}* &           0.699  \small{0.003} &           \underline{0.691}  \small{0.004}* \\
SBM\_GCN &           \underline{0.780}  \small{0.002}* &           0.710  \small{0.004} &  \underline{\textbf{0.703}}  \small{0.006}* \\
SBM\_GAT &  \underline{\textbf{0.796}}  \small{0.008}* &           0.699  \small{0.003} &           \underline{0.698}  \small{0.003}* \\
\bottomrule
\end{tabular}
\end{table}

 \section{Conclusion}
\label{sec:conclusion}

In this paper, we have presented a flexible generative framework for graph-based semi-supervised learning. By applying scalable variational inference, this framework is able to take the advantages of both recently developed graph neural networks and the wisdom of random graph models from classical network science literature, which leads to the GNN model. We further implement 4 variants of GNN, instantiations of the proposed framework where we build generative graph models with graph neural networks as the approximate posterior models. Through thorough experiments, We demonstrated that these instantiation models outperform the state-of-the-art graph-based semi-supervised learning methods on most benchmark datasets under the standard benchmark setting. We also showed that the proposed generative framework has great potential in data-scarce situations. 

For future work, we expect more complex instantiations of generative models to be developed using this framework and to optimize the graph-based semi-supervised learning. 
\subsubsection*{Acknowledgments}
This work was in part supported by the National Science Foundation under grant numbers 1633370 and 1620319.

\bibliography{reference}
\bibliographystyle{apalike}

\end{document}
