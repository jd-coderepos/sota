\documentclass{article}

\usepackage{graphicx}
\usepackage{appendix}
\usepackage{amssymb}
\usepackage{dsfont}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{cancel}
\usepackage{verbatim}
\usepackage{chngpage}
\usepackage{fullpage}

\usepackage[english]{babel}

\usepackage{url}

\makeatletter
\newif\if@restonecol
\makeatother
\let\algorithm\relax
\let\endalgorithm\relax

\usepackage[boxruled]{algorithm2e}

\newtheorem{thm}{Theorem}
\newtheorem{obsv}[thm]{Observation}
\newtheorem{cor}[thm]{Corollary}
\newtheorem{lem}[thm]{Lemma}
\newtheorem{conj}[thm]{Conjecture}
\newtheorem{hypo}[thm]{Hypothesis}
\newtheorem{assum}[thm]{Assumption}
\newtheorem{prop}[thm]{Proposition}
\newtheorem{defn}[thm]{Definition}
\newtheorem{exmp}[thm]{Example}
\newtheorem{rem}[thm]{Remark}




\begin{document}

\title{Feasibility of Motion Planning\\ on Acyclic and Strongly Connected Directed Graphs}
\author{Zhilin Wu and St\'{e}phane Grumbach \\
INRIA-LIAMA\thanks{CASIA -- PO Box 2728 --
Beijing 100080 -- PR China -- Stephane.Grumbach@inria.fr  zlwu@liama.ia.ac.cn}\\
Chinese Academy of Sciences}

\maketitle


\begin{abstract}
Motion planning is a fundamental problem of robotics with
applications in many areas of computer science and beyond. Its
restriction to graphs has been investigated in the literature for it
allows to concentrate on the combinatorial problem abstracting from
geometric considerations.  In this paper, we consider motion
planning over directed graphs, which are of interest for asymmetric
communication networks. Directed graphs generalize undirected
graphs, while introducing a new source of complexity to the motion
planning problem: moves are not reversible. We first consider the
class of acyclic directed graphs and show that the feasibility can
be solved in time linear in the product of the number of vertices
and the number of arcs. We then turn to strongly connected directed
graphs. We first prove a structural theorem for decomposing strongly
connected directed graphs into strongly biconnected components.
Based on the structural decomposition, we give an algorithm for the
feasibility of motion planning on strongly connected directed
graphs, and show that it can also be decided in time linear in the
product of the number of vertices and the number of arcs.
\end{abstract}


\section{Introduction}


Motion planning is a fundamental problem of robotics. It has been
extensively studied \cite{Lavalle06}, and has numerous practical
applications beyond robotics, such as in manufacturing, animation,
games \cite{MPG} as well as in computational biology
\cite{SA01,FK99}. The complexity of motion planning, which is
intrinsically PSPACE-hard \cite{Latombe95,Lavalle06}, has received a
lot of attention. The study of motion planning on graphs was
proposed by Papadimitriou et al. \cite{PapadimitriouRST94} to strip
away the geometric considerations of the general motion planning
problem and concentrate on the combinatorial problem.

In this paper, we consider the feasibility of motion planning over
directed graphs. Our results generalize results on undirected
graphs, which can be shown as a subclass of directed graphs.
Directed graphs are of great importance in several fields such as
communication networks which are frequently asymmetric
\cite{JetchevaJ06}. But technically, directed graphs differ from
undirected graphs, for movements in the graph are not reversible.

Papadimitriou et al. \cite{PapadimitriouRST94} first introduced the
problem of motion planning on graphs. They defined the Graph Motion
Planning with 1 Robot problem (GMP1R) as follows: Suppose we are
given a graph  with  vertices, there is one robot in a
vertex  and some of the other vertices contain a movable
obstacle. The objective of GMP1R is to move the robot from the
source vertex  to a destination vertex  with the smallest
number of moves, where a move consists in moving a robot or an
obstacle from one vertex to an adjacent vertex that does not contain
an object (robot or obstacle). It may be impossible to move the
robot from  to , for instance, if all the vertices other than
 are occupied by obstacles. The feasibility problem of GMP1R is
to decide whether it is possible or not to move the robot from the
source vertex to the destination vertex.

In \cite{PapadimitriouRST94}, it was shown that the feasibility of
GMP1R can be decided in polynomial time, and the optimization of
GMP1R is NP-complete (even on planar graphs). They also gave a
 exact algorithm as well as a fast -approximation
algorithm for GMP1R on trees, a -approximation
algorithm for GMP1R on general graphs. Auletta et al. proposed more
efficient algorithms for the feasibility and optimization of GMP1R
on trees in \cite{AulettaMPP96,AulettaP01}.


Motion planning on graphs has wide practical applications. Track
transportation system \cite{Per88} constitutes a typical example:
Vehicles move on a system of tracks such that each track connects
two distinct stations. There is a distinguished vehicle which moves
from a source station to a destination station. There are other
vehicles (obstacles) on the non-source stations. The vehicles are
only able to stop at the stations and not able to stop in the middle
of tracks. They coordinate with each other to let the distinguished
vehicle move from the source station to the destination station.
Variant of the previous example is packet transfer in communication
buffers. Graphs are regarded as (bidirectional) communication
networks and objects as indivisible packets of data. If there is a
distinguished packet which moves from a source node to a destination
node, and there are already some other packets stored in the
communication buffers of nodes in the network, the objective is to
move the distinguished packet from the source node to the
destination node without exceeding the capacities of the
communication buffers of each node.









In practice, in the two previous examples, the tracks (links)
between the stations (nodes) might be asymmetric. This motivates the
study of motion planning on directed versus undirected graphs.

Let us consider first the track transportation system. Some of the
tracks may be unidirectional. For instance, if the two stations are
not in the same altitude, the track connecting them might be too
steep, and the vehicles not strong enough to climb up the track.
There may also be unidirectional tracks as a result of security
considerations. The vehicle movement from a source station to a
destination station, on a track-transportation system containing
unidirectional tracks, leads to motion planning on directed graphs.

Now consider the packet transfer in communication networks. There
might be unidirectional links in communication networks. For
instance, in wireless ad hoc networks, unidirectional links can
result from factors such as heterogeneity of receiver and
transmitter hardware, power control algorithms, or topology control
algorithms. Unidirectional links may also result from interferences
around a node that prevents it from receiving packets even though
the other nodes are able to receive packets from it
\cite{MD02,JetchevaJ06}. Networks with unidirectional links can be
modeled as directed graphs. The problem of transferring a
distinguished packet in networks with unidirectional links without
exceeding the capacities of the communication buffers amounts to
solving motion planning on directed graphs.

Directed graphs generalize undirected graphs, while introducing a
new source of complexity to the motion planning problem: moves are
not reversible, and motion planning might become infeasible after
inappropriate moves.

In this paper, we first give a motivating example to illustrate that
motion planning on directed graphs is much more intricate than
motion planning on graphs. Then, we consider the class of acyclic
directed graphs, we give an algorithm to decide the feasibility on
such class of directed graphs, prove its correctness, and analyze
its complexity. We show that the feasibility of motion planning on
acyclic directed graphs can be decided in time linear in the product
of the number of vertices and the number of arcs
(Theorem~\ref{thm:acyclic-complexity}). We then turn to strongly
connected directed graphs. We first consider their structure and
introduce a new class of directed graphs, strongly biconnected
directed graphs. We obtain an interesting characterization of
strongly biconnected directed graphs by showing that a directed
graph is strongly biconnected iff it has an open ear decomposition
(Theorem~\ref{thm:bi-strong}). This characterization can be seen as
a generalization of the classical open-ear-decomposition
characterization of biconnected graphs. We then prove a structural
theorem for decomposing strongly connected directed graphs into
strongly biconnected components (Theorem~\ref{thm:strong2}). Based
on the open-ear-decomposition characterization, we show that motion
planning on strongly biconnected directed graphs is feasible iff
there is at least one vertex occupied neither by robot nor by
obstacle (Theorem~\ref{thm:feas-bi-strong}). Based on the structural
decomposition, we give an algorithm for the feasibility of motion
planning on strongly connected directed graphs, prove its
correctness, and analyze its complexity. We show that the
feasibility of motion planning on strongly connected directed graphs
can also be decided in time linear in the product of the number of
vertices and the number of arcs
(Theorem~\ref{thm:strong-complexity}).

The paper is organized as follows. A motivating example is presented
in the next section. In Section~\ref{sec:prelim}, we recall
classical definitions from graph theory. We consider acyclic
directed graphs in Section~\ref{sec:acyclic}, and give an algorithm
to decide the feasibility of motion planning on such class of
directed graphs. In Section~\ref{sec:strong-structure}, we consider
strongly biconnected directed graphs, and prove a structural theorem
on their decomposition into strongly biconnected components. The
feasibility for strongly connected directed graphs is considered in
Section~\ref{sec:strong-algo}.

\section{A motivating example}
In the sequel, for brevity, we use ``digraph'' to denote ``directed
graph''.

Let us consider a simple example to illustrate the motion planning
on digraphs. Vertices can contain either an object (obstacle or the
robot) or nothing. If there is no object on a vertex, we say that
there is a \emph{hole} in that vertex. For an arc  from 
to , with an object on , and a hole on , the object can be
moved from  to , and we say equivalently that the hole can be
moved (backwards) from  to .

\begin{figure}[ht]
\centering
\includegraphics[width=0.7\textwidth]{figures//example-1.jpg}
\caption{Motion planning on digraphs}\label{fig:example-1}
\end{figure}


Consider the strongly connected component   in the graph of
Figure~\ref{fig:example-1} which contains vertices ,
 and . The initial positions of the robot and obstacles are
shown in Figure~\ref{fig:example-1}(a).

We can move the robot from  to  as follows: move the hole in
 to , move the robot from  to , then move the two
holes in ,  into  through , without moving the
robot in  (Figure~\ref{fig:example-1}(b)). Now move the
obstacle in  to , and move the robot to  (see
Figure~\ref{fig:example-1}(c)). Move the two obstacles in  and
 to  and  (Figure~\ref{fig:example-1}(d)), then move the
robot from  to , and finally to . The main idea of
these moves is to move the robot to  in order to free the way
for the moves of the holes from  and   to  and .

If the robot is in  and we move the hole in  to 
(Figure~\ref{fig:example-2}(a)), then the problem becomes
infeasible. We can move the robot from  to  and the hole in
 to  (Figure~\ref{fig:example-2}(b)), but it is then
impossible to move the robot from  to .

\begin{figure}[ht]
\centering
\includegraphics[width=0.7\textwidth]{figures//example-2.jpg}
\caption{Object moves that do not preserve feasibility}\label{fig:example-2}
\end{figure}

As illustrated in the above example, the intricacy of motion
planning on digraphs follows from the non-reversibility of moves in
the digraphs.

In the sequel, we propose algorithms which take as input, a digraph
 encoded by its adjacency lists, a source and destination
vertex , a function  mapping each vertex to an element
of the set \{``robot'',``obstacle'', ``hole''\}, and produces a
Boolean value (true or false) indicating whether it is feasible to
move the robot from  to  in .

\section{Preliminaries}\label{sec:prelim}


A \emph{digraph}  is a binary tuple  such that . Elements of  and  are called respectively
\emph{vertices} and \emph{arcs} of . We assume that  for all  (there are no self-loops).

For a vertex  of a digraph , the \emph{indegree} of ,
denoted , is defined as , and the \emph{outdegree} of , denoted , is
defined as .

A \emph{graph}  is a binary tuple  such that , where  contains exactly all two-element subsets
of , namely . Elements
of  are called \emph{edges} of .

For a vertex  of a graph , the \emph{degree} of ,
denoted , is defined as .

If  (resp. ), and  (resp.
), then  is said to be \emph{incident} to 
and  in  (resp. ).

A digraph (resp. graph) containing exactly one vertex is said to be
\emph{trivial}, otherwise it is said to be \emph{nontrivial}.


Given a digraph  (resp. graph ), the digraph
(resp. graph)  such that  and  is called a \emph{sub-digraph} of  (resp.
\emph{subgraph} of ). Let , the sub-digraph (resp.
subgraph) \emph{induced by} , denoted  (resp. ), is
the sub-digraph (resp. subgraph)  (resp. ).



Suppose  (resp. ) is a digraph (resp. graph) and
, let  (resp. ) denote the digraph (resp.
graph) obtained from  (resp. ) by deleting all the vertices in
 and all the arcs (resp. edges) incident to at least one element
of . If , then  (resp. ) is written as
 (resp. ) for simplicity.

Given a digraph , the \emph{underlying graph} of ,
denoted by , is the graph obtained from  by
omitting the directions of arcs, namely .

A \emph{path} of a digraph  (resp. graph ) is an
alternating sequence of vertices and arcs (resp. edges)
 () such that for all ,  (resp. ), and for all , .  and 
are called the \emph{tail} and \emph{head endpoint} of the path
respectively, and the other vertices are called the \emph{internal
vertices} of the path. In particular, an arc or an edge is a path
without internal vertices.

A \emph{cycle} of a digraph  is a sequence of vertices
 such that for all ,  ( interpreted as ), and for all , . Cycles of graphs can be defined similarly,
but we have the additional restriction that . So cycles of
graphs contain at least three vertices.

A digraph  is \emph{acyclic} if there are no cycles in .

Suppose  is a sub-digraph of  (resp. subgraph
of ). A path  of  (resp. ) is an \emph{-path}
if the two endpoints of  are in , no internal vertices of 
are in , and no arcs (resp. edges) of  are in . In
particular, an arc  (resp. an edge
) with  is an -path. A
cycle  is an \emph{-cycle} if there is exactly one vertex of
 in .

Let  and  be two sub-digraphs of a
digraph , then the \emph{union} of  and , , is defined as .
The union of subgraphs can be defined similarly.

A digraph  is \emph{strongly connected} if for any two
distinct vertices  and , there are both a path from  to 
and a path from  to  in . The digraph containing exactly
one vertex and no arcs is the minimal strongly connected digraph.

Let  be a digraph. The \emph{strongly connected components}
of  are the maximal strongly connected sub-digraphs of .

A graph  is \emph{connected} if for any two distinct
vertices  and  of , there is a path of  with endpoint
 and . The \emph{connected components} of a graph  are the
maximal connected subgraphs of .



If  is a graph, , and the number of connected
components of  is more than that of , then  is said to be
a \emph{cut vertex} of .

A graph  is \emph{biconnected} if  is connected and there are
no cut vertices in . In particular, the graph containing exactly
one vertex is the minimal biconnected graph. The \emph{biconnected
components} of a graph  are the maximal biconnected subgraphs of
.

\medskip \noindent Without loss of generality, we assume
that for each digraph , (i) the underlying graph of ,
, is connected, (ii) the source vertex  and the
destination vertex  are distinct (thus all the digraphs
considered from now on are nontrivial), (iii) there is at least one
path from  to  in .





\section{Motion planning on acyclic digraphs}\label{sec:acyclic}
In this section we assume that  is an acyclic digraph.

We first recall a result about acyclic orderings of acyclic
digraphs.

An \textit{acyclic ordering} of an acyclic digraph  is an
ordering of all vertices of , say , such that
 implies . From \cite{BangGutin00}, we know
that an acyclic ordering of a given acyclic digraph can be computed
in linear time by depth-first-search.

\begin{thm}[\cite{BangGutin00}]\label{thm:acyclic-ordering}
Given an acyclic digraph , an acyclic ordering of  can
be computed in time , where  is the number of vertices
and  is the number of arcs of .
\end{thm}

We introduce some notations in the following.

Let  denote the set of vertices from which there is a path
to , and to which there is a path from . In particular, .

For each , let  denote the number of holes
that can be moved to .

For each , define  as follows: Suppose that
the robot is in .
\begin{itemize}
\item If the robot can be moved from  to  in , then there
may be different paths (from  to ) along which the robot can
be moved from  to , let  be the minimal length (number
of arcs) of such paths.

\item If it is impossible to move the robot from  to , let
.
\end{itemize}

\medskip

The algorithm FAD() (see Algorithm 1 in the box below)
decides the feasibility of the motion planning problem on acyclic
digraphs. FAD first computes  for each , then
computes  for each , finally checks whether
.

\begin{algorithm}[ht]

\dontprintsemicolon \SetVline
\SetKwInOut{Input}{input}
\SetKwInOut{Output}{output}
\Input{ such that  is an acyclic digraph, , , and  is a function from  to \{``robot'',``obstacle'',``hole''\}.}
\Output{true or false.}
\tcc{Compute , the set of vertices reachable from  and
from which  is reachable.}
Let  be a FIFO queue, push  into .\;
\lForEach{} {\lIf{}{.
}\lElse{.}}\;
\While{ is nonempty}
{
the first element of , pop the first element of .\;
\ForEach{ such that }
{
\If{}
    {, push  into .}
}
}
Push  into .\;
\lForEach{}{\lIf{}{
}\lElse{}}\;
\While{ is nonempty}
{
the first element of , pop the first element of .\;
\ForEach{ such that }
{
\If{}
    {, push  into .}
}
}
.\;
\tcc{Compute }
\ForEach{}
{
\lForEach{}{}\;
\lIf{``hole''}{. }\lElse{.}\;
Push  into .\;
\While{ is nonempty}
{
 the first element of , pop the first element of .\;
\ForEach{ such that }
{
\If{}
{
, push  into .\;
\lIf{``hole''}{.}
}
}
}
}
\tcc{Compute }
Compute an acyclic ordering of , say ,
such that .\;
.\;
\For{ from  to }
{
\If{ such that
     and }
{
.\;
}
}
\lIf{}{\Return true. }\lElse{\Return false.}\;
\caption{FAD()\label{Alg:feas-acyclic}}
\end{algorithm}


\clearpage

The computation of  and  on an acyclic digraph is
illustrated in Figure~\ref{fig:acyclic-example}.

\begin{figure}[ht]
\centering
  \includegraphics[width=0.7\textwidth]{figures//acyclic-example.jpg}
  \caption{Computation of  and }\label{fig:acyclic-example}
\end{figure}



\begin{thm}
FAD is correct.
\end{thm}



\begin{proof}

We prove that given an instance of the motion planning problem on
acyclic digraphs, FAD returns true iff the problem is feasible.

\noindent ``If'' part:

If the problem is feasible, the robot can be moved from  to .
Let  be the trace of the robot during this movement (namely the
sequence of nodes and arcs reached by the robot). As a result of
acyclicity of ,  is a path of . Let  such that  and . During the movement,
when the robot is moved to (), in order to
move the robot from  to , a hole should be moved to
. Since  is acyclic, the hole moved to  cannot be
moved to  for any  such that  (holes are moved
along the reverse direction of arcs). So these holes are distinct
from each other, and can be moved to occupy all the vertices on 
except . By induction, we can show that for all vertices  on
,  computed by FAD satisfies that .
Consequently FAD returns true.

\noindent ``Only if'' part:

If FAD returns true, then . By induction, we can
show that there is a path  from  to  such that for each
vertex  on , we have  and , and for each arc  on , . By
induction again, we can show that the holes in  can be moved to
occupy all the vertices on  except . Then the robot can be
moved to  along , the problem is feasible.
\end{proof}

\begin{thm}\label{thm:acyclic-complexity}
The time complexity of FAD is , where  is the number of
vertices, and  is the number of arcs.
\end{thm}

\begin{proof}

Let  be an acyclic digraph,  and  be the number of vertices
and number of arcs of  respectively.

The computation of  takes  time since each arc is
visited at most once in each of the first two ``While'' loops.

The computation of 's takes  time because the
computation of each  takes  time and there are at most
 such computations.

The computation of an acyclic ordering of  takes
 time from Theorem~\ref{thm:acyclic-ordering}.

The computation of 's takes  time.

Since , we conclude that the time complexity of FAD is
.
\end{proof}


\section{Structure of strongly connected digraphs}\label{sec:strong-structure}

In this section, we consider the structure of strongly connected
digraphs. We first recall some definitions and theorems.

An \emph{open ear decomposition} of a digraph  (resp. graph
) is a sequence of sub-digraphs of  (resp. subgraphs of
), say , such that
\begin{itemize}

\item  is a cycle;

\item  is a -path (resp. -path), where  (resp. ) is  for all ;

\item  (resp. ).
\end{itemize}

A \emph{closed ear decomposition} of a digraph  (resp.
graph ) is a sequence of sub-digraphs of  (resp.
subgraphs of ), say , such that
\begin{itemize}

\item  is a cycle;

\item  is a -path or a -cycle (resp. a -path or a -cycle), where  (resp. ) is  for all ;

\item  (resp. ).
\end{itemize}

\begin{thm}[\cite{West00}]\label{thm:bi-connected}
Let  be a graph containing at least three vertices.  is
biconnected iff  has an open ear decomposition. Moreover, any
cycle can be the starting point of an open ear decomposition.
\end{thm}

\begin{thm}[\cite{BangGutin00}]\label{thm:strong}
Let  be a nontrivial digraph.  is strongly connected iff 
has a closed ear decomposition. Moreover, any cycle can be the
starting point of a closed ear decomposition.
\end{thm}

Let  be a graph. The \emph{biconnected-component graph} of
, denoted , is a bipartite graph
 defined by
\begin{itemize}
\item : biconnected components of ;

\item : vertices of  shared by
at least two distinct biconnected components of ;

\item : let  and , then 
iff .
\end{itemize}

\begin{thm}[\cite{West00}]\label{thm:biconn-components}
Let  be a connected graph. Then  is a
tree.
\end{thm}

\smallskip

\noindent Now we introduce a new class of digraphs, strongly
biconnected digraphs.

\begin{defn}
Let  be a digraph.  is said to be strongly biconnected if 
is strongly connected and  is biconnected. The
strongly biconnected components of  are the maximal strongly
biconnected sub-digraphs of .
\end{defn}
In particular, the digraph containing exactly one vertex and no arcs
is strongly biconnected.

\noindent We now show that strongly biconnected digraphs also admit
a similar characterization.

\begin{thm}\label{thm:bi-strong}
Let  be a nontrivial digraph.  is strongly biconnected iff 
has an open ear decomposition. Moreover, any cycle can be the
starting point of an open ear decomposition.
\end{thm}
\begin{proof}

\noindent \textbf{``If'' part}: Suppose  has an open ear
decomposition .

Since open ear decompositions are special cases of closed ear
decompositions, from Theorem~\ref{thm:strong}, we know that  is
strongly connected.

Let , the underlying graph of ,
for all .

If  is a cycle with at least  vertices, then
 is an open ear decomposition of
,  is biconnected according to
Theorem~\ref{thm:bi-connected}. So  is strongly biconnected.

If  is a cycle with only two vertices and , then
 is a graph with exactly two vertices connected by
an edge.  is biconnected and  is strongly
biconnected.

Otherwise,  is a cycle with only two vertices and . Then
it is easy to see that  is a cycle of
, so  is an open ear
decomposition of .  is biconnected
from Theorem~\ref{thm:bi-connected}.  is strongly biconnected.

\noindent \textbf{``Only if'' part}: Suppose  is nontrivial and
strongly biconnected. Consider the following procedure:

Initially select an arbitrary cycle in , let  be this cycle.

Suppose we have obtained .

Select a -path in  as .

Continue until .

The above procedure produces the desired open ear decomposition of
, which is guaranteed by the following claim.

\smallskip
\noindent \textbf{Claim}. If , there must be a
-path in .
\smallskip

\noindent \emph{Proof of the Claim}.

If , then there must be arcs in  but not in ,
which are the -paths in .

Otherwise,  is nonempty.

To the contrary, suppose that there are no -paths in .

For all , we call the path from some
vertex in  to  such that none of its internal vertices are
in , as the -path, and the path from  to some
vertex in  such that none of its internal vertices are in
, as the -path. Moreover, we call the endpoint of a
-path (resp.-path ) that is in  as the
-endpoint of the -path (resp. -path).

Because  is strongly connected, for all , there are -paths and -paths in . Let
 and  be the set of
-endpoints of -paths and -paths respectively.

For each , if  and ,
then we must have , because otherwise
we will have a -path in , contradicting to the assumption.
Therefore for each ,
, and 
is a singleton.

For all , let  be the set of
all  such that
.

Then all the nonempty 's ()
form a partition of  (see
Figure~\ref{fig:bi-strong}).

\begin{figure}[ht]
\centering
  \includegraphics[width=0.25\textwidth]{figures//bi-strong.jpg}
  \caption{Partition of }\label{fig:bi-strong}
\end{figure}

Select an arbitrary  such that 
is nonempty. We show that  is a cut vertex in
.

Let  be a vertex in , we show that all the arcs
incident to  are confined to ,
namely if  or , then .

To the contrary, suppose that there is an arc  (the case of
 is similar) such that , then either  and , or
 for some 
such that .

Since  is a singleton, the
former case is impossible.

For the latter case, we can get a -path in , contradicting
to the assumption.

Therefore, all the arcs incident to  are confined to
, as a consequence, all the paths
in  from  to vertices in  go
through ,  is a cut vertex in ,
contradicting to the fact that  is biconnected
(since  is strongly biconnected).

Consequently, when  is nonempty, there are
always -paths in .

We conclude that the claim holds and complete the proof of the
theorem.

\end{proof}



\noindent We can prove the following structural theorem for strongly
connected digraphs.

\begin{thm}\label{thm:strong2}
Let  be a strongly connected digraph. Then the strongly
biconnected components of  are those , namely the
sub-digraph of  induced by , where  is a biconnected
component of .
\end{thm}

\begin{proof}

Let  be a strongly connected digraph.

If  is trivial, then the result is obvious.

Otherwise,  is nontrivial, let  be a biconnected component of
.

It is sufficient to show that  is strongly connected. If
this holds, then  is strongly biconnected. Because all the
vertices of a strongly biconnected sub-digraph of  are in some
 biconnected component of  and  is a biconnected component of ,
 is a maximal strongly biconnected sub-digraph of , i.e.
a strongly biconnected component of . Since the union of all
biconnected components of  is 
itself, the theorem holds.

Now we show that  is strongly connected.

Let  such that . Since  is strongly
connected, there must be a path  from  to  in . Now we
show that  is in  as a matter of fact.

To the contrary, suppose that there is a vertex on  not in
.

Let  be the first vertex on  (starting from ) not in
. Then there is  on  such that
. Because  is a biconnected component
of , and two distinct biconnected components contain
at most one vertex in common according to
Theorem~\ref{thm:biconn-components}, it follows that  is
in a biconnected component  of ,
and  is the unique vertex shared by  and .
Since  is a path, we have that , otherwise we
have reached  before  on , a contradiction. Because
 and , we have that . Since  is the unique vertex
shared by  and , any path from  to  has to visit , so  must
visit  again after visiting , contradicting to
the fact that  is a path and there should be no vertices visited
twice on a path.

Consequently for any , , there is a path in
 from  to ,  is strongly connected.
\end{proof}


From Theorem~\ref{thm:strong2}, we have the following definition for
strongly-biconnected-component graph of a strongly connected
digraph.

\begin{defn}
Let  be a strongly connected digraph, the
strongly-biconnected-component graph of , denoted
, is
, namely the
biconnected-component graph of the underlying graph of .
\end{defn}

From the above definition and Theorem~\ref{thm:biconn-components},
we have the following corollary.
\begin{cor}\label{cor:G_bis}
Let  be a strongly connected digraph. Then 
is a tree.
\end{cor}

\begin{exmp}[Strongly-biconnected-component graph]
A strongly connected digraph 
(Figure~\ref{fig:strong-example}(a)) and its
strongly-biconnected-component graph 
(Figure~\ref{fig:strong-example}(b)).

\begin{figure}[ht]
\centering
  \includegraphics[width=0.75\textwidth]{figures//strong-example.jpg}
  \caption{Example: strongly-biconnected-component graph}\label{fig:strong-example}
\end{figure}
\end{exmp}



\section{Motion planning on strongly connected digraphs}\label{sec:strong-algo}

At first, we make the following observation about motion planning on
strongly connected digraphs.

\begin{prop}\label{prop:motion-strong-observ}
Let  be a strongly connected digraph. Then
\begin{enumerate}
\item If the robot and a hole are in the same cycle  of , then the robot can be moved to any vertex of .

\item The movement of objects (robot or obstacles) in  preserves the feasibility of motion
planning on .
\end{enumerate}
\end{prop}
\begin{proof}

\noindent (i): it is obvious since the hole can be moved along the
reverse direction of the arcs in  and the objects can be rotated
to any vertex in .

\noindent (ii): Suppose we move an object from  to  along the
arc . We prove that the motion planning problem is
feasible before the movement iff it is feasible after the movement.

Since  and  is strongly connected, there is a path
 from  to  in , let  denote the cycle .

Suppose the motion planning problem is feasible before the movement.
Because after the movement, there is a hole in , we can move the
hole along the reverse direction of , rotate the objects along
, and restore the situation before the movement, namely all the
objects return to the positions before the movement. An example of
this restoration is given in Figure~\ref{fig:cycle-rotate}. So the
motion planning problem is also feasible after the movement.

\begin{figure}[ht]
\centering
  \includegraphics[width=0.6\textwidth]{figures//cycle-rotate.jpg}
  \caption{Restoration by rotating the objects in a cycle}\label{fig:cycle-rotate}
\end{figure}

The other direction is obvious.
\end{proof}

\smallskip
From \cite{PapadimitriouRST94}, we know that if a graph is
biconnected, then one hole is sufficient to move the robot from the
source vertex to the destination vertex, which is also the case for
strongly biconnected digraphs.
\begin{thm}\label{thm:feas-bi-strong}
Let  be a strongly biconnected digraph. Then the motion planning
problem on  is feasible iff there is at least one hole in .
\end{thm}
\begin{proof}

``Only if'' part: obvious.

``If'' part:

Suppose  is strongly biconnected, there is exactly one hole in
 (the case that there are more than one hole is similar), the
source vertex is  and the destination vertex is .

From Theorem~\ref{thm:bi-strong}, we know that there is an open ear
decomposition  of .

Let  be the minimal  such that  and the hole are all
in , where .

Induction on .

Induction base : ,  and the hole are all in the cycle
. Then move the hole along the reverse direction of the cycle
and move the robot to .

Induction step .

Let the tail and head endpoint of  be  and
 respectively.

Because of minimality of , we have the following three cases.

\textbf{Case I}  is in , :

Select a path  in  from  to , then
 is a cycle in .

If the hole is not in , the hole must be in
, we can move it to  in  without moving the
robot in .

If  is in , then move the hole along the reverse
direction of  and move the robot to .

Otherwise, move the hole along the reverse direction of  and move the robot to . Now the hole is in
, move the hole along the reverse direction of ,
until it reaches .

Then the position of the robot, , the destination  and
the position of the hole, , are all in ,
according to the induction hypothesis, we can move the robot to .

\textbf{Case II}  is in , the hole is in some vertex
of  different from  and :

Select a path  in  from  to , then
 is a cycle in .

If  is in  and , we can move the hole
to  along the reverse direction of  without
moving the robot in , then according to the induction hypothesis,
we can move the robot to .

If  is in  and , then move the hole
along the reverse direction of  and move the robot
to . Now the hole is in , we can move the hole
along the reverse direction of  to . Then by the
induction hypothesis, we can move the robot to .

If  is not in , then  is in .

If , then we can move the hole along the reverse
direction of  and move the robot to .

Now we consider the case .

We can move the hole along the reverse direction of  to
 without moving the robot. Then by the induction
hypothesis, we can move the robot from  to  in
.

By the induction hypothesis again, we can move the robot from
 to  in . Let the trace of the robot
during the movement from  to  be .
Note that  may contain cycles. Suppose the last arc of
 is  for some . Then the hole is in 
after the movement. Without loss of generality, we assume that
during the movement, the robot visits  only once since
 is the destination. Consequently, the hole can be moved
from  to  along the reverse direction of 
without moving the robot in  (see
Figure~\ref{fig:strong-biconn-motion}).

\begin{figure}[ht]
\centering
  \includegraphics[width=0.4\textwidth]{figures//strong-biconn-motion.jpg}
  \caption{The case that the hole and  are in  different from  and , , and }\label{fig:strong-biconn-motion}
\end{figure}

Since  is a cycle, now we can move the hole along
the reverse direction of  and move the robot to .

\textbf{Case III}  and the hole are both in ,  is
in , :

We can move the hole in  to  with possible
movements of the robot in . Suppose the new position of
the robot is .

Now move the hole to some vertex in  different from
 and , which is possible since 
contains at least three vertices. Then we have reduced Case III to
Case II.
\end{proof}
\noindent We introduce the following notation before giving the
algorithm.
\begin{defn}\label{defn:w-side-v}
Let  be a strongly connected digraph,  such
that , and  be the strongly-biconnected-component graph of . Then
 is said to be on the -side of , if  and one of
the following two conditions holds:
\begin{enumerate}
\item , and  are in the same connected component of .

\item , and either  are in the same connected component of , or
, where  is the unique strongly biconnected component
of  to which  belongs.
\end{enumerate}
 is said to be on the non--side of  if , and 
is not on the -side of .

A hole (resp. obstacle) is said to be on the -side of the robot
if the position (vertex) of the hole (resp. obstacle) is on the
-side of the position of the robot, and a hole (resp. obstacle)
is said to be on the non--side of the robot if the position of
the hole is on the non--side of the position of the robot.
\end{defn}


Note that if , , , , where  is the unique strongly biconnected component of
 to which  belongs, then  is on the -side of  iff  and  according to Definition~\ref{defn:w-side-v}.

\begin{exmp}[-side of the robot]
In Figure~\ref{fig:w-side-v-example}(a), the robot is in , two holes in  and  are on the -side of the
robot, and the hole in  is on the non--side of the robot. In
Figure~\ref{fig:w-side-v-example}(b), the robot is in , the hole in  belongs to the same strongly biconnected
component as , so  is on the -side of the robot, and
two holes in  and  are on the non--side of the robot.
\end{exmp}

\begin{figure}[ht]
\centering
  \includegraphics[width=0.7\textwidth]{figures//w-side-v-example.jpg}
  \caption{Example: -side of the robot}\label{fig:w-side-v-example}
\end{figure}



Function FSCD (see Algorithm~\ref{Alg:feas-strong}) decides the
feasibility of motion planning problem on strongly connected
digraphs. FSCD is similar to the algorithm for motion planning on
graphs since strongly biconnected components of strongly connected
digraphs are similar to biconnected components of connected graphs.
\begin{algorithm}[ht]

\dontprintsemicolon \SetVline

\SetKwInOut{Input}{input}
\SetKwInOut{Output}{output}
\Input{ such that  is a strongly connected digraph, , , and  is a function from  to \{``robot'',``obstacle'',``hole''\}.}
\Output{true or false.}



Construct the underlying graph of , , and
construct the biconnected-component graph of  to get
.\;

\While{there are obstacles on the -side of the robot and there
are holes on the non--side of the robot}
{
Let  be the current position of the robot.\;
\eIf{}
{
Select a strongly biconnected component  such that , all the vertices of  are not on the -side of ,
    and there is at least one hole on the -side of  for some , .\;

    \If{there are no holes in }
{
There is  and  such that there is at least one hole on the non--side of ,
      move one such hole to  without moving the robot.
}

    Move a hole in  to  and the robot is moved to some vertex  such that .\;
}
{
Let  be the unique strongly biconnected component to which  belongs ( contains at least three vertices).\;

    \If{there are no obstacles in }
{
Move an obstacle on the -side of the robot into  without moving the robot.
}
Move a hole on the non--side of the robot into  by moving the robot if necessary, while keeping the robot inside .\;

    Move the robot to  again.
  }
}
Let the current position of the robot be .\;

\eIf{ and  are in the same strongly biconnected
component}
{
\eIf{there is at least one hole on the -side of the robot}
{\Return true.}
{\Return false.}\;
}
{
Let  be the path in
  , such that , ,  and .\;
Let  be the maximum of  such that , and
   satisfy the following conditions:\;
\Indp 1. , or  contains at least three vertices, or
  there is some  such that  is not on  and ;\;
2. , or  contains at least three vertices, or there is
  some  such that  is not on  and ;\;
3. For all ,  contains only two vertices, and
  for all , there is no  such that  is
  not on  and .\;
\Indm \eIf{the number of holes on the -side of the robot is no
  less than }
{\Return true.}
{\Return false.}\;
}
\caption{FSCD()\label{Alg:feas-strong}}
\end{algorithm}
\clearpage

\begin{exmp}[Computation of FSCD]
The strongly connected digraph is given in
Figure~\ref{fig:feas-strong-example-1}(a). At first, the robot is
moved from  to , all the holes are on the -side of the
robot (see Figure~\ref{fig:feas-strong-example-1}(b)). Then
according to the definition of  in FSCD, we have . There are
four holes on the -side of the robot, so FSCD returns ``true''.
Now we show how the robot is moved from  to  with the four
holes: three holes are moved to  and the robot is moved
to  (see Figure~\ref{fig:feas-strong-example-1}(c)), then the
holes are moved to  (See
Figure~\ref{fig:feas-strong-example-1}(d)), the robot is moved to
 (see Figure~\ref{fig:feas-strong-example-1}(e)), and all the
holes are moved to  (see
Figure~\ref{fig:feas-strong-example-1}(f)), finally the robot is
moved to .
\end{exmp}

\begin{figure}[ht]
\centering
  \includegraphics[width=0.75\textwidth]{figures//feas-strong-example-1.jpg}
  \caption{Example: motion planning on a strongly connected digraph}\label{fig:feas-strong-example-1}
\end{figure}

\begin{thm}
FSCD is correct.
\end{thm}
\begin{proof}

At first, we show that the ``While'' loop in FSCD terminates.

It is sufficient to show that each execution of the body of the
``While'' loop reduces the number of holes on the non--side of
the robot by .

There are two cases.

\textbf{Case the robot is in some }.

Then  is shared by several strongly biconnected components.

Because there are holes on the non--side of the robot, we can
select a strongly biconnected component  such that ,
all the other vertices of  different from  are on the
non--side of , and there is at least one hole on the -side
of  for some , .

If there are no holes in , then there is  and
 such that there is at least one hole on the
non--side of , then one such hole can be moved to
 without moving the robot.

Now there must be at least one hole in some ,
there is a path from  to  in , we can move the hole
from  to  along the reverse direction of the path, and
the robot is moved to  on the path such that
.

The hole moved to  is on the non--side of the robot before the
movement. Now we show that the hole (in ) is on the -side of
the robot after the movement according to
Definition~\ref{defn:w-side-v}: if ,
then  is in the same connected component as  in
, the hole in  is on the
-side of the robot (); if , since  is the unique strongly biconnected
component to which  belongs, and  is in , so
the hole in  is on the -side of the robot () as
well.

Consequently, in the case that the robot is in some ,
each execution of the ``While''-loop reduces the number of holes on
the non--side of the robot by .

\textbf{Case the robot is in some }.

Let  be the unique strongly biconnected component to which 
belongs.

Since there are holes on the non--side of the robot, and
according to Definition~\ref{defn:w-side-v}, holes in  are on the
-side of the robot, there must be some , ,
 such that there is at least one hole on the
non--side of .

Because there are obstacles on the -side of the robot, if there
are no obstacles in , we can move an obstacle on the -side of
 into  without moving the robot. Now there must be at least
one obstacle in .

If  is not occupied by an obstacle, then an obstacle in  can
be moved to  by moving the robot if necessary. Now a hole on the
non--side of  can be moved to . Move the robot to 
again.

In this case, one hole on the non--side of the robot is moved
into  and the robot returns to  after the movement.
Consequently, in this case, the number of holes on the non--side
of the robot is reduced by  as well.

\medskip

\noindent After the execution of the ``While'' loop, either there
are no obstacles on the -side of the robot or all the holes are
on the -side of the robot. In the former case, it is evident that
FSCD returns ``true'' eventually. Now we consider the latter case.

Suppose the current position of the robot is  now.

If  and  are in the same strongly biconnected component
, then it is easy to see that the problem is feasible iff there
is at least one hole on the -side of the robot according to
Theorem~\ref{thm:feas-bi-strong}.

Otherwise, let  be the number as defined in FSCD, we show that
the problem is feasible iff there are at least  holes.

``Only If'' part: Suppose the problem is feasible.

Then according to Proposition~\ref{prop:motion-strong-observ}, it is
still feasible after the execution of the ``While''-loop.

To the contrary, suppose that there are at most  holes.

Let  be the path in
, such that
, ,  and .

Let  satisfy Condition 1-3 in FSCD and
.

Since the problem is feasible, during the movement of the robot from
 to , the robot should be moved to  sometime.

If the robot has been moved to , then there must be one hole on
the non--side of . So there are at most  holes on the
-side of . Since  holes are needed to occupy all the
vertices  and move the robot from  to
, if the robot has been moved from  to , then all the
holes are on the non--side of  now. The robot cannot be
moved further towards , namely the robot cannot be moved to the
vertices on the -side of , the problem is infeasible, a
contradiction.

``If'' part: Suppose there are at least  holes on the  side
of the robot.

Now we show how to move the robot from  to .

Let  () be the list of all the
numbers  such that , and one of the following
two conditions holds,
\begin{itemize}
\item  contains at least three vertices,

\item there is some  not on  satisfying that .
\end{itemize}

Without loss of generality, assume that there is at least one 
satisfying the above condition. The case that there are no such
's can be discussed similarly.

By convention, let .

At first, we show how to move the robot from  to 
if  satisfies the first condition, and how to move the robot
from  to some  in  such that  is not on ,
, and , if 
satisfies the second condition.

If  contains at least three vertices, since  and
all the holes are on the -side of the robot, we can move the
holes to occupy all the 's such that  and let
another hole occupy some vertex in  different from
. Then we move the robot to  (which is possible
according to Theorem~\ref{thm:feas-bi-strong}). We continue moving
the robot to , , until to . Moreover, because
there is still one hole in , we can move the robot inside
 and move one hole to  and all the other holes
to the -side of the .

If there is some  not on  such that , since , we let the holes occupy all the 's
such that  and another hole occupy some  such that . Then we move the robot to
, and to . Now we can move one hole to  and all
the other holes to the -side of .

The discussions for  and  () are similar
to the above discussion.

During the movement, if sometime there are no obstacles on the
-side of the robot, then obviously the robot can be moved to 
and the problem is feasible. In the following we consider situations
that such situation does not occur.

Now we assume that
\begin{enumerate}
\item If  contains at least three vertices, then the robot is in , one hole
is in , and all the other holes are on the -side of
.

\item If there is  not on  such that
, then the robot is in some  such that
, one hole is in , and all
the other holes are on the -side of .
\end{enumerate}

In the first case above, since , we can move one hole
to some  such that , and the other holes to
occupy vertices . Then we can move the robot
to , , until to . Finally move the robot to
 inside .

In the second case above, since , we can move one
hole to some  such that , and the other
holes to occupy . Then we can move the robot to
, , until to . Finally move the robot to 
inside .

\end{proof}

\begin{thm}\label{thm:strong-complexity}
The time complexity of FSCD is , where  is the number of
vertices and  is the number of arcs.
\end{thm}
\begin{proof}

There are three phases in FSCD: the phase constructing
, the phase of the ``While''-loop, and the
phase checking whether the number of holes are sufficient to move
the robot to the destination.

The phase constructing  is in time 
since the biconnected components of a connected graph of  edges
can be constructed in  time by a depth-first-search technique
\cite{CLRS01}.

Each execution of the ``While''-loop takes  time, and there
are at most  such executions since there are at most  holes,
so the ``While'' loop takes  time in total.

The phase checking whether the number of holes are sufficient to
move the robot to the destination takes  time as well.

So the total time of FSCD is .
\end{proof}


\section{Conclusion}

In this paper, we considered the feasibility of motion planning on
digraphs, and proposed two algorithms to decide the feasibility of
motion planning on acyclic and strongly connected digraphs
respectively, we proved the correctness of the two algorithms and
analyzed their time complexity. We showed that the feasibility of
motion planning on acyclic and strongly connected digraphs can be
decided in time linear in the product of the number of vertices and
the number of arcs.

The algorithm for the feasibility of motion planning on acyclic
digraphs (FAD) can be adapted to the case where the capacity of each
vertex is more than one (namely, vertices are able to hold several
objects simultaneously), by just changing the computation of the
's, the number of holes that could be moved to each node .
The algorithm for the feasibility of motion planning on strongly
connected digraphs (FSCD) can also be adapted to the case where the
capacity of each vertex is more than one by only changing the
``While''-loop.

The strongly biconnected digraphs introduced in this paper may be of
independent interest in graph theory since they admit nice
characterization: a nontrivial digraph is strongly biconnected iff
it has an open ear decomposition. It seems interesting to consider
also strongly triconnected digraphs, strongly four-connected
digraphs, etc. and investigate their theoretical properties.

The feasibility of motion planning on digraphs is only partially
solved in this paper since we did not give the algorithm for
deciding the feasibility on general digraphs, which, as well as the
optimization of the motion of robot and obstacles, is much more
intricate than that on graphs because of the irreversibility of the
movements on digraphs.

The motion planning on graphs with one robot, GMP1R, has a natural
generalization, GMPR, where there are  robots with their
respective destinations. It is also interesting to consider motion
planning on digraphs with  robots since in practice it is more
reasonable that a robot shares its workspace with other robots.

GMPR in general is a very complex problem. A special case of
GMPR, where there are no additional obstacles (thus all the
movable objects have their destinations), has been considered.
Wilson studied the special case of GMPR for  in
\cite{Wilson74}, which is a generalization of the ``15-puzzle''
problem to general graphs. They gave an efficiently checkable
characterization of the solvable instances of the problem.
Kornhauser et al. extended this result to 
\cite{KornhauserMS84}. Goldreich proved that determining the
shortest move sequence for the problem studied by Kornhauser et al.
is NP-hard \cite{Goldreich84}. It seems more realistic to first
consider the above special case of GMPR on digraphs.
\bibliographystyle{amsalpha}
\bibliography{biblio-motion}

\end{document}
