\documentclass{article}







\usepackage[final,nonatbib]{neurips_2019}



\usepackage[utf8]{inputenc} \usepackage[T1]{fontenc}    \usepackage{hyperref}       \usepackage{url}            \usepackage{booktabs}       \usepackage{amsfonts}       \usepackage{nicefrac}       \usepackage{microtype}      

\usepackage{graphicx}
\usepackage{subcaption}
\usepackage{amsmath}
\usepackage{float}
\usepackage{xcolor}
\usepackage{dsfont}
\usepackage{algorithm}
\usepackage[noend]{algpseudocode}
\usepackage{multirow}
\usepackage{comment}
\usepackage{array,amsmath}
\usepackage{mdframed}

\DeclareMathOperator*{\argmax}{arg\,max}
\DeclareMathOperator*{\argmin}{arg\,min}
\newcommand*{\G}{\mathcal{G}}
\newcommand*{\V}{\mathcal{V}}
\newcommand*{\E}{\mathcal{E}}
\newcommand*{\X}{\mathcal{X}}
\newcommand*{\Y}{\mathcal{Y}}
\newcommand*{\I}{\mathcal{I}}
\newcommand*{\loss}{\mathcal{L}}
\newcommand*{\A}{\mathcal{A}}
\newcommand*{\B}{\mathcal{B}}
\newcommand*{\z}{\mathbf{z}}
\newcommand*{\smn}{\text{MobileNetV1-DNW}}
\newcommand*{\rg}{\text{MobileNetV1-RG}}
\providecommand{\mitch}[1]{{\protect\color{blue}{\bf [Mitchell: #1]}}}





\title{Discovering Neural Wirings}

\author{Mitchell Wortsman,\ Ali Farhadi,\  Mohammad Rastegari \\
  PRIOR @ Allen Institute for AI, \
  University of Washington, \
  XNOR.AI \\
  \texttt{mitchnw@cs.washington.edu},  \texttt{\{ali, mohammad\}@xnor.ai}
}

\begin{document}

\maketitle

\begin{abstract}
The success of neural networks has driven a shift in focus from feature engineering to architecture engineering. However, successful networks today are constructed using a small and manually defined set of building blocks. Even in methods of neural architecture search (NAS) the network connectivity patterns are largely constrained. In this work we propose a method for discovering neural wirings. We relax the typical notion of layers and instead enable channels to form connections independent of each other. This allows for a much larger space of possible networks. The wiring of our network is not fixed during training -- as we learn the network parameters we also learn the structure itself. Our experiments demonstrate that our learned connectivity outperforms hand engineered and randomly wired networks. By learning the connectivity of MobileNetV1 \cite{mobilenetv1} we boost the ImageNet accuracy by  at M FLOPs. Moreover, we show that our method generalizes to recurrent and continuous time networks.
Our work may also be regarded as unifying core aspects of the neural architecture search problem with sparse neural network learning. As NAS becomes more fine grained, finding a good architecture is akin to finding a sparse subnetwork of the complete graph. Accordingly, DNW provides an effective mechanism for discovering sparse subnetworks of predefined architectures in a single training run. Though we only ever use a small percentage of the weights during the forward pass, we still play the so-called initialization lottery \cite{lth} with a combinatorial number of subnetworks. Code and pretrained models are available at \url{https://github.com/allenai/dnw} while additional visualizations may be found at \url{https://mitchellnw.github.io/blog/2019/dnw/}.

\end{abstract}

\section{Introduction}
Deep neural networks have shifted the prevailing paradigm from \emph{feature engineering} to \emph{feature learning}. The architecture of deep neural networks, however, must still be hand designed in a process known as \emph{architecture engineering}. A myriad of recent efforts attempt to automate the process of the architecture design by searching among a set of smaller well-known building blocks \cite{mnasnet,wu2018fbnet,zoph2016neural,liu2018progressive,cai2018proxylessnas,darts}. While methods of search range from reinforcement learning to gradient based approaches \cite{wu2018fbnet, darts}, the space of possible connectivity patterns is still largely constrained. NAS methods explore wirings between predefined blocks, and \cite{Savarese2019LearningIR} learns the recurrent structure of CNNs. We believe that more efficient solutions may arrive from searching the space of wirings at a more fine grained level, i.e. single channels. 

In this work, we consider an unconstrained set of possible wirings by allowing channels to form connections independent of each other. This enables us to discover a wide variety of operations (e.g. depthwise separable convs \cite{mobilenetv1}, channel shuffle and split \cite{shufflenet}, and more). Formally, we treat the network as a large \textit{neural graph} where each each node processes a single channel.

\begin{figure*}
    \centering
        \includegraphics[width=\textwidth]{Fig/NG.pdf}
\caption{\textbf{Dynamic Neural Graph:} A 3-layer perceptron (\textit{left}) can be expressed by a dynamic neural graph with 3 time steps (\textit{right}).}
    \label{fig:neuralgraph}
\end{figure*}

One key challenge lies in searching the space of all possible wirings -- the number of possible sub-graphs is combinatorial in nature. When considering thousands of nodes, traditional search methods are either prohibitive or offer approximate solutions. In this paper we introduce a simple and efficient algorithm for discovering neural wirings (DNW). Our method searches the space of all possible wirings with a simple modification of the backwards pass.

Recent work in randomly wired neural networks \cite{randwire} aims to explore the space of novel neural network wirings. Intriguingly, they show that constructing neural networks with random graph algorithms often outperforms a manually engineered architecture. However, these wirings are fixed at training.

Our method for discovering neural wirings is as follows: First, we consider the sole constraint that that the total number of edges in the \textit{neural graph} is fixed to be . Initially we randomly assign a weight to each edge. We then choose the weighted edges with the highest magnitude and refer to the remaining edges as \textit{hallucinated}. As we train, we modify the weights of \emph{all} edges according to a specified update rule. Accordingly, a hallucinated edge may strengthen to a point it replaces a real edge. We tailor the update rule so that when \textit{swapping} does occur, it is beneficial.



We consider the application of DNW for \textit{static} and \textit{dynamic} neural graphs. In the \textit{static} regime each node has a single output and the graphical structure is acyclic. In the case of a \textit{dymanic neural graph} we allow the state of a node to vary with time. \textit{Dymanic neural graphs} may contain cycles and express popular sequential models such as LSTMs \cite{lstm}. As \textit{dymanic neural graphs} are strictly more expressive than \textit{static neural graphs}, they can also express feed-forward networks (as in Figure \ref{fig:neuralgraph}).

Our work may also be regarded as a unification between the problem of neural architecture search and sparse neural network learning. As NAS becomes less restrictive and more fine grained, finding a good architecture is akin to finding a sparse sub-network of the complete graph. Accordingly, DNW provides an effective mechanism for discovering sparse networks in a single training run.


The \textit{Lottery Ticket Hypothesis} \cite{lth,lth2} demonstrates that dense feed-forward neural networks contain so-called \textit{winning-tickets}. These \textit{winning-tickets} are sparse subnetworks which, when reset to their initialization and trained in isolation, reach an accuracy comparable to their dense counterparts. This hypothesis articulate an advantage of overparameterization during training -- having more parameters increases the chance of winning the \textit{initialization lottery}. We leverage this idea to train a sparse neural network without retraining or fine-tuning. Though we only ever use a small percentage of the weights during the forward pass, we still play the lottery with a combinatorial number of sub-networks.


We demonstrate the efficacy of DNW on small and large scale data-sets, and for feed-forward, recurrent, continuous, and sparse networks. Notably, we augment MobileNetV1 \cite{mobilenetv1} with DNW to achieve a  improvement on ImageNet \cite{imagenet} from the hand engineered MobileNetV1 at M FLOPs\footnote{We follow \cite{shufflenet, shufflenetv2} and define FLOPS as the number of Multiply Adds.}.

\begin{figure*}
    \centering
    \includegraphics[scale=0.17]{Fig/convgraph.pdf}
    \caption{An example of a dynamic (left) and static (right) neural graph. Details in Section~\ref{sec:dyn}.}
    \label{fig:convgraph}
\end{figure*}
\section{Discovering Neural Wirings}

In this section we describe our method for jointly discovering the structure and learning the parameters of a neural network. We first consider the algorithm in a familiar setting, a feed-forward neural network, which we abstract as a \textit{static neural graph}. We then present a more expressive \textit{dynamic neural graph} which extends to discrete and continuous time and generalizes feed-forward, recurrent, and continuous time neural networks.

\subsection{Static Neural Graph}
A \textit{static neural graph} is a directed acyclic graph  consisting of nodes  and edges . The state of a node  is given by the random variable . At each node  we apply a function  and with each edge  we associate a weight . In the case of a multi-layer perceptron,  is simply a parameter-free non-linear activation like ReLU \cite{alexnet}.

For any set  we let  denote  and so  is the state of all nodes in the network.

 contains a subset of input nodes  with no parents and output nodes  with no children. The input data  flows into the network through  as  for a function  which may have parameters . Similarly, the output of the network  is given by .

For brevity, we let  denote the ``input" to node , where  may be expressed


In this work we consider the case where the input and output of each node is a two-dimensional matrix, commonly referred to as a channel. Each node performs a non-linear activation followed by normalization and convolution (which may be strided to reduce the spatial resolution). As in \cite{randwire}, we no longer conform to the traditional notion of ``layers" in a deep network.

The combination of a separate  convolution for each channel (depthwise convolution) followed by a  convolution (pointwise convolution) is often referred to as a depthwise seperable convolution, and is essential in efficient network design \cite{mobilenetv1, shufflenetv2}. With a \textit{static neural graph} this process may be interpreted equivalently as a  convolution at each node followed by information flow on a complete bipartite graph. 
\subsection{Discovering a -Edge neural graph}
We now outline our method for discovering the edges of a static neural graph subject to the constraint that the total number of edges must not exceed .

We consider a set of real edges  and a set of \textit{hallucinated} edges . The real edge set is comprised of the -edges which have the largest magnitude weight. As we allow the magnitude of the weights in both sets to change throughout training the edges in  may replace those in . 

Consider a \textit{hallucinated} edge . If the gradient is pushing  in a direction which aligns with , then our update rule strengthens the magnitude of the weight . If this alignment happens consistently then  will be eventually be strong enough to enter the real edge set . As the total number of edges is conserved, when  enters the edge set  another edge is removed and placed in . This procedure is detailed by Algorithm \ref{alg:train}, where  is the node set,  are the input and output node sets, ,  and  are the input, output, and node functions,  is the data distribution,  is the number of edges in the graph and  is the loss.
\begin{algorithm}[t]
\caption{DNW-Train}\label{alg:train}
\begin{algorithmic}[1]
\For{each pair of nodes  such that }  {\color{gray}\Comment{Initialize}}
    \State{Initialize  by independently sampling from a uniform distribution.}
\EndFor
\For{each training iteration}
    \State{Sample mini batch of data and labels  using } {\color{gray}\Comment{Sample data}}
    \State{ where  is chosen so that } {\color{gray}\Comment{Choose edges}}
    \State{} {\color{gray}\Comment{Forward pass}}
    \State{} {\color{gray}\Comment{Compute output}}
    \State{Update  via SGD \& Backprop \cite{backprop} using loss }
    \For{each pair of nodes  such that }  {\color{gray}\Comment{Update edge weights}}
        \State{} {\color{gray}\Comment{Recall  }} \label{line:edge_update}
    \EndFor
\EndFor
\end{algorithmic}
\end{algorithm}
\begin{figure}[t]
    \centering
        \includegraphics[width=1\textwidth]{Fig/grad_flow_v2.pdf}
        \caption{\textbf{Gradient flow:} On the forward pass we use only on the \textit{real} edges. On the backwards pass we allow the gradient to flow \textit{to} but not \textit{through} the hallucinated edges (as in Algorithm \ref{alg:train}).}
        \label{fig:gradientflow}
\end{figure}

In practice we may also include a momentum and weight decay\footnote{Weight decay \cite{wd} may in fact be very helpful for eliminating dead ends.} term in the weight update rule (line \ref{line:edge_update} in Algorithm \ref{alg:train}). In fact, the weight update rule looks nearly identical to that in traditional SGD \& Backprop but for one key difference: we \textbf{allow} the gradient to flow \textit{to} edges which did not exist during the forward pass. Importantly, we \textbf{do not allow} the gradient to flow \textit{through} these edges and so the rest of the parameters update as in traditional SGD \& Backprop. This gradient flow is illustrated in Figure~\ref{fig:gradientflow}.

Under certain conditions we formally show that swapping an edge from  to  decreases the loss . We first consider the simple case where the \textit{hallucinated edge}  replaces . In Section \ref{section:formal-extensions} we discuss the proof to a more general case.

We let  to denote the weight  after the weight update rule . We assume that  is small enough so that sign() = sign().

\textbf{Claim:} Assume  is Lipschitz continuous. There exists a learning rate  such that for  the process of swapping  for  will decrease the loss on the mini-batch when the state of the nodes are fixed and  but .

\textit{Proof.} Let  be value of  after the update rule if  is replaced with . Let  be the state of  after the update rule if we do not allow for swapping.  and  are then given by

Additionally, let  be the direction in which the loss most steeply descends with respect to . By \textit{Lemma 1} (Section \ref{section:lemma1} of the Appendix) it suffices to show that moving  towards  is more aligned with  then moving  towards . Formally we wish to show that

which simplifies to

In the case where  and  have the same sign but  and  have different signs the inequality immediately holds. This corresponds to the case where  \textit{increases} in magnitude but  \textit{decreases} in magnitude. The opposite scenario ( \textit{decreases} in magnitude but  \textit{increases}) is impossible since  but .

We now consider the scenario where both sides of the inequality (equation \ref{eq:ineq}) are positive. Simplifying further we obtain

and are now able to identify a range for  such that the inequality above is satisfied. By assumption the right hand side is less than 0 and sign() = sign() so . Accordingly, it suffices to show that 

If we let  and , then for 

the inequality (equation \ref{eq:ineq2}) is satisfied. Here we are implicitly using our assumption that the gradient is bounded and we may ``tune''  to control the magnitude . In the case where  the right hand side of equation \ref{eq:ineq2} becomes 0 while the left hand side is .

In Section \ref{sec:scale} of the appendix we discuss the effect of  on . In Section \ref{sec:st} of the Appendix, we show that the update rule is equivalently a straight-through estimator \cite{st}.

\subsection{Dynamic Neural Graph} \label{sec:dyn}




We now consider a more general setting where the state of each node  may vary through time. We refer to this model as a \textit{dynamic neural graph}. 


The initial conditions of a \textit{dynamic neural graph} are given by

where  is a designated set of input nodes, which may now have parents. 
\begin{mdframed}
\textbf{Discrete Time Dynamics:} For a discrete time neural graph we consider times . The dynamics are then given by

and the network output is .
We may express equation \ref{eq:io_disc} more succinctly as

where , , and  is the weighted adjacency matrix for graph . Equation \ref{eq:io_succ} suggests the following interpretation: At each time step we send information through the edges using  then apply a function at each node.
\end{mdframed}
\begin{mdframed}
\textbf{Continuous Time Dynamics:} As in \cite{node}, we consider the case where  may take on a continuous range of values. We then arrive at dynamics given by

Interestingly, if  is a strict subset of  we uncover an Augmented Neural ODE \cite{anode}.
\end{mdframed}
The discrete time case is unifying in the sense that it may also express any static neural graph. In Figure~\ref{fig:neuralgraph} we illustrate than an MLP may also be expressed by a discrete time neural graph. Additionally, the discrete time dynamics are able to capture sequential models such as LSTMs \cite{lstm}, as long as we allow input to flow into  at any time.

In continuous time it is not immediately obvious how to incorporate strided convolutions. One approach is to keep the same spatial resolution throughout and pad with zeros after applying strided convolutions. This design is illustrated by Figure~\ref{fig:convgraph}.

We may also apply Algorithm \ref{alg:train} to learn the structure of dynamic neural graphs. One may use backpropogation through time \cite{bptt} and the adjoint-sensitivity method \cite{node} for optimization in the discrete and continuous time settings respectively. In Section \ref{sec:small-scale}, we demonstrate empirically that our method performs better than a random graph, though we do not formally justify the application of our algorithm in this setting.

\subsection{Implementation details for Large Scale Experiments} \label{sec:impl}
For large scale experiments we do not consider the dynamic case as optimization is too expensive. Accordingly, we now present our method for constructing a large and efficient \textit{static neural graph}. With this model we may jointly learn the structure of the graph along with the parameters on ImageNet \cite{imagenet}. As illustrated by Table~\ref{tab:arch} our model closely follows the structure of MobileNetV1 \cite{mobilenetv1}, and so we refer to it as . We consider a separate \textit{neural graph} for each spatial resolution -- the output of graph  is the input of graph . For width multiplier \cite{mobilenetv1}  and spatial resolution  we constrain  to have the same number of edges for resolution  as the corresponding MobileNetV1 . We use a \textit{slightly smaller} width multiplier to obtain a model with similar FLOPs as we do not explicitly reduce the number of depthwise convolutions in . However, we do find that neurons often \textit{die} (have no output) and we may then skip the depthwise convolution during inference. Note that if we interpret a pointwise convolution with  input channels and  output channels as a complete bipartite graph then the number of edges is simply .

We also constrain the longest path in graph  to be equivalent to the number of layers of the corresponding MobileNetV1. We do so by partitioning the nodes  into blocks  where  is the input nodes ,  is output nodes , and we only allow edges between nodes in  and  if . The longest path in a graph with  blocks is then . Splitting the graph into blocks also improves efficiency as we may operate on one block at a time. The structure of MobileNetV1 may be recovered by considering a complete bipartite graph between adjacent blocks.

The operation  at each non-output node is a batch-norm \cite{batchnorm} (2 parameters), ReLU \cite{alexnet},  convolution (9 parameters) triplet. There are no operations at the output nodes. When the spatial resolution decreases in MobileNetV1 we change the convolutional stride of the input nodes to 2. 

In models denoted -Small  we also limit the last fully connected (FC) layer to have the same number of edges as the FC layer in MobileNetV1 . In the normal setting of  we do not modify the last FC layer.













\section{Experiments} \label{sec:experiments}

In this section we demonstrate the effectiveness of DNW for image classification in small and large scale settings. We begin by comparing our method with a random wiring on a small scale dataset and model. This allows us to experiment in static, discrete time, and continuous settings. Next we explore the use of DNW at scale with experiments on ImageNet \cite{imagenet} and compare DNW with other methods of discovering network structures. Finally we use our algorithm to effectively train sparse neural networks without retraining or fine-tuning. 

Throughout this section we let RG denote our primary baseline -- a \textbf{randomly wired graph}. To construct a randomly wired graph with -edges we assign a uniform random weight to each edge then pick the  edges with the largest magnitude weights. As shown in \cite{randwire}, random graphs often outperform manually designed networks.

\subsection{Small Scale Experiments For Static and Dynamic Neural Graphs} \label{sec:small-scale}
We begin by training tiny classifiers for the CIFAR-10 dataset \cite{cifar}. Our initial aim is not to achieve state of the art performance but instead to explore DNW in the static, discrete, and continuous time settings. As illustrated by Table \ref{tab:small-scale}, our method outperforms a random graph by a large margin.

The image is first downsampled\footnote{We use two  strided convolutions. The first is standard while the second is depthwise-separable.} then each channel is given as input to a node in a \textit{neural graph}. The static graph uses 5 blocks and the discrete time graph uses 5 time steps. For the continuous case we backprop through the operation of an adaptive ODE solver\footnote{We use a 5th order Runge-Kutta method \cite{ode} as implemented by \cite{node} (from  to  with tolerance ).}. The models have 41k parameters. At each node we perform Instance Normalization \cite{instancenorm}, ReLU, and a  single channel convolution.

\begin{table}
\parbox{.45\linewidth}{
  \small
  \caption{Testing a tiny (41k parameters) classifier on CIFAR-10 \cite{cifar} in static and dynamic settings shown as mean and standard deviation (std) over 5 runs.}
  \label{tab:small-scale}
  \centering
  \begin{tabular}{ll}
    \toprule
    Model  & Accuracy \\
    \midrule
    Static (RG) &  \\
    Static (DNW) &  \\
    \midrule
    Discrete Time (RG) &  \\
    Discrete Time (DNW) &  \\
    \midrule
    Continuous (RG) &  \\
    Continuous (DNW) &  \\
    \bottomrule
  \end{tabular}
 } \hspace{1cm}
\parbox{.45\linewidth}{
  \small
  \caption{Other methods for discovering wirings (using the architecture described in Table \ref{tab:arch}) tested on CIFAR-10 shown as mean and std over 5 runs. Models with  first require the complete graph to be trained.}
  \label{tab:net}
  \centering
  \begin{tabular}{ll}
    \toprule
    Model      & Accuracy \\
    \midrule
    MobileNetV1   &      \\
    \rg  &      \\
    No Update Rule  &      \\
    L1 + Anneal  &      \\
    TD  &  \\
    Lottery Ticket (one-shot)  &      \\
    Fine Tune   &      \\
    Fine Tune   &      \\
    Fine Tune   &      \\
    \smn &  \\ 
    \bottomrule
  \end{tabular}
  }
  \vspace{-2em}
\end{table}
\subsection{ImageNet Classification}
For large scale experiments on ImageNet \cite{imagenet} we are limited to exploring DNW in the static case (recurrent and continuous time networks are more expensive to optimize due to lack of parallelization). Although our network follows the simple structure of MobileNetV1 \cite{mobilenetv1} we are able to achieve higher accuracy than modern networks which are more advanced and optimized. Notably, MobileNetV2 \cite{mobilenetv2} extends MobileNetV1 by adding residual connections and linear bottlenecks and ShuffleNet \cite{shufflenet, shufflenetv2} introduces channel splits and channel shuffles. The results of the large scale experiments may be found in Table \ref{tab:imagenet}.

As standard, we have divided the results of Table \ref{tab:imagenet} to consider models which have similar FLOPs. In the more sparse case (M FLOPs) we are able to use DNW to boost the performance of MobileNetV1 by . Though random graphs perform extremely well we still observe a  boost in performance. In each experiment we train for 250 epochs using Cosine Annealing as the learning rate scheduler with initial learning rate 0.1, as in \cite{randwire}. Models using random graphs have considerably more FLOPs as nearly all depthwise convolutions must be performed. DNW allows neurons to die and we may therefore skip many operations.

\begin{table}
  \caption{ImageNet Experiments (see Section~\ref{sec:impl} for more details). Models with  use the implementations of \cite{shufflenetv2}. Models with multiples asterisks use different image resolutions so that the FLOPs is comparable (see Table 8 in \cite{shufflenetv2} for more details).}
  \label{tab:imagenet}
  \small
  \centering
  \begin{tabular}{llll}
    \toprule
    Model   &Params  & FLOPs     & Accuracy \\
    \midrule
    MobileNetV1  \cite{mobilenetv1} & 0.5M & 41M  &      \\
    X-4 MobileNetV1 \cite{xnets} & --- & > 50M  &      \\
    MobileNetV2  \cite{mobilenetv2} & --- & 39M  &      \\
    MobileNetV2  & --- & 43M  &      \\
    DenseNet  \cite{densenet} & --- & 42M  &      \\
    Xception  \cite{xception} & --- & 40M  &      \\
    ShuffleNetV1  \cite{shufflenet} & --- & 38M  &      \\
    ShuffleNetV2  \cite{shufflenetv2} & 1.4M & 41M  &      \\
    \rg  & 1.2M & 55.7M  &      \\
    \smn-Small  & 0.24M & 22.1M  &      \\
    \smn-Small  & 0.4M & 41.2M  &      \\
    \smn  & 1.1M & 42.1M  &      \\
    \midrule
    MnasNet-search1 \cite{mnasnet}& 1.9M & 65M  &      \\
    \smn  & 1.3M & 66.7M  &      \\
    \midrule
    MobileNetV1  & 1.3M & 149M  &      \\
    MobileNetV2  & --- & 141M  &      \\
    MobileNetV2  & --- & 145M  &      \\
    DenseNet  & --- & 142M  &      \\
    Xception  & --- & 145M  &      \\
    ShuffleNetV1  & --- & 140M  &      \\
    ShuffleNetV2  & 2.3M & 146M  &      \\
    \rg  & 1.8M & 170M  &      \\
    \smn  & 1.8M & 154M  &      \\
    \bottomrule
  \end{tabular}
  \vspace{-1em}
\end{table}
\subsection{Related Methods}
We compare DNW with various methods for discovering neural wirings. In Table \ref{tab:net} we use the structure of  but try other methods which find -edge sub-networks. The experiments in Table \ref{tab:net} are conducted using CIFAR-10 \cite{cifar}. We train for 160 epochs using Cosine Annealing as the learning rate scheduler with initial learning rate  unless otherwise noted.

\textbf{The Lottery Ticket Hypothesis:} The authors of \cite{lth, lth2} offer an intriguing hypothesis: sparse sub-networks may be trained in isolation when reset to their initialization. However, their method for finding so-called winning tickets is quite expensive as it requires training the full graph from scratch. We compare with \textbf{one-shot} pruning from \cite{lth2}. One-shot pruning is more comparable in training FLOPS than iterative pruning \cite{lth}, though both methods are more expensive in training FLOPS than DNW. After training the full network  (i.e. no edges pruned) the optimal sub-network  with -edges is chosen by taking the weights with the highest magnitude. In the row denoted \textit{Lottery Ticket} we retrain  using the initialization of . We also initialize  with the weights of  \textit{after} training -- denoted by \textbf{FT} for \textit{fine-tune} (we try different initial learning rates ). Though these experiments perform comparably with DNW, their training is more expensive as the full graph must initially be trained.

\textbf{Exploring Randomly Wired Networks for Image Recognition:} The authors of \cite{randwire} explore ``\textit{a more diverse set of connectivity patterns through the lens of randomly wired neural networks.}" They achieve impressive performance on ImageNet \cite{imagenet} using random graph algorithms to generate the structure of a neural network. Their network connectivity, however, is fixed during training. Throughout this section we have a random graph (denoted \textbf{RG}) as our primary baseline -- as in \cite{randwire} we have seen that random graphs outperform hand-designed networks.

\textbf{No Update Rule:} In this ablation on DNW we do not apply the update rule to the hallucinated edges. An edge may only leave the hallucinated edge set if the magnitude of a real edge is sufficiently \textit{decreased}. This experiment demonstrates the importance of the update rule.

\textbf{L1 + Anneal:} We experiment with a simple pruning technique -- start with a fully connected graph and remove edges by magnitude throughout training until there are only  remaining. We found that accuracy was much better if we added an L1 regularization term.

\textbf{Targeted Dropout:} The authors of \cite{td} present a simple and effective method for training a network which is robust to subsequent pruning. Their method outperforms variational dropout \cite{vd} and  pruning \cite{l0}. We compare with \textit{Weight Dropout/Pruning} from \cite{td}, which we denote as \textbf{TD}. Section~\ref{sec:td} of the Appendix contains more information, experimental details, and hyperparameter trials for the Targeted Dropout experiments, though we provide the best result in Table~\ref{tab:net}.

\textbf{Neural Architecture Search:} As illustrated by Table \ref{tab:imagenet}, our network (with a very simple MobileNetV1 like structure) is able to achieve comparable accuracy to an expensive method which performs neural architecture search using reinforcement learning \cite{mnasnet}. 

\subsection{Training Sparse Neural Networks}

We may apply our algorithm for Discovering Neural Wirings to the task of training sparse neural networks. Importantly, our method requires no fine-tuning or retraining to discover a sparse sub-networks -- the sparsity is maintained throughout training. This perspective was guided by the the work of Dettmers and Zettelmoyer in \cite{sparse}, though we would like to highlight some differences. Their work enables faster training, though our backwards pass is still dense. Moreover, their work allows for a redistribution of parameters across layers whereas we consider a fixed sparsity per layer.

Our algorithm for training a sparse neural network is similar to Algorithm \ref{alg:train}, though we implicitly treat each convolution as a separate graph where each parameter is an edge. For each convolutional layer on the forwards pass, we use the top  of the parameters chosen by magnitude. On the backwards pass we allow the gradient to flow to, but not through, all weights that were zeroed out on the forwards pass. All weights receive gradients as if they existed on the forwards pass, regardless of if they were zeroed out.

As in \cite{sparse} we leave the biases and batchnorm dense. We compare with the result in Appendix C of \cite{sparse}, as we also use a tuned version of a ResNet50 that uses modern optimization techniques such as cosine learning rate scheduling and warmup\footnote{We adapt the code from \url{https://github.com/NVIDIA/DeepLearningExamples/tree/master/PyTorch/Classification/RN50v1.5}, using the exact same hyperparameters but training for 100 epochs.}. We train for 100 epochs and showcase our results in Table~\ref{tab:sparse}.
\begin{table}
  \caption{Training a tuned version of ResNet50 on ImageNet with modern optimization techniques, as in Appendix C of \cite{sparse}. For \textit{All Layers Sparse}, every layer has a fixed sparsity. In contrast, we leave the very first convolution dense for \textit{First Layer Dense}. The parameters in the first layer constitute only 0.04\% of the total network.}
  \small
  \centering
  \begin{tabular}{cccc}
    \toprule
    Method   & Weights (\%)    & Top-1 Accuracy & Top-5 Accuracy \\
    \midrule
    Sparse Networks from Scratch \cite{sparse} & 10\% & 72.9\% & 91.5\% \\
    Ours - All Layers Sparse & 10\% & 74.0\% & 92.0\% \\
    Ours - First Layer Dense & 10\% & 75.0\% & 92.5\% \\
    \midrule
    Sparse Networks from Scratch \cite{sparse} & 20\% & 74.9\% &  92.5\% \\
    Ours - All Layers Sparse & 20\% & 76.2\% & 93.0\% \\
    Ours - First Layer Dense & 20\% & 76.6\% & 93.4\% \\
    \midrule
    Sparse Networks from Scratch \cite{sparse} & 30\% & 75.9\% & 92.9\% \\
    Ours - All Layers Sparse & 30\% & 76.9\% & 93.4\% \\
    Ours - First Layer Dense & 30\% & 77.1\% & 93.5\% \\
    \midrule
Sparse Networks from Scratch \cite{sparse} & 100\% & 77.0\% &  93.5\% \\
    Ours - Dense Baseline & 100\% & 77.5\% & 93.7\% \\
    \bottomrule
  \end{tabular}
  \label{tab:sparse}
\end{table}









\section{Conclusion} \label{sec:conclusion}

We present a novel method for discovering neural wirings. With a simple algorithm we demonstrate a significant boost in accuracy over randomly wired networks. We benefit from overparameterization during training even when the resulting model is sparse. Just as in \cite{randwire}, our networks are free from the typical constraints of NAS. This work suggests exciting directions for more complex and efficient methods of discovering neural wirings.

\subsubsection*{Acknowledgments}
We thank Sarah Pratt, Mark Yatskar and the Beaker team. We also thank Tim Dettmers for his assistance and guidance in the experiments regarding sparse networks. This work is in part supported by DARPA N66001-19-2-4031, NSF IIS-165205,  NSF IIS-1637479, NSF IIS-1703166, Sloan Fellowship, NVIDIA Artificial Intelligence Lab, the Allen Institute for Artificial Intelligence, and the AI2 fellowship for AI. Computations on \url{beaker.org} were supported in part by credits from Google Cloud. 

\medskip

{\small
\bibliographystyle{plain}
\bibliography{neurips_2019}
}


\newpage
\appendix

\section{Architecture}

\begin{table}[H]
  \caption{The general structure of MobileNetV1 vs.  for ImageNet experiments. \texttt{dwconv} denotes \textit{depthwise convolutions}, \texttt{pwconv} denotes \textit{pointwise convolution}, \texttt{FC} denotes a fully connected layer,  denotes width multiplier \cite{mobilenetv1},  denotes the number of output channels, and  denotes stride. When omitted assume that stride is 1. Batch-norm \cite{batchnorm} and ReLU follow each convolution in MobileNetV1. When training on CIFAR-10 \cite{cifar} the first convolution has stride 1.}
  \label{tab:arch}
  \centering
\begin{tabular}{llll}
 \toprule
\textbf{Stage} & \textbf{Output} & \textbf{MobilNetV1} & \textbf{\smn}   \\
 \midrule
  &   &   &  \\
 \midrule
  &   &   &  with  \\
  &   &   &   \\
 \midrule
   &   &   &  with  \\
  &   &   &  \\
  &   &   &  \\
  &   &   &  \\
 \midrule
    &   &   &  with  \\
  &   &   &   \\
  &   &   &  \\
  &   &   &  \\
 \midrule
   &   &   &  with   \\
  &   &   &   \\ 
  &   & \multirow{3}{*}{}  &  \\
  &   &   &  \\
  &   &   &  \\
 \midrule
    &   &   &  with   \\
  &   &   &    \\
  &   &   &  \\
  &   &   &  \\
 \midrule
  &  &    & \\
\bottomrule
\end{tabular}
\end{table}

\section{Targeted Dropout: Details, Regular vs. Unconstrained and Additional Hyperparameters} \label{sec:td}

The method of Targeted Dropout is as follows: choose the bottom  fraction of weights by magnitude and apply dropout with probability . We use the same architecture as   and fix  at each stage so that the network \textit{post pruning} has the same number of edges per stage as  .

In the setting we consider, \textit{unconstrained} targeted weight dropout outperforms the targeted weight dropout presented in \cite{td} (which we refer to as \textit{regular}). Accordingly, the results we present in Table~\ref{tab:net} correspond to unconstrained targeted \textit{weight dropout}. In \textit{regular} targeted weight dropout, dropout is applied to the bottom  fraction of incoming weights \textit{to each neuron}. In \textit{unconstrained} targeted weight dropout, we apply dropout to the bottom  fraction of edges at a given spatial resolution. Accordingly, neurons may die and have no incoming or outgoing edges. We compare unconstrained and regular targeted dropout in Table~\ref{tab:td}.
\begin{table}[H]
  \caption{Comparing variants of targeted weight dropout using the architecture described in Table \ref{tab:arch} and tested on CIFAR-10 shown as mean and std over 5 runs.}
  \label{tab:td}
  \centering
  \begin{tabular}{llll}
    \toprule
    Model      & Accuracy  & Accuracy \\
          & (Unconstrained)  & (Regular) \\
    \midrule
    TD  &   &  \\
    TD  &  &  \\
    TD  &  &  \\
    TD  &  &  \\
    \bottomrule
  \end{tabular}
\end{table}

\section{A More General Case} \label{section:formal-extensions}

We now consider the case where the \textit{hallucinated edge}  replaces .

As before we use  to denote the weight  after the weight update rule . We assume that  is small enough so that sign() = sign().

\textbf{Claim:} Assume  is Lipschitz continuous. There exists a learning rate  such that for  the process of swapping  for  will decrease the loss when the state of the nodes are fixed, there is no path from  to , and  but .

\textit{Proof.} Let  be value of  and  after the update rule if  is replaced with . Let  and  be the state of  and  after the update rule if we do not allow for swapping. ,  and  are then given by

Additionally, let  and  be the direction in which the loss most steeply descends with respect to  and . By \textit{Lemma 1} (Section \ref{section:lemma1} of the Appendix) it suffices to show that

which simplifies to

We are now in the equivalent setting as equation \ref{eq:ineq} and may complete the proof as before.

In practice there may be a path from  and  the state of the nodes will never be the fixed due to stochasticity of mini-batches and updates to the rest of the parameters in the network. However, as the graph grows large the state of one node will have little effect on the state of another, even if there is a path between them. The proofs are done in an idealized case and the empirical results demonstrate that the method works in practice.

\section{Lemma 1} \label{section:lemma1}

Here we show that for sufficiently small ,

implies that

Note that for brevity we have written the loss as a function of . By taking a Taylor expansion we find that

and so for sufficiently small 

which completes the lemma.

An equivalent argument holds for two dimensions.

implies that

By taking a Taylor expansion we find that

and so for sufficiently small 


\section{Effect of  on } \label{sec:scale}

One concern is that convolution or batch normalization \cite{batchnorm} in  would make it difficult to choose edges by magnitude. Consider the case where a convolutional kernel is scaled up arbitrarily in magnitude. Even if the incoming edges were important, their magnitudes would likely be small. As a consequence, they would not be chosen.

Here we argue that this is unlikely to occur. When batch normalization \cite{batchnorm} is present, the ``energy" of the incoming weights are conserved. A formal treatment of this statement is provided by Thoerem 3 of \cite{luck}.

\section{Reformulation as a Straight-Through Estimator} \label{sec:st}
We now reformulate the update rule as a straight-through estimator \cite{st,gs}. We are equivalently computing the input to node  as

where  in the forward pass. Even though  has gradient  when , we would still like a mechanism for updating  in the backward pass. Here we may use the ``straight-through" estimator \cite{st}, and let  be the identity in the backward pass (\textit{i.e.} we go straight-through ). Then  in the backward pass and we then compute




which, when using the chain rule and a standard SGD update, aligns with our update rule (line \ref{line:edge_update} in Algorithm \ref{alg:train}). This is exactly how we implement the update rule in PyTorch \cite{paszke2017automatic}.


\end{document}
