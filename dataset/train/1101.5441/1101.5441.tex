\documentclass[copyright,creativecommons]{eptcs}
\providecommand{\event}{CL&C 2010} 





\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{mathrsfs}
\usepackage{bussproofs}




\newcommand{\powerset}           {\mathbb{P}}
\newcommand{\EM}                       { {\tt EM} }
\newcommand{\HA}                       { {\tt HA} }
\newcommand{\Nat}                      { {\tt N} }
\newcommand{\Bool}                     { {\tt Bool} }
\newcommand{\State}                    { {\tt S} }
\newcommand{\NatSet}                   {\mathbb{N}}
\newcommand{\BoolSet}                  {\mathbb{B}}
\newcommand{\StateSet}                 {\mathbb{S}}
\newcommand{\SystemT}                  {\mathsf{T}}
\newcommand{\True}                     { {\tt{True}} }
\newcommand{\False}                    { {\tt{False}} }
\newcommand{\Realizer}                 { {\mbox{\tiny Real}} }
\newcommand{\StructureN}               { {\mathcal N} }
\newcommand{\Class}                    {\mbox{\tiny Class}}
\newcommand{\Learn}                    {\mbox{\tiny Learn}}
\newcommand{\SystemTState}             {\SystemT_\State}
\newcommand{\SystemTClass}             {{\SystemT_{\Class}}}
\newcommand{\SystemTLearn}             {{\SystemT_{\Learn}}}
\newcommand{\Language}                 {\mathcal{L}}
\newcommand{\LanguageClass}            {\Language_{\Class}}
\newcommand{\LanguageLearn}            {\Language_{\Learn}}
\newcommand{\comment}[1]{}
\newcommand{\proj}                     { {p} }
\newcommand{\CupSem}                   { {\mathcal U} }
\newcommand{\Add}                      { {\mbox{Add}} }
\newcommand{\add}                      { {\mbox{add}} }
\newcommand{\fix}                      { {f} }
\newcommand{\makenum}        [1]       { {\underline{#1}} }
\newcommand{\makestate}      [1]       { {\underline{#1}} }
\newcommand{\PRclass}                    {{\mathsf{PCF}_{\Class}}}
\newcommand{\PRlearn}                    {{\mathsf{PCF}_{\Learn}}} 



\newtheorem{theorem}{Theorem}
\newtheorem{corollary}{Corollary}
\newtheorem{lemma}{Lemma}
\newtheorem{proposition}{Proposition}
\newtheorem{definition}{Definition}





\title{Interactive Learning Based Realizability and 1-Backtracking Games}
\author{Federico Aschieri
\institute{Dipartimento di Informatica\\
Universit\`a di Torino\\ Italy}
\institute{School of Electronic Engineering and Computer Science\\
Queen Mary, University of London\\
UK}
}

\def\titlerunning{Interactive Learning Based Realizability and 1-Backtracking Games}
\def\authorrunning{F. Aschieri}

\begin{document}
\maketitle

\begin{abstract}  We prove that interactive learning based classical realizability (introduced by Aschieri and Berardi for first order arithmetic \cite{Aschieri}) is sound with respect to Coquand game semantics. In particular, any realizer of an implication-and-negation-free arithmetical formula embodies a winning recursive strategy for the 1-Backtracking version of Tarski games. We also give examples of realizer and winning strategy extraction for some classical proofs. We also sketch some ongoing work about how to extend our notion of realizability in order to obtain completeness with respect to Coquand semantics, when it is restricted to 1-Backtracking games.
 \end{abstract}

\section{Introduction}

In this paper we show that learning based realizability (see Aschieri and Berardi \cite{Aschieri}) relates to 1-Backtracking Tarski games as intuitionistic realizability (see Kleene \cite{Kleene}) relates to Tarski games. It is well know that Tarski games (see, definition \ref{definition-TarskiGame} below) are just a simple way of rephrasing the concept of classical truth in terms of a game between two players - the first one trying to show the truth of a formula, the second its falsehood - and that an intuitionistic realizer gives a winning recursive strategy to the first player. The result is quite expected: since a realizer gives a way of computing all the information about the truth of a formula, the player trying to prove the truth of that formula has a recursive winning strategy. However, not at all \emph{any} classically provable arithmetical formula allows a winning recursive strategy for that player; otherwise, the decidability of the Halting problem would follow. In \cite{Coquand}, Coquand introduced a game semantics for Peano Arithmetic such that, for any provable formula , the first player has a recursive winning strategy, coming from the proof of . The key idea of that remarkable result is to modify Tarski games, allowing players to correct their mistakes and backtrack to a previous position. Here we show that  learning based realizers have direct interpretation as winning recursive strategies in 1-Backtracking Tarski games (which are a particular case of Coquand games see \cite{BerCoq} and definition \ref{definition-1BacktrackingGames} below). The result, again, is expected: interactive learning based realizers, by design, are similar to strategies in games with backtracking: they improve their computational ability by learning from interaction and counterexamples in a convergent way; eventually, they gather enough information about the truth of a formula to win the game. 

An interesting step towards our result was the Hayashi realizability \cite{Hayashi1}. Indeed, a realizer in the sense of Hayashi  represents a recursive winning strategy in 1-Backtracking games. However, from the computational point of view,  realizers do not relate to 1-Backtracking games in a significant way: Hayashi winning strategies work by exhaustive search and, actually, do not learn from the game and from the \emph{interaction} with the other player. As a result of this issue, constructive upper bounds on the length of games cannot be obtained, whereas using our realizability it is possible. For example, in the case of the 1-Backtracking Tarski game for the formula , the Hayashi realizer checks all the natural numbers until an  such that  is found; on the contrary, our realizer yields a strategy which bounds the number of backtrackings by , as shown in this paper. In this case, the Hayashi strategy is the same one suggested by the classical \emph{truth} of the formula, but instead one is interested in the constructive strategy suggested by its classical \emph{proof}.

Since learning based realizers are extracted from proofs in  (Heyting Arithmetic with excluded middle over existential sentences, see \cite{Aschieri}), one also has an interpretation of classical proofs as learning strategies. Moreover, studying  learning based realizers in terms of 1-Backtracking games also sheds light on their behaviour and offers an interesting case study in program extraction and interpretation in classical arithmetic. 

The plan of the paper is the following. In section \S \ref{calculusandrealizability}, we recall the calculus of realizers and the main notion of interactive learning based realizability. In section \S \ref{gamesrealizability}, we prove our main theorem: a realizer of an arithmetical formula embodies a winning strategy in its associated 1-Backtracking Tarski game. In section \S \ref{examples}, we extract realizers from two classical proofs and study their behavior as learning strategies. In section \S \ref{completeness}, we define an extension of our realizability and formulate a conjecture about its completeness with respect to 1-Backtracking Tarski games.



\section{The Calculus  and Learning-Based Realizability}\label{calculusandrealizability}

The whole content of this section is based on Aschieri and Berardi \cite{Aschieri}, where the reader may also find full motivations and proofs. We recall here the definitions and the results we need in the rest of the paper.\\
The winning strategies for 1-Backtracking Tarski games will be represented by terms of  (see \cite{Aschieri}).  is a system of typed lambda calculus which extends G\"odel's system  by adding symbols for non computable functions and a new type  (denoting a set of states of knowledge) together with two basic operations over it. The terms of  are computed with respect to  a state of knowledge, which represents a finite approximation of the non computable functions used in the system. 

For a complete definition of  we refer to Girard \cite{Girard}.  is simply typed -calculus, with atomic types  (representing the set  of natural numbers) and  (representing the set  of booleans), product types  and arrows types , constants , , , pairs , projections , conditional  and primitive recursion  in all types, and the usual reduction rules  for , . From now on, if  are terms of  with  we denote provable equality in . If , the numeral denoting  is the closed normal term  of type .  All closed normal terms of type  are numerals. Any closed normal term of type  in  is  or .

We introduce a notation for ternary projections: if , with  we respectively denote the terms , , .
If , then  in  for . We abbreviate  with . 

\begin{definition} [States of Knowledge and Consistent Union]\label{definition-StateOfKnowledge}\begin{enumerate}
\item
A -ary {\em predicate} of  is any closed normal term  of .

\item
An atom is any triple , where  is a -ary predicate of , and  are  numerals, and  in .

\item
Two atoms ,  are {\em consistent} if  and  in  imply .


\item
A state of knowledge, shortly a {\em state}, is any finite set  of pairwise consistent atoms.

\item
Two states  are consistent if  is a state.

\item
 is the set of all states of knowledge.
\item
The {\em consistent union}  of  is  minus all atoms of  which are inconsistent with some atom of .
\end{enumerate}
\end{definition}
For each state of knowledge  we assume having a unique constant  denoting it; if there is no ambiguity, we just assume that state constants are strings of the form , denoting a state of knowledge. We define with  the extension of  with one atomic type  denoting , and a constant  for each , and {\em no} new reduction rule. Computation on states will be defined by a set of algebraic reduction rules we call ``functional''.

\begin{definition}[Functional set of rules]\label{definition-functional}
Let  be any set of constants, each one of some type , for some . We say that  is a {\em functional set of reduction rules} for  if  consists, for all  and all closed normal terms  of , of exactly one rule , where  is a closed normal term of .
\end{definition}
We define two extensions of : an extension  with symbols denoting non-computable maps  (for each -ary predicate  of ) and no computable reduction rules, another extension , with the computable approximations  of , and a computable set of reduction rules.  and  are intended to represent respectively the oracle mapping  to the truth value of ,  and a Skolem function mapping  to an element  such that  holds iff .  We use the elements of  to represent non-computable realizers, and the elements of  to represent a computable ``approximation'' of a realizer. We denote terms of type  by .




\begin{definition} \label{definition-TermLanguageL1}
Assume  is a -ary predicate of . We introduce the following constants:
\begin{enumerate}

\item

and
.

\item
 and .

\item
 (we denote  with ). 

\item
 and .

\end{enumerate}
\begin{enumerate}
\item
 is the set of all constants .

\item
 is the set of all constants .

\item
.

\item
A term  has state  if it has no state constant different from .
\end{enumerate}
\end{definition}
Let . We interpret  and  respectively as a ``guess'' for the values of the oracle and the Skolem map  and  for , guess computed w.r.t. the knowledge state denoted by the constant .  There is no set of computable reduction rules for the constants , and therefore no set of computable reduction rules for . If  denotes the states , we  interpret  as denoting the consistent union  of .  denotes the map constantly equal to the empty state .  denotes the empty state  if we cannot add the atom  to , either because  for some numeral , or because .  denotes the state  otherwise. We define a system  with reduction rules over  by a functional reduction set .

\begin{definition}[The System ] \label{definition-EquationalTheoryL1}
Let   be state constants denoting the states . Let  be an atom.  is the following functional set of reduction rules for :
\begin{enumerate}
\item
If , then
 and , else
 and .

\item

\item
 if either  for some numeral  or , and  otherwise.

\end{enumerate}

We define .
\end{definition}
\textbf{Remark.}  is nothing but  with some ``syntactic sugar''.   is strongly normalizing, has Church-Rosser property for closed term of atomic types and:


\begin{proposition}[Normal Form Property for ]\label{proposition-normalform} Assume  is either an atomic type or a product type. Then any closed normal term  of type  is: a numeral , or a boolean , or a state constant , or a pair .
\end{proposition}



\begin{definition} Assume  and   is a state constant. We call ``approximation of  at state '' the term  of  obtained from  by replacing each constant  with , each constant  with , each constant  with .
\end{definition}




 If  are state constants denoting , we write  for . We say that a sequence  of state constants is a weakly increasing chain of states (is w.i. for short), if  for all .

\begin{definition}[Convergence]
\label{definition-Convergence} Assume
that  is a w.i. sequence of state constants,
and .
\begin{enumerate}

\item
   converges in  if  in .

\item
 converges if  converges in every w.i. sequence of state constants.
\end{enumerate}
\end{definition}
Our realizability semantics relies on two properties of the non computable terms of atomic type in . First, if we repeatedly increase the knowledge state , eventually the value of  stops changing. Second, if  has type , and contains no state constants but , then we may effectively find a way of increasing the knowledge state  such that eventually we have . 
\begin{theorem}[Stability Theorem] \label{theorem-StabilityTheorem}
Assume  is a closed term of atomic type  (). Then  is convergent.
\end{theorem}

\begin{theorem}[Fixed Point Property]\label{Fixed Point Property}
Let  be a closed term of  of state , and . Define  if , and .
\begin{enumerate}
\item
For any , define  and . There are ,  such that ,  and .
\item
We may effectively find a state constant  such that .
\end{enumerate}
\end{theorem}


\begin{definition}[The language  of Peano Arithmetic] \label{definition-extendedarithmetic} 

\begin{enumerate}

\item
The terms of  are all , such that  and  for some .

\item
The atomic formulas of  are all , for some  {\em closed term of }, and some terms  of .


\item
The formulas of  are built from atomic formulas of  by the connectives  as usual.
\end{enumerate}


\end{definition}


\begin{definition}[Types for realizers]
\label{definition-TypesForRealizers} For each
arithmetical formula  we define a type  of  by
induction on :
,
,
,
,
,

\end{definition}
We define now our notion of realizability, which is relativized to a knowledge state , and differs from Kreisel modified realizability for a single detail: if we realize an atomic formula, the atomic formula does not need to be true, unless the realizer is equal to the empty set in .
\begin{definition}[Realizability]
\label{lemma-IndexedRealizabilityAndRealizability}
Assume  is a state constant,  is a closed term of state ,  is a closed formula, and . Let .

\begin{enumerate}
\item
 if and only if  in  implies



\item
 if and only if  and 

\item
  if and only if either  in  and , or  in  and 

\item
 if and only if for all , if ,
then 

\item
 if and only if for all numerals ,

\item

 if and only for some numeral ,  in  and 
\end{enumerate}
We define  if and only if  for all state constants .
\end{definition}

\begin{theorem}\label{Realizability Theorem}
If  is a closed formula provable in  (see \cite{Aschieri}), then there
exists  such that .
\end{theorem}



\section{Games, Learning and Realizability}\label{gamesrealizability}
\label{section-GamesLearningandRealizability}

In this section, we define the notion of game, its 1-Backtracking version andTarski games. We also prove our main theorem, connecting learning based realizability and 1-Backtracking Tarski games. 

\begin{definition}[Games]
\label{definition-Games}
\begin{enumerate}

 \item
 A \emph{game}  between two players is a quadruple ,
where  is a set,  are  subsets of  such that
, where  is the domain of ,  and  is a set of sequences,
possibly infinite, of elements of .  The elements of  are
called \emph{positions} of the game; ,  are the transition
relations respectively for player one and player two:
 means that player  can legally move from the
position  to the position .

 \item We define a \emph{play} to be a walk, possibly infinite, in the
graph , i.e. a sequence, possibly void,   of elements of   such that  for every . A play of the form  is said to \emph{start from}  . A play is said to be
\emph{complete} if it is either infinite or is equal to  and .  is required to be a set of
complete plays. If  is a complete play and , 
we say that player one wins in . If  is a complete play and , 
we say that player two wins in .

 \item
 Let  be the set of finite plays. Consider a function ; a play  is said to be
-correct if  for every  such that


 \item
 A \emph{winning strategy} from position  for player one is a function
 such that every complete
-correct play   belongs to .
 \end{enumerate}
 \end{definition}
 \textbf{Notation.}  If for   we have that  is a finite sequence of elements of length ,  with  we denote the sequence  where  denotes the -th element of the sequence . \\\\
 Suppose that  is a play of a game ,
representing, for some reason, a bad situation for player one (for
example, in the game of chess,  might be a configuration of
the
chessboard in which player one has just lost his queen). Then,
learnt the lesson, player one might wish to erase some of his moves
and come back to the time the play was just, say,  and
choose, say,  in place of ; in other words, player one
might wish to \emph{backtrack}. Then, the game might go on as
 and, once again, player one might want to
backtrack to, say, , with , and so
on... As there is no learning without remembering, player one
must keep in mind  the errors made during the play. This is the
idea
of 1-Backtracking games  (for more motivations, we refer the reader to \cite{BerCoq} and \cite{BerLig}) and here is our definition. 

\begin{definition}[1-Backtracking Games]
\label{definition-1BacktrackingGames} Let
 be a game.

\begin{enumerate}

\item
We define  as the game , where:\\
\item  is the set of finite plays of \\

\item   and  
\item  is  the set of finite complete plays  of
 such that .
\end{enumerate}
\end{definition}
\textbf{Note.} The pair  in the definition above of  codifies a {\em backtracking move} by player one (and we point out that  might be the empty sequence).\\
\textbf{Remark.} Differently from \cite{BerCoq}, in which both players are allowed to backtrack, we only consider the case in which only player one is supposed do that (as in \cite{Hayashi1}). It is not that our results would not hold: clearly, the proofs in this paper would work just as fine for the definition of 1-Backtracking Tarski games given in \cite{BerCoq}. However, as noted in \cite{BerCoq}, any player-one recursive winning strategy in our version of the game can be effectively transformed into a winning strategy for player one in the other version the game. Hence, adding backtracking for the second player does not increase the computational challenge for player one.
 Moreover, the notion of winner of the game given in \cite{BerCoq} is strictly non constructive and games played by player one with the correct winning strategy may even not terminate. Whereas, with our definition, we can formulate our main theorem as a program termination result: whatever the strategy chosen by player two, the game terminates with the win of player one. This is also the spirit of realizability and hence of this paper: the constructive information must be computed in a finite amount of time, not in the limit. \\
 
 
 
In the well known Tarski games, there are two players and a formula
on the board. The second player - usually called Abelard - tries to
show that the formula is false, while the first player - usually
called Eloise - tries to show that it is true. Let us see the
definition.

\begin{definition}[Tarski Games]
\label{definition-TarskiGame} Let  be a closed
implication and negation free arithmetical formula of . We define the
Tarski
game for  as the game , where:
\begin{enumerate}

\item
 is the set of all subformula occurrences of ; that is,  is the smallest set of formulas such that, if either  or  belongs to , then ; if either  or  belongs to , then  for all numerals . \\

\item
 is the set of pairs  such that     and ,  or  and either  or
;\\

\item
 is the set of pairs  such that   and ,  or  and  or
;\\

\item
 is the set of finite complete plays  such that
.
\end{enumerate}
\end{definition}
\textbf{Note.} We stress that Tarski games are defined only for implication and negation free formulas. Indeed, , when  contains implications, would be much more involved and less intuitive (for a definition of Tarski games for every arithmetical formula see for example Berardi \cite{Ber2}).\\


What we want to show is that if ,
 gives to player one a recursive winning strategy in
. The idea of the proof is the following. Suppose we play as player one. Our strategy is relativized to a knowledge state and we start
the game by fixing the actual state of knowledge as .
Then we play in the same way as we would do in the Tarski game. For
example,  if there is  on the board and
 is chosen by player two, we recursively play the
strategy given by ; if there is  on the
board, we calculate  and play
 and recursively the strategy given by . If there is  on the board, we calculate , and according as to whether it equals  or , we play the strategy recursively given by  or .
If there is an atomic formula on the board, if it is true, we win; otherwise we extend the current state with the state , we backtrack and play with respect to the new state of knowledge and trying to keep as close as possible to the previous game.
Eventually, we will reach a state large enough to enable our
realizer to give always correct answers and we will win. Let us consider first an example and then the formal definition of the winning strategy for Eloise.\\


\textbf{Example ()}. Given a predicate  of , and its boolean negation predicate  (which is representable in ), the realizer  of  
  is defined as 
According to the rules of the game , Abelard is the first to move and, for some numeral , chooses the formula


Now is the turn of Eloise 
and she plays the strategy given by the term


Hence, she computes  (by definition \ref{definition-EquationalTheoryL1}), so she plays the formula 

and Abelard chooses  and plays 


If , Eloise wins. Otherwise, she plays the strategy given by 

So, the new knowledge state is now  and she backtracks to the formula


Now, by definition \ref{definition-EquationalTheoryL1},  and she plays the formula


calculates the term 
plays  and wins.\\\\
\textbf{Notation.} In the following, we shall denote with upper case letters 
closed arithmetical formulas, with lower case letters 
plays of  and with upper case letters   plays of
 (and all those letters may be indexed by numbers). To avoid confusion with the plays of , plays of 1Back() will be denoted as  rather than . Moreover, if , then  will denote the sequence .

 \begin{definition}\label{adaptrealizer}
 Fix  such that . Let   be a finite play of
 starting with . We define by induction on the length of
 a term  (read as `the realizer adapt
to ')  in the following way: \begin{enumerate} 
\item If , then
. \item If  and
, then . 
\item If  and ,
then . 
\item  If 
and , then . 
\item If
 and , then
.\end{enumerate}
 Given a play  of , we set
.

\end{definition}

\begin{definition}\label{adaptstate}
 Fix  such that . Let  be as in definition \ref{adaptrealizer} and  be a finite play of  starting with . We
define by induction on the length of  a state  (read
as  `the state associated to ') in the following way:
\begin{enumerate} 
\item If , then .
\item If  and , then
.
 \item If  and  and , then if , then
, else .\end{enumerate}

\end{definition}

\begin{definition}[Winning strategy for 1Back()]\label{definition-winningstrategy}
Fix  such that . Let  and  be respectively as in definition \ref{adaptrealizer} and \ref{adaptstate}. We define a function  from the set of finite plays of
 to set of finite plays of ;  is intended
to be a recursive winning strategy from  for player one in .
 \begin{enumerate} 
 \item If ,
 and ,
then 

 \item If  and ,
then if  then  else 

 \item If  is atomic, ,  and , then  where  is equal to the smallest
 such that  and either
 
or    
or  If such  does not exist, we set .
\item
In the other cases, .
\end{enumerate}

\end{definition}

 \begin{lemma} \label{preservationlemma}
 \label{lemma-Completenessof1Backtracking}Suppose  and  as in definition \ref{definition-winningstrategy}. Let  be a finite
-correct play of  starting with , , . If
, then . \end{lemma}
\textit{Proof.} By a straightforward induction on the length of
.

  \comment{
\textit{Proof.} See the full version of this paper \cite{Aschierifull}.
By a straightforward induction on the length of
.
 \begin{enumerate}

  \item If , then .\\
  
  \item If , then let . By
definition of , . Since 
is -correct and , we have  and so
. Moreover, by definition of ,
; by induction hypothesis, ;
so, .\\

   \item If , then let
. By definition of ,
. Since  is -correct and
, we have  and so . Moreover, by definition
of , ; by induction hypothesis, ; so, .
The other case is analogous.\\


  \item
 If ,
then let . By definition of , . By definition of ,
; by induction hypothesis, ; hence, .\\

  \item
 If , then let
. By definition of , . By definition of , ; by induction hypothesis,
; hence, . The other case is analogous.\\

 \item
 If , ,  atomic, then . Furthermore, if 
and  , then . Let
, for . We prove by
induction on  that , and hence the thesis.
If , then .\\ If ,
by induction hypothesis , for every . If either  or , then
either  and , or
 and : in both cases, we have
, since . Therefore, by definition of  and  and the -\emph{correctness} of , the remaining possibilities are that either
, , , with ; or
, ,  and
 if and only if ; in both cases,  we
have . \end{enumerate}
 \qed
}


\begin{theorem}[Soundness Theorem] Let  be a closed negation and implication free arithmetical formula. Suppose that  and consider the game
. Let  be as in definition \ref{definition-winningstrategy}. Then  is a recursive winning strategy from  for player one. \end{theorem}
\textit{Proof.} The theorem will be proved in the full version of this paper. The idea is to prove it by contradiction, assuming there is an infinite -correct play. Then one can produce an increasing sequence of states. Using theorems \ref{theorem-StabilityTheorem} and \ref{Fixed Point Property}, one can show that Eloise's moves eventually stabilize and that the game results in a winnning position for Eloise. 


\comment{
\textit{Proof.}  We begin by showing that there is no infinite
-correct play.\\ Let  be, for the
sake of contradiction, an infinite -correct play, with
. Let  be the \emph{longest} play of  such that there exists  such that for every
,  is of the form .  is well defined, because:   is of the form  for every ;  the length of  is at most the degree of the formula ; the sequence of maximum length is unique because any two such sequences are one the prefix of the other, and therefore are equal. Moreover,  let  be the infinite increasing sequence
of all indexes  such that  is of the form  and
 (indeed, 
must be infinite: if it were not so, then there would be an index
 such that for every , , violating the assumption on the maximal length of
). , if not atomic, is a disjunction or an
existential statement.\\ Let now 
and
. For every , , by definition of .
There
are three cases:

 1) . Then, by the Stability Theorem (Theorem \ref{theorem-StabilityTheorem}), there exists
 such that for every , if , then . Let , where . So let  such that ; then   Moreover, by hypothesis, and since 
  
 for some  and : contradiction, since 
where  , whilst  should hold, by definition of .

2) . This case is totally analogous to the preceding.

 3)  is atomic. Then, for every , . So, for every ,  and  hence, by Theorem \ref{Fixed Point Property} there
exists  such that  . But , by Lemma \ref{preservationlemma}; hence,  must equal , and so it is
impossible that : contradiction.\\
Let now  be a
complete finite -correct play.  must equal 
, with  atomic and : otherwise,
 wouldn't be complete, since player one would lose the play  in  and hence would be allowed to backtrack by definition \ref{definition-1BacktrackingGames}.\\
\qed }




 
\section{Examples}
\label{examples}
\comment{
\textbf{Example ( and  formulas).} Suppose
, with  atomic. Let  be the
smallest natural number such that  is a
fixed point of . We have  and so
, where .
Since ,  must be true. Hence, here
is the algorithm (in pseudo code) to find the witness for :\\ \\;\\ repeat  until
;\\
return \\ Suppose now . Then, given , . So we can apply the algorithm for 
formulas. Hence, the extracted algorithm is the following:\\
;\\ ;\\ repeat 
until
;\\ return \\
}

\textbf{Minimum Principle for functions over natural numbers.} The
minimum principle states that every function  over natural
numbers has a minimum value, i.e. there exists an 
such that for every  . We can prove
this principle in , for any  in the language. We assume , but, in order to
enhance readability, we will write  rather than the obscure
. We define:\\ \\ \\ \\ Then we formulate - in equivalent form - the
minimum principle as:  The informal argument goes as follows. As base case of the induction, we just observe that , implies   has a minimum value (i.e. ). Afterwards, if , we are done, we have find the minimum. Otherwise, , and hence  for some  given by the oracle. Hence  and we conclude that  has a minimum value by induction hypothesis. 

 Now we give the formal proofs, which are natural deduction trees, decorated with terms of , as formalized in \cite{Aschieri}. We first prove
that
 holds.

\def\proofSkipAmount{\vskip-2ex plus.1ex minus.1ex}
\begin{prooftree}
\small
\AxiomC{}
\UnaryInfC{}


                   \AxiomC{}
                   \noLine
                   \UnaryInfC{}
                   \noLine
                   \UnaryInfC{}


                                        \AxiomC{}
                                        \noLine
                                       \UnaryInfC{}
                                       \noLine
                                        \UnaryInfC{}

\TrinaryInfC{}
\UnaryInfC{}
\UnaryInfC{}
\UnaryInfC{}
\end{prooftree}where  the term  is looked at later,  is the proof

\def\proofSkipAmount{\vskip0ex plus.1ex minus.1ex}\begin{prooftree}
\small
\AxiomC{}
                   \AxiomC{}
                   \BinaryInfC{}
                   \UnaryInfC{}
\end{prooftree}
and  is the proof

\def\proofSkipAmount{\vskip-3ex plus.1ex minus.1ex}
\begin{prooftree}
\small
\AxiomC{}
                                        \AxiomC{}

                                        \AxiomC{}
                                        \UnaryInfC{}
                                         \UnaryInfC{}
                                        \BinaryInfC{}
                                        \BinaryInfC{}
\end{prooftree}
We prove now that 
\def\proofSkipAmount{\vskip-4ex plus.1ex minus.1ex}
 \begin{prooftree}
\small
 \AxiomC{}

 \AxiomC{}
 \UnaryInfC{}

 \UnaryInfC{}
 \UnaryInfC{}
                \AxiomC{}
                \UnaryInfC{}
 \BinaryInfC{}
 \UnaryInfC{}
 \BinaryInfC{}
 \UnaryInfC{}
 \end{prooftree}
Therefore we can conclude with the induction rule that  And now the thesis:


\def\proofSkipAmount{\vskip-1ex plus-1ex minus.1ex} \begin{prooftree}
\small
\AxiomC{}
\UnaryInfC{}
                  \AxiomC{}
                  \UnaryInfC{}
\BinaryInfC{}
\end{prooftree}

 Let us now take a closer look to . We have defined 
 Let  be a state and let us consider , the realizer of , in the base case of the recursion and after in its general form during the computation: . If ,  
If , we have two other cases. If , then 
If , then 
In the first case, the minum value of  has been found. In the second case, the operator , starting from , recursively calls itself on ; in the third case, it reduces to its normal form. From these equations, we easily deduce the behavior of
the realizer of .   In a pseudo imperative programming
language, for the witness of  we would write:\\
\\
\\
\\
 \\
Hence, when , we have, for some numeral  

It is clear that   is the
minimum value of , according to the partial information provided by

about , and that . If  is sufficiently complete, then 
is the true minimum of .\\
The normal form of the realizer  of  is so simple that we can immediately extract the winning strategy  for the 1-Backtraking version of the Tarski game for .
Suppose the current state of the game is . If , Eloise chooses the formula

and wins. If , she chooses 


If Abelard chooses , she wins, because she responds with , which holds. Suppose hence Abelard chooses  and then . If it holds, Eloise wins. Otherwise, she adds to the current state 

 and backtracks to  and then plays again. This time, she chooses 
 
 
 (using , which was Abelard's counterexample to the minimality of  and is smaller than her previous choice for the minimum value). After at most  backtrackings, she wins. \\
 
 
 \textbf{Coquand's Example.} We investigate now an example -  due to
Coquand - in our framework of realizability. We want to prove that
for every function over natural numbers and  for every
 there exists  such that . Thanks to the minimum principle, we can give a very easy
classical proof:
\comment{
\begin{prooftree}
\AxiomC{}
            \AxiomC{}
            \UnaryInfC{}
                  \AxiomC{}
                  \UnaryInfC{}
                  \UnaryInfC{}

                                   \AxiomC{}
                  \BinaryInfC{}
                  \UnaryInfC{}
                  \UnaryInfC{}
                                    \BinaryInfC{}
\BinaryInfC{}
\end{prooftree}}

\def\proofSkipAmount{\vskip-1ex plus.1ex minus.1ex}
\begin{prooftree}
\scriptsize\AxiomC{}
            \AxiomC{}
            \UnaryInfC{}
                  \AxiomC{}
                  \UnaryInfC{}
                  \UnaryInfC{}

                                   \AxiomC{}
                  \BinaryInfC{}
                  \UnaryInfC{}
                  \UnaryInfC{}
                                    \BinaryInfC{}
\BinaryInfC{}
\end{prooftree}
The extracted realizer is  where  is the realizer of .
 is a point the purported minimum value  of  is attained at, accordingly to the information in the state  (i.e. ). So, if Abelard chooses


Eloise chooses


 We have to
consider the term   which updates the current state .  Surely,
.   is equal either
to 
or to .
 So,
what does 
actually do? We have:

with either  or 
So   tests if ; if it is not the
case, Eloise wins, otherwise she enlarges the state , including the information
 and backtracks to . Starting from the state ,
after  backtrackings, it will be reached a state , which will
be of the form 
and Eloise will play . Hence, the extracted
algorithm for Eloise's witness is the following:\\\\
; while  do ; return ;

\section{Partial Recursive Learning Based Realizability and Completeness}\label{completeness}

In this section we extend our notion of realizability and increase the computational power of our realizers, in order to be able to represent any partial recursive function and in particular, we conjecture, every recursive strategies of 1-Backtracking Tarski games. So, we choose to add to our calculus a fixed point combinator , such that for every term , . 

\begin{definition}[Systems  and  ]
We define  and  to be, respectively, the extensions of  and  obtained by adding for every type  a constant  of type  and a new equality axiom  for every term .

\end{definition}

Since in  there is a schema for unbounded iteration, properties like convergence do not hold anymore (think about a term taking a states  and returning the largest  such that  ). So we have to {\em ask} our realizers to be convergent. Hence, for each type  of  we define a set   of
terms  which we call the set of {\em stable terms} of
type . We define stable terms by lifting the notion of
convergence from atomic types (having a special case for the atomic
type , as we said) to arrow and product types.


\begin{definition}[Convergence]
\label{definition-Convergence2} Assume
that  is a w.i. sequence of state constants,
and .
\begin{enumerate}

\item
   converges in  if there exists a normal form  such that  in .

\item
 converges if  converges in every w.i. sequence of state constants.
\end{enumerate}
\end{definition}

\begin{definition}[Stable Terms]
\label{definition-StableTerms} Let
 be a w.i. chain of states and . Assume  is a
type. We define a set  of terms
 of type , by induction on .
\begin{enumerate}

\item


\item


\item


\item


\item

\end{enumerate}

If , we say that  is a {\em stable} term of type
.
\end{definition}

Now we extend the notion of realizability with respect to  and .


\begin{definition}[Realizability]
\label{lemma-IndexedRealizabilityAndRealizability2}
Assume  is a state constant,  is a closed term of state ,  is a closed formula, and . Let .

\begin{enumerate}
\item
 if and only if  in  implies



\item
 if and only if  and 

\item
  if and only if either  in  and , or  in  and 

\item
 if and only if for all , if ,
then 

\item
 if and only if for all numerals ,

\item

 if and only for some numeral ,  in  and 
\end{enumerate}
We define  if and only if  for all state constants .
\end{definition}

The following conjecture will be addressed in the next version of this paper:

\begin{theorem}[Conjecture]
Suppose there exists a recursive winning strategy for player one in . Then there exists a term  of  such that .

\end{theorem}

\section{Conclusions and Further work}

The main contribution of this paper is conceptual, rather than technical, and it should be useful to understand the significance and see possible uses of learning based realizability. We have shown how learning based realizers may be understood in terms of backtracking games and that this interpretation offers a way of eliciting constructive information from them. The idea is that playing games represents a way of challenging realizers; they react to the challenge by learning from failure and counterexamples. In the context of games, it is also possible to appreciate the notion of convergence, i.e. the fact that realizers stabilize their behaviour as they increase their knowledge. Indeed, it looks like similar ideas are useful to understand other classical realizabilities (see for example, Miquel \cite{Miq}). 

A further step will be taken in the full version of this paper, where we plan to solve the conjecture about the completeness of learning based realizability with respect to 1Backtracking games. As pointed out by a referee, the conjecture could be interesting with respect to a problem of game semantics, i.e. whether all recursive innocent strategies are intepretation of a term of PCF.






\begin{thebibliography}{99}

\comment{\bibitem{Aschierifull} F.Aschieri, \emph{Interactive Learning Based Realizability and 1Backtracking Games}(Full Version), ( \texttt{http://www.di.unito.it/aschieri/1Back.pdf })}
\bibitem{Aschieri} F. Aschieri, S. Berardi,
\emph{Interactive Learning-Based Realizability for Heyting Arithmetic with }, to appear in Logical Methods in Computer Science, 2010 (preprint: \texttt{http://arxiv.org/abs/1007.1785 })



\bibitem{Ber2} S. Berardi, \emph{Semantics for Intuitionistic Arithmetic Based on Tarski Games with Retractable Moves.} TLCA 2007

\bibitem{BerLig}S. Berardi, U. De' Liguoro, \emph{Toward the interpretation of non-constructive reasoning as non-monotonic learning}, Information and Computation, vol 207, issue 1, 2009
\bibitem{BerCoq}S. Berardi, T. Coquand, S. Hayashi,
\emph{Games with 1-Bactracking}, to appear in Annals of Pure and Applied Logic, 2010
(see also GALOP 2005). 



\bibitem{Coquand}T. Coquand,
\emph{A Semantic of Evidence for Classical Arithmetic},
Journal of Symbolic Logic 60, pag 325-337 (1995)


\bibitem{Girard}J.-Y. Girard,
\emph{Proofs and Types},
Cambridge University Press (1989)




\bibitem{Hayashi1}S. Hayashi,
\emph{Can Proofs be Animated by Games?},
Fundamenta Informaticae 77(4), pag 331-343 (2007)


\bibitem{Kleene}S. C. Kleene,
\emph{On the Interpretation of Intuitionistic Number Theory},
Journal of Symbolic Logic 10(4), pag 109-124 (1945)

\bibitem{Miq} A. Miquel, \emph{Relating classical realizability and negative translation for existential witness extraction.} In Typed Lambda Calculi and Applications  (TLCA 2009), pp. 188-202, 2009


\end{thebibliography}







\end{document}
