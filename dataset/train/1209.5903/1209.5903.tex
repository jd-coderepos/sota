\documentclass[orivec]{llncs}

\usepackage{units} 

\usepackage{tikz}
\usetikzlibrary{matrix,arrows}
\tikzstyle{every picture}+=[descr/.style={fill=white,inner sep=2.5pt},node distance=5.5em]
\newcommand{\obj}[3]{\node (#1) [#2] {};}
\newcommand{\arr}[3]{\path[->,font=\scriptsize](#2) edge node[auto] {} (#3);}

\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}

\usepackage{verbatim}

\newcommand{\mC}[1]{\mathtt{#1}}
\newcommand{\mF}[1]{\mathtt{#1}}
\newcommand{\Set}{\mC{Set}}
\newcommand{\Id}{\mF{Id}}
\newcommand{\C}{\mC{C}}
\newcommand{\I}{\mC{I}}
\newcommand{\E}{\mC{E}}
\newcommand{\F}{\mF{F}}
\newcommand{\G}{\mF{G}}
\newcommand{\B}{\mF{B}}
\newcommand{\U}{\mF{U}}
\newcommand{\T}{\mF{T}}
\newcommand{\K}{\mF{K}}
\newcommand{\reach}{\mC{R}}

\newcommand{\id}{\mathit{id}}
\newcommand{\cod}{\mF{cod}}
\newcommand{\dom}{\mF{dom}}

\newcommand{\dialg}{\mathit{Dialg}}
\newcommand{\coalg}{\mathit{Coalg}}

\newcommand{\tr}[1]{\stackrel{#1}{\longrightarrow}}
\newcommand{\utr}{\to}

\newcommand{\Pow}{\mathcal{P}}
\renewcommand{\ker}{\mathit{ker}\,}
\newcommand{\quotient}[1]{_{/_{#1}}}
\newcommand{\N}{\mathbb{N}}
\newcommand{\R}{\mathcal{R}}
\newcommand{\sbb}{\stackrel{\ldotp}{\sim}}
\newcommand{\sbe}{\simeq}


\newcommand{\fn}{\mathit{fn}}

\newcommand{\chan}{\mathcal{C}}



\newcommand{\defend}{}
\newcommand{\proend}{\medskip}


\let\defn\definition
\renewenvironment{definition}{\begin{defn}}{\defend\end{defn}}

\let\thm\theorem
\renewenvironment{theorem}{\begin{thm}}{\defend\end{thm}}

\let\pro\proof
\renewenvironment{proof}{\begin{pro}}{\proend\end{pro}}

\let\cor\corollary
\renewenvironment{corollary}{\begin{cor}}{\defend\end{cor}}

\usepackage{dashrule}

\renewcommand{\arraystretch}{1.8}

\begin{document}

\title{Interaction and observation: categorical semantics of reactive systems trough dialgebras}
\author{Vincenzo Ciancia\thanks{The research leading to these results was partially supported by
the EU FET 7FP Collaborative Project n. 600708 (QUANTICOL), the PAR FAS 2007-2013 (TRACE-IT) project, and the EU 7FP
projects n. 256980 (NESSoS), n. 257930 (Aniketos), n. 295354 (SESAMO).} }
\institute{Istituto di Scienza e Tecnologie dell'Informazione ``A. Faedo''\\ 
Consiglio Nazionale delle Ricerche \\ Pisa, Italy}
\maketitle
\begin{abstract}
We use dialgebras, generalising both algebras and coalgebras, as a complement of the standard coalgebraic framework, aimed at describing the semantics of an interactive system by the means of reaction rules. In this model, interaction is built-in, and semantic equivalence arises from it, instead of being determined by a (possibly difficult) understanding of the side effects of a component in isolation. Behavioural equivalence in dialgebras is determined by how a given process interacts with the others, and the obtained observations. We develop a technique to inter-define categories of dialgebras of different functors, that in particular permits us to compare a standard coalgebraic semantics and its dialgebraic counterpart. We exemplify the framework using the CCS and the -calculus. Remarkably, the dialgebra giving semantics to the -calculus does not require the use of presheaf categories.
\end{abstract}

\section{Introduction}

A system is called \emph{interactive} when its semantics depends upon interaction with a surrounding environment. The semantics does not just yield a value (or not at all), but rather it consists in the denotation of the \emph{behaviour} of the system itself, usually described either by \emph{reaction rules} or by a \emph{labelled transition system} (LTS). The difference is illustrated by the following example, defining a reaction rule for the synchronisation of two parallel processes in a process calculus (the rule on the left) or the LTS  variant (the three rules on the right):

Here  is a process waiting for a signal on channel , whose continuation is . Similarly,  sends a signal on , while  is the parallel composition of two processes. The reaction rule may be read as ``whenever two processes can synchronise, they do, and evolve into the parallel composition of their continuations''. The LTS rules may be read as: ``whenever a process can send or receive a signal, it evolves into its continuation, and has a \emph{side effect} on the environment''. Two processes with complementing side effects interact by the last rule. 



LTSs are widely used for modelling the semantics of interactive systems, since they come equipped with bisimilarity, a form of \emph{behavioural equivalence} that specifies when the semantics of two processes is the same. Coalgebras generalise LTSs and have a standard definition of bisimilarity, coinciding with kernel equivalence of morphisms under mild assumptions. Many formalisms received a coalgebraic treatment. This becomes increasingly harder as the complexity of the calculus grows, depending on the general question of \emph{what are side effects} in a specific calculus. For example, dealing with name allocation in the -calculus requires the use of presheaf categories (see e.g. \cite{ft99}). 



In this work, we seek for a setting where reaction rules are the main object of study, and side effects or labels are not needed at all to define behavioural equivalence.
We
use a generalisation of coalgebras, namely \emph{dialgebras}, to represent a rule system as an object in a category, so that kernel equivalence can be used as a notion of behavioural equivalence.
To appreciate the difference, consider a function . It specifies an LTS with states in  describing, for each state , the non-deterministic choices at , the side effects of each choice, and the resulting state. In LTSs, and coalgebras, elements are observed in isolation. In contrast, an example of a dialgebra is . The value of  is meant to describe the possible (non-deterministic) outcomes of an interaction between  and . Elements are not observed in isolation, but rather their mutual interactions define the semantics.

Categories of dialgebras were first studied under the name of \emph{generalised algebraic categories} (see e.g. \cite{TG69,Ada76}). These structures have been used in computer science for the specification of data types \cite{Hag87,PZ01}. A systematic study of dialgebras, patterned after \cite{Rut00}, was done in \cite{Vou10}. Applications to a compositional calculus for software components were proposed in \cite{CiE11}.  In \cite{Cia11}, we modelled asynchronous process calculi as isolated machines that can be fed with input tokens by an external observer, using dialgebras to generalise \emph{Mealy machines}. In this paper we aim at a more intensional characterisation, tailored to reaction rules, obtained by studying interaction between pairs of systems rather than the relation between their input and output. Our work diverts from previous research, as we take a ``local'' approach. Instead of studying a whole category of dialgebras, 
one just considers objects that are reachable by morphisms from the particular dialgebra being studied.
This approach addresses the issue, previously unsolved, that a final dialgebra fails to exist, so there is no universal semantic domain for the whole class of considered objects. To obviate to this, in \S \ref{sec:dialgebras}, we study the \emph{bisimilarity quotient} of a specific system, showing that it exists under mild conditions. The bisimilarity quotient is sufficient to provide a canonical semantics to an interactive system up-to behavioural equivalence, by the means of a canonical epimorphism. Indeed, a universal model is also useful to compare different systems of the same type. However, this is not typical in coalgebraic program semantics, as different systems have different types, representing different kinds of side effects. In dialgebraic program semantics, just like in the coalgebraic case, working with different systems requires the use of categorical comparisons. In \S \ref{sec:comparing-all}, we develop techniques to do so in the local perspective.










In \S \ref{sec:examples} we provide two examples: the \emph{Calculus of Communicating Systems} and the -calculus. The simplicity of the former allows us to cleanly illustrate our framework, including the comparisons of \S\ref{sec:comparing-all}, used to prove the equivalence of the coalgebraic and dialgebraic semantics. On the other hand, the dialgebraic semantics of the -calculus provides an important insight: using reaction rules, one does not need to understand what are the side effects of programs, as interaction is sufficient to characterise their behaviour. Thus, the semantics of the calculus is given as a dialgebra in , without the need to resort to presheaf categories to describe bisimilarity; but nevertheless, we are able to prove that standard dialgebraic bisimilarity coincides with early bisimilarity. It is also worth notice that the close relationship between the two calculi permits us to define the dialgebra for the -calculus by just changing one rule from the dialgebra for the CCS.  This is possible since both systems can be described by the means of binary \emph{interactions} and non-deterministic \emph{observations}; that is, they use the same functors. We introduce these two simple functors in \S \ref{sec:interaction-and-observation-functors}, together with a characterisation theorem for the associated behavioural equivalence.



\paragraph{Related work.} The most widely known framework for the categorical semantics of reactive systems is the so-called ``\emph{contexts as labels}'' approach \cite{lm00,Sew02,ss03}. Roughly, an LTS is derived from reaction rules adopting unary contexts as labels; bisimilarity of such LTS serves as behavioural equivalence.
Nevertheless, \emph{minimal} contexts need to be carefully selected in order to obtain a sensible equivalence relation; the obtained semantics depends on this choice, and is not directly specified by the reaction rules themselves. The resulting categorical framework is highly non-trivial.
Dialgebras, in contrast, provide a simple setting in which to study reactive systems. However, compositionality, which is a foundational reason to use contexts as labels, and certainly a desired feature, has not yet been investigated for dialgebras (more on this in the conclusions). For the time being, dialgebras complement algebras and coalgebras, rather than \emph{bialgebras}. 







\section{Dialgebras}
\label{sec:dialgebras}

A coalgebraic semantics can be interpreted as the discerning power of an \emph{observer} that can see all the actions done by a process. In contrast,  \emph{dialgebras} endow the observer with the ability to \emph{interact} with the system. The passive observer becomes an entity which runs \emph{experiments} and \emph{observes} the results. By this change of point of view, we can represent e.g. input as an experiment in which the observer feeds a system with a value \cite{Cia11}, or we can represent interaction as a binary experiment involving two processes as we do in the current paper.

We restrict all our definitions to the category , but indeed the theory of dialgebras can be developed in any category.

\begin{definition}\label{def:dialgebra} Given two functors , a -\emph{dialgebra} is a pair  where  is the \emph{carrier set} or \emph{underlying set} and  is a function. A -dialgebra homomorphism from  to  is a function  such that , as depicted in Figure \ref{fig:dialgebra-homomorphism}. Dialgebras and their homomorphisms form the category .
\end{definition}

\begin{figure}
	\begin{center}
		\begin{tikzpicture}
			\obj{X}{}{X}
			\obj{Y}{below of = X}{Y}
			
			\arr{h}{X}{Y}
			 
			\obj{FX}{right of = X}{\F X}
			\obj{BX}{right of = FX}{\B X}
			\obj{FY}{below of = FX}{\F Y}
			\obj{BY}{right of = FY}{\B Y}
			
			\arr{\F h}{FX}{FY}
			\arr{\B h}{BX}{BY}
			\arr{f}{FX}{BX}
			\arr{g}{FY}{BY}
	    \end{tikzpicture}
	\end{center}
	\caption{A dialgebra homomorphism.} \label{fig:dialgebra-homomorphism}
\end{figure}



Roughly,  is the syntax of experiments, of which the function  is the semantics, yielding a set of elements in a type of observed results . The crucial feature of dialgebras is that, since they form a category, they have a standard notion of equivalence coming from kernels of morphisms. Notice that dialgebras conservatively extend algebras () and coalgebras ().

\begin{definition}\label{def:dialgebraic-bisimilarity}
	Given a -dialgebra , \emph{dialgebraic bisimilarity}  is defined by . 
\end{definition}
\medskip

Notice that in Definition \ref{def:dialgebraic-bisimilarity} we use the kernel of  as a function. Thus, we do not require kernels (pullbacks of a function with itself) in . The ``extensional'' definition that we provide is applicable to any kind of dialgebra (independently from  and ), and it avoids the machinery of relation liftings (which are used in \cite{PZ01}). We now study epi-mono factorisations of dialgebras. 

\begin{proposition}\label{prop:epi-mono-factorisations}
	If  and  preserve monos whose domain is empty, the category  has unique epi-mono factorisations. Otherwise, it has epi-mono factorisations of morphisms whose domain does not have an empty carrier.
\end{proposition}

Proposition \ref{prop:epi-mono-factorisations} guarantees that bisimilarity is determined by the  epimorphisms.  
In coalgebras, the kernel of the unique morphism into the final object (if any) coincides with bisimilarity. For simple functors , e.g., , even when  is bounded, a final dialgebra does not exist\footnote{A final dialgebra still exists when  preserves the terminal object \cite{Vou10}. However, this makes the category of dialgebras not very interesting, as the final dialgebra has just one element, thus all the elements of any system are bisimilar.}.

\begin{example}\label{exa:lack-of-final-dialgebra}
Let  and  (the finite power set of ). Suppose there is a final dialgebra . Consider the dialgebra  where  if ,  if , and . Consider the final map . Here we get to a contradiction:  restricted to  must be the identity, therefore injective and surjective. To see this, consider that  embeds into  by the identity function, and that the identity of  must factor through such embedding and , by finality. Thus, there is  such that . Then  is not a dialgebra homomorphism: we have , while .
Intuitively, the element  behaves differently from every other element of , but  ought to encompass all the possible behaviours, which is a contradiction.
Similarly, for any , define the dialgebra ,  if . Since  is arbitrary, and no different elements are bisimilar, the cardinality of a final dialgebra is unbounded.
\end{example}

Final semantics is a well-established way to define behavioural equivalence of systems. 
In the absence of a final object in , we can still define behavioural equivalence by reasoning in terms of quotients of a system. Recall that a \emph{quotient} of an object  in a category is the canonical representative of an equivalence class of epimorphisms from , under the equivalence relation  if and only if there is an isomorphism  such that . In , the quotients of an object form a set. 

\begin{definition}
 The \emph{bisimilarity quotient} of a dialgebra  is the wide pushout  (if it exists) of the cone of \emph{quotients} of  in . We call the diagonal  the \emph{canonical map} of .
\end{definition}

\begin{proposition}\label{pro:bisimilarity-equivalence}
	Let  be the bisimilarity quotient of  and  the canonical map. For all ,  is bisimilar to  if and only if . Therefore, when the bisimilarity quotient exists, bisimilarity is an equivalence relation.
\end{proposition}

When the bisimilarity quotient exists, the canonical map can be considered the semantics of a system. Although  is canonical, it is not necessarily the unique : bisimilarity classes may be interchangeable in dialgebras. 

\begin{example}Consider the dialgebra  defined in Example \ref{exa:lack-of-final-dialgebra}; the dialgebra has no non-trivial quotients, so it coincides with its bisimilarity quotient. However all the isomorphisms of the carrier set are dialgebra homomorphisms. The bisimilarity classes are the same, but for the identity of the sole element of each class. 
\end{example}

For a different example, in the semantics of a symmetric process calculus such as the \emph{pure} variant of CCS, the bisimilarity classes of an element, and of the element obtained by replacing all the input or output actions in it with the complementary ones, can be interchanged.


Clearly, when a final object exists, the epi-mono factorisation of the final morphism yields the bisimilarity quotient. A bisimilarity quotient may exist also in the absence of a final object. Here is a sufficient condition.



\begin{proposition}\label{pro:existence-bisimilarity-quotients}
	When  preserves wide (small) pushouts of epimorphisms, that is, colimits of an arbitrary small cone of epis, the bisimilarity quotient exists.
\end{proposition}

The dialgebraic semantics of CCS in \S \ref{sec:CCS-dialgebra} is an example where the bisimilarity quotient exists, but there is no final dialgebra (by Example \ref{exa:lack-of-final-dialgebra}).

\section{Interaction and observation}
\label{sec:interaction-and-observation-functors}

In this section we introduce two functors  and  that can be used to give dialgebraic semantics to interactive, non-deterministic calculi.

\begin{definition}\label{def:int-and-obs-functors}
	The \emph{interaction} and \emph{observation} functors are defined as  and , respectively.
\end{definition}

As elements of  and  are syntactically disjoint, we use them to denote elements of , avoiding labels for the coproduct. An element of  is either , representing an experiment about a process in isolation, or , an experiment where two processes are allowed to interact. Elements of  are sets of processes, that are the possible non-deterministic outcomes of an experiment. We write  and  for  and , respectively.


\begin{proposition}\label{pro:int-obs-epi-mono-bisim-quotient}
	The functors  and  preserve monos from the empty set.  preserves wide pushouts of epis. Therefore  has epi-mono factorisations, and each dialgebra in the category has a bisimilarity quotient.
\end{proposition}

\noindent Theorem \ref{thm:bisimilarity-back-and-forth} provides a characterisation of bisimilarity in .


\begin{theorem}\label{thm:bisimilarity-back-and-forth}
 Let  be an -dialgebra. An equivalence relation  is the kernel of  for some , , , if and only if, for all  and , we have: , and, . As a corollary, the bisimilarity quotient of  is the largest such relation.
\end{theorem}




\section{Comparing dialgebras}\label{sec:comparing-all}



Categories of algebras or coalgebras of different functors may be compared by mapping one category into the other by composition with an appropriate natural transformation \cite{Rut00}. In \S \ref{sec:comparing-categories} we generalise this technique to dialgebras (of which algebras and coalgebras are special cases). The problem has first been studied in \cite{Vou10}. Here we improve on it by adding an intermediate ``container'' functor , whose role is crucial, e.g., for \S \ref{sec:ccs-comparison}. In \S \ref{sec:specific-comparisons} we discuss the limitations of this method in the setting of dialgebras, and refine the construction.

\subsection{Comparing categories of dialgebras}
\label{sec:comparing-categories}


Consider  endofunctors . One can specify functor  using  and two natural transformations  and , as illustrated by the diagram in Figure \ref{fig:natural-in-set}.
\begin{figure}
\begin{center}
\begin{tikzpicture}
	\obj{F1X}{}{\F'X}
	\obj{F1Y}{below of = F1X}{\F'Y}
	\obj{GFX}{right of = F1X}{\G \F X}
	\obj{GFY}{right of = F1Y}{\G \F Y}
	\obj{GBX}{right of = GFX}{\G \B X}
	\obj{GBY}{right of = GFY}{\G \B Y}
	\obj{B1X}{right of = GBX}{\B'X}
	\obj{B1Y}{right of = GBY}{\B'Y}
	
	
	\arr{\F' h}{F1X}{F1Y}
	\arr{\G \F h}{GFX}{GFY}
	\arr{\G \B h}{GBX}{GBY}
	\arr{\B' h}{B1X}{B1Y}
	
	\arr{\lambda_X}{F1X}{GFX}
	\arr{\lambda_Y}{F1Y}{GFY}
	\arr{\mu_X}{GBX}{B1X}
	\arr{\mu_Y}{GBY}{B1Y}
	\arr{\G f}{GFX}{GBX}
	\arr{\G g}{GFY}{GBY}
	
	\obj{FX}{right of = B1X}{\F X}
	\obj{FY}{below of = FX}{\F Y}
	\obj{BX}{right of = FX}{\B X}
	\obj{BY}{right of = FY}{\B Y}
	
	\arr{\F h}{FX}{FY}
	\arr{\B h}{BX}{BY}
	\arr{f}{FX}{BX}
	\arr{g}{FY}{BY}
	
	\obj{X}{left of = F1X}{X}
	\obj{Y}{below of = X}{Y}
	
	\arr{h}{X}{Y}
\end{tikzpicture}	
\end{center}
\caption{Comparing categories of dialgebras using natural transformations.}\label{fig:natural-in-set}
\end{figure}

Notice that dialgebras come equipped with the ``underlying set'' or ``forgetful'' functor  defined as , ; this allows us to state that  is \emph{concrete}.

\begin{theorem}{\label{thm:general-comparisons}}
	Two natural transformations  and  determine a functor  as , .  is concrete, that is: . 
\end{theorem}	
	
As a consequence of  being concrete, we have the following corollary.

\begin{corollary}
	If  are bisimilar in  then they are so in .
\end{corollary}

\subsection{Comparing dialgebras}
\label{sec:specific-comparisons}

The framework of \S \ref{sec:comparing-categories} is more restrictive than necessary. Observe that  and  have to be defined for each set . But when comparing say, two different semantics of a language, we are only interested in the two dialgebras, and in the objects that may be reached from them by an epimorphism. Considering this subclass of objects, in the definition of  and , we could use specific features of a given dialgebra (e.g. exploit the fact that the underlying set  is the carrier of an algebra, or refer to specific elements of ).
In this light, we now restrict our attention to natural transformations between functors whose codomain is , but whose domain is not. The framework appears complicated at first; however, Theorem \ref{pro:nat-uniquely-determined} allows us to specify such natural transformations by single functions, called \emph{bisimulation invariants}, that serve as an ``adaptation layer'' between dialgebras of different type.
Although proofs in this section require quite a bit of categorical reasoning, defining a bisimulation invariant is not a difficult task by itself and encapsulates the complexity of the framework in a simple definition. We shall support this claim in \S \ref{sec:ccs-comparison}, which proves equivalence of the dialgebraic and coalgebraic semantics of CCS. 



Let  be the subcategory of epimorphisms of . Given a dialgebra , consider the coslice category . Its objects are arrows in  whose domain is . Its arrows are commuting morphisms of . Our framework is parametrised by a full subcategory of  having the following properties.

\begin{definition}\label{def:reach}
	Let  be a full subcategory of , such that:
for each object  of  there is at least one object  of  with a commuting arrow ;
the identity  is an object.
\end{definition}


By the first condition,  contains enough epimorphisms to characterise bisimilarity: whenever  and  are identified by a morphism , there is  in the category that identifies them. The second condition embeds the object  into . The purpose of  is to serve as a domain for functors into , so that natural transformations between them may be more specific, while preserving bisimilarity of the object . A natural transformation in this setting may make explicit reference to . Notice that the maps composing such a natural transformation depend on dialgebra morphisms, not objects, by definition of . Using a \emph{subcategory} of  further relaxes proof obligations; e.g., in Proposition \ref{prop:invariants-CCS} we only consider morphisms whose kernels are congruences with respect to the parallel operator. 
The following definition casts  endofunctors into functors from  to .
\begin{definition}\label{def:lifting} For each , define its \emph{lifting}  as , where  is the codomain functor, mapping objects (arrows in ) to their codomains, and arrows to themselves.
\end{definition}

Spelling out the definition,  acts on objects as  and on arrows as . 
Next, we prove that natural transformations indexed by  may be specified by single functions, obeying to a condition that we call \emph{bisimulation invariance}. Notice that, since  is a full subcategory containing the identity of a coslice category, each arrow  can be regarded as both an object of  and an arrow in the same category from  to  itself. In the following, we refer to the arrow as  to avoid confusion.
\begin{definition}\label{def:invariant}
Given two functors , consider a function . Call  \emph{bisimulation invariant with respect to  and  from   to } if and only if, for all  , and for each arrow  in , we have . 
\end{definition}

In the following we call  simply \emph{invariant} when , ,  and  are clear from the context. Such a property of a function may seem difficult to prove. However, it is actually easier to show invariance of a given function with respect to the lifted versions of two functors, than naturality of a transformation in  between the same functors. One needs to prove commutativity just for a given class of morphisms (those in ), which are also guaranteed to preserve and reflect bisimilarity. The fundamental property of invariants is Theorem \ref{pro:nat-uniquely-determined}, that depends on  preserving epis. This holds for the lifting  of a  endofunctor, as all  endofunctors preserve epis, and so do  and  used in Definition \ref{def:lifting}. 

\begin{theorem}\label{pro:nat-uniquely-determined}
	Consider two functors , with  preserving epis. There is a one-to-one correspondence between natural transformations  and invariants from  to . Each natural transformation  is uniquely determined by , which is invariant; conversely, for each invariant  there is a unique natural transformation  such that .
\end{theorem}

We can restate Theorem \ref{thm:general-comparisons} in terms of natural transformations  between functors from  to ; this is described by the diagram in Figure \ref{fig:natural-in-reach-X-f}.
\begin{figure}
\begin{center}
	\begin{tikzpicture}[node distance=8em]		
		\obj{F1X}{}{\bar{\F'}(\id) = \F' X}
		\obj{F1Y}{below of = F1X}{\bar{\F'}(h) = \F' Y}
		\obj{GFX}{right of = F1X}{\G \bar{\F} (\id) = \G \F X}
		\obj{GFY}{below of = GFX}{\G \bar{\F} (h) = \G \F Y}
		\obj{GBX}{right of = GFX}{\G \bar{\B} (\id) = \G \B X}
		\obj{GBY}{below of = GBX}{\G \bar{\B} (h) = \G \B Y}
		\obj{B1X}{right of = GBX}{\bar{\B'}(\id) = \B' X}
		\obj{B1Y}{below of = B1X}{\bar{\B'}(h) = \B' Y}
		
		
		\arr{\bar{\F'} h = \F' h}{F1X}{F1Y}
		\arr{\G \bar{\F} h = \G \F h}{GFX}{GFY}
		\arr{\G \bar{\B} h = \G \B h}{GBX}{GBY}
		\arr{\bar{\B'} h = \B' h}{B1X}{B1Y}
		
		\arr{\lambda_{\id}}{F1X}{GFX}
		\arr{\lambda_h}{F1Y}{GFY}
		\arr{\mu_{\id}}{GBX}{B1X}
		\arr{\mu_h}{GBY}{B1Y}
		\arr{\G f}{GFX}{GBX}
		\arr{\G g}{GFY}{GBY}
		
	\end{tikzpicture}	
\end{center}
\caption{Comparing dialgebras using functors from  to . 	Here  is .} \label{fig:natural-in-reach-X-f}
\end{figure}	

\begin{theorem}\label{thm:specific-comparisons}
	Given an -dialgebra , a category  as in Definition \ref{def:invariant}, a functor , and two invariants  from  to ,  from  to , consider the -dialgebra  where . Whenever two elements are bisimilar in , then they are bisimilar in . 
\end{theorem}

\section{Examples}
\label{sec:examples}
\subsection{The coalgebraic semantics of CCS}
\label{sec:CCS-coalgebra}

The \emph{Calculus of Communicating Systems} (CCS) is a simple process calculus, formalising a fundamental aspect of computation: \emph{communication} between parallel processes. In the \emph{pure} variant only \emph{synchronisation} is considered, that is, the exchanged data is not taken into account.
We briefly recall the LTS (thus, coalgebraic) semantics of CCS here. The interested reader may refer to \cite{Mil82} for more details.
The syntax is described by the grammar: 

where  is a finite set, and  ranges over a countable set of channels . Elements of  are \emph{processes}, or \emph{agents}. Elements of  are \emph{atomic actions}, or \emph{prefixes}, or \emph{guards}.  CCS features operators for denoting: \emph{parallel composition} (); \emph{restriction} of a channel  which becomes private to  ();  non-deterministic \emph{guarded choice} among a finite set of action-prefixed processes (), usually written as . Special cases of the choice construct are the empty process  which is the sum of zero processes, and the action prefix , which is the sum of one process. Notice that choice is commutative by construction. The actions  are: the \emph{internal step} (); the act of \emph{receiving} a signal on channel  (the action ); \emph{sending} a signal on a channel (). We omit recursion for simplicity; including it does not change the presented results.
Channels are also called \emph{names}. \emph{Free} names  are defined by induction, as usual, for processes and labels. The only binding construct is , in which name  is \emph{bound}.
In the following, let  be the set of CCS processes. 

\begin{definition}\label{def:structural-congruence}
\emph{Structural congruence} is the minimal congruence  including -conversion of  in ; commutative monoid axioms for the parallel operator with respect to ; the equations , ,  for all , ,  and . 
\end{definition}

The labelled transition system for CCS is presented in Figure \ref{fig:CCS-LTS}. The set  of labels is just the set of prefixes . We write  as a shorthand for .
An LTS with labels from  can be represented as a pair  where  is a function\footnote{Here  is the \emph{(co-variant) power set} of . In coalgebras it is typical to assume a cardinality bound on the size of the subsets, as the functor  does not have a final coalgebra. Indeed, in all the systems we define,  can be replaced by a bounded variant, as all our transition sets are finite or countable. Since we do not use the final coalgebra in this paper, the distinction is immaterial here.}
from  to .  Let  be the LTS for CCS.
\begin{figure}
	\begin{center}
			{\small 
				 }
	\end{center}
	\caption{The LTS describing the operational semantics of CCS.}\label{fig:CCS-LTS}
\end{figure}


\begin{definition}\label{def:CCS-bisimilarity} CCS bisimilarity is the greatest symmetric relation  such that, if  and , there is  such that  and . 
\end{definition}

Notice that we are defining bisimilarity in one specific system (e.g. CCS), not between states of different systems. This corresponds to a standard categorical notion once recognised that LTSs are -coalgebras.

\begin{definition}
	Given a functor , a -coalgebra is a pair  where  is a set. A homomorphism of coalgebras from  to  is a function  such that . -coalgebras and their morphisms form the category .
\end{definition}

\begin{definition}\label{def:coalgebraic-bisimilarity}
	Given a -coalgebra , \emph{coalgebraic bisimilarity}  is defined by . 
\end{definition}

It is well-known that under suitable conditions on  (that the functor for LTSs respects) bisimilarity as in Definition \ref{def:coalgebraic-bisimilarity} coincides with other coalgebraic notions (see e.g. \cite{Sta11}). We do not discuss the details, but we note that for LTSs and the one for CCS in particular, the relations from Definition \ref{def:CCS-bisimilarity} and \ref{def:coalgebraic-bisimilarity} coincide.

\subsection{A dialgebraic semantics of CCS}
\label{sec:CCS-dialgebra}

In \S \ref{sec:CCS-coalgebra}, we have seen the coalgebraic semantics of CCS.
Now we describe it as an -dialgebra for the functors of Definition \ref{def:int-and-obs-functors}.

\begin{definition}\label{def:CCS-dialgebra}
Let  be the set of CCS processes. The dialgebra  for CCS is the least function obeying to the rules in Figure \ref{fig:CCS-dialgebra}.
\end{definition}

\begin{figure}
\begin{scriptsize}
 \begin{centering}
              
  \hdashrule[0.2ex]{.4\textwidth}{.3pt}{3mm}   
              
     \hdashrule[0.2ex]{.4\textwidth}{.3pt}{3mm}   
     
  \end{centering}
\end{scriptsize}
\caption{The dialgebra for CCS.}\label{fig:CCS-dialgebra}
\end{figure}
	
We briefly comment on the rules. The first group deals with processes in isolation: rule  permits internal computation actions to be executed; Rule  allows a process in the scope of a restriction to progress; Rule  allows one component in a parallel composition to progress independently from the others;  Rule  allows any possible interaction between two processes to also happen between internal components of a process in isolation.

The second group of rules defines the semantics of interaction. Rule  permits interaction between a process  in the scope of a restriction, and any other process , provided that  is not known by . Recall that the restricted name  can always be -converted to one which is fresh in . Rule  allows parallel components of a process  to interact with  independently from each other. Rule  implements synchronisation between two processes.

Rules , ,  simplify the definition; alternatively, one can add variants of the other rules taking into account the effects of these three schemes.





\subsection{Comparing the coalgebraic and dialgebraic semantics of CCS}
\label{sec:ccs-comparison}

In this section, we use Theorem \ref{thm:specific-comparisons} to compare the semantics for CCS from Definition \ref{def:CCS-dialgebra} to bisimilarity in the well-known labelled transition system. 

First, we attempt to give some intuition on the constructions of \S\ref{sec:comparing-all}. Consider defining a coalgebra  for the functor of \S \ref{sec:CCS-coalgebra} out of the dialgebra for CCS of \S \ref{sec:CCS-dialgebra}. We can employ ``witness processes'' such as  in experiments such as . For each  , we let  contain the labelled transition . The idea sounds promising, but in the process we need to refer to specific elements of , namely the witness processes, thus to the specific set  of elements. Natural transformations are not allowed to depend upon an object in this way; therefore, we need the the theory of \S \ref{sec:comparing-all}.


The dialgebra of \S \ref{sec:CCS-dialgebra} describes processes as they interact, with no explicit notion of side effect. The coalgebra of \S \ref{sec:CCS-coalgebra} describes processes in isolation, and their side effects.
It is not difficult to imagine how the two kinds of semantics can be compared. In one direction, starting from the coalgebra, we may define a -dialgebra on the same carrier; for processes in isolation, we run one step of the LTS, and then turn all the  transitions into observed results; for interaction between pairs of elements, we run one step of the LTS on each element, and let interaction happen whenever an input (or an output) is matched by the complementing action. In the other direction, starting from the dialgebra, we may define a -coalgebra, by letting  transitions correspond to the observations that are made on a process in isolation, and by running experiments in which we let a process and a ``witness process'' such as  interact. The resulting transitions are labelled with a corresponding action, e.g.,  in our case. 

In the rest of the section we closely implement the above plan. From now on, we let , , and the functors  be the dialgebra and the coalgebra for CCS, and the functors from \S \ref{sec:interaction-and-observation-functors}; we let . Below, we define three invariants , , , that we shall use to instantiate Theorem~\ref{thm:specific-comparisons} twice. In one direction, we will define the coalgebra  out of the dialgebra . In the other direction, we will get the dialgebra  from .

\begin{definition}\label{def:CCS-invariants}
	We define , ,  as:
	
\end{definition}

Notice how the definition of  uses the fact that  is also the carrier of the initial algebra, therefore the parallel composition  is defined. An appropriate choice of  makes  an invariant. Also, the definition of  uses specific elements of , such as . On the other hand,  is independent of  and extends to a natural transformation from  to .

\begin{proposition}\label{prop:invariants-CCS}
 Let  be the subcategory of  of epis whose domain is , and  the subcategory of  of epis whose domain is .
 	Let  be the coslice , and  be the full subcategory of  whose objects  commute with the parallel operator, that is, . Then:
\begin{itemize}	
        \item  obeys to Definition \ref{def:reach};

	\item  is invariant for  and  from  to ; 
	
	\item  is invariant for  and  from  to ; 
	
	\item  is invariant for  and  from  to ; 
	
	\item  is invariant for  and  from  to .  
\end{itemize}
\end{proposition}


In Proposition \ref{prop:invariants-CCS},  contains only homomorphisms that commute with the parallel operator, strengthening the hypothesis for invariance, which facilitates the proof.
We can now use Theorem \ref{thm:specific-comparisons}, twice. Let ; we obtain the -dialgebra  where . Similarly, let ; then we derive the -dialgebra, that is, -coalgebra,  with .

\medskip

So far, we have mapped the dialgebra of CCS into a coalgebra, and the coalgebra into an -dialgebra. However, no link is established between  and , or  and  . We conclude the paper by proving coincidence of the two semantics. For this, we need the following lemma. 

\begin{lemma}\label{lem:transition-reaction}
	For all channels  and elements , the following holds:
; 
; 
; 
. 
\end{lemma}

\begin{proposition}\label{pro:equal}
	Let  and  be the dialgebra and the coalgebra for CCS. We have that  and . Therefore, bisimilarity in  and in  is the same.
\end{proposition}


\subsection{The -calculus}



The -calculus \cite{mpw92} is a very well known extension of CCS. The calculus takes network mobility into account by the means of fresh name generation and communication. Bisimilarity in the -calculus is non-standard, since it requires side conditions on freshness of names that do not permit one to compare labels just syntactically. A coalgebraic semantics is possible by switching from the category  to presheaves (see e.g. \cite{ft99}). In this section we provide a dialgebraic semantics to the calculus. Remarkably, the dialgebra we define lives in ; the difference from the semantics of CCS is just to add data passing in the rule for synchronisation.
We give a very brief summary of the calculus here. The reader may consult e.g., \cite{San01} for further information. The -calculus features data passing, and fresh name creation. Channels and data coincide, giving to the calculus its expressive power. The syntax is as follows.

Again, we do not introduce recursion, as it does not add to the presentation and complicates proofs.  In the syntax,  range over a countable set of \emph{channel names}.
The prefix  reads  from channel . Therefore,  is bound in . The prefix  sends  on channel . The other constructs have the same informal meaning as in the CCS, and share the same syntax.  We adopt the \emph{early} semantics of the calculus. For space reasons, we omit the definition of the corresponding transition system, which is widely available (see e.g. \cite{San01}, Definition 1.3.2). We just mention that the transitions may have four kinds of labels: , , , , corresponding to silent actions, output of  on channel , input of  on , and \emph{bound output}, where  is a fresh name. Synchronization with a process doing bound output may only take place when  is fresh in the receiving process, which is obtained by -conversion of .

The close syntactic resemblance between CCS and the -calculus is reflected in the dialgebraic semantics we propose, as we only need to change one rule to switch from one semantics to the other. The formal definition uses structural congruence, which is the same as Definition \ref{def:structural-congruence},  with the addition of -conversion of variable  for processes under the scope of an input .

\begin{definition}
Let  be the set of -calculus terms. Define the -dialgebra  importing the rules of Definition \ref{def:CCS-dialgebra}, where Rule  is replaced by 

\end{definition}
Rule  models data passing in the usual way. Combined with Rule , it implicitly handles \emph{scope extrusion}, which is one of the most difficult bits of the -calculus semantics. For example, for  fresh in , we have , by first applying  and then . Such a simple treatment of scope extrusion is inherited from the reactive system for the -calculus that we are mimicking (see \cite{San01}, Definition 1.2.12). The dialgebraic definition adds to it a non-trivial notion of bisimilarity, that we ought to relate to the standard definition. A direct comparison, as in \S \ref{sec:ccs-comparison}, is not obvious, as the coalgebraic semantics lives in a presheaf category, whereas the dialgebraic semantics is defined in . However, we are able to reuse well known results for the -calculus to obtain a characterisation theorem. Dialgebraic semantics is easier to compare to \emph{strong barbed equivalence}, defined below, than to bisimilarity. We use the \emph{observability predicate} , for  in the form  or , that holds whenever  can perform a communication action  or , respectively. In turn, strong barbed equivalence is defined in terms of \emph{strong barbed bisimilarity}.

\begin{definition}\label{def:pi-strong-barbed}
\emph{Strong barbed bisimilarity} is the largest symmetric relation  such that whenever , , and  with . 
We say that processes  and  are \emph{strong barbed equivalent}, written , if for all , .
\end{definition}


\begin{theorem}\label{thm:pi-calculus-characterization}
 Dialgebraic bisimilarity coincides with strong barbed equivalence.
\end{theorem}

Finally, Theorem 2.2.9 in \cite{San01} proves that strong barbed equivalence coincides with strong early bisimilarity\footnote{Therein, it is shown that the \emph{matching} prefix of the -calculus is not required for this result to hold, thus we omit it for simplicity.}. Thus, as a corollary, we get that dialgebraic bisimilarity coincides with early bisimilarity.


\noindent 









\section{Conclusions and future work}

The most important difference between coalgebras and dialgebras is that there is no final dialgebra, therefore no universal model. This forces one to reason in terms of quotients. The locality which is intrinsic to the definition of a dialgebra deserves in our opinion a more thorough investigation in various directions.

A fundamental problem is to spell out an inductive definition principle, in order to obtain simpler definitions, and compositionality. A conjecture on how to generalise the use of distributive laws \cite{tp97} from bialgebras to dialgebras has been formulated in \cite{Blo12}, and will be developed in future work.  

Logical aspects should also be considered. The interplay between adequate logics for dialgebras, and equational logic on terms, may lead to new insights on algebraic and coalgebraic specifications. 

Another matter is the implementation and verification of dialgebras. Coalgebras have an associated partition refinement procedure that computes the bisimilarity quotient of a system, by the means of iteration along the terminal sequence of the functor . A generalisation of this procedure to dialgebras appears in \cite{Blo12}, and will be explained and enhanced in future work.

Finally, an open question is the definition of a proof principle for dialgebras, generalising induction and coinduction.

\bibliographystyle{splncs}
\small{\vskip -20pt \bibliography{reactive.bib}}

\appendix

\section{Proofs}


\begin{proof}(Proposition \ref{prop:epi-mono-factorisations})
	Consider a dialgebra homomorphism  and the diagram of Figure \ref{fig:dialgebra-homomorphism}. First notice that the epimorphisms in  are just the epimorphisms in  that are dialgebra morphisms.
	Since  has epi-mono factorisations, we can factor every arrow  in the diagram, including  itself, as  where  is epic, and  is monic. Call  the codomain of . We are going to endow  with a dialgebra structure  so that  is a dialgebra morphism from  to . 
	
	Since all set functors preserve all epis, and all monos except possibly those with an empty domain, assume that either  and  preserve the monos with an empty domain, or that . In the latter case,  as there are no arrows whose codomain is the empty set. Thus,  epic, and  monic. Then by uniqueness of epi-mono factorisations,  is the epi-mono factorisation of . Similarly  is the unique factorisation of . Consider the pushout  of , , and the injection . There is an unique commuting arrow . Call  the diagonal of the pushout. All the arrows we mentioned except  are epi. Similarly, consider the pullback  of , . There is a unique commuting arrow . Also consider the projection  of the pullback, and the diagonal . All the arrows in 
this sub-diagram except  are mono. We have two morphisms  and  that commute with the outer square, therefore they are equal. Now factor  and . Then  with  epi. Also  with  mono. Therefore we have two epi-mono factorisations  of the arrow , thus there is an isomorphism . The composite  is an arrow from  to . It is easy to see that  is a dialgebra homomorphism from  to . Commutativity is by diagram chasing, and uniqueness by  epi.
\end{proof}


\begin{proof}(Proposition \ref{pro:bisimilarity-equivalence})
    If  then  and  are bisimilar by definition. Conversely, given a homomorphism  such that , by epi-mono factorisations we can assume  is epic ( is certainly non-empty since we assume an element ); w.l.o.g. assume  is a quotient (as bisimilarity is the same in a class of isomorphic epis). Thus, there is an epi  such that , thus . As bisimilarity is the kernel of a morphism, it is an equivalence.
\end{proof}

\begin{proof}(Proposition \ref{pro:existence-bisimilarity-quotients})
  Call  the cocone of epimorphisms from . First, observe that  is a small diagram, that is, its objects and morphisms form sets. This is since the cone of of  in  forms a set , and  can be at most as large as the product  (the possible quotients are as many as the dialgebras whose carrier is a quotient of  in ). Since  is cocomplete, the pushout  of the morphisms in  exists in .  It is not difficult to see that the category of -dialgebras has all colimits that the base category ( in our case) has and  preserves (see Theorem 14 in \cite{Vou10}). Therefore if  preserves wide pushouts, there is a pushout  of  as a diagram in . The carrier is ; the dialgebra map  is the unique commuting morphism from , which is a pushout of all the  for  in , to , that forms a commuting diagram with all the dialgebras that are codomains of morphisms in .
\end{proof}

\begin{proof}(Proposition \ref{pro:int-obs-epi-mono-bisim-quotient})
	 preserves the initial object and  sends it into . Therefore they both preserve the specified monos.  By relying on the fact that all epi split, it is easy to see that  preserves binary pushouts of epis, even though it fails to preserve pushouts in general. Since  also preserves filtered colimits, it preserves wide pushouts of epis. 
\end{proof}




\begin{proof}(Theorem \ref{thm:bisimilarity-back-and-forth})
 For one direction of the proof, let  be the kernel of . First, let , and consider the case . By commutativity we have , thus by definition of , , that is , from which, for the specific  that we introduced, there is a  such that  and , that is, . Similarly, let , with . By commutativity and by definition of  we have . Therefore, there is  such that  with .
 
 For the other direction of the proof, assume a dialgebra , and an equivalence relation  as in the thesis. We shall define a dialgebra  and homomorphism  such that . Let  (the quotient of  by ). Let  denote the equivalence class of , and define , therefore identifying exactly the processes that are equivalent by . To conclude the proof, we need to define a commuting dialgebra. Let  be defined by , . The commutativity requirement on  is now reduced to prove that  and . This follows immediately by the hypotesis on .
\end{proof}

\begin{proof}(Theorem \ref{thm:general-comparisons})
	For all dialgebra morphisms , the diagram in Fig \ref{fig:natural-in-set} commutes. The middle square commutes since  is a dialgebra homomorphism and  is a functor. The left and right ones by naturality of  and . Therefore  is a dialgebra homomorphism from  to .  is concrete by definition and easily checked to be a functor.
\end{proof}

\begin{proof}(Theorem \ref{pro:nat-uniquely-determined})
Consider any object  of . We show that  is uniquely determined by . 
	Consider the commuting square
	\begin{center}
		\begin{tikzpicture}
			\obj{FX}{}{\F (\id_{(X,f)})}
			\obj{FY}{below of = FX}{\F h}
			\obj{DUMMY}{right of = FX}{}
			\obj{GX}{right of = DUMMY}{\G (\id_{(X,f)})}
			\obj{GY}{below of = GX}{\G h}
			\arr{\F \hat h}{FX}{FY}
			\arr{\G \hat h}{GX}{GY}
			\arr{\delta_{\id_{(X,f)}}}{FX}{GX}
\			\arr{\delta_h}{FY}{GY}
	\end{tikzpicture}	
	\end{center} 
Since  is epic, and  preserves epis, a commuting  is uniquely determined by : by commutativity, for all , we have .  If  is invariant, this equation defines a function . Conversely, if  is natural, then  is invariant by definition.
\end{proof}

\begin{proof}(Theorem \ref{thm:specific-comparisons})
Since  and  are invariant, they determine corresponding natural transformations by Proposition \ref{pro:nat-uniquely-determined}. If two elements  and  are bisimilar in , then there is a morphism of -dialgebras  such that . By epi-mono factorisations (Proposition \ref{prop:epi-mono-factorisations}), we can assume w.l.o.g. that  is epic, and by the condition in Definition \ref{def:reach} we can also assume that it is an object of  (formally one sees that there is an object in the subcategory that identifies  and ). Let . Notice that  is an -dialgebra. Consider the diagram in Figure \ref{fig:natural-in-reach-X-f} and the equations therein. These equations hold by Definition \ref{def:lifting}.  The diagram commutes: the middle square since  is a dialgebra homomorphism and  a functor, the left and right ones by naturality of  and . From commutativity of the perimeter, we see that  is also a morphism of -dialgebras from  to , therefore  and  are bisimilar in .
\end{proof}


\begin{proof}(Proposition \ref{prop:invariants-CCS})
	Note that  respects the conditions in Definition \ref{def:reach} because both the required identity and the final coalgebra (that is, the final -dialgebra) are included in it. The result on the identity function being invariant is obvious. 
	
	For , suppose . By definition of , this implies either  or , where .
	
	When , we have . Thus . 
	
	In the other case, we have  where  is a shorthand for the defining condition of the set. Consider the set of pairs .  Under the hypothesis , we have . We shall prove that if this equality holds, then . The equality implies that, for all  such that , there are  such that , and . Therefore, by how we chose the objects of , we have . 
	
	The cases for  and  are handled similarly.
\end{proof}

\begin{proof}(Lemma \ref{lem:transition-reaction}) The proof is a simple induction on the derivation. Notice that the rules dealing with structural congruence permit us to prove equality of the destination states; otherwise this lemma would hold only up-to structural congruence. We only show the most complicated part of the proof, which is the right to left direction of the last case. Suppose  and , so we have finite derivations for these transitions. We construct a finite derivation of  by induction on the sum of the lengths of the two derivations. The base case is when the last rule of both derivations is ; then we can apply Rule  from Figure \ref{fig:CCS-dialgebra} and obtain the thesis. Otherwise, we look at the last step in the derivation of . If either ,  or  from Figure \ref{fig:CCS-LTS} is used, we apply the inductive hypothesis to the transitions in the premises, obtaining a derivation of a transition in the 
dialgebra, and then we conclude the derivation of  either by Rule ,  or  from Figure \ref{fig:CCS-dialgebra}, respectively. For  to be applied correctly, we may assume that all bound names are sufficiently fresh, because of -conversion. When Rule  is the last rule used to derive , we construct the derivation of  by applying Rule , and then by applying the inductive hypothesis (notice that the argument is symmetric in the polarity of a label (input or output).
\end{proof} 


\begin{proof}(Proposition \ref{pro:equal})
	Let us look at equality of  and .  We have . Then, by Lemma \ref{lem:transition-reaction}, this set is equal to . Then it is immediate that .
	For equality of  and , we have , which by Lemma \ref{lem:transition-reaction} is equal to . The binary case is analogous, using the last case of Lemma \ref{lem:transition-reaction}.
\end{proof}



\begin{proof}(Theorem \ref{thm:pi-calculus-characterization})
We need to establish some facts before the main proof. 

\medskip
First, notice that using Theorem 2.2.9 in \cite{San01} and well-known properties of the -calculus (in particular, compositionality under parallel contexts), Definition \ref{def:pi-strong-barbed} can be given a coinductive flavour. The formal statement is as follows. Strong barbed equivalence is the greatest symmetric relation  that falls under the hypothesis:
whenever , we have , and for all , we have .
 To see that  falls under this condition, let  be strong bisimilarity in the -calculus, and observe that  . For the other direction, given , for all , we show that , by definition of , with .

 \medskip 
 \noindent 
 Furthermore, we use the fact that dialgebraic bisimilarity for the -calculus is a congruence with respect to parallel composition: . This is proved by induction on the rules, using Theorem \ref{thm:bisimilarity-back-and-forth}; the most important case of the proof is to see that, when ,  and . This is immediate from Rule  in the semantics.


\medskip 
 \noindent Finally, the proof uses 
a variant of the \emph{harmony lemma} 
(\cite{San01}, Lemma 1.4.15); our statement is  where  is our dialgebraic semantics. The proof of this fact reuses the standard harmony lemma as follows. First assume Lemma 1.4.15 in \cite{San01}, asserting that the reductions in the -calculus (\cite{San01}, Table 1.3) coincide with  transitions. Then show that  can be proved in the dialgebraic semantics if and only if the same reduction can be proved in the standard -calculus reduction system. This is done by a straightforward case analysis.


 
 \medskip 

 \noindent After these preliminary steps, we need to show that  is the same as the bisimilarity quotient  (in the following, just ) of the dialgebra  for the -calculus. We proceed by proving first that  is included in , then the reverse inclusion.


 \noindent First, let us see that  is included in  by using our characterization of . Let us assume . First we look at the ``barbs''. Let , thus  for some  and . 
 Then 
. By Theorem \ref{thm:bisimilarity-back-and-forth},  with . Then . Similarly for the case . 
 
 \medskip
 
 
 \noindent Next, consider an arbitrary process , with . We show  with . One of three possibilities holds: (1)  with ; (2)  with ; (3)  and  synchronize. In Case 1, we have , thus we use compositionality of  with respect to parallel composition. In Case 2, by the harmony lemma, we have , and by Theorem \ref{thm:bisimilarity-back-and-forth},  with . Then by compositionality with respect to parallel composition we get the thesis. In Case 3, we have 
. By Theorem \ref{thm:bisimilarity-back-and-forth} we have  with . Applying Rule  in the definition of the dialgebra, . By the harmony lemma , proving the thesis.
 
 \medskip
 
 \noindent For the second half of the proof, consider , with  . Applying the harmony lemma, , thus there is  such that  and . The thesis follows by the harmony lemma.
 
 \medskip
 \noindent Finally, let , , with . Without loss of generality, assume  is sending data and  is receiving (the other case is symmetric). Let us import notation from \cite{San01}, shortening  as  where  is the set of channels . By induction on the rules, 
it is easy to see that , , with , where, importantly, , , and besides, ``all fresh names are sufficiently fresh'', that is: , , . Notice that we deliberately chose to use  in ; by doing so, under the previous assumptions, we can avoid writing the substitution in  explicitly. By rule  and the harmony lemma, we have , thus by  we have  with . 
Furthermore, , thus  with , similarly  with , therefore . 


 \newcommand{\ndownarrow}{/\hskip -7pt \downarrow}
 
 We need to see that ; we shall do this by proving that  and , with freshness assumptions similar to the ones for  and , and that , . 
 
 For this, we can use barbs and specially crafted contexts.  Let ,  be names that are fresh in all the entities mentioned so far. Consider . Roughly, the parallel component that reads on channel  is used to detect when the name  received on  is equal to . This can also be done using matching, that we did not include precisely because of this property. This idea comes from \cite{San01} (see the remarks before the proof of Theorem 2.2.9).
We have  (where  means that the observable  is not present). Thus by  we have  with , where  is a name (received on channel ) that we want to prove equal to . Indeed, it suffices to observe that in the empty context, by ,  which is only possible if . We also see that . From this, and inspection of the rules of the -calculus, one concludes that  is in the requested form. Similarly for .
\end{proof}

\end{document}
