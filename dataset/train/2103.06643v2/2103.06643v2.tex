\documentclass[final]{cvpr}

\usepackage{times}
\usepackage{graphicx}
\usepackage{epsfig}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{subfigure}
\usepackage{bbding}
\usepackage{booktabs}
\usepackage{lipsum}

\newcommand\blfootnote[1]{\begingroup
  \renewcommand\thefootnote{}\footnote{#1}\addtocounter{footnote}{-1}\endgroup
}

\usepackage{paralist}
\let\itemize\compactitem
\let\enditemize\endcompactitem
\let\enumerate\compactenum
\let\endenumerate\endcompactenum
\let\description\compactdesc
\let\enddescription\endcompactdesc




\usepackage[pagebackref=true,breaklinks=true,colorlinks,bookmarks=false]{hyperref}
\usepackage[ruled]{algorithm2e}

\def\cvprPaperID{2115} \def\confYear{CVPR 2021}


\begin{document}

\title{Deep Graph Matching under Quadratic Constraint}

\author{Quankai Gao, Fudong Wang, Nan Xue, Jin-Gang Yu, Gui-Song Xia\\
Wuhan University, Wuhan, China.\\
South China University of Technology, Guangzhou, China.\\
{\tt\small \{quankaigao, fudong-wang, xuenan, guisong.xia\}@whu.edu.cn},
{\tt\small jingangyu@scut.edu.cn}


}

\maketitle

\blfootnote{The study of this paper is funded by the National Natural Science Foundation of China (NSFC) under grant contracts No.61922065, No.61771350 and No.41820104006 and 61871299. It is also supported by Supercomputing Center of Wuhan University.}
\blfootnote{
Corresponding author: Gui-Song Xia (guisong.xia@whu.edu.cn).}

\begin{abstract}
    Recently, deep learning based methods have demonstrated promising results on the graph matching problem, by relying on the descriptive capability of deep features extracted on graph nodes. However, one main limitation with existing deep graph matching (DGM) methods lies in their ignorance of explicit constraint of graph structures, which may lead the model to be trapped into local minimum in training. In this paper, we propose to explicitly formulate pairwise graph structures as a \textbf{quadratic constraint} incorporated into the DGM framework. The quadratic constraint minimizes the pairwise structural discrepancy between graphs, which can reduce the ambiguities brought by only using the extracted CNN features.
    Moreover, we present a differentiable implementation to the quadratic constrained-optimization such that it is compatible with the unconstrained deep learning optimizer. To give more precise and proper supervision, a well-designed false matching loss against class imbalance is proposed, which can better penalize the false negatives and false positives with less overfitting. Exhaustive experiments demonstrate that our method achieves competitive performance on real-world datasets.
\end{abstract}

\section{Introduction}
Graph matching aims to find an optimal one-to-one node correspondence between graph-structured data, which has been widely used in many tasks~\cite{berg2005shape,brendel2011learning,conte2004thirty,gasse2019exact,jiang2010linear,szeliski2010computer}. By integrating the similarity between nodes and edges in a combinatorial fashion, graph matching is often mathematically formulated as a quadratic assignment problem (QAP)~\cite{loiola2007survey}. QAP is known to be NP-hard~\cite{hartmanis1982computers}, and various approximation techniques~\cite{leordeanu2005spectral,leordeanu2009integer,liu2014graph,schellewald2001evaluation} have been proposed to make it computationally tractable.

\begin{figure}[t!]
\centering
\subfigure[DGM {\em without} quadratic constraint]{
\includegraphics[height=0.25\linewidth, width=0.7\linewidth]{car_noQC.pdf}
\includegraphics[height=0.25\linewidth]{car_noQC_mtx.pdf}
}\\
\vspace{-3mm}
\subfigure[DGM {\em with} quadratic constraint (our method)]{
\includegraphics[height=0.25\linewidth, width=0.7\linewidth]{car_QC.pdf}
\includegraphics[height=0.25\linewidth]{car_QC_mtx.pdf}
}
\caption{Deep graph matching with/without quadratic constraint. Matching results are in left and the predicted (black) {\em v.s.} the ground truth (red) correspondence matrices are in right.}
\vspace{-3mm}
\label{fig:QC}
\end{figure}

\begin{figure*}[t]
\centering
   \includegraphics[width=0.87\linewidth]{pipeline.pdf}
\caption{Overview of our proposed architecture for deep graph matching under quadratic constraint. Node attributes consisting geometric prior and deep features are refined to build the initial node affinity matrix, which is followed by a Sinkhorn layer and then further optimized under quadratic constraint (QC). Loss between the prediction and the ground truth (GT) is calculated by the proposed false matching loss (FM-Loss).}
   \vspace{-3mm}
\label{fig:overview}
\end{figure*}

Until recently, deep graph matching (DGM) methods give birth to many more flexible formulations~\cite{fey2020deep,rolinek2020deep,wang2019learning,yu2020learning} besides traditional QAP. DGM aims to learn the meaningful node affinity by using deep features extracted from convolutional neural network. To this end, many existing DGM methods~\cite{rolinek2020deep,wang2019learning,yu2020learning} primarily focus on the feature modeling and refinement for more accurate affinity construction. The feature refinement step is expected to capture the implicit structure information~\cite{wang2019learning} encoded in learnable parameters.
However, nodes with similar deep features are hard to distinguish from each other in deep graph matching, while their structure contexts may be very different. Moreover, the implicit structure information is not specific enough, which is insufficient to clearly represent the structural discrepancy over graphs ({\em e.g.}, Fig.~\ref{fig:QC}(a)).


In traditional graph matching, it is common to
incorporate pairwise structures into the formulation to enhance matching accuracy~\cite{leordeanu2005spectral}, which inspired us to consider quadratic structural constraint in deep graph matching to maximize the adjacency consensus and achieve global consistency. More precisely, we use the pairwise term of Koopmans-Beckmann’s QAP~\cite{loiola2007survey} as our quadratic constraint to minimize the adjacency discrepancy of graphs to be matched ({\em e.g.}, Fig.~\ref{fig:QC}(b)). To this end, we present a modified Frank-Wolfe algorithm~\cite{lacoste2015global}, which is a differentiable optimization scheme {\em w.r.t.} learnable parameters in our model and the relaxed Koopmans-Beckmann’s QAP.

Another important issue of deep graph matching is class imbalance. Concretely, the result of a graph matching task is usually represented as a permutation matrix, where only a small portion of the entries take the value of one representing the pairs to be matched while the rest are zero-valued, leading to the imbalance between matched and unmatched entries. In case of such class imbalance, it will be problematic to establish the loss function between predicted matching matrices and ground truth matrices by using the conventional cross-entropy-type loss functions (see Section~\ref{subsec:fmloss} for details). To our best knowledge, there is no loss function specifically designed for deep graph matching to take care of the class imbalance issue so far. To this end, we design a novel loss function for deep graph matching, called False Matching Loss, which will be experimentally shown to be better for dealing with class imbalance and overfitting in compared with previous works.

Our main contributions are highlighted as follows:
\begin{itemize}
    \item[-] We explicitly introduce quadratic constraint with our constructed geometric structure into deep graph matching, which can further revise wrong matches by minimizing structure discrepancy over graphs.
    \item[-] We present a differentiable optimization scheme in training to approach the objective such that it is compatible with the unconstrained deep learning optimizer.
    \item[-] We propose a novel loss function focusing on false matchings, {\em i.e.} false negatives and false positives, to better lead the parameter update against class imbalance and overfitting.
\end{itemize}

\section{Preliminaries and Related Work}
For better understanding, this section will revisit some preliminaries and related works on both traditional combinatorial graph matching and deep graph matching.

\subsection{Combinatorial graph matching}
Graph matching aims to build the node-to-node correspondence between the given two graphs  with  and  with , where  we denote as the set of nodes and  as the set of edges. By denoting  as the correspondence matrix indicating the matching between two graphs  and , {\em i.e.},  means the -th node in  matches to the -th node in ,  otherwise, one well-known form of graph matching with combinatorial nature can be written as:

where ,  are adjacency matrices encoding the pairwise information of edges in graphs  and , respectively.  measures the node similarities between two graphs.  is the Frobenius norm. Generally, Eq.~\eqref{eq:KBQAP} can be cast as a quadratic assignment problem called Koopmans-Beckmann's QAP~\cite{loiola2007survey}. One can find more details in \cite{yan2016short}.

In the previous works \cite{gold1996graduated,wfd2020frgm,zhou2015factorized} following this combinatorial graph matching formulation, the node similarity  and adjacency matrices  are usually calculated with some specifically designed handcrafted features like SIFT \cite{lowe2004distinctive}, Shape Context \cite{belongie2002shape}, {\em etc}. And then they will solve the objective functions ({\em e.g.}, Eq.~\eqref{eq:KBQAP}) with different discrete or continuous constrained-optimization algorithms \cite{cho2014finding,wfd2020frgm,egozi2012probabilistic,yan2015discrete}. Until recently, the deep learning based graph matching framework has been developed
consisting of learned features and unconstrained optimizer, which will be detailed in next section.

\subsection{Deep graph matching}
 Recently, many works~\cite{fey2020deep,wang2019learning,wang2020combinatorial,yu2020learning,rolinek2020deep} on deep graph matching have been proposed to take advantages of the descriptive capability of high-dimensional deep features as node or edge attributes, which can collect visual information of background images. As a basic setting of these works, the output of CNN layers  and  are commonly used, denoted as  and ,

where  denotes the input image and  denotes the annotated keypoints. CNN here is a widely used architecture VGG16~\cite{simonyan2014very} initially pretrained on the ImageNet~\cite{russakovsky2015imagenet}. "align" in Eq.~\eqref{eq:ftU} and Eq.~\eqref{eq:ftF} is bi-linear interpolation to approximately assign the output features of a convolution layer to the annotated keypoints on the input image pairs.


Since the extracted raw features are independent with the graph structure, various refinement strategies on the raw features are adopted in deep graph matching trying to implicitly utilize the information of graph structure.
As a typical example of non-Euclidean data, a graph with its node and edge attributes can be processed by graph convolutional network (GCN)~\cite{kipf2016semi} under the message passing scheme to update its attributes. Each node attribute is updated by aggregating its adjacency node attributes so that GCN is expected to implicitly capture the structure contexts of each node to some extent. There are also some works~\cite{rolinek2020deep,yu2020learning} using unary node features to model pairwise edge features for matching.


Deep graph matching asks for the model fully-differentiable so that many combinatorial solvers and methods ({\em e.g.}, Hungarian algorithm~\cite{kuhn1955hungarian} and IPFP~\cite{leordeanu2009integer}) are not recommended. Thus, various relaxation approaches become popular, which refer to the recent progress~\cite{rolinek2020deep,wang2019learning,wang2020learning}.


Under these settings, deep graph matching can be reformulated as maximizing the node affinity based on the extracted features.

 Though many works about deep graph matching have been proposed, there are few thorough discussions about loss functions. The prototype of cross entropy loss has been widely used in deep graph matching, {\em e.g.} permutation loss~\cite{wang2019learning} and its improved version~\cite{yu2020learning}. Instead of directly calculating the linear assignment cost, GMN~\cite{zanfir2018deep} uses ``displacement loss" measuring pixel-wise offset on the image but is shown to have a weaker supervision than cross entropy loss~\cite{wang2019learning}. However, none of the existing works consider the class imbalance that naturally exists in deep graph matching. Besides, overfitting and gradient explosion are always conspicuous on models trained with cross-entropy-type loss functions. For the above reasons, we propose a novel loss function specifically designed for deep graph matching, which not only considers numerical issue but also shows promising performance against overfitting and class imbalance.

\section{DGM under Quadratic Constraint}
We briefly demonstrate our method overview here. As shown in Fig.~\ref{fig:overview}, given the input two images with detected or annotated keypoints as graph nodes, we firstly adopt the CNN features and the coordinates of keypoints to calculate both the initial node attributes and the pairwise structural context as weighted adjacency matrices. By this end, we establish graphs with structural attributes, based on which we explicitly use the weighted adjacency matrices to construct the quadratic constraint, and design a differentiable constrained-optimization algorithm to achieve compatibility with the deep learning optimizer. Since the quadratic constrained-optimization is non-convex and needs a proper initialization, we update the node attributes with weighted adjacency matrices through a GCN module and a differentiable Sinkhorn layer~\cite{adams2011ranking,sinkhorn1967concerning} respectively, to obtain a node affinity matrix between two graphs as the initialization. Finally, the solved optimum will be compared with the ground truth by the proposed false matching loss, which addresses the issue of class imbalance to achieve better performance.

\subsection{Geometric structure for DGM}

{\bf{Unary geometric prior} }
Since our work doesn't focus on deep feature extraction, we follow the previous deep graph matching works to use CNN features described in Eq.~\eqref{eq:ftU} and Eq.~\eqref{eq:ftF}. Moreover, features from different layers of CNN are expected to incorporate both the local and global semantic information of images, we concatenate  and  together as  to be the initial node attributes of two graphs.

Since the extracted raw features associated to nodes only have visual information of local patches, to make raw node attributes more discriminative, we add the the normalized 2D Cartesian coordinate  of each node as , which provides a unary geometric prior that can better describe the locations of nodes as a complement to the CNN features.

{\bf{Pairwise structural context} }
In deep graph matching, the graph construction is usually based on node coordinates and never consider the visual meaningful features of the background image. For this reason, we introduce deep feature weighted adjacency matrices  and  of the two graphs to learn more proper relations among graph nodes, which are defined as

where  are the binary adjacency matrices built on coordinates of nodes in two graphs,   are the above-mentioned node attributes of two graphs,  denotes element-wise product.  can be various commutative function and here we use a linear kernel  for simplicity, where  is the -th row of . As illustrated in Fig.~\ref{fig:cosine}, the geometric meaning of the function  is related to the cosine of the angle between two normalized node attributes, which can be detailed as cos. By this definition, each element of  and  represents the feature distance between the corresponding nodes while preserving the topology constraints provided by  and .
\begin{figure}[t]
\centering
   \includegraphics[width=0.9\linewidth]{cosine.pdf}
   \caption{Illustration of the geometric relationship between two nodes and their edge connection in attribute space. Normalized attributes of nodes are represented as coloured squares.}
\label{fig:cosine}
\vspace{-3mm}
\end{figure}

{\textbf{Attributes fusion with GCN} }
There are many convolutional architectures~\cite{fey2018splinecnn,zhou2018graph} for processing irregular data. As a typical example of non-Euclidean data, a graph with its node and edge attributes can be processed by GCN under the message passing scheme to update its attributes. Each node attribute is updated by aggregating its adjacency node attributes so that GCN is expected to capture the structure contexts of each node in an implicit way. With the above interpretation, we adopt GCN that incorporates both update from neighbors and self-update, which can be written as:

where  denote learnable parameters of GCN at -th layer.  is the activation function. The updated attributes  is then used to update  and  by Eq.~\eqref{eq:adj}.


{\bf{Node affinity} }
Since we have the refined attributes of two graphs, the node affinity  at -th iteration can be built by a learnable metric:

where  is a matrix containing learnable parameters. We then adopt Sinkhorn layer taking  to the set of doubly-stochastic matrices , which is the convex hull of the set of permutation matrices .

\subsection{Quadratic constraint for DGM}
To explicitly utilize the information of graph structures, we formulate the objective as to minimize the pairwise structure discrepancy between the graphs to be matched. As Eq.~\eqref{eq:KBQAP}, Koopmans-Beckmann’s QAP explicitly involves the second-order geometric context in its pairwise term and the optimal solution will minimize the two terms simultaneously. The learnable metric  we obtained from Eq.~\eqref{eq:affinity} is considered as the initial point of , {\em i.e.}, . We rewrite Eq.~\eqref{eq:KBQAP} as:

\begin{algorithm}[t!]
\label{alg1}
\caption{DGM under Quadratic Constraint}
\KwIn{Nodes of graph pairs ;
two input images , where =A, B; the ground truth ; initial parameters }
\KwOut{prediction }

    //feature extraction and alignment\\
    ;\\
    ;\\
    //node attributes\\
      ;\\
    \\
    \For{{\rm epoch }}{
      ;\\
    (  ;\\
      ;\\
      ;\\
    \For{{\rm iter = 1:}}{
     \For{{\rm k = 1:}}{   ;\\
    // is Sinkhorn normalization\\
      ;\\
      ;
    }
      ;
    }
      (, ), ;
    }
    \\
      ;\\
    \For{{\rm iter = 1:m}}{
    \Repeat {{\rm  converges}}{   ;\\
 // is Hungarian algorithm\\
      ;\\
      ;}
      ;}
\end{algorithm}
We specify unary affinity matrix  as the obtained node affinity matrix  in both the training stage and the inference stage.

Due to the paradox between the combinatorial nature of QAP formulation and the differentiable requirement of deep learning framework, we consider a relaxed version of Eq.~\eqref{eq:obj}: . The value of  is continuous and satisfies normalization constraints at the same time. By minimizing the objective function, the solution will close to the ground truth in the direction of minimizing the adjacency inconsistency.

\subsection{Quadratic constrained-optimization}
We adopt a differentiable Frank-Wolfe algorithm~\cite{lacoste2015global} for  to obtain an approximate solution:

where  is a parameter representing the step size. Usually, we set ~\cite{jaggi2013revisiting} in implementation. In training stage,  in Eq.~\eqref{eq:s} and Eq.~\eqref{eq:x} is the Sinkhorn layer to project the positive variable into the set of doubly stochastic matrices , while  is the Hungarian algorithm in the inference stage for obtaining a discrete solution. We write down the gradient of  as:

where . In training stage, the variable  is associated with the learnable parameters  and every iteration of Frank-Wolfe algorithm is actually going with the parameters fixed before backpropagation~\cite{ionescu2015training}. From Eq.~\eqref{eq:xhat} and Eq.~\eqref{eq:x},  is differentiable with respect to  so  is differentiable with respect to  by the recursive relations:

where  is a differentiable function {\em w.r.t.}  in training stage.
Since the goal of the optimization is to utilize the information of the pairwise term in Eq.~\eqref{eq:obj}, only few iterations roughly approaching to a local minimum in training stage can fulfill our purpose. Though there is no guarantee of global minimum, it is actually not necessary because the pairwise term will be noisy with outliers and the global minimum may not be the desired matching. Besides, few iterations in training stage encourage the model to learn a relatively short path to approximate the object so that it is easier to convergence within fewer iterations in inference stage.



\iffalse
Though deep graph matching framework can extract CNN features for matching rather than handcrafted attributes as in traditional QAP formulation, there are two main reasons why CNN features along are not enough for graph matching. Firstly because the spatial resolution of feature map on high level convolution layer is not the same as input image and the features from CNN layers will only be interpolated to the graph nodes as approximation. Secondly because the nodes with similar local patches have the similar CNN features while their structure context may be very different. Although some works~\cite{fey2020deep,rolinek2020deep,yu2020learning} explicitly consider the learned or handcrafted pairwise features as a complement to the unary node features, the problems about CNN features mentioned above can not be avoid. Besides, the refinement step of using GCN is also a compromise because it is essentially a smooth operation over neighbor features of each node and can incorporate the information of graph structure only to a limit extent. Thus far, none of the above parts explicitly involve the structure constraint to maximize the adjacency consensus or minimize the adjacency inconsistency.
\fi

\subsection{False-matching loss}
\label{subsec:fmloss}
 The elements of correspondence matrix can be divided into two classes with clear different meaning, one of which represents matched pairs and the other represents unmatched pairs. Given two graphs with equal number of nodes , there are  elements of correspondence matrix are 1 while the rest  are 0. Under the constraint of one-to-one matching, the unmatched pairs clearly take the majority. Though the values of the soft correspondence matrix are all between 0 and 1, the two classes should be separately treated in the calculation of loss during training.

The cross-entropy-type loss functions such as permutation loss~\cite{wang2019learning} and its improved version~\cite{yu2020learning} achieve the state-of-the-art performance. This type of loss functions directly measures the linear assignment cost between the ground truth  and the prediction  like

with , . Cross entropy loss does not consider the class imbalance in deep graph matching because the vast majority of  are preserved by multiplying  while at most  elements of  are kept by multiplying . Similarly, cross entropy loss with Hungarian attention~\cite{yu2020learning} can not solve this issue either and the so called Hungarian attention in loss function brings discontinuity in learning.
\begin{figure}[t!]
\begin{center}
   \includegraphics[width=1\linewidth]{fmloss.pdf}
\end{center}
   \caption{An illustration of the work flow about our proposed false matching loss. We take both the false positive and false negative of the predicted doubly stochastic matrix into consideration.  and  are two parameters to weight the two terms.}
\label{fig:inner}
\vspace{-3mm}
\end{figure}

 Since the optimization of deep learning is unconstraint, the local minimum with bad properties can not be avoid. Once a bad case or a bad local minimum occurs, {\em e.g.} at least one element of the prediction  approaches to 0 while the corresponding element of the ground truth  is 1, the cross-entropy-type loss will be invalid. Though permutation loss with Hungarian attention mechanism is more focus on a specific portion of the prediction , it only works without severe bad cases either. Even with gradient clipping, overfitting is still a problem to be addressed.
\begin{figure}[t]
\centering
\subfigure[cross entropy loss ]{
\begin{minipage}[t]{0.5\linewidth}
\centering
\includegraphics[width=1.7in]{cross_entropy.pdf}
\end{minipage}}\subfigure[false matching loss ]{
\begin{minipage}[t]{0.5\linewidth}
\centering
\includegraphics[width=1.7in]{false_matching.pdf}
\end{minipage}}\centering
\caption{Comparison between cross entropy loss and false matching loss on a toy example, where  and . We mark the three extreme points of : ,  and . A cooler color means a smaller value. The comparison shows that false matching loss has a higher value than cross entropy loss when it close to the ground truth. Besides, false matching loss has a high but limited value when  close to the extreme points, which are the bad cases for cross entropy loss and make the loss function output infinite values. The curve of cross entropy loss on points between  and  are below the red line connected to  and , while the curve of false matching loss coincides with the red line.}
\label{fig:innercross}
\vspace{-2mm}
\end{figure}

Facing the problems above, we propose a new loss function called false matching loss:

where , .  and  of our false matching loss penalize false positive matches and false negative matches, which are the main indexes describing the false matchings in statistics. To address the issue of class imbalance, we draw on the experience of focal loss~\cite{lin2017focal} and take two hyperparameters  and  for weighting.

As illustrated in Fig.~\ref{fig:innercross}, false matching loss is more smooth and always has a relatively large value than cross entropy loss even when the prediction  is close to the ground truth. While on extreme points that are away from the ground truth, false matching loss will have more proper outputs (high but limited). Besides, the values of cross entropy loss on points between  and  are lower than that on  and , which is not proper because points between  and  are still far away from the ground truth.

Our method is summarized in Algorithm~\ref{alg1}.

\section{Experiments and Analysis}
In this section, we evaluate our method on two challenging datasets.
We compare the proposed method with several state-of-the-art deep graph matching methods:  GLMNet~\cite{jiang2019glmnet}, PCA~\cite{wang2019learning},  NGM~\cite{wang2019neural}, ~\cite{yu2020learning}, GMN~\cite{zanfir2018deep}, LCSGM~\cite{wang2020learning} and BB-GM~\cite{rolinek2020deep}. To compare the proposed false matching loss with the previous work: permutation loss with Hungarian attention~\cite{yu2020learning}, we follow~\cite{yu2020learning} to implement the loss function for the source code is not publicly available. Given graphs with  nodes, the matching accuracy is computed as


Stochastic gradient descent (SGD)~\cite{bottou2010large} is employed as the optimizer with an initial learning rate . In our false matching loss, we set  and . In our optimization step, we set the number of iterations  and  for the consideration of both computational efficiency and convergence.

Since the feature refinement step is not limited to Eq.~\eqref{eq:GCN}, we additionally deploy another novel architecture SplineCNN~\cite{fey2018splinecnn} to replace Eq.~\eqref{eq:GCN} as a comparision with~\cite{rolinek2020deep}. Thus, two versions of our method are provided: qc-DG and qc-DG. In qc-DG, the node attributes are refined by a two-layer GCN as Eq.~\eqref{eq:GCN} with ReLU~\cite{nair2010rectified} activation function. While in qc-DG, the refinement step is done by a two-layer SplineCNN~\cite{fey2018splinecnn} with max aggregation. In our implementation, all the input graphs are constructed by Delaunay
triangulation. Specifically for GMN~\cite{zanfir2018deep}, two input graphs are constructed by fully-connected topology and Delaunay triangulation respectively. While  is another version of GMN that two input graphs are both constructed by Delaunay triangulation.

\subsection{Results on Pascal VOC Keypoints}
Pascal VOC dataset~\cite{everingham2010pascal} with Berkeley annotations of keypoints~\cite{bourdev2009poselets} has 20 classes of instance images with annotated keypoints. There are 7,020 annotated images for training and 1,682 for testing. Before training, each instance is cropped around its bounding box and is re-scaled to  as the input for VGG16. We follow the previous works to filter the truncated, occluded and difficult images. The training process will be performed on all 20 classes. Because of the large variation of pose, scale, and appearance, Pascal VOC Keypoints is considerably a challenging dataset.

\begin{table*}[t!]
\begin{center}
\resizebox{\textwidth}{!}{
\begin{tabular}{c | cccccccccccccccccccc | c}
\toprule
\noalign{\smallskip}
Method & aero & bike & bird & boat & bottle & bus & car & cat & chair & cow & table & dog & horse & mbike & person & plant & sheep & sofa & train & tv & Mean\\
\noalign{\smallskip}
\midrule
\noalign{\smallskip}
  GMN~\cite{zanfir2018deep} & 35.5 & 50.0 & 52.2 & 45.2 & 75.5 & 69.1 & 59.0 & 61.1 & 34.4 & 51.9 & 66.4 & 53.4 & 53.9 & 50.7 & 31.1 & 75.8 & 59.2 & 47.9 & 86.1 & 89.6 & 57.4 \\
  ~\cite{zanfir2018deep} & 40.8 & 57.1 & 56.2 & 48.2 & 75.5 & 71.6 & 64.1 & 63.3 & 36.3 & 54.3 & 50.2 & 57.6 & 60.3 & 55.4 & 35.5 & 85.2 & 62.7 & 51.8 & 86.5 & 87.4 & 60.0\\
  qc-GMN & 37.3 & 52.2 & 54.3 & 47.2 & 76.4 & 70.4 & 61.2 & 61.7 & 34.5 & 53.1 & 69.1 & 55.4 & 56.0 & 52.4 & 31.6 & 77.3 & 59.7 & 49.1 & 87.4 & 89.7 &  58.8 \\
  PCA~\cite{wang2019learning} & 40.9 & 55.0 & 65.8 & 47.9 & 76.9 & 77.9 & 63.5 & 67.4 & 33.7 & 66.5 & 63.6 & 61.3 & 58.9 & 62.8 & 44.9 & 77.5 & 67.4 & 57.5 & 86.7 & 90.9 & 63.8 \\
  qc-PCA & 42.5 & 58.5 & 66.1 & 51.3 & 79.6 & 78.2 & 65.8
  & 68.7 & 35.1 & 66.8 & 65.6 & 62.5 & 62.1 &  63.1 &  45.1 & 80.7 &  67.7 &  59.1 & 87.0 & 91.1 &  64.8\\
  PCA-H~\cite{wang2019learning} & 50.8 & 61.7 & 62.6 & 56.4 & 80.0 & 75.6 & 72.4 & 74.0 & 38.5 & 64.3 & 49.9 & 63.8 & 65.2 & 63.5 & 46.0 & 78.5 & 68.0 & 41.5 & 82.2 & 90.8 & 64.3 \\
  PCA-F & 50.0 & 66.7 & 61.8 & 55.1 & 81.5 & 75.5 & 70.1 & 70.4 & 39.7 & 64.8 & 60.3 & 65.5 & 67.6 & 64.2 & 45.6 & 84.4 & 68.6 & 56.5 & 88.7 & 91.1 & 66.3 \\
  NGM~\cite{wang2019neural} & 50.8 & 64.5 & 59.5 & 57.6 & 79.4 & 76.9 & 74.4 & 69.9 & 41.5 & 62.3 & 68.5 & 62.2 & 62.4 & 64.7 & 47.8 & 78.7 & 66.0 & 63.3 & 81.4 & 89.6 & 66.1 \\
  GLMNet~\cite{jiang2019glmnet} &  & 67.3 & 63.2 & 57.4 & 80.3 & 74.6 & 70.0 & 72.6 & 38.9 & 66.3 &  & 65.7 & 67.9 & 64.2 & 44.8 & 86.3 & 69.0 & 61.9 & 79.3 & 91.3 & 67.5 \\
  LCSGM~\cite{wang2020learning} & 46.9 & 58.0 & 63.6 &  &  & 79.8 & 71.8 & 60.3 &  & 64.3 & 79.4 & 57.5 & 64.4 & 57.6 &  &  & 62.9 & 65.8 &  & 92.0 & 68.5\\
  -H~\cite{yu2020learning} & 51.2 &  &  & 55.0 & 82.8 & 72.8 & 69.0 &  & 39.6 & 68.8 & 71.8 &  &  & 66.8 & 44.8 & 85.2 &  & 65.4 & 85.2 &  & 68.9\\
\noalign{\smallskip}
\midrule
\noalign{\smallskip}
 qc-DG(ours) & 48.4 & 61.6 & 65.3 & 61.3 & 82.4 & 79.6 & 74.3 & 72.0 & 41.8 &  & 65.0 & 66.1 & 70.9 & 69.6 & 48.2 & 92.1 & 69.0 & 66.7 & 90.4 & 91.8 & 69.3 \\
 qc-DG(ours) & 49.6 & 64.6 & 67.1 & 62.4 & 82.1 &  &  & 73.5 & 43.0 & 68.4 & 66.5 & 67.2 & 71.4 &  & 48.6 & 92.4 & 69.2 &  & 90.9 & 92.0 &  \\
\noalign{\smallskip}
\bottomrule
\end{tabular}}
\end{center}
\vspace{-3mm}
\caption{Accuracy (\%) of 20 classes and average accuracy on Pascal VOC. Bold numbers represent the best performing of the methods to be compared. Method with ``-H" and ``-F" denotes it with permutation loss with Hungarian attention and false matching loss, respectively. Suffix ``-QC" denotes the method with the proposed quadratic constraint.}
\label{table:accuracyP}
\end{table*}

\begin{table*}[t!]
\centering
\resizebox{\textwidth}{!}{
\begin{tabular}{c | cccccccccccccccccccc | c}
    \toprule
    \noalign{\smallskip}
    Method & aero & bike & bird & boat & bottle & bus & car & cat & chair & cow & table & dog & horse & mbike & person & plant & sheep & sofa & train & tv & Mean\\
    \noalign{\smallskip}
    \midrule
    \noalign{\smallskip}
      BB-GM-Max~\cite{rolinek2020deep} & 35.5 & 68.6 & 46.7 & 36.1 & 85.4 & 58.1 & 25.6 & 51.7 & 27.3 & 51.0 & 46.0 & 46.7 & 48.9 & 58.9 & 29.6 & 93.6 & 42.6 & 35.3 & 70.7 & 79.5 & 51.9\\
     BB-GM~\cite{rolinek2020deep} & 42.7 & 70.9 & 57.5 & 46.6 & 85.8 & 64.1 & 51.0 & 63.8 & 42.4 & 63.7 & 47.9 & 61.5 & 63.4 & 69.0 & 46.1 & 94.2 & 57.4 & 39.0 & 78.0 & 82.7 & 61.4\\
     \noalign{\smallskip}
     \midrule
    \noalign{\smallskip}
     qc-DGM (ours) & 30.1 & 59.1 & 48.6 & 40.0 & 79.7 & 51.6 & 32.4 & 55.4 & 26.1 & 52.1 & 47.0 & 50.1 & 56.8 & 59.9 & 27.6 & 90.4 & 50.9 & 33.1 & 71.3 & 78.8 & 52.0\\
     qc-DGM (ours) & 30.9 & 59.8 & 48.8 & 40.5 & 79.6 & 51.7 & 32.5 & 55.8 & 27.5 & 52.1 & 48.0 & 50.7 & 57.3 & 60.3 & 28.1 & 90.8 & 51.0 & 35.5 & 71.5 & 79.9 & 52.6\\
    \noalign{\smallskip}
    \bottomrule
\end{tabular}
}
\vspace{-1mm}
   \caption{F1 score (\%) of matching and mean over 20 classes on Pascal VOC.}
   \label{table:accuracyP1}
    \vspace{-2mm}
\end{table*}

Experimental results on 20 classes are given in Table~\ref{table:accuracyP}. Since the peer work~\cite{rolinek2020deep} suggests to compare F1 score (the harmonic mean of precision and recall) on the dataset without intersection filtering, we provide F1 score of our method to compare with BB-GM~\cite{rolinek2020deep} and its ablation BB-GM-Max as shown in Table~\ref{table:accuracyP1}.

To show the robustness of the deep graph matching models against outliers, we add outliers to the original set of keypoints. The 2D Cartesian coordinates of the outliers are generated by Gaussian distribution . The outliers exist only in inference stage to challenge the model trained on the clean data (without outliers). This robustness test is more challenging than that on synthetic graphs because all the inliers and outliers have their extracted CNN features and thus, more close to the real-world scenes. Experimental results are shown in Fig.~\ref{fig:comparison}. With our quadratic constraint, the improvement of overall accuracy is witnessed on the clean data and the robustness of deep graph matching models have been significantly improved against outliers.

By comparing PCA and qc-PCA or GMN and qc-GMN in Table~\ref{table:accuracyP}, the effectiveness of our quadratic constraint is shown to be general and the matching accuracy is improved over all 20 classes by considering our quadratic constraint.

\begin{table}[t!]
\vspace{-1mm}
\scriptsize
\centering
\begin{tabular}{c|ccccc|c}
\noalign{\smallskip}
\toprule
{Method} & {face} & {mbike} & {car} & {duck} & {wbottle} & {Mean} \\
\midrule
\noalign{\smallskip}
 HARG-SSVM~\cite{cho2013learning} & 91.2 & 44.4 & 58.4 & 55.2 & 66.6 & 63.2\\
 GMN~\cite{zanfir2018deep} & 98.1 & 65.0 & 72.9 & 74.3 & 70.5 & 76.2 \\
  &  & 82.4 & 84.4 & 84.0 & 91.2 & 88.4 \\
 qc-GMN &  & 65.7 & 75.3 & 81.1 & 90.5 & 82.5\\
 PCA~\cite{wang2019learning} &  & 76.7 & 84.0 & 93.5 & 96.9 & 90.2 \\
 qc-PCA &  & 83.3 & 87.3 & 93.8 & 97.1 & 92.3 \\
 PCA-H~\cite{wang2019learning} &  & 76.9 & 88.9 & 89.7 & 92.9 & 89.7 \\
 PCA-F~\cite{wang2019learning} &  & 78.4 & 86.8 & 93.2 & 97.2 & 91.1 \\
 NGM~\cite{wang2019neural} & 99.2 & 82.1 & 84.1 & 77.4 & 93.5 & 87.2 \\
 GLMNet~\cite{jiang2019glmnet} &  & 89.7 & 93.6 & 85.4 & 93.4 & 92.4 \\
 LCSGM~\cite{wang2020learning} &  &  & 91.2 & 86.2 & 97.9 & 94.9\\
 -H~\cite{yu2020learning} &  & 90.0 & 82.2 & 81.2 & 97.6 & 90.2 \\
 BB-GM~\cite{rolinek2020deep} &  &  & 96.9 & 89.0 & 98.8 & 96.8\\
\midrule
 qc-DG(ours) & & 95.0 & 93.8 &  & 97.6 & 96.0 \\
 qc-DG(ours) &  & 98.8 &  & 92.8 &  & \\
\bottomrule
\end{tabular}
\vspace{.2em}
\caption{Accuracy (\%) of 5 classes and the average on Willow Object Class.}
\label{table:willow}
\vspace{-3mm}
\end{table}

\begin{figure}[t!]
\vspace{-7mm}
\centering
\includegraphics[height=0.13\linewidth, width=0.8\linewidth]{legend.pdf}\\
\vspace{-1mm}
\subfigure[]{
\includegraphics[height=0.4\linewidth,width=0.47\linewidth]{comparisonp.pdf}}
\subfigure[]{
\includegraphics[height=0.4\linewidth,width=0.47\linewidth]{comparisonw.pdf}
}
\caption{Robustness analysis against outliers on Pascal VOC (a) and Willow Object Class (b). Method with ``+'' means {\em with} quadratic constraint while ``-'' means {\em without} quadratic constraint.}
\label{fig:comparison}
\vspace{-3mm}
\end{figure}

\begin{figure*}[t!]
\centering
\includegraphics[height=0.14\linewidth,width=0.33\linewidth]{airplane.pdf}
\includegraphics[height=0.14\linewidth,width=0.33\linewidth]{duck1_instance.pdf}
\includegraphics[height=0.14\linewidth, width=0.33\linewidth]{motor1_instance.pdf}\\
\includegraphics[height=0.14\linewidth,width=0.33\linewidth]{train.pdf}
\includegraphics[height=0.143\linewidth,width=0.33\linewidth]{face1_instance.pdf}
\includegraphics[height=0.14\linewidth,width=0.33\linewidth]{bottle.pdf}
\caption{Matching examples on Pascal VOC and Willow Object Class. Nodes with the same color indicate the correspondence of a graph pair. All the visualized graphs are constructed by Delaunay triangulation in yellow.}
\vspace{-3mm}
\label{fig:example}
\end{figure*}

\subsection{Results on Willow Object Class}
Willow Object Class dataset~\cite{cho2013learning} contains 5 classes with 256 images in total. Three classes (face, duck and wine bottle) of the dataset are from Caltech-256 and the rest two classes (car and motorbike) are from Pascal VOC 2007. We resize all the image pairs to 256256 for VGG16 backbone and crop the images around the bounding box of the objects. The variations of the pose, scale, background and illumination of the images on Willow Object Class are small, and thus, graph matching tasks on this dataset are much more easier.

As shown in Table~\ref{table:willow}, the proposed method achieves the state-of-the-art performance. Comparing the methods with and without quadratic constraint (PCA and qc-PCA or GMN and qc-GMN), the performance improvements on Willow dataset are more prominent than those on Pascal VOC, which because the structure variations of graph pairs on the easier dataset are relatively small and quadratic constraint contributes to matching more soundly. Since BB-GM adopts SplineCNN to refine the features, we provide qc-DG for fair comparison, which has a higher overall accuracy.

\subsection{Further study}
Table~\ref{table:ablation} shows the usefulness of the proposed components. CNN feature vector of each node has d=1024 dimensions, which are supposed to be better than the two-dimensional coordinates but the geometric prior encoded in coordinates provides a more precise description of graph nodes. By simply combining the unary geometric prior with the extracted CNN features, the matching accuracy is improved, which supports our point of view, {\em i.e.}, CNN features are indeed useful but not discriminative enough to depict pixel-wise graph nodes.

 There are various forms of quadratic constraint that are not limited to ours. Global affinity matrix  is constrainted by graph incidence matrices in the factorized form of Lawler's QAP~\cite{lawler1963quadratic,zhou2015factorized}, which can be considered as another form of quadratic constraint adopted in GMN. As shown in Table~\ref{table:accuracyP} and Table~\ref{table:willow}, GMN performs significantly worse than  on both two datasets by replacing similar graph topology with the completely different one, while the extracted deep features of both settings remain the same. This implies the main limitation of quadratic constraint, {\em i.e.}, only graphs with similar topology contribute to matching. Besides, the fact shows the independent relationship between the graph structure and raw deep features for the change of graph topology can not be reflected by raw deep features (before being refined).

\begin{figure}[t!]
\vspace{-1mm}
\centering
  \includegraphics[height=0.13\linewidth, width=0.45\linewidth]{legend_acc.pdf}
\includegraphics[height=0.13\linewidth, width=0.47\linewidth]{legend_loss.pdf}\\
   \includegraphics[height=0.4\linewidth, width=0.47\linewidth]{comparison_acc.pdf}
   \includegraphics[height=0.4\linewidth, width=0.47\linewidth]{comparison_loss.pdf}
\caption{Accuracy/loss vs. training epoch on Pascal VOC. As the training goes, the loss functions try to drag the output to binary and the local minimum with bad properties makes the cross-entropy-type loss explosion. Since the accuracy will be very close to 0 after gradient explosion, we truncate the descending curves and keep them unchanged for better visualization.}
\label{fig:allcomp}
\end{figure}


 The two main loss functions to be compared with ours are permutation loss~\cite{wang2019learning} and permutation loss with Hungarian attention~\cite{yu2020learning}. We report accuracy/loss with training epoch in Fig.~\ref{fig:allcomp}. In experiments, the model with cross-entropy-type loss functions (Loss-P and Loss-H) always encounter the bad cases leading to gradient explosion in training stage, while our false matching loss (Loss-F) can avoid this issue. Besides, false matching loss is shown to do better against overfitting than the compared two loss functions.

\begin{table}[t!]
\scriptsize
\centering
\begin{tabular}{ccccc}
\toprule
\multicolumn{1}{c}{\begin{tabular}[c]{@{}c@{}}raw \\attributes\end{tabular}} & \multicolumn{1}{c}{\begin{tabular}[c]{@{}c@{}}unary \\geomteric prior\end{tabular}} & \multicolumn{1}{c}{\begin{tabular}[c]{@{}c@{}}pairwise \\structure context\end{tabular}} & \multicolumn{1}{c}{\begin{tabular}[c]{@{}c@{}}QC \\ optimization\end{tabular}} & accuracy \\
\midrule
 &  &  &  & 69.3\\
 &  &  &  & 68.5\\
 &  &  &  & 68.3\\
 &  &  &  &67.8\\
\bottomrule
\end{tabular}
\vspace{1mm}
\caption{Ablation study of qc-DG on Pascal VOC. The component been adopted is marked by a tick. ``QC optimization" is quadratic constrained-optimization.}
\label{table:ablation}
\vspace{-3mm}
\end{table}

\section{Conclusion}
In this work, we explicitly introduce quadratic constraint of graph structure into deep graph matching. To this end, unary geometric prior and pairwise structural context are considered for objective construction and a differentiable
optimization scheme is provided to approach the problem. Moreover, we focus on class imbalance that naturally exists in deep graph matching to propose our false matching loss. Experimental results show the competitive performance of our method. In future work, we plan to seek a more general form of quadratic constraint to the learning-based optimization for better matching.

{\small
\bibliographystyle{ieee_fullname}
\bibliography{egbib}
}

\end{document}
