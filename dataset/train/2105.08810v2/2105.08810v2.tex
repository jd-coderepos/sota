\documentclass{article}



\usepackage[final, nonatbib]{neurips_2021}







\usepackage[utf8]{inputenc} \usepackage[T1]{fontenc}    \usepackage{hyperref}       \usepackage{url}            \usepackage{booktabs}       \usepackage{amsfonts}       \usepackage{nicefrac}       \usepackage{microtype}      \usepackage{xcolor}         


\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{graphicx}
\newtheorem{theorem}{Theorem}
\newtheorem{definition}{Definition}
\newtheorem{proposition}{Proposition}
\newtheorem*{proof*}{Proof}
\bibliographystyle{unsrt}
\definecolor{mygreen}{rgb}{0,0.69,0.31}
\definecolor{myblue}{rgb}{0,0.44,0.75}
\definecolor{mypurple}{rgb}{0.44,0.19,0.63}

\usepackage{multirow}


\title{Sparse Spiking Gradient Descent }



\author{Nicolas Perez-Nieves \\
  Electrical and Electronic Engineering\\
  Imperial College London\\
  London, United Kingdom \\
  \texttt{nicolas.perez14@imperial.ac.uk} \\
\And
  Dan F.M. Goodman \\
  Electrical and Electronic Engineering\\
  Imperial College London\\
  London, United Kingdom \\
  \texttt{d.goodman@imperial.ac.uk} \\
}

\begin{document}

\maketitle

\begin{abstract}
  There is an increasing interest in emulating Spiking Neural Networks (SNNs) on neuromorphic computing devices due to their low energy consumption. Recent advances have allowed training SNNs to a point where they start to compete with traditional Artificial Neural Networks (ANNs) in terms of accuracy, while at the same time being energy efficient when run on neuromorphic hardware. However, the process of training SNNs is still based on dense tensor operations originally developed for ANNs which do not leverage the spatiotemporally sparse nature of SNNs. We present here the first sparse SNN backpropagation algorithm which achieves the same or better accuracy as current state of the art methods while being significantly faster and more memory efficient. We show the effectiveness of our method on real datasets of varying complexity (Fashion-MNIST, Neuromophic-MNIST and Spiking Heidelberg Digits) achieving a speedup in the backward pass of up to x, and  more memory efficient, without losing accuracy. 
\end{abstract}

\section{Introduction}

In recent years, deep artificial neural networks (ANNs) have matched and occasionally surpassed human-level performance on increasingly difficult auditory and visual recognition problems \cite{lecun2015deep, hinton2012deep, krizhevsky2012imagenet}, natural language processing tasks \cite{zhang2019ernie, brown2020language} and games \cite{mnih2015human, silver2017mastering, vinyals2019grandmaster}.  As these tasks become more challenging the neural networks required to solve them grow larger and consequently their power efficiency becomes more important \cite{strubell2019energy, schwartz2019green}. At the same time, the increasing interest in deploying these models into embedded applications calls for faster, more efficient and less memory intensive networks \cite{hochstetler2018embedded, lane2017squeezing}.

The human brain manages to perform similar and even more complicated tasks while only consuming about 20W \cite{mink1981ratio} which contrasts with the hundreds of watts required for running ANNs \cite{strubell2019energy}. Unlike ANNs, biological neurons in the brain communicate through discrete events called spikes. A biological neuron integrates incoming spikes from other neurons in its membrane potential and after reaching a threshold emits a spike and resets its potential \cite{gerstner2014neuronal}. The spiking neuron, combined with the sparse connectivity of the brain, results in a highly spatio-temporally sparse activity \cite{cox2014neural} which is fundamental to achieve this level of energy efficiency. 

Inspired by the extraordinary performance of the brain, neuromorphic computing aims to obtain the same level of energy efficiency preferably while maintaining an accuracy standard on par with ANNs by emulating spiking neural networks (SNNs) on specialised hardware \cite{pfeil2013six, merolla2014million, esser2016convolutional, diehl2016conversion}. These efforts go in two directions: emulating the SNNs and training the SNNs. While there is a growing number of successful neuromorphic implementations for the former \cite{mahowald1991silicon, schemmel2010wafer, merolla2011digital, moradi2013event, chicca2014neuromorphic, merolla2014million, benjamin2014neurogrid, davies2018loihi}, the latter has proven to be more challenging. Some neuromorphic chips implement local learning rules \cite{davies2018loihi, pedretti2017memristive, kim2018demonstration} and recent advances have achieved to approximate backpropagation on-chip \cite{kwon2020chip}. However, a full end-to-end supervised learning via error backpropagation requires off-chip training \cite{merolla2011digital, moradi2013event, esser2016convolutional}. This is usually achieved by simulating and training the entire SNN on a GPU and more recently, emulating the forward pass of the SNN on neuromorphic hardware and then performing the backward pass on a GPU \cite{schmitt2017neuromorphic, cramer2020training}. The great flexibility provided by GPUs allows the development of complex training pipelines without being constrained by neuromorphic hardware specifications. However, as GPUs do not leverage the event-driven nature of spiking computations this results in effective but slower and less energy efficient training. An alternative to directly training an SNN consists on training an ANN and converting it to an SNN. However, this approach has been recently shown to not be more energy efficient than using the original ANN in the first place \cite{davidson2021comparison}.

Training SNNs has been a challenge itself even without considering a power budget due to the all-or-none nature of spikes which hinders traditional gradient descent methods \cite{SuGD_zenke, wunderlich2021event}. Since the functional form of a spike is a unit impulse, it has a zero derivative for all membrane potentials except at the threshold where it is infinity. Recently developed methods based on surrogate gradients have been shown to be capable of solving complex tasks to near state-of-the-art accuracies \cite{hunsberger2015spiking, esser2016convolutional, Shresta2018SLAYER, wozniak2020deep, zenke2021remarkable, perez2021neural, cramer2020training}. The problem of non-differentiability is solved by adopting a well-behaved surrogate gradient when backpropagating the error \cite{SuGD_zenke}. This method, while effective for training very accurate models, is still constrained to working on dense tensors, thus, not profiting from the sparse nature of spiking, and limits the training speed and power efficiency when training SNNs.

In this work we introduce a sparse backpropagation method for SNNs. Recent work on ANNs has shown that adaptive dropout \cite{frey13adaptive} and adaptive sparsity \cite{blanc2018adaptive} can be used to achieve state-of-the-art performance at a fraction of the computational cost \cite{chen2019slide, daghaghi2021accelerating}. We show that by redefining the surrogate gradient functional form, a sparse learning rule for SNNs arises naturally as a three-factor Hebbian-like learning rule. We empirically show an improved backpropagation time up to x faster than current implementations and up to  more memory efficient in real datasets (Fashion-MNIST (F-MNIST) \cite{xiao2017fashion}, Neuromorphic-MNIST (N-MNIST) \cite{orchard2015converting} and Spiking Heidelberg Dataset (SHD) \cite{cramer2020heidelberg})  thus reducing the computational gap between the forward and backward passes. This improvement will not only impact training for neuromorphic computing applications but also for computational neuroscience research involving training on SNNs \cite{perez2021neural}.


\section{Sparse Spike Backpropagation }\label{section:main_text}

\subsection{Forward Model}

We begin by introducing the spiking networks we are going to work with (Figs. \ref{fig:schematic} and \ref{fig:forward_backward}). For simplicity we have omitted the batch dimension in the derivations but it is later used on the complexity analysis and experiments. We have a total of  fully connected spiking layers. Each layer  consisting of  spiking neurons which are fully connected to the next layer  through synaptic weights . Each neuron has an internal state variable, the membrane potential,  that updates every discrete time step  for some finite simulation time . Neurons emit spikes according to a spiking function  such that 



\begin{figure}[!tb]
\centering
\includegraphics[width=0.8\textwidth]{figures/network_diagram.pdf}
\caption{Spiking Neural Network diagram highlighting the forward and backward passes}
\label{fig:schematic}
\vspace{-0.5cm}
\end{figure}

The membrane potential varies according to a simplified Leaky Integrate and Fire (LIF) neuron model in which input spikes are directly integrated into the membrane \cite{gerstner2014neuronal}. After a neuron spikes, its potential is reset to . We will work with a discretised version of this model (see Appendix \ref{supp:training_details} for a continuous time version). The membrane potential of neuron  in layer  evolves according to the following difference equation





The first two terms account for the leaky part of the model where we define  with  being the time resolution of the simulation and the membrane time constant of the neurons respectively. The second term deals with the integration of spikes. The last term models the resetting mechanism by subtracting the distance from the threshold to the reset potential. For simplicity and without loss of generality, we consider  and  from now on. 

We can unroll \eqref{eq:lif} to obtain

\vspace{-0.4cm}


Thus, a spiking neural network can be viewed as a special type of recurrent neural network where the activation function of each neuron is the spiking function . The spiking function, is commonly defined as the unit step function centered at a particular threshold 


Note that while this function is easy to compute in the forward pass, its derivative, the unit impulse function, is problematic for backpropagation which has resulted in adopting surrogate derivatives \cite{SuGD_zenke} to allow the gradient to flow. Interestingly, it has been shown that surrogate gradient descent performs robustly for a wide range of surrogate functional forms \cite{zenke2021remarkable}.

After the final layer, a loss function  computes how far the network activity is with respect to some target value for the given input. The loss function can be defined as a function of the network spikes, membrane potentials or both. It may also be evaluated at every single time step or every several steps. We deliberately leave the particular definition of this function open as it does not directly affect the sparse gradient descent method we introduce.


\begin{figure}[!tb]
\centering
\includegraphics[width=0.8\textwidth]{figures/forward-backward_diagram.pdf}
\caption{Illustration of the gradient backpropagating only through active neurons.}
\label{fig:forward_backward}
\vspace{-0.5cm}
\end{figure}

\subsection{Backward Model}

The SNN is updated by computing the gradient of the loss function with respect to the weights in each layer. This can be achieved using backpropagation through time (BPTT) on the unrolled network. Following \eqref{eq:spike} and \eqref{eq:lif_unrolled} we can derive weight gradients to be

\vspace{-0.4cm}


This gradient consists of a sum over all time steps of the product of three terms. The first term, modulates the spatio-temporal credit assignment of the weights by propagating the gradient from the next layer. The second term, is the derivative of  evaluated at a given . The last term is a filtered version of the input spikes. Notice that it is not necessary to compute this last term as this is already computed in the forward pass \eqref{eq:lif_unrolled}. We have chosen not make the spike resetting term in \eqref{eq:lif_unrolled} differentiable as it has been shown that doing so can result in worse testing accuracy \cite{zenke2021remarkable} and it increases the computational cost.

For a typical loss function defined on the output layer activity, the value of  (i.e. in the last layer) is the gradient of the loss with respect to the output layer (see Fig. \ref{fig:schematic}). For all other layers we have that , that is, the gradient of the loss function with respect to the output spikes of layer . We can obtain an expression for  as a function of the gradient of the next layer:



All hidden layers need to compute equations \eqref{eq:w_grad} and \eqref{eq:s_grad}. The first one to update their input synaptic weights and the second one to backpropagate the loss to the previous layer. The first layer () only needs to compute \eqref{eq:w_grad} and the last layer () will compute a different \textcolor{mygreen}{} depending on the loss function. 

We introduce the following definitions which result in the sparse backpropagation learning rule.

\begin{definition}
Given a backpropagation threshold  we say neuron  is \textbf{active} at time  iff


\end{definition}

\begin{definition}
The spike gradient is defined as


\end{definition}

This means that neurons are only active when their potential is close to the threshold. Applying these two definitions to \eqref{eq:w_grad} and \eqref{eq:s_grad} results in the gradients only backpropagating through active neurons at each time step as shown in Fig. \ref{fig:forward_backward}. The consequences of this are readily available for the weight gradient in \eqref{eq:w_grad} as the only terms in the sum that will need to be computed are those in which the postsynaptic neuron  was active at time . Resulting in the following gradient update:



For the spike gradient in \eqref{eq:s_grad} we have two consequences, firstly, we will only need to compute \textcolor{mygreen}{} for active neurons since \textcolor{mygreen}{} is always multiplied by \textcolor{red}{} in \eqref{eq:w_grad} and \eqref{eq:s_grad}. Secondly, we can use a recurrent relation to save time and memory when computing  in \eqref{eq:s_grad} as shown in the following proposition.

\begin{proposition}
We can use a recurrent relation to compute  given by 

\end{proposition}

This means that we only need to compute  at those time steps in which either  or  is active (see Appendix \ref{supp:delta_vis} for a visualisation of this computation). Thus, we end up with the following sparse expression for computing the spike gradient.

\vspace{-0.3cm}


\subsection{Complexity analysis}

We define  to be the probability that a neuron is active in layer  at a given time. Table \ref{table:complexity} summarises the computational complexity of the gradient computation in terms of number of sums and products. We use here  to refer to the number of neurons in either the input or output layer and  to refer to the batch size. In a slight abuse of notation we include the constants  as part of the complexity expressions. Details of how these expression were obtained can be found in Appendix \ref{supp:compl_analysis} and are based on a reasonable efficient algorithm that uses memoisation for computing .



\begin{table}[h]
  \caption{Computational complexity}
  \centering
  \begin{tabular}{lll}
    \toprule
                              & Original     & Sparse \\
    \midrule
    Sums      &         &   \\
    Products  &         &   \\
    Sums      &         &   \\
    Products  &         &   \\
    \bottomrule
  \end{tabular}
  \label{table:complexity}
\end{table}

In order for the sparse gradients to work better than their dense counterpart we need to have a balance between having few enough active neurons as to make the sparse backpropagation efficient while at the same time keeping enough neurons active to allow the gradient to backpropagate. We later show in section \ref{section:experiments} that this is the case when testing it on real world datasets. 


\subsection{Sparse learning rule interpretation}

The surrogate derivative we propose, while not having a constrained functional form for active neurons, imposes a zero gradient for the inactive ones. Looking back into equation \eqref{eq:w_grad} we can identify it now as a three-factor Hebbian learning rule \cite{gerstner2018eligibility}. With our surrogate derivative definition, the second term (spike derivative) measures whether the postsynaptic neuron is close to spiking (i.e. its membrane potential is close to the threshold). The third term (input trace) measures the presynaptic neuron activity in the most recent timesteps. Finally the first term (gradient from next layer) decides whether the synaptic activity improves or hinders performance with respect to some loss function. We note that this is not exactly a Hebbian learning rule as neurons that get close to spike but do not spike can influence the synaptic weight update and as such, the second term is simply a surrogate of the postsynaptic spike activity.
 
Previous surrogate gradient descent methods have used a similar approach to implement backpropagation on SNNs \cite{esser2016convolutional, Shresta2018SLAYER, yin2020effective, perez2021neural, zenke2021remarkable}, often using surrogate gradient descent definitions that are maximal when the membrane is at the threshold and decay as the potential moves away from it. In fact, in Esser et al. \cite{esser2016convolutional} the surrogate gradient definition given implies that neurons backpropagate a zero gradient  of the time. However, as shown in the next section, neurons can  be active a lot less often when presented with spikes generated from real world data and still give the same test accuracy. This is only possible because surrogate gradient approximations to the threshold function yield much larger values when the potential is closer to spike thus concentrating most of the gradient on active neurons. This fact makes it possible to fully profit from our sparse learning rule for a much reduced computational and memory cost.

\section{Experiments}\label{section:experiments}

We evaluated the correctness and improved efficiency of the proposed sparse backpropagation algorithm on real data of varying difficulty and increasing spatio-temporal complexity. Firstly, the Fashion-MNIST dataset (F-MNIST) \cite{xiao2017fashion} is an image dataset that has been previously used on SNNs by converting each pixel analogue value to spike latencies such that a higher intensity results in an earlier spike \cite{perez2021neural}\cite{zenke2021remarkable}. Importantly, each input neuron can only spike at most once thus resulting in a simple spatio-temporal complexity and very sparse coding. Secondly, we used the Neuromorphic-MNIST (N-MNIST) \cite{orchard2015converting} dataset where spikes are generated by presenting images of the MNIST dataset to a neuromorphic vision sensor. This dataset presents a higher temporal complexity and lower sparsity than the F-MNIST as each neuron can spike several times and there is noise from the recording device. Finally, we worked on the Spiking Heidelberg Dataset (SHD) \cite{cramer2020heidelberg}). This is a highly complex dataset that was generated by converting spoken digits into spike times by using a detailed model of auditory bushy cells in the cochlear nucleus. This results in a very high spatio-temporal complexity and lowest input sparsity. A visualisation of samples of each dataset can be found in the supplementary materials. These datasets cover the most relevant applications of neuromorphic systems. Namely, artificially encoding a dataset into spikes (Fashion-MNIST), reading spikes from a neuromorphic sensor such as a DVS camera (N-MNIST) and encoding complex temporally-varying data into spikes (SHD).

We run all experiments on three-layer fully connected network as in Fig. \ref{fig:schematic}, where the last layer (readout) has an infinite threshold. Both spiking layers in the middle have the same number of neurons. We used  for the surrogate gradient as in \cite{zenke2021remarkable}. See Appendix \ref{supp:training_details} for all training details. We implemented the sparse gradient computation as a Pytorch CUDA extension \cite{Paszke2019pytorch}. 


\subsection{Spiking neurons are inactive most of the time resulting in higher energy efficiency}

One of the most determining factors of the success of our sparse gradient descent resides on the level of sparsity that we can expect and, consequently, the proportion of active neurons we have in each layer. We measure the percentage of active neurons on each batch as training progresses for each dataset. This can be computed as 



where  is the batch size  is the total number of time steps and  the number of neurons in the layer and the number of active neurons is obtained according to \eqref{eq:active}. This is an empirical way of measuring the coefficient  introduced earlier.

Figure \ref{fig:panel1}A shows the activity on each dataset. As expected, the level of activity is correlated with the sparseness of the inputs with the lowest one being on the F-MNIST and the larger in the SHD dataset. Remarkably however, the activity on average is never above  on average in any dataset and it is as low as  in the F-MNIST dataset. This means that on average we will never have to compute more than  of the factors in  and  of the values of . This can be visualised in the bottom row of Fig. \ref{fig:panel1}B.

These coefficients give us a theoretical upper bound to the amount of energy that can be saved if this sparse backpropagation rule was implemented in specialised hardware which only performed the required sums and products. This is summarised in Table \ref{table:energy}.

\begin{table}[h]
  \caption{Theoretical upper bound to energy saved in hidden layers.}
  \centering
  \begin{tabular}{lllll}
    \toprule
\multirow{2}{*}{} 
    & Mean activity & Mean activity & Energy saved & Energy saved \\ 
    & layer 1 (\%) & layer 2 (\%) & in  (\%) & in  (\%) \\ 
    \midrule
    F-MNIST     & 1.06        & 0.87  & 99.13 & 98.94\\
    N-MNIST     & 1.12        & 0.77  & 99.23 & 98.88\\
    SHD         & 1.70        & 1.09  & 98.91 & 98.30\\
    \bottomrule
  \end{tabular}
  \label{table:energy}
\end{table}

Importantly, in dense backpropagation methods the temporal dimension of datasets and models is necessarily limited to a maximum of  since gradients must be computed at all steps \cite{cramer2020heidelberg, perez2021neural}. This means that a lot of negligible gradients are computed. However, our method adapts to the level of activity of the network and only computes non-negligible gradients. This cost-prohibitive reality was evidenced when we attempted to run these experiments in smaller GPUs leading to running out of memory when using dense methods but not on ours (see \ref{supp:other_gpus}). Thus, sparse spiking backpropagation allows to train data that runs for longer periods of time without requiring a more powerful hardware.



\begin{figure}[!tb]
\centering 
\includegraphics[width=0.99\textwidth]{figures/panel1_new.pdf}
\caption{Sparse backpropagation learns at high levels of sparsity. All figures except B are a 5 sample average. Standard error in the mean is displayed (although too small to be easily visualised). \textbf{A.} Percentage of active neurons during training as a fraction of total tensor size () with  neurons for each dataset. \textbf{B.} Visualisation of the weight and spike gradients on the SHD dataset. We show zero value in hatched grey. Note how both  are nearly identical in despite being computed using a small fraction of the values of  in the sparse case. \textbf{C.} Loss evolution on the SHD dataset using both algorithms. \textbf{D.} Final test accuracy on all datasets using both methods.}
\label{fig:panel1}
\vspace{-0.1cm}
\end{figure}


\subsection{Sparse backpropagation training approximates the gradient very well}

We test that our sparse learning rule performs on par with the standard surrogate gradient descent. Figure \ref{fig:panel1}B shows a visualisation of the weight (first row) and spike gradients (second row). Note how most of the values of  were not computed and yet  is nearly identical to the original gradient. This is further confirmed in Figures \ref{fig:panel1}C and \ref{fig:panel1}D where the loss on the SHD dataset is practically identical with both methods (the loss for the other datasets can be found in Appendix \ref{supp:other results}) and the test accuracy is practically identical (albeit slightly better) in the sparse case (F-MNIST: , N-MNIST: , SHD: ). These accuracies are on par to those obtained with similar networks on these datasets (F-MNIST: , N-MNIST: , SHD: ) \cite{cramer2020heidelberg, zenke2021remarkable, perez2021neural}. These results show that sparse spiking backpropagation gives practically identical results to the original backpropagation but at much lower computational cost.


\subsection{Sparse training is faster and less memory intensive}

We now measure the time it takes the forward and the backward propagation of the second layer of the network during training as well as the peak GPU memory used. We choose this layer because it needs to compute both   and  (note that the first layer only needs to compute ). A performance improvement in this layer translates to an improvement in all subsequent layers inn a deeper network. We compute the backward speedup as the ratio of the original backpropagation time and the sparse backpropagation time. We compute the memory saved as



Figure \ref{fig:panel2}A shows the speedup and memory saved on a  neuron hidden layer (both hidden layers).
Backpropagation time is faster by x and GPU memory is reduced by .
To put this speedup into perspective Figure \ref{fig:panel2}B shows the time taken for backpropagating the second layer in the original case (about ms) and the sparse case (about ms). It also shows that the time taken for backpropagating is nearly constant during training as it could be expected after studying the network activity in Fig. \ref{fig:panel1}A. 



We also tested how robust is this implementation for a varying number of hidden neurons (in both layers). We increase the number of neurons up to  which is similar to the maximum number of hidden units used in previous work \cite{cramer2020heidelberg} and it is also the point at which the original backpropagation method starts to run out of memory. Here we also show the overall speedup defined as the ratio between the sum of forward and backward times of the original over the sparse backpropagation. The results shown in Fig. \ref{fig:panel2}C show that the backward speedup and memory saved remain constant as we increase the number of hidden neurons but the overall speedup increases substantially. Given that the forward time is the same for both methods (see Appendix \ref{supp:other results}) this shows that as we increase the number of neurons, the backward time takes most of the computation and thus the sparse backpropagation becomes more important.

We also note that these results vary depending on the GPU used, Figure \ref{fig:panel2} was obtained from running on an RTX6000 GPU. We also run this on smaller GPUs (GTX1060 and GTX1080Ti) and found that the improvement is even better reaching up to a x faster backward pass on N-MNIST and SHD. These results can found in Appendix \ref{supp:other results}. Our results show that our method speeds up backward execution between one and two orders of magnitude, meaning that to a first approximation we would expect it reduce energy usage by the same factor since GPUs continue to use 30-50\% of their peak power even when idle \cite{knight2018gpus}.


\begin{figure}[!tb]
\centering
\includegraphics[width=0.99\textwidth]{figures/panel2.pdf}
\caption{Speedup and memory improvement when using sparse gradient backpropagation. All figures are a 5 sample average and its standard error in the mean is also displayed.
\textbf{A.} Backward speedup and memory saved in the second hidden layer for all three datasets when using sparse gradient descent with  hidden neurons. \textbf{B.} Time spent in computing the backward pass in the second hidden layer consisting of  neurons when using regular gradient descent and sparse gradient descent. \textbf{C.} Backward speed and memory saved in the second hidden layer as we increase the number of hidden neurons in all hidden layers. We included the overall speedup which takes into consideration both the forward and backward times spent in the second layer.}
\label{fig:panel2}
\end{figure}

\subsection{Training deeper and more complex architectures}

We show that our gradient approximation can successfully train deeper networks by training a 6-layer fully connected network (5 hidden plus readout all with 300 neurons) on Fashion-MNIST. We measured the performance of the 5 hidden layers and achieve a x backward speedup when using 1080-Ti GPU (better than the x speedup under these conditions with only 2 hidden layers as shown in Appendix \ref{supp:other_gpus}) and  memory saved while achieving a  testing accuracy (slightly better than with 2 layers at ). The results are consistent with our previous findings and show that the gradient is not loss in deeper architectures.

We also run a experiment with a convolutional and pooling layers on the Fashion-MNIST dataset obtaining a test accuracy of  when using our spike gradient approximation and  with the original gradients. We do not report speedup or memory improvements in this network as developing a sparse convolutional CUDA kernel is out of the scope of our work but we simply ran a dense implementation with clamped gradients. This proves that our gradient approximation is able to train on more complex architectures although it still remains to be shown whether efficient sparse operators can be implemented for this purpose. See Appendix \ref{supp:training_details} for training details.

\subsection{Sparsity-Accuracy trade-off}

We trained the SHD dataset on the original 2-layer fully connected network with  neurons in each hidden layer and varied the backpropagation threshold . We found that the training is very robust to even extreme values of . The loss and accuracy remains unchanged even when setting  (see \ref{fig:panel3}A and \ref{fig:panel3}B) achieving a nearly x speedup and  memory improvement as shown in \ref{fig:panel3}C. We also inspected the levels of activity while varying  and we found that there are enough active neuron to propagate the gradient effectively. As  gets closer to  the number of active neurons decreases rapidly until there are no gradients to propagate. 

\begin{figure}[!tb]
\centering
\includegraphics[width=0.99\textwidth]{figures/panel3.pdf}
\caption{Impact of varying the backpropagation threshold  on the SHD dataset.
\textbf{A.}  Final test accuracy on the SHD dataset as  increases. \textbf{B.} Loss evolution on the SHD dataset for different . \textbf{C.} Hidden activity, backward speedup and backward memory saved as  increases.}
\label{fig:panel3}
\end{figure}

\section{Discussion}\label{section:discussion}
\vspace{-0.1cm}
Recent interest in neuromorphic computing has lead to energy efficient emulation of SNNs in specialised hardware. Most of these systems only support working with fixed network parameters thus requiring an external processor to train. Efforts to include training within the neuromorphic system usually rely on local learning rules which do not guarantee state-of-the-art performance. Thus, training on these systems requires error backpropagation on von-Neumann processors instead of taking advantage of the physics of the neuromorphic substrate \cite{indiveri2015memory, demirag2021pcm}.

We have developed a sparse backpropagation algorithm for SNNs that achieves the same performance as standard dense backpropagation at a much reduced computational and memory cost. To the best of our knowledge this is the first backpropagation method that leverages the sparse nature of spikes in training and tackles the main performance bottleneck in neuromorphic training. Moreover, while we have used dense all-to-all connectivity between layers, our algorithm is compatible with other SNNs techniques that aim for a sparser connectivity such as synaptic pruning \cite{chen2021pruning}.

By constraining backpropagation to active neurons exclusively, we reduce the number of nodes and edges in the backward computation graph to a point where over \% of the operations required to compute the gradients can be skipped. This results in a much faster backpropagation time, lower memory requirement and less energy consumption on GPU hardware while not affecting the testing accuracy. This is possible because the surrogate gradient used to approximate the derivative of the spiking function is larger when the membrane potential is closer to the threshold resulting in most of the gradient being concentrated on active neurons. Previous work has used, to a lesser extent, similar ideas. Esser et al. \cite{esser2016convolutional} used a surrogate gradient function which effectively resulted in about one third the neurons backpropagating a zero gradient. Later, Pozzi, et al. \cite{pozzi2020attention} developed a learning rule where only the weights of neurons directly affecting the activity of the selected output class are updated, however, the trial and error nature of the learning procedure resulted in up to x slower training. 



However, due to the lack of efficient sparse operators in most auto-differentiation platforms, every layer type requires to develop its own sparse CUDA kernel in order to be competitive with current heavily optimised libraries. In our work, we concentrated on implementing and testing this in spiking fully connected layers and we managed to show that sparse backpropagation is a lot faster and uses less memory. Developing these sparse kernels is not trivial and we are aware that having to do so for each layer is an important limitation of our work. This is no surprise since for now there is few reasons to believe that sparse tensor operations will significantly accelerate neural network performance. Our work aims to challenge this view and motivate the adoption of efficient sparse routines by showing for the first time that sparse BPTT can be faster without losing accuracy.

We implemented and tested our method on real data on fully connected SNNs and simulated it in convolutional SNNs. The same method can be extended to any SNN topology as long as the neurons use a threshold activation function and the input is spiking data. However, due to the lack of efficient sparse operators in most auto-differentiation platforms, every layer type requires to develop its own sparse CUDA kernel in order to be competitive with current heavily optimised libraries. Developing these sparse kernels is not trivial and we are aware that having to do so for each layer is an important limitation of our work. This is no surprise since for now there is few reasons to believe that sparse tensor operations will significantly accelerate neural network performance. Our work aims to challenge this view and motivate the adoption of efficient sparse routines by showing for the first time that sparse spiking BPTT can be faster while achieving the same accuracy as its dense counterpart. Nevertheless, ideally, a dynamic backward graph should be generated each time the backward pass needs to be computed and consequently a GPU may not be the best processing unit for this task. A specialised neuromorphic implementation or an FPGA may be more suited to carry out the gradient computation task as this graph changes every batch update. Additionally, while we have reduced the number of operations required for training several times, we have only achieved up to a  memory reduction thus, memory requirements remains an important bottleneck. 

In summary, our sparse backpropagation algorithm for spiking neural networks tackles the main bottleneck in training SNNs and opens the possibility of a fast, energy and memory efficient end-to-end training on spiking neural networks which will benefit neuromorphic training and computational neuroscience research. Sparse spike backpropagation is a necessary step towards a fully efficient on-chip training which will be ultimately required to achieve the full potential of neuromorphic computing.

\begin{ack}
We thank Friedemann Zenke, Thomas Nowotny and James Knight for their feedback and support. This work was supported by the EPSRC Centre for Doctoral Training in High Performance Embedded and DistributedSystems (HiPEDS, Grant Reference EP/L016796/1)
\end{ack}


\bibliography{refs.bib}

\newpage





































































































































































\newpage
\appendix

\begin{center}
{\huge \textbf{Sparse Spiking Gradient Descent: Supplementary Materials}}
\end{center}
\bigskip

\section{Proof of Proposition 1} \label{supp:proof1}

\setcounter{proposition}{0}


\begin{proposition}
We can use a recurrent relation to compute  given by 

\end{proposition}

\begin{proof*}

The proof follows directly from the definition of .

For the first case we have



where the penultimate equality holds from the condition 

The proof of the second case is identical except that now the term  will be non-zero.
\end{proof*}

\section{Complexity analysis} \label{supp:compl_analysis}

For clarity, we consider that all layers have the same number  of neurons. The weight gradient is given by



Since the trace  has been compated in the forward pass, then computing  requires doing a total of  products and  sums per element in  per batch. Thus resulting in  products and  sums. In the sparse case instead of  we have on average  products and  sums resulting in a total of   products and  sums.

The spikes gradient is given by



This gradient is obtained by doing the matrix product between  and  per batch. This gives a total of  products and sums. In the sparse case we only need to compute a fraction  of the entries in  thus a total of  products and sums.

There are two main ways of computing . The naive way requires doing  products and  sums by computing all values with  for a given  every time. Alternatively, we can use memoisation to store all values already computed resulting in just  products and  sums per batch. Thus resulting in  products and sums. In the sparse case, the worst case scenario is when the active times of layers  and  are completely disjoint as we show in Appendix \ref{supp:delta_vis}. Meaning we have to compute  products and sums without memoisation or  with memoisation.

Overall we get that if we do not use memoisation for computing  then we do  sums and products and  in the sparse case. With memoisation we do  and  in the sparse case.


\section{Visualisation of  computation} \label{supp:delta_vis}

Given a presynaptic neuron  and postsynaptic neuron  we need to compute the gradient



We first note that  is always multiplied by  either in the weight gradient equation \eqref{eq:w_grad} or in the spike gradient equation \eqref{eq:s_grad}. Thus, we only need  at those times at which . 

Secondly, according to Proposition 1   is only modified beyond an attenuation factor of  at those times when . 

We define 



Both sets of times are known by the time we compute the gradients since they are simply the times at which neurons  and  were active.

The following example shows how the computation of  would take place using Proposition 1. We note that we only need to write the result in global memory at times . Consequently, once we have all  we can simply stop the computation

\begin{figure}[!h]
\centering 
\includegraphics[width=0.9\textwidth]{figures_supp/delta_vis.pdf}
\label{fig:delta_vis}
\end{figure}



Thus, in the worse case scenario where sets  and  are disjoint instead of doing  updates we only do  updates.

\section{Visualisation of input data} \label{supp:dataset_vis}
Visualisation of several of one sample per dataset to provide and intuitive idea of the level of sparsity of the data.  

\begin{figure}[!ht]
\centering 
\includegraphics[width=0.49\textwidth]{figures_supp/input_vis/FMNIST_3D_front_vf.pdf}\includegraphics[width=0.49\textwidth]{figures_supp/input_vis/FMNIST_3D_vf.pdf}
\caption{Visulization of a sample of the Fashion-MNIST dataset converted into spike times. Left: Front view. Right: Side view}
\label{fig:supp_fmnist}
\end{figure}

\begin{figure}[!ht]
\centering 
\includegraphics[width=0.49\textwidth]{figures_supp/input_vis/NMNIST_3D_front_vf.pdf}
\vspace{0.5cm}
\includegraphics[width=\textwidth]{figures_supp/input_vis/NMNIST_3D_vf.pdf}
\caption{Visulization of a sample of the Neuromorphic-MNIST dataset. Top: Front view. Bottom: Side view}
\label{fig:supp_nmnist}
\end{figure}

\begin{figure}[!ht]
\centering 
\includegraphics[width=0.8\textwidth]{figures_supp/input_vis/SHD_2D.pdf}
\caption{Visulization of a sample of the Spiking Heidelberg Digits dataset.}
\label{fig:supp_shd}
\end{figure}


\section{Training details} \label{supp:training_details}

\subsection{Conversion of Fashion-MNIST to spike latencies}

We convert the normalised analog grayscale pixel values  of the Fashion-MNIST samples \cite{xiao2017fashion} to spike times in a similar way to that used in \cite{zenke2021remarkable}. Specifically, we convert the normalised intensities into spike times following



\subsection{Spiking neuron model}

We use the simplified Leaky Integrate and Fire model which is a variation on the standard Leaky Integrate and Fire model in which spikes are directly integrated in the membrane without being filtered by beforehand. The membrane potential evolves according to


The membrane potential resets to  as soon as it reaches a threshold . The model keeps the main features of a spiking model, namely, a membrane potential that varies according to the incoming input spikes and synaptic weights, a leaky component that draws the potential towards  and spiking and resetting mechanisms. 

We use a discretised version of the model as in Equation \eqref{eq:lif} that we repeat here



where we define . Spiking then takes place by applying  on the membrane potential



which is defined as a unit step function centered at the threshold 



Thus, given an input spikes tensor  ( being the batch size  number of time steps and  number of neurons in layer ) and weights  we obtain the output spikes  by applying \eqref{supp_eq:slif_discrete}, \eqref{supp_eq:spike_def}, \eqref{supp_eq:f_def}.

\subsection{Network and weight initialisation}
All layers are feed-forward fully connected in all experiments unless otherwise specified.  The weights were sampled from a uniform distribution  where  is the number of input connections to the layer. In all experiments we have an input layer, two hidden layers with the same number of neurons and a readout layer with as many neurons as output classes for the given dataset. The readout layer neurons are identical to the hidden layers except in the firing threshold which we set to infinity.

In the convolutional layer experiment, the first layer was a convolutional spiking layer with  filters, kernel size of  and stride of , followed by a max pool layer with kernel size of  and then flattened into a linear layer of  inputs and 10 outputs.


\subsection{Supervised and regularisation losses}

We have a loss composed of three terms: cross entropy loss, higher activity regularisation and lower activity regularisation. The cross entropy loss is defined as 



With  being a one hot target vector for batch sample  given a total batch size  and a total number of classes . The probabilities  are obtained using the Softmax function



Here, the logits  are obtained by taking the max over the time dimension on the readout layer membrane potential . For the SHD dataset we used 

We also use two regularisation terms to constrain the spiking activity. These terms have been shown to not degrade the network performance \cite{zenke2021remarkable}. First, we use a lower activity penalty to promote activity in the hidden layers.



Here  is the spike count of neuron  in layer  and batch sample . 

Secondly, the upper activity loss is added to prevent neurons to spike too often. 



 Finally the overall loss is obtained 



\subsection{Surrogate gradient}

We use the following function as the surrogate derivate of the firing function defined in \eqref{supp_eq:f_def}.



In the sparse case we use 



\newpage
\subsection{Parameters}

Here we summarise all parameters used in each dataset.

\begin{table}[h]
  \centering
  \begin{tabular}{llll}
    \toprule
                                & F-MNIST & N-MNIST & SHD \\
    \midrule
    Number of Input Neurons     &  &  &   \\
    Number of Hidden            &  &  &   \\
    Number of classes           &  &  &   \\
    Number epochs               &  &  &   \\
    B                           &  &  &   \\
    T                           &  &  &    \\
                      & ms & ms & ms  \\
     hidden               & ms & ms & ms  \\
     readout              & ms & ms & ms  \\
             & ms & N/A & N/A  \\
                        &  & N/A & N/A  \\
                         &  &  &   \\
                      &  &  &   \\
                        &  &  &   \\
                        &  &  &   \\
                         &  &  &   \\
    Optimiser                   & Adam & Adam & Adam  \\
    Learning Rate               &  & &   \\
    Betas                       &  &  &     \\
               &  &  &    \\
                   &  &  &   \\
                &  &  &    \\
                    &  &  &    \\
    \bottomrule
  \end{tabular}
  \caption{Network and training parameters}
\end{table}

\clearpage
\newpage
\section{Other results} \label{supp:other results}

\subsection{Average activity for varying number of hidden neurons}
\begin{figure}[!h]
\centering 
\includegraphics[width=\textwidth]{figures_supp/extra_plots/supp_plot_activity.pdf}
\caption{Average percentage of active neurons during training for each dataset and varying number of neurons (5 samples)}
\end{figure}

\subsection{Loss evolution for all datasets}
\begin{figure}[!h]
\centering 
\includegraphics[width=\textwidth]{figures_supp/extra_plots/supp_plot_loss.pdf}
\caption{Loss for each dataset when using 200 hidden neurons (5 samples)}
\end{figure}



\newpage
\subsection{Forward times}
\begin{figure}[!h]
\centering 
\includegraphics[width=\textwidth]{figures_supp/extra_plots/supp_forward_times.pdf}
\caption{Forward time for each dataset when using 200 hidden neurons (5 samples)}
\end{figure}
\begin{figure}[!h]
\centering 
\includegraphics[width=\textwidth]{figures_supp/extra_plots/supp_forward_times_all.pdf}
\caption{Average forward time for each dataset and varying number of neurons (5 samples)}
\end{figure}

\subsection{Backward times}
\begin{figure}[!h]
\centering 
\includegraphics[width=\textwidth]{figures_supp/extra_plots/supp_backward_times.pdf}
\caption{Backward time for each dataset when using 200 hidden neurons (5 samples)}
\end{figure}
\begin{figure}[!h]
\centering 
\includegraphics[width=\textwidth]{figures_supp/extra_plots/supp_backward_times_all.pdf}
\caption{Average backward time for each dataset and varying number of neurons (5 samples)}
\end{figure}

\newpage
\subsection{Forward memory}
\begin{figure}[!h]
\centering 
\includegraphics[width=\textwidth]{figures_supp/extra_plots/supp_forward_mem.pdf}
\caption{Forward memory for each dataset when using 200 hidden neurons (5 samples)}
\end{figure}
\begin{figure}[!h]
\centering 
\includegraphics[width=\textwidth]{figures_supp/extra_plots/supp_forward_mem_all.pdf}
\caption{Average forward memory time for each dataset and varying number of neurons (5 samples)}
\end{figure}


\subsection{Backward memory}
\begin{figure}[!h]
\centering 
\includegraphics[width=\textwidth]{figures_supp/extra_plots/supp_backward_mem.pdf}
\caption{Backward memory for each dataset when using 200 hidden neurons (5 samples)}
\end{figure}
\begin{figure}[!h]
\centering 
\includegraphics[width=\textwidth]{figures_supp/extra_plots/supp_backward_mem_all.pdf}
\caption{Average backward memory for each dataset and varying number of neurons (5 samples)}
\end{figure}

\newpage
\subsection{Memory saved}
\begin{figure}[!h]
\centering 
\includegraphics[width=\textwidth]{figures_supp/extra_plots/supp_mem_saved_all.pdf}
\caption{Average memory saved according to \eqref{eq:memory_saved} for each dataset and varying number of neurons (5 samples)}
\end{figure}


\subsection{Results on different GPUs} \label{supp:other_gpus}

Note that some entries are missing due to the GPU running out of memory.

\begin{figure}[!h]
\centering 
\includegraphics[width=\textwidth]{figures_supp/extra_plots/1060.pdf}
\caption{Backward speedup, overall layer speedup and backward memory memory saved on an NVIDIA 
GeForce GTX 1060}
\end{figure}

\begin{figure}[!h]
\centering 
\includegraphics[width=\textwidth]{figures_supp/extra_plots/1080ti.pdf}
\caption{Backward speedup, overall layer speedup and backward memory memory saved on an NVIDIA 
GeForce GTX 1080 Ti}
\end{figure}

\newpage
\section{Results on 5 hidden layers  network}

\begin{figure}[!h]
\centering 
\includegraphics[width=0.49\textwidth]{figures_supp/6-layer/loss_h300.pdf}
\includegraphics[width=0.49\textwidth]{figures_supp/6-layer/total_active_h300.pdf}
\caption{Loss history and layer activities when training on Fashion-MNIST with 5 hidden layers with 300 neurons each}
\end{figure}

\section{Weight gradient difference and relative error}


We show here the difference between the original weight gradient and that obtained from our method as well as its relative error. We like to note that the original gradient is not necessarily more accurate than the sparse one as surrogate gradient training results in approximated gradients. Thus, it is not a ground truth gradient and the real test is done by showing that our method achieves the same or better loss and testing accuracy. 

\begin{figure}[!h]
\centering 
\includegraphics[width=0.49\textwidth]{figures_supp/gradient difference/grad_diff.pdf}
\includegraphics[width=0.49\textwidth]{figures_supp/gradient difference/grad_rel_error.pdf}
\caption{Difference between the weight gradients displayed in \ref{fig:panel1}. The maximum relative error between two individual weights is  }
\end{figure}

\newpage
\section*{Checklist}
\begin{enumerate}

\item For all authors...
\begin{enumerate}
  \item Do the main claims made in the abstract and introduction accurately reflect the paper's contributions and scope?
    \answerYes{}
  \item Did you describe the limitations of your work?
    \answerYes{See sections \ref{section:main_text} and \ref{section:discussion}}
  \item Did you discuss any potential negative societal impacts of your work?
    \answerNA{}
  \item Have you read the ethics review guidelines and ensured that your paper conforms to them?
    \answerYes{}
\end{enumerate}

\item If you are including theoretical results...
\begin{enumerate}
  \item Did you state the full set of assumptions of all theoretical results?
    \answerYes{See section \ref{section:main_text} and Appendix \ref{supp:proof1}} and \ref{supp:compl_analysis}
	\item Did you include complete proofs of all theoretical results?
    \answerYes{Section \ref{section:main_text} and Appendix \ref{supp:proof1}} and \ref{supp:compl_analysis}
\end{enumerate}

\item If you ran experiments...
\begin{enumerate}
  \item Did you include the code, data, and instructions needed to reproduce the main experimental results (either in the supplemental material or as a URL)?
    \answerYes{The code has been included in the supplementary materials}
  \item Did you specify all the training details (e.g., data splits, hyperparameters, how they were chosen)?
    \answerYes{See Appendix \ref{supp:training_details}}
	\item Did you report error bars (e.g., with respect to the random seed after running experiments multiple times)?
    \answerYes{All experimental results include standard error in the mean over multiple trials. See section \ref{section:experiments} and Appendix \ref{supp:other results}}
	\item Did you include the total amount of compute and the type of resources used (e.g., type of GPUs, internal cluster, or cloud provider)?
    \answerYes{See section \ref{section:experiments} and Appendix \ref{supp:other results}}
\end{enumerate}

\item If you are using existing assets (e.g., code, data, models) or curating/releasing new assets...
\begin{enumerate}
  \item If your work uses existing assets, did you cite the creators?
    \answerYes{The three datasets used have been cited}
  \item Did you mention the license of the assets?
    \answerNo{All three datasets are licensed either by  \textit{Creative Commons Attribution-ShareAlike 4.0 license} or \textit{MIT License}. This will be included in the acknowledgements in the final version}
  \item Did you include any new assets either in the supplemental material or as a URL?
    \answerYes{The code used to run the experiments is included in the supplementary materials}
  \item Did you discuss whether and how consent was obtained from people whose data you're using/curating?
    \answerNA{}
  \item Did you discuss whether the data you are using/curating contains personally identifiable information or offensive content?
    \answerNA{}
\end{enumerate}

\item If you used crowdsourcing or conducted research with human subjects...
\begin{enumerate}
  \item Did you include the full text of instructions given to participants and screenshots, if applicable?
    \answerNA{}
  \item Did you describe any potential participant risks, with links to Institutional Review Board (IRB) approvals, if applicable?
    \answerNA{}
  \item Did you include the estimated hourly wage paid to participants and the total amount spent on participant compensation?
    \answerNA{}
\end{enumerate}

\end{enumerate}

\end{document}
