\documentclass[3p]{elsarticle}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage[usenames,dvipsnames]{color}
\usepackage{enumitem}
\usepackage{tikz}
\tikzset{cross/.style={cross out, draw=black, minimum size=2*(#1-\pgflinewidth), inner sep=0pt, outer sep=0pt},
cross/.default={8pt}}

\usepackage{subfigure}
\usepackage[ruled,vlined,linesnumbered]{algorithm2e}
\usepackage{lineno}

\newcommand{\comm}[1] {}
\newcommand{\VD}{\mathcal{VD}}
\newcommand{\PP}{\mathcal{P}}
\newcommand{\PPP}{\texttt{P}}
\newcommand{\HH}{\mathcal{I}}
\newcommand{\CC}{\mathcal{C}}
\newcommand{\TT}{\mathcal{T}}
\newcommand{\PT}{\PP\TT}
\newcommand{\HT}{\HH\TT}
\newcommand{\FF}{\mathcal F}
\newcommand{\stepover}{\delta}
\newcommand{\tStepover}{\Delta}
\newcommand{\parentEdge}{\texttt{ParentE}}
\newcommand{\childEdges}{\texttt{ChildEs}}
\newcommand{\nodeStart}{\texttt{Start}}
\newcommand{\nodeEnd}{\texttt{End}}
\newcommand{\indexInParentNode}{\texttt{IndexInStart}}
\newcommand{\getNextEdge}{\texttt{NextCCW}}
\newcommand{\getNextEdgeCW}{\texttt{NextCW}}
\newcommand{\ttimeO}{\texttt{TmNd}}
\newcommand{\ttimeT}{\texttt{TmEd}}
\newcommand{\speedO}{\texttt{VeNd}}
\newcommand{\speedT}{\texttt{VeEd}}
\newcommand{\height}{\texttt{Hgt}}
\newcommand{\holeHeight}{\texttt{Isl}\height}
\newcommand{\boundaryHeight}{\texttt{Bnd}\height}
\newcommand{\getSpeed}{\texttt{GetSp}}
\newcommand{\getDist}{\texttt{GetDs}}
\newcommand{\getTime}{\texttt{GetTm}}
\newcommand{\getPoint}{\texttt{GetPt}}
\newcommand{\setTimesAndSpeeds}{\texttt{SetTmAndSp}}
\newcommand{\setAllTimesAndSpeeds}{\texttt{SetAllTmAndSp}}
\newcommand{\reuseAcc}{\texttt{ReuseAcc}}
\newcommand{\wavefront}{\texttt{Wf}}
\newcommand{\holeWavefront}{\texttt{Isl}\wavefront}
\newcommand{\boundaryWavefront}{\texttt{Bnd}\wavefront}
\newcommand{\wavefrontLength}{\wavefront\texttt{Lng}}
\newcommand{\totalWavefrontLength}{\texttt{Ttl}\wavefrontLength}
\newcommand{\rootNode}{\texttt{Root}}
\newcommand{\point}{\texttt{Pt}}
\newcommand{\spiral}{\texttt{Sp}}
\newcommand{\parent}{\texttt{Pa}}
\newcommand{\parentWavefrontCorner}{\parent\wavefront}
\newcommand{\parentSpiralCorner}{\parent\spiral}
\newcommand{\arc}{\texttt{Arc}}
\newcommand{\inflDist}{\texttt{InfDst}}
\newcommand{\weight}{\texttt{Wgt}}
\newcommand{\bridges}{\texttt{Bridges}}
\newcommand{\makeBridges}{\texttt{Make}\bridges}
\newcommand{\ora}[1]{\overrightarrow{#1}}
\newcommand{\picc}[1]{}

\newtheorem{lemma}{Lemma}
\newtheorem{proposition}{Proposition}


\journal{arXiv.org}

\begin{document}

\begin{frontmatter}

\title{Spiral Toolpaths for High-Speed Machining of 2D Pockets with or without Islands}
\author{Mikkel Abrahamsen\fnref{fn1}}
\fntext[fn1]{A large part of this work was made while the author worked for
Autodesk, Inc.}
\address{Department of Computer Science\\
University of Copenhagen\\
Universitetsparken 5\\
DK-2100 K\o{}benhavn \O\\
Denmark\\
\texttt{miab@di.ku.dk}}

\begin{abstract}
We describe new methods for the construction of spiral toolpaths for high-speed machining.
In the simplest case, our method takes a polygon as input and a number  and
returns a spiral starting at a central point in the polygon, going around towards the boundary
while morphing to the shape of the polygon. The spiral consists of
linear segments and circular arcs, it is  continuous, it has no self-intersections, and
the distance from each point on the spiral to each of the neighboring revolutions is at most .
Our method has the advantage over previously described methods that it is
easily adjustable to the case where there is an island in the polygon to be avoided by the spiral.
In that case, the spiral starts at the island and morphs
the island to the outer boundary of the polygon. It is shown how to apply that method to make
significantly shorter spirals in polygons with no islands than what is obtained by conventional
spiral toolpaths. Finally, we show how to make
a spiral in a polygon with multiple islands by connecting the islands into one island.
\end{abstract}

\begin{keyword}
Computer-aided manufacturing \sep CNC machining \sep High-speed machining
\sep Pocket machining \sep Spiral toolpath




\end{keyword}

\end{frontmatter}





\section{Introduction}

A fundamental problem often arising in the CAM\comm{\footnote{Computer-aided manufacturing.}} industry
is to find a suitable toolpath for milling a pocket that is defined by a shape in the plane.
A CNC\comm{\footnote{Computer numerical control.}} milling machine is programmed to follow
the toolpath and thus cutting a cavity with the shape of the given pocket in a solid piece of material.
The cutter of the machine can be regarded as a circular disc with radius , and
the task is to find a toolpath in the plane
such that the swept volume of the disc, when the disc center is moved along the path,
covers the entire pocket. We assume for simplicity that the toolpath is allowed
to be anywhere in the pocket.

Some work has been made on spiral toolpaths that morphs a point
within the pocket to the boundary of the pocket \cite{bieterman2003, chuang2007, held2009, banerjee2012, held2014, huertas2014}.
The method described by Held and Spielberger
\cite{held2009} yields a toolpath that (i) starts at a user-specified
point within the pocket, (ii) ends when the boundary is reached, (iii) makes the cutter remove
all material in the pocket, (iv) has no self-intersections, (v)
is  continuous\footnote{A plane curve
is \emph{ continuous} or \emph{tangent continuous}
if there exists a continuous and differentiable parameterization of the curve.},
(vi) makes the width of material cut away at most  at any time, where
 is a user-defined constant called the \emph{stepover}.
We must have , since otherwise some material might not be cut away.
See figure \ref{spiral} for an example of such a spiral toolpath. It is the result of an algorithm
described in the present paper, but has similar appearance as the spirals described by Held and Spielberger
\cite{held2009}.

Most traditional toolpath patterns have many places where the cutter does not cut away any new
material, for instance in retracts where it is lifted and moved in the air to another place
for further machining, or self-intersections of the toolpath, where the tool
does not cut away anything new when it visits a place for the second time.
That may increase machining time and lead to visible marks on the
final product. Spiral toolpaths have the advantage that the cutter is
cutting during all of the machining and that, at the same time,
the user can control the stepover.
Spiral toolpaths are particularly useful when doing high-speed machining, where the
rotational speed of the cutter and the speed with which it is moved along the
toolpath is higher than in conventional milling.
We refer to Held and Spielberger \cite{held2009} for a more detailed discussion of
the benefits of spiral toolpaths compared to various other toolpath patterns
and more information on CNC milling in general.

Bieterman and Sandstrom \cite{bieterman2003} and Huertas-Tal{\'o}n et al.~\cite{huertas2014}
give methods
for computing spiral toolpaths by solving elliptic partial differential equation
boundary value problems defined on the pocket. However, the methods only work
for star-shaped pockets\footnote{A polygon is \emph{star-shaped} if there
exists a point  in the polygon such that the segment  is contained in the polygon
for every other point  in the polygon.} \cite{held2009}.

We describe an alternative construction of spirals that also satisfy the previously mentioned properties
of the construction of Held and Spielberger \cite{held2009}.
They define a wave that starts at a point in the Voronoi diagram of the pocket at time
. When the time increases, the wave moves towards the boundary of the
pocket in every direction so that at time ,
it reaches the boundary everywhere. The shape of the wave at a certain time represents
the area machined at that time. Roughly speaking,
the spiral is obtained by traveling around the wave while the time
increases from  to .
Our method is similar up to this point, but the way we define the wave is different.
The wave defined in \cite{held2009} is the union of growing
disks placed on the Voronoi diagram of the pocket.
In our model, the wave is at any time a polygon with its corners on
the Voronoi diagram of the pocket.
Using that model, we define a spiral consisting of line segments which is
at last rounded by circular arcs to get a  continuous curve.

In practice, it is very common that there is one or more islands in the
pocket that should be avoided by the cutter, for instance if there are areas of material that should
not be machined to the same depth.
It is only described by Held and Spielberger \cite{held2009} how to handle simply-connected
pockets, i.e., there must be no islands.
In their following paper \cite{held2014}, it is described how one can handle a pocket with an island
by connecting it to the boundary with a ``bridge'', effectively getting a pocket without islands.
Thus, the resulting spiral morphs a point to a shape consisting of the island,
the bridge, and the pocket boundary.
A big advantage of our method is that it has a natural extension to pockets with one
island in the sense that the spiral morphs the shape of the island to the pocket boundary.
We exploit the fact that the Voronoi diagram of a pocket with an island consists of exactly one cycle
and trees rooted at that cycle to extend our wave model to work in this case.
This is our biggest new contribution. We shall demonstrate natural applications of this method
to make significantly shorter spirals for pockets with no holes than one could obtain with previously described methods. We also show how to handle pockets with multiple holes.

The paper is based on the author's experiences while developing the morphed spiral strategy for the
Autodesk\texttrademark{} CAM products (HSMWorks,
Inventor HSM\textsuperscript{\textregistered}, and Fusion 360\textsuperscript{\textregistered}).
The morphed spiral seems to be quite popular among the users.
Due to the abundant number of real-world parts that have been available during the development,
we guarantee that it is possible
to make an efficient industrial-strength implementation of the algorithms described here.

We use Held's \texttt{VRONI} library for the computation of Voronoi diagrams \cite{held2001}.
All figures in the paper are automatically generated using our implementation of the algorithms.

The rest of the paper is structured as follows:
In section \ref{withoutHoles}, we describe our basic method for making a spiral
that morphs a point to the boundary in a simply-connected pocket.
Section \ref{pocketWithHole} describes how the method is adapted to a pocket with one island.
Using that method, we describe in section \ref{skeletonMethod} an alternative spiral in simply-connected pockets which will be superior to the one from section \ref{withoutHoles} in many cases.
In section \ref{multipleHoles}, we show how to construct at spiral
around arbitrarily many islands by first connecting the islands into one island.
Finally, we conclude the paper in section \ref{conclusion}
by suggesting some future paths of development of spiral
toolpaths.

\subsection{Notation and other general conventions}
We use zero-based numbering of arrays.
For a point , the point  is the counterclockwise rotation of .
Given two distinct points  and ,  is the segment between  and 
and  is the half-line that starts at  and contains .
Given a set of points  in the plane,  denotes the boundary of .
In algorithms, we
use semicolon to separate different statements written on the same line.

\section{Computing a spiral in a pocket without islands}\label{withoutHoles}

In this section we describe a method to compute a spiral in a given simply-connected
2D pocket , see figure \ref{spiral}.
In practice, the boundary of a pocket is often described by line segments and more advanced pieces of
curves, such as like circular arcs, elliptic arcs, and splines.
However, it is always possible to use a sufficiently accurate linearization of the input,
so we assume for simplicity that  is a polygon.

Our algorithm first constructs a polyline spiral, see figure \ref{polylineSpiral}.
The polyline spiral must respect the stepover , i.e.,
the distance from every point to the neighboring revolutions
and the distance from the outermost revolution to 
is at most .
In section \ref{rounding}
we devise a method for rounding the polyline spiral to get a  continuous spiral
consisting of line segments
and circular arcs. 

The corners of the
polyline spiral are points on the edges of the Voronoi diagram of , and there
is a corner at each intersection point between the spiral and the Voronoi diagram.
We only consider the part of the Voronoi diagram inside . We have found
that we get better results in practice by modifying the Voronoi diagram slightly.
We describe these modifications in sections \ref{enriching} and \ref{removing}
to avoid too many technical details here.
See figures \ref{rawVD}--\ref{finalVD} for a concrete example of the modifications
we make on the Voronoi diagram.
Let  be the modified Voronoi diagram of the pocket . 
Like the Voronoi diagram of , the modified diagram
 has the following properties which are necessary and sufficient for
the computation of the spiral:
\begin{itemize}
\setlength\itemsep{0em}
\item  is a plane tree contained in ,
\item each leaf of  is on the boundary  of ,
\item there is at least one leaf of  on each corner of ,
\item all the faces into which  divides  are convex.
\end{itemize}

\begin{figure*}
\centering
\subfigure[] {
\includegraphics{fig1a.pdf}
\label{rawVD}
}\quad
\subfigure[]{
\includegraphics{fig1b.pdf}
\label{enrichedVD}
}
\subfigure[]{
\includegraphics{fig1c.pdf}
\label{finalVD}
}
\caption{\subref{rawVD} The Voronoi diagram.
\subref{enrichedVD} The Voronoi diagram enriched with equidistantly placed
segments perpendicular to long edges.
\subref{finalVD} The final diagram  where double edges going to concave corners
of  are replaced by their angle bisector.
}
\end{figure*}

\begin{figure*}
\centering
\subfigure[]{
\includegraphics{fig2a.pdf}
\label{wavefrontsBad}
}\quad
\subfigure[]{
\includegraphics{fig2b.pdf}
\label{wavefrontsGood}
}
\caption{The wavefronts in the same polygon  for the same stepover 
but using two different diagrams to define the wavefronts.
\subref{wavefrontsBad} The wavefronts obtained using the Voronoi diagram. The Voronoi
diagram is in gray.
\subref{wavefrontsGood} The wavefronts obtained using .  is in gray.
}
\label{wavefronts}
\end{figure*}

\begin{figure*}
\centering
\subfigure[]{
\includegraphics{fig3a.pdf}
\label{polylineSpiral}
}\quad
\subfigure[]{
\includegraphics{fig3b.pdf}
\label{spiral}
}
\caption{
\subref{polylineSpiral} The polyline spiral and  in gray.
\subref{spiral} The final rounded spiral.
}
\label{firstSpirals}
\end{figure*}

\subsection{The wave model}\label{waveModel}

We imagine that a wave starts at time  at the point  inside . The wave moves out
in every direction such that at time , it has exactly the same shape as .
The shape of the wave at a specific time is called a \emph{wavefront}.
The wave is growing in the sense that if ,
the wavefront at time  is contained in the wavefront at time .
We choose  as a point in the diagram  and consider  as a tree
rooted at . We define the time
at which the wave hits each node and the speed with which it travels on each edge in .
The speed of the wave is always constant or decreasing.
Thus, we create a continuous map  that assigns
a time value between 0 and 1 to each point on . If  is a point moving along a path
on  from  to any leaf,
the value  increases monotonically from 0 to 1.
For each time , the wavefront is a polygon inside  and the vertices of the wavefront
are all the points  on  such that . Note that there is exactly one such point
on each path from  to a leaf of  for a given .

We define a time step  for some
integer  and compute the wavefront at the times
, where ,
see figure \ref{wavefronts}.
By \emph{wavefront} , we mean the wavefront at time .
We choose  such that the distance from each point on
wavefront  to each of the wavefronts  and 
is at most  when  and , respectively.
In other words, the \emph {Hausdorff distance} between
two neighboring wavefronts is at most .
Recall that the Hausdorff distance between two sets  and  is
, where .
For each ,
we compute a revolution of the polyline spiral by interpolating between the wavefronts 
and . We describe in sections \ref{constructingWavefronts}
and \ref{interpolating} how to make the wavefronts and the interpolation such
that the stepover is respected between neighboring revolutions.

\subsection{Choosing the starting point  and the number of revolutions of the spiral}\label{startingPoint}

In order to get a spiral with small length, we try to minimize the number of revolutions.
Consider the longest path from  to a leaf in .
The length of a path is the sum of edge lengths on the path.
If  is the length of the longest path, then  wavefronts
are necessary and sufficient for the stepover to be respected between all neighboring wavefronts.
Therefore, we choose  as the point in  that minimizes the longest distance to a leaf in
. That is a unique point traditionally known as the \emph{center} of .
Handler \cite{handler1973} gives a simple algorithm to compute  linear time in the size of
.
The center will most likely not be a node in , but an interior point on some edge. In that
case, we split the edge into two edges by introducing a node at .

\subsection{Our representation of }

We consider  as a directed, rooted tree with the node  at  being the root.
We let  be the position of the node . Let
 be the subtree rooted at node .
We store a pointer  to the edge having end node .
We say that edge  is the \emph{parent edge} of node  and any edge
having start node .
We also store an array
 of the edges going out of  sorted in counterclockwise order with the
edge following  being the first. For , the choice of the first child
edge does not matter.
For each edge , we store pointers  and  to 
the start and end nodes of . We also store an index 
such that . If  is an edge, we say that 
and  are \emph{incident} to  and that  is \emph{incident} to
 and .
For an edge  and node  incident to ,
we let ,
where  is the edge after  among the edges incident to  in counterclockwise
order. The function  can be implemented so that it runs in constant time
using the values defined here.

Using , we can traverse all of  in counterclockwise direction in linear time.
We start setting .
In each iteration, we let  be the other node incident to  and
then set .
We stop when we have traversed every edge, i.e., when
 at the end of an iteration. Note that each edge 
is visited twice, once going down the tree  and once going up.

\subsection{Defining the movement of the wave}\label{movementOfWave}

Let  for each node  be the maximal distance from  to a leaf in .
All the  values can be computed in linear time by traversing  once.
For each node , we define the time  where the wave reaches .
We set . We also define the speed  that the wave has when it
reaches . We set .
The wave starts at the root at time 
and travels with constant speed  on the paths to the farthest leafs in .
(Due to our choice of the starting point , there will always be at least two paths
from  to a leaf with maximum length.)
Hence,
it reaches those leafs at time . On all the shorter paths, we make the wave slow down
so that it reaches every leaf at time .
In \ref{appA}, we describe in detail a possible way of defining the speed and time of the wave
on each point in .

When the movement of the wave is defined,
we may define  as the point on edge  with ,
where .

\subsection{Constructing the wavefronts}\label{constructingWavefronts}

\begin{figure*}[h]
\centering
\subfigure[]{
\includegraphics[scale=0.97]{fig4a.pdf}
\label{wavefrontsParents}
}\quad
\subfigure[]{
\includegraphics[scale=0.97]{fig4b.pdf}
\label{polylineSpiralParents}
}
\caption{The construction of a polyline spiral in a polygon :
\subref{wavefrontsParents} The wavefronts in green and blue arrows from each wavefront corner

to its parent .
The diagram  is in gray.
\subref{polylineSpiralParents} The polyline spiral in black obtained by interpolating
between the wavefronts. The purple arrows are from each corner 
of the spiral to its parent .
}
\label{polylineSpiralFig}
\end{figure*}

We make a spiral with  revolutions, where
.
We use the slightly smaller stepover 
so that the maximum distance between two neighboring
revolutions is smaller. That gives more flexibility to smooth the spiral later on as described in section \ref{rounding}.
We set  and compute a wavefront for each of the times
. The two-dimensional array
 stores the wavefronts, so that the wavefront at time  is the array
. Wavefront  is constructed by traversing  once and finding every
point on  with time  in counterclockwise order.
Let  be an edge we have not visited before, and let  and
. There is a corner of wavefront  on  if
. If that is the case, we add
 to the end of .
We make one corner in  for each of the child edges of the root,
, and all these corners are copies of
the point . Using this construction,
there is exactly one corner of each wavefront on each path from
 to a leaf of .

For each corner , we store the length of the part of the
wavefront up to the corner, i.e.~ and

for . Here  is the Euclidean norm. We also store the total length of
 as .


We introduce a rooted tree with the wavefront corners as the nodes.
See figure \ref{wavefrontsParents}.
The parent of a corner , , is the
unique corner  on wavefront  on the path from
 to .
We store  as , i.e.,
the parent of  is .

Since the distance from each wavefront corner to each of its children is at most ,
the Hausdorff distance between two neighboring wavefronts is also at most .
Furthermore, since the wave is moving with positive speed towards the leafs of  and the faces
into which  divides  are convex, neighboring wavefronts do not intersect each other.
From the order in which the corners of a wavefront is constructed, it is also clear that
a wavefront does not intersect itself.

\subsection{Interpolating between the wavefronts}\label{interpolating}

We construct a polyline spiral stored as an array . For each , we construct one
revolution of the spiral by interpolating between wavefront  and wavefront . Every
corner of the spiral is a point on . There is exactly one spiral corner
on the path in  from each wavefront corner  to its parent
.
Assume for now that we know how to choose the actual corners of the polyline spiral. We shall get
back to this shortly.

The first corner  is on the root node of , and for every other
corner , , we store an index of the parent ,
such that the parent 
is the first corner we meet on the path in  from  to the root.
Figure \ref{polylineSpiralParents} shows the resulting polyline spiral and the parents of each corner.
We define the spiral
such that the distance between a spiral corner and its parent is at most . It follows that
the distance from a point on the polyline spiral to the neighboring revolutions is at most .

Here we describe how to define the -pointers.
When we have constructed
a spiral corner  which is on the path from  to its parent wavefront
corner , we know that the first spiral corner on the path from
 to the root is , and we store this information as
.
Therefore, when we have made a new spiral corner  on the path from 
to its parent , the parent of  is defined to be
. By doing so, the corner
 will be
the first spiral corner on the path from  to the root.

In the following we describe how to choose the corners of the polyline spiral.
We assume that we have finished the revolution of the spiral between wavefronts  and
 and we show how to make the revolution between wavefronts  and .
For each wavefront corner , we find the point  on the path to
, where , with time

If  is more than  away from
, we redefine  to be the point on the same path
with distance exactly .
We mark the path from  to the root of .
See figure \ref{interpolationDetail}.

When we have done the marking for each , we traverse wavefront  once more.
For each wavefront corner ,
we find the first marked point on the path
to the root. We let  be that point and
 be its time. We have that , because
a later wavefront corner , , can mark more of the path from
 to the root. Therefore, we can have  for some .
Using this construction, there is exactly one distinct
-point on each path from a wavefront corner to the root.
Furthermore, we know that the distance from  to the spiral corner

is at most .

\begin{figure*}[h]
\centering
\subfigure[]{
\includegraphics{fig5a.pdf}
\label{interpolation}
}\quad
\subfigure[]{
\includegraphics{fig5b.pdf}
\label{convexification}
}
\caption{\subref{interpolation} The interpolation between the two blue wavefronts. The boundary
 is in black and the diagram  is in gray. The red circles
are the points  and the marked part of of  is in black. The green crosses
are the resulting points of the polyline spiral stored in  after the convexification process.
\subref{convexification} Related values for the same interpolation:
The points  are red circles.
The upper convex hull  of the points is a black curve, and the green crosses are the points
 on that hull.}
\label{interpolationDetail}
\end{figure*}

The polyline defined by the points 
is basically our interpolated spiral, but the points
have a tendency to have unnecessarily sharp corners if  is relatively dense, which is
often the case for polygons  occurring in real-world problems.
To avoid unnecessary sharp corners, we apply a method which we denote as the \emph{convexification},
see figure \ref{interpolationDetail}.
Let  be the length of the polyline
until  and consider the points . We compute the upper
convex hull of these points, e.g. using the method of Graham and Yao \cite{graham1983}.
Let  be the function whose graph
is the upper hull. By definition, we have that 
for each .
We now choose the corners of  in the following way:
For each wavefront corner  in order, we find the point 
on the path to the root with time
. If  is more than  away from the parent spiral corner
 (which will be the
parent of the spiral corner we are constructing), we
choose instead  to be the point on the same path which is exactly  away.
To avoid repetitions of the same point in , we add  to the end of 
if  is different from the last point in .
Since we get the spiral corners by moving the -points closer to wavefront ,
we get exactly one distinct spiral corner on each path from a wavefront corner to the root.
When  is sparse like in figure \ref{polylineSpiralFig}, the convexification makes no visible
difference between the -points and the final points in ,
but when  is dense as in figure \ref{interpolationDetail}, the effect is significant.

We also add one revolution around  to the end of ,
which is used to test that
the last interpolated revolution respects the stepover when the spiral is rounded later on.


The polyline spiral constructed as described clearly satisfies that the distance from
a point on one revolution to the neighboring revolutions is at most .
Furthermore, each revolution is between two neighboring wavefronts
since all the corners of the interpolation between wavefronts  and  have times
in the interval .
The wavefronts do not intersect as mentioned earlier, so different revolutions of
the polyline spiral do not either. It is also clear from the construction that
one revolution does not intersect itself.
Therefore, the polyline spiral has all the properties that we require of our spiral
except being  continuous. How to obtain that is described in section
\ref{rounding}.

\subsection{Enriching the diagram}\label{enriching}

In this and the following section, we describe some modifications we make on the Voronoi
diagram of  before doing anything else. The result is the diagram .
Long edges on  lead to long
faces in the Voronoi diagram,
so that the wave is not moving towards the boundary 
in a natural way, see figure \ref{wavefronts}.
In figure \ref{wavefrontsBad}, the wave starts on a long edge, and the first three
wavefronts are all degenerated polygons with only two corners, both on the edge.
Therefore, we need edges going directly to the boundary with a distance to each other
of at most ,
so that each wavefront has corners on more edges than the previous one.
We have obtained this by traversing the Voronoi diagram and inspecting each pair of
consecutive leafs  and . Such a pair of nodes are
on the same or on two neighboring corners of . Assume the latter, so that
there is a segment  on  from  to  and a face  of the Voronoi diagram
to the left of .
Let  be the vector from  to ,
 be the length of  and
. We want to subdivide  into  faces.
Let
, , be interpolated points on .
Let  be the half-line starting at  with direction ,
where  is the counterclockwise rotation of .
For each , we find the first intersection point between  and the Voronoi
diagram. Assume the intersection for some  is a point  on an edge .
If the smallest angle between
 and  is larger than 50 degrees, we split  into two edges by introducing a node at 
and add a segment from that node to a new node at . If the smallest angle is less than 50 degrees,
the Voronoi diagram is moving fast enough towards the boundary so that the wavefronts will be fine
in that area without adding any additional edges.
Figure \ref{enrichedVD} shows the result of enriching the Voronoi diagram shown in
figure \ref{rawVD}.

\subsection{Removing double edges to concave corners}\label{removing}

A \emph{concave} corner of  is a corner where the inner angle is more than 180 degrees.
Each concave corner  on  leads to a face in the Voronoi diagram of all the points
in  being closer to  than to anything else on the boundary of .
Therefore, there are two edges  and  of the Voronoi diagram with an endpoint on .
We have found that we get a better spiral if we remove these
edges and instead add an edge following the angle bisector of the edges, i.e., we follow the bisector
from  and find the first intersection point  with the Voronoi diagram and add an edge from
 to , see figure \ref{finalVD}.
The reason that this process improves the resulting spiral is that the wavefronts
will resemble  more because they will have one corner on the
bisector edge corresponding to the corner  on .
We can only do this manipulation if the resulting
faces are also convex. That is checked easily by computing the new angles of the manipulated faces
and it seems to be the case almost always.

\subsection{Rounding the polyline spiral}\label{rounding}

In this section we describe a possible way for smoothing the polyline spiral to get a
 continuous spiral.
See figure \ref{spiralRounding} for a comparison between the rounded and unrounded spiral from figure
\ref{firstSpirals} using this method.
Note that some of the arcs of the rounded spiral rounds multiple corners
of the polyline spiral.

For each corner on the polyline spiral, we substitute a part of the spiral containing the corner with a
circular arc which is tangential to the polyline spiral in the endpoints.
That gives a spiral which is  continuous, i.e., having no sharp corners. Each arc is either
clockwise or counterclockwise. For each index , let
 be the segment from  to  and
 be the vector from  to .
Each arc has the startpoint  on some segment  and the endpoint 
on another segment , , so that the arc \emph{substitutes} the part of the
polyline spiral from  to . We say that the arc \emph{rounds} the corners
 to .
We call the arc \emph{tangential} if it is counterclockwise and its center is on the intersection of the
half-lines  and  or it is
clockwise and its center is on the intersection of the half-lines
 and .

We store a pointer  to the arc that substitutes the corner .
The same arc can substitute multiple consecutive corners, so that
.
In that case, when ,
the \emph{neighbors} of  are  and .
Two different arcs must substitute disjoint parts of the polyline spiral
for the rounded spiral to be well-defined. We subdivide each segment
 at a point  such that an arc ending at
 must have its endpoint at the segment  and an arc
beginning at  must have its startpoint on the segment
. The point  is chosen as a weighted average of  and
 so that the arc rounding the sharpest of the corners  and 
gets most space. Let  be the angle at corner  of the polyline spiral.
We set  and choose  as
.

We keep a priority queue  \cite{cormen2009} of the arcs that can possibly be
enlarged.
After each enlargement of an arc, the resulting spiral respects the stepover 
and no self-intersection has been introduced. We say that an arc with these properties is
\emph{usable}.
Initially, we let each corner be rounded by a
degenerated zero-radius arc, and  contains all these arcs.
Clearly, these initial zero-radias arcs are usable by definition.
We consider the front arc  in  and try to find another usable arc 
that substitutes a longer chain of the polyline spiral.
The new arc  normally has a larger radius than .
If possible, we choose  so that it also
substitutes one or, preferably, two of the neighbors of . Assume that we succeed
in making a usable arc  substituting both  and its neighbors  and .
Now  rounds the union of the corners previously rounded by , , and .
For all these corners, we update the -pointers
and we remove , , and  from .
We add  to . For every corner that  rounds,
we also add the arcs rounding the children and parents of that corner to ,
since it is possible that these arcs can now be enlarged.
If no larger usable arc  is found, we just remove  from .
The rounding process terminates when  is empty.

We test if an arc is usable by measuring the distance to the arcs
rounding the child and parent corners. That is easily done using elementary
geometric computations.

Here we describe how to find the largest usable arc rounding the corners
 to , . We find the possible radii of tangential arcs beginning at
a point on  and ending at a point on  using elementary geometry.
There might be no such arcs, in which case we give up
finding an arc rounding these corners.
Otherwise, we have an interval  of radii of tangential arcs
going from  and ending on .
We check if the arc with radius  is usable.
If it is not, we give up. Otherwise, we check if
the arc with radius  is usable. If it is, we use it. Otherwise, we
make a binary search in the interval 
after the usable arc with the largest radius. We stop when the binary search interval
has become sufficiently small, for instance , and use the arc
with the smallest number in the interval as its radius.

The order of the arcs in  is established in the following way:
We have found that giving the arc  the priority
 gives good results, where
 is the radius of ,  is the size of the subtended angle from the center of 
in radians, and
 is the radius of the maximum circle contained in .
The front arc in  is the one with smallest -value.
We divide by  to make the rounding invariant when  and  are scaled
by the same number.
 can be obtained from the Voronoi diagram of , since the largest inscribed circle
has its center on a node in the diagram.
If , we set , since there is no corner to round.

We see that arcs with small radii or large subtended angles are chosen first for enlargement.
In the beginning when all the arcs in  have zero radius, the arcs in the sharpest corners are
chosen first because their degenerated arcs have bigger subtended angles -- even though the radius
is zero, we can still define the start and end angle of the arc according to the slope of the segments
meeting in the corner and thus define the subtended angle of the arc.

If two or three arcs are substituted by one larger arc each time we succeed in making a larger arc,
we are sure that
the rounding process does terminate, since the complexity of the spiral decreases.
However, it is often not possible to merge two or three arcs, but only to make a larger
arc rounding the same corners as an old one. The rounded spiral gets better, but we cannot
prove that the process terminates. In practice, we have seen fast termination in any tested example.
A possible remedy could be only to allow each arc to increase in size without rounding more corners
a fixed number of times.

\begin{figure*}
\centering
\includegraphics{fig6.pdf}
\label{spiralRounding}
\caption{The spirals from figure \ref{firstSpirals} together. The polyline spiral is blue and the rounded
spiral is black.}
\end{figure*}

\section{Computing a spiral in a pocket with an island}\label{pocketWithHole}

In many practical applications, the area to be machined is not simply-connected,
but has one or more ``islands'' that should not be machined. It might be because there are
physical holes in the part or areas of a thicker layer of material not to be machined in the same depth.
Therefore, assume that we are
given a polygon  and a single polygonal island  in the interior of . In
section \ref{multipleHoles} we suggest a method to deal with multiple islands.
By , we denote the closed set of points which are in the interior or
on the boundary of  but not in the interior of .
We want to compute a spiral which
is contained in  such that the Hausdorff distance is at most
 between (i) two consecutive revolutions,
(ii)  and the first revolution, and (iii)  and the last revolution.
As before,  is the user-defined \emph{stepover}.
We also require
that the spiral is  continuous and
has no self-intersections. See figure \ref{holeResult} for an example.

As in the case with a simply-connected pocket, we use a wave model to construct the spiral.
We imagine a wave that has exactly the shape of  at time  and moves
towards , so that at the time , it reaches  everywhere.
We explain how to define a polyline spiral. The spiral should be rounded by a method similar to the one
described in section \ref{rounding}. 

\subsection{The Voronoi diagram of a pocket with an island}

We use the Voronoi diagram of
the set of line segments of  and . As in the case with no islands, we modify the
diagram slightly. Let  be the modified polygon. Like the true Voronoi diagram,
the modified diagram  has the following properties:
\begin{itemize}
\setlength\itemsep{0em}
\item  is a connected, plane graph contained in ,
\item each leaf of  is on the boundary of  or ,
\item there is at least one leaf of  on each corner of  and ,
\item all the faces into which  divides  are convex,
\item  contains exactly one cycle,
the cycle is the locus of all points being equally close to  and , and
 is contained in its interior.
\end{itemize}

\begin{figure*}
\centering
\subfigure[]{
\includegraphics[scale=0.98]{fig7a.pdf}
\label{holeVD}
}\quad
\subfigure[]{
\includegraphics[scale=0.98]{fig7b.pdf}
\label{holeResult}
}
\caption{
\subref{holeVD} A polygon  with an island , both in black.
The diagram  of  is drawn with the cycle  in blue
and the other edges in gray.
\subref{holeResult} The resulting spiral.
}
\label{spiralWithHole}
\end{figure*}

The diagram  is consisting of one cycle , which we also denote by the \emph{central cycle},
and some trees growing out from , see figure \ref{holeVD}.
Each of the trees grows either outwards and has all
its leafs on 
or inwards and has all its leafs on .
The general idea is to use the method described in section \ref{withoutHoles}
to define wavefronts in each of these trees separately. Afterwards, we interpolate between
the neighboring wavefronts in each tree and connect the interpolated pieces to get one
contiguous spiral.

As in the case of a polygon without an island,
we enrich the Voronoi diagram by adding edges equidistantly along and perpendiculairly to long
edges on  as described in section \ref{enriching}.
One small difference is that if the half-line  intersects an edge  at the point
, and  is an edge on the cycle
, we do not split  and do not introduce a new edge from  to .
There would be no advantage of adding that edge.
We also remove double edges to concave corners and add their bisector instead
as described in section \ref{removing}.

We want the trees to be \emph{symmetric} in the sense
that there is a tree  with root  and leafs on  if and only if
there is a tree  with root  and leafs on . If for a node 
we only have one of the trees, say ,
we add an edge from node  to the closest point on  and let
 be the tree consisting of that single edge.
It follows from the properties of the Voronoi diagram that the added edge does not intersect any of the
other edges.

We store  as a vector  of the nodes on 
in counterclockwise order, such that there are trees  and  for each
.
A \emph{root node} is a node  on .
We let
 be the union of the two trees rooted at node 
and consider  as a tree rooted at node .

\subsection{Defining the movement of the wave}\label{defMovement}

On each tree  we now define a wave model similar to the one described
in section \ref{waveModel}.
The wave starts at time  on the leafs on  and moves through  so that
it hits the leafs on  at time .
Once the time and speed in the node  is determined, the
times and speeds on the other nodes and edges in  are computed analogously to
algorithm \ref{setTimesAndSpeeds}. One difference is that we compute decreasing times
for the tree . A way to do so is to set ,
compute the inverse times using algorithm \ref{setTimesAndSpeeds}, and
afterwards inverse each of the computed times  by setting .

Let the \emph{preferred time} of a node  be
,
where  is the length of the longest path to a leaf in  and
 is the length of the longest path to a leaf in .
Similarly, if the time  has already been defined,
we let the \emph{preferred speed} of  be
.

A naive method to define the times and speeds of a root  is to set
 and .\comm{} That will
minimize the number of revolutions and give the most equidistant
wavefronts on each tree . However, the abrupt changes in time and speed along the central cycle
 results in a spiral which curves a lot. Instead, we might smooth the times and
speeds around . See figure \ref{holeWavefronts}
for a comparison of the wavefronts with and without smoothing.
There may be many ways of smoothing the values. After much experimentation, we
have found the method described in \ref{appB} to give good results.
Notice that the wavefronts in figure \ref{badWavefronts} intersect each other, and
that will indeed also be the case for some problem instances after using the
smoothing method described in \ref{appB}.
However, in the end of section \ref{interpolWithIsland} we describe how to ensure that the
polyline spiral will not have any self-intersections.

\begin{figure*}
\centering
\subfigure[]{
\includegraphics[scale=0.68]{fig8aa.pdf}
\label{goodWavefronts}
}\quad
\subfigure[]{
\includegraphics[scale=0.68]{fig8ab.pdf}
\label{badWavefronts}
}
\caption{
\subref{holeVD} Wavefronts in red when the times and speeds of the wave in the root nodes
have been defined as described in \ref{appB}.  is in blue and the rest of  is in gray.
\subref{badWavefronts} Wavefronts when the preferred times and speeds have been used
to define the movement of the wave.
}
\label{holeWavefronts}
\end{figure*}

\subsection{Creating wavefronts}

For a given root node , we want at least

revolutions of the spiral in the tree  in order to respect the stepover .
Similarly, we want  revolutions in
. Therefore, the time between two revolutions should be
at most .
Hence, we let  be the minimum over all such values.
We let the number of revolutions be  and set
.

Each tree  contains a contiguous subset of the
corners of any wavefront . The corners of the subset are
points on  if and only if , otherwise they are on .
Let .
The wavefronts  are on
, while wavefronts  are on
.
As explained in section \ref{defMovement}, we do not use the same time  for every
node  on . Therefore, we may get wavefronts crossing , as
is seen in figure \ref{holeWavefronts}.

We suggest to store the wavefront corners in a two-dimensional array for each of the trees
 and .
The wavefront corners on  of one wavefront are stored in an array ,
where index  corresponds to wavefront .
In , the array  stores corners of
wavefront .
Hence, the corners of each wavefront is stored locally in each tree .

In , the parents of the corners of wavefront 
are corners of wavefront . In , the parents of the corners of wavefront
 are corners of wavefront .
Therefore, all parents are on the
wavefront one step closer to the root .
In both  and , we introduce fake wavefront corners
at node  stored in the arrays  and ,
respectively, which are the parents of the corners in
the arrays  and .
Thus, these fake corners are not corners on wavefront  for any , but are merely
made to complete the tree of parent pointers between corners of neighboring wavefronts.

We also need an array  containing \emph{global} information about the length
of each wavefront crossing all the trees  in order to do interpolation between
the wavefronts later. We have
 for every wavefront .
If  and  are the 'th and 'st corners on
wavefront , respectively, we have
. Notice that  and  can be corners
in different, however neighbouring trees  and  and hence stored in
different arrays.
 stores the total length of wavefront .

\subsection{Interpolating between wavefronts}\label{interpolWithIsland}

We interpolate between two wavefronts  and  in each tree  separately,
but using the same technique as in section \ref{interpolating}. If
, we interpolate between the
wavefront fragments stored in
 and ,
where , using the values of the length of wavefront  stored in
.
If , we interpolate between
 and ,
where , using the values stored in .
A special case occurs when
, i.e.,
when we are interpolating between the first wavefront on each side of the root node .
In that case, let

when  is the 'th corner on wavefront .
If , we interpolate between  and .
Otherwise, we interpolate on the other side of , that is,
between  and .
The convexification process described in section \ref{interpolating} can be used in each
tree  separately.

We may store the interpolated spiral in an one-dimensional array .
Before we add the first interpolated revolution to , i.e., the one between wavefront  and ,
we add wavefront  to , that is, all the corners on . Likewise,
after the final revolution between wavefronts  and , we add wavefront , which is
all the corners on . These are used to ensure that the distance from the
first and last revolution to  and , respectively,
does respect the stepover when rounding the spiral.

\begin{figure*}
\centering
\includegraphics{fig9.pdf}
\caption{
A polyline spiral in black and red arrows from each corner  to its parents.
The cycle  is in blue and the diagram  is in gray.
}
\label{holePolyline}
\end{figure*}

For every corner  we have a pointer  such that  is
the first spiral corner we meet when traveling from  to the root  of the tree 
containing .
The parents are not defined for the spiral corners closest to the root node .
Therefore, we make every spiral corner between  and

the parent of every spiral corner between  and 
to make parent dependencies across .
We want all the parent pointers to be towards the island . Therefore, we reverse
all the pointers between pairs of corners in each tree . Now, the parent pointers
are defined for all spiral corners except for the ones on .
See figure \ref{holePolyline} for an example of a polyline spiral around an island and red arrows
indicating the parent pointers. Notice that a corner can have multiple parents, but the parents
are consecutive and can thus be stored using two indices.

In section \ref{interpolating}, we stated that since there are no intersections between different
wavefronts,
the polyline spiral has no self-intersections when there is no island in .
The wavefronts do not intersect in that
case due to the convexity of the faces into which the diagram  subdivides .
When there is an island  in ,
there are two kinds of faces into which  subdivides ,
see figure \ref{repairCrossings}. Some faces, like  in the figure, are bounded
by edges of one tree  while some are between two trees,
like  and . The latter kind is bounded by edges of two
neighboring
trees  and  and an edge  from  to  on , where  and  are neighboring nodes on .
The first kind of faces is similar to the faces in section \ref{withoutHoles},
so here we do not worry about
self-intersections of the spiral. The second, however, can lead to wavefronts crossing each other and
therefore also a self-intersecting spiral as is the case in the figure when the spiral jumps over  and
crosses . If the union of
the faces on each side of  is convex,
like  and its neighboring face on the other side of , there is no problem.
It can easily be tested if the union of the faces is convex by considering the angles of the union
at nodes  and . If it is not, we introduce a new corner
on the edge on  whenever the spiral jumps from one side of 
to the other. The new corner is an interpolation of nodes  and 
using the time of the spiral in the last corner in tree .
Figure \ref{noCrossingZoom} shows the result of introducing
the extra corners. Our experience is that these intersection problems occur very rarely
when the method described in \ref{appB} has been applied.

\begin{figure*}
\centering
\subfigure[]{
\includegraphics[scale=0.8]{fig10aa.pdf}
\label{crossing}
}\\
\subfigure[]{
\includegraphics[scale=0.72]{fig10ab.pdf}
\label{crossingZoom}
}\quad
\subfigure[]{
\includegraphics[scale=0.72]{fig10ac.pdf}
\label{noCrossingZoom}
}
\caption{
The same pocket and island as in figure \ref{holeWavefronts}.
The cycle  is blue, the other edges of  are gray.
The interpolated spiral is black, and we have not introduced extra spiral corners on
 to avoid self-intersections.
In order to emphasize the intersection problems that can arise,
we have not used the method described in \ref{appB},
but merely used the preferred time and speed of each node (section \ref{defMovement}).
\subref{crossingZoom} is a close-up of \subref{crossing}
of the area in the red rectangle. In \subref{noCrossingZoom}, we have introduced new corners on
 when the spiral jumps from one side of  to the other when the union of the two
faces on each side of  is not convex.
}
\label{repairCrossings}
\end{figure*}

\section{The skeleton method for a spiral in a pocket without an island}\label{skeletonMethod}

\begin{figure*}
\centering
\subfigure[]{
\includegraphics[scale=0.99]{fig11a.pdf}
\label{spiralNoHole}
}\quad
\subfigure[]{
\includegraphics[scale=0.99]{fig11b.pdf}
\label{spiralSkeletonHole}
}
\caption{
Comparison of the basic spiral method from section \ref{withoutHoles}, figure \subref{spiralNoHole},
with the improved skeleton method from section \ref{skeletonMethod}, figure \subref{spiralSkeletonHole}.
Note that the spiral obtained from the skeleton method is significantly shorter and that the distance between
neighboring revolutions is varying much less than when using the basic method.
}
\label{skeletonHole}
\end{figure*}

The method from section \ref{withoutHoles} is mainly applicable
if the polygon  is not too far from being a circle. If  is very elongated or branched,
the distance between neighboring revolutions will often be much less
than the maximum stepover. Therefore, the toolpath will be unnecessarily long and the cutting width will
vary a lot. That leads to long machining time and an uneven finish of the part.
See figure \ref{skeletonHole} for an example.
In such cases, we construct a \emph{skeleton} in ,
which is an island  with zero area.
We then use the method from section \ref{pocketWithHole} to make a spiral from the island to the boundary.
It does not matter for the construction of the spiral that the island  has zero area.
See figure \ref{skeletonHole} for a comparison between the basic method from
section \ref{withoutHoles} with the skeleton method described here when applied to the same
polygon.

\subsection{Constructing the skeleton in a polygon }

\begin{figure*}
\centering
\subfigure[]{
\includegraphics[scale=0.99]{fig12a.pdf}
\label{spiralHoleConstruction}
}\quad
\subfigure[]{
\includegraphics[scale=0.99]{fig12b.pdf}
\label{spiralSkeletonVD}
}
\caption{
\subref{spiralHoleConstruction} The diagram  of the polygon  from figure \ref{skeletonHole} in green,
where the edges chosen for the skeleton are black. \subref{spiralSkeletonVD} The diagram
 of
 with the skeleton considered an island . The cycle  is blue and the remaining edges are green.
The resulting spiral from figure \ref{spiralSkeletonHole} is included in gray.
}
\label{skeletonConstruction}
\end{figure*}

We choose the skeleton as a connected subset of the edges of the diagram .
We traverse  once starting at the root and decide for each edge whether to include it in the
skeleton. If an edge from node  to  is not included, we don't include anything from the sub-tree
.
For any node , let  be the length of the shortest path from  to a leaf in , and
let . We have found that the following criteria for including
an edge  from node  to  gives good results. We require all the criteria to be satisfied.
\begin{enumerate}
\setlength\itemsep{0em}
\item \label{case0} The longest path from  to a leaf in  goes
through  or , where  is the length of edge .

\item \label{case1} The length of the spanned boundary (defined in \ref{appB})
of  is larger than .

\item \label{case2} .
\end{enumerate}

Criterion \ref{case0} is to avoid getting a skeleton that branches into many short paths. Therefore,
we only make a branch which is not following the longest path from  if it seems to
become at least  long
(taking criterion \ref{case2} into account).
When criterion \ref{case1} fails,
it seems to be a good indicator that an edge is not a significant, central edge
in , but merely one going straight to the boundary.
Criterion \ref{case2} ensures that we do not get too close to the boundary. If we did, we would get
very short distances between the neighboring revolutions there. If
criterion \ref{case2} is the only failing criterion, we find the point  on  such that
 and include the edge from node  to 
in the skeleton. See figure \ref{skeletonConstruction} for the skeleton constructed
given the polygon from figure \ref{skeletonHole}.

If the polygon is close to being a circle, the method described here
results in a very small skeleton, and we get a better spiral using the
basic method from section \ref{withoutHoles} in that case.
This can be tested automatically by falling back to the basic method if
the circumference of the skeleton is less than, say, 5\% of the circumference of .

\section{Computing a spiral in a pocket with multiple islands}\label{multipleHoles}

\begin{figure*}
\centering
\subfigure[]{
\includegraphics[scale=0.96]{fig13a.pdf}
\label{manyHolesConnection}
}\quad
\subfigure[]{
\includegraphics[scale=0.96]{fig13b.pdf}
\label{manyHolesResult}
}
\caption{
\subref{manyHolesConnection} A polygon with 13 islands. The bridges chosen among the Voronoi
edges to connect the islands are blue. The remaining Voronoi edges are red.
\subref{manyHolesResult} The resulting spiral around the islands.
}
\label{manyHoles}
\end{figure*}

The method from section \ref{pocketWithHole} works only for polygons with a single island.
If there are many islands  in a polygon ,
we may connect them with bridges in a tree structure to form one
big connected island, see figure \ref{manyHoles}.
The basic idea of reducing the number of islands by connecting them is also used
by Chuang and Yang \cite{chuang2007} and Held and Spielberger \cite{held2014}.
Our method is given in algorithm \ref{makeBridges}, and it is a variation of the minimum spanning
tree algorithm of Dijkstra \cite{dijkstra1959}.
We choose the bridges as edges in the Voronoi diagram  of the area
.
The algorithm creates an array  of the edges to use as bridges.
We keep a growing set  of the nodes of the Voronoi diagram that we have
connected by bridges so far. Here, we have represented  as a bit-vector.
We first find one central node  and  is only containing  in the beginning.
We use Dijkstra's algorithm \cite{dijkstra1959} in the loop beginning at line \ref{MBwhile1}
to make all shortest paths from nodes in . We make a relaxation of the distances in line \ref{MBrelaxation}. When we reach
an island  whose corners are not in ,
we use the shortest path to that island as a bridge and add the nodes on the shortest path
and the corners on  to . The use of the distance vector  makes the algorithm
prefer to build bridges from the vertices that has been in  for the longest time.
That makes the bridges grow from the center node  out in every direction.
If we did not choose the bridges in this careful way, the resulting connected island
would possibly make unnecessarily long dead ends that would require many
revolutions to fill out by the spiral.

\texttt{VRONI} by Held \cite{held2001}
has the possibility to add edges to the Voronoi diagram between
neighboring objects in the input where the distance between the objects is shortest,
even though these are not
genuine Voronoi edges. It is an advantage also to consider these edges when choosing
the bridges between the islands,
since they are often the best bridges. For instance, all the bridges chosen in the
example of figure \ref{manyHoles} are of that kind.

\begin{algorithm}[h]
\scriptsize
\LinesNumbered
\DontPrintSemicolon
\SetArgSty{}
\SetKwIF{If}{ElseIf}{Else}{if}{}{else if}{else}{end if}
\SetKwFor{Foreach}{for each}{}{end for}
\SetKwInput{Effect}{Effect}
Compute the Voronoi diagram  of the area inside  but outside every .\;
Find the set of all nodes  of  which are either a corner on an island or
equally close to two islands but farther from
.\;
Let  be the node in  closest to the root of  defined as in section \ref{startingPoint}.\;
Let  for each node .\;
Let  for each node .\;
; \;
\;
\While { does not include every island} { \nllabel{MBwhile0}
  For each node , if , set .\;
  Let  for each node .\;
  Let  be a priority queue of the nodes  of  sorted after the values .\;
  \While {} { \nllabel{MBwhile1}
    Let  be the front node in  and remove  from .\;
    \If { is a corner on an island  and } {
      For each node  on the path , set .\;
      Add each edge on the path  to .\;
      Let  be the node on  farthest from  and let .\;
      For each node  on , set  and .\;
      Go to line \ref{MBwhile0}.\;
    }
    For each edge going out of  to a node ,
    if  and ,
    set , update  accordingly, and set .\;  \nllabel{MBrelaxation}
  }
}
\caption{}
\label{makeBridges}
\end{algorithm}

\section{Conclusion}\label{conclusion}
We have described methods for the computation of spiral toolpaths suitable for many
shapes of pockets for which no previously described algorithms yield equally good results.
Our main contribution is the new possibility of making a spiral morphing an island in a pocket
to the boundary of the pocket.

Our developed spiral algorithms only work for polygonal input. We believe that it should be possible to
generalize to input consisting of line segments and circular arcs, as done by
Held and Spielberger \cite{held2009}, using \texttt{ArcVRONI} by Held and Huber \cite{held2009topology}
to compute the Voronoi diagrams for such input.

Held and Spielberger \cite{held2014} developed methods to subdivide a pocket with arbitrarily many
islands into simply-connected sub-pockets, each of which are suitable for basic spirals as the ones
described in section \ref{withoutHoles}. Since we have the possibility to make spirals around islands,
we never have to partition the input into separate areas, but in some cases, for instance if the
pocket has a long ``arm'' requiring a lot of revolutions, it might be useful to machine
different areas of the input independently. Another possibility is to combine the method for
machining around multiple islands with the skeleton method.
Given these new possibilities, our problem is quite different from the one
discussed by Held and Spielberger. It would be interesting to investigate if and how one can
make an automatic partitioning that leads to a more efficient toolpath using our new kinds of spirals.

\section*{Acknowledgements}

I would like to thank my colleague at Autodesk,
Niels Woo-Sang Kj\ae rsgaard, for numerous helpful discussions while I did
the development of the spiral algorithms and for many useful comments on this paper.
My thanks also go to Autodesk in general for letting me do this research and publish the
result.


\bibliography{proj}{}
\bibliographystyle{plain}

\newpage
\appendix
\section{An algorithm defining the movement of the wave}\label{appA}

Here we describe how we define the speed and time of the wave at every point in the diagram
 in a polygon  with no island.
There might be other models giving equally good or even better
results, but we think this model has an advantage of being quite simple to implement.
Recall that for a node  in the diagram ,  is the time when the wave
reaches  and  is the speed with which it passes .
We define the movement of the wave from the root and out towards the leafs in
.
We let  and .
Let  be an edge going out of the node  where we have
defined  and  already. Let  be
the longest path starting with . By definition,
 has length , where  is the length of , i.e.,
the distance from node  to node .
If , the wave has to slow down on , since the speed of the wave at node 
is determined by .

We decrease the speed linearly
as a function of time such that the wave is decreasing on the first 1/4 of 
while it has constant speed on the last 3/4 of .
The resulting spiral looks wrong if the wave abruptly changes acceleration when it is not needed.
Therefore, if the wave is already slowing down when reaching the node , we might prefer that it keep
slowing down on  with the same rate, even though we must use more than 1/4
of . We do that if , i.e., if  is almost as long
as the longest path going out of .
How to implement this idea is described in greater detail in the following.
It would be interesting to find a model where the acceleration is a continuous function
of the time along every path in , but we have not found such a model that could be implemented
efficiently.

We define the values  and 
for each edge  which satisfy
 and ,
where  is the node .
At a time ,
the speed of the wave is

where
. When , the speed
is . Let  be the speed defined by the values of edge  and

at time . Let  be the distance travelled by the wave from time
 to .
We have

which can be computed easily since  is piecewise linear.
We also need the function  which is the time  such that .
Hence,  is the inverse of , i.e., we have
 and .
When , we can compute
 by solving a quadratic equation. When
, we get a linear equation.
Finally,  returns the point
,
where  and .
For ,  is the position of the wave on
edge  at time .

Assume that we have defined , , , and  on all
nodes and edges on the path from  to some non-leaf node .
Algorithm \ref{setTimesAndSpeeds} computes the values for an edge  going out of
 and for the node .

\begin{algorithm}[h]
\scriptsize
\LinesNumbered
\DontPrintSemicolon
\SetArgSty{}
\SetKwIF{If}{ElseIf}{Else}{if}{}{else if}{else}{end if}
\SetKwFor{Foreach}{for each}{}{end for}
\SetKwInput{Effect}{Effect}
; ; ; \;
\uIf{} {
  ; \;
} \Else {
  ; ; \;
}
\; \nllabel{stasSetttimeT}
\; \nllabel{stasSetspeedT}
\;
\If {}
{ \nllabel{stasIf1}
  \;
  \If { and } { \nllabel{stasIf2}
    \; \nllabel{stasCompA}
    \;
    \; \nllabel{stasCompS}
    \If {} { \nllabel{stasIf3}
      Define  and  such that 
      and .\; \nllabel{stasCompEq1}
      \;
    }    
  }
  \If {} {
    Define  and  such that 
    and .\; \nllabel{stasCompEq2}
  }
}
\; \nllabel{stasCompttimeO}
\; \nllabel{stasCompspeedO}
\caption{}
\label{setTimesAndSpeeds}
\end{algorithm}

In lines \ref{stasSetttimeT}--\ref{stasSetspeedT},
we try to use the same values for  as for the previous edge . If,
however, the length  of the longest path starting with edge  is smaller
than the longest of all paths going out of , we are in the case of line \ref{stasIf1},
where we need the wave to slow down.
Lines \ref{stasCompA}--\ref{stasCompS} compute the distance  that the wave will travel
if it continues to decrease speed with the same rate until time .
We can only keep using the same acceleration if  is smaller than .
If we cannot
keep using the same acceleration or the speed of the wave is not decreasing at the node ,
we define the values in line \ref{stasCompEq1}
as previously described.
Both of the lines \ref{stasCompEq1} and \ref{stasCompEq2}
give two equations in the two unknowns  and . Each pair of equations
lead to a quadratic equation in one of the unknowns,
and we need to choose the unique meaningful solution.
We assign the time and speed values to every node and edge in linear time
by traversing  once. Algorithm \ref{setAllTimesAndSpeeds} sets times and speeds for all
nodes and edges by traversing  once.

\begin{algorithm}[h]
\scriptsize
\LinesNumbered
\DontPrintSemicolon
\SetArgSty{}
\SetKwIF{If}{ElseIf}{Else}{if}{}{else if}{else}{end if}
\SetKwFor{Foreach}{for each}{}{end for}
\SetKwInput{Effect}{Effect}
  \;
  \;
  \Repeat{} {
    \uIf {} {
      \;
      \;
    } \Else {
      \;
    }
    \;
  }
\caption{}
\label{setAllTimesAndSpeeds}
\end{algorithm}

\section{A method for defining time and speed on the central cycle}\label{appB}

In this section, we describe an alternative method to the naive one mentioned in section
\ref{defMovement} to define the time and speed of the wave on the cycle 
in the diagram  of a polygon  with an island .

Recall that the \emph{preferred time} of a root node  is

We let the time for a node  be a weighted average of
its neighbors' preferred times.
We define an \emph{influence distance} 
of each root node
, which is the distance along  in which  has influence on the times and
speeds of other root nodes. In many real-world instances, the majority of the trees
 consist of just two edges, namely one going to  and one to , and these two
edges are almost equally long. We have experienced that these should have zero influence distance,
so that they only have an influence on their own times.
Therefore we give a positive influence distance if and only if one of the trees
 and  have more than one leaf or the ratio
 is not in the interval .

When the influence distance should be positive, we define it in the following way:
Consider three consecutive leafs , , and  of 
on  or . We define the \emph{spanned boundary} of 
to be the path , where 
and .
The spanned boundary of a tree 
is the union of all the spanned boundaries of the leafs of , similarly for .
We let  be the maximum of the distances between the start- and endpoints of the
spanned boundaries of  and .

To compute the times of the root nodes,
we define a weight of a root node  as
.
If a node  with low weight or zero influence distance is very close (say, closer than )
to a node  with a high weight
(say, 5 times as much) and positive influence distance, we have experienced better results
if we set . In that way, the influential neighbor  completely dominates node .

Let  be a fixed node on 
and consider another node  on  with positive influence distance.
Assume that the path
from  to  on  has length .
We define the
weight of node  on node  as
, where ,
i.e., we let the weight decrease cubically as the distance increases.
The time at node  is defined as

Here, the sums are over all nodes  where  is within the influence distance of .

Recall that the \emph{preferred speed} of a root node  is

The wave should have a non-increasing speed from a root node 
towards the leafs of both  and .
Therefore, the speed at node  should at least be the preferred speed
so that the wave can reach  at time  and  at time .
We define the speed as

where the maximum is over all the nodes  such that  is within the influence distance of .
The value  is defined above.
The last factor in the expression is to reduce the influence from nodes that have gotten a
very different time than node , since the speeds of the wave become less comparable
when the times are different.

\end{document}
