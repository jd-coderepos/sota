\documentclass{LMCS}

\def\dOi{11(3:10)2015}
\lmcsheading {\dOi}
{1--31}
{}
{}
{Nov.~17, 2014}
{Sep.~16, 2015}
{}

\ACMCCS{[{\bf Theory of computation}]: Logic---Modal and temporal
  logics; [{\bf Computer systems organization}]: Dependable and fault-tolerant systems and networks}
\subjclass{B.6.3 Design Aids---Automatic synthesis, F.4.1 Mathematical Logic---Temporal logic}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{stmaryrd} \usepackage{wasysym}
\usepackage{mathtools} \usepackage{bm}
\usepackage{array}
\newcolumntype{L}{>{\qquad\labelitemi~~}l<{}}

\usepackage{subfigure}

\usepackage{verbatim}
\usepackage[hidelinks]{hyperref}
\usepackage{color}

\usepackage{cite}

\usepackage{tikz}
\usetikzlibrary{arrows,automata,positioning}
\usetikzlibrary{decorations.pathmorphing}

\tikzstyle{printing_highlight_lines}=[red,dashed]

\usepackage[nofonts]{coordinationlogic}

\newcommand{\deps}{\mathit{deps}}
\newcommand{\branches}{\mathit{branches}}
\newcommand{\paths}{\mathit{paths}}
\newcommand{\strategies}{\mathit{strategies}}
\newcommand{\header}{\mathit{header}}
\newcommand{\consistent}{\mathit{consistent}}
\newcommand{\unsatii}{\mathit{unsat}_\mathit{dist}}
\newcommand{\unsatnf}{\mathit{unsat}_\mathit{fault}}
\newcommand{\unsatcy}{\mathit{unsat}_\mathit{cycles}}
\newcommand{\partition}{\mathit{partition}}

\newcommand{\operational}{\mathit{operational}}
\newcommand{\consensus}{\mathit{consensus}}
\newcommand{\correctval}{\mathit{correctval}}

\newcommand{\uniform}{\mathit{uniform}}

\newcommand{\Prev}{\mathit{Prev}}

\newcommand{\btrue}{\top}
\newcommand{\bfalse}{\perp}

\newcommand{\eclpuntil}   [3]{#2\;\ltluntil_{#1}\;\kern-.1em #3}

\newcommand{\modelsltl}{\vDash_\text{\rm LTL}}
\newcommand{\nmodelsltl}{\nvDash_\text{\rm LTL}}
\newcommand{\modelsqptl}{\vDash_\text{\rm QPTL}}
\newcommand{\nmodelsqptl}{\nvDash_\text{\rm QPTL}}
\newcommand{\modelssos}{\vDash_\text{\rm S1S}}
\newcommand{\nmodelssos}{\nvDash_\text{\rm S1S}}
\newcommand{\modelswsos}{\vDash_\text{\rm WS1S}}
\newcommand{\nmodelswsos}{\nvDash_\text{\rm WS1S}}
\newcommand{\modelsqbf}{\vDash_\text{\rm QBF}}
\newcommand{\nmodelsqbf}{\nvDash_\text{\rm QBF}}

\newcommand{\sostransformer}{\mathit{s1s}}
\newcommand{\wsostransformer}{\mathit{ws1s}}
\newcommand{\qbftransformer}{\mathit{qbf}}
 
\theoremstyle{plain}\newtheorem{theorem}[thm]{Theorem}
\theoremstyle{plain}\newtheorem{lemma}[thm]{Lemma}
\theoremstyle{plain}\newtheorem{proposition}[thm]{Proposition}
\theoremstyle{plain}\newtheorem{corollary}[thm]{Corollary}
\theoremstyle{definition}\newtheorem{definition}{Definition}[section]


\begin{document}

\title[Detecting Unrealizability of Distributed Fault-tolerant Systems]{Detecting Unrealizability of Distributed Fault-tolerant Systems}

\author[Finkbeiner and Tentrup]{Bernd Finkbeiner}	\address{Saarland University, 66123 Saarbr\"ucken}	\email{\{finkbeiner,tentrup\}@cs.uni-saarland.de}  

\author[]{Leander Tentrup}	\address{\vspace{-18 pt}}	



\keywords{Distributed Synthesis, Fault-tolerance, Coordination Logic}





\begin{abstract}
  \noindent Writing formal specifications for distributed systems is difficult.
Even simple consistency requirements often turn out to be unrealizable because of the complicated information flow in the distributed system: not all information is available in every component, and information transmitted from other components may arrive with a delay or not at all, especially in the presence of faults.
The problem of checking the distributed realizability of a temporal specification is, in general, undecidable.
Semi-algorithms for synthesis, such as bounded synthesis, are only useful in the positive case, where they construct an implementation for a realizable specification, but not in the negative case: if the specification is unrealizable, the search for the implementation never terminates.
In this paper, we introduce \emph{counterexamples to distributed realizability} and present a method for the detection of such counterexamples for specifications given in linear-time temporal logic (LTL).
A counterexample consists of a set of paths, each representing a different sequence of inputs from the environment, such that, no matter how the components are implemented, the specification is violated on \emph{at least one} of these paths.
We present a method for finding such counterexamples both for the classic distributed realizability problem and for the fault-tolerant realizability problem.
Our method considers, incrementally, larger and larger sets of paths until a counterexample is found.
For safety specifications in weakly ordered architectures we obtain a decision procedure, while counterexamples for full LTL and arbitrary architectures may consist of infinitely many paths.
Experimental results, obtained with a QBF-based prototype implementation, show that our method finds simple errors very quickly, and even problems with high combinatorial complexity, like the Byzantine Generals' Problem, are tractable.
\end{abstract}

\maketitle

\section{Introduction}


The goal of program synthesis, and systems engineering in general, is to build systems that satisfy a given specification. Sometimes, however, 
this goal is unattainable, because the conditions of the specification are \emph{impossible} to satisfy in an implementation. A textbook example for such a case is the \emph{Byzantine Generals' Problem}, introduced in the early 1980s by Lamport et al.~\cite{DBLP:journals/toplas/LamportSP82}. Three generals of the Byzantine army, consisting of one commander and two lieutenants, need to agree on whether they should ``attack'' or ``retreat.''  For this purpose, the commander sends an order to the lieutenants, and all generals then exchange messages with each other, reporting, for example, to one general which messages they have received from the other general. The problem is that one of the generals is a traitor and can therefore not be assumed to tell the truth: the tale of the Byzantine generals is, after all, just an illustration for the problem of achieving fault tolerance in distributed operating systems, where we would like to achieve consensus even if a certain subset of the nodes fail. 
Of course, we cannot expect the traitor to agree with the loyal generals, but we might still expect a loyal lieutenant to agree with the order issued by a loyal commander, and two loyal lieutenants to reach a consensus in case the commander is the traitor. This specification is, however, unrealizable in the setting of the three generals (and, more generally, in all settings where at least a third of the nodes are faulty).

Detecting unrealizable specifications is of great value because it avoids spending implementation effort on specifications that are impossible to satisfy. If the system consists of a single process, then unrealizable specifications can be detected with \emph{synthesis} algorithms, which detect unrealizability as a byproduct of attempting to construct an implementation. For distributed systems, the problem is more complicated: in order to show that there is no way for the three generals to achieve consensus, we need to argue about the knowledge of each general. The key observation in the Byzantine Generals' Problem is that the loyal generals have no way of knowing who, among the other two generals, is the traitor and who is the second loyal general. For example, the situation where the commander is the traitor and orders one lieutenant to ``attack'' and the other to ``retreat'' is \emph{indistinguishable}, from the point of view of the loyal lieutenant who is ordered to attack, from the situation where the commander is loyal and orders both lieutenants to attack, while the traitor claims to have received a ``retreat'' order. Since the specification requires the lieutenant to act differently (agree with the other lieutenant vs.\ agree with the commander) in the two indistinguishable situations, we reach a contradiction. 

Since realizability for distributed systems is in general an undecidable problem~\cite{DBLP:conf/focs/PnueliR90}, the only available decision procedures are limited to special cases, such as pipeline and ring architectures~\cite{DBLP:conf/lics/KupfermanV01,DBLP:conf/lics/FinkbeinerS05}. There are semi-algorithms for distributed synthesis, such as \emph{bounded synthesis}~\cite{journals/sttt/FinkbeinerS13}, but the focus is on the search for implementations rather than on the search for inconsistencies: if an implementation exists, the semi-algorithm terminates with such an implementation, otherwise it runs forever.
In this paper, we take the opposite approach and study \emph{counterexamples to realizability}. Intuitively, a counterexample collects a sufficient number of scenarios such that, no matter what the implementation does, an error will occur in \emph{at least one} of the chosen scenarios. As specifications, we consider formulas of linear-time temporal logic (LTL). It is straightforward to encode the Byzantine Generals' Problem in LTL\@.
Another interesting example is the famous CAP Theorem, a fundamental result in the theory of distributed computation conjectured by Brewer~\cite{DBLP:conf/podc/Brewer00}. The CAP Theorem states that it is impossible to design a distributed system that provides Consistency, Availability, and Partition tolerance (CAP) simultaneously.
We assume there is a fixed number  of nodes, that every node implements the same service, and that there are direct communication links between all nodes.
We use the variables  and  to denote input and output of node , respectively.
The consistency and availability requirements can then be encoded as the LTL formulas  and .
The partition tolerance is modeled in a way that there is always at most one node partitioned from the rest of the system, i.e., we have  different fault-tolerance scenarios where in every scenario all communication links to one node are faulty.

In both examples, a finite set of input sequences suffices to force the system into violating the specification on at least one of the input sequences.
In this paper, we present an efficient method for finding such counterexamples.
It turns out that searching for counterexamples is much easier than the classic synthesis approach of establishing unrealizability by the non-existence of strategy trees~\cite{DBLP:conf/focs/PnueliR90,DBLP:conf/lics/KupfermanV01,DBLP:conf/lics/FinkbeinerS05}. The difficulty in synthesis is to enforce the consistency condition that the strategy of a process must act the same way in all situations the process cannot distinguish.
On the strategy trees, this consistency condition is not an -regular (or even decidable) property. 
When analyzing a counterexample, on the other hand, we only check consistency on a specific set of sequences, not on a full tree. This restricted consistency condition is an -regular property and can, in fact, simply be expressed in LTL as part of the temporal specification.
Our QBF-based prototype implementation finds counterexamples for the Byzantine Generals' Problem and the CAP Theorem within just a few seconds. 

\paragraph{\bf Related Work.}
To the best of the authors' knowledge, there has been no attempt in the literature to characterize unrealizable specifications for distributed systems beyond the restricted class of architectures with decidable synthesis problems, such as pipelines and rings~\cite{DBLP:conf/lics/KupfermanV01,DBLP:conf/lics/FinkbeinerS05}.
By contrast, there is a rich literature concerning unrealizability for open systems, that is, single-process systems interacting with the environment~\cite{Church/63/Logic,DBLP:conf/icalp/AbadiLW89,conf/ictl/KupfermanV97}.
Schuppan~\cite{DBLP:journals/scp/Schuppan12} introduced the notion of unrealizable cores to identify a minimal subformula that contains the reason for unrealizability.
In robotics, there have been recent attempts to analyze unrealizable specifications~\cite{DBLP:conf/cav/RamanK11}.
The results are also focused on the reason for unrealizability, while our approach tries to determine if a specification is unrealizable.
Moreover, they only consider the simpler non-distributed synthesis of GR(1) specifications, which is a subset of LTL\@.
There are other approaches concerning unrealizable specifications in the non-distributed setting that also use counterexamples~\cite{DBLP:conf/concur/ChatterjeeHJ08,DBLP:conf/memocode/LiDS11}.
There, the system specifications are assumed to be correct and the information from the counterexamples are used to modify environment assumptions in order to make the specifications realizable.
The Byzantine Generals' Problem is often used as an illustration for knowledge-based reasoning in epistemic logics, see~\cite{DBLP:conf/podc/HalpernM84} for an early formalization.
Concerning the synthesis of fault-tolerant distributed systems, there is an approach to synthesize fault-tolerant systems in the special case of strongly connected architectures~\cite{DBLP:conf/atva/DimitrovaF09}.
A preliminary version of this paper appeared as~\cite{DBLP:conf/tacas/FinkbeinerT14}.
The present paper extends our earlier work by removing restrictions to acyclic architectures and providing a completeness result for safety specifications and weakly ordered architectures, as well as a general encoding of fault-tolerant synthesis.








\section{Distributed Realizability}


A specification is \emph{realizable} if there exists an implementation that satisfies the specification. 
For distributed systems, the realizability problem is typically stated with respect to 
a specific system architecture. Figure~\ref{fig:architectures} shows some typical example architectures: an architecture consisting of \emph{independent} processes, a \emph{pipeline} architecture, and a \emph{join} architecture. The architecture describes the communication topology of the distributed system. For example, an edge from  to  labeled with  indicates that  and  are shared variables between processes  and , where  writes to  and  reads from .
The classic \emph{distributed realizability problem} is to decide whether there exists an implementation (or \emph{strategy}) for each process in the architecture, such that the joint behavior satisfies the specification.
In this case, the distinction between the shared variables is unnecessary as the valuation of the variable that is read from is always equal to the valuation of the variable that is written to.
In this paper, we are furthermore interested in the synthesis of fault-tolerant distributed systems, where the processes and the communication between processes may become faulty.
Here, the distinction of the shared variables is used to model the different types of faults.

\paragraph{\bf LTL} \label{sec:ltl}
We use linear-time temporal logic~(LTL)~\cite{DBLP:conf/focs/Pnueli77} to express linear-time properties, that are properties  for a finite alphabet , also called \emph{atomic propositions}.
LTL consists of the temporal operators Next  and Until .
The syntax is given by the grammar

where .
We define  as , the Weak Until operator  as , and the Release operator  as .
We use the standard abbreviations  and , for some , as well as , , , and .

For , the satisfaction of a path  on position  with respect to formula , denoted by , is inductively defined as\smallskip\\
\begin{tabular}{L l}
   & , \1pt]
   & , \1pt]
   &  \enspace,
\end{tabular}\smallskip\\
where  and  are LTL formulas.
We say a path  is satisfied by , if .
The language of an LTL formula  is defined as the set of paths that satisfy .
In~Section~\ref{sec:abstractions}, we use the syntactically restricted fragments \emph{safety LTL} and \emph{co-safety LTL}~\cite{DBLP:journals/fmsd/KupfermanV01}.
These fragments are given by the grammars

respectively, where .
Safety and co-safety formulas are dual with respect to negation.

\paragraph{\bf Coordination Logic.}
We use  Coordination logic~(CL)~\cite{DBLP:conf/csl/FinkbeinerS10} to give uniform and precise definitions of the various realizability problems of interest.
CL is a game-based extension of LTL that makes strategies---and their observations---to first class citizens of the logic.
CL divides the set of atomic propositions into strategic and coordination variables, where the latter represent observations for the strategies represented by strategic variables.
The \emph{strategy quantifier}  introduces a strategy for  that bases its decisions only on the history of valuations of the variables in .
This allows us to pose queries on the \emph{existence} of strategies, with specific observations, within the logic.
In order to specify the realizability of distributed systems, we use the strategy quantifier  to express the existence of an implementation for a process output  based on input variables~.


\begin{figure}[t]
\centering
\subfigure[]{
  \begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=1cm,semithick,scale=0.8,transform shape]
  
\tikzstyle{every state}=[shape=rectangle]
  \tikzstyle{envstate}=[shape=circle,scale=0.95]
  
\node[state,envstate]           (env) {};
  \node[state,above right=0 and 1 of env] (P0)  {};
  \node[state,below right=0 and 1 of env] (P1)  {};
  
  \path (P0.east) edge            node  {} +(right:0.75)
        (P1.east) edge            node  {} +(right:0.75)
        (env) edge node {} (P0)
        (env) edge node {} (P1)
        ;

\end{tikzpicture}   \label{fig:undecidable_architecture}
}\qquad \subfigure[]{
  \begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=1cm,semithick,scale=0.8,transform shape]
  
\tikzstyle{every state}=[shape=rectangle]
  \tikzstyle{envstate}=[shape=circle,scale=0.95]
  
\node[state,envstate] (env)      {};
  \node[state] (P0) [right=0.85 of env] {};
  \node[state] (P1) [right=of P0]  {};
  
  \path (env) edge node {} (P0)
        (P0) edge node[near start,swap] {} node[near end] {} (P1)
        (P1.east) edge node[swap] {} +(1,0)
        ;
  
  \path[white] (P0.south) edge node {} +(down:0.75);

\end{tikzpicture}   \label{fig:pipeline_architecture}
}\qquad \subfigure[]{
  \begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=1cm,semithick,scale=0.8,transform shape]
\tikzstyle{every state}=[shape=rectangle]
  \tikzstyle{envstate}=[shape=circle,scale=.95]
  
\node[state] (S1)                                {};
  \node[state] (S2) [above left=0 and 1 of S1] {};
  \node[state] (S3) [below left=0 and 1 of S1] {};
  \node[state,envstate] (env) [left=2.85 of S1]     {};
  
  \path (S1) edge []   node[swap] {} +(1.25,0)
        (S2) edge []   node[near start,swap,xshift=5pt] {} node[near end,xshift=-5pt] {} (S1)
        (S3) edge []   node[near start,swap,xshift=-8pt] {} node[near end,xshift=8pt,yshift=2pt] {} (S1)
        (env) edge node {} (S2)
        (env) edge node {} (S3);
\end{tikzpicture}   \label{fig:node_failure_example}
}
\caption[]{Example architectures}
\label{fig:architectures}
\end{figure}

\paragraph{\bf CL Syntax.}
CL formulas contain two types of variables: the set  of \emph{input} (or \emph{coordination}) variables, and the set  of \emph{output} (or \emph{strategy}) variables.
In addition to the usual LTL operators Next~, Until~, and Release~, CL has the strategy quantifier , which introduces an output variable  whose values must be chosen based on the history of valuations of the inputs .
The syntax\footnote{This logic is called \emph{Extended} Coordination Logic in~\cite{DBLP:conf/csl/FinkbeinerS10}.} is given by the grammar

where , , and .
Beside the standard abbreviations , , , and , we use  as an abbreviation of  consecutive Next operators.

We denote by  the (possibly empty) \emph{quantification prefix} of a formula and call the remainder the \emph{body}.
For , we use  if the prefix contains only -quantifiers.
For the purposes of this paper, it suffices to consider the fragment CL that contains only existential quantifiers.
We furthermore assume that the body is quantifier-free, i.e., that the formulas are in \emph{prenex normal form (PNF)}.

\paragraph{\bf Examples.}
We demonstrate how to express distributed realizability problems in CL with the example architectures from Fig.~\ref{fig:architectures}.
The realizability of an LTL formula  in the architecture from Fig.~\ref{fig:undecidable_architecture} is expressed by the CL formula 

Interprocess communication via a shared variable , as in the pipeline architecture from Fig.~\ref{fig:pipeline_architecture}, is expressed by separating the information read from  from the output written to .
In the following CL formula we use output variable  to denote the output written to :

The LTL specification  is qualified by the input-output specification , which expresses that  is required to hold under the assumption that the information written to  by process~ is also the information read from  by process . This separation between sent and received information is useful to model faults that disturb the transmission. Failing processes are specified by omitting the input-output specifications that refer to the failing processes. As an example, consider the architecture in Fig.~\ref{fig:node_failure_example}. The CL formula

specifies that there exists an implementation such that  is guaranteed to hold even if process  or  (but not both) fails.

For a formula , we differentiate two types of coordination variables, \emph{external} and \emph{internal}.
A coordination variable  is internal iff the value of  is uniquely defined by the input-output specifications.
In contrast, external coordination variables provide input from the environment.
For example, the input  in \eqref{eq:pipeline_architecture} is external while  is internal.

\paragraph{\bf CL Semantics.} \label{sec:cl_semantics}
We give a quick definition of the CL semantics for formulas in PNF and refer the reader to~\cite{DBLP:conf/csl/FinkbeinerS10} for details and for the semantics of full CL\@.
The semantics is based on 
\emph{trees} as a representation for strategies and computations.
Given a finite set of directions  and a finite set of labels , a (full) -\textit{labeled} -\textit{tree}  is a pair , where  assigns each \textit{node}  a label .
For two trees  and , we define the joint valuation  to be the widened tree with the union of both labels.
We refer to~\cite{DBLP:conf/csl/FinkbeinerS10} for a formal definition.
A path  in a -labeled -tree  is an -word  and the corresponding labeled path  is .

For a strategy variable  that is bound by some quantifier , we refer to  as the \emph{scope} of , denoted by .
The meaning of a strategy variable  is a \emph{strategy} or \emph{implementation} , i.e., a function that maps a history of valuations of input variables to a valuation of the output variable .
We represent the computation of a strategy  as the tree  where  serves as the labeling function (cf.~Fig.~\ref{fig:ecl_semantics_example_strategy_y}--\subref{fig:ecl_semantics_example_strategy_x}).
CL formulas are interpreted over \emph{computation trees}, that are the joint valuations of the computations for strategies belonging to the strategy variables in , i.e.,  (cf.~Fig.~\ref{fig:ecl_semantics}(c)).
Given a CL formula  in prenex normal form over strategy variables  and coordination variables , the formula is satisfiable if there exists a computation tree  (over ), such that all paths in  satisfy the LTL formula , i.e., .
\begin{figure}[t]
  \centering
  \subfigure[Strategy for ] {
  \begin{tikzpicture}[auto,node distance=1cm,semithick,scale=0.75,transform shape]
      
\tikzstyle{treenode} = [fill,circle,inner sep=0,minimum size=5pt]
  
  \node[red](root) {} [level distance=25pt]
    child
    {
      node[] {}
      child
      {
        node[red] {}
        child
        {
          node[] {}
        }
      }
    }
    ;
    
\node[left=30pt of root] {};
  \node[right=30pt of root] {};
  
  \node[below=70pt of root] {};
  
  \end{tikzpicture}
  \label{fig:ecl_semantics_example_strategy_y}
}\
\subfigure[Strategy for ] {
  \begin{tikzpicture}[auto,node distance=1cm,semithick,scale=0.75,transform shape]
      
\tikzstyle{treenode} = [fill,circle,inner sep=0,minimum size=5pt]
  \tikzstyle{treenodenfill} = [draw,circle,inner sep=0,minimum size=5pt]
  \tikzstyle{usepath} = [line width=1.2pt]
  
  \node[](root) {} [level distance=25pt,
    level 1/.style={sibling distance=80pt},
    level 2/.style={sibling distance=40pt},
    level 3/.style={sibling distance=20pt}]
  
    child
    {
      node[blue] {} 
      child
      {
        node[blue] {} 
        child {node[blue] {}}
        child {node[] {}}
      }
      child
      {
        node[] {}
        child {node[blue] {}}
        child {node[] {}}
      }
      edge from parent node[above left] {}
    }
    child
    {
      node[] {}
      child
      {
        node[blue] {}
        child {node[blue] {}}
        child {node[] {}}
      }
      child
      {
        node[] {}
        child {node[blue] {}}
        child {node[] {}}
      }
      edge from parent node[above right] {}
    }
    ;
  
  \node[below=70pt of root] {};
  
  \end{tikzpicture}
  \label{fig:ecl_semantics_example_strategy_x}
}\quad
\subfigure[Computation tree] {
  \begin{tikzpicture}[auto,node distance=1cm,semithick,scale=0.75,transform shape]
      
\tikzstyle{treenode} = [fill,circle,inner sep=0,minimum size=5pt]
  \tikzstyle{treenodenfill} = [draw,circle,inner sep=0,minimum size=5pt]
  \tikzstyle{usepath} = [line width=1.2pt]
  
  \node[red](root) {} [level distance=25pt,
    level 1/.style={sibling distance=80pt},
    level 2/.style={sibling distance=40pt},
    level 3/.style={sibling distance=20pt}]
  
    child
    {
      node[blue] {} 
      child
      {
        node[] {}
        child {node[blue] {}}
        child {node[] {}}
      }
      child
      {
        node[red] {}
        child {node[blue] {}}
        child {node[] {}}
      }
      edge from parent node[above left] {}
    }
    child
    {
      node[] {}
      child
      {
        node[] {}
        child {node[blue] {}}
        child {node[] {}}
      }
      child
      {
        node[red] {}
        child {node[blue] {}}
        child {node[] {}}
      }
      edge from parent node[above right] {}
    }
    ;
  
  \node[below=70pt of root] {};
  
  \end{tikzpicture}
  \label{fig:ecl_semantics_example_computation_tree}
}
 
  \caption[]{In (a) and (b) we sketch example strategies for  and  satisfying the CL formula . In (c) we visualize the resulting computation tree on which the body (LTL) formula is evaluated.}
  \label{fig:ecl_semantics}
\end{figure}

\paragraph{\bf From Distributed Realizability to CL}
We formally introduce the distributed realizability problem and show reductions from the distributed realizability problem to CL.
Let  be a finite set of variables. An \textit{architecture}  is a tuple , where  is the set of processes and  is the distinct environment process.
 denotes the set of input variables for process  and  denotes the set of output variables for process .
We denote by  the set of all input variables and by  the set of all output variables.
The input given by the environment is , the communication variables are .
While some input may be shared across processes in the case of broadcasting, the output variables of every pair of processes are assumed to be disjoint, i.e.,  for all .
We represent the architecture  by a directed graph , where  is the set of vertices and  the set of edges.
There is an edge between two vertices  if , i.e., there is a communication over shared variables between  and .

An \textit{implementation} of a process  is a function  which maps the history of valuation of the input variables to a subset of output variables.
We say an implementation is finite state, if it can be represented by a finite transducer.
An implementation for  is a set of implementations for each process.
The distributed realizability problem for architecture  and LTL formula  is to decide whether there is a finite state implementation for every process in  such that the system satisfies  against the environment, i.e., the joint behavior of the implementations satisfies  against all input sequences given by the environment:  where .

The distributed realizability problem is decidable for the class of 
weakly ordered architectures~\cite{DBLP:conf/lics/FinkbeinerS05}, which includes pipelines and rings.
Weakly ordered architectures are characterized by the absence of pairs of processes, called \emph{information forks}, that each have access to some information that is hidden from the other process.
Consider a tuple , where  is a subset of the processes ,  is a subset of the variables disjoint from , and  are two different system processes.
Such a tuple is an information fork if  together with the edges that are
labeled with at least one variable from  forms a subgraph rooted in the
environment and there exist two nodes  that have edges to ,
respectively, but are labeled with incomparable sets of variables (i.e.,
neither set is a subset of the other).
For example, the architecture in Fig.~\ref{fig:undecidable_architecture} contains the information fork .
A \emph{weakly ordered architecture} is an architecture that does not contain an information fork.

\begin{definition} \label{def:induced_architecture}
  Given a CL formula , where  for some , the induced architecture  is defined as follows.
  By abuse of notation, we use  as the set of variables in the architecture and define a process  as a set of strategy variables .
  
  Let  be the quotient of  according to the equivalence relation  with  if , i.e., we group the strategy variables with the same inputs together as a single process.
  For all , we define  as  for some  and  as the union over the defined communication variables  and the strategy variables that are not used for communication .
\end{definition}

\begin{theorem} \label{thm:ecl_encoding_distributed_synthesis}
The distributed realizability problem over architecture  and LTL formula~ can be encoded as CL formula  with only prenex existential quantification.
\end{theorem}
\proof
Consider an arbitrary architecture  and an LTL formula .
We give a CL formula  that is satisfiable if, and only if,  is realizable in .
For variable , we denote the coordination variable and strategy variable used in the encoding by  and , respectively.
Analogously we use  as the set of coordination variables and  as the set of strategy variables.

For each process  we introduce a set of strategy variables  with the scope .
We take care of the input-output specifications by restricting the paths such that  holds, i.e., we only consider paths where the valuation of the strategy variables  representing the output variables is equal to the valuation of the coordination variables  representing the input variables. The resulting formula  for processes  is

The correctness of the encoding follows from the semantics of CL and .
\qed

\paragraph{\bf Realizability under Byzantine faults.} 
\label{sec:multiple-architecture-realizability}
We model the occurrence of a Byzantine fault as a modification of the architecture, where a process reading from some shared variable no longer reads the output written by the other process, but instead some arbitrary input. An implementation is fault-tolerant if it works both in the original architecture and in the modified architecture.
We encode \emph{fault-tolerant realizability} as   CL formulas of the general form

where the formulas  are obtained from  by omitting constraints , which indicates that there is a Byzantine fault on the shared variable : 
the coordination variable  can deviate arbitrarily from .

A disadvantage of this encoding is that we can no longer partition the coordination variables into internal and external variables, because the 
coordination variable  is external in the architecture where the shared variable is faulty and internal in the other architectures.
In order to retain the partitioning, we use the following satisfiability preserving transformation :
For each coordination variable  that is neither internal nor external, we introduce a fresh coordination variable  that represents the external information given in the fault architectures.
Consequently, we add the condition  to all path specifications  where  is not contained, thus, making the value  deterministic in all architectures.
In the transformed formula ,  is an internal coordination variable as its value is in every architecture uniquely determined and  is an external coordination variable as it provides environmental input to the system.


\section{Counterexamples to Distributed Realizability} \label{sec:counterexamples}
We now introduce \emph{counterexamples to realizability}, which are actually {counterexamples to satisfiability} for the CL formula encoding the realizability problem.
The satisfiability problem for a CL formula in prenex form asks for an implementation for all strategy variables in the quantification prefix of the formula such that the temporal specification in the body is satisfied.

Let  be a CL formula in prenex form over coordination variables  and strategy variables , where the body of the formula is the LTL formula~.
A \emph{counterexample to satisfiability} for  is a (possibly infinite) set of paths , such that, no matter what strategies are chosen for the strategy variables in , there exists a path  that violates the body .
Formally,  is a counterexample to satisfiability iff, for each  and every strategy , it holds that there exists a path  such that  where .
\begin{proposition} \label{eq:ecl_unsatisfiability}
A CL formula  over coordination variables  and strategy variables 
is unsatisfiable if, and only if, there exists a counterexample to satisfiability .
\end{proposition}
\proof
  By the semantics of CL and .
\qed\noindent
The distributed realizability problem \emph{without} faults corresponds to CL formulas of the form , where the  defines the architecture : there is an edge from one strategy variable to another if the input-output specification occurs in .
A \emph{finite} counterexample to satisfiability of  is a finite set of paths  corresponding to external coordination variables , such that for every implementation  there exists a path  such that an extension  of  violates .
We say that  is an extension of  if for all , it holds that .
Note that the extension of  by the valuation of the internal coordination variables is uniquely specified by the input path  and the system implementation .
\begin{proposition} \label{eq:dr_without_faults_finite_unsatisfiability}
  A CL formula  over coordination variables  and strategy variables  is unsatisfiable if there exists a finite counterexample to satisfiability  of . \qed
\end{proposition}\noindent
As an example consider again the CL formula (\ref{eq:undecidable_architecture}) ,
corresponding to the architecture from Fig.~\ref{fig:undecidable_architecture} in the previous section. Let , i.e.,  must output the input  with an one-step delay.
A simple counterexample for this formula consists of two paths  that differ in the values of , but not in the values of~. 
Since process  cannot distinguish the two paths, but must produce different outputs, this leads to contradiction.
Consider the same formula  for the pipeline architecture specified by (\ref{eq:pipeline_architecture}) .
The formula is unsatisfiable due to the delay when forwarding the input  over shared variable  (cf.\ CL semantics in~Section~\ref{sec:cl_semantics}, the current output of  is only visible to  in the next step).
 is a finite counterexample in this case, too: Given an implementation of  and , we extend both paths such that the input-output specification  is satisfied.

The fault-tolerant distributed realizability problem corresponds to  CL formulas of the form .
If  for all , the formula states that there exists an implementation such that the specification  should hold in all architectures induced by the path specifications .
Omitted specifications  in one of these formulas  represent an arbitrary communication error at input  in architecture .
In this case, a counterexample identifies for each implementation one of these architectures where a contradiction occurs.
A \emph{finite} counterexample to satisfiability of  are  finite sets of paths  each corresponding to external coordination variables  in the respective architecture , such that for any implementation  there exists an architecture  and a path  such that an extension  of  violates .
\begin{proposition} \label{eq:dr_with_faults_finite_unsatisfiability}
  A CL formula  over coordination variables  and strategy variables  is unsatisfiable if there exists a finite counterexample to satisfiability of . \qed
\end{proposition}\noindent
A counterexample for the CL specification (\ref{eq:node_failure_example})

introduces paths for inputs as well as for every faulty node such that some paths model the exact input-output specification and other paths model the arbitrary node failures.
The node that reads from a shared variable can, in contrast to incomplete information, react differently on the given paths, but the reaction must be consistent regarding its observations on all paths.
Consider for example the specification  for the CL formula in~(\ref{eq:node_failure_example}), that is, process  should output the input  of nodes  and .
In both architectures, depicted in Fig.~\ref{fig:fault_architectures}, we introduce additional paths for the coordination variable that is omitted in the input-output specification, i.e.,  and  for the first and second conjunct, respectively.
Process~ cannot tell which of its inputs come from a faulty node.
Since  must produce the same output on two paths it cannot distinguish, the implementation of  contradicts the specification in either architecture.
\begin{figure}[t]
\centering
\subfigure[]{
  \begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=1cm,semithick,scale=0.8,transform shape]
\tikzstyle{every state}=[shape=rectangle]
  \tikzstyle{envstate}=[shape=circle,scale=.95]
  
\node[state,envstate] (env) []   {};
  \node[state] (S1) [right=of env] {};
  \node[state] (S2) [above=of env] {};
  \node[state] (S3) [below=of env] {};
  
  \path (S1) edge []   node[swap] {} +(1.25,0)
        (S2) edge []   node[swap] {} +(1.25,0)
        (S3) edge []   node[near start,swap,xshift=-5pt] {} node[near end,xshift=2pt,yshift=-2pt] {} (S1)
        (env) edge node {} (S2)
        (env) edge node {} (S3)
        (env) edge[red] node {} (S1);
\end{tikzpicture}   \label{fig:node_failure_example_left}
}\qquad \subfigure[]{
  \begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=1cm,semithick,scale=0.8,transform shape]
\tikzstyle{every state}=[shape=rectangle]
  \tikzstyle{envstate}=[shape=circle,scale=.95]
  
\node[state,envstate] (env) []   {};
  \node[state] (S1) [right=of env] {};
  \node[state] (S2) [above=of env] {};
  \node[state] (S3) [below=of env] {};
  
  \path (S1) edge []   node[swap] {} +(1.25,0)
        (S2) edge []   node[near start,swap,xshift=2pt,yshift=2pt] {} node[near end,xshift=-2pt,yshift=-2pt] {} (S1)
        (S3) edge []   node[swap] {} +(1.25,0)
        (env) edge node {} (S2)
        (env) edge node {} (S3)
        (env) edge[red] node {} (S1);
\end{tikzpicture}   \label{fig:node_failure_example_right}
}
\caption[]{Visual interpretation of the fault-tolerance specification (\ref{eq:node_failure_example}): There exists a strategy for , , and  such that the specification is satisfied in both architectures.}
\label{fig:fault_architectures}
\end{figure}

\section{Computing Finite Counterexamples} \label{sec:computing_counterexamples}


We encode the existence of finite counterexamples to realizability as a formula of \emph{quantified propositional temporal logic (QPTL)}~\cite{DBLP:conf/lics/KestenP95}. 
QPTL extends LTL with a \emph{path quantifier} , where a path  satisfies  at position , denoted by , if there exists a path  which coincides with  except for the newly introduced atomic proposition , such that .
We define the universal path quantifier  as .
In the following encoding, we use the path quantifier to explicitly name the paths in the counterexample.

\paragraph{\bf Distributed Realizability.} \label{sec:algorithm_incomplete_information}


We consider first the distributed realizability problem, represented by CL formula .
Before proceeding with the general encoding, we show an example query that encodes the existence of a counterexample to satisfiability of CL formula (\ref{eq:pipeline_architecture})  by using two external paths, represented by the path variables  and .
The QPTL query is

This query is satisfiable, one satisfying assignment for  and  is  and , respectively.
The assignments for  is a (alpha renamed) copy of the assignment for , satisfying the condition  for .
As already mentioned in the previous section, the value of  is uniquely determined by the strategies.
Thus, we could optimize the query by removing  altogether.
However, we need the distinction between reading and writing variables later in this section.

The valuations of  and  represent two \emph{paths} in the computation tree of the original CL formula.
In the query above, the strategies for  and  are also evaluated on these two paths.
To make the connection between the path variables  and  and the strategy variable , we introduce \emph{consistency} conditions between all paths considered in the query.
These consistency conditions~\eqref{eq:qptl_example_consustency} state that valuations of universal path variables are only valid if they can be generated by the corresponding strategy.
For example, the consistency condition for , , states that  and  must be different in some step  before  and  can be different in some step .
Hence, according to~\eqref{eq:qptl_example_consustency},  and  hold in the first step.
As  holds in the first step as well, the consistency condition for  extends to the second step as well.
Hence, we have two \emph{paths}, given by the assignments for  and , where  and  differ in the first position, but  in the second position.
Consequently, either  or  holds and we have obtained a counterexample to satisfiability of the CL formula.

In the following, we introduce the general encoding for computing finite counterexamples of CL formulas  by bounding the number of paths regarding the \emph{external} coordination variables .
The bound on the number of paths is given as a function  that maps each coordination variable to the number of branchings that should be considered for this variable.
W.l.o.g.\ we can assume that  for every internal coordination variable .
For example, for coordination variables  and , and  , we encode 4 different paths, one per possible combination for the two paths for each variable.
We fix an arbitrary strict order  between the coordination variables.
For a set , we identify  by the vector in  where the position of the value  for a coordination variable  is determined by .
For our encoding in QPTL, we use the following helper functions:
\begin{itemize}
  \item  returns the set of external coordination variables that \emph{influence} variable .
    An external coordination variable  influences variable  if there is a directed path from  to  in .
    For example in the architecture of Fig.~\ref{fig:node_failure_example}, , , and  are influenced by .
    A coordination variable is influenced by itself.
  
  \item  returns the set of branches belonging to coordination variables .
    A branch  is referenced by a vector in  and the set of branches is
    
  
  \item  and  represent the set of (path) variables in the QPTL formula that belong to the variables of the CL formula.
    For a variable  it introduces for each branch  a separate variable  that represents the variable  belonging to this branch .
    Formally, we define the sets
      
  
  \item  creates the alternating introductions of strategies and paths according to the (partial) order given the subset relation of the strategy variables on .
    For every strategy variable  we introduce all paths belonging to external coordination variables  prior to  and avoid duplicate path introductions: 
    -5pt]
      & \dots \
    where  are ordered such that for all ,  with , either  or , i.e., either  is a subset of  or both are incomparable.
    
   \item  specifies the consistency condition for the variables belonging to the strategy variables on the different branches.
    The variables  belonging to a strategy variable  must be equal as long as the coordination variables in the scope of  on the branches  are equal.
    This is expressible in LTL as we only consider a finite number of branches.
    In detail, the formula
    
    states that for every strategy variable  and every pair of branches  that belongs to , we ensure that the valuation of  on these two branches differ only if one of the variables in the scope of  was different in a prior step.
   
\end{itemize}
Finally, we define the QPTL encoding for CL formula  and function  as

where  is the initialization of LTL formula  on branch , that is we exchange  by  for  where  is the subvector of  that contains the values for coordination variables in .

\paragraph{\bf Fault-tolerant Realizability.} 
\label{sec:realizability_node_failures}


In the case of possible failures, the CL formulas  have the more general form .
In this setting, the set of coordination variables  is in general not partitioned into external and internal coordination variables.
In the first step, we apply the transformation  given in Section~\ref{sec:multiple-architecture-realizability} in order to get a partitioning into external and internal coordination variables.
Furthermore, we generalize  to multiple architecture: An external coordination variable  influences variable  if there is a directed path from  to  in one of the architectures.
The QPTL query for counterexamples to CL formula  and a bound on the number of paths, given by the functions , is

where  is defined as  for every .

Consider the example formula

that models the two-way pipeline architecture, depicted in Fig.~\ref{fig:fault_architectures}, where the connection between shared variables  and  may fail.
We apply the transformation  and get the formula

where  is a free coordination variable.
The QPTL encoding  with  and  is 

In difference to distributed realizability, the encoding states that there must be a violation of the specification in some architecture.
Also, not every architecture is challenged with all paths, e.g., in the query~\eqref{eq:example_encoding_fault_tolerance_architecture_1} for the first architecture, we use only one path as the path specification states that the connection between  and  is correct, while in the second architecture~\eqref{eq:example_encoding_fault_tolerance_architecture_2} we use two paths that are generated by the external inputs  and .
\begin{figure}[t]
  \centering
  \subfigure[]{
  \begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=1.5cm,semithick,scale=0.75,transform shape]
\tikzstyle{every state}=[shape=rectangle]
    
\node[state] (S1)                {};
    \node[state] (S2) [right=of S1]  {};
    
    \path (S1) edge [<-] node {} +(-1.25,0)
          (S1) edge [bend right,red,printing_highlight_lines] node[swap,near start] {} node [swap,near end] {} (S2)
          (S2) edge [bend right] node[swap,near start] {} node[swap,near end] {} (S1)
          (S2) edge [] node {} +(1.25,0)
          ;
  \end{tikzpicture}
}\qquad \subfigure[]{
  \begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=1.5cm,semithick,scale=0.75,transform shape]
\tikzstyle{every state}=[shape=rectangle]
    
\node[state] (S1)                {};
    \node[state] (S2) [right=of S1]  {};
    
    \path (S1) edge [<-] node {} +(-1.25,0)
          (S2) edge [<-] node[xshift=-2pt,yshift=2pt] {} +(0,1)
          (S2) edge [] node[near start] {} node[near end] {} (S1)
          (S2) edge [] node {} +(1.25,0)
          ;
    \node[below=6.5pt of S2] {};
  \end{tikzpicture}
}   \caption[]{Visualization of the two architectures given by the fault-tolerance specification . In architecture , the link between shared variables  and  is faulty, hence,  is an external input.}
  \label{fig:fault_cyclic_architecture}
\end{figure}

\begin{theorem}[Correctness ] \label{thm:correctness_unsatnf}
  Given a CL formula  over coordination variables  and strategy variables .
   is unsatisfiable if there exist functions  such that the QPTL formula  is satisfiable.
\end{theorem}
\proof
  Let  be an arbitrary CL formula after applying the transformation  given in Section~\ref{sec:multiple-architecture-realizability} in order to recover the partitioning into external and internal coordination variables.
  Assume there exists functions  such that the QPTL formula  is satisfiable.
  From the satisfiability of this QPTL formula we construct the proof that the CL formula  is unsatisfiable~(Proposition~\ref{eq:dr_with_faults_finite_unsatisfiability}), i.e., that for all strategies there exists a path  that satisfies .
  
  We introduce the following auxiliary notation for this proof.
  We define  to be the set of variables that are quantified prior to .
   denotes the set  when only considering the existential variables (), respectively universal variables ().
  For a variable  and a branch , we define the branching operator , where  is the subvector of  that contains only values for variables in .
   is used to relate CL variables to QPTL variables, i.e., it selects the variable in QPTL formula that \emph{belongs} to the branch .
  Note that one QPTL variable can belong to more than one branch, for example,  if the branches  and  differ only in the values for variables not contained in .
  For , we write  for the set of QPTL variables belonging to the CL variables  on branch .


  Let  be the strategy variables  ordered according to the subset relation on .
  Let  be an arbitrary strategy for strategy variable  and fix a set of strategies .
  By the semantics of CL we need to show that in the composition of these strategies  there exists a path such that the LTL formula  is satisfied.
  We build the paths that satisfy the LTL formula from the branches  encoded in the QPTL formula.
  Let  be the valuation of the existential path variable in the QPTL formula belonging to coordination variable  on branch .
  Note that  depends on all prior universal quantified variables, especially also on universal quantified variables (representing strategy variables) on different branches.
  The strategies  for  correspond to the external coordination variables, while strategies  for  correspond to the extensions defined in the finite counterexamples (Section~\ref{sec:counterexamples}).
  We view the existential quantified variables in the formula that correspond to the external coordination variables as inputs to our system strategies  and get the canonical tuple of paths , one path  for each branch .
        
  In the construction of the paths , we restrict a strategy  to a single branch, that is the function  where .
  Let  be the strategy corresponding to the strategy variable  in the QPTL formula for branch .
  We have to make sure that  is not more constrained than , i.e., the QPTL path-strategies  must be able to handle all behaviors of .
  As  the strategy  subsumes the strategy , i.e., for every branch  we can embed every strategy  in strategies  when only considering these branches instead of the whole computation tree.
  We build the paths  according to the inductive definition for every  and 
  
  where  denotes the projection of path  to the variables .
  
  Since the  are derived from the system strategies, it holds that they satisfy the consistency condition ~(\ref{eq:consistency_conditon_qptl}) in the QPTL encoding.
  From the satisfaction of the QPTL formula, we conclude that
  
   is satisfied, i.e., there exists an index  and branches  such that  holds.
  From the first conjunct it follows that each path  from  corresponding to a branch  satisfies the path specification .
  We conclude with the second conjunct that one of the branches from  violates the specification~.
\qed

\begin{corollary}[Correctness ] \label{thm:correctness_unsatii}
  Given a CL formula  over coordination variables  and strategy variables .
   is unsatisfiable if there exists a function  such that the QPTL formula  is satisfiable.
\end{corollary}

\begin{rem}[Monotonicity of ]
  For the distributed synthesis encoding it holds that  is monotone with respect to the satisfiability of , however, for the fault-tolerant synthesis this is not necessarily true because of the complex information dependencies between different architectures.
  By increasing the number of paths for a coordination variable  in an architecture  where  is not involved in a fault, i.e.,  is contained in , we restrict the choice of the environment in another architecture (where  could be involved in a fault).
  Hence, we have the following monotonicity condition:  is monotone with respect to the satisfiability of  if  is only increased if  is not contained in the input-output specification .
\end{rem}


\paragraph{\bf Example.} \label{sec:qptl_translation_example}
We consider again the Byzantine Generals' Problem with three nodes , , and .
The first general is the commander who forwards the input  that states whether to attack the enemy or not.
The encoding as CL formula is
\noindent
where we use the following definitions

The quantification prefix introduces the strategies for the generals  and , as well as the communication between the three generals as depicted in the architecture in Fig.~\ref{fig:byzantine_architecture_complete}.
Note that we omit the vote of the commander  as it is not used in the specification.
In the temporal part, we specify which failures can occur.
The first conjunct, corresponding to Fig.~\ref{fig:byzantine_architecture_failure_g1}, states that the commander is a traitor () which implies that the other two generals have to reach a consensus whether to attack or not ().
The other two cases, depicted in Fig.~\ref{fig:byzantine_architecture_failure_g2}--\subref{fig:byzantine_architecture_failure_g3}, are symmetric and state that whenever one general is traitor the other one should agree on the decision made by the commander.
The QPTL encoding  is given as

By using the functions  for  which are defined as

and 0 otherwise, we get a satisfying QPTL instance and, hence, proved the unsatisfiability of .
This resembles the manual proof for the Byzantine Generals' Problem.
In every situation where one of the generals is a traitor, one has to consider the possible deviations from the loyal behavior.

\begin{figure}[t]
\subfigure[]{
  \begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2cm,semithick,scale=0.75,transform shape]
    \tikzstyle{failure1}=[]
    \tikzstyle{failure2}=[]
    \tikzstyle{failure3}=[]
    
\tikzstyle{every state}=[shape=rectangle]

\node[state] (G1)                                      {};
\node[state] (G2) [below left=1cm and 0.63cm of G1]  {};
\node[state] (G3) [below right=1cm and 0.63cm of G1] {};

\path (G1) edge [failure1,bend right,above left] node {} (G2)
      (G1) edge [failure1,bend left,above right] node {} (G3)
      (G2) edge [failure2,bend right=25,below] node {} (G3)
      (G3) edge [failure3,bend right=25,above] node {} (G2)
      (G1) edge [<-] node[xshift=-1pt,yshift=2pt] {} +(0,1);   \end{tikzpicture}
  \label{fig:byzantine_architecture_complete}
}\subfigure[]{
  \begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2cm,semithick,scale=0.75,transform shape]
    \tikzstyle{failure1}=[red,printing_highlight_lines]
    \tikzstyle{failure2}=[]
    \tikzstyle{failure3}=[]
    
\tikzstyle{every state}=[shape=rectangle]

\node[state] (G1)                                      {};
\node[state] (G2) [below left=1cm and 0.63cm of G1]  {};
\node[state] (G3) [below right=1cm and 0.63cm of G1] {};

\path (G1) edge [failure1,bend right,above left] node {} (G2)
      (G1) edge [failure1,bend left,above right] node {} (G3)
      (G2) edge [failure2,bend right=25,below] node {} (G3)
      (G3) edge [failure3,bend right=25,above] node {} (G2)
      (G1) edge [<-] node[xshift=-1pt,yshift=2pt] {} +(0,1);   \end{tikzpicture}
  \label{fig:byzantine_architecture_failure_g1}
}\subfigure[]{
  \begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2cm,semithick,scale=0.75,transform shape]
    \tikzstyle{failure1}=[]
    \tikzstyle{failure2}=[red,printing_highlight_lines]
    \tikzstyle{failure3}=[]
    
\tikzstyle{every state}=[shape=rectangle]

\node[state] (G1)                                      {};
\node[state] (G2) [below left=1cm and 0.63cm of G1]  {};
\node[state] (G3) [below right=1cm and 0.63cm of G1] {};

\path (G1) edge [failure1,bend right,above left] node {} (G2)
      (G1) edge [failure1,bend left,above right] node {} (G3)
      (G2) edge [failure2,bend right=25,below] node {} (G3)
      (G3) edge [failure3,bend right=25,above] node {} (G2)
      (G1) edge [<-] node[xshift=-1pt,yshift=2pt] {} +(0,1);   \end{tikzpicture}
  \label{fig:byzantine_architecture_failure_g2}
}\subfigure[]{
  \begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2cm,semithick,scale=0.75,transform shape]
    \tikzstyle{failure1}=[]
    \tikzstyle{failure2}=[]
    \tikzstyle{failure3}=[red,printing_highlight_lines]
    
\tikzstyle{every state}=[shape=rectangle]

\node[state] (G1)                                      {};
\node[state] (G2) [below left=1cm and 0.63cm of G1]  {};
\node[state] (G3) [below right=1cm and 0.63cm of G1] {};

\path (G1) edge [failure1,bend right,above left] node {} (G2)
      (G1) edge [failure1,bend left,above right] node {} (G3)
      (G2) edge [failure2,bend right=25,below] node {} (G3)
      (G3) edge [failure3,bend right=25,above] node {} (G2)
      (G1) edge [<-] node[xshift=-1pt,yshift=2pt] {} +(0,1);   \end{tikzpicture}
  \label{fig:byzantine_architecture_failure_g3}
}\caption[]{The Byzantine Generals' architecture. Figure (a) shows the architecture in cases all generals are loyal. Figures \subref{fig:byzantine_architecture_failure_g1}--\subref{fig:byzantine_architecture_failure_g3} show the possible failures, indicated by the dashed communication links.}
\label{fig:byzantine_architecture}
\end{figure}

\begin{comment}
\subsubsection{Analysis.}

For finding a counterexample for every possible strategy in the Byzantine Generals' Problem we need to select 6 different paths as shown in Fig.~\ref{fig:byzantine_path_selection}.

\begin{figure}
\centering
\begin{tikzpicture}[-,>=stealth',shorten >=1pt,auto,semithick,scale=1,transform shape]
  
  \tikzstyle{treenode} = [fill,circle,inner sep=0,minimum size=5pt]
      
  \node[treenode](tree1) {}
child {
      child {
        child {
          node[treenode]{} edge from parent node[left,align=right]{\\}
        }
        node[treenode]{} edge from parent node[left,align=right]{\\}
      }
      node[treenode]{} edge from parent node[left]{}
    }
    child {
      child {
        child {
          node[treenode]{} edge from parent node[right,align=left]{\\}
        }
        node[treenode]{} edge from parent node[right,align=left]{\\}
      }
      node[treenode]{} edge from parent node[right]{}
    }
    ;
  
  \node[above of=tree1] {(1,2)};
  
  \node[treenode,right=4cm of tree1](tree2) {}
child {
      child {
        child {
          node[treenode]{} edge from parent node[left,align=right]{\\}
        }
        node[treenode]{} edge from parent node[left,align=right]{\\}
      }
      child {
        child {
          node[treenode]{} edge from parent node[right,align=left]{\\}
        }
        node[treenode]{} edge from parent node[right,align=left]{\\}
      }
      node[treenode]{} edge from parent node[right]{}
    }
    ;
  
  \node[above of=tree2] {(2,3)};

  \node[treenode,right=4cm of tree2](tree3) {}
child {
      child {
        child {
          node[treenode]{} edge from parent node[left,align=right]{\\}
        }
        node[treenode]{} edge from parent node[left,align=right]{\\}
      }
      node[treenode]{} edge from parent node[left]{}
    }
    child {
      child {
        child {
          node[treenode]{} edge from parent node[right,align=left]{\\}
        }
        node[treenode]{} edge from parent node[right,align=left]{\\}
      }
      node[treenode]{} edge from parent node[right]{}
    }
    ;

  \node[above of=tree3] {(1,3)};

\end{tikzpicture} \caption[]{Path selection for counter example when assuming that all correct nodes use the identity input-output encoding}
\label{fig:byzantine_path_selection}
\end{figure}
\end{comment}

\section{Completeness} \label{sec:completeness}


In practice, finite external counterexamples are often sufficient to detect unrealizable specifications. In this section, we show that our method is in fact complete for the case of safety specifications and weakly ordered architectures. 
It turns out that if one of these restrictions is dropped, i.e., if one is interested in general LTL specifications, or in architectures that are not weakly ordered, then finite counterexamples may no longer exist, and the method, therefore, becomes incomplete.



A universal safety (tree) automaton is a tuple  where  denotes a finite set of labels,  denotes a finite set of directions,  is a finite set of states,  the designated initial state, and  denotes the transition function.
The transition function  maps a state and a input letter to a positive and conjunctive Boolean formula over .
We allow the abbreviations  and .

A -labeled -transition system is a tuple  where  is a finite set of states,  is the designated initial state,  is the transition function, and  is the state labeling function.
A universal safety automaton accepts a -labeled -transition system  if  has a run graph.
A run graph is a directed graph  that satisfies the following constraints:
\begin{itemize}
  \item The vertices  are a subset of the product of  and .
  \item The pair of initial states  is a vertex of .
  \item For each vertex , the set  satisfies .
\end{itemize}
Since  is universal, the run graph on a transition system is unique.

If we start with a temporal specification instead of a universal safety automaton, we first need the following transformations.
As we only consider safety languages, we restrict the temporal specifications to \emph{syntactically safe}~\cite{DBLP:journals/fac/Sistla94} formulas, i.e., LTL formulas where the only temporal operator is the weak until . (The weak until subsumes the globally operator , which is equivalent to .)
\begin{proposition}[\hspace{-0.3pt}\cite{DBLP:journals/fmsd/KupfermanV01}]
  Given a syntactically safe LTL formula , we can construct a non-deterministic automaton  on finite words that accepts the (not necessarily minimal) good prefixes of the co-safety formula .
  The size of  is on .
\end{proposition}\noindent
Using this result, we build the universal safety automaton  by simulating the automaton  along each path: if each path is not a good prefix for the negation of , then  holds on every path.
\begin{proposition} \label{thm:universal-safety-automaton-for-safety-ltl}
  Given a syntactically safe LTL formula , we can construct a universal safety automaton  with  states that accepts a transition system  if, and only if,  satisfies .\qed
\end{proposition}\noindent
We use the bound on the size of a transition system that is accepted by a universal safety automaton  in order to derive a upper bound on the number of counterexample paths needed to refute the existence of an implementation.
\begin{proposition}[\hspace{-0.3pt}\cite{journals/sttt/FinkbeinerS13}] \label{thm:safety-automaton-finite-transition-system}
If a universal safety automaton  with  states accepts a transition system, then  accepts a finite transition system  with  states.
\end{proposition}

\begin{theorem} \label{thm:completeness_full_informed_synthesis}
  Given a syntactically safe LTL formula  over inputs  and outputs ,  is unrealizable if, and only if, there exists a finite counterexample.
\end{theorem}
\proof
  Let  be the universal safety automaton for 
  according to Proposition~\ref{thm:universal-safety-automaton-for-safety-ltl}.
  By the contraposition of Lemma~\ref{thm:safety-automaton-finite-transition-system} it holds that  rejects all transition systems if  rejects all finite transition systems with  states.
  Hence, all finite transition systems with size  have a finite counterexample path in the run of .
  We show that every minimal counterexample path is bounded by , where  is the longest loop-free path in the safety automaton .
  
  Assume by contradiction that there exists a transition system  of size , where the length of the minimal counterexample path  exceeds .
  As  is the size of the product of  and , there must be a repetition on , i.e., there exists  such that .
  Thus, we can shorten the counterexample to  violating our minimality assumption.
  
  As the length of the minimal counterexample is bounded by , all minimal counterexamples are contained in the full tree of depth  that has  paths.
\qed\noindent
This argumentation can be generalized to weakly ordered architectures since we have an upper bound on the size of implementations, too.
Given an architecture  and an implementation for each process, we call the resulting system the distributed product according to architecture  as the system state consist of the product of the states of the process implementations.
The meaning of the distributed product is a strategy  that maps finite input sequences from the environment to the valuations of the process outputs.
\begin{proposition}[\hspace{-0.3pt}\cite{DBLP:conf/lics/FinkbeinerS05}] \label{thm:bound_distributed_realizability}
  For a weakly ordered  architecture and a realizable specification~, the size of the smallest implementation of every process is -exponential, where  is the number of processes.
\end{proposition}

\begin{theorem}
  Given a syntactically safe LTL formula  and a weakly ordered architecture ,  is unrealizable in  if, and only if, there exists a finite counterexample.
\end{theorem}
\proof
   Let  be the universal safety automaton for .
  By Proposition~\ref{thm:bound_distributed_realizability} and the unrealizability of  in  it holds that there does not exist -exponential strategies for the processes.
  Let  be arbitrary -exponential strategies for the  processes and  be the (-exponential) \emph{distributed product} according to architecture .
  
  We choose a bound  that is greater than the size of the product of  and .
  By the same argument as in the proof of Theorem~\ref{thm:completeness_full_informed_synthesis}, it follows that the length of the minimal counterexample for every such  is bounded by , hence the number of paths is bounded by .
\qed\noindent
Proposition~\ref{eq:ecl_unsatisfiability} states that the characterization of unsatisfiable formulas with counterexamples is complete.
Our method, however, searches for counterexamples involving only a bounded number of external paths. In general, this is not enough, as the following propositions show.\begin{proposition}
  For full LTL, the unrealizability of a specification does not imply the existence of a finite counterexample.
\end{proposition}
\proof
Consider the CL formula  with temporal specification .
 is unsatisfiable because for every strategy  it holds that  cannot correctly guess the future value of  on every path, as the formula is evaluated over the full binary tree that branches by the valuation of  (cf.\ CL semantics in~Section~\ref{sec:cl_semantics}).
Assume for contradiction that a finite set of paths  suffices to satisfy  against every strategy~.
As there are only a finite set of paths , there exists a level in the full binary tree such that every node in this level has at exactly one successor path in .
Choose the strategy  that assigns the nodes in this level with one successor the labeling of the next input.
Such a finite state strategy exists because the nodes in each level are distinguishable by the strategy.
Hence, for all paths in  it holds that  and thus no path satisfies .
\qed

\begin{proposition}
  For the architecture in Fig.~\ref{fig:undecidable_architecture}, the unrealizability of a safety specification does not imply the existence of a finite counterexample.
\end{proposition}
\proof
Let  be a deterministic Turing machine that implements a unary counter.
We use the encoding of  into the realizability problem of a safety LTL formula  in the architecture of Fig.~\ref{fig:undecidable_architecture}~\cite{DBLP:journals/ipl/Schewe14}.
There does not exist a finite state implementation that satisfies , but for every finite set of environment input paths, only a finite number of correct configurations of  can be asserted.
Hence, for every such finite set of paths, there exists an implementation that fulfills these assertions.
\qed


\section{Approximations} 
\label{sec:abstractions}


Presently available QPTL solvers were unable to handle even small instances of our problem.
In this section, we present two simplifications of the finite counterexample problem and their corresponding encodings.
We consider the problem where we restrict the counterexample paths to a finite length by using a \emph{weak monadic second order logic of one successor~(WS1S)} encoding.
Afterwards, we show a practical encoding in \emph{quantified Boolean formulas~(QBF)} that bounds the length of a counterexample path.
We only consider the more general form of CL formulas modeling the fault-tolerance case, i.e., .

\paragraph{\bf From QPTL to S1S}
We give a short introduction to the monadic second-order theory of one successor (S1S) and show the equisatisfiable reduction from QPTL to S1S.
Let  and  be finite sets of first-order and second-order variables, respectively.
A term  is given by the grammar

where  is a first-order variable and  denotes the successor function of the natural numbers.
We build formulas  over terms by using the grammar

where  is a term,  is a first-order variable, and  is a second-order variable.
We define  as ,  as , and  as .
Furthermore, we use the abbreviations  and .

The semantics of S1S is defined over first-order and second-order valuations  and , respectively.
The semantics of terms is defined as\smallskip\\
\begin{tabular}{L l}
   & ,\1pt]
   & \enspace,
\end{tabular}\smallskip\\
where  is a term and .
The semantics of formulas is defined as\smallskip\\
\begin{tabular}{L l}
   & ,\1pt]
   & ,\1pt]
   & , and\1pt]
   & ,\1pt]
   & ,\1pt]
   &  \enspace,
\end{tabular}\smallskip\\
where  and  are fresh first order variables.\qed

\paragraph{\bf Finite-length Counterexamples.}


When we restrict the counterexamples to finite length, we lose the ability to detect violations of liveness properties.
Thus, we restrict the LTL specifications  in  to syntactic \emph{safety} properties~\cite{DBLP:journals/fmsd/KupfermanV01}.
As these specifications are negated in the encoding, the resulting LTL specifications describe \emph{co-safety} properties~\cite{DBLP:journals/fmsd/KupfermanV01}.
A property  is co-safety if every  has a \emph{good prefix}, that is a prefix  of  such that for all  it holds that .

In the weak version of S1S, the second-order quantification is restricted to finite sets.
While syntactically equivalent to S1S, we change the semantics  by replacing the second-order quantification rule by

We define a S1S formula  that asserts that the valuation of the second-order variable  is a finite set:

We define  as  with the difference that we interpret the result of  as a WS1S formula and we only apply it to co-safety LTL formulas.

\begin{lemma} \label{thm:co-safety-ws1s}
Given a QPTL formula  where  is a co-safety LTL formula.
If  is satisfiable then  is satisfiable.
\end{lemma}
\proof
Let  be satisfiable.
By Lemma~\ref{thm:qptl_to_s1s}, it suffices to argue that  is satisfiable.
First, we can extend any existential quantification  to infinite quantification as the WS1S restriction to quantification over finite sets are special cases of the S1S semantics (these where  holds).
Next, we show that finite universal quantification is as powerful as infinite universal quantification.
Consider the co-safety LTL formula .
It holds that every satisfying assignment has a good prefix~\cite{DBLP:journals/fmsd/KupfermanV01}.
Hence, the satisfaction of an infinite word  depends only on a finite prefix.
Thus, a satisfying assignment against universal quantified finite sequences implies the satisfaction against universal quantified infinite sequences.
\qed

\noindent
The WS1S encoding of CL formula  and functions  is

where  is defined as  for every .
 introduces the second-order variables  that correspond to the path variables , but is otherwise identical to the QPTL version.
Furthermore,  uses second-order equivalence  for .
The consistency condition  in WS1S is defined as the conjunction of

for every .
This formula ensures different reactions of a universal variable on two branches is based on different prior valuations of the dependencies (cf.~QPTL consistency condition~\eqref{eq:consistency_conditon_qptl}).

We give an example query based on CL formula (\ref{eq:pipeline_architecture}) .
The WS1S query is


\begin{theorem}[Correctness ] \label{thm:correctness_ws1s_encoding}
  Given a CL formula  over coordination variables  and strategy variables .
  Let  be a syntactically safe LTL formula for each .
   is unsatisfiable if there exists functions  such that the WS1S formula  is satisfiable.
\end{theorem}
\proof
Assume  is satisfiable.
We show that this implies the satisfiability of  and use Theorem~\ref{thm:correctness_unsatnf} that states the correctness of the QPTL encoding.
Lemma~\ref{thm:co-safety-ws1s} states that we only have to consider finite state sequences for the LTL specifications .
What is missing in the argumentation are the paths specifications  and the consistency condition .
The transformed path specifications are equisatisfiable under WS1S and QPTL semantics as the (existential quantified) input variables appear after the (universal quantified) strategy variables in .
Lastly, the consistency condition restricts the finite behavior of the universal quantified strategy variables and the infinite behavior does not affect the satisfiability of the co-safety properties.
Hence, there exists an infinite path extension for every existentially quantified second-order variable, and the formula remains satisfiable against any infinite path extension of the universally quantified second-order variables.
\qed\noindent
WS1S is supported by the Mona~\cite{DBLP:conf/tacas/HenriksenJJKPRS95} tool.
Some of our smaller instances were solved by Mona, but the Byzantine Generals' Problem failed due to memory constraints in the BDD library.


\paragraph{\bf Bounded-length Counterexamples.}
Taking the simplifications even further, we not only bound the \emph{number} of paths but also the \emph{length} of the paths by translating the problem to the satisfiability problem of \emph{quantified Boolean formulas (QBF)}.
Quantified Boolean formulas are the extension of Boolean formulas by quantification over variables.
Let  be a finite set of variables.
The syntax of QBF is given by the grammar

where .
We define the usual abbreviations , , , , , and .
The semantics is defined over valuations . The satisfaction of an valuation  is defined as\smallskip\\
\begin{tabular}{L l}
   & ,\1pt]
   & , and\1pt]
   & , for ,\1pt]
   & ,\1pt]
   &  for  \enspace.
\end{tabular}\smallskip\\
\begin{corollary} \label{thm:co-safety-qbf}
Given a QPTL formula  where  is a syntactically co-safe LTL formula.
If  is satisfiable for some  then  is satisfiable.
\end{corollary}\noindent
The QBF encoding of CL formula  and functions  is

where  is defined as  for every  and .
 introduces the variables  that correspond to the path variables , but is otherwise identical to the QPTL version.
Furthermore,  uses the equivalence  for .
The consistency condition  in QBF is defined as the conjunction of

for every .
This formula ensures different reactions of a strategy variable on two branches is based on different prior valuations to the dependencies (cf.~QPTL consistency condition~\eqref{eq:consistency_conditon_qptl}).
In this simple translation, one cause of high complexity is due to the consistency conditions between the strategy variables across different paths.
However, most of these variables are not used for the counterexample itself but appear only in the consistency condition.
One optimization removes these unnecessary variables from the encoding.
Therefore, we collect all strategy variables and (when possible) their temporal occurrence from the LTL specification.
For every used strategy variable we build the \emph{dependency graph} that contains all variables which can influence the outcome of the strategy.
In the last step, we remove all variables that are not contained in any dependency graph.
This optimization is depicted in Fig.~\ref{fig:qbf_encoding_optimization_dependency_graph}.

\begin{figure}
  \subfigure[]{
    \tikzstyle{used1}=[]
    \tikzstyle{used2}=[]
    \tikzstyle{used3}=[]
    \tikzstyle{used4}=[]
    \tikzstyle{unused}=[]
      \begin{tikzpicture}[node distance=0.5cm,scale=0.75,semithick,transform shape]
    
    \node (step0) {};
    \node[used1,right=0.5cm of step0] (v0) {};
    \node[unused,right=of v0] (g120) {};
    \node[unused,right=of g120] (g130) {};
    \node[unused,right=of g130] (g230) {};
    \node[unused,right=of g230] (g320) {};
    \node[unused,right=of g320] (g20) {};
    \node[unused,right=of g20] (g30) {};
    
    \node[below=1.5cm of step0] (step1) {};
    \node[right=0.5cm of step1] (v1) {};
    \node[right=of v1] (g121) {};
    \node[right=of g121] (g131) {};
    \node[unused,right=of g131] (g231) {};
    \node[unused,right=of g231] (g321) {};
    \node[unused,right=of g321] (g21) {};
    \node[unused,right=of g21] (g31) {};
    
    \node[below=1.5cm of step1] (step2) {};
    \node[unused,right=0.5cm of step2] (v2) {};
    \node[right=of v2] (g122) {};
    \node[right=of g122] (g132) {};
    \node[right=of g132] (g232) {};
    \node[right=of g232] (g322) {};
    \node[unused,right=of g322] (g22) {};
    \node[unused,right=of g22] (g32) {};
    
    \node[below=1.5cm of step2] (step3) {};
    \node[unused,right=0.5cm of step3] (v3) {};
    \node[unused,right=of v3] (g123) {};
    \node[unused,right=of g123] (g133) {};
    \node[unused,right=of g133] (g233) {};
    \node[unused,right=of g233] (g323) {};
    \node[used1,right=of g323] (g23) {};
    \node[used1,right=of g23,yshift=2pt] (g33) {};
    
    \path[unused]
          (g120) edge (g231)
          (g120) edge (g21)
          (g130) edge (g321)
          (g130) edge (g31)
          (g230) edge (g31)
          (g320) edge (g21)
          
          (g121) edge (g22)
          (g131) edge (g32)
          (g231) edge (g32)
          (g321) edge (g22)
          
          (v2) edge (g123)
          (v2) edge (g133)
          (g122) edge (g233)
          (g132) edge (g323)
          ;
    
    \path[used4]
          (v0) edge (g121)
          (v0) edge (g131)
          ;

    \path[used3]
          (v1) edge (g122)
          (v1) edge (g132)
          (g121) edge (g232)
          (g131) edge (g322)
          ;
          
    \path[used2]
          (g122) edge (g23)
          (g132) edge (g33)
          (g232) edge (g33)
          (g322) edge (g23)
          ;
    
    \draw (step0.north east) -- (step3.south east);
    
\end{tikzpicture}     \label{fig:qbf_encoding_optimization_dependency_graph_before}
  }\subfigure[]{
    \tikzstyle{used1}=[red,circle,draw]
    \tikzstyle{used2}=[red]
    \tikzstyle{used3}=[red]
    \tikzstyle{used4}=[red]
    \tikzstyle{unused}=[black!30]
      \begin{tikzpicture}[node distance=0.5cm,scale=0.75,semithick,transform shape]
    
    \node (step0) {};
    \node[used1,right=0.5cm of step0] (v0) {};
    \node[unused,right=of v0] (g120) {};
    \node[unused,right=of g120] (g130) {};
    \node[unused,right=of g130] (g230) {};
    \node[unused,right=of g230] (g320) {};
    \node[unused,right=of g320] (g20) {};
    \node[unused,right=of g20] (g30) {};
    
    \node[below=1.5cm of step0] (step1) {};
    \node[right=0.5cm of step1] (v1) {};
    \node[right=of v1] (g121) {};
    \node[right=of g121] (g131) {};
    \node[unused,right=of g131] (g231) {};
    \node[unused,right=of g231] (g321) {};
    \node[unused,right=of g321] (g21) {};
    \node[unused,right=of g21] (g31) {};
    
    \node[below=1.5cm of step1] (step2) {};
    \node[unused,right=0.5cm of step2] (v2) {};
    \node[right=of v2] (g122) {};
    \node[right=of g122] (g132) {};
    \node[right=of g132] (g232) {};
    \node[right=of g232] (g322) {};
    \node[unused,right=of g322] (g22) {};
    \node[unused,right=of g22] (g32) {};
    
    \node[below=1.5cm of step2] (step3) {};
    \node[unused,right=0.5cm of step3] (v3) {};
    \node[unused,right=of v3] (g123) {};
    \node[unused,right=of g123] (g133) {};
    \node[unused,right=of g133] (g233) {};
    \node[unused,right=of g233] (g323) {};
    \node[used1,right=of g323] (g23) {};
    \node[used1,right=of g23,yshift=2pt] (g33) {};
    
    \path[unused]
          (g120) edge (g231)
          (g120) edge (g21)
          (g130) edge (g321)
          (g130) edge (g31)
          (g230) edge (g31)
          (g320) edge (g21)
          
          (g121) edge (g22)
          (g131) edge (g32)
          (g231) edge (g32)
          (g321) edge (g22)
          
          (v2) edge (g123)
          (v2) edge (g133)
          (g122) edge (g233)
          (g132) edge (g323)
          ;
    
    \path[used4]
          (v0) edge (g121)
          (v0) edge (g131)
          ;

    \path[used3]
          (v1) edge (g122)
          (v1) edge (g132)
          (g121) edge (g232)
          (g131) edge (g322)
          ;
          
    \path[used2]
          (g122) edge (g23)
          (g132) edge (g33)
          (g232) edge (g33)
          (g322) edge (g23)
          ;
    
    \draw (step0.north east) -- (step3.south east);
    
\end{tikzpicture}     \label{fig:qbf_encoding_optimization_dependency_graph_after}
  }\caption[]{Example for a dependency graph of the Byzantines' Generals Problem. The graph identifies all variables that influence the variables used in the LTL specifications  and  (variables with red circle). All variables that do not influence the LTL formula can be safely removed, e.g., the input  in step  and  never reaches the strategies  and .}
  \label{fig:qbf_encoding_optimization_dependency_graph}
\end{figure}

Let us consider again the pipeline example given by the CL formula (\ref{eq:pipeline_architecture}) .
The QBF encoding with unrolling depth of  is


\begin{theorem}[Correctness ] \label{thm:correctness_qbf_encoding}
  Given a CL formula  over coordination variables  and strategy variables .
  Let  be a syntactically safe LTL formula for each .
   is unsatisfiable if there exists functions  such that the QBF query  is satisfiable for some .
\end{theorem}
\proof
The encoding is a special case of Theorem~\ref{thm:correctness_ws1s_encoding}.
If the Boolean formula that is a finite -unrolling of the LTL formula is satisfied against a finite sequence of length , i.e., we found a counterexample within the first  steps, then it is also satisfied against any (possibly infinite) strategy.
\qed









\section{Experimental Results}


We have carried out our experiments on a 2.6\,GHz Opteron system.
For solving the QBF instances, we used a combination of the QBF preprocessor Bloqqer~\cite{DBLP:conf/cade/BiereLS11} in version 031 and the QBF solver DepQBF~\cite{DBLP:journals/jsat/LonsingB10} in version 3.0.3.
For solving the WS1S instances, we used Mona~\cite{DBLP:conf/tacas/HenriksenJJKPRS95} in version 1.4-15.

\paragraph{\bf Byzantine Generals' Problem.}


\begin{table}[b]
\caption[]{Result of the \emph{Byzantine Generals' Problem} example}\medskip
\label{tbl:bgp_example}
\centering
\begin{tabular}{l|rrrrr}
Bound         &    &    &    &    &  \ \label{eq:byzantine_firing_squad}
  &\eclexists{\set{\text{req}_1}}{\text{bcast}_1} \eclexists{\set{\text{req}_1, \text{chan}_{21}, \text{chan}_{31}}}{\text{out}_1} \nonumber\\
  &\eclexists{\set{\text{req}_2}}{\text{bcast}_2} \eclexists{\set{\text{req}_2, \text{chan}_{12}, \text{chan}_{32}}}{\text{out}_{2}} \nonumber\\
  &\eclexists{\set{\text{req}_3}}{\text{bcast}_3} \eclexists{\set{\text{req}_3, \text{chan}_{13}, \text{chan}_{23}}}{\text{out}_{3}} \nonumber\\
  & \left( \eclalws  \operational_{2,3}  \rightarrow \consistent_{2,3} \right) \land {} \nonumber\\
  & \left( \eclalws  \operational_{1,3}  \rightarrow \consistent_{1,3} \right) \land {} \nonumber\\
  & \left( \eclalws  \operational_{1,2}  \rightarrow \consistent_{1,2} \right) \land {} \nonumber\\
  & \left( \eclalws  \operational_{1,2,3}  \rightarrow \consistent_{1,2,3} \land \uniform_{1,2,3} \right) \enspace,

  \consistent_N &{} \coloneqq \eclalws \bigwedge_{i<j \in N^2} \big( \text{out}_i = \text{out}_j \big) \text{ and} \nonumber \\
  \uniform_N &{} \coloneqq \left( \bigvee_{i \in N} \text{req}_i \right) \rightarrow \eclnnext{3} \left( \bigvee_{i \in N} \text{out}_i \right) \enspace. \label{eq:bfsp_fixed_uniform}
 \label{eq:cap_theorem}
  &\eclexists{\set{\text{req}_1}}{\text{com}_1} \eclexists{\set{\text{req}_1, \text{chan}_2}}{\text{out}_1} \eclexists{\set{\text{req}_2}}{\text{com}_2} \eclexists{\set{\text{req}_2, \text{chan}_1}}{\text{out}_2} \nonumber\\
  & ( \eclalws ( \text{chan}_1 = \text{com}_1 ) \rightarrow \eclalws ( (\text{out}_1 = \text{out}_2) \land ( (\text{req}_1 \lor \text{req}_2) \leftrightarrow \eclnnext{3} (\text{out}_1 \lor \text{out}_2) ) ) ) \land {} \nonumber\\
  & ( \eclalws ( \text{chan}_2 = \text{com}_2 ) \rightarrow \eclalws ( (\text{out}_1 = \text{out}_2) \land ( (\text{req}_1 \lor \text{req}_2) \leftrightarrow \eclnnext{3}(\text{out}_1 \lor \text{out}_2) ) ) ) \enspace .
 \label{eq:example_infinite_long}
  \eclexists{\emptyset}{y} \eclevtlalws (\eclnext y \leftrightarrow x)  
 \label{eq:bfsp_finite_uniform}
  \uniform_N \coloneqq \left( \bigvee_{i \in N} \text{req}_i \right) \rightarrow \eclevtl \left( \bigvee_{i \in N} \text{out}_i \right)

  \Phi = \mathcal{Q}_\exists \ldot \bigwedge_{F \in \mathcal{F}} \big( \varphi_{\mathit{path}_F} \rightarrow \varphi_F \big)


We now define the path specifications .
Let  be a fault-tolerance scenario.
For every process  we introduce a fresh coordination variable  that immediately signals whether a fault occurred at process  in the last step.
If the faults are observable () we extend the scope of every strategy variable by \footnote{These signals are called \emph{fault-notification variables} in~\cite{DBLP:conf/atva/DimitrovaF09} as only detectable faults were considered.}.

Let .
We remove every conjunct  from  where  is the output of a faulty process.
For every  we add the following new constraints to  depending on the type of faults .
For readability, we replace  by ,  by , and  by .
\begin{itemize}
  \item : .
  \item : .
  \item : .
  \item : .
\end{itemize}
Lastly, we add a requirement for every  variable regarding the specified duration :
\begin{itemize}
  \item : 
  \item : . If we want to have tighter control about the duration of faults we can use the parametric LTL operators~\cite{DBLP:journals/tocl/AlurETP01} to bound the length  of a fault , or require that length of a correct behavior is longer than  by formula .
  \item :  where  is the maximal duration of the fault.
\end{itemize}
We simplify the undetectable permanent fault encoding by removing the  variables, as these variables are not used in the specification.
Our formulation allows for many types and durations of faults that cannot be captured with a fault-tolerance scenario.
Indeed, it is possible to use arbitrary LTL formulas to specify the type and duration of a fault.
Computing counterexamples for these general types of faults can be integrated into the method described in Section~\ref{sec:computing_counterexamples}.

\section{Conclusion}


We have introduced counterexamples for distributed realizability and shown how to automatically derive counterexamples from given specifications in CL.
We used encodings in QPTL, WS1S, and QBF\@.
In our experiments, the QBF encoding was the most efficient.
Even problems with high combinatorial complexity, such as the Byzantine Generals' Problem, are handled automatically.
Given that QBF solvers are likely to continue to improve in the future, even larger instances should become tractable.
In future work, we plan to extend the method to a larger class of \emph{infinite} counterexamples, which will support liveness specifications.
Furthermore, we want to investigate approximation techniques for more general types of faults.

\section*{Acknowledgments}


This work was partially supported by the German Research Foundation (DFG) as part of the Transregional Collaborative Research Center ``Automatic Verification and Analysis of Complex Systems'' (SFB/TR 14 AVACS).
We thank Swen Jacobs for comments on an earlier version of this paper.

\bibliographystyle{alpha}
\bibliography{main}


\end{document}
