\documentclass[envcountsame]{llncs}
\pdfoutput=1 

\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{url}
\usepackage{wrapfig}
\usepackage{graphics}
\usepackage{graphicx}

\newcommand{\ZZZ}{\mathbb{Z}}
\newcommand{\bfd}{\mathbf{d}}
\newcommand{\OO}{\mathcal{O}}
\newcommand{\outline}[1]{\textsl{#1}}

\newcommand{\comment}[1]{\footnote{!!! #1}}
\newcommand{\oldcomment}[1]{}

\newcommand{\exactly}[1]{\mbox{exactly}_{#1}}
\newcommand{\atleast}[1]{\mbox{atLeast}_{#1}}
\newcommand{\atmost}[1]{\mbox{atMost}_{#1}}
\newcommand\tuple[1]{\langle #1 \rangle}
\newcommand\etal{{\it et al{.}}}
\newcommand\minisatp{\textsc{MiniSat}}
\newcommand{\Base}{\mathit{Base}}
\newcommand{\intMultiSet}{\mathit{ms(\mathbb{N})}}
\newcommand{\sumCarry}{\mathit{sum\_carry}}
\newcommand{\sumDigits}{\mathit{sum\_digits}}
\newcommand{\numComparators}{\mathit{num\_comp}}
\newcommand{\cost}{\mathit{cost}}

\newenvironment{SProg}
     {\begin{small}\begin{tt}\begin{tabular}[c]{l}}{\end{tabular}\end{tt}\end{small}}

\newenvironment{SProg2}
     {\begin{small}\begin{tt}\begin{tabular}[c]{ll}}{\end{tabular}\end{tt}\end{small}}
\newcommand{\qin}{\hspace*{0.15in}}

\newcommand{\set}[1]{\left\{
      \begin{array}{l}#1\end{array}
        \right\}}
\newcommand{\sset}[2]{\left\{~#1  \left|
      \begin{array}{l}#2\end{array}
    \right.     \right\}}
\newcommand{\card}[1]{ 
    \left|
      \begin{array}{l}#1\end{array}
    \right|}
\def\anno#1{{\ooalign{\hfil\raise.07ex\hbox{\small{\rm #1}}\hfil \crcr\mathhexbox20D}}}
\newcommand{\ceil}[1]{\lceil{#1}\rceil} 


\pagestyle{plain}

\title{Optimal Base Encodings for\\
       Pseudo-Boolean Constraints\thanks{Supported by GIF\ grant
       966-116.6 and the Danish Natural Science Research Council.}
       }



\author{    Michael Codish\inst{1}
            \and
            Yoav Fekete\inst{1}
            \and
            Carsten Fuhs\inst{2}
            \and
            Peter Schneider-Kamp\inst{3}
}

\institute{
	Department of Computer Science, 
        Ben Gurion University of the Negev, Israel
\and 	  
	LuFG Informatik 2, RWTH Aachen University, Germany 
\and 	  
        IMADA, University of Southern Denmark, Denmark
}


\begin{document}
\maketitle

\begin{abstract}
  This paper formalizes the \emph{optimal base problem}, presents an
  algorithm to solve it, and describes its application to the encoding
  of Pseudo-Boolean constraints to SAT.  We demonstrate the impact of
  integrating our algorithm within the Pseudo-Boolean constraint
  solver \minisatp.  Experimentation indicates that our algorithm
  scales to bases involving numbers up to 1,000,000, improving on the
  restriction in \minisatp\ to prime numbers up to 17.  We show that,
  while for many examples primes up to 17 do suffice, encoding with
  respect to optimal bases 
reduces the CNF sizes and improves the subsequent SAT solving
  time for many examples.
\end{abstract}

\section{Introduction}

The optimal base problem is all about finding an efficient
representation for a given collection of positive integers. One
measure for the efficiency of such a representation is the sum of the
digits of the numbers.  Consider for example the decimal numbers
. The sum of their digits is 25.  Taking binary
representation we have   and
the sum of digits is 13, which is smaller. Taking ternary
representation gives  with an even
smaller sum of digits, 12. Considering the \emph{mixed radix} base
, the numbers are represented as 
 and the sum of the digits is 9.  The optimal base
problem is to find a (possibly mixed radix) base for a given sequence
of numbers to minimize the size of the representation of the
numbers. When measuring size as ``sum of digits'', the base  is
indeed optimal for the numbers of . In this paper we present the
optimal base problem and illustrate why it is relevant to the encoding
of Pseudo-Boolean constraints to SAT.
We also present an algorithm and show that our implementation is
superior to current implementations.

Pseudo-Boolean constraints take the form , where  are integer coefficients,
 are Boolean literals (i.e., Boolean variables or
their negation), and  is an integer.  We assume that constraints
are in Pseudo-Boolean normal form~\cite{Barth95}, that is, the
coefficients  and  are always positive and Boolean
variables occur at most once in .
Pseudo-Boolean constraints are well studied and arise in many
different contexts, for example in verification \cite{Bryant02} and in
operations research \cite{Bixby92}.  Typically we are interested in
the satisfiability of a conjunction of Pseudo-Boolean constraints.
Since 2005 there is a series of Pseudo-Boolean Evaluations
\cite{Manquinho06} 
which aim to assess the state of the art in the field of
Pseudo-Boolean solvers. We adopt these competition problems as a
benchmark for the techniques proposed in this paper.

Pseudo-Boolean constraint satisfaction problems are often reduced to
SAT. 
Many works describe techniques to encode these constraints to
propositional formulas \cite{BailleuxBR06,BailleuxBR09,EenS06}.
The Pseudo-Boolean solver \minisatp\ (\cite{EenS06}, cf.\
\url{http://minisat.se}) chooses between three techniques to
generate SAT encodings for Pseudo-Boolean constraints. These convert
the constraint to: (a) a BDD structure, (b) a network of sorters, and
(c) a network of (binary) adders. The network of adders is the most
concise encoding, but it has the weakest propagation properties and
often leads to higher SAT solving times
than the BDD based encoding, which, on the other hand,
generates the largest encoding. The encoding based on sorting networks
is often the one applied and is the one we consider in this paper.

\begin{wrapfigure}{r}{42mm}\vspace{-10mm}
  \begin{center}\scriptsize  
     
  \end{center}
\vspace{-11mm}
\end{wrapfigure}
To demonstrate how sorters can be used to translate Pseudo-Boolean
constraints, consider the constraint  where the sum of the coefficients is 8. On the right, we
illustrate an  sorter where  are each fed into
a single input,  into two of the inputs, and  into three of
the inputs. The outputs are .  First, we represent the
sorting network as a Boolean formula, , which in general, for
 inputs, will be of size  \cite{Batcher68}. Then, to
assert  we take the conjunction of  with the formula
.

But what happens if the coefficients in a constraint are larger than
in this example?  How should we encode 
?  How should we
handle very large coefficients (larger than 1,000,000)? To this end,
the authors in~\cite{EenS06} generalize the above idea and propose 
to decompose the constraint into a number of interconnected
sorting networks. Each sorter represents a digit in a mixed radix
base.
This construction is governed by the choice of a suitable mixed radix
base and the objective is to find a base which minimizes the size of
the sorting networks. 
Here the optimal base problem comes in, as the size of the
networks is directly related to the size of the representation of the
coefficients. We consider the sum of the digits (of coefficients)
and other measures for the size of the representations
and study their influence on the quality of the encoding.

In \minisatp\ the search for an optimal base is performed using a
brute force algorithm and the resulting base is constructed from prime
numbers up to 17. The starting point for this paper is the following
remark	 from \cite{EenS06} (Footnote 8):
\vspace{-1mm}
\begin{quotation}\noindent
  \emph{This is an ad-hoc solution that should be improved in the
  future. Finding the optimal base is a challenging optimization
  problem in its own right.}
\end{quotation}
In this paper we take the challenge and present an algorithm which
scales to find an optimal base consisting of elements 
with values up to 1,000,000. We illustrate that in many
cases finding a better base leads also to better SAT solving time.

\pagebreak

Section~\ref{section:obp} provides preliminary definitions and
formalizes the optimal base problem.
Section~\ref{sec:encoding} describes how \minisatp decomposes a
Pseudo-Boolean constraint with respect to a given mixed radix base to
generate a corresponding propositional encoding, so that the constraint has
a solution precisely when the encoding has a model.
Section~\ref{section:4} is about (three) alternative measures with
respect to which an optimal base can be found.
Sections~\ref{sec:ob1}--\ref{sec:ob3} introduce our algorithm
based on classic AI search methods (such as cost underapproximation)
in
three steps: Heuristic pruning, best-first branch and bound, and base
abstraction.  
Sections~\ref{sec:exp} and \ref{relwork} present an experimental
evaluation and some related work.  
Section~\ref{sec:conc} concludes. 
Proofs are given in the appendix.




\section{Optimal Base Problems}
\label{section:obp}

In the classic base  radix system, positive integers are
represented as finite sequences of digits
 where for each digit , and
for the most significant digit, .  The integer value associated
with  is .
A mixed radix system is a generalization where a base is an infinite
radix sequence  of integers where for
each radix,  and for each digit, .
The integer value associated with  is 

where  and for , .
The sequence  specifies the
weighted contribution of each  digit position and is called the
\emph{weight sequence of }.  
A finite mixed radix base is a finite sequence
 with the same restrictions as for
the infinite case except that numbers always have  digits
(possibly padded with zeroes) and there is no bound on the value of
the most significant digit, .

In this paper we focus on the representation of finite multisets of
natural numbers in finite mixed radix bases.  Let  denote the
set of finite mixed radix bases and  the set of finite
non-empty multisets of natural numbers. We often view multisets as
ordered (and hence refer to their first element, second element, etc.).
For a finite sequence or multiset  of natural numbers, we denote
its length by , its maximal element by , its 
element by , and the multiplication of its elements by  (if  is the empty sequence then ).
If a base consists of prime numbers only, then we say that it is a
prime base. The set of prime bases is denoted .

Let  with . We denote by  the representation of a natural number  in base
. The most significant digit
 of , denoted , is
.  If  then we say that  is redundant for .
Let  with . We denote the 
matrix of digits of elements from  in base  as
. Namely, the  row in  is the vector
. The most significant digit column of  is the
 column of the matrix and denoted .  If
, then we say that  is redundant
for .
This is equivalently characterized by .

\begin{definition}[non-redundant bases]
\label{def:nrb}
  Let . We denote the set of non-redundant bases for
  , . The set of  
  non-redundant prime bases for  is denoted . 
  \pagebreak
The set of non-redundant (prime) bases for , containing elements
  no larger than , is denoted 
  (). 
The set of bases in //, is
  often viewed as a tree with root  (the empty base) and an
  edge from  to  if and only if  is obtained from  by
  extending it with a single integer value.
\end{definition}


\begin{definition}[]\label{def:sumDigits}
  Let  and .  The sum of the digits of
  the numbers from  in base  is denoted .
\end{definition}


\begin{example}
  The usual binary ``base 2'' and ternary ``base 3'' are represented
  as the infinite sequences  and
  . The finite sequence
   and the empty sequence  are
  also bases. The empty base is often called the ``unary base''
  (every number in this base has a single digit).  
Let .  Then, 
  ,~~
  , ~~
  , ~and
  .
\end{example}

Let . A cost function for  is a function
 which associates bases with real
numbers. An example is .
In this paper we are concerned with the following \emph{optimal base
problem}. 

\begin{definition}[optimal base problem]
  Let  and  a cost function.  We say that
  a base  is an \emph{optimal base for } with respect to
  , if for all bases , .
  The corresponding \emph{optimal base problem} is to find an optimal
  base  for .
\end{definition}




The following two lemmata confirm that for the  cost
function, we may restrict attention to non-redundant bases involving
prime numbers only.

\begin{lemma}
\label{l1}
   Let  and consider the  cost
   function. Then,  has an optimal base in .
\end{lemma}

\begin{lemma}
\label{lem:primes}
   Let  and consider the  cost
   function. Then,  has an optimal base in .
\end{lemma}


How hard is it to solve an instance of the optimal base problem
(namely, for )? The following lemma provides a
polynomial (in ) upper bound on the size of the search
space. This in turn suggests a pseudo-polynomial time brute force
algorithm (to traverse the search space).

\begin{lemma}\label{zeta}
  Let   with . Then,
   where
   and where  is the Riemann
  zeta function.
\end{lemma}

\begin{proof}
  Chor \etal\ prove in \cite{ChorLM00} that the number of ordered
  factorizations of a natural number  is less than . The
  number of bases for all of the numbers in  is hence bounded by
  , which is bounded by .
\end{proof}


\section{Encoding Pseudo-Boolean Constraints}
\label{sec:encoding}

This section presents the construction underlying the sorter based
encoding of Pseudo-Boolean constraints applied in \minisatp
\cite{EenS06}.  It is governed by the choice of a mixed radix base
, the optimal selection of which is the topic of this paper. 
The construction sets up a series of sorting networks to encode the 
\pagebreak
digits, in base , of the sum of the terms on the left side of a 
constraint . The
encoding then compares these digits with those from  from the
right side.
We present the construction, step by step, through an example where
 and . 


\vspace{-2mm}
\paragraph{\textbf{Step one - representation in base:}}~\\
\vspace{-3mm}
\begin{wrapfigure}{r}{30mm}\vspace{-17mm}

\vspace{-13mm}
\end{wrapfigure}
\noindent
The coefficients of  form a multiset 
and their representation in base , a  matrix,
, depicted on the right. The  rows of the matrix
correspond to  the representation of the coefficients
 in base .



\vspace{-2mm}
\paragraph{\textbf{Step two - counting:}}

Representing the coefficients as four digit numbers in base
 and considering the values
 of the digit positions, we obtain a
decomposition for the left side of :

To encode the sums at each digit position (), we set up a
series of four  sorting networks as depicted below.
Given values for the variables, the sorted 
\begin{wrapfigure}{r}{80mm}\vspace{-10mm}
8mm]
~~~~count~1's & ~~~~count~2's & ~~~~count~6's& ~~~~count~18's 
\end{array}
\begin{array}{cccc}
\tiny    \begin{array}{ll|l|l}
      \cline{3-3}
          & ~ &\hspace{4mm} & ~\\
          & ~ &\hspace{4mm} & ~\\
          & ~ &\hspace{4mm} & ~\\
          & ~ & & \\
          & ~ & & \\
      x_5 & ~ & & \\
        \cline{2-2} \cline{4-4}
          & & &\\
      \cline{3-3}
    \end{array}
~~& \tiny    \begin{array}{ll|l|l|l|ll}
      \cline{3-3} \cline{5-5}
      x_1    & ~ &\hspace{4mm} & ~y_6~  &\hspace{2mm}& ~ &y_6 \\
          \cline{2-2} \cline{4-6}   
      x_2    & ~ &\hspace{4mm} & ~y_5 &\hspace{2mm}& ~ & \\
          \cline{2-2} \cline{4-4} 
      x_3    &   &             & ~y_4 &         &   & \\
        \cline{2-2} \cline{4-4}  
      x_4 & ~ & &~y_3 & & & y_3\\
        \cline{2-2} \cline{4-6} 
      x_5 & ~ & &~y_2 & & &r_1\\
        \cline{2-2} \cline{4-4} \cline{6-6}
      x_5 & ~ & &~y_1 & & &r_2\\
        \cline{2-2} \cline{4-4} \cline{6-6}
          & & & & & & \\
      \cline{3-3}  \cline{5-5}
    \end{array}
~~& \tiny \hspace{-14mm}   \begin{array}{ll|l|l}
      \cline{3-3} 
          &\hspace{8mm}  & \hspace{4mm} &  \\
          \cline{2-2} 
           & ~ &\hspace{4mm} &~  \\
            &   &              &   \\
            & ~ & & \\
          \cline{2-2} 
            & ~ & & \\
                  \cline{4-4}
            & ~ & &\\
                  \cline{4-4}
            & & &\\
      \cline{3-3}  
    \end{array}
~~& \tiny    \begin{array}{ll|l|l}
      \cline{3-3} 
          & ~ &\hspace{4mm} & ~\\
& ~ &\hspace{4mm} & ~\\
&   &             &  \\
& ~ & &\\
& ~ & &\\
x_6 & ~ & &\\
        \cline{2-2} \cline{4-4} 
          & & & \\
      \cline{3-3}  
    \end{array}

\
\vspace{-14mm}\end{wrapfigure}
defines two
outputs  and introduces clauses specifying that the
(unary) value of  equals the (unary) value of . 


\paragraph{\textbf{Step four - comparison:}}
The outputs from these four units now specify a number in base ,
each digit represented in unary notation. This number is now compared
(via an encoding of the lexicographic order) to  (the value
from the right-hand side of ).



\section{Measures of Optimality}
\label{section:4}

We now return to the objective of this paper: For a given
Pseudo-Boolean constraint, how can we choose a mixed radix base with
respect to which the encoding of the constraint via sorting networks
will be optimal? We consider here three alternative cost functions
with respect to which an optimal base can be found.  These cost
functions capture with increasing degree of precision the actual size
of the encodings.

The first cost function,  as introduced in
Definition~\ref{def:sumDigits}, provides a coarse measure on the size
of the encoding.  It approximates (from below) the total number of
input bits in the network of sorting networks underlying the
encoding. An advantage in using this cost function is that there always
exists an optimal base which is prime. The disadvantage is that it
ignores the carry bits in the construction, and as such is not always
a precise measure for optimality.
In~\cite{EenS06}, the authors propose to apply a cost function which
considers also the carry bits. This is the second cost function we
consider and we call it  .

\begin{definition}[cost function: ]
\label{cost2}
Let ,  with  and
 the corresponding  matrix of digits.
Denote the sequences  (sums) and 
 (carries) defined by: 
 for , , and 
 for\\
\begin{minipage}[t]{0.5\linewidth}
.
The ``sum of digits with carry''
cost function is defined by the equation on the right.
\end{minipage}\quad
\begin{minipage}[t]{0.5\linewidth}
\vspace{-6mm}

\end{minipage}
\end{definition}


The following example illustrates the  cost function and
that it provides a better measure of base optimality for the (size of
the) encoding of Pseudo-Boolean constraints.

           
\begin{example}\label{runningD}

  Consider the encoding of a Pseudo-Boolean constraint with
  coefficients  with respect to  bases: , , and
  .
Figure~\ref{fig:3cost} depicts the sizes of the sorting networks for
  each of these bases.  The upper tables  illustrate the representation of the coefficients in the
  corresponding bases. 
In the lower tables, the rows labeled ``sum'' indicate the
  number of bits per network and (to their right) their total sum which
  is the  cost.
With respect to the  cost function, all three bases are
  optimal for , with a total of 9 inputs. The algorithm might as
  well return .

  The rows labeled ``carry'' indicate the number of carry bits in each
  of the constructions and (to their right) their totals. With respect
  to the  cost function, bases  and  are optimal
  for , with a total of  bits while  involves 
  bits. The algorithm might as well return .
\end{example}


\begin{figure}\vspace{-6ex}
  \begin{center}\scriptsize  

\end{center}
 \caption{Number of inputs/carries/comparators when encoding
    and three bases ,
   , and  .  }
\label{fig:3cost}
\vspace{-3ex}
\end{figure}

The following example shows that  when
searching for an optimal base with respect to the  cost
function, one must consider also non-prime bases.

\begin{example}
  Consider again the Pseudo Boolean constraint  from Section~\ref{sec:encoding}.
  The encoding with respect to  results in 4
  sorting networks with 10 inputs from the coefficients and 2
  carries. So a total of 12 bits. The encoding with respect to
   is smaller. It has the same 10 inputs from the
  coefficients but no carry bits. Base  is optimal and
  non-prime. 
\end{example}



We consider a third cost function which we call the 
cost function.
Sorting networks are constructed from ``comparators'' \cite{Knuth73}
and in the encoding each comparator is modeled using six CNF clauses.
This function counts the number of comparators in the construction.
Let  denote the number of comparators in an  sorting
network. For small values of ,  takes the values
 and  respectively which correspond to
the sizes of the optimal networks of these sizes \cite{Knuth73}.  For
larger values, the construction uses Batcher's odd-even sorting
networks \cite{Batcher68} for which
.



\begin{definition}[cost function: ]
\label{num_comparators}
Consider the same setting as in Definition~\ref{cost2}.  Then,
\vspace{-7mm}

\end{definition}

\vspace{-5mm}
\begin{example}
  Consider again the setting of Example~\ref{runningD}. 
In Figure~\ref{fig:3cost}  the rows labeled ``comp'' indicate the
  number of  comparators in each of the sorting networks and their
  totals. The construction with the minimal number of comparators is
  that obtained with respect to the base  with 
  10 comparators.
\end{example}


It is interesting to remark the following relationship between the
three cost functions: The  function is the most
``abstract''. It is only based on the representation of numbers in a
mixed radix base.
The  function considers also properties of addition
in mixed-radix bases (resulting in the carry bits).
Finally, the  function considers also implementation
details of the odd-even sorting networks applied in the underlying
\minisatp\ construction.
In Section~\ref{sec:exp} we evaluate how the alternative choices for a
cost function influence the size and quality of the encodings obtained
with respect to corresponding optimal bases.




\section{Optimal Base Search I: Heuristic Pruning}
\label{sec:ob1}

This section introduces a simple, heuristic-based, depth-first, tree
search algorithm to solve the optimal base problem. The search space
is the domain of non-redundant bases as presented in
Definition~\ref{def:nrb}.
The starting point is the brute force algorithm applied in \minisatp.
For a sequence of integers , \minisatp\ applies a depth-first
traversal of  to find the base with the optimal value
for the cost function .

Our first contribution is to introduce a heuristic function and to identify
branches in the search space which can be pruned early on in the
search. Each tree node  encountered during the traversal is
inspected to check if given the best node encountered so far, ,
it is possible to determine that all descendants of  are guaranteed
to be less optimal than . In this case, the subtree rooted at
 may be pruned.
The resulting algorithm improves on the one of \minisatp\ and
provides the basis for the further improvements introduced in
Sections~\ref{sec:ob2} and~\ref{sec:ob3}.
We need first a definition.

\begin{definition}[base extension, partial cost, and admissible heuristic]
  Let , , and  a cost
  function. We say that: 
(1)  extends , denoted , if  is a prefix of
  , 
(2)  is a partial cost function for  if
  , and
(3)  is an admissible heuristic function for  and
   if .
\end{definition}
The intuition is that  signifies a part of the
cost of  which will be a part of the cost of any extension of ,
and that  is an under-approximation on the additional cost of
extending  (in any way) given the partial cost of .
We denote . If
 is a partial cost function and  is an
admissible heuristic function, then  is an
under-approximation of .
The next lemma provides the basis for heuristic pruning using the
three cost functions introduced above.


\begin{lemma}
\label{lem:h}
  The following are
    admissible heuristics for the cases when: 
  \begin{enumerate}
  \item :~~
.
  \item :~~
.

  \item :~~
   .
\end{enumerate}
In the first two settings we take   
. \\
In the case of  we take the  trivial heuristic estimate

\end{lemma}




\begin{figure}[t]
\begin{SProg2}  
  {\scriptsize /*input*/} &multiset S\\
  {\scriptsize /*init*/}  &  base  bestB =  \\
{\scriptsize /*dfs*/} & depth-first traverse \\
                        & at each node , 
                          for the next value  p  B.extenders(S) do\\
             &\qin\qin base newB = B.extend(p)\\
             &\qin\qin if () \textbf{prune}\\
             &\qin\qin  else if () 
                                           bestB = newB \\                  
   {\scriptsize /*output*/} & return bestB;\\
\end{SProg2}
\caption{\texttt{dfsHP}: depth-first search for an
  optimal base with heuristic pruning}
\label{fig:alg1}
\vspace{-3ex}
\end{figure}


The algorithm, which we call \texttt{dfsHP} for depth-first search
with heuristic pruning, is now stated as Figure~\ref{fig:alg1} where
the input to the algorithm is a \texttt{multiset} of integers
\texttt{S} and the output is an optimal base. The algorithm applies a
depth-first traversal of  in search of an optimal base.
We assume given: a cost function , a partial cost function
 and an admissible heuristic . We denote
.
The abstract data type \texttt{base} has two operations:
\texttt{extend(int)} and \texttt{extenders(multiset)}. For a base
\texttt{B} and an integer \texttt{p}, \texttt{B.extend(p)} is the base
obtained by extending \texttt{B} by \texttt{p}. For a multiset
\texttt{S}, \texttt{B.extenders(S)} is the set of integer values
\texttt{p} by which \texttt{B} can be extended to a non-redundant base
for \texttt{S}, i.e., such that .  The definition of this operation may have
additional arguments to indicate if we seek a prime base or one
containing elements no larger than .

Initialization ({\scriptsize /*init*/} in the figure) assigns to the
variable \texttt{bestB} a finite binary base of size
. This variable will always denote the
best base encountered so far (or the initial finite binary base).
Throughout the traversal, when visiting a node \texttt{newB} we first
check if the subtree rooted at \texttt{newB} should be pruned. If this
is not the case, then we check if a better ``best base so far'' has
been found. Once the entire (with pruning) search space has been
considered, the optimal base is in \texttt{bestB}.

To establish a bound on the complexity of the algorithm,  denote
the number of different integers in  by  and .  
The algorithm has space complexity , for the depth first
search on a tree with height bound by  (an element of
 will have at most  elements).
For each base considered during the traversal, we have to calculate
 which incurs a cost of .  To see why, consider that
when extending a base  by a new element giving base , the first
columns of  are the same as those in  (and thus
also the costs incurred by them). Only the cost incurred by the most
significant digit column of  needs to be recomputed for
 due to base extension of  to . 
Performing the
computation for this column, we compute a new digit for the 
different values in .
Finally, by Lemma~\ref{zeta}, there are  bases and
therefore, the total runtime is . Given that ,
we can conclude that runtime is bounded by .



\section{Optimal Base Search II: Branch and Bound}
\label{sec:ob2}

In this section we further improve the search algorithm for an optimal
base. 
The search algorithm is, as before, a traversal of the search space
using the same partial cost and heuristic functions as before to prune
the tree. The difference is that instead of a depth first search, we
maintain a priority queue of nodes for expansion and apply a
best-first, branch and bound search strategy.


Figure~\ref{fig:alg2} illustrates our enhanced search algorithm. We
call it \texttt{B\&B}.
The abstract data type \texttt{priority\_queue} maintains bases
prioritized by the value of . Operations
\texttt{popMin()}, \texttt{push(base)} and \texttt{peek()} (peeks at
the minimal entry) are the usual. The reason to box the text
``\texttt{priority\_queue}'' in the figure will become apparent in
the next section.



\begin{figure}[t]
  \begin{SProg}
  base findBase(multiset S)\\
  {\scriptsize /*1*/} \qin base  bestB = ; 
                           \fbox{priority\_queue} Q = ;\\
  {\scriptsize /*2*/} \qin while ( \mbox{\&\&} 
        ) \\
  {\scriptsize /*3*/} \qin\qin  base B = Q.popMin();\\
  {\scriptsize /*4*/} \qin\qin  foreach (p  B.extenders(S)) \\
  {\scriptsize /*5*/} \qin\qin\qin base newB = B.extend(p);\\
  {\scriptsize /*6*/} \qin\qin\qin  if () \\
  {\scriptsize /*7*/} \qin\qin\qin\qin  \{ Q.push(newB); 			
        if () bestB =
        newB; \}\\ 
  {\scriptsize /*8*/} \qin return bestB;\\
\end{SProg}
\caption{Algorithm \texttt{B\&B}: best-first, branch and bound}
\label{fig:alg2}
\vspace{-3ex}
\end{figure}


On line {\scriptsize /*1*/} in the figure, we initialize the variable
\texttt{bestB} to a finite binary base of size
 (same as in Figure~\ref{fig:alg1})
and initialize the queue to contain the
root of the search space (the empty base).
As long as there are still nodes to be expanded in the queue that are
potentially interesting (line {\scriptsize /*2*/}), we select (at line
{\scriptsize /*3*/}) the best candidate base \texttt{B} from the
frontier of the tree in construction for further expansion.  Now the
search tree is expanded for each of the relevant integers (calculated
at line {\scriptsize /*4*/}). For each child \texttt{newB} of
\texttt{B} (line {\scriptsize /*5*/}), we check if pruning at
\texttt{newB} should occur (line {\scriptsize /*6*/}) and if not we
check if a better bound has been found (line {\scriptsize /*7*/})
Finally, when the loop terminates, we have found the optimal base and
return it (line {\scriptsize /*8*/}).










\section{Optimal Base Search III: Search Modulo Product}
\label{sec:ob3}

This section introduces an abstraction on the search space,
classifying bases according to their product. Instead of maintaining
(during the search) a priority queue of all bases
(nodes) that still need to be explored, we maintain a special priority
queue in which there will only ever be at most one base with the same
product.  So, the queue will never contain two
different
bases  and 
such that .
In case a second base, with the same product as one already in, is
inserted to the queue, then
only
the base with the minimal value of
 is maintained on the queue. We call this type of
priority queue a \emph{hashed priority queue} because it
can conveniently be
implemented as a hash table.

The intuition comes from a study of the  cost function for
which we can prove the following \textbf{Property 1} on bases:
Consider two bases  and  such that 
and such that . Then for
any extension of  and of  by the same sequence ,
.  In particular, if one of  or
 can be extended to an optimal base, then  can.
A direct implication is that when maintaining the frontier of the
search space as a priority queue, we only need one representative of
the class of bases which have the same product (the one with the
minimal value of ).

A second \textbf{Property 2} is more subtle and true for any cost
function that has the first property: Assume that in the algorithm
described as Figure~\ref{fig:alg2} we at some stage remove a base
 from the priority queue. This implies that if in the future we
encounter any base  such that , then we
can be sure that  and immediately
prune the search tree from .

Our third and final algorithm, which we call \texttt{hashB\&B}
(best-first, branch and bound, with hash priority queue) is identical
to the algorithm presented in Figure~\ref{fig:alg2}, except that the
the boxed priority queue introduced at line {\scriptsize /*1*/} is
replaced by a \begin{tt}\fbox{hash\_priority\_queue}\end{tt}.

The abstract data type \texttt{hash\_priority\_queue} maintains bases
prioritized by the value of . Operations
\texttt{popMin()} and \texttt{peek()} are as usual. Operation
\texttt{push()} works as follows: (a) if there is no base 
in the queue such that , then add .
Otherwise, (b) if  then
do not add . Otherwise, (c) remove  from the queue and add
.


\begin{theorem}\label{algIsGood}~\\
\noindent(1) The  cost function satisfies \textbf{Property 1}; and
(2)
the \texttt{hashB\&B} algorithm finds an optimal base for any cost
function which satisfies \textbf{Property~1}.
\end{theorem}

We conjecture that the other cost functions do not satisfy
\textbf{Property 1}, and hence cannot guarantee that the
\texttt{hashB\&B} algorithm always finds an optimal base.
However, in our extensive experimentation, all bases found
(when searching for an optimal prime base) are indeed optimal.





A direct implication of the above improvements is that we can now
provide a tighter bound on the complexity of the search algorithm.
Let us denote the number of different integers in  by  and
.
First note that in the worst case the hashed priority queue will
contain  elements (one for each possible value of a base product,
which is never more than ).  
Assuming that we use a Fibonacci Heap, we have a  cost
(amortized) per \texttt{popMin()} operation and in total a  cost for popping elements off the queue during the search
for an optimal base.

Now focus on the cost of operations performed when extracting a
base  from the queue. Denoting
,
 has at most 
children (integers which extend it). 
For each child we have to calculate  which incurs a cost of
 
and possibly to insert it to the queue.
Pushing an element onto a hashed priority queue (in all three cases)
is a constant time operation (amortized), and hence the total cost for
dealing with a child is .

Finally, consider the total number of children created during
the search which corresponds to the following sum:
\vspace{-2mm}
 
So, in total we get . 
When we restrict the extenders to be prime numbers then we can further
improve this bound to  by reasoning about the
density of the primes. 
A proof can be found in the appendix.
\section{Experiments}
\label{sec:exp}


Experiments are performed using an extension to \minisatp\
\cite{EenS06} where the only change to the tool is to plug in our
optimal base algorithm.
The reader is invited to experiment with the implementation via its
web interface.\footnote{
  \url{http://aprove.informatik.rwth-aachen.de/forms/unified_form_PBB.asp}}
All experiments are performed on a Quad-Opteron 848 at 2.2 GHz, 16 GB
RAM, running Linux.

Our benchmark suite originates from 1945 Pseudo-Boolean Evaluation
\cite{Manquinho06}
instances from the years 2006--2009 containing a total of 
74,442,661 individual Pseudo-Boolean constraints. After 
normalizing and removing constraints with  coefficients we
are left with 115,891 different optimal base problems where the
maximal coefficient is .
We then focus on 734
PB instances where at least one optimal base
problem from the instance yields a base with an element that is
non-prime or greater than 17.
When solving PB instances, in all experiments, a 30 minute timeout is
imposed as in the Pseudo-Boolean competitions. When solving an optimal
base problem, a 10 minute timeout is applied.


\paragraph{Experiment 1 (Impact of optimal bases):}

The first experiment illustrates the advantage in searching for an
optimal base for Pseudo-Boolean solving. We compare sizes and
solving times when encoding w.r.t. the binary base vs.\ w.r.t. an optimal base
(using the \texttt{hashB\&B} algorithm with the  cost
function).
Encoding w.r.t. the binary base, we solve 435 PB instances (within the
time limit) with an average time of 146 seconds and average CNF size
of 1.2 million clauses.
Using an optimal base, we solve 445 instances with an average time of
108 seconds, and average CNF size of 0.8 million clauses.



\paragraph{Experiment 2 (Base search time):}

Here we focus on the search time for an optimal base in six
configurations using the  cost function.
Configurations \texttt{M17}, \texttt{dfsHP17}, and \texttt{B\&B17},
are respectively, the \minisatp\ implementation, our \texttt{dfsHP}
and our \texttt{B\&B} algorithms, all three searching for an optimal
base from , i.e., with prime elements up to 17.
Configurations \texttt{hashB\&B1,000,000}, \texttt{hashB\&B10,000},
and \texttt{hashB\&B17} are our \texttt{hashB\&B} algorithm 
searching for a base from  with bounds of
 1,000,000,  10,000, and  17, respectively.

Results are summarized in Fig.~\ref{fig:results1} which is obtained
as follows. We cluster the optimal base problems according to the
values  where  is the maximal
coefficient in a problem. Then, for each cluster we take the average
runtime for the problems in the cluster. The value  is chosen
to minimize the standard deviation from the averages (over all
clusters). These are the points on the graphs.
Configuration \texttt{M17} times out on 28
problems.  For \texttt{dfsHP17}, the maximal search time is 200
seconds.  Configuration \texttt{B\&B17} times out for 1 problem.  The
\texttt{hashB\&B} configurations have maximal runtimes of 350 seconds,
14 seconds and 0.16 seconds, respectively for the bounds 1,000,000,
10,000 and 17.
\begin{figure}
  \centering
  \vspace{-3ex}
  \includegraphics[scale=0.152]{searceTimeAsFunctionOfMAxCoaf-SlowAlgs.pdf}
  \includegraphics[scale=0.152]{searceTimeAsFunctionOfMAxCoaf-FastAlgs.pdf}
  \vspace{-3ex}
\caption{Experiment 2: the 3 slowest configurations (left)
    (from back to front)
    \texttt{M17}(blue), \texttt{hashB\&B1,000,000}(orange) and
    \texttt{dfsHP17}(yellow).  
The 4 fastest configurations (right) (from back to front)
    \texttt{dfsHP17}(yellow), \texttt{B\&B17}(green),
    \texttt{hashB\&B10,000}(brown) and \texttt{hashB\&B17}(azure).
Note the change of scale for the -axis with 50k ms on the left
    and 8k ms on the right. Configuration \texttt{dfsHP17} (yellow) is
    lowest on left and highest on right, setting the reference point
    to compare the two graphs. \vspace{-5mm}}

\label{fig:results1}
\vspace{-1ex}
\end{figure}


Fig.~\ref{fig:results1} shows  that: (left)  even with primes
up to 1,000,000, \texttt{hashB\&B} is faster than the algorithm from
\minisatp\ with the limit of 17; and
(right)  even with primes
up to 10,000, the search time using \texttt{hashB\&B} is essentially
negligible.







\paragraph{Experiment 3 (Impact on PB solving):}
Fig.~\ref{fig:results2} illustrates the influence of improved base
search on SAT solving for PB Constraints. Both graphs
depict the number of instances solved (the -axis) within a
time limit (the -axis). On the left, total solving time
(with base search), and on the right, SAT solving time only.

\begin{figure}
  \centering
  \vspace{-5ex}
  \includegraphics[scale=0.063]{intrestingInstancesTotalTimeGraph.pdf}
  \includegraphics[scale=0.063]{intrestingInstancesSolveTimeGraph.pdf}
\vspace{-3ex}
  \caption{Experiment 3: total times (left), solving times (right) }
 \vspace{-5ex}
\label{fig:results2}
\end{figure}
\noindent Both graphs consider the  instances of interest and compare
SAT solving times with bases found using five configurations.  The first is \minisatp with
configuration \texttt{M17}, the second is with respect to the binary
base, the third to fifth are \texttt{hashB\&B}
searching for bases from 
with cost functions: , , and
, respectively.
The average total/solve run-times (in sec) are 150/140, 146/146,
122/121, 116/115 and 108/107 (left to right). The total number of
instances solved are 431, 435, 442, 442 and 445 (left to right).  
The average CNF sizes (in millions of clauses) for the entire
test set/the set where all algorithms solved/the set where
no algorithm solved are 7.7/1.0/18,
9.5/1.2/23, 8.4/1.1/20, 7.2/0.8/17
and 7.2/0.8/17 (left to right).  

The graphs of Fig.~\ref{fig:results2} and average solving times
clearly show: \textbf{(1)} SAT solving time dominates base
finding time, \textbf{(2)} \minisatp\ is outperformed by the trivial
binary base,  \textbf{(3)}
total solving times with our algorithms are faster than with the binary
base, and \textbf{(4)} the most specific
cost function (comparator cost) outperforms the other cost functions
both in solving time and size.  Finally, note that sum of
digits with its nice mathematical properties, simplicity, and
application independence solves as many instances as cost carry.




\paragraph{Experiment 4 (Impact of high prime factors):}

\begin{wrapfigure}{r}{73mm}\vspace{0mm}
  \includegraphics[scale=0.16]{generated31-size-cactus.pdf}
  \vspace{-4ex}
  \caption{\small
Experiment 4:  Number (-axis) of instances encoded within
    number of clauses (-axis) on 4 configurations. From top line
    to bottom: (yellow) , , (red) , ,
    (green) , , and (blue) , .}
\label{fig:resultsGenCactus}
\vspace{-4ex}
\end{wrapfigure}
This experiment is about the effects of restricting the maximal prime
value in a base (i.e. the value  of \minisatp).
An analysis of the our benchmark suite indicates that coefficients
with small prime factors are overrepresented.
To introduce instances where coefficients have larger prime factors we
select 43 instances from the suite and multiply their coefficients to
introduce the prime factor 31 raised to the power . We also introduce a slack
variable 
to avoid gcd-based simplification.
This gives us a collection of 258 new instances.
We used the \texttt{B\&B} algorithm
with the  cost function applying the limit  (as in
\minisatp) and .
Results indicate that for , both CNF size
and
SAT-solving time are independent of the factor  introduced for
. However, for , both measures increase as the power
 increases. Results on CNF sizes are reported in Fig.\
\ref{fig:resultsGenCactus} which plots for 4 different settings the
number of instances encoded (-axis) within a CNF with that many
clauses (-axis). 
















\section{Related Work}\label{relwork}

Recent work \cite{BailleuxBR09} encodes Pseudo-Boolean constraints via
``totalizers'' similar to sorting networks, determined by the
representation of the coefficients in an underlying base.  Here the
authors choose the standard base 2 representation of numbers. It is
straightforward to generalize their approach for an arbitrary mixed
base, and our algorithm is directly applicable.
In~\cite{Sidorov99} the author considers the  cost
function and analyzes the size of representing the natural numbers up
to  with (a particular class of) mixed radix bases.  
Our Lemma~\ref{lem:primes} may lead to a contribution in that context.




\section{Conclusion}
\label{sec:conc}

It has been recognized now for some years that decomposing the
coefficients in a Pseudo-Boolean constraint with respect to a mixed
radix base can lead to smaller SAT encodings. However, it remained an
open problem to determine if it is feasible to find such an optimal
base for constraints with large coefficients. In lack of a better
solution, the implementation in the \minisatp\ tool applies a brute
force search considering prime base elements less than 17.



To close this open problem, we first formalize the optimal base
problem and then significantly improve the search algorithm currently
applied in \minisatp.
Our algorithm scales and easily finds optimal bases
with elements up to 1,000,000.
We also illustrate that, for the
measure of optimality applied in \minisatp, one must consider also
non-prime base elements. However, choosing the more simple
 measure, it is sufficient to restrict the search to prime
bases.

With the implementation of our search algorithm it is possible, for
the first time, to study the influence of basing SAT encodings on
optimal bases.  We show that for a wide range of benchmarks,
\minisatp\ does actually find an optimal base consisting of elements
less than 17.  We also show that many Pseudo-Boolean instances have
optimal bases with larger elements and that this does influence the
subsequent CNF sizes and SAT solving times, especially when
coefficients contain larger prime factors.



\vspace{-2ex}

\subsubsection*{Acknowledgement}
We thank Daniel Berend and Carmel Domshlak for useful discussions.

\vspace{-2ex}



\newcommand{\noopsort}[1]{}
\begin{thebibliography}{10}

\bibitem{BailleuxBR06}
O.\ Bailleux, Y.\ Boufkhad, and O.\ Roussel.
\newblock A translation of pseudo boolean constraints to {SAT}.
\newblock {\em Journal on Satisfiability, Boolean Modeling and Computation
  (JSAT)}, 2(1-4):191--200, 2006.

\bibitem{BailleuxBR09}
O.\ Bailleux, Y.\ Boufkhad, and O.\ Roussel.
\newblock New encodings of pseudo-boolean constraints into {CNF}.
\newblock In {\em Proc.\ Theory and Applications of Satisfiability Testing (SAT
  '09)}, pages 181--194, 2009.

\bibitem{Barth95}
P.\ Barth.
\newblock {\em Logic-based 0-1 constraint programming}.
\newblock Kluwer Academic Publishers, Norwell, MA, USA, 1996.

\bibitem{Batcher68}
K.~E. Batcher.
\newblock Sorting networks and their applications.
\newblock In {\em AFIPS Spring Joint Computing Conference}, volume~32 of {\em
  AFIPS Conference Proceedings}, pages 307--314. Thomson Book Company,
  Washington D.C., 1968.

\bibitem{Bixby92}
R.~E. Bixby, E.~A. Boyd, and R.~R. Indovina.
\newblock {MIPLIB}: {A} test set of mixed integer programming problems.
\newblock {\em SIAM News}, 25:16, 1992.

\bibitem{Bryant02}
R.~E. Bryant, S.~K. Lahiri, and S.~A. Seshia.
\newblock Deciding {CLU} logic formulas via boolean and pseudo-boolean
  encodings.
\newblock In {\em Proc.\ Intl.\ Workshop on Constraints in Formal Verification
  (CFV '02)}, 2002.

\bibitem{ChorLM00}
B.\ Chor, P.\ Lemke, and Z.\ Mador.
\newblock On the number of ordered factorizations of natural numbers.
\newblock {\em Discrete Mathematics}, 214(1-3):123--133, 2000.



\bibitem{EenS06}
N.\ E\'en and N.\ S\"orensson.
\newblock Translating pseudo-boolean constraints into {SAT}.
\newblock {\em Journal on Satisfiability, Boolean Modeling and Computation
  (JSAT)}, 2(1-4):1--26, 2006.

\bibitem{Knuth73}
D.\ Knuth.
\newblock {\em The Art of Computer Programming, Volume III: Sorting and
  Searching}.
\newblock Addison-Wesley, 1973.

\bibitem{Manquinho06}
V.~M.\ Manquinho and O.\ Roussel.
\newblock The first evaluation of {P}seudo-{B}oolean solvers {(PB'05)}.
\newblock {\em Journal on Satisfiability, Boolean Modeling and Computation
  (JSAT)}, 2(1-4):103--143, 2006.

\bibitem{Sidorov99}
N.~Sidorov.
\newblock Sum-of-digits function for certain nonstationary bases.
\newblock {\em Journal of Mathematical Sciences}, 96(5):3609--3615, 1999.

\end{thebibliography}




\appendix

\section{Appendix: Proofs}\label{apdx}

\newcommand{\apdxtheoremlike}[1]{\par\medskip\penalty-250{\bfseries\scshape\noindent#1}\slshape}

\subsection{Proving Lemma~\ref{l1}}

\noindent\apdxtheoremlike{Lemma~\ref{l1}.}
Let  and consider the  cost
function. Then,  has an optimal base in .


\begin{proof}
  Let  and let  be an optimal base for
   with . Let  be the base obtained by
  removing the last element from .  We show that  and that . The claim then follows.
Assume falsely that for ,\linebreak .
  Then we get the contradiction .
  From the definition of  and the above
  contradiction we deduce that .
\end{proof}

It is straightforward to generalize Lemma~\ref{l1} for the other cost
functions considered in this paper. 

\subsection{Proving Lemma~\ref{lem:primes}} 

\begin{proposition}[Unique base representation] \label{pNib} Let  be a base with
   and let .  
  Then, the unique representation of  in  is obtained as
   such that:
(1) ,             
(2)  \ for , and
(3) .
\end{proposition}

\begin{proof}(sketch)
  We have to show that for ,  and that 
  . The first property follows directly
  from the construction. The second is elaborated on below.
\end{proof}



\begin{proposition}[Base factoring]
\label{pPrimesOnly}
Let  and let  and
 be bases which are identical
except that at some position , two consecutive base
elements in  are replaced in  by their
multiplication. Formally:
 for , 
 , and
  for .
Then, the sum of the digits in  is greater or equal to the
sum of the digits in .
\end{proposition}

\begin{proof}(sketch)
   We first observe that 
	  for    and 
         for .
   So, it remains to show that 
	.
   We elaborate on this below.
\end{proof}



\noindent\apdxtheoremlike{Lemma~\ref{lem:primes}.}
Let  and consider the  cost
   function. Then,  has an optimal base in .


\begin{proof}
  Let  be a base with  elements of the form

  where the element  at position 
  is non-prime and .
So, taking , we are in the  setting of
  Proposition~\ref{pPrimesOnly}.
The result follows:
  
\end{proof}




\subsection{Proving Lemma~\ref{lem:h}}
Consider the
notation of Definition~\ref{cost2}.  Let ,
 with  and .
Denote the sequences 
(sums) and  (carries)
defined by:
 for , , and 
 for .
We denote also .


\begin{proposition}
\label{pSubBase1} 
Let  and , bases such that .
Then, for , .
\end{proposition}


\begin{proposition}
\label{pSubBase2}
Let , and  a base.  Then for every  such that  there exists  such that .
\end{proposition}

\begin{proposition}
\label{lHC}
Let  be any monotonically increasing
function such that for , .
Let . Then  given by:
\begin{enumerate}
\item 

\item 
.
\item 
.
\end{enumerate}
	is a heuristic cost function.
\end{proposition}





\begin{proof} 
  Let  and  be as defined above and ,  bases such that
  , , and .  For every base  we can
  see that  (the size of a finite set is a natural
  number).  Therefore it is sufficient to prove that .  From
  Proposition~\ref{pSubBase1} we get that
  .  From the definition of 
  and of  we see that
  
For , denote .  \\
  Let . By Proposition \ref{pSubBase2} there exists  such that  and therefore .  This implies that
  
 In total we have  

The proof that  is similar noting that .
\end{proof}


\begin{proof}(of Lemma~\ref{lem:h})\\
  If , then .  By Proposition~\ref{lHC} both
  definitions give a heuristic cost function. 
  The proof for the case of  and  
   is of the same structure as Proposition~\ref{lHC}. The case of  is the most complicated one.
\end{proof}

\subsection{Proving Theorem~\ref{algIsGood}}

\begin{definition}(\textbf{Property 1})
\label{dBME}
A heuristic cost function  is
called \emph{base mul equivalent} if for every  and
for every bases ,  such that  and
 the following holds:
\begin{enumerate}
   \item for any extension of  and of  by same base ,
          .
\end{enumerate}
\end{definition} 

In the following propositions we refer to the \texttt{hashB\&B}
search algorithm of Section~\ref{sec:ob3}.


\begin{proposition}
\label{pBestRep}
Let  and let 
be a base mul equivalent heuristic cost function.  For every base
 extracted from the queue and for every base  such that
 then .
\end{proposition}

\begin{proof}
Let . By complete induction on .

\paragraph{\bf Base:} 

For  we have only the empty base and the claim is trivially true.

\paragraph{\bf Step:}  

Assume that the claim is true for every  and assume that during
the run of the algorithm we extract a base  from the queue with
. Assume falsely that there exists a base  such that
 and .This
means that  was not evaluated yet (otherwise ).
Therefore the father of  (in the tree of bases) was never
extracted from the queue.  Let  be the closest ancestor of 
that was extracted. Denote by  the child of  which is also
the ancestor of  (potentially  itself). So,  was
evaluated.  Observe that  and  are unique because the search
space (of bases) is a tree and . So,
 and that is a contradiction to the existence of
.  \bigskip

\noindent This proves that \textbf{Property 1} derives
\textbf{Property 2}.
\end{proof} 

\begin{proposition}
\label{pBaseExtenstion}
Let  and , bases such that .
Then, for , .
\end{proposition}


\noindent\apdxtheoremlike{Theorem~\ref{algIsGood}.}\\
\noindent(1) The  cost function satisfies \textbf{Property 1}; and
(2)
the \texttt{hashB\&B} algorithm finds an optimal base for any cost
function which satisfies \textbf{Property~1}.



\begin{proof}~\\
  1) Let ,  and . We prove that if  then for any base extension , .  The proof is by complete induction on
  .

\paragraph{\bf Base:} 

For , first notice that . This follows
directly from the definition of admissible heuristics (for the
 case). Hence, .
From Propositions~\ref{pNib} and~\ref{pBaseExtenstion}, we have that
{\small
}

\paragraph{\bf Step:}  
For , we define . So
by
the complete
induction assumption for  we get that .  By the fact that  we
can deduce that . 
By the definition of  admissible heuristics for  :

Therefore, .  Combining it with the fact that  we
have that . Finally
from the inductive assumption we get that .

\medskip
2) Let  a base mul equivalent
heuristic cost function and .  We denote by 
the best base found by the algorithm at each point of the run.  Let
 be the first base extracted from the queue such that
.  This is the condition that
terminates the main loop of the algorithm, so we need to prove that
 is the optimal base for .
Assume falsely that there exists an optimal base  such
 that .  Let  be the nearest ancestor
 of  such that the its base equivalence class representative 
 was extracted from queue ( otherwise ).  By Proposition~\ref{pBestRep} we know that
  and by \textbf{Property 1} that
 for any base C .  In particular for the
 case where .  By choice of  we get that
 the equivalence class representative of  was not
 extracted (and it is the same class of ).  Therefore,
 , which is a
 contradiction.
\end{proof}







\subsection{On the complexity of the \texttt{hashB\&B} algorithm
  for prime bases}

\begin{theorem}
  Let   with  . Then,
  the complexity of the \texttt{hashB\&B} algorithm for prime bases
  is .
\end{theorem}

\begin{proof}
  We use the prime number theorem which states that the density of the
  primes near  is .
  The number of prime bases evaluated in the worst case scenario is: 
  
  But 
  
And so the total number of bases evaluated during a run of the
algorithm is bounded by  and the overall
complexity is .
\end{proof}\bigskip


\subsection{Integer division and modulus}
\noindent
Let  with . It is standard to define
 and  as natural numbers such that  and . In our proofs we note
that  is the maximal number such that there exists  with .






\begin{proposition}
\label{pDiv} 
Let   with . Then .
\end{proposition}

 \begin{proof}
   By definition if ,  and
   . Then, , 
   and . Now,  because
   otherwise it would be a contradiction to the maximality of .  If
    then .  Assume that . Then  and from that we
   deduce  (otherwise it would be a contradiction to the
   maximality of ).  On the other hand,   . 
From the definition of modulus
we get that  and so , and therefore .  In total we get that  and because  and  are natural numbers we get the
   equality.
 \end{proof}\bigskip


\begin{proposition} 
  \label{pDivMod}
  Let  such that . Then, .
\end{proposition}

\begin{proof}
  Let , , , and
  . By definition we can see that , , and . Therefore
   
              
  and this is true by Proposition \ref{pDiv}.
\end{proof}\bigskip

\subsection{The rest of the details}
\noindent
For the sake of readability, we write .

\begin{proof}(of Proposition \ref{pNib} by induction on ). 
  \paragraph{Base (length is 1):}  and hence ,  and by
  definition of div and mod we can see
  that  .
  \paragraph{Step:} Assume the assumption is true for every base 
  such that .  Let  such that . Define the base
   with .
We can see
  that for , , and that for ,
  .  From this we can see that for ,  and also that
  .
  Back to the main claim by the induction we know that
  .
  Therefore . \\
  By Proposition \ref{pDivMod} we can see that .
  And therefore we get that .
\end{proof} \bigskip

\begin{proof}(of Proposition \ref{pSubBase1})\\
  First we notice that because  then for  we
  get that  and therefore . By
  Proposition~\ref{pNib} we see that .  By
  definition of  and by Proposition~\ref{pNib} and
  the definition of  we prove this proposition by induction on \ .
	\begin{enumerate}
		\item 
			Base case: 
		\item 
			Step: Assume that .\\
			\\
			
	\end{enumerate}
\end{proof} \bigskip

\begin{proof}(of Proposition \ref{pSubBase2})\\
	Let  and  be as defined above. 
	Let  such that . 
	If there exists an  such that  then 
	we get that \  \ and in any case ( or ) \ \  .
	Otherwise let  be the maximal index such that .
	If  then . Consider the case when 
	Then  such that \    
	and so by dividing both sides by  we get that ,
	which means that   .
\end{proof} \bigskip

 \begin{proof}(of Proposition \ref{pPrimesOnly})
	 \\The following proof is deeply based on the definition of  and Proposition \ref{pNib}.\\
	Let ,  and  be as defined above.
	\begin{enumerate}
		\item 
			For   by definition  
			which means that  and therefore . 
			For   again we get that  
			and   which again means that ). 
		\item 
  			We can see that .  By Proposition \ref{pNib} we know that \\
			\\
			\\
			\\
			Therefore \   \\
			 Because  we deduce that \  \\
			And in total we get that  \\
				
	\end{enumerate}
\end{proof} \bigskip 

\begin{proof}(of Proposition \ref{pBaseExtenstion})\\
Let  and , bases such that .
Let  (, otherwise there is no such index).
For  by Proposition~\ref{pNib} we get that
 .
If  then by Proposition~\ref{pNib} and definition of  we can deduce .
\end{proof}

\end{document}
