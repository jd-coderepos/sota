\documentclass{article} \usepackage{iclr2019_conference,times}



\usepackage{amsmath,amsfonts,bm}

\newcommand{\figleft}{{\em (Left)}}
\newcommand{\figcenter}{{\em (Center)}}
\newcommand{\figright}{{\em (Right)}}
\newcommand{\figtop}{{\em (Top)}}
\newcommand{\figbottom}{{\em (Bottom)}}
\newcommand{\captiona}{{\em (a)}}
\newcommand{\captionb}{{\em (b)}}
\newcommand{\captionc}{{\em (c)}}
\newcommand{\captiond}{{\em (d)}}

\newcommand{\newterm}[1]{{\bf #1}}


\def\figref#1{figure~\ref{#1}}
\def\Figref#1{Figure~\ref{#1}}
\def\twofigref#1#2{figures \ref{#1} and \ref{#2}}
\def\quadfigref#1#2#3#4{figures \ref{#1}, \ref{#2}, \ref{#3} and \ref{#4}}
\def\secref#1{section~\ref{#1}}
\def\Secref#1{Section~\ref{#1}}
\def\twosecrefs#1#2{sections \ref{#1} and \ref{#2}}
\def\secrefs#1#2#3{sections \ref{#1}, \ref{#2} and \ref{#3}}
\def\eqref#1{equation~\ref{#1}}
\def\Eqref#1{Equation~\ref{#1}}
\def\plaineqref#1{\ref{#1}}
\def\chapref#1{chapter~\ref{#1}}
\def\Chapref#1{Chapter~\ref{#1}}
\def\rangechapref#1#2{chapters\ref{#1}--\ref{#2}}
\def\algref#1{algorithm~\ref{#1}}
\def\Algref#1{Algorithm~\ref{#1}}
\def\twoalgref#1#2{algorithms \ref{#1} and \ref{#2}}
\def\Twoalgref#1#2{Algorithms \ref{#1} and \ref{#2}}
\def\partref#1{part~\ref{#1}}
\def\Partref#1{Part~\ref{#1}}
\def\twopartref#1#2{parts \ref{#1} and \ref{#2}}

\def\ceil#1{\lceil #1 \rceil}
\def\floor#1{\lfloor #1 \rfloor}
\def\1{\bm{1}}
\newcommand{\train}{\mathcal{D}}
\newcommand{\valid}{\mathcal{D_{\mathrm{valid}}}}
\newcommand{\test}{\mathcal{D_{\mathrm{test}}}}

\def\eps{{\epsilon}}


\def\reta{{\textnormal{$\eta$}}}
\def\ra{{\textnormal{a}}}
\def\rb{{\textnormal{b}}}
\def\rc{{\textnormal{c}}}
\def\rd{{\textnormal{d}}}
\def\re{{\textnormal{e}}}
\def\rf{{\textnormal{f}}}
\def\rg{{\textnormal{g}}}
\def\rh{{\textnormal{h}}}
\def\ri{{\textnormal{i}}}
\def\rj{{\textnormal{j}}}
\def\rk{{\textnormal{k}}}
\def\rl{{\textnormal{l}}}
\def\rn{{\textnormal{n}}}
\def\ro{{\textnormal{o}}}
\def\rp{{\textnormal{p}}}
\def\rq{{\textnormal{q}}}
\def\rr{{\textnormal{r}}}
\def\rs{{\textnormal{s}}}
\def\rt{{\textnormal{t}}}
\def\ru{{\textnormal{u}}}
\def\rv{{\textnormal{v}}}
\def\rw{{\textnormal{w}}}
\def\rx{{\textnormal{x}}}
\def\ry{{\textnormal{y}}}
\def\rz{{\textnormal{z}}}

\def\rvepsilon{{\mathbf{\epsilon}}}
\def\rvtheta{{\mathbf{\theta}}}
\def\rva{{\mathbf{a}}}
\def\rvb{{\mathbf{b}}}
\def\rvc{{\mathbf{c}}}
\def\rvd{{\mathbf{d}}}
\def\rve{{\mathbf{e}}}
\def\rvf{{\mathbf{f}}}
\def\rvg{{\mathbf{g}}}
\def\rvh{{\mathbf{h}}}
\def\rvu{{\mathbf{i}}}
\def\rvj{{\mathbf{j}}}
\def\rvk{{\mathbf{k}}}
\def\rvl{{\mathbf{l}}}
\def\rvm{{\mathbf{m}}}
\def\rvn{{\mathbf{n}}}
\def\rvo{{\mathbf{o}}}
\def\rvp{{\mathbf{p}}}
\def\rvq{{\mathbf{q}}}
\def\rvr{{\mathbf{r}}}
\def\rvs{{\mathbf{s}}}
\def\rvt{{\mathbf{t}}}
\def\rvu{{\mathbf{u}}}
\def\rvv{{\mathbf{v}}}
\def\rvw{{\mathbf{w}}}
\def\rvx{{\mathbf{x}}}
\def\rvy{{\mathbf{y}}}
\def\rvz{{\mathbf{z}}}

\def\erva{{\textnormal{a}}}
\def\ervb{{\textnormal{b}}}
\def\ervc{{\textnormal{c}}}
\def\ervd{{\textnormal{d}}}
\def\erve{{\textnormal{e}}}
\def\ervf{{\textnormal{f}}}
\def\ervg{{\textnormal{g}}}
\def\ervh{{\textnormal{h}}}
\def\ervi{{\textnormal{i}}}
\def\ervj{{\textnormal{j}}}
\def\ervk{{\textnormal{k}}}
\def\ervl{{\textnormal{l}}}
\def\ervm{{\textnormal{m}}}
\def\ervn{{\textnormal{n}}}
\def\ervo{{\textnormal{o}}}
\def\ervp{{\textnormal{p}}}
\def\ervq{{\textnormal{q}}}
\def\ervr{{\textnormal{r}}}
\def\ervs{{\textnormal{s}}}
\def\ervt{{\textnormal{t}}}
\def\ervu{{\textnormal{u}}}
\def\ervv{{\textnormal{v}}}
\def\ervw{{\textnormal{w}}}
\def\ervx{{\textnormal{x}}}
\def\ervy{{\textnormal{y}}}
\def\ervz{{\textnormal{z}}}

\def\rmA{{\mathbf{A}}}
\def\rmB{{\mathbf{B}}}
\def\rmC{{\mathbf{C}}}
\def\rmD{{\mathbf{D}}}
\def\rmE{{\mathbf{E}}}
\def\rmF{{\mathbf{F}}}
\def\rmG{{\mathbf{G}}}
\def\rmH{{\mathbf{H}}}
\def\rmI{{\mathbf{I}}}
\def\rmJ{{\mathbf{J}}}
\def\rmK{{\mathbf{K}}}
\def\rmL{{\mathbf{L}}}
\def\rmM{{\mathbf{M}}}
\def\rmN{{\mathbf{N}}}
\def\rmO{{\mathbf{O}}}
\def\rmP{{\mathbf{P}}}
\def\rmQ{{\mathbf{Q}}}
\def\rmR{{\mathbf{R}}}
\def\rmS{{\mathbf{S}}}
\def\rmT{{\mathbf{T}}}
\def\rmU{{\mathbf{U}}}
\def\rmV{{\mathbf{V}}}
\def\rmW{{\mathbf{W}}}
\def\rmX{{\mathbf{X}}}
\def\rmY{{\mathbf{Y}}}
\def\rmZ{{\mathbf{Z}}}

\def\ermA{{\textnormal{A}}}
\def\ermB{{\textnormal{B}}}
\def\ermC{{\textnormal{C}}}
\def\ermD{{\textnormal{D}}}
\def\ermE{{\textnormal{E}}}
\def\ermF{{\textnormal{F}}}
\def\ermG{{\textnormal{G}}}
\def\ermH{{\textnormal{H}}}
\def\ermI{{\textnormal{I}}}
\def\ermJ{{\textnormal{J}}}
\def\ermK{{\textnormal{K}}}
\def\ermL{{\textnormal{L}}}
\def\ermM{{\textnormal{M}}}
\def\ermN{{\textnormal{N}}}
\def\ermO{{\textnormal{O}}}
\def\ermP{{\textnormal{P}}}
\def\ermQ{{\textnormal{Q}}}
\def\ermR{{\textnormal{R}}}
\def\ermS{{\textnormal{S}}}
\def\ermT{{\textnormal{T}}}
\def\ermU{{\textnormal{U}}}
\def\ermV{{\textnormal{V}}}
\def\ermW{{\textnormal{W}}}
\def\ermX{{\textnormal{X}}}
\def\ermY{{\textnormal{Y}}}
\def\ermZ{{\textnormal{Z}}}

\def\vzero{{\bm{0}}}
\def\vone{{\bm{1}}}
\def\vmu{{\bm{\mu}}}
\def\vtheta{{\bm{\theta}}}
\def\vphi{{\bm{\phi}}}
\def\va{{\bm{a}}}
\def\vb{{\bm{b}}}
\def\vc{{\bm{c}}}
\def\vd{{\bm{d}}}
\def\ve{{\bm{e}}}
\def\vf{{\bm{f}}}
\def\vg{{\bm{g}}}
\def\vh{{\bm{h}}}
\def\vi{{\bm{i}}}
\def\vj{{\bm{j}}}
\def\vk{{\bm{k}}}
\def\vl{{\bm{l}}}
\def\vm{{\bm{m}}}
\def\vn{{\bm{n}}}
\def\vo{{\bm{o}}}
\def\vp{{\bm{p}}}
\def\vq{{\bm{q}}}
\def\vr{{\bm{r}}}
\def\vs{{\bm{s}}}
\def\vt{{\bm{t}}}
\def\vu{{\bm{u}}}
\def\vv{{\bm{v}}}
\def\vw{{\bm{w}}}
\def\vx{{\bm{x}}}
\def\vy{{\bm{y}}}
\def\vz{{\bm{z}}}

\def\evalpha{{\alpha}}
\def\evbeta{{\beta}}
\def\evepsilon{{\epsilon}}
\def\evlambda{{\lambda}}
\def\evomega{{\omega}}
\def\evmu{{\mu}}
\def\evpsi{{\psi}}
\def\evsigma{{\sigma}}
\def\evtheta{{\theta}}
\def\eva{{a}}
\def\evb{{b}}
\def\evc{{c}}
\def\evd{{d}}
\def\eve{{e}}
\def\evf{{f}}
\def\evg{{g}}
\def\evh{{h}}
\def\evi{{i}}
\def\evj{{j}}
\def\evk{{k}}
\def\evl{{l}}
\def\evm{{m}}
\def\evn{{n}}
\def\evo{{o}}
\def\evp{{p}}
\def\evq{{q}}
\def\evr{{r}}
\def\evs{{s}}
\def\evt{{t}}
\def\evu{{u}}
\def\evv{{v}}
\def\evw{{w}}
\def\evx{{x}}
\def\evy{{y}}
\def\evz{{z}}

\def\mA{{\bm{A}}}
\def\mB{{\bm{B}}}
\def\mC{{\bm{C}}}
\def\mD{{\bm{D}}}
\def\mE{{\bm{E}}}
\def\mF{{\bm{F}}}
\def\mG{{\bm{G}}}
\def\mH{{\bm{H}}}
\def\mI{{\bm{I}}}
\def\mJ{{\bm{J}}}
\def\mK{{\bm{K}}}
\def\mL{{\bm{L}}}
\def\mM{{\bm{M}}}
\def\mN{{\bm{N}}}
\def\mO{{\bm{O}}}
\def\mP{{\bm{P}}}
\def\mQ{{\bm{Q}}}
\def\mR{{\bm{R}}}
\def\mS{{\bm{S}}}
\def\mT{{\bm{T}}}
\def\mU{{\bm{U}}}
\def\mV{{\bm{V}}}
\def\mW{{\bm{W}}}
\def\mX{{\bm{X}}}
\def\mY{{\bm{Y}}}
\def\mZ{{\bm{Z}}}
\def\mBeta{{\bm{\beta}}}
\def\mPhi{{\bm{\Phi}}}
\def\mLambda{{\bm{\Lambda}}}
\def\mSigma{{\bm{\Sigma}}}

\DeclareMathAlphabet{\mathsfit}{\encodingdefault}{\sfdefault}{m}{sl}
\SetMathAlphabet{\mathsfit}{bold}{\encodingdefault}{\sfdefault}{bx}{n}
\newcommand{\tens}[1]{\bm{\mathsfit{#1}}}
\def\tA{{\tens{A}}}
\def\tB{{\tens{B}}}
\def\tC{{\tens{C}}}
\def\tD{{\tens{D}}}
\def\tE{{\tens{E}}}
\def\tF{{\tens{F}}}
\def\tG{{\tens{G}}}
\def\tH{{\tens{H}}}
\def\tI{{\tens{I}}}
\def\tJ{{\tens{J}}}
\def\tK{{\tens{K}}}
\def\tL{{\tens{L}}}
\def\tM{{\tens{M}}}
\def\tN{{\tens{N}}}
\def\tO{{\tens{O}}}
\def\tP{{\tens{P}}}
\def\tQ{{\tens{Q}}}
\def\tR{{\tens{R}}}
\def\tS{{\tens{S}}}
\def\tT{{\tens{T}}}
\def\tU{{\tens{U}}}
\def\tV{{\tens{V}}}
\def\tW{{\tens{W}}}
\def\tX{{\tens{X}}}
\def\tY{{\tens{Y}}}
\def\tZ{{\tens{Z}}}


\def\gA{{\mathcal{A}}}
\def\gB{{\mathcal{B}}}
\def\gC{{\mathcal{C}}}
\def\gD{{\mathcal{D}}}
\def\gE{{\mathcal{E}}}
\def\gF{{\mathcal{F}}}
\def\gG{{\mathcal{G}}}
\def\gH{{\mathcal{H}}}
\def\gI{{\mathcal{I}}}
\def\gJ{{\mathcal{J}}}
\def\gK{{\mathcal{K}}}
\def\gL{{\mathcal{L}}}
\def\gM{{\mathcal{M}}}
\def\gN{{\mathcal{N}}}
\def\gO{{\mathcal{O}}}
\def\gP{{\mathcal{P}}}
\def\gQ{{\mathcal{Q}}}
\def\gR{{\mathcal{R}}}
\def\gS{{\mathcal{S}}}
\def\gT{{\mathcal{T}}}
\def\gU{{\mathcal{U}}}
\def\gV{{\mathcal{V}}}
\def\gW{{\mathcal{W}}}
\def\gX{{\mathcal{X}}}
\def\gY{{\mathcal{Y}}}
\def\gZ{{\mathcal{Z}}}

\def\sA{{\mathbb{A}}}
\def\sB{{\mathbb{B}}}
\def\sC{{\mathbb{C}}}
\def\sD{{\mathbb{D}}}
\def\sE{{\mathbb{E}}}
\def\sF{{\mathbb{F}}}
\def\sG{{\mathbb{G}}}
\def\sH{{\mathbb{H}}}
\def\sI{{\mathbb{I}}}
\def\sJ{{\mathbb{J}}}
\def\sK{{\mathbb{K}}}
\def\sL{{\mathbb{L}}}
\def\sM{{\mathbb{M}}}
\def\sN{{\mathbb{N}}}
\def\sO{{\mathbb{O}}}
\def\sP{{\mathbb{P}}}
\def\sQ{{\mathbb{Q}}}
\def\sR{{\mathbb{R}}}
\def\sS{{\mathbb{S}}}
\def\sT{{\mathbb{T}}}
\def\sU{{\mathbb{U}}}
\def\sV{{\mathbb{V}}}
\def\sW{{\mathbb{W}}}
\def\sX{{\mathbb{X}}}
\def\sY{{\mathbb{Y}}}
\def\sZ{{\mathbb{Z}}}

\def\emLambda{{\Lambda}}
\def\emA{{A}}
\def\emB{{B}}
\def\emC{{C}}
\def\emD{{D}}
\def\emE{{E}}
\def\emF{{F}}
\def\emG{{G}}
\def\emH{{H}}
\def\emI{{I}}
\def\emJ{{J}}
\def\emK{{K}}
\def\emL{{L}}
\def\emM{{M}}
\def\emN{{N}}
\def\emO{{O}}
\def\emP{{P}}
\def\emQ{{Q}}
\def\emR{{R}}
\def\emS{{S}}
\def\emT{{T}}
\def\emU{{U}}
\def\emV{{V}}
\def\emW{{W}}
\def\emX{{X}}
\def\emY{{Y}}
\def\emZ{{Z}}
\def\emSigma{{\Sigma}}

\newcommand{\etens}[1]{\mathsfit{#1}}
\def\etLambda{{\etens{\Lambda}}}
\def\etA{{\etens{A}}}
\def\etB{{\etens{B}}}
\def\etC{{\etens{C}}}
\def\etD{{\etens{D}}}
\def\etE{{\etens{E}}}
\def\etF{{\etens{F}}}
\def\etG{{\etens{G}}}
\def\etH{{\etens{H}}}
\def\etI{{\etens{I}}}
\def\etJ{{\etens{J}}}
\def\etK{{\etens{K}}}
\def\etL{{\etens{L}}}
\def\etM{{\etens{M}}}
\def\etN{{\etens{N}}}
\def\etO{{\etens{O}}}
\def\etP{{\etens{P}}}
\def\etQ{{\etens{Q}}}
\def\etR{{\etens{R}}}
\def\etS{{\etens{S}}}
\def\etT{{\etens{T}}}
\def\etU{{\etens{U}}}
\def\etV{{\etens{V}}}
\def\etW{{\etens{W}}}
\def\etX{{\etens{X}}}
\def\etY{{\etens{Y}}}
\def\etZ{{\etens{Z}}}

\newcommand{\pdata}{p_{\rm{data}}}
\newcommand{\ptrain}{\hat{p}_{\rm{data}}}
\newcommand{\Ptrain}{\hat{P}_{\rm{data}}}
\newcommand{\pmodel}{p_{\rm{model}}}
\newcommand{\Pmodel}{P_{\rm{model}}}
\newcommand{\ptildemodel}{\tilde{p}_{\rm{model}}}
\newcommand{\pencode}{p_{\rm{encoder}}}
\newcommand{\pdecode}{p_{\rm{decoder}}}
\newcommand{\precons}{p_{\rm{reconstruct}}}

\newcommand{\laplace}{\mathrm{Laplace}} 

\newcommand{\E}{\mathbb{E}}
\newcommand{\Ls}{\mathcal{L}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\emp}{\tilde{p}}
\newcommand{\lr}{\alpha}
\newcommand{\reg}{\lambda}
\newcommand{\rect}{\mathrm{rectifier}}
\newcommand{\softmax}{\mathrm{softmax}}
\newcommand{\sigmoid}{\sigma}
\newcommand{\softplus}{\zeta}
\newcommand{\KL}{D_{\mathrm{KL}}}
\newcommand{\Var}{\mathrm{Var}}
\newcommand{\standarderror}{\mathrm{SE}}
\newcommand{\Cov}{\mathrm{Cov}}
\newcommand{\normlzero}{L^0}
\newcommand{\normlone}{L^1}
\newcommand{\normltwo}{L^2}
\newcommand{\normlp}{L^p}
\newcommand{\normmax}{L^\infty}

\newcommand{\parents}{Pa} 

\DeclareMathOperator*{\argmax}{arg\,max}
\DeclareMathOperator*{\argmin}{arg\,min}

\DeclareMathOperator{\sign}{sign}
\DeclareMathOperator{\Tr}{Tr}
\let\ab\allowbreak
 
\usepackage{hyperref}
\usepackage{url}
\usepackage{subfigure}
\usepackage{graphicx}
\usepackage{tabularx}
\usepackage{booktabs}
\usepackage{ulem}
\normalem
\usepackage[font=small]{caption}
\usepackage{algorithm}
\usepackage{algorithmicx, algpseudocode}
\usepackage{mathtools}

\newcommand{\gn}[1]{\textcolor{magenta}{\bf\small [#1 --GN]}}
\newcommand{\gnc}[2]{\textcolor{magenta}{\sout{#1} #2}}


\title{Lagging Inference Networks and Posterior Collapse in Variational Autoencoders}


\author{Junxian He, Daniel Spokoyny, Graham Neubig \\
Carnegie Mellon University\\
\texttt{\{junxianh,dspokoyn,gneubig\}@cs.cmu.edu} \\
\And
Taylor Berg-Kirkpatrick \\
University of California San Diego\\
\texttt{tberg@eng.ucsd.edu} 
}



\newcommand{\fix}{\marginpar{FIX}}
\newcommand{\new}{\marginpar{NEW}}
\newcommand{\TODO}[1]{\textcolor{red}{TODO: #1}}
\newcommand{\nE}{\mathop{\E}}
\newcommand{\Eq}{\E_{\rvz\sim q_{\vphi}(\rvz|\rvx)}}
\newcommand{\Epz}{\E_{\rvz\sim p_{\vtheta}(\rvz|\rvx)}}
\newcommand{\Ep}{\E_{\rvx\sim p_d(\rvx)}}
\newcommand{\qzx}{q_{\vphi}(\rvz|\rvx)}
\newcommand{\pzx}{p_{\vtheta}(\rvz|\rvx)}
\newcommand{\pxz}{p_{\vtheta}(\rvx|\rvz)}
\newcommand{\px}{p_{\vtheta}(\rvx)}
\newcommand{\pdx}{p_d(\rvx)}
\newcommand{\pz}{p(\rvz)}
\newcommand{\qz}{q_{\vphi}(\rvz)}
\newcommand{\z}{\rvz}
\newcommand{\x}{\rvx}
\newcommand{\y}{\rvy}
\newcommand{\m}{\rvm}
\newcommand{\n}{\rvn}
\newcommand{\mut}{\mu_{\x, \vtheta}}
\newcommand{\mup}{\mu_{\x, \vphi}}
\newcommand{\dtheta}{\nabla_{\vtheta}}
\newcommand{\dphi}{\nabla_{\vphi}}
\newcommand{\dphitheta}{\nabla_{\vphi, \vtheta}}

\iclrfinalcopy \begin{document}


\maketitle

\begin{abstract}
The variational autoencoder (VAE) is a popular combination of deep latent variable model and accompanying variational learning technique. By using a neural inference network to approximate the model's posterior on latent variables, VAEs efficiently parameterize a lower bound on marginal data likelihood that can be optimized directly via gradient methods.
In practice, however, VAE training often results in a degenerate local optimum known as ``posterior collapse''
where the model learns to ignore the latent variable and the approximate posterior mimics the prior.
In this paper, we investigate posterior collapse from the perspective of training dynamics. We find that during the initial stages of training the inference network fails to approximate the model's true posterior, which is a moving target. As a result, the model is encouraged to ignore the latent encoding and posterior collapse occurs.
Based on this observation, we propose an extremely simple modification to VAE training to reduce inference lag: depending on the model's current mutual information between latent variable and observation, we aggressively optimize the inference network before performing each model update. Despite introducing neither new model components nor significant complexity over basic VAE, our approach is able to avoid the problem of collapse that has plagued a large amount of previous work.
Empirically, our approach outperforms strong autoregressive baselines on text and image benchmarks in terms of held-out likelihood, and is competitive with more complex techniques for avoiding collapse while being substantially faster.\footnote{Code and data are available at \href{https://github.com/jxhe/vae-lagging-encoder}{https://github.com/jxhe/vae-lagging-encoder}.}
\end{abstract}


\section{Introduction}
Variational autoencoders (VAEs)~\citep{kingma2013auto} represent a popular combination of a deep latent variable model 
(shown in Figure~\ref{fig:model}) and an accompanying variational learning technique. The generative model in VAE defines a marginal distribution on observations, $\rvx\in \gX$, as:
\begin{equation}
\label{eq:marginal}
p_{\vtheta}(\rvx) = \int p_{\vtheta}(\rvx|\rvz)p(\rvz)\text{d}\rvz.
\end{equation}
The model's generator defines $p_{\vtheta}(\rvx|\rvz)$ and is typically parameterized as a complex neural network. Standard training involves optimizing an evidence lower bound (ELBO) on the intractable marginal data likelihood (Eq.\ref{eq:marginal}), where an auxiliary variational distribution $\qzx$ is introduced to approximate the model posterior distribution $\pzx$. VAEs make this learning procedure highly scalable to large datasets by sharing parameters in the inference network to amortize inferential cost. This amortized approach contrasts with traditional variational techniques that have separate local variational parameters for every data point~\citep{blei2003latent,hoffman2013stochastic}.

While successful on some datasets, prior work has found that VAE training often suffers from ``posterior collapse'', in which the model ignores the latent variable $\rvz$~\citep{bowman2015generating,kingma2016improved, chen2016variational}. This phenomenon is more common when the generator $\pxz$ is parametrized with a strong autoregressive neural network, for example, an LSTM~\citep{hochreiter1997long} on text or a PixelCNN~\citep{van2016conditional} on images.
Posterior collapse is especially evident when modeling discrete data, which hinders the usage of VAEs in important applications like natural language processing.
Existing work analyzes this problem from a static optimization perspective, noting that the collapsed solution is often a reasonably good local optimum in terms of ELBO~\citep{chen2016variational,zhao2017infovae,alemi2018fixing}.
Thus, many proposed solutions to posterior collapse focus on weakening the generator by replacing it with a non-recurrent alternative~\citep{yang2017improved,semeniuta2017hybrid} or modifying the training objective~\citep{zhao2017infovae,tolstikhin2017wasserstein}. In this paper, we analyze the problem from the perspective of training dynamics and propose a novel training procedure for VAEs that addresses posterior collapse. In contrast with other solutions, our proposed procedure optimizes the standard ELBO objective and does not require modification to the VAE model or its parameterization.

Recently, \citet{kim2018semi} proposed a new approach to training VAEs by composing the standard inference network with additional mean-field updates. The resulting semi-amortized approach empirically avoided collapse and obtained better ELBO. However, because of the costly instance-specific local inference steps, the new method is more than 10x slower than basic VAE training in practice. It is also unclear why the basic VAE method fails to find better local optima that make use of latents.
We consider two questions in this paper:
(1) Why does basic VAE training often fall into undesirable collapsed local optima?
(2) Is there a simpler way to change the training trajectory to find a non-trivial local optimum?

To this end, we first study the posterior collapse problem from the perspective of training dynamics. We find, empirically, that the posterior approximation often lags far behind the true model posterior in the initial stages of training (Section \ref{sec:lag}).
We then demonstrate how such lagging behavior can drive the generative model towards a collapsed local optimum, and propose a novel training procedure for VAEs that aggressively optimizes the inference network with more updates to mitigate lag (Section \ref{sec:method}).
Without introducing new modeling components over basic VAEs or additional complexity, our approach is surprisingly simple yet effective in circumventing posterior collapse.
As a density estimator, it outperforms neural autoregressive baselines on both text (Yahoo and Yelp) and image (OMNIGLOT) benchmarks, leading to comparable performance with more complicated previous state-of-the-art methods at a fraction of the training cost (Section \ref{sec:expresults}).

\begin{figure}[!t]
\centering
    \subfigure[Variational autoencoders]{
    \includegraphics[scale=0.14]{figures/model_fig.pdf}
    \label{fig:model}}
    \hspace{2cm}
    \subfigure[Posterior mean space]{
    \includegraphics[scale=0.14]{figures/plane.pdf}
    \label{fig:plane}}
\caption{\textbf{Left:} Depiction of generative model $\pz\pxz$ and inference network $\qzx$ in VAEs. \textbf{Right:} A toy posterior mean space $(\mut, \mup)$ with scalar $z$. The horizontal axis represents the mean of the model posterior $\pzx$, and the vertical axis represents the mean of the approximate posterior $\qzx$. The dashed diagonal line represents when the approximate posterior matches the true model posterior in terms of mean.}
\vspace{-10pt}
\end{figure}

\section{Background}
\subsection{Variational Autoencoders}
\label{sec:vae-bg}
VAEs learn deep generative models defined by a prior $\pz$ and a conditional distribution $\pxz$ as shown in Figure~\ref{fig:model}. In most cases the marginal data likelihood is intractable,
so VAEs instead optimize a tractable variational lower bound (ELBO) of $\log p_{\vtheta}(\rvx)$,
\begin{equation}
\label{eq:elbo-1}
\Ls (\rvx;\vtheta, \vphi) = \underbrace{\Eq[\log \pxz]}_{\textrm{Reconstruction Loss}} - \underbrace{\vphantom{\Eq[\log \pxz]} \KL(\qzx\| p(\rvz))}_{\textrm{KL Regularizer}},
\end{equation}
where $\qzx$ is a variational distribution parameterized by an inference network with parameters $\vphi$, and $\pxz$ denotes the generator network with parameters $\vtheta$. $\qzx$ is optimized to approximate the model posterior $\pzx$. This lower bound is composed of a reconstruction loss term that encourages the inference network to encode information necessary to generate the data and a KL regularizer to push $\qzx$ towards the prior $p(\rvz)$. Below, we consider $\pz \coloneqq \gN(\bm{0}, \mI)$ unless otherwise specified. A key advantage of using inference networks (also called amortized inference) to train deep generative models over traditional locally stochastic variational inference~\citep{hoffman2013stochastic} is that they share parameters over all data samples, 
amortizing computational cost and allowing for efficient training.

The term VAE is often used both to denote the class of generative models and the amortized inference procedure used in training. 
In this paper, it is important to distinguish the two and throughout we will refer to the generative model as the \textit{VAE model},
and the training procedure as \textit{VAE training}.




\subsection{Posterior Collapse}
Despite VAE's appeal as a tool to learn unsupervised representations through the use of latent variables, as mentioned in the introduction, VAE models are often found to ignore latent variables when using flexible generators like LSTMs~\citep{bowman2015generating}. This problem of ``posterior collapse" occurs when the training procedure falls into the trivial local optimum of the ELBO objective in which both the variational posterior and true model posterior collapse to the prior. This is undesirable because an important goal of VAEs is to learn meaningful latent features for inputs. Mathematically, posterior collapse represents a local optimum of VAEs where $\qzx = \pzx = \pz$ for all $\x$. To facilitate our analysis about the causes leading up to collapse, we further define two partial collapse states: \textit{model collapse}, when $\pzx = \pz$, and \textit{inference collapse}, when $\qzx = \pz$ for all $\x$. Note that in this paper we use these two terms to denote the posterior states in the middle of training instead of local optima at the end. These two partial collapse states may not necessarily happen at the same time, which we will discuss later.




\subsection{Visualization of Posterior Distribution}
Posterior collapse is closely related to the true model posterior $\pzx$ and the approximate posterior $\qzx$ as it is defined. Thus, in order to observe how posterior collapse happens, we track the state of $\pzx$ and $\qzx$ over the course of training, and analyze the training trajectory in terms of the \textit{posterior mean space} $\mathcal{U} = \{\mu: \mu=(\mut^T, \mup^T)\}$, where $\mut$ and $\mup$ are the means of $\pzx$ and $\qzx$, respectively.\footnote{$\mut$ can be approximated through discretization of the model posterior, which we show in Appendix~\ref{apdix:mean}.} We can then roughly consider $\mut = \bm{0}$ as model collapse and $\mup = \bm{0}$ as inference collapse as we defined before. Each $\x$ will be projected to a point in this space under the current model and inference network parameters. If $\z$ is a scalar we can efficiently compute $\mut$ and visualize the posterior mean space as shown in Figure~\ref{fig:plane}. The diagonal line $\mut = \mup$ represents parameter settings where $\qzx$ is equal to $\pzx$ in terms of mean, indicating a well-trained inference network. The collapsed local optimum is located at the origin,\footnote{Note that the converse is not true: the setting where all points are located at the origin may not be a local optimum. For example when a model is initialized at the origin as we show in Section~\ref{sec:vanilla-syn}.} while the data points at a more desirable local optima may be distributed along the diagonal. In this paper we will utilize this posterior mean space multiple times to analyze the posterior dynamics.






\section{A Lagging Inference Network Prevents Using Latent Codes}
\label{sec:lag}
\begin{figure}[!t]
\centering
	 \includegraphics[scale=0.23]{figures/population.pdf}
	 \vspace{-15pt}
	 \caption{The projections of 500 data samples from a synthetic dataset on the posterior mean space over the course of training. ``iter'' denotes the number of updates of generators. The top row is from the basic VAE training, the bottom row is from our aggressive inference network training. The results show that while the approximate posterior is lagging far behind the true model posterior in basic VAE training, our aggressive training approach successfully moves the points onto the diagonal line and away from inference collapse.}
	\label{fig:aggre-traj}
	\vspace{-10pt}
\end{figure}
In this section we analyze posterior collapse from a perspective of training dynamics. We will answer the question of why the basic VAE training with strong decoders tends to hit a collapsed local optimum and provide intuition for the simple solution we propose in Section ~\ref{sec:method}.



\subsection{Intuitions from ELBO}
Since posterior collapse is directly relevant to the approximate posterior $\qzx$ and true model posterior $\pzx$, we aim to analyze their training dynamics to study how posterior collapse happens. To this end, it is useful to analyze an alternate form of ELBO:
\begin{equation}
\label{eq:elbo-2}
\Ls (\rvx;\vtheta, \vphi) = \underbrace{\log \px}_{\textrm{marginal log data likelihood}} - \underbrace{\KL(\qzx \| \pzx)}_{\textrm{agreement between approximate and model posteriors}},
\end{equation}
With this view, the only goal of approximate posterior $\qzx$ is to match model posterior $\pzx$, while the optimization of $\pzx$ is influenced by two forces, one of which is the ideal objective marginal data likelihood, and the other is $\KL(\qzx \| \pzx)$, which drives $\pzx$ towards $\qzx$. Ideally if the approximate posterior is perfect, the second force will vanish, with $\dtheta\KL(\qzx | \pzx) = 0$ when $\qzx = \pzx$.
At the start of training, $\z$ and $\x$ are nearly independent under both $\qzx$ and $\pzx$ as we show in Section~\ref{sec:vanilla-syn}, i.e. all $\x$ suffer from model collapse in the beginning.
Then the only component in the training objective that possibly causes dependence between $\z$ and $\x$ under $\pzx$ is $\log \px$. However, this pressure may be overwhelmed by the KL term when $\pzx$ and $\qzx$ start to diverge but $\z$ and $\x$ remain independent under $\qzx$. We hypothesize that, in practice, training drives $\pzx$ and $\qzx$ to the prior in order to bring them into alignment, while locking into model parameters that capture the distribution of $\x$ while ignoring $\z$. Critically, posterior collapse is a \emph{local optimum}; once a set of parameters that achieves these goals are reached, gradient optimization fails to make further progress, even if better overall models that make use of $\z$ to describe $\x$ exist.

Next we visualize the posterior mean space by training a basic VAE with a scalar latent variable on a relatively simple synthetic dataset to examine our hypothesis.



\subsection{Observations on Synthetic Data}
\label{sec:vanilla-syn}
As a synthetic dataset we use discrete sequence data since posterior collapse has been found the most severe in text modeling tasks.
Details on this synthetic dataset and experiment are in Appendix~\ref{apdix:synthetic}.

We train a basic VAE with a scalar latent variable, LSTM encoder, and LSTM decoder
on our synthetic dataset. We sample 500 data points from the validation set and show them on the posterior mean space plots at four different training stages from initialization to convergence in Figure~\ref{fig:aggre-traj}. The mean of the approximate posterior distribution $\mup$ is from the output of the inference network, and $\mut$ can be approximated by discretization of the true model posterior $\pzx$ (see Appendix~\ref{apdix:mean}).

As illustrated in Figure~\ref{fig:aggre-traj}, all points are located at the origin upon initialization\footnote{In Appendix~\ref{apdix:enc-init} we also study the setting where the points are not initialized at origin.}, which means $\z$ and $\x$ are almost independent in terms of both $\qzx$ and $\pzx$ at the beginning of training.
In the second stage of basic VAE training, the points start to spread along the $\mut$ axis. This phenomenon implies that for some data points $\pzx$ moves far away from the prior $\pz$, and confirms that $\log \px$ is able to help move away from model collapse.
However, all of these points are still distributed along a horizontal line, which suggests that $\qzx$ fails to catch up to $\pzx$ and these points are still in a state of inference collapse. As expected, the dependence between $\z$ and $\x$ under $\pzx$ is gradually lost and finally the model converges to the collapsed local optimum.

\begin{figure}[!t]
\scalebox{0.9}{
\begin{minipage}{.65\textwidth}
    \begin{algorithm}[H]
    \centering
    \caption{VAE training with controlled aggressive inference network optimization. }
    \label{alg:opt}
    \begin{algorithmic}[1]
    \State $\vtheta, \vphi \leftarrow$ Initialize parameters
    \State $aggressive \leftarrow$ TRUE
    \Repeat
        \If{$aggressive$}
\Repeat \Comment{[aggressive updates]}
                \State $\rmX \leftarrow$ Random data minibatch
                \State Compute gradients $\vg_{\vphi} \leftarrow \dphi\Ls (\rmX; \vtheta, \vphi)$
                \State Update $\vphi$ using gradients $\vg_{\vphi}$
            \Until{convergence}
            \State $\rmX \leftarrow$ Random data minibatch
            \State Compute gradients $\vg_{\vtheta} \leftarrow \dtheta\Ls (\rmX; \vtheta, \vphi)$
            \State Update $\vtheta$ using gradients $\vg_{\vtheta}$
        \Else \Comment{[basic VAE training]}
            \State $\rmX \leftarrow$ Random data minibatch
            \State Compute gradients $\vg_{\vtheta, \vphi} \leftarrow \dphitheta\Ls (\rmX; \vtheta, \vphi)$
            \State Update $\vtheta, \vphi$ using $\vg_{\vtheta, \vphi}$
        \EndIf
        \State Update $aggressive$ as discussed in Section~\ref{sec:stop}
    \Until{convergence}
    \end{algorithmic}
    \end{algorithm}
\end{minipage}}
\hfill
\begin{minipage}{.37\textwidth}
    \begin{figure}[H]
    \centering
    \includegraphics[scale=0.13]{figures/trajectory.pdf}
    \vspace{-7pt}
    \caption{Trajectory of one data instance on the posterior mean space with our aggressive training procedure. Horizontal arrow denotes one step of generator update, and vertical arrow denotes the inner loop of inference network update. We note that the approximate posterior $\qzx$ takes an aggressive step to catch up to the model posterior $\pzx$.}
    \label{fig:trajectory}
    \end{figure}
\end{minipage}
\end{figure}

\section{Method}
\label{sec:method}
\subsection{Aggressive Training of the Inference Network}
The problem reflected in Figure~\ref{fig:aggre-traj} implies that the inference network is lagging far behind $\pzx$, and might suggest more ``aggressive'' inference network updates are needed.
Instead of blaming the poor approximation on the limitation of the inference network's amortization, we hypothesize that the optimization of the inference and generation networks are imbalanced, and propose to separate the optimization of the two.
Specifically, we change the training procedure to:
\begin{equation}
\label{eq:new-elbo}
\vspace{-2pt}
\vtheta^{\ast} = \argmax_{\vtheta} \ \Ls(\rmX; \vtheta, \vphi^{\ast}), \  \text{where} \ \vphi^{\ast} = \argmax_{\vphi} \ \Ls(\rmX; \vtheta, \vphi),
\vspace{-2pt}
\end{equation}
where optimizing the inference network $\qzx$ is an inner loop in the entire training process as shown in Algorithm~\ref{alg:opt}. This training procedure shares the same spirit with traditional stochastic variational inference (SVI)~\citep{hoffman2013stochastic} that performs iterative inference for each data point separately and suffers from very lengthy iterative estimation. Compared with recent work that try to combine amortized variational inference and SVI~\citep{hjelm2016iterative,krishnan2018challenges,kim2018semi,marino2018iterative} where the inference network is learned to be a component to help perform instance-specific variational inference, our approach keeps variational inference fully amortized, allowing for reverting back to efficient basic VAE training as discussed in Section~\ref{sec:stop}. Also, this aggressive inference network optimization algorithm is as simple as basic VAE training without introducing additional SVI steps, yet attains comparable performance to more sophisticated approaches as we will show in Section~\ref{sec:expresults}.

\subsection{Stopping Criterion}
\label{sec:stop}
Always training with Eq.\ref{eq:new-elbo} would be inefficient and neglects the benefit of the amortized inference network.
Following our previous analysis, the term $\KL(\qzx \| \pzx)$ tends to pressure $\qzx$ or $\pzx$ to $\pz$ only if at least one of them is close to $\pz$, and thus we posit that if we can confirm that we haven't reached this degenerate condition, we can continue with standard VAE training.
Since $\qzx$ is the one lagging behind, we use the mutual information $I_q$ between $\z$ and $\x$ under $\qzx$ to control our stopping criterion.
In practice, we compute the mutual information on the validation set every epoch, and stop the aggressive updates when $I_q$ stops climbing. In all our experiments in this paper we found that the aggressive algorithm usually reverts back to basic VAE training within 5 epochs.
Mutual information, $I_q$ can be computed by~\citep{hoffman2016elbo}:
\begin{equation}
\label{eq:mi}
I_q = \Ep[\KL(\qzx || \pz)] - \KL(\qz \| \pz),
\end{equation}
where $\pdx$ is the empirical distribution. The aggregated posterior, $\qz=\Ep[\qzx]$, can be approximated with a Monte Carlo estimate.
$\KL(\qz \| \pz)$ is also approximated by Monte Carlo, where samples from $\qz$ can be easily obtained by ancestral sampling (i.e. sample $\x$ from dataset and sample $\z \sim \qzx$). This estimator for $I_q$ is the same as in~\citep{dieng2018avoiding}, which is biased because the estimation for $\KL(\qz \| \pz)$ is biased. More specifically, it is a Monte Carlo estimate of an upper bound of mutual information. The complete algorithm is shown in Algorithm~\ref{alg:opt}.

\subsection{Observations on Synthetic Dataset}
By training the VAE model with our approach on synthetic data, we visualize the 500 data samples in the posterior mean space in Figure~\ref{fig:aggre-traj}.
From this, it is evident that the points move towards $\mut = \mup$ and are roughly distributed along the diagonal in the end. This is in striking contrast to the basic VAE and confirms our hypothesis that the inference and generator optimization can be rebalanced by simply performing more updates of the inference network. In Figure~\ref{fig:trajectory} we show the training trajectory of one single data instance for the first several optimization iterations and observe how the aggressive updates help escape inference collapse.

\section{Relation to Related Work}
Posterior collapse in VAEs is first detailed in~\citep{bowman2015generating} where they combine a LSTM decoder with VAE for text modeling. They interpret this problem from a regularization perspective, and propose the ``KL cost annealing'' method to address this issue, whereby the weight of KL term between approximate posterior and prior increases from a small value to one in a ``warm-up'' period. This method has been shown to be unable to deal with collapse on complex text datasets with very large LSTM decoders~\citep{yang2017improved,kim2018semi}. Many works follow this line to lessen the effect of KL term such as $\beta$-VAE~\citep{higgins2016beta} that treats the KL weight as a hyperparameter or ``free bits'' method that constrains the minimum value of the KL term. 
Our approach differs from these methods in that we do not change ELBO objective during training and are in principle still performing maximum likelihood estimation. While these methods explicitly encourage the use of the latent variable, they may implicitly sacrifice density estimation performance at the same time, as we will discuss in Section~\ref{sec:expresults}.

Another thread of research focuses on a different problem called the ``amortization gap''~\citep{cremer2018inference}, which refers to the difference of ELBO caused by parameter sharing of the inference network. Some approaches try to combine instance-specific variational inference with amortized variational inference to narrow this gap~\citep{hjelm2016iterative,krishnan2018challenges,kim2018semi,marino2018iterative}. The most related example is SA-VAE~\citep{kim2018semi}, which mixes instance-specific variational inference and empirically avoids posterior collapse. Our approach is much simpler without sacrificing performance, yet achieves an average of 5x training speedup. 

Other attempts to address posterior collapse include proposing new regularizers~\citep{zhao2017infovae,goyal2017z,tolstikhin2017wasserstein,phuong2018the}, deploying less powerful decoders~\citep{yang2017improved,semeniuta2017hybrid}, using lossy input~\citep{chen2016variational}, utilizing different latent variable connections~\citep{dieng2016topicrnn,dieng2018avoiding, park2018hierarchical}, or changing the prior~\citep{tomczak2017vae,xu2018spherical}. 

\section{Experiments}
\label{sec:expresults}
Our experiments below are designed to (1) examine whether the proposed method indeed prevents posterior collapse, (2) test its efficacy with respect to maximizing predictive log-likelihood compared to other existing approaches, and (3) test its training efficiency.

\begin{table}[!t]
    \centering
    \caption{Results on Yahoo and Yelp datasets. We report mean values across 5 different random restarts, and standard deviation is given in parentheses when available. For LSTM-LM$^\ast$ we report the exact negative log likelihood.}
    \label{tab:results-text}
    \resizebox{1.0 \columnwidth}{!}{
    \begin{tabular}{lcccc|cccc}
    \toprule
    \multicolumn{1}{c}{} &\multicolumn{4}{c}{\bf Yahoo}  &\multicolumn{4}{c}{\bf Yelp}      \\
    \multicolumn{1}{l}{\bf Model} &\multicolumn{1}{c}{\bf NLL} &\multicolumn{1}{c}{\bf KL} &\multicolumn{1}{c}{\bf MI} &\multicolumn{1}{c}{\bf AU} &\multicolumn{1}{c}{\bf NLL} &\multicolumn{1}{c}{\bf KL} &\multicolumn{1}{c}{\bf MI} &\multicolumn{1}{c}{\bf AU}
    \\ \midrule
    \vspace{-9pt} \\
    \multicolumn{9}{c}{\bf Previous Reports} \vspace{3pt} \\
    CNN-VAE~\citep{yang2017improved}             &$\leq$332.1  &10.0  &-- &--     &$\leq$359.1 &7.6  &-- &--\\
    SA-VAE + anneal~\citep{kim2018semi}      &$\leq$327.5  &7.19  &--   &--   &--    &--      &--   &-- \\
    \midrule
    \midrule
    \vspace{-9pt} \\
    \multicolumn{9}{c}{\bf Modified VAE Objective}\vspace{3pt}\\
    VAE + anneal                &328.6 (0.0)  &0.0 (0.0)   &0.0 (0.0)  & 0.0 (0.0)  &357.9 (0.1)  &0.0 (0.0)   &0.0 (0.0) & 0.0 (0.0)   \\
    $\beta$-VAE ($\beta$ = 0.2) &332.2 (0.6)  &19.1 (1.5)  &3.3 (0.1)   &20.4 (6.8) &360.7 (0.7) &11.7 (2.4)    &3.0 (0.5) & 10.0 (5.9) \\
    $\beta$-VAE ($\beta$ = 0.4) &328.7 (0.1)  &6.3 (1.7)   &2.8 (0.6)  &8.0 (5.2) &358.2 (0.3)  &4.2 (0.4)  &2.0 (0.3) &4.2 (3.8)  \\
    $\beta$-VAE ($\beta$ = 0.6) &328.5 (0.1)  &0.3 (0.2)   &0.2 (0.1)  &1.0 (0.7) &357.9 (0.1)  &0.2 (0.2)  &0.1 (0.1) & 3.8 (2.9)  \\
    $\beta$-VAE ($\beta$ = 0.8) &328.8 (0.1)   &0.0 (0.0)   &0.0 (0.0) &0.0 (0.0)  &358.1 (0.2)  &0.0 (0.0)  &0.0 (0.0) & 0.0 (0.0) \\
    SA-VAE + anneal             &327.2 (0.2) &5.2 (1.4)   &2.7 (0.5)   &9.8 (1.3) &355.9 (0.1)           &2.8 (0.5)     &1.7 (0.3) & 8.4 (0.9) \\
    Ours + anneal               &\textbf{326.7 (0.1)}  &5.7 (0.7)   &2.9 (0.2)  &15.0 (3.5) &\textbf{355.9 (0.1)}  &3.8 (0.2)     &2.4 (0.1)  & 11.3 (1.0) \\
    \midrule
    \vspace{-9pt} \\
    \multicolumn{9}{c}{\bf Standard VAE Objective} \vspace{3pt} \\
    LSTM-LM$^\ast$              &\textbf{328.0 (0.3)}                 &--    &--   &-- &358.1 (0.6)           &--      &--   &-- \\
    VAE                         &329.0 (0.1)   &0.0 (0.0)   &0.0 (0.0) &0.0 (0.0)   &358.3 (0.2)          &0.0 (0.0)     &0.0 (0.0)   &0.0 (0.0)\\
    SA-VAE                      &329.2 (0.2)  &0.1 (0.0)   &0.1 (0.0) &0.8 (0.4)  &357.8 (0.2)   &0.3 (0.1)     &0.3 (0.0) &1.0 (0.0) \\
    Ours                        &328.2 (0.2)        &5.6 (0.2)   &3.0 (0.0) &8.0 (0.0)  &\textbf{356.9 (0.2)}  &3.4 (0.3)  &2.4 (0.1) &7.4 (1.3)  \\    
    \bottomrule
    \end{tabular}}
\end{table}

\begin{table}[!t]
    \centering
    \caption{Results on OMNIGLOT dataset. We report mean values across 5 different random restarts, and standard deviation is given in parentheses when available. For PixelCNN$^\ast$ we report the exact negative log likelihood.}
    \label{tab:results-image}
    \resizebox{0.8 \columnwidth}{!}{
    \begin{tabular}{lcccc}
    \toprule
        \multicolumn{1}{l}{\bf Model} &\multicolumn{1}{c}{\bf NLL} &\multicolumn{1}{c}{\bf KL} &\multicolumn{1}{c}{\bf MI} &\multicolumn{1}{c}{\bf AU} 
    \\ \midrule
    \vspace{-9pt} \\
    \multicolumn{5}{c}{\bf Previous Reports} \vspace{3pt} \\
    VLAE~\citep{chen2016variational}                &89.83       &--  &-- &--\\
    VampPrior~\citep{tomczak2017vae}        &89.76       &--  &-- &--\\
    \midrule
    \midrule
    \vspace{-9pt} \\
    \multicolumn{5}{c}{\bf Modified VAE Objective}\vspace{3pt}\\
    VAE + anneal                &89.21 (0.04)  &1.97 (0.12)   &1.79 (0.11)  & 5.3 (1.0)   \\
    $\beta$-VAE ($\beta$ = 0.2) &105.96 (0.38)  &69.62 (2.16)  &3.89 (0.03)   &32.0 (0.0)  \\
    $\beta$-VAE ($\beta$ = 0.4) & 96.09 (0.36)  &44.93 (12.17)   &3.91 (0.03)  &32.0 (0.0)   \\
    $\beta$-VAE ($\beta$ = 0.6) & 92.14 (0.12)  &25.43 (9.12)   &3.93 (0.03)  &32.0 (0.0)  \\
    $\beta$-VAE ($\beta$ = 0.8) & 89.15 (0.04)   &9.98 (0.20)   &3.84 (0.03) &13.0 (0.7)   \\
    SA-VAE + anneal             &\textbf{89.07 (0.06)}   &3.32 (0.08)   &2.63 (0.04)   &8.6 (0.5) \\
    Ours + anneal               &89.11 (0.04)  &2.36 (0.15)   &2.02 (0.12)  &7.2 (1.3)  \\
    \midrule
    \vspace{-9pt} \\
    \multicolumn{5}{c}{\bf Standard VAE Objective} \vspace{3pt} \\
    PixelCNN$^\ast$             &89.73 (0.04)                &--    &--   &-- \\
    VAE                         &89.41 (0.04) &1.51 (0.05) & 1.43 (0.07)   &3.0 (0.0) \\
    SA-VAE                      &89.29 (0.02)  &2.55 (0.05)   &2.20 (0.03) &4.0 (0.0)   \\
    Ours                        &\textbf{89.05 (0.05)}   &2.51 (0.14)   &2.19 (0.08) &5.6 (0.5)   \\    
    \bottomrule
    \end{tabular}}
\end{table}


\subsection{Setup}
For all experiments we use a Gaussian prior $\mathcal{N}(\bm{0},\bm{I})$ and the inference network parametrizes a diagonal Gaussian. We evaluate with approximate negative log likelihood (NLL) as estimated by 500 importance weighted samples\footnote{We measure the uncertainty in the evaluation caused by the Monte Carlo estimates in Appendix~\ref{apdix:iw}. The variance of our NLL estimates for a trained VAE model is smaller than $10^{-3}$ on all datasets. }~\citep{burda2015importance} since it produces a tighter lower bound to marginal data log likelihood than ELBO (ELBO values are included in Appendix~\ref{apdix:elbo}), and should be more accurate. We also report $\KL(\qzx \| \pz)$ (KL), mutual information $I_q$ (MI),  and number of active units (AU)~\citep{burda2015importance} in latent representation. The activity of a latent dimension $z$ is measured as $A_{z}=\text{Cov}_{\x}(\E_{z\sim q(z|\x)}[z])$. The dimension $z$ is defined as active if $A_{z} > 0.01$.

As baselines, we compare with strong neural autoregressive models (LSTM-LM for text and PixelCNN~\citep{van2016conditional} for images), basic VAE, the ``KL cost annealing'' method~\citep{bowman2015generating,sonderby2016ladder}, $\beta$-VAE~\citep{higgins2016beta}, and SA-VAE~\citep{kim2018semi} which holds the previous state-of-the-art performance on text modeling benchmarks. For $\beta$-VAE we vary $\beta$ between 0.2, 0.4, 0.6, and 0.8. SA-VAE is ran with 10 refinement steps. We also examine the effect of KL cost annealing on both SA-VAE and our approach. To facilitate our analysis later, we report the results in two categories: ``Standard VAE objectives'', and ``Modified VAE objectives''.\footnote{While annealing reverts back to ELBO objective after the warm-up period, we consider part of ``Modified VAE objectives'' since it might produce undesired behavior in the warm-up period, as we will discuss soon.}

We evaluate our method on density estimation for text on the Yahoo and Yelp corpora~\citep{yang2017improved} and images on OMNIGLOT~\citep{lake2015human}. Following the same configuration as in ~\citet{kim2018semi}, we use a single layer LSTM as encoder and decoder for text. For images, we use a ResNet~\citep{he2016deep} encoder and a 13-layer Gated PixelCNN~\citep{van2016conditional} decoder. We use 32-dimensional $\z$ and optimize ELBO objective with SGD for text and Adam~\citep{kingma2014adam} for images. We concatenate $\z$ to the input for the decoders. For text, $\z$ also predicts the initial hidden state of the LSTM decoder. We dynamically binarize images during training and test on fixed binarized test data. We run all models with 5 different random restarts, and report mean and standard deviation. Full details of the setup are in Appendix~\ref{apdix:text} and ~\ref{apdix:image}.

\begin{figure}[!t]
\centering
    \subfigure[OMNIGLOT]{
    \includegraphics[scale=0.195]{figures/omniglot_uncertain.pdf}}
    \subfigure[Yahoo]{
    \includegraphics[scale=0.195]{figures/yahoo_uncertain.pdf}}
    \subfigure[Yelp]{
    \includegraphics[scale=0.195]{figures/yelp_uncertain.pdf}}
    \vspace{-12pt}
\caption{NLL versus AU (active units) for all models on three datasets. For each model we display 5 points which represent 5 runs with different random seeds. ``Autoregressive'' denotes LSTM-LM for text data and PixelCNN for image data. We plot ``autoregressive'' baselines as their AU is 0. To better visualize the system difference on OMNIGLOT dataset, for OMNIGLOT figure we ignore some $\beta$-VAE baselines that are not competitive.\label{fig:uncertain}}
\end{figure}

\subsection{Results}
In Table \ref{tab:results-text} and Table \ref{tab:results-image} we show the results on all three datasets, we also plot NLL vs AU for every trained model from separate runs in Figure~\ref{fig:uncertain} to visualize the uncertainties. Our method achieves comparable or better performance than previous state-of-the-art systems on all three datasets. Note that to examine the posterior collapse issue for images we use a larger PixelCNN decoder than previous work, thus our approach is not directly comparable to them and included at the top of Table~\ref{tab:results-image} as reference points. We observe that SA-VAE suffers from posterior collapse on both text datasets without annealing. However, we demonstrate that our algorithm does not experience posterior collapse even without annealing.







\subsection{Training Time}
In Table~\ref{timing-table} we report the total training time of our approach, SA-VAE and basic VAE training across the three datasets. We find that the training time for our algorithm is only 2-3 times slower than a regular VAE whilst being 3-7 times faster than SA-VAE. 

\begin{table}[!t]
\caption{Comparison of total training time, in terms of relative speed and absolute hours.}
\label{timing-table}
\centering
 \resizebox{0.7 \columnwidth}{!}{
\begin{tabular}{lrr|rr|rr}
\toprule
\multicolumn{1}{c}{} &\multicolumn{2}{c}{\bf Yahoo}  &\multicolumn{2}{c}{\bf Yelp15} &\multicolumn{2}{c}{\bf OMNIGLOT}
\\
\multicolumn{1}{c}{} &\multicolumn{1}{c}{\bf Relative} &\multicolumn{1}{c}{\bf Hours} &\multicolumn{1}{c}{\bf Relative} &\multicolumn{1}{c}{\bf Hours} &\multicolumn{1}{c}{\bf Relative} &\multicolumn{1}{c}{\bf Hours}
\\ \hline
VAE                         &1.00 &5.35      &1.00  &5.75    &1.00  &4.30   \\
SA-VAE                      &9.91 &52.99     &10.33 &59.37   &15.15 &65.07  \\
Ours                        &2.20 &11.76     &3.73  &21.44   &2.19  &9.42  \\
\bottomrule
\end{tabular}}
\vspace{-3mm}
\end{table}

\subsection{Analysis of Baselines}
\label{sec:mi}
We analyze the difference between our approach and the methods that weaken the KL regularizer term in ELBO, and explain the unwanted behavior produced by breaking maximum likelihood estimation. As illustrative examples, we compare with the KL cost annealing method and $\beta$-VAE. Decreasing the weight of the KL regularizer term in ELBO is equivalent to adding an additional regularizer to push $\qzx$ far from $\pz$. We set $\beta=0.2$ in order to better observe this phenomenon.

We investigate the training procedure on the Yelp dataset based on: (1) the mutual information between $\z$ and $\x$, $I_q$, (2) the KL regularizer, $\Ep[\KL(\qzx \| \pz)]$, and (3) the distance between the aggregated posterior and the prior, $\KL(\qz \| \pz)$. Note that the KL regularizer is equal to the sum of the other two as stated in Eq.\ref{eq:mi}. We plot these values over the course of training in Figure~\ref{fig:mi-comp}. In the initial training stage we observe that the KL regularizer increases with all three approaches, however, the mutual information, $I_q$, in the annealing remains small, thus a large KL regularizer term does not imply that the latent variable is being used. Finally the annealing method suffers from posterior collapse. For $\beta$-VAE, the mutual information increases, but $\KL(\qz \| \pz)$ also reaches a very large value. Intuitively, $\KL(\qz \| \pz)$ should be kept small for learning the generative model well since in the objective the generator $\pxz$ is learned with latent variables sampled from the variational distribution. If the setting of $\z$ that best explains the data has a lower likelihood under the model prior, then the overall model would fit the data poorly.  The same intuition has been discussed in~\citet{zhao2017infovae} and~\citet{tolstikhin2017wasserstein}. This also explains why $\beta$-VAE generalizes poorly when it has large mutual information. In contrast, our approach is able to obtain high mutual information, and at the same time maintain a small $\KL(\qz \| \pz)$ as a result of optimizing standard ELBO where the KL regularizer upper-bounds $\KL(\qz \| \pz)$.



\begin{figure}[!t]
\centering
    \subfigure{
    \includegraphics[scale=0.20]{figures/anneal_mi.pdf}}
    \hfill
    \subfigure{
    \includegraphics[scale=0.20]{figures/our_mi.pdf}}
    \hfill
    \subfigure{
    \includegraphics[scale=0.20]{figures/beta_mi.pdf}}
    \vspace{-12pt}
\caption{Training behavior on Yelp. \textbf{Left: }VAE + annealing. \textbf{Middle: }Our method. \textbf{Right: }$\beta$-VAE ($\beta=0.2$).\label{fig:mi-comp}}
\vspace{-3mm}
\end{figure}

\begin{table}[!t]
    \centering
    \caption{Results on Yelp dataset using a fixed budget of inner encoder updates}
    \label{tab:fix-results}
    \resizebox{0.55 \columnwidth}{!}{
    \begin{tabular}{lccccc}
    \toprule
        \multicolumn{1}{l}{\bf \# Inner Iterations} &\multicolumn{1}{c}{\bf NLL} &\multicolumn{1}{c}{\bf KL} &\multicolumn{1}{c}{\bf MI} &\multicolumn{1}{c}{\bf AU} &\multicolumn{1}{c}{\bf Hours}
    \\ \midrule
    \vspace{-9pt} \\
    10 &357.9  &1.1  &1.0   &3 & 11.97  \\
    30 & 357.1  &3.6  &2.5  &8 & 22.31   \\
    50 &356.9  &4.2  &2.8   &9 & 29.58  \\
    70 &357.1  &4.4  &2.7   &10 & 24.18  \\
    convergence & 357.0 & 3.8 & 2.6 & 8 & 21.44\\
    \bottomrule
    \end{tabular}}
\end{table}

\subsection{Analysis of Inner Loop Update}
We perform analysis to examine the tradeoff between performance and speed within the inner loop update in our approach, through fixing a budget of updates to the inference network instead of updating until convergence.\footnote{Note that in practice, we never reach exact convergence, thus here we aim to show how close to convergence is required in the inner loop update.} In our implementation, we break the inner loop when the ELBO objective stays the same or decreases across 10 iterations. Note that we do not perform separate learning rate decay in the inner loop so this convergence condition is not strict, but empirically we found it to be sufficient. Across all datasets, in practice this yields roughly 30 -- 100 updates per inner loop update. Now we explore using a fixed budget of inner loop updates and observe its influence on performance and speed. We report the results on Yelp dataset from single runs in Table~\ref{tab:fix-results}.\footnote{70 inner iterations take less time than 50 because the aggressive training of it stops earlier in practice.} We see that sufficient number of inner iterations is necessary to address posterior collapse and achieve good performance, but the performance starts to saturate near convergence, thus we believe that optimizing to a near-convergence point is important.








\section{Conclusion}
In this paper we study the ``posterior collapse'' problem that variational autoencoders experience when the model is parameterized by a strong autoregressive neural network. In our synthetic experiment we identify that the problem lies with the lagging inference network in the initial stages of training. To remedy this, we propose a simple yet effective training algorithm that aggressively optimizes the inference network with more updates before reverting back to basic VAE training. Experiments on text and image modeling demonstrate the effectiveness of our approach.
\bibliography{iclr2019_conference}
\bibliographystyle{iclr2019_conference}

\newpage
\appendix
\section{Approximation of the mean of the true model posterior}\label{apdix:mean}
We approximate the mean of true model posterior $\pzx$ by discretization of the density distribution (Riemann integral):
 \begin{equation}
 \Epz[z] = \sum_{z_i \in \gC}[z_ip(z_i|\x)],
 \end{equation}
 where $\gC$ is a partition of an interval with small stride and sufficiently large coverage. We assume the density value outside this interval is zero. The model posterior, $p_{\vtheta}(z | \x)$, needs to be first approximated on this partition of interval. In practice, for the synthetic data we choose the interval [-20.0, 20.0] and stride equal to 0.01. This interval should have sufficient coverage since we found all samples from true model posterior $p_{\vtheta}(z | \x)$ lies within [-5.0, 5.0] by performing MH sampling.

\section{Experimental Details}
In general, for annealing we increase the KL weight linearly from 0.1 to 1.0 in the first 10 epochs, as in~\citet{kim2018semi}. We also perform analysis for different annealing strategies in Appendix~\ref{apdix:anneal}
\subsection{Synthetic experiment for Section~\ref{sec:lag} and~\ref{sec:method}}\label{apdix:synthetic}
To generate synthetic data points, we first sample a two-dimensional latent variable $\z$ from a mixture of Gaussian distributions that have four mixture components. We choose dimension two because we want the synthetic data distribution to be relatively simple but also complex enough for a one-dimensional latent variable model to fit. We choose mixture of Gaussian as the prior to make sure that the synthetic data is diverse. The mean of these Gaussians are (-2.0, -2.0), (-2.0, 2.0), (2.0, -2.0), (2.0, 2.0), respectively. All of them have a unit variance. Then we follow the synthetic data generation procedure in~\citet{kim2018semi}, where we sample data points from an one-layer LSTM conditioned on latent variables. The LSTM has 100 hidden units and 100-dimensional input embeddings. An affine transformation of $\z$ is used as the initial hidden state of LSTM decoder, $\z$ is also concatenated with output of LSTM at each time stamp to be directly mapped to vocabulary space. LSTM parameters are initialized with $\gU(-1, 1)$, and the part of MLP that maps $\z$ to vocabulary space is initialized with $\gU(-5, 5)$, this is done to  make sure that the latent variables have more influence in generating data. We generated a dataset with 20,000 examples (train/val/test is 16000/2000/2000) each of length 10 from a vocabulary of size 1000.

In the synthetic experiment we use a LSTM encoder and LSTM decoder, both of which have 50 hidden units and 50 latent embeddings. This LSTM decoder has less capacity than the one used for creating the dataset since in the real world model capacity is usually insufficient to exactly model the empirical distribution. Parameters of LSTM decoders are initialized with $\gU(-0.01, 0.01)$, except for the embedding weight matrix which is initialized with $\gU(-0.1, 0.1)$. Dropout layers with probability 0.5 are applied to both input embeddings and output hidden embeddings of decoder. We use the SGD optimizer and start with a learning rate of 1.0 and decay it by a factor of 2 if the validation loss has not improved in 2 epochs and terminate training once the learning rate has decayed a total of 5 times. 

\subsection{Text}\label{apdix:text}
Following~\citet{kim2018semi}, we use a single-layer LSTM with 1024 hidden units and 512-dimensional word embeddings as the encoder and decoder for all of text models. The LSTM parameters are initialized from $\gU(-0.01, 0.01)$, and embedding parameters are initialized from $\gU(-0.1, 0.1)$. We use the final hidden state of the encoder to predict (via a linear transformation) the latent variable. We use the SGD optimizer and start with a learning rate of 1.0 and decay it by a factor of 2 if the validation loss has not improved in 2 epochs and terminate training once the learning rate has decayed a total of 5 times. We don't perform any text preprocessing and use the datasets as provided. We follow~\citet{kim2018semi} and use dropout of 0.5 on the decoder for both the input embeddings of the decoder and on the output of the decoder before the linear transformation to vocabulary space.

\subsection{Images}\label{apdix:image}
We use the same train/val/test splits as provided by~\cite{kim2018semi}. We use the Adam optimizer and start with a learning rate of 0.001 and decay it by a factor of 2 if the validation loss has not improved in 20 epochs. We terminate training once the learning rate has decayed a total of 5 times. Inputs were dynamically binarized throughout training by viewing the input as Bernoulli random variables that are sampled from pixel values. We validate and test on a fixed binarization and our decoder uses binary likelihood. Our ResNet is the same as used by~\cite{chen2016variational}. Our 13-layer PixelCNN architecture is a larger variant based on what was used in~\cite{kim2018semi} and described in their Appendix B.3 section. The PixelCNN has five 7 x 7 layers, followed by, four 5 x 5 layers, and then four 3 x 3 layers. Each layer has 64 feature maps. We use batch normalization followed by an ELU activation before our final 1 x 1 convolutional layer and sigmoid nonlinearity.

\section{Additional Results Containing ELBO}\label{apdix:elbo}
\begin{table}[h]
    \centering
    \caption{Results on Yahoo and Yelp datasets. We report mean values across 5 different random restarts, and standard deviation is given in parentheses when available. For LSTM-LM$^\ast$ we report the exact negative log likelihood.}
    \label{tab:appx-results-text}
    \resizebox{1.0 \columnwidth}{!}{
    \begin{tabular}{lccccc|ccccc}
    \toprule
    \multicolumn{1}{c}{} &\multicolumn{4}{c}{\bf Yahoo}  &\multicolumn{4}{c}{\bf Yelp}      \\
    \multicolumn{1}{l}{\bf Model} &\multicolumn{1}{c}{\bf IW} &\multicolumn{1}{c}{\bf -ELBO}&\multicolumn{1}{c}{\bf KL} &\multicolumn{1}{c}{\bf MI} &\multicolumn{1}{c}{\bf AU} &\multicolumn{1}{c}{\bf IW} &\multicolumn{1}{c}{\bf -ELBO}&\multicolumn{1}{c}{\bf KL} &\multicolumn{1}{c}{\bf MI} &\multicolumn{1}{c}{\bf AU}
    \\ \midrule
    \vspace{-9pt} \\
    \multicolumn{11}{c}{\bf Previous Reports} \vspace{3pt} \\
    CNN-VAE~\citep{yang2017improved}           &--  &332.1  &10.0  &-- &--     &-- &359.1 &7.6  &-- &--\\
    SA-VAE + anneal~\citep{kim2018semi}    &--  &327.5  &7.19  &--   &--   &-- &--   &--      &--   &-- \\
    \midrule
    \midrule
    \vspace{-9pt} \\
    \multicolumn{11}{c}{\bf Modified VAE Objective}\vspace{3pt}\\
    VAE + anneal                &328.6 (0.0)  &328.8 (0.0)  &0.0 (0.0)   &0.0 (0.0)  & 0.0 (0.0)  &357.9 (0.1)  &358.1 (0.1) &0.0 (0.0)   &0.0 (0.0) & 0.0 (0.0)   \\
    $\beta$-VAE ($\beta$ = 0.2) &332.2 (0.6)  &335.9 (0.8) &19.1 (1.5)  &3.3 (0.1)   &20.4 (6.8) &360.7 (0.7) &363.2 (1.1) &11.7 (2.4)    &3.0 (0.5) & 10.0 (5.9) \\
    $\beta$-VAE ($\beta$ = 0.4) &328.7 (0.1)  &330.2 (0.4) &6.3 (1.7)   &2.8 (0.6)  &8.0 (5.2) &358.2 (0.3) &359.1 (0.3) &4.2 (0.4)  &2.0 (0.3) &4.2 (3.8)  \\
    $\beta$-VAE ($\beta$ = 0.6) &328.5 (0.1)  &328.9 (0.0) &0.3 (0.2)   &0.2 (0.1)  &1.0 (0.7) &357.9 (0.1)  &358.2 (0.1) &0.2 (0.2)  &0.1 (0.1) & 3.8 (2.9)  \\
    $\beta$-VAE ($\beta$ = 0.8) &328.8 (0.1)   &329.0 (0.1) &0.0 (0.0)   &0.0 (0.0) &0.0 (0.0)  &358.1 (0.2)  &358.3 (0.2) &0.0 (0.0)  &0.0 (0.0) & 0.0 (0.0) \\
    SA-VAE + anneal          &327.2 (0.2) &327.8 (0.2) &5.2 (1.4)   &2.7 (0.5)   &9.8 (1.3) &355.9 (0.1)     &356.2 (0.1)       &2.8 (0.5)     &1.7 (0.3) & 8.4 (0.9) \\
    Ours + anneal               &\textbf{326.7 (0.1)}  &328.4 (0.2) &5.7 (0.7)   &2.9 (0.2)  &15.0 (3.5) &\textbf{355.9 (0.1)}  &357.2 (0.1) &3.8 (0.2)     &2.4 (0.1)  & 11.3 (1.0) \\
    \midrule
    \vspace{-9pt} \\
    \multicolumn{11}{c}{\bf Standard VAE Objective} \vspace{3pt} \\
    LSTM-LM$^\ast$              &\textbf{328.0 (0.3)}     &--            &--    &--   &-- &358.1 (0.6)    &--   &--      &--   &-- \\
    VAE                         &329.0 (0.1)   &329.1 (0.1) &0.0 (0.0)   &0.0 (0.0) &0.0 (0.0)   &358.3 (0.2)   &358.5 (0.2)  &0.0 (0.0)     &0.0 (0.0)   &0.0 (0.0)\\
    SA-VAE                      &329.2 (0.2) &329.2 (0.2)  &0.1 (0.0)   &0.1 (0.0) &0.8 (0.4)  &357.8 (0.2)  &357.9 (0.2)  &0.3 (0.1)     &0.3 (0.0) &1.0 (0.0) \\
    Ours                        &328.2 (0.2)   &329.8 (0.2)     &5.6 (0.2)   &3.0 (0.0) &8.0 (0.0)  &\textbf{356.9 (0.2)}  &357.9 (0.2) &3.4 (0.3)  &2.4 (0.1) &7.4 (1.3)  \\    
    \bottomrule
    \end{tabular}}
\end{table}

\begin{table}[h]
    \centering
    \caption{Results on OMNIGLOT dataset. We report mean values across 5 different random restarts, and standard deviation is given in parentheses when available. For PixelCNN$^\ast$ we report the exact negative log likelihood.}
    \label{tab:appx-results-image}
    \resizebox{0.8 \columnwidth}{!}{
    \begin{tabular}{lccccc}
    \toprule
        \multicolumn{1}{l}{\bf Model} &\multicolumn{1}{c}{\bf IW} &\multicolumn{1}{c}{\bf -ELBO} &\multicolumn{1}{c}{\bf KL} &\multicolumn{1}{c}{\bf MI} &\multicolumn{1}{c}{\bf AU} 
    \\ \midrule
    \vspace{-9pt} \\
    \multicolumn{6}{c}{\bf Previous Reports} \vspace{3pt} \\
    VLAE~\citep{chen2016variational}                &89.83       &--  &-- &--\\
    VampPrior~\citep{tomczak2017vae}        &89.76       &--  &-- &--\\
    \midrule
    \midrule
    \vspace{-9pt} \\
    \multicolumn{6}{c}{\bf Modified VAE Objective}\vspace{3pt}\\
    VAE + anneal                &89.21 (0.04)  &89.55 (0.04) &1.97 (0.12)   &1.79 (0.11)  & 5.3 (1.0)   \\
    $\beta$-VAE ($\beta$ = 0.2) &105.96 (0.38)  &113.24 (0.40) &69.62 (2.16)  &3.89 (0.03)   &32.0 (0.0)  \\
    $\beta$-VAE ($\beta$ = 0.4) & 96.09 (0.36) &101.16 (0.66)  &44.93 (12.17)   &3.91 (0.03)  &32.0 (0.0)   \\
    $\beta$-VAE ($\beta$ = 0.6) & 92.14 (0.12)  &94.92 (0.47) &25.43 (9.12)   &3.93 (0.03)  &32.0 (0.0)  \\
    $\beta$-VAE ($\beta$ = 0.8) & 89.15 (0.04)   &90.17 (0.06) &9.98 (0.20)   &3.84 (0.03) &13.0 (0.7)   \\
    SA-VAE + anneal             &\textbf{89.07 (0.06)} &89.42 (0.06)  &3.32 (0.08)   &2.63 (0.04)   &8.6 (0.5) \\
    Ours + anneal               &89.11 (0.04)  &89.62 (0.16) &2.36 (0.15)   &2.02 (0.12)  &7.2 (1.3)  \\
    \midrule
    \vspace{-9pt} \\
    \multicolumn{6}{c}{\bf Standard VAE Objective} \vspace{3pt} \\
    PixelCNN$^\ast$             &89.73 (0.04)        &--        &--    &--   &-- \\
    VAE                         &89.41 (0.04) &89.67 (0.06) &1.51 (0.05) & 1.43 (0.07)   &3.0 (0.0) \\
    SA-VAE                      &89.29 (0.02)  &89.54 (0.03)   &2.55 (0.05)   &2.20 (0.03) &4.0 (0.0)   \\
    Ours                        &\textbf{89.05 (0.05)}  &89.52 (0.03)  &2.51 (0.14)   &2.19 (0.08) &5.6 (0.5)   \\    
    \bottomrule
    \end{tabular}}
\end{table}

\section{Uncertainty of Evaluation}\label{apdix:iw}
To measure the uncertainty in the evaluation stage caused by random Monte Carlo samples, we load pre-trained VAE models trained by our approach and basic VAE training, and repeat our evaluation process with 10 different random seeds. We report the mean and variance values in Table~\ref{tab:appx-iw} and Table~\ref{tab:appx-iw-basic}.

\begin{table}[h]
    \centering
    \caption{Evaluation of a trained VAE model trained by our approach across 10 different random seeds. Mean values are reported and variance is given in parentheses. IW denotes the approximation to NLL we used in Section~\ref{sec:expresults}. }
    \label{tab:appx-iw}
    \resizebox{0.8 \columnwidth}{!}{
    \begin{tabular}{lccccc}
    \toprule
        \multicolumn{1}{l}{\bf Dataset} &\multicolumn{1}{c}{\bf IW} &\multicolumn{1}{c}{\bf -ELBO} &\multicolumn{1}{c}{\bf KL} &\multicolumn{1}{c}{\bf MI} &\multicolumn{1}{c}{\bf AU} 
    \\ \midrule
    Yahoo & 327.98 ($10^{-5}$) & 329.54 ($5\times10^{-4}$) & 5.35 (0) & 3.01 (0.002) & 8 (0) \\
    Yelp & 357.03 ($10^{-5}$) & 358.25 ($2\times 10^{-4}$) & 3.82 ($10^{-5}$) & 2.61 (0.003) & 8 (0) \\
    OMNIGLOT & 89.03 (0) & 89.53 ($3\times 10^{-4}$) & 2.54 (0) & 2.21 (0.001) & 6 (0) \\
    \bottomrule
    \end{tabular}}
\end{table}

\begin{table}[h]
    \centering
    \caption{Evaluation of a trained VAE model trained by basic VAE training across 10 different random seeds. Mean values are reported and variance is given in parentheses. IW denotes the approximation to NLL we used in Section~\ref{sec:expresults}. }
    \label{tab:appx-iw-basic}
    \resizebox{0.8 \columnwidth}{!}{
    \begin{tabular}{lccccc}
    \toprule
        \multicolumn{1}{l}{\bf Dataset} &\multicolumn{1}{c}{\bf IW} &\multicolumn{1}{c}{\bf -ELBO} &\multicolumn{1}{c}{\bf KL} &\multicolumn{1}{c}{\bf MI} &\multicolumn{1}{c}{\bf AU} 
    \\ \midrule
    Yahoo & 328.85 (0) & 329.54 ($1\times10^{-5}$) & 0.00 (0) & 0.00 (0) & 0 (0) \\
    Yelp & 358.17 (0) & 358.38 ($3\times 10^{-5}$) & 0.00 (0) & 0.00 (0) & 0 (0) \\
    OMNIGLOT & 89.41 (0) & 89.66 ($2\times 10^{-4}$) & 1.48 (0) & 1.39 ($6\times 10^{-4}$) & 3 (0) \\
    \bottomrule
    \end{tabular}}
\end{table}

\section{Comparison with different KL-annealing schedules}\label{apdix:anneal}
For the annealing baseline in Table~\ref{tab:results-text} and Table~\ref{tab:results-image}, we implement annealing as increasing KL weight linearly from 0.1 to 1.0 in the first 10 epochs following~\citep{kim2018semi}, and observed posterior collapse for KL-annealing method. However, this annealing strategy may not be the optimal. In this section, we explore different KL-annealing schedules. Specifically, we increase KL weight linearly from 0.0 to 1.0 in the first $s$ iterations, and $s$ is varied as 30k, 50k, 100k, and 120k. We report results on three datasets in Table~\ref{tab:anneal-results}. The results indicate that KL-annealing does not experience posterior collapse if the annealing procedure is sufficiently slow, but it does not produce superior predictive log likelihood to our approach, which is expected because a very slow annealing schedule resembles $\beta$-VAE training in the first many epochs, and $\beta$-VAE encourages learning latent representations but might sacrifice generative modeling performance, as we already showed in Table~\ref{tab:results-text} and Table~\ref{tab:results-image}. Also, the optimal KL annealing schedule varies with different datasets and model architectures, so that it requires careful tuning for the task at hand.

\begin{table}[h]
    \centering
    \caption{Results on Yahoo and Yelp datasets, with different annealing schedules. Starred entries represent original annealing strategy.}
    \label{tab:anneal-results}
    \resizebox{1.0 \columnwidth}{!}{
    \begin{tabular}{lcccc|cccc|cccc}
    \toprule
    \multicolumn{1}{c}{} &\multicolumn{4}{c}{\bf Yahoo}  &\multicolumn{4}{c}{\bf Yelp}  &\multicolumn{4}{c}{\bf OMNIGLOT}    \\
    \multicolumn{1}{l}{\bf Model} &\multicolumn{1}{c}{\bf NLL} &\multicolumn{1}{c}{\bf KL} &\multicolumn{1}{c}{\bf MI} &\multicolumn{1}{c}{\bf AU} &\multicolumn{1}{c}{\bf NLL} &\multicolumn{1}{c}{\bf KL} &\multicolumn{1}{c}{\bf MI} &\multicolumn{1}{c}{\bf AU} &\multicolumn{1}{c}{\bf NLL} &\multicolumn{1}{c}{\bf KL} &\multicolumn{1}{c}{\bf MI} &\multicolumn{1}{c}{\bf AU}
    \\ \midrule
    \vspace{-9pt} \\
    VAE + anneal (30k)  &328.4  &0.0  &0.0   &0 &357.9 &0.2  &0.2 & 1 &89.18  &2.54  &2.19   &10\\
    VAE + anneal (50k) &328.3 &0.7   &0.7  &4 &357.7  &0.3  &0.3 &1  & 89.15  &3.18  &2.58  &10\\
    VAE + anneal (100k) &327.5  &4.3   &2.6  &12 &356.8  &1.9  &1.2 & 5 & 89.27  &4.04   &2.97  &16 \\
    VAE + anneal (120k) &327.5   &7.8  &3.2 &18  &356.9 &2.7  &1.8 & 6 & 89.32   &4.12   &3.00 &15\\
    VAE + anneal$^{\ast}$                &328.6 &0.0  &0.0  & 0  &358.0 &0.0 &0.0 & 0 &89.20 &2.11  &1.89   & 5\\
    Ours + anneal$^{\ast}$               &\textbf{326.6} &6.7 &3.2  &15 & \textbf{355.9}  &3.7     &2.3  & 10 &89.13 &2.53   &2.16  &8\\
    Ours                        &328.0       &5.4  &3.0 &8  &357.0  &3.8 &2.6 &8  &\textbf{89.03}   &2.54  &2.20 &6\\    
    \bottomrule
    \end{tabular}}
\end{table}




\section{Separate Learning Rates of Inference Network and Generator}\label{apdix:lr}
The lagging behavior of inference networks observed in Section~\ref{sec:lag} might be caused by different magnitude of gradients of encoder and decoder\footnote{In the experiments, we did observe that the gradients of decoder is much larger than the gradients of encoder.}, thus another simpler possible solution to this problem is to use separate learning rates for the encoder and decoder optimization. Here we report the results of our trial by using separate learning rates. We experiment with the Yelp dataset, and keep the decoder optimization the same as discussed before, but vary the encoder learning rates to be 1x, 2x, 4x, 6x, 8x, 10x, 30x, 50x of the decoder learning rate. We notice that training becomes very unstable when the encoder learning rate is too large. Particularly it experiences KL value explosion for all the 8x, 10x, 30x, 30x, 50x settings. Therefore, in Table~\ref{tab:lr-results} we only report the settings where we obtained meaningful results. All of the settings suffer from posterior collapse, which means simply changing learning rates of encoders may not be sufficient to circumvent posterior collapse.
\begin{table}[h]
    \centering
    \caption{Results on Yelp dataset varying learning rate of inference network. }
    \label{tab:lr-results}
    \resizebox{0.55 \columnwidth}{!}{
    \begin{tabular}{lcccc}
    \toprule
        \multicolumn{1}{l}{\bf Learning Rate} &\multicolumn{1}{c}{\bf NLL} &\multicolumn{1}{c}{\bf KL} &\multicolumn{1}{c}{\bf MI} &\multicolumn{1}{c}{\bf AU} 
    \\ \midrule
    \vspace{-9pt} \\
    1x &358.2  &0.0  &0.0   &0  \\
    2x & 358.3  &0.0  &0.0  &0   \\
    4x &358.2  &0.0  &0.0   &0  \\
   6x &390.3  &0.0  &0.0   &0  \\
    \bottomrule
    \end{tabular}}
\end{table}

\section{Discussion about Initialization of Inference Networks}\label{apdix:enc-init}
In Section~\ref{sec:lag} we observe and analyze the lagging behavior of inference networks on synthetic data, but Figure~\ref{fig:aggre-traj} only shows the setting where the model is initialized at the origin. It remains unknown if a different initialization of inference networks would also suffer from posterior collapse, and whether our approach would work in that case or not. Here we explore this setting. Specifically, we add an offset to the uniform initialization we used before: we initialize all parameters as $\gU(0.04, 0.06)$ (previously $\gU(-0.01, 0.01)$), except the embedding weight as $\gU(0.0, 0.2)$ (previously $\gU(-0.1, 0.1)$). Since all parameters are positive values the output of encoder must be positive. We show the posterior mean space over course of training in Figure~\ref{fig:apdix-aggre-traj}. Note that all points are located at (approximately) the same place, and are on $\mu_{\x, \vtheta} = 0$ upon initialization, which means $\z$ and $\x$ are still nearly independent in terms of both $\pxz$ and $\qzx$. We observe that in basic VAE training these points move back to $\mu_{\x, \vphi} = 0$ very quickly. This suggests that the ``lagging'' issue might be severe only at the inference collapse state. In such a setting our approach works similarly as before.
 
\begin{figure}[h]
\centering
	 \includegraphics[scale=0.23]{figures/population_pi.pdf}
	 \vspace{-15pt}
	 \caption{The projections of 500 data samples from synthetic dataset on the posterior mean space over the course of training. ``iter'' denotes the number of updates of generators. The top row is from the basic VAE training, the bottom row is from our aggressive inference network training. The results show that while the approximate posterior is lagging far behind the true model posterior in basic VAE training, our aggressive training approach successfully moves the points onto the diagonal line and away from inference collapse.}
	\label{fig:apdix-aggre-traj}
	\vspace{-10pt}
\end{figure}







\end{document}
