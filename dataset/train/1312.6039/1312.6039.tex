\documentclass[12pt]{article}

\usepackage{cite}
\usepackage{booktabs}
\usepackage{hyperref}
\usepackage{graphicx}
\usepackage{subfig}
\usepackage{paralist}

\usepackage{geometry}
\geometry{a4paper,tmargin=2.5cm,bmargin=2.5cm,lmargin=2.5cm,rmargin=2.5cm}

\usepackage{amsthm}
\usepackage{amsmath}
\usepackage{amssymb}

\allowdisplaybreaks[1]

\renewcommand{\qedsymbol}{\rule{1.2ex}{1.2ex}}
\renewcommand{\proofname}{\upshape\bfseries Proof}
\newcommand{\Qed}{\qedhere}

\newtheorem{theorem}{Theorem}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{observation}[theorem]{Observation}
\newtheorem{definition}[theorem]{Definition}

\makeatletter
\def\@endtheorem{\endtrivlist}
\makeatother

\newcommand{\BP}{\mathit{BP}}
\newcommand{\NULL}{\mathrm{NULL}}

\newcommand{\Labelb}{\mathrm{label}}
\newcommand{\depthb}{\mathrm{depth}}
\newcommand{\parentb}{\mathrm{parent}}
\newcommand{\levelancestorb}{\mathrm{level\_ancestor}}
\newcommand{\Degb}{\mathrm{deg}}
\newcommand{\childrankb}{\mathrm{child\_rank}}
\newcommand{\childselectb}{\mathrm{child\_select}}
\newcommand{\numdescendantsb}{\mathrm{num\_descendants}}
\newcommand{\preorderrankb}{\mathrm{preorder\_rank}}
\newcommand{\preorderselectb}{\mathrm{preorder\_select}}
\newcommand{\postorderrankb}{\mathrm{postorder\_rank}}
\newcommand{\postorderselectb}{\mathrm{postorder\_select}}
\newcommand{\deepestb}{\mathrm{deepest}}
\newcommand{\heightb}{\mathrm{height}}
\newcommand{\lcab}{\mathrm{lca}}
\newcommand{\bprankb}{\mathrm{bp\_rank}}
\newcommand{\bpselectb}{\mathrm{bp\_select}}
\newcommand{\bpopenb}{\mathrm{bp\_open}}
\newcommand{\bpcloseb}{\mathrm{bp\_close}}
\newcommand{\bpnodeb}{\mathrm{bp\_node}}

\newcommand{\Label}[1]{\Labelb(#1)}
\newcommand{\depth}[2]{\depthb_{#1}(#2)}
\newcommand{\parent}[2]{\parentb_{#1}(#2)}
\newcommand{\levelancestor}[3]{\levelancestorb_{#1}(#2,#3)}
\newcommand{\Deg}[2]{\Degb_{#1}(#2)}
\newcommand{\childrank}[2]{\childrankb_{#1}(#2)}
\newcommand{\childselect}[3]{\childselectb_{#1}(#2,#3)}
\newcommand{\numdescendants}[2]{\numdescendantsb_{#1}(#2)}
\newcommand{\preorderrank}[2]{\preorderrankb_{#1}(#2)}
\newcommand{\preorderselect}[2]{\preorderselectb_{#1}(#2)}
\newcommand{\postorderrank}[2]{\postorderrankb_{#1}(#2)}
\newcommand{\postorderselect}[2]{\postorderselectb_{#1}(#2)}
\newcommand{\deepest}[2]{\deepestb_{#1}(#2)}
\newcommand{\height}[2]{\heightb_{#1}(#2)}
\newcommand{\lca}[3]{\lcab_{#1}(#2,#3)}

\newcommand{\depthx}[1]{\depthb(#1)}
\newcommand{\parentx}[1]{\parentb(#1)}
\newcommand{\levelancestorx}[2]{\levelancestorb(#1,#2)}
\newcommand{\Degx}[1]{\Degb(#1)}
\newcommand{\childrankx}[1]{\childrankb(#1)}
\newcommand{\childselectx}[2]{\childselectb(#1,#2)}
\newcommand{\numdescendantsx}[1]{\numdescendantsb(#1)}
\newcommand{\preorderrankx}[1]{\preorderrankb(#1)}
\newcommand{\preorderselectx}[1]{\preorderselectb(#1)}
\newcommand{\postorderrankx}[1]{\postorderrankb(#1)}
\newcommand{\postorderselectx}[1]{\postorderselectb(#1)}
\newcommand{\heightx}[1]{\heightb(#1)}
\newcommand{\lcax}[2]{\lcab(#1,#2)}

\newcommand{\D}[2]{\mathcal{D}_{#1,#2}} \newcommand{\T}[2]{#1_{#2}} \newcommand{\V}[1]{V(#1)} \newcommand{\C}[1]{C(#1)} 

\newcommand{\idxzero}{0}
\newcommand{\idxtotal}{1}
\newcommand{\idxle}{2}
\newcommand{\idxgt}{3}
\newcommand{\idxeq}{4}
\newcommand{\idxchildren}{5}
\newcommand{\idxleftmostchild}{6}
\newcommand{\idxspecial}{7}
\newcommand{\idxp}{8}

\newcommand{\Sumb}{\mathrm{sum}}
\newcommand{\fwdsearchb}{\mathrm{fwd\_search}}
\newcommand{\bwdsearchb}{\mathrm{bwd\_search}}
\newcommand{\RMQib}{\mathrm{RMQi}}

\newcommand{\bp}[1]{\mathrm{bp}(#1)}
\newcommand{\bprank}[2]{\bprankb_{#1}(#2)}
\newcommand{\bpselect}[2]{\bpselectb_{#1}(#2)}
\newcommand{\bpopen}[1]{\bpopenb(#1)}
\newcommand{\bpclose}[1]{\bpcloseb(#1)}
\newcommand{\bpnode}[1]{\bpnodeb(#1)}
\newcommand{\findopen}[1]{\mathrm{findopen}(#1)}
\newcommand{\findclose}[1]{\mathrm{findclose}(#1)}
\newcommand{\Sum}[4]{\Sumb(#1,#2,#3,#4)}
\newcommand{\fwdsearch}[4]{\fwdsearchb(#1,#2,#3,#4)}
\newcommand{\bwdsearch}[4]{\bwdsearchb(#1,#2,#3,#4)}
\newcommand{\RMQi}[4]{\RMQib(#1,#2,#3,#4)}

\newcommand{\rank}[3]{\mathrm{rank}_{#1}(#2,#3)}
\newcommand{\select}[3]{\mathrm{select}_{#1}(#2,#3)}
\newcommand{\access}[2]{\mathrm{access}(#1,#2)}
\newcommand{\tselect}{t_{\mathrm{select}}}

\newcommand{\map}[1]{\mathrm{map}(#1)}
\newcommand{\range}[2]{\{#1,\ldots,#2\}}

\begin{document}

\title{Succinct representation of labeled trees}
\author{Dekel Tsur\thanks{Department of Computer Science, Ben-Gurion University of the Negev.
Email: \texttt{dekelts@cs.bgu.ac.il}}}
\date{}
\maketitle

\begin{abstract}
We give a representation for labeled ordered trees
that supports labeled queries such as finding the -th ancestor of a node
with a given label.
Our representation is succinct, namely the redundancy is
small-o of the optimal space for storing the tree.
This improves the representation of He et al.~\cite{HeMZ12} which is
succinct unless the entropy of the labels is small.
\end{abstract}

\section{Introduction}

A problem which was extensively studied in recent years is representing an ordered rooted
tree using space close to the information-theoretic lower bound
while supporting numerous queries on the tree, e.g.~\cite{Jacobson89,MunroR01,ChiangLL05,MunroRRR12,BenoitDMRRR05,GearyRR06,FarzanM08,NavarroS14}.
Geary et al.~\cite{GearyRR06} studied an extension of this problem, in which
the nodes of the tree are labeled with characters from alphabet .
The tree queries now receive a character  as an additional argument, and the
goal of a query is to locate a certain node whose label is  or to count
the nodes satisfying some property and whose labels are .
The set of queries considered by Geary et al.\ is given in
Table~\ref{tab:labeled-queries}.
Geary et al.\ gave a representation that uses
 bits,
where  is the number of nodes and  is the size of the alphabet,
and answers queries in constant time.
For , the space is
, namely, the space is  more than the
information-theoretic lower bound.

Barbay et al.~\cite{BarbayGMR07} and Ferragina et al.~\cite{FerraginaLMM09}
gave labeled tree representations that use space close to the lower bound
for large alphabets,
but the set of supported queries is more restricted.
He et al.~\cite{HeMZ12} improved the result of Geary et al.\ by showing
a labeled tree representation based upon a rank-select structure on
the string  that contains the labels of the nodes in preorder.
Using the rank-select structure of Belazzougui and Navarro~\cite{BelazzouguiN12}
the following results were obtained:
\begin{inparaenum}[(1)]
\item
For , there is a representation that uses 
bits and answers queries in  time,
where  is the word size and
 is the zero-order entropy of .
\item
For , there is a representation that uses
 bits.
 queries are answered in  time,
and  queries are answered in  time
(namely, for every function  satisfying , the time is ), or vice versa. Other queries are answered in
 time.
\end{inparaenum}
The representation of He et al.\ supports all the queries of
Table~\ref{tab:labeled-queries} and additional queries.
Note that the representation is succinct if .

In this paper we give a fully succinct representation of labeled trees.
Our result is given in the following theorem.
\begin{theorem}
Let  be a labeled tree with  nodes and labels from .
\begin{enumerate}
\item
For , there is a representation of  that uses
 bits
and answers the queries of Table~\ref{tab:labeled-queries} in  time.
\item
For , there is a representation of  that
uses  bits.
 queries are answered in  time,
and  queries are answered in  time,
or vice versa.
The rest of the queries of Table~\ref{tab:labeled-queries} are answered in
 time.
\end{enumerate}
\end{theorem}
Note that our representation supports only the queries considered by
Geary et al.\ and it does not support the additional queries considered by He et al.

\begin{table}
\caption{Supported queries on a labeled tree.
A node with label  is called an -node.
A -child of a node is a child which is an -node.
Other - terms are defined similarly.
\label{tab:labeled-queries}}
\centering
\begin{tabular}{lp{11.4cm}}
\toprule
Query & Description \\
\midrule
 & The label of . \\
 & The number of -nodes on the path from
						the root to . \\
 & The -ancestor  of  for which
						. \\
 & . \\
 & The number of -children of . \\
 & The rank of  among its -siblings. \\
 & The -th -child of . \\
 & The number of -descendants of . \\
 & The preorder rank of  among
the -nodes. \\
 & The -th -node in the preorder. \\
 & The postorder rank of  among
the -nodes. \\
 & The -th -node in the postorder. \\
\bottomrule
\end{tabular}
\end{table}

\section{Preliminaries}
A \emph{rank-select structure} stores a string  over alphabet
 and supports the following queries:
\begin{inparaenum}[(1)]
\item
 returns the number of occurrences of  in the first
 characters of 
\item
 returns the -th occurrence of  in 
\item
 returns the -th character of .
\end{inparaenum}
The problem of designing a succinct rank-select structure with efficient query
times was studied extensively. For our purpose, we use the following results.
\begin{theorem}[Belazzougui and Navarro~\cite{BelazzouguiN12}]
\label{thm:rank-select}
A rank-select structure can be built on a string  of length 
over alphabet  such that
\begin{inparaenum}[(1)]
\item
If , the space is  bits,
and the structure answers rank queries in  time
\item
If , the space is  bits,
and the structure answers rank queries
in  time.
The structure answers access queries in  time and select
queries in  time, or vice versa.
\end{inparaenum}
\end{theorem}
\begin{theorem}[Raman et al.~\cite{RamanRS07}]
\label{thm:rank-select-binary}
A rank-select structure can be built on a binary string  of length 
that contains  ones
such that the space is  bits, and
the structure answers queries in  time.
\end{theorem}

We also use the following result on representation of (unlabeled) ordered trees.
We are intrested in a representation that supports
the unlabeled versions of the queries listed in Table~\ref{tab:labeled-queries}
and additional queries such as  queries.
\begin{theorem}[Navarro and Sadakane~\cite{NavarroS14}]
\label{thm:unlabeled-tree}
An ordered tree can be stored using  bits such that
tree queries can be answered in  time.
\end{theorem}

\subsection{Representation of weighted trees}
In this section we consider the problem of representing ordered trees with
weights on the nodes. We will use weighted trees in our representation of
labeled trees.

Let  be a tree with weights  for each node,
where each weight is from .
For a set of nodes , the \emph{-weight} of  is
.
The weighted tree queries we need are described in
Table~\ref{tab:weight-queries}. Throughout this section we assume that the balanced
parenthesis string of a tree is a binary string, where open and close parenthesis are
represented by 1 and 0, respectively.

\begin{table}
\caption{Supported queries on a weighted tree.
 denotes the balanced parenthesis representation of the tree.
\label{tab:weight-queries}}
\centering
\begin{tabular}{lp{11.4cm}}
\toprule
Query & Description \\
\midrule
 & The -weight of . \\
 & The -weight of the nodes of the path from the root
			to . \\
 & The lowest ancestor  of  for which
			the -weight of the nodes of the path from  to ,
			excluding , is at least .\\
 &  .\\
 & The -weight of the children of . \\
 & The  weight of  and its left siblings. \\
 & The leftmost child  of  for which
			. \\
 & The -weight of the proper descendants of . \\
 & The -th character of . \\
 & The index of the `1' character in  that corresponds
			to . \\
 & The index of the `0' character in  that corresponds
			to . \\
 & The node that corresponds to the -th character of . \\
 & The -weight of the nodes that correspond
			to `1' characters of  with index at most ,
			plus the -weight of the nodes that correspond
			to `0' characters of  with index at most . \\
 & The minimum index  for which 
			. \\
\bottomrule
\end{tabular}
\end{table}

\begin{lemma}\label{lem:weighted-tree}
A weighted tree with  nodes and  weight functions with weights
from , where , can be stored using at most
 bits such
that the queries in Table~\ref{tab:weight-queries} are answered
in  time.
\end{lemma}
\begin{proof}
The representation is a variation of the unweighted tree representation
of Navarro and Sadakane~\cite{NavarroS14}.
We first review the latter representation.
Let  be an unweighted tree, and let  be its balanced parenthesis
representation.
Navarro and Sadakane showed that tree queries can be implemented by
supporting a set of \emph{base queries} that include
(1) the queries , , and 
(2) the following queries on  and a function
 from a fixed set of functions :

We note that Navarro and Sadakane used a slightly different definition for
 and , but their technique is easily modified for the
alternative definitions above.

The main idea of Navarro and Sadakane's representation is to partition 
into blocks of size  for some constant .
Each block of  is stored using an aB-tree~\cite{Patrascu08} which
is able to support the base queries on the block in constant time.
The space of an aB-tree is  more than the information-theoretic lower
bound.
Since  is a binary string, the space of one aB-tree is ,
and the space for all trees is .
In order to support base queries on the entire string ,
Navarro and Sadakane added additional data-structures.
The space of the additional data-structures is .
Thus, by choosing large enough , the additional space is .

For example, for supporting  for a function ,
a tree  is constructed with weights from  on its edges,
and a weighted ancestor data-structure is built over .
The tree  is defined as follows.
Let  be the maximum value of  for an
index  that belongs to the -th block of .
The nodes of  are .
A node  is a child of node , where  is the minimum index for which
 and . The edge between these nodes have weight
.
If no such index exists,  is a child of node .
A  query is answered by first checking whether
the answer lies in the block of  (using the aB-tree that stores the block).
If not, a weighted ancestor query
on  finds the block in which the answer lies, and the location
inside the block is found using the aB-tree storing this block.

We now describe our representation for weighted trees.
Let  denote the balanced parenthesis representation of .
Define a string  of length  in which each
character is a tuple of  elements.
For an index , the tuple  is ,
where  is the node that corresponds to .
As for the case of unweighted trees, it suffices to support
(1) the weighted tree queries
, , and 
(2) , ,  and  queries on the
string  and a function  (from a fixed set of functions )
which has the form

where  denotes the -th coordinate of 
(we also denote ).
To support the base queries,  is partitioned into blocks and each block
is stored using an aB-tree.
The space of one aB-tree is now .
Thus, the total space of the aB-trees is .
Additionally, since now the range of a function  is 
whereas the range is  for unweighted trees,
the space of the additional data-structures is increased
by a factor of at most 
(for example, the  trees have now edge weights from 
and thus require more space).
Since , we can ensure the additional space is 
by increasing  by .
\end{proof}

\subsection{Tree decomposition}
In the next lemma we present a tree decomposition that we will use in
our labeled tree representation.
The decomposition is slightly modified version of the decomposition of
Farzan and Munro~\cite{FarzanM08}.
An example for the decomposition is given in Figure~\ref{fig:decomposition-new}.
\begin{lemma}\label{lem:tree-cover}
For a tree  with  nodes and an integer , there is a collection
 of subtrees of  with
the following properties.
\begin{enumerate}
\item\label{enum:cover}
Every edge of  appears in exactly one tree of .
\item\label{enum:size}
The size of each tree in  is at most .
\item\label{enum:number}
The number of trees in  is .
\item\label{enum:interval}
For every tree  there are two intervals of integers
 and  such that a node  is
a non-root node of  if and only if ,
where  is the preorder rank of  in .
The node with preorder rank 
is called the \emph{special node} of .
\item\label{enum:special}
For every , only the root and the special node of 
can appear in other trees of .
\end{enumerate}
\end{lemma}
\begin{proof}
We first construct the decomposition of Farzan and Munro~\cite{FarzanM08}
(see Figure~\ref{fig:decomposition-old} for an example), which
satisfied the properties of the lemma, except for property~\ref{enum:cover}.
It also satisfies stronger versions of properties~\ref{enum:size}
and~\ref{enum:special}: Each tree in the decomposition has size at most ,
and the common node of two trees in the decomposition can be only the root of
both trees.
Moreover, for a tree  in the decomposition,
for every edge  between a node  and a node ,
 is the root of , except perhaps for one edge.

We now change the decomposition as follows
(see Figure~\ref{fig:decomposition-new}).
First, for every edge  for which  and  are in different trees,
if  is not a root of a tree in the decomposition,
add the node  to the unique tree containing .
Note that in this case, the tree also contains the predecessor of  in the
preorder, so property~\ref{enum:interval} is maintained.
Otherwise, add a new tree to the decomposition that consists of the nodes
 and .
After the first step is performed, remove from the decomposition
all trees that consist of a single node.
It is easy to verify that the new decomposition satisfied all the properties
of the lemma.
\end{proof}
\begin{figure}
\centering
\hfill
\subfloat[\label{fig:decomposition-old}]{
\includegraphics[scale=0.5]{figs/decomposition}}
\hfill
\subfloat[\label{fig:decomposition-new}]{
\includegraphics[scale=0.5]{figs/decomposition2}}
\hfill
\subfloat[\label{fig:decomposition-TL}]{
\includegraphics[scale=0.5]{figs/TL}}
\hfill\hspace*{0pt}
\caption{Example of tree decomposition using .
Figure~(a) shows the decomposition of Farzan and Munro,
and Figure~(b) shows are modified decomposition.
Figure~(c) shows the tree .
}
\end{figure}

For a tree  and an integer  we define a tree  as follows
(see Figure~\ref{fig:decomposition-TL}).
Construct a tree decomposition  according to
Lemma~\ref{lem:tree-cover}.
If the root  of  appears in several trees of ,
add to  a tree that consists of .
The set of nodes of  is the set .
For two trees ,  is the parent of  in 
if and only if the root of  is equal to the special node of 
(or  is the tree that consists of ).

\section{Representation of labeled trees}
As in He et al.~\cite{HeMZ12}, we build trees  for every
.
To build , we temporarily add to  a new root with
label .
Then, let  be the set of all -nodes in  and
their parents.
The nodes of  are the nodes of , and  is a parent of
 in  if and only if  is the lowest (proper) ancestor of 
that appears in .
Unlike He et al., we do not store the tree .
Instead, we store a weighted tree that contains only part of the information
of .
The weighted tree is the tree  obtained from
the tree decomposition of Lemma~\ref{lem:tree-cover}.
For the case  the value of  is
, where  is a function that satisfies ,
and for large  set .
Denote by  the number of -nodes in .
We say that a character  is \emph{frequent} if .
We only construct the trees  for frequent characters.

For a node  in , let  be the set
of all -nodes in the tree , excluding the root of .
Let  be the leftmost -child of the root of 
among the nodes of .
We define the following weight functions for .
\begin{enumerate}
\item  is the number of nodes in .
\item  is the number of nodes in 
whose preorder rank in  is
less than or equal to the preorder rank the special node of .
\item  is equal to .
\item  is the number of nodes in 
which are ancestors of the special node of .
\item  is the number of -children of the
root of .
\item  is the rank of  among the nodes
of , when the nodes are sorted according to preorder
(if  does not exist, ).
\item  is equal to  if the special node of
 is an -node, and  otherwise.
\end{enumerate}

Our representation of  consists of the following data-structures.
We store a rank-select structure on , using one of the structures of
Theorem~\ref{thm:rank-select} according to the size of the alphabet.
We also store an unlabeled tree  obtained from  by
removing the labels.
 is stored using Theorem~\ref{thm:unlabeled-tree}.
We also store the trees .
In order to reduce the space, we do not store these trees individually.
Instead, we merge them into a single tree .
The tree  contains a new root node, on which the trees 
are hanged, ordered by increasing values of .
The tree  is stored using the representation of
Lemma~\ref{lem:weighted-tree}.
In order to map a node of 
to the corresponding node of , and vice versa, we store
the rank-select structure of Theorem~\ref{thm:rank-select-binary}
on the string , where
 are the frequent characters.
We also store the rank-select structure of Theorem~\ref{thm:rank-select-binary}
on a binary string  of length  in which  if
 is frequent.
Since a mapping between nodes of  and nodes of  can
be computed in constant time, in the following we shall assume that the trees
 are available.

We now analyze the space complexity of the representation.
The space for  is  bits for small alphabet,
and  bits for large alphabet.
The space for  is  bits.
The tree  has  nodes, and the weight functions have ranges
. Thus, the space for  is  bits.
The strings  and  have at most  zeros and at most  ones.
Thus, the space for the rank-select structures on these strings is
 bits.
Therefore, the total space of the representation
is  for small alphabet,
and  for large alphabet.

In the following, when we use an unlabeled tree operation
(e.g., ) we assume that the operation is performed on
, and when we use a weighted tree operation  we assume that the
operation is performed on .

\subsection{Mapping from  to }

Let  be a node of .
From property~\ref{enum:interval} of Lemma~\ref{lem:tree-cover} there are
two intervals  and 
such that an -node  of  is a non-root node of 
if and only if the rank of  among all the -nodes of ,
sorted in preorder, is in one of the intervals.
These intervals can be computed as follows:

The set  can be computed with

and  can be computed with ,
where  if
,
and  otherwise.

\subsection{Mapping from  to }
Let  be a node of  and  be a frequent character.
If , we want to compute the node  such
that .
We denote this node by .
Additionally, we compute whether  is the special node of .

We consider two cases. The first case is when  is an -node.
Then,

Moreover,  is the special node of  if and only if
 and .

Now suppose that  is not an -node.
The algorithm for computing  is as follows.
\begin{enumerate}
\item
Let  and  be the -descendants of  with minimum and maximum
preorder ranks, respectively
( are computed using the structures on  and ).
If  do not exist return .
\item
Compute  and .
\item
If 
\begin{enumerate}
\item
If  return .
\item
Compute .
If  then
 and  is the special node of .
Otherwise,  and  is not the special node.
\label{alg:x-not-lca}
\end{enumerate}
\item
If 
\begin{enumerate}
\item
If  is an ancestor of  (including ), compute .
Scan the nodes of  and check for each node whether it is a child of .
If no child of  was found, return .
Compute . If  exists and 
then  and  is the special node of .
Otherwise,  and  is not the special node.
\item If  is a proper ancestor of , 
handle this case analogously to the handling of the previous case.
\item If neither node  or  is an ancestor of the other,
 and  is the special node of .
\end{enumerate}
\end{enumerate}
To see the correctness of the algorithm above, observe that
if  do not exist then  does not have -children.
Since  is not an -node, by definition .
Now suppose that  exist.
If , the only possible -child of  is .
Thus, if  then .
If  then  is a node of .
By the definition of ,  is not the root of ,
and therefore the node  is also a node of .
Thus,  if  is the root of , and
 otherwise.
Since  is the only -child of , it follows that the former case
occurs if and only if .

Now consider the case .
Denote by  and  the ancestors of  and  that are
children of  in .
By the definition of  and , if  has -children then
every -child  of  is between  and  in .
If   is an ancestor of  then  and  must belong to the
tree .
Thus, all the -children of  (if there are any) belong to .
Therefore, it suffices to scan the nodes of  in order to decide
whether  has -children.
If  has -children then these children are non-root nodes of .
It follows that  belongs to the tree .
Moreover,
 if  is the root of , and
 otherwise.

\subsection{Answering queries}
In this section describe how to implement the queries of
Table~\ref{tab:labeled-queries}.
The queries , , ,
 and  are answered as in~\cite{HeMZ12}.
Answering the remaining queries is also similar to~\cite{HeMZ12},
but here additional steps are required as a weighted tree 
holds less information than .
The general idea is to use the tree  to get an approximate
answer to the query. Then, by enumerating the nodes of constant number
of  set, the exact answer is found.
The time complexity of answering a query is thus ,
where  is the time for a select query on .
Since  for small alphabet
and  for large alphabet,
it follows that the time for answering a query is  for small alphabet
and  for large alphabet.

We assume that  is a frequent character until the end of the section.
Handling queries in which  is non-frequent is done by enumerating all
the -nodes in .

\subsubsection{ query}
We consider two cases.
If  is an -node the query is answered as follows.
\begin{enumerate}
\item Compute .
\item Compute . Scan the nodes of  in reverse order,
and check for each node  whether  is an ancestor of .
If an ancestor of  is found, return it.
\item
Compute .
If  does not exist return .
\item
Compute . Scan the nodes of  in reverse order,
and check for each node  whether  is an ancestor of .
When an ancestor of  is found, return it.
\end{enumerate}
If  is not an -node then the query is answered as
in He et al.~\cite{HeMZ12}.




\subsubsection{ query}
\begin{enumerate}
\item
Let  if  is an -node, and  otherwise.
\item
Compute .
\item
Compute  and scan the nodes of .
Count the number of nodes that are ancestors of ,
and let  denote this number.
\item
Return .
\end{enumerate}

\subsubsection{ query}
\begin{enumerate}
\item
Compute .
If  does not exist return .
\item
If  return .
\item
Compute .
\item
Compute . Scan the nodes of  in reverse order.
For each node , if  is an ancestor of , decrease  by .
If  becomes  return , and otherwise continue with the scan.
\item
Compute .
If  does not exist return .
\item
Set .
\item
Compute . Scan the nodes of  in reverse order.
For each node , check whether  is an ancestor of .
If  is an ancestor, decrease  by .
If  becomes  return , and otherwise continue with the scan.
\end{enumerate}

\subsubsection{ query}
\begin{enumerate}
\item
Compute .
If  does not exist return .
\item
If  is not the special node of ,
compute  and scan the nodes of .
Return the number of nodes that are children of .
\item
Return .
\end{enumerate}

We now explain the correctness of the algorithm above.
If  is not the special node of  then all the children of 
in  are in the tree . Thus, it suffices to scan .
If  is the special node, the set of -children of  is
precisely the set of -children of the roots of all trees 
such that  is a child of  in .
Therefore, .

\subsubsection{ query}
If  is an -node the query is answered as follows.
\begin{enumerate}
\item
Compute .
\item
Compute  and scan the nodes of .
Count the number of nodes that are left sibling of ,
and let  denote this number.
\item
Compute  and .
\item
If  is not the special node of  return .
\item
Return .
\end{enumerate}
We now consider the case when  is not an -node.
\begin{enumerate}
\item
Compute  and .
If  does not exist return .
\item
If  is not the special node of ,
compute  and scan the nodes of .
Return the number of nodes that are left sibling of .
\item
Let  be the -predecessor.
If  does not exist or if 
return .
\item
Compute .
\item
Let  be the child of  which is an ancestor of .
\item
Compute  and scan the nodes of .
Count the number of nodes that are left sibling of ,
and let  denote this number.
\item
Return .
\end{enumerate}

\subsubsection{ query}
\begin{enumerate}
\item
Compute .
If  does not exist return .
\item
If  is not the special node of , compute  and scan the nodes of .
For each node , check whether  is a child of .
Return the -th child.
\item
Compute .
\item
Set .
\item
Compute  and scan the nodes of .
For each node , check whether  is a child of .
Return the -th child.
\end{enumerate}

\subsubsection{ query}
\begin{enumerate}
\item
Return .
\end{enumerate}



\bibliographystyle{plain}
\bibliography{string-index}
\end{document}
