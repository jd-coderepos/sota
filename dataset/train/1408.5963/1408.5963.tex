\documentclass[copyright,creativecommons]{eptcs}
\providecommand{\event}{GandALF 2014} \usepackage{breakurl}             \usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{verbatim}

\newtheorem{theorem}{Theorem}[section]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{claim}[theorem]{Claim}

\title{Infinite Networks, Halting and Local Algorithms}
\author{Antti Kuusisto\thanks{The author acknowledges that
this work was carried out during a tenure of the
ERCIM ``Alain
Bensoussan" Fellowship Programme.
The reported research has received funding from the
European Union
Seventh Framework
Programme (FP7/2007-2013) under
grant agreement
number 246016.}
\institute{Institute of Computer Science\\ University of Wroc\l aw\\ Poland}
\email{antti.j.kuusisto@uta.fi}
}
\def\titlerunning{Infinite Networks, Halting and Local Algorithms}
\def\authorrunning{A. Kuusisto}
\begin{document}
\maketitle

\begin{abstract}
The immediate past has witnessed an increased amount of interest in local algorithms, i.e., constant time distributed algorithms. In a recent survey of the topic (Suomela, ACM Computing Surveys, 2013), it is argued that local algorithms provide a natural framework that could be used in order to theoretically control infinite networks in finite time. We study a comprehensive collection of distributed computing models and prove that if infinite networks are included in the class of structures investigated, then every universally halting distributed algorithm is in fact a local algorithm. To contrast this result, we show that if only finite networks are allowed, then even very weak distributed computing models can define nonlocal algorithms that halt everywhere. The investigations in this article continue the studies in the intersection of logic and distributed computing initiated in (Hella et al., PODC 2012) and (Kuusisto, CSL 2013).




\end{abstract}

\section{Introduction}








This work is a study of deterministic distributed algorithms for arbitrary networks,
including infinite structures in addition to finite ones.
In the recent survey article \cite{suomela}, Suomela points out that distributed constant-time algorithms are a reasonable
choice for theoretically controlling infinite networks in finite time. In this article we show that for a rather comprehensive
collection of models of distributed computing, constant-time algorithms are in a
sense the \emph{only} choice. We define a
framework---based on a class of message passing automata and relational structures---that contains a
comprehensive variety of models of distributed computing in \emph{anonymous networks}, i.e., networks
without -numbers.
We then show that if infinite networks are allowed,
then \emph{all universally halting algorithms} definable in the framework are in fact local algorithms, i.e.,
distributed constant-time algorithms. 






The widely studied \emph{port-numbering model} (see \cite{angluin, hella, hella2})
of distributed computing can be directly extended to a framework that contains infinite structures
in addition to finite ones.
In the port-numbering model, a node of degree , where  is a globally known
finite degree bound, receives messages through  input ports
and sends messages through  output ports.
The processors in the nodes can send different messages to different neighbours,
and also see from which port incoming messages arrive.
There are no -numbers 
in this framework. The omission of -numbers is well justified when infinite
networks are studied: in most natural theoretical frameworks for the
modelling of computation in infinite networks,
\emph{even the reading of all local s in the 
beginning of computation would take infinitely long}. Thus typical synchronized
communication using -numbers would be impossible.




There are several fields of study outside distributed computing
where the objects of investigation can be regarded as infinite
distributed anonymous communication networks.
\emph{Cellular automata}
provide probably the most
obvious and significant example of such a framework.
But of course there are various others.
Crystal lattices and the brain, for example, are 
massive network systems often modelled by infinite structures.




Below we define a \emph{general  
distributed computing model} based on relational structures and synchronized message passing automata.
The port-numbering model  of \cite{hella, hella2} and all its subclasses can be directly
simulated in our framework by restricting attention to suitable
classes of structures and automata.
We establish (Theorem \ref{maintheorem}\hspace{0.4mm}) that if  is a class of
communication networks definable by a 
\emph{first-order theory}, then all universally halting algorithms over  are local algorithms.
For example, the classes of networks for the  model are easily seen to be definable by
first-order formulae, \emph{as long as infinite structures are allowed}.
In fact, when the requirement of finiteness is lifted,
all classes of structures in the comprehensive study
in \cite{hella, hella2} can easily be seen to be first-order definable.




The proof of Theorem \ref{maintheorem} makes a \emph{crucial use of logic},
thereby extending the work initiated in \cite{hella, hella2}
and developed further in \cite{kuusi}.
The articles \cite{hella, hella2, kuusi} extend the scope of \emph{descriptive complexity theory}
(see \cite{ebbinghaus, Immerman, libkin}) to the realm of distributed computing by identifying a
highly canonical one-to-one link between \emph{local} algorithms and
formulae of modal logic.
This link is based on the novel idea of 
directly identifying \emph{Kripke models}
and distributed communication networks with each other.
Under this interpretation, arrows of the accessibility relations of
Kripke models are considered to \emph{\textbf{be}} communication channels
between processors in distributed networks.
This idea has turned out to be fruitful because it enables the
transfer of results between modal logic and distributed computing.
For example, in \cite{hella, hella2} a novel separation argument
concerning distributed complexity classes is obtained by applying the
\emph{bisimulation method} (see \cite{johan, han, blackburn}) of modal logic to
distributed communication networks.




In this article we adapt the link between modal logic
and distributed computing for the purpose of
proving Theorem \ref{maintheorem}\hspace{0.4mm}.
We first obtain a characterization of 
halting behaviour in terms of modal formulae.
This facilitates the use of the \emph{compactness theorem} (see \cite{ebbinghaus}),
which is the final step in our  proof.




To contrast Theorem \ref{maintheorem}\hspace{0.4mm}, we investigate halting
behaviour of distributed message passing automata in the finite.
We establish that even extremely weak subsystems of the port-numbering model
can define nonlocal halting algorithms when attention is restricted to
finite networks:
Theorem \ref{secondmain} shows that even if message passing automata in the port-numbering
model have absolutely no access to port numbers whatsoever,
nonlocal but universally halting behaviour is possible.


In order to prove Theorem \ref{secondmain}\hspace{0.4mm}, we employ tools from
\emph{combinatorics on words}, namely, the 
infinite \emph{Thue-Morse sequence} (see \cite{allouche}). This infinite binary sequence is known to be cube-free,
i.e., it does not have a prefix of the type , where  is a nonempty word. This 
lack of periodicity allows us to design an appropriate algorithm that is halting but nonlocal
in the finite.




\begin{comment}
The current article continues the logic based investigations into the theory of distributed computing
initiated in \cite{hella, hella2} and developed further in \cite{kuusi}.
There are several possible related future research directions that could
and should be followed. The article \cite{hella} and the current article
investigate anonymous models by using tools of modal logic.
\emph{Hybrid logic} (see \cite{Areces}) is a subfield of modal logic that investigates
systems extended with so-called \emph{nominals}, which are objects that are true in exactly one
node of each model, and therefore naturally correspond to -numbers.
It would be interesting to see how this link could be used.
\end{comment}




\begin{comment}




\textbf{Related locigal work} In this work we investigate distributed systems from the point of
view of the so called \emph{port-numbering model}.
In the recent article \cite{hella}, Hella and co-authors
identify a highly natural connection between modal logic \cite{blackburn} and local distributed algorithms.
While modal logic has been succesfully applied in the distributed computing context
before, the fresh perspective in \cite{hella} is a radical departure from
the traditional approaches, where the domain elements of a Kripke model correspond
to possible states of a distributed computation process.
In the framework of \cite{hella}, a distributed system
\emph{\textbf{is}} a Kripke model, where the domain elements are individual computers and the
arrows of the accessibility relation are communication channels. While such an interpretation
is of course always possible, it turns out to be particularly helpful in the study of
\emph{weak models of distributed computing} (see \cite{hella, surveysuomela}).
The article \cite{hella} identifies \emph{descriptive characterizations} for a comprehensive
collection of \emph{complexity classes of distributed computing} in terms of modal logics.
For example, it is shown that the class  is 
\emph{captured}---in the sense of descriptive complexity theory \cite{Immerman, ebbinghaus, libkin}---
by ordinary modal logic . A graph property is in  iff it can
be defined by a formula of . Various other characterizations are also obtained.
For example the class  is captured by \emph{graded modal logic}, i.e.,
a modal logic which can count the number of accessible nodes.
Furthermore, the logical characterizations enable the use of logical tools in the investigation
of distributed complexity classes. The article \cite{hella} provides a \emph{complete classification}
of the investigated complexity classes with respect to their computational capacities.  
The proofs behind the related separation results make heavy use of logical methods. In particular,
the notion of bisimulation turns out to be very useful in this context.
While there are various characterization results in classical descriptive complexity theory,
separation results are rare, and related questions  have proved very difficult. 
Therefore the separation results in \cite{hella} are rather \emph{delightful}, since they nicely demonstrate the potential
of the \emph{descriptive complexity approach in the framework of non-classical computing.}
A \emph{local algorithm}
\cite{surveysuomela}
is a distributed algorithm that a distributed system carries out by executing a fixed finite number of
synchronized \emph{communication rounds}. (Our example above concerning the property P is an example of a local algorithm.)
The characterizations in \cite{hella} concern local algorithms carried out by
\emph{message passing automata} that run in constant time.
\end{comment}




\section{Preliminaries}\label{preliminaries}








Let  be a finite  set of
\emph{unary relation symbols}  and  a finite set of
\emph{binary relation symbols} . These symbols are also called
\emph{predicate symbols}. 
The set of -\emph{formulae} of \emph{modal logic} 
is generated by the grammar

where  is any symbol in ,   any symbol in , and  is a logical constant  symbol.
Let  
be a set of \emph{variable symbols}. 
The set of -\emph{formulae} of \emph{first-order logic}  
is generated by the grammar

where  and  are symbols in ,
 a symbol in ,   a symbol in , and  a logical constant  symbol.
For both logics, we define the abbreviation . We also
use the abbreviation symbols ,  and  in the usual way.
The \emph{modal depth}  of a formula is defined recursively such that
, ,
, and
.




Let  and .
A -\emph{model} 
is a structure

where  is an arbitrary nonempty set (the \emph{domain}
of the model ), 
each  is a unary relation , and
each  a binary relation .
The semantics of  is defined
with respect to \emph{pointed -models}
, where 
is a -model and  a \emph{point} or a \emph{node} of (the
domain of) .
For each , we define  iff . We also define .
We then recursively define

The semantics of  is defined
in the usual way with respect to \emph{-interpretations}
, where

is a -model and  is an \emph{assignment function}
 giving an interpretation to the variables in .
We define , ,
and . We also define .
We then recursively define

where  is the function  such that

It is well known that modal logic can be directly translated into first-order logic.
We define the \emph{standard translation} from  into  in
the following way. We let , ,
,
, and .
Here  is a fresh variable distinct from .
It is easy to see that  iff
. 
Due to the standard translation, modal logic is often 
considered to be simply a \emph{fragment} of first-order logic.




We next fix some conventions concerning \emph{sets}
of formulae. We only discuss formulae of first-order logic,
but analogous definitions hold for modal logic.




If  is a set of formulae of ,
then  and  denote the \emph{disjunction} and
\emph{conjunction} of the formulae in . The set  can be infinite, but 
then of course neither  nor  is a formula of 
.
We define  if there exists at least one formula  such that .
We define  if  for all .
A \emph{set} of formulae of 
is called a \emph{theory} (over the
signature ).\hspace{0.4mm}\footnote{A theory does not have to be closed under
logical consequence. A theory is simply a set of formulae, and
can be infinite or finite.} If  is a theory over the signature ,
then  means that  for all .
When we write , we mean that
the implication  holds
for all -interpretations .
As usual, two -formulae  and 
are \emph{equivalent} if the equivalence  holds
for all -interpretations .




Let  be a class of \emph{pointed} -models, and let .
A modal formula  \emph{defines} the class  \emph{with respect to} , if
for all , we have .
If some formula  defines a class  of pointed -models with respect to the
class of all pointed -models, we simply say that  defines .




If  is a \emph{sentence} of  
and  a -model,
we write  if 
for some assignment . (Trivially, whether  holds or not, does not
depend on  when  is a sentence.)
If  is a theory consisting of -sentences,
we write  iff  for all .
Let  be a class of \emph{pointed} -models
and  a theory consisting of \emph{-sentences}.
We say that the \emph{first-order theory  defines the class 
of pointed models} if for all pointed -models , we have
.
Notice indeed that accoring to this convention, if 
defines a class  of pointed models
and if  is a point in
the domain of  and  a pointed model in , then
we have .
If a first-order theory  defines a class  of pointed models,
then we say that  is \emph{definable} by
the first-order theory .
If  is definable by a theory  containing a
single first-order -sentence , we say that 
is definable by the first-order sentence .




Let  and  be finite sets of unary and
binary relation symbols, respectively.
A \emph{message passing automaton}  over the signature 
, or a -automaton,
is a tuple

defined as follows.
 is a nonempty set of \emph{states}.  can be finite or countably infinite.
 is a nonempty set of \emph{messages}.
 can be finite or countably infinite.
For a set , we let  denote the power set of .
 is an \emph{initial transition function} that
determines the beginning state of the automaton . 
is a \emph{transition function} that constructs a new state 
when given a -tuple  of received message sets
and the current state.  is a \emph{message construction function}
that constructs a message for the automaton to send forward when given the current state of the automaton and a
\emph{communication channel} .
 is the set of \emph{accepting states} of the automaton.
 is the set of \emph{rejecting states} of the automaton.




Let  and .
Let  be a -model. The set of -\emph{predecessors} of  is the set of
nodes  in the domain of  such that , and the set of -\emph{successors} of  is
the set of nodes  such that . The set of -successors of  is denoted by .




A message passing -automaton  
is \emph{run} on a -model ,
considered to be a distributed system. We first give an intuitive
description of the computation of the distributed system defined by
the automaton  and the model , and then define the computation
procedure more formally.




On the intuitive level, we place a copy  of the automaton  to each node .
Then, each automaton   first scans the \emph{local  information} of the node , i.e.,
finds the set of unary relation symbols  such that , and then makes a transition to
a \emph{beginning state} based on the local information.
The local information at  can be considered to be an -bit string  of zeros and ones such
that the -th bit of  is  iff .
After scanning the local information, the automata , where ,
begin running in \emph{synchronized steps}. During
each step, each automaton  sends, for each , a message  to the
-\emph{predecessors} of .\hspace{0.4mm}\footnote{Therefore information flows opposite to the direction of
the arrows (i.e., ordered pairs) of . The reason for this choice is technical, and could be avoided.
The choice is due to the relationship between modal logic and message passing automata.
A possible alternative approach would be to consider modal logics with the truth of 
defined such that 
iff .}
The automaton  also receives a tuple  of message sets  such that
set  is received from 
the -successors of . Then the automaton updates its state based on the received messages and
the current state.




More formally, a -model  
and a -automaton

define a
synchronized distributed computation system which executes \emph{communication
rounds} defined as follows. Each round  defines a \emph{global configuration} .
The configuration  of the zeroth round is the function  such that 
for all .
Recursively, assume that we have defined ,
and let 
be a tuple of message sets 

Then
.




When we talk about \emph{the state of the automaton  at the node  in round }, we mean
the state . We define that an automaton  \emph{accepts} a
pointed model  if there exists some 
such that , and furthermore, for all , .
Similarly,  \emph{rejects}  if there exists some 
such that , and for all , . 
Notice that  may keep passing messages and changing state even after it has accepted or rejected.
Automata that stop sending messages after accepting or rejecting can be 
modelled in this framework by automata that begin sending only the message
``I have halted" once they have accepted or rejected.
(Notice that the behaviour of the distributed system does not
have to be Turing computable in any sense.)




Let  be the class of all pointed -models. Let .
We say that  accepts (rejects) 
if the class of pointed models in  that  accepts (rejects) is .
Let .
We say that  accepts (rejects)  in 
if the class of pointed models in  that  accepts (rejects) is .
A -automaton 
\emph{converges} in the class  if for all , the automaton  either
accepts or rejects .
A -automaton 
\emph{halts} in 
if  converges in , and furthermore,
for each state  that is obtained by 
at some , the state of  at 
will be  forever once  has been obtained for the first time.
We say that the automaton  \emph{specifies a local algorithm} in 
if there exists some  such that for all ,
the automaton  accepts or rejects  in some round .
The smallest such number  is called the \emph{effective running time} of  in .
For the sake of curiosity, note that even if  specifies a local algorithm, it
does not necessarily halt. However, a corresponding halting automaton of course exists.




Let  be a class of pointed -models.
When we say that an algorithm  (or more 
rigorously, a -automaton ) is \emph{strongly
nonlocal} in , we mean that there exists no -automaton
 that specifies a local algorithm in  and accepts
exactly the the same pointed models in  as .





Our framework with -automata
operating on -models is rather flexible
and general. For example, each system in 
the comprehensive collection of
\emph{weak models of distributed computing}
studied in \cite{hella, hella2} can be directly
simulated in our framework by restricting attention to suitable
classes of -structures and -automata.
Let us have a closer look at this matter.








Let  and let  be any finite set.
If  is -model, where  is a symmetric and irreflexive binary relation, then
 is an \emph{-model}. The letter  stands
for the word \emph{set} and the letter  for \emph{broadcast}.
The intuition behind the framework provided by -models is that
message passing automata see \emph{neither input port numbers nor output port numbers}.
This means that the state transition of an automaton depends only on the
current state and the \emph{set} of messages received---rather than
the multiset for example---and an
automaton must \emph{broadcast} the same message to \emph{each} of its
neighbours during a communication round.
It is not possible to send different messages to different neighbours during the
same communication round.




The framework provided by -models is similar to
the weakest (in computational capacity) computation model  studied in \cite{hella, hella2}.
In fact, the framework of -models in the current paper is a canonical
generalization of the model  in \cite{hella, hella2}.
In the article \cite{hella, hella2}, all \emph{classes} of structures
studied are always associated with a finite maximum degree bound,
and furthermore, all structures are assumed to be finite.
In the current article, such restrictions need not apply.
Also, we allow arbitrary interpretations of the unary relation symbols in ,
while in the  model of \cite{hella, hella2}, unary relation symbols
always indicate the degree of a node in a network (and nothing else).\hspace{0.4mm}\footnote{We 
do not need the to define the  model
used in \cite{hella, hella2} for the purposes of the current article.
For the precise definition, see \cite{hella, hella2}. It is worth mentioning here once more, however,  
that all systems studied in \cite{hella, hella2} can be directly simulated in our framework
by simply restricting attention to suitable automata and suitable classes of pointed models.}
The reason for generalizing the definition of \cite{hella, hella2} is that in the current paper
we opt for generality as well as increased mathematical simplicity.
The philosophy in \cite{hella, hella2} is more application oriented.















Let  and .
Let  and .
A pointed -model  is an \emph{-port-numbering structure}, or a -structure,
if it satisfies the following (admittedly long and technical, and for the 
current paper rather unimportant) list of conditions.
\begin{enumerate}
\item
The union  of the relations  is a symmetric and irreflexive
relation.
\item
For any two distinct pairs , if , then  does not hold.
\item
For each , if , then .
\item
For each , the out-degree and in-degree of  is at most one at each node.
\item
If  for some nodes  and  and some ,
then, if , there exists some  and some node  such that .
\item
Similarly, if  for some nodes  and  and some ,
then, if , there exists some  and some node  such that . 
\item
Finally, for each node  and each , we have  if and only if the out-degree
(or equivalently, in-degree) of the union  of all the relations in  is  at .
\end{enumerate}




It is straightforward to show that there exists a first-order -sentence
 that defines the class  of all -structures.
This piece of information will be used in the very end of the current article when
we discuss concrete applications of Theorem \ref{maintheorem}\hspace{0.4mm}.
The class of \emph{finite}
-structures is \emph{exactly} the collection of communication networks of
maximum degree at most  used in the framework of 
the port-numbering model  of \cite{hella, hella2}.
The related collection of \emph{-algorithms}
corresponds to the class of algorithms that can be specified by -automata
that halt in all finite -structures.
Therefore the class  of 
exactly all -structures, together with -automata, defines a
generalization of the port-numbering model to the context with infinite structures in addition to
finite ones. Theorem \ref{maintheorem} shows that all halting algorithms for 
are constant-time algorithms.
There are no nonlocal halting algorithms in the framework of the port-numbering model when infinite structures are
included in the picture.




The port numbering model  has been studied
extensively since the 1980s. The related investigations
were originally initiated by Angluin in \cite{angluin}.
Section 3 of \cite{hella2} gives a brief and accessible
introduction to the port-numbering model and
its relation to other models of distributed computing.








\begin{comment}
Let  be a finite set of proposition symbols. Let  be a class
of Kripke frames of the vocabulary , and assume that there exists some message passing
automaton  of the vocabulary  that accepts a pointed -model  iff
. Then we say that  is -recognizable.
If  is -recognizable by a finite message passing automaton,
we say that  is -recognizable. The class of exactly all -recognizable
classes of pointed models is denoted by MPA-Regular. The class of exactly all -recognizable
classes of pointed models is denoted by FMPA-Regular. (Note that we do not limit attention to finite pointed models
here. The logical characterization results below hold with or without the restriction 
of attention to finite pointed models.)
\end{comment}








\section{Halting in the Finite}\label{finite}




In this section we prove that when 
attention is restricted to finite structures, halting
and strongly nonlocal algorithms exist
even when the model of computing is defined by -models.
While the existence of such algorithms may not be surprising,
it is by no means a trivial matter. Indeed, as we shall see in Section \ref{arbitrary}\hspace{0.4mm},
no such algorithms exist when infinite structures are included in the picture. 





Let  and .
We will show that there exists a
strongly nonlocal algorithm that halts in the class of finite -models.




We begin by sketching a \emph{rough} intuitive description of the algorithm.
The unary relation symbols  and  will be used in order to define binary words in 
that correspond to \emph{finite walks} in -models.\hspace{0.4mm}\footnote{
A finite walk in a -model  is a function from some initial segment of 
into the domain of  such that 
 for each pair  of indices in
the domain of . A finite word  \emph{corresponds} to a walk 
iff we have  for each .}
Each pair , where  is an automaton and  a node,
will store a dynamically growing set of increasingly long finite binary words that correspond to 
walks that originate from . The walks will be oriented by the relation symbols ,  and 
such that if a node  is labelled by , then its successor is labelled by ,
where  
is the cyclic permutation .
A pair  will halt if it records some word  that contains a
\emph{cube} as a factor, i.e.,  a word , where 
 is a \emph{nonempty} word in  and .




Upon halting,  will send an instruction to
halt to its neighbours, who will then pass the message on and also halt. Thus the halting instruction
will spread out in the connected component of , causing further nodes to halt.
In addition to detecting a word with a cube factor, a globally spreading 
halting instruction can also be generated due to the detection of an undesirable
labelling pattern defined by the unary predicates in . For example, if a node 
satisfies both predicates  and , then the labelling pattern at 
is undesirable. The intuition is that then  does not uniquely specify an alphabet in ,
and thereby destroys our intended labelling scheme.
Similarly, a halting instruction is generated if a violation of the cyclic permutation scheme
of the predicates  is detected.




A node accepts iff it halts in a round  for some positive even number .
Otherwise it rejects upon halting.
We shall see that the algorithm is halting and strongly nonlocal in the finite.
Strong nonlocality will follow from the existence of arbitrarily long cube-free finite words.
Indeed, there exists an infinite cube-free word, known as the
\emph{Thue-Morse sequence} (see \cite{allouche} for example).




We then define the algorithm formally.
Let us say that a node 
is a \emph{-node} if .
Similarly,  is a \emph{}-node if

and a \emph{-node} if
.
A node  is \emph{properly oriented} if  is a -node for some ,
and furthermore,  has a -node as a neighbour if and only if .
A node  is \emph{properly labelled} if it is properly oriented, and furthermore, 
either  or .




Let  denote the set , where  is the empty word.
Let  be the set of finite subsets of .
The set of states of the automaton  that defines our algorithm is the set

of quintuples, together with an extra finite set  of \emph{auxiliary states}.
The set of messages is

of triples, together with an additional finite set  of \emph{auxiliary messages}.




We next discuss the intuition behind the definition of the states in .
The first set  of a state 
 of a node  in round  encodes a collection of words corresponding to
walks originating from .
The longer the automaton computes, the longer the words in  get.




The second and third sets  and  are used in order to be able to detect nodes that are not properly labelled.
The second set  (intuitively) encodes the symbol  satisfied by the node :
assuming that the labelling scheme at  is 
fixed such that  or
, then we have  iff  satisfies .
Similarly, the third set  intuitively encodes the symbol  such that .




The fourth and fifth sets  and  control the halting of the node .
A state  is an accepting final state if  and ,
and rejecting final state if  and .
The state  simply counts whether the current computation step is even or odd.




The set  of a message  is a
set of binary words.  corresponds to the language recorded by the sending node.
 encodes the label in  that labels the sending node.
 is a halting instruction if .




In the very beginning of the computation,
the algorithm makes use of the additional states in  
and messages in  in order to locally detect nodes that
are not properly labelled. (It is of course possible that such
nodes do not exist.)
Then, if a node  is proper and , where  and ,
the state of  at  in round 
is set to be .
If  is not proper, then the state of  at  in round  is
set to be , where  and  are fixed arbitrarily.




Let  be the set of messages received by a node  in some round ,
where .
Let  be the state of  in round .
If , then the new state is the same 
state .
Otherwise the new state  is defined as follows.




Let  be the cyclic permutation
.
Assume first that  does not contain a tuple of the form .
Then we define 

We set  and . We let  iff  contains a word with a cube as a factor.
We let .




If  contains a tuple of the form ,
we define ,
where , and ,  and  are fixed arbitrarily.




Let  be the state of  at  in round , where .
If , the  message
broadcast by  at  in round  is , and if , the
message is , where  and   are fixed arbitrarily.




Recall that the automaton  accepts iff it halts in round  for
some positive even number .
The set of accepting states of the automaton  is exactly the set
of states of the type .
The set of rejecting states is the set
of states of the type .




\begin{theorem}\label{secondmain}
Let  be as defined above.
There exists an  automaton  that is halting but
strongly nonlocal in the class of finite pointed -models.
\end{theorem}
\begin{proof}
We shall first establish that the algorithm defined above halts in the class of finite pointed
-models.
Assume that it does not halt in some finite model .
Thus  must be a proper node.
By symmetry, we may assume that .
It is easy to see that for each , the node  must be the first member  of
some finite walk  of proper nodes that satisfy the predicates 
in the cyclic fashion such that
, , ,
,
and so on.
Therefore, since  is a finite model,  the node  must be the first member  of
some infinite walk  of proper nodes that satisfy the predicates  in
the cyclic fashion. The infinite walk must contain a cycle.
The cycle will generate a word with a cube factor that will ultimately be detected at .
Therefore the automaton at  halts. This is a contradiction.




To see that the automaton is strongly nonlocal, we shall consider labelled \emph{path graphs}
that encode finite prefixes of the infinite Thue-Morse sequence.
The labelled path graphs are defined as follows.




Let  denote the infinite Thue-Morse sequence of zeros and ones. The sequence
does not contain a cube factor. For each finite nonempty prefix  of ,
let  denote the
-model  such that the following conditions hold.
\begin{enumerate}
\item
Note first that  is a nonempty prefix of , so   is a function 
 for some .
The domain of the model  is the set .
\item
The model  encodes a path graph, so for each ,
we have  iff .
\item
 encodes the finite prefix  of the Thue-Morse sequence, so
the following conditions hold for each .
\begin{enumerate}
\item
We have  iff .
\item
Similarly, we have  iff .
\end{enumerate}
\item
Let .
For each , we have  iff    .
Thus we observe that each node of , with the exception of the end nodes  and , is
properly labelled. (Recall the definition of proper labelling from the beginning of this section.)
\end{enumerate}




Since there exist structures  of arbitrarily large finite sizes,
and since the Thue-Morse sequence is
cube-free, it is easy to see that our automaton  is strongly nonlocal.
To see this, assume that there exists a automaton  such that
 and  accept (and reject) exactly the same finite pointed -models,
and furthermore,  specifies a local algorithm.
Let  be the effective running time of  in the class
of finite pointed -models. 
(We assume, w.l.o.g., that  is greater than, say, .)
Define the prefixes 
and 
of the Thue-Morse sequence.
Define the pointed models 
and .




Consider the behaviour of our original automaton  on these two
pointed models. We claim that  accepts
exactly one of the two pointed models.
The halting of the pair  in the model 
is caused by detecting a violation of the proper labelling 
scheme  at the end point .
Similarly, the halting of  in the model 
is caused by detecting a violation
at the end point .
The distance from the node  to the node  is
exactly one step greater than
the distance from the node  to the node .
Thus  accepts exactly one of the pointed models

and .




Since the pointed models 
and  look locally similar
to the automaton , whose effective running time is ,
the automaton  cannot differentiate between them.
Thus  does not halt on exactly the same finite
pointed -models as .
This is a contradiction.
\end{proof}




\section{Halting and Convergence in Arbitrary Networks}\label{arbitrary}




In this section we study a 
comprehensive collection of distributed computing models in a setting
that involves infinite networks in addition to finite ones.
We establish that \emph{every} halting distributed algorithm is in fact a local algorithm.
In fact, we show that this result relativises to any class of networks definable by a first-order theory.




The strategy of proof in this section is to first appropriately characterize acceptance and rejection
of automata in terms of definability in modal logic (see Lemma \ref{firstlemma}), and then use the compactness theorem
in order to obtain the desired end result
(see the proof of Theorem \ref{maintheorem}).
The characterizations we obtain extend the
characterizations in \cite{kuusi}.





Let  be a finite set of unary relation symbols, and let
 be a finite set binary relation symbols.
The set  of -\emph{types} 
is defined to be the set containing a conjunction 

for each set , and no other formulae. We assume some standard bracketing and ordering of
conjuncts, so that there is exactly one conjunction for each set  in . Note also
that . The -type 
of a pointed -model  is the unique formula  in 
such that .




Assume then, recursively, that we have defined the set  of -types.
Assume that  is finite, and
assume also that each pointed -model  satisfies \emph{exactly one} type in .
We denote this unique type by . Define

The formula  is the -type of . We assume some
standard ordering of conjuncts and bracketing, so that if two types  and 
are equivalent, they are actually the same formula. We define  to be the set 

We observe that the set  is finite, and that for each pointed -model , there exists
exactly one type  such that .




It is easy to show by a simple induction on modal
depth that each formula  of 
is equivalent to the disjunction of
exactly all -types  such that .
Here  means that for all pointed -models , 
we have . (Note that .)




Define .
A -\emph{type automaton}  
is a -automaton whose set of states is .
The set of messages is also the set .
The initial transition function  is defined such that the state of  at 
in round  is the -type .
The state transition funtion  is defined as follows.




Let . Let  be a sequence of sets  of -types.
Let  be a -type.
If there exists a type 

we define .
Otherwise we define  arbitrarily.
On other kinds of input vectors,  is also defined arbitrarily.





The message construction function  is defined such that  for each .
The sets of accepting and rejecting states can be defined differently
for different type automata.
It is easy to see that the state of any type automaton  at  in round  is 
iff the -type of  is .
















\begin{lemma}\label{firstlemma}
Let  and  be finite sets of unary and binary relation symbols,
respectively. Let  be a -automaton.
Let  be the class of pointed -models.
The class  of pointed models accepted by  is definable
by a (possibly infinite)
disjunction  of formulae of . Also the 
class  of pointed models rejected by  is definable
by a (possibly infinite)
disjunction  of formulae of .
The -type of a pointed -model  is in  iff
the automaton  accepts  in round . Similarly, the -type of 
is in  iff the automaton  rejects  in round .
\begin{comment}
If  specifies a local algorithm in some class  and
  is the class of pointed models accepted by  in ,
then there is a formula of  that defines 
with respect to .
\end{comment}
\end{lemma}
\begin{proof}
Let  be a pointed -model.
Let  be a -automaton.
Let . We let 
denote the state of the automaton  at the node  in round .




We shall first show that for all  and all pointed -models  and ,
if the models  and  satisfy exactly the same -type,
then  
for each  and each -automaton .
We prove the claim by induction on .




For , the claim holds
trivially by definition of the
transition function .
Let  and  be pointed -models that satisfy the same
-type .
Let  be a -automaton and  the transition function of .
Call  and .
Let  be sets of -types such that  is the formula

Since the models  and  satisfy , they must
satisfy the -type . 
By the induction hypothesis, we therefore conclude that 
for each . In particular, .
We must still show that .




Let us define that if  is the set of exactly all -types  such that
, then  is the
\emph{set of -types realized by the -successors of }.




Let .
Since  and  satisfy the same -type ,
the set of  -types realized
by the -successors of the point 
is the same as the set realized by the -successors of ;
that set is  in both cases. Therefore, by the induction hypothesis, the set of
states obtained by the -successors of 
in round  is exactly the same as the set of
states obtained by the -successors of 
in round . This holds for all .
Thus  and  receive exactly the same -tuple of message sets in round .
Therefore, since , we conclude that
, as required.








We have now established that if  an  satisfy the same -type,
then any automaton  produces the same state at  and  in all rounds .
We are ready to complete the proof of the current lemma.




Let  be an arbitrary -automaton.
Let  denote the set 

Let  denote the set of exactly all types  such
that for some , the type  is the -type of 
some pointed -model , and furthermore, the automaton 
accepts  in round . Define the (possibly infinite) disjunction .
We shall establish that for all pointed -models ,
we have  iff 
 accepts . 




Assume that . Thus
 for some -type  of some pointed model 
accepted by  in round .
The models  and  satisfy the same -type ,
and thus  produces exactly the same
state at  and at  in each round .
Therefore  must be accepted by  in round .




Assume that  is accepted by the automaton .
The pointed model  is accepted in some round ,
and thus the -type of  is one of the formulae in .
Therefore .




We have established that  defines the class .
Let  be the class of pointed models
rejected by .
Let  be the set of types  such
that for some , the type  is the -type of 
some pointed -model , and furthermore, the automaton 
rejects  in round . 
By an argument practically identical to the one above establishing that 
is definable by , one can establish that 
defines the class .
\begin{comment}
If  defines a local algorithm in some class ,
then there exists some  such that each pointed model in  is either accepted or
rejected in some round . Let  be the class of
pointed models accepted by  in .
Define  to the set of exactly all types  such that  is the -type
of some  accepted in round . The set  is finite.
An argument practically identical to the argument
discussed above shows that
 defines  with respect to . 
Since  is finite,  is a formula of .
\end{comment}
\end{proof}




\begin{comment}
\begin{lemma}\label{formulatoalgorithm}
Let  and  be finite sets of unary
and binary relation symbols.
Let  be any class of pointed -models.
Let  be a formula of  that defines a class 
of pointed models with respect to .
Then there is a -automaton  that accepts  in .
Furthermore,  specifies a local algorithm in .
\end{lemma}
\begin{proof}
As discussed in the beginning of the current section, each -formula  is equivalent to
the disjunction of -types  such that .
Let  be the set of -types  such that .
Thus the type automaton  whose set of accepting states is , accepts  in .
Now notice that type automata have the property that no state can be visited twice.
Hence, since  is a finite set of states of , and since  is a type automaton,
we can transform  into an automaton  that specifies a local algorithm in 
and accepts  in .
\end{proof}
\end{comment}




\begin{theorem}[Compactness Theorem, see for example \cite{ebbinghaus}]
Assume  is a set of formulae of\,   such that for each finite
subset  of\, , there exists a -interpretation  such that .
Then there exists a  -interpretation  such that .
\end{theorem}




It is a well-known immediate consequence of the compactness theorem that if ,
then there is a finite subset  of  such that .




\begin{theorem}\label{maintheorem}
Let  and  be finite sets of unary
and binary relation symbols.
Let  be the class of all pointed -models. Let 
be a class definable by a first-order -theory.
If a -automaton converges in , then it
specifies a local algorithm in .
\end{theorem}
\begin{proof}
Assume a -automaton  converges in .
Let  be the class of pointed models accepted by  in .
By Lemma \ref{firstlemma}\hspace{0.4mm}, there is a
disjunction   of types that defines  with respect to 
and a disjunction  of types that defines  with respect to .
The -type of a pointed -model  is in  iff
the automaton  accepts  in round . Similarly, the -type of 
is in  iff the automaton  rejects  in round .




Let   be a first-order theory that defines the class .
Call  and
. 
Since  defines  with
respect to  and  defines
 with
respect to , we have .
By the compactness theorem, there is a finite set 
such that .
Let  and .
Define , 
and define ,  and  analogously.
We shall next establish that  defines  with respect to .




Assume .
Thus ,
and hence .
Assume then that .
Therefore .
Since , we have .
Now assume, for the sake of contradiction, that .
Therefore . 
Thus .
Since , we conclude that .
This is a contradiction.




We then establish that 
defines 
with respect to .
Assume .
Thus ,
and hence .
Assume then that .
Therefore .
Since , we have .
Now assume, for the sake of contradiction, that .
Therefore . 
Thus .
Since , we conclude that .
This is a contradiction.




The finite sets  and  are negations of types. Let  be the set of types whose negations are in 
and  the set of types whose negations are in .
Notice indeed that  and .
The disjunction 
defines 
with respect to , and the disjunction  defines 
with respect to .




Let  be the greatest integer  such that there is a -type in .
We claim that for each pointed model  in , the automaton  either accepts or rejects 
in some round . To see this, let . Thus ,
and hence  for some -type , where . 
Since , we have .
As we already stated in the beginning of the proof of the current theorem,
the -type of a pointed -model  is in  iff
the automaton  accepts  in round .
Thus the fact that  implies that  is
accepted in round  by . A similar argument applies when .
Therefore  specifies a local algorithm in .
\end{proof}




As we saw in Section \ref{preliminaries}\hspace{0.4mm}, each class  is definable by a related first-order
sentence . Hence all halting algorithms in the port-numbering model 
are local algorithms when infinite networks are allowed.
In Section \ref{finite}\hspace{0.4mm}, we saw that finiteness gives rise to
nonlocal halting behaviour. It would be interesting to
investigate what kinds of other non-first-order properties (in addition to finiteness)
there are that lead to existence of nonlocal halting algorithms.




\section{Conclusion}




We have shown that a comprehensive variety of models of 
distributed computing cannot define universally halting nonlocal algorithms when
infinite networks are allowed.
In contrast, we have shown that in the finite, even very weak models of distributed
computing can specify universally halting nonlocal algorithms.
Our proof concerning infinite networks nicely demonstrates the potential
usefulness of modal logic in investigations
concerning distributed computing.




Our work in this article concerned \emph{anonymous networks},
i.e., networks without -numbers. This choice was due
to the fact that in most natural theoretical frameworks for the
modelling of computation in infinite networks,
even the reading of local s would take infinitely long, and thus synchronized
communication using -numbers would be impossible.
This reasoning still leaves the possibility of investigating asynchronous
computation. A natural logical framework that can accomodate 
-numbers can probably be based on 
some variant of hybrid logic (see \cite{Areces}).
Hybrid logic is an extension of modal logic with \emph{nominals};
nominals are formulae that hold in exactly one node.
It remains open at this stage, however,
how asynchronicity should be treated.  Of course there are numerous possibilities, and
different logic-based frameworks for similar investigations exist,
but we would like to develop an approach that canonically
extends the approach introduced in \cite{hella,hella2}, developed further in \cite{kuusi},
and used in the current article.
































\nocite{*}
\bibliographystyle{eptcs}
\bibliography{generic}
\end{document}
