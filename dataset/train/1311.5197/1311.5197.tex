\documentclass[11pt,a4paper]{article}

\usepackage{geometry}
\geometry{ top=1.0in, inner=1.0in, outer=1.0in, bottom=1.3in}
\usepackage[utf8x]{inputenc}
\usepackage{amsmath, amsthm}
\usepackage{graphicx,amssymb,textcomp,array,amsmath}
\usepackage{algpseudocode} 
\algtext*{EndWhile}\algtext*{EndIf}\algtext*{EndFor}\usepackage{algorithm}

\setlength{\arraycolsep}{0in}


\newcommand{\MC}{M_\times}
\newcommand{\MNC}{M_=}
\newcommand{\MOPT}{M^*}
\newcommand{\bt}{\lambda}
\newcommand{\btopt}{\lambda^*}
\newcommand{\cw}{cw}

\renewcommand{\qedsymbol}{\hfill\rule{2mm}{2mm} \vspace{2mm}} \newcommand{\require}{\textbf{Input: }}
\newcommand{\ensure}{\textbf{Output: }}
\newtheorem{lemma}{Lemma}
\newtheorem{corollary}{Corollary}
\newtheorem{theorem}{Theorem}

\title{Approximating the Bottleneck Plane Perfect Matching\\of a Point Set}

\author{
A. Karim Abu-Affash \thanks{Software Engineering Department, Shamoon College of Engineering, Beer-Sheva 84100, Israel, {\tt abuaa1@sce.ac.il.}} 
\and 
Ahmad Biniaz
\thanks{School of Computer Science, Carleton University, 
                    Ottawa, Canada. Research supported by NSERC.}
\and 
Paz Carmi\thanks{Department of Computer Science, Ben-Gurion University of the Negev, Beer-Sheva 84105, Israel, {\tt carmip@cs.bgu.ac.il.}}
\and
Anil Maheshwari\footnotemark[2]
\and 
Michiel Smid\footnotemark[2]
}
\date{\today}


\begin{document}

\maketitle

\begin{abstract}
A bottleneck plane perfect matching of a set of  points in  is defined to be a perfect non-crossing matching that minimizes the length of the longest edge; the length of this longest edge is known as {\em bottleneck}. The problem of computing a bottleneck plane perfect matching has been proved to be NP-hard. 
We present an algorithm that computes a bottleneck plane matching of size at least  in -time.
Then we extend our idea toward an -time approximation algorithm which computes a plane matching of size at least  whose edges have length at most  times the bottleneck.

{\bf Key words:} plane matching, bottleneck matching, geometric graph, unit disk graph, approximation algorithm.

\end{abstract}


\section{Introduction}
We study the problem of computing a bottleneck non-crossing matching of points in the plane.
For a given set  of  points in the plane, where  is even, let  denote the complete Euclidean graph with vertex set . The {\em bottleneck plane matching} problem is to find a perfect non-crossing matching of  that minimizes the length of the longest edge. We denote such a matching by . The bottleneck, , is the length of the longest edge in . The problem of computing  
has been proved to be NP-hard \cite{Abu-Affash2014}. 
Figure 1 in \cite{Abu-Affash2014} and \cite{Carlsson2010} shows that the longest edge in the minimum weight matching (which is planar) can be unbounded with respect to . On the other hand the weight of the bottleneck matching can be unbounded with respect to the weight of the minimum weight matching, see Figure \ref{weight}.

\begin{figure}[ht]
  \centering
\setlength{\tabcolsep}{0in}
  
  \caption{(a) bottleneck matching, (b) minimum weight matching.}
\label{weight}
\end{figure}

Matching and bottleneck matching problems play an important role in graph theory, and thus, they have been studied extensively,  e.g.,~\cite{Abu-Affash2014, Aloupis2013, Chang1992, Efrat2001, Efrat2000, Vaidya1989, Varadarajan1998}. Self-crossing configurations are often undesirable and may even imply an error condition; for example, a potential collision between moving objects, or inconsistency in a layout of a circuit.
In particular, non-crossing matchings are especially important in the context of VLSI circuit layouts~\cite{Lengauer1990} and operations research.


\subsection{Previous Work}

It is desirable to compute a perfect matching of a point set in the plane, which is optimal with respect to some criterion such as: (a) {\em minimum-cost matching} which minimizes the sum of the lengths of all edges; also known as {\em minimum-weight matching} or {\em min-sum matching}, and (b) {\em bottleneck matching} which minimizes the length of the longest edge; also known as {\em min-max matching} \cite{Efrat2000}. For the minimum-cost matching, Vaidya \cite{Vaidya1989} presented an  time algorithm, which was improved to  by Varadarajan \cite{Varadarajan1998}. As for bottleneck matching, Chang et al. \cite{Chang1992} proved that such kind of matching is a subset of 17-RNG (relative neighborhood graph). They presented an algorithm, running in -time to compute a bottleneck matching of maximum cardinality. The matching computed by their algorithm may be crossing.
Efrat and Katz \cite{Efrat2000} extended the result of Chang et al. \cite{Chang1992} to higher dimensions. They proved that a bottleneck matching in any constant dimension can be computed in -time under the -norm. 

Note that a plane perfect matching of a point set can be computed in -time, e.g., by matching the two leftmost points recursively.

Abu-Affash et al.~\cite{Abu-Affash2014} showed that the bottleneck plane perfect matching problem is NP-hard and presented an algorithm that computes a plane perfect matching whose edges have length at most  times the bottleneck, i.e., . They also showed that this problem does not
admit a PTAS (Polynomial Time Approximation Scheme), unless P=NP. Carlsson et al.~\cite{Carlsson2010} showed that the bottleneck plane perfect matching problem for a Euclidean bipartite complete graph is also NP-hard.

\subsection{Our Results}

The main results of this paper are summarized in Table \ref{table1}. We use the unit disk graph as a tool for our approximations. First, we present an -time algorithm in Section \ref{UDG}, that computes a plane matching of size at least  in a connected unit disk graph. Then in Section \ref{bottleneck-five-over-two} we describe how one can use this algorithm to obtain a bottleneck plane matching of size at least  with edges of length at most  in -time.
In Section \ref{bottleneck-five-over-four} we present an -time approximation algorithm that computes a plane matching of size at least  whose edges have length at most . Finally we conclude this paper in Section \ref{conclusion}.

\begin{table}
\centering
\caption{Summary of results.}
\label{table1}
    \begin{tabular}{|l|c|c|c|}
         \hline
             Algorithm &time complexity&bottleneck ()    & size of matching  \\ \hline
             Abu-Affash et al. \cite{Abu-Affash2014}&  &  &  \\
             Section \ref{bottleneck-five-over-two} &&  &  \\
             Section \ref{bottleneck-five-over-four}& &  & \\
         \hline
    \end{tabular}
\end{table}

\section{Preliminaries}
\label{preliminaries}

Let  denote a set of  points in the plane, where  is even, and let  denote the complete Euclidean graph over . A {\em matching}, , is a subset of edges of  without common vertices. Let  denote the {\em cardinality} of , which is the number of edges in .  is a {\em perfect matching} if it covers all the vertices of , i.e., . The {\em bottleneck} of  is defined as the longest edge in . We denote its length by . A {\em bottleneck perfect matching} is a perfect matching that minimizes the bottleneck length. A {\em plane matching} is a matching with non-crossing edges. 
We denote a plane matching by  and a crossing matching by . 
The {\em bottleneck plane perfect matching}, , is a perfect plane matching which minimizes the length of the longest edge. Let  denote the length of the bottleneck edge in . In this paper we consider the problem of computing a bottleneck plane matching of . 

The Unit Disk Graph, , is defined to have the points of  as its vertices and two vertices  and  are connected by an edge if their Euclidean distance  is at most 1. The {\em maximum plane matching} of  is the maximum cardinality matching of , which has no pair of crossing edges. 

\begin{lemma}
 If the maximum plane matching in unit disk graphs can be computed in polynomial time, then the bottleneck plane perfect matching problem for point sets can also be solved in polynomial time.
\end{lemma}
\begin{proof}
Let  be the set of all distances determined by pairs of points in . Note that . For each , define the ``unit'' disk graph , in which two points  and  are connected by an edge if and only if . Then  is the minimum  in  such that  has a plane matching of size .
\end{proof}



The Gabriel Graph, , is defined to have the points of  as its vertices and two vertices  and  are connected by an edge if the disk with diameter  does not contain any point of  in its interior and on its boundary.

\begin{lemma}
\label{MST-UDG}
If the unit disk graph  of a point set  is connected, then  and  have the same minimum spanning tree.
\end{lemma}
\begin{proof}
 By running Kruskal's algorithm on , we get a minimum spanning tree, say . All the edges of  have length at most one, and the edges of  which do not belong to  all have length greater than one. Hence,  is also a minimum spanning tree of .
\end{proof}

As a direct consequence of Lemma \ref{MST-UDG} we have the following corollary:

\begin{corollary}
\label{MST-DEL}
Consider the unit disk graph  of a point set . We can compute the minimum spanning forest of , by first computing the minimum spanning tree of  and then removing the edges whose length is more than one.
\end{corollary}

\begin{lemma}
\label{same-component}
 For each pair of crossing edges  and  in , the four endpoints , , , and  are in the same component of . 
\end{lemma}
\begin{proof}
Note that the quadrilateral  formed by the end points , , , and  is convex. W.l.o.g. assume that the angle  is the largest angle in . Clearly , and hence, in triangle , the angles  and  are both less than . Thus, the edges  and  are both less than . This means that  and  are also edges of , thus, their four endpoints belong to the same component.  
\end{proof}

As a direct consequence of Lemma \ref{same-component} we have the following corollary: 

\begin{corollary}
\label{non-crossing-edges}
Any two edges that belong to different components of  do not cross.
\end{corollary}

\begin{figure}[ht]
  \centering
    \includegraphics[width=0.4\textwidth]{fig/empty-triangle-figure.pdf}
  \caption{In , the triangle  formed by two adjacent edges  and , is empty.}
\label{empty-triangle-figure}
\end{figure}

Let  denote the Euclidean minimum spanning tree of .

\begin{lemma}
\label{empty-triangle-lemma}
If  and  are two adjacent edges in , then the triangle  has no point of  inside or on its boundary.
\end{lemma}
\begin{proof}
If the angle between the line segments  and  is equal to  then clearly there is no other point of  on  and . So assume that . Refer to Figure \ref{empty-triangle-figure}. Since  is a subgraph of the Gabriel graph, the circles  and  with diameters  and  are empty. Since ,  and  intersect each other at two points, say  and . Connect ,  and  to . Since  and  are the diameters of  and , .
This means that  is a straight line segment. Since  and  are empty and , it follows that .
\end{proof}

\begin{corollary}
\label{empty-convex-hull}
Consider  and let  be the set of neighbors of a vertex  in . Then the convex hull of  contains no point of  except  and the set .
\end{corollary}

The shaded area in Figure \ref{empty-skeleton-fig} shows the union of all these convex hulls.

\section{Plane Matching in Unit Disk Graphs}
\label{UDG}

In this section we present two approximation algorithms for computing a maximum plane matching in a unit disk graph . In Section \ref{three-approximation} we present a straight-forward -approximation algorithm; it is unclear whether this algorithm runs in polynomial time. For the case when  is connected, we present a -approximation algorithm in Section \ref{five-over-two-approximation}.

\subsection{-approximation algorithm}
\label{three-approximation}

Given a possibly disconnected unit disk graph , we start by computing a (possibly crossing) maximum matching  of  using Edmonds algorithm \cite{Edmonds1965}. Then we transform  to another (possibly crossing) matching  with some properties, and then pick at least one-third of its edges which satisfy the non-crossing property. Consider a pair of crossing edges  and  in , and let  denote the intersection point. If their smallest intersection angle is at most , we replace these two edges with new ones. For example if , we replace  and  with new edges  and . Since the angle between them is at most , the new edges are not longer than the older ones, i.e. , and hence the new edges belong to the unit disk graph. On the other hand the total length of the new edges is strictly less than the older ones; i.e. . For each pair of intersecting edges in , with angle at most , we apply this replacement. We continue this process until we have a matching  with the property that if two matched edges intersect, each of the angles incident on  is larger than .

For each edge in , consider the counter clockwise angle it makes with the positive -axis; this angle is in the range . Using these angles, we partition the edges of  into three subsets, one subset for the angles , one subset for the angles , and
one subset for the angles . Observe that edges within one subset are non-crossing. Therefore, if we output the largest subset, we obtain a non-crossing matching of size at least
.

Since in each step (each replacement) the total length of the matched edges decreases, the replacement process converges and the algorithm will stop. We do not know whether this process converges in a polynomial number of steps in the size of .

\subsection{-approximation algorithm for connected unit disk graphs}
\label{five-over-two-approximation}

In this section we assume that the unit disk graph  is connected. Monma et al. \cite{Monma1992} proved that every set of points in the plane admits a minimum spanning tree of degree at most five which can be computed in  time. By Lemma \ref{MST-UDG}, the same claim holds for . Here we present an algorithm which extracts a plane matching  from . Consider a minimum spanning tree  of  with vertices of degree at most five. We define the {\em skeleton tree}, , as the tree obtained from  by removing all its leaves; see Figure \ref{empty-skeleton-fig}. Clearly . For clarity we use  and  to refer to the leaves of  and  respectively. In addition, let  and , respectively, refer to the copies of a vertex  in  and . In each step, pick an arbitrary leaf . By the definition of , it is clear that the copy of  in , i.e. , is connected to vertices , for some , which are leaves of  (if  has one vertex then ). Pick an arbitrary leaf  and add  as a matched pair to . For the next step we update  by removing  and all its adjacent leaves. We also compute the new skeleton tree and repeat this process. 
In the last iteration,  is empty and we may be left with a tree  consisting of one single vertex or one single edge. If  consists of one single vertex, we disregard it, otherwise we add its only edge to .

\begin{figure}[ht]
  \centering
    \includegraphics[width=0.7\textwidth]{fig/empty-skeleton.pdf}
  \caption{Minimum spanning tree  with union of empty convex hulls. The skeleton tree  is surrounded by dashed line, and  is a leaf in . }
\label{empty-skeleton-fig}
\end{figure}

The formal algorithm is given as {\scshape PlaneMatching}, which receives a point set ---whose unit disk graph is connected---as input and returns a matching  as output. The function MST5 returns a Euclidean minimum spanning tree of  with degree at most five, and the function Neighbor returns the only neighbor of leaf  in .

\begin{algorithm}                      \caption{{\scshape PlaneMatching}}          \label{alg1} 
\require{set  of  points in the plane, such that  is connected.}\\
\ensure{plane matching  of  with .}
\begin{algorithmic}[1]
    \State 
    \State MST5
    \State SkeletonTree
    \While {}
	\State  {a leaf of } 
	\State  {set of leaves  connected to }  { in } 
        \State  {an element of } 
	\State 	
	\State 
	\If {Neighbor}
	    \State { Neighbor}
	\Else
	    \State 
	\EndIf
    \EndWhile
    \If { {consists of one single edge}}
	\State 
    \EndIf
    \State \Return 
\end{algorithmic}
\end{algorithm}

\begin{lemma}
\label{n-minus-one-lemma}
Given a set  of  points in the plane such that  is connected, algorithm {\scshape PlaneMatching} returns a plane matching  of  of size . Furthermore,  can be computed in  time.
\end{lemma}
\begin{proof}
In each iteration an edge  is added to . Since  is plane,  is also plane and  is a matching of .

Line 5 picks  which is a leaf, so its analogous vertex  is connected to at least one leaf. In each iteration we select an edge incident to one of the leaves and add it to , then disregard all other edges connected to  (line 9). So for the next iteration  looses at most five edges. Since  has  edges initially and we add one edge to  out of each five edges of , we have . 

According to Corollary \ref{MST-DEL} and by \cite{Monma1992}, line 2 takes  time. The while-loop is iterated  times and in each iteration, lines 5-13 take constant time. So, the total running time of algorithm {\scshape PlaneMatching} is . 
\end{proof}

The size of a maximum matching can be at most . Therefore, algorithm {\scshape PlaneMatching} computes a matching of size at least  times the size of a perfect matching, and hence, when  is large enough, {\scshape PlaneMatching} is a -approximation algorithm. On the other hand there are unit disk graphs whose maximum matchings have size ; see Figure \ref{worst-case-optimal}. In this case {\scshape PlaneMatching} returns a maximum matching. In addition, when  is a tree or a cycle, {\scshape PlaneMatching} returns a maximum matching. 

\begin{figure}[ht]
  \centering
    \includegraphics[width=0.7\textwidth]{fig/worst-case-optimal.pdf}
  \caption{Unit disk graph with all edges of unit length, and maximum matching of size .}
\label{worst-case-optimal}
\end{figure}

In Section \ref{bottleneck-five-over-two} we will show how one can use a modified version of algorithm {\scshape PlaneMatching} to compute a bottleneck plane matching of size at least  with bottleneck length at most . Recall that  is the length of the bottleneck edge in the bottleneck plane perfect matching . Section \ref{bottleneck-five-over-four} extends this idea to an algorithm which computes a plane matching of size at least  with edges of length at most .

\section{Approximating Bottleneck Plane Perfect Matching}
\label{bottleneck}


The general approach of our algorithms is to first compute a (possibly crossing) bottleneck perfect matching  of  using the algorithm in \cite{Chang1992}. Let  denote the length of the bottleneck edge in . It is obvious that the bottleneck length of any plane perfect matching is not less than . Therefore, . We consider a ``unit'' disk graph  over , in which there is an edge between two vertices  and  if . Note that  is not necessarily connected. Let  be the connected components of . For each component , consider a minimum spanning tree  of degree at most five. We show how to extract from  a plane matching  of proper size and appropriate edge lengths.

\begin{lemma}
 Each component of  has an even number of vertices.
\end{lemma}
\begin{proof}
This follows from the facts that  is a perfect matching and both end points of each edge in  belong to the same component of .
\end{proof}

\subsection{First Approximation Algorithm}
\label{bottleneck-five-over-two}
In this section we describe the process of computing a plane matching  of size
 with bottleneck length at most . Consider the minimum spanning trees  of the  components of . For , let  denote the set of vertices in  and  denote the number of vertices of . Our approximation algorithm runs in two steps:

\begin{paragraph}{Step 1:} 
We start by running algorithm {\scshape PlaneMatching} on each of the point sets . Let  be the output. Recall that algorithm {\scshape PlaneMatching}, from Section \ref{five-over-two-approximation}, picks a leaf , corresponding to a vertex , matches it to one of its neighboring leaves in  and disregards the other edges connected to . According to Lemma \ref{n-minus-one-lemma}, this gives us a plane matching  of size at least . However, we are looking for a matching of size at least . 

 The total number of edges of  is  and in each of the iterations, the algorithm picks one edge out of at most five candidates. If in at least one of the iterations of the while-loop,  has degree at most four (in ), then in that iteration algorithm {\scshape PlaneMatching} picks one edge out of at most four candidates. Therefore, the size of  satisfies 

 If in all the iterations of the while-loop,  has degree five, we look at the angles between the consecutive leaves connected to . Recall that in  all the angles are greater than or equal to . If in at least one of the iterations,  is connected to two consecutive leaves  and  for , such that , we change  as follow. Remove from  the edge incident to  and add to  the edges  and , where , is one of the leaves connected to . Clearly  is equilateral and , and by Lemma \ref{empty-triangle-lemma},  does not cross other edges. In this case, the size of  satisfies 


\end{paragraph}

\begin{paragraph}{Step 2:}
In this step we deal with the case that in all the iterations of the while-loop,  has degree five and the angle between any pair of consecutive leaves connected to  is greater than . Recall that  is a perfect matching and both end points of each
edge in  belong to the same .

\begin{figure}[ht]
  \centering
    \includegraphics[width=0.5\textwidth]{fig/two-leaves.pdf}
  \caption{Resulted matching  by modified {\scshape PlaneMatching}. The numbers show the order in which the edges (bold edges) are added to .}
\label{two-leaves-fig}
\end{figure}

\begin{lemma}
\label{two-leaves-lemma}
In Step 2, at least two leaves of  are matched in .
\end{lemma}
\begin{proof}
 Let  and  denote the number of external (leaves) and internal nodes of , respectively. Clearly  is equal to the number of vertices of  and . Consider the reverse process in {\scshape PlaneMatching}. Start with a 5-star tree , i.e. , and in each iteration append a new  to  until . In the first step  and . In each iteration a leaf of the appended  is identified with a leaf of ; the resulting vertex becomes an internal node. On the other hand, the \textquotedblleft center\textquotedblright of the new  becomes an internal node of  and its other four neighbors become leaves of . So in each iteration, the number of leaves  increases by three, and the number of internal nodes  increases by two. Hence, in all iterations (including the first step) we have .

Again consider . In the worst case if all  internal vertices of  are matched to leaves, we still have four leaves which have to be matched together.   
\end{proof}

According to Lemma \ref{two-leaves-lemma} there is an edge  where  and  are leaves in . We can find  and  for all 's by checking all the edges of  once. We remove all the edges of  and initialize . Again we run a modified version of {\scshape PlaneMatching} in such a way that in each iteration, in line 7 it selects the leaf  adjacent to  such that  is not intersected by . In each iteration  has degree five and is connected to at least four leaf edges with angles greater than . Thus,  can intersect at most three of the leaf edges and such kind of  exists. See Figure \ref{two-leaves-fig}. In this case,  has size


\end{paragraph}

We run the above algorithm on each  and for each of them we compute a plane matching . The final matching of point set  will be .

\begin{theorem}
\label{two-over-five-theorem}
Let  be a set of  points in the plane, where  is even, and let  be the minimum bottleneck length of any plane perfect matching of . In  time, a plane matching of  of size at least  can be computed, whose bottleneck length is at most .
\end{theorem}
\begin{proof}

{\em Proof of edge length}: Let  be the length of the longest edge in  and consider a component  of . All the selected edges in Steps 1 and 2 belong to  except  and .  is a subgraph of , and the edge  belongs to , and the edge  belongs to  (which belongs to  as well). So all the selected edges belong to , and . Since , we have  for all , .

 {\em Proof of planarity}: The edges of  belong to the minimum spanning forest of  which is plane, except  and . According to Corollary \ref{non-crossing-edges} and Lemma \ref{empty-triangle-lemma} the edge  does not cross the edges of the minimum spanning forest. In Step 2 we select edges of  in such a way that avoid . Note that  belongs to the component  and by Corollary \ref{non-crossing-edges} it does not cross any edge of the other components of . So  is plane.

 {\em Proof of matching size}: Since , and for each , , hence


 {\em Proof of complexity}: The initial matching  can be computed in time  by using the algorithm of Chang et al. \cite{Chang1992}. By Lemma \ref{n-minus-one-lemma} algorithm {\scshape PlaneMatching} runs in  time. In Step 1 we spend constant time for checking the angles and the number of leaves connected to  during the while-loop. In Step 2, the matched leaves  and  can be computed in  time for all 's by checking all the edges of  before running the algorithm again. So the modified {\scshape PlaneMatching} still runs in  time, and the total running time of our method is .
\end{proof}

Since the running time of the algorithm is bounded by the time of computing the initial bottleneck matching , any improvement in computing  leads to a faster algorithm for computing a plane matching  . In the next section we improve the running time.

\subsubsection{Improving the Running Time}
In this section we present an algorithm that improves the running time to . We first compute a forest , such that each edge in  is of length at most  and, for each tree , we have a leaf  and a point  such that . Once we have this forest , we apply Step 1 and Step 2 on  to obtain the matching  as in the previous section. 

Let  be a (five-degree) minimum spanning tree of . 
Let  be the forest obtained from  by removing all the edges whose length is greater than , i.e., . For a point , let  be the point in  that is closest to .

\begin{lemma}
\label{opt-forest}
For all , it holds that
\begin{enumerate}
	\item[(i)]  the number of points in  is even, and
	\item[(ii)]  for each two leaves  that are incident to the same node  in , let , let , and assume that . Then,  and  belongs to .
\end{enumerate}
\end{lemma}
\begin{proof}
(i) Suppose that  has odd number of points. Thus in  one of the points in  should be matched to a point in a tree  by an edge . Since , we have , which contradicts that  is the minimum bottleneck. (ii) Note that  is the closest point to both  and . In , at most one of  and  can be matched to , and the other one must be matched to a point which is at least as far as its second closest point. Thus,  is at least . The distance between any two trees in  is greater than . Now if  is not in , then in any bottleneck perfect matching, either  or  is matched to a point of distance greater than , which contradicts that  is the minimum bottleneck.
\end{proof}


Let  be the edges of  in sorted order of their lengths. Our algorithm performs a binary search on , and for each considered edge , it uses Algorithm~\ref{proc2} to decide whether , where . 
The algorithm constructs the forest , and for each tree  in , it picks two leaves  and  from  and finds their second closest points  and . Assume w.l.o.g. that . Then, the algorithm returns FALSE if  does not belong to . By Lemma~\ref{opt-forest}, if the algorithm returns FALSE, then we know that . 

Let  be the shortest edge in , for which Algorithm~\ref{proc2} does not return FALSE. This means that Algorithm~\ref{proc2} returns FALSE for , and there is a tree  in  and a leaf  in , such that . Thus  and for each tree  in the forest , we stored a leaf  of  and a point , such that . Since each tree in  is a subtree of ,  is planar and each tree in  is of degree at most five. 

\floatname{algorithm}{Algorithm}

\begin{algorithm}                      \caption{{\scshape CompareToOpt}}          \label{proc2} 
\begin{algorithmic}[1]

  \State compute  \State { empty list}
  \For {each }
	\If { has an odd number of points} 
		\State return {FALSE} \EndIf
	\If {there exist two leaves  and  incident to a node }
  \State 
	\State 
	
  \If {}
			\If { does not belong to } 
				\State \Return {FALSE}
			\Else
				\State {add the triple  to }  \EndIf
  \Else 
			\If { does not belong to } 
				\State \Return {FALSE}
			\Else
				\State {add the triple  to }  \EndIf
  \EndIf \EndIf
	\EndFor
\State \Return 
	
\end{algorithmic}
\end{algorithm}



Now we can apply Step 1 and Step 2 on  as in the previous section. Note that in Step 2, for each tree  we have a pair  (or ) in the list  which can be matched. In Step 2, in each iteration  has degree five, thus,  should be a vertex
of degree two or a leaf in . If  is a leaf we run the modified version of {\scshape PlaneMatching} as in the previous section. If  has degree two, we remove all the edges of  and initialize . Then remove  from  and run {\scshape PlaneMatching} on the resulted subtrees. Finally, set .

\begin{lemma}
\label{planarity}
 The matching  is planar.
\end{lemma}
\begin{proof}
Consider two edges  and  in . We distinguish between four cases:
\begin{enumerate}
   \item  and . In this case, both  and  belong to  and hence they do not cross each other.
  \item  and . If  and  cross each other, then this contradicts the selection of  in Step 2 (which prevents ).
  \item  and . It leads to a contradiction as in the previous case.
  \item  and . If  and  cross each other, then either  or , which contradicts the selection of  or . Note that  cannot be the second closest point to , because  and  are in different trees. 
\end{enumerate} 
\end{proof}


\begin{lemma}
\label{running-time}
 The matching  can be computed in  time.
\end{lemma}
\begin{proof}
Computing  and sorting its edges take ~\cite{deBerg08}. Since we performed a binary search on the edges of , we need  iterations. In each iteration, for an edge , we compute the forest  in  and the number of the trees in the forest can be  in the worst case. We compute in advance the second order Voronoi diagram of the points together with a corresponding point location data structure, in ~\cite{deBerg08}. For each tree in the forest, we perform a point location query to find the closest points  and , which takes  for each query. Therefore the total running time is .
\end{proof}

\begin{theorem}
\label{two-over-five-theorem-2}
Let  be a set of  points in the plane, where  is even, and let  be the minimum bottleneck length of any plane perfect matching of . In  time, a plane matching of  of size at least  can be computed, whose bottleneck length is at most .
\end{theorem}

\subsection{Second Approximation Algorithm}
\label{bottleneck-five-over-four}

In this section we present another approximation algorithm which gives a plane matching  of size  with bottleneck length . Let  denote the Delaunay triangulation of . Let the edges of  be, in sorted order of their lengths, . Initialize a forest  consisting of  tress, each one being a single node for one point of . Run Kruskal's algorithm on the edges of  and terminate as soon as every tree in  has an even number of nodes. Let  be the last edge that is added by Kruskal's algorithm. Observe that  is the longest edge in . Denote the trees in  by  and for , let  be the vertex set of  and let . 

\begin{lemma}
\label{longest-edge}
 
\end{lemma}
\begin{proof}
Let  be such that  is an edge in . Let  and  be the trees obtained by removing  from . Let  be the vertex set of . Then . Consider the optimal matching  with bottleneck length . Since  is the last edge added,  has odd size. The matching  contains an edge joining a point in  with a point in . This edge has length at least .
\end{proof}

By Lemma \ref{longest-edge} the length of the longest edge in  is at most . For each , where , our algorithm will compute a plane matching  of  of size at least  with edges of length at most  and returns . To describe the algorithm for tree  on vertex set , we will write , , ,  instead of , , , , respectively. Thus,  is a set of  points, where  is even, and  is a minimum spanning tree of .

\iffalse
In this section we present another approximation algorithm which gives a plane matching  of size  with bottleneck length . Start by computing a minimum spanning tree  of . Let  be the longest edge in , and
let  denote its length. Let  and  be the two trees obtained by removing
 from . If  has an odd number of nodes, then, clearly, , otherwise, both  and  have an even number of nodes. In the latter case, we remove  from  and we recursively perform this algorithm on  and . We partition  to trees  with vertex sets  respectively. Each tree , where , has an even number of nodes denoted by . That is, we remove every edge  that splits  into two trees  and  of even cardinality (not necessarily ), and obtain a forest  such that each tree in  has an even number of nodes and cannot be further partitioned. Clearly there is no node of even degree (in each tree of ). For each , our algorithm will compute a plane matching  of  of size at least  with edges of length at most  and returns . To describe the algorithm for tree  on vertex set , we will write , , ,  instead of , , , , respectively. Thus,  is a set of  points, where  is even, and  is a minimum spanning tree of .
\fi


Consider the minimum spanning tree  of  having degree at most five, and let  be the skeleton tree of . Suppose that  has at least two vertices. We will use the following notation. Let  be a leaf in , and let  be the neighbor of . Recall that  and  are copies of vertices  and  in . In , we consider the clockwise ordering of the neighbors of . Let this ordering be  for some . Clearly  are leaves in . Consider two leaves  and  where . We define  as the clockwise angle from  to . We say that the leaf  (or its copy ) is an {\em anchor} if  and . See Figure \ref{empty-skeleton-angle-fig}.

\begin{figure}[ht]
  \centering
    \includegraphics[width=0.7\textwidth]{fig/empty-skeleton-angle.pdf}
  \caption{The vertices around  are sorted clockwise, and  is an anchor vertex.}
\label{empty-skeleton-angle-fig}
\end{figure}

Now we describe how one can iteratively compute a plane matching of proper size with bounded-length edges from . We start with an empty matching . Each iteration consists of two steps, during which we add edges to . As we prove later, the output is a plane matching of  of size at least  with bottleneck at most .

\subsubsection{Step 1}

We keep applying the following process as long as  has more than six vertices and  has some non-anchor leaf. Note that  has at least two vertices.
 
Take a non-anchor leaf  in  and according to the number  of leaves connected to  in  do the following:
 \begin{description}
  \item[{\em k} = 1] add  to , and set . 
  \item[{\em k} = 2] since  is not an anchor, . By Lemma \ref{empty-triangle-lemma} the triangle  is empty. We add  to , and set .
  \item[{\em k} = 3] in this case  has degree four and at least one of  and  is less than . W.l.o.g. suppose that . By Lemma \ref{empty-triangle-lemma} the triangle  is empty. Add  to  and set . 
  \item[{\em k} = 4] this case is handled similarly as the case .
 \end{description}

At the end of Step 1,  has at most six vertices or all the leaves of  are anchors. In the former case, we add edges to  as will be described in Section \ref{base-cases} and after which the algorithm terminates. In the latter case we go to Step 2.

\subsubsection{Step 2}

In this step we deal with the case that  has more than six vertices and all the leaves of  are anchors. We define the {\em second level skeleton tree}  to be the skeleton tree of . In other words,  is the tree which is obtained from  by removing all the leaves. For clarity we use  to refer to a leaf of , and we use , , and , respectively, to refer to the copies of vertex  in , , and . For now suppose that  has at least two vertices. Consider a leaf  and its neighbor  in . Note that in ,  is connected to , to at least one anchor, and possibly to some leaves of . After Step 1, the copy of  in , i.e. , is connected to anchors  in  (or  in ) for some , and connected to at most  leaves of . In , we consider the clockwise ordering of the non-leaf neighbors of . Let this ordering be . We denote the pair of leaves connected to anchor  by  and  in clockwise order around ; see Figure \ref{anchor-orientation}. 

\begin{figure}[ht]
  \centering
    \includegraphics[width=0.6\textwidth]{fig/anchor-orientation.pdf}
  \caption{Second level skeleton tree  is surrounded by dashed line. 's are ordered clockwise around leaf vertex , as well as 's.  and  are ordered clockwise around .}
\label{anchor-orientation}
\end{figure}

In this step we pick an arbitrary leaf  and according to the number of anchors incident to , i.e. , we 
add edges to . Since , four cases occur and we discuss each case separately. Before that, we state some lemmas.

\begin{figure}[ht]
  \centering
    \includegraphics[width=0.3\textwidth]{fig/empty-quadrilateral.pdf}
  \caption{Illustrating Lemma \ref{empty-quadrilateral-lemma}.}
\label{empty-quadrilateral-fig}
\end{figure}

\begin{lemma}
\label{empty-quadrilateral-lemma}
Let  be a leaf in . Consider an anchor  which is adjacent to  in . For any neighbor  of  for which , if  (resp. ), the polygon  (resp. ) is convex and empty.
\end{lemma}
\begin{proof}
We prove the case when ; see Figure \ref{empty-quadrilateral-fig}. The proof for the second case is symmetric. To prove the convexity of  we show that the diagonals  and  of  intersect each other. To show the intersection we argue that  lies to the left of  and to the right of .

Consider . According to Lemma \ref{empty-triangle-lemma}, triangle  is empty so  lies to the right  of . On the other hand,  is an anchor, so , and hence  lies to the left of .
Now consider . For the sake of contradiction, suppose that  is to the left of . Since , the angle  is greater than . This means that  is the largest side of , which contradicts that  is an edge of . So  lies to the right of . Therefore,  intersects  and  is convex.  is empty because by Lemma \ref{empty-triangle-lemma}, the triangles  and  are empty. 
\end{proof}

\begin{figure}[ht]
  \centering
    \includegraphics[width=0.4\textwidth]{fig/clockwise-order-figure.pdf}
  \caption{Proof of Lemma \ref{clockwise-order-lemma}.}
\label{clockwise-order-fig}
\end{figure}

\begin{lemma}
\label{clockwise-order-lemma}
Let  be a leaf in  and consider the clockwise sequence  of anchors that are incident on . The sequence of vertices  are angularly sorted in clockwise order around . 
\end{lemma}
\begin{proof}
 Using contradiction, consider two vertices  and , and assume that  comes before  and  comes before  in the clockwise order; see Figure \ref{clockwise-order-fig}. Either  is in  or  is in . However, by Lemma \ref{empty-triangle-lemma}, neither of these two cases can happen.
\end{proof}

\begin{figure}[ht]
  \centering
\setlength{\tabcolsep}{0in}
  
  \caption{Illustrating Lemma \ref{anchor2-vertex1-lemma}.}
\label{anchor2-vertex1-1-fig}
\end{figure}

\begin{lemma}
\label{anchor2-vertex1-lemma}
Let  be a leaf in  and consider the clockwise sequence  of anchors that are adjacent to . Let  and let  be a neighbor of  for which  and . 
\begin{enumerate}
 \item If  is between  and  in the clockwise order:
    \begin{enumerate}
      \item if  is to the right of , then  is convex and empty.
      \item if  is not to the right of , then  is convex and empty.
    \end{enumerate}
  \item If  is between  and , or  is between  and  in the clockwise order:
    \begin{enumerate}
      \item if  is to the left of , then  is convex and empty.
      \item if  is not to the left of , then  is convex and empty.
    \end{enumerate}
\end{enumerate}
\end{lemma}

\begin{proof}
We only prove the first case, the proof for the second case is symmetric. Thus, we assume that  is between  and  in the clockwise order. First assume that  is to the right of . See Figure \ref{anchor2-vertex1-1-fig}(a). Consider . Since  is an anchor,  cannot be to the right of , and according to Lemma \ref{empty-triangle-lemma},  cannot be to the right of . For the same reasons, both the vertices  and  cannot be to the left of . Now consider . By assumption,  is to the right of . Therefore  intersects  and hence  is convex.

Now assume that  is not to the right of ; see Figure \ref{anchor2-vertex1-1-fig}(b). By Lemma \ref{clockwise-order-lemma},  is to the left of . Therefore,  intersects  and hence  is convex. 
The emptiness of the polygons follows directly from Lemma \ref{empty-triangle-lemma}.
\end{proof}

\begin{figure}[ht]
  \centering
    \includegraphics[width=0.35\textwidth]{fig/anchor4-5.pdf}
  \caption{Illustrating Lemma \ref{separation-lemma}.}
\label{anchor4-5-fig}
\end{figure}

\begin{lemma}
\label{separation-lemma}
Let  be a leaf in  and consider the clockwise sequence  of anchors that are incident on . If , then at least one of the pentagons  and  is convex and empty.
\end{lemma}
\begin{proof}
We prove the case when ; the proof for  is analogous. By Lemma \ref{clockwise-order-lemma},  comes before  in the clockwise order. Consider ; see Figure \ref{anchor4-5-fig}. Let  denote the line through  and . If  is to the left of , then  separates  from  and . Otherwise,  is to the right of . Now consider . If  is to the right of , then  separates  from  and . The remaining case, i.e., when  is to the left of , cannot happen by Lemma \ref{clockwise-order-lemma} (because, otherwise,  would come before  in the clockwise order).

Thus, we have shown that (i)  separates  from  and  or (ii)  separates  from  and . Assume w.l.o.g. that (i) holds. Now to prove the convexity of  we show that all internal angles of  are less than . Since  is an anchor, . By Lemma~\ref{empty-triangle-lemma},  is to the left of of . Therefore, . On the other hand , so in , . By a similar analysis  and  are less than . In addition,  in  is less than . Thus,  is convex. Its emptiness is assured from the emptiness of the triangles ,  and .
\end{proof}

Now we are ready to present the details of Step 2. Recall that  has more than six vertices and all leaves of  are anchors. In this case  has at least one vertex. If  has exactly one vertex, we add edges to  as will be described in Section \ref{base-cases} and after which the algorithm terminates. Assume that  has at least two vertices. Pick a leaf  in . As before, let  where  be the clockwise order of the anchors connected to . Let  where  be the clockwise order of the leaves of  connected to ; see Figure \ref{anchor-orientation}. This means that , where . Now we describe different configurations that may appear at , according to  and .
 \begin{description}
  \item[Case 1:] assume . If  or , add  and  to  and set . If  remove  from  as well. If , consider  as the acute angle between segments  and . W.l.o.g. assume . Two cases may arise: (i) , (ii) . If (i) holds, w.l.o.g. assume that  comes before  in clockwise order around . According to Lemma \ref{empty-quadrilateral-lemma} polygon  is convex and empty. So we add ,  and  to . Other cases are handled in a similar way. If (ii) holds, according to Lemma \ref{empty-triangle-lemma} triangle  is empty. So we add ,  and  to . In both cases set . If , remove  from  and handle the rest as .
  \item[Case 2:] assume . If , we add , , and  to . If  suppose that  comes before  in clockwise ordering. According to Lemma \ref{anchor2-vertex1-lemma} one of polygons  and  is empty; suppose it be  (where  and  in Lemma \ref{anchor2-vertex1-lemma}). Thus we add , ,  and  to . In both cases set  and if  remove  from  as well. If , remove  from  and handle the rest as .
  \item[Case 3:] assume . If  then set . If , consider  as the acute angle between segments  and . W.l.o.g. assume  has minimum value among all 's and  comes after  in clockwise order. According to Lemma \ref{anchor2-vertex1-lemma} one of polygons  and  is empty; suppose it be  (where  and  in Lemma \ref{anchor2-vertex1-lemma}). Thus we set . In both cases set  and if  remove  from  as well. Other cases can be handled similarly.


\begin{figure}[ht]
  \centering
    \includegraphics[width=0.35\textwidth]{fig/case4.pdf}
  \caption{The vertex  is shared between  and .}
\label{case4-fig}
\end{figure}

  \item[Case 4:] assume . According to Lemma \ref{separation-lemma} one of  and  is convex and empty. Again by Lemma \ref{separation-lemma} one of  and  is also convex and empty. Without loss of generality assume that  and  are empty. See Figure \ref{case4-fig}. Clearly, these two polygons share a vertex ( in Figure \ref{case4-fig}). Let  which is contained in  and  which is contained in . We pick one of the polygons  and  which minimizes . Let  be that polygon. So we set  and set . 
 \end{description}

This concludes Step 2. Go back to Step 1.

\subsubsection{Base Cases}
\label{base-cases}

In this section we describe the base cases of our algorithm. As mentioned in Steps 1 and 2, we may have two base cases: (a)  has at most  vertices, (b)  has only one vertex.

\begin{paragraph}{(a) {\em t}} Suppose that  has at most six vertices.
\begin{description}
  \item [{\em t} = 2] it can happen only if , and we add the only edge to .
  \item [{\em t} = 4, 5] in this case we match four vertices. If ,  could be a star or a path of length three, and in both cases we match all the vertices. If , remove one of the leaves and match other four vertices.
  \item [{\em t} = 6] in this case we match all the vertices. If one of the leaves connected to a vertex of degree two, we match those two vertices and handle the rest as the case when , otherwise, each leaf of  is connected to a vertex of degree more than two, and hence  has at most two vertices. Figure \ref{n-small}(a) shows the solution for the case when  has only one vertex and  is a star; note that at least two angles are less than . 
  Now consider the case when  has two vertices,  and , which have degree three in . Figure \ref{n-small}(b) shows the solution for the case when neither  nor  is an anchor. 
  Figure \ref{n-small}(c) shows the solution for the case when  is an anchor but  is not.
  Figure \ref{n-small}(d) shows the solution for the case when both  and  are anchors. Since  is an anchor in Figure \ref{n-small}(d), at least one of  and  is less than or equal to . W.l.o.g. assume . By Lemma \ref{empty-quadrilateral-lemma} polygon  is convex and empty. We add , , and  to .

  \item [{\em t} = 1, 3] this case could not happen. Initially  is even. Consider Step 1; before each iteration  is bigger than six and during the iteration two vertices are removed from . So, at the end of Step 1,  is at least five. Now consider Step 2; before each iteration  has at least two vertices and during the iteration at most one vertex is removed from . So, at the end of Step 2,  has at least one vertex that is connected to at least one anchor. This means that  is at least four. Thus,  could never be one or three before and during the execution of the algorithm.

\begin{figure}[ht]
  \centering
\setlength{\tabcolsep}{0in}
  
  \caption{The bold (solid and dashed) edges are added to  and all vertices are matched. (a) a star, (b) no anchor, (c) one anchor, and (d) two anchors.}
\label{n-small}
\end{figure} 

\end{description}
\end{paragraph}

\begin{paragraph}{(b)  has one vertex}
In this case, the only vertex  is connected to at least two anchors, otherwise  would have been matched in Step 1. So we consider different cases when  is connected to ,  anchors and  leaves of :
\begin{description}
 \item[{\em k} = 2] if  we handle it as Case 2 in Step 2. If , at least two leaves are consecutive, say  and . Since  we add  to  and handle the rest like the case when . 
\item[{\em k} = 3] if  remove  from . Handle the rest as Case 3 in Step 2.
\item[{\em k} = 4] if  remove  from . Handle the rest as Case 4 in Step 2. 
\item[{\em k} = 5] add  to , remove , ,  from , and handle the rest as Case 4 in Step 2.
\end{description}
\end{paragraph}

This concludes the algorithm.

\begin{lemma}
\label{convex-disjoint-lemma}
The convex empty regions that are considered in different iterations of the algorithm, do not overlap.
\end{lemma}
\begin{proof}
In Step 1, Step 2 and the base cases, we used three types of convex empty regions; see Figure \ref{convex-disjoint-fig}.
Using contradiction, suppose that two convex regions  and  overlap. Since the regions are empty, no vertex of  is in the interior of  and vice versa. Then, one of the edges in  that is shared with  intersects some edge in  that is shared with , which is a contradiction.   
\end{proof}

\begin{figure}[ht]
  \centering
\setlength{\tabcolsep}{0in}
  
  \caption{Empty convex regions. Bold edges belong to .}
\label{convex-disjoint-fig}
\end{figure}

\begin{theorem}
Let  be a set of  points in the plane, where  is even, and let  be the minimum bottleneck length of any plane perfect matching of . In  time, a plane matching of  of size at least  can be computed, whose bottleneck length is at most .
\end{theorem}
\begin{proof}

 {\em Proof of planarity}: In each iteration, in Step 1, Step 2, and in the base cases, the edges added to  are edges of  or edges inside convex empty regions. By Lemma \ref{convex-disjoint-lemma} the convex empty regions in each iteration will not be intersected by the convex empty regions in the next iterations. Therefore, the edges of  do not intersect each other and  is plane.

{\em Proof of matching size}: In Step 1, in each iteration, all the vertices which are excluded from  are matched. In Step 2, when  we match four vertices out of five, and when  we match eight vertices out of ten. In base case (a) when  we match four vertices out of five. In base case (b) when  we match eight vertices out of ten. In all other cases of Step 2 and the base cases, the ratio of matched vertices is more than . Thus, in each iteration at least  of the vertices removed from  are matched and hence . Therefore, 


{\em Proof of edge length}: By Lemma \ref{longest-edge} the length of edges of  is at most . Consider an edge  and the path  between its end points in . If  is added in Step 1, then  because  has at most two edges. If  is added in Step 2,  has at most three edges () except in Case 4. In this case we look at  in more detail. We consider the worst case when all the edges of  have maximum possible length  and the angles between the edges are as big as possible; see Figure \ref{path-fig}. Consider the edge  added to  in Case 4. Since  is an anchor and , the angle . As our choice between  and  in Case 4, . Recall that  avoids , and hence . The analysis for the base cases is similar.

\begin{figure}[ht]
  \centering
    \includegraphics[width=0.55\textwidth]{fig/path2.pdf}
  \caption{Path  (in bold) with four edges of length  between end points of edge .}
\label{path-fig}
\end{figure}

{\em Proof of complexity}: The Delaunay triangulation of  can be computed in  time. Using Kruskal's algorithm, the forest  of even components can be computed in  time. 
In Step 1 (resp. Step 2) in each iteration, we pick a leaf of  (resp. ) and according to the number of leaves (resp. anchors) connected to it we add some edges to . Note that in each iteration we can update ,  and  by only checking the two hop neighborhood of selected leaves. Since the two hop neighborhood is of constant size, we can update the trees in  time in each iteration. 
Thus, the total running time of Step 1, Step 2, and the base cases is  and the total running time of the algorithm is .
\end{proof}

\section{Conclusion}
\label{conclusion}
We considered the NP-hard problem of computing a bottleneck plane perfect matching of a point set. Abu-Affash et al. \cite{Abu-Affash2014} presented a -approximation for this problem. We used the maximum plane matching problem in unit disk graphs (UDG) as a tool for approximating a bottleneck plane perfect matching. In Section \ref{three-approximation} we presented an algorithm which computes a plane matching of size  in UDG, but it is still open to show if this algorithm terminates in polynomial number of steps or not. We also presented a -approximation algorithm for computing a maximum matching in UDG. By extending this algorithm we showed how one can compute a bottleneck plane matching of size  with edges of optimum-length. A modification of this algorithm gives us a plane matching of size at least  with  edges of length at most  times the optimum. 

\bibliographystyle{abbrv}
\bibliography{BNCM}
\end{document}
