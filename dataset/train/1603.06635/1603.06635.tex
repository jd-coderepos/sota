\documentclass[a4paper,10pt]{article}














\usepackage[utf8]{inputenc}
\usepackage{authblk}
\usepackage[english]{babel}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{mathrsfs} \usepackage{verbatim} \usepackage{etoolbox} \usepackage[stretch=5,shrink=5]{microtype} \usepackage{hyperref} \usepackage{csquotes} \usepackage{mathtools} \usepackage[justification=centering,font={small}]{caption}\usepackage{array} \usepackage{multirow} \usepackage{color}
\usepackage{float}
\usepackage{setspace}
\usepackage{wrapfig}
\usepackage{forest}



\newcolumntype{M}[1]{>{\centering\arraybackslash}m{#1}}
\newcolumntype{N}{@{}m{0pt}@{}}

\usepackage[backend=bibtex, doi=false, isbn=false, url=false, maxbibnames=99]{biblatex} 

\addbibresource{thesis.bib} \AtEveryBibitem{\clearlist{language}} 

\hyphenation{ad-ver-sar-y non-emp-ty ci-pher-text ad-mis-si-ble mas-sa-chu-setts at-tri-bute par-ti-cu-lar}

\newtheorem{assumption}{Assumption} 
\newtheorem{definition}{Definition}
\newtheorem{theorem}{Theorem}  
\newtheorem{proposition}{Proposition} 
\newtheorem{remark}{Remark} 
\newtheorem{lemma}{Lemma} 



\makeatletter
\newcommand*\wt[1]{\mathpalette\wthelper{#1}}
\newcommand*\wthelper[2]{\hbox{\dimen@\accentfontxheight#1\accentfontxheight#11.2\dimen@ \accentfontxheight#1\dimen@
        }}
\newcommand*\accentfontxheight[1]{\fontdimen5\ifx#1\displaystyle
                \textfont
        \else\ifx#1\textstyle
                \textfont
        \else\ifx#1\scriptstyle
                \scriptfont
        \else
                \scriptscriptfont
        \fi\fi\fi3
}
\makeatother
\newcommand{\powerset}[1]{\mathcal{P} \left( #1 \right) }
\newcommand{\G}{\mathbb{G}}
\newcommand{\GT}{\widetilde{\G}} \newcommand{\N}{\mathbb{N}}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\bigO}[1]{\mathcal{O}\left( #1 \right)}
\newcommand{\prob}[1]{\mathbb{P}\left[#1\right]}
\newcommand{\adv}{\textbf{Adv}}
\newcommand{\tree}{\mathfrak{T}}
\newcommand{\ith}{\text{-th}}
\newcommand{\varRow}{l}
\newcommand{\varColumn}{m}
\newcommand{\pvec}[2][]{{\hspace{-0.05em}\vec{\hspace{0.05em}#2}\mkern2mu\vphantom{#2}}^\prime_{\hspace{-0.18em}#1}}
\newcommand{\ppvec}[2][]{{\hspace{-0.05em}\vec{\hspace{0.05em}#2}\mkern2mu\vphantom{#2}}^{\prime\prime}_{\hspace{-0.18em}#1}}
\newcommand{\definline}[1]{(\textit{#1})}
\newcommand{\matrixset}[3]{\text{M}_{#1\times #2}(#3)}
\newcommand{\maps}[2]{}
\newcommand{\mapssingleoutput}[2]{}
\newcommand{\singlefunction}[1]{\texttt{#1}}
\newcommand{\algorithm}[2]{\texttt{#1.#2}}
\newcommand{\algorithmdef}[4]{\item[#1.#2 \maps{#3}{#4}:]}
\newcommand{\algorithmdefsingleoutput}[4]{\item[#1.#2 \mapssingleoutput{#3}{#4}:] }
\newcommand{\singlefunctiondef}[3]{\item[ \textbf{#1} \maps{#2}{#3}.\hspace{0.1em} ]}
\newcommand{\singlefunctiondefsingleoutput}[3]{\item[ \textbf{#1} \mapssingleoutput{#2}{#3}.\hspace{0.1em} ]}
\newcommand{\randomchoose}[1]{We choose randomly the element\ifstrequal{#1}{s}{}{s} }
\newcommand{\standalone}[2]{
\textit{Standalone version, \maps{#1}{#2}:}}
\newcommand{\standalonesingleoutput}[2]{
\textit{Standalone version, \mapssingleoutput{#1}{#2}:}}
\newcommand{\game}[2]{}
\newcommand{\mathgame}[2]{\mathbf{#1_{#2}}}
\newcommand{\phase}[1]{\textbf{#1 phase.} \hspace{0pt}}
\newcommand{\gamedef}[3]{
\textbf{Definition of \game{#1}{#2}.}
#3}
\newcommand{\EK}{\mathrm{EK}}
\newcommand{\CH}{\mathrm{CH}}
\newcommand{\CV}{\mathrm{CV}}
\newcommand{\PV}{\mathrm{PV}}
\newcommand{\PI}{\mathrm{PI}}
\newcommand{\normal}{S}
\newcommand{\semifunctional}{SF}
\newcommand{\sfone}{SF1}
\newcommand{\sftwo}{SF2}
\newcommand{\sfthree}{SF3}
\newcommand{\sffour}{SF4}
\newcommand{\random}{R}
\newcommand{\typeone}{type~1}
\newcommand{\typetwo}{type~2}
\newcommand{\disclaimerSUE}{The SUE keys are generated in a similar fashion, for which we refer to the paper by Lee et al.~\cite{lee2013RSABE}.

}

\definecolor{mildgray}{RGB}{220,220,220} 
\definecolor{darkgray}{RGB}{150,150,150} 
\colorlet{Rnode}{darkgray}
\definecolor{mildgray}{RGB}{230,230,230} 
	\definecolor{Rnode}{RGB}{170,170,170} 
	\definecolor{consideredNode}{RGB}{230,230,230}
	\definecolor{consideredEdge}{RGB}{0,0,0}
	\definecolor{boxPV}{RGB}{0,0,0}
	\newlength{\consideredWidth}
	\newlength{\boxPVWidth}
	\setlength{\consideredWidth}{0.1em}
	\setlength{\boxPVWidth}{0.025em}
	\definecolor{revokedNode}{RGB}{170,170,170}
	\definecolor{revokedEdge}{RGB}{0,0,0}
	\definecolor{boxCV}{RGB}{0,0,0}	
	\definecolor{consideredNode}{RGB}{230,230,230}
	\definecolor{consideredEdge}{RGB}{0,0,0}
	\definecolor{revokedNode}{RGB}{170,170,170}
	\definecolor{revokedEdge}{RGB}{0,0,0}
	\definecolor{boxSet}{RGB}{0,0,0}
	\newlength{\boxSetWidth}
	\setlength{\boxSetWidth}{0.025em}	
	\newlength{\revokedWidth}
	\newlength{\boxCVWidth}
	\setlength{\revokedWidth}{0.1em}
	\setlength{\boxCVWidth}{0.025em}

\DeclarePairedDelimiter{\ceil}{\lceil}{\rceil}

\let\oldemptyset\emptyset
\renewcommand{\emptyset}{\varnothing}
\let\oldsetminus\setminus
\renewcommand{\setminus}{\smallsetminus}



\title{A proof of security for a key-policy \texorpdfstring{\\}{}RS-ABE scheme}
\author[1]{Federico Giacon\thanks{federico.giacon@rub.de}}
\author[2]{Riccardo Aragona\thanks{riccardo.aragona@unitn.it}}
\author[2]{Massimiliano Sala\thanks{maxsalacodes@gmail.com }}
\affil[1]{Horst G\"ortz Institute for IT-Security, Ruhr-University Bochum, Germany}
\affil[2]{Department of Mathematics, University of Trento, Italy}
\date{}

\begin{document}
	\maketitle
	\begin{abstract}
A revocable-storage attribute-based encryption  (RS-ABE) scheme is an encryption scheme which extends attribute-based encryption by introducing user revocation. A key-policy RS-ABE scheme links each key to an access structure. We propose a new key-policy RS-ABE scheme whose security we prove in term of indistinguishability under a chosen-plaintext attack (IND-CPA).
	\end{abstract}
\medskip
\small{\textbf{Keywords:} Key Policy, Attribute Based Encryption, Bilinear Group}


	\section{Introduction}
	\label{intro}
	


	Attribute-based encryption (ABE) is a flavor of public-key encryption which has seen a growing interest in the last years. 
	An ABE scheme builds its ciphertexts and its keys employing \emph{attributes}. Attributes are used to manage the access to a certain document using a fixed key. In a \emph{key-policy} ABE scheme each ciphertext links the encrypted plaintext to a set of attributes, and each key is linked to an \emph{access structure}. An access structure is a list of sets of attributes which the key is able to decrypt. Thus a key can decrypt a ciphertext if and only if the set of attributes of the ciphertext belongs to the access structure of the key.
	In a similar way, a \emph{ciphertext-policy} reverses the roles of set of attributes and access structure: in this case, a key is associated with the set of attributes, and a ciphertext with an access structure.
	The choice between key-policy and ciphertext-policy depends on the final application of the scheme. For example, a digital television platform could favour key policy to manage their TV licenses: associating attributes to encrypted programs, the clients are able to decrypt only the programs which belong to their license. Conversely, a bank could prefer a ciphertext policy to manage the work of its personnel: if we associate attributes to the cryptographic keys of each employee, then each member is able to decrypt only the documents within their competence, i.e., those corresponding to attributes associated with their keys.
	Different ABE constructions have been proposed over time, with gradually increased security, reliability and efficiency.
	For this reason the concept of ABE has been extended in order to widen its use-cases.
	Our interest lies specifically on user revocation and in this paper we design a public-key scheme which enjoys ABE for encryption, while allowing to  revoke users arbitrarily.
	This is the goal of revocable-storage attribute-based encryption (RS-ABE), a scheme described by \citeauthor{lee2013RSABE}~\cite{lee2013RSABE} employing a ciphertext policy. To be more precise, our aim is to build a key-policy version of such scheme and to prove its security in a theoretical framework fit to the application context. Starting from the ideas in \cite{lee2013RSABE}, we modify concepts and techniques described therein to adapt them to our goals.\\
	We observe that a key-policy RS-ABE scheme was independently described by \citeauthor{lee2014}~\cite{lee2014}, but we employ a different construction and different security assumptions, reaching an independent security result.
	
	
	In Section~\ref{sec:structure} we describe the RS-ABE framework, and we give the definition of CPA-security. In Section~\ref{assumptions.sec} we describe the assumptions required for the security of our scheme. In Section~\ref{sec:block} we give an overview of the building blocks of our scheme: Complete Subset (CS), Self-Updatable Encryption (SUE) and key-policy Attribute Based Encryption. In Section~\ref{sec:scheme} we are finally able to describe our scheme in detail and  state our main result on its security.  Section~\ref{sec:proof} is entirely devoted to the proof of our claimed theorem. Finally, in Section~\ref{efficiency.sec} we discuss the efficiency of our key-policy RS-ABE scheme and draw some conclusions, sketching future work.
	


	\section{Structure}\label{sec:structure}
	We provide a high-level description of a \emph{key-policy revocable-storage at\-tri\-bute-based encryption} scheme.  is the set of all possible attributes and an access structure  is a set of subsets of  (for a formal definition, see Definition~\ref{def.accessstructure}). Moreover we denote with  the set of all users. 
	Starting from  and other public parameters, an authority   must create some \emph{public information} () and two general keys:  the \emph{general public key} and the \emph{master key}. The public information contains the general setting and is known to everyone. The general public key, which we shorten to \emph{public key} (), can be used by any user to encrypt, even by anyone having access to the system and knowing only  and . The master key () is used only by 
	 to create the users' private keys (no user has a personal public key), when user requests it, and the (general) \emph{time-update key} (), at any time update. The latter is known to everyone and incorporates the information on the updated list of revoked users. In order to decrypt, any user needs her own \emph{private key} (),  and .\\
	This scheme is described by seven Probabilistic Polynomial Time (PPT) algorithms. 
		\begin{description}
		\singlefunctiondef{Setup}{\lambda,\mathfrak{A},T_{\textnormal{max}},N_{\textnormal{max}}}{\mathit{\mathrm{MK}},\PI,\mathit{\mathrm{PK}}}
		\label{RS-ABE_Setup-theory}
			 is the security parameter,
			 is the set of all possible attributes,
			 is the maximum time which can be used inside the system,
			 is the total number of users who can receive a key. W.l.o.g. we can assume  with .
			The outputs are the master (private) key,   the public information and the (general) public key.
		
		\singlefunctiondefsingleoutput{GenKey}{\mathit{\mathrm{PI}},\mathit{\mathrm{PK}},\mathit{\mathrm{MK}},\mathbb{A},u}{\mathit{\mathrm{SK}}_{\mathbb{A},u}}
		The inputs are
		\begin{itemize} 
		\item all three outputs of \singlefunction{Setup}, that is, , , and , 
		\item , an access structure listing the sets of attributes which the key is able to decrypt, and
		\item , the user assignee of the key.
		\end{itemize}
		The output is 
		, the private key for the user .

\singlefunctiondefsingleoutput{UpdateKey}{\mathit{\mathrm{PI}},\mathit{\mathrm{PK}},\mathit{\mathrm{MK}},T,R}{\mathit{\mathrm{TK}}_{T,R}}
		This function generates a key which links the time  with a set of \emph{revoked users} . The remaining inputs are
		, , and
		.
		The output is
		, the \emph{time-update key} for the time  (and with revoked users ).
		
		\singlefunctiondefsingleoutput{Encrypt}{\mathit{\mathrm{PI}},\mathit{\mathrm{PK}},M,S,T}{\mathrm{CT}_{S,T}}
		The inputs are , , a plaintext
		, 
		 (the set of attributes required to decrypt the plaintext) and
		the encryption time .
		The output is
		, the ciphertext.
		
		\singlefunctiondefsingleoutput{Decrypt}{\mathit{\mathrm{PI}},\mathrm{CT}_{S,T},\mathit{\mathrm{SK}}_{\mathbb{A},u},\mathit{\mathrm{TK}}_{T^{\prime}\!,R}}{M}
		This is the function merging together both the secret key  and the time-update key  to decrypt a ciphertext . Moreover, the public information  is used.
		The output is
		, the decrypted plaintext.
		
		\singlefunctiondefsingleoutput{Update}{\mathit{\mathrm{PI}},\mathit{\mathrm{PK}},\mathrm{CT}_{S,T}}{\mathrm{CT}_{S,T+1}}
		The goal of this function is to update the time  of a ciphertext  by a unit, using only  and .		
		The output is
		, a ciphertext for the same plaintext of , but with updated time.
		
\end{description}
	
	W.l.o.g. we will always assume that the set  of users is the largest possible, that is, .
	
	The \emph{correctness} of a scheme describes which keys can decrypt a ciphertext. This scheme is correct \underline{if}, fixing any , , and  obtained as output of \singlefunction{Setup}, for any plaintext  and any ciphertext  output of \singlefunction{Encrypt}, for any key  output of \singlefunction{GenKey}, and any key  output of \singlefunction{UpdateKey}, \underline{then} the output of \singlefunction{Decrypt} is exactly  \underline{when} all the following are true:
	\begin{itemize}
		\item
		, i.e., the user  is not revoked;
		\item
		, i.e., the ciphertext is older than the update key;
		\item
		, i.e., the set of attributes of the ciphertext is authorized by the key.
	\end{itemize}
	

	We also require that, for any ciphertext  output of \singlefunction{Encrypt}, decrypting the output of \singlefunction{Update} yields the same as decrypting the output of \singlefunction{Encrypt}. 

	\subsection{Definition of security}
	\label{security.sec}
	The security of our scheme is described in term of \emph{indistinguishability under a chosen-plaintext attack} (\emph{IND-CPA}).
	An informal description follows.\\
	An adversary is allowed to query the challenger for a polynomial number of private keys and time-update keys. When satisfied, the adversary presents two different plaintexts  and ; one of them is randomly chosen by the challenger and given back encrypted () to the adversary. The adversary may then continue querying the challenger for other private keys and time-update keys, and must eventually decide which plaintext between  and  corresponds to . Informally, we may consider an RS-ABE scheme secure if the adversary cannot reliably guess which of the two messages was encrypted.\\
	We now provide the corresponding formal security game.
	\begin{definition} \label{security.def}
		The security game describing IND-CPA is played by a PPT  adversary  and a challenger , and consists of five distinct phases. At the start we fix the attributes , the maximum time , the number of users , and the security parameter . Each of these parameters are known by both~ and .
		\begin{description}
			\item[Setup]
			 runs \singlefunction{Setup} to obtain the master secret key , the public information  and the public key . The former is kept secret by , while the others are given to~.
			
			\item[Query, I]
			 is now allowed to query . The maximum number of allowed queries  is polynomial with respect to .
			The queries\footnote{The querying process is adaptive, i.e., the choice for the type of query and the input for the next query may depend on the output of the previous queries. } may be of two different types: private-key queries,  indexed with , or time-update queries, indexed with . 
			\begin{enumerate}
				\item
				(private-key query)
				 chooses a pair  consisting of an access \linebreak{} structure  and a user  who was not previously requested. 
				 runs \singlefunction{GenKey} and gives the output  to .
				\item
				(time-update query)
				 selects a pair , where  is an arbitrary set of users and  is a time for which there was no previous request for a private key ().
				 runs \singlefunction{UpdateKey} and hands its output 
				 
				to~.
			\end{enumerate}
			
			
			\item[Challenge]
			\label{security.challenge}
			 chooses two plaintexts  and , together with a time  and a set of attributes .
			We require also that, for each previous private-key query  and  time-update query  occurring in Query~I, the following condition holds\footnote{Since  and  are going to be used in the encryption,    must not be able to decrypt the message using the keys she previously queried.}
				
			 selects randomly a bit  and runs \singlefunction{Encrypt}.\\ The obtained output  is returned to .
			
			\item[Query, II]
			This phase is similar\footnote{with the additional restriction that any key which would allow  to simply use \singlefunction{Decrypt} cannot be requested. The querying process is again adaptive.} to the previous querying phase.			
			 can continue to query  a polynomial number of times with respect to~ with two possible requests.
			\begin{enumerate}
				\item
				(private-key query)
				 chooses a pair , where    was not previously requested, such that 
				\begin{itemize}
				\item , or
				\item for each  such that , then .
				\end{itemize}
				 runs \singlefunction{GenKey} and gives the output  to~.
				
				\item
				(time-update query)
				 selects a pair , where  is an arbitrary set of users and  is a time that was no previous requested for a previous time-update key () such that
				\begin{itemize} 
				\item , or
				\item for each  such that , then .
				\end{itemize}
				 runs \singlefunction{UpdateKey} and gives the output    to .
			\end{enumerate}
			
			
			\item[Guess]
			 outputs a guess  for the value of .
		\end{description}
		If the output is correct, the adversary wins the game.		
		The \emph{advantage} of the adversary  is defined as the likelihood of making the right guess for :
		
		Since the output of the functions shaping the scheme may depend on randomly chosen parameters, the advantage is described in term of the probability over all possible choices for their output considering their distribution.
	\end{definition}	
	\begin{definition}
 		A function  is \emph{negligible} in  if for every  and for every  there exists  such that  for all .
 	\end{definition}
	\begin{definition}[Security]
		The RS-ABE scheme is said to be \emph{IND-CPA-secure}, or \emph{secure for a chosen-plaintext attack}, if the advantage of a PPT adversary is negligible with respect to the security parameter .
	\end{definition}
	
	
Notice how the use of \singlefunction{Update} does not allow the adversary to request a key that would allow the decryption of an updated ciphertext, because of the restrictions of the challenge phase and second-query phase. 
	
	Notice that the update key is not required to be secret.
	
	The aim of this paper is to propose a key-policy RS-ABE scheme which can be shown to be secure for a chosen-plaintext attack if the three assumptions in the next section hold.
	
	

	\section{Assumptions}
	\label{assumptions.sec}
	We work in the context of composite-order bilinear groups, adapted for the special case , where each  is a prime number. This is a concept first introduced by Boneh et al.~\cite{kilian2005bilineargroups}.
	\begin{definition}[Bilinear group]
		\label{bilineargroup.def}
		A \emph{bilinear group} (of composite order three) is identified by the tuple
		
		 where:
		
		\begin{enumerate}
			\item
			,  and  are three distinct primes, and ;
			\item
			 and  are two cyclic groups of order~;
			\item
			 is a map such that:
			\begin{itemize}
				\item
				\definline{bilinear} for every  and , 
				
				\item
				\definline{non-degenerate} there exists  such that  generates~.
			\end{itemize}
		\end{enumerate}
		\end{definition}
		\begin{definition}
		\label{groupdes.def}
		A \emph{group descriptor} (of composite order three) is\\ a tuple  such that
		\begin{itemize}
		\item the tuple  is a bilinear group;
		\item the group operations of~ and~ and the map  are efficiently computable;
		\item  is a generator of ,  is a generator of  and  is a generator of , where  is the subgroup of~ with order~.
		\end{itemize}
		\end{definition}
		\begin{remark}
		The three generators , , and  are only used implicitly to generate random element of the group  and its subgroups , , and .
		\end{remark}
		
		We observe that  generates , that  is a generator of~ and that every element of~ has the form  for some~.
		\begin{definition}
		\label{groupdesgen.def}
		A \emph{group descriptor generator}  is a polynomial algorithm which takes as input the security parameter~ and outputs a group descriptor \linebreak  such that 
	the group operations and the bilinear map  are computable in polynomial time with respect to~.
	\end{definition}
	


	The group descriptor  contains all the parameters used by the challenger for generating random elements of the group   and its subgroups. The adversary knows only the tuple , which allows him to compute group operations and the bilinear map.
	
	The  following three assumptions fix the properties which must hold for a group descriptor generator , used in \singlefunction{Setup} (page~\pageref{RS-ABE_Setup-theory}).
	With the notation
	
	we specify that we are choosing an element  among the elements of  using a uniform random distribution. These assumptions were introduced by Lewko et al.~\cite{lewko2010assumptions}.
	Notice that in the following 
	the element  belongs to , and 
	the element identified with the letters , , and  belong respectively to , , and .

	\begin{assumption}[Subgroup decision problem]
		\label{a1}
		Let  be a group descriptor generator and for any  compute .
		We choose randomly the following elements:
			;
			;
and we call . 
		We choose randomly two other elements:
			;
			.
		The advantage of an algorithm  is defined as:
		
		This advantage is denoted with .
		We say that  satisfies Assumption \ref{a1} if for any PPT algorithm  we have that  is a negligible function with respect to .
	\end{assumption}
	\noindent The previous assumption could be informally rephrased as follows.
An adversary  returns , i.e , if and only if she thinks that  is 
in the small subgroup , knowing that in any case  is in the large subgroup .
Her advantage is a measurement of the correctness of her guess.
In the case she is randomly guessing, she would return  half of the times and so her advantage
would be zero. What we want with this assumption is to make any adversary at most negligibly better than a random guess.
	\begin{assumption}[General subgroup decision problem]
		\label{a2}
		Let  be a group descriptor generator and for any  compute . 
		We choose randomly the following elements:
			;
			;
			;
		and we call \linebreak .
		We choose randomly two other elements:
			
			.
		The advantage of an algorithm  is defined as:
		
		This advantage is denoted with .
		We say that  satisfies Assumption \ref{a2} if for any PPT algorithm  we have that  is a negligible function with respect to .
	\end{assumption}
	\noindent In this assumption,  is trying to guess if  is  in the subgroup , knowing that in any case  is in  group .
	\begin{assumption}[Composite Diffie-Hellman problem]
		\label{a3}
		Let  be a group descriptor generator and for any  compute .
		We choose randomly the following elements:
			;
			;
			;
			;
		and we call \linebreak 
		. 
		We choose randomly another element
			,
		and we fix .
		The advantage of an algorithm  is defined as:
		
		This advantage is denoted with .
		We say that  satisfies Assumption \ref{a3} if for any PPT algorithm  we have that  is a negligible function with respect to .
	\end{assumption}
	


	





	\section{Building blocks}\label{sec:block}
	
	We build our original key policy RS-ABE, starting from the ideas described by Lee et al.~\cite{lee2013RSABE} and adapting them to the key-policy case. To construct the scheme we outline three different schemes, which are later merged to form RS-ABE. These schemes are the \emph{complete subset} scheme (\emph{CS})~\cite{naor2001SC}, a \emph{self-updatable encryption} scheme (\emph{SUE})~\cite{lee2013RSABE}, and an \emph{attribute-based encryption} scheme (\emph{ABE})~\cite{lewko2010ABE}.


	\subsection{Notation}
	In the following construction we employ perfect binary trees. 
A perfect binary tree  of depth  is a binary tree where all leaf nodes has depth , and all other nodes have exactly two children. Obviously,  exactly  leaves hang from . Each node of  is denoted  , where the index  is assigned using breadth-first search on the tree. In other words, the root node has index , the left child of  has index  and the right child has index~.\\ 
	For each node  we call  the maximal subtree of  having  as root node. Clearly,  is a perfect binary tree. To say that a node  belongs to a subtree  we write .
	
	In our case, each user in   is associated to a leaf of the tree and vice versa. Sometimes,   will denote the leaf corresponding to the user. The set  contains all users associated with a leaf of the subtree , in other words, all users whose leaf meets the node  in the path from the leaf to the root node (see Figure \ref{fig1}).

	\begin{figure}[H]
	\begin{center}
	\forestset{
		nice empty nodes/.style={
delay={where content={}{shape=coordinate,for parent={for children={anchor=north}}}{}}
	}}
	\begin{forest}
		grow down/.style={for tree={grow=south,
		  s sep=.5cm,
		  parent anchor=south,
		  child anchor=north
		  }
		}
		[ , draw, for tree={   l sep=0em, l=3.5em,	   grow down,
									edge={dashed},
									if={n_children==0} {circle, 
											draw, 
											minimum size=1.2em,
											l sep=1.6em,
											inner sep=0
										}
										{
										}
								}, 
							nice empty nodes ,
[  , draw,
	   tikz={\node [draw,rounded corners,line width=\boxPVWidth,boxPV,fit=(!11)(!22)] {};} [, for tree={consideredEdge,edge={solid}, line width=\consideredWidth} [   ] 
		   [   ] ]
	     [ , for tree={consideredEdge,edge={solid}, line width=\consideredWidth},  draw ,
[   ,
, ] 
		   [   ] ] ]
	   [ [ [   ] 
		   [   ] ]
	     [ [   ] 
		   [   ] ] ] ]
	\end{forest}
	\end{center}
		\caption{The solid line represents the subtree  with root  and the box represents the set .}
		\label{fig1}
	\end{figure}
	
	 The \emph{Steiner tree} , for a tree  and a proper set of users , is the smallest subtree of  containing the root node and the leaves associated to all users in . Observe that a Steiner tree is binary perfect only if .
	
	\subsection{Complete subset scheme}
	\label{cs.sec}
	The complete-subset scheme is a particular implementation of the subset cover framework, introduced by Naor et al.~\cite{naor2001SC}. We use the same implementation described by Lee et al.~\cite{lee2013RSABE}.
	Notice that the subset-cover scheme as we describe it is not a full-fledged encryption mechanism, but rather a framework upon which we build encryption. Our main use of a CS scheme is to handle revoked users.\\
	The CS scheme is described by the following four functions.
	\begin{description}
	\algorithmdefsingleoutput{CS}{Setup}{N_{\textnormal{max}}}{\tree{}} we take the number of users  as an input and we build a perfect binary tree  with depth .
		Then we assign to each user in  a unique leaf of the tree. The tree  is the output of this function.

		\algorithmdefsingleoutput{CS}{Assign}{\tree{},u}{\PV_{u}} given the users' tree  and a user , we output as \emph{private set} the subsets in  of the form  which contains :
		
		where  is the power set of .\\
		Observe that .


		\algorithmdefsingleoutput{CS}{Cover}{\tree{},R}{\CV_{R}} we consider the Steiner tree . We denote with  all children of a node in  which are not in . The \emph{covering set}  is then (see Figure \ref{figure.cover}):
		
		Notice that   is a partition of .
		
		\begin{figure}[H]
			\begin{center}
	\forestset{
		nice empty nodes/.style={
delay={where content={}{shape=coordinate,for parent={for children={anchor=north}}}{}}
	}}
	\begin{forest}
		grow down/.style={for tree={grow=south,
		  s sep=.5cm,
		  parent anchor=south,
		  child anchor=north
		  }
		}
		[ , for tree={   l sep=0em, l=3.5em,	   grow down,
									if={n_children==0} {circle, 
											draw,
											minimum size=1.2em,
											l sep=1.6em,
											inner sep=0
										}
										{
										}
								}, 
							nice empty nodes
	   [ , edge={revokedEdge, line width=\revokedWidth} [ , edge={revokedEdge, line width=\revokedWidth} [   , edge={dashed},
	   tikz={\node [draw,rounded corners,line width=\boxCVWidth,boxCV,fit=()] {};} ] 
		   [  , edge={revokedEdge, line width=\revokedWidth}, fill=revokedNode ] ] [  , draw,edge={dashed}, tikz={\node [draw,rounded corners,line width=\boxCVWidth,boxCV,fit=(!1)(!2)] {};}[   ,edge={dashed} ] 
		   [   ,edge={dashed} ] ] ]
	   [ , edge={revokedEdge, line width=\revokedWidth} [ , edge={revokedEdge, line width=\revokedWidth} [  , edge={revokedEdge, line width=\revokedWidth}, fill=revokedNode ] 
		   [   ,edge={dashed},
	   tikz={\node [draw,rounded corners,line width=\boxCVWidth,boxCV,fit=()] {};}
	    ] ]
	     [ , edge={revokedEdge, line width=\revokedWidth} [  , edge={revokedEdge, line width=\revokedWidth}, fill=revokedNode ] 
		   [  , edge={revokedEdge, line width=\revokedWidth}, fill=revokedNode ] ] ] ]
	\end{forest}
	\end{center}
	\caption{. The solid subtree is the Steiner tree , the gray leaves are the revoked users, , , , , , .}
		\label{figure.cover}
		\end{figure}
		
		\algorithmdefsingleoutput{CS}{Match}{\CV_R,\PV_u}{U} we find a match between a covering set  and a private set  simply by considering the (unique) element in the intersection of the two sets, , when it exists (see Figure \ref{fig3}). The output is 
		if  exists, empty otherwise.
		A match exists if and only if the user is not revoked. It must be unique, since  is a partition.
	
	\begin{figure}[H]
	\begin{center}
	\forestset{
		nice empty nodes/.style={
delay={where content={}{shape=coordinate,for parent={for children={anchor=north}}}{}}
	}}
	\begin{forest}
		grow down/.style={for tree={grow=south,
		  s sep=.5cm,
		  parent anchor=south,
		  child anchor=north
		  }
		}
		[ , for tree={   l sep=0em, l=3.5em,	   grow down,
									if={n_children==0} {circle, 
											draw, 
											minimum size=1.2em,
											l sep=1.6em,
											inner sep=0
										}
										{
										}
								}, 
							nice empty nodes
	   [ , edge={revokedEdge, line width=\revokedWidth} [  , edge={revokedEdge, line width=\revokedWidth} [  , edge={dashed} ] 
		   [   , edge={revokedEdge, line width=\revokedWidth} , fill=revokedNode ] ]
	     [ , edge={consideredEdge, dotted, line width=\consideredWidth},
	   tikz={\node [draw,rounded corners,line width=\boxSetWidth,boxSet,fit=(!1)(!2)] {};} [   , edge={consideredEdge, dotted, line width=\consideredWidth}, fill=consideredNode] 
		   [   , edge={dashed} ] ] ]
	   [ , edge={revokedEdge, line width=\revokedWidth} [ , edge={revokedEdge, line width=\revokedWidth} [  , edge={revokedEdge, line width=\revokedWidth}, fill=revokedNode ] 
		   [   , edge={dashed}
	    ] ]
	     [ , edge={revokedEdge, line width=\revokedWidth} [  , edge={revokedEdge, line width=\revokedWidth}, fill=revokedNode ] 
		   [  , edge={revokedEdge, line width=\revokedWidth}, fill=revokedNode ] ] ] ]
	\end{forest}
	\end{center}
	\caption{Considering Figure~\ref{figure.cover}, the box is the output of \singlefunction{CS.Match} for . }
	\label{fig3}
	\end{figure}
	
	\end{description}
	\begin{remark}
	It is worth considering the size of the private set and of the covering set. Recall that  and let  then~\cite{naor2001SC}
	
	
\end{remark}
		
	\subsection{Self-updatable encryption scheme}
The self-updatable encryption scheme (SUE) manages the evolution of the system, introducing a discrete time structure used to equip ciphertexts and keys with specific times. The basic idea behind this scheme is to associate (with depth-first search) each time with a node of a perfect binary tree and then to employ the ciphertext-delegatable encryption scheme (CDE)~\cite{lee2013RSABE} to validate the time of the given decryption key, exploiting the tree structure. This allows to identify the nodes associated with a time bigger than a certain threshold, by using a small number of keys.\\
Here we present  a high-level description of  the SUE scheme.
The SUE scheme is characterized by the following five PPT algorithms, the detailed description is provided by Lee et al.~\cite{lee2013RSABE}.
\begin{description}

	\algorithmdef{SUE}{Setup}{\mathscr{S},T_\textnormal{max}}{\mathrm{MK},\mathrm{PI},\mathrm{PK}} given a string\footnote{we might  as well give a group descriptor.}  and the maximum admissible time , it outputs the master  key , which is used by the authority  to create private keys,   the public information  and the (general) public key . In particular, we choose randomly the elements  and . The outputs of the function are
	,   and the (general) public key , that is, a string containing ,  and some randomly chosen elements in .
	
	
			
		\algorithmdefsingleoutput{SUE}{GenKey}{\mathrm{PI},\mathrm{PK},\mathrm{MK},T^{\prime}}{\mathrm{SK}_{T^{\prime}}} given the public information , the public key , the master key  and a time , it outputs a private key  associated  .
		
		
		\algorithmdef{SUE}{Encrypt}{\mathrm{PI},\mathrm{PK},T,M}{C,\mathrm{CH}_{T}} given the public information , the public key , a time  and a plaintext , it outputs the ciphertext  and the  ciphertext header  associated with the time . In particular, we choose randomly an element  and a session key  is computed. With , we compute  and we do not output .
		
		
		
	
		
		\algorithmdef{SUE}{Decrypt}{\mathrm{PI},\mathrm{SK}_{T^{\prime}},\mathrm{CH}_{T},C}{\mathrm{EK},M} given
		the public information , a ciphertext  for the time  and a secret key  for the time , first it computes  from the ciphertext header  and then  . Note that the output  might be empty in case the given key is not allowed to decrypt the ciphertext.
		
		\algorithmdefsingleoutput{SUE}{Update}{\mathrm{PI},\mathrm{PK},\mathrm{CH}_{T}}{\mathrm{CH}_{T+1}}
		given the public information , the public key  and a ciphertext  associated with a time , it outputs a ciphertext  associated with the time , which decrypts to the same plaintext of 
	
		
		\algorithmdefsingleoutput{SUE}{Randomize}{\mathrm{PI},\mathrm{PK},\mathrm{CH}_{T}}{\overline{\mathrm{CH}}_{T}} given the public information , the public key  and a ciphertext  for the time , it outputs a  ciphertext  for the same time .
		This function takes a ciphertext and transforms it to another one, associated with the same time, but which decrypts to the same plaintext.\footnote{The function is named ``Randomize" because it changes the internal randomness used to create the ciphertext.} 
		
	\end{description}
	
	\noindent The \emph{correctness} of this scheme is characterized by a correct decryption:
	
	when  is a time less or equal than , or otherwise empty.
	This must be true for every output of \singlefunction{SUE.Setup}, any valid times , , any ciphertext  generated by \singlefunction{SUE.Encrypt} and any private key  generated by \singlefunction{SUE.GenKey}.
	We require also that for any ciphertext , the decryption of  offers the same plaintext as the 
the decryption of \singlefunction{SUE.Randomize}.
	The distribution of the outputs of \singlefunction{SUE.Randomize} must be equal to the distribution of the outputs of \singlefunction{SUE.Encrpyt}.
	
	\subsection{Attribute-based encryption scheme}
	The attribute-based encryption scheme (ABE) regulates the access to ciphertexts with respect to the presence or absence of specific attributes.
	ABE is an encryption scheme delineated for the first time by Sahai and Waters~\cite{sahai2005}. The first fully secure ABE scheme is described by Lewko et al.~\cite{lewko2010ABE}, and this is the scheme we are going to employ. Various other results for ABE are described in~\cite{chase2007, garg2013, waters2011}, and a non-monotonic ABE scheme in~\cite{ostrovsky2007}.
	\begin{definition}[Access structure]
	\label{def.accessstructure}
	An \emph{attribute} is an element of a given finite set , the set of all attributes. An \emph{access structure} is a non-empty subset of . 
	An access structure  is \emph{monotonic}  if for any   we have that also
	all supersets of  belong to . 
	\end{definition}
	\noindent From now on we consider implicitly only monotonic access structure.
	
	We can find two different forms of ABE schemes, depending on the position of attributes and access structure between the key and the ciphertext. The differentiation was first stated in~\cite{goyal2006}.
	\begin{itemize}
		\item
		A \emph{ciphertext-policy} (\emph{CP}) ABE scheme provides  each ciphertext with an access structure  (from which the name ``ciphertext-policy''), and  each secret key with a set of attributes .
		\item
		A \emph{key-policy} (\emph{KP}) ABE scheme does exactly the converse: it provides  each secret key with an access structure , and  each ciphertext with a set of attributes .
	\end{itemize}
	A general method to transform a KP-ABE in a CP-ABE scheme is discussed in~\cite{goyal2008}.	
	We are going to describe the KP version of the scheme of Lewko \cite{lewko2010ABE}, since we are going to construct our RS-ABE scheme from it. A key-policy RS-ABE scheme was independently described by \citeauthor{lee2014}~\cite{lee2014}; however the author employs a different construction and different assumptions to prove the security of the scheme.
\subsubsection{Linear Secret Sharing Scheme.}	
Before describing the construction of the ABE algorithm, we have to recall the construction of a \emph{linear secret sharing scheme (LSSS)} that is used in order to manage the attribute structure. For more details about LSSS see~\cite{beimel1996SSS}.
\label{LSSS_def}

	The classical construction, that we are going to present, distributes the shares to each \texttt{LSSS user}. However in an ABE scheme the role of the LSSS users is played by the attributes in . So we will use the set  for the set of LSSS users, with  denoting any LSSS user.

		Let  be the set of the possible secrets. A \emph{linear secret sharing scheme}  (\emph{LSSS}) for a secret  is a scheme constructed with the following procedure. 
		\begin{enumerate}
			\item
			Let  be a public parameter. The authority knows the secret  and chooses a random element  uniformly over . 
			\item
			 The authority assign to each LSSS user    a vector in , called the \emph{vector of shares}. The  are  public parameters.  Each vector entry, a \emph{share}, is a linear combination of  and of 's.
\noindent We denote the  element of the shares vector of  as , and we call  the \emph{size} of the scheme.
		\end{enumerate}
	We can then identify a generic LSSS with a pair  and a vector , where:
	
	\begin{itemize}
		\item
		 is an  matrix used to generate all the shares.
		\item
		 is a function which assigns to every row of the matrix its corresponding LSSS user.
		\item
		 is a vector in  which has the secret as the first component, and the remaining ones are random elements of .
	\end{itemize}
The authority creates the shares multiplying the matrix  by the vector . Then, each LSSS user  receives all  corresponding components of the vector , i.e.,  obtains from the authority the elements with position in the set  as shares. The sets of LSSS users who can obtain the secret are the \emph{authorized sets}. The authorized sets form an access structure  which is monotonic, since adding LSSS users does not diminish the number of shares available for retrieving the secret.


Any authorized set  can reconstruct the secret via linear combination of their shares. This means that there exist some constants 
			
			such that the secret  can be obtained as
			
			More details are provided by Beimel~\cite{beimel1996SSS}.



\subsubsection{Construction of the ABE scheme.}\label{ABE.construction}
First we have to suppose that the function  is injective, i.e., to each attribute is assigned only a single share. This hypothesis is used in the proof of security of  RS-ABE\@ scheme (see Section~\ref{security_section}). This restriction can be lifted by enlarging the dimensions of the keys, as we are going to see in Section~\ref{efficiency.sec}. For describing the construction we use the same notation as in the previous sections.
\begin{description}
		\algorithmdef{ABE}{Setup}{\mathscr{S},\mathfrak{A}}{\mathrm{MK},\mathrm{PI},\mathrm{PK}} where   and   is a set of attributes.\\ We choose randomly the elements:\begin{itemize}
		\item ;
		\item ;
		\item .
	\end{itemize}
The outputs of the function are the master secret key , the public information ,
	
	and the (general) public key,
	
	
	\algorithmdefsingleoutput{ABE}{GenKey}{\mathrm{PI},\mathrm{PK},\mathrm{MK},\mathbb{A}}{\mathrm{SK}_{\mathbb{A}}} where  is a generic LSSS access structure  as in Section~\ref{LSSS_def}, of size  for a set of attributes , such that   is a matrix with  rows and  columns.\\ 
	We choose randomly the elements:
\begin{itemize}
		\item ;
		\item ;
		\item .
	\end{itemize}
	We also define the vector .\\
	The output is the secret key\footnote{Any secret key is actually a list of  key pairs. Both keys in a pair lie in .} associated with the access structure :
	
	where  indicates the  row of the matrix .
	\algorithmdef{ABE}{Encrypt}{\mathrm{PI},\mathrm{PK},S,M}{C,\mathrm{CH}_{S}} where  is a set of attributes and    is a plaintext. First, randomly chosen , it computes
	
	then the outputs are  and the ciphertext header:
	

	
	\algorithmdef{ABE}{Decrypt}{\mathrm{PI},\mathrm{SK}_{\mathbb{A}},\CH_S,C}{\EK,M} the output is the same session key  we have obtained when we ran \algorithm{ABE}{Encrypt} and the corresponding plaintext . Since  is authorized  for , we know that there exist some constants  such that 
	If we know the 's. we can compute the session key:
	
	and then the plaintext .

	
	\algorithmdef{ABE}{Randomize}{\mathrm{PI},\mathrm{PK},\EK,\CH_{S},\overline{s}}{\EK^{\prime},\overline{\CH}_{S}} .
	If we call the components of the given header as  the outputs are the rerandomized session key:
	
	and the rerandomized ciphertext header:
	

	\end{description}
	
The correctness of the ABE algorithm follows from the properties of the bilinear map .
	
	
	
	\pagebreak
	\section{The scheme}\label{sec:scheme}
	
	In this section we describe our construction of a key-policy RS-ABE scheme and we show its correctness. We strongly recommend the reader to read the following scheme description while rereading Section \ref{sec:structure} since we use the notation we introduced before, providing the details required to build the scheme.
	
	\subsection{Construction}
	
	\begin{description}
	\algorithmdef{RS-ABE}{Setup}{\lambda,\mathfrak{A},T_{\textnormal{max}},N_{\textnormal{max}}}{\mathit{\mathrm{MK}},\mathit{\mathrm{PI}},\mathit{\mathrm{PK}}} 


	We take the following steps.
	\begin{enumerate}
		\item
		We use the security parameter to generate a group descriptor  (De\-finition~\ref{groupdes.def}) using a group descriptor generator  (Definition~\ref{groupdesgen.def}). We fix a generator  of , and we define .
		\item
		We use \algorithm{CS}{Setup} to obtain a perfect binary tree  with  leaves.
		\randomchoose{p}, for each node .
		Every node  of the tree  is associated with the element .
		\item
		We choose randomly the elements:
		\begin{itemize}
\item ;
		\item ;
		\item .
	\end{itemize}
		
		\item
		For each node  we define 
	
	
	Note that we are considering almost the same construction of  as \algorithm{ABE}{Setup}:  for each node  we have a common  but a different . We will denote .
	\item
	We define
	
Note that we are considering almost the same construction of  as \algorithm{ABE}{Setup} but here    does not contain  for any .
\item
For each node  we define
	
	
	Note that we are considering almost the same construction of  as \algorithm{SUE}{Setup}: for each node  we have a common  but a different  (the same considered before). We will denote .
	\item
	We define  containing  and some randomly chosen elements in .\\
	Note that we are considering almost the same construction of  as \algorithm{SUE}{Setup} but here    does not contain  for any .



	\end{enumerate}
	The final output is:
	
	
	
	
	\algorithmdefsingleoutput{RS-ABE}{GenKey}{\mathit{\mathrm{PI}},\mathit{\mathrm{PK}},\mathit{\mathrm{MK}},\mathbb{A},u}{\mathit{\mathrm{SK}}_{\mathbb{A},u}} this function generates a secret key associated with the user index  and an access structure , requiring as input also the public information, the (general) public key and the master secret key.
	\begin{enumerate}
		\item
		We run \algorithm{CS}{Assign} and obtain a private set .
		\item
 		 We consider the ABE  public key  and for every  from  to  the ABE master private key . We  obtain  by running \algorithm{ABE}{GenKey} .
	\end{enumerate}
	Then we output the secret key:
	
	
	\algorithmdefsingleoutput{RS-ABE}{UpdateKey}{\mathit{\mathrm{PI}}, \mathit{\mathrm{PK}},\mathit{\mathrm{MK}},T,R}{\mathit{\mathrm{TK}}_{T,R}} this function generates the key  which associates with a certain time  the corresponding set of revoked users . It requires  the public information, the public key and the master private key of the scheme.
	\begin{enumerate}
		\item
		We run \algorithm{CS}{Cover} and obtain a covering , for some , and every set  is the set of the leaves of the subtree .
		\item
		We consider the SUE public key  and for every  from  to   the SUE master private key . We  obtain  by running \algorithm{SUE}{GenKey}.
	\end{enumerate}
	Then we output the time key:
	
	
	\algorithmdefsingleoutput{RS-ABE}{Encrypt}{\mathit{\mathrm{PI}},\mathit{\mathrm{PK}},M,S,T}{\mathrm{CT}_{S,T}} we require as input the public information, the public key, a  plaintext , a set of attributes  and a time . The output is a ciphertext .
	\randomchoose{s}.
	Then we run \algorithm{ABE}{Encrypt} and \algorithm{SUE}{Encrypt} in order to obtain  and . The output ciphertext is:
	
	
	\algorithmdefsingleoutput{RS-ABE}{Decrypt}{\mathit{\mathrm{PI}},\mathrm{CT}_{S,T},\mathit{\mathrm{SK}}_{\mathbb{A},u},\mathit{\mathrm{TK}}_{T^{\prime}\!,R}}{M} we require as input the public information, a ciphertext  for a time  and a set of attributes , a private key  for a user  and an LSSS access structure  which contains , a time key  for a time  and a set of revoked users such that . The output is the  plaintext .
	
	\begin{enumerate}
		\item
		We run \algorithm{CS}{Match} and obtain a set of users of the form .
		\item
		We run \algorithm{ABE}{Decrypt} to obtain  and  \algorithm{SUE}{Decrypt} to obtain , which are the ciphertext headers used for the decryption in ABE and SUE. By construction,  the ABE ciphertext header and the SUE ciphertext header do not depend on , so it is not necessary to include the index  in  and .
	\end{enumerate}
	Then we output the plaintext:
	
	
	\algorithmdefsingleoutput{RS-ABE}{Update}{\mathit{\mathrm{PI}},\mathit{\mathrm{PK}},\mathrm{CT}_{S,T}}{\mathrm{CT}_{S,T+1}} the inputs are the public information, the public key and a ciphertext.
	The output is a ciphertext  which encrypts the same plaintext of  with the time updated by a unit.
	We fix  by running \linebreak \algorithm{SUE}{Update}
	.
	The output ciphertext is:
	
	
\end{description}
	
	\subsection{Correctness}\label{subsec:cor}
	The decryption process finds a match for the private set and the partition of the non-revoked users, which always exists when the user is not revoked, from the construction of the CS scheme~\cite{naor2001SC}. Then we use the keys corresponding to the found match to retrieve the session keys of SUE and ABE. Due to the choice of the private key when creating the keys  and , from the correctness of the ABE and SUE schemes we obtain  and .
	The decryption process can be expanded as:
	
	The time is correctly updated by \algorithm{RS-ABE}{Update}, since we are using the update properties of the SUE scheme.


	\subsection{Security for a chosen-plaintext attack}
	\label{security_section}
	We are now ready to state the following result on the security of the key-policy RS-ABE scheme we have just described.
	
	\begin{theorem}[Security]
	\label{RS-ABE_security_th}
	If Assumptions~\ref{a1}, \ref{a2}, and \ref{a3} are valid, then the key-policy RS-ABE scheme is secure under a chosen-plaintext attack.
	\begin{comment}
	Moreover, the advantage of the RS-ABE scheme is restrained by the inequality
	
	where  is a PPT adversary who queries at most  between private and update keys,  is the maximum number of users,  is the maximum size of a set of revoked users
	\end{comment}
	\end{theorem}
	


The idea behind our proof starts from the strategy adopted by Lee et al.~\cite{lee2013RSABE} for the proof of security of their ciphertext-policy RS-ABE scheme. For our key-policy RS-ABE scheme we want to show that a PPT adversary  plays the security game with negligible advantage.
	
	First we are going to define the so-called \emph{semi-functional} algorithm, a slightly modified version of the algorithm of the existing schemes. Then we define indexes to identify each request of the adversary, and later we describe the game structure and the reductions to our assumptions.
	
	We use hybrid games to prove our result: we split the proof of security of the original game in a sequence of lesser proof involving \emph{hybrid games}, where a hybrid game and the following differ 	only slightly. These hybrid games are constructed by taking each single request of the adversary in account: starting from the base security game, each ensuing game keeps each request equal to its following one, except for a single request. During this request, the key supplied to the adversary changes, with respect to the previous game, from standard to semi-functional.
	


	\subsubsection{Semi-functional algorithms}
	\label{semifunctional.def}
	Here we define the semi-functional versions of the algorithm \algorithm{RS-ABE}{GenKey}, and \algorithm{RS-ABE}{Enrypt}. 
	In the proof of Theorem \ref{RS-ABE_security_th} (Section \ref{sec:proof}), we will also use the semi-functional version \algorithm{RS-ABE}{UpdateKeySF} of the algorithm \algorithm{RS-ABE}{UpdateKey} but we omit here the definition, since the SUE part of the scheme is only modified, for which we refer to the work done by Lee et al.~\cite{lee2013RSABE}.  
	Henceforth we refer to the unmodified version of those algorithms as \emph{standard}. In the hybrid games the standard version of each algorithm will be gradually swapped by its semi-functional counterpart.

	For all semi-functional algorithms we fix a generator  of . Then we fix randomly in  two elements ,  for each node  of the binary tree . These elements will be used to link each other the semi-functional keys between multiple requests,  will be associated with semi-functional private key generation, and  will be associated with time-update key.	
Moreover, for each possible attribute in  we fix an element .


	\begin{description}
	
\algorithmdefsingleoutput{RS-ABE}{GenKeySF}{\mathrm{PI},\mathrm{PK},\mathrm{MK},\mathbb{A},u}{\mathrm{SK}_{\mathbb{A},u}} first we generate a standard private key  using the standard version of the algorithm, \algorithm{RS-ABE}{GenKey}, considering as parameter the user  and the access structure , . The private set is the set .
	
	We use a construction similar to the one employed in \algorithm{ABE}{GenKey}. For each ABE key  associated with the set  we fix some random elements  and we set . 
	Then the corresponding semi-functional ABE key is given by \linebreak  
	
	The output is then:
	
	
\begin{comment}


	\algorithmdefsingleoutput{RS-ABE}{UpdateKeySF}{\mathrm{PI},\mathrm{PK},\mathrm{MK},T,R}{\mathrm{TK}_{T,R}} the first step is to generate a standard time-update key  using the standard \algorithm{RS-ABE}{UpdateKey}, associating it to the time  and the set of revoked users . The covering set is the set .
	
	The final result is very similar to the output of \algorithm{SUE}{GenKey}. For each SUE key  associated with the set  the corresponding semi-functional SUE keys is given by 
	
	We output the semi-functional time key .



\algorithmdef{SUE}{EncryptSF}{\mathrm{PK},T,c}{EK,CH_{S,T}}  first we generate a standard ciphertext header  for a time  and a session key . Moreover we denote with  the label of length  associated with the ciphertext header . We call also .
We choose randomly the elements , , and .
We define then .
\begin{enumerate}
	\item
	We write the first CDE header as .
	The first semi-functional CDE ciphertext for  is 
	\item
	For each  from  to  we do the following:
	\begin{itemize}
		\item
		If  is empty, then  remains empty.
		\item
		Otherwise we fix  and we set:
	
	\end{itemize}
\end{enumerate}
The final output is	 and .

\algorithmdefsingleoutput{RS-ABE}{UpdateKeySF}{\mathrm{PK},\mathrm{MK},T,R}{\mathrm{TK}_{T,R}}
\end{comment}
\algorithmdef{SUE}{EncryptSF}{\mathrm{PI},\mathrm{PK},T,M,c}{C,\mathrm{CH}_{T}} we omit the definition of this  function, since the SUE part of the scheme is only modified, for which we refer to the work done by Lee et al.~\cite{lee2013RSABE}.

\algorithmdef{ABE}{EncryptSF}{\mathrm{PI},\mathrm{PK},S,M,c}{C,\mathrm{CH}_{S}} first we generate a standard ciphertext header  associated with a set of attributes  and a standard session key .
	
	Then the output is:  and 
	
	
	\algorithmdefsingleoutput{RS-ABE}{EncryptSF}{\mathrm{PI},\mathrm{PK},M,S,T}{\mathrm{CT}_{S,T}} first we generate a standard ciphertext  using \algorithm{RS-ABE}{Encrypt}, associating it to the set of attributes  and the time .
	Now we create a semi-functional header both for the ABE part and the SUE part of the scheme.
	We choose randomly the element , and	
	we input  in the previous functions: we run \algorithm{ABE}{EncryptSF} and \algorithm{SUE}{EncryptSF} in order to obtain  and , discarding the session keys.
	
	The output ciphertext is:
	
	
	\end{description}
	


	Observe that knowing the semi-functional private key and update key does not allow us to decrypt a semi-functional encrypted text. The result of a decryption attempt would result in a randomized plaintext.

	\section{Proof of Security}\label{sec:proof}
	\subsection{Key indexing}
	During the proof of Theorem~\ref{RS-ABE_security_th} we want to be able to easily manage each different key request made in the querying phases of the security game.
	Each RS-ABE private key is a list of ABE keys, each of them associated with a different node of the tree . The same is true for a time-update key, which is basically a list of SUE private keys.
	This means that the adversary makes multiple requests of private ABE and SUE keys associated with the same node.
	
	We consider for example the requests for ABE keys; the notation is identical for SUE keys. We are going to identify each of them using a pair of integers . The first component is called \emph{node index}, and the second component is called \emph{counter index}.
	
	Their value is assigned as follows: suppose that a request is made for an ABE key associated with the node .
	\begin{itemize}
		\item
		The node index  is computed in two different ways, depending on the number of time the same node was requested.
		\begin{itemize}
			\item
			If this is the first time at which a key associated with the node  was requested, then we set  equal to the number of distinct nodes associated with previous ABE requests.
			\item
			Otherwise, we set the  equal to the value of the node index of the previous request for the same node .
		\end{itemize}
		In a request for the same node the node index remains always the same.
		\item
		The counter index  is instead incremental for the same node, which means the following.
		\begin{itemize}
			\item
			If this is the first time at which a key associated with the node  was requested, then we set  equal to .
			\item
			Otherwise, we consider the counter index of the previous node and we set  as one more of that value.
		\end{itemize}
		In particular, when the same node is requested, the counter index is always different and increasing.
	\end{itemize}
	
	\subsection{Proof}
	\begin{proof}[Theorem \ref{RS-ABE_security_th}]
		We start by defining the hybrid games used in the proof. 

		\gamedef{G}{0}{
		The game \game{G}{0} is the standard security game, defined in Section~\ref{security.sec}: the private keys and time-update keys are standard, as is the challenge ciphertext.
		}
		
		\gamedef{G}{1}{
		This game is almost equal to \game{G}{0}, with the exception of the challenge ciphertext, which is semi-functional, i.e., computed using \algorithm{RS-ABE}{EncryptSF} instead of \algorithm{RS-ABE}{Encrypt}.
		}
		
 		\gamedef{G}{1,h}{
 		The index  ranges from  to , where  is the total number of distinct nodes of  for which the adversary can query the corresponding ABE private key or SUE private key.
 		In the game \game{G}{1,h} the challenge ciphertext is semi-functional, and the keys are given as follow.
If the request for the ABE or SUE key is identified by a node index  less or equal than , then the key supplied by the challenger is semi-functional.
Otherwise, the key is a standard ABE or SUE key.
}
		
		\gamedef{G}{2}{
		In this game everything is semi-functional: the challenge ciphertext, all the private keys and all the time-update keys.
		}
		
		\gamedef{G}{3}{
		The last game is equal to \game{G}{2}, but the ciphertext is random, which means that if 
		 is the semi-functional ciphertext for the plaintext  in game \game{G}{2}, the ciphertext of \game{G}{3} is 
		
		where  is a random element in .
		}
		
		In particular we can notice how the game \game{G}{1,0} has no semi-functional keys, because the node index is always greater than zero, meaning that . Similarly for \game{G}{1,q_n}: each node index is less or equal than , hence .
	
	\vspace{-1em} \begin{table}[H]
		\begin{center}
		\makebox[\textwidth][c]{ \renewcommand{\arraystretch}{1.2}


		\begin{tabular}{M{1cm}| M{1.1cm} M{1.1cm} M{1.1cm} | M{1.1cm} M{1.1cm} M{1.1cm} | M{2.5cm} N }
&	\multicolumn{3}{c|}{\textbf{Private key}}	&	\multicolumn{3}{c|}{\textbf{Time-update key}}	&	\textbf{Ciphertext} &	\\
				&	\multicolumn{3}{c|}{\textbf{ }}	&	\multicolumn{3}{c|}{\textbf{}}	&	\textbf{} &	\\
			
			\hline \game{G}{0}	&	\multicolumn{3}{c|}{\normal}	&	\multicolumn{3}{c|}{\normal}	&	\normal	&	\\
\game{G}{1}	&	\multicolumn{3}{c|}{\normal}	&	\multicolumn{3}{c|}{\normal}	&	\semifunctional	&	\\
\multirow{2}{*}{\game{G}{1,h}}	&	 &  &		&	 &  &		&	\multirow{2}{*}{\semifunctional}	&	\\ [-0.5em]
				&	\semifunctional&\semifunctional&\normal	&	\semifunctional&\semifunctional&\normal	&		&	\\ 
\game{G}{2}	&	\multicolumn{3}{c|}{\semifunctional}	&	\multicolumn{3}{c|}{\semifunctional}	&	\semifunctional	&	\\
\game{G}{3}	&	\multicolumn{3}{c|}{\semifunctional}	&	\multicolumn{3}{c|}{\semifunctional}	&	\random	&	\\
\end{tabular}
		}
		\end{center}
		\caption{The structure of the components for each hybrid game; \normal{} means standard, \semifunctional{} means semi-functional and \random{} means random.}
	\end{table}


	We call  the advantage of the adversary  for the game \game{G}{i}.
	\game{G}{0} is the original game, therefore . Moreover, since the final game has a randomly chosen session key, we know that the advantage for the last game is . We also use the fact that  and .
		
	We split the advantage of the RS-ABE scheme using the advantages on distinguishing hybrid games. This advantage will later be bounded by its advantage in solving the problem in assumptions \ref{a1}, \ref{a2}, and \ref{a3} by Lemma~\ref{lemma.g0}, \ref{lemma.g1h}, and \ref{lemma.g2}, which are used for the inequality in the last line.
	We keep the dependence on  implicit.
	
	
	The number  (respectively ) is the number of ABE (respectively SUE) key requests for the node with node index , i.e., the highest value of a counter index in a request with node index .
	The advantages , , and  in the last line are the one for an adversary who solves the assumption A\ref{a1}, A\ref{a2}, A\ref{a3} respectively, with the algorithms , ,   defined in the corresponding lemma.
	
	We recall now the properties of the CS scheme (Section~\ref{cs.sec}) which estimates the number of elements in  and : the elements of  are at most , and the elements of  are at most , where  is the maximum size for a set of revoked user. Calling  the number of requests for RS-ABE private keys and  the number of requests for time updates, we obtain that:
	
	
	Thus the final formula is:
	
	where  is the total number of requests from the adversary.
	\end{proof}
	Now we prove the three aforementioned lemmas.
	Each lemma uses only a single assumption: the order of presentation is based on the required assumption.
	For any detail regarding the SUE scheme we refer to the paper by Lee et al.~\cite{lee2013RSABE}, since the procedure in regard to the SUE scheme is the same.
	\subsubsection{Changing the ciphertext}
	\begin{lemma}
		\label{lemma.g0}
		If Assumption \ref{a1} is true, then no PPT adversary  is able to distinguish between~\game{G}{0} and~\game{G}{1}, which means that  is negligible with respect to .
	\end{lemma}
	\begin{proof}
		We prove this lemma by contradiction, showing that if a PPT adversary  could distinguish between~\game{G}{0} and~\game{G}{1}, then there would exist a PPT algorithm  which breaks assumption~\ref{a1}.
	
	Let us take  and  as inputs, the latter either of the form~ or~.
	We create a simulator  that from the input constructs two games, whose probability distribution is the same as random construction of the~\game{G}{0} (if ) or~\game{G}{1} (if ).
	
	\phase{Setup}
	We follow the procedure of \algorithm{RS-ABE}{Setup}, but when applying \algorithm{ABE}{Setup} and \algorithm{SUE}{Setup} we choose the random components of both of them by fixing a random exponent for the corresponding subgroup generator, instead of directly making the random choices between the elements of the subgroup.
	Let  be the maximum length of a label string, obtained from the maximum time  as .
	\randomchoose{p}{
;
.
	}
	
	
	We fix . Then we set the ABE keys as:	
	
	\disclaimerSUE{}
	By choosing random exponents we are choosing random elements of the corresponding groups with a uniform distribution, thus the output of this procedure has the same probability distribution of the corresponding outputs of the standard setup procedure.
	Moreover we create the binary tree  associating to each node  a random exponent .
	The master private key is then:
	
	
	The public key, which is given to the distinguishing adversary , is then:
	
	
	\phase{Query 1}
	During this phase a standard private key or time-update key is provided to each request of , since we know everything needed in order to run \algorithm{RS-ABE}{GenKey} or \algorithm{RS-ABE}{UpdateKey}.
	
	\phase{Challenge}
	We receive from  the attributes , the time , and the messages  and  upon which the adversary wish to be challenged.
	
	A standard RS-ABE ciphertext has the form , where  and  is a SUE ciphertext. We are going to create a particular ciphertext which generates everything randomly as in the standard construction, but which sets . If~ is of the form , this implies that the key is standard, otherwise it will be a semi-functional ciphertext, thus exploiting  gives us an advantage in distinguishing .
	
	We show how to create ABE ciphertext:
	
	
	Observe that if , then the above header is exactly a standard ciphertext header for the ABE scheme, since .
	Otherwise we know that  can be written as a product of an element of  and an element of : , for some unknown generator .
	Recalling that a semi-functional ciphertext header has the form 
	
	we can observe that the case  corresponds to a semi-functional ciphertext header with  and .
	
	However the  are certainly not random and independent on the value of , hence there might be differences between this key and a random key generated by \algorithm{ABE}{EncryptSF}.
	This is not the case: the elements  are randomly generated in , but we are only interested in the \emph{ part} of , i.e., . In fact  is an element of , and thus has the form  for some generator  of  and , and obviously .
	On the other side, using the same argument we notice that we are not interested in all the information of , but only on its  part, since  is a generator of .
	
	From the Chinese Remainder Theorem we know that, since , , and  are three distinct primes, there is a bijection from  and  defined by . Therefore choosing a random  is equivalent to choosing randomly and independently each  part.
	
	In conclusion, the final distribution for the challenge ciphertext header is the same as the output of \algorithm{RS-ABE}{Encrypt} if  or \algorithm{RS-ABE}{EncryptSF} if .
	
	\phase{Query 2}
	This phase is equal to the first querying phase.
	
	\phase{Guess}
	We obtain the guess  from : this is the final output of .
	
	Since the adversary  has a non-negligible advantage on differentiating \game{G}{0} from \game{G}{1}, and this difference allows us to correctly guess the type of , then the algorithm  has a non-negligible advantage, which is a contradiction.
	\end{proof}

	The proof structure we have just employed will recur many times when proving that the difference between two games is negligible: we suppose that we are able to distinguish the two, and from this hypothesis we will build a solver for the assumption that are involved.
	
	\subsubsection{Changing each key}
\ \\
	The proof of the second lemma is more involved, since we need to take care of the ABE and SUE keys which compose each request for a private key or a time-update request.	
	For this reason the reduction is split in a finer sequences of games: each game transforms into the following by changing the behavior of requests associated only with a fixed counter index~.
	
	We will consider two separate cases depending on the request type, respectively for an ABE or a SUE key. Let us fix any challenge attributes  and challenge time ; with the querying phase restrictions of the security game defined in Section~\ref{security.sec} the adversary is able to perform only two kinds of requests for a fixed node  with node index : we can thus split the adversary into two possible types.
	\begin{definition}
		We say that an adversary  is of \emph{\typeone{}} if each access structure  of an ABE private key associated with the node  does not contain the set~.
		
		An adversary  is of \emph{\typetwo{}} if the update time  of every SUE private key associated with the node  is less than~.
	\end{definition}
	
	This distinction is not a partitioning of all the possible adversaries, but each of them is described by at least one of these types. If we consider the description of the challenge phase, we observe that the two types correspond to the conditions  and  respectively. If by contradiction we suppose that the adversary is neither of \typeone{} nor of \typetwo{}, then there exists at least a valid ABE key and a valid SUE key for the challenge time and set of attributes. Since our security game does not allow the requested keys to directly decipher the ciphertext, this means that the user who owns the secret key must be revoked, . However this is impossible, since we are considering only requests for the node : in order to be a node involved in an ABE request, the adversary must require a private key for a user whose position on the binary tree  is below the node . But if we revoke any one single user  below the node , then the node  would belong to the path from  to the root node, and thus it would belong to the Steiner tree of the set of revoked users. This means that any valid time-update key from a time-update request would not contain a SUE key associated with the node .
	
	We are now ready to prove the following.
	
	\begin{lemma}
		\label{lemma.g1h}
		If Assumption \ref{a2} is true, then no PPT adversary  is able to distinguish between \game{G}{1,h-1} and \game{G}{1,h}, which means that  is negligible with respect to .
	\end{lemma}
	\begin{proof}
		We consider first an adversary of \typeone{} which makes at most  ABE key requests for the node with node index , and we define the corresponding hybrid games. Each of them is based on the structure of the game \game{G}{1,h-1}, i.e., a game where the requested keys for both ABE and SUE are semi-functional for the nodes with node index less than~, standard for a bigger node index, and the ciphertext is semi-functional. The only difference between \game{G}{1,h-1} and \game{G}{1,h} occurs during the requests for ABE keys associated with nodes with node index exactly equal to . We modify the behavior of the games basing on the value of the counter index of the node,~. In the following we assume that the index~ ranges from  to .
		
		\gamedef{H}{k,1}{
		We define the behavior for the \ith{} key request, associated with a node index  basing on its counter index .
		
		\begin{itemize}
			\item
			If  we generate a standard ABE key  as previously.
			\randomchoose{p}{,
				.
			}
			We give to the adversary the following semi-functional key:
			
			where the 's are the elements randomly chosen in order to create the ABE semi-functional ciphertext.
			We call this kind private keys \emph{semi-functional of type 1} (\emph{\sfone}, as suggested in~\cite{lewko2010ABE}.
			
			\item
			If , we create a standard ABE key  using as parameters the access structure  and the user  given as input by the adversary, where  is the number of rows and  is the number of columns of the matrix  defining the access structure .
			\randomchoose{p}{.
			}
			Moreover we fix , and then we output the semi-functional key defined by:
			
			Those keys are called \emph{semi-functional of type 2} (\emph{\sftwo}).
			
			\item
			If  then the challenger gives to the adversary a standard ABE private key.
		\end{itemize}
		The two types of semi-functional keys are different from the semi-functional ABE keys which we have previously defined in \ref{semifunctional.def}: the vector  is generated randomly each time for every new key request, but for a semi-functional key the first component of the vector is fixed at the start, depending on the node associated with the request.
		}
		
		\gamedef{H}{k,2}{
		This game is equal to the previous game, with the exception that the case  and  gives a semi-functional key of type 2, or equivalently that the elements  are equal to zero.
		}
		
		\gamedef{H^\prime}{k,1}{
		This game is equal to the game \game{H}{k,1}, with the exception that the cases with node index  and counter index  give a different semi-functional ABE key. We first generate a key  with the same procedure as described in game \game{H}{k,1}, and then we add the contribution of the elements 's, defined in Section~\ref{semifunctional.def} to create the semi-functional keys.
		\randomchoose{p}{.
		}
		We take the element , where  is the index of the node  associated with the node index , and we fix the vector . The output is:
		
		We call \emph{semi-functional of type 3} (\emph{\sfthree}) the key resulting for the case .
		
		We observe that if the starting key is standard, i.e., , then the resulting key is semi-functional. In fact the added element does not change the distribution of the output: the combined exponent of the element  is , where  is the vector we have previously defined, and  is the random vector used in game \game{H}{k,1}. In fact the first component of the sum of the two vectors is the sum of a random element and a constant, and the other components are the sum of two random elements in .
		Similarly, if we start with a semi-functional key of type one we obtain a key which has the same distribution as a randomly-generated semi-functional key of type one.
		}
		
		\gamedef{H^\prime}{k,2}{
		This game merges the behaviors of the games \game{H}{k,2} and \game{H^\prime}{k,1}. Again, this game is equal to the game \game{H}{k,2}, with the exception that the cases  and  give a modified ABE key. The modification is the same as in game \game{H^\prime}{k,1}, which means that the keys for  are semi-functional, and the key for , which we denote \emph{semi-functional of type 4} (\emph{\sffour}), has the same distribution of the key given in \game{H}{k,2}, that is of a semi-functional key of type 2.
		}
		
		\gamedef{H^{\prime\prime}}{}{
		This game is equal to the game \game{G}{1,h}.
		}
		
		\begin{remark}The only difference between semi-functional keys and semi-functional keys of type 2 is that the latter uses random elements in lieu of the elements  and .
		\end{remark}
		
		We observe that the two games \game{H}{q_h^\textbf{ABE},2} and \game{H^\prime}{q_h^\textbf{ABE},2} are equal, since the output distribution for the only different case ,  is the same.
		The games \game{H^\prime}{0,1} and \game{H^\prime}{0,2} are equal: each ABE key associated with the node with node index  is semi-functional. The difference between them and \game{H^{\prime\prime}}{} are only the SUE key requests with node index : in the formers they are standard, but in the latter they are semi-functional.
		Moreover the games \game{H}{0,1} and \game{H}{0,2} are equal to \game{G}{1,h-1}.
		
		\begin{table}[H]
		\begin{center}
		\makebox[\textwidth][c]{ \renewcommand{\arraystretch}{1.2}


		\begin{tabular}{M{1cm}| M{1.3cm} M{1.3cm} M{1.3cm} | M{0.5cm} M{0.5cm} M{0.5cm} !{\color{white}} N } &	\multicolumn{3}{c|}{\textbf{ABE keys}}	&	\multicolumn{3}{c}{\textbf{SUE keys}}	&	\\
				&	\multicolumn{3}{c|}{\textbf{}}	&	\multicolumn{3}{c}{\textbf{}}	&	\\
			\hline
			\multirow{2}{*}{\game{H}{k,1}}	&	 &  &		&	\multicolumn{3}{c}{\multirow{2}{*}{\normal}}	&	\\ [-0.5em]
				&	\sftwo&\sfone&\normal	&	&&	&	\\
\multirow{2}{*}{\game{H}{k,2}}	&	 &  &		&	\multicolumn{3}{c}{\multirow{2}{*}{\normal}}	&	\\ [-0.5em]
				&	\sftwo&\sftwo&\normal	&	&&	&	\\
\multirow{2}{*}{\game{H^\prime}{k,1}}	&	 &  &		&	\multicolumn{3}{c}{\multirow{2}{*}{\normal}}	&	\\ [-0.5em]
				&	\sftwo&\sfthree&\semifunctional	&	&&	&	\\
\multirow{2}{*}{\game{H^\prime}{k,2}}	&	 &  &		&	\multicolumn{3}{c}{\multirow{2}{*}{\normal}}	&	\\ [-0.5em]
				&	\sftwo&\sffour&\semifunctional	&	&&	&	\\
\multirow{2}{*}{\game{H^{\prime\prime}}{}}	&	\multicolumn{3}{c|}{\multirow{2}{*}{\semifunctional}}	&	\multicolumn{3}{c}{\multirow{2}{*}{\semifunctional}}	&	\\ [-0.5em]
				&		&		&	\\


		\end{tabular}
		}
		\end{center}
		\caption{The behavior of the security games for all requests with node index~; the remaining requests are made as in \game{G}{1,h-1}.}
		
	\end{table}
	
		We call  the advantage of the adversary  in a game \game{H}{}. In propositions \ref{prop.h1}, \ref{prop.h2}, \ref{prop.h3}, \ref{prop.h4}, and \ref{prop.h5} we will prove that the advantage in distinguishing the pair of games
(\game{H}{k,1}, \game{H}{k-1,2}),
			(\game{H}{k,1}, \game{H}{k,2}),
			(\game{H^\prime}{k,1}, \game{H^\prime}{k-1,2}),
			(\game{H^\prime}{k,1}, \game{H^\prime}{k,2}), and
			(\game{H^\prime}{0,2}, \game{H^{\prime\prime}}{})
is negligible with respect to the security parameter .
		Thus we split the advantage in distinguishing between \game{G}{1,h-1} and \game{G}{1,h} for an adversary  of \typeone{} with the following inequalities:
		
		

		A similar splitting can be obtained considering an adversary of \typetwo{} who we suppose making at most  SUE key requests for the nodes with node index .		
		The full description for games involving an adversary of \typetwo{}, and the corresponding proof for the inequality that follows, is found in Lee et al.~\cite{lee2013RSABE}.		
		The advantage for an adversary  of \typetwo{} in distinguishing between \game{G}{1,h-1} and \game{G}{1,h} satisfies:
				
		
		Now we combine both adversary types by considering both the events \textit{the adversary is of \typeone{}}, , and \textit{the adversary is of \typetwo{}}, . If the adversary is both of \typeone{} and of \typetwo{} we can arbitrarily choose one of the two types, e.g.\@ we can assume that they are of \typeone{}.
		
		If the adversary is of \typeone{} we use inequality \ref{inequality.ABE}, otherwise we use \ref{inequality.SUE}. In particular, with this setting we know than there is no difference between the games \game{G}{1,h-1} and \game{G}{1,h} for both an adversary of \typeone{} and of \typetwo{}.
		Thus we can now conclude the proof with the following inequality:
		
		
		The last inequality is obtained by supposing , and then removing the resulting negative term. If  we follow the same procedure, but using  as reference set, in particular .
	\end{proof}
	
	As in Lemma~\ref{lemma.g0} we are going to show that if a PPT adversary were able to distinguish between the two considered games, then we would be able to exploit this advantage in order to find a PPT algorithm which breaks Assumption~\ref{a2}.
	The only differences with the Lemma are found in the querying phases, where the key constructions is different between each game.
		
		We are given the two input in Assumption~\ref{a2}, which are the tuple \linebreak, where , , and , and an element  of the group.
		The group element  can be with equal probability of two different forms: either randomly chosen among all elements of , or just among the element of . Equivalently, it can be chosen as a product of random elements, either  or , where , , and , everything chosen with uniform distribution.
		
	We use the inputs to build the following simulator.
	
	\phase{Setup}
	The setup phase generates the public and private parameters of the scheme through random choices of exponents for each group element.
	
	\randomchoose{p}{;
		.
	}
	
	Let . We set the ABE and SUE keys as:
	
	\disclaimerSUE{}
		This means that, maintaining the notation used in the previous scheme constructions, , , , and .
	
	Since we are choosing random exponents, when we consider their corresponding elements of the group we are choosing them with a uniform distribution, and thus the output of this procedure has the same probability distribution of the corresponding outputs of \algorithm{ABE}{Setup} and \algorithm{SUE}{Setup}.
	We create the binary tree  associating to each node  a random exponent~.
	
	The output, given to the adversary , is then:
	
	
	The secret key, which we fully know, is 
	
	We also generate randomly for each node  the elements , which are needed to create the semi-functional keys. We need also the elements , for each , used in the construction of a SUE ciphertext.
	
	Exception will be Proposition~\ref{prop.h5}, where for a specific node  the elements  and  will be implicitly defined using input elements.
	
	\phase{Query 1}
	In this phase we give to the adversary  the required keys.
	
	First we observe that we are able to generate standard private and time-update keys, since we own all the needed elements of the private master key. We are also able to build semi-functional keys, even if we cannot generate them directly, because we do not know a generator for the subgroup . The following con\-struc\-tions leverage the element  given as input, and fix implicitly . 
	
	Suppose that the request is associated with the node .
	A semi-functional ABE key can be obtained with the following procedure. First we build a standard ABE key, , for the access structure , .
	We fix some random elements  and we set . 
	The semi-functional ABE key is:
	
	The distribution is the same as a standard semi-functional key: the only difference is the presence of the factor  in , but since when we generate  we use a random element of  as a factor, the contribution of this element is just a translation inside the space , which does not change the distribution of our random choice.
	We are also able to create ABE semi-functional keys of type 2, since its construction is the same apart from the elements  and , which are swapped with random elements.
	
	We can also obtain semi-functional SUE key. Everything regarding the SUE part of the scheme is omitted, for more details we refer to Lee et al.~\cite{lee2013RSABE}.
	
	We must consider three different cases in the querying phase.
	\begin{itemize}
		\item
		If  we output a semi-functional key.
		\item
		If  the behavior of the simulator will be specified for each considered proposition (Proposition~\ref{prop.h1}, \ref{prop.h2}, \ref{prop.h3}, \ref{prop.h4}, \ref{prop.h5}).
		\item
		If  we output a standard key.
	\end{itemize}
	
	\phase{Challenge}
	We receive the attributes , the time , and the messages  and  which the adversary wish to challenge, and then we fix a bit  randomly in .
	We want to create a semi-functional ciphertext without knowing the generator~.
	To do so we fix implicitly  and .
	
	The components of the ABE ciphertext are:
		
		
	We construct also the SUE ciphertext  using the element .
	Lastly we observe that , which is implicitly .
	The ciphertext we output to the adversary  is:
	
	
	The described constructions account for a correctly distributed ciphertext. Moreover, the ciphertext and the keys for the case  are uncorrelated. Thus in the remaining propositions we must only consider the case .
		
	\phase{Query 2}
	The second quering phase is managed as the first one.
	
	\phase{Guess}
	We obtain the guess  from , which is the final output of our simulator.
	
	\vspace{0.5em} 

	To conclude the proof of Lemma~\ref{lemma.g1h} we need to prove the following propositions.
	In each of them we describe the behavior of the simulator when the counter index is . We consider only the case where the aversary is of \typeone{}, for the same result for an adversary of \typetwo{} we refer to Lee et al.~\cite{lee2013RSABE}.
	
	\begin{proposition}
		\label{prop.h1}
		If Assumption \ref{a2} is true, then no PPT adversary  of \typeone{} is able to distinguish between \game{H}{k,1} and \game{H}{k-1,2}, that is,  is negligible with respect to .
	\end{proposition}
	\begin{proof}
If the query is for a SUE key, we give to the adversary a standard SUE key, which we are able to build. If the request is for an ABE key, we must consider three different cases depending on the counter index. Suppose that the access structure is described by , where  and  is injective. The request is associated with the node , corresponding to the node index , which is associated with the element  in .
		\begin{itemize}
			\item
			If  we create a semi-functional ABE key of type 2.
			\item
			If  we build the key relying on the element .
			\randomchoose{p}{;
				;
				.
			}
			We set  and .			
			The given secret key is:			
			
			\item
			If  we create a standard ABE key.
		\end{itemize}
		The only case we need to check is when .
		We call  the  part of , i.e., , and implicitly we set , the  part of , when it exists.
		The  part of  does not add any contribution, since each element composing the key is multiplied by a random element in .
		The  part manages the standard key creation. In particular the private key we are building sets implicitly the vector  used in the function \algorithm{ABE}{GenKey} as , and the  elements used in the same function implicitly as .
		If the  part of  is , i.e., , then the output key is a standard key, as needed for game \game{H}{k-1,2}.
		Otherwise the  part of  is nontrivial, and we obtain a semi-functional key of type 1. In particular (we use the notation found in the definition of \game{H}{k,1} at the beginning of Lemma~\ref{lemma.g1h}) the elements 's are equal to the 's, the 's are the same as in the construction of an ABE semi-functional key, and .
		
		It remains to show that the given secret key is correctly distributed.
		First we can use the same argument as in Lemma~\ref{lemma.g0} to observe that the output distribution does not change because . In fact we have previously chosen  to be a random element of , and the occurrence of  uses its  part if and only if they are used instead of .
		
		The only remaining problem is that the first component of the vector  is not in general zero, but it is a random number in . Nevertheless the final distribution remains the same in this case. 
Since the set  is not authorized, we know that the span of the rows associated with an attribute in~ does not contain , otherwise  would be able to decrypt the ciphertext.
		In particular the same is true if we consider the projection of each entry of the row from  to , and their corresponding linear span~. Otherwise if we consider the same linear combination in  then the first element is one plus a multiple of , and the other elements are multiples of : by computing the greatest common divisor between any multiple of  and  we are able to obtain a nontrivial factor of , thus allowing us to break Assumption~\ref{a2}.
		Therefore we can find a vector  which is orthogonal to the space~, but which is not orthogonal to . In fact if each element of  is orthogonal to , then , and since the standard bilinear product is symmetric, non-degenerate, and the space has finite dimension, then , which is a contradiction. We can fix a basis including : this allows us to write  for some , where  belongs to the span of the remaining elements of the base. We can choose  with uniform distribution, and then we can fix the unique  which zeroes the first component.
		 With this construction we obtain each possible element for , thus a uniform distribution of the  in the semi-functional key corresponds to a uniform distribution for the choice of . 
		
		We want to show that an adversary has not enough information to discover~: by knowing just  we are not able to obtain any information about .
		The only expression where  appears is of the form .
		If we are considering a row  for an attribute which belongs to the challenge set of attributes~, then we are not giving any information about , since  by definition of .
		For the remaining attributes we use the hyphothesis for which  is injective. In particular, there is only one occurrence of the element~, since it does not appear in the challenge ciphertext.
		The element  is randomly chosen, and unless  we are not adding any information about , since we are adding to the expression an unknown random element.
		Furthermore the probability that  becomes negligible as  grows.
		In particular, an adversary is not able to distinguish the distribution of the output key from a key created with random first component for .
		
		We have shown that the key given to the adversary in our simulator has the correct distribution. Therefore, we have shown that this is a correct simulator. Its existence would contradict our assumption, 
	\end{proof}
	\begin{proposition}
		\label{prop.h2}
		If Assumption \ref{a2} is true, then no PPT adversary  of \typeone{} is able to distinguish between \game{H}{k,1} and \game{H}{k,2}, meaning that  is negligible with respect to .
	\end{proposition}
	\begin{proof}
		We consider the case .
		As before, we consider a request for the access structure , where . The request is associated with the node , which is associated with the element  in .
		\begin{itemize}
			\item
			If  we create a semi-functional ABE key of type 2.
			\item
			If  we build the key relying on the element .
			\randomchoose{p}{;
				;
				.
			}
			We set  and .
			
			The given secret key is:
			
			\item
			If  we create a standard ABE key.
		\end{itemize}
		The only case we need to check is when .
		We call  the  part of , i.e., , and we set implicitly .
		Observe that the  part of the key creates a standard key, which sets implicitly in the construction of a standard ABE key done in \algorithm{ABE}{GenKey} the element  as , which is uniformly distributed in .
		If  contains no  part, then the key is a semi-functional ABE key of type 2, and .
		Otherwise if  is the  part of , we have also the additional component needed for the key of type 1, with the same 's and .
		As before we notice how the reuse of  as  does not change the result, since we are considering in one case its  part, and for the other variable its  part.
		Moreover, the  part contribution is absorbed by the random elements, and the other elements are independent.
		
		We proved that the simulator is correctly distributed, thus an adversary who could distinguish between the two games would also be able to break Assumption~\ref{a2}.
	\end{proof}
	\begin{proposition}
		\label{prop.h3}
		If Assumption \ref{a2} is true, then no PPT adversary  of \typeone{} is able to distinguish between \game{H^\prime}{k,1} and \game{H^\prime}{k-1,2}, that is,  is negligible with respect to .
	\end{proposition}
	\begin{proof}
		This proof follows the same procedure as the Proposition~\ref{prop.h1}.
		In particular, each case is equal, with two exceptions, where we add the contribution of the factor .
		\begin{itemize}
			\item
			If  we follow the same procedure as in Proposition~\ref{prop.h1}.
			\item
			If  we build the key relying on the element .
			\randomchoose{p}{;
				;
				.
			}
			We set ,  and .
			The given secret key is:
			
			
			\item
			If  we create a semi-functional ABE key.
		\end{itemize}
		The rest of the proof is equal to the Proposition~\ref{prop.h1}, since the added factor does not change the output distribution.
	\end{proof}
	\begin{proposition}
		\label{prop.h4}
		If Assumption \ref{a2} is true, then no PPT adversary  of \typeone{} is able to distinguish between \game{H^\prime}{k,1} and \game{H^\prime}{k,2}, meaning that  is negligible with respect to .
	\end{proposition}
	\begin{proof}
		This proof follows the same procedure as the Proposition~\ref{prop.h2} and Proposition~\ref{prop.h3}.
		In particular, each case is equal, with two exceptions, where we add the contribution of the factor .
		\begin{itemize}
			\item
			If  we follow the same procedure as in Proposition~\ref{prop.h2}.
			\item
			If  we build the key relying on the element .
			\randomchoose{p}{;
				;
				.
			}
			We set ,  and .
			
			The given secret key is:
			
			\item
			If  we create a semi-functional ABE key.
		\end{itemize}
		The rest of the proof is equal to the Proposition~\ref{prop.h2}, since the added factor does not change the output distribution.
	\end{proof}
	\begin{proposition}
		\label{prop.h5}
		If Assumption \ref{a2} is true, then no PPT adversary  of \typeone{} is able to distinguish between \game{H^\prime}{0,2} and \game{H^{\prime\prime}}{}, which means that  is negligible with respect to .
	\end{proposition}
	\begin{proof}
		This proof is similar to Proposition~\ref{prop.h1}.
		Suppose that the adversary queries for an ABE key with node index , for an access structure described by , where  and  is injective. The request is associated with the node . Notice that we do not need to distinguish between the different counter indices, since all keys for the two considered games with the same node index are equal.
		
		\randomchoose{p}{;
			\linebreak;
			.
		}		
		We call  and .		
		The semi-functional ABE key is:
				
		\disclaimerSUE{}
We compute explicitly the components of the ABE key where  appears, ignoring the  parts.
		
		The first component of the vector  is exactly , and the remaining are randomly distributed. If the  part of  is equal to , i.e., , then we have a standard semi-functional ABE key construction with . Otherwise the first component of the vector  is , which is . The remaining vector elements are again randomly distributed and independent on other key value, since from the second element onward of  they are randomly fixed in~.
		
\end{proof}
\subsubsection{Randomizing the ciphertext}
	\begin{lemma}
	\label{lemma.g2}
	If Assumption \ref{a3} is true, then no PPT adversary  is able to distinguish between \game{G}{2} and \game{G}{3}, which means that  is negligible with respect to .
	\end{lemma}
	\begin{proof}
		By contradiction we prove that the existence of a PPT adversary who can distinguish between \game{G}{2} and \game{G}{3} implies the existence of an algorithm~ which can break Assumption~\ref{a3}.
		
		The algorithm  is given the two inputs  and .
		 can be  or a random element  in , or equivalently  for some random .
		
	\phase{Setup}
	The setup phase is similar to the one in Lemma \ref{lemma.g0}, with the exception of the choice of the public parameter , for which we will (implicitly) use the same   used in the input.
	\randomchoose{p}{;
.
	}
	
	Let . We set the ABE keys as:
	
	\disclaimerSUE{}
	Since we are choosing random exponents, when we consider their corresponding elements of the group, we are choosing them with a uniform distribution. Thus the output of this procedure has the same probability distribution of the corresponding outputs of the standard setup procedure.
	We create the binary tree  associating to each node  a random exponent~.
	Lastly we set , which for the bilinearity is equivalent to . In particular we are implicitly setting .
	The public key, given to , is then:
	
	We also generate randomly for each node  the elements ,  in , which are needed to create the semi-functional keys.
	
	\phase{Query 1}
	In this phase we supply  with all the required keys, both private keys and time-update keys. Since we do not know , we are not able to create standard time-update keys; nevertheless we will show that we can still create semi-functional keys from our inputs. We fix  as the generator of  used for every semi-functional request.
	\begin{itemize}
		\item
		If the request is for a private key, then we first find the private set  for the user . For each node  involved with the private set, we create its corresponding ABE key. This ABE key should be generated with an ABE scheme of private master key : since all elements are known, we are able to generate the corresponding ABE private key, and then we can apply the same procedure in \algorithm{RS-ABE}{GenKeySF} to make this key semi-functional .
		\item
		Otherwise the request is for a time-update key, for which we use the procedure shown in Lee et al.~\cite{lee2013RSABE}.
		
	\end{itemize}
	
	\phase{Challenge}
	We receive the attributes , the time , and the messages  and  upon which the adversary wishes to be challenged; we fix a bit  randomly in .
	We use both these and the inputs of  in order to create the needed semi-functional ciphertext, using randomly chosen exponents.
	First we generate the ABE semi-functional ciphertext.
	The components of the ciphertext are:
		
	We generate also the SUE ciphertext , as done by Lee et al.~\cite{lee2013RSABE}.
	
	Finally we output to the adversary the ciphertext
	
	
	We need to prove that the above definition gives rise to the games \game{G}{2} and \game{G}{3} depending on the form of the given value . In particular we must show that the above construction generates valid semi-functional ciphertexts. Notice that the construction of the keys uses the term , and the ciphertexts contruction uses , elements which are chosen independently. Thus there is not mutual correlation between them.
	
	The constructed ABE ciphertext is equivalent to a semi-functional ABE ciphertext with . The construction of an ABE semi-functional ciphertext involves the choice of some random elements  for each used attribute, but we have implicitly set , values used in the previous construction. Nevertheless this setting is independent from the previous random choices, since this is the only time we have considered the  part of the 's.
Previously we have only used them in the form , which uses only the  part of the 's. Using the same argument of Lemma~\ref{lemma.g0}, the Chinese remainder theorem assures us that the two parts are mutually independent.
	
	If the element  has the form , then the output is exactly a semi-functional ciphertext, as required by the game \game{G}{2}, otherwise it is of the form  for some random , which is the output required for the game \game{G}{3}.
	
	\phase{Query 2}
	We repeat the keys construction of the first querying phase.
	
	\phase{Guess}
	We obtain the guess  from , which is the final output of .
	
	The adversary  has a non-negligible advantage on differentiating \game{G}{2} from \game{G}{3}, which means that we can correctly guess the type of : the algorithm  has a non-negligible advantage in breaking Assumption \ref{a3}, which is a contradiction.
	\end{proof}
	


	\section{Efficiency and conclusions}
	\label{efficiency.sec}
	In this section we study the dimension of keys and ciphertexts of RS-ABE.
	The dimension is measured in term of group elements which compose the keys and the ciphertext, and depends on the parameters of the scheme.
	
	For the SUE scheme we refer to~\cite{lee2013RSABE}. The maximum length for a SUE key is , where  is the maximum time for the system, and a SUE cipertext header has size that is upper-bounded by .
	
	We analyze now the ABE scheme, starting from the key. We want to find the length of a key associated with an LSSS access structure . The first thing to notice is the hypothesis stated at the beginning of Section~\ref{ABE.construction}, requiring that  is injective, i.e., each attribute is assigned with a single row of the matrix . We can extend the result by assuming that  is associated with at most  rows of the matrix . We modify the attributes used in the scheme: if  is the set of attributes of the scheme, we consider the set  which contains  copies of each attribute. Then each attribute set  becomes the set , and the new function  assigns to each occurrence of an attribute one of the new corresponding attributes, without repetitions.
	
	An ABE private key for an LSSS access structure , modified to take into account for repetitions in , such that  is a matrix with  rows and  columns, has the following form:
	
	A key contains exactly  group elements.
	
	An ABE ciphertext for the set of attributes  has the form
	which corresponds to a size equal to .
	
	Now we merge these results together to obtain the length of the keys for the RS-ABE scheme.
	The private key for a user  and an access structure  is generated starting from the private set  associated with the user : a private ABE key for the access structure  is generated for each element of  . Then the private key is: 
	The number of elements  of the private set is smaller than , as we have noticed in Section~\ref{cs.sec}. This means that the maximum length of a private RS-ABE key, considering only group elements, is bounded by .
	
	A time-update key can be obtained starting from a covering of the associated revoked set : for each element of the covering  a SUE key is built. Calling , we know from Section~\ref{cs.sec} that the size of the covering is bounded above by the value . Therefore the maximum number of group elements is	.
	
	A ciphertext for a set of attributes  is composed by an element of  and both an ABE and a SUE ciphertext. The number of group elements is then .
	\begin{table}[H]
		\begin{center}
		\makebox[\textwidth][c]{ \renewcommand{\arraystretch}{1.2}


		\begin{tabular}{M{3.9cm}| M{4.55cm}| M{4.1cm} !{\color{white}} N } &	{\textbf{Upper bound}}	&	{\textbf{Magnitude}}	&	\\
			\hline SUE private key	&		&	 \\
			SUE ciphertext	&		&	 \\
			ABE	private key	&		&	 \\
			ABE ciphertext	&		&	 \\
			RS-ABE private key	&		&	 \\
			RS-ABE time-update key	&		&	 \\ RS-ABE ciphertext	&		&	 \\
			
		\end{tabular}
	}
	\end{center}
	\caption{The length in term of number of group elements employed.  is the maximum time used in the scheme,  is the number of rows of the matrix in the access structure used for the key,  is the size of the set of attributes used for the ciphertext,  is the maximum number of users, and  is the size of the set of revoked users in the update key.}
	\end{table}
	
	
Finally we present briefly a possible extension of our work. In this paper we built a Key-Policy ABE scheme that allows to revoke users arbitrarily, and we prove its security. In our scheme only a single authority can create the public parameters and issue private keys to the users: this might be seen as a limitation for certain practical application of the scheme, for example those in which the users fear that the authority becomes curious. A natural follow-up for this work consists in introducing a hierarchy to manage the key-generation process, in a similar fashion to what is done for SSL certificates. A different problem is the trust on the authority managing the scheme: in our setting the authority has the full power to create and revoke the keys according to its own volition. This problem might be assuaged by distributing the authority's power among multiple authorities, such that a single failure would not cause a complete collapse of the scheme. In \cite{longocollaborative,longo2015key}, the authors present two different Key-Policy Attribute-Based Encryption schemes in which many different authorities operate independently, and prove their security. As a future work may be interesting the design of a Multi-Authority Key-Policy ABE scheme that allows user revocation, with a full proof of security.
	
	
	
	
	


	\section*{Acknowledgements}
	Most of the results shown in this work were developed in the first author's Master's thesis at the University of Padua, who would like to thank his supervisors: the third author and A.~Tonolo.



	\printbibliography{}
\end{document}