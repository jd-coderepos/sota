

\documentclass{llncs}
\usepackage{latexsym,amsmath, algorithm2e}
\usepackage{graphicx}
\usepackage{verbatim}




\begin{document}

\bibliographystyle{plain} 

\title{Bounded Search Tree Algorithms for Parameterized Cograph Deletion: Efficient Branching Rules by Exploiting Structures of Special Graph Classes\thanks{Supported in part by NSERC Discovery Grant RGPIN 327587-09}}
\author{James Nastos \and Yong Gao \thanks{We thank Dr. Donovan Hare for our discussions on these results}}
\institute{
    Department of Computer Science, Irving K. Barber School of Arts and Sciences.\\
    University of British Columbia Okanagan, Kelowna, Canada V1V 1V7\\
    \email{jnastos@interchange.ubc.ca, yong.gao@ubc.ca}
}

\maketitle

\begin{abstract}
Many \emph{fixed-parameter tractable} algorithms using a bounded search tree have been repeatedly improved, often by describing a larger number of branching rules involving an increasingly complex case analysis. We introduce a novel and general search strategy that branches on the forbidden subgraphs of a graph class relaxation. By using the class of -sparse graphs as the relaxed graph class, we obtain efficient bounded-search tree algorithms for several parameterized deletion problems. We give the first non-trivial bounded search tree algorithms for the cograph edge-deletion problem and the trivially perfect edge-deletion problems. For the cograph vertex deletion problem, a refined analysis of the runtime of our simple bounded search algorithm gives a faster exponential factor than those algorithms designed with the help of complicated case distinctions and non-trivial running time analysis~\cite{NiRo} and computer-aided branching rules~\cite{GGHN}.

\smallskip
\textbf{Keywords:} Fixed-parameter tractability; edge-deletion; graph modification; cographs; trivially perfect graphs; quasi-threshold graphs; bounded search tree.


\end{abstract}

\normalsize


\section{Introduction}

A graph is a \emph{cograph}~\cite{Sein} if it has no induced subgraph isomorphic to a , an induced path on four vertices. The name originates from \emph{complement reducible graphs} as cographs are also characterized as being those graphs  which are either disconnected or else its complement  is disconnected~\cite{Sein}. They are a well-studied class of graphs and many NP-complete problems on graphs have been shown to have polynomial time solutions when the input is a cograph~\cite{CPS}.

A \emph{graph modification problem} is a general term for a problem that takes a graph as input and asks how the graph can be modified to arrive at a new graph with a desired property. Usually, graph modifications are edge additions or deletions, vertex additions or deletions, or combinations of these. Our work on the following problems originally stems from studying social networks from which edge removals are made to reveal underlying structures in the network.

Many parameterized graph modification problems are tackled by a bounded search tree method where the size of the search tree usually dominates the computation time. This paper presents a framework for designing branching rules for bounded search tree algorithms. Our strategy exploits the structure of specialized graph classes in order to design efficient algorithms for (hard) problems on general graphs. We illustrate this method by giving algorithms that solve four different graph modification problems.

The \emph{cograph edge-deletion problem} is the problem of determining when a graph  has a set  of at most  edges which can be removed in order to make  a cograph. This problem is known to be NP-complete \cite{ElMC} and also known to be \emph{fixed parameter tractable}~\cite{CAI}. Similarly, the \emph{trivially perfect edge-deletion problem} asks whether  edges can be removed to turn a graph into a trivially perfect graph (a graph which is  and -free.) We first show how to solve these problems in linear time on a relaxed graph class, the \emph{-sparse} graphs, and design algorithms to solve these problems on general graphs by branching towards -sparse graphs. Furthermore, we give improved algorithms for the vertex-deletion version of these problems.

We note that since the class of cographs is self-complementary, an algorithm solving -edge-deletion problem also serves as a solution to the problem of -edge-addition to cographs. Similarly, the -edge-deletion problem to trivially perfect graphs serves as a solution to the -edge-addition problem to co-trivially perfect graphs.

This paper is structured as follows: Section 2 summarizes previous results related to graph modification problems and gives some background on the class of -sparse graphs; Section 3 gives edge-deletion algorithms to cographs and to trivially perfect graphs; Section 4 designs \emph{vertex deletion} algorithms for cographs and \emph{trivially perfect} graph and their improvements using {\sc Hitting Set}; Section 5 summarizes and discusses these results and suggestions a number of directions for future work.

\section{Previous Results and Background}

\subsection{Previous Fixed-Parameter Tractability Results}

While cographs can be recognized in linear time~\cite{CPS}, it is also known that it is NP-complete to decide whether a graph is a cograph with  extra edges~\cite{ElMC}. Graph modification problems have been studied extensively: Yannakakis shows that vertex-deletion problems to many types of structures is NP-hard~\cite{Yanna}. Elmallah and Colbourn give hardness results for many edge-deletion problems~\cite{ElMC}.

Recently, much research has been devoted to finding fixed-parameter tractable algorithms for graph modification problems: Guo~\cite{Guo} studied edge deletion to split graphs, chain graphs, threshold graphs and co-trivially perfect graphs; Kaplan et al.~\cite{KST} studied edge-addition problems to chordal graphs, strongly chordal graphs and proper interval graphs; Cai~\cite{CAI} showed fixed-parameter tractability for the edge deletion, edge addition, and edge editing problem to any class of graphs defined by a finite set of forbidden induced subgraphs. The constructive proof implies that -edge-deletion problems to a class of graphs defined by a finite number of forbidden subgraphs is  where  is some polynomial and  is the maximum over the number of edges in each of the forbidden induced subgraphs defining that graph class in question. For -edge-deletions to -free graphs in particular, Cai's result implies an algorithm running in  time. This algorithm would work by finding a :  in a graph and branching on the 3 possible ways of removing an edge in order to destroy the  (that is, removing either the edge  or  or ).

Nikolopoulos and Palios study the edge-deletion to cograph problem for a graph  where  is a cograph and  is some edge of ~\cite{NikoPalio}. Lokshtanov et al. study cograph edge-deletion sets to determine whether they are \emph{minimal}, but not a minimum edge-deletion set~\cite{LMP}. To the best of our knowledge, ours is the first study that specifically addresses the edge-deletion problem to cographs. We present a bounded search tree algorithm that solves -edge-deletion to cographs in  time by performing a search until we arrive at a -sparse graph and then optimally solving the remainder of the problem using the structure of -sparse graphs.

Graph modification problems can also be regarded as a type of graph recognition problem. Following the notation of Cai~\cite{CAI}, for any class of graphs , we call  the set of all graphs which cane be composed by adding  extra edges to a graph from class . Similarly,  is the set of graphs which are formed from a graph from class  with  edge removals. Replacing `edges' by `vertices' in these definitions gives analogous classes for  and . A -edge-deletion problem to a class of graphs  can thusly be restated as a recognition problem for the class of  graphs. Our results on cographs here can be restated as recognition algorithms for the classes: Cograph+, Cograph-, Cograph+, Trivially Perfect+.

\subsection{Background Information: -sparse graphs}

\begin{figure}
  \includegraphics[height=8cm]{P4sparse.pdf}\\
  \caption{The forbidden induced subgraphs for -sparse graphs}\label{forb}
\end{figure}

One generalization to the class of cographs is formed by allowing  to exist in a graph but in restricted amounts. Ho\'ang \cite{Hoa} introduced -sparse graphs to be those for which every induced subgraph on five vertices induces at most one . This immediately implies a forbidden induced subgraph characterization which restricts any subgraph of five vertices inducing two or more s. We include these graphs in Figure 1.

A special graph structure called a \emph{spider}~\cite{JaOl} commonly occurs in graph classes of bounded cliquewidth. We define two types of spiders here:

\begin{definition}
A graph  is a \emph{thin spider} if  can be partitioned into ,  and  such that:
\begin{itemize}
\item[i)]  is a clique,  is a stable set, and .
\item[ii)] every vertex in  is adjacent to every vertex of  and to no vertex in .
\item[iii)] each vertex in  has a unique neighbour in , that is: there exists a bijection  such that every vertex  is adjacent to  and to no other vertex in .
\end{itemize}
\end{definition}

\begin{figure}
    \hspace{2.6cm}
  \includegraphics[height=5cm]{spiders.pdf}\\
  \caption{(a) A thin spider and (b) thick spider with  and  }\label{spider}
\end{figure}

A graph  is called a \emph{thick spider} if  is a thin spider. Note that the vertex sets  and  swap roles under graph complementation, that condition (i) and (ii) hold for thick spiders, and that statement (iii) changes to saying that every vertex in  has a unique \emph{non-neighbour} in . The sets ,  and  are called the \emph{body}, \emph{feet} and \emph{head} of the spider, respectively. The edges with one endpoint in  are called \emph{thin legs} or \emph{thick legs} for thin spiders or thick spiders, respectively. Examples of spiders are given in Figure~\ref{spider}.

Ho\`ang \cite{Hoa} defined a graph  to be -sparse if every induced subgraph with exactly five vertices contains at most one . The following decomposition theorem for -sparse graphs was proven in~\cite{JaOl}:
\begin{lemma}\cite{JaOl}
Let  be a -sparse graph. Then exactly one of the following is true:
\begin{itemize}
\item[i)]  is disconnected
\item[ii)]  is disconnected
\item[iii)]  is a spider
\end{itemize}
\end{lemma}

We conclude our discussion of -sparse graphs with an observation that will be useful to us:

\begin{lemma}\label{lem:unique}
  Let  be a spider with body  and feet . Then every edge  with  is in one  in . 
\end{lemma}

\begin{proof}
  A  can not contain 3 vertices of . If  is a thin spider, let each  be adjacent to each . The edge  is only in the . If  is a thick spider, let each  be adjacent to every foot  where . The edge  is only in the .
 \hfill 
\end{proof}

\section{Edge-Deletion Algorithms}

In this section, we give algorithms for two edge-deletion problems.

\begin{problem}{\sc Cograph Deletion} :\\
Given graph , does there exist a set  of at most  edges such that  is a cograph?
\end{problem}

A graph is \emph{trivially perfect} if it has no induced subgraphs isomorphic to a  or a ~\cite{YCC}. Every trivially perfect graph is a cograph and every cograph is a -sparse graph.

\begin{problem}{\sc Trivially Perfect Deletion} :\\
Given graph , does there exist a set  of at most  edges such that  is a trivially perfect graph?
\end{problem}

The idea of the algorithms in this section is to focus on the forbidden subgraphs of -sparse graphs so that efficient branching rules can be designed systematically. This depends critically on whether these problems can be solved polynomially on -sparse graphs. We first show how to solve the cograph deletion problem on -sparse graphs in linear time.

\subsection{Computing Cograph Edge-Deletion Sets on -sparse Graphs in Linear Time}

We show that a linear time divide-and-conquer algorithm can be designed to find the minimum cograph deletion set for -sparse graphs.

\begin{definition}
Let  be a graph and  be the complement of . The vertex sets corresponding to the maximal connected components of  are called the \emph{co-components} of . If  is connected, then we say that  is \emph{co-connected.}
\end{definition}

\begin{proposition}\label{prop:decomposition}
 Let  be a -sparse graph and  be the size of a minimum edge-deletion set required to turn  into a -free graph. Then:
 \begin{itemize}
 \item[i)] if  is disconnected with components , then 
 \item[ii)] if  is disconnected with co-components , then 
 \item[iii)] if  is a spider with head , body  and feet , then .
 \end{itemize}
\end{proposition}

\begin{proof}
 (i) This follows from the fact that a  is connected and so any  is in only one connected component, even after some edge deletions.

 (ii) It is easy to verify that an edge joining two vertices in separate co-components can not be in a  (or else in the graph complement this would imply a  contains vertices in separate connected components as a  is self-complementary.) After any edge-deletions within a co-component are made, the vertex sets of separate co-components are still completely joined, and so any new s will not include any two vertices in separate co-components.

 (iii) Call a \emph{leg edge} any edge joining a vertex  with a vertex , a \emph{head edge} any edge joining some  with some , a \emph{body edge} any edge joining two vertices in , and call a \emph{neck edge} any edge joining some  with some .
  
 The structural definition of a spider says that every vertex in  is adjacent to every vertex in , even after the removal of any leg edges and head edges. Thus a  can never contain an edge  with  and  even after leg and head edge removals. We will show that there is an optimal solution without body edges.
  
 Consider an edge-deletion set  such that  is a cograph, and let  be the set of body edges and neck edges in . Consider the s in  (the s created when adding  back to .) In ,  and  are completely joined and  is a clique and so no  crosses the neck. So any s in  are strictly in  or strictly in . Since  is a cograph deletion set, the induced graph on  in  is -free. In , the body edges added back may be in a  with two leg edges, and if so, this  will be unique by Lemma~\ref{lem:unique}. Adding the body edges from  can not create a  involving a body edge not in , so we just concentrate on the unique  that each of these added body edges may have created. By deleting one of these leg edges for each body edge that creates a , we create a new deletion set  where  is a set of leg edges and , so this new edge deletion set is a solution no larger than  which does not use body or neck edges.
 \hfill 
\end{proof}

We note that parts (i) and (ii) of Proposition~\ref{prop:decomposition} apply to any graph , and not just -sparse graphs.

\begin{lemma} \label{thin}
  Let  be a thin spider with body  and legs , and  is an edge if and only if . Then a minimum cograph edge-deletion set for  is .
\end{lemma}

\begin{proof}
  Since  is a clique and  is stable, every  in  has its endpoints in . Furthermore, every pair of vertices in  are in a unique . Deleting any  thin legs will clearly destroy all of the s, so this edge-deletion set is indeed a cograph edge-deletion set. To see that it is of minimum size, assume there is a deletion set of size  or less in which two legs are not part of the deletion set. Let these two legs be  and  and call them ``permanent" in this case. Since  is a  and the edges  and  are not in the deletion-set, it must be that  is in the deletion set. There at most  other edges in the deletion set. Now  induces a  for every . This means that the permanent edge  is still in  s and every pair of these s have distinct edges aside from . Thus it is impossible to destroy all of these remaining s with only  additional deletions or less.
  \hfill 
\end{proof}

\begin{lemma} \label{thick}
  Let  be a thick spider with body  and feet , and  is an edge if and only if . Then a minimum cograph edge-deletion set for  is .
\end{lemma}

\begin{proof}
 Every edge in  is in exactly one : an edge  is only in the   and any edge  is only in the   so the number of s in  is , and since no two of these s share an edge, at least  deletions are required. Consider the edge set . When deleting  from ,  is still a clique and  is still a stable set, and so if there is any  in , its endpoints must still be in . But after deletion of , we have that the neighbourhood of  is  which means that  for all , and so no two vertices in  can be the endpoints of a . So  indeed destroys all the s in  and since , this is a minimum set.
\hfill 
\end{proof}

\begin{theorem}
 Algorithm~\ref{alg:spider} correctly solves the cograph edge-deletion problem for -sparse graphs and can be implemented in  time.
\end{theorem}

\begin{proof}
 The correctness of Algorithm~\ref{alg:spider} follows from Lemma~\ref{thin}, Lemma~\ref{thick} and Proposition~\ref{prop:decomposition}.

 Algorithm~\ref{alg:spider} can be implemented in linear time, as the spider structure of -sparse graphs can be identified in linear time~\cite{JaOl}. Identifying the connected or co-components can also be done in linear time, as these types of vertex partitions are special cases of the more general notion of a \emph{homogeneous set} or \emph{module}, and there are a number of modular decomposition algorithms running in linear time~\cite{McCSp},~\cite{CoHa}.
\hfill 
\end{proof}

Our algorithm to find cograph edge-deletion sets in -sparse graphs is presented in Algorithm~\ref{alg:spider}.

\begin{algorithm}[H]
\SetAlgoLined Algorithm {\sc Spider()}:\\
\KwIn{A -Sparse Graph }
\KwOut{A set  such that  is a -free graph}
\ \\
\If{ (or ) is disconnected}{
    Let  be the components or co-components of \;
    {\sc Spider}()\;
}
 is a spider with  and \;
\If{ is a thin spider}{
    Notation:  adjacent to  if and only if \;
    Add edge  to solution set  for every \;
}
\If{ is a thick spider}{
    Notation:  adjacent to  if and only if \;
    Add edge  to solution set  for every pair \;
}
Return  {\sc Spider()}\;
\ \\
\caption{Cograph edge-deletion algorithm for -sparse graphs}
\label{alg:spider}
\end{algorithm}

\subsection{A Bounded Search Tree Algorithm for Cograph Edge-Deletion}

The bounded search tree algorithm (Algorithm~\ref{alg:cograph}) finds 5-vertex subsets that induce at least 2 s, branches on the possible ways of destroying the s, and then finally arrives at a -sparse graph and calls Algorithm~\ref{alg:spider}. This algorithm either terminates with a call to the subroutine (in the case that a spider structure is encountered) or detects a cograph structure early, or else its integer parameter  has been reduced to 0 or less in which case the number of allowed edge-deletions has been exhausted without reaching a cograph.

Refer to Figure~\ref{forb} for the possible subgraphs the general search algorithm may encounter. We refer to specific edges as they are labeled in Figure~\ref{forb} for each subgraph. The pseudocode description of the general search algorithm branches on one of the deletion sets given in the table below.

Let  be one of the forbidden subgraphs from Figure~\ref{forb}. The possible edge-deletion sets to destroy the s in  are:


\ \\

\begin{algorithm}[H]
\SetAlgoLined Algorithm {\sc CographDeletion()}\\
\KwIn{A Graph  and a positive integer }
\KwOut{A set  of edges of  with  where  is a cograph if it exists, otherwise {\sc No} }
\ \\
Initialize \;
\If{ is a cograph}{
    Return \;
}
\If{}{
    Return {\sc No}\;
}
Apply a -sparse recognition algorithm\;
\If{ is -sparse}{
     {\sc Spider()}\;
    If , return ; Otherwise, return {\sc No}\;
}
\Else{A forbidden graph  from Figure~\ref{forb} exists\;
    \ForEach{minimal edge-deletion set  for }{
        \;
        {\sc CographDeletion}()\;
    }
}
\ \\
\caption{Bounded search tree algorithm computing a cograph edge-deletion set}
\label{alg:cograph}
\end{algorithm}

It is routine to verify that any edge-deletion set from each of the 7 induced subgraph cases must contain one of the deletion set cases given in the table. Since every  in the graph must be destroyed with an edge deletion, encountering any of these 7 configurations necessitates the need to apply one of the corresponding deletions.

The runtime of the algorithm is dominated by the size of the search tree. The spider structure can be identified in linear time. When  is the parameter measuring the number of edge deletions left to make, the size  of the search tree produced by this process is found from each branch rule separately:
\begin{enumerate}
  \item : five branches, each reducing the parameter by 2 gives  and so 
  \item :  giving 
  \item :  giving 
  \item 4-pan:  giving 
  \item co-4-pan:  giving 
  \item fork:  giving 
  \item kite:  giving 
\end{enumerate}

The size of the search tree is thus upper-bounded by the worst case of deleting s in a 4-pan: .

\begin{theorem}
Algorithm~\ref{alg:cograph} correctly solves the cograph -edge-deletion problem in {} time.
\end{theorem}

\begin{proof}
Jamison and Olariu~\cite{JaOl} give a linear time recognition algorithm for -sparse graphs. In the case that the graph being tested is not -sparse, the algorithm terminates upon finding a 5-set of vertices isomorphic to one of the forbidden subgraphs shown in Figure~\ref{forb}. In  time on a general graph, we can find one of the subgraphs in Figure~\ref{forb} or else assert that our graph is -sparse.

\hfill 
\end{proof}

\subsection{A Bounded Search Tree Algorithm for Edge-Deletion to Trivially Perfect Graphs}

In \cite{Guo}, Guo studied the edge-deletion problem for \emph{complements} of trivially perfect graphs. We know of no prior study of the specific problem of deleting edges to a trivially perfect graph. A na\"ive solution would find a subgraph isomorphic to either a  or a  and then branch on the possible ways of deleting an edge from that subgraph, resulting in a worst-case search tree of size . A minor observation that deleting any one edge from a  always results in the other forbidden subgraph, , allows us to branch on the 6 possible ways of deleting any 2 edges from a . This results in a worst-case search tree of size  due to the 3 edges in a .

We use our strategy of branching towards a relaxation class of trivially perfect graphs. The 6 possible ways of deleting 2 edges from  yield a branching factor of , and since removing two edges from any  is necessary to arrive at a (,)-free graph, our algorithm will begin by performing this branching step before running a -sparse recognition algorithm. Then we proceed as in the previous section, finding any -sparse forbidden subgraph and branching on the ways of deleting s and s in it. Once no -sparse obstruction exists, we solve the problem optimally on the resulting specialized structure (a -free -sparse graph.) The branching rules become simpler in that only 5 of the 7 graphs in Figure~\ref{forb} need consideration. In particular, the \emph{4-pan} that caused the bottleneck of Algorithm~\ref{alg:cograph}, is no longer considered and this changes the runtime of the process from  to .

One main difference in this algorithm from Algorithm~\ref{alg:cograph} is that s are found and destroyed first, and after any of the -sparse deletions are made, the process restarts with looking for s to destroy again. Once the s are destroyed and the resulting graph is -sparse, we proceed with removing edges with edge-deletion algorithm for thin or thick spiders (Algorithm~\ref{alg:spider}).

\begin{algorithm}[H]
\SetAlgoLined Algorithm {\sc TriviallyPerfectEdgeDeletion()}\\
\KwIn{A Graph  and a positive integer }
\KwOut{A set  of edges of  with  where  is trivially perfect if it exists, otherwise {\sc No} }
\ \\
Initialize \;
\If{ is a trivially perfect}{
    Return \;
}
\If{}{
    Return {\sc No}\;
}
\While{There exists  isomorphic to }{
    Create 6 branches corresponding to the possible ways of removing any 2 edges in 
}
Apply a -sparse recognition algorithm\;
\If{ is -sparse}{
     {\sc Spider()}\;
    If , return ; Otherwise, return {\sc No}.
}
\Else{A forbidden graph  from Figure~\ref{forb} exists\;
    \ForEach{minimal vertex-deletion set  for }{
        Add the vertices  to the solution set \;
        {\sc TriviallyPerfectEdgeDeletion}(, )\;
    }
}
\ \\
\caption{Bounded search tree algorithm finding a trivially perfect edge-deletion set}
\label{alg:TrivPer}
\end{algorithm}

The correctness of decomposing the edge-deletion problem into separate problems on  and  depends a proposition similar to Proposition~\ref{prop:decomposition}.

\begin{proposition}\label{prop:trivperdecomp}
 Let  be a -free graph and  be the size of a minimum edge-deletion set required to turn  into a -free graph. Then:
 \begin{itemize}
 \item[i)] if  is disconnected with components , then 
 \item[ii)] if  is disconnected,  is a complete join between a clique and a smaller -free graph, , and .
 \item[iii)] if  is a spider with head , body  and feet , then .
 \end{itemize}
\end{proposition}

\begin{proof}

 Case i): If  has more than one connected component, any edge deletions made in one component cannot create a  or a  in a different connected component.

 Case ii):  is disconnected. Let  be a set of at least 2 vertices inducing a connected component in . Then  induces a -free graph in  since any induced subgraph of a -free graph is -free. Since  is connected in , there must be two non-adjacent vertices  of  in . Let  and  be any two vertices not in . If  and  are not adjacent, then  induces a  in , which is impossible. So any vertices outside of  must induce a clique in . Furthermore, since  is a connected component in , every vertex in  is adjacent to every vertex of the clique . It follows, then, that no  in  includes a vertex of , and after any edge deletions in , no  or  can include a vertex of . Hence .

 Case iii): Notice that no  can include a vertex  from  in a spider even after removals of leg edges and head edges since the neighbourhood of  induces a clique. Since  is a clique, and every  is adjacent to every , there can not exist a  in  unless the  is completely contained in . So no  contains an edge from  to . Therefore, any edge  with  and  is not in any  in , and for any subset of leg edges and head edges  the edge  is not in any  in . Combining this with Proposition~\ref{prop:decomposition} for s establishes the decomposition.
\hfill 

\end{proof}

Proposition~\ref{prop:trivperdecomp} shows us that since all the s are destroyed in the branching stage of {\sc TriviallyPerfectEdgeDeletion()}, once we arrive at a -free spider, we are free to delete leg edges without creating a new .







The runtime of Algorithm~\ref{alg:TrivPer} is dominated by the branching rules once again. Encountering a  results in 6 branches which delete 2 edges each. The resulting recurrence is  and so . Having deleted all the s, we no longer include the  or the \emph{4-pan} cases in our analysis. The runtime analysis for the rest remain unchanged: , co-4-pan: , fork: , kite: . The search tree is thus bounded by the  case of size . Finding a  directly is a problem that is currently best-achieved using matrix multiplication~\cite{KrSp}, so this entire process \emph{as described} runs in  where  is the time required for matrix multiplication (~\cite{CopWin}).

We can, in fact, modify the algorithm to run linearly in  and  by observing that a graph is -free and -free if and only if it is a chordal cograph. By first running a certifying chordal recognition algorithm~\cite{TaYa}, we can either deduce that there is no  or else find a  or a  or a larger induced cycle (and thus a ) and branch on these subgraphs according to the rules we gave, and if the graph is chordal then we apply a -sparse recognition algorithm to find one of the other forbidden induced subgraph, branch on it, and then re-apply the chordal recognition process.

\begin{theorem}
Finding a trivially perfect -edge-deletion set can be solved in  time.
\end{theorem}



\section{Vertex-Deletion Algorithms}

This section shows how our general method can be used to solve vertex-deletion version of our prior two problems:

\begin{problem}{\sc Cograph Vertex-Deletion} :\\
Given graph , does there exist a set  of at most  vertices such that  is a cograph?
\end{problem}

\begin{problem}{\sc Trivially Perfect Vertex-Deletion} :\\
Given graph , does there exist a set  of at most  vertices such that  is a trivially perfect graph?
\end{problem}

\subsection{Vertex-Deletion to Cographs}

Since removing a vertex set  from a graph  is equivalent to taking the induced subgraph on the vertex set , these problems are also often named \emph{maximum induced subgraph} problems. In our case of asking if there is a vertex set of size at most  that can be removed to leave behind a cograph, this is equivalent to asking if there is an induced cograph subgraph of size at least . Removing a vertex from  can never create a new induced subgraph in , and so deleting vertices to destroy induced subgraphs is commonly modeled as a {\sc Hitting Set} problem. In this case in which each  maps to a 4-set in a {\sc Hitting Set} instance, we have the restricted problem of a 4-{\sc Hitting Set}. Algorithms for such vertex-deletion problems should always be compared against the state-of-the-art algorithms of {\sc Hitting Set} if not anything else. -{\sc Hitting Set} is a well-studied NP-complete problem which admits fixed-parameter tractable algorithms. The first improved analysis of -{\sc Hitting Set} by Niedermeier and Rossmanith~\cite{NiRo} give a search tree of size , and a more detailed and involved analysis by Fernau~\cite{Fer} improves the bound to . This is the best known bound for -{\sc Hitting Set} to date.

The simple spider structure of  sparse graphs allows us to describe a simple algorithm for the vertex-deletion problem to cographs. The runtime of this simple algorithm matches that of~\cite{GGHN} and of~\cite{NiRo}. The algorithm in~\cite{GGHN} used branching rules that were designed by breaking the s in every subgraph of size . Testing various values of  deduced that rules based on subgraphs of size 7 yielded the optimal runtime of an algorithm of this sort, with runtime . Their algorithm builds branching rules from 447 graphs of size 7, while our algorithm only involves seven graphs on 5 vertices (Figure~\ref{forb}.)

In the following subsection, we use the analysis technique of~\cite{NiRo} to show that the runtime of our bounded search tree algorithm is , hence improving on Fernau's . Our runtime could be improved further if we were to use the methods of Fernau~\cite{Fer}, but such an analysis is extensive and would sidetrack from the focus of this paper.

We describe the subroutine {\sc Spider Vertex-Deletion} here. The algorithm works in the same way as Algorithm~\ref{alg:spider}, taking as input a -sparse graph and returning the optimal number of vertices to remove in order to break all s in the graph. For thin spiders, every pair of feet is the end-pair of a , and removing any  vertices from  will destroy all the s in the body and legs. Removing less than  will leave at least two thin legs and hence a , so  is necessary.

Since a set of 4 vertices induces a  in a graph  if and only if they induce a  in , deleting any  vertices from  in a thick spider will destroy all the s in . In either the thin or thick spider case, the subroutine is then applied to head . This concludes the description of {\sc Spider Vertex-Deletion}. The correctness of the algorithm is asserted by the following proposition:

\begin{proposition}\label{prop:cographvertex}
Let  be a spider with head , body  and feet . Let  be the minimum number of vertices required to remove from  in order to turn  into a cograph. Then .
\end{proposition}

\begin{proof}
  Deleting vertices from a graph can never create a new . We know from Proposition~\ref{prop:decomposition} that no  includes vertices from both  and . Deleting any vertices from  will not destroy s in , and vertex deletions from  will not destroy any s in . Hence .
  \hfill 
\end{proof}

\begin{corollary}
  The algorithm {\sc Spider Vertex-Deletion} described above correctly solves the cograph vertex deletion problem for spiders in linear time.
\end{corollary}

For a general graph, we proceed as in the cograph edge-deletion algorithm. We find -sparse obstructions and branch on the possible ways of deleting vertices to destroy all s, repeating until the remaining graph is -sparse. The pseudocode description is given in~\ref{alg:cographVertex}.


\begin{algorithm}[H]
\SetAlgoLined Algorithm {\sc CographVertexDeletion()}\\
\KwIn{A Graph  and a positive integer }
\KwOut{A set  of vertices of  with  where  is a cograph if it exists, otherwise {\sc No} }
\ \\
Initialize \;
\If{ is a cograph}{
    Return \;
}
\If{}{
    Return {\sc No}\;
}
Apply a -sparse recognition algorithm\;
\If{ is -sparse}{
     {\sc Spider Vertex-Deletion()}\;
    If , return ; Otherwise, return {\sc No}.
}
\Else{A forbidden graph  from Figure~\ref{forb} exists\;
    \ForEach{minimal vertex-deletion set  for }{
        Add the vertices  to the solution set \;
        {\sc CographVertexDeletion}(, )\;
    }
}
\ \\
\caption{Bounded search tree algorithm finding a cograph vertex-deletion set}
\label{alg:cographVertex}
\end{algorithm}

The branching rules for the vertex deletions are given in a table as before:



The runtime of the algorithm is dominated by the branching steps. The runtime  for the  case depends on 10 branches, while each of the other cases have equivalent runtime analysis.

\begin{enumerate}
  \item : ten branches, each reducing the parameter by 2 gives  and so 
  \item All others:  giving 
\end{enumerate}

The runtime of this vertex-deletion algorithm is bounded by , matching the runtime of the cograph vertex deletion algorithm generated by automated branching rule design~\cite{GGHN}.

\begin{theorem}
    Algorithm~\ref{alg:cographVertex} solves the vertex-deletion problem for cographs in  time.
\end{theorem}

\subsection{Improvement using Hitting-Set}

The 4-{\sc Hitting Set} algorithm of~\cite{NiRo} involves an analysis which counts when a branch choice can be made on a 3-set. Without counting these cases, an algorithm for 4-{\sc Hitting Set} which only makes choices on 4-sets will have a search tree size of . By keeping track of when 3-sets are created in the search process and by branching on 3-sets whenever they are available, the authors of~\cite{NiRo} are able to improve the upper-bound to the size of the search tree to .

We show here that using a similar technique to that in~\cite{NiRo} can improve our search tree size. For an instance  of cograph vertex-deletion, we will use an implicit instance of 4-{\sc Hitting Set} where each set of 4 vertices inducing a  in  corresponds to a 4-set. A cograph deletion set for  will correspond to the hitting set of the set of 4-sets. 

We adapt the notion of dominance from {\sc Hitting Set} to that of s: a vertex  \emph{-dominates}  if  exists in every  that  is in.

Following the {\sc Hitting Set} method, we observe that if  -dominates , then any hitting set that contains  could be replaced with a hitting set containing . Using this observation, we \emph{mark}  in the graph to signify that it will not be in our solution. When we encounter s involving , the  only needs to be considered as a 3-set to hit. Marking  in  is equivalent to removing  in the implicit 4-{\sc Hitting Set} instance.

Our vertex-deletion algorithm given in the previous subsection applies a -sparse recognition algorithm to find one of the 7 forbidden configurations from Figure~1. We illustrate how to proceed to the branching step when encountering a :  with  and  as the endpoints:

If we put  in , remove  from the graph  and reduce the parameter  by 1. Any set in the hitting set instance  containing  is removed. Otherwise (if  is not in ) we mark  in  and remove  from , possibly creating some 3-sets. If  is put in , reduce  by 1 and remove  from the graph, as before. Otherwise (if  is also not in ) then mark  in the graph and remove  from . If  is in , reduce  by 1 and remove any set containing . Otherwise (if none of  are in ) we add  and  to , remove them from  and reduce the parameter  by 2.

If we first ensure that -dominated vertices have been removed from consideration, some vertices in the  (or analogous forbidden subgraph) may be marked. We do not need to build branches on cases asking if a vertex  is in  if  is already marked. If we encounter a  in one of our forbidden subgraphs consisting of four marked vertices, we can terminate that branch of the search tree and backtrack.

When encountering any of the -sparse forbidden subgraphs: , kite, fork, 4-pan, co-4-pan, we have in each case 3 vertices whose removal will break both s in the obstruction, or else two vertices which must be removed together. Call those first 3 vertices the \emph{breaking vertices.} Our process is summarized in the following algorithm:\\


\begin{algorithm}[H]
\SetAlgoLined Algorithm {\sc CographVertexDeletionHittingSet()}\\
\KwIn{A Graph  and a positive integer }
\ \\
1. If any 3-set has been created, branch on that 3-set. Repeat until there are no more 3-sets\;
2. If any vertex is -dominated, mark it in  and remove it from the hitting set. Go to step 1.\;
3. Find one of , kite, fork, 4-pan, co-4-pan.\;
4. If there is a  all of whose vertices are marked, {\sc Stop} and backtrack.\;
5. Branch on the (up to 3) unmarked breaking vertices using the cases as described above. Go to step 1.\;
6. If all three breaking vertices are marked, include the other two vertices in  and Go to 1.\;
7. If no such subgraph can be found, our graph is an \emph{extended -sparse graph} (See below.) Solve the remainder optimally without search.\\
\ \\
\caption{Using Hitting-Set for Cograph Vertex-Deletion}
\label{alg:cographVertexHittingSet}
\end{algorithm}

Let  and  be breaking vertices encountered after steps 1 and 2 cannot be applied any further. If  is not in any other  besides the two s in the obstruction graph found in step 3, then  is -dominated by , but this cannot happen if steps 1 and 2 are done to exhaustion. So we have that  must be in another  not involving . When branching on , we consider , in which case  is removed from , or  in which case we remove  from , creating at least one 3-set since we established that  must be in another  not containing .

Step 3 can be performed with a linear-time algorithm recognizing (, kite, fork, 4-pan, co-4-pan)-free graphs. These are called \emph{extended -sparse graphs} by Giakoumakis and Vanherpe~\cite{GV}. This ensures we do not encounter a  at this stage of the process. They showed:

\begin{theorem}\cite{GV}
If  is a  in an extended -sparse graph, then  is a prime module.
\end{theorem}

\begin{figure}
    \hspace{3.6cm}
  \includegraphics[height=2cm]{Impossible.pdf}\\
  \caption{An impossible configuration for a  in an extended -sparse graph}\label{impossible}
\end{figure}

Let  be a  in our graph after reaching step 7 of our hitting-set process. Observe that every 4-set of  induces a , so no vertex of  is contained in a nontrivial module or else we will have one of the forbidden subgraphs of extended -sparse graphs which we have already destroyed. Further,  can not be a module in some  or else that  extends to one of the forbidden graphs already destroyed (see Figure~\ref{impossible}.) It must be that  is a set of 5 vertices inducing a 5-cycle and not overlapping with any other . Since  does not intersect with any other existing s left in , we are free to choose any two vertices of  to add to  and delete from .

After deleting every  from the extended -sparse graph, we have a conventional -sparse graph and we proceed with vertex deletions for spiders using {\sc Spider Vertex-Deletion} described in the previous subsection.

Let  be the number of leaves in a search tree of our vertex deletion problem, and let  be the number of leaves in a search tree for this problem whose root branched on a 3-set. Step 4 of Algorithm~\ref{alg:cographVertexHittingSet}, can (at worst) branch on each of the breaking vertices. If the first vertex is put in , we reduce  by 1 and so we have a  branch. If we assume the first vertex is not in  and select the second vertex to be in , the parameter decreases by 1. Since this first vertex is not -dominated (or else it would have been marked), it must be in another  and so marking the it will create at least one 3-set in , giving a  branch. Along the same lines, if we choose the third breaking vertex, we arrive at another  branch. In the final case of deleting the two non-breaking vertices, we create a  branch. Together this puts an upper bound on  of .

Similarly, when branching on a 3-set, . Together, these two recurrences give a simultaneous system from which one can show  and  with a straightforward induction proof.

\begin{theorem} Algorithm~\ref{alg:cographVertexHittingSet} solves the cograph vertex-deletion problem in  time.
\end{theorem}

The method of analyzing the search tree size created upon the existence of a 3-set shows that our search tree size is smaller than the  for 4-{\sc Hitting Set} found by Niedermeier and Rossmanith~\cite{NiRo}. Fernau~\cite{Fer} refines this analysis process by keeping track of the \emph{the number} of -sets in -{\sc Hitting Set}, arriving at  for 4-hitting set. Specifically, Fernau's analysis involves expressions  for  where  is the number of 3-sets in an instance of 4-hitting set (in our case,  is .) We are confident that a similar refinement in the analysis of our vertex-deletion algorithm would reveal further gains, but our presented algorithm is already shown to have a smaller search space.

\subsection{Vertex-Deletion for Trivially Perfect Graphs}

Given a graph , our task now is to find the largest induced trivially perfect subgraph in . Equivalently, given a value , we want know whether we can delete at most  vertices in order to turn the graph -free and -free.

In the edge-deletion version of this problem from the previous section, we deleted at least 2 edges from all s in the branching process since 2 edges is necessary, and this was algorithmically appealing as it decreased the parameter by 2. The vertex-deletion problem does not share this luxury: there are 4 vertices in a  and only a single vertex removal is required to turn it into a (, )-free graph. This will result in a more complicated procedure to delete all remaining s in the -sparse graph that remains after the search process.

We will proceed directly to finding the -sparse obstructions and branching on them to turn each one into a -free graph. This yields a worst-case runtime of , as summarized by the following table for each obstruction graph :



The runtime for each of these cases is summarized below:

\begin{enumerate}
  \item : five branches, each reducing the parameter by 2 gives  and so 
  \item :  giving 
  \item :  giving 
  \item 4-pan:  giving 
  \item co-4-pan:  giving 
  \item fork:  giving 
  \item kite:  giving 
\end{enumerate}

After all the forbidden configurations of -sparse graphs have been destroyed, we are left with a -sparse graph from which we must delete vertices to destroy the remainder of the s and s. While s do not exist in a thin or thick spider, s will exist across co-components. Namely, if  and  are two non-clique co-components, then any two nonadjacent vertices  and  in  and any two nonadjacent vertices  and  in  will induce a 4-cycle. Since each connected component and co-component of a -sparse graph must be a spider, every induced 4-cycle must be the type that crosses non-clique co-components.

In order for this -sparse graph to be  free, all but one of the co-components must be a clique. The only s that will be left to delete will be those strictly in the non-clique co-component. To determine the optimal way at arriving at this point, let us introduce some notation: for a -sparse graph , let  be the co-components of . Let  be the size of a maximum clique in , and  be the size of a minimum cograph vertex-deletion set, as found by the algorithm {\sc Spider Vertex-Deletion}.

We seek to find  such that deleting all co-components  into cliques, plus {\sc Spider Vertex-Deletion}() is a minimum. That is, we want to find  that minimizes


For a particular ,  is fixed, as is . We see that the expression above is minimized when  is chosen such that  is a maximum.

Our algorithm is as follows:

\begin{algorithm}[H]
\SetAlgoLined Algorithm {\sc TriviallyPerfectVertexDeletion()}\\
\KwIn{A Graph  and a positive integer }
\KwOut{{\sc Yes} if there exists a set  of at most  vertices so that  is trivially perfect, {\sc No} otherwise.}
\ \\
\While{ is not -sparse}{
    Let  be a -sparse obstruction subgraph\;
    Branch on the possible ways of deleting the s and s from H\;
    Let  be the number of vertex deletions made in this stage\;
}
 is -sparse. Let  be the co-components of \;
Fix  to be the lowest index maximizing \;
\For{}{
    Fix a maximum clique of \;
    Delete any vertex of  which is not in this maximum clique\;
}
Let  be the number of vertex deletions made in the for-loop\;
Let  be the number of deletions performed in {\sc Spider Vertex-Deletion}()\;
\If{}{
    return {\sc Yes}\;
}
return {\sc No}\;
\ \\
\caption{Trivially Perfect Vertex-Deletion Algorithm}
\label{alg:TrivPerfVertex}
\end{algorithm}

Since maximum cliques can be found in linear time on -sparse graphs, it is clear that this algorithm runs in polynomial time for any fixed . The runtime is dominated by the exponential factor from the search tree, which was shown to be .

\begin{theorem}
Algorithm~\ref{alg:TrivPerfVertex} is a fixed-parameter tractable algorithm which solves the vertex-deletion problem for trivially perfect graphs in .
\end{theorem}

Of course, a hitting set-style improvement similar to the previous section could be applied here.

\section{Conclusions and Future Work}

We presented a general method for solving a variety of graph modification problems by limiting a search to a superclass of graphs which are close enough to the target that an optimal polynomial-time subroutine can be used. The algorithms presented here depend on the fact that deleting edges or vertices to a cograph or a trivially-perfect graph can be solved in linear time when the input is a -sparse graph. For general input, we gave the first non-trivial algorithm for the cograph edge-deletion problem (running in ) and trivially-perfect edge-deletion problem (running in  time.) We gave simple algorithms to find minimum vertex-deletion sets to cographs and trivially perfect graphs whose runtime of  matched the existing literature. We also illustrated how a careful branching strategy and refined analysis technique improved the runtime to  for the cograph vertex deletion problem, and noted that these vertex-deletion problems can likely yield to further improvements with a more detailed analysis.

Our general method of branching toward a superclass of the target class benefits from few branching rules. This paper concentrated on only 7 graph configurations of -sparse graphs, allowing to explicitly define the small number branching rules when compared to the automated method of~\cite{GGHN}.

This paper leaves open many opportunities for future work. Firstly, the bound of  for cograph edge-deletion is due to the basic branching rules when encountering the 4-pan subgraph. Any improvement on this branching step would reduce the bottleneck of the cograph edge-deletion algorithm. Alternately, one could remove the 4-pan from the list of subgraphs to branch on provided this is accompanied with an efficient algorithm to optimally solve cograph edge-deletion on a (, , kite, fork, co-4-pan)-free graphs (which are a restricted version of \emph{semi -sparse graphs}~\cite{FG}. Such an algorithm would improve cograph edge-deletion from  to .

The literature on graph classes is extensive~\cite{BLS}, and many of these classes admit polynomial time solutions to many NP-complete problems. We expect that new and fast fixed-parameter tractable algorithms will soon develop through the use of superclasses as we have used in this paper. It would be interesting to see if the linear time algorithms for treewidth and minimum fill-in on permutation graphs~\cite{Mei} and on distance hereditary graphs~\cite{BDK}, or polynomial time algorithms on weakly chordal graphs~\cite{BT99} could be used to design simple FPT algorithms for those problems.




\bibliography{mybibtex}


\end{document}
