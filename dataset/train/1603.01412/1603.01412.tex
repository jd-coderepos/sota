\RequirePackage{fix-cm}
\documentclass[11pt]{llncs}


\usepackage{fullpage}

\def \proc{{\bf proc}\ }
\def \lact{\mathop{|\joinrel\![}}
\def \ract{\mathop{]\joinrel\!|}}

\def \hvar{h}
\def \hrvar{{\sf hr}}
\def \ttvar{tt}
\def \outtvar{{\sf out_t}}
\def \outIvar{{\sf out_1}}
\def \outIIvar{{\sf out_2}}
\def \pctvar{pc_t}
\def \hpctvar{{\widehat{pc}_t}}
\def \hpcIvar{{\widehat{pc}_1}}
\def \hpcIIvar{{\widehat{pc}_2}}
\def \calltvar{{\sf call_t}}
\def \callIvar{{\sf call_1}}
\def \callIIvar{{\sf call_2}}
\def \endbox{\hfill \qed}


\usepackage{xspace}

\def\matches{\rightarrowtriangle}
\newcommand\Tstrut{\rule{0pt}{2.6ex}}         \newcommand\Bstrut{\rule[-0.9ex]{0pt}{0pt}}   

\def \outt {\xspace} 
\def \outu {\xspace}
\def \follows {\Leftarrow} 

\def \nasgn {\mathbin{:\joinrel\in}}
\def \qa {\mathbin{?}}  
\def \bs{\backslash}

\def \qb {\mathbin{!}}

\def \out {out}


\usepackage{graphicx}
\usepackage{rcp}
\usepackage{url}
\usepackage{amsmath}
\usepackage{color}
\usepackage{stmaryrd}
\usepackage{oz}
\usepackage{zed-csp}
\usepackage{wasysym}


\newcommand{\rstmt}[1]{\langle #1 \rangle}

\newcommand{\beh}[1]{\llbracket #1 \rrbracket}

\newcommand{\rStut}{rS}
\newcommand{\rPriv}{rL}
\newcommand{\rSp}{rSp}


\def \diverge {{\mathop \uparrow}}

\def \traces {{\sf Tr}}
\def \WF {\ensuremath{{\sf WF}}}
\def \SF {\ensuremath{{\sf SF}}}
\def \Mfair {\ensuremath{{\sf Tr_{MF}}}}
\def \Wfair {\ensuremath{{\sf Tr_{WF}}}}
\def \Sfair {\ensuremath{{\sf Tr_{SF}}}}
\def \Ftraces {\ensuremath{{\sf Tr_{F}}}}
\def \Fair {{\mathrel{\mathsf{F}}}}
\def \fair {{\ensuremath{\mathrel{\mathsf{F}}}}}


\def \all  {\forall}
\def \asgn  {{\;:=\;}}

\def \refseq  {{\;\sqsubseteq\!\!\!\!\!\!\sqsupseteq\;}}
\def \refs  {{\;\sqsubseteq\;}}

\def \sref  {\sqsubseteq}
\def \srefc  {\mathbin{\widehat{\sqsubseteq}}}


\def \unit {\mathbb{1}}
\def \zero {\mathbb{O}}
\def \bfA {{\bf A}}
\def \var {{\bf var}\ }
\def \rav {{\bf rav}\ }
\def \lvar {{\bf var_u}\ }
\def \gvar {{\bf var_o}\ }
\def \entails {\Rrightarrow}
\def \val {{\bf val}\ }
\def \res {{\bf res}\ }


\newcommand{\sskip}{\mathbf{skip}}
\newcommand{\iif}{\mathbf{if}}
\newcommand{\tthen}{\mathbf{then}}
\newcommand{\eelse}{\mathbf{else}}
\newcommand{\ffi}{\mathbf{fi}}
\newcommand{\wwhile}{\mathbf{while}}
\newcommand{\ddo}{\mathbf{do}}
\newcommand{\ood}{\mathbf{od}}
\newcommand{\iinv}{\mathbf{inv}}
\newcommand{\eemp}{\mathbf{emp}}
\newcommand{\cons}{\mathbf{cons}}
\newcommand{\dispose}{\mathbf{dispose}}


\renewcommand{\End}{{\bf end}\ }
\newcommand{\Class}{{\bf class}\ }
\newcommand{\Var}{{\bf var}\ }
\renewcommand{\Init}{{\bf initialisation}\ }
\newcommand{\Method}{{\bf method}\ }
\newcommand{\When}{{\bf when}\ }
\newcommand{\While}{{\bf while}\ }
\renewcommand{\Then}{{\bf then}\ }
\newcommand{\Do}{{\bf do}\ }
\newcommand{\Action}{{\bf action}\ }
\newcommand{\Assert}{{\bf assert}\ }
\renewcommand{\Begin}{{\bf begin}\ }
\renewcommand{\If}{{\bf if}\ }
\renewcommand{\Else}{{\bf else}\ }
\newcommand{\New}{{\bf new}\ }

\newcommand{\invar}{\mathbf{in}}
\newcommand{\outvar}{\mathbf{out}}

\usepackage{mathrsfs}
\newcommand{\msA}{\mathscr{A}}
\newcommand{\msB}{\mathscr{B}}
\newcommand{\msC}{\mathscr{C}}

\newcommand{\mcA}{\mathcal{A}}
\newcommand{\mcB}{\mathcal{B}}
\newcommand{\mcC}{\mathcal{C}}
\newcommand{\mcD}{\mathcal{D}}
\newcommand{\mcP}{\mathcal{P}}
\newcommand{\mcR}{\mathcal{R}} 
\newcommand{\mcT}{\mathcal{T}}
\newcommand{\msS}{\mathcal{S}} 
\newcommand{\mcS}{\mathcal{S}}


\newcommand{\mcM}{\mathcal{M}}


\newcommand{\MGC}{\mathcal{M}}


\newcommand{\Abort}{\mathbf{abort}}
\newcommand{\Magic}{\mathbf{magic}}

\newcommand{\triple}[3]{\{#1\}\ #2\ \{#3\}}
\newcommand{\ifstat}[3] {\iif \ #1 \ \tthen \ #2 \ \eelse \ #3 \ \ffi}
\newcommand{\whileloop}[2] {\wwhile \ #1 \ \ddo \ #2 \ \ood}
\newcommand{\whileinv}[3] {\wwhile \ #1 \ \iinv \ #2 \ \ddo \ #3 \ \ood}
\newcommand{\predT}[1]{[#1]}

\newcommand{\wand}{-\hspace{-0.42em}\ast\ }

\newcommand{\emptylist}{[~]}
\newcommand{\mapslist}{\ [\mapsto]\ }




\newcommand{\refeq}[1]{(\ref{#1})}
\newcommand{\refeqn}[1]{(\ref{#1})}
\newcommand{\eqrng}[2]{(\ref{#1}-\ref{#2})}
\newcommand{\refprop}[1]{Proposition~\ref{#1}}
\newcommand{\reffig}[1]{Fig.~\ref{#1}}
\newcommand{\refthm}[1]{Theorem~\ref{#1}}
\newcommand{\reflem}[1]{Lem\-ma~\ref{#1}}
\newcommand{\refcor}[1]{Corollary~\ref{#1}}
\newcommand{\refsec}[1]{Section~\ref{#1}}
\newcommand{\refex}[1]{Example~\ref{#1}}
\newcommand{\refdef}[1]{Definition~\ref{#1}}
\newcommand{\refchap}[1]{Chapter~\ref{#1}}
\newcommand{\reftab}[1]{Table~\ref{#1}}



















\authorrunning{Brijesh Dongol and Lindsay Groves} 
\titlerunning{Contextual trace refinement for concurrent objects}




\usepackage[scaled]{beramono}
\usepackage[T1]{fontenc}


\newcommand{\OMIT}[1]{{}}\usepackage{color}

\newcommand{\invoke}[3]{inv(#1, #2, #3)}
\newcommand{\return}[3]{ret(#1, #2, #3)}
\newcommand{\invokeb}[2]{#2_{#1}}
\newcommand{\returnb}[2]{\widehat{#2}_{#1}}

\title{Contextual trace refinement for concurrent objects: \\Safety
  and progress}

\author{Brijesh Dongol\inst{1} \and Lindsay Groves\inst{2}}

\institute{Department of Computer Science,\\
  Brunel University London, UK\\
 \email{Brijesh.Dongol@brunel.ac.uk} \
  \begin{array}[t]{@{}ll@{}}
    & pc_2 = U1 \land S = \emptyseq \to out \asgn empty ; npc_2(U2)\\
    \sqcap & pc_2 = U1 \land S \neq \emptyseq \to out, S \asgn head.S,
    tail.S \,; npc_2(U2)
  \end{array}

\begin{array}[t]{@{}ll@{}}
  act.P \sdef \textstyle\bigsqcap_{v, x, t}\
  p_{1,t}(v,x) \sqcap \dots \sqcap p_{n,t}(v,x)
\end{array}

rem.P \sdef \textstyle\bigsqcap_{v, x, t}\ \neg dec(\hpctvar) \to
\begin{array}[t]{@{}l@{}}
  (p_{1,t}(v,x) \sqcap \dots \sqcap p_{n,t}(v,x))
\end{array}

    \label{eq:l9}
    rel.I_C.\tau' & \imp & \exists \sigma \dot
    R.\sigma.\tau'  \land
    rel.I_A.\sigma
    \\
    \label{eq:l10-s}
    R.\sigma.\tau \land rel.(act.P_C).\tau.\tau' &
    \imp & \exists \sigma' \dot R.\sigma'.\tau' \land
    rel.(act.P_A)^*.\sigma.\sigma'
\\
    \label{eq:l11} 
    R.\sigma.\tau \land \neg grd.(act.P_C).\tau & \imp & \neg
    grd.(act.P_A).\sigma
    \\
    \label{eq:l12}
    \begin{array}[b]{@{}r@{}}
\tau' = (\tau \oplus \textstyle \bigcup_{t:T}
      \{tt_t \mapsto false\})
    \end{array}
                  & \imp & term.(rem.P_C).\tau'  
    \label{eq:1}
    rel.I_C.\tau' \land R.\sigma'.\tau' & \imp & rel.I_A.\sigma'
    \\
    \label{eq:2}
    rel.(act.P_C).\tau.\tau' \land R.\sigma'.\tau'  & \imp & \exists 
    \sigma \dot R.\sigma.\tau \land rel.(act.P_A)^*.\sigma.\sigma'
    \\
    \label{eq:13}
    \neg grd.(act.P_C).\tau & \imp & \exists \sigma \dot R.\sigma.\tau \land \neg
    grd.(act.P_A).\sigma
(s.j).\ttvar \lor \exists m \dot pi(m, (s.j).H) \land \neg pi(m,
  (s.(j+1)).H)1mm]
  lin(h,f) & \sdef & \all m,n : \dom f \dot m < n \land  ret?(h.m)
  \land inv?(h.n) \imp f.m < f.n
\end{array}OCOAOC
  \models_{OA} lin \land totalp_t(\val in, \res out) = P_t\begin{array}{rcl}
    P^\xi_t & \sdef  &
    \begin{array}[t]{@{}l@{~}l@{~}l@{}}
      & \neg dec(\pctvar)  & \to\ \var \pctvar; \pctvar \asgn 1 ; H \cat \langle inv(t, p,
        in) \rangle
      \\
      \sqcap & \pctvar = 1 & \to\ p_t(in, out) ; \pctvar \asgn 2
      \\
      \sqcap & \pctvar = 2 & \to\ \rav  \pctvar ; H \cat \langle
                             ret(t, p, out) \rangle
    \end{array}
  \end{array}OAOBOBOAOA \srefc OBOBrel.act.OBrel.act.OBOBpopOCOAOCOAOA, OBOC\MGC[OA]OC \models_{OA} lin \land totalOBOAR\MGC[OB]\MGC[OC]OCOAOC\mcM[OA]\mcC\mcC[OA]\mcC[OA] \sref \mcC[OC]OBOA\sref\mcC[OA] \sref \mcC[OB]\mcC[OB] \sref \mcC[OC]\mcC[OA]\mcC[OB]R\MGC[OB]\MGC[OC]R\mcC[OB]\mcC[OC]scqcqp\begin{array}{rcl}
  sc(h, f) & \sdef & \all m, n : \dom f
  \dot \begin{array}[t]{@{}l@{}}
    m < n \land \pi_1.(h.m) = \pi_1.(h.n) \land \\
    ret?(h.m) \land inv?(h.n) \imp f.m < f.n
  \end{array} 
  \1mm]
  qc(h, f) & \sdef & \all m, k, n : \dom f \dot m < k < n \land 
  qp(k, h) \imp f.m < f.n
\end{array}OCOAOC \models_{OA} sc \land totalOCOAOC \models_{OA} qc \land
  totalOCOAOA \srefc OCs
  \langle (x, y, z) \mapsto (0, 0, 0), \ \ (x, y, z) \mapsto (1,0,0),
  \ \ (x, y, z) \mapsto (1,0,1), \ \ (x, y, z) \mapsto
  (1,2,1)\rangleASOCOAOA \srefc OCs
  \langle (x, y, z) \mapsto (0, 0,
  0), \ \ (x, y, z) \mapsto (1,0,0), \ \ (x, y, z) \mapsto (1,2,0), \
  \ (x, y, z) \mapsto (1,2,3)\rangle
  popT3T4popU1T1T2T3T4AS$ from
  \reffig{fig:Abstract-TS}.  \hfill \qed
\vspace{-2mm}


\section{Conclusions}


In this paper, we have developed a framework, based on action systems
with procedures, for studying the link between the correctness
conditions for concurrent objects and contextual trace refinement,
which guarantees substitutability of objects within potentially
non-terminating reactive clients. Thus, we bring together the
previously disconnected worlds of correctness for concurrent objects
and trace refinement within action systems. We have shown that
linearizability and minimal progress together ensure contextual trace
refinement, but sequential consistency and quiescent consistency are
inadequate for guaranteeing contextual trace refinement regardless of
whether clients communicate outside the concurrent object. The
sequential consistency result contrasts earlier results for
observational refinement, where sequential consistency is adequate
when clients only communicate through shared objects~\cite{FORY10}.







We have derived the sufficient conditions for contextual trace
refinement using the proof obligations for forwards and backward
simulation. However, neither of these conditions have been shown to be
necessary, leaving open the possibility of using weaker correctness
conditions on the underlying concurrent objects.  Studying this
relationship remains part of future work --- areas of interest include
the study of how the correctness conditions for safety of concurrent
objects under relaxed memory models \cite{DDGS15-ECOOP} can be
combined with different scheduler implementations for progress (e.g.,
extending \cite{LiangHFS13,HS11}) to ensure contextual trace
refinement. 





























\subsubsection*{Acknowledgements}
We thank John Derrick and Graeme Smith for helpful discussions.
Brijesh Dongol is supported by EPSRC grant EP/N016661/1 ``Verifiably
correct high-performance concurrency libraries for multi-core
computing systems''.


\bibliographystyle{plain}

\bibliography{main,ls}


\end{document}
