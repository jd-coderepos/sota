\documentclass[fleqn]{LMCS}



\usepackage{url}
\usepackage{latexsym}
\usepackage{amsfonts}
\usepackage{amssymb,amsmath}
\usepackage{enumerate}
\usepackage[breaklinks=true]{hyperref} 





\theoremstyle{plain}\newtheorem{satz}[thm]{Satz}
\theoremstyle{plain}\newtheorem{hyp}[thm]{Hypothesis}
\theoremstyle{plain}\newtheorem{hyps}[thm]{Hypotheses}
\theoremstyle{definition}\newtheorem{note}[thm]{Note}
\def\eg{{\em e.g.}}
\def\cf{{\em cf.}}



\marginparwidth=20mm
\marginparsep=1mm















\newcommand{\To}{T}
\newcommand{\fo}{f}


\newcommand{\EE}{\mathcal{E}}

\newcommand{\restr}{\upharpoonright}

\newcommand{\lqq}{\mbox{``}}
\newcommand{\rqq}{\mbox{''}}

\newcommand{\defis}{\mbox{-}}

\newcommand{\setof}[1]{\{#1\}}
\newcommand{\App}{{\rm App}}

\newcommand{\bYdef}{\mathrel{\BYDEF}}
\newcommand{\BYDEF}{\mbox{}}


\newcommand{\pr}{^{\prime}}
\newcommand{\pointwiselub}{\biguplus}

\newcommand{\arr}{\rightarrow}
\newcommand{\arrr}{\longrightarrow}
\newcommand{\Arr}{\Rightarrow}
\newcommand{\Arrr}{\Longrightarrow}
\newcommand{\Larr}{\Leftarrow}
\newcommand{\Arra}{\Leftrightarrow}
\newcommand{\embed}{\hookrightarrow}

\newcommand{\bm}{\boldmath}
\newcommand{\la}{\langle}
\newcommand{\ra}{\rangle}
\newcommand{\lla}{\langle\!\langle}
\newcommand{\rra}{\rangle\!\rangle}
\newcommand{\Osem}[1]{\lla #1 \rra}
\newcommand{\Dsem}[1]{[\![ #1 ]\!]}
\newcommand{\tuple}[1]{\la #1 \ra}
\newcommand{\AND}{\mathrel{\&}}

\newcommand{\G}{G}
\newcommand{\NN}{\mathbf{N}}
\newcommand{\bNN}{\bar{\NN}}
\newcommand{\bMM}{\bar{\MM}}

\newcommand{\BB}{\mathbf{B}}
\newcommand{\bQQ}{\bar{\QQ}}
\newcommand{\bbQ}{\mathbb{Q}}
\newcommand{\tbbQ}{\mathbb{Q}}\newcommand{\bbW}{\mathbb{W}}
\newcommand{\tbbW}{\mathbb{W}}\newcommand{\bbD}{\mathbb{D}}

\newcommand{\Basictype}{\iota}
\newcommand{\PCF}{\mbox{\bf PCF}}
\newcommand{\cPCF}{\mbox{}}

\newcommand{\LCF}{\mbox{\bf LCF}}

\newcommand{\I}{\mbox{\bf I}}
\newcommand{\K}{\mbox{\bf K}}
\newcommand{\Ss}{\mbox{\bf S}}
\newcommand{\Y}{\mbox{\bf Y}}
\newcommand{\IF}{\mbox{\bf if}}
\newcommand{\PIF}{\mbox{\bf pif}}
\newcommand{\THEN}{\mbox{\bf then}}
\newcommand{\ELSE}{\mbox{\bf else}}
\newcommand{\mPIF}{m_{\rm\bf pif}}

\newcommand{\CC}{{\mathcal C}}
\newcommand{\KA}{{\mathcal K}^A}
\newcommand{\KbarA}{{\mathcal K}^{\bar{A}}}
\newcommand{\KAeff}{{\mathcal K}^A_{\rm eff}}

\newcommand{\jj}{\underline{j}}




\newcommand{\bottom}{{\perp}}
\newcommand{\Undef}{{\perp}}

\newcommand{\fla}[1]{}   



\newcommand{\Lub}{\bigsqcup}
\newcommand{\MM}{{\mathcal M}}
\newcommand{\sM}{M^{\bigstar}}
\newcommand{\sm}{m^{\bigstar}}
\newcommand{\sMM}{\MM^{\bigstar}}
\newcommand{\HH}{{\mathcal H}}
\newcommand{\bx}{\bar{x}}
\newcommand{\bY}{\bar{y}}
\newcommand{\bc}{\bar{c}}
\newcommand{\bC}{\bar{C}}
\newcommand{\bq}{\bar{q}}
\newcommand{\bj}{\bar{j}}
\newcommand{\bi}{\bar{i}}
\newcommand{\bpsi}{\bar{\psi}}


\newcommand{\dx}{\dot{x}}
\newcommand{\dy}{\dot{y}}
\newcommand{\dz}{\dot{z}}
\newcommand{\df}{\dot{f}}
\newcommand{\dg}{\dot{g}}

\newcommand{\dQ}{\dot{\bbQ}}
\newcommand{\dW}{\dot{\bbW}}

\newcommand{\dE}{\dot{E}}
\newcommand{\dEE}{\dot{\EE}}

\newcommand{\Id}[1]{I(#1)}

\newcommand{\QQ}{{\mathcal Q}}

\newcommand{\tQ}{\tilde{Q}}
\newcommand{\tW}{\tilde{W}}
\newcommand{\WW}{{\mathcal W}}

\newcommand{\lee}{\preceq}
\newcommand{\sqle}{\sqsubseteq}
\newcommand{\?}{\mbox{?}}



\newcommand{\false}{\mbox{\bf false}}
\newcommand{\true}{\mbox{\bf true}}


\def\doi{3 (3:7) 2007}
\lmcsheading {\doi}
{1--50}
{}
{}
{Feb.~17, 2006}
{Sep.~\phantom{0}6, 2007}
{}   





\begin{document}

\title[Fully Abstract Models for \PCF\ and ]{Inductive Definition and 
Domain Theoretic Properties \\
of 
Fully Abstract Models for \PCF\ and }

\author[V.~Sazonov]{Vladimir Sazonov}	\address{Department of Computer Science, 
the University of Liverpool, 
Liverpool, L69 3BX, U.K.
}	\email{vyszuk@yahoo.co.uk, \url{v.sazonov@csc.liv.ac.uk}}  




\keywords{LCF, PCF, full abstraction, sequentiality, 
computational strategies, game semantics, non-dcpo domain theory}
\subjclass{F.3.2}



\begin{abstract}
A construction of fully abstract typed models 
for PCF and PCF+ 
(i.e., PCF + ``parallel conditional function''), respectively, is presented. 
It is based on general notions of 
sequential computational strategies and wittingly 
consistent 
non-deterministic strategies
introduced by the author 
in the seventies. 
Although these notions of strategies are old, the definition of the 
fully abstract models is new, in that it 
is given level-by-level in the finite type hierarchy. 
To prove full abstraction and non-dcpo 
domain theoretic properties of these models, 
a theory of computational strategies is developed. 
This is also an alternative and, in a sense, an analogue 
to the later game strategy semantics approaches of 
Abramsky, Jagadeesan, and Malacaria; 
Hyland and Ong; and  Nickau. 
In both cases of PCF and PCF+ 
there are definable universal (surjective) 
functionals from numerical functions to any given type, 
respectively, 
which also makes each of these models unique up to isomorphism. 
Although such models are non-omega-complete and therefore 
not continuous in the traditional terminology, 
they are also proved to be 
sequentially complete 
(a weakened form of omega-completeness), 
``naturally'' continuous 
(with respect to existing directed ``pointwise'', or ``natural'' lubs) 
and also 
``naturally'' omega-algebraic and 
``naturally'' bounded complete---appropriate generalisation 
of the ordinary notions 
of domain theory to the case of non-dcpos. 

\end{abstract}
\maketitle

\section{Introduction}\label{sec-intro}


\noindent
\LCF, a \emph{Logic for Computable Functions}, 
was introduced in 1969 by Scott 
in a seminal paper \cite{Scott93} (published only in 1993). 
Its term language \PCF---a typed version of the lambda calculus 
over integers and booleans with the 
least fixed point operator \fla{\Y}---was further considered in the middle 
of the seventies by Plotkin \cite{Plotkin77}, 
Milner \cite{Milner77}, and the author 
\cite{Saz76d,Saz76AL,Saz76SMZH,Saz76t}. 
In particular, the expressive power of \fla{\PCF} in the framework 
of a standard continuous model  
for \PCF\ was described 
in terms of 
\emph{(sequential) computational strategies} 
as the Theorem:  
``\emph{definable in \fla{\PCF}} = 
\emph{sequentially computable}'' \cite{Saz76AL}. 
Also, a 
\emph{precise correspondence between operational 
and denotational semantics}  
in various formulations (and even an untyped version) 
was 
obtained in \cite{Saz76SMZH} (and independently, 
in somewhat different terms, by Hyland~1976, 
Plotkin~1977 and Wadsworth~1976). 
The full abstraction property of the standard continuous model for 
 (or parallel \IF)''
(by definability of all finite continuous functionals) 
was stated, as well as the fact that 
\fla{\PCF^{++}=\textrm{``}\PCF+\mbox{ parallel OR}+\exists}'' 
defines  
all computable 
continuous functionals (Plotkin \cite{Plotkin77} and, 
without publishing proofs, 
the author \cite{Saz76d,Saz76AL}).
Degrees of parallelism for continuous 
finite type functionals with various examples 
were introduced in \cite{Saz76d} 
(see also \eg\ \cite{Bucciarelli97Degrees,MTrakhte76TCS}). 

A first, essentially syntactic, construction of 
a continuous \emph{fully abstract model} for \PCF\ 
was given in 1977 by Milner 
\cite{Milner77}. The characteristic property of fully abstract models 
is as follows: 
which says (for `' in place of `') that, if two program fragments 
behave equivalently in all computational contexts, then they 
should have the same denotational semantics. The main reason for focusing 
particular attention on this definition and on Milner's model 
is that for the standard continuous 
model   and \PCF\ this natural property 
of the denotational 
semantics does \emph{not} hold. As mentioned above, \PCF\ defines 
(exactly) all sequentially computable functionals, whereas the 
standard model contains some `extra' elements, such as 
`parallel' disjunction OR  and 
`parallel' existential quantification 
. This is essentially the reason 
for the violation of full abstraction. 
But although Milner's fully abstract model 
satisfies desirable properties of continuity, 
it is not a satisfactory domain theoretic characterization of sequentiality 
due to the existence in it of non-sequential 
limit functionals (Normann \cite{Normann2004}). 






Also, having a syntactic nature, 
the definition of this model was considered as 
not very satisfactory 
in comparison with the standard model of \emph{all} continuous functionals. 
Non-syntactic
\emph{game semantic} approaches 
to defining fully abstract models 
were developed by  
Abramsky, Jagadeesan, Malacaria~\cite{Abramsky-Jagadeesan2000}; 
Hyland, Ong~\cite{Hyland-Ong2000} and Nickau~\cite{Nickau96}.  
Various approaches to sequentiality and full abstraction were considered also 
by 
Kahn and Plotkin~\cite{KP93},  
Berry and Curien~\cite{BC82}, 
Bucciarelli and 
Ehrhard~\cite{BE91,BE93}; Curien~\cite{Cur92}; 
Jung and Stoughton~\cite{Jung-Stoughton93}; 
O'Hearn and Riecke~\cite{OR95}; 
Marz, Rohr and Streicher~\cite{Marz-Thesis,Marz-Rohr-Streicher}; 
Sieber~\cite{Sieber92}, 
Cartwright and Felleisen~\cite{Cartw-Fell92}
and others. Unlike this paper some of them consider more general sequentiality concepts 
going outside \PCF\ and even outside the class 
of monotonic functionals 
such as sequentially realizable functionals (equivalent to some other 
approaches implicitly mentioned above); a unifying approach is presented by 
Longley~\cite{Longley-seq-realizable}.



Hyland and Ong~\cite{Hyland-Ong2000} 
identified a very close analogy between the old approach 
to sequentiality of functionals via computational strategies in \cite{Saz76AL} 
and their game theoretic framework. 
One of the goals of this paper is to demonstrate 
\emph{how computational 
sequential strategies could define a fully abstract model  
for \fla{\PCF} inductively, level-by-level in the finite type hierarchy 
in a direct computational way} corresponding to 
the original definition and characterization of higher type sequentiality 
in \cite{Saz76SMZH,Saz76AL}. (The latter was applied only to the standard, 
non-fully-abstract continuous 
model  containing not only sequential functionals.) 
It is important to stress the straightforward, inductive 
character of the definition of  which may be compared, 
at least partly, with the inductive definition of the continuous model 
. 
Assuming, by induction, that we have 
the class of sequential functionals 
of types up to level , we define what are sequential functionals 
of the level  as those computable by sequential strategies. 
In this respect our approach differs from the game-semantic one 
based on a quotient construction for all types simultaneously. 
However, 
proving the essential properties of the inductively defined model  
of hereditarily sequential functionals is not so direct and 
requires the quite involved theory of computational strategies 
and a quotient construction  giving an alternative, non-inductive 
definition of the same model. Reference in the inductive step of the definition 
of  to all 
sequential functionals of the previous levels also reflects the complicated 
character of this inductive definition. A finitary version referring only to 
the immediate subtypes of the given type should not be possible due to 
the undecidability result 
of Loader \cite{LoaderTCS2001}. 





However, the definition of  is sufficiently straightforward, although involving 
some technical complications to make it mathematically correct and, additionally, 
to crucially simplify the correctness proof of the induction step. 

As in \cite{Abramsky-Jagadeesan2000}, ``we want to capture just those 
sequential computations in which the different parts 
or modules interact with each other in purely functional 
fashion'' and, as in \cite{Hyland-Ong2000}, ``without 
recourse to the syntax or operational semantics 
of the language'' (\PCF). More precisely, 
we will use computability by sequential strategies to define (hereditarily) 
sequential functionals. 
Although  
\PCF\ is a partial case of the general concept of a system 
of strategies, our definitions will not be reduced simply to doing things in \PCF. 
We will work in the quite general 
terms of abstract computability in higher types 
in a ``functional fashion'', by using ``interpreted computations'' 
(involving applicative terms) in the style of \emph{denotational semantics},
to define a fully abstract 
model for \PCF. 
Also note that the very term ``sequential'' primarily assumes 
``sequentially computable''. That is why involving some kind of 
computability approach 
at the level of denotational semantics is quite natural. In fact, we 
will also provide an alternative, generalized \emph{operational semantics} 
of strategies---not only for ground types---and 
demonstrate that it is coherent with the denotational one (the approach 
originally presented in \cite{Saz76SMZH} 
but not in the ``fully abstract framework'' 
as in the present paper.)
This distinction together with the interplay 
between operational () and denotational () semantics 
( for arbitrary finite type combinations of strategies) 
is one of the crucial points 
of this paper. 


On the other hand, we read in 
\cite{Hyland-Ong2000} that: 
``we do not have a proper definition of higher-type 
sequentiality from first principles''. 
There could probably be various philosophical 
views concerning 
what are these ``first principles''. 
However, for the simpler case of non-higher-type sequentiality, 
we see that its definition (say, for the conditional 
function {\bf if-then-else}), 
reduces to the existence of a sequential strategy of 
computation of a function by asking of an Oracle the 
values of the arguments---here of a basic type. 
For higher types, 
we just extend this idea by allowing more general queries 
to the Oracle---applicative 
combinations 
(of a basic type) of the arguments and strategies. 
This approach recalls and generalizes that 
of Kleene \cite{Kleene60,Kleene62} for Turing computability of finite 
type functionals and is essentially an extensional one, 
despite its somewhat intensional-computational features, 
and can be also considered as a natural generalisation both of combinators 
and the conditional operation {\bf if-then-else} having an evidently 
functional/extensional character. 
Moreover, this allows us to characterise, in abstract computational terms, 
the expressive power of \PCF\ both in the standard model  
of all continuous finite type functionals \cite{Saz76AL} and 
in the fully abstract model  considered in this paper where 
all functionals prove to be definable in \PCF\ + ``all (one place 
numeric) functions of the type ''. 
By the way, the ordinary 
concept of continuous functions over dcpo domains, 
usually considered as non-intensional, 
is nothing more than a very abstract version of the idea of 
computability:  for  with  of a basic type 
means that the value of  can be ``computed'' by extracting ``finite'' information 
 from the argument ; we abstract all other details of a computation process. 
That is, it has some hidden 
intensional features. We should have just a natural balance, or interplay, 
between ``intensional'' and ``extensional''. 
For computational strategies the former aspect corresponds to the operational 
semantics of strategies, and the latter is represented by the concept of 
interpreted computations leading to denotational semantics of strategies and 
to the extensional inductive definition of the fully abstract model of 
sequentially computable functionals. 

Let us stress again, as this is an important point: 
denotational semantics of strategies, and thus 
the corresponding inductive definition of the fully abstract model, is based on 
\emph{interpreted computations} in terms of ``real'' (applications of) 
finite type functionals. Therefore it has, despite computations involved, 
rather an extensional character, whereas the operational semantics of 
(combinations of) strategies is based on purely ``syntactical'', 
\emph{non-interpreted computations} 
in terms of strategies only (like in terms of the language \PCF\ only) 
and without invoking ``real'' finite type 
functionals.

The main drawback of our approach, in comparison with 
game-theoretical ones, 
is the lack of a construction 
for a general category (not referring to finite types) 
like that of games with arrows representing suitable game strategies. However, 
this more concrete view allows 
us to construct, inductively, 
a monotonic order extensional fully abstract model for \PCF,  
in a straightforward and natural way. 
Unfortunately, this inductive definition contrasts with the 
proof of the main domain-theoretic properties of  
which involves a significant amount of machinery 
of computational strategies, 
including an isomorphic quotient construction 
 
(reflected by the tilde symbol). 
In comparison, the game theoretic approach is based on a quotient 
construction in the very definition of the fully abstract model. 
In this respect, it looks 
more intensional. 


It turns out that this model consists only of continuous 
functionals with respect to existing ``pointwise'', or 
``natural'' lubs. We need to consider this generalized and novel version 
of continuity, called \emph{natural continuity}, because the poset of 
sequential functionals of a given type (starting with the level 3) is not 
-complete, 
as was recently shown by Normann \cite{Normann2004}, 
and therefore this model is not isomorphic 
to the `limit-term' model in \cite{Milner77}. 
Note that the model  
satisfies the corresponding uniqueness 
property 
(the property formally different from, but similar to, that of 
the continuous fully abstract model of Milner) 
and is therefore isomorphic to the game models 
defined in~\cite{Abramsky-Jagadeesan2000,Hyland-Ong2000}. 
This leads to a generalized concept of \emph{natural non-dcpo domains} 
most appropriate for describing the properties of the models 
of finite type functionals considered in this paper 
which will be shown to be  
sequentially complete 
(a weakened form of -completeness), 
naturally continuous 
and also 
naturally -algebraic and 
naturally bounded complete. This domain theoretic framework 
plays a crucial role in this paper and can serve as a kind of substitute for 
the categories of games mentioned above. 





The more general concept of \emph{wittingly consistent} 
non-deterministic computational 
stra\-tegies defined in 
\cite{Saz76t} (Part II, \S 4) is also successfully used in the current 
paper to 
construct the fully abstract model  
for  satisfying  
definability properties such as  
the fully abstract model  
for \PCF\ discussed above. 
This gives a positive answer to the question 
stated in \cite{Longley-Plotkin} 
(before Proposition~6): 
\begin{quote}
\emph{``It is worth remarking that 
there is no corresponding definability result for . 
It may well be that there can be none; it is not at all clear, however, 
how to even formulate a precise statement to that effect''.}
\end{quote}
Although this question was seemingly related to the possibility 
of extending the game semantics results for \PCF\ to , 
our approach via computational 
strategies is a natural and quite general alternative 
with some analogy to the game approach and might probably 
lead also to a corresponding extended game semantics solution. 
Note also that the fully abstract model  
for  is also 
\emph{not} -complete (even at the level 2)---this is clear from the known 
result that  is not definable in . 
But it is wittingly--complete 
and satisfies all the above mentioned generalized, ``natural'' 
versions of (non-dcpo) domain theoretic properties. 


\paragraph*{\bf Organization.} 
We start with the generalized, ``natural'' version of non-dcpo 
(finite type) domain theory 
in Section~\ref{sec:prelim}. 
We define computational sequential strategies 
in Section~\ref{sec-seq-stra} and their denotational semantics 
on the base of interpreted computations in Section~\ref{sec-seq-stra-den-sem}. 
Then hereditarily 
sequential functionals are defined inductively (level-by-level) 
in Section~\ref{sec-seq-func}.  
Sections~\ref{sec-quotient} and \ref{sec:full-abs} are devoted to 
demonstrating 
the full abstraction property of the resulting model  for \PCF. 
The definability of a universal functional 

for each type  is also stated, but not proved (see the details in \cite{Saz76AL}).
Finitary ranked and other finite versions of 
strategies are introduced computing exactly all 
``naturally'' finite sequential functionals to demonstrate the ``natural'' continuity 
of  (implying other ``natural'' domain theoretic 
properties of ) 
which is actually used in the proof of the full abstraction property of this model. 
The class of finitary strategies is also shown to be effectively closed under 
application (on the base of a kind of normalizability property).
Section~\ref{sec:full-abstr-PCF+} is devoted 
to a sketchy definition (by a very close analogy to the case of  and \PCF) 
of a fully abstract model  for  based on the concept of 
wittingly consistent non-deterministic strategies. 
Unlike the case of \PCF, some details are given 
(but still with a reference to the old approach for \PCF\ \cite{Saz76AL}) 
of a construction in  of a universal (surjective) 
functional  
for each type . 
It is also demonstrated in 
Section~\ref{seq:non-complete} 
that the model  is not -complete at level~2. 
Section~\ref{sec:conclusion} contains some concluding remarks 
and directions for further research. 
Finally, Appendix~\ref{appendix:univ-sys-strategies} 
presents an explicit construction of the typed version of a universal system 
of sequential strategies  from \cite{Saz76t} which is used 
in previous sections for constructing~. 
































\section{Domains and Types---a Generalisation}
\label{sec:prelim}

\subsection{Basic Definitions}\label{sec:basic-def}


\noindent
Let us recall and generalize several well-known notions from domain theory 
(see, for example, \cite{Abramsky-Jung1994,Plo81}), 
emphasizing some more subtle points related with 
their usage in this paper.  
Importantly,  
some of the known terms here have a meaning different from the traditional one. 
The goal is to find a version of domain theory most appropriate for the case 
of sequential (and other kinds of) functionals. 



The term {\em poset} means a set  partially ordered 
by an {\em approximation} relation . 
Any poset  with the least ({\em bottom}, or {\em undefined}) 
element  will be called a \emph{domain}. 
If  is any set, then  is the
corresponding {\em flat} domain where . 
A nonempty set  is called \emph{directed} 
if, for any , we have  and  
for some . 
The least upper bound (lub) of a set  is denoted by . 
If all directed sets have a lub in  
then it is called a {\em directed complete} 
poset, or briefly, \emph{dcpo}. 
However, the domains we will consider are typically not assumed to be dcpos. 
An element  of a domain (not necessarily a dcpo) is called 
\emph{finite} (or \emph{compact}) 
if  implies  for any
directed set  for which  exists. 
All elements of a flat domain are evidently finite. 
A 
domain  in which 
there are only countably many finite elements 
and each element  is a directed lub of all its finite approximations 
is called 
-\emph{algebraic}. 
A monotonic mapping  between domains is called 
\emph{continuous} 
if it preserves 
existing lubs  of directed sets: 
 
(that is, if  exists then  
is required to exist and satisfy this equality). 
Let  or  
denote the set of all monotonic mappings ordered pointwise: 

For dcpos, let  denote the set of continuous mappings also 
ordered pointwise. 
(We can suitably extend this denotation also for some special kinds 
of non-dcpo domains, called natural domains, by taking  to be 
the set of all naturally continuous mappings; see Section~\ref{sec:natural}.) 
If any two upper bounded elements  have least upper bound  
in  then  is called \emph{bounded complete}. 
A domain is called \emph{finitely bounded complete} if, in the above, 
only finite , and therefore , are considered. 
If  is an algebraic dcpo then 
it is bounded complete if, and only if, it is finitely bounded complete. 
In fact, for dcpos bounded completeness is equivalent to existence of a lub for 
any bounded set, not necessarily finite. 
Algebraic and bounded complete dcpos are also known as \emph{Scott domains} 
or as \emph{complete f-spaces} of Ershov~\cite{Ershov72}. 

The above definitions are well-known and quite natural in the context of dcpos. 
We extended them to non-dcpos rather 
as a formal intermediate step 
before introducing in Section~\ref{sec:natural} so called ``natural'' versions 
of these notions. The general idea is that nonexistence of lubs of some 
directed sets is an indication that even existing lubs might be non-natural 
(existing ``by a wrong reason''), and 
therefore the definitions of continuity, finite elements, etc.\ should 
be relativized to ``natural'' lubs only. 


{\em Types} (or functional types) are defined as formal expressions
built inductively from some {\em basic\/} types, in our case 
and  
(with the generic name \mbox{Basic-type}), 
by the arrow construct: if  and  are types
then  is a type. We usually write
 or 
 instead of
.
The \emph{level} of any type

is defined as

and, in particular, 

The \emph{arity} (or the number of arguments) 
of  is the number  above. 

For any type  we define inductively, as usual, 
the corresponding (\emph{standard}) domain  of
all {continuous} functionals of type  
with , , 
and ,
where  and 
. 
All these  are -algebraic, bounded complete dcpos. 
More general, 
\begin{defi}A \emph{(typed monotonic order extensional 
applicative) structure}  is a system of domains 
(with the least element  in each) such that 
for any types  and  there is a monotonic 
mapping 
 (with 
 abbreviated as  and 
 abbreviated as ) 
satisfying 
\begin{itemize}
\item[(i)]  for all 
, and 
\item[(ii)]the extensionality condition: for all  and 
,

\end{itemize}
Elements of  
are called \emph{functionals} of type .
An extensional structure  is called a -\emph{model} 
if it is sufficiently rich to contain all 
-definable functionals. 
\end{defi}
For the closure under -definability we can equivalently require that 
 contains combinators 
 and 

for all types  satisfying identities 
 and  for all  
with  of appropriate types, omitted for brevity. 
We will also always assume that 
 and . 
To simplify the exposition, let us take that 
 
with ,  and  
and, hence, avoid using the Boolean type  at all in the ``official'' exposition. 
(However, we will use  in some examples for the convenience.)
Then  will mean just~. 
Although in general the sets  and 
may even not intersect, 
there is the natural embedding  
induced by the application operation. 
Moreover, without restricting generality we may also consider that the set

consists of some monotonic mappings of the type shown, ordered pointwise, 

and for all  and  

is the ``residual'' map. 
Indeed, any  satisfying (\ref{eq:EE}) 
and (\ref{eq:App}) and containing constant undefined functions 
 
is a monotonic, order extensional applicative structure.  
It is clear that such an  is a restricted 
class of monotonic finite-type functionals. 
\begin{defi}\label{def:continuous-structure}A structure  (with  not necessarily a dcpo) 
is called \emph{continuous} 
if for each type  
and variables  and , the \emph{full application map} 

is \emph{{continuous}}. 
Equivalently, we can require the continuity 
of the application maps of two arguments 
. 
\end{defi}
\label{page:continuity}

\subsection{Natural Non-dcpo Domains}\label{sec:natural}

\noindent
More generally, 
\begin{defi}In any monotonic, order extensional applicative structure 
a \emph{pointwise lub} 
 of an arbitrary 
(not necessarily directed) family of functionals (of the same type) is the ordinary 
lub , in the case of the basic type, and, for higher types, it is  
the ordinary lub
which is also required to satisfy, inductively, the pointwise identity 
 
(with  also pointwise)
for all  of appropriate type.
\end{defi}

\noindent
Thus,  implies , but, in general, 
not vice versa. 
That is,  is a restricted version of~. 
(See an example below.) 
Equivalently, we may require from  the identity 
 
in the basic type.\label{page:pointwise-lub}
In fact, 

assuming  is of the basic type. 
The concept of pointwise lub is quite natural and could also be called 
just \emph{union}, or \emph{natural lub}. 
This is even the ordinary set theoretic union 
if to identify monotonic functionals of the type 
 
with corresponding graph subsets of 
. 
In this case  also coincides with the set theoretic notion of inclusion 
. 
Respectively, non-pointwise lubs are considered as non-natural in this sense. 
(However note that neither finite nor also ``naturally'' finite functionals 
considered below are necessarily represented as finite graph sets in the above sense.) 


\begin{exa}\label{ex:O_i}To illustrate the above definition, 
consider a simple example in  (the monotonic, 
order extensional -model of sequential functionals 
to be defined later) of a finite non-natural lub of two 
elements. 
Define two first order sequential functions 
, , 
as  if the corresponding , and  otherwise. 
Then  
 is the constant zero function 
in , and this is not a natural  lub. 
The natural  lub, if it would exist in , should satisfy 
 if  or , 
and  otherwise. But this is not a sequential function, 
that is, it lies outside of . 
\end{exa}



\begin{defi}A structure  is called \emph{naturally  {continuous}} 
if for all types  and  the map
 
preserves directed natural lubs of the arguments whenever they exist:
\label{page:pointwise-continuity}
.
That is, if the directed natural lub to the left exists then 
the natural lub to the right exists too, and the equality holds. 
\end{defi}

\noindent
We can require, equivalently, for each type 
 and 
,  
that the map 

is naturally  {continuous} (preserves natural  lubs) in each argument. 
Evidently, natural  continuity of  or  in  
is automatically satisfied by the definition of natural lub as the pointwise one. 
Also, \emph{in a continuous structure} 
(that is, with continuous full application maps)
\emph{all existing directed lubs are natural (pointwise), and therefore 
any continuous structure is naturally continuous}. 
Further, 
\begin{defi}\emph{Naturally finite} functionals 
are defined like the ordinary finite ones, but by using the natural  lubs. 
\end{defi}

\noindent
Each finite functional is also naturally finite 
(but probably not vice versa; see the discussion below). 
\begin{defi}\label{def:alg-bound-compl-struct}\hfill  \begin{enumerate}[(a)]
\item A structure  
is called \emph{naturally -algebraic} if each of its elements 
is a directed natural lub of naturally finite elements, 
and there are only countably many naturally finite elements 
in the structure. 

\item It is called \emph{naturally bounded complete} if any two 
upper bounded 
naturally finite elements 
have a lub (not necessarily a natural lub, but evidently also naturally 
finite element). 
\end{enumerate}
\end{defi}

\noindent
For any naturally algebraic and naturally bounded complete structure  
the sets of the form , 
for  naturally finite, constitute a base of a \mbox{(\To-)}~topology in each  
which makes  satisfying this definition 
a (non-necessarily complete) \fo-space of Ershov \cite{Ershov72}. 
Note that open sets in this topology are exactly those \emph{naturally Scott open} 
(defined as usual, but with respect to the natural directed lubs). 


By using  
Lemma~\ref{lemma:algebraicity} presented below, 
we will prove in Theorem~\ref{th:continuity} 
the natural  continuity and the last two properties (a) and (b) defined above 
for the special case of the model of sequential 
functionals . 
That  
is not a dcpo was actually shown by Normann \cite{Normann2004}.
\begin{hyps}
It seems quite plausible
that in  
there exist
\begin{enumerate}[\em(1)]
\item
a directed non-natural  lub, 
\item 
a naturally finite, but not a finite functional 
(being a proper directed lub), 
\item
a non-continuous (but naturally continuous) functional, and 
\item 
a naturally finite (and naturally continuous), but not a continuous functional.
\end{enumerate}
We could also expect that 
\begin{enumerate}[\em(1)]
\setcounter{enumi}{4}
\item
a continuous (and therefore naturally continuous) lambda model exists 
whose higher type domains are not dcpos. 
\end{enumerate}
\end{hyps}

\begin{note}\hfill
\begin{enumerate}[(a)]
\item We see that these hypotheses reveal a terminological problem 
(``naturally finite, but not finite'', etc.). Properly speaking, 
these are naturally finite functionals which are most naturally 
considered as full-fledged finite objects in the framework of~. 
Moreover, together with naturally continuous functionals, these concepts 
give rise to an appropriate non-dcpo generalisation 
of continuous, -algebraic and bounded complete -models 
(originally considered over dcpos). 
This will be seen from the following considerations and 
Lemma~\ref{lemma:algebraicity}. 
The more traditional definitions of continuous and finite functionals in terms 
of the ordinary directed lubs prove to be not very adequate 
in the framework of non-dcpos. 

\item Another important point is that, being based on types, the natural lub 
\fla{\pointwiselub} as well as other related ``natural'' 
concepts are not purely order-theoretic ones. 
However, 
one can give an abstract definition of \emph{natural (non-dcpo) domains} 
with a primitive partially defined operator 
 in each domain which is 
a restricted version of  and has appropriate postulated properties. 
Then the special case of these natural domains satisfying 
the conditions (a) and (b) of Definition~\ref{def:alg-bound-compl-struct} 
corresponds exactly to the \fo-spaces of Ershov \cite{Ershov72}. 
More detailed and general discussion on this generalized theory 
of non-dcpo domains and the mentioned correspondence requires 
a separate consideration to be presented elsewhere. 
It is also worth noticing that these domains appear in our presentation as 
natural non-dcpo domains rather than \fo-spaces. They prove to be 
\fo-spaces only a posteriori by using quite involved technical theory 
of computational strategies and applying Lemma~\ref{lemma:algebraicity} below.
\end{enumerate}
\end{note}

\subsection{Finitely Restricted Functionals} \ \ 


\paragraph*{\bf Conditions on } 
For the rest of Section~\ref{sec:prelim} 
let  be any monotonic, order extensional 
-model which contains the first order 
equality predicate  
(monotonic and strict in  and~) 
and the ordinary (monotonic and sequential) 
conditional function  
for the basic type (and hence for all types by -definablity). 

\bigskip

Recall that a monotonic function  
is called a \emph{projection} 
if  for all , and  . 
We say also that  is a projection from  \emph{onto} its range  
which is also the set of all fixed points of . 
For any two projections,  iff 
range  range. 
Note that 
 is the largest -approximation to  
from the range of . 




\bigskip

\noindent
Now, we will follow Milner \cite{Milner77}, 
slightly simplifying and generalizing to the ``natural'' non-dcpo case. 

\begin{defi}\label{def:proj-finitely-restricted}Define projections 
 for all types and any  
by letting

Denote . 
Elements  in 
 
are called \emph{finitely restricted}. 
\end{defi}
\noindent
These all are monotonic sequences on . 
That  and hence all other  are 
(representable by) elements of the -model 
(we write )
follows from existence in it of both  and . 
By induction on types, each  is a finite set 
since  at all types. 
Also, the application of -restricted functionals to any argument is -restricted. 
In particular, each finitely restricted functional  
 
has a tabular representation

In each model  (over ) 
satisfying the above conditions 
there are only countably many finitely restricted elements. 
This is another approach to the finiteness 
of higher type functionals.
Without assuming any further conditions on , 
each  considered as a map 
\mbox{} 
\emph{is naturally continuous and, moreover, 
preserves all existing natural  lubs} (not necessarily directed). 
This follows by induction on the types: 

It also follows that \emph{each finitely restricted element 
 is naturally finite}: 
 for a directed set  
implies  
for some  by natural  continuity of  
and because  is finite. 

Moreover, \emph{if the model is naturally continuous then
 holds for all }. 
Indeed, assuming by induction on types that , 
we have
. 
Thus  by (\ref{eq:pointwise-lub}), as required. 

Finally we note that, without any further assumptions on the model, 
\emph{any two upper bounded finitely restricted elements  
have a (not necessarily natural) lub  which is also finitely restricted}. 
Indeed, it can be obtained as the greatest lower bound 
 
for any fixed  such that  
because the glb of any finite nonempty set is definable from  and . 


The following Lemma is a generalisation of the Algebraicity Lemma of Milner 
in \cite{Milner77} to the case of non-dcpos and to the ``natural'' case, 
but formulated for simplicity only for the models with the numerical basic values 
. 
It clearly demonstrates that the generalisations introduced are 
quite adequate and natural. 


\begin{lem}\label{lemma:algebraicity} 
Let  be any monotonic, order extensional 
-model, with , 
which contains first order equality and the conditional. Then
\begin{enumerate}[\em(a)]
\item this model is naturally continuous 
if, and only if, 
   \begin{itemize}
   \item[(*)] for any type 
 
and elements 
 and , 
 holds 
for some finitely restricted 
; 
   \end{itemize}

\item if the model is naturally continuous 
then 
(i) the naturally finite elements of each  
are exactly the finitely restricted ones, 
(ii)  
is naturally -algebraic, and 
(iii) it is 
naturally bounded complete;  

\item repeats {\em(b)}, but with ``naturally'' omitted. 
\end{enumerate}
\end{lem}
\proof\hfill
\begin{enumerate}[(a)]
\setcounter{enumi}{1}
\item \label{page:algebraicity}
follows easily from the above considerations on projections~. 

\item It suffices to recall that continuous structures 
are also naturally continuous, and 
the concepts of directed lubs, and hence of finite functionals 
in these models, are equivalent to their 
``natural'' versions. 
Note that we do not assume here that the  are dcpos. 

\setcounter{enumi}{0}
\item ``If'' follows from natural  finiteness of all . 
``Only if'' follows from~(b).\qed
\end{enumerate}



\noindent
The clause (a) of this Lemma (not considered in \cite{Milner77}) 
is used in Section~\ref{sec:ranked-finitary} below to show that 
the model of sequential functionals  
is naturally continuous and satisfies the conditions (i)--(iii) from (b). 
In the application of this Lemma to  the crucial point 
is that (*) in (a) implies all the essential domain theoretic properties 
holding for this model. 



Moreover, we will also show in Theorem~\ref{th:least-correct-sem} (b) 
that the model  
is also \emph{sequentially complete} in the sense that it is closed 
under taking natural (pointwise) lubs of a special class of increasing 
sequences (determined by sequential strategies). 
For example, in  we have the natural lub 
 giving the least fixed point of  
for all types . 

\subsection{On Efficiency of Naturally Finite Functionals}
\label{sec:efficiency}


For the case of the standard continuous model ,
the tabular representation (\ref{eq:fin-main}) of naturally finite 
(finitely restricted) functionals proves to be quite effective and 
gives rise to an effective numbering 
of these functionals \cite{Ershov72}. The main reason for that is that 
(by induction on types)
any monotonic table as in (\ref{eq:fin-main}) represents a finitely restricted 
functional in this model. This also holds 
for  (the non-dcpo fully abstract model for ) 
where naturally finite functionals are the same as in . 
The latter essentially follows from 
their definability in ~\cite{Plotkin77}. In fact, the predicates 
``'', `` are upper bounded (consistent)'' 
and the application operation ``'', for naturally finite , 
are effectively computable in the cases of  and . 


Unfortunately, in the model of hereditarily-sequential functionals 
 no such effective numbering is possible as can be shown 
by appropriate adaptation of the undecidability result of Loader \cite{LoaderTCS2001}. 
In fact, we cannot generally, and effectively, decide which monotonic 
tables (\ref{eq:fin-main}) represent sequential functionals in , 
let even for finitely many of -restricted ones. 
But we can enumerate them 
by means of the \emph{finitary strategies} introduced in Section~\ref{sec:ranked-finitary} 
instead of using non-effective (in this case) tabular representation. 
In this sense the set of -restricted 
functionals of a fixed type  is finite and recursively enumerable but, 
in general, ``undecidable''. 
However, it will be demonstrated in Theorem~\ref{th:applications-of-finitary} that, 
under the above mentioned ``finitary'' representation of naturally finite functionals 
, 
the application ``'' is computable, and it easily follows that 
``'', 
unlike ``'', is semidecidable 
in  
(and similarly for  in addition to the above tabular 
effective in this case and decidable representation). 


This seemingly diminishes the role of naturally finite 
(= finitely restricted) functionals and their use 
(like in )
to define effective functionals as those 
which are (natural) lubs of a  recursively enumerable directed set of 
(naturally) finite approximations. 
Such a definition seems not very appropriate, 
not only for , but even for the case of . 
At least, further research is required.
For efficiency of functionals we should, in these cases, rather use the concept 
of an effective (sequential and, respectively, wittingly consistent) computational strategy 
\eg\ as in Definition~\ref{def:seq-func}. 

Finally, let us mention one more related question on  and : 
for naturally finite  and any  the application  is 
evidently naturally finite, but 
\emph{is its finitary representation computable from that of  and a strategy 
representing  in general?} (However, for  it is computable.)


\subsection{Ideal Completion and Uniqueness of Fully Abstract Models}
\label{sec:completion}


\noindent
Although our goal is the fully abstract non-dcpo (in fact, naturally continuous) 
models for \PCF\ and , it make sense 
to relate them with the continuous dcpo model construction of Milner \cite{Milner77} 
via the ideal completion procedure. 

\medskip

Now, let  be any naturally continuous -model 
satisfying the assumption and the conclusions (i)--(iii) 
of Lemma~\ref{lemma:algebraicity}. 
Consider its \emph{ideal completion}  which is 
a continuous dcpo model defined as follows. 
A~nonempty directed set  
of naturally finite elements is called an \emph{ideal} if 
 
for  naturally finite. 
Let , 
be the set of all ideals in . 
This is evidently a dcpo ordered by set inclusion  with 
 the least ideal and with directed 
lubs coinciding with set unions . 
Let 
 be the 
ideal generated by a directed set , and . 
As , 
we have an order isomorphic embedding of posets  which is 
onto for the basic type. Note that always 
. 
If  is naturally finite in  then  is finite
element in the dcpo~. 
For any ,
. In fact,  is a directed union of such , 
and  is an -algebraic dcpo domain with finite elements 
 for  naturally finite. It is also bounded complete because 
 is naturally bounded complete. 
Further, we may define the application operation in  by 
 
for any  and  of appropriate types, 
which makes it a monotonic order extensional structure. 
For the latter use the fact that 

It is easy to show that  is continuous, that is having the continuous 
application operation  
( holds 
for directed families). 
The application also agrees with the embedding : 

Moreover,  is a -model because for the combinators 
 we have 
 
in~ (where all directed lubs are natural/pointwise and 
``naturally finite'' = ``finite''). 
Assuming additionally the existence of 
a fixed point combinator in  satisfying the \emph{-property}

for all  of appropriate type, its 
image in  behaves accordingly: 



The languages  and  \cite{Plotkin77,Longley-Plotkin} 
considered in this paper are based on , 
plus constants for some level one functions 
(successor, predecessor, first order equality and one of two versions 
of the conditional---sequential and parallel, respectively).
For any  satisfying the -property the meaning of all these constants 
is also not changed by the embedding . 
Hence, 
\begin{prop}\label{prop:meanings}
The meaning of\/  terms in  
agrees with that in~.
\qed 
\end{prop}
\begin{defi}\label{def:full-abstract}Let  denote an arbitrary ground type program context in . 
A~model  satisfying the -property (\ref{eq:Y-property}) 
is called \emph{fully abstract} relative to  if  

\end{defi}
\noindent
Evidently,  is fully abstract iff  is such 
(relative to  or, equivalently, relative to  minus ; 
use the Fixed-point Lemma in \cite{Milner77} for the dcpo case of ). 

\begin{prop}
Let  be any fully abstract and 
naturally continuous -model of\/  
satisfying the -property (\ref{eq:Y-property}). 
Then the model  is also fully abstract and 
all finite elements in , and therefore all naturally finite elements in , 
are definable in\/  without using\/ . 
The same holds for  fully abstract relative to 
the language  minus\/  
(although still satisfying -property). 
\end{prop}
\proof  
The definability statement for the case of fully abstract continuous dcpo models 
(here ) was actually shown in the proof of Theorem~3 in  \cite{Milner77}. 
This implies the case of naturally continuous model  by using 
Proposition~\ref{prop:meanings}.\qed


\noindent
It follows as in \cite{Milner77}, by taking  
with  defining finite elements, that on definable elements, 
and therefore on all finite elements such fully abstract , if exists at all, 
is determined uniquely, up to isomorphism. A~general construction of such a 
continuous \emph{dcpo} model from some given level one functions is presented 
in \cite{Milner77}. 

Alternatively and extending to the case of non-dcpos, we will define 
two models  and  
for \PCF\ and , respectively, 
such that it will follow from 
Theorems~\ref{th:least-correct-sem}~(b), 
\ref{th:full-abstr}, \ref{th:universal} and \ref{th:continuity} below 
(on a generalization of the -property, 
full abstraction property, universality and natural continuity of , 
and corresponding versions for~) that 

\begin{thm}\label{th:UNIQUE}\hfill
\begin{enumerate}[\em(a)]
\item  and , 
are the only possible  
fully abstract 
continuous dcpo models for \PCF\ and , respectively 
(with  also isomorphic to Milner's model in \cite{Milner77} 
and  isomorphic to ). 

\item Therefore also  and  are the only possible 
fully abstract naturally continuous\footnote{Note that the natural continuity requirement on  here 
can be omitted and the proof of (b) can be done straightforwardly 
by showing first that (i) the denotational semantics of  terms 
(possibly involving arbitrary type  functions)
of the type  corresponds exactly to the natural operational semantics, 
and (ii) Milner's Context Lemma \cite{Milner77} for the operational 
semantics holds. 
To this end, define a logical relation 
between values  in  and closed  terms  
by letting, for the type , 
 the value to which  
operationally reduces, and show  for closed terms. 
(Thanks to Achim Jung who has drawn attention of the author 
to this proof of (i) and (ii).) 
The point is that only the -property is used 
in the proof, and neither dcpo nor continuity properties 
of models considered are needed. We omit the details. 
Then the full abstraction property can be formulated in terms of operational 
semantics and thus leads to an 
operational characterisation of the relation  
for  terms. 
}
models for \PCF\ and , respectively, satisfying the -property and
in which all elements are definable 
from arbitrary type  functions of the model 
where 
---all monotonic functions.\qed
\end{enumerate}

\end{thm}

\noindent
More general, in the latter uniqueness formulation 
we could consider for  and  
some other classes of type  
monotonic functions, say, all computable---as the minimal such a class. 
In the computable case only definability in pure  may be used, 
without reference to type  functions in (b). 

\vspace{1em}


\section{Sequential Strategies}\label{sec-seq-stra}
\subsection{Definition, Informal Meaning and Examples}
\label{sec-seq-stra-def}

\subsubsection{Preliminary Definitions and Conventions}
\label{sec-seq-stra-def-prelim}

\noindent
Let  be any set of abstract elements 
denoted as , etc., 
each having a specified type (\eg, ). 
That is, actually,  is a disjoint union of sets  
consisting of elements of the type . 
An additional structure on  considered below 
will allow us to call these elements (computational) {\em strategies\/} 
(over~).  


For each type , let us also fix an infinite list of 
\emph{variables} of this type . 
We will use, , , , etc.\ as meta-variables. 
However, 
 or  will usually refer 
to the numbering in the above lists, assuming some typing.  
That is,  is -th variable of a type which can 
be recovered from the context. 
Thus, given any types , 
we have the corresponding \emph{canonical} list 
of variables  
(first variable of the type , second 
variable of the type , etc.) 
or just  or , for brevity.  
Well-typed \emph{applicative terms} over  constitute the least 
set containing  
\emph{atomic terms} (i.e., variables  and constants ), 
and closed under application: 
if~ and  then . 
Let  be the set of all well-typed applicative 
terms of the \mbox{Basic-type} (actually, ) built up from 
(typed) strategies of  and (typed) variables. 
If  then 
 or  will denote 
the applicative term  of the type  
with  (the -th variable of the type ). 
These notational agreements allow us to avoid 
type superscripts and related assumptions 
which, otherwise, would obscure the exposition. 
Strictly speaking, all variables, elements 
of  and terms are typed. 


Additionally, let us agree that, depending on the context, 
we can identify any variable  with some 
value in the corresponding set of values . 
This is in the same line as the tradition of using variables in 
ordinary mathematical texts. Again, this way we avoid 
extra complications in notation, relying on the context. 
Let us also assume that, by default, 
 range over  
whereas  range over .
Say,  denotes the string 
of the length , whereas  is the concatenation 
of any two strings , and  
is the concatenation of any string  with a one element string 
, etc. We will use similar conventions for the case of 
 for any other set . 

\subsubsection{Main Definition}
\label{sec-seq-stra-def-main}
\begin{defi}\label{def:strategies}A {\em system of sequential computational strategies\/}\footnote{We will also consider, in Section~\ref{sec:wittingly-cons}, 
the more general concept of non-deterministic (non-sequential), 
wittingly consistent strategies. 
However, we will typically use the simple term ``strategy'' 
relying on the context. 
} 
is a pair  consisting of 
the set  of typed elements (strategies) 
and a {\em partial\/} 
function

satisfying the following condition:
\begin{quote}
{\bf if}  is a strategy, 
 is the canonical list of variables
of the types , respectively, so that
, 
and  is defined {\bf then} either
\begin{enumerate}[(1)]
\item\label{item:strategies:variables}

 (written also as the query   ``'') 
with all variables in  contained in the list , or
\item
 is a (defined) basic value. 
\end{enumerate}
\end{quote}
\end{defi}

\noindent
We also write  if  is undefined. 


\paragraph*{\bf Informal comments.}
Any applicative term of the form 
 
is considered as the \emph{query} or \emph{task} ``'' of finding its 
(basic) value by means of the strategy  with the help of an \emph{Oracle} as follows:
\begin{enumerate}[]
\item
by asking, in the case~1
above, 
{\em queries\/} of the form ``'' 
(concerning~) 
addressed to the Oracle,
assuming that a finite sequence of answers  
to previous queries 
(called also a \emph{prompt} or \emph{computation history} 
for the strategy ) 
have been
received from the Oracle, and 
\item
by giving,
in the case~2, a {\em resulting value (solution)\/} for the
initial task ``'', based on the previous computation history . 
\end{enumerate}
In particular, it is possible that
 is a Basic-type value in , 
or  is undefined, where
 denotes the \emph{empty string} of the Oracle's replies 
to the previous queries
(i.e., when no queries to the Oracle have been asked yet---the 
empty history) 
and 
corresponds to the beginning state of the computation of strategy .
In the case of  we say that   
defines (or is) a \emph{constant strategy\/} giving rise 
to a final result  without asking the Oracle any questions. 
If  is undefined, then  is called 
an {\em undefined constant strategy\/}. 
In each of these cases we write, respectively,
 or  or even
 or , especially when  is itself a basic type. 
Intuitively, a constant strategy  for 
 defines (computes) 
the constant functional  
of the type . Analogously,  denotes 
, the constant, 
undefined functional. 

However, typically, the strategy  starts its computation 
by asking the Oracle sequentially some questions  
(concerning ) 

assuming that the Oracle replied 

We assume that the strategy  cannot continue computation until 
receiving the definite answer to the last asked query, if receiving 
any answer at all. 
This querying process can be either 
(i) finite with no result, if the Oracle does not answer a query, or 
(ii) infinite, or (iii) after some answers ,  
 could ``decide'' that it has already received 
all the ``required'' answers from the Oracle and stop asking queries  
by returning a resulting value 

instead of asking the next query , 
if 
 is defined at all. 

 
We say that  is \emph{descendant} to  if 
 for some  
and  occurs in  
(that is,  \emph{asks} about , or  is a \emph{child strategy} of )
or, recursively,  is descendant to a strategy occurring in 
. Intuitively, only descendant strategies 
matter for the meaning of the given strategy . 


\subsubsection{Additional Requirements on Systems of Strategies}
\label{sec:additional-requirements}

Without restricting generality we can impose the following 
natural requirements on systems of strategies. 
\begin{enumerate}[]
\item
If 
 then  is undefined  
for all non-empty . 
(Contraposition: If  is defined then  defines a query.)
\item 
 is defined only for -\emph{self-consistent}  
computational histories 
, i.e.\ for such  which 
do not contain different answers 
to the same query by : 
for all proper initial segments   
and , 
 
\end{enumerate}
Note that only computational histories 
satisfying these properties are realizable in 
the interpreted computations considered below in 
Section~\ref{sec-seq-stra-den-sem}. The idea of consistency 
will be further generalized in 
Section~\ref{sec:wittingly-cons} 
when considering nondeterministic wittingly consistent strategies. 

Intuitively, each strategy  computes some functional 
 of the type . Let us first consider some simple examples. 


\subsubsection{Examples of Strategies}
\label{sec-seq-stra-def-examples}

In these examples we assume that strategies compute functionals from the 
standard continuous model .
In the special case, when  and
 for all basic values ,  
we represent (the behaviour of) such a strategy  by the formal equality

This style of presentation allows us to avoid explicitly 
using  when the behaviour of strategies is simple enough. 
It follows that the (typed) \PCF\ \emph{combinators} 
satisfying equalities\footnote{Strictly speaking, we should use the canonical list of variables 
 instead of  and write, for example, 
 
for the base type terms.
}

\noindent may be also considered as strategies. 
In fact, we can consider \PCF\ \cite{Scott93,Plotkin77} as 
a system of strategies  where 
, and some evident basic arithmetical operations 
with typing 
omitted for brevity\footnote{this is actually an infinite system. 
}.
Note that the \emph{least fixed point operator}  is an 
example of a \emph{recursive} strategy referring to itself. 
Another simple example
of a strategy is the {\em conditional\/} \PCF\ constant 
 

This strategy asks at most two questions: 
first ``'' and then, depending on the result 
 or ,
it asks ``'' or ``'', respectively. 
The answer received from the Oracle to the second question 
on  or  will be 
returned by \IF\ as the final result of the computation. 
It is quite trivial to rewrite the above conditional equation for \IF\ 
in terms of ---in the style of Definition~\ref{def:strategies}. 

Note that the following version of \IF, the
\emph{parallel conditional monotonic function} 

(and analogously for )\footnote{Although we decided to avoid using the boolean type  in 
the general theory of strategies, the examples considered here are a little simpler 
and more natural when this type is used. 
} 
defined as
 
evidently has no computing it sequential strategy asking simple queries 
of the kind ``'', ``'', and ``'' (and, in fact 
no sequential strategy at all, asking arbitrary queries). 
Say, if the first query asked by such a strategy is ``'', 
it may happen that the answer is undefined, leading to an undefined 
result of the whole computation, whereas it can be  which should 
give a defined result. Analogously, such a strategy could not start with 
``'' or ``''. 


Unlike \PIF, every \PCF\ constant 
can be considered as a sequential strategy. 
Say, the successor operation  for  
is defined by the evident strategy which asks the question ``'' and, 
after getting a result  from the Oracle, returns the 
value . 

As a less trivial example, consider the following strategy   
computing the functional for 
the \emph{weak sequential existential quantifier} 
: 

To compute  (i.e., ) 
this strategy starts by asking, sequentially, the queries  
\linebreak
``'', ``'',  to the Oracle.
The strategy keeps asking these queries in this order 
while all the currently received answers are \false. 
As soon as one of the answers obtained in this order 
is \true\ or , this value 
is the result of the computation. 
Alternatively,  could be defined as follows. 
Again,  starts with asking 
``'' (). If the answer is \true, 
 returns the result \true\ (). 
Otherwise,   
asks ``''\footnote{This is a recursive query because  asks about itself. 
}
and returns the answer of the Oracle to this query as the final result 
(, ). 
Here the lambda abstraction operator can be simulated, as usual, 
by combinatory strategies  and . 
Then, to compute , the system of strategies should also 
contain strategies , and  (the successor).
The functional  can be also 
defined in \PCF\ by the recursive equation 

or alternatively by using 
: 



Consider also the \emph{finite sequential existential quantifiers} 
,  which can output 
both \true\ and \false:

The sequential strategy computing   
starts by asking  queries 
``'', ``'', , ``''. 
As soon as one of the answers obtained in this order 
will be \true\ or  (undefined), this is the result of the computation. 
Otherwise, 
if all answers are \false, the strategy asks 
``'' and outputs the 
value of~. 

The sequence of functionals  is evidently increasing with a limit 
 which can be also defined as 

or in terms of \PCF:

We omit the (well-known) definition in \PCF\ of the 
-operator. 
The sequential strategy computing  reduces this task 
to the sub-task . The equation for  
gives an analogous strategy. 
The main point here is that strategies may be quite arbitrarily complicated. 
As we will 
see in Theorem~\ref{th:universal}, all (effectively computable) strategies, 
however general, can be simulated in \PCF, which 
characterises exactly its expressive power. 

\section{Interpreted Computations and the Denotational 
Semantics of Strategies}
\label{sec-seq-stra-den-sem}

\subsection{Preliminaries}
\label{sec-seq-stra-den-sem-prelim}

\noindent
Let us fix a given system of strategies 
 
and a monotonic, order extensional applicative structure 
 of finite type functionals, with  
and . 
Our current goal is to define a \emph{denotational semantics} 
of strategies 

as the least fixed point of some operator 
, that is, 
the least solution of the equation . 
This equation is also understood as the requirement of 
\emph{correctness} of the given semantics 
. 
In fact,  is defined via 
interpreted computations over  
performed by strategies of the system 
 relative to~. 
The problem, however, concerns whether the operator 
 is well-defined and 
whether the required least fixed point  exists. 
It does exist if  is the standard continuous model 
.
It also exists for 
the monotonic model  of hereditarily 
sequential functionals, which we will 
consider in Section~\ref{sec-seq-func}. 
In both the definition of a system of strategies  and in 
earlier informal comments and examples 
it was \emph{implicitly}
assumed that both the Oracle and the strategy  always give {\em correct\/}
(in a reasonable sense) answers/solutions 
to the queries/tasks they are
``resolving''. 
This can be further clarified as follows.
\nopagebreak
\subsection{Formal Definitions}
\label{sec:seq-stra-den-sem-formal-def}


Assume any semantic map  is given. 
We can extend  from  to terms  
with variables from the list  
as usual, by induction, 
, assuming that each variable  
has some associated value . 
That is,  depends on the values of~.
Then, for any computational strategy 
, 
we define that the initial task ``'' (to be ``resolved'' 
by ) and 
all the queries 
``'' asked by  have
corresponding \emph{correct solutions} 
(with respect to~)---just the unique basic values 
 and  
of these \mbox{Basic-Terms}, respectively. 




























Let us now give the formal definition of \emph{interpreted computation} of the basic 
value of 
 induced by a strategy  
in a system of strategies 
relative to some semantic map in 
, , and some values of  in . 
This is a maximal finite or infinite 
sequence of pairs 

of queries and Oracle's answers, 
i.e.\ of terms 
 
and basic values , which satisfy the following 
two conditions for 
each :
\begin{description}
\item [] 
, 
\item [] 
 
(for the given values of  in ). 
\end{description}
The latter means that \emph{Oracle's answers  are correct} with respect to 
 and the values of~.

A finite (maximal) interpreted computation , 
is called 
\emph{successful} with the \emph{result}  
if, additionally, 
\begin{description}
\item 
[] . 
\end{description}
As sequential strategies are ``deterministic'', 
the result  is determined uniquely, 
if it exists at all. 
If it does not exist, we also 
say that the result is \emph{undefined} (). 
This is possible in the following cases: 
\begin{enumerate}[(i)]
\item the computation is infinite, or 
\item it is finite and consisting of  pairs, 
but unsuccessful, 
that is,  is either undefined, or  some 
 
with 

(for the given values of  in ). 
\end{enumerate}

Now let  denote 
the result  in  of the interpreted 
computation (according to  above) 
of the value of  
relative to ,  and any values of  in . 
Of course we would like to expect that  
(i.e.\ that \emph{the result of the computation is correct}) 
what, in general, 
is not true. For example, take  for all  of a non-trivial 
system of strategies. 
\begin{defi} is called \emph{computationally correct} if 
the equation  holds in  wherever  
or, briefly, . 
\end{defi}
In general, 
is evidently monotonic on  
\label{page:monotonic}, as well as on , 
and defines 
a unique functional 
. 
But is this functional necessarily in 
?
If true for all , this defines a new semantic map 
 and 
a monotonic operator \mbox{} 
(probably defined not for all ). 
In the case of the standard 
continuous model , this operator, 
being computable in the above sense, is evidently 
well-defined and also continuous 
and, therefore, has the least fixed point which we 
also denote as~. 
But in the general case of monotonic 
order extensional  (and even of any continuous 
and directly complete 
, but containing possibly not all continuous functionals)
the required value  might not exist in the model
and, even if 
it always exists, the 
monotonic operator  
might be not continuous (in the case of arbitrary monotonic 
) and may have no least fixed point.\footnote{All of this seems quite plausible and desirable to confirm by example.}
But, when possible, we 
take  to be the least solution of the 
equation . 
Thus, we are interested in the least computationally correct 
denotational semantics of strategies. 


Moreover, for any model  
and arbitrary system of sequential strategies ,
let  
for all  
and 
 
assuming the latter is 
well-defined in . 
Evidently, those  which exist are defined uniquely. 
It follows from the monotonicity of  and monotonicity and order extensionality 
of  by induction on  that 
 
assuming  is an arbitrary computationally correct semantics. 
\begin{defi}\label{def:natural-defined} is called \emph{naturally defined} in  if 
all  exist and 

that is, 
 holds for each  
where  is the natural, 
or pointwise lub in , as defined in Section~\ref{sec:natural}. 
\end{defi}
\begin{prop}\label{prop:natural-sem}\hfill
\begin{enumerate}[\em(a)]
\item If 
 is naturally defined in  
then it is  any computationally correct semantics in . 
Thus, if  is also computationally correct then it is the least one. 

\item Moreover, 
if  is naturally continuous and  is naturally defined then it 
is, indeed,  
the least computationally correct semantics of .
\end{enumerate}

\end{prop}
\proof \hfill
\begin{enumerate}[(a)]
\item The conclusion follows from the same statement on all . 

\item Just the equality 
 
implies that  
 
holds whenever  for some  depending on .  
The converse inequalities 
 hold 
for appropriate  depending on  by using natural continuity of  . 
It follows that , as required.\qed
\end{enumerate}

\begin{defi}\label{def:sequentially-complete}If the naturally defined semantics  
exists in  and is (the least) computationally correct
for all sequential systems of strategies then  
is called \emph{sequentially complete}. 
\end{defi}

\noindent
Besides the evident example of the standard directly complete 
continuous model , 
the sequential completeness property holds also for 
the model  of hereditarily sequential functionals
considered below in 
Sections~\ref{sec-seq-func}--\ref{sec:full-abs}. 
An analogous result takes place for another model  and a 
more general 
concept of nondeterministic (wittingly consistent)
strategies considered in Section~\ref{sec:full-abstr-PCF+}. 



\begin{defi}\label{def:seq-func}Finite type functionals in  of the form  
for any strategy  of any system 
(for the least computationally correct semantics , 
if it does exist)
are called 
\emph{sequential}.\footnote{We do not expect that this concept is really interesting 
for arbitrary~. 
Although it is reasonable to restrict attention to naturally continuous and 
sequentially complete models, it may be unknown in advance that the given structure 
(such as  or  considered below) satisfies these properties. 
Thus, for the sake of the argument, we need the general definition. 
}
If  is a strategy from an (effectively) computable system 
of strategies  (i.e. with computable 
), 
then  is called
an \emph{effectively-sequential} functional.\footnote{A sequential functional can also be called 
\emph{sequentially computable}, although the corresponding strategy could 
be not (effectively) computable at all. 
That is, the concept of sequential computability is, in fact, a relative one 
(see also \cite{MTrakhte76TCS,Saz76d}).
}
\end{defi}

\noindent
This is the way that sequential and effectively-sequential finite type functionals 
(in appropriate ) can be defined in quite general terms of 
computational strategies~\cite{Saz76AL}. The same approach works for the 
type-free version of sequentiality~\cite{Saz76SMZH} in the Scott model 
\footnote{\label{foot:Dinfty}
Actually, a closely related and ``stronger'' isomorphism 
 should be used. 
Note that this isomorphism evidently implies 

and hence 
.
This allows us to consider strategies asking (infinite) 
applicative queries over  
of the basic type , like in the typed approach. 
}. 
It could be also extended to more 
general type theories and models and also for more general kinds 
of basic values than the flat . 





\section{Hereditarily Sequential Functionals}
\label{sec-seq-func}


\subsection{Canonical Strategies}
\label{sec:canonical}

\begin{defi}\label{def:canonical}
A system of strategies is said to be in the \emph{canonical form} if
all queries ``'' asked by these strategies 
 (with  of the basic type) have the form 

\noindent
where each  
has a type suitably depending on the type of the head variable .
\end{defi}


\noindent
For example, a strategy  of the type  
computing a functional  with  
can ask queries of canonical form 
``'' or, in particular, ``'' 
if  is a constant functional having the integer value . 
Note that for sequential computability of such functionals 
it is insufficient to consider queries of the form ``''. 
As we will see in Section~\ref{sec-quotient}, 
the canonical form of queries does not restrict the 
computational and denotational power of sequential strategies. 
Importantly, the descendant strategies  in (\ref{eq:canonical}) 
have evidently \emph{the same, or lower, level} 
(of their types) than .
This will serve below as the base for the inductive definition of 
hereditarily sequential functionals in terms of canonical systems 
of strategies. 

\subsection{The Main Inductive Definition}
\label{sec:ind-def}

\noindent
By using the above property of levels of strategies in canonical systems
we can give the
following inductive (level-by-level) definition of a 
\emph{monotonic order extensional structure
 of hereditarily sequential functionals} 
which will be shown later to be \emph{fully abstract model for\/ \PCF}. 
The initial part of this model for types up to level  is denoted as .
\begin{defi}\label{def:bbQ}For level 0, 
let  
be the flat basic domain. 
Assume, by induction, that 
the initial part of the model 
 satisfying (\ref{eq:EE}) and (\ref{eq:App}) 
has been defined. 
For any  of level 
take the minimal  such that 
 is of the level , and let, 
up to uncurrying\footnote{Note that the simpler definition 

does not work 
because we need to have below  to be an appropriate 
structure closed under application. 
}, 

\noindent
More precisely, let 

Then

can be considered as  
a monotonic, order extensional applicative structure up to level  
with the application operator defined by taking the residual map, 
as in~(\ref{eq:App}). 
Then, for any  of level , define : 

as the set of all monotonic 
mappings in  which are computable/definable 
(as described in Section~\ref{sec:seq-stra-den-sem-formal-def}) 
by the strategies  of the type
 of any system of strategies in canonical form\footnote{Without restricting generality, these systems 
may be evidently considered as 
containing only strategies of types  up to level .
}
for which 
the least correct semantics 
 
in the structure  exists. 
In fact, we can equivalently\footnote{This will be clear later from isomorphic representation of 
 as  and Theorem~\ref{th:least-correct-sem} (b). See also 
Proposition~\ref{prop:conditional-isomorphism}. 
}
require that  is \emph{naturally defined} 
(see Definition~\ref{def:sequentially-complete}). 

Alternatively, and equivalently (see the comments below), we can define 
for any  of level~\mbox{}

(See also Proposition~\ref{prop:natural-sem} (a).)
Sets of functionals  defined in this way 
for  of level  are evidently nonempty and contain at least 
all the constant functionals. In particular, they contain 
the elements  computable 
by the undefined strategies . 
They are considered to be
partially ordered pointwise by . 
This defines the extension  of  
which satisfies (\ref{eq:EE}) and (\ref{eq:App}). 
(The latter property of the closure under application 
follows straightforwardly assuming (\ref{eq:dom'}).  
This is much more difficult to show, if the more intuitively plausible (\ref{eq:dom}) 
is assumed instead; see the comments below.)
 
This makes the induction step mathematically correct because we 
assumed, and used, the fact that  satisfies only 
(\ref{eq:EE}) and~(\ref{eq:App}). 
Thus, (\ref{eq:dom'}) defines a monotonic order extensional structure  by induction. 
\end{defi}




\paragraph*{\bf Comments} 
\begin{enumerate}[(1)]
\item
The induction step above defines
{\em simultaneously\/} all  of level .
The canonical form of
strategies guarantees that {\em no\/}  of a higher level
(not yet defined)
will be needed in the induction step.
By contrast, recall that, for example, Milner's definition of the fully abstract dcpo model, 
as well as later approaches to non-dcpo models, 
requires consideration of \emph{all} types and levels at once.



\item
Although (\ref{eq:dom}) and (\ref{eq:dom'}) are, in fact, equivalent definitions 
of  at the level \mbox{}, unfortunately this is not so trivial and 
when taking the simpler equation~(\ref{eq:dom}) 
the proof of the \emph{correctness} of the whole definition would be rather involved.\footnote{Note that even for the standard definition of (hereditarily)
continuous functionals in  some correctness proof
is necessary.  Of course, the case of  is more
complicated. Instead of contrasting the continuous case with the
sequential one we prefer to see some analogy here. Thus, both
approaches are essentially extensional with some intensional component in each
case, even if these intensional components have somewhat different
flavour and complexity.  } For the inductive step in
Definition~\ref{def:bbQ} to be legal in this case we must show that
the resulting  satisfies both (\ref{eq:EE}) and
(\ref{eq:App}).  The condition (\ref{eq:EE}) holds by definition, and
(\ref{eq:App}) means that  is closed under
application (also for results of the level ), that is under
taking residual maps, like for .  This is
quite straightforward in the case of~(\ref{eq:dom'}), unlike the case
of~(\ref{eq:dom}) although the latter looks more natural.  This is the
reason for our choice of~(\ref{eq:dom'}) in the above definition\footnote{Thanks to an anonymous referee for suggesting the formula~(\ref{eq:dom'}) 
which crucially simplified (made it just straightforward) 
correctness proof of the induction step 
of the definition of . Based originally on~(\ref{eq:dom}) it required 
the full theory of sequential strategies of the next sections. 
But, anyway, this theory is still needed to prove the main 
properties of . 
}.
The equivalence of (\ref{eq:dom}) and (\ref{eq:dom'}) 
will be shown later, 
as well as that 
an arbitrary system of sequential strategies, not necessary in the canonical form, 
has the least correct and even naturally defined denotational semantics  in  
(that is  is sequentially complete), 
and that each element in 
 should have the form  for some (even canonical) strategy
. The latter means that  consists of all, and only, sequentially 
computable functionals. 

\item
In general, we want to know that this structure is natural enough 
(although it is not a directly complete poset). 
That is it is a fully abstract model for \PCF, sequentially complete, 
naturally continuous, naturally algebraic and 
naturally bounded complete; we establish this later.  
But now we can prove a conditional 

\end{enumerate}














\begin{prop}\label{prop:conditional-isomorphism}
If some 
sequentially complete model  exists 
and each of its elements has the form 
 for a strategy in some system of strategies 
in canonical form for  the (least) correct and naturally defined 
semantics in  then . 
It follows that in this case all the mentioned variations of the Definition~\ref{def:bbQ} 
give rise to the same . 
\end{prop}
\proof 
Assuming 
that  (as well as ) satisfies 
(\ref{eq:EE}) and~(\ref{eq:App}) we can even show the identity . 
Thus, given by induction  
(as is definitely true for ) 
and therefore 
, 
for  of level , 
and , 
let us show that . 
But, according to (\ref{eq:dom'}) and our assumptions (in particular, the closure of 
 under applications as taking residuals), we have 
 
with the omitted parts ``'' as in (\ref{eq:dom'}).
In the second equality we use 
the routinely checked fact that the naturally defined and correct semantic map 
 in  is also naturally defined and correct in the extension 
 because  is closed 
under applications and all corresponding arguments and answers to all 
queries considered are evidently the same in both structures 
 and . 
(Proposition~\ref{prop:natural-sem}~(a) shows that  is in fact the least 
correct semantics).\qed


\noindent
In particular, once the above shows , 
we have a simplified version of (\ref{eq:dom})

with the extensions 
 and  no more necessary to mention. 








\subsection{What Next?}
\label{sec:what-next}

\noindent
For showing the required properties of  such as continuity 
and sequential completeness 
we will need more involved considerations and  
develop the corresponding general theory of sequential strategies 
\cite{Saz76SMZH,Saz76AL}
in Sections~\ref{sec-quotient}~and~\ref{sec:full-abs}. 

In particular, to represent the application operation in 

we will need to define corresponding operation
 for arbitrary strategies

and \mbox{}, giving a ``residual'' strategy 
 of the type
, such that
; 
\cf\ Theorem~\ref{th:least-correct-sem} (a).
It is crucial here that  serves as the operational semantics of strategies of arbitrary, not necessarily the basic types. 


In fact, we will \emph{redefine} our model in a non-inductive, ``quotient'' form 
 where  
is a unique \emph{universal} system of sequential strategies 
(containing in a sense all other systems---the unique up to isomorphism 
terminal object of the category 
of all systems of strategies) and will work mainly in terms of  and . 




This general theory is based on the 
\emph{operational semantics} of strategies and will culminate in 
Sections~\ref{sec-quotient} in 
Theorem~\ref{th:least-correct-sem} and its Corollary~\ref{corr:isomorphism} 
(using the above Proposition~\ref{prop:conditional-isomorphism}) that . 
Moreover, 
we will also prove in Section~\ref{sec:full-abs} that  is a fully
abstract 
model of~\PCF\ and has further good domain theoretic properties discussed in
Section~\ref{sec:prelim}.  

















\section{Sequential Functionals as Quotient Strategies}
\label{sec-quotient}

\noindent
According to \cite{Saz76SMZH,Saz76t}, 
there exists a {\em universal\/} system of
sequential strategies  
(with  of the cardinality of continuum)
such that for any other system
of strategies  there exist a \emph{unique} homomorphism
. 
For the rest of this paper we will need only the existence of , 
however its explicit construction is presented 
in Appendix~\ref{appendix:univ-sys-strategies}. 
In general, 
a \emph{homomorphism} 
is a map  preserving types such that 


for any applicative terms , strategy , basic value  and 
variable . 
That is, a homomorphic image of a strategy has essentially ``the same'' behaviour.\footnote{\label{foot:approx-hom} 
In particular,  means that both 
 and  are defined, or not. 
A~more general concept of an \emph{approximating homomorphism} 
is obtained by allowing the requirement 
 
only in the case of . 
That is,  has ``the same or more definite'' behaviour than .  
}
The fact that  can map different strategies in  to the same strategy 
in  means that the latter is more ``abstract'' version of the former. 
Homomorphisms are evidently closed under compositions: 
.


 
Moreover, any strategy  and its homomorphic image  
have the same denotational semantics in the following sense. 
\begin{prop}\label{prop:homomorphism-and-semantics}
Let  be a homomorphism. 
\begin{enumerate}[\em(a)]
\item For any  and its composition 

the corresponding results of 
the interpreted computations coincide:  
wherever . 

\item  holds
assuming 
 exists.\footnote{For approximating homomorphisms defined in Footnote~\ref{foot:approx-hom} 
we rather have 
 for all .
}



\item If  is computationally correct 
(resp., naturally defined) then so is the composition 
. 

\item For  
sequentially complete, 
 holds 
for the (least) computationally correct and naturally defined semantics 
 and  of these two systems, respectively. 
\end{enumerate}
\end{prop}
\proof \hfill
\begin{enumerate}[(a)]
\item follows from the similarity of the two interpreted computations 
via the homomorphism .

\setcounter{enumi}{0}
\item  (b)
(by induction):

\setcounter{enumi}{0}
\item[(a)]  
the first part of (c):

\item[(b)]  
the second part of (c):

\item[(c)]   
(d). (See also Proposition~\ref{prop:natural-sem}~(a).)
\qed
\end{enumerate}

\noindent
Therefore, it is natural to identify informally  with  
and with their unique homomorphic image in , 
and to consider the latter as a really universal system of strategies ``containing'' 
all possible strategies (up to homomorphism). 


\medskip

Various strategies in  
computing the same functional in , , 
may be identified via an equivalence relation  
which will be also defined in Section~\ref{sec:def-of-tQ} by using 
operational semantics of strategies 
over  
so that we will actually have
 isomorphic to  
and even could take the equality
 as (another) definition of .
Moreover, we will define a preorder relation  
on the strategies in  generating  
as the corresponding equivalence relation 
and inducing the approximation relation 
 on  
(that is, ) 
which, in fact, exactly corresponds to the pointwise approximation 
relation on  assumed in Section~\ref{sec:ind-def}.

\subsection{Operational Semantics for Strategies (Informally)}
\label{sec:operational-sem-informal}

\noindent
Following \cite{Saz76SMZH}, we will define an operation  
of the application of strategies (having appropriate types) 
of the universal system . 
More generally, given any combination 
 of any type  
consisting only of strategies, 
a new strategy can be defined  of the same type  
(also denoted in the op. cit. as ). 
In particular,  and  should have the same denotational meaning 
in any ``reasonable'' model , that is, 

This will be achieved in terms of 
a quite natural computation 
process induced by the strategies involved in , without any reference 
to any model . That is why this may be considered 
as an \emph{operational semantics}  for the terms , 
unlike the denotational semantics .

Therefore, let us consider the formal expression  as a strategy 
(or we could take its unique homomorphic image in ). 
We need to define the action of  
for any string of the Oracle's answers . 
It is both simpler and instructive to first consider the case when  and  
have the basic type~. Such a strategy asks the Oracle no questions  
and ``computes'' some basic value , 
if defined at all, for  (the empty string of Oracle's answers). 
Thereby, the corresponding initial task ``'' or task 
``'' of finding this basic value  will be resolved 
with the help of strategies participating in  by reducing this task 
(by induction) to some sub-sub--tasks ``''. 
Here all  are terms of the basic type consisting only of strategies, and therefore 
having a numerical solution (if any) computed by induction in the same way 
until the original task ``'' is resolved.
In fact, each  sub-sub--task  has the form 
, that is headed by a strategy  
which asks further queries (reduces  to further immediate sub-tasks),
and continues the computation of the value of  on the basis of the replies obtained. 
This generalizes the 
reduction process of lambda calculus or the natural (call-by-name) computation 
of the value of a closed \PCF\ term of the basic type. 


















In the general case, when the strategy  or the term  has 
an arbitrary, non-basic type 
,
we need to consider the initial task ``'' 
or ``'' 
of the basic type , with the variables . 
Then
it will be reduced to various sub-sub--tasks 
 
which can now involve the variables~. If  
is headed by a strategy 
 then the further computation (reduction to further immediate sub-tasks of ) 
proceeds as in the case above when all tasks considered had no variables. 
But it is also possible that 
 is headed by a variable  in . 
Here we assume that the computation continues with 
the help of an arbitrary (now non-empty) prompt  by the Oracle 
because the head variable  itself 
does not have the ``ability'' to continue the computation of . 

For the initial task ``'' 
we actually want to know/compute: under which prompts  from the Oracle, which 
sub-sub--tasks  headed by a variable, 
or which resulting values in  can be generated? 
(The tasks  headed by a strategy will continue the computation themselves.)
This is essentially the way (with many details omitted) 
how  can be defined (computed) 
by this process.

Formally, at each point 
we have a state of the computation 
like a ``stack'' (a finite string 
consisting of pending 
sub-sub--tasks and basic values as the intermediate results) 
which may ``pulsate'' during time as we will see in the formal 
definition below. 


\subsection{Operational Semantics for Strategies---Formal Definitions}
\label{sec:operational-sem-formal}

\noindent
Consider 
\begin{enumerate}[]
\item
a system of strategies , 
\item
an applicative term 
 
(in the role of a currently considered task or sub-sub--task 
of some initial task) 
with a head strategy  and possibly involving variables. 
\item
the canonical list of variables  for  (such that 
), and 
\item
a prompt .
\end{enumerate}
Three cases are possible: 
\begin{enumerate}[(1)]
\item[()]
, 
\item[()]
 is undefined, or 
\item[()]
 
\end{enumerate}
in which we will, respectively, say that the task 
 (or ``'') 
is -\emph{reducible} () to the \emph{result} , 
or 
() to the \emph{result} , 
or
() to 
the \emph{immediate sub-task} 
 --- the result of substituting the terms 
 in   
 for 
its free variables . 

Now, given , consider the set 
.\footnote{Recall that the union is considered here to be disjoint, and 
 may also involve variables. 
}
As usual,  denotes the set of finite strings over 
the set  considered now as consisting of atomic data. These strings 
can serve as \emph{intermediate configurations} of a computation. 
Let the \emph{initial configurations} have the form  
where  is a numerical string (the potential Oracle's answers) 
and  shown are the only occurrences of 
variables in . 
We use parentheses around  
to emphasize that this is a single element of . 

Define a computational procedure 
consisting of a transformation of finite strings in  
by the following rules defining inductively a transformation relation 
. For any , 
, , and  the 
following transformations (derivations) are allowed: 
\begin{enumerate}[(1)]
\item , if  is -reducible to ; 
\item , if  is -reducible to the immediate sub-task ; 
\item , if  has a head variable, i.e., has the 
form \footnote{Here  is considered as the Oracle's prompt for the 
variable-headed task . 
Thus, query  is replaced by the the prompt  which, actually, originates 
from an element in  of the initial configuration . 
If  with  and  then, before applying this 
rule to the occurrence of , 
the initial segment  should have been used analogously as the Oracle's 
answers on the previous steps of the computation. 
}; 
\item Transitivity: if  and  then 
. 
\end{enumerate}
Note, that no two of the rules (--) are applicable 
simultaneously to a string in~. It follows that  
determines a \emph{deterministic} (sequential) computation process. 
The term  in the rules ,  should be necessarily 
headed by a strategy, i.e., should have a form 
 with .
A derivation terminating in a string of the form , 
with  -reducible to , is called 
\emph{dead-ended}. 

For any initial configuration 
, 
exactly one 
of three cases is possible:
\begin{enumerate}[(\rlap{}1)]
\item  (with  completely ``exhausted'' by using ), 
where ; 
\item  \ \ 
(with  completely ``exhausted'' by using ), where  and 
``sub-sub--task''  is headed by a variable; 
\item either there exists an infinite or dead-ended derivation starting with 
, or 
 
holds for some initial segment  of the string  
(i.e.\ not all prompts from  are used). 
\end{enumerate}
Given any applicative term  of a type  without variables 
consisting of strategies in , 
consider a formal expression of the form  as a new strategy 
of the same type. 
Define a new system of strategies  where 
 is the set of all such formal expressions  
 and  is a function 
making  a system of strategies which is defined below 
with the help of a ``splicing'' function 
. 
We set  to be the result of grouping in the term 
, with the aid of , all the maximal sub-terms 
not containing variables. For example, 

Finally, we define  by setting, for any  
and , 

Thus, 
the system of strategies  
is based on the computation process () 
induced by the strategies of . 
By (implicit) use of the unique homomorphism from  
into the universal system of strategies , this 
gives  for any applicative term  over  without variables. 
In particular,  for any two strategies . 
For  of the basic type , the strategy 
 computes a constant value  
of this type (defined or not). This is also written as . 

\begin{note}\label{note:canonical}\em
For the case of arbitrary type, 
the resulting strategy  only asks queries headed by a variable 
(see () above) and 
may be slightly redefined in such a way that 
all these queries will be in the \emph{canonical}
form (\ref{eq:canonical}) 
(by the evident use of combinators \Ss\ and \K\ and the splicing function 
), 
even if the strategies participating in  were not canonical. 
Alternatively, we could trivially extend  to the case of 
-terms as  for  involving no  
and use these -terms to get the canonical form. 
\end{note}


\subsection{Relating Denotational and Operational Semantics 
of Strategies for the Standard Continuous Model 
\texorpdfstring{}{D}}
\label{sec:denot-oper}

\noindent
The main result of \cite{Saz76SMZH} relates
the {\em denotational\/} and {\em operational\/} 
semantics, 
and , of strategies in the
standard dcpo model \footnote{more precisely,---in an untyped model
	;
	the case of typed model  is quite similar
	and a corresponding result like (\ref{eq:oper-denot-sem}) 
	is formulated without proof in 
        \cite{Saz76AL} (see also Footnote~\ref{foot:Dinfty})
	 }
of all continuous finite type functionals over the given basic flat domain
. 
It consists in the
following equality which holds for any 
typed applicative combination  of
strategies containing no variables:

Here the right-hand side of the equality 
is the ordinary denotational semantics of an
applicative term defined by the application operator 
in the model 
and by  eventually applied to the strategies comprising .
We will show in Theorem~\ref{th:least-correct-sem}~(a) 
that the same equality holds in the model  
(and therefore in its isomorphic version~). 


The equality (\ref{eq:oper-denot-sem}) is essentially based on the 
\emph{associativity law} for  
:

where  are  any combinations of strategies in , and  is
obtained from  by grouping some sub-terms of  with the help of
the operation . 
The associativity law allows us to eliminate any nesting of  
and can be proved by a
thorough  analysis of -computations defined by strategies
 and ; \cf~\cite{Saz76SMZH} for a detailed proof 
(for the untyped case and for more general non-deterministic strategies). 


\subsection{Definition of 
\texorpdfstring{  and }{tilde-Q}}
\label{sec:def-of-tQ}

\noindent
Having the operational semantics , we can define a
relation  on strategies of the same type  as follows.

where  relates the (constant) strategies of 
basic type  and 
means that the strategy  outputs 
the same basic value as the strategy , if the first value is
defined at all. 
	To simplify notation we will often omit the external 
	in inequalities  for applicative terms
	 and  writing simply .
Evidently,  is a preorder on the set of strategies 
 of the type . The corresponding
equivalence relation is denoted as , and the ``undefined'' strategy 
 is the
-least element in each type. 
Due to the above associativity law, we
have  and, hence, 
. Therefore, 
\begin{prop}
Any strategy  is -equivalent to a
strategy in canonical form
\em (see Note~\ref{note:canonical}).\qed
\end{prop}
\begin{lem}\label{lemma:monotonic-op-sem}
Operational semantics is monotonic in the sense that 
for any applicative term  without variables 
which involves a strategy , 

\end{lem}
\proof  We can evidently consider that  has the basic type. 
Then the proof proceeds by induction on the length  of the computation 
. 
Let us write  for  and  for , etc. 
Two cases are possible. 
\begin{enumerate}[(1)]
\item 
 and 
 for the same head strategy . 
The case if  is a constant strategy (with the value ) is trivial. 
Otherwise,  reduces
the computation of the value  of  to some length  sub-computations of the
(basic) values  of some sub-tasks . By the induction hypothesis, 
corresponding  evaluate to
the same results . It follows that  also evaluates 
to  by the strategy , as required.
\item 
 and  
for the above  and . 
Then, as
it was just proved,
 and  evaluate both to , 
and it suffices to note that  and to use the 
definition of  with  and associativity 
of~.\qed
\end{enumerate}



\noindent
The following Lemma 
(Theorem 6.4 in \cite{Saz76SMZH}) 
corresponds to the \emph{context lemmas} in~\cite{Milner77}. 

\begin{lem}\label{lemma:context}
 Given any types  and ,

In particular, 

\end{lem}
\proof\hfill
\begin{itemize}  
\item[()] follows from Lemma~\ref{lemma:monotonic-op-sem}. 

\item[()]
Let us assume (for contraposition) that 
. 
For any basic value , define a strategy  by 

Then , 
as required.\qed
\end{itemize}

\noindent
Now, our goal is to show that 
 (\cf\ Definition~\ref{def:bbQ}) 
is isomorphic to the quotient 
 where each  
generates the equivalence class  and  
is the partial order on  induced by . 
The natural (typed) application operation in
 is defined by 

which does not depend on
representatives  and  of the equivalence classes. 
So defined structure  
is \emph{monotonic and order extensional} by 
Lemma~\ref{lemma:monotonic-op-sem} and definition 
(\ref{eq:approx-strat}) of~.
\nopagebreak
\subsection{Denotational Semantics of Strategies in 
\texorpdfstring{}{tilde-Q} 
and the isomorphism \texorpdfstring{}{of tilde-Q and inductively defined Q}}
\label{sec:den-sem-isomorphism}

Let us consider  as the denotational semantics of  in .

\begin{thm}\hfill  \label{th:least-correct-sem}
\begin{enumerate}[\em(a)]
\item Denotational semantics 
of the universal system of strategies  in  is coherent 
with the operational one\footnote{Compare this with the equation (\ref{eq:oper-denot-sem}) for 
the case of . 
}:
. 

\item  is sequentially complete 
(in particular, satisfying the -property (\ref{eq:Y-property})) 
with~ the least correct denotational semantics 
which is also naturally defined. 
\end{enumerate}
\end{thm}
\proof\hfill  \begin{enumerate}[(a)]
\item Apply associativity of  and the definition 
(\ref{eq:appl-in-tQ}) of application in . 
For example, . 

\item First, show correctness of . 
Consider the interpreted computation by a strategy  
associated with the task ``'' 
of the basic type
with some fixed values  in  
for the arguments  (and
). We should assume that  receives correct replies to its queries
``'' where  is a combination of strategies
 and the variables . According to the assignment  
and (a),
the correct replies are obtained
just by replacing all strategies  in  by  or, equivalently, by replacing
 by 
.
Then we must show that the resulting basic value  
(possibly ) 
of the interpreted 
computation coincides with the value of the combination
.
However, the latter value is
obtained by -computation, i.e.\ by 
essentially the same interpreted computation as above 
plus -sub-computations of the values
 for all queries.
The required correctness follows.


Let us show 
that  is sequentially complete.
First, we present a general consideration on the ``approximating'' semantics  
in any monotonic and order extensional structure . 
Given any system of strategies , define its 
``approximating'' 
version  by letting 

where  is considered as a formal expression (a pair of  and ), 
 for ,  for applicative terms, 
and  for variables. 
For any structure~, if a computationally correct 
 exists 
then all , , exist too and 
 holds for all , and vice versa. 
In particular,  is uniquely defined, if exists at all 
(iff all , , exist). 


Now, let , and 
 and  be the unique homomorphisms. 
Then both  and 
 
are computationally correct semantics of  and  in  
by the correctness of  
and Proposition~\ref{prop:homomorphism-and-semantics}~(c). 
It follows from the latter that all  exist, and, for 
sequential completeness of  , it remains to show that 
, that is 
, or equivalently, that 
for all strategies  of appropriate types
 holds for some . 
But the latter holds because, in each -computation 
giving a defined result in , 
 behaves as  for sufficiently large  and gives the same result. 


It follows that  and therefore its special case 
 are naturally defined and computationally correct and hence (by 
Proposition~\ref{prop:natural-sem}~(a))
both are the least correct semantics of  and , respectively, in .\qed
\end{enumerate}



\begin{cor}\label{corr:isomorphism}
.
\end{cor}
\proof 
Use Proposition~\ref{prop:conditional-isomorphism}.\qed











\section{Main Results on Full Abstraction and Domain Theoretic Properties 
of \texorpdfstring{}{Q}}
\label{sec:full-abs}


\subsection{Full Abstraction, Universality and 
\texorpdfstring{\PCF}{PCF}-Definability}
\label{sec:main-res}


\begin{thm}\label{th:full-abstr}
 is fully abstract model of\/ \PCF. 
The same holds for  (\PCF\ with  omitted). 
\end{thm}
\proof 
Assume  and  holds 
for all \PCF\ combinations . Then, in particular, 
 for all  definable terms  
of appropriate types. Let us infer , or equivalently 
that  holds for all strategies  of appropriate types. 
Indeed, according to Section~\ref{sec:observation} below, 
if  for some  then  holds also 
for some \emph{finite} (and even \emph{finitary ranked}) and 
therefore definable in  strategies  
(see Lemma~\ref{lemma:computations-finitary}~(a) 
and Theorem~\ref{th:continuity} (b) below). 
It follows  and , as required.\qed


\noindent
As in \cite{Saz76AL} (the case of ), 
\cite{Abramsky-Jagadeesan2000,Hyland-Ong2000} 
and also \cite{Longley-Plotkin} (the effective case), we have
\begin{thm}\label{th:universal}
For any type  there exists a\/ \PCF-definable functional

which is universal in the
sense that its range is the whole set  of sequential 
functionals. Moreover, there
exists\/ \PCF-definable

which enumerates all elements of  definable by
computable strategies (i.e. those in systems 
with computable~).

In particular,\/ \PCF\ exactly grasps sequential computability over , 
that is, \PCF\ definable = sequentially computable. 
\end{thm}
\proof  As in \cite{Saz76AL} for the case of 
. It is omitted here, but see the proof 
in Section~\ref{sec:full-abstr-PCF+} 
of analogous result for  and .\qed










\begin{thm}[Normann \cite{Normann2004}]
\label{th:normann}
The (unique up to isomorphism) directly complete and continuous 
fully abstract model 
for \PCF\ defined by Milner {\em \cite{Milner77}}\footnote{which is, more precisely, isomorphic to the limit (ideal) completion  
of ; 
\cf\ Section~\ref{sec:completion}. 
}
cannot be exhausted by sequentially computable functionals 
in , 
i.e.\ by those definable in \PCF\  all monotonic .\qed
\end{thm}

\noindent
More precisely, the proof in \cite{Normann2004} shows that 
 is \emph{not} an -complete domain for some  
of level~3. 
We know from Theorem~\ref{th:least-correct-sem}~(b) that  
is only sequentially complete.


\subsection{Deriving Domain Theoretic Properties 
of \texorpdfstring{}{Q}}

We need to use Lemma~\ref{lemma:algebraicity}, and this requires 
to work out appropriate versions 
of ``finite'' approximations of strategies. 

\subsubsection{Finite, Finitely Restricted and Finitary Sequential Strategies}
\label{sec:ranked-finitary}


\begin{defi}\label{def:restricted}We say that a system of strategies  
is a \emph{restriction}, or \emph{subsystem } 
(or \emph{approximation}\footnote{but in a different sense than considered above 
system 
})
of
another system  if , 
and, as partial functions, .\footnote{Note, that the embedding  is  
an approximating homomorphism; \cf\ Footnote~\ref{foot:approx-hom}. 
}
A restriction  is called \emph{finite} if both 
the set  and the function  are finite. 
Strategies (if any) from finite restrictions of  are called 
\emph{finite}. 
\end{defi}

\noindent
If  is a restriction of  
then the (unique)
homomorphic image  in  of any  in
 is called a 
\emph{restriction}, or \emph{sub-strategy} (or \emph{approximation}) 
of the homomorphic
image  of the same  considered as a strategy of . 
By abusing notation, we write .\footnote{By considering the explicit construction of  
(\cf\ \cite{Saz76t} or Appendix~\ref{appendix:univ-sys-strategies}), the relation  on  may be treated, indeed, 
as set inclusion between strategies considered as graphs of partial functions 
of a special kind and is therefore 
a partial order. However, we will not need this fact. 
}
Then, evidently,  (i.e.\ ), holds in~.

Let us introduce a more general concept than a finite strategy. 

\begin{defi}\label{def:finitely-restricted}Given any system of strategies , 
let  be defined and equal to  
if, and only if, (i) the string  consists only of numbers  
and (ii)~ in the case of . 
The system  
is called \mbox{-\emph{restriction}} of . 
If, in fact,  then 
the original system is called \mbox{-\emph{restricted}}. 
Then \emph{finitely restricted} means -restricted for some . 
A strategy  is called -\emph{restricted} if it is contained in the homomorphic 
image of some -restricted system of strategies. 
\end{defi}
\noindent
Evidently, , and also 
any finite  is finitely restricted (but not vice versa). 
-restricted strategies ``understand'' only basic values , 
as if it was our basic domain  so restricted to 
. 
Strategies from the original and restricted versions 
of a system of strategies, although formally having the same names, 
behave differently. Therefore, to emphasize that a restricted version 
is assumed, we will write  instead of  and 
 instead of , 
whereas  will typically be considered as a strategy of the 
non-restricted system .\footnote{Note that, although there is a kind of analogy between the strategies  
considered here, and  considered in the proof of 
Theorem~\ref{th:least-correct-sem}, the behaviour of these strategies is different. 
}
In the following Lemma 
we identify strategies with their homomorphic images in  
and relate -restriction with the projection maps  
defined in Section~\ref{sec:natural}. 

\begin{lem}\label{lemma:finitely-restricted}
Functionals  in  defined by finitely (-)restricted
strategies are also finitely (-)restricted 
\em (as defined in Section~\ref{sec:natural}). 
\end{lem}
\proof 
Consider projection functionals ,   
and computing them sequential strategies 
. 
Their behaviour can be described by the equality (in the basic type , 
assuming  and ) 

Here  means the application of  (of appropriate type) 
to each  in~. 
Let us show that . 
The task ``''
is reducible to ``''.
By assuming that  asks queries in canonical form 
``'', 
the task ``'' is further reducible 
by  to the sub-task  

and then by  to 

with the head variable , 
where  assumes that only answers  will be taken into account. 
As  is -computationally equivalent 
to \footnote{if to replace the variables  by arbitrary strategies  
of the same types
},
the latter query is equivalent to 

All of this means that  behaves computationally as  
which asks similar queries 
``'' and reacts to the answers 
in the same way as  and , 
except considering the integer values bigger than~ as if they were undefined. 
It follows that , as required. 
Moreover, . 
If the original system is -restricted then , 
and therefore the functional  is -restricted in~.\qed










\begin{defi}\label{def:ranked}A system of sequential strategies  is called \emph{ranked} if 
(ignoring types)
 is a disjoint union 
such that any strategy
in  can ask queries only concerning the strategies in .  
\end{defi}
\noindent
We have actually considered a similarly ranked systems in the proof of 
Theorem~\ref{th:least-correct-sem}~(b) but with the \emph{inverse} ranking order. 
Our choice of the \emph{ranking order} as in Definition~\ref{def:ranked} is based  
on the following Lemma. Independently of the choice of this order, 
ranked systems of strategies evidently remain ranked under restriction. 






\begin{lem}\label{lemma:ranked}
Any system of strategies  is 
homomorphic image of a ranked system. 
\end{lem}
\proof 
Indeed,  is homomorphic image of a ranked system 
 with  defined for all  as 

where  is obtained from , for  any term, by replacing each 
occurrence of a strategy  in  by
, and 
 for any resulting basic output value .  
The required homomorphism is .\qed


\noindent
Moreover, if  is a 
homomorphism 
then  is 
also a homomorphism of corresponding ranked systems 

and the resulting square diagram commutes: 
. 




\begin{defi}\label{def:finitary}Strategies from
ranked systems of strategies  with  
both  and  finite are called \emph{finitary}. 
(That is, essentially, finitary = finite  ranked, also = finite well-founded).) 
Equivalently, only  may be required to be finite. 
\end{defi}

\begin{lem}\label{lemma:finitary-finitely-restricted}
Finitary strategies are special case of finite strategies 
which, in turn, are special cases of finitely restricted ones and therefore 
define (in fact all; \em see Theorem~\ref{th:continuity}\em) finitely restricted 
functionals in .\qed
\end{lem}
\noindent
If  is finite and  is the ranking then all  
are empty for  large enough.
In a reasonable sense 
finitary strategies are considered as \emph{non-recursive}. 
Homomorphic images in  of finitely restricted (resp., finitary) strategies 
can also be unofficially called \emph{finitely restricted (resp., finitary)} ones. 
Any (finitary) strategy  from a finite ranked system 
 with the ranking  
has a finite \emph{rank} 
which is the length  
of a maximal chain  of strategies 
(in , respectively) starting with given  
such that each 
, , asks a query on  
(i.e.\  is a child of~). 
Now, K\"onig's Lemma entails more general
\begin{prop}\label{prop:finitary}
All strategies in  are finitary\footnote{each in an appropriate finite ranked subsystem of 
} 
iff for each  
there is only a finite number of computational histories  such that 
 is defined and there are no infinite chains 
 where  asks a query on  
(i.e.\  is well-founded). 
\end{prop}
\proof
``Only if'' case is trivial. For ``if'' case assume its condition, and let 

Then  
 is an \emph{inverse ranking} 
of  (in the evident sense dual to Definition~\ref{def:finitary}). 
By K\"onig's Lemma, each  has only a finite set  
of improper descendants (including  itself) 
which, if intersected with each , gives a finite (inverse) ranked 
subsystem of , as is essentially required.\qed

\noindent
The finitary strategies of rank 0 are either constant strategies of any type 
(asking no queries to the Oracle) or strategies which can ask 
in each of finitely many possible ways of computation 
only (finitely many) queries which are applicative terms 
consisting of variables only. 
The finitary strategies of rank 1 are defined analogously, except that they can ask 
queries involving, besides variables, only strategies of rank 0. 
Etc., for finitary strategies of any rank. 

\medskip

But we need to be careful with such verbal descriptions. 
For example, the functional
 
(and  if )
computable by the evident rank 1 strategy 
is 
\emph{not finitary} because, 
in its computation, the query  can have \emph{any} answer  
leading to the definite result . 
In fact,  describing the evident strategy computing functional  has an infinite 
domain. 






\subsubsection{Observation on Computations and Finitary Strategies}
\label{sec:observation}
It follows from Lemma~\ref{lemma:ranked} that 
in computations only countable ranked systems of strategies 
 matter. 


\begin{lem}\label{lemma:computations-finitary}\hfill
\begin{enumerate}[\em(a)]
\item For any combination of strategies  over 
, 
if  then also  over a 
finite restriction  of . 

\item For any countable 
system of strategies,  holds 
for some monotonic by set inclusion sequence of finite restrictions of .

\item For any system represented as a monotonic union 
  
 of some 
restrictions, 
any resulting computation  over  is, in fact, 
a computation over some , or equivalently 
over some . 

\item Let the strategy  be just  considered as a strategy 
of  with  as in (c).\footnote{ may be \emph{finite}, or even 
\emph{finitary} in the case of (b) and ranked , 
or \emph{finitely restricted} in the case 
 from 
Definition~\ref{def:finitely-restricted} 
with  denoted there as~.
} 
By identifying these strategies with their homomorphic images 
in , this gives rise to the -increasing sequence  with the 
natural lub . 

\item In particular, any functional in  is the natural lub of an increasing sequence of 
finitary presented functionals (and the same for any of the version of ``finite'' considered in Section~\ref{sec:ranked-finitary}). 
\end{enumerate}
\end{lem}
\proof\hfill
\begin{enumerate}[(a)]
\item Let  consist only of those finitely many strategies in  which 
participate in the original derivation  and 
(the finite)  be defined if, and only if,  and 
the computational history  for  
was really used in the derivation . 

\item Let  with  any increasing sequence of finite subsets exhausting~. 
Let  and 
, and define  
to consist of all strategies 
participating in the domain and range of . 

\item Like in (a), construct finite  and embed it in appropriate 
. 

\item Use (c) with the equation (\ref{eq:pointwise-lub}) 
defining the natural lub as the ordinary 
pointwise defined lub  in the basic type 
by using an appropriate list of arguments. 

\item Use Lemma~\ref{lemma:ranked} and (d) with  as in (b).\qed
\end{enumerate}

\begin{thm}\label{th:continuity}\hfill
\begin{enumerate}[\em(a)]
\item The model of sequential functionals  
is naturally continuous, 
naturally -algebraic and naturally finitely bounded complete. 
Naturally finite elements of each  are exactly 
finitely restricted ones\/ {\em(in the sense of Definition~\ref{def:proj-finitely-restricted})} 
or, equivalently, definable 
by finitary strategies or, equivalently, 
by finite strategies or, equivalently, 
by finitely restricted strategies.\footnote{In \cite{Saz76SMZH}, special non-deterministic (non-sequential) 
strategies  played the role analogous to that of 
sequential finitely restricted/finitary strategies considered here 
to define finite elements in  (or in  in the 
typed case), and  was also represented as a quotient of a universal 
system of (consistent) non-deterministic strategies. 
}
\item Naturally finite elements of  are definable in 
\PCF\ (even without using ). 
\end{enumerate}
\end{thm}

\proof\hfill
\begin{enumerate}[(a)]
\item follows from Lemma~\ref{lemma:algebraicity} whose condition (*) 
is satisfied because of the above observations and  
Lemmas~\ref{lemma:finitely-restricted}, \ref{lemma:ranked}, 
\ref{lemma:finitary-finitely-restricted}, and, most important, 
\ref{lemma:computations-finitary} (a).
Also recall that the naturally finite natural lub of an increasing sequence 
in  must stabilize. 

\item Use straightforward induction on the rank of finitary sequential strategies.  
Alternatively, apply the general Theorem~\ref{th:universal} concerning definability 
in \PCF\ (having much more involved proof).\qed
\end{enumerate}



\begin{note}\label{note:finite-simeq-finitary}\em
It follows from the definition of naturally finite elements in  
that any finitely restricted or finite 
(possibly recursive) strategy is  
to some finitary (ranked, non-recursive) strategy, by representing the former as  
the natural (in fact, stabilizing up to ) lub of finitary strategies. 
But this proof is non-constructive, and by appropriate adaptation 
of the technique of Loader \cite{LoaderTCS2001} it should be possible to show that 
the \emph{there is no corresponding ``canonization'' algorithm} 
finite  finitary as there is no way to determine the moment 
of stabilization in the above lub. Also the related \emph{problem ``?'' 
even for finitary (ranked) strategies should be undecidable}. 
\end{note}

\noindent
Note also that Theorem~\ref{th:continuity}~(b)  
and Lemma~\ref{lemma:computations-finitary}~(a) were 
actually used in the proof of Theorem~\ref{th:full-abstr} 
that the model  is fully abstract for \PCF\ 
which was incomplete till this moment. 



\medskip

We conclude this section by proving that \emph{the class of finitary strategies 
is effectively closed under taking applications}. This was actually used in  
Section~\ref{sec:efficiency} in representation of naturally finite functionals 
in  by finitary strategies (and, similarly, for ). 
\begin{note}\label{note:closure-under-appl-of-finite-strategies}\em
On the other hand, the closure of finitely (-) restricted strategies under 
application is trivial. But, unlike the finitary strategies, they are not necessary finite 
(and can be recursive). Also, \emph{arbitrary finite strategies are 
probably not closed under application} 
(note that ranking is essentially used in the proof of the following theorem), 
however evidently giving rise to finitely restricted strategies. 
\end{note}

\begin{thm}\label{th:applications-of-finitary}
For any applicative term  consisting of finitary strategies, the strategy 
 is finitary, too, and\/ {\em(as a finite object understood in the evident sense)} 
can be effectively computed from  and 
comprising its strategies. 
\end{thm}
\proof 
Let us slightly generalize the concept of the initial configuration  
from Section~\ref{sec:operational-sem-formal} 
(where  and  is a list of variables making the term  
be of the basic type ) 
by allowing the term  to contain any variables.  
The statement which we will actually prove is a kind of 
\emph{normalization (termination) property}: 
for each applicative term  involving only finitary strategies 
and any variables 
\begin{quotation}
(*) \emph{ for any list of variables  making  a term of the basic type 
there exists only a finite number of finite non-dead-ended computations\footnote{This requirement also means that for each numerical answer 
(either computed or taken from ) 
to a strategy question during such a computation the strategy should be able 
to react in a definite way 
giving either a result in , as in the case of 
(), or a new query, as in (). 
If dead-ended computations would be allowed then we might have an infinite number of them 
for  with large values in . 
Indeed, only finitely many strategies---all being finitary descendants 
of those occurring in ---can participate in such computations, 
and they ``do not understand'' large numerical values. 
}
(sequences of derivation steps) starting from 
\mbox{} for various 
 obtained by the rules (--) with  completely ``exhausted''\footnote{Exhaustion 
is necessary, otherwise infinitely many  
of unbounded length would be admitted.
}. 
}
\end{quotation}
Then appropriate application of K\"onig's Lemma will imply that  is indeed 
finitary and computable from . 

Following Tait~\cite{Tait67} and the presentation by Barendregt~\cite{Barendregt85} of 
the normalizability proof for typed calculi, 
(*) can be shown 
for any  as follows.\footnote{We give the detailed proof to show the specifics of the concept of 
strategies.
}
Define classes of typed terms 
consisting of finitary strategies and variables:

Evidently, 

and  is closed under taking applications of terms. 
Any variable satisfies~(*) and belongs to~. 
Also any finitary strategy trivially satisfies (*).  
It belongs to  if its rank is 0, i.e.\ it is either a constant 
(defined or undefined) strategy or a strategy whose all possible 
(basic type) queries involve only variables. This is because  is closed under 
applications, and therefore -substitution cases of such queries 
satisfy (*). 
(That, in fact, all finitary strategies belong to~ 
can be concluded from the following considerations.) 

Then we show by induction on the type of  that 

Indeed, the base case  holds by definition. 
For  and any variable  
we have , , 
and hence  satisfies (*) by induction hypothesis. 
Then it follows straightforwardly that  itself satisfies (*). 

Finally, we show by induction on  that for any term  whose
participating strategies have rank   

The case : That (\ref{eq:finitary-2}) holds for atomic terms (variables 
and rank 0 strategies) was, in fact, shown above. The rest follows from 
the closure of  and therefore of the class of   satisfying 
(\ref{eq:finitary-2}) under applications. For  it again suffices to show 
(\ref{eq:finitary-2}) for atomic terms. The main case is finitary strategies  
of rank~ for which we should show that . We need to show that 
 satisfies (*) for any  of appropriate types. 
But this follows from the fact that  asks a bounded number of queries , , 
involving only variables  and 
strategies of the rank  and which therefore satisfy 
(\ref{eq:finitary-2}) by induction hypothesis, 
and hence  so that all such 
 satisfy~(*). 
Finally, this implies that  satisfies~(*). 
Indeed, from our requirements on the computations  
each value in  should be used either by  or by (its child strategies from) the  
subcomputations generated by . Thus,  should have bounded both 
the length and participating numerical values. This concludes the proof.\qed



\section{Fully Abstract Model for \texorpdfstring{}{PCF+}}
\label{sec:full-abstr-PCF+}

\noindent
For the case of , let us consider the more general 
concept of a \emph{nondeterministic system of 
strategies} \cite{Saz76SMZH} extending the Definition~\ref{def:strategies}
of sequential (deterministic) strategies by letting 

and adding the clause (third possibility for )
\begin{enumerate}[(1)]
\stepcounter{enumi}
\stepcounter{enumi}
\item  (\emph{the nondeterministic state of computation}).
\end{enumerate}
The nondeterministic state can be also considered as representing a specific query 
``''. The ``correct'' answer from the Oracle to this query 
is \emph{any} numerical value . 
However, such an extended concept of nondeterministic strategies 
is too general to grasp  
(unlike  --- the case which we will not consider 
in full detail). 
Thus, we need to appropriately restrict nondeterministic strategies 
to fit them with . 


\subsection{Wittingly Consistent Strategies}
\label{sec:wittingly-cons}

\noindent
First, without restricting generality we can assume that the 
requirements from Section~\ref{sec:additional-requirements} 
hold also for non-deterministic systems of strategies. 
Further, a pair of prompts (computational histories) 
 and  
for a strategy  is called -\emph{consistent}  
if they do not contain different answers 
to the same query by , i.e.\ if 
for all proper initial segments 
 and , 
 
In this paper, we will additionally require for systems of 
nondeterministic strategies  that they 
should be 
\emph{wittingly consistent} (\cite{Saz76t}, Chapter II, \S4). 
This means 
that, for any  and any -consistent pair 
of prompts  and , the strategy  cannot output two contradictory 
final results:

Sequential (deterministic) systems of strategies are evidently 
wittingly consistent (assuming the first requirement 
of Section~\ref{sec:additional-requirements}). 





Consider one example of such a wittingly consistent 
strategy  computing 
a parallel conditional monotonic function 
 
defined in Section~\ref{sec-seq-stra-def-examples}: 

, 

p=\?,  

x=\?, 
y=\?, 

, 
, 

x=\?, 
y=\?, . 

\noindent
In all other cases  is undefined. 

Consider also 
\emph{parallel disjunction}  
(used in infix notation) 

It is parallel (as well as \PIF) because it is \true\ if 
\emph{any one} of the arguments is \true\ 
while the other may even be undefined~(). Thus, there is no 
sequential way of evaluating the arguments, but an appropriate 
wittingly consistent strategy exists. 


For wittingly consistent strategies, 
the \emph{interpreted (nondeterministic) computation} is defined as before 
in Section~\ref{sec:seq-stra-den-sem-formal-def}.  
All the successful computations under 
\emph{any} given interpretation of strategies  should 
evidently lead to a unique value  independently of 
the non-deterministic steps. This gives rise, as before, to 
the concept of the (least correct and naturally defined) denotational semantics 
 for any system of wittingly consistent strategies. 
As to operational semantics, , we can easily show 
that the (appropriately defined as in Section~\ref{sec:operational-sem-formal}) 
system of strategies 
 is wittingly consistent if 
 is.

In the most general case of nondeterministic strategies 
(the least) denotational semantics may give rise to , 
the ``over-defined'' or ``contradictory'' value,  
for some ``contradictory''  because for some 
values  the interpreted computation of the value 
gives different final results in  for various paths of the computation. 
A weaker concept of consistency \cite{Saz76SMZH,Saz76t} of a system of nondeterministic 
strategies (in a structure) means the mere possibility of giving 
(the least) denotational semantics with  
for all strategies in  independently of the ways of computation. 
Witting consistency is a kind of guarantee, or sufficient condition, of the 
existence (say, in ) of ``non-contradictory'' 
semantics. Otherwise this existence 
would be either somewhat accidental and unpredictable, 
or just fail, because of nondeterminism. 




The theory for sequential strategies vs.\ \PCF\ considered so far can be 
naturally and, in many cases, straightforwardly 
extended for the case of wittingly consistent nondeterministic strategies 
vs.\  (), 
giving a fully abstract and naturally continuous order extensional 
model  
consisting exactly of all functionals definable in 
  all monotonic functions 
\mbox{}. 
(Corresponding results for , instead of the case 
 considered here for the first time, 
were announced without proof 
in \cite{Saz76t}.) 
This model can be defined, like , both inductively, level-by-level 
of types, 
and as a quotient  of the universal system  
of wittingly consistent strategies. The universal functionals 
 for each type 
can be constructed as for  (and ) for sequential functionals. 
This gives a reasonable answer to a 
question of Longley and Plotkin in \cite{Longley-Plotkin} 
concerning the mere possibility of a general approach 
to a fully abstract model for  with 
definability properties like the above. 
(Cf. Introduction for a quotation.) 

Everything for wittingly consistent strategies goes almost as smoothly 
as for sequential strategies, except we should make some additional 
technical 
considerations needed for the definability of universal functionals 

with the range being the whole~. 
(We mean additional considerations 
in comparison with the case of sequential functionals and \PCF\ 
\cite{Saz76AL} --- what is unchanged 
is presented below without proof.) 
Note, that universal functionals for 
a (countable) fully abstract term model for  
(of types , rather than ) 
have also been defined in \cite{Longley-Plotkin}. But we use our old 
technique for \PCF\ and 
(here --- for the model ) 
with appropriate additions. 

Constructing  is the primary goal of 
Section~\ref{sec:full-abstr-PCF+}. 
However, for better understanding both of the nature of wittingly consistent 
strategies, and that witting consistency is an essential restriction, 
it makes sense to consider first some example demonstrating 
that  is not -complete and thus does not coincide with 
the standard continuous model . 
Otherwise, the reader can well skip the following subsection. 








































\subsection{\texorpdfstring{}{W} is not 
\texorpdfstring{}{omega}-Complete}
\label{seq:non-complete}

\noindent
Although the undefinability result of this section is essentially 
well-known (in slightly different form) for the case of  
(\cf\ \cite{Plotkin77,Saz76d,Saz76AL}), 
it makes sense to present its proof in terms of wittingly consistent 
strategies which was not published yet, except in~\cite{Saz76t}. 
Applied to the case of , this implies that 
 is \emph{not -complete} and, therefore, 
it is a \emph{proper subset} of . 

Let us define functionals  and , 
, with  any argument for them, 
by the following equation: 

Recall that  defines exactly all computable 
functionals (computable --- in terms of recursive enumerability of finite approximations) 
in the standard continuous model , and, 
by using arbitrary (actually, only strict) 
functions 
, 
this language defines all continuous functionals of this model 
\cite{Plotkin77,Saz76d,Saz76AL}. 
On the other hand, each  is definable in  by using 
the (wittingly consistent) parallel disjunction : 

and therefore . 
Moreover,  (pointwise), but 
 because of the following
\begin{prop}
 
is not a wittingly consistent functional 
and hence not definable in . 
In particular,  is not -complete at the level 2. 
\end{prop}
\proof  
Let us assume on the contrary that  holds 
for some strategy  of the type 
\mbox{} from a wittingly consistent system of strategies 
. We may consider that 
all queries asked by the strategy  computing  have the canonical form 
``'' for some  in . 

For each , define 
 by . 
Let us show that \emph{for various , the sets of sub-tasks in any successful 
interpreted computations for  do not intersect}.
To this end, consider two successful interpreted computations of  
for  and , , both giving a result (actually  
by ), and 
assume on the contrary that the initial task ``'', 
for  and , is reduced to the same task ``'' 
(i.e., with the same ) 
in the course of these two computations. 
As both the computations should continue further to the result, 
we would have 
, , 
both actually  by the definition of  and ,  
and hence 
, 
contrary to . 

Now, let us consider an arbitrary -prompt  giving a defined boolean result 
\linebreak
, and show that the only possibility is .  
Indeed, the corresponding -computation along 
involves only finite number of queries 
( for  initial segments of )
which, 
by the above consideration, 
may also participate in successful interpreted computations of  
only for a finite number of .  Therefore, for  outside this 
finite set, -prompt  
is -consistent with the -prompt  arising 
in some interpreted computation of the value  
giving a defined result, 
which should be  by the assumption . 
From the definition of witting consistency, 
it follows that , as required. 

Thus, the values of 
 for any predicate  
may only be  or , and  cannot be  
(for which  is possible), contrary to the main assumption.\qed


\bigskip


\noindent
As to sequential functionals, the 
increasing sequence , 
 analogous to  
cannot demonstrate that  is not -complete because 
this sequence 
has the limit  existing also in , as we 
have shown in Section~\ref{sec-seq-stra-def}. 
Thus, demonstrating the incompleteness of  
requires the more subtle considerations of \cite{Normann2004} at the level 3. 




It is useful to note that \emph{strictly sequential functionals} of
the type , i.e.\ those computable by the
sequential strategies asking only simple queries of the form
``'' with , \emph{are closed under -limits}.
(Hint: first note, that if  is strictly sequential then so is any
, and consider limits of finite, in the sense of
, strictly sequential functionals.)  Further, for
a functional of the type  or , \emph{to be strict {\em(see below)} and sequential is
equivalent to be strictly sequential}.  Moreover, looking for limits
of sequences of more complicated, non necessarily strict sequential
functionals of this type (based on the general queries of the form
``\mbox{}'') will also fail.  In fact, the minimal level of
 where non--completeness holds is 3
\cite{Normann2004}.


\subsection{Definability in \texorpdfstring{}{PCF+} 
of Strict Continuous Functionals 
\texorpdfstring{\mbox{}}{F:(i->i)->i}}
\label{sec:strict-functionals}


\noindent
Here we will consider strict level~2 functionals. 
We will also rely on some definability concepts 
and ideas due to Plotkin \cite{Plotkin77}.  
A similar definability technique was assumed also in 
the corresponding results announced in 
\cite{Saz76d,Saz76AL}, but without 
presenting details and proofs. 

A function  is called \emph{strict} if 
.
Given any 
,  
, , with all  different, 
let 

denote a \emph{strict (naturally) finite function} in  
such that 

or, equivalently, 

Recall that more general \emph{finite} (not necessarily strict) functions 
in  are defined by such tables with 
 arbitrary elements of , possibly , 
satisfying 
a natural consistency requirement, and defined by equation~(\ref{eq:fin}), 
and analogously (by induction) for finite elements of 
arbitrary  with 
 and  being finite elements, respectively, 
of  and . 
Note, that any (constant) function in  
such that  is also 
finite ( for some ), but not strict. 
Let , , be an \emph{effective numbering} of all 
strict finite functions in  
such that, given , the numbers  (all ) can be recovered. 

We can also consider \emph{strict finite functionals} of the form 
 
with  strict finite and :
 
In general, any continuous functional  is 
called \emph{strict} if, 
for all \iota\arr\iota, the coincidence of  and  
on all type  
arguments  implies . 
Equivalently,  is strict if for each  
there exists a strict (and therefore exists a strict finite) 
 such that . 

\begin{lem}\label{lemma:strict-def}\hfill
\begin{enumerate}[\em(a)]
\item All strict functionals  are 
(uniformly) definable in  from strict 
functions of type 
 and are, in fact, wittingly consistent. 

\item The same holds for the functionals 
 
which are strict in the first type  argument 
and either constant or strict in the second 
type \mbox{} argument
{\em(and can be identified with arbitrary sequences 
, 
, of constant or strict functionals)}. 
\end{enumerate}
\end{lem}
\proof\hfill  \begin{enumerate}[(a)]
\item First, note that parallel disjunction can be generalized 
to \emph{bounded quantification}. This can be defined in  
recursively (for ): 

In particular, . 
This allows us to define in  a functional 

assuming that 
 and 
 is understood as a strict predicate. 
Here we rely on the simple fact that the number  and functions 
 and  of  are computable and \PCF-definable from . 
The value of  is \true\ if the strict finite function 

is inconsistent with ;  if  
; 
otherwise, . Also, . 






Now, any strict  can be evidently represented as   
, or as 

with appropriate strict one place numeric functions  
such that . Although we can take , 
we will need the general case. Note that for arbitrary  and  
this lub may not 
exist if  and  
are consistent, but  
for some . 
We can evidently assume that  and  are 
defined () on the \emph{same} 
initial segment of , finite or the whole . 
(In fact, only two cases suffice here: the whole , or 
the empty segment, if . 
But the case of an arbitrary segment will be needed later.)
Then for arbitrary  and  
for which the lub  exists
we have  if , 
and
also 
 if . 
Then  is also definable 
in  recursively on  and thus by using the least fixed point 
operator  as well as 
the parallel conditional function : 

Let us show that the two definitions are equivalent (). 
First note that 
 satisfying the first definition should also satisfy this formula 
with  replaced by , thus giving . 
Indeed, the value of the right-hand side, when defined, is equal either to 
, if 
, 
or to 
. 
In both cases the left-hand side, , has evidently the same value. 
For the converse, , it suffices to show that 
for the second definition 
we have 
, 
for all  with defined , 
assuming that the above union does exist, and  and  are 
defined on the same initial segment of . 
This can be shown by induction on : 
if  contradicts  then 
; 
otherwise, , and hence again  
. 


We can define, in \PCF, 
the \emph{correction operator}  
with  and  
by restricting , and the same 
for , for the maximal  (possibly ) such that 
the union 

exists. 
Evidently, if the unrestricted union exists for the original 
 and  then  and . 
This, together with the definition of , 
constructs, in , a \emph{universal functional} 

for all strict continuous functionals of the type .  


Finally, for , the functional 
 can be computed by the strategy  whose behaviour 
is definable from the functions  and  as follows: 

where 
.
It is easy to see that  is wittingly consistent. 




\item[(b)] 
Define, essentially, 

This leads to an universal functional for the required class of 
type  functionals.\qed
\end{enumerate}

\noindent
These definability considerations were devoted   
mainly to strict type 
\mbox{} 
functionals of the standard continuous model . 
For the monotonic non-dcpo model  we have isomorphisms   
, 
(and also for all level 1 ),
but 
, 
(by Section~\ref{seq:non-complete}). 
(The same holds for  and , 
whereas 
 is strictly embeddable in 
 which is also strictly embeddable in 
 and consisting, thereby, of continuous 
functionals only.) 
Moreover,   contains all (but not only) 
strict continuous functionals. 
The latter holds because the above Lemma~\ref{lemma:strict-def} 
on the (relative) definability of strict continuous functionals holds 
in the -model , as well as in .




\subsection{On Denotational Semantics of Wittingly Consistent Strategies}
\label{sec:den-sem-wit-strat}


\noindent
Let us look again at denotational semantics of 
any wittingly consistent 
system of strategies . 


For any 
strategy  of the type 
  
define a 1-1 computable enumeration 
of the basic terms  
, 
, over  with variables from the canonical list 
 =  only 
which contains all queries to the Oracle 
potentially ``asked'' by the strategy .  

For any such system , let us construct  
a system of  
continuous functionals 
, ,  
such that the denotational 
semantics  of the system  
in the model  (respectively, in ) 
may be equivalently defined 
(instead of explicitly using the interpreted computations) 
as the least solution of the system of equations\footnote{This means that the fixed point equation 
 considered formerly 
can be represented in this form for appropriate . 
}

Here  are ranging over  
(or, alternatively, over ) 
and, for all ,  are considered 
as strict functions in . 

The required functionals  can be defined as 
 if, and only if, for some 
 the following two conditions hold:
\begin{enumerate}[(1)]
\item 
 (with  for all initial segments 
 of ), and 
\item
for all , 
if  () then .
\end{enumerate}
This definition is correct ( does not depend on the choice of 
) because the system of strategies  is 
wittingly consistent. 
Indeed, let  satisfy the analogous condition 
as  with . It follows that 
the pair  is not -consistent and for some proper 
initial segments  and ,  
 and 
 --- the contradiction.

The functional  is also computable by a strategy 
 
\linebreak
induced by : . 
It behaves in the same way as , except that 
instead of the queries 
``'' it asks ``'' for . 
The resulting system of 
strategies is denoted as . 
Evidently,  is sequential/wittingly 
consistent if ~is. 

The equation (\ref{eq:den-sem-w}) and its versions 
(\ref{eq:den-sem-w-special}) and (\ref{eq:den-sem-w-special-u}) below 
considerably simplify the corresponding equation in \cite{Saz76AL}\footnote{for a functional denoted there as 
} 
for the sequential case.
They will be needed for the construction in  of a universal 
functional  in Section~\ref{sec:univ-wittingly-consis}.  

\subsection{Definability of \texorpdfstring{}{G-M-m(f)}}
\label{sec:def-of-F}

\noindent
Without restricting generality we can consider that 
the given wittingly consistent 
system of strategies  
is countable. 
Elements of  may be numbered, or even identified with 
the natural numbers: . Our current goal is to define 
the functional 
 in \PCF from some type 
 numerical functions 
which can be computed from  (so that if  
is effectively computable, such are these numerical 
functions, too). 


According to the strategy  in  or  in 
, the functional  is 
evidently either constant  or strict. 
Therefore  is definable 
in  from some strict type  functions 
by Lemma~\ref{lemma:strict-def} (b). 
Note, that the constants , the (partial) predicate  
`` is a constant functional '' 
and the corresponding numerical functions  

for the strict  
used in the Lemma are effectively computable from  and . 






\subsection{A Universal Functional for Special Wittingly Consistent 
Systems of Strategies}
\label{sec:univ-special}

\noindent
Let us fix an arbitrary Basic-term  
constructed from 
\begin{enumerate}[]
\item 
symbols of the language \PCF,  
\item
a variable  and a fixed list of variables
 of the same type 
, and 
\item
a fixed list of variables 
. 
\end{enumerate}
Let us also fix a set  
of strategies (the constant symbols) with all  of the same type . 
Consider the class  of all wittingly consistent systems of strategies 
, with  fixed as above  
and  varying, but with the ordinary reductions for the 
constants of \PCF\ and such that the terms  
can only be -reduced to terms of the form 

with the same fixed , 
where  is a numeral () and  
are arbitrary  natural numbers. 
The class of effective systems in  is called 
.
\begin{lem}
\label{lemma:KA-universal}
Both for  and , 
a universal functional 
\mbox{} 
for some superset of -computable functionals is definable in . 
Specifically,  ranges over some superset of -computable 
(-computable) type  functionals, 
if  ranges over all (respectively, all effective) strict monotonic 
functions of the type 
. 
In particular, each -computable 
(-computable) type  functional 
is definable in  from some (effective, in the case of ) 
. 
\end{lem}
\proof 
The above recursive equation (\ref{eq:den-sem-w}) becomes now 

with  ranging over  (respectively, over ).
It is inessential that  here has a slightly different 
type than in~(\ref{eq:den-sem-w}). 
So, it is still definable in  from some type  strict 
functions computable from . 

Now, consider a variable  and the following 
version of the above recursive equation 

By using combinators  and  to simulate lambda abstraction, and 
the least fixed point combinator  of an appropriate type, 
this gives rise to a -term 
 
(corresponding to the above variable )
depending on some, actually strict, functions  which 
were involved in the -definition of . 
By some trivial encoding this gives rise to the required 
-term  
involving no variables  at all.\qed


\begin{note}\em
Lemma~\ref{lemma:KA-universal} may be easily generalized to the case 
of any finite number of terms  
with the same variables, giving rise to the universal functional 
 for -computable functionals 
of the type  . 
\end{note}


\subsection{A Universal Functional for all Wittingly Consistent 
Functionals of a Given Type}
\label{sec:univ-wittingly-consis}

\noindent
The general universal -definable functional 
, or its version 
, for all wittingly consistent 
functionals of any given type 
can be obtained from  for suitable  
and  by using only \PCF. 
Here we also employ the fact that, without restricting generality, 
we can consider only systems of strategies  asking queries 
in the canonical form (\ref{eq:canonical}). 
Given any such , this allows us to ``concentrate'', by some encoding 
most of the strategies descendant to  
(having levels  the level of ) 
in a finite number of types, and, even in only one type , 
(and, analogously, to further restrict 
the form of queries). That is, the general wittingly 
consistent systems of strategies can be 
reduced to the special systems of some class  considered above. 
We omit the details which are presented in \cite{Saz76AL}. 



\section{Conclusion}
\label{sec:conclusion}

\noindent
A generalized non-dcpo domain theoretic framework for finite type functionals 
which are not necessarily closed under directed limits was presented in this paper 
in terms of pointwise (natural) least upper bounds, and corresponding 
natural continuity, natural algebraicity and natural bounded completeness 
properties. 

An inductive definition of a monotonic fully abstract 
model  for \PCF\ satisfying the above properties and 
based on a quite general concept of 
sequential strategies was also given. 
This model consists hereditarily of all finite type functionals 
computable by the sequential 
strategies which also prove to be uniformly definable in \PCF\ from 
(strict)
functions of the type . 
This is the universality property also characterising 
precisely the expressive power of \PCF. 
Thereby we have demonstrated 
that the old concept of sequential strategies \cite{Saz76SMZH,Saz76AL} 
can be used quite naturally for defining the fully abstract 
model along with 
the more recent game approach 
\cite{Abramsky-Jagadeesan2000,Hyland-Ong2000,Nickau96}. 
The uniqueness of  was also shown. 
The essential feature of our definition is its straightforward, 
inductive and computational character. 
For each level we just hereditarily restrict the class of monotonic 
functionals to those that are sequentially computable. 
However, either the correctness proof of the induction step of 
this definition, if based on (\ref{eq:dom}), 
or (in the case of alternative definition based on (\ref{eq:dom'}) with a simpler 
correctness) proving the main properties 
of  is more complicated 
and requires developing a general and quite involved theory of all 
computational strategies 
with their generalized operational semantics 
coherent with the denotational one. 
In this way the above ``natural'' 
non-dcpo domain theoretic continuity and other properties of 
 are also shown. 

Quite analogous inductive definition of a fully abstract model 
 for ``\mbox{parallel OR}'' satisfying 
the above non-dcpo domain theoretic properties 
+ the universality property relative to  
was also briefly outlined in terms 
of wittingly consistent nondeterministic strategies.  
The model  proves to be not -complete, as well as  
the model of sequential functionals  
for which this was shown in \cite{Normann2004}.  

As the future perspective, it would be interesting 
to develop a game semantics version of wittingly consistent strategies. 
Recall also several domain theoretic hypotheses from Section~\ref{sec:natural} 
on the model  (equally applicable to ) 
related with the fact that it is not -complete, as well as the 
hypotheses concerning effectiveness of representation of naturally finite functionals 
in Section~\ref{sec:efficiency} and the related Notes~\ref{note:finite-simeq-finitary} 
and~\ref{note:closure-under-appl-of-finite-strategies} on finite and finitary strategies. 


\section*{Acknowledgement} 

\noindent
The author is grateful to Gordon Plotkin 
for fruitful discussions on the subject, to Achim Jung for his comments on 
the domain theoretic part,  
and to Michael Fisher for his kind help in polishing the English. 
Thanks to the referees for numerous useful comments helping to considerably improve 
the exposition and in particular for the amending Definition~\ref{def:bbQ} 
which made its correctness proof just straightforward. 

\bibliographystyle{plain}
\bibliography{lmcs-PCF}















\appendix 
\section{Universal System of Sequential Strategies 
\texorpdfstring{}{}}
\label{appendix:univ-sys-strategies}

\newcommand{\BT}{\mbox{BT}_\Box}
\newcommand{\qq}{q}
\newcommand{\pp}{p}
\newcommand{\type}{\textrm{\bf type}}
\newcommand{\Types}{\textrm{Types}}
\newcommand{\Erase}{\Box}

\noindent
Here we give a construction of the typed version of the universal system of strategies 
 \cite{Saz76SMZH} 
(with the details which are a bit more complicated than in the untyped case 
presented formerly only in \cite{Saz76t}). 

Let  consist of duplicates of natural numbers  
so that  is disjoint with  (and with any other set considered below), 
and  be the ``empty'' constant (placeholder for a strategy 
from~) of a type  for each~. 
Then, according to Section~\ref{sec-seq-stra-def-prelim}, 
 
is the set of basic terms (possibly with variables) over 
the set of constants . 

Define  (recursively) as the set of all functions 

(considered as partial due to ) 
satisfying the following conditions for all  and 
:
\begin{enumerate}[(1)]
\item 
.
\item
. 

\noindent
We write  if  and take 
.  
If we have a map  
(i.e.\  is undefined on ) then writing 
 also means ``assignment'' of the type  to , i.e.\ 
adding  to the graph of  so that 
 is a map with . 
\item
 for non-empty . 


\item
{\bf If}  and  {\bf then} all variables in  are 
from the canonical list  for the type of  
(the condition similar to that in 
Definition~\ref{def:strategies}(\ref{item:strategies:variables})).

\item
{\bf If}  (with ) 
{\bf and}  contains  occurrences 
of the symbol  
{\bf then} 
, 
{\bf otherwise}, if the -th occurrence of  in  has the type 
 then 

\end{enumerate}
More precisely, we take the set  to be the \emph{largest} 
one whose elements  satisfy the above conditions, i.e.\ the largest set  
satisfying 
 
where  is the (universally quantified by  and ) 
conjunction of the above conditions (1)--(5), which is 
monotonic on . 
(Note that the least such set is just empty. 
Thus, the definition of  is, in fact, \emph{co-recursive}.) 

Define a function , 
making the pair  a system of strategies, 
by taking for all 
 and 

Here  
is the term obtained as the result of the substitution 
in  of the strategies , 
respectively, in place of the first, second, etc.\ occurrences of  in , and 
 are the types of these occurrences. 


Our goal is to show the universality of the defined system of strategies 
. First, define , for any , 
as the -th occurrence of an element from  in term~. If  has  
occurrences of elements from  then  is undefined. 
(If~ then  is the -th occurrence of a -symbol in .)
Denote by 
 the result of ``erasing'' in  of all occurrences of elements 
from , i.e.\ the result of replacement of all such occurrences by the symbol 
 (of appropriate type). 
Evidently, 

(and dually for ). 
It will also be convenient to define  for  
and  for . 

Given any system of strategies  and , define
two functions 
 
by letting 

and, iteratively, for any 
,  and ,  
0.5em]
\bMM_m(u\bj w)&=&\left\{
                      \begin{array}{lll}
                      \bMM_{m_j}(w), & \textrm{if} & \MM(m,u)=B\in\textrm{Basic-Terms}(M)\\
                                     &             &\textrm{and } m_j=\mu_j(B),\\
                      \Undef,  & \textrm{if} & \MM(m,u)\not\in\textrm{Basic-Terms}(M) \\
                      & & \textrm{or }\mu_j(B)\textrm{ is undefined},
                      \end{array}
                 \right. \
For any system of strategies  the elements  of the set  
satisfy the conditions (1)--(5) above. Therefore  
(preserving types). 
\begin{lem}\label{lemma:hom-universal}
If  is a homomorphism then 
 for all . 
\end{lem}
\proof
First note that for all  and  the equality 

evidently holds. 
It follows that 









\qed
\begin{lem}\label{lemma:universal}
 for all . Therefore 
. 
\end{lem}
\proof
As  
and , 
it evidently suffices to show that, for  
and , 

This equality is proved by induction on the number of occurrences of symbols from  
in the string . If  
then the equality evidently follows from (\ref{eq:univ-system-map}) and (\ref{eq:bMM}). 
Let  where ,  and . 
Two cases are possible. 
\begin{enumerate}[(1)]
\item
. Then, using (\ref{eq:univ-system-map}), 
 
for  and an appropriate type ,
and hence  
according to (\ref{eq:bMM}). 
The number of occurrences from  in string  is less than in . 
Therefore the formula (\ref{eq:lemma:universal}) is applicable by induction:

Since , this gives exactly the equality 
(\ref{eq:lemma:universal}). 

\smallskip

\item
. Then  and therefore 
 by (\ref{eq:bMM}). Then  
entails  by the definition of . Therefore 
(\ref{eq:lemma:universal}) holds in this case as well.\qed
\end{enumerate}
\begin{thm}\label{th:universal-system}
 is the unique up to isomorphism universal system of strategies. 
For any system , the map  is the unique 
homomorphism .
\end{thm}
\proof
The uniqueness of the homomorphism follows from Lemmas~\ref{lemma:hom-universal} 
and~\ref{lemma:universal}. 
For, if  is a homomorphism then 

for any . 

To establish that  is a homomorphism we need to show that 
for all  and  that 
\begin{enumerate}[(i)]
\item , and
\item . 
\end{enumerate}
Here we assume that  and , . 
The first implication is easy. 
In the second, we need to show by the definition of  that 
, and , 
. Both equalities follow from (\ref{eq:bMM}). The first is easy. For the second, 
we get  
for all  and , 
and apply the erasing operator~. \qed


\end{document}
