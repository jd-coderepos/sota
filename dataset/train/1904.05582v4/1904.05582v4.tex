\documentclass{article}
\usepackage{chapterbib}






\usepackage[final,nonatbib]{neurips_2019}



\usepackage[utf8]{inputenc} \usepackage[T1]{fontenc}    \usepackage{hyperref}       \usepackage{url}            \usepackage{booktabs}       \usepackage{amsfonts}       \usepackage{nicefrac}       \usepackage{microtype}      \usepackage{float}


\usepackage{microtype}
\usepackage{graphicx}
\usepackage{subfigure}
\usepackage{booktabs} \usepackage{amssymb}
\usepackage{amsmath}
\usepackage{nccmath}

\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage{ragged2e}
\usepackage{hyperref}



\newcommand\textbox[1]{\parbox{.333\textwidth}{#1}}









\usepackage[T1]{fontenc}    \usepackage{hyperref}       \usepackage{url}            \usepackage{booktabs}       \usepackage{amsfonts}       \usepackage{nicefrac}       \usepackage{microtype}      \usepackage{float}
\usepackage{makecell}
\usepackage{multirow}

\usepackage{microtype}
\usepackage{graphicx}
\usepackage{subfigure}
\usepackage{booktabs} \usepackage{amssymb}
\usepackage{amsmath}
\usepackage{nccmath}

\usepackage{algorithm}
\usepackage{algorithmic}

\usepackage{hyperref}



\newcommand{\ve}[1]{\mathbf{#1}} \newcommand{\ma}[1]{\mathrm{#1}} 

 \newcommand{\km}[1]{{\color{red}[km: #1]}}
\newcommand{\rbg}[1]{{\color{blue}[rbg: #1]}}
\newcolumntype{x}[1]{>{\centering\arraybackslash}p{#1pt}}

\newcommand{\bd}[1]{\textbf{#1}}
\newcommand{\app}{\raise.17ex\hbox{$\scriptstyle\sim$}}
\newcommand{\ncdot}{{\mkern 0mu\cdot\mkern 0mu}}
\def\x{$\times$}
\newcolumntype{x}[1]{>{\centering\arraybackslash}p{#1pt}}
\newcommand{\dt}[1]{\fontsize{8pt}{.1em}\selectfont \emph{#1}}
\newlength\savewidth\newcommand\shline{\noalign{\global\savewidth\arrayrulewidth
  \global\arrayrulewidth 1pt}\hline\noalign{\global\arrayrulewidth\savewidth}}
\newcommand{\tablestyle}[2]{\setlength{\tabcolsep}{#1}\renewcommand{\arraystretch}{#2}\centering\footnotesize}
\usepackage{tabularx}


\begin{document}

\title{Recurrent Space-time Graph Neural Networks}



\makeatletter
\newcommand{\printfnsymbol}[1]{\textsuperscript{\@fnsymbol{#1}}}
\makeatother

\author{Andrei Nicolicioiu\thanks{Equal contribution.}, \hspace{1.5mm}Iulia Duta\printfnsymbol{1}
  \\
  Bitdefender, Romania\\
  \texttt{{anicolicioiu, iduta}@bitdefender.com} \\
   \And
   Marius Leordeanu \\
   Bitdefender, Romania \\
\fontsize{6pt}{7pt}Institute of Mathematics of the Romanian Academy \\
   University "Politehnica" of Bucharest \\
   \texttt{marius.leordeanu@imar.ro} \\
}

\maketitle
\begin{abstract}
 Learning in the space-time domain remains a very challenging problem in machine learning and computer vision. Current computational models for understanding spatio-temporal visual data are heavily rooted in the classical single-image based paradigm. It is not yet well understood how to integrate information in space and time into a single, general model. We propose a neural graph model, recurrent in space and time, suitable for capturing both the local appearance and the complex higher-level interactions of different entities and objects within the changing world scene. Nodes and edges in our graph have dedicated neural networks for processing information. Nodes operate over features extracted from local parts in space and time and over previous memory states. Edges process messages between connected nodes at different locations and spatial scales or between past and present time. Messages are passed iteratively in order to transmit information globally and establish long range interactions. Our model is general and could learn to recognize a variety of high level spatio-temporal concepts and be applied to different learning tasks. We demonstrate, through extensive experiments and ablation studies, that our model outperforms strong baselines and top published methods on recognizing complex activities in video. Moreover, we obtain state-of-the-art performance on the challenging Something-Something human-object interaction dataset.
\end{abstract}
\section{Introduction}
\label{introduction}
Video data is available almost everywhere. While image level recognition is better understood, visual learning in space and time is far from being solved. The main challenge is how to model interactions between objects and higher level concepts, within the large spatio-temporal context. For such a difficult learning task it is important to efficiently model the local appearance, the spatial relationships and the complex interactions and changes that take place over time.

Often, for different learning tasks, different models are preferred, such that they capture the specific domain priors and biases of the problem~\cite{battaglia2018relational}.  Convolutional neural networks (CNNs) are preferred on tasks involving strong local and stationary assumptions about the data. Recurrent models are chosen when data is sequential in nature. Fully connected models could be preferred when there is no known structure in the data. Our recurrent neural graph efficiently processes information in both space and time and can be applied to different learning tasks in video.



We propose Recurrent Space-time Graph (RSTG) neural networks, in which each node receives features extracted from a specific region in space-time using a backbone deep neural network. Global processing is achieved through iterative message passing in space and time. Spatio-temporal processing is factorized, into a space processing stage and a time processing stage, which are alternated within each iteration. We aim to decouple, conceptually, the data from the computational machine that processes the data. Thus, our nodes are processing units that receive inputs from several sources: local regions in space at the present time, their neighbor spatial nodes as well as their past memory states (Fig.~\ref{fig:main_graph_figure}). 

\noindent \textbf{Main contributions.}
We sum up our contributions into the following three main ideas:

\begin{enumerate}
    \item We propose a \textbf{novel computational model} for learning in spatio-temporal domain. Space and time are treated differently, while they function together in complementary ways. Our model is \textbf{general} and could be applied to various learning problems. It could also be used as \textbf{a processing block} in combination with other powerful models.

    \item We \textbf{factorize space and time} and \textbf{process them differently} within a unified neural graph model from an unstructured video. In extensive ablation studies we show the importance of each graph component and also demonstrate that different temporal and spatial processing is crucial for learning in space-time domain. Through \textbf{recurrent} and factorized space-time processing
    our model achieves a relatively \textbf{low computational complexity}. 
    
    \item We introduce a new synthetic dataset, with complex interactions, to analyse and evaluate different spatio-temporal models. We obtain a performance that is superior to several powerful baselines and top published methods. More importantly, we obtain \textbf{state-of-the-art} results on the challenging Something-Something, real world dataset.
    
\end{enumerate}

\begin{figure}[t!]
\begin{center}
\centerline{\includegraphics[width=1.0\columnwidth]{piramida10.png}}
\caption{The RSTG-to-map architecture: the input to RSTG is a feature volume, extracted by a backbone network, down-sampled according to each scale. Each node receives input from a cell, corresponding to a region of interest in space. The edges between different nodes represent messages in space, the red links are spatial updates, while the purple links represent messages in time. All the extracted (input to graph) and up-sampled features (output from graph) have the same spatial and temporal dimension $T \times H \times W \times C$ and are only represented at different scales for a better visualisation.}
\label{fig:main_graph_figure}
\end{center}
\vskip -0.2in
\end{figure}

\paragraph{Relation to previous work:}
Iterative graph based methods have a long history in machine learning
and are currently enjoying a fast-growing interest~\cite{battaglia2018relational, pmlr-v70-gilmer17a}. Their main paradigm is the following: at each iteration, messages are passed between nodes, information is updated at each node and the process continues until convergence or a stopping criterion is met. Such ideas trace back to work on image denoising, restoration and labeling~\cite{besag1986statistical,hummel1983foundations,geman1984stochastic,geman1986markov}, with many inference methods, graphical models and mathematical formulations being proposed over time for various tasks~\cite{lafferty2001conditional,kumar2006discriminative,pearl2014probabilistic,ravikumar2006quadratic,schaeffer2007graph,leordeanu2012unsupervised,ng2002spectral}.

Current approaches combine the idea of message passing between graph nodes, from graphical models, with convolution operations. Thus, the idea of graph convolutions was born. Initial methods generalizing conv nets to the case of graph structured data~\cite{DBLP:journals/corr/BrunaZSL13_bruna_lecun_spectral,henaff2015deep,defferrard2016convolutional} learn in the spectral domain of the graph. They are approximated~\cite{kipf2017semi} by message passing based on linear operations~\cite{duvenaud2015convolutional} or MLPs~\cite{battaglia2016interaction}. Aggregation of messages needs permutation invariant operators such as max or sum, the last one being proved superior in \cite{xu2018how_powerful}, with attention mechanism~\cite{velickovic2018graph_gat} as an alternative.

Recurrence in graph models has been proposed for sequential tasks~\cite{li2016gated, jain2016structural} or for iteratively processing the input~\cite{dehghani2018universal_transformer, NIPS2018_7960_transformer}. Recurrence is used in graph neural nets~\cite{li2016gated} to tackle symbolic tasks with single input and sequential language output. Different from them, we have two types of recurrent stages, with distinct functionality, one over space and the other over time.

The idea of modeling complex, higher order and long range spatial relationships by the spatial recurrence relates to more classical work using pictorial structures~\cite{felzenszwalb2005pictorial} to model object parts and their relationships and perform inference through iterative optimization algorithms. The idea of combining information at different scales also relates to classic approaches in object recognition, such as the well-known spatial pyramid model~\cite{lazebnik2006beyond, he2015spatial_pyramid}.

Long-range dependencies in sequential language are captured in~\cite{vaswani2017attention} with a self-attention model. It has a stack of attention layers, each with different parameters. It is improved in~\cite{dehghani2018universal_transformer} by performing operations recurrently. This is similar to our recurrent spatial processing stage. As mentioned before, our model is different by adding another complementary dimension - the temporal one.
In \cite{NIPS2018_7960_transformer} new information is incorporated into the existing memory by self-attention using a temporary new node. Then each node is updated by an LSTM~\cite{hochreiter1997long_lstm}. Their method is applied on program evaluation, simulated environments used in reinforcement learning and language modeling where they do not have a spatial dimension. Their nodes act as a set of memories. Different from them, we receive new information for each node and process them in multiple interleaved iterations of our two stages.

Initial node information could come from each local spatio-temporal point in convolutional feature maps~\cite{NIPS2017_7082_ralational_cuburi, wang2018non_local} or from features corresponding to entities detected by external methods, such as objects~\cite{wang2018videos_gupta2, Ghosh2018StackedSG_B, tsai2019video_C} or skeletons~\cite{yan2018spatial_A}. Also, the approach in \cite{Baradel_2018_ECCV_orn} is to extract objects and form relations between objects from pairs of time steps randomly chosen. Different from that methods, our nodes are not attached to specific volumes in time and space. Also, we do not need pre-trained higher-level detectors, our model working on unstructured videos.

 While the above methods need access to the whole video at test time, ours is recurrent and can function in an online, continuous manner in time. 
 All space-time positions in the input volume are connected in~\cite{wang2018non_local, wang2018videos_gupta2,chen20182_a2nets}. In contrast, we treat space and time differently and prove the effectiveness of our choice in experiments.  
 A 1D convolution is used in \cite{yan2018spatial_A} to temporally connect only the nodes corresponding to the same skeleton joint and recently~\cite{Ghosh2018StackedSG_B} send messages between nodes corresponding to the same entities, while we recurrently update in time the state of each node. We could see our different handling of time and space as an efficient factorization into simpler mechanisms that function together along different dimensions. The work in \cite{szegedy2016incv2, chollet2017xception} confirm our hypothesis that features could be more efficiently processed by factorization into simpler operations. The models in~\cite{sun2015human_factorised, xie2018rethinking, tran2018closer} factorize 3D convolutions into 2D spatial and 1D temporal convolutions.

For spatio-temporal processing, some methods, which do not use explicit graph modeling, encode frames individually using 2D convolutions and aggregate them in different ways~\cite{karpathy2014large, yue2015beyond, donahue2015long}; others form relations as functions (MLPs) over sets of frames~\cite{zhou2018temporal_trn_torralba} or use 3D convolution inflated from existing 2D convolutional networks~\cite{carreira2017quo} .
Optical flow could be used as input to a separate branch of a 2D ConvNet \cite{simonyan2014two_stream} or used as part of the model to guide the kernel of 3D convolutions~\cite{NIPS2018_7489_trajectory}. To cover both spatial and temporal dimensions simultaneously, Convolutional LSTM~\cite{Shi2015ConvLSTM} can be used, augmented with additional memory~\cite{Wang2017ST-LSTM} or self-attention in order to update LSTM hidden states~\cite{wang2018eidetic}. 

\section{Recurrent Space-time Graph Model}
\label{model_section}
The Recurrent Space-time Graph (RSTG) model is designed to process data in both space and time, to capture both local and long range spatio-temporal interactions (Fig. \ref{fig:main_graph_figure}). RSTG takes into consideration local information by computing over features extracted from specific locations and scales at each moment in time. Then it integrates long range spatial and temporal information by iterative message passing at the spatial level between connected nodes and by recurrence in time, respectively. The space and time message passing is coupled with the two stages succeeding one after another. 

Our model takes a video and process it using a backbone function into a features volume $F~\in~\mathbb{R}^{T\times H \times W \times C}$, where $T$ is the time dimension and $H$,$W$ the spatial ones. The backbone function could be modeled by any deep neural network that operates over single frames or over space-time volumes.
Thus, we extract local spatio-temporal information from the video volume and we process it using our graph, sequentially, time step after time step. This approach makes it possible for our graph to also process a continuous flow of spatio-temporal data and function in an online manner.




Instead of fully connecting all positions in time and space, which is costly, we establish long range interactions through recurrent and complementary Space and Time Processing Stages. Thus, in the temporal processing stage, each node receives a message from the previous time step. Then, at the spatial stage, the graph nodes, which now have information from both present and past, start exchanging information through message passing.  Space and time are coupled and performed alternatively: after each space iteration $iter$, another time iteration follows, with a message coming from past memory associated with the same space iteration $iter$. The processing stages of our algorithm are succinctly presented in Alg. \ref{alg:main_model} and Fig. \ref{fig:processing_stages}. They are detailed below. The code for the full model can be found in our repository \footnote{\url{https://github.com/IuliaDuta/RSTG}}.

\begin{figure}
\begin{minipage}[!tp]{.52\textwidth}
\begin{algorithm}[H]
\begin{algorithmic}\vspace{1mm}
   \STATE {\bfseries Input:} Time-space features $F \in \mathbb{R}^{T\times H \times W \times C}$
\vspace{3mm}
   \REPEAT
    \vspace{-6mm}
    \STATE
    \begin{flalign*}
     & \mathbf{v}_i \gets extract\_features(F_t,i) \qquad &\forall i
\end{flalign*}
    \vspace{-4mm}
    \FOR{$k=0$ {\bfseries to} $K-1$}
\vspace{-4mm}
  \STATE
  \begin{flalign*} 
      &\mathbf{v}_{i} = \mathbf{h}_{i}^{t,k} = f_{time}(\mathbf{v}_{i},           \mathbf{h}_{i}^{t-1,k} ) &&\forall i\\
&\mathbf{m}_{j,i} = f_{send}(\mathbf{v}_j,\mathbf{v}_i) 
        && \forall i, \forall j \in \mathcal{N}(i)\\
      &\mathbf{g}_{i} = f_{gather}(\mathbf{v}_i, \{\mathbf{m}_{j,i}\}_{j \in \mathcal{N}(i)})  &&\forall i \\
      &\mathbf{v}_{i} = f_{space}(\mathbf{v}_i,\mathbf{g}_i)  &&\forall i 
\end{flalign*}

   \ENDFOR
\begin{flalign*}
      &\mathbf{h}_{i}^{t,K} = f_{time}(\mathbf{v}_{i},  \mathbf{h}_{i}^{t-1,K} ) \qquad\qquad &\forall i\\
      &t = t + 1
  \end{flalign*}
   \vspace{-5mm}
   \UNTIL{end-of-video}
    \vspace{2mm}
    \STATE $\mathbf{v}_{final} = f_{aggregate}(\{\mathbf{h}_{i}^{1:T,K}\}_{\forall i})$ 
\vspace{2mm}
\end{algorithmic}
 \caption{Space-time processing in RSTG model. 
}
   \label{alg:main_model}
\end{algorithm}
\end{minipage}
\begin{minipage}[!tp]{.35\textwidth}
    \begin{figure}[H]
\begin{center}
    \centerline{\includegraphics[width=1.0\columnwidth]{stages17.png}}
    \caption{ Two Space Processing Stages ($K=2$) from top to bottom, each one preceded by a Temporal Processing Stage. }


    \label{fig:processing_stages}
    \end{center}
    \vskip -0.2in
    \end{figure}

\end{minipage}
\end{figure}

\noindent \textbf{Graph Creation.}  We create N nodes connected in a graph structure and use them to process a features volume $F \in \mathbb{R}^{T\times H \times W \times C}$. Each node receives input from a specific region (a window defined by a location and scale) of the features volume at each time step $t$ (Fig. ~\ref{fig:main_graph_figure}). At each scale we downsample the $H \times W$ feature maps into $h\times w$ grids, each cell corresponding to one node. Two nodes are connected if they are neighbours in space or if  
their regions at different scales intersect. 

\subsection{Space Processing Stage}
Spatial interactions are established by exchanging messages between nodes. The process involves 3 steps: \textbf{send} messages between all connected nodes, \textbf{gather} information at node level from the received messages and \textbf{update} internal nodes representations. Each step has its own dedicated MLP. Message passing is iterated $K$ times, with time processing steps followed by space processing steps, at each iteration.


\paragraph{Message sending function.} A given message between two nodes should represent relevant information about their pairwise interaction. Thus, the message is a function of both the source and destination nodes $j$ and $i$, respectively. The function, $f_{send}(\mathbf{v}_j, \mathbf{v}_i)$ is modeled as a multilayer perceptron (MLP) applied on the concatenation of the two node features: 

\begin{align}
    f_{send}(\mathbf{v}_j,\mathbf{v}_i) &= \text{MLP}_s( [\mathbf{v}_j | \mathbf{v}_i])  \in \mathbb{R}^{D}. \\
    \text{MLP}_a(\mathbf{x}) &= \sigma(W_{a_2}  \sigma(W_{a_1} (\mathbf{x}) + b_{a_1}) + b_{a_2}).
\end{align}

\paragraph{Position-aware messages.}
The pairwise interactions between nodes should have positional awareness - each node should be aware of the position of the neighbor that sends a particular message. Therefore we include the position information as a (linearized) low-resolution $6 \times 6$ map in the message body sent with $f_{send}$, by concatenating the map to the rest of the message. The actual map is formed by putting ones for the cells corresponding to the region of interest of the sending nodes and zeros for the remaining cells, and then applying filtering with a Gaussian kernel.


\paragraph{Gather function.}
Each node receives a message from each of its neighbours and aggregates them using the $f_{gather}$ function, which could be a simple sum of all messages or an attention mechanism that gives a different weight to each message, according to its importance. In this way, a node could choose what information to receive. In our implementation, the attentional weight function $\alpha$ is computed as the dot product between features of the two nodes, measuring their similarity.

\begin{align}
    f_{gather}(\mathbf{v}_i) &= \sum_{j \in \mathcal{N}(i)} \alpha(\mathbf{v}_j,\mathbf{v}_i) f_{send}(\mathbf{v}_j,\mathbf{v}_i) \in \mathbb{R}^{D}.\\
    \alpha(\mathbf{v}_j,\mathbf{v}_i) &= (W_{\alpha_1} \mathbf{v}_j)^T (W_{\alpha_2} \mathbf{v}_i) \in \mathbb{R}.
\end{align}


\paragraph{Update function.} We update the representation of each node with the information gathered from its neighbours, using function $f_{space}$ modeled as a 
multilayer perceptron (MLP). We want each node to be capable of taking into consideration global information while also maintaining its local identity. The MLP is able to combine efficiently new information received from neighbours with the local information from the node's input features.

\begin{equation}
    f_{space}(\mathbf{v}_i) = \text{MLP}_u( [\mathbf{v}_i | f_{gather}(\mathbf{v}_i)])  \in \mathbb{R}^{D}.
\end{equation}

In general, the parameters $W_u, b_u$ could be shared among all nodes at all scales or each set could be specific to the actual scale. 

\subsection{Time Processing Stage}
Each node updates its state in time by aggregating the current spatial representation $f_{space}(\mathbf{v}_i)$ with its time representation from the previous step using a recurrent function.
In order to model more expressive spatio-temporal interactions and to give it the ability to reason about all the information in the scene, with knowledge about past states, we put a Time Processing Stage before each Space Processing Stage, at each iteration, and another Time Processing Stage after the last spatial processing.

Thus messages are passed iteratively in both space and time, alternatively. The Time Processing Stage at iteration $k$ updates each node's internal state $v_i^{t,k}$ with information from its corespondent state $v_i^{t-1,k}$, at iteration $k$, in the previous time $t-1$, resulting in features that take into account both spatial interactions and history (Fig.~\ref{fig:processing_stages}).

\begin{equation}
    \mathbf{h}_{i,time}^{t,k} =  f_{time}(\mathbf{v}_{i, space}^{k},  \mathbf{h}_{i,time}^{t-1,k} ).
\end{equation}

\subsection{Aggregation step}
\label{section:aggregation}

The aggregation  $f_{aggregate}$ function could produce two types of final representations, a 1D vector or a 3D map. In the first case, denoted \textbf{RSTG-to-vec}, we obtain the vector encoding by summing the representation of all the nodes from the last time step.
In the second case, denoted \textbf{RSTG-to-map}, we create the inverse operation of the node creation, by sending the processed information contained in each node back to the original region in the space-time volume as shown in Figure~\ref{fig:main_graph_figure}. For each scale, we have $h * w$ nodes with $C$-channel features, that we arrange in a $h \times w$ grid resulting in a volume of size $h \times w \times C$. We up-sample the grid map for each scale into $H \times W \times C$ maps and sum all maps for all scales for the final $H \times W \times C$ representation.

\newpage

\subsection{Computational complexity}

We analyse the computational complexity of the RSTG model. 
If $N$ is the number of nodes in a frame and $E$ the number of edges, we have $O(2E)$ messages per space-processing stage, as there are two different spatial messages in each edge direction.
With a total of $T$ time steps and $K$ (=3) spatio-temporal message passing iterations, 
each of the  $K$ spatial message passing iterations is preceded by a temporal iteration, resulting in a total complexity of $O(T~\times~(~2E)~\times~K~+~T\times~N~\times~(K+1))$. Note that $E$ is upper-bounded by $N(N-1)/2$.
Without the factorisation, with messages between all the nodes in time and space (similar to \cite{wang2018non_local, wang2018videos_gupta2}), we would arrive at a complexity of $O(T^2 \times N^2 \times K)$ in the number of messages, which is quadratic in time.
Note that our lower complexity is due to the recurrent nature of our model and the space-time factorization.



\section{Experiments}

\begin{figure}
    \begin{minipage}{.65\textwidth}
    \begin{table}[H]
    \label{tab:results_digits}
    \fontsize{9}{10}\selectfont
\caption{Accuracy on SyncMNIST dataset, showing the capabilities of different parts of our model. }
       \begin{tabular}{lcccr}
            \toprule
            Model & 3 SyncMNIST  & 5 SyncMNIST & \\
            \midrule
            \midrule
            Mean + LSTM    &  77.0 & - \\
            Conv + LSTM  &  95.0 & 39.7 \\
            I3D & - & 90.6 \\
            Non-Local & - & 93.5 \\
            \midrule
            RSTG: Space-Only & 61.3 & - \\
            RSTG: Time-Only & 89.7 & - \\
            RSTG: Homogenous & 95.7 & 58.3\\
            RSTG: 1-temp-stage    & 97.0 & 74.1\\
            RSTG: All-temp-stages & \textbf{98.9} & 94.5 \\
            RSTG: Positional All-temp & \textbf{-} & \textbf{97.2} \\
            \bottomrule
        \end{tabular}
            \end{table}
    \end{minipage}
    \begin{minipage}{.35\textwidth}
        \centering
        \vspace{3mm}
        \includegraphics[width=\textwidth]{digits_sample2.png}
        
        \caption{On each row we present frames from videos of 5SyncMNIST dataset. In each video sequence two digits follow the exact same pattern of movement. The correct classes: "3-9" "6-7" and "9-1".}\label{fig:digits}
    \end{minipage} 
\end{figure}

We perform experiments on two video classification tasks, which involve complex object interactions. We experiment on a video dataset that we create synthetically, containing complex patterns of movements and shapes, and on the challenging Something-Something-v1 dataset, involving interactions between a human and other objects~\cite{goyal2017something}. 

\subsection{Learning patterns of movements and shapes}


There are not many available video datasets that require modeling of difficult object interactions. Improvements are often made by averaging the final predictions over space and time~\cite{chen20182_a2nets}. The complex interactions and the structure of the space-time world still seem to escape the modeling capabilities. For this reason, and to better understand the role played by each component of our model in relation to some very strong baselines, we introduce a novel dataset, named SyncMNIST.

We make several MNIST digits move  in complex ways. We designed the dataset such that the relationships involved are challenging in both space and time. The dataset contains $600K$ videos showing multiple digits, where all of them move randomly, apart from a pair of digits that moves synchronously - that specific pair determines the class of the activity pattern, for a total of $45$ unique digit pairs (classes) plus one extra class (no pair is synchronous).

In order to recognize the pattern, a given model has to reason about the location in space of each digit, track them across the entire time in order to learn the association between a label and a pair of digits that moves synchronously. The data has $18 \times 18$ size digits moving on a black $64 \times 64$ background for $10$ frames. In Fig. \ref{fig:digits} we present frames from three different videos used in our experiments. We trained and evaluated our models first on an easier 3 digits (3SyncMNIST) dataset and then, only the best models were trained and tested on the harder 5 digits dataset (5SyncMNIST).

 We compared against four strong baseline models that are often used on video understanding tasks. For all tested models we used a convolutional network as a backbone. It is a small CNN with 3 layers, pre-trained to classify a digit randomly placed in a frame of the video. It is important to notice that published models such as MeanPooling+LSTM, Conv+LSTM, I3D and Non-Local, have the same ranking on our SyncMNIST dataset as on other datasets such as UCF-101~\cite{soomro2012ucf101},  HMDB-51~\cite{kuehne2011hmdb}, Kinetics (see ~\cite{carreira2017quo}) and Something-Something (see  ~\cite{wang2018videos_gupta2}). The available performance of these models on all datasets can be found in Section A of the Appendix.  


It is also important that the performance of different models seems to be well correlated with the ability of a specific model to incorporate and process time axis. This aspect, combined with the fact that, by design, on SyncMNIST the temporal dimension is important, make the tests on SyncMNIST relevant. 


\textbf{Mean pooling + LSTM:} Use backbone for feature extraction, spatial mean pool and temporally aggregate them using an LSTM. This model is capable of processing information from distant time-steps but it has poor understanding of spatial information.

\textbf{ConvNet + LSTM:} Replace the mean pooling with convolutional layers that are able to capture fine spatial relationships between different parts of the scene. Thus, it is fully capable of analysing the entire video, both in space and in time.

\textbf{I3D:} We adapt the I3D model \cite{carreira2017quo} with a smaller ResNet~\cite{He2016DeepRL_resnet} backbone to maintain the number of parameters comparable to our model. 3D convolutions are capable of capturing some of the longer range relationships both spatially and temporally.

\textbf{Non-Local:}  We used the previous I3D architecture as a backbone for a Non-Local~\cite{wang2018non_local} model. We obtained best results with one non-local block in the second residual block.

\paragraph{Implementation details for RSTG:}
Our recurrent neural graph model (RSTG) uses the initial \mbox{3-layer} CNN as backbone, an LSTM with $512$ hidden state size for the $f_{time}$ and RSTG-to-vec as aggregation. We use 3 scales with $1\times1$, $2\times2$ and $3\times3$ grids with nodes of dimension $512$. We implement our model in Tensorflow framework \cite{tensorflow2015-whitepaper}. We use cross-entropy as loss function and trained the model end-to-end with SGD with Nesterov Momentum with value $0.9$ for momentum, starting from a learning rate of $0.0001$ and decreasing by a factor of 10 when performance saturates. 

In Table~\ref{tab:results_digits} results  show that RSTG is significantly more powerful than the competitors. Note that the graph model runs on single-image based features, without any temporal processing at the backbone level. The only temporal information is transmitted between nodes at the higher graph level.



\subsubsection{Ablation study} 

Solving the moving digits task requires a model capable of capturing pairwise interactions both in space and time. RSTG is able to accomplish that, through spatial connections between nodes and the temporal updates of their state. In order to prove the benefits of each element, we perform experiments that shows the contributions brought by each one and present them in Table~\ref{tab:results_digits}.
We observed the efficiently transfer capabilities of our model between the two versions of the SyncMNIST dataset. When pretrained on 3SyncMNIST, our best model RSTG-all-temp-stages achieves $90 \% $ of its maximum performance in a number of steps in which an uninitialized model only attains $17 \% $ of its maximum performance.

\textbf{Space-Only RSTG:} We create this model in order to prove the necessity of having powerful time modeling. It performs the Space Processing Stage on each frame, but ignores the temporal sequence, replacing the recurrence with an average pool across time dimension, applied for each node. As expected, this model obtains the worst results because the task is based on the movement of each digit, an information that could not be inferred only from spatial exploration.

\textbf{Time-Only RSTG:} This model performs just the Time Processing Stage, without any message-passing between nodes. The features used in the recurrent step are the initial features extracted from the backbone neural network, which takes as input single frames.

\textbf{Homogeneous Space-time RSTG:} This model allows the graph to interact both spatially and temporally, but learn the same set of parameters for the MLPs that compute messages in time and space. Thus, time and space are computed in the same way.

\newpage
\textbf{Heterogeneous Space-time RSTG:} We developed different schedulers for our spatial and temporal stages. In the first scheduler, used in the \textbf{1-temp RSTG} model, for each time step, we performed 3 successive spatial iteration, followed by a single final temporal update. The second scheduler, the \textbf{all-temp RSTG} model, alternates between the spatial and temporal stages (as presented in Alg.\ref{alg:main_model}).  We use one Time Processing Stage before each of the three Space-Processing Stages, and a last Time Processing Stage to obtain the final nodes representation.

\textbf{Positional All-temp RSTG:} This is the previous all-temp RSTG model, but enriched with positional embeddings used in $f_{send}$ function as explained in Section~\ref{model_section}. This model, which is our best and final model, is also  able to reason about global locations of the entities.

\subsection{Learning human-object interaction}
In order to evaluate our method in a real world scenario involving complex interactions, we use the Something-Something-v1 dataset~\cite{goyal2017something}.
It consists of a collection of 108499 videos with 86017, 11522 and 10960 videos for train, validation and test splits respectively.  It has 174 classes for fine-grained interactions between humans and objects. It is designed such that classes can be discriminated not by some global context or background but from the actual specific interactions. 


\begin{table}[t]
    \fontsize{9}{10}\selectfont
    \caption{Comparison with state-of-the-art models on Something-Something-v1 dataset showing Top-1 and Top-5 accuracy. }
\centering
           \begin{tabular}{lccc}
                \toprule
                Model & Backbone & Val Top-1  & Val Top-5 \\ \midrule
                \midrule
C2D    &  2D ResNet-50 & 31.7 & 64.7 \\ TRN \cite{zhou2018temporal_trn_torralba}& 2D Inception & 34.4 & - \\ ours C2D + RSTG    &  2D ResNet-50 & \textbf{42.8} & \textbf{73.6} \\ \midrule
                \midrule
MFNet-C50~\cite{Lee2018MF_Net} & 3D ResNet-50 & 40.3 & 70.9 \\

                I3D \cite{wang2018videos_gupta2}    & 3D ResNet-50 & 41.6 & 72.2  \\NL I3D \cite{wang2018videos_gupta2}    & 3D ResNet-50 & 44.4 & 76.0 \\

                NL I3D + Joint GCN \cite{wang2018videos_gupta2}    &  3D ResNet-50 & 46.1 & 76.8\\\midrule 
                $\text{ECO}_{\text{Lite-16F}}$~\cite{zolfaghari2018eco} & 2D Inc+3D Res-18  & 42.2 & - \\MFNet-C101~\cite{Lee2018MF_Net} & 3D ResNet-101 & 43.9 & 73.1 \\I3D \cite{xie2018rethinking} & 3D Inception & 45.8 & 76.5  \\

                S3D-G~\cite{xie2018rethinking} & 3D Inception & 48.2 & 78.7  \\\midrule
                ours I3D + RSTG & 3D ResNet-50  & \textbf{49.2} & \textbf{78.8} \\\bottomrule
            \end{tabular}
            \label{tab:results}
            \end{table}




For this task we investigate the performance of our graph model combined with two backbones, a 2D convolutional one (C2D~\cite{wang2018non_local}), based on ResNet-50 architecture and an I3D~\cite{carreira2017quo} model inflated also from the ResNet-50. We start with backbones pretrained on Kinetics-400~\cite{carreira2017quo} dataset as provided by \cite{wang2018non_local} and train the whole model end-to-end.

We analyse our both aggregation types, described in Section \ref{section:aggregation}. For RSTG-to-vec we use the last convolutional features given by the I3D backbone as input to our graph model and obtain a vector representation. To facilitate the optimisation process we use residual connections in RSTG, by adding the results of the graph processing to the pooled features of the backbone. For the second case we use intermediate features of I3D as input to the graph and also add them to the graph output by a residual connection and continue the I3D model. For this purpose we need both the input and the output of the graph to have the same dimension. Thus we use RSTG-to-map to obtain a 3D map at each time step. 


\paragraph{Training and evaluation.} For training, we uniformly sample 32 frames from each video resized such that the height is $256$, preserving the aspect ratio and randomly cropped to a $224 \times 224$ clip. For inference, we apply the backbone fully convolutional on a $256 \times 256$ crop with the graph taking features from larger activation maps. We use 11 square clips uniformly sampled on the width of the frames for covering the entire spatial size of the video, and use 2 samplings along the time dimension. We mean pool the clips output for the final prediction.

\newpage
\paragraph{Results.}
We analyse how our graph model could be used to improve  I3D by applying RSTG-to-map at different layers in the backbone and RSTG-to-vec after the last convolutional layer. In all cases  the model achieves competitive results, and the best performance is obtained using the graph in the res3 and res4 blocks of the I3D as shown in Table~\ref{tab:ablation}.
We compare against recent methods on the Something-Something-v1 dataset and show the results in Table~\ref{tab:results}. Among the models using 2D ConvNet backbones, ours obtains the best results (with a significant improvement of more than $8\%$ over all methods using a 2D backbone, for the Top-1 setup). When using the I3D backbone, RSTG reaches state-of-the-art results, with $1\%$ improvement over all methods (Top-1 case) and $3.1\%$ improvement over top methods (Top-1 case) with the same 3D-ResNet-50 backbone.

\paragraph{Computational requirements}
 We show the compute times for different variants of our model and for the Non-Local model using the Resnet-50 backbone on Something-Something videos running on one Nvidia GTX 1080 Ti GPU in Figure~\ref{fig:time}. We observe that our RSTG-to-vec model is faster, while having better accuracy than the Non-Local model, whereas our top performing model RSTG-to-map res3-4 further increase the results at the cost of being about 2x slower than RSTG-to-vec. Our RSTG-to-vec requires 6.95 GB for training and 1.23 GB for inference, while RSTG-to-map res3-res4 requires 7.50 GB and 1.93 GB respectively, with a batch of 2 clips. 
 

\begin{figure}
    \begin{minipage}[t]{.47\textwidth}
    \centering
\caption{We show running time (clips~/~s) on the left axis and final accuracy on the right axis.}\label{fig:time}
    \includegraphics[width=1.0\textwidth]{time2.pdf}
\end{minipage}
\hfill \begin{minipage}[t]{.47\textwidth}
    \vspace{-2mm}
    \begin{table}[H]
        \caption{Ablation study showing where to place the graph inside the ResNet-50 I3D backbone. For our best model we use two different graphs after the res3 and res4 stages of the I3D.}
        \vspace{2mm}
        \centering
        \fontsize{9}{10}\selectfont
        \begin{tabular}{lcc}
            \toprule
            Model & Top-1  & Top-5 \\\midrule
            \midrule
            RSTG-to-vec   & 47.7 & 77.9 \\RSTG-to-map res2   & 46.9 & 76.8 \\RSTG-to-map res3   & 47.7 & 77.8 \\RSTG-to-map res4   & 48.4 & 78.1 \\
            RSTG-to-map res3-4   & \textbf{49.2} & \textbf{78.8} \\\bottomrule
        \end{tabular}
        \label{tab:ablation}
        \end{table}
    
\end{minipage}
\end{figure}



    
\section{Conclusions}
In this paper we introduce the Recurrent Space-time Graph (RSTG) neural network model, which is specifically designed to learn efficiently in space and time. The graph, at each moment in time, starts by receiving local space-time information from features produced by a given backbone network. Then it moves towards global understanding by passing messages over space between different locations and scales and recurrently in time, by having a different past memory for each space-time iteration. Our model is unique in the literature in the way it processes space and time, with several main contributions: 1) it treats space and time differently; 2) it factorizes them and uses recurrent connections within a unified neural graph model from an unstructured video, with relatively low computational complexity; 3) it is flexible and general, being relatively easy to adapt to various learning tasks in the spatio-temporal domain; 4) our ablation study justifies the structure and different components of our model, which obtains state-of-the-art results on the challenging Something-Something dataset. In future work we plan to further study and extend our model to other higher-level tasks such as semantic segmentation in spatio-temporal data and vision-to-language translation.


\paragraph{Acknowledgements:} This work has been supported in part by Bitdefender and UEFISCDI, through projects EEA-RO-2018-0496 and TE-2016-2182.

\bibliography{arxiv_full_version}
\bibliographystyle{unsrt}

\newpage

\appendix

\title{Appendix: Recurrent Space-time Graph Neural Networks}



\author{Andrei Nicolicioiu\thanks{Equal contribution.}, Iulia Duta^\notice{*}\\
  Bitdefender, Romania\\
  \texttt{{anicolicioiu, iduta}@bitdefender.com} \\
  \And
  Marius Leordeanu \\
  Bitdefender, Romania \\
\fontsize{6pt}{7pt}Institute of Mathematics of the Romanian Academy \\
  University "Politehnica" of Bucharest \\
  \texttt{marius.leordeanu@imar.ro} \\
}



\maketitle


\section{Models ranking on 5SyncMNIST vs other video datasets}
 \label{section:ranking}
    
  We present in Figure~\ref{fig:dataset_correlation} the available results of our RSTG model and the published models MeanPooling+LSTM, Conv+LSTM, I3D and Non-Local  on UCF-101~\cite{soomro2012ucf101},  HMDB-51~\cite{kuehne2011hmdb}, Kinetics (see ~\cite{carreira2017quo}), Something-Something (see~\cite{wang2018videos_gupta2}) and on our 5SyncMNIST dataset. There is one curve per dataset, with one point on the curve per method, shown in increasing order of performance, which is preserved across datasets. As seen by the strictly increasing lines, the same rank order of all the models is maintained on several datasets, including ours. This affirms the consistent behaviour of the methods as well as the relevance of the datasets.
         
         
    \begin{figure}[H]
        \centering
        \includegraphics[width=0.5\textwidth]{scores2.png}
        \caption{Performance of different models on several datasets}
        \label{fig:dataset_correlation}
    \end{figure}

\section{Details about using the RSTG module together with a backbone}

\newcommand{\graphiter}{\(\left[\begin{array}{c}\text{Temporal Processing Stage}\\[-.1em] \text{Spatial Processing Stage }\end{array}\right]\)\x3\\ & \\ & \text{Temporal Processing Stage}}



\paragraph{Feature extraction:} In the following section we give some additional technical details of the way the RSTG model is designed in order to work in conjunction with a backbone. More specifically, we discuss how we combine RSTG with I3D as the backbone model. Our model is suited for being inserted at multiple layers of any backbone network. We test the model when it is included after a single I3D stage or after multiple such stages. This insertion is done as follows (as seen in Figure 1 in the main paper): we take the output from a specific backbone layer, having dimension $\mathbb{R}^{T\times H \times W \times C}$ and use it as an input to our graph model. 
For example, if we give as video input $32$ frames of size $224 \times 224$ frames to I3D and use the features given by the res4 stage (as input to our RSTG model), we obtain a $16 \times 14 \times 14 \times 2048$ input feature map as shown in Table~\ref{tab:arch}.

\paragraph{Node creation:} As shown in Figure 1 in the main paper, we pool features at $S$ different scales, each corresponding to regions in the original image, ranging from areas covering parts of the image to areas covering the entire image. For each of the $S$ scales, we down-sample the features into increasingly smaller maps (one for each scale). Each of these maps form an $M \times M$ grid, each point representing a node. 
Then, at each time step, each node receives a temporal slice from the features corresponding to its cell in the grid. 



\paragraph {Output creation: } We process the graph with our interleaved Space and Time Processing Stages. The recurrent Time Processing Stage runs for $T$ steps, with each node internal state $h_i^t$ at each time step having an increasingly better temporal information during this process. 




By using a residual connection, we add the graph features to the backbone features, thus they must have the same number of channels and temporal dimension. For this, we first project each node back to the initial $2048$ dimension and aggregate together the graph and backbone features.

In the case of RSTG-to-vec models, we sum all the nodes and add them to the global spatial mean pooling of the backbone and average them across time.

In the case of RSTG-to-map models, we also need to have the same spatial dimension for graph and backbone features. 
For each scale, the node features, arranged as grids, are up-sampled to the original input spatial size. This is done for each of the $S$ scales, resulting in $S$ $16 \times 14 \times 14 \times 2048$ maps that are then summed together into a single map of the same size $16 \times 14 \times 14 \times 2048$. The resulting map is further summed with the backbone input features map using a residual connection. The final map thus obtained (which is represented by the up-sampled output features in Figure 1 of the main paper) is then fed into the remaining stages of the I3D model to obtain the final prediction.


\paragraph{Experiments on the graph position inside the backbone: } We conduct several experiments showing different ways of combining our RSTG model with the I3D backbone, by varying which I3D layers are used as input to the graph (res2, res3, res4), the final aggregation methods (RSTG-to-vec, RSTG-to-map) and the number of graphs used between different I3D layers.

We observe that our graph model obtains the best results with higher level features from res4 stage, while it obtains the wors results using lower level res2 stage features. The best results are achieved when two graphs are stacked with input features from different layers of the backbone (i.e. res3 and res4).

\begin{table}[t]
\caption{Architecture of our RSTG-to-map-res4 model, with 4 scales, that processes features from the res4 stage of the I3D ResNet-50 model.
}
\footnotesize
\centering
\resizebox{0.65\columnwidth}{!}{
\tablestyle{6pt}{1.08}
\begin{tabular}{c|c|c}
model & {layer} & output size \\
\shline
&  {input} &$32 \times 224 \times 224 \times 3$ \\
\hline
\multirow{6}{*}{I3D} &\multicolumn{1}{c|}{conv1} & $32 \times 112 \times 112 \times 64$ \\
\cline{2-3}
& \multicolumn{1}{c|}{pool1} & $32 \times 56 \times 56 \times 64$ \\
\cline{2-3}
&  res2 &  { $32 \times 56 \times 56 \times 256$} \\
\cline{2-3}
& pool2 & $16 \times 56 \times 56 \times 256$ \\
\cline{2-3}
& res3 &  {$16 \times 28 \times 28 \times 512$} \\
\cline{2-3}
& res4 &  {$16 \times 14 \times 14 \times 1024$}  \\
\shline
  &  & \\
 \multirow{11}{*}{RSTG}& \text{Graph creation} & 
\makecell{
$16 \times 4 \times 4 \times 512$\\
$16 \times 3 \times 3 \times 512$\\
$16 \times 2 \times 2 \times 512$\\
$16 \times 1 \times 1 \times 512$\\
} \\
& \\
\cline{2-3}
& \\
& \graphiter & 
\makecell[c]{$16\times30\times512$} 
\\
\cline{2-3}
& \\
& 
\makecell{
Up-sample each grid\\
$1\times 1 \times 1$ conv
}
& 
\makecell{
$16 \times 14 \times 14 \times 512$\\
$16 \times 14 \times 14 \times 2048$
}
\\
& \\
\shline
{I3D} & res5 &  {16\x14\x14\x2048} \\
\cline{2-3}
& {mean pool, fc} & $1 \times 1 \times 1 \times 174$  \\
\hline
\end{tabular}
}
\label{tab:arch}
\end{table}

\section{Additional experiments regarding the form of adjacency matrix}

In order to validate our choice of connectivity used in the spatial processing, we experimentally test two types of adjacency matrix. The first is formed as stated in the main paper by connecting two nodes if they are neighbours in space or if their regions at different scales intersect. The second is a matrix full of ones, forming a completely connected graph.
We observe that the sparser version used in the rest of the paper obtains better results.



    \begin{table}[H]
        \caption{Results of RSTG-to-vec model obtained by varying the adjacency matrix.}
        \vspace{2mm}
        \centering
        \fontsize{9}{10}\selectfont
        \begin{tabular}{lcc}
            \toprule
            Model & Top-1  & Top-5 \\\midrule
            \midrule
            RSTG-to-vec - sparse   & 47.7 & 77.9 \\RSTG-to-vec - full   & 46.9 & 76.8 \\

            \bottomrule
        \end{tabular}
        \label{tab:ablation}
        \end{table}


\section{Details about the baselines used in SyncMNIST experiments}

We offer a more detailed description of the baselines used in the experiments on SyncMNIST dataset.

\textbf{Mean pooling + LSTM:} We use as backbone a 3-layer CNN to independently extract features from each frame. Each convolutional layer uses  $3\times3$ filters followed by ReLU non-linearity and $2\times 2$ max-pooling. We aggregate the spatial information using a final global average pooling, and use an LSTM with $512$ hidden state dimension to process all frame features into a feature vector used to make the final prediction. This model is capable of processing information from distant time-steps but it has poor understanding of spatial information because of the lost information due to the pooling.

\textbf{ConvNet + LSTM:} We include an additional ConvNet on top of the previous CNN backbone. It consists of a three convolutional layers, with stride 1, without pooling, with ReLU non-linearity and batch normalization~\cite{pmlr-v37-ioffe15} between them. For the second baseline, the extra convolutional layers (without spatial pooling and no down-sizing of the activation maps) are able to capture fine spatial relationships between different parts of the scene. The features from the last layer are also passed through the same LSTM model. Thus, the second baseline is fully capable of analyzing the entire video, both in space and in time.

\textbf{I3D:}  We used a version of I3D \cite{carreira2017quo} with inflated 3D convolutions adapted from ResNet-50. We considered only 3 residual stages (res2, res3, res5) with fewer number of blocks (2 for each residual stage) and fewer filters such that the number of parameters became comparable with our models (around 10M). While the 3D convolutions process local space-time volumes at a time, they are very powerful and capable to capture some of the longer range relationships through repeated convolutions at multiple layers of depth.

\textbf{Non-Local:}  We used the previous I3D architecture (described as I3D above) as a backbone for a Non-Local\cite{wang2018non_local} model. We tried adding multiple blocks at different stages, and obtained the best results with one non-local block in the second residual stage.

\begin{figure}[t!]
\begin{center}
\centerline{\includegraphics[width=1.0\textwidth]{digits_sample3.png}}
\caption{Sampled frames from our 5SyncMNIST dataset. With green arrows we show the path of the pair of digits that move synchronously and determine the class label of the video (for a total of 45+1 possible class labels, where the is no pair of synchronously moving digits); with red arrows we show the paths of other digits that move randomly, independently from the pair that move synchronously.}
\label{fig:main_graph_figure}
\end{center}
\end{figure}








\section{An intuitive view of Recurrent Space-time Graph Neural Networks}

The experiments presented in the paper strongly indicate that the RSTG graph structure, which operates iteratively and recurrently over space and time brings an important additional value to the convolutional network backbone, whether that backbone has 3D or 2D convolutions. We believe that the main reason for this fact is hidden in the way objects and events, which are more distant in space and time, interact and influence each other to determine a specific action or activity. Complex activities are often composed of many events, which in turn are defined by several interactions between objects that take place at different positions, scales and moments in time. It is also important that the arrangement of events in time is different, conceptually, than the arrangements of objects in space. 

The ideas above suggest that there is a need for a computational structure that is able to process information locally but is also able to quickly send the results of such computations to distant regions in space and time. What the recurrent space-time graph model has over the more uniform and local convolutional backbone networks is, first and foremost, its ability to separate conceptually the local computation at the level of nodes from the passing of messages between nodes at the level of space-time edges. Then, the message passing routine, which is iterative, can quickly send information globally and reach a convergent state that puts in agreement the local computations. 

In the case of convolutional networks, the spreading of information from the local to the global levels seems to be done less efficiently, through many layers of processing, in a more continuous and local manner, in which time and space are treated more or less in the same uniform fashion. The RSTG graph structure treats from the start time and space differently. It encourages the computation at the node level to reach an agreement by passing messages between nodes for several iterations, in space and also in time (from past state to the current one). We believe that this iterative process is suited for such higher levels of abstraction in order to learn efficiently about how objects interact to form first simpler and more local events and then more complex and more global activities.

These concluding remarks are supported by our experiments in which we show that RSTG brings a stronger boost over a powerful backbone model when operating over the higher level features provided by this model. The results suggest that the RSTG graph adds complementary capabilities to the input network, by being able to capture, perhaps more efficiently, the discrete-continuous and complex structure of the space-time world at higher levels of abstraction.



\end{document}