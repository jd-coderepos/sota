\documentclass[submission,copyright,creativecommons]{eptcs}
\providecommand{\event}{AFL 2017}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{mathtools}
\usepackage{subcaption}
\usepackage[usenames]{color}

\newcommand{\match}{\mathsf{match}}
\newcommand{\fail}{\mathsf{fail}}

\newcommand{\Rule}{\mathcal{R}}
\newcommand{\NonT}{\mathcal{N}}
\newcommand{\Expr}{\mathcal{X}}
\newcommand{\Lang}{\mathcal{L}}

\newcommand{\str}{\mathrm{s}}
\newcommand{\chs}[1]{\mathtt{#1}}
\newcommand{\eos}{\lozenge}
\newcommand{\eosp}{\mathrm{\textit{\\mathrm{LR}(k)a^n b^n c^n\mathrm{LL}(1)A := \alphaA\alpha\Sigma^*\Sigma\alpha\alpha: \Sigma^* \rightarrow \left\lbrace \match, \fail \right\rbrace \times \Sigma^*\NonT\Expr\Rule\Rule: \NonT \rightarrow \Expr\mathcal{G}(\NonT, \Expr, \Sigma, \Rule, \sigma)\sigma \in \Expr\varphi \in \ExprN \in \NonT\chs{c} \in \Sigma\str \in \Sigma^*\varphi\Lang(\varphi)\varphi\Lang(\varphi) = \left\lbrace \str \in \Sigma^* : \exists \str', \varphi(\str) = \left(\match, \str'\right) \right\rbrace\varphi\Lang(\varphi) = \Sigma^*\varepsilon\varepsilonc\alpha\beta\alpha\beta\alpha/\beta\alpha\beta\alphaab/aa/ababa!\alpha\alphaN\Rule(N)\Rule(N)A := a\:A\;/\;\varepsilon\alpha*Aa*{a*}~aa*a\alpha?\alpha/\varepsilon\alpha+\alpha\,{\alpha*}\&\alpha\alpha!(!\alpha)\anyc\Sigma[a_0 \cdots a_k]a_0/\cdots/a_k[^\wedge a_0 \cdots a_k]![a_0 \cdots a_k]\:\anyc\eosp!\anyc\alpha \rightarrow \beta(!\beta\,\alpha)\!*\,\beta\alpha\betaU := \beta/\alpha U\beta\chs{a}^n\chs{c}^nAA0 < i < nAn-iA := A\,a\:/\:\varepsilon\varphid_c(\varphi)\Lang(\varphi)d_f\left(foo/bar/baz\right) = ood_b\left(foo/bar/baz\right) = ar/azd_a\left(ar/az\right) = r/zd_r\left(r/z\right) = \varepsilon\varphi\varphi'\Lang(d_c(\varphi)) = \left\lbrace \str : \chs{c}\,\str \in \Lang(\varphi) \right\rbraced_{c_k} \circ \cdots \circ d_{c_1}(\varphi)d_{c_1 \cdots c_k}(\varphi)\varphi^{(k)}\varnothing\infty\varnothing(\str) = \infty(\str) = \left(\fail, \str\right)\varnothing\infty0\g{X} = \{x_0, x_1, \cdots, x_k\}0, \cdots, k\varepsiloni\varepsilon[i]\varepsilon[0]\varepsilon[i > 0]i\of{\g{F}}{\g{G}} = \{f_i : i \in \g{G}\}\of{\{0, 3, 4\}}{\{0, 2\}} = \{0, 4\}\alpha/\beta[\g{A},\g{B},m]\g{A}\g{B}\alpha\betam\g{A}\g{B}\alpha\beta\alpha\beta\alpha/\beta\varphi = a!c/!(ab)a!c\g{A} = \{0\}!(ab)\varepsilon[1]\g{B} = \{0, 1\}\varepsilon[1]1\varphia!c/!(ab)[\{0\},\{0,1\},1]d_a(\varphi) = !c/!b!c!b2\varepsilon[1]!c\varepsilon[2]\varphi!c/!b[\{0,2\},\{0,1\},2]\alpha\beta\alpha\alpha\beta = (\delta/\varepsilon)\beta\delta\beta/\beta\delta^{(k)}\beta^{(k)}\alpha\beta\beta_\emptyset\g{B}_\emptyset\beta_\emptyset\alpha^{(k)}\beta\alpha^{(k+i)}\alpha^{(k)}(\delta/\varepsilon)\beta\delta\beta/\beta\delta = a\beta = a+\chs{a} \in \Lang(a\:{a+}/{a+})\chs{a} \not \in \Lang((a/\varepsilon){a+})(a/\varepsilon)\chs{a}a+\alpha\beta\alpha\alpha\beta\beta\beta_i\betai\g{B}_il_i\alpha\beta\beta_i0l_i\alpha\betam\varphiback(\varphi)match(\varphi)a\{0\}\{\}\varepsilon[i]\{i\}\{i\}\varnothing\{0\}\{\}\infty\{0\}\{\}Aback(\Rule(A))back(A) = \{0\}match(\Rule(A))match(A) = \{\}!\alpha\{1\}\{\}\alpha[\g{A},m]\of{\g{A}}{back(\alpha)}\of{\g{A}}{match(\alpha)}\alpha/\beta[\g{A},\g{B},m]\of{\g{A}}{back(\alpha)} \cup \of{\g{B}}{back(\beta)}\of{\g{A}}{match(\alpha)} \cup \of{\g{B}}{match(\beta)}backmatchbackmatchback(\varphi)\varphimatch(\varphi)back(\varphi)match0 \in match(\varphi)\varphibackmatchbackmatchAA\inftymatch\alpha[\g{A},m]backmatch\alpha\alpha[\g{A},m](\str) = \alpha(\str)up\g{P}\varphi\varphi'1\varepsilon\varepsilon[0]\alpha/\beta[\g{A}, \g{B}, m]\g{A}\g{B}back(\alpha)back(\beta)m\max(\g{A}, \g{B})\alpha\beta\alpha0 \in match(\alpha)\beta_\emptyset = \beta\beta_\emptyset = \varnothing\g{B}_\emptyset = back(\beta_\emptyset)1 \in back(\alpha)\alpha\beta\beta_1 = \beta\g{B}_1 = back(\beta)\betal_1 = 1l_1 = 0m = \max(0, \g{B}_\emptyset, \g{B}_1, l_1)1d_c(\varphi)\delta'd_c(\delta)a'\chs{a}\varepsilon[0]'\varepsilon[0]\varepsilon[i > 0]'\varnothing\infty\infty(!\alpha)'\alpha[\g{A},m]'\alpha[\g{A},m]'\alpha/\beta[\g{A},\g{B},m]'\beta\alpha\alpha\beta\alphai > 0l_i\alpha\alpha\alpha\beta_i\beta_\emptysetk'\alphal_i'\beta_\emptyset^\dagger\g{B}_\emptyset'\beta\alphac = \eos!\anyc\anyc\eos!\anyc\beta^\dagger\beta\eosd_\eos(\alpha)\varepsilonparse\varphi\chs{c_1 c_2 \ldots c_n}parse\varphi'\varphi'\varphibackmatchbackmatchiback(\alpha)\alpha\beta\beta_i\g{B}_il_i\alpha\varepsilon[i]\beta_i\alpha[\g{A} = \{a_0,a_1,\cdots,a_k\},m]a_ii \not\in back(\alpha)\g{A}\g{A}d_c(\varphi)\varphi\varphi\varphi^\#(\varphi)\varphi\varphi\alpha/\beta[\g{A},\g{B},m]!\alpha|\varphi|\varphibO(b)O(b)|\varphi|\varphibA'bAA\Rule(A)'\Rule(A)^\#(\Rule(A)')\Rule(A)'\Rule(A)'AA\infty\inftyA^\#(\Rule(A)')\sum_{A \in \NonT} {^\#}(\Rule(A)')O(b^2 n)O(n^3)O(b^2 n^2)O(n^4)b\alpha\alpha*1bbb{a*}\,b\:/\:{a*}\,ca*\chs{a}^n\chs{c}^nn=27n=4000n=10000\varepsilon$ expressions with parse tree nodes, composing these nodes as their containing expressions matched or failed. 
An alternate approach would be to integrate semantic action expressions into the grammar; this should be possible by augmenting each parsing expression with an environment to store local variables. 
A third option would be to extend the derivative of parsing expressions defined in this paper to a derivative of parsing expression parsers, analogously to the extension defined by Might~\etal\ for CFG derivatives \cite{MDS11}. 
All these extensions are left to future work.

It would also be interesting to attempt to handle left-recursion in derivative parsing with sensible semantics. 
Ford \cite{For02} removes left-recursive rules by grammar transformation, Medeiros~\etal \cite{MMI14} modify PEG semantics to support left-recursive grammars, and Laurent and Mens \cite{LM15} use a custom parsing expression to handle left-recursion; one of these approaches could possibly be applied dynamically in the derivative parsing algorithm.

{\it The author would like to acknowledge the helpful feedback of Matt Might, David Darais, Peter Buhr, Adam Roegiest, and a number of anonymous reviewers, as well as Kota Mizushima's provision of test data and grammars. 
This work was supported in part by the author's NSERC post-graduate scholarship.}

\bibliographystyle{eptcs}
\bibliography{peg_deriv}

\end{document}
