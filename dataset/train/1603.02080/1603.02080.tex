\documentclass{article}

\usepackage[hidelinks]{hyperref}
 
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage[ruled,vlined,linesnumbered]{algorithm2e}
\usepackage{graphicx}
\usepackage{fullpage}
\usepackage[hidelinks]{hyperref}
\usepackage{thmtools,thm-restate}

\newcommand{\ttt}[1]{\texttt{#1}}
\newcommand{\NULL}{\ttt{NULL}}
\newcommand{\RR}{\mathbb R}
\newcommand{\NN}{\mathbb N}
\newcommand{\ZZ}{\mathbb Z}
\newcommand{\PP}{P}
\newcommand{\QQ}{Q}
\newcommand{\KO}{K}
\newcommand{\nn}{\mathbf n}
\newcommand{\mm}{\mathbf m}
\newcommand{\vv}{\vartheta}
\newcommand{\ee}{\varepsilon}
\newcommand{\pp}{\varphi}
\newcommand{\comm}[1]{}
\newcommand{\dist}{\textrm{dist}}
\newcommand{\stack}{\Sigma}
\newcommand{\simplex}{S}
\newcommand{\simplices}{\mathfrak S}
\newcommand{\se}{\sigma}
\newcommand{\VV}{\mathcal V}
\newcommand{\cutreg}{F}
\newcommand{\cut}{\mathcal C}
\newcommand{\cutdisk}{\mathcal D}
\newcommand{\start}{s}
\newcommand{\terminal}{t}
\newcommand{\arcA}{A}
\newcommand{\arcB}{B}
\newcommand{\tool}{\cutdisk}
\newcommand{\biDef}[1]{\textbf{(#1)}}
\newcommand{\cutDef}[1]{\textbf{(#1)}}
\newcommand{\mydef}{:=}
\newcommand{\CH}{\textsc{CH}}
\newcommand{\round}{\mathcal R}

\newcommand{\dis}[1]{}


\DeclareMathOperator{\Int}{Int}
\DeclareMathOperator{\argmin}{argmin}
\DeclareMathOperator{\diam}{diam}


\bibliographystyle{plain}

\newtheorem{theorem}{Theorem}[section]
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{exmp}[theorem]{Example}
\newtheorem{observation}[theorem]{Observation}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{fact}[theorem]{Fact}
\newtheorem{convention}[theorem]{Convention}


\renewcommand{\thefootnote}{\fnsymbol{footnote}}

\begin{document}

\title{How to Cut Corners and Get Bounded Convex Curvature\footnote{A
preliminary version of this paper was presented at SoCG 2016~\cite{abrahamsen_et_al:LIPIcs:2016:5896}.}}

\author{Mikkel Abrahamsen\footnote{University of Copenhagen and part of BARC, Basic Algorithms Research Copenhagen, supported by the VILLUM Foundation grant 16582. Mikkel Abrahamsen is supported by Starting Grant 1054-00032B from the Independent Research Fund Denmark under the Sapere Aude research career programme.}
\and Mikkel Thorup\footnotemark[2]}

\date{March 5, 2022}

\maketitle

\begin{abstract}
We describe an algorithm for solving an important geometric problem arising in computer-aided manufacturing.
When cutting away a region from a solid piece of material --- such as steel, wood, ceramics, or plastic --- using a rough tool in a milling machine, sharp convex corners of the region cannot be done properly, but have to be left for finer tools that are more expensive to use.
We want to determine a toolpath that maximizes the use of the rough tool.
In order to formulate the problem in mathematical terms, we introduce the notion of bounded convex curvature.
A region of points in the plane  has \emph{bounded convex curvature} if for any point , there is a unit disk  and  such that  and all points in  within distance  from  are in .
This translates to saying that as we traverse the boundary  with the interior of  on the left side, then  turns to the left with curvature at most .
There is no bound on the curvature where  turns to the right.
Given a region of points  in the plane, we are now interested in computing the maximum subset  of bounded convex curvature.
The difference in the requirement to left- and right-curvature is a natural consequence of different conditions when machining convex and concave areas of .
We devise an algorithm to compute the unique maximum such set , when the boundary of  consists of  line segments and circular arcs of arbitrary radii.
In the general case where  may have holes, the algorithm runs in time  and uses  space.
If  is simply-connected, we describe a faster  time algorithm.
\end{abstract}


\section{Introduction}\label{introSec}


\begin{figure}
\centering
\includegraphics[page=18]{collectFigs.pdf}
\caption{Left: A milling machine.
The model is the Rabbit Mill v3.0 from SourceRabbit, who kindly provided permission to use the picture.
\copyright\ SourceRabbit.
Right: A milling tool. Picture by Rocketmagnet, licensed under CC BY-SA 3.0.}
\label{millFig}
\end{figure}

The motivation for our work comes from the generation of toolpaths for milling machines.
Milling is the process of cutting some specified shape in a piece of material --- such as steel, wood, ceramics, or plastic --- using a milling machine; see Figure~\ref{millFig}.
We first describe the clean and general mathematical problem that we solve and afterwards explain how it relates to milling.

Consider a region  of the plane. 
We say that  has \emph{bounded convex curvature} if for any point , there is a unit disk  and  such that  and , where ; see Figure~\ref{compositionFig} (left).
This translates to saying that as we traverse  with the interior of  on the left side, then  turns to the left with curvature at most .
There is no bound on the curvature where it turns to the right, and we may even have
sharp concave corners.
Similarly, we say that  has \emph{bounded concave curvature} if the complement  has bounded convex curvature.

\begin{figure}
\centering
\includegraphics[page=19]{collectFigs.pdf}
\caption{Left: The sets  and  have bounded convex curvature, and then  does too.
It is demonstrated that the curvature condition is satisfied at the boundary point .
Right: A curvilinear region .
Dark gray regions are the complement of , which consist of four holes and the unbounded exterior of .
The white regions are the subset  of bounded convex curvature.
The regions of  are light gray, i.e., what we need to remove from  to get bounded convex curvature.}
\label{compositionFig}
\end{figure}

An appealing composition property of sets of bounded convex curvature is that if we take two such sets  and , then the union  also has bounded convex curvature, as demonstrated in Figure~\ref{compositionFig} (left).
Thus, if  is a region of points and  is a maximal (with respect to inclusion) subset of bounded convex curvature, it follows that  is the unique such subset; for if there was another  of bounded convex curvature that was not contained in , then  would be a larger subset of bounded convex curvature, contradicting the maximality of .

The input of our problem is a \emph{curvilinear region} .
By this we mean that  is a connected and compact set of points in the plane bounded by a finite number  of line segments and circular arcs of arbitrary radii.
This representation is quite common in the practical context of computer-aided manufacturing~\cite{Held2005biarc} and it also has the advantage that the output of our algorithm will anyway have this form if the input is a polygonal region (although the output may not be connected).

We present an algorithm that in  time finds a subset  of bounded convex curvature.
We prove that the result  contains any set  of bounded convex curvature, and hence  is the unique maximum such subset.
See Figure~\ref{compositionFig} (right) for an example.
In the special case where  is simply-connected, i.e., has no holes, we show how the algorithm can be implemented such that it takes  time.
Even in this case, the result  may be disconnected.

As we will see, the resulting region  will be a collection of curvilinear regions bounded by  line segments and circular arcs in total.
The circular arcs in  (the ``new'' part of the boundary of ) all have unit radius and are convex with respect to .
A very useful property of the boundary  is that all concave arcs and concave vertices are also on the boundary of .
Indeed, it is easy to verify that if there is a concave arc or vertex on the boundary of  which is not on the boundary of , then  is not maximal.

We will now discuss some differences between the various notions of bounded curvature:
\begin{itemize}
\item
The composition property does not hold for sets of bounded concave curvature because if  and  have bounded concave curvature, then sharp concave corners can appear in .
On the other hand, the intersection  does have bounded concave curvature and may not have bounded convex curvature.

\item
As we will explain in more detail in Section~\ref{mathFound}, a crucial property is that if  is the (bounded) region enclosed by a simple closed curve  and  has bounded convex curvature, then  contains a unit disk.
A similar property does not hold for sets of bounded concave curvature --- any disk of radius less than  is a counterexample.

\item
As stated above, it follows from the correctness of the algorithm described in this paper that any curvilinear region  contains a unique maximal subset  of bounded convex curvature.
It does not hold in general that  contains a unique maximal subset of bounded concave curvature (nor of bounded convex \emph{and} concave curvature).
Instead, it holds that there is a unique minimal \emph{superset} of  of bounded concave curvature, which we can express as .
\end{itemize}

\subsection{Applications in milling}
In the following, we describe different contexts in which the problem of computing the maximum subset of bounded convex curvature appears naturally.
The first author came across the problem when he worked as a software engineer for the company Autodesk (a major provider of CAD/CAM software), developing algorithms for computing toolpaths for milling machines.
He implemented a variant of the algorithm presented in this paper which was of great practical use.
The general problem is that we are given a curvilinear region , which we call a \emph{pocket}.
There is a thin layer of material in  close to the boundary
 of . The goal is to remove that layer without removing anything from outside . We are given a rough
tool, and we want to remove as much as possible of the thin layer, leaving as little as
possible for finer tools that are more expensive to use. The output is
a toolpath for the rough tool consisting of one or more curvilinear
regions. The tool is a disk  of radius , where  is
bigger than the width of the layer we wish to remove.  The toolpath is
the path which the center of  is following and the tool will remove all material in the area swept by  as its center follows the toolpath.
The reason that we only have to handle a thin layer close to the boundary of  is because the area farther from the boundary is removed beforehand by tools
that are less precise since they do not get close to the boundary.
Thus we may assume that all material with distance at least  from the boundary has been removed.
Some material closer to the boundary may also have been removed, but this only makes it easier for our tool to move.

Let  be the inwards offset of  by , that is,  is the subset of  of points with distance at least  to the pocket boundary ; see Figure~\ref{beforeAfterRounding}.
Then  is the set of all allowed positions of the center of  --- if the center goes outside , the tool will cut away material from outside the pocket .
If we had complete control over the tool, then we would be able to remove the material at all points with distance at most  from  by letting the tool center traverse the boundary  (if  consists of more than one cycle, we would traverse the cycles one after one, connected by some transitions that we do not care about here), and this would be the maximum amount of material that could possibly be removed from .
However, there are restrictions on what toolpaths we can follow, e.g., we cannot count on following a toolpath with sharp corners in a precise way.

\begin{figure}
\centering
\includegraphics[page=4]{collectFigs.pdf}
\caption{A pocket bounded by . To the left is shown
the boundary  of the inwards offset of  by . 
To the right is shown the boundary  of the maximum subset
with bounded
convex curvature of .
The dotted arcs in
the corners show the boundary of the material in 
that cannot be removed by  using the two toolpaths.}
\label{beforeAfterRounding}
\end{figure}

We are now ready to describe the first application where we
want to compute the maximum subset of bounded
convex curvature.

\paragraph{Application 1: Toolpaths of bounded curvature.}
Assume that the tool can only follow the boundary of a curvilinear region with bounded convex \emph{and} concave curvature.
This means that the curvature must be bounded both when the tool is turning left and right.
A double-sided restriction on the curvature like this is usually simply called \emph{bounded curvature} and has been studied in many papers on robotics and routing problems~\cite{agarwal2002curvature,ahn2012reachability,ayala2015length,lazard2002complexity,lee2000approximation}.
In our setup, we furthermore assume that the tool can turn at least as sharply as its own boundary, that is, we have~.

Using our algorithm for bounded convex curvature, we are able to identify the toolpath of bounded curvature that will remove the most material, as follows.
First we compute the above set  which is the inwards offset of  by .
The boundary  can be computed from the Voronoi diagram of  \cite{held1998voronoi}.
As stated before, the toolpath has to stay inside .
We now note that every concave part of  has curvature at most , as the concave parts of  stem from inwards offsets of concave parts of .
Hence,  has bounded concave curvature.
Next we use our algorithm to find the maximum subset  of bounded convex curvature; see Figure~\ref{beforeAfterRounding}.
The material cut away as  follows  is the unique maximum subset that can be cut out of  using a tool with radius  and such that  has bounded convex curvature.
However, all concave arcs and concave vertices of  are also in , and  has bounded concave curvature, so  has bounded convex \emph{and} concave curvature.
It follows that using the toolpath , we remove the maximum subset of the thin layer of material close to the pocket boundary  while respecting the curvature restriction. \\

\begin{figure}
\centering
\includegraphics[page=5]{collectFigs.pdf}
\caption{
The dashed toolpath  is the boundary of the inwards offset of
 by . The dotted segments to the corner 
show the alternative way of getting around the corner , instead of using the arc .}
\label{heartExFig}
\end{figure}

\noindent
In the above example, the set  had bounded concave curvature. In
particular, all concave arcs on  have radius at least ,
and for each concave arc  on  of radius
 and center , there is an associated concave vertex  of
. Let  and  be the first and last point on
. When the tool follows , the corner  will be on the
tool boundary , and the slightest imprecision will
blunt the corner . A recommended alternative
\cite{park2003mitered} is that we substitute  with two line
segments  and  tangential to  at  and ,
respectively, thus creating a sharp concave corner  on the
toolpath; see Figures~\ref{heartExFig} and~\ref{cuttingCloseups}. Using this technique, the
corner  will be cut much sharper and more precise. One can think of
various variations of this technique, since we can ``casually'' stop
and turn the tool at any point on its way to  because the remaining
toolpath already ensures that all material will be cut away.  This
shows that we cannot in general assume that there is any bound on the
concave curvature of the input toolpath. We also note the asymmetry with
convex corners and arcs, where overshooting a convex corner implies an
illegal cut through the boundary of .

\begin{figure}
\centering
\includegraphics[page=12]{collectfigs.pdf}
\caption{In each of these four situations, the thick black curve is the boundary  of the pocket.
The remaining material in the pocket is ensured to be between the dashed black curve and .
The boundary of the tool  is the dashed circle, and the solid part of the circle between the two crosses is the maximum part that can be in engagement with the material, i.e., the largest possible portion of the tool boundary cutting away material.
In the third picture, the convex corner on the path in the second picture has been rounded by an arc, thus bounding the convex curvature and reducing the maximum engagement.
The two rightmost pictures show two ways of going around a concave corner of .
In both cases, the maximum engagement is smaller than when the tool
follows a line segment of  (the case of the first picture).}
\label{cuttingCloseups}
\end{figure}

\paragraph{Application 2: Reducing the load on the tool in convex turns.}
We shall now provide a completely different explanation for the need
for bounded convex curvature. The point is that it is often preferable
for the surface quality of the final product that the tool moves with a constant
speed. Recall that the tool is only removing a thin layer
close to the pocket boundary. The width of this layer is typically a
deliberately chosen fraction of the tool radius .
When moving at constant speed, a convex
turn implies a higher engagement of the tool in the sense of the amount of
material removed per time unit; see Figure~\ref{cuttingCloseups}.
In concave turns the engagement is only decreased.  A too high
engagement could break the tool, and therefore we must bound the
convex curvature of the toolpath.

These and other issues related to the machining of corners have been extensively studied in the technical literature on milling.
See for instance the surveys \cite{hatna1998automatic,toh2004study} and
the papers \cite{burek2019simulation,burek2019numerical,choy2003corner,han2015precise,
iwabe1994study,pateloup2004corner,shixiong2018tool,tong2018prediction,zhao2007pocketing}.
There are several previous papers suggesting methods to get bounded
convex curvature, but none of them guarantees an optimal solution like
ours. One idea for how to handle convex corners is to replace each
of them by a convex circular arc as deep in the corner
as possible. This is suggested and studied
in the papers~\cite{choy2003corner,iwabe1994study,pateloup2004corner,shixiong2018tool}.
However, in all the papers it is assumed that every corner is formed by two
line segments which are
sufficiently long (relative to the angle between them) that a tangential
corner-rounding arc of sufficient size can be placed inside the wedge 
they form.
As can be seen in Figure \ref{beforeAfterRounding}, this is not always the case,
and rounding a toolpath can require more complicated modifications.

\begin{figure}
\centering
\includegraphics[page=8]{collectFigs.pdf}
\caption{The region 
has bounded convex curvature and all material in  will be machined using 
as the toolpath.
The innermost dotted curves are the boundary of the inwards offset of  by .
The thin corridor of  collapses so that the offset is split in two components.
Because of that, the region of  between the thick dashed arcs will not be machined if the double offset method is used.}
\label{boneFig}
\end{figure}

\subsection{Approaches based on Voronoi diagrams}
It may be tempting to think that an algorithm can be obtained by considering the Voronoi diagram of .
The Voronoi diagram is a plane graph with one face  for each object  of  (where an object is a vertex or an open line segment or circular arc) such that for every point in , the closest object of  is .

One heuristic that can be used to obtain a non-trivial subset of bounded convex curvature is the \emph{double offset method}, where we offset  inwards by  and then offset the result outwards by  and use that as .
Another way to express the same region is that  is the union of all unit disks contained in .
This can be computed from the Voronoi diagram as described by Held, Luk{\'a}cs, and Andor~\cite{held1994pocket}, and using Yap's algorithm~\cite{yap1987ano} for computing Voronoi diagrams, it will take  time.
However, the method does not in general result in the maximum subset of bounded convex curvature.
See for instance Figure~\ref{boneFig}.

\begin{figure}
\centering
\includegraphics[page=17]{collectfigs.pdf}
\caption{An example where it seems that the Voronoi diagram cannot be used to find the maximum subset of bounded convex curvature.
Neither the part of the diagram inside  (shown here in fat gray) nor outside  contain the center  of the arc from  to .}
\label{fig:considerations2}
\end{figure}

It is in general not true that the Voronoi diagram contains the center of the arcs that are needed to round the parts of the boundary of  where the convex curvature is too high.
Consider the example in Figure~\ref{fig:considerations2}.
We assume that the arcs centered at  and  have unit radius.
The Voronoi diagram contains a branch to the convex vertex , and  has bounded convex curvature everywhere except at .
To fix this, we need to trim this branch from the Voronoi diagram, but it is not clear how to do this using the Voronoi diagram as the center  of the unit radius arc from  to  is outside  and not contained in an edge of the Voronoi diagram (even if extended to the exterior of ).

Also note the spike with the concave corner .
If the unit radius arc from  to  does not cross the arcs incident at  (as in the figure), then we have obtained the solution by cutting along that arc and removing the corridor .
Otherwise, if  was above the arc from  to , the solution would simply consist of the two unit radius disks with centers  and .
Again, it is not clear how this information can be extracted directly from the Voronoi diagram.

Instead of using the Voronoi diagram, our algorithm works by locally modifying the boundary of .
Piece by piece, we remove parts of  where the convex curvature is too high.
The difficult part is to do this in such a way that we never remove too much and at the same time terminate after few iterations.

\subsection{Comparison with the conference version}

The paper has been almost completely rewritten since the conference version~\cite{abrahamsen_et_al:LIPIcs:2016:5896}.
First of all, we use another definition of bounded convex curvature, which is shorter, cleaner, and more general than what was used in~\cite{abrahamsen_et_al:LIPIcs:2016:5896}.
In order use this definition, we had to develop a generalized version of the Pestov Ionin Theorem which will be described in Section~\ref{mathFound}.
That work was mathematically challenging and has been published independently~\cite{aam2019disks}, so that this paper can focus on the algorithmic aspects.
Second, we give a more general algorithm that accepts input regions with holes, whereas the input in~\cite{abrahamsen_et_al:LIPIcs:2016:5896} had to be simply-connected.
Third, the nature of the algorithm has changed somewhat:
While we believe the algorithm as described in~\cite{abrahamsen_et_al:LIPIcs:2016:5896} to be correct, we encountered problems when working out subtle technical details in some proofs as we prepared (an earlier version of) this paper.
Our remedy is to describe an algorithm that is slightly less aggressive in the way it cuts away parts of  where the convex curvature is too high.
This comes at the cost of a more sophisticated argument bounding the total number of cuts to~.

\subsection{Outline of the paper}
We establish the mathematical foundation of our work in Section~\ref{mathFound} by referring to a recent generalization of the theorem of Pestov and Ionin.
In Section~\ref{algoDescription} we describe an algorithm that computes the maximum subset of bounded convex curvature of .
In Section~\ref{anImplementation}, we show that the algorithm has a simple implementation running in time  when the input is a general curvilinear region.
We also consider the special case where the input is simply-connected (i.e., a region with no holes), and here we describe a more involved implementation that runs in  time.

\section{Mathematical foundation}\label{mathFound}

\subsection{General notation and conventions}

If  is a set of points in the plane,  denotes the boundary of .
A \emph{curve}  is a continuous function from some interval  to the plane .
The curve  is \emph{simple} if it is injective.
We sometimes use  as a short-hand notation for the set of points  on .
A curve  is \emph{closed} if  for some interval  such that
.

We give simple, closed curves an orientation, either clockwise or counterclockwise.
If  is a disk, we always consider the boundary circle  to have counterclockwise orientation.
If  is a simple, closed curve and  and  are two distinct points on , then  denotes the portion of  from  to  in the direction of .
Round parenthesis can be used to exclude one or both endpoints.
If  is not closed, the order of  and  does not matter.
When  is an open curve, we say that a point  is an \emph{inner point} of  if  is not an endpoint of .


\subsection{Curves of bounded convex curvature and the theorem of Pestov and Ionin}

We say that a simple, closed curve  in the plane has \emph{bounded convex curvature} if for every point  on , there is a unit disk  and  such that  and , where .
Here,  denotes the region enclosed by .
Note that  has bounded convex curvature if and only if the region  has bounded convex curvature (as defined in Section~\ref{introSec}).
Inspired by the work of the preliminary version of this paper~\cite{abrahamsen_et_al:LIPIcs:2016:5896}, the authors proved the following theorem together with Anders Aamand~\cite{aam2019disks}, generalizing an old result by Pestov and Ionin~\cite{pestov1959largest}.

\begin{theorem}[\cite{aam2019disks}]\label{MAINTHM}
The region enclosed by any curve of bounded convex curvature contains a unit disk.
\end{theorem}

\begin{figure}
\centering
\includegraphics[page=6]{collectFigs.pdf}
\caption{A curve  of bounded convex curvature together with a unit disk  in its interior, the existence of which is guaranteed by Theorem~\ref{MAINTHM}.}
\label{mainThmFig}
\end{figure}

The correctness of the algorithm presented in this paper depends on Theorem~\ref{MAINTHM} as well as the following derived Theorem~\ref{mainThm}.
See Figure~\ref{mainThmFig} for an illustration of the theorem.

\begin{figure}
\centering
\includegraphics[page=7]{collectFigs.pdf}
\caption{Since , Theorem~\ref{mainThm} ensures the existence of a unit disk  which is not contained in .
The theorem does not make such a promise about , since  is in the exterior of .}
\label{mainThmFig}
\end{figure}

\begin{theorem}\label{mainThm}
Consider a curve  of bounded convex curvature and counterclockwise orientation.
Consider a disk  of any radius, and suppose that for an interval  of , it holds that .
Let  be the region enclosed by .
If  contains , then  contains a unit disk  which is not contained in . 
\end{theorem}

\begin{proof}
The condition that  contains  ensures that  consists of  and the region enclosed by , the latter of which is a subset of .
The overall proof is now similar to the one of Theorem~\ref{MAINTHM} from~\cite{aam2019disks}, which we assume the reader to know, but instead of choosing  as an arbitrary point on , we choose  on  and choose  as the maximal disk tangent to  in  and contained in .
If  has at least unit radius, we are done.
Otherwise, we observe that  meets  in at least two points, none of which can be in  since it would imply that .
We can then choose an interval  such that  and proceed as in the original proof.
\end{proof}

The concept of bounded convex curvature is a generalization of previously studied notions of bounded curvature; see~\cite{aam2019disks} for the details.
Versions of the theorem of Pestov and Ionin have often been applied to problems in robot motion planning and related fields~\cite{agarwal2002curvature,ahn2012reachability,ayala2015length,lazard2002complexity,lee2000approximation}.
These papers have studied problems involving curves of bounded curvature, whereas our restriction is one-sided so the class of curves is more general.
Ahn, Cheong, Matou{\v{s}}ek, and Vigneron~\cite[Lemma 2]{ahn2012reachability} gave a result analogous to Theorem~\ref{mainThm} for curves of bounded curvature.

\section{Algorithm}\label{algoDescription}

\subsection{Preliminaries}

We assume that a curvilinear region  in the plane is given.
That is,  is a connected, compact region bounded by a finite number of line segments and circular arcs of arbitrary radii.
These form simple, closed curves, where one curve is the outermost and the others bound the holes of .
The curves bounding the holes are contained in the region enclosed by the outermost curve and the holes have pairwise disjoint interiors.

We set  and our algorithm keeps removing parts of 
while maintaining the invariant that
 contains every subset of
 of bounded convex curvature.
In the end,  itself has bounded convex curvature and it follows
that  is the unique maximum subset of 
of bounded convex curvature.

The region  is always a collection of curvilinear regions.
Each region  is represented by the cycles forming the boundary .
Each cycle on the boundary  is represented as a set of points known as the \emph{vertices}
of  (and of ) and a set of line segments and circular arcs known as the \emph{arcs}
of  (and of ).
An \emph{object} of  (and of ) is a vertex or an arc of .

We think of line segments as circular arcs with infinite radius and therefore in most cases we use the word \emph{arcs} for both circular arcs and line segments.
Depending on the context, we may consider a vertex as a point or a set
containing a single point.
We use the convention that an arc includes its endpoints.
Every two arcs of  are disjoint except possibly at the endpoints, and
for each vertex there are exactly two arcs incident at that vertex.
This way, the arcs form the closed curves bounding .
We always use  to denote the number of vertices of the input .

Each cycle on the boundary  is oriented so that the interior of  is on the left.
For an outer cycle, this will be the counterclockwise direction, while for cycles bounding the holes, it will be clockwise.
Similarly, we orient each arc following the orientation of the cycle containing it.
We denote the endpoints of an arc  as  and , so that  starts at  and ends at .
An arc  of  is \emph{convex} if  turns to the left when traversed in forward direction.
Otherwise,  is \emph{concave}.
If  is a line segment, we regard it as both convex and concave at the same time.
A vertex  is \emph{convex} if the interior angle of  at  is strictly less
than . If the angle is strictly more than ,  is \emph{concave}.
If the angle is exactly , then  is \emph{tangential}.

When  and  are points on the same boundary cycle  of , we define  and  to mean the portion of  from  to  with respect to the orientation of .
Again, we may use round parenthesis to exclude one or both endpoints.

We require that no arc of the input  spans an angle of more than .
Arcs that span a larger angle can be split into two arcs connected by a tangential vertex.
This at most doubles the number of vertices and arcs.

Let  be an arc of  and  a point on . Then
 is the unit normal of  at  which points to the left
relative to the orientation of .
We say that two arcs  and  are \emph{tangential} if
 and
.
Note that  and  are tangential if and only if
the vertex  is tangential.

\subsection{Basic algorithm}

Until Section~\ref{sec:infinite}, we will consider a basic version of our algorithm, which is written as pseudocode in Algorithm~\ref{roundAlgSimple}.
As we will see, the algorithm is correct in the sense that if it returns , then  is the maximum subset of the input  of bounded convex curvature.
Unfortunately, the algorithm may go into an infinite loop and never return anything.
In Section~\ref{sec:active}, we will describe a more aggressive algorithm which terminates after  iterations.
The aggressive algorithm is similar to the basic algorithm, but makes some shortcuts to avoid the infinite loops.
We therefore describe the basic algorithm first, as it nicely illustrates the principle behind both algorithms.

The basic format is to repeatedly choose an object  of  that violates the condition of bounded convex curvature.
We say that such an object  is \emph{problematic}, and it can be a convex arc of radius less than  or a convex vertex. 
In each iteration of the loop at line~\ref{simple:loop}, we pick an arbitrary problematic object  and eliminate it by removing from  a subset .
By \emph{performing} a \emph{cut}, or simply a \emph{cut}, we mean the process of removing  from .
It is important to choose  such that  for every set  of bounded convex curvature.
Theorems~\ref{MAINTHM} and \ref{mainThm} will be used to prove this.

It is possible that a cut splits  into more components.
The algorithm will then keep working on each component separately.
Most cuts will introduce one or more new unit radius cut arcs on , the endpoints of which can be convex vertices.
The algorithm will proceed to work on these in subsequent iterations.

\begin{algorithm}[h]
\LinesNumbered
\DontPrintSemicolon
\SetArgSty{}
\SetKwInput{Input}{Input}
\SetKwInput{Output}{Output}
\SetKw{Report}{report}
\SetKwIF{If}{ElseIf}{Else}{if}{}{else if}{else}{end if}
\SetKwFor{Foreach}{for each}{}{end for}
\SetKwFor{While}{while}{}{end while}
\While { does not have bounded convex curvature} {\label{simple:loop}
  Let  be a convex arc of radius less than  or a convex vertex of . \\
  Remove  from . \\
}
\Return {}
\caption{}
\label{roundAlgSimple}
\end{algorithm}

Let  be the set  in the beginning of iteration  of the loop at line \ref{loop} in Algorithm~\ref{roundAlgSimple}.
Hence we have

The challenge is to define  in each iteration so that:
\begin{enumerate}
\item
 can be computed efficiently,
\item
 for every set  of bounded convex curvature, and
\item
the total number of iterations is linear, i.e., the algorithm returns  for some .
\end{enumerate}
The last requirement will not be satisfied by the basic algorithm described here.
In Section~\ref{sec:active} we will see that by making the algorithm more aggressive so that it removes larger sets  in some cases, we obtain an algorithm that fulfills all requirements.

\subsection{Specifying a cut using an arc }\label{sec:specifying}

Let  be a problematic object of  
that is to be eliminated in a certain iteration of Algorithm~\ref{roundAlgSimple}, and let  be the connected component of  such that  is an object of .
If we conclude that  does not contain any non-empty set of
bounded convex curvature, we set , so that all of the component  is removed from
.
We may conclude so when  has only  arcs.
Otherwise, we specify  using a circular arc 
of unit radius; see Figure \ref{cutFig}.
Assume for now that we have defined .
Let  and  be the points where  starts
and ends in counterclockwise direction, respectively.
The endpoints are included in  and
are points on .
They will be defined so that .

If  is a convex vertex, then  will connect the arc preceding  with the arc succeeding  on .
Otherwise,  is a convex arc of radius less than , and  will connect the endpoints of .
It is furthermore the case that  does not intersect , so that  forms a simple, closed curve consisting of up to three arcs.
Let  be the region enclosed by this curve.
The arc  will be chosen such that it is a concave arc of .

\begin{figure}
\centering
\includegraphics[page=2]{collectfigs.pdf}
\caption{
The dark gray area is the region  that will be removed in order to handle the convex corner .
This cut will split  into two smaller components, one with a single new cut arc and the other with two.
}
\label{cutFig}
\end{figure}

The arc  divides  into regions , which are
the connected components of .
Since we choose  such that , it follows that exactly one of the regions contains  on the boundary, and we may assume that it is .
We now simply define  as the region to be removed from .
Note that , but as shown in Figure~\ref{cutFig}, there may also be other regions  where , and these we do not remove from .

We now have that  is closed and so is our new
.
The arc  will be carefully chosen so that
 for every set 
of bounded convex curvature.

Consider the situation where we have chosen an arc  and thus removed a proper subset  from a connected component  of  to obtain .
The remaining part of  consists of a number  of components , and each of these  will have one or more arcs  which are contained in .
In other words, these arcs are the common boundary of the remaining component  and the removed part .
If  is simply-connected, there will be exactly one such arc for each , but when  has holes, there can be more, as seen in Figure~\ref{cutFig}.
We denote the arcs  as \emph{new cut arcs} of .
Note that since the arc  defining a cut is a concave arc of , , and the common boundary between  and  consists of arcs on , we get that all new cut arcs of  are convex.

In general, a \emph{cut arc} of  is a convex arc of unit radius. 
For technical reasons, this even includes convex arcs of unit radius of the original input .
We say that a cut arc  is \emph{perfect} if no endpoint of  is a convex vertex.

An important concept in our algorithm is that of a unit radius arc from one point to another.
Consider two points  and  with distance at most  and let  be the unique unit disk such that  and the arc  spans an angle of at most .
We then define the \emph{unit radius arc} from  to  to be this arc .
In fact, it will always hold that  is the unit radius arc from  to .

Recall that we require that all arcs of the input  span an angle of at most .
We now show that this property is maintained by the algorithm.

\begin{lemma}\label{lem:leqpi}
Every arc created by the algorithm spans an angle of at most .
\end{lemma}

\begin{proof}
The only arcs for which we need to verify the property are the new cut arcs, as all other arcs can only shrink.
The statement thus holds if for every cut we make, the arc  specifying the cut spans an angle of less than .
This is trivial since we define  as the unit radius arc from a point  to a point , which by definition is an arc spanning an angle of at most .
\end{proof}

Before we can describe how to choose the arcs defining our cuts in Section~\ref{cutDef}, we need the notions of touching disks and bisectors of arcs, as defined in the following section.

\subsection{Touching disks and bisectors of arcs}

Let  be an arc of .
A disk  \emph{touches}  at  if
\begin{itemize}
\item
the interior of  is disjoint from ,

\item
 and  have the
point  in common, and

\item
the center  of  is the point  where  is the radius of  (recall that  is the unit normal to  in  pointing to the left).
\end{itemize}

\begin{figure}
\centering
\includegraphics[page=13]{collectfigs.pdf}
\caption{
Two arcs  and  and the bisector  that they define.
Here,  is limited by .
}
\label{fig:bisector}
\end{figure}

We allow the case , where  is a single point.
Note that for  to touch an arc  of , we do not require that  be contained in .

It always holds that the point  where  touches  is the point on  closest to the center  of .
A special case happens when  is an arc on , in which case  is a convex arc and  touches  at every point on .

The \emph{bisector}  of two arcs  and  of  is the locus of the centers of all disks that touch both  and ; see Figure~\ref{fig:bisector}.
Then  is an open curve, and Yap~\cite{yap1987ano} showed that  is part of a conic section.
For a point , we define  to be the disk with center  that touches  and .
Let the endpoints of  be  and  such that  touches  at  or  at , and  touches  at  or  at .
We then orient  from  to .
If  contains , we say that  \emph{limits} , and otherwise that  \emph{limits} .
Note that sometimes  is not be contained in .

For a point , we define  as the point .
In the exceptional case where  is the center of  so that this is not unique, we define .
We define  similarly, except that when  is the center of , we define .

When defining the arc  that specifies the cut we want to perform, we are often searching for the first point  on a bisector , with respect to the orientation of , where  has radius .
If there is no such point, we choose  as the end of .
Using elementary geometry, we can compute the point  in constant time.

When we have chosen , we shall define  to be the unit radius arc from  to .
If  has radius , then  will be an arc on , but otherwise, the radius of  is less than  and then  will be passing through the interior of .

Since  touches  and , we have that  and  consist of the single points  and , except in the special case where  or  is an arc on .
Since  is contained in , we can therefore likewise conclude that  and , unless  and  or  and  are both arcs on .
This property will be crucial when proving that the algorithm works, since it allows us to prove that  forms a simple, closed curve.

\subsection{Defining the arc  specifying a cut}\label{cutDef}

The arc  that defines a cut is specified by one of the following two types.
Recall that  is an object of , which is either a convex arc of radius less than  or a convex vertex. 
Figure~\ref{fig:cuttypesSimple} shows an example of each type of cut.
In each case, we define  to be the arc preceding  and  to be the arc succeeding  on .
The statement inside the square brackets [ ] specifies when the type of cut applies.

\begin{figure}
\centering
\includegraphics[page=11]{collectFigs.pdf}
\caption{An example of each type of cut of the basic algorithm.}
\label{fig:cuttypesSimple}
\end{figure}

\begin{enumerate}
\item[1.]
[ is a convex arc with radius less than .]
We define  as the unit radius arc from  to .

\item[2.]
[ is a convex vertex of .]
We consider the bisector .
 
\begin{enumerate}
\item[2.1.]
[There is  such that  has radius .]
We choose the first such  and define  as the unit radius arc from  to , which is the same as the arc .

\item[2.2.]
[Otherwise], we choose  as the end of  and  as the unit radius arc from  to .
\end{enumerate}
\end{enumerate}

This finishes the description of the basic algorithm.

\subsection{Basic properties of cuts}\label{sec:basicSimple}

In this section, we prove that the way we defined the arcs specifying cuts in Section~\ref{cutDef} ensures that the cuts have certain important  properties.
Recall that we claimed the set  to be a simple, closed curve, and we defined  to be the region bounded by this curve.
This property was used when defining the set  to be removed in each cut.
We now prove this claim.

\begin{restatable}{lemma}{simplecurvelemma}
\label{lem:simplecurve}
The arc  intersects  at the points  and  only.
Thus, it holds that  is a simple, closed curve.
\end{restatable}

\begin{proof}
For cuts of type 1, the arcs  and  intersect at  and .
There can be at most  intersection points as the arcs have different radii, so the statement holds in this case.

Now consider a cut of type 2.
Here, we choose  in the disk  that touches  and .
We claim that  consists of a single point, and similarly for .
If  consists of more than one point, then it must be the case that  is an arc on .
Now, since  and  have the point  in common,  also touches  at .
Hence,  and  are tangential at , which contradicts this type of cut.
As  and  consist of single points and  is contained in , the statement now follows.
\end{proof}

We define  to be the unit disk with  on the boundary.
As we will see, the correctness of the algorithm relies on the following crucial lemma.


\begin{restatable}{lemma}{unitdisklemma}
\label{lem:unitpropSimple}
The only unit disk contained in  is .
\end{restatable}

\begin{proof}
If there is another unit disk  in , then  overlaps .
For a cut of type 1, that is clearly not possible as  is a convex arc of radius less than .

Let us now consider a cut of type 2.1; a cut of type 2.2 can be analyzed in a similar way.
We move  in the direction away from the center of  until we are blocked by the boundary of , so that there is a point .
The proof now branches out in several cases depending on where this point  is on , and all of these cases are easy to refute.
 
Suppose first that .
Since  and  are both disks of radius , this implies that they are the same disk, which is a contradiction.

Suppose now that .
Since  touches  and  in these points and  and  both have radius , it again follows that they must be the same disk, which is a contradiction.

Therefore, we are left with the possibility that .
Hence, we have  or .
It follows that there exists a unit disk osculating  and  at points closer to  than  does, which is a contradiction.
\end{proof}

With these lemmas, we are now ready to prove that the basic algorithm is correct.

\subsection{Correctness of the basic algorithm}\label{correctness}

In this section, we prove that the set  to be cut away from 
is disjoint from every subset of  of bounded convex curvature.
The proof is by contradiction. The idea is that if there is a subset of
 of bounded convex curvature
that overlaps , then Theorem~\ref{MAINTHM} or~\ref{mainThm} shows the existence of a unit disk in  which cannot be there according to Lemma~\ref{lem:unitpropSimple}.
We first prove a lemma of a more general nature, which will also turn out useful when describing an implementation of our algorithm in Section~\ref{anImplementation}; see Figure~\ref{fig:lemma:algCurve}.

\begin{figure}
\centering
\includegraphics[page=22]{collectfigs.pdf}
\caption{Lemma~\ref{lemma:algCurve} says that the region  does not contain a curve of bounded convex curvature, such as the curve  shown here.
Furthermore, the interval  cannot be contained in , as  is contained in the region bounded by .}
\label{fig:lemma:algCurve}
\end{figure}

\begin{restatable}{lemma}{lemmaalgcurve}
\label{lemma:algCurve}
Let  be the arc that defines the cut we make to get from  to  for any iteration .
For every curve  of bounded convex curvature and counterclockwise orientation, the following holds.
\begin{enumerate}
\item
.

\item\label{lemma:algCurve:it2}
Suppose that an interval  satisfies , , and that the region bounded by  contains .
Then .
\end{enumerate}
\end{restatable}

\begin{proof}
Consider for contradiction
a situation where the statement is violated by a curve  of bounded convex curvature.
Suppose first that .
By Theorem~\ref{MAINTHM}, the interior of  contains a unit disk  which is also contained in , but that contradicts Lemma~\ref{lem:unitpropSimple}.

Consider now an interval  as described in point~\ref{lemma:algCurve:it2}.
Assume for contradiction that .
By Theorem~\ref{mainThm}, we get that the region  bounded by  and  contains a unit disk different from .
As , this contradicts Lemma~\ref{lem:unitpropSimple}.
\end{proof}

We are now ready to prove the correctness of the simple algorithm.

\begin{restatable}{theorem}{thmcorrect}
\label{algOptimalSimple}
For every set  of bounded convex curvature and every iteration , the set  contains~.
\end{restatable}

\begin{proof}
Let  be a set of bounded convex curvature, and assume for contradiction that  while , where  is chosen to be minimal.
Let  be the arc defining the cut we make in  in order to get .
Without loss of generality, we can assume that  has one connected component.
The outer boundary of  is a curve  of bounded convex curvature.
If , we get from the minimality of  that also .
Since  by definition, this contradicts Lemma~\ref{lemma:algCurve}.

On the other hand, if , we get by the minimality of  that  exits  through a point on .
Let  be the point in  closest to .
We now follow  after  and observe that  must enter  at a point  on .
Hence, the region  bounded by  and  contains .
By the minimality of , we have .
However, the existence of such an interval  contradicts Lemma~\ref{lemma:algCurve}.
\end{proof}

\subsection{Infinite loops}\label{sec:infinite}

\begin{figure}
\centering
\includegraphics[page=16]{collectfigs.pdf}
\caption{Left: The basic algorithm can end in an infinite loop of cuts of type 2.2 when rounding vertex .
The algorithm would create convex vertices  that converge to a tangential vertex.
Right: Even if we make a more sophisticated type of cut where the arc  is tangential to one arc and goes to the endpoint of the other, we can get into an infinite loop.
In order to round , we would create and thereafter round the infinite sequence of vertices .}
\label{fig:considerations1}
\end{figure}

Figure~\ref{fig:considerations1} (left) shows that the basic algorithm may go into an infinite loop.
Here, the algorithm keeps making cuts of type 2.2, because such a cut always produces a new convex vertex (although in the limit, a tangential vertex is created).
If we are slightly more careful, we can instead of type 2.2 introduce new types of cuts:
When type 2.1 is not applicable, we first try to use an arc which is tangential to  or  and has an endpoint in  or , respectively.
If that is not possible, we choose  as the unit radius arc from  to .
With these rules, we would avoid the infinite loop seen in Figure~\ref{fig:considerations1} (left), as we would jump directly to the arc in the limit.
However, as shown in Figure~\ref{fig:considerations1} (right), it would still be possible for the algorithm to go into an infinite loop.
Due to such phenomena, we introduce the concept of an \emph{active} cut arc, which is a cut arc introduced in an earlier iteration where one or both endpoint are convex vertices of , as explained in the next section.

\subsection{Active cut arcs and aggressive algorithm}\label{sec:active}

As we saw in the previous section, the basic algorithm may make an infinite number of iterations where cut arcs are created with a convex endpoint, such that we never obtain a set of bounded convex curvature.
In order to resolve this issue, we introduce the notion of an \emph{active} cut arc, which is a new type of problematic object that our algorithm must be able to handle (the other two types being convex vertices and convex arcs of radius less than , as in the basic algorithm).

The active cut arcs get priority to be handled before the other problematic objects in the same component of , and we will introduce special cut rules describing how to handle them below.
The cut rules will result in larger regions  to be removed from  in iterations where the problematic object is an active cut arc.
We therefore say that the resulting algorithm is \emph{aggressive}.
The old types of problematic objects (convex vertices and convex arcs of radius less than ) are handled as by the basic algorithm, but only if there is no active cut arc in the same component of .
The pseudocode of the resulting algorithm can be seen in Algorithm~\ref{roundAlg}.
One can think of the new cut rules as a way to shortcut the process of the basic algorithm (and variations of it as described in Section~\ref{sec:infinite}) so that instead of making an infinite sequence of cuts that converge to some arc in the limit, we directly make a cut defined by that limit arc.

We now describe when a new cut arc becomes an active cut arc.
Consider the situation where we have chosen an arc  and thus removed a subset from a connected component  of  to obtain .
The remaining part of  consists of a number  of components , and each of these  will have one or more new cut arcs  which are contained in .
If , i.e., a component  has only one new cut arc, and that arc  is not perfect (which implies that one or both endpoints of  is a convex vertex), then we define  to be the \emph{active} cut arc of .
Otherwise, no arc of  is active.
Note in particular that at any time during the execution of the algorithm, each component of  has at most one active cut arc.

\begin{algorithm}[h]
\LinesNumbered
\DontPrintSemicolon
\SetArgSty{}
\SetKwInput{Input}{Input}
\SetKwInput{Output}{Output}
\SetKw{Report}{report}
\SetKwIF{If}{ElseIf}{Else}{if}{}{else if}{else}{end if}
\SetKwFor{Foreach}{for each}{}{end for}
\SetKwFor{While}{while}{}{end while}
\While {a connected component  of  does not have bounded convex curvature} {\label{loop}
  Let  be the active cut arc of  if there is one, and otherwise let  be a convex arc of radius less than  or a convex vertex of . \\
  Remove  from . \\
  For each resulting component , if  has exactly one new cut arc  and  is not perfect, mark  as active. \\
}
\Return {}
\caption{}
\label{roundAlg}
\end{algorithm}







In the following, we specify the cut rules when the problematic object is an active cut arc .
Figure~\ref{fig:cuttypesActive} shows an example of each type of cut.
Again, a cut will be specified by an arc  with endpoints  and  on the boundary , as described in Section~\ref{sec:specifying}.
We define  to be the arc preceding  and  to be the arc succeeding  on .
The statement inside the square brackets [ ] specifies when the type of cut applies.

The intuition behind the rules is that in order to avoid infinite loops, we should prefer to make cuts that either completely removes  or  or such that the disk  touches  and .

\begin{figure}
\centering
\includegraphics[page=20]{collectFigs.pdf}
\caption{An example of each type of cut when the problematic object  is an active cut arc.}
\label{fig:cuttypesActive}
\end{figure}

\begin{enumerate}
\item[3.]
[ is a cut arc with a convex endpoint  and the other arc incident at  is also a cut arc.]
Suppose without loss of generality that . 
We then define  to be the unit radius arc from  to .

\item[4.]
[ is a cut arc with a convex endpoint, the other endpoint of  is tangential or convex, and each neighbour incident at a convex endpoint of  is not a cut arc.]
Consider the bisectors  and , and let  be the end of  and  be the end of .
\begin{enumerate}
\item[4.1.]
[ limits  and  is not a cut arc, or  limits  and  is not a cut arc.]
Without loss of generality, assume that  limits .
We then choose  as the unit radius arc from  to , where  is the end of .

\begin{convention}\label{conv:double}
Let  be the component where  appears on the boundary after the cut, and let  be the part of  that is an arc of  incident at .
Then  is a convex vertex shared by the two cut arcs  and .
If  is the only new cut arc of its component, then  will be an active cut arc.
Hence, the next cut in  must be of type 3.
However, if the other neighbour of  is also a cut arc , it is not specified if we should cut from  to  or from  to .
For technical reasons (to be used when bounding the number iterations made by the algorithm in the proof of Lemma~\ref{linearIts}) we make the convention that we always choose the last of these two options, so that after the next cut, both  and  will have disappeared from .
\end{convention}

\item[4.2.]
[Otherwise], there exists a disk  of radius at most  that touches , , and .
Let  be the center of .
We then consider the bisector  and follow  from  until we get to a point  where  has radius  or we get to the end of , so we have two types~4.2.1 and 4.2.2 as for type 2.
\end{enumerate}

\item[5.]
[ is a cut arc with a convex endpoint , the other arc incident at  is not a cut arc, and the other endpoint of  is concave.]
Without loss of generality, assume that .
We have two subtypes.
\begin{enumerate}
\item[5.1.]
[There exists a disk  of radius  touching  at a point  and containing .]
If there are more, we choose  with the contact point  closest to .
We then define  as the unit radius arc from  to .

\item[5.2.]
[Otherwise], we define  to be the unit radius arc from  to .
\end{enumerate}

\end{enumerate}

This finishes the description of our aggressive algorithm.



\subsection{Basic properties of aggressive cut rules}

We now prove that the cut rules for handling active cut arcs have the same properties as the ones described in Section~\ref{sec:basicSimple}.
We therefore repeat the lemmas and give proofs for the new cut rules when needed.

\simplecurvelemma*


\begin{figure}
\centering
\includegraphics[page=14]{collectFigs.pdf}
\caption{Figures for the proof of Lemma~\ref{lem:simplecurve}.
Left: Fact~\ref{fact:fact} says that the unit arcs from  to  and  to  only intersect at .
Right: A special case of a cut of type 4.1.
}
\label{fig:factetc}
\end{figure}

\begin{proof}[Proof for cut rules 3--5.]
We use the following fact which is easy to check; see Figure~\ref{fig:factetc} (left) for an illustration.

\begin{fact}\label{fact:fact}
Let  be three points such that the distance from  to each of  and  is at most .
Then the unit radius arcs from  to  and from  to  have only the point  in common, unless one arc is contained in the other.
\end{fact}

We now divide into the type of cut, as follows.
\begin{enumerate}
\item[3.]
We need to prove that 
 and .
Let  be the unit disk with  and define  similarly.
We first observe that  or : if both of these properties are violated, it is easy to see that  and  have two intersection points, which contradicts that the boundary  is a simple, closed curve.
So suppose without loss of generality that .
It then follows that the distance between  and  is at most .
Since we know that  and  both span angles of at most , we also have that  is the unit radius arc from  to  and that  is that from  to .
It now follows from Fact~\ref{fact:fact} that  and  have only the point  in common and  and  have only the point  in common, so the statement follows.

\item[4.]

Note that it follows for cuts of this type that if  (resp.~) is a cut arc, then  and  (resp.~ and ) are tangential.
If the shared vertex is convex, we should make a cut of type 3 instead.

\begin{enumerate}
\item[4.1]
We consider without loss of generality the case that  limits  and  is not a cut arc.
We choose  in the disk  touching  and , where the center  is the end of .
Suppose that  consists of more than one point.
As for cuts of type 2, we conclude that  and  are tangential at  and that .
Since  is not a cut arc, we get that  has radius less than  and that  touches  at , as shown in Figure~\ref{fig:factetc} (right).
The arc  is therefore the unit radius arc from  to .
The cut is similar to one of type 1, so the result follows.

Suppose now that  consists of one point and that  consists of more than one point.
Again, we conclude that  and  are tangential at  and that .
Now, since  limits , we conclude that  is also a cut arc, but that contradicts our assumption.

On the other hand, if  and  both consist of single points, then it follows directly that  is a simple, closed curve, as .



\item[4.2]
We first prove that  and  consist of single points.
For instance, suppose that  has more points.
Then  must be an arc on , and since  is a unit disk,  is a cut arc.
But then  and  are two cut arcs with a common vertex  which must be tangential.
We conclude that  must be convex in order for the cut to be of type 4, but then  enters the interior of  at , which contradicts that  touches .
Hence,  and  consist of single points.

\begin{figure}
\centering
\includegraphics[page=23]{collectFigs.pdf}
\caption{Figures for the proof of Lemma~\ref{lem:simplecurve}.
Left: For a cut of type 4.2, it is not possible that the arcs  and  are tangential, since that would separate  from  so that  cannot connect them.
Right: For a cut of type 5.2, it leads to a contradiction if  and  have an extra intersection point .}
\label{fig:factetc2}
\end{figure}

It remains to be verified that  and  are disjoint.
Recall that we defined  to be a point such that the disk  touches , , and .
We then follow  from  until we get to a point  where  has radius  or we get to the end of .
For any point , we define  to be the unit radius arc from  to .
If  and  are not disjoint, we may consider the first point  after  where  and  intersect.
This may happen for two different reasons: (i)  contains an inner point of  or (ii)  contains an endpoint of .
Consider first case (i).
It is not possible that an intersection point in  is an endpoint of , because then  would intersect  or  at points other than  and .
Hence,  and  are tangential and touch each other at a unique point  which is an inner point of both arcs; see Figure~\ref{fig:factetc2} (left).
It is now easy to verify that the simple, closed curve  separates  from .
Hence,  has to intersect , which is impossible.
We now consider case (ii).
If  and  intersect at an endpoint of , we get that  or  self-intersect or intersect each other, which cannot happen.
But it also cannot happen that  and  intersect at an inner point of , since  is contained in the disk  which intersects  and  only in the points  and .
\end{enumerate}

\item[5.]
In both types 5.1 and 5.2, we get from Fact~\ref{fact:fact} that  and  intersect only at .
\begin{enumerate}
\item[5.1]
Since  and  are tangential, they can have only one intersection point, and the statement follows.

\item[5.2]
Suppose for contradiction that  and  in addition to the point  also intersect at a point ; see Figure~\ref{fig:factetc2} (right).
Let  be the unit disk containing .
We now consider rotating  clockwise so that  always contains .
Then the intersection points , which are initially  and , will move towards each other.
Eventually, there will be a single intersection point somewhere in between the two intersection points , and  will be a unit disk touching  and with , thus fulfilling the requirements for a cut of type 5.1.
Hence, the cut should not have been of type 5.2, but of type 5.1.
\qedhere
\end{enumerate}
\end{enumerate}
\end{proof}

We now obtain Lemma~\ref{lem:unitpropSimple} for our new cut rules.
The argument is similar to the one in the proof for cuts of type 2.

\unitdisklemma*

\subsection{Correctness of the aggressive algorithm}

We now obtain Lemma~\ref{lemma:algCurve} for Algorithm~\ref{roundAlg}, by an unchanged proof.

\lemmaalgcurve*

We can finally state the correctness of Algorithm~\ref{roundAlg}, which again follows by an identical proof.

\thmcorrect*



\subsection{Linear bound on the number of iterations}
\label{sec:linear}

In order to bound the number of iterations,  we first bound the number of some special types of cut arcs and cuts, which are then used to bound the remaining ones.

\begin{lemma}\label{lem:perfCutArcs}
At most  perfect cut arcs are created by Algorithm~\ref{roundAlg}.
\end{lemma}

\begin{proof}
We show that each time we make a perfect cut arc, it corresponds to drawing an edge in a directed plane graph  with  vertices.
In this graph, there can be multiple edges from one vertex to another, but whenever that is the case, the region enclosed by two neighbouring edges will contain another vertex.
It hence follows from a variant of Euler's formula that there can be at most  edges in total.

We first observe that when making a perfect cut arc , each endpoint of  is either an original vertex of  or a point on an original arc of :
Otherwise, an endpoint  of  is on another cut arc made in a previous iteration.
But then  is a convex vertex, so  is not perfect.

The vertices of our graph  are the original vertices of  and the original arcs of .
Here, each arc excludes the endpoints, such that the vertices of  are pairwise disjoint.

Now suppose that we make a perfect cut arc  by cutting along an arc  in order to handle a problematic object.
We then draw an edge from  to  contained in .
Since the vertices of  are pairwise disjoint, this uniquely defines the vertices in  that we connect.
Because we draw the edge in the region  that we remove, the edges from different iterations cannot cross and the result is a plane graph.
Suppose that we draw multiple edges  from one vertex to another in  that appear in this cyclic order around one of the vertices.
We now prove that for each , the region  enclosed by  and  contains a hole of .
This translates to saying that  contains a vertex of .
Undirected plane graphs with this property and  vertices are known to have at most  edges~\cite{abrahamsen2020tiling}, and our graph  has  vertices and is directed.
We can partition the edges into two sets so that in each set, there are no anti-parallel edges.
Hence, there are at most  edges in each set, so  has at most  edges.

\begin{figure}
\centering
\includegraphics[page=3]{collectFigs.pdf}
\caption{Situation in the proof of Lemma~\ref{lem:nperfectcutarcs}.
The region  is gray (light and dark), and  is dark gray.
It is impossible that the algorithm removes a subset  of .}
\label{fig:nottwoarcs}
\end{figure}

For any pair of vertices  of , there is at most one unit radius arc from  to , so there can be made at most one perfect cut arc from  to , and it remains to bound the number of perfect cut arcs with an endpoint on an inner point of an arc of .
Suppose that we draw two edges from  to , where  and  are arcs of ; see Figure~\ref{fig:nottwoarcs}.
The case where we draw an edge between a vertex and an edge follows from a similar reasoning.
Say that in iterations  and , where , we introduce perfect cut arcs  and , respectively, connecting  and .
Let  and  be the edges we draw in  corresponding to  and .
Let  be the region bounded by the simple, closed curve , which corresponds to the region enclosed by  and  in the graph .

Suppose for contradiction that  does not contain a hole of .
Then, since , it follows that .
As , we then have that  becomes one cut arc of .

Define  to be the region bounded by the simple, closed curve , consisting of , , and parts of  and .
There is no convex vertex on the boundary  since the endpoints of the arc  are tangential.
Since the algorithm later cuts along , a convex vertex must appear in  in some iteration  in between the two cuts, i.e., .
The cut in iteration  removes a region  and since it creates a convex vertex in , we must have .
But the only boundary of  in  is , which has no convex vertex, so the algorithm would not remove such a region , which is a contradiction.
\end{proof}

We now study cuts of type 4.2.1 and 5.1.
These are special in that they are the only cuts where we handle a cut arc  and parts of both of the neighbours  and  of  remain on  after the cut.
In all other cuts handling a cut arc , one of the neighbours of  is completely removed.

\begin{lemma}\label{lem:nperfectcutarcs}
Algorithm~\ref{roundAlg} makes at most  cuts of types 4.2.1 and 5.1.
\end{lemma}

\begin{proof}
The argument is similar to that used in the proof of Lemma~\ref{lem:perfCutArcs}:
We define a plane graph , where the vertices of  are the vertices and edges of .


We first observe that when making a cut of type 4.2.1, the neighbours  and  of  must both be original arcs of :
Otherwise one of them, say , is a cut arc, and the unit disk  touches , so .
The vertex  must be tangential (otherwise we should make a cut of type 3), and therefore we also have .
Hence  is convex (otherwise  would be perfect), so  does not touch , which is a contradiction.

For a cut of type 5.1, assume without loss of generality that  touches  and that .
Then  must be an arc of , by a similar reasoning as for type 4.2.1.
Furthermore,  is a concave vertex by definition of the cut type, so the vertex must be an original vertex of , since it is easy to check that all new vertices made by the algorithm are either tangential or convex.
Therefore the objects we have included as vertices in our graph  are sufficient.
We can then proceed as in the proof of Lemma~\ref{lem:perfCutArcs}.
\end{proof}

\begin{figure}
\centering
\includegraphics[page=21]{collectFigs.pdf}
\caption{Situation in the proof of Lemma~\ref{lemma:holearcs}.
The shown cut splits a component into four pieces, eliminates four holes, and creates seven hole cut arcs.}
\label{fig:lemma:holearcs}
\end{figure}

Consider a component  of  with new cut arcs .
If , we denote these arcs as \emph{hole cut arcs}, since their creation corresponds to the elimination of  holes in , as explained in the proof of the following lemma.

\begin{lemma}\label{lemma:holearcs}
Less than  hole cut arcs are created by Algorithm~\ref{roundAlg}.
\end{lemma}

\begin{proof}
Consider the arc  that defines the cut to be made in  in order to obtain .
Suppose that the cut creates hole cut arcs  of  that appear in this cyclic order along ; see Figure~\ref{fig:lemma:holearcs}.
We choose a point , and in each connected component  of , we choose a point .
For each , we now choose an open curve  from  to , where  is the component of .
We choose a curve  that consists of one interval contained in  and the other in , so that  leaves  through a point on .
Furthermore, these curves  can be chosen to be pairwise disjoint except for the endpoints.
For a pair  of hole cut arcs that are consecutive on the same component of , the closed curve  enclose a hole  where , which we associate to the arc .
We now observe that no other hole cut arc can be associated to the same hole :
The curve  separates  from all hole cut arcs in the exterior of , and a hole cut arc  in the interior of  can only be associated to a hole  which is separated from  by another curve  contained in the interior of .
Each hole  is merged with the exterior of  due to the cut, so the number of holes decreases by at least .
Since we start with less than  holes, it follows that we create less than  hole cut arcs in total.
\end{proof}


\begin{lemma}\label{linearIts}
Algorithm~\ref{roundAlg} performs  iterations and makes in total  cut arcs.
\end{lemma}

\begin{proof}
We make an amortized analysis where we assign credits to the arcs of  which are used to ``pay'' for later iterations.
All in all, we will create  credits, and each credit can be used to pay for one iteration, so the statement follows.

\begin{figure}
\centering
\includegraphics[page=15]{collectFigs.pdf}
\caption{Left: The fat arcs are the new cut arcs . The arc  is a double cut arc and is thus the union of two arcs.
Right: The arc  is an active cut arcs and the arcs have credits according to the invariant.}
\label{fig:doublecutarc}
\end{figure}

Before we describe the actual accounting scheme, we explain the concept of a \emph{double cut arc}, which allows us to express the invariant of our accounting scheme in a much simpler form:
Suppose that we have picked an active cut arc .
Then  is completely removed from  except if the cut is of type 4.1.
In a cut of type 4.1, a part of  will remain and be adjacent to one of the new cut arcs created by the cut.
To be precise, let the new cut arcs created be , and suppose that  is the part of  that remains; see Figure~\ref{fig:doublecutarc} (left).
Then  is a neighbour of  or .
Without loss of generality, consider the second case.
We then consider  to be a single cut arc, which we call a \emph{double cut arc}.
By slight abuse of notation, we shall from now on (but only in this proof) denote this double cut arc as .
By Convention~\ref{conv:double}, we know that if the double cut arc  is active, then it will disappear by the following cut in its component due to a cut of type~3.

We can now express the desired invariant; see Figure~\ref{fig:doublecutarc} (right).
Initially, we put  credits on each arc of the original input .
We will keep the following invariant. 

\textbf{Invariant:}
\emph{
In each connected component  of , the following holds:
If  has an active cut arc , then  has at least  credit.
All arcs of  that are not active or neighbours of an active cut arc have at least  credits.
}

Let  be the element 
that the algorithm is handling in one iteration.
If  is an active cut arc, then it has at least  credit by the invariant, and this is used to pay for the present iteration.
Otherwise, all arcs in the component of  have  credits and  is a convex vertex or a convex arc with radius less than .
If  is a convex vertex, we use  credit from one of the incident arcs to pay for the iteration.
If  is a convex arc of radius less than , then  has  credits and we use  to pay for the iteration.
We now show that by paying for the iterations in this way, we are able to maintain the invariant.

\begin{figure}
\centering
\includegraphics[page=10]{collectFigs.pdf}
\caption{Left: A cut creates three new cut arcs  and their neighbours  are shown. (Not all arcs of  are shown.)
Right: An example where  is a double cut arc and .}
\label{fig:arcAB}
\end{figure}

Consider the arc  that defines the cut to be made in order to handle the object .
Suppose that the cut generates  cut arcs , all contained in , which are the new cut arcs of .
Here,  or  may be a double cut arc (which is the case if the cut is of type 4.1).
Let  and  be the arcs of  preceding and succeeding ; see Figure~\ref{fig:arcAB} (left).
We denote the arcs  as the \emph{neighbour arcs} of .

Some of the new cut arcs  will be active in their component.
Recall that this is the case for an arc  if  is the only new cut arc in its component and  is not perfect.
We need to ensure that we can assign  credit to the active cut arcs and  to all the others and their neighbours.

If  is a new perfect cut arc, we can create  new credits so that we can assign  credits to  and the neighbour arcs  and .
By Lemma~\ref{lem:perfCutArcs}, this results in the creation of at most  credits in total.
In the following, we prove that we can also assign enough credits to the new cut arcs that are not perfect and their neighbours.

The arcs  and  stem from arcs  and  of , respectively, which contain  and , but are generally longer.
We denote the arcs  as the \emph{original neighbour arcs}.
It is possible that different neighbour arcs of  stem from the same original neighbour arc of .
For instance, we can have  or .
Furthermore, it may be the case that the outermost original neighbour arcs  and  have no credits because they are neighbours of the active cut arc  in .
As we will see, enough of the original neighbour arcs will have  credits so that they can be distributed in a way that satisfies the invariant.

Let us consider the event that three of the neighbour arcs stem from ; see Figure~\ref{fig:arcAB} (right) for an example where this happens.
We claim that this is possible only if 
 is a double cut arc.
If 
 is not double, then  intersects  three times, which is impossible.
Similarly, at most three neighbour arcs can stem from .
We also see that it is impossible that four neighbour arcs stem from  or , since that would imply that one of these arcs had three intersection points with .
We conclude that at most six of the neighbour arcs stem from  or .
Similarly, consider an original neighbour arc  or  which is not  or .
It is possible that two neighbour arcs stem from such an arc, but not more than that.

With these observations in mind, we now prove that the scheme for redistributing credits works.
We first consider the components of  that have more than one new cut arc contained in . 
If  of the arcs  are on the same component  of , then these are hole cut arcs.
We create  credits for each of the  new cut arcs of  and their neighbours, and the invariant is then satisfied for .
By Lemma~\ref{lemma:holearcs}, this results in the generation of at most  credits in total.

We now define  to be the number of components created that have exactly one active cut arc contained in , and we need to verify that we can distribute the credits so that these  new cut arcs get  credit each.
We divide into two cases depending on the number  of these components:
\begin{itemize}
\item[]
If  or  has  credits, the  arcs can get a credit each and the invariant holds.
When  and  have less, the object  must have been an active cut arc, and  and  must be the neighbours of  on .
Furthermore,  is chosen according to a cut of type 4.2.1 and 5.1, since for cuts of all other types, one of the neighbours of  is completely removed, and then one of  and  would have  credits.
By Lemma~\ref{lem:nperfectcutarcs}, there are only  cuts of type 4.2.1 and 5.1, so we can afford to generate  new credits every time to be placed on the new arcs.

\item[]
Since at most six of the neighbour arcs can stem from  or , there are at least  that do not.
These stem from at least  unique original neighbour arcs of  that have  credits each, so we have  credits available.
Hence, there are enough credits for the  new cut arcs to get  credit each.
\end{itemize}

Since each new cut arc gets at least  credit and we generate at most  credits, it follows that the algorithm makes in total  cut arcs.
\end{proof}

We have now proved the following theorem.

\begin{theorem}\label{LTThm}
Given a curvilinear region  bounded by  line segments and circular arcs,
there is a unique maximum set 
of bounded convex curvature
which contains every set 
of bounded convex curvature.
At any time during the execution of Algorithm~\ref{roundAlg}, the boundary
 consists of  line segments and circular arcs, and
the algorithm returns the result  after  iterations.
\end{theorem}

\section{Implementation}\label{anImplementation}

Here we describe two implementations of the algorithm.
The first one runs in  time and works for general curvilinear regions in the standard DCEL (doubly connected edge list) representation, with no additional data structures required.
The second runs in  time and works under the assumption that the input  is a simply-connected curvilinear region.
This assumption is needed to make use of efficient data structures for circular ray shooting and fully dynamic orthogonal range searching.
As is often the case for geometric algorithms, it may turn out challenging to program an actual implementation of these algorithms in practice.
For instance, circular arcs intersecting in non-generic ways can lead to robustness issues when using floating-point arithmetic.
We ignore these issues and refer the reader to the work by Devillers, Fronville, Mourrain, and Teillaud~\cite{DEVILLERS2002119}, who described a method to design exact geometric predicates in algorithms dealing with curved objects such as circular arcs.

\subsection{General curvilinear regions}\label{anImplementation:general}

For each connected component of , the algorithm stores a pointer to the active cut arc, if there is one.
If there is a component with an active cut arc, the algorithm handles that arc.
Otherwise, the algorithm traverses the boundary of  to check if there is a convex vertex or a convex arc with radius less than .
If there is none,  is returned since it is our maximum subset of bounded convex curvature.

Suppose that a problematic object has been chosen, and let  be the arc specifying a cut to be performed in .
Algorithm~\ref{performCut} traverses the boundary of the region , that we must remove, from  clockwise to  (since portions of  are concave arcs of , this corresponds to traversing  in counterclockwise direction).
Note that the remaining part of  is , so the traversed part contains all the new cut arcs that should be created.
The algorithm changes the boundary  accordingly by splicing in the new cut arcs .

\begin{algorithm}[h]
\LinesNumbered
\DontPrintSemicolon
\SetArgSty{}
\SetKwInput{Input}{Input}
\SetKwInput{Output}{Output}
\SetKw{Report}{report}
\SetKwIF{If}{ElseIf}{Else}{if}{}{else if}{else}{end if}
\SetKwFor{Foreach}{for each}{}{end for}
\SetKwFor{While}{while}{}{end while}
.\; \label{alg1:line1}
\Repeat {}
{
.\;
.\;
.\;
If  (resp.~) is not a vertex of , then create one by splitting the arc containing  (resp.~) into two. \;
Change  by setting the arc succeeding  and preceding  to .\;
}
\caption{}
\label{performCut}
\end{algorithm}

When we call the subroutine , we assume that .
The subroutine traverses  from  in clockwise direction until we reach a point  such that (i)  exits  at , or (ii) .
The point  is then returned.
It will always be the case that , and it may be that .
Case (ii) is just used to make sure that we stop when all new cut arcs have been constructed.

When we call the subroutine , it is assumed that  leaves  at  when traversed in clockwise direction.
The subroutine then follows  in counterclockwise direction from  through the interior of  until we reach a point , which is returned.
It then holds that , and it will always be the case that .
The call to  in line~\ref{alg1:line1} is needed because it can happen that a portion of  after  (in clockwise direction) is contained in , and therefore we cannot call  directly.

The point  is the first intersection point between  and  when following  from
.
This is found simply by checking all arcs of .

\begin{theorem}\label{finalThmGen}
Algorithm~\ref{roundAlg} can be implemented so that it runs in time  and uses  space when the input is a general curvilinear polygon.
\end{theorem}

\begin{proof}
Each time the algorithm chooses a problematic object to be handled, it traverses .
By Theorem~\ref{LTThm}, this happens  times and each traversal takes  time, so this takes in total  time.
It then remains to bound the time used on .

The running time of executing  is clearly dominated by the time used at  and .
By Lemma~\ref{linearIts}, we make  calls to , and by Theorem~\ref{LTThm}, each takes  since that is the number of arcs of  at any time.
We therefore use  on  in total.

The portion of  we traverse when calling
 is removed from  and hence never traversed again.
Therefore, the time used on  is bounded by the number of
vertices occuring on  during the execution of the algorithm.
By Lemma~\ref{linearIts}, this is  time in total.
\end{proof}

\subsection{Simply-connected curvilinear regions}\label{anImplementation:simply}

In this section, we show how the algorithm can be implemented so
that it uses 
time in total and  space when the input  is a simply-connected curvilinear region.
The main difference between the general and the simply-connected case is that while a cut in a simply-connected region might split the region into many connected components (as seen in Figure~\ref{fig:improper}), these will have only one new cut arc each.
In particular, all new cut arcs that are not perfect will be the active cut arcs in their components.

The algorithm for general curvilinear regions described in Section~\ref{anImplementation:general} uses  time just to find the problematic objects to be handled.
This can be reduced to  time by storing pointers to the problematic objects on a stack .
The algorithm starts by traversing the boundary of the original input  and adds pointer to all problematic objects to .
During the executing of the algorithm, we maintain  so that it contains pointers to all problematic objects of .
In particular, when an active cut arc is made, a pointer to the arc is pushed to .
This ensures that the active cut arc will be handled first in its component.

We implement the stack  as a doubly linked list, so that elements in the middle of  can be removed.
The cut performed due to one problematic object  popped from  may result in another problematic object  to disappear from .
By careful use of pointers from objects of  to elements in , we can remove pointers in  that point to objects of  that we remove in such situations.
In this way, we can ensure that when we pop a pointer to an object , the object  has not disappeared from  after the pointer to  was pushed to .
Likewise, we update pointers to arcs that shrink due to a cut.
It may also happen that there is a pointer in  to an arc  of  that is split in two smaller arcs  and  due to a cut.
We may then update  accordingly by replacing the old pointer to  with pointers to  and .

In order to get down to the promised running time of , it then remains to improve the running time used on the subroutine  from  to .
Cheng, Cheong, Everett, and van Oostrum~\cite{Cheng04} described an efficient solution to the following problem.
For a simple polygon , preprocess  such that queries of the following
kind can be answered efficiently: Given a circular unit radius arc  beginning
at some point in the interior of , find the first intersection point between  and
the boundary  if it exists.
The algorithm requires  space, uses  time on preprocessing, and answers queries in  time, where  is the number of vertices of .

It is straightforward to generalize the method to work for curvilinear polygons.
We apply the preprocessing to the original input .
Thus, by querying an arc following  from  in the direction through , we know the point where  exits .
However, the arc  can exit  before it exits , namely if and only if it crosses a cut arc of .
In the following, we show how to detect if that is the case or not.

Using the circular ray shooting data structure in both directions from  along , we can find a maximal arc  such that , , and .
Note that if , then , but it is possible that  is a point on a cut arc introduced by the algorithm so that .
The following lemma says that if the arc , when traversed forward from , enters a removed area, i.e., a connected component of , then it stays in that removed area.

\begin{lemma}\label{charArcB}
If  leaves  through a point  on a cut arc , then  does not again enter  after , i.e., .
Similarly, we have .
\end{lemma}

\begin{proof}
We consider the first iteration  such that  leaves  and enters  again later, when traversed from .
If there are no such iterations, we conclude that , as stated.
Let  be the arc that defined the cut made in  in order to get .
It follows that  crosses  at a point  and later again at a point .
Note that the circle containing  is a curve  of bounded convex curvature.
Furthermore, it holds for the disk  that  is contained in the region bounded by .
We get from Lemma~\ref{lemma:algCurve} that .
But them  leaves and reenters , which contradicts the minimality of .

That  follows from an analogous argument.
\end{proof}

\begin{figure}
\centering
\includegraphics[page=1]{collectfigs.pdf}
\caption{Left: A cut of type 4.2.2 splits a component into three.
The middle component gets an improper active cut arc  with both neighbours also improper.
Right: The points  for every cut arc  from the left figure.
The range in which we search in order to find the arc  intersecting  is shown in gray.}
\label{fig:improper}
\end{figure}

We say that a cut arc  is \emph{proper} if .
Otherwise,  is \emph{improper}; see Figure~\ref{fig:improper} (left) for an example where improper cut arcs are born, one of them being the arc .

\begin{lemma}\label{lem:improper}
In each connected component  of , if there are any improper cut arcs of , then it is the active cut arc of  and one or both of the neighbours.
\end{lemma}

\begin{proof}
We prove that if the statement holds in the beginning of an iteration, then it also holds in the beginning of the next.
Consider a component  and suppose first that no cut arc of  is improper.
Suppose that we make a cut in  defined by an arc .
Recall that the new cut arcs created are some of the arcs  in .
The only other arcs that change are the neighbours of these new cut arcs.
An improper arc is created when one of the new cut arcs  has one or two endpoints on an existing cut arc, which is not an original arc of .
Then  will be pushed to  and be the active cut arc in its component. 
It then holds that the only other improper cut arcs are one or both of the neighbours of .

Suppose now that there is an improper cut arc of  in the beginning of an iteration.
We assume inductively that the active cut arc  of  is improper, as is one or both of its neighbours  and , but not other arcs of .
Suppose that both  and  are improper. 
We then make a cut of type 3 and may assume that we cut along the arc  from  to .
Let the new cut arcs thus created be .
Here,  will have endpoint , so  is improper and the active cut arc in its component, and  is an improper cut arc in the same component which is a neighbour to , so the statement holds.
The argument for the components of the other arcs  is identical as the one we gave for the case where no cut arc of  is improper.

The case that only one of  and  is improper is also similar.
\end{proof}

By Lemma~\ref{lem:improper}, we know that there are at most three improper cut arcs to take into account when implementing .
It therefore remains to find intersections between  and the proper cut arcs.

Suppose that  intersects a proper cut arc .
Then  and  can have one or two intersection points.
We now argue that if they have two, the first must be : There can be no intersection at  since  (by Lemma~\ref{charArcB}) and .
Similarly, Lemma~\ref{charArcB} gives that if  intersect at a point , then , so there can be no other intersection point than  on the part .
Therefore, we can easily check if  intersects the same proper cut arc twice, as that arc must be the arc of  containing the point .
We therefore turn our attention to finding a proper cut arc intersecting  once, where the intersection is on the part .
This leads to the following lemma.

\begin{lemma}\label{charArcB2}
Let  be a proper cut arc of .
Assume for a point  that  and that  is on the convex side of , that is, .
Then  and  intersect if and only if the endpoints of  and  appear in the order  on .
\end{lemma}

\begin{proof}
If  and  intersect, then the intersection point is a unique point  by Lemma~\ref{charArcB}, and .
Therefore, since , we know that  separates  and  in .
As  and  are on the convex side of  and  is on the concave side, this is equivalent to saying that the order is .
\end{proof}

Lemma~\ref{charArcB2} leads to our method for finding proper cut arcs intersecting
an arc  by searching after arcs with endpoints on specific portions of
.
We associate to each point  on  a unique number
. Let the vertices of  be
, where . We set
 for .
For the points  on the arc between two vertices  and
, we interpolate between  and  to uniquely define .
For a proper cut arc ,
we define an associated point 
in the following way:


Lemma~\ref{charArcB2} then implies the following lemma, the use of which is demonstrated in Figure~\ref{fig:improper} (right).

\begin{lemma}\label{charArcB3}
Let  be a proper cut arc of .
Assume that  and  and let .
Then  and  intersect
if and only if
\begin{itemize}
\item
 and , or

\item
 and .
\end{itemize}
\end{lemma}

\begin{proof}
Lemma~\ref{charArcB2} says that  and 
intersect if and only if the endpoints of  and  appear in the order

on .
If we assume that  and ,
this is equivalent to
, which means that
.
If  and , we get .
These two cases can then be expressed at once as .

The case  is handled in a similar way.
\end{proof}

For each proper cut arc  of , we store
the point  in a data structure .
It is necessary to add new points to and
delete points from  as the algorithm proceeds, since new
cut arcs are created and others become improper or completely removed.
We need to be able to find a point  in a rectangle
specified by  as stated in Lemma~\ref{charArcB3}.
Therefore, we implement  as a fully dynamic orthogonal
range searching structure as described by Blelloch~\cite{blelloch2008space}.
Algorithm~\ref{traverseC} sketches how to implement .

\begin{algorithm}[h]
\LinesNumbered
\DontPrintSemicolon
\SetArgSty{}
\SetKwInput{Input}{Input}
\SetKwInput{Output}{Output}
\SetKw{Report}{report}
\SetKwIF{If}{ElseIf}{Else}{if}{}{else if}{else}{end if}
\SetKwFor{Foreach}{for each}{}{end for}
\SetKwFor{While}{while}{}{end while}
Use the circular ray shooting data structure to find the arc
 such that , , and 
.\;
Return the first intersection between  and  when following  from  by checking the following arcs:\;
\quad\quad The arc(s) containing .\;
\quad\quad The improper cut arcs of , if any.\;
\quad\quad The arc represented by the point  in the rectangle(s) as specified by Lemma~\ref{charArcB3}, if any.\;
\quad\quad The arc(s) containing .
\caption{}
\label{traverseC}
\end{algorithm}

It is now possible to bound
the running time and memory requirement
of Algorithm~\ref{roundAlg} when using our suggested implementation.

\begin{theorem}\label{finalThm}
Algorithm~\ref{roundAlg} can be implemented so that it runs in
time  and uses  space, assuming that the input is a simply-connected curvilinear region.
\end{theorem}

\begin{proof}
We first bound the space and time used on maintaining and querying the data structure
.
From Lemma~\ref{linearIts}, we know that there are  points in  at
any time. Blelloch~\cite{blelloch2008space} describes how to implement
 using  space so that insertions and deletions are performed in
 amortized time and
orthogonal range reporting queries in

time, where  is the number of reported points.
In our case, due to Lemma~\ref{charArcB}, there are  or  points
to report in each query.
Therefore, we use  time on  in total.

It takes  time and uses  space to build the circular ray shooting data structure~\cite{Cheng04}.
For each cut arc of , we perform  circular ray shooting queries in order to find the arc  with endpoints on .
Thus, we use  time building and querying the data structure in total.

The portion of  we traverse when calling
 is removed from  and hence never traversed again.
Therefore, the time used on  is bounded by the number of
vertices occuring on  during the execution of the algorithm.
By Lemma~\ref{linearIts}, we use  time on 
in total.
\end{proof}

\section{Concluding remarks}
It remains an interesting open problem if the running time of  for general curvilinear regions can be improved.
One way to do that would be to find an efficient data structure for circular ray shooting in polygonal domains and generalize the approach we used for simply-connected regions in Section~\ref{anImplementation:simply}.
In the case of straight line ray shooting in polygonal domains, Hershberger and Suri~\cite{hershberger95pedestrian} and Chazelle, Edelsbrunner, Grigni, Guibas, Hershberger, Sharir, and Snoeyink~\cite{chazelle94ray} devised data structures with preproccesing time  and query time , where  is the number of holes (Chen and Wang~\cite{chen2015visibility} described a data structure with query time , at the cost of preprocessing time , which is quadratic in  in the worst case).
This gives hope that a data structure for circular ray shooting in polygonal domains can be constructed where preprocessing and  queries together take  time.
But then we still need to find a way to replace the range searching data structure.
Another approach could be to find other cut rules that can be implemented more efficiently.

We finally mention a question of a purely mathematical nature:
For a set of points , let  be the family of subsets of  of bounded convex curvature.
Is it true that for any set , the union  has bounded convex curvature?
In other words, is there a unique maximum subset of  of bounded convex curvature?
It follows from our results that this holds when  is a curvilinear region, but we expect it to be the case for all sets .

\section{Data availability}

Data sharing is not applicable to this article as no datasets were generated or analyzed during the current study.

\section*{Acknowledgement}

We thank the anonymous reviewers for their thorough comments and one reviewer for spotting a glitch in the submitted manuscript.

\bibliography{bib}{}

\end{document}
