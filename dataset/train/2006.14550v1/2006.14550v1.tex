

\documentclass{article}

\usepackage{microtype}
\usepackage{graphicx}
\usepackage{subfigure}
\usepackage{booktabs} 

\usepackage{hyperref}

\newcommand{\theHalgorithm}{\arabic{algorithm}}




\usepackage{algorithmic}
\usepackage{amsthm}
\usepackage{amsmath,amssymb} \usepackage[T1]{fontenc}
\usepackage{etex}
\usepackage{graphicx}
\usepackage{amsxtra}
\usepackage{amsfonts}
\usepackage{nicefrac}
\usepackage{microtype}
\usepackage{url}
\usepackage{soul}

\usepackage{color}
\usepackage{bbm}
\usepackage{pgfplots}
\usepackage{tikz}

\usepackage{wrapfig}
\usepackage{sidecap}


\usepackage{colortbl}
\newcolumntype{g}{>{\columncolor[gray]{0.85}}c}

\usepackage{epsfig}
\usepackage{stmaryrd} \usepackage{mathtools}

\usepackage{multirow}
\usepackage{fixmath}
\usepackage{booktabs}
\usepackage{pbox}
\usepackage{enumerate}
\usepackage{enumitem}





\newcommand{\SE}{\mathcal{E}}
\newcommand{\SX}{\mathcal{X}}
\newcommand{\Simplex}{\mathcal{S}}
\newcommand{\SI}{\Sigma}
\newcommand{\SV}{\mathcal{V}}
\newcommand{\SM}{\mathcal{M}}
\newcommand{\SP}{\mathcal{P}}
\newcommand{\SN}{\mathcal{N}}
\newcommand{\SG}{\mathcal{G}}
\newcommand{\SL}{\mathcal{L}}

\newcommand{\BF}{\mathbb{F}}
\newcommand{\BR}{\mathbb{R}}
\newcommand{\BV}{\mathbb{V}}
\newcommand{\BE}{\mathbb{E}}
\newcommand{\BG}{\mathbb{G}}
\newcommand{\BS}{\mathbb{S}}

\newcommand{\FG}{\mathsf{G}}
\newcommand{\FV}{\mathsf{V}}
\newcommand{\FE}{\mathsf{E}}
\newcommand{\FL}{\mathsf{L}}
\newcommand{\IPSLP}{IRPS-LP}

\newcommand{\R}{\mathbb{R}}
\newcommand{\N}{\mathbb{N}}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\la}{\langle}
\newcommand{\ra}{\rangle}
\newcommand{\T}{\top}
\newcommand{\zero}{\mathbbmss{O}}
\newcommand{\eins}{\mathbbmss{1}}
\newcommand{\dcup}{\dot{\cup}}
\newcommand{\fdots}{\makebox[0.75em][c]{.\hfill.}\thinspace} 

\DeclareMathOperator*{\argmin}{arg min}
\DeclareMathOperator*{\argmax}{arg max}
\DeclareMathOperator*{\conv}{conv}

\def\clap#1{\hbox to 0pt{\hss#1\hss}}
\def\mathllap{\mathpalette\mathllapinternal}
\def\mathrlap{\mathpalette\mathrlapinternal}
\def\mathclap{\mathpalette\mathclapinternal}
\def\mathllapinternal#1#2{\llap{}}
\def\mathrlapinternal#1#2{\rlap{}}
\def\mathclapinternal#1#2{\clap{}}

\providecommand{\abs}[1]{\lvert#1\rvert}
\providecommand{\norm}[1]{\lVert#1\rVert}

\definecolor{fettrot}{RGB}{255,10,10}
\newcommand{\todo}[1]{\colorbox{fettrot}{TODO: \color{black}#1}}

\newtheorem{example}{Example}
\newtheorem{definition}{Definition}
\newtheorem{theorem}{Theorem}
\newtheorem{lemma}{Lemma}
\newtheorem{proposition}{Proposition}
\newtheorem{remark}{Remark}



\usepackage{tikz}
\usetikzlibrary{arrows}
\usetikzlibrary{decorations.pathmorphing}
    \tikzstyle{lifted-edge}=[->,> = latex',blue]
    \tikzstyle{base-edge}=[->,> = latex',black]
	\tikzstyle{cut-edge}=[->,> = latex',dashed]
    \tikzstyle{vertex}=[circle, draw, inner sep=0pt,text height=3mm,text width=3mm,text depth=1.5mm,align=center]
\tikzset{every picture/.append style={baseline,scale=1.1}}



\makeatletter
\def\nobreakhline{\noalign{\ifnum0=`}\fi
\penalty\@M
\futurelet\@let@token\LT@@nobreakhline}
\def\LT@@nobreakhline{\ifx\@let@token\hline
\global\let\@gtempa\@gobble
\gdef\LT@sep{\penalty\@M\vskip\doublerulesep}\else
\global\let\@gtempa\@empty
\gdef\LT@sep{\penalty\@M\vskip-\arrayrulewidth}\fi
\ifnum0=`{\fi}\multispan\LT@cols
\unskip\leaders\hrule\@height\arrayrulewidth\hfill\cr
\noalign{\LT@sep}\multispan\LT@cols
\unskip\leaders\hrule\@height\arrayrulewidth\hfill\cr
\noalign{\penalty\@M}\@gtempa}
\makeatother  \usepackage{times}
 \usepackage{placeins}
 \usepackage{longtable}
 \usepackage{thmtools}
 \usepackage{thm-restate}
\usepackage{tikz}
\usetikzlibrary{positioning}
\usetikzlibrary{decorations.markings}
\newcommand{\MC}{\mathsf{MC}}
 \newcommand{\re}{\mathcal{R}}
 \newcommand{\unre}{\bar{\mathcal{R}}}

 \setitemize{topsep=2.5pt,parsep=1.5pt,partopsep=1.5pt,leftmargin=0.4cm}
\declaretheorem[name=Theorem]{thm}
 \declaretheorem[name=Proposition]{prop}
\mathchardef\mhyphen="2D


\makeatletter
\newcommand\footnoteref[1]{\protected@xdef\@thefnmark{\ref{#1}}\@footnotemark}
\makeatother





\usepackage[accepted]{icml2020}

\icmltitlerunning{Lifted Disjoint Paths with Application in Multiple Object Tracking}

\begin{document}

\twocolumn[
\icmltitle{Lifted Disjoint Paths with Application in Multiple Object Tracking}





\icmlsetsymbol{equal}{*}

\begin{icmlauthorlist}
\icmlauthor{Andrea Hornakova}{equal,mpi}
\icmlauthor{Roberto Henschel}{equal,tnt}
\icmlauthor{Bodo Rosenhahn}{tnt}
\icmlauthor{Paul Swoboda}{mpi}
\end{icmlauthorlist}

\icmlaffiliation{mpi}{Computer Vision and Machine Learning, Max Planck Institute for Informatics, Saarbr\"ucken, Saarland, Germany}
\icmlaffiliation{tnt}{Institut for Image Processing, Leibniz University Hannover, Hannover, Niedersachsen, Germany}


\icmlcorrespondingauthor{Andrea Hornakova}{andrea.hornakova@mpi-inf.mpg.de}
\icmlcorrespondingauthor{Roberto Henschel}{henschel@tnt.uni-hannover.de}



\icmlkeywords{combinatorial optimization, disjoint paths, network flow, polyhedral relaxation, multiple object tracking}

\vskip 0.3in
]







\printAffiliationsAndNotice{\icmlEqualContribution} 

\begin{abstract}
We present an extension to the disjoint paths problem in which additional \emph{lifted} edges are introduced to provide path connectivity priors.
We call the resulting optimization problem the lifted disjoint paths problem.
We show that this problem is NP-hard by reduction from integer multicommodity flow and 3-SAT.
To enable practical global optimization, we propose several classes of linear inequalities that produce a high-quality LP-relaxation.
Additionally, we propose efficient cutting plane algorithms for separating the proposed linear inequalities.
The lifted disjoint path problem is a natural model for multiple object tracking and allows an elegant mathematical formulation for long range temporal interactions.
Lifted edges help to prevent id switches and to re-identify persons. 
Our lifted disjoint paths tracker achieves nearly optimal assignments with respect to input detections. 
As a consequence, it leads on all three main benchmarks of the MOT challenge, improving significantly over state-of-the-art.
\end{abstract}
 \section{Introduction}
The disjoint paths problem, a special case of the network flow problem with flows constrained to be binary, is a classical combinatorial optimization problem for which fast combinatorial solvers exist.
It is a natural model for the multiple object tracking problem (MOT) in computer vision~\cite{zhang2008global}.
In the form of the tracking-by-detection paradigm, MOT consists of two steps: First, an object detector is applied to each frame of a video sequence to find the putative locations of all objects appearing in the video.
Then, in the data association step, false positive detections are removed while correct detections are associated to the corresponding identities, thereby forming trajectories.
In this work, we concentrate on the latter task.


While for MOT even very large data association instances can be solved using the disjoint paths formulation, it has been shown that the basic disjoint paths problem alone is not sufficient to provide trajectories of high accuracy.
The main limitation for MOT is the implicit assumption of a first-order Markov chain.
In particular, costs only indicate whether two detections directly follow each other in a track.


Our contribution is three-fold:
First, to overcome the limited expressiveness of disjoint paths, we propose to augment it with lifted edges which take into account long range interactions. 
We call the resulting problem the \emph{lifted disjoint paths problem}, see Section~\ref{sec:problem-formulation}.
We prove the problem to be NP-hard in Section~\ref{sec:complexity}.
Second, we study the optimization problem from a polyhedral perspective, proposing a high-quality linear programming relaxation, see Section~\ref{sec:constraints}.
Separation routines for the proposed constraints are described in Section~\ref{sec:separation}.
Third, we apply the lifted disjoint paths problem to MOT and show that our solver significantly outperforms state-of-the-art trackers on the popular MOT challenge, see Section~\ref{sec:experiments}.



We argue that our model has advantages from the modelling and optimization point of view.
From the modelling standpoint, the lifted disjoint paths problem does not change the set of feasible solutions, but adds more expressive power to it. 
For MOT, this means that the set of feasible solutions, which naturally represent trajectories of objects, is preserved. 
The additional lifted edges represent connectivity priors.
A lifted edge is active if and only if there is an active trajectory between its endpoints in the flow graph. 
For MOT, lifted edges take (dis-)similarity of object detection pairs represented by its endpoints into account. This allows to encourage or penalize an active path between the detections with possibly larger temporal distance. This helps to re-identify the same object and to prevent id-switches between distinct objects within long trajectories.



From the optimization point of view, we study several non-trivial classes of linear inequalities that result in a high-quality relaxation.
The proposed inequalities depend non-trivially on the constraint structure of the underlying disjoint paths problem, see Section~\ref{sec:constraints}.
We show that the polyhedral relaxation we consider is tighter than naively applying known inequalities.
The proposed relaxation enables us to solve MOT problems via a global approach, in contrast to established approaches, which either use heuristics on complex models or global optimization on simpler models that do not exploit long range interaction.
We present, to our knowledge, the first global optimization approach that incorporates long range interaction for MOT.
This has several advantages:
First, our optimization is not trapped in poor local optima or affected by initialization choices and is hence potentially more robust.
Second, improvements in the discriminative power of features used to compute costs for the lifted disjoint paths problem directly correlate to better tracking performance, since no errors are introduced by suboptimal choices during optimization.


Finally, we note that the proposed lifted disjoint path formulation is not inherently tied to MOT and can potentially be applied to further problems not related to MOT. 

Our code is available at \url{https://github.com/AndreaHor/LifT_Solver}.




  \section{Related Work}



\paragraph{Disjoint paths problem.}
The disjoint paths problem 
can be solved with fast combinatorial solvers~\cite{kovacs2015minimum}. 
The shortest paths method for network flow specialized for the disjoint paths problem~\cite{wang2019mussp} performs extremely well in practice.
For the case of the two disjoint paths problem the specialized combinatorial algorithm by Suurballe's~\cite{suurballe1974disjoint} can be used.


There exist several NP-complete extensions to the disjoint paths problem.
The shortest disjoint paths problem with multiple source-sink pairs~\cite{eilam1998disjoint} is NP-complete, as is the more general integer multicommodity flow problem~\cite{EvenMulti}.
The special case of the disjoint paths problem with two distinct source/sink pairs can be solved in polynomial time, however~\cite{tholey2012linear}.


\paragraph{Connectivity priors \& lifted edges.}
For several combinatorial problems, special connectivity inducing edges, which we will call lifted edges for our problem, have been introduced to improve expressiveness of the  base problem.

In the Markov Random Field literature, special connectivity inducing edges were studied from a polyhedral point of view in~\cite{nowozin2010global}.
They were used in image analysis to indicate that two non-adjacent pixels come from the same object and hence they must be part of a contiguously labeled component of the underlying graph.

For multicut (a.k.a.\ correlation clustering), a classical graph decomposition problem, lifted edges have been introduced in~\cite{keuper2015lifted} to model connectivity priors. 
A lifted edge expresses affinity of two nodes to be in the same/different connected component of the graph partition.
Lifted multicut has been used for image and mesh segmentation~\cite{keuper2015lifted}, connectomics~\cite{beier2017multicut} and cell tracking~\cite{rempfler2017efficient}.
A combination of the lifted multicut problem and Markov Random Fields has been proposed in~\cite{levinkov2017joint} with applications in instance-separating semantic segmentation~\cite{kirillov2017instancecut}.
A polyhedral study of lifted multicut was presented in~\cite{hornakova2017analysis}.

Yet, for the above problems, global optimization  has only been reported for small instances.

\paragraph{Disjoint paths for MOT.}
The data association step of MOT has been approached using the disjoint path setup ~\cite{berclaz2011multiple,zhang2008global}, since disjoint paths through a graph naturally model trajectories of multiple objects. 
Extension of the plain disjoint paths problem that disallow certain pairs of detections to occur simultaneously have been used to fuse different object detectors~\cite{chari2015pairwise} and for multi-camera MOT~\cite{hofmann2013hypergraphs,leal2012branch}. 
The drawback of these approaches is that they cannot integrate long range information, in contrast to our proposed formulation.



\paragraph{Other combinatorial approaches to MOT.}

The minimum cost arborescence problem, an extension of minimum spanning tree to directed graphs, has been used for MOT in~\cite{henschel2014efficient}.
In~\cite{keuper2016multi,keuper2018motion,kumar2014multiple,ristani2014tracking,tang2015subgraph,tang2016multi} the multicut problem has been used for MOT and in~\cite{babaee2018multiple,tang2017multiple} additionally lifted edges have been used to better model long range temporal interactions.
The maximum clique problem, which corresponds to multicut with complete graphs has been applied for MOT in~\cite{zamir2012gmcp,dehghan2015gmmcp}.
Maximum independent set, which corresponds to maximum clique on the complement graph, has been used for MOT in~\cite{brendel2011multiobject}.
The multigraph-matching problem, a generalization of the graph matching problem, has been applied to MOT in~\cite{hu2019dual}.
Consistency of individual matched detections is ensured by cycle-consistency constraints coming from the multi-graph matching.
The works~\cite{Henschel_2018_CVPR_Workshops,henschel2016tracking} reformulate tracking multiple objects with long temporal interactions as a binary quadratic program. If the problem size is small, the optimization problem can be solved optimally by reformulating it to an equivalent binary linear program \cite{henschel2019simultaneous,von2018recovering}. For large instances, an approximation is necessary.  To this end, a specialized non-convex Frank-Wolfe method can be used \cite{Henschel_2018_CVPR_Workshops}.
Common to the above state of the art trackers is that they either employ heuristic solvers or are limited in the integration of long range information, in contrast to our work.


\paragraph{Contribution w.r.t.\ existing combinatorial approaches.}
It is widely acknowledged that one crucial ingredient for obtaining high-quality MOT results is to incorporate long range temporal information to re-identify detections and prevent id-switches.
However, from a theoretical perspective, we believe that long range information has not yet been incorporated satisfactorily in optimization formulations for the data association step in MOT.

In comparison to lifted multicut for MOT, we argue that from the modelling point of view, network flow has advantages.
In multicut, clusters can be arbitrary, while in MOT, tracks are clusters that may not contain multiple detection hypotheses of distinct objects at the same time point.
This exclusion constraint must be enforced in multicut explicitly via soft constraints, while the disjoint paths substructure automatically takes care of it.
On the other hand, the lifted multicut approach~\cite{tang2017multiple} has used the possibility to cluster multiple detections in one time frame.
This directly incorporates non-maxima suppression in the optimization, which however increases computational complexity.

From a mathematical perspective, naively using polyhedral results from multicut is also not satisfactory.
Specifically, one could naively obtain a polyhedral relaxation for the lifted disjoint paths problem by reusing the known polyhedral structure of lifted multicut~\cite{hornakova2017analysis} and additionally adding network flow constraints for the disjoint paths substructure.
However, this would give a suboptimal polyhedral relaxation. 
We show in Section~\ref{sec:constraints} that the underlying structure of the disjoint paths problem can be used to derive new and tighter constraints for lifted edges.
This enables us to use a global optimization approach for MOT.
To our knowledge, our work is the first one to combine global optimization with long range interactions for MOT.



In comparison to works that propose non-convex algorithms or other heuristics for incorporating long range temporal edges~\cite{Henschel_2018_CVPR_Workshops,hu2019dual,zamir2012gmcp,dehghan2015gmmcp} our approach yields a more principled approach and globally optimal optimization solutions via LP-based branch and bound algorithms.
  \section{Problem Formulation}
\label{sec:problem-formulation}
Below we recapitulate the disjoint paths problem and extend it by defining lifted edges.
We discuss how the lifted disjoint paths problem can naturally model MOT.
Proofs for statements in all subsequent sections can be found in the Appendix, Section~\ref{sec:appendix}.

\paragraph{Flow network and lifted graph.}
Consider two directed acyclic graphs  and  where .
The graph  represents the \emph{flow network} and we denote by  the lifted graph. 
The two special nodes  and  of  denote source and sink node respectively. 
We further assume that every node in  is reachable from , and  can be reached from it.




We define the set of paths starting at  and ending in  as

For a path  we denote its edge set as  and its node set as .


The flow variables in  are denoted by  for edges and  for nodes. Allowing only 0/1 values of vertex variables reflects the requirement of vertex disjoint paths.
Variables on the lifted edges  are denoted by .
Here,  means that nodes  and  are connected via the flow  in .
Formally, 




\paragraph{Optimization problem.}
Given edge costs , node cost  in flow network  and edge cost  for the lifted graph  we define the lifted disjoint paths problem as



In Section \ref{sec:constraints}, we present an ILP formulation of~\eqref{eq:lifted-disjoint-paths-problem} by proposing
several linear inequalities that lead to a high-quality linear relaxation.

\paragraph{Graph construction for multiple object tracking.}
We argue that the lifted disjoint paths problem is an appropriate way of modelling the data association problem for MOT.
In MOT, an unknown number of objects needs to be tracked across a video sequence.
This problem can be naturally formalized by a graph  where its node set  represents either object detections or tracklets of objects.
If  represents object detections, we can express it as follows: , where  is the number of frames and  denotes the object detections in time .
We introduce edges between adjacent time frames.
An active flow on such an edge denotes correspondences of the same object.
We also introduce skip edges  between time frames that are farther apart.
An active flow on a skip edge also denotes correspondences between the same object that, in contrast, may have been been occluded or not detected in intermediate time frames.
This classical network flow formulation has been commonly used for MOT~\cite{zhang2008global}.

On top of the underlying flow formulation for MOT, we usually want to express that two detections belong to the same object connected by a possibly longer track with multiple detections in between.
For that purpose, lifted edges with negative costs can be used.
We say in such a case that an active lifted edge re-identifies two detections~\cite{tang2017multiple}.
If two detections with larger temporal distance should not be part of the same track, a positive valued lifted edge can be used.
In this case the lifted edge is used to prevent id-switches.


  \section{Constraints}
\label{sec:constraints}
Below, we will first introduce constraints that give an integer linear program (ILP) of the lifted disjoint paths problem~\eqref{eq:lifted-disjoint-paths-problem}.
The corresponding linear programming (LP) relaxation can be strenghtened by additional constraints that we present subsequently.


Many constraints considered below will rely on whether a node  is reachable from another node  in the flow network. We define to this end the \emph{reachability relation}  via

In the special case of , we also allow empty paths, which means .
This makes relation  reflexive.

\paragraph{Flow conservation constraints.}
The flow variables  obey, as in classical network flow problems~\cite{ahuja1988network}, the flow conservation constraints




\paragraph{Constraining lifted edges.} 
     All the following constraints restrict values of lifted edge variables  in order to ensure that they satisfy \eqref{eq:lifted-edge-def}. Despite their sometimes complex form, they always obey the two basic principles:
\begin{itemize}
 \item If there is flow in  going from vertex  to vertex , then .
 The constraints of this form are \eqref{eq:path-inequalities}, \eqref{eq:lifted-path-inequalities}.
 \item If there is a -cut in  with all edges labeled by zero (i.e. no flow passes through this cut), then .
 We will mainly look at cuts that are induced by paths, i.e.\ edges that separate a path from the rest of the graph. 
 The paths of interest will either originate at  or end at .
The constraints of this form are \eqref{eq:vwcut1}, \eqref{eq:vwcut2}, \eqref{eq:path-induced-cut-inequality}, \eqref{eq:lifted-path-induced-cut-inequality}, \eqref{eq:lifted-path-induced-cut-inequality2}.
\end{itemize}


\paragraph{Single node cut inequalities.}
Given a lifted edge , if there is no flow going from vertex  which can potentially go to vertex , then . 
Formally,

Similarly, if there is no flow going to  that can originate from vertex , then .
Formally,


The number of constraints of the above type~\eqref{eq:flow-conservation} is linear in the number of vertices, while~\eqref{eq:vwcut1} and~\eqref{eq:vwcut2} are linear in the number of lifted edges.
Hence we add them into our initial constraint set during optimization.

\paragraph{Path inequalities.}
For lifted edge  it holds that if there is
a flow in  going from  to  along a path ,
then . This constraint can be expressed by the following set of inequalities:

Here the first sum expresses the flow going from  to any vertex of path . The second sum is the flow leaving path vertices  before reaching .
In other words, if flow does not leave , edge  must be active.
Note that inequality~\eqref{eq:path-inequalities} implicitly enforces  to be active if any path -path  with  is active.




\begin{remark}
For the multicut problem, there exist path inequalities that enforce path properties in an analogous way.
While the multicut path inequalities would yield the same set of feasible integral points, the resulting polyhedral relaxation would be weaker, see Proposition~\ref{prop:multicut-path-inequalities weaker} in the Appendix.
\end{remark}

\paragraph{Path-induced cut inequalities.}
The path-induced cut inequalities generalize the single node cut inequalities~\eqref{eq:vwcut1} and~\eqref{eq:vwcut2} by allowing cuts induced by paths.

Let a lifted edge , a node  from which  is reachable and a -path  be given.
Consider the cut given by edges  with  and  but such that  is reachable from .
If the flow does not take any edge of this cut, then .
Formally,



\paragraph{Lifted inequalities.}
The path inequalities~\eqref{eq:path-inequalities} and the path-induced cut inequalities~\eqref{eq:path-induced-cut-inequality} only consider base edges on their right hand sides.
We can generalize both~\eqref{eq:path-inequalities} and~\eqref{eq:path-induced-cut-inequality} by including lifted edges in the paths as well.
Conceptually, using lifted edges allows to represent all possible paths between their endpoints, which enables to formulate tighter inequalities, see Propositions~\ref{prop:lifted-path-strictly-better} and~\ref{prop:lifted-path-induced-cut-inequality-strictly-better}.




To that end consider the multigraph .
For any edge  we always distinguish whether  or .
For , we denote by  and  edges of the path  in  and  respectively. 
We require . 


\paragraph{Lifted path inequalities.}
We generalize the path inequalities~\eqref{eq:path-inequalities}.
Now the -path  may contain both edges in  and .
Whenever a lifted edge  in the third sum in~\eqref{eq:lifted-path-inequalities} is one, two cases can occur:
(i)~Flow goes out of  (uses vertices not in ) but reenters it again later.
Then a base edge variable  will be one in the second sum in~\eqref{eq:lifted-path-inequalities} and the values of  and  cancel out.
(ii)~A base edge  parallel to the lifted edge is active.
Then the variable  in the fourth sum in~\eqref{eq:lifted-path-inequalities} cancels out .
The lifted path inequality becomes

Whenever the path in~\eqref{eq:lifted-path-inequalities} consists only of base edges , the resulting inequality becomes a path inequality~\eqref{eq:path-inequalities}.

\begin{restatable}{prop}{liftedstrictlybetter}
\label{prop:lifted-path-strictly-better}
The lifted path inequalities~\eqref{eq:lifted-path-inequalities} provide a strictly better relaxation than the path inequalities~\eqref{eq:path-inequalities}.
\end{restatable}



\paragraph{Lifted path-induced cut inequalities.}
We generalize the path-induced cut inequalities~\eqref{eq:path-induced-cut-inequality}.
Let a lifted edge  and a path  in  be given.
In contrast to the basic version~\eqref{eq:path-induced-cut-inequality}, a lifted edge  can be taken.
This can occur in two cases: Either the flow leaves  via a base edge ,  or a base edge  parallel to the lifted edge is taken. Both cases are accounted for by terms in the first and the third sum in~\eqref{eq:lifted-path-induced-cut-inequality} below.






Assume that the last node  of path  is connected via a lifted edge with .
Then we can strengthen~\eqref{eq:lifted-path-induced-cut-inequality} by replacing the sum of base edges outgoing from  by .



\begin{restatable}{prop}{liftedpathinducedcutbetter}
\label{prop:lifted-path-induced-cut-inequality-strictly-better}
The lifted path-induced cut inequalities~\eqref{eq:lifted-path-induced-cut-inequality} define a strictly tighter relaxation than the path-induced cut inequalities~\eqref{eq:path-induced-cut-inequality}.

Furthermore the lifted path-induced cut inequalities~\eqref{eq:lifted-path-induced-cut-inequality} and~\eqref{eq:lifted-path-induced-cut-inequality2} define a strictly better relaxation than~\eqref{eq:lifted-path-induced-cut-inequality} alone.
\end{restatable}



\paragraph{Symmetric cut inequalities.}
Inequalities \eqref{eq:vwcut2} provide a symmetric counterpart to inequalities \eqref{eq:vwcut1}. 
We can also formulate symmetric counterparts to  inequalities \eqref{eq:path-induced-cut-inequality}, \eqref{eq:lifted-path-induced-cut-inequality} and \eqref{eq:lifted-path-induced-cut-inequality2} by swapping the role of  and .
 All constraints \eqref{eq:path-induced-cut-inequality}, \eqref{eq:lifted-path-induced-cut-inequality} and \eqref{eq:lifted-path-induced-cut-inequality2} concentrate on paths originating in . 
The symmetric inequalities are obtained by studying all paths ending in . 
These symmetric inequalities are described in Appendix Section~\ref{sec:symmetric-inequalities}.
Relations analogous to those described in Proposition~\ref{prop:lifted-path-induced-cut-inequality-strictly-better} hold for the symmetric counterparts as well.
The symmetric inequalities also strengthen the relaxation strictly.
For the exact statements, see propositions in Appendix Section~\ref{sec:symmetric-inequalities}.









  \section{Separation}
\label{sec:separation}
We solve the lifted disjoint paths problem~\eqref{eq:lifted-disjoint-paths-problem} with the state of the art integer linear program solver Gurobi~\cite{gurobi}.
Since there are exponentially many constraints of the form~\eqref{eq:path-inequalities}, \eqref{eq:path-induced-cut-inequality}, \eqref{eq:lifted-path-inequalities}, \eqref{eq:lifted-path-induced-cut-inequality} and~\eqref{eq:lifted-path-induced-cut-inequality2}, we do not add them initially.
Instead, we start with constraints~\eqref{eq:flow-conservation}, \eqref{eq:vwcut1} and \eqref{eq:vwcut2} and find the optimal integer solution.
In the separation procedures described below we check if any of the advanced constraints are violated and add those that are to the active constraint set.
We resolve the tightened problem and iterate until we have found a feasible solution to the overall problem~\eqref{eq:lifted-disjoint-paths-problem}.

Algorithms \ref{alg:lifted1-separation} and \ref{alg:lifted2-separation} describe the separation procedures for adding lifted path constraints \eqref{eq:lifted-path-inequalities}, and lifted path-induced cut constraints \eqref{eq:lifted-path-induced-cut-inequality} and \eqref{eq:lifted-path-induced-cut-inequality2}.
Since path constraints~\eqref{eq:path-inequalities} and path-induced cut inequalities~\eqref{eq:path-induced-cut-inequality} are special cases of those above, they are also accounted for.

\paragraph{Separation for path inequalities.}
Algorithm~\ref{alg:lifted1-separation} iterates over all active -paths.
For every path , labels of all lifted edges connecting two vertices in  are inspected.
If the lifted edge variable is zero, Algorithm~\ref{alg:lifted1-separation} will extract a path in  connecting the endpoints and add the resulting lifted path inequality~\eqref{eq:lifted-path-inequalities} to the active constraint set.
\begin{algorithm}[!ht]
    \caption{Separation for lifted path inequalities~\eqref{eq:lifted-path-inequalities}}
    \label{alg:lifted1-separation}
    \begin{algorithmic}\STATE Define , 
        \FORALL {-paths }
          \FORALL{}          
          \STATE  \textrm{Extract\_path()}
          \STATE Add constr.~\eqref{eq:lifted-path-inequalities} for  with  .
         \ENDFOR
        \ENDFOR
    \end{algorithmic}
\end{algorithm}

\paragraph{Separation for path-induced cut inequalities.}
Algorithm~\ref{alg:lifted2-separation} iterates over all active -paths.
For every path , lifted edges that start in  but do not end in  are inspected.
If their label is one, Algorithm~\ref{alg:lifted2-separation} will extract a subpath of  for either~\eqref{eq:lifted-path-induced-cut-inequality2} or~\eqref{eq:lifted-path-induced-cut-inequality} and add the respective inequality to the active constraint set.
 \begin{algorithm}[!ht]
    \caption{Separation for lifted path-induced cut inequalities~\eqref{eq:lifted-path-induced-cut-inequality} and \eqref{eq:lifted-path-induced-cut-inequality2}}
    \label{alg:lifted2-separation}
    \begin{algorithmic}
       \STATE Define , 
        \FORALL{paths }
          \FORALL{}
          \IF{}
          \STATE  \textrm{Extract\_path()}
          \STATE Add constr.~\eqref{eq:lifted-path-induced-cut-inequality2} for  with  .
         \ELSE
         \STATE  last vertex of  such that 
         \STATE  \textrm{Extract\_path ()}
          \STATE Add constr.~\eqref{eq:lifted-path-induced-cut-inequality} for  with  .
         \ENDIF      
         \ENDFOR
        \ENDFOR
    \end{algorithmic}
\end{algorithm}
\paragraph{Complexity of separation.}
Both Algorithms \ref{alg:lifted1-separation} and \ref{alg:lifted2-separation} can be implemented efficiently such that they are linear in  (i.e. in the number of active edges of graph ).
In our implementation, we traverse all active -paths from the end to the beginning and directly store correctly labelled lifted edges that originate on the already processed subpaths. These lifted edges can be used later as edges in  in \eqref{eq:lifted-path-inequalities}-\eqref{eq:lifted-path-induced-cut-inequality2} or as  in \eqref{eq:lifted-path-induced-cut-inequality2}. 
\begin{algorithm}[!ht]
    \caption{Extract\_path()}
    \label{alg:extract-path}
    \begin{algorithmic}
        \STATE  -subpath of , 
        \FOR{ from end of path to beginning} 
        \IF{ edge , }
        \STATE Add  to , skip to node 
        \ELSE 
        \STATE Add  from  to 
        \ENDIF
        \ENDFOR
        \OUTPUT{}
    \end{algorithmic}
\end{algorithm}



  \section{Complexity}
\label{sec:complexity}



Below, we show that the lifted disjoint paths problem~\eqref{eq:lifted-disjoint-paths-problem} is NP-hard. The following Theorems state that even its restricted versions  using only negative or only positive lifted edges are NP-hard.
The proofs use reductions from two known NP-complete problems. Theorem~\ref{thm:multicommodity-flow-reduction} is proven by reduction from integer multicommodity flow~\cite{EvenMulti} and Theorem~\ref{thm:3sat-flow-reduction}  by reduction from 3-SAT~\cite{cook1971complexity}.




\begin{restatable}{thm}{multicommodityflowreduction}
\label{thm:multicommodity-flow-reduction}
Lifted disjoint paths problem~\eqref{eq:lifted-disjoint-paths-problem} with negative lifted edges only is NP-hard.
\end{restatable}

\begin{restatable}{thm}{threesatreduction}
\label{thm:3sat-flow-reduction}
Lifted disjoint paths problem~\eqref{eq:lifted-disjoint-paths-problem} with positive lifted edges only is NP-hard.
\end{restatable}

  \section{Experiments}
\label{sec:experiments}


We conduct several experiments on MOT showing the merit of using lifted disjoint paths for the tracking problem.
Below, we describe our problem construction, cost learning for base and lifted edges, preprocessing and post-processing steps and report resulting performance. More details about our experiments are provided in Appendix, Section \ref{sec:appendix}.
\subsection{Graph Construction.}

\paragraph{Two-step procedure.}
Due to the computational complexity of the problem, we cannot solve entire video sequences straightforwardly. 
In order to make the problem tractable, we apply the following two-step procedure.
In the first step, the solver is applied on graphs over person detections but only for small time intervals consisting of a few dozen video frames.  
The tracks resulting from the first step are used for extracting tracklets. 
In the second step, the solver is applied on newly created graphs  and  where vertices correspond to the obtained tracklets.
Edges and edge costs between tracklets are obtained by aggregating original edges resp.\ edge costs between person detections.
The tracks resulting from the second step may be suboptimal with respect to the original objective function defined over person detections.
Therefore, we identify points where splitting a track leads to an improvement of the original objective value and extract new tracklets from the divided tracks. 
Multiple iterations of the second step are performed until no improving split points are found in the output tracks.
This two-step procedure improves the objective w.r.t.\ the original objective~\eqref{eq:lifted-disjoint-paths-problem} in every iteration.
Since there are only finitely many trackings, the procedure terminates finitely.
In practice, only a few iterations are necessary.



\paragraph{Graph sparsification. }For our experiments, we use edges between detections up to  temporal distance. These long range edges cause high computational complexity for the first step. In order to reduce it, we apply sparsification on both base and lifted graphs. For the base edges, we select for every  its  nearest (lowest-cost) neighbors from every subsequent time frame within an allowed time gap. Lifted edges with costs close to zero are not included, since they are not discriminative. Lifted edges connecting detections with high time gap are included more sparsely than lifted edges having lower time gaps. We use dense graphs in the second step. 

\paragraph{Costs.}
Initially, in the first step, we set  for all vertices .
For the second step, where  represents tracklets,  is set to the cost of outputting tracklet  as a final trajectory. 
Specifically,  is the sum of costs of base edges between consecutive detections in the tracklet and the cost of lifted edges between all pairs of detections contained in the tracklet.
The cost of a base edge between two tracklets is given by the cost of the original base edge connecting the last detection in the first tracklet with the first detection in the subsequent tracklet.
The cost of a lifted edge between two tracklets is obtained by summing up the costs of original lifted edges between detections contained in the tracklets.
This ensures that the costs of the tracklet solution corresponds to the costs of the original problem. We set cost of all edges from the source node  and to the sink node  to zero. Setting of detection costs and in/out costs to zero reduces the number of hyperparameters that  usually needs to be incorporated by other methods. Moreover, our method does not include temporal decay of edge costs since the formulation directly prefers short range base edges over the long range ones.



\subsection{Preprocessing and Post-processing}
\label{sec:pre_post_processing}
As is common for tracking by detection, we perform pre- and  postprecessing to compensate for detector inaccuracies.


\textbf{Input filtering.} Given a set of input detections derived from a detector, we follow the approach of~\cite{bergmann2019tracking}, a leading tracker for the MOT challenge, to reject false positive detections and to correct misaligned ones.
For this, each input detection is send through the regression and classification part of their detector.
In more detail, all tracking parts involved in the tracker Tracktor \cite{bergmann2019tracking} are deactivated, such that it only reshapes and eventually rejects input  detections, without assigning labels to them.
Input detections are rejected if  Tracktor's detector outputs a confidence score .

Tracktor also applies a non-maxima-surpression on the reshaped input detections, where we use the threshold .



\textbf{Inter- and extrapolation.} 
Even if all input detections have been assigned to the correct identities by our solver, there might still be  missing detections in case that a person has not been detected in some frames. We recover missing detections within the time range of a trajectory, which we denote as interpolation. Further, we extend a trajectory in forward and backward directions, which we denote as extrapolation.
To this end, we follow~\cite{bergmann2019tracking} and apply their object detector to recover missing positions based on the visual information at the last known position. 
Finally, for sequences filmed from a static camera, we perform linear interpolation on the remaining gaps. 
These sequences can be automatically detected using DeepMatching on the regions outside detection boxes.



To demonstrate the performance using traditional post-processing, we also evaluate our tracker using only linear interpolation as post-processing in all sequences.


\subsection{Cost Learning}
\label{sec:cost_learning}
Costs for base edges  and lifted edges  are computed equally, since they both indicate whether two detections are from the same object or not.
For an edge , we denote with  the detection width corresponding to node .


\paragraph{Visual cues.}
We exploit two different appearance features:
Given two detections, the \emph{re-identification} descriptor utilizes global appearance statistics, 
while the \emph{deep-matching} descriptor relies on fine-grained pixel-wise correspondences.



We employ the state-of-the-art re-identification network~\cite{zheng2019joint} and train it on MOT17 train set~\cite{MOT16} together with additional re-identification datasets~\cite{zheng2015scalable,wei2018person,ristani2016MTMC}. The obtained feature value  is modified in order to better reflect the uncertainty of a connection.
We truncate values smaller  (corresponding to improbable connections) and re-scale the rest. First, we normalize scores between each detection  and all detections in every time frame  through the score of the most probable connecting edge . Second, all other connections than  are downscaled.


Our second visual cue utilizes DeepMatching (DM)~\cite{weinzaepfel:hal-00873592} to establishes pixelwise correspondences between two images. It thus serves as a reliable tracking feature \cite{tang2016multi,Henschel_2018_CVPR_Workshops,henschel2019multiple}.


We apply DM between boxes in two images and compute the DM intersection over union~\cite{tang2016multi,Henschel_2018_CVPR_Workshops}  w.r.t.\ the whole detection boxes and on five subboxes (left/right, upper/middle/lower part).
In addition,  we measure for all points in a given subbox whether their matched endpoints are in the corresponding subbox again or not. This gives two additional error measures for deviation in  and -directions.
Thus, in total we obtain a feature vector .
In order to assess the reliability of DM features, density of matching points is computed in each box and its subboxes. The smaller value is chosen for each box pair. This results in feature .



\paragraph{Motion constraints.}
We penalize for improbable motions by comparing the maximal displacement of DM endpoints within the sequence with the displacements of detection boxes. Assignment hypotheses of pairs of boxes representing improbable motions are penalized with a large cost.



\paragraph{Spatio-temporal cues.}
Our spatio-temporal cues utilize a simple motion compensation by computing the median DM displacement between correspondences of the background. 

We assume a linear motion model, similar to~\cite{ristani2018features} and penalize deviations of detections from the estimated motion trajectory.
This enforces  spatio-temporally consistency of detections within one trajectory.
Furthermore, we penalize improbable large person movements by relating velocities (in pixels per seconds) in horizontal direction to box width:  .




\paragraph{Fusion of input features.}
We construct a neural network consisting of fully connected layers, batch normalization and relu units taking the above described features and time differences as input and outputting scores for assignment hypotheses.
The final layer uses a sigmoid activation function for producing a score in .
We refer to the supplemental material for the exact structure of the neural network and details about the training procedure. 

\subsection{Experiment Setup}
In order to assess the suitability of the proposed lifted disjoint paths formulation for MOT, we conduct extensive experiments on three challenging benchmarks: MOT15~\cite{MOTChallenge2015}, MOT16 and MOT17~\cite{MOT16}, resulting in 39 test sequences. The sequences are filmed from static and moving cameras. While MOT16 and MOT17 share the same sequences, MOT17 provides three different detectors in order to study the dependence of the tracking quality on the input detections. 
We perform analysis and parameter tuning for our tracker on the MOT17 train set, even when our tracker is applied to the MOT15 sequences to ensure that our tracker is not prone to overfitting. 
We follow the MOT challenge protocol and use the detections provided by the respective benchmarks. 
All experiments on the training set are evaluated using a leave-one-out cross-validation. This includes all of our training procedures,  in particular also the training of the re-identification  network. 

To measure the tracking quality, the multiple object tracking accuracy (MOTA) \cite{bernardin2008evaluating} and the IDF1 metric \cite{ristani2016MTMC} are regarded as the most meaningful ones. The first incorporates the number of false negatives (FN), false positives (FP) and identity switches (IDS), thereby focusing on the coverage of persons. The latter assesses the consistency w.r.t.\ identities. Further tracking metrics (MT, ML) are defined in \cite{li2009learning}. 


\subsection{Benefit of Long Range Edges}
\label{sec:exp_long_range_edges}
We investigate the importance of using long range information for MOT. To this end, we apply our proposed tracker on the MOT17 training sequence with varying maximal time gap, for which base and lifted edges are created between nodes. In order to assess the influence of the time gap on the tracking quality, we measure the \textit{assignment} quality in terms of the MOTA and IDF1 metrics, without performing any inter- or extrapolation.
To assess how well the \textit{assignment part} is solved by our tracker, we compute the maximum achievable metrics given the filtered input detections and admissible assignment hypotheses within maximal time gaps. A detailed description of how we obtain the optimal assignments are given in the appendix in Section \ref{sec:optimal_assignment_definition}.
From the result in Table~\ref{tab:tracking_performance_over_time}, we see essentialy constant MOTA scores. 
This is due the fact that selecting correct connections does not change MOTA significantly except after inter- and extrapolation (which we have excluded in Table~\ref{tab:tracking_performance_over_time}). 
However, we see a significant improvement in the IDF1 score, which directly penalizes wrong connections. Here, long range edges help greatly.
Moreover, both metrics, ID precision and ID recall, clearly increase with increasing time gap. This shows that improvements by incorporating more temporal information come from using longer skip edges (impact on IDR) but most importantly, precision increases greatly. This means that ID switches are avoided thanks to lifted edges.
Furthermore, the experiment shows that our designed features together with the lifted disjoint paths formulation \eqref{eq:lifted-disjoint-paths-problem} are well-suited for the MOT problem delivering nearly optimal assignments. 





\begin{table}[hbt]

    \centering
\tabcolsep=0.09cm
\begin{tabular}{lcccccc}
\toprule  &   &  &  &  &  &  \\ \hline
MOTA (ours) &  &   &   &   &   & - \\
MOTA (optimal) & &  &  &  &   & \\ \hline 
IDF1 (ours)  &  &   &   &   &   & - \\
IDF1 (optimal) & &  &  & &   & \\ \hline
IDP (ours)  &  &   &   &   &   & - \\
IDP (optimal) & &  &  & &   &   \\ \hline
IDR (ours)  &  &   &   &   &   & - \\
IDR (optimal) & &  &  & &   & \\ \bottomrule
\end{tabular}   
\caption{Assignment quality of our solver without interpolation or extrapolation on the MOT17 train set with different maximal time gaps in seconds. Rows 1,3,5 and 7 show the results by our solver, rows 2,4,6 and 8 show the maximally achievable bounds with admissible assignment hypotheses up to the specified time gap. 
Bold numbers represent the best values per row.}
    \label{tab:tracking_performance_over_time}

\end{table}{}





\begin{table*}
\center

\small{

    \begin{tabular}{c l c c c c c c c c c}
     \toprule
     & Method  & MOTA  & IDF1  & MT  & ML  & FP & FN & IDS & Frag \\   
     \toprule
     \parbox[t]{3mm}{\multirow{5}{*}{\rotatebox[origin=c]{90}{MOT17}}} &
 Lif\_T (ours) &   &&  &   &  &  & &   \\ 
 & Lif\_TsimInt (ours) &   &&  &   &  &  & &   \\ 
& Tracktor17&   &  &  &  &  &  &  &   \\ 
& JBNOT~ &   &  &  &  &  &  &  &   \\ 
& FAMNet&   &  &  &   &  &  &  &   \\ 
& eTC17&  &  &   &   &  &  &  &   \\ 
& eHAF17&   &  &   &   &  &  &  &   \\


     \midrule
     
     \parbox[t]{3mm}{\multirow{5}{*}{\rotatebox[origin=c]{90}{MOT16}}} &
     Lif\_T (ours) &  &  &  &  &  &  &  &   \\ 
     & Lif\_TsimInt (ours) &   &&  &   &  &  & &   \\
& Tracktor16 &   &  &  &  &  &  &  &   \\ 
& NOTA &   &  &  &  &  &  &  &   \\ 
& HCC &   &  &  &  &  &  &  &   \\ 
& eTC&   &  &  &  &  &  &  &   \\ 
& KCF16  &   &  &  &  &  &  &  &   \\
     \midrule
     
     \parbox[t]{3mm}{\multirow{5}{*}{\rotatebox[origin=c]{90}{2D MOT15}}} &
    Lif\_T (ours) &   &  &  &  &  &  &  &  \\ 
    & Lif\_TsimInt (ours) &   &  &  &  &  &  &  &  \\ 
& Tracktor15 & &  &  &  &  &  &  &   \\ 
& KCF  &  &  &  &  &  &  &  &   \\ 
& AP\_HWDPL\_p &   &  &  &   &  &  &  &   \\ 
& STRN &   &  &  &   &  &  &  &   \\ 
& AMIR15 &   &  &  &  &  &  &  &     \\
     \bottomrule
    \end{tabular}

\caption{We compare our tracker Lif\_T with the five best performing competing solvers w.r.t.\ MOTA from the MOT challenge. 
Tracktor~\cite{bergmann2019tracking}, 
JBNOT~\cite{henschel2019multiple},
FAMNet~\cite{chu2019famnet},
eTC~\cite{wang2019exploit},
eHAF~\cite{sheng2018heterogeneous},
NOTA~\cite{chen2019aggregate},
HCC~\cite{ma2018customized},
KCF~\cite{chu2019online},
AP\_HWDPL\_p~\cite{chen2017online},
STRN~\cite{xu2019spatial} and
AMIR15~\cite{sadeghian2017tracking}.
In addition, we compare the results to our tracker Lif\_TsimInt that uses only a simple interpolation method (linear interpolation) as post-processing in all sequences.
We outperform competing solvers on most metrics on all three MOT Challenge benchmarks, using Lif\_T and Lif\_TsimInt.  
Arrows indicate whether low or high metric values are better.}
\vspace{-0.2cm}
\label{tab:mot}
}
\end{table*}

\subsection{Benchmark Evaluations}
Finally, we compare our tracking performance on the MOT15, MOT16 and MOT17 benchmarks with all trackers listed on the MOTChallenge which have been peer-reviewed and correspond to published work. 
The three benchmark datasets consist of 11/7/7 training and test sequences for MOT15/16/17 respectively.
They are the standard benchmark datasets for MOT.
The results in Table~\ref{tab:mot} show the tracking performance of our tracker together with the best 5 performing trackers, accumulated over all sequences of the respective benchmarks. 
The evaluations show that we outperform all tracking systems by a large margin on all considered benchmarks. On MOT17, we improve the MOTA score from 53.5 to 60.5 and the IDF1 score from  52.3 to 65.6, which corresponds to an improvement of 13\% in terms of MOTA and almost 25\% in terms of the IDF1 score, indicating the effectiveness of the lifted edges. We observe similar improvements across all three benchmarks. These results reflect the near-optimal assignment performance observed on the MOT17 train set in Sect.~\ref{sec:exp_long_range_edges}. 
Finally, using only simple linear interpolation as post-processing (Lif\_TsimInt), our tracker achieves   MOTA and  IDF1. Even then, our system clearly outperforms existing tracking systems. On average, the ILP solver needs  min.\ per sequence. Detailed runtimes are available in Table 5 in Appendix. 

 \section{Conclusion}
\label{sec:conclusion}
We have shown that for the MOT challenge datasets we reach nearly optimal data association performance.
We conjecture that further improvements would have to come from better detectors, better inter- and extrapolation and more powerful solvers for our formulation to take into account even longer time-gaps.
Our polyhedral work offers the basis for writing such more powerful solvers.


 \section{Acknowledgement}
\label{sec:acknowledgement}
This work was funded by the Deutsche Forschungsgemeinschaft (DFG, German Research Foundation) under Germany's Excellence Strategy within the Cluster of Excellence PhoenixD (EXC 2122). We thank Laura Leal-Taix{\'e} for initiating the collaboration. We thank all reviewers for their valuable comments.  
\clearpage 
\newpage
\bibliography{literature}
\bibliographystyle{icml2020}

\setcounter{@affiliationcounter}{2}

\clearpage
\newpage
\twocolumn[
\icmltitle{Lifted Disjoint Paths with Application in Multiple Object Tracking \\ \normalfont Appendix}





\icmlsetsymbol{equal}{*}

\begin{icmlauthorlist}
\icmlauthor{Andrea Hornakova}{equal,mpi}
\icmlauthor{Roberto Henschel}{equal,tnt}
\icmlauthor{Bodo Rosenhahn}{tnt}
\icmlauthor{Paul Swoboda}{mpi}
\end{icmlauthorlist}

\icmlaffiliation{mpi}{Computer Vision and Machine Learning, Max Planck Institute for Informatics, Saarbr\"ucken, Saarland, Germany}







\icmlkeywords{combinatorial optimization, disjoint paths, network flow, polyhedral relaxation, multiple object tracking}

\vskip 0.3in
]
\printAffiliationsAndNotice{\icmlEqualContribution} 

\begin{abstract}
This appendix supplements our work by presenting missing proofs regarding the solver and details about our tracker. 

Sections \ref{sec:appendix-constraints} up to Section \ref{sec:appendix-complexity} provide proofs used in Sections \ref{sec:constraints} and \ref{sec:complexity}. 

Section \ref{sec:optimal_assignment_definition} provides further information how  the optimal assignments used in Section \ref{sec:exp_long_range_edges} were obtained. The impact of the employed post-processing used in our tracker is analyzed in Section \ref{sec:ablation_postprocessing}. Details about the used fusion network are given in Section \ref{sec:fusion_network_details}. Finally, evaluation metrics for all tracked sequences are provided in Section \ref{sec:results_all_sequences}. 
\end{abstract}
 \section{Appendix}
\subsection{Proofs for Section~\ref{sec:constraints}}
\label{sec:appendix-constraints}


\begin{restatable}{prop}{multicutpathineqweaker}
\label{prop:multicut-path-inequalities weaker}
Path inequalities \eqref{eq:path-inequalities} define a strictly tighter relaxation of the lifted disjoint path problem than the lifted multicut path inequalities

\end{restatable}
\begin{proof}
Let us define the following sets:

\begin{itemize}
    \item Let us prove that 
    
    Let us rewrite the right hand side of \eqref{eq:path-inequalities} for a path -paths:
 
\item Let us prove that  

We prove that there exists  such that  satisfies \eqref{eq:multicut-path} and does not satisfy \eqref{eq:path-inequalities}. 
An example is given in Figure \ref{fig:multicut-path}.
There are four possible paths from  to .
If we use Constraints \eqref{eq:multicut-path}, the highest lower bound on  is given by path  and it is as follows:

Let us apply Constraint \eqref{eq:path-inequalities} using path . We obtain the following threshold on 

\end{itemize}
\end{proof}

\begin{figure}
\begin{center}
\begin{tikzpicture}


\node[style=vertex] (1) at (1, 0) {};
\node[style=vertex] (2) at (2, 0) {};
\node[style=vertex] (3) at (3, 0) {};
\node[style=vertex] (4) at (4, 0) {};
\node[style=vertex] (5) at (5, 0) {};
\node[style=vertex] (6) at (6, 0) {};

\node[style=vertex] (7) at (3, -0.7) {};
\node[style=vertex] (8) at (6, -0.7) {};


\draw[base-edge] (1) edge node[midway,above]{\footnotesize{0.5}} (2);
\draw[base-edge] (2) edge node[midway,above]{\footnotesize{0.5}}(3);
\draw[base-edge] (3) edge node[midway,above]{\footnotesize{0.5}}(4);
\draw[base-edge] (4) edge node[midway,above]{\footnotesize{0.5}}(5);
\draw[base-edge] (5) edge node[midway,above]{\footnotesize{1}}(6);

\draw[base-edge] (2) edge node[pos=0.3,below]{\footnotesize{0}}(7);
\draw[base-edge] (5) edge node[pos=0.3,below]{\footnotesize{0}}(8);

\draw[base-edge] (1) edge [bend left=50] node[midway,above]{\footnotesize{0.5}} (3);
\draw[base-edge] (3) edge [bend left=50] node[midway,above]{\footnotesize{0.5}} (5);

\draw[lifted-edge] (1) edge [bend left=60] node[midway,above]{\footnotesize{?}} (6);



\end{tikzpicture} \caption{Failure case for lifted multicut path inequality~\eqref{eq:multicut-path}. The path inequality~\eqref{eq:path-inequalities} gives the correct lower bound for lifted edge  in this case. Example for Proposition \ref{prop:multicut-path-inequalities weaker}.}
\label{fig:multicut-path}
\end{center}
\end{figure}

\liftedstrictlybetter*



\begin{proof}
Let us define the following sets

\begin{itemize}
\item Let us prove that :\\
Note that every path  belongs to the set of  too. It just holds that . 
Let us rewrite the right hands side of the inequality from~\eqref{eq:lifted-path-inequalities} for such   where . 

Which is exactly the right hand side of~\eqref{eq:path-inequalities}. Therefore, any pair of real vectors  that satisfies~\eqref{eq:lifted-path-inequalities} must satisfy~\eqref{eq:path-inequalities} as well.



\item Let us prove that :\\
We prove that there exists  such that  satisfies~\eqref{eq:path-inequalities} and does not satisfy~\eqref{eq:lifted-path-inequalities}. See the graph in Figure~\ref{fig:lifted-path-proof}. There are four possible paths from  to  in . If we use Constraints~\eqref{eq:path-inequalities}, all the paths give us the same lower bound on 

\end{itemize}
If we use Constraints \eqref{eq:lifted-path-inequalities} with path  where , we obtain

\end{proof}

\begin{figure}
\begin{center}
\begin{tikzpicture}


\node[style=vertex] (2) at (1, 0) {};
\node[style=vertex] (3) at (2, 0) {};
\node[style=vertex] (4) at (3, 0.7) {};
\node[style=vertex] (5) at (3, -0.7) {};
\node[style=vertex] (6) at (4, 0) {};
\node[style=vertex] (7) at (5, 0.7) {};
\node[style=vertex] (8) at (5, -0.7) {};
\node[style=vertex] (9) at (6, 0) {};
\draw[base-edge] (2) -- (3) node[midway,above]{\footnotesize{1}} ;
\draw[base-edge] (3) -- (4)node[midway,above]{\footnotesize{0.5}} ;
\draw[base-edge] (3) -- (5)node[pos=0.3,below]{\footnotesize{0.5}} ;
\draw[base-edge] (4) -- (6)node[midway,above]{\footnotesize{0.5}} ;
\draw[base-edge] (5) -- (6)node[pos=0.7,below]{\footnotesize{0.5}} ;
\draw[lifted-edge] (3) -- (6)node[midway,above]{\footnotesize{1}} ;
\draw[base-edge] (6) -- (7)node[midway,above]{\footnotesize{0.5}} ;
\draw[base-edge] (6) -- (8)node[pos=0.3,below]{\footnotesize{0.5}} ;
\draw[base-edge] (7) -- (9)node[midway,above]{\footnotesize{0.5}} ;
\draw[base-edge] (8) -- (9)node[pos=0.7,below]{\footnotesize{0.5}} ;
\draw[lifted-edge] (6) -- (9)node[midway,above]{\footnotesize{1}} ;
\draw[lifted-edge] (2) edge [bend left=70] node[midway,above]{\footnotesize{?}} (9);


\end{tikzpicture} \caption{Exemplary case where the path inequalities~\eqref{eq:path-inequalities} give a trivial lower bound on lifted edge .
The lifted path inequality~\eqref{eq:lifted-path-inequalities} gives the correct lower bound. Example for Proposition~\ref{prop:lifted-path-strictly-better}.
}
\label{fig:lifted-path-proof}
\end{center}
\end{figure}


\liftedpathinducedcutbetter*


\begin{proof}
Let us define the following sets




\begin{itemize}
\item First, we prove :\\
We use the same argument as in the proof of Proposition~\ref{prop:lifted-path-strictly-better}. Every path  belongs to the set of  and it holds that . 
Let us rewrite the right hands side of the inequality from~\eqref{eq:lifted-path-induced-cut-inequality} for such   where . 

Which is exactly the right hand side of \eqref{eq:path-induced-cut-inequality}. Therefore, any pair of real vectors  that satisfies \eqref{eq:lifted-path-induced-cut-inequality} must satisfy \eqref{eq:path-induced-cut-inequality}.\\


\item Let us prove :\\
We prove that there exists  such that  satisfies \eqref{eq:path-induced-cut-inequality} and does not satisfy \eqref{eq:lifted-path-induced-cut-inequality}.

See the example in Figure \ref{fig:lifted-cut-proof}. There are four possible paths in  from  to either  or . They are , , , . Using~\eqref{eq:lifted-path-induced-cut-inequality}, all of them give us the same threshold on :

If we use Constraint \eqref{eq:lifted-path-induced-cut-inequality} with path , we obtain the following threshold:



\item Let us prove that \\
It holds trivially that . Let us prove that there exists   such that  and .

See the example graph in Figure~\ref{fig:lifted-cut-proof2}. Similarly as in Figure~\ref{fig:lifted-cut-proof}, there are  four possible paths from  to either  or  in . There are no active lifted edges that would enable us to obtain a better upper bound on  using~\eqref{eq:lifted-path-induced-cut-inequality} than the following:

However, if we use Constraints \eqref{eq:lifted-path-induced-cut-inequality2} with path  and , we obtain

\end{itemize}
\end{proof}




\begin{figure}
\begin{center}
\begin{tikzpicture}[scale=1.3]

\node[style=vertex] (10) at (1, 0) {};
\node[style=vertex](20) at (2, 0) {};
\node[style=vertex]  (30) at (3, 0) {};
\node[style=vertex] (40)  at (4, 0) {};

\node[style=vertex] (11) at (1, 1) {};
\node[style=vertex] (21) at (2,1) {};
\node[style=vertex] (31) at (3, 1) {};
\node[style=vertex] (41) at (4, 1) {};

\draw[base-edge] (10) -- (20)node[midway,below] {\footnotesize{0.5}};
\draw[base-edge] (20) -- (30)node[midway,below] {\footnotesize{0.5}};
\draw [base-edge] (21) -- (30)node[pos=0.3,above]  {\footnotesize{0.5}};
\draw [base-edge](11) -- (21)node[pos=0.5,above]  {\footnotesize{0.5}};
\draw [base-edge](21) -- (31)node[pos=0.5,above]  {\footnotesize{0.5}};
\draw [base-edge](31) -- (41)node[pos=0.5,above]  {\footnotesize{1}};
\draw [base-edge](31) -- (40)node[pos=0.3,above]  {\footnotesize{0}};
\draw [base-edge](20) -- (31)node[pos=0.3,below]  {\footnotesize{0.5}};
\draw[base-edge] (30) -- (41)node[pos=0.3,below]  {\footnotesize{0}};
\draw[base-edge] (11) -- (20)node[pos=0.3,above]  {\footnotesize{0.5}};
\draw[base-edge] (10) -- (21)node[pos=0.3,below]  {\footnotesize{0.5}};
\draw[base-edge] (30) -- (40)node[midway,below]  {\footnotesize{1}};

\draw[lifted-edge] (11) edge [bend left=50] node[midway,above]{\footnotesize{1}}(31);
\draw[lifted-edge] (10) edge [bend right=50] node[midway,above]{\footnotesize{1}}(30);

\draw[lifted-edge] (11) edge node[pos=0.65,above]{\footnotesize{?}} (40);


\end{tikzpicture} \caption{
Exemplary case where the path-induced cut inequalities~\eqref{eq:path-induced-cut-inequality} fail to give non-trivial upper bounds for lifted edge .
The lifted path-induced cut-inequalities~\eqref{eq:lifted-path-induced-cut-inequality} give the correct upper bound in this case. Example for Proposition~\ref{prop:lifted-path-induced-cut-inequality-strictly-better}.
}
\label{fig:lifted-cut-proof}
\end{center}
\end{figure}



\begin{figure}
\begin{center}
\begin{tikzpicture}[scale=1.3]

\node[style=vertex] (10) at (1, 0) {};
\node[style=vertex](20) at (2, 0) {};
\node[style=vertex]  (30) at (3, 0) {};
\node[style=vertex] (40)  at (4, 0) {};

\node[style=vertex] (11) at (1, 1) {};
\node[style=vertex] (21) at (2,1) {};
\node[style=vertex] (31) at (3, 1) {};
\node[style=vertex] (41) at (4, 1) {};

\draw[base-edge] (10) -- (20)node[midway,below] {\footnotesize{1}};
\draw[base-edge] (20) -- (30)node[midway,below] {\footnotesize{0.5}};
\draw [base-edge] (21) -- (30)node[pos=0.3,above]  {\footnotesize{0.5}};
\draw [base-edge](11) -- (21)node[pos=0.5,above]  {\footnotesize{1}};
\draw [base-edge](21) -- (31)node[pos=0.5,above]  {\footnotesize{0.5}};
\draw [base-edge](31) -- (41)node[pos=0.5,above]  {\footnotesize{0.5}};
\draw [base-edge](31) -- (40)node[pos=0.3,above]  {\footnotesize{0.5}};
\draw [base-edge](20) -- (31)node[pos=0.3,below]  {\footnotesize{0.5}};
\draw[base-edge] (30) -- (41)node[pos=0.3,below]  {\footnotesize{0.5}};
\draw[base-edge] (11) -- (20)node[pos=0.3,above]  {\footnotesize{0}};
\draw[base-edge] (10) -- (21)node[pos=0.3,below]  {\footnotesize{0}};
\draw[base-edge] (30) -- (40)node[midway,below]  {\footnotesize{0.5}};

\draw[lifted-edge] (21) edge node[midway,above]{\footnotesize{0}}(40);


\draw[lifted-edge] (11) edge node[pos=0.3,below]{\footnotesize{?}} (40);

\end{tikzpicture} \caption{
Exemplary failure case for the lifted path-induced cut inequalities~\eqref{eq:lifted-path-induced-cut-inequality}.
The lifted path-induced cut inequalities~\eqref{eq:lifted-path-induced-cut-inequality2} give the correct upper bound for lifted edge . Example for Proposition~\ref{prop:lifted-path-induced-cut-inequality-strictly-better}.
}
\label{fig:lifted-cut-proof2}
\end{center}
\end{figure}



\subsection{Symmetric Form of Cut Inequalities}
\label{sec:symmetric-inequalities}

Inequalities symmetric to \eqref{eq:path-induced-cut-inequality}:


Inequalities symmetric to \eqref{eq:lifted-path-induced-cut-inequality}


Inequalities symmetric to \eqref{eq:lifted-path-induced-cut-inequality2}




\begin{restatable}{prop}{liftedpathinducedcutbetter-sym}
\label{prop:lifted-path-induced-cut-inequality-strictly-better-sym}
    The lifted path-induced cut inequalities~\eqref{eq:lifted-path-induced-cut-inequality-sym} define a strictly tighter relaxation than the path-induced cut inequalities~\eqref{eq:path-induced-cut-inequality-sym}.\\
    The lifted path-induced cut inequalities~\eqref{eq:lifted-path-induced-cut-inequality-sym} and~\eqref{eq:lifted-path-induced-cut-inequality2-sym} define a strictly better relaxation than~\eqref{eq:lifted-path-induced-cut-inequality-sym} alone.
\end{restatable}

\begin{proof}
Analogical to the proof of Proposition~\ref{prop:lifted-path-induced-cut-inequality-strictly-better}. See Figure~\ref{fig:lifted-cut-sym-proof} for example analogical to the one in Figure~\ref{fig:lifted-cut-proof} and Figure~\ref{fig:lifted-cut-sym-proof2} for example analogical to the one in Figure~\ref{fig:lifted-cut-proof2}.
\end{proof}




\begin{restatable}{prop}{symmetric-different}
\label{prop:sym-different}

\begin{enumerate}
    \item The path-induced cut inequalities~\eqref{eq:path-induced-cut-inequality} together with their symmetric counterpart \eqref{eq:path-induced-cut-inequality-sym} define a strictly tighter relaxation than  inequalities~\eqref{eq:path-induced-cut-inequality} alone.
    \item The path-induced cut inequalities~\eqref{eq:lifted-path-induced-cut-inequality} together with their symmetric counterpart \eqref{eq:lifted-path-induced-cut-inequality-sym} define a strictly tighter relaxation than  inequalities~\eqref{eq:lifted-path-induced-cut-inequality} alone.
       \item Using path-induced cut inequalities~\eqref{eq:lifted-path-induced-cut-inequality2-sym} together with \eqref{eq:lifted-path-induced-cut-inequality}, \eqref{eq:lifted-path-induced-cut-inequality2} and \eqref{eq:lifted-path-induced-cut-inequality-sym} strictly improves the relaxation.
\end{enumerate}    
\end{restatable}

\begin{proof}
\begin{enumerate}
    \item See the example in Figure \ref{fig:sym-cut-proof}.\\
    Upper bound  on  by \eqref{eq:path-induced-cut-inequality}:
    .\\
    Upper bound  on  by \eqref{eq:path-induced-cut-inequality-sym}: .
    
    \item See the example in Figure~\ref{fig:lifted-cut-sym-proof}.\\
    Upper bound  on  by~\eqref{eq:lifted-path-induced-cut-inequality}: 
    .\\
    Upper bound  on  by~\eqref{eq:lifted-path-induced-cut-inequality-sym} using path : .
    
    \item See the example in Figure \ref{fig:lifted-cut-sym-proof2}.\\
    Upper bounds  on  by \eqref{eq:lifted-path-induced-cut-inequality}, \eqref{eq:lifted-path-induced-cut-inequality2}, \eqref{eq:lifted-path-induced-cut-inequality-sym}: .
    Upper bound  on  by \eqref{eq:lifted-path-induced-cut-inequality2-sym} using path  and : .
\end{enumerate}

\end{proof}



\begin{figure}
\begin{center}
\begin{tikzpicture}[scale=1.3]

\node[style=vertex] (10) at (1, 0) {};
\node[style=vertex](20) at (2, 0) {};
\node[style=vertex]  (30) at (3, 0) {};
\node[style=vertex] (40)  at (4, 0) {};

\node[style=vertex] (11) at (1, 1) {};
\node[style=vertex] (21) at (2,1) {};
\node[style=vertex] (31) at (3, 1) {};
\node[style=vertex] (41) at (4, 1) {};

\draw[base-edge] (10) -- (20)node[midway,below] {\footnotesize{1}};
\draw[base-edge] (20) -- (30)node[midway,below] {\footnotesize{0.5}};
\draw [base-edge] (21) -- (30)node[pos=0.3,above]  {\footnotesize{0.5}};
\draw [base-edge](11) -- (21)node[pos=0.5,above]  {\footnotesize{1}};
\draw [base-edge](21) -- (31)node[pos=0.5,above]  {\footnotesize{0.5}};
\draw [base-edge](31) -- (41)node[pos=0.5,above]  {\footnotesize{0.5}};
\draw [base-edge](31) -- (40)node[pos=0.7,right]  {\footnotesize{0.5}};
\draw [base-edge](20) -- (31)node[pos=0.3,below]  {\footnotesize{0.5}};
\draw[base-edge] (30) -- (41)node[pos=0.7,right]  {\footnotesize{0.5}};
\draw[base-edge] (11) -- (20)node[pos=0.3,above]  {\footnotesize{0}};
\draw[base-edge] (10) -- (21)node[pos=0.3,below]  {\footnotesize{0}};
\draw[base-edge] (30) -- (40)node[midway,below]  {\footnotesize{0.5}};

\draw[lifted-edge] (21) edge [bend left=50] node[midway,above]{\footnotesize{1}}(41);
\draw[lifted-edge] (20) edge [bend right=50] node[midway,above]{\footnotesize{1}}(40);

\draw[lifted-edge] (11) edge node[pos=0.65,above]{\footnotesize{?}} (40);

\end{tikzpicture} \caption{The best upper bound on  is provided by inequalities~\eqref{eq:lifted-path-induced-cut-inequality-sym}. Example for Proposition~\ref{prop:lifted-path-induced-cut-inequality-strictly-better-sym} and Proposition~\ref{prop:sym-different}.}
\label{fig:lifted-cut-sym-proof}
\end{center}
\end{figure}


\begin{figure}
\begin{center}
\begin{tikzpicture}[scale=1.3]

\node[style=vertex] (10) at (1, 0) {};
\node[style=vertex](20) at (2, 0) {};
\node[style=vertex]  (30) at (3, 0) {};
\node[style=vertex] (40)  at (4, 0) {};

\node[style=vertex] (11) at (1, 1) {};
\node[style=vertex] (21) at (2,1) {};
\node[style=vertex] (31) at (3, 1) {};
\node[style=vertex] (41) at (4, 1) {};

\draw[base-edge] (10) -- (20)node[midway,below] {\footnotesize{0.5}};
\draw[base-edge] (20) -- (30)node[midway,below] {\footnotesize{0.5}};
\draw [base-edge] (21) -- (30)node[pos=0.3,above]  {\footnotesize{0.5}};
\draw [base-edge](11) -- (21)node[pos=0.5,above]  {\footnotesize{0.5}};
\draw [base-edge](21) -- (31)node[pos=0.5,above]  {\footnotesize{0.5}};
\draw [base-edge](31) -- (41)node[pos=0.5,above]  {\footnotesize{1}};
\draw [base-edge](31) -- (40)node[pos=0.7,right]  {\footnotesize{0}};
\draw [base-edge](20) -- (31)node[pos=0.3,below]  {\footnotesize{0.5}};
\draw[base-edge] (30) -- (41)node[pos=0.7,right]  {\footnotesize{0}};
\draw[base-edge] (11) -- (20)node[pos=0.3,left]  {\footnotesize{0.5}};
\draw[base-edge] (10) -- (21)node[pos=0.3,left]  {\footnotesize{0.5}};
\draw[base-edge] (30) -- (40)node[midway,below]  {\footnotesize{1}};

\draw[lifted-edge] (11) edge node[pos=0.4,below]{\footnotesize{0}}(30);


\draw[lifted-edge] (11) edge node[pos=0.65,above]{\footnotesize{?}} (40);

\end{tikzpicture} \caption{The best upper bound on  is provided by inequalities~\eqref{eq:lifted-path-induced-cut-inequality2-sym}. Example for Proposition~\ref{prop:lifted-path-induced-cut-inequality-strictly-better-sym} and Proposition~\ref{prop:sym-different}.}
\label{fig:lifted-cut-sym-proof2}
\end{center}
\end{figure}



\begin{figure}
\begin{center}
\begin{tikzpicture}


\node[style=vertex] (11) at (1, 0.5) {};
\node[style=vertex] (10) at (1, -1.5) {};

\node[style=vertex] (22) at (2, 0.5) {};
\node[style=vertex] (21) at (2, -0.5) {};
\node[style=vertex] (20) at (2, -1.5) {};

\node[style=vertex] (31) at (3, 0.5) {};
\node[style=vertex] (30) at (3, -1.5) {};

\node[style=vertex] (42) at (4, 0.5) {};
\node[style=vertex] (41) at (4, -0.5) {};
\node[style=vertex] (40) at (4, -1.5) {};

\node[style=vertex] (51) at (5, 0.5) {};
\node[style=vertex] (50) at (5, -1.5) {};


\draw[base-edge] (10) edge node[midway,below]{\footnotesize{1}}(20);
\draw[base-edge] (10) edge node[midway,left]{\footnotesize{0}}(21);

\draw[base-edge] (20) edge node[midway,below]{\footnotesize{1}}(30);
\draw[base-edge] (21) edge node[pos=0.5,left]{\footnotesize{0}}(30);

\draw[base-edge] (30) edge node[midway,below]{\footnotesize{1}}(40);
\draw[base-edge] (30) edge node[midway,left]{\footnotesize{0}}(41);

\draw[base-edge] (40) edge node[midway,below]{\footnotesize{1}}(50);
\draw[base-edge] (41) edge node[midway,above]{\footnotesize{0}}(50);

\draw[base-edge] (11) edge node[midway,above]{\footnotesize{0.5}}(22);
\draw[base-edge] (11) edge node[pos=0.5,left]{\footnotesize{0.5}}(21);

\draw[base-edge] (22) edge node[midway,above]{\footnotesize{0.5}}(31);
\draw[base-edge] (21) edge node[midway,right]{\footnotesize{0.5}}(31);

\draw[base-edge] (31) edge node[midway,right]{\footnotesize{0.5}}(41);
\draw[base-edge] (31) edge node[midway,above]{\footnotesize{0.5}}(42);

\draw[base-edge] (41) edge node[pos=0.5,right]{\footnotesize{0.5}}(51);
\draw[base-edge] (42) edge node[midway,above]{\footnotesize{0.5}}(51);

\draw[base-edge] (22) edge node[pos=0.8,right]{\footnotesize{0}}(30);
\draw[base-edge] (42) edge node[pos=0.8,right]{\footnotesize{0}}(50);


\draw[lifted-edge] (11) edge node[midway,above]{\footnotesize{?}}(50) ;

\end{tikzpicture} \caption{
The best upper bound on  is provided by inequalities~\eqref{eq:path-induced-cut-inequality-sym}. Example for Proposition~\ref{prop:sym-different}.
}
\label{fig:sym-cut-proof}
\end{center}
\end{figure}

\subsection{Other Valid Inequalities}
Basic flow constraints~\eqref{eq:flow-conservation} together with the advanced constrains on lifted edges~\eqref{eq:vwcut1}-\eqref{eq:lifted-path-induced-cut-inequality2} are sufficient for defining the set of feasible solutions of the lifted disjoint paths problem~\eqref{eq:lifted-disjoint-paths-problem}. Moreover, they define an efficient LP relaxation (Section~\ref{sec:constraints}) and enable efficient separation procedures (Section~\ref{sec:separation}). 
Below, we present lifted flow inequalities specific to the lifted disjoint paths problem applied to MOT that help to improve the speed of our ILP solver.
The inequalities depend on the fact that every node can be connected to maximally one node in each time frame.
Therefore the number of lifted edges originating (or ending) in a given point and ending (resp.\ originating) in a specific time frame is at most one.


The number of constraints~\eqref{eq:lifted-flow1} and~\eqref{eq:lifted-flow2} is linear in the number of vertices. Therefore, we add them to our initial constraint set. This enables to reduce the search space for the branch and bound method in the early solver stages when only few constraints of type~\eqref{eq:path-inequalities}-\eqref{eq:lifted-path-induced-cut-inequality2} have been added.

 \subsection{Proofs for Section \ref{sec:complexity} Complexity}
\label{sec:appendix-complexity}
We define  to be the set of all  such that  are feasible solutions of the lifted disjoint path problem~\eqref{eq:lifted-disjoint-paths-problem}.
\paragraph{Integer multicommodity flow.}

The integer multicommodity flow problem is defined on a directed graph  with edge capacities  and source/sink pairs  and edge flows  and demands , .

The aim is to send  flows from their sources to their sinks such that the flows obey the edge capacities. Formally,

where  denotes the set .
Even has shown in~\cite{EvenMulti} that the integer multicommodity flow problem is NP-complete also in the case of unit capacity edges and two source sink pairs.
Below we detail a construction that gives us a correspondence between edge-disjoint paths in   and node-disjoint paths in the transformed graph .
This construction is similar to transforming a graph into its line graph.
The lifted edges in the transformed graph will count how many units of flow go from sources to sinks.



\begin{lemma}
\label{lemma:multicommodity-flow-reduction}

There exists a polynomial transformation from any graph  with source/sink pairs ,  with demands  to
a pair of graphs  and  with edge costs  and  respectively such that
there exists a feasible integer multicommodity flow in  if and only if the lifted disjoint paths problem for  has objective
.
\end{lemma}

\begin{proof}
Without loss of generality, we consider these feasible flow sets  where it holds  . Note that if the flow of commodity  is higher than its demand , we can reduce it to  by removing the flow across one or more paths in  without violating other constraints.\\
We first detail the graph transformation (see Figures~\ref{fig:mcf-reduction} and \ref{fig:mcf-reduction2}).
\begin{itemize}
 \item For all edges  add a vertex  to .
 \item For each pair of vertices   add an edge  to .
 \item Add vertices  and  to .
 \item Add to  vertices  representing requirements of each commodity .
 \item For each vertex  add an edge  to .
 \item For each pair of vertices  add edge  to .
 \item For all  (representing and edge from  to  in ) add an edge  to .
 \item For all pairs of vertices   add an edge  to . That is, the lifted edges connect all vertices representing edges from  in  with vertices representing the edges to  in .
 \item Cost function on base edges   . 
 \item Cost function on lifted edges  .
\end{itemize}
An illustration of this construction can be seen in Figures~\ref{fig:mcf-reduction} and \ref{fig:mcf-reduction2}.
Note that the construction of  in \cite{EvenMulti} allows  for .
In this case, we still construct separate vertices for their incident edges in .




Every path  in  can be assigned to a path  in  where  can be chosen arbitrarily and vice versa. Note that such a path  saturates exactly one lifted edge .
Moreover, every feasible set of flow functions  satisfying  for all   defines a set of edge-disjoint paths from  to  in .
This set corresponds to a set of  -paths in  whose edges and vertices are disjoint and where every path saturates exactly one lifted edge .  Every lifted edge contributes with  to the total cost. So, this set of disjoint -paths has total cost .\\
Reversely, let us have a set of vertex- and edge-disjoint -paths in  of size  where every path contains some -path as its subpath and therefore its cost is . This set defines uniquely a set of feasible flow functions .\\
So, there exist feasible functions  
 satisfying  for all 
 iff .


\end{proof}




\begin{figure}
\begin{center}
\begin{tikzpicture}[scale=1.3]

\node[style=vertex] (10) at (1, 0) {};
\node[style=vertex] (11) at (1, 1) {};
\node[style=vertex](20) at (2, 0) {};
\node[style=vertex] (21) at (2,0.5) {};
\node[style=vertex] (22) at (2,1) {};

\node[style=vertex]  (30) at (3, 0.5) {};
\node[style=vertex] (31) at (3, 1) {};

\node[style=vertex] (40)  at (4, 0) {};
\node[style=vertex] (41) at (4, 1) {};

\draw[base-edge] (10) -- (20)node[midway,below] {};

\draw [base-edge] (21) -- (30)node[pos=0.3,above]  {};
\draw [base-edge](11) -- (21)node[pos=0.5,above]  {};
\draw [base-edge](21) -- (31)node[pos=0.5,above]  {};
\draw [base-edge](31) -- (41)node[pos=0.5,above]  {};
\draw [base-edge](31) -- (40)node[pos=0.3,above]  {};
\draw [base-edge](22) -- (31)node[pos=0.3,below]  {};
\draw[base-edge] (30) -- (41)node[pos=0.3,below]  {};
\draw[base-edge] (11) -- (22)node[pos=0.3,above]  {};
\draw[base-edge] (10) -- (21)node[pos=0.3,below]  {};
\draw[base-edge] (20) -- (40)node[midway,below] {};







\end{tikzpicture} \caption{Integer multicommodity flow network transformation: Original graph.}
\label{fig:mcf-reduction}
\end{center}
\end{figure}

\begin{figure}
\begin{center}
\tikzset{vertex/.style={circle, draw, inner sep=0pt,text height=3.4mm,text width=3.6mm,text depth=1.5mm,align=center}}

\begin{tikzpicture}[scale=1.3]

\node[style=vertex] (01) at (0, 0) {\footnotesize{}};
\node[style=vertex] (51) at (5, 0) {\footnotesize{}};


\node[style=vertex] (12) at (1, -2) {\footnotesize{}};
\node[style=vertex] (13) at (1, -1) {\footnotesize{}};
\node[style=vertex] (14) at (1, 1) {\footnotesize{}};
\node[style=vertex] (15) at (1, 2) {\footnotesize{}};


\node[style=vertex] (21) at (2, -2) {\footnotesize{}};

\node[style=vertex] (23) at (2, -1) {\footnotesize{}};
\node[style=vertex] (24) at (2, 1) {\footnotesize{}};
\node[style=vertex] (25) at (2, 2) {\footnotesize{}};

\node[style=vertex] (31) at (4, -2) {\footnotesize{}};

\node[style=vertex] (33) at (3, 0) {\footnotesize{}};
\node[style=vertex] (34) at (3, 1) {\footnotesize{}};
\node[style=vertex] (35) at (3, 2) {\footnotesize{}};


\node[style=vertex] (42) at (4, 1) {\footnotesize{}};
\node[style=vertex] (43) at (4, -1) {\footnotesize{}};
\node[style=vertex] (44) at (4, 2) {\footnotesize{}};



\draw[base-edge] (01) edge (12);
\draw[base-edge] (01) edge (13);
\draw[base-edge] (01) edge (14);
\draw[base-edge] (01) edge (15);



\draw[base-edge] (12) edge (21);

\draw[base-edge] (12) edge (23);

\draw[base-edge] (13) edge (21);

\draw[base-edge] (13) edge (23);

\draw[base-edge] (14) edge (24);
\draw[base-edge] (14) edge (25);

\draw[base-edge] (15) edge (24);
\draw[base-edge] (15) edge (25);

\draw[base-edge] (21) edge (31);


\draw[base-edge] (23) edge (33);
\draw[base-edge] (23) edge (34);

\draw[base-edge] (24) edge (33);
\draw[base-edge] (24) edge (34);

\draw[base-edge] (25) edge (35);

\draw[base-edge] (31) edge [bend right=30] (51);


\draw[base-edge] (33) edge (42);

\draw[base-edge] (33) edge (42);

\draw[base-edge] (34) edge (43);
\draw[base-edge] (34) edge (44);

\draw[base-edge] (35) edge (43);
\draw[base-edge] (35) edge (44);

\draw[base-edge] (42) edge (51);
\draw[base-edge] (43) edge (51);
\draw[base-edge] (44) edge (51);

\draw[lifted-edge] (21) edge[bend right=30] node[pos=0.3,above]{\footnotesize{-1}} (31);
\draw[lifted-edge] (21) edge  node[pos=0.3,above]{\footnotesize{-1}}  (43);

\draw[lifted-edge] (23) edge node[pos=0.3,above]{\footnotesize{-1}} (31);
\draw[lifted-edge] (23) edge[bend left=30] node[pos=0.3,above]{\footnotesize{-1}} (43);

\draw[lifted-edge] (24) edge [bend right=30]node[pos=0.3,above]{\footnotesize{-1}} (42);
\draw[lifted-edge] (24) edge node[pos=0.3,above]{\footnotesize{-1}} (44);

\draw[lifted-edge] (25) edge node[pos=0.3,above]{\footnotesize{-1}} (42);
\draw[lifted-edge] (25) edge[bend left=30] node[pos=0.3,above]{\footnotesize{-1}} (44);


\end{tikzpicture} 
 \caption{Integer multicommodity flow network transformation. Transformed graph from Figure \ref{fig:mcf-reduction} for flow demands . Edges without label have cost 0.}
\label{fig:mcf-reduction2}
\end{center}
\end{figure}


\multicommodityflowreduction*
\begin{proof}
The NP-complete integer multicommodity flow problem with unit edge capacities can be reduced in polynomial time to the lifted disjoint paths problem~\eqref{eq:lifted-disjoint-paths-problem} with negative lifted edges only. The transformation is described in Lemma~\ref{lemma:multicommodity-flow-reduction}.

\end{proof}



\paragraph{3-SAT.}
The boolean satisfiability problem (SAT) is a classical NP-complete problem~\cite{cook1971complexity}. 
A transformation from its NP-complete special version 3-SAT is commonly used for proving than a problem is NP-hard or NP-complete.

\threesatreduction*

\begin{proof}

Below, we detail a transformation from 3-SAT to the lifted disjoint paths problem with positive lifted edges only. For the transformation, it holds that a 3-SAT formula consisting of  clauses has a true assignment iff .
 
 
 
Let a 3-SAT problem containing  ordered clauses  be given.
Each clause  consists of a conjunction of literals, which is either a variable  or its complement .
We construct graphs  and  as follows. 
\begin{itemize}
 \item The graph  has  layers. Every layer corresponds to one clause. Each layer contains 3 vertices labeled with the literals in the corresponding clause.
 Specifically, for a variable  in clause  we associate node , analoguously for a complemented variable  in clause  we associate node .
 \item For every pair of vertices  and  where  add an edge  to  and set .
 \item For every variable  and every pair of vertices  where  add an edge  to  and set .
 Do so analoguously for every pair of variables  and .
 \item Add an edge from  to all vertices corresponding to the first clause.
 And an edge to  from all vertices corresponding to the last clause.
\end{itemize}
An illustration of this construction can be found in Figure~\ref{fig:3sat}.
     


\begin{figure}
\begin{tikzpicture}[scale=1.3]



\node[style=vertex] (10) at (1, 0) {};

\node[style=vertex](20) at (2, 0) {};
\node[style=vertex]  (30) at (3, 0) {};
\node[style=vertex] (40)  at (4, 0) {};

\node[style=vertex] (11) at (1, 1) {};
\node[style=vertex] (21) at (2,1) {};
\node[style=vertex] (31) at (3, 1) {};
\node[style=vertex] (41) at (4, 1) {};

\node[style=vertex] (12) at (1, 2) {};
\node[style=vertex] (22) at (2, 2) {};
\node[style=vertex] (32) at (3, 2) {};
\node[style=vertex] (42) at (4, 2) {};

\node[style=vertex] (01) at (0, 1) {};
\node[style=vertex] (51) at (5, 1) {};



\draw[base-edge] (10) -- (20)node[midway,below] {\footnotesize{-1}};
\draw[base-edge] (20) -- (30)node[midway,below] {\footnotesize{-1}};
\draw [lifted-edge] (10) -- (41)node[pos=0.7,below] {\footnotesize{4}};
\draw[lifted-edge] (10) -- (31)node[midway,above] {\footnotesize{4}} ;
\draw [base-edge] (21) -- (32) node[pos=0.6,above]  {\footnotesize{-1}};
\draw [base-edge] (12) -- (21)node[near start,above]  {\footnotesize{-1}};
\draw [base-edge] (21) -- (30)node[pos=0.7,below]  {\footnotesize{-1}};
\draw[base-edge] (12) -- (22)node[midway,above]  {\footnotesize{-1}};
\draw[base-edge] (32) -- (42)node[midway,above]  {\footnotesize{-1}};
\draw [base-edge](11) -- (21)node[pos=0.2,above]  {\footnotesize{-1}};
\draw [base-edge](21) -- (31)node[pos=0.2,above]  {\footnotesize{-1}};
\draw [base-edge](31) -- (41)node[pos=0.2,above]  {\footnotesize{-1}};
\draw [base-edge](20) -- (31)node[pos=0.3,below]  {\footnotesize{-1}};
\draw [base-edge](31) -- (42)node[pos=0.6,above]  {\footnotesize{-1}};
\draw[base-edge] (30) -- (41)node[pos=0.3,below]  {\footnotesize{-1}};
\draw[base-edge] (11) -- (22)node[pos=0.6,above]  {\footnotesize{-1}};
\draw[base-edge] (11) -- (20)node[midway,above]  {\footnotesize{-1}};
\draw [base-edge](32) -- (41)node[pos=0.2,above]  {\footnotesize{-1}};
\draw[base-edge] (22) -- (31)node[pos=0.2,above]  {\footnotesize{-1}};
\draw[base-edge] (31) -- (40)node[midway,above]  {\footnotesize{-1}};
\draw [base-edge](10) -- (22)node[pos=0.9,below]  {\footnotesize{-1}};

\draw [base-edge](12) -- (20)node[pos=0.1,below]  {\footnotesize{-1}};
\draw [base-edge](22) -- (30)node[pos=0.1,below]  {\footnotesize{-1}};
\draw [base-edge](20) -- (32)node[pos=0.9,below]  {\footnotesize{-1}};
\draw [base-edge](32) -- (40)node[pos=0.1,below]  {\footnotesize{-1}};
\draw [base-edge](30) -- (42)node[pos=0.9,below]  {\footnotesize{-1}};

\draw[base-edge] (01) -- (10);
\draw[base-edge] (01) -- (11);
\draw[base-edge] (01) -- (12);

\draw [base-edge](40) --  (51) ;
\draw [base-edge] (41) -- (51);
\draw [base-edge] (42) -- (51);



\draw[lifted-edge] (12) edge [bend left=40]  node[midway,above]{\footnotesize{4}} (32);
\draw[lifted-edge] (22) edge [bend left=40] node[midway,above]{\footnotesize{4}} (42); 
\draw[lifted-edge] (12) edge [bend left=60]  node[midway,above]{\footnotesize{4}} (42);



\end{tikzpicture} 
 \label{fig:multi-com-flow-trafo}
\caption{
Reduction to lifted disjoint paths problem for 3-SAT formula
.
}
\label{fig:3sat}
\end{figure}


 Every path -paths that has cost  saturates vertices labelled by non-contradicting literals. We can obtain a 3-SAT solution from P as follows. If , set variable . If , set variable . Variables not contained as labels of vertices in  can have arbitrary values. \\
 Similarly, every solution of 3-SAT problem defines at least one path -paths that has cost .

\end{proof} \subsection{Implementation Details on the Lifted Disjoint Paths Solver}
The solver for the lifted disjoint paths problem is implemented in C++ and builds upon Gurobi 7.5.
All experiments were conducted on a machine with a 6-Core Intel 2.00GHz CPU and 128 GB RAM. 

\subsection{Optimal data association}
\label{sec:optimal_assignment_definition}
The experiment of Section \ref{sec:exp_long_range_edges} compares the assignments of our tracking system with the optimal assignments. 
We elaborate on the details to obtain the optimal assignments. 
We start with the pre-processed input detections, according to Section \ref{sec:pre_post_processing}. 
For each frame, we compute the intersection over union between the detections and ground-truth boxes of the respective frame, which forms a weighted bipartite graph. Edges with a corresponding intersection over union below  are removed. 
Then, we use Hungarian matching to find a maximum-weight matching. Unmatched detections are considered as false positives, while matched detections are assigned the corresponding ground-truth label. Thus, we obtain the trajectories on the input detections using the optimal assignment. Finally, depending on the time threshold of Table \ref{tab:tracking_performance_over_time}, trajectories are synthetically splitted at skip-edges longer than the specified threshold.



\subsection{Ablation study on post-processing methods.}
\label{sec:ablation_postprocessing}

Solving the proposed lifted disjoint paths problem establishes the assignment of input detections to object identities very close to the best possible assignment (Section \ref{sec:exp_long_range_edges}). 


To localize tracked objects also in the frames in which the object detector failed to detect them, some trackers apply an additional object detector on these frames based on the available input detections. This can be seen as performing interpolation and extrapolation, if viewed from the perspective of data association in a tracking-by-detection framework, e.g. see \cite{bergmann2019tracking}. 
As a result, improvements can be achieved from extending trajectories  to image areas without input detections by applying of a very accurate object detector.

In order to make our tracking performance comparable with other trackers, we follow this strategy and employ an inter- and extrapolation based on \cite{bergmann2019tracking}. 

During the inter- and extrapolation, output detections (coming from the lifted disjoint paths solver) are preserved.
In particular, the detections are not rejected, reshaped, neither are their labels changed by Tracktor. Instead, we apply Tracktor to recover further locations of an object 
in the frames where detections of the object were missing. The procedure is based on its trajectory obtained from the lifted disjoint paths solver.
Note that our adaption ignores additional, unassigned input detections, whereas the original implementation  \cite{bergmann2019tracking} of Tracktor fuses the detections coming from Tracktor's detector with detections provided by the dataset.

\begin{table}[hbt]
\begin{center}
\begin{tabular}{lcc}
\toprule Method & MOTA & IDF1  \\ \hline
Assignment &  &   \\
Assignment (optimal) &  &   \\
Assignment+SI &  &   \\
Assignment+ &  &   \\
Assignment+VI &  &   \\
Assignment+VI+VE &  &   \\
Assignment+VI+VE+SI &  &   \\
\bottomrule
\end{tabular}
\end{center}
\caption{Ablation study on inter- and extrapolation, evaluated on the MOT17 train set. SI = spatial interpolation only on sequences filmed from a static camera,  = spatial interpolation on all sequences, VI = visual interpolation, VE = visual extrapolation. Assignment and assignment (optimal) denote the results of the lifted disjoint paths problem and the optimal assignment, as reported in Section \ref{sec:exp_long_range_edges} given   time gap. Note that Tracktor's object detector is fine-tuned on MOT17Det. In our experiments, this resulted in bigger improvements on the MOT17 training set than on the test set, compare Table \ref{tab:mot}.
} 
\label{tab:tracking_ablation}
\end{table}

Table \ref{tab:tracking_ablation} reports the influence of employing inter- and extrapolation.
The first two rows repeat values from Table~\ref{tab:tracking_performance_over_time} given the maximal  time gap. Since our solver produces nearly optimal data assignemt with respect to the used input detections, further improvements can only be achieved by applying interpolation and extrapolation on the tracks obtained by the solver.

We compare the visual interpolation (VI) as well as visual extrapolation (VE), both using the method of \cite{bergmann2019tracking} with spatial interpolation (SI). For SI, we employ linear interpolation based solely on the geometric bounding box information. 

The interpolation SI is applied only to sequences with a fixed camera in order to guarantee robust approximations.
Still, the improvements by Assignment+SI over the baseline is evident. Especially the MOTA metric, which measures mainly the coverage of objects by detections, improves by about 10\%. We also evaluate spatial interpolation for all sequences (), which improves the tracker further to  MOTA and  IDF1. However, performing spatial interpolation on sequences with moving cameras can lead to error propagation. Thus, our final tracker Lif\_T relies on the more robust visual interpolation and employs spatial interpolation only on sequences filmed from a static camera.

On the contrary, the  visual interpolation based on \cite{bergmann2019tracking} can be applied robustly to all sequences, but only in situations where the object is visible.
Accordingly, the method Assignment+VI further improves over the baseline, as it is applied to more frames.

Recovering the position of tracked objects also outside of the time range of its computed trajectory (Assignment+VI+VE) further helps to improve the tracking accuracy, enhancing MOTA by about 20\% and IDF1 by about 10\% IDF1, as VE extends computed trajectory thereby achieving longer identity consistencies.

Finally, we employ spatial interpolation on the remaining cases where detections are missing and the objects are fully occluded (Assignment+VI+VE+SI) resulting in a slight improvement over Assignment+VI+VE.

Note that we use the method Assignment+VI+VE+SI to evaluate our tracker on the MOT15, MOT16 and MOT17 test set, as reported in Table \ref{tab:mot}. The impact of the post-processing on the training set using Tracktor seems to be very high. We conjectured this might be due to the fact that Tracktor's object detector is trained on MOT17Det (which are the detections of MOT17), leading to some degree of overfitting. Note that Tracktor is not trained the MOT17 tracking ground truth, so that it is still regarded as a meaningful validation procedure \cite{bergmann2019tracking}.
Therefore, we created another tracker Lif\_TsimInt that uses a simple interpolation, namely only linear interpolation between detections of a trajectory, for all sequences. The tracker thus corresponds to Assignment+.
Comparing Table \ref{tab:tracking_ablation} with Table \ref{tab:mot}, we see that indeed, the impact of the post-processing on the test set is significantly lower. We conclude that while the post-processing improves the tracking performance, the main performance of our tracker is due to our contributions. 


Recall that most offline tracking systems obtain trajectories by solving a data association problem, e.g.~\cite{Henschel_2018_CVPR_Workshops,tang2017multiple,ristani2018features}. Our proposed tracker is able to achieve near-optimal results with respect to the input detections. Applying interpolation and extrapolation further improves the results, and makes it conceptually comparable to Tracktor. 
Still, with post-processing on our computed data-association, we improve over Tracktor by 25\%. We argue that solving the data association accurately is important to obtain a final high-quality result after post-processing.





\subsection{Further Details on the Feature Fusion Network.}
\label{sec:fusion_network_details}
We discuss in detail the neural network which fuses the input features, thereby extending Section \ref{sec:cost_learning}. 
\paragraph{Architecture of the fusion network. } 
Considering one assignment hypothesis represented by an edge , the DeepMatching densities  as well the temporal distance  between the corresponding detections  and  serve as a confidence score for the remaining input features.  
They describe which of the input features is a reliable metric for a given assignment hypothesis, but they are not giving any information about the correctness of the assignment hypothesis. We transform the density features non-linearly and denote them together with the temporal distance as control features . The remaining features described in Section \ref{sec:cost_learning} are denoted as  .


One plausible architecture is to use a convex combination of the input features, such that the coefficients depend on the control features. To this end, let  for  denote a neural network with the control features as input and  as learnable weights. Further, let  for  be a neural network applied to -th feature of , with learnable weights . 

The input features and control features can then be fused via

{}
such that

To ensure stable training, \eqref{eqn:convex_fusion} should be applied to a sigmoid function and trained using binary cross-entropy loss. 


Nonetheless, our tracker implementation employs neural network based mainly on a combination of relu units and fully connected layers, which performed slightly better, still sharing the idea of seperating the input into  control features and input features.
The detailed architecture is depicted in Figure \ref{fig:fusion_network}.


\begin{figure}
    \centering
    \includegraphics{figures/fusion.png}
    \caption{The architecture of the edge classifier used in Lif\_T. FC- denotes a fully-connected layer with  nodes in as outputs. 
    Using a concatenation with subsequent fully connected layer,  control features and  input features are fused. }
    \label{fig:fusion_network}
\end{figure}{}


\paragraph{Training details.}
Training of the neural network is performed directly on the (preprocessed) input detections.  Labels are retrieved by assigning each detection to the best fitting ground-truth bounding box. Detections with ambiguous assignments are ignored within the training phase. 

In order to train the edge classifier, special care has to be taken as the training set is highly imbalanced. The number of edges which correspond to true negatives (pairs of detections which do not belong to the same person) clearly dominates the number of true positive edges (pairs of detections belonging to the same person). 

To address this issue, the network is trained on a randomly sampled subset of all possible edges, such that the ratio of true positive edges and true negative edges per time distance between the end nodes of the edges remains fixed.  The maximal temporal distance of an edge is set to  seconds, allowing to recover persons even after long occlusions. 

The weights of the fusion network are optimized according to the binary cross-entropy loss.
We employ stochastic gradient descent with the learning rate set to  and Nesterov momentum set to , for a total of 10 epochs. Training and inference is performed using Pytorch 1.3 on a Nvidia  RTX 2080 Ti. 

\paragraph{Accuracy of the fusion network.}
The performance of a tracking system depends highly on the accuracy of the edge classifier (and the corresponding edge weights).

Therefore, we report our evaluation of the edge classifier on all training sequences of the filtered MOT17 train set in Table \ref{tab:edge_classifier}.
Together with Table \ref{tab:mot_eval_per_sequence} and Table \ref{tab:mot}, it shows that improvements in the tracking features directly correlate to high quality tracking results thanks to the proposed solver. While Table \ref{tab:edge_classifier} shows very good performance of the edge classifier, a powerful graph model and solver is still crucial to obtain high quality tracking results. Even small errors (we observed 5\% maximal error) in the edge classifier can cause many errors in the tracking results if an unsuitable procedure is used. 
Also note that for training the edge classifier, detections with ambiguous assignment to the ground truth boxes were ignored. So, these potentially difficult cases are excluded int the evaluation of the edge classifier.
Especially the interpolation and extrapolation is prone to error propagation, once a single identity switch has been created, which heavily affects, among others,  the IDF1 score. Our lifted disjoint paths formulation can be advantageous, since lifted edges aggregate multiple edge classifiers which can correct individual wrong classifications of single edges.




\begin{table}[]
    \centering
    \resizebox{\columnwidth}{!}{
    \begin{tabular}{l  c c c c}
    \toprule
        Sequence & Acc  & Prec   & TPR  & TNR  \\ 
        \toprule
        MOT17-02-DPM &  &  &  &  \\
        MOT17-04-DPM &  &   &  &  \\
        MOT17-05-DPM &  &  &  & \\
        MOT17-09-DPM &  &  &  &  \\
        MOT17-10-DPM &  &  &  &  \\
        MOT17-11-DPM &  &  &  &  \\
        MOT17-13-DPM &  &  &  &  \\
        
        MOT17-02-SDP &  &  &  &  \\
        MOT17-04-SDP &  &  &  &  \\
        MOT17-05-SDP &  &  &  &  \\
        MOT17-09-SDP &  &  &  &  \\
        MOT17-10-SDP &  &  &  &  \\
        MOT17-11-SDP &  &  &  &  \\
        MOT17-13-SDP &  &  &  &  \\
        
        MOT17-02-FRCNN &  &  &  &  \\
        MOT17-04-FRCNN &  &  &  &  \\
        MOT17-05-FRCNN &  &  &  &  \\
        MOT17-09-FRCNN &  &  &  &  \\
        MOT17-10-FRCNN &  &  &  &  \\
        MOT17-11-FRCNN &  &  &  &  \\
        MOT17-13-FRCNN &  &  &  &  \\
        \bottomrule
    \end{tabular}}
    \caption{Performance metrics on the edge classifier. The performance is measured in terms of the accuracy (Acc), precision (Prec), true positive rate (TPR) and true negative rate (TNR). The arrows indicate that higher metric values are better.  }
    \label{tab:edge_classifier}
\end{table}



\subsection{Extended Quantitative  Results}
\label{sec:results_all_sequences}
We provide additional evaluations on our tracking system as well as on the lifted disjoint paths solver.

\paragraph{Detailed tracking evaluations.}
We provide the evaluations of the MOT15, MOT16, MOT17 test sets as well as the MOT17 train set per sequence in Table \ref{tab:mot_eval_per_sequence}. 
In addition, the table contains the solver time (STime) in seconds, needed to solve the corresponding lifted disjoint paths problem. 


\begin{table*}
\center
\tabcolsep=0.09cm

    \resizebox{1.3\columnwidth}{!}{
    \begin{tabular}{c l c c c c c c c c c}
     \toprule
     & Sequence  & MOTA  & IDF1  & MT  & ML  & FP & FN & IDS & Frag &STime \\   
     \toprule
     \parbox[t]{3mm}{\multirow{6}{*}{\rotatebox[origin=c]{90}{MOT17-Train}}}
 & MOT17-02-DPM &  &  &  &  &  &  &  &  &  \\ 
 & MOT17-04-DPM &  &  &  &  &  &  &  &  &  \\ 
 & MOT17-05-DPM &  &  &  &  &  &  &  &  &  \\ 
 & MOT17-09-DPM &  &  &  &  &  &  &  &  &  \\ 
 & MOT17-10-DPM &  &  &  &  &  &  &  &  &  \\ 
 & MOT17-11-DPM &  &  &  &  &  &  &  &  &  \\ 
 & MOT17-13-DPM &  &  &  &  &  &  &  &  &  \\ 
 & MOT17-02-FRCNN &  &  &  &  &  &  &  &  &  \\ 
 & MOT17-04-FRCNN &  &  &  &  &  &  &  &  &  \\ 
 & MOT17-05-FRCNN &  &  &  &  &  &  &  &  &  \\ 
 & MOT17-09-FRCNN &  &  &  &  &  &  &  &  &  \\ 
 & MOT17-10-FRCNN &  &  &  &  &  &  &  &  &  \\ 
 & MOT17-11-FRCNN &  &  &  &  &  &  &  &  &  \\ 
 & MOT17-13-FRCNN &  &  &  &  &  &  &  &  &  \\ 
 & MOT17-02-SDP &  &  &  &  &  &  &  &  &  \\ 
 & MOT17-04-SDP &  &  &  &  &  &  &  &  &  \\ 
 & MOT17-05-SDP &  &  &  &  &  &  &  &  &  \\ 
 & MOT17-09-SDP &  &  &  &  &  &  &  &  &  \\ 
 & MOT17-10-SDP &  &  &  &  &  &  &  &  &  \\ 
 & MOT17-11-SDP &  &  &  &  &  &  &  &  &  \\ 
 & MOT17-13-SDP &  &  &  &  &  &  &  &  &  \\ 
  & MOT17-Train &  &  &  &  &  &  &   &  &  \\ 



     \midrule
     \parbox[t]{3mm}{\multirow{6}{*}{\rotatebox[origin=c]{90}{MOT17-Test}}} &
 MOT17-01-DPM &   &&  &   &  &  &  &   &  \\ 
& MOT17-03-DPM  &   &  &  &  &  &  &  &   &  \\ 
& MOT17-06-DPM  &   &  &  &  &  &  &  &   &  \\ 
& MOT17-07-DPM  &   &  &  &  &  &  &  &   &  \\ 
& MOT17-08-DPM  &   &  &  &  &  &  &  &   &  \\ 
& MOT17-12-DPM  &   &  &  &  &  &  &  &   &  \\ 
& MOT17-14-DPM  &   &  &  &  &  &  &  &   &  \\ 
& MOT17-01-FRCNN  &   &  &  &  &  &  &  &   &  \\ 
& MOT17-03-FRCNN  &   &  &  &  &  &  &  &   &  \\ 
& MOT17-06-FRCNN  &   &  &  &  &  &  &  &   &  \\ 
& MOT17-07-FRCNN  &   &  &  &  &  &  &  &   &  \\ 
& MOT17-08-FRCNN  &   &  &  &  &  &  &  &   &  \\ 
& MOT17-12-FRCNN  &   &  &  &  &  &  &  &   &  \\ 
& MOT17-14-FRCNN  &   &  &  &  &  &  &  &   &  \\ 
& MOT17-01-SDP  &   &  &  &  &  &  &  &   &  \\ 
& MOT17-03-SDP  &   &  &  &  &  &  &  &   &  \\ 
& MOT17-06-SDP  &   &  &  &  &  &  &  &   &  \\ 
& MOT17-07-SDP  &   &  &  &  &  &  &  &   &  \\ 
& MOT17-08-SDP  &   &  &  &  &  &  &  &   &  \\ 
& MOT17-12-SDP  &   &  &  &  &  &  &  &   &  \\ 
& MOT17-14-SDP  &   &  &  &  &  &  &  &   &  \\ 

     
     \midrule
     
     \parbox[t]{3mm}{\multirow{6}{*}{\rotatebox[origin=c]{90}{MOT16}}} &
     MOT16-01 &   &&  &   &  &  & &   &  \\ 
& MOT16-03  &   &  &  &  &  &  &  &   &  \\ 
& MOT16-06  &   &  &  &  &  &  &  &   &  \\ 
& MOT16-07  &   &  &  &  &  &  &  &   &  \\ 
& MOT16-08  &   &  &  &  &  &  &  &   &  \\ 
& MOT16-12  &   &  &  &  &  &  &  &   &  \\ 
& MOT16-14  &   &  &  &  &  &  &  &   &  \\ 
     \midrule
     
     \parbox[t]{3mm}{\multirow{6}{*}{\rotatebox[origin=c]{90}{2D MOT15}}} &
     ADL-Rundle-1 &   &&  &   &  &  & &   &  \\ 
     & ADL-Rundle-3  &   &  &  &  &  &  &  &   &  \\ 
     & AVG-TownCentre  &   &  &  &  &  &  &  &   &  \\ 
     & ETH-Crossing  &   &  &  &  &  &  &  &   &  \\ 
     & ETH-Jelmoli  &   &  &  &  &  &  &  &   &  \\ 
& ETH-Linthescher  &   &  &  &  &  &  &  &   &  \\ 
& KITTI-16  &   &  &  &  &  &  &  &   &  \\ 
& KITTI-19 &   &  &  &  &  &  &  &   &  \\ 
& PETS09-S2L2  &   &  &  &  &  &  &  &   &  \\ 
& TUD-Crossing  &   &  &  &  &  &  &  &   &  \\ 
& Venice-1  &   &  &  &  &  &  &  &   &  \\ 
     \bottomrule
    \end{tabular}}

\caption{We provide the results of our tracker Lif\_T, evaluated per sequence. In addition, we provide the time necessary to solve the corresponding lifted disjoint path problem instance (STime), in seconds. 
Arrows indicate whether low or high metric values are better. Tracking results on the test sets were evaluated by the MOTChallenge server \url{https://www.motchallenge.net}}
\vspace{-0.2cm}
\label{tab:mot_eval_per_sequence}

\end{table*}



 

\end{document}
