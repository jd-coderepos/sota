\documentclass[final,copyright,creativecommons]{eptcs}
\providecommand{\event}{LSFA 2012}

\usepackage{soul}
\usepackage{wrapfig}
\usepackage{cite}
\usepackage{multicol}
\usepackage[all]{xy}
\usepackage{prooftree}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amsthm}
\usepackage{float}
\usepackage{stmaryrd}
\floatstyle{boxed}\restylefloat{figure}
\hypersetup{
  colorlinks=true,
  citecolor=blue,
  linkcolor=black,
  urlcolor=black,
  pdftitle={Non determinism through type isomorphism},
  pdfauthor={Alejandro D\'iaz-Caro and Gilles Dowek}
}

\newcommand{\OurCalculus}{\ensuremath{\lambda_+}}
\newcommand{\eq}{\ensuremath{\rightleftarrows}}
\newcommand{\re}{\ensuremath{\hookrightarrow}}
\newcommand{\subst}[2]{\ensuremath{[{#1}/{#2}]}}
\newcommand{\tf}{\mbox{\bf T\!F}}
\newcommand{\true}{\mbox{\bf T}}
\newcommand{\false}{\mbox{\bf F}}
\newcommand{\ve}[1]{\ensuremath{\mathrm{\textbf{#1}}}}
\newcommand{\cond}[1]{\ensuremath{\mbox{\small}}}

\newtheorem{theorem}{Theorem}[section]
\newtheorem{lemma}[theorem]{Lemma}

\theoremstyle{definition}
\newtheorem{example}[theorem]{Example}

\title{Non determinism through type isomorphism}
\author{Alejandro D\'iaz-Caro\thanks{This work was supported by grants from DIGITEO and R\'egion \^Ile-de-France.}
\institute{Universit\'e Paris 13, Sorbonne Paris Cit\'e, LIPN\\
Universit\'e Paris-Ouest Nanterre La D\'efense\\
INRIA}
\and Gilles Dowek
\institute{INRIA\\
23 avenue d'Italie, CS 81321,\\ 75214 Paris Cedex 13}
}

\def\titlerunning{Non determinism through type isomorphism}
\def\authorrunning{A.~D\'iaz-Caro and G.~Dowek}


\begin{document}
\maketitle

\begin{abstract}
We define an equivalence relation on propositions and a proof system
where equivalent propositions have the same proofs.  The system
obtained this way resembles several known non-deterministic and
algebraic lambda-calculi.
\end{abstract}

\section{Introduction}
Several non-deterministic extensions to the -calculus have been proposed,
e.g.~\cite{BoudolIC94,BucciarelliEhrhardManzonettoAPAL12,deLiguoroPipernoIC95,DezaniciancaglinideliguoroPipernoTCS96,DezaniciancagliniDeliguoroPipernoSIAM98,PaganiRonchidellaroccaFI10}. In these approaches, the parallel composition (sometimes called the
{\em must-convergent} parallel composition)
is such that if  and  are two -terms, the term  (also written ) represents the computation that runs either  or  non-deterministically.
It is common to consider in these approaches the associativity and commutativity of the operator . Indeed the interpretation ``either  or  runs'' shall not prioritise any of them, and so ``either  or  runs'' must be represented by the same term. Moreover,  can run either  or , which is the same expressed by . Extra equivalences (or rewrite rules, depending on the presentation) are set up to account for such an interpretation, e.g.~. This right distributivity can alternatively be seen as the one of function sum:  is defined pointwise as . This is the approach of the algebraic lambda-calculi~\cite{ArrighiDowekRTA08,VauxMSCS09}, two independently introduced algebraic extensions which resulted strongly related afterwards~\cite{AssafPerdrixDCM11,DiazcaroPerdrixTassonValironHOR10}. In these algebraic calculi, a scalar pondering each `choice' is considered in addition to the sum of terms.

Because of these equivalences between terms, it is natural to think that a typed version must allow some equivalences at the type level. Definitely, if  and  are typed with types  and  respectively, it is natural to expect that whatever connective tie these types in order to type , it must be commutative and associative.

An independent stream of research is the study of isomorphisms between types for several languages (see \cite{DiCosmo95} for a reference).
For example, we know that the propositions  and  are equiprovable: one is provable if and only if the other is, but they do not have the same proofs. If  is a proof of  and  is a proof of , then  is a proof of  while  is a proof of . Despite that both proofs can be derived from the same hypotheses, they are not the same.
In this paper, we show how the non-determinism arises naturally in a classic context only by introducing some equivalences between types. These equivalences, nevertheless, will be chosen among valid, well-known isomorphisms.
In order to consider these isomorphic types as equivalent, we need to design a proof system such that they have the same proofs, or conversely, in order to consider these terms to be equivalent, we need to make these isomorphic types to be equivalent. Formally, two types  and  are isomorphic if there are two conversion functions  of type  and  of type , such that  for any  of type  and  for any  of type .
Hence, in this system the conversion functions  and  should become and identity function. In other words, we take the quotient of the set of propositions by the relation generated by the isomorphisms of types and define proofs for elements in this quotient. In System F with products, which correspond to the propositional logic with universal quantifier, conjunction and implication, the full list of isomorphisms is known~\cite{DiCosmo95}, and it is summarised in Figure~\ref{fig:iso}.
\begin{figure}[!h]
\begin{multicols}{2}
 \begin{enumerate}
  \item\label{iso:comm} 
  \item\label{iso:asso} 
  \item\label{iso:distrib} 
  \item\label{iso:currying} 
  \item\label{iso:ordering} 
  \item 
  \item 
  \item  if 
  \item 
  \item 
 \end{enumerate}
\end{multicols}
 \caption{All the type isomorphisms in propositional logic with universal quantifier, non-idempotent conjunction and implication}
 \label{fig:iso}
\end{figure}

In this work, we consider only the three first isomorphisms of this list,
because they are those that arise naturally when studying non deterministic
processes. The impact of the others is left for future work.

\begin{wrapfigure}{r}{0.1\textwidth}\vspace{-0.7cm}

\end{wrapfigure}Usually, for the deduction rule on the right
if we call  the proof of  and  that of , we write  or  the proof of . However if  and  are {\em the same} proposition, we get  and  to be the same term. Let us write ``'' to the commutative comma\footnote{We could chose another symbol, however  is the one used in most non-deterministic settings.} and set the rule


In the same way, the associativity of  induces that of .
Furthermore, the isomorphism (\ref{iso:distrib}) of Figure~\ref{fig:iso} induces the following equivalence on proofs. If  is a proof of ,  one of , and  one of  then  is a proof of  and  is a proof of . This proof is the same as .
Summarising, from the equivalences between types we obtained a commutative and associative , which is such that the application right-distributes over it.

Several non-classical type systems have been already proposed for the non-deterministic and algebraic calculi, e.g.~\cite{ArrighiDiazcaroLMCS12,ArrighiDiazcaroValironDCM11,DiazcaroPetitWoLLIC12}. In these systems there is already an equivalence relation on propositions such that if  and  types a term, then also  types it. Such equivalence is reminiscent of type theory~\cite{CoquandHuetIC88,MartinLof84} and deduction modulo~\cite{DowekHardinKirchnerJAR03,DowekWernerJSL98}. But here we go further, introducing an equivalence relation that equates types built with different connectives such as  and , which is not possible there.
Moreover, there is no elimination rule for conjunction in~\cite{ArrighiDiazcaroLMCS12,ArrighiDiazcaroValironDCM11,DiazcaroPetitWoLLIC12}. Indeed, having commutativity and associativity properties in both, the sums of terms and the conjunctions of propositions, leads to uncertainty on how to eliminate them. A rule like
`` implies '',
would not be consistent.
If  and  are two arbitrary types,  a term of type  and  a term of type , then  has both types  and , thus  would have both type  and type .
Hence, a naive rule would lead to inconsistency. The projection would project a random term of any of the types of its arguments, so not being a trustfully valid proof for any proposition.

The approach we follow here is to consider explicitly typed terms (Church style), and hence make the projection to depend on the type:
if  then .
This way, we recover consistency of the proof system. This new form of projection entails allowing some non-determinism directly in the rewrite system. Indeed, if  and  have the same type ,
 both reduces to  and to .
A priori this does not entail any problem; any of them is a valid proof of the same proposition . This approach can be summarised by the slogan {\em ``the subject reduction property is more important than the uniqueness of results''}~\cite{DowekJiangIC11}. Therefore the projection turns the non-deterministic choice explicit.

We formalise all of the previously discussed concepts in Section~\ref{sec:calculus}, where we present the calculus \OurCalculus, and provide some examples. Section~\ref{sec:SR} The next section is devoted to prove that our system enjoys the subject reduction property. In Section~\ref{sec:prob} we discuss the relation of this setting with respect to the algebraic approach. Finally, Section~\ref{sec:conclusion} concludes the paper with suggestions for future research.

\section{The calculus}\label{sec:calculus}
\subsection{Definitions}
In this section we present the calculus \OurCalculus, an explicitly typed lambda-calculus extended with a  operator as discussed in the introduction.
We consider the following grammar of types

where the isomorphisms (\ref{iso:comm}), (\ref{iso:asso}) and (\ref{iso:distrib}) from Figure~\ref{fig:iso} are made explicit by an equivalence relation between types


The set of terms  is defined inductively by the grammar


All our variable occurrences are explicitly typed, but we usually omit the superscript indicating the type of variables when it is clear from the context. For example we write  instead of .
The {\em -conversion} and the sets  of {\em free variables of } and  of {\em free variables of } are defined as usual in the -calculus (cf.~\cite[\S2.1]{Barendregt84}). For example .
The same variable, with different types, is treated as a different variable. For example, the term  is typable in our system, and it is the constant function , since  is free in the term .
We say that a term  is {\em closed} whenever . Given two terms  and  we denote by  the term obtained by simultaneously substituting the term  for all the free occurrences of  in , subject to the usual proviso about renaming bound variables in  to avoid capture of the variables free in . Analogously  denotes the substitution of the type  for all the free occurrences of  in , and  the substitution in . For example, ,  and . Simultaneous substitutions are defined in the same way. Finally, terms and types are considered up to -conversion.

Each term of the language has a main type associated, which can be obtained from the type annotations, and other types induced by the type equivalences.
The type system for \OurCalculus\ is given in Figure~\ref{fig:typeSys}.
If , we write .  is defined by .
{\em Typing judgements} are of the form . A term  is {\em typable} if there exists a type  such that .

\begin{figure}[!ht]
\centering\vspace{0.1cm}
\hspace{0.25cm}
  \prooftree
  \justifies x^A:A
  \using{ax}
  \endprooftree
\hfill
  \cond{A\equiv B}\prooftree\ve r: A
  \justifies\ve r: B
  \using\equiv
  \endprooftree
\hfill
  \prooftree\ve r:B
  \justifies \lambda x^A.\ve r:A\Rightarrow B
  \using\Rightarrow_I
  \endprooftree
\hfill
  \prooftree\ve r:A\Rightarrow B\quad \ve s:A
  \justifies\ve r\ve s:B
  \using\Rightarrow_E
  \endprooftree\hspace{0.10cm}
\vspace{0.5cm}

\hspace{0.25cm}
  \prooftree\ve r:A\quad \ve s:B
  \justifies\ve r+\ve s:A\wedge B
  \using\wedge_I
  \endprooftree
\hfill
  \prooftree\ve r:A\wedge B
  \justifies\pi_A(\ve r):A
  \using\wedge_E
  \endprooftree
\hfill
  \cond{X\notin FV(\Gamma(\ve r))}\prooftree\ve r: A
  \justifies\Lambda X.\ve r:\forall X.A
  \using\forall_I
  \endprooftree
\hfill
  \prooftree\ve r:\forall X.A
  \justifies\ve r\{B\}:A[B/X]
  \using\forall_E
  \endprooftree\hspace{0.10cm}

\vspace{0.1cm}
  \caption{The type system for \OurCalculus}
  \label{fig:typeSys}
\end{figure}

Lemma~\ref{lem:unicity} states that the typing modulo equivalences is unique.
\begin{lemma}\label{lem:unicity}
 If  and , then .
\end{lemma}
\begin{proof}
  Without rule , the type system is syntax directed. The only rule able to modify the type of a term without changing it is .
\end{proof}

The operational semantics of the calculus is given in Figure~\ref{fig:opSem}, where there are two distinct relations between terms:  and a symmetric relation .
We write  and  for the transitive and reflexive closures of  and  respectively.
In particular, notice that  is an equivalence relation.

\begin{figure}[!h]\centering
    \emph{Symmetric relation:}\\
    \hspace{1cm},\hfill
	,\hfill
    ,\hspace{1cm}

	\hspace{1cm},\hfill
	If , then .\hspace{1cm}
\vspace{0.3cm}

	\emph{Reductions:}\\
    \hspace{1cm},\hfill
	,\hfill
    If , then .\hspace{1cm}

	\caption{Operational semantics of \OurCalculus}
	\label{fig:opSem}
\end{figure}

\subsection{Examples}
\begin{example} We have
  and so by rule ,
 , from which we can obtain .
 Let , then ,
and notice that
 .
\end{example}

\begin{example} Let . It is easy to check that , and by rule  it also has the type . Therefore,  is well typed. In addition, if  and , we have .

Notice that
,
which is coherent with such typing.
\end{example}

\begin{example}
 Let  and . Then , hence  reduces non-deterministically either to  or to . Moreover, notice that , hence in this very particular case, the non-deterministic choice does not play any role.
\end{example}

\section{Subject reduction}\label{sec:SR}
In this section we prove that the set of types assigned to a term is invariant under  and .
In other words, Theorem~\ref{thm:SR} states that if  is a proof of , any reduction fired from  will still be a proof of .

The substitution lemma below will be the key ingredient in the proof of subject reduction.
It ensures that when substituting types for type variables or terms for term variables,
in an adequate manner, the typing judgements remain valid.

\begin{lemma}[Substitution]\label{lem:substitution}~
 If  and , then . Also,
 If , then .
\end{lemma}
\begin{proof} By induction over  for the first result and over the type derivation for the second.
\end{proof}

\noindent Now we can prove the subject reduction property, ensuring that the typing is preserved during reduction.

\begin{theorem}[Subject reduction]\label{thm:SR}
 If  and , then \quad (where  is either  or ).
\end{theorem}
\begin{proof}
 By induction over the reduction relation. We give only two interesting cases.

\noindent\textbf{Rule  , with }. Let , then  and . But then  and , because clearly, the main type for  is , so , however since , we have . So, by rule , . We conclude by rule .
For the inverse direction, let . Then  and , so  and . Hence, since , by Lemma~\ref{lem:unicity}, we have  and , so , from which, we conclude . We conclude by rule .

\noindent\textbf{Rule .} Let , then  and , with . Then , with . Notice that, since , it must be  and . Then, by rule , , and so, by Lemma~\ref{lem:substitution}, , and since , by rule , we obtain .
\qedhere
\end{proof}

\section{From non-determinism to probabilities}\label{sec:prob}
In~\cite{ArrighiDowekRTA08} and \cite{VauxMSCS09} two algebraic extensions of the untyped lambda-calculus are introduced, which we call  and  respectively. In these settings, not only the  operator is present, but also a scalar pondering each choice. Hence, if  and  are two possible terms, so is the linear combination of them , with  some kind of scalars (taken from a generic ring in  or from  in ). Both these calculi identify the term  with , either with a rewrite system or an equality, and  is associative and commutative. Also, the scalars interact with the , e.g.~. By restricting the scalars to positive real numbers,
or even to natural numbers, one possible interpretation is that the scalars give the probability of following one possible path (after `normalising' the scalars, i.e.~dividing over the total amount in order to sum up to ).
In this way, the term  is twice more likely to run  than .

Indeed, in \cite[\S6]{ArrighiDiazcaroLMCS12} the type system  for  is proposed, which can decide whether a superposition is a probability distribution (i.e.~it can check that the sum of terms is up to ). Such a system includes scalars at the type level, reflecting those in the terms, so  has type  whenever  has type . This provides a powerful tool to account for the scalars within the terms, however it entails a `non-classical' extension of System F with scalars pondering the types. In such a formalism, there is no possibility to tie terms with different types: if  and  have both type , then  have type , however if the types of  and  differ, the previous term cannot be typed.
That weakness is solved in~\cite{ArrighiDiazcaroValironDCM11}, where a more powerful system is introduced, with a type system also allowing for linear combination of types, just like for terms. In both these systems, while powerful, it is hard to establish a connection with a well-known logic. That is precisely the goal of~\cite{BuirasDiazcaroJaskelioffLSFA11}, where a more `classic' system is developed, with no scalars at the type level. However it carries some costs: first, it is only meant for positive real scalars (which anyway is enough for a `probabilistic' interpretation), and more importantly, the type system gives just an approximation, an upper bound, of the scalars in the terms.

We could envisage extending \OurCalculus\ with a more thorough projection where  would output
\begin{wrapfigure}{r}{0.37\textwidth}
  \begin{center}\vspace{-0.2in}
\end{center}
\end{wrapfigure}
either , with probability , or  with probability . However, even when the scalars are not explicitly written, the probabilities are present. The following example is clarifying.

Let ,  and . Then, the reductions depicted in the diagram at right are possible. If we consider  making an equiprobable choice instead of a non-deterministic one, it is clear that  have more probability to be reached, followed by , and the less likely is .

\begin{wrapfigure}{L}{0.39\textwidth}
  \begin{center}\vspace{-0.2in}

    \end{center}
\end{wrapfigure}

Indeed, we can calculate the global probability of reaching each possibility by labelling the reductions with its local probability as shown in the diagram at left, from where just by summing up the labels reaching a term, and multiplying those in the same path, we can easily check that the term  has probability  of being reached, the term  probability  and the term  probability .
Hence, this term would be expressed with
scalars as  according to the
previously discussed interpretation.
Therefore, \OurCalculus\ could be seen as a sort of algebraic calculus, with implicit scalars taken from , typed with a standard type system. These ideas will be fully developed in a future research.

\section{Conclusions and future work}\label{sec:conclusion}
\subsection{Conclusions}
In this paper we have introduced \OurCalculus, a proof system for second order propositional logic with an associative and commutative conjunction, and implication. In this system, isomorphic propositions get the same proofs. At this first step we only consider three isomorphisms, namely commutativity and associativity of the conjunction, and distributivity of implication with respect to conjunction. We use the symbol  to put together the proofs of different propositions, so  becomes a proof of , if  is a proof of  and  a proof of . Such a symbol is commutative and associative, and application is right-distributive with respect to it, to account for the isomorphisms of propositions.

This construction entails a non-deterministic projection where if a proposition has two possible proofs, the projection of its conjunction can output any of them. For example, if  and  are two possible proofs of , then  will output either  or .

In several works (cf.~\cite[\S3.4]{ManzonettoPhDThesis} for a reference), the non-determinism is modelled by two operators. The first  is normally written , and instead of distributing over application, it actually makes the non-deterministic choice. Hence  reduces either to  or to ~\cite{deLiguoroPipernoIC95}. The second one, denoted by , does not make the choice, and therefore  reduces to ~\cite{DezaniciancagliniDeliguoroPipernoSIAM98}. One way to interpret these operators is that the first one is a non-deterministic one, while the second is the parallel composition. Another common interpretation is that  is a {\it may-convergent} non-deterministic operator, where type systems ensure that at least one branch converges, while  is a {\it must-convergent} non-deterministic operator, where both branches are meant to converge~\cite{BucciarelliEhrhardManzonettoAPAL12,DiazcaroManzonettoPaganiLFCS13}. In our setting, the  operator in \OurCalculus\ behaves like , and an extra operator () induces the non-deterministic choice.
The main point is that this construction arose naturally just by considering some of the isomorphisms between types as an equivalence relation.
In order to ensure that our system is must-convergent, we shall prove its strong normalisation, which is left for future research.

\subsection{Open questions and future research}
As mentioned in Section~\ref{sec:prob}, the calculus \OurCalculus\ has implicit scalars on it, which can convert this non-deterministic setting into a probabilistic one. The original motivation behind ~\cite{ArrighiDowekRTA08} and its {\em vectorial} type system~\cite{ArrighiDiazcaroValironDCM11} was to encode quantum computing on it. A projection depending on scalars could lead to a measurement operator in a future design---after other questions like deciding orthogonality~\cite{ValironQPL10} have been addressed in that setting. This is a promising future direction we are willing to take.

In order to follow such direction, a first step is to move to a call-by-value calculus, where  (because a non-deterministic choice yet to make, is not considered to be a value). The reason to move to call-by-value is explained with the following example. Consider for instance the term \delta applied to a sum . In call-by-name it reduces to  while in a call-by-value strategy  () the same term reduces to \delta\delta first, and then to . If seeking for a quantum interpretation, reducing \delta into  is considered as the forbidden quantum operation of ``cloning''~\cite{WoottersZurekNATURE82}, while the alternative reduction to  is seen as a ``copy'', or CNOT, a fundamental quantum operation~\cite{MonroeMeekhofKingItanoWinelandPRL95}.

In order to account for such an equivalence, , we would need an equivalence at the type level such as
,
however it is clearly false. A workaround which have been used already in the vectorial type system~\cite{ArrighiDiazcaroValironDCM11} is to use the polymorphism instead of an equivalence. If  have type , then we can specialise  to the needed argument. Indeed,
 entails both  and , which can latter be tied by a conjunction.
\medskip

Another prominent future work is to determine what is needed for the remaining isomorphisms (cf.~Figure~\ref{fig:iso}).
In a work by Garrigue and A\"it-Kaci~\cite{GarrigueAitkaciPOPL94}, the isomorphism  has been indirectly treated by combining it with currying:  (cf.~isomorphism~(\ref{iso:currying}) of Figure~\ref{fig:iso}), from which it can be deduced the isomorphism  (cf.~isomorphism~(\ref{iso:ordering}) of Figure~\ref{fig:iso}). Their proposal is the selective -calculus, a calculus including labellings to identify which argument is being used at each time. Moreover, by considering the Church encoding of pairs, isomorphism (\ref{iso:ordering}) implies isomorphism (\ref{iso:comm}) (commutativity of ). However their proposal is completely different to ours, and the non-determinism cannot be inferred from the selective -calculus.

\paragraph{Acknowledgements.} We would like to thank Fr\'ed\'eric Blanqui, Michele Pagani and Giulio Manzonetto for enlightening discussions.


\bibliographystyle{eptcs}
\bibliography{biblio}

\end{document}
