\documentclass{llncs}
\newtheorem{observation}{Observation}
\usepackage{amssymb}
\usepackage{comment}
\title{Cliquewidth and Knowledge Compilation}
\author{Igor Razgon \thanks{I would like to thank Fedor Fomin for his help in shaping
of my understanding of the structural graph parameters.}\inst{1} \and Justyna Petke \inst{2}}
\institute{
Department of Computer Science and Information Systems, \\ 
Birkbeck, University of London \email{igor@dcs.bbk.ac.uk} \and
Department of Computer Science, \\ University College London
\email{J.Petke@cs.ucl.ac.uk} 
} 
\begin{document}
\maketitle
\begin{abstract}
In this paper we study the role of cliquewidth in succinct representation of Boolean
functions. Our main statement is the following: Let  be a Boolean circuit having
cliquewidth . Then there is another circuit  computing the same function as 
having treewidth at most  and which has at most  gates where  is the number of gates of . 
In this sense, cliquewidth is not more `powerful' than
treewidth for the purpose of representation of Boolean functions. We believe this is quite 
a surprising fact because it contrasts the situation with graphs where an upper bound on the 
treewidth implies an upper bound on the cliquewidth but not vice versa.

We demonstrate the usefulness of the new theorem for knowledge compilation.
In particular, we show that a circuit  of cliquewidth  can be compiled into a Decomposable
Negation Normal Form ({\sc dnnf}) of size  and the same runtime. To the best of our knowledge, 
this is the first result on efficient knowledge compilation parameterized by cliquewidth of a 
Boolean circuit. 
\end{abstract}
\section{Introduction}
Cliquewidth is a graph parameter, probably best known for its role in the design of fixed-parameter algorithms
for graph-theoretic problems \cite{CoMaRo}. In this context the most interesting property of cliquewidth is that it
is `stronger' than treewidth in the following sense: if all graphs in some (infinite) class have treewidth bounded by some
constant , then the cliquewidth of the graphs of this class is also bounded by a constant . However, the
opposite is not true. Consider, for example, the class of all complete graphs. The treewidth of this class is unbounded
while the cliquewidth of any complete graph is . 


In this paper we essentially show that, roughly speaking, cliquewidth of a Boolean function is not
a stronger parameter than its treewidth. In particular, given a Boolean circuit , we define its cliquewidth
as the cliquewidth of the DAG of this circuit and the treewidth as the treewidth of the undirected graph 
underlying this DAG. The main theorem of this paper states that for any circuit  of cliquewidth  there is
another circuit  computing the same function whose treewidth is at most  and the number of gates is at most
 times the number of gates of . Moreover, if  is accompanied with the respective clique decomposition then
such a circuit  (and the tree decomposition of width ) can be obtained in time .
The definition of circuit treewidth is taken from \cite{OBDDTWJha} and the definition of circuit cliquewidth naturally
follows from the treewidth definition. In fact, the relationship between circuit treewidth and cliquewidth is 
put in \cite{OBDDTWJha} as an open question.

We demonstrate that the main theorem is useful for knowledge compilation, that is, compact representation of Boolean
functions that allows to efficiently answer certain queries regarding the considered function.
In particular, we show 
that any circuit  of cliquewidth  can be compiled into decomposable negation normal form
({\sc dnnf}) \cite{DarwicheJACM} of size  (where  is the number of gates)
by an algorithm taking the same runtime. To the best of our knowledge, this is the first result 
on space-efficient knowledge compilation parameterized by cliquewidth. We believe this
result is interesting because the parameterization by
cliqewidth, compared to treewidth, allows to capture a wider class of inputs including those circuits
whose underlying graphs are dense. 

This bound is obtained as an immediate corollary of the main theorem
and the  bound on the {\sc dnnf} size for the given circuit , where  is the treewidth
of . The intermediate step for the latter result is an  bound of the {\sc dnnf} 
size of the given {\sc cnf} where  and  are, respectively the number of clauses and variables
of this {\sc cnf} and  is the treewidth of its \emph{incidence} graph. All these  bounds significantly 
extend the currently existing bound   of \cite{DarwicheJACM} where  is the treewidth of 
the \emph{primal} graph of the given {\sc cnf}. For example, if the given {\sc cnf} has large clauses (and hence
a large treewidth of the primal graph) then the  bound becomes practically
infeasible while the  bound may be still feasible provided a small treewidth of the incidence
graph and a number of clauses polynomially dependent on .  
\section{Related Work}
The algorithmic power of cliquewidth stems from the meta-theorem of \cite{CoMaRo}
stating that any problem definable in Monadic Second Order Logic (MSO) can be solved in linear time for a class
of graphs of fixed cliquewidth . The cliquewidth of the given graph is NP-hard to compute \cite{CWNP}
and it is not known to be FPT. On the other hand, cliquewidth is FPT approximable by an FPT computable
parameter called \emph{rankwidth} \cite{CWDApprox,RWDCompute}. As said above, there are classes of graphs with unrestricted treewidth
and bounded cliquewidth. However, it has been shown in \cite{CWDNoBicliques} that the only reason for treewidth to be much larger
than cliquewidth is the presence of a large complete bipartite graph (biclique) in the considered graph. In fact, we prove the main theorem of this 
paper by applying a transformation that eliminates all bicliques from the DAG of the given circuit. 


{\sc dnnf}s have been introduced as a knowledge compilation formalism in \cite{DarwicheJACM}, where it has been shown
that any {\sc cnf} on  variables of treewidth  of the primary graph can be compiled into a {\sc dnnf} of size 
with the same runtime. A detailed analysis of special cases of {\sc dnnf} has been provided in \cite{DerMar}. In particular,
it has been shown that Free Binary Decision Diagrams ({\sc fbdd}) and hence Ordered Binary Decision Diagrams ({\sc obdd}) can be seen as special cases of {\sc dnnf}. 
In fact, there is a separation between {\sc dnnf} and {\sc fbdd} \cite{SepDNNFFBDD}. This additional expression power of {\sc dnnf} has 
its disadvantages: a number of queries that can be answered 
in polynomial time (polytime) for {\sc fbdd} and {\sc obdd} are NP-complete for {\sc dnnf} \cite{DerMar}. This trade-off led to investigation of subclasses
of {\sc dnnf} that, on one hand, retain the succinctness of {\sc dnnf} for {\sc cnf}s of small treewidth and, on the other hand, have an increased
set of queries that can be answered in polytime. Probably the most notable result obtained in this direction are
Sentential Decision Diagrams ({\sc sdd}) \cite{SDD} that, on one hand, can answer in polytime the equivalence query
(possibility to answer this query in polytime for {\sc obdd}s is probably the main reason why this formalism is very
popular in the area of verification) and, on the other hand, retains the same upper bound dependence on treewidth
as {\sc dnnf}. 

In fact the size of {\sc obdd} can also be efficiently parameterized by the treewidth of the initial representation of the considered function. 
Indeed, there is an {\sc obdd} of size  where  is the pathwidth of the primal graph of the given
{\sc cnf} and of size  where  is the treewidth of the graph, see e.g. \cite{VardiTWD}.
It is shown in \cite{OBDDTWJha} that similar pattern retains if we consider the pathwidth and treewidth of a circuit but in the former
case  is replaced by an exponential function of  and in the latter case,  is replaced by a double exponential function
of . 
   
\section{Preliminaries}
A \emph{labeled} graph , in addition to the usual set  of vertices and a set  of edges, contains
a component , which is a partition of . Each element of the partition class is called a \emph{label}.
A \emph{simplified clique decomposition} ({\sc scd}) is a pair  where  is a rooted tree and  is a family of labeled graphs.
Each node  of  is associated with a graph , which is defined as follows.
If  is a leaf node, then . Assume that  has two children  and  and let 
and .
Then  and .
Finally, assume that  has only one child  and let . Graph  can be obtained from  by one
of the following three operations:
\begin{itemize}
\item {\bf Adding a new vertex}. There is  such that .
\item {\bf Union of labels}. There are  such that  .
We say that  and  are \emph{children} of .
\item {\bf New adjacency}. There are  such that .
We say that  and  are \emph{adjacent}. 
\end{itemize}

The width of a node  of  is . The width of  is the largest width of a node  of .
Let  be the root of . Then we say that  is an {\sc scd} of  and of 
(the unlabeled version of . The \emph{simplified cliquewidth} ({\sc scw}) of a graph  is the smallest width among all 
{\sc scd}s of . The definition of {\sc scd} is closely related to the standard notion of clique decomposition. 
In fact {\sc scw} of a graph  is at most twice larger than the cliquewidth of . The details of comparison are postponed
to the appendix.

Clique decomposition and {\sc scd} are easily extended to the directed case.
In fact the notion of cliquewidth has been initially proposed for the directed case, as noted in  \cite{COMMA2010}. 
The only change is that the new adjacency operation adds to  all possible directed arcs from label  to
label  instead of undirected edges. In this case we say that there is an arc from  to .

We denote  by  and call it \emph{the set of labels} of .


 


A tree decomposition of a graph  is a pair  where  is a tree and the elements of  are subsets of vertices
called \emph{bags}. There is a mapping between the nodes of  and elements of . 
Let us say a vertex  of  is \emph{contained} in a node  of  if  belongs to the bag  of .
Two properties of a tree decomposition are \emph{connectedness} (all the nodes containing the given vertex
 form a subtree of ), \emph{adjacency} (each edge  is a subset of some bag), and \emph{union} (the union
of all bags is  . In this paper we consider the treewidth of a directed graph as the treewidth of the underlying undirected graph.

Boolean circuits considered in this paper are over the basis .
In such a circuit there are input gates (having only output wires) corresponding to variables and constants
 and . The output of each gate of a circuit  computes a function on the set of input variables.
We denote by  the set of all functions computed by the gates of .
The number of gates of  is denoted by .

A clique or tree decomposition of a circuit  is the respective decomposition of the 
DAG of . In our discussion, we often associate the vertices of the DAG with the respective gates.
\emph{De Morgan circuits} are a subclass of circuits where the inputs of all the {\sc not} gates are variables
(i.e. the outputs of {\sc not} gates serve as negative literals). For a gate  of , denote by 
the set of variables having a path to  in the DAG of . A circuit  has the \emph{decomposability} property
if for any two in-neighbors  and  of an {\sc and} gate , .
{\sc dnnf} is a decomposable De Morgan circuit. 
When we consider a general circuit , we assume that it does not
have constant input gates, since these gates can be propagated by removal of some gates of , which in turn
does not increase the cliquewidth nor the treewidth of the circuit. However, for convenience of reasoning, 
we may use constant input gates when we describe construction of a {\sc dnnf}. If the given circuit  is a {\sc cnf}
then its variables-clauses relation can be represented by the \emph{incidence graph}, 
a bipartite graph with parts corresponding to variables and clauses and a variable-clause
edge representing occurrence of a variable in a clause. 
\begin{comment}
A \emph{satisfying assignment} of a {\sc cnf}  is a set  of literals
such that each clause  of  contains at least one literal of . We say that {\sc cnf}s  and  are \emph{equivalent}
if they have the same set of satisfying assignments. A \emph{projection} of a set  of literals to a set  of variables is
a subset  of  consisting of all the literals whose variables belong to . A {\sc cnf}  is a projection of a {\sc cnf} 
to a set  of variables if the following two conditions are true: (i) if  is a satisfying assignment of  then the projection
of  to  is a satisfying assignment of  (ii) any satisfying assignment of  can be extended to a satisfying assignment of 
.
\end{comment}



\section{From small cliquewidth to small treewidth}
The central result of this section is the following theorem:

\begin{theorem} \label{finalwidth}
Let  be a circuit of cliquewidth  over  variables
Then there is a circuit  of treewidth at most  and 
such that . Moreover, 
given  and a clique decomposition of  of width  there is
an  algorithm constructing  and a tree decomposition of
 of width at most  having at most  bags.
\end{theorem}

The rest of this section is the proof of Theorem \ref{finalwidth}.
The main idea of the proof is to replace `parts' of the given circuit forming large
bicliques by circuits computing equivalent functions where such bicliques do not occur.
As an example consider a {\sc cnf} of  clauses ,
 and . The circuit of this graph contains a biclique of order  created by 
on one side and  on the other one. This biclique can be eliminated 
by the introduction of additional {\sc or} gate  having input  and output  so that the clauses  are transformed into , 
respectively. It is not hard to see that the new circuit computes the same function as the original 
one. This is the main idea behind the construction of circuit . The formal description
of the construction is given below.


For the purpose of construction of 
we consider a type respecting {\sc scd}  of  where each non-singleton label is one of the following:
\begin{itemize}
\item A \emph{unary} label containing input gates and negation gates.
\item An \emph{{\sc and}} label containing {\sc and} gates.
\item An \emph{{\sc or}} label containing {\sc or} gates.
\end{itemize}
 
The following lemma essentially follows from splitting each label of the given clique decomposition into
three type respecting labels. 

\begin{lemma} \label{typerespect}
Let  be the cliquewidth of  and let  be the smallest width of an {\sc scd} of 
that respects types. Then .
\end{lemma}

{\bf Proof.}
Let  be an {\sc scd} of  having width at most  (existing since
the cliquewidth is ).
In each graph  split each label into at most  subsets so that
each subset contains one type of the gates as specified above. Clearly, the resulting
number of labels is at most  times larger than the original one. The resulting
structure is not necessarily an {\sc scd}. In particular, there may
be situation when the graph associated with a node is the same as the graph associated 
with the parent node because the union operation in the parent has been reversed by
the splitting. Also, the new adjacency operation may become applied between more than
one pair of labels. However, a legal {\sc scd} is easy to recover:
the 'redundant' parent nodes can be removed (since they are unary this will no
cause problems with the structure of the binary tree) and each node with
a multiple adjacency operation can be replaced by a sequence of nodes applying these
operations one by one. 


Given a type respecting {\sc scd} , let us construct the circuit . 
In the first stage, we associate each label  with a set of gates as follows:
\begin{itemize}
\item If  is non-singleton then it is associated with an {\sc and} gate denoted by 
and an {\sc or} gate denoted by .
\item If  is non-singleton and does not contain input gates then it is associated with an additional
gate called  whose type is determined as follows: If  is an {\sc and} or {\sc or} label
then  is  an {\sc and} or {\sc or} gate, respectively. If  is a unary label then
 is a circuit (perceived as a single atomic gate) consisting of two {\sc not} gates, the output of
one of them is the input of the other. So, the input of the former and the output of the latter are,
respectively, the input and output of .
\item Each singleton label  is associated with the gate 
of . We call the gates associated with singleton labels \emph{original gates} because
they are the gates of  appearing in . For the sake of uniformity,
for each original gate  associated with label , we put .
\end{itemize}

The wires of  are described below. When we say that
there is a wire from gate  to gate , we mean that the wire is
\emph{from the output} of  \emph{to the input} of .
\begin{itemize}
\item {\bf Child-parent wires.}
Let  and  be labels of  such that
 is a child of . Then there is a wire from  to  and a wire from  to .
\item {\bf Parent-child wires.}
Let  and  be as above and assume that  does not contain input gates.
Then there is a wire from  to . That is, the direction of child-parent wires
is opposite to the direction of parent-child wires. \footnote{We would like to thank the anonymous
referee, for helping us to identify a typo in this definition that occurred in the first version of
the manuscript.}
\item {\bf Adjacency wires.} Assume that in  there is an arc from  to  (established by the new adjacency node). Then the following cases apply:
\begin{itemize}
\item If  is an {\sc and} label then put a wire from  to .
\item If  is an {\sc or} label then put a wire from  to .
\item If  is a unary label consisting of negation gates only then put a wire from
an arbitrary one of  or  to .
\end{itemize}
\end{itemize}
 
Finally, we remove  gates that have no inputs.
This removal may be iterative as removal of one gate may leave without input another one.


It is not hard to see by construction that  and  have the same input gates.
This gives us possibility to state the following theorem with proof in Section \ref{samef}.

\begin{theorem} \label{samefunctions}
 is a well formed circuit.
The output of each original gate  of   computes exactly the same function (in terms of input gates)
 as in . 
\end{theorem}

In Section \ref{twidth}, we prove that the treewidth of  is not much larger than the width of
.

\begin{theorem} \label{widths}
There is a tree decomposition of  with at most  bags having width at most , where  is the width of . 
\end{theorem}

Now we are ready to prove Theorem \ref{finalwidth}.

{\bf Proof of Theorem \ref{finalwidth}} 
Due to Theorem \ref{samefunctions}, . If we take  to be of the smallest possible
type respecting width then the treewidth of  is at most  by combination of Theorem \ref{widths} and Lemma \ref{typerespect}.

To compute the number of gates of , let  be the number of gates of , which is also the number of
singleton labels of . Since each non-singleton label has two children (i.e. in the respective
tree of labels each non-leaf node is binary), the number of non-singleton labels is at most .
By construction,  has one gate per singleton label plus at most  gates per non-singleton label,
which adds up to at most .

The technical details of the runtime derivation are postponed to the appendix.
\begin{comment}
The key aspect is the data structure used for representation of the clique decomposition 
. Instead of associating each node of  with a graph, the node is associated 
with the corresponding operation that creates the graph. 
We show that, given this representation, the desired tree decomposition can be constructed in 
 per node of . Then we show that  contains  nodes, 
immediately implying the desired  bound on the runtime.
\end{comment}


\subsection{Proof of Theorem \ref{samefunctions}} \label{samef}
We start with establishing simple combinatorial properties of  (Lemmas \ref{childparent},\ref{andconnect},
\ref{notconnect},\ref{ubconnect}). 
A \emph{path} in a circuit is a sequence of gates so that the output of every gate (except the last one) is connected by a wire to the input of its successor. 
Let us call a path a \emph{connecting} path if it contains exactly one adjacency circuit.

\begin{lemma} \label{childparent}

\begin{itemize}
\item Any path  of  starting at an original gate and not containing adjacency wires contains
child-parent wires only.
\item Any path  of  ending at an original gate and not containing adjacency wires contains
parent-child wires only. 
\end{itemize}

\end{lemma}

{\bf Proof.}
The only possible wire to leave the original gate is a child-parent wire.
Any path starting from an original gate and containing child-parent wires only 
ends up in an  or  gate.  This means that the next wire (if not an adjacency one)
can be only another child-parent wire. Thus the correctness of the lemma for all
the paths of length  implies its correctness for all such paths of length ,
confirming the first statement. 

For the second statement, we start from an original gate and go back \emph{against}
the direction of wires. The reasoning similar to the previous paragraph applies 
with the  gates of non-singleton labels replacing the  and  ones.
  

\begin{lemma} \label{andconnect}
Let  and  be gates of  such that  is an {\sc and} or
an {\sc or} 
gate. Then there is a wire from  to  in  if and only if
 has a connecting path from  to  
such that all the gates of this path except possibly  are of the same type
as .
\end{lemma}

{\bf Proof.}
We prove only the case where  is an {\sc and} gate, the other case is symmetric. 
Let  be a connecting path of  from  to  of the specified kind. Let  and  be, respectively, the tail and the head gates of the adjacency wire. Then either 
 or the suffix of  ending at  consists
of child-parent wires only according to Lemma \ref{childparent}.
It follows that  corresponds to a label containing . Analogously, we conclude that either  or the suffix of  starting at  contains only parent-child labels and hence the label corresponding to  contains . Existence of the adjacency wire from the label of  to the label of  means that the {\sc scd} introduces all wires from the 
gates in the label of  to the gates in the label of . In particular, there is a wire from  to  in . 

Conversely, assume that there is a wire from  to  in . Then there are labels  and  containing 
 and , respectively, such that  introduces an adjacency arc from  to . By construction of  there is a gate  corresponding to  and a gate  corresponding to  such that  has an adjacency wire from  to . Moreover, by the definition of a type respecting {\sc scd},  is
an {\sc and} label, hence  is an {\sc and} gate. Furthermore, by construction of 
either  or there is a path from  to  consisting of parent-child arcs only and {\sc and} gates only. Indeed, if  is not a singleton then there is a wire from  to  containing  since  is the parent of . Iterative application of this argument produces a path from  to . Since  is an {\sc and} gate, all gates in this path are 
{\sc and} gates by construction.  Thus the suffix exists. What about the prefix?
By construction, . Since  contains ,
either  or there is a path from  to  involving child-parent wires and {\sc and} gates only: just start at  and go every time to the -gate of the parent
until  has been reached. Thus we have established existence of the desired prefix.

It remains to be shown that the prefix and suffix do not intersect. However, this is impossible due to the disjointness of  and . 




\begin{lemma} \label{notconnect}
Let  and  be the gates of  such that  is a {\sc not} gate. Then  has a wire from  to  if and only if 
there is a connecting path  in  from  to  with the adjacency wire  such that  and all the intermediate vertices in the suffix of  
starting from  are -gates of unary labels containing negation gates only.
\end{lemma}

{\bf Proof.}
Let  be a connecting path of  of the specified form. Then either  or  corresponds to a label containing . In both cases this means that  has a wire from  to .

Conversely, assume that  has a wire from  to .
Then there are labels  and  containing  and  such that  sets an adjacency wire from  to . Observe that  cannot contain more than one element because in this case , a {\sc not} gate, will have two inputs. Furthermore, either  contains  only or  is a unary label containing negation gates only
(because the input gates do not have input wires). In the latter case, the desired suffix from the head of the adjacency arc to  follows by construction.  


\begin{lemma} \label{ubconnect}
Any path of  between two original gates that does not involve other original gates is a connecting path.
\end{lemma}

{\bf Proof.}
First of all, let us show that any path of  between original gates involves at least one adjacency wire. 
Indeed, by Lemma \ref{childparent}, any path leaving an original gate and not having adjacency wires has only child-parent wires.
Such wires lead only to bigger and bigger labels and cannot end up with a singleton gate.
It follows that at least one adjacency wire is needed.

Let us show that additional adjacency wires cannot occur without original gates as intermediate vertices.
Indeed, the head of the first adjacency wire is an  gate of some label . Unless  is a singleton,
the only wires leaving  are parent-child wires to the  gates of the children of . Applying this
argumentation iteratively, we observe that no other wires except parent-child wires are possible until
the path meets the  gate of a singleton label. However, this is an original gate that cannot be 
an intermediate node in our path. It follows that any path between two original gates without other original 
cannot involve  adjacency wires. Combining with the previous paragraph, it follows that any such path
involves exactly one adjacency wire, i.e. it is a connecting path.
 

Using the lemmas above, it can be shown that any cycle in  involves at least one original
gate and that this implies that  contains a cycle as well, a contradiction showing that
 is acyclic. The technical details of this derivation are provided in the lemma below. 
By construction, each wire connects output to input 
and there are no gates (except the input gates of course) having no input.
It follows that  is a well formed circuit.


\begin{lemma} \label{nocycles}
 has no cycles.
\end{lemma} 

{\bf Proof.} Observe first that if  has a cycle involving at least two original gates  and 
then we can conclude existence of such cycle in , which will supply us a desired contradiction. 
Indeed, let  be all the original gates of the cycle. Then, according to Lemma \ref{ubconnect} there is a connecting path between any two consecutive singleton gates and also between  and . Applying Lemmas \ref{andconnect}, and
\ref{notconnect} depending on the nature of the specific gates, we observe that in  there are wires from each  to  (treating ) that is,  has a cycle, a contradiction.

Furthermore, let us observe that existence of one original gate in a cycle implies existence of another one. Indeed, 
following the argumentation in the proof of Lemma \ref{ubconnect}, we observe that to arrive from a singleton gate to a singleton gate (even to itself) one has to go through an adjacency wire. However, the label on the other side of the adjacency wire is disjoint with the label of the tail side and thus when we start to descend through  gates we eventually (without closing the cycle before that since we have not arrived yet at the initial original gate!) will encounter another original gate, different from the starting one. Similar argumentation means that any -gate in a cycle imply the presence of a singleton gate eventually. This rules out adjacency and parent-child arc from a potential cycle and leaves us only with child-parent arc but they are acyclic by construction since they go from a smaller label to a larger one. 

In the rest of the discussion we implicitly assume that  is well formed without explicit reference to Lemma \ref{nocycles}.


For each gate  of  denote by  the function
computed by a subcircuit of  rooted by . We establish properties of these functions from which
Theorem \ref{samefunctions} will follow by induction. 
In the following we sometimes refer to   as the function of .

\begin{lemma} \label{notfunction}
For each {\sc not} gate  of ,  is the negation of , where  is the input
of  in .
\end{lemma}

{\bf Proof.}
According to Lemma \ref{notconnect},  has a path from 
 to  where all vertices except the first one are {\sc not} gates.
Since all of them but the last one are doubled, there is an odd number of such {\sc not} gates. Each {\sc not} gate has 
a single input, hence the function of each gate of the path (except the first one) is the negation of the function of its predecessor.
Hence these functions are, alternatively, the negation of the function of  and the function of . Since the number of 
{\sc not} gates in the path is odd, the function of  is the negation of the function of , as required. 

In order to establish a similar statement regarding {\sc and} and {\sc or} gates we need two auxiliary lemmas.

\begin{lemma} \label{childparentconnect}
For each label ,  is the conjunction of
 of all original gates  contained in . Similarly,  is the disjunction of the functions of such gates.
\end{lemma}

{\bf Proof.} 
We prove the lemma only for the  gates as for the  gates the proof is symmetric.
The proof easily goes by induction. For an original gate this is just a conjunction of a single element, namely itself, and 
this is clear by construction. For a larger label , it follows by construction that , where  and  are the children of . For  and  the
rule holds by the induction assumption. Hence,  is the conjunction of all the functions of all the original gates in the union of  and , the same as  is the conjunction of the functions of all the original gates contained in , as required.


Let us call a path of  \emph{semi-connecting} if it starts with an adjacency wire and the rest of the wires are parent-child ones.

\begin{lemma} \label{semiconnect}
Let  be an {\sc and} label. Then  is the conjunction of the functions of all gates from which there is a semi-connecting path to .
For the {\sc or} label the statement is analogous with the conjunction replaced by disjunction.
\end{lemma}

{\bf Proof.} 
We provide the proof only for the {\sc and} label, for the {\sc or} label
the proof is analogous with the corresponding replacements of {\sc and} by {\sc or} and conjunctions by disjunctions.

The proof is by induction on the decreasing size 
of labels. For the largest {\sc and} label , all the input wires are the adjacency wires. Clearly the considered function is the conjunction of the functions of the gates at the tails of these adjacency wires. It remains to see if there are no more gates to arrive at  by semi-connected paths. But any such gate, after passing through the adjacency wire must meet an ancestor of  and, by the maximality assumption,  has
no ancestors.

The same reasoning as above is valid for any label  without ancestors. If  has ancestors, then 
is the conjunction of the functions of the gates at the tails
of the adjacency wires incident to  and the function of the  gate of the parent of  . By the induction assumption, this function is in fact a conjunction of the gates at the tails of the adjacency wires incident to  plus those connected to  by semi-connected paths through the parent. Since any semi-connected path either directly hits  at the head of an adjacency wire or approaches it through the parent, the statement is proven. 



\begin{lemma} \label{andorfunction}
The function of any original {\sc and} gate  of 
is the conjunction of the functions of the singleton gates whose outputs are the inputs of  in .
The same happens for the {\sc or} gate and the disjunction. 
\end{lemma}

{\bf Proof.}
As before, we prove the statement for the {\sc and} gate, for the {\sc or} gate it is analogous with the respective substitutions. 
By construction and Lemma \ref{semiconnect}, 
is the conjunction of functions of all  gates (since there are no other ones) connected to  by semi-connected paths. 
Let us call the labels of these  gates the \emph{critical labels}. Combining this with Lemma \ref{childparentconnect}, we see that  is in fact a conjunction of the functions
of all original gates contained in the critical labels. It remains to show that
these gates are exactly the in-neighbors of  in . Let us take a particular in-neighbor .
By Lemma \ref{andconnect}, there is a connecting path from  to  and by Lemma \ref{childparentconnect},
the tail of the adjacency wire of this path is 
the  gate of a critical label, so  is in the required set. Conversely, assume that  is a gate in the required set.
Specify a critical label   belongs to. Clearly, there is a child-parent path from  to  which, together with a semi-connected path from  to , makes a connecting path. The latter means that in  there is a wire from  to  according to Lemma \ref{andconnect}, as required.



{\bf Proof of Theorem \ref{samefunctions}.}
Let us order the gates topologically and do induction on the topological order. The first gate is an input gate and the function of the input is just the corresponding variable both in  and in . Otherwise, the gate is {\sc and} or {\sc or} or {\sc not} gate. In the former two cases, according to Lemma \ref{andorfunction} the function of  in  is the conjunction (or disjunction, in case of {\sc or}) of the functions of its inputs in , the same relation as in . The theorem holds regarding the inputs by the induction assumption, hence the function of  in  is the same as in . Regarding the {\sc not} gate, the argumentation is analogous, employing Lemma \ref{notfunction}. 




\subsection{Proof of Theorem \ref{widths}} \label{twidth}
\begin{comment}
A direct construction of tree decomposition of  is quite a cumbersome task.
Indeed, the topology of  essentially involves three 'similar' structures induced by 
 and  gates and it would not look very elegant to repeat the same of reasoning for each
of these parts. We follow, in our opinion, a more elegant approach. We introduce a graph retaining
the essential structure of , quite easily show that the treewidth of  is at most 
times as the treewidth of this graph and then show tat the treewidth of this graph is at most
twice as the width of . The result immediately follows from the combination of these
two statements.
\end{comment}

Let us define the undirected graph  called the
\emph{representation graph} of  as follows. The vertices of this graph are the labels of  
and two vertices  and  are adjacent if and only if either  is a child of  (or vice versa of course) or  and  are adjacent in 
 (meaning that the new adjacency operation is applied on  and ).
We call the first type of edges \emph{child-parent} edges
and the second type \emph{adjacency} edges.


 
\begin{lemma} \label{widthf}
Let  be the treewidth of .
Then the treewidth of  is at most .
\end{lemma}

{\bf Proof (Sketch).} Observe that if we contract the gates in  of each label into a single vertex,
eliminate directions and remove multiple occurrences of edges, we obtain a graph isomorphic to .
The desired tree decompositom is obtained from the tree decomposition of  by replacing the occurrence of each vertex
of  in a bag by the gates corresponding to this vertex. Thus, there is a tree decomposition of 
with at most  elements in each bag, that is the treewidth of  is at most . 

\begin{comment}
{\bf Proof.}
Let  be an undirected graph obtained from  as follows.
For each label, replace all the associated gates by one vertex.
Vertices corresponding to different labels  and 
are adjacent if and only there is a wire between a gate corresponding to
 and a gate corresponding to . It is not hard to see that
 is isomorphic to . Indeed, consider a natural correspondence under 
which vertex  is mapped into vertex  corresponding to the same
label. It follows that  is adjacent to  if and only if  is adjacent to .
Indeed,  is adjacent to  if and only if the new adjacency operation is applied 
on the corresponding labels or these labels are in a child-parent relation.
On the other hand  and  are adjacent if and only if there is a wire between
the gates of the corresponding labels. But the wire appears due to exactly the same 
reasons as the edge between  and . So, the isomorphism has been established.

It follows that  has  tree decomposition of size  or, that each bag of this 
decomposition consists of at most  elements. In each bag replace each vertex 
of  with the at most  gates of  corresponding to the same label. It is straightforward
to see that the resulting structure is a tree decomposition of . It contains at most
 bags in each label and therefore the treewidth of  is at most .

\end{comment}

\begin{lemma} \label{widthh}
The treewidth of  is at most ,
where  is the width of . 
\end{lemma}

{\bf Proof.}
For each node  of , let  be the set of labels of the graph
associated with . Consider the structure  where
 is a family of subsets of  associating with each node
 a set  consisting of vertices of  corresponding to the 
elements of . We are going to show that  is a tree
decomposition of graph  obtained from  by removal of all child-parent
edges.


First of all, observe that for each , the subgraph  of 
consisting of all nodes containing  is a subtree of . 
Let us consider  as a rooted tree
with the root  being the same as in .
Let  and  be two nodes containing . Then one of them
is an ancestor of the other. Indeed, otherwise  and  are nodes of two disjoint
subtrees  and  whose roots  and  are children of some node .
By the definition of {\sc scd},  is disjoint with  and it is
not hard to conclude from the definition that  and 
 are disjoint. Since any label is a subset of the set of vertices of 
the graph it belongs to,  and  cannot have a common label and hence
 and  cannot have a joint node. 
Furthermore, it is not hard to observe, if  is ancestor of  and  
then  belongs to  of all nodes  in the path between  and . Of course, the same
is true regarding the node of  corresponding to .
Thus we have shown that if  and  contain  they cannot belong to different 
connected components of , confirming the connectedness of .

Next, we observe that if  and  are incident to an adjacency edge then
there is a node  containing both  and . Indeed, let  and 
be the labels corresponding to  and , respectively. Let  be the node
where the adjacency operation regarding  and  is applied. Then both 
and  belong to  and, consequently,  contains both  and .
Finally, by construction, each vertex of  is contained in some node.


To obtain the desired tree decomposition of , we are going to modify 
to acquire two properties: that the number of nodes of the resulting tree is at most 
and that each parent-child pair  is contained in some node . 
For the former just iteratively remove all nodes whose operations are new adjacency.
If the node  being removed is not the root then make the parent of  to be the parent
of the only child of  (since  has only one child the tree remains binary).
The latter property can be
established by adding at most one vertex to each bag of the resulting structure . Indeed,
for each non-singleton label , let  be the node where this label is created by the union 
operation. Then both children of  belong to the only child of .
Let  be obtained from  as follows. For each non-singleton label
, add the vertex corresponding to  to the bag of the child of . Since at most one new label
is created per node of , at most one vertex is added to each bag. It is not hard to see 
both of the modifications preserve
properties stated in the previous paragraphs and achieve the desired properties regarding the child-parent edges.
Since each bag of  contains at most  elements, we conclude that the treewidth of 
is at most . Since the number of bags is at most as the number of labels, we conclude that the number of bags
is at most  

{\bf Proof of Theorem \ref{widths}.}
Immediately follows from the combination of
Lemmas \ref{widthf} and Lemma \ref{widthh}. 
 



\section{Application to knowledge compilation}
In this section we demonstrate an application of Theorem \ref{finalwidth} to knowledge compilation
by showing existence of an algorithm compiling the given circuit  into {\sc dnnf}. Both the time
complexity of the algorithm and the space complexity of the resulting {\sc dnnf} are fixed-parameter linear
parameterized by the cliquewidth of . More precisely, the statement is the following:

\begin{theorem} \label{mainone}
Given a single-output circuit  of cliquewidth ,
there is a {\sc dnnf} of   having size .
Moreover, given a clique decomposition of  of width , there is a 
 algorithm constructing such a {\sc dnnf}.
\end{theorem}

Theorem \ref{mainone} is an immediate corollary of Theorem \ref{finalwidth} and the following one:
\begin{theorem} \label{dnnfcircuit}
Given a single-output circuit  of treewidth , there is  a {\sc dnnf} of  having size .
Moreover, such a {\sc dnnf} can be constructed by an algorithm of the same runtime that gets
as input the circuit  and a tree decomposition of  of width  having  bags.
\end{theorem}


The rest of this section is a proof of Theorem \ref{dnnfcircuit}.
Our first step is Tseitin transformation from circuit  into a {\sc cnf} .
For this purpose we assume that  does not have paths of  or more {\sc not} gates.
Depending on whether this path is of odd or even length, it can be replaced by a single
{\sc not} gate or by a wire, without treewidth increase. In this case the variables 
of  are the variables of  and the outputs of {\sc and} and {\sc or} gates of .
Under this assumption, it is not hard to see that the inputs of each gate are literals 
of . Then the output  of  is either  or  for some .
Let us call  the output literal. 

The {\sc cnf}  is a conjunction of the singleton clause containing the output literal and the 
{\sc cnf}s associated with each {\sc and} and {\sc or} gate. Let  be an {\sc and} gate with inputs 
 and output . Then the resulting {\sc cnf} is 
. 
If  is an {\sc or} gate then the resulting {\sc cnf} is 
.
We call the last clause of the {\sc cnf} of  the \emph{carrying} clause w.r.t.  and the rest 
are \emph{auxiliary} ones w.r.t.  and the corresponding input. 

To formulate the property of Tseitin transformation that we need for our transformation, let us extend
the notation. We consider sets of literals that do not contain a variable and its negation.
For a set  of literals,  is the set of variables of . 
The \emph{projection}  of  to a set  of variables is the subset  of  
obtained by the removal of variables that are not in .
Let  be a family of sets of literals over a set  of variables. Then the projection
 of  to  is .
Denote by  and  the sets of variables of  and , respectively. Let us say
that a set  of literals with  is a \emph{satisfying assignment} of  if  is
true on the truth assignment on  that assigns all the literals of  to true. For a {\sc cnf},
the definition is analogous. The well known property of Tseitin transformation is the following:

\begin{lemma} \label{tseitin}
Let  and  be the sets of satisfying assignments of  and ,
respectively. Then .
\end{lemma}

Lemma \ref{tseitin} is useful because of the following nice property of {\sc dnnf}.
\begin{lemma} \label{dnnfproj} (Theorem 9 of \cite{DarwicheJACM}).
Let  be a DNNF let  and let  be the {\sc dnnf} obtained from 
by replacing the variables of  with the  constant.
Let  and  be sets of satisfying assignments of  and , respectively.
Then . 
\end{lemma}

Thus it follows from Lemmas \ref{tseitin} and \ref{dnnfproj} that having compiled  into a {\sc dnnf} ,
a {\sc dnnf}  of  can be obtained by replacing the variables of  with the 
constant. Clearly, this does not incur any additional gates. In order to obtain a {\sc dnnf} of , we observe 
that the treewidth of the incidence graph of  is not much larger than the treewidth of .


\begin{lemma} \label{tseitindecomp}
Let  be a tree decompositoion of  of width .
There is a  time algorithm ( is the number of nodes of ) transforming
 into a tree decomposition  of the incidence graph  of 
 having width at most  and with .
\end{lemma}

{\bf Proof.}
Let  be the {\sc cnf} obtained from  by removal of all the clauses but the carrying ones and let 
be the respective incidence graph. Transform  into  as follows:
\begin{itemize}
\item Replace each occurrence of an {\sc and} or {\sc or} gate  with the respective carrying clause and the
      variable corresponding to the output of .
\item Replace each occurrence of a {\sc not} gate with the variable corresponding to the input of the gate
      (it may either be an input variable of  or the output variable of some {\sc and} or {\sc or} gate).			
\end{itemize}
Let us show that  is indeed a tree decomposition 
of  of width .

Each element of a bag of  is replaced by at most  elements, hence the size of a bag
is at most twice the maximal size of bag of , i.e. at most . Consequently the
width of  is at most . Let us verify the connectedness property.
An original variable  of  is contained in a node  of  if and only if
in   contains either  or the NOT gate  with input . By the connectedness property
both nodes of  containing  and those containing  form subtrees and by the adjacency
property, these subtrees have at least one joint vertex. It follows that their union forms a subtree of .
Each new variable  corresponding to a gate  of  is contained in exactly those nodes of 
that contain  or the negation of  in . Exactly the same argument as in the previous case
ensures connectedness regarding . Finally each carrying clause  is contained in exactly those nodes of 
that contain the corresponding gate in . So, the connectedness regarding  follows from the connectedness
property of . Thus we have established the connectedness of .
To establish the adjacency property, let  be a carrying clause corresponding to a gate  in  and 
let  be a variable occurring in . If  corresponds to the output of  then the adjacency follows by
construction because  is explicitly put in those clauses where  appears. So, assume that  corresponds to
an input of . If  is an original variable then  has a node  containing a literal of  and .
By construction, in ,  contains  and . So, assume that  is the output variable of some gate
 and let  be the corresponding carrying clause of . It follows that in  there is anode 
containing both  and . Consequently, in  the same node  contains . So, the adjacency 
property has been established and we conclude that  is indeed a tree decomposition of  of
width .

Next, we observe that for each {\sc and} or {\sc or} gate  of  and for each variable  of  corresponding to an input
of  and for variable  of  corresponding to the output of , there is a node  of 
containing both  and . Indeed, let  be the carrying clause corresponding to . By construction, whenever
 contains ,  also contains . By the adjacency property, there is at least one  containing  and .
Since this last  contains also , this is a desired clause. Pick one node with the specified property and denote
it by . Add to  a new node  with  being its only neighbor. The bag of  will contain
, and  the auxiliary clause of  corresponding to the input . Do so for all the auxiliary clauses. 
\begin{comment}
Finally, properly add a node whose bag contains the variable  of the output literal and the singleton clause containing
this literal (the neighbor of this new node should be an existing node containing ). 
Let  be the resulting structure. It is not hard to observe by construction that 
 satisfies the statement of the lemma.
\end{comment}
Finally, let  be the variable occurring in the output clause (the clause containing the 
output literal). Specify a node  containing this variable.
Add a new node  for whom  is the only neighbor and add  and the output clause to the bag of . 
Let  be the resulting structure. Clearly the connectedness is preserved and the adjacency property
is established for the clauses of  that are not included in . It follows that  is a tree
decomposition of  by construction, its width does not exceed the width of , i.e. at most
 and the additional  nodes (their number is bounded by the number of wires of  plus  for
the output clause) are leaves. The desired runtime of the transformation from  to
 clearly follows from the above description. 


It remains to show that a space-efficient {\sc dnnf} can be created parameterized by the treewidth of the incidence
graph. 

\begin{theorem} \label{dnnfcnf}
Let  be a {\sc cnf} and let  be a tree decomposition of the incidence graph of .
Then  has a {\sc dnnf} of size  where  is the width of .
Moreover, given  and  such a {\sc dnnf} can be constructed by an algorithm having the same runtime. 
\end{theorem}

The proof of Theorem \ref{dnnfcnf} is provided in Section \ref{dnnfcnfproof}.
\begin{comment}
We omit the proof of Theorem \ref{dnnfcnf} due to space constraints. It is similar to the proof of Theorem 16 of
\cite{DarwicheJACM}, essentially based on dynamic programming. The difference is that in addition to branching on 
assignments of variables of the given bag, the algorithm also needs to branch on the clauses of that bag that are not 
satisfied by the currently considered assignment of variables. Three choices need to be considered for each clause: to 
not satisfy the clause at all (this choice is needed for `coordination' with the `parent bag'), to satisfy the clause by
the variables of the left child and to satisfy the clause by the variables of the right child. These  choices increase
the base of the exponent from  to . 
\end{comment}

{\bf Proof of Theorem \ref{dnnfcircuit}.}
The construction of a {\sc dnnf} for  consists of  stages: transform  into  by the Tseitin transformation;
transform the tree decomposition of  into a tree decomposition of the incidence graph of ; obtain a {\sc dnnf}
of  as specified by Theorem \ref{dnnfcnf} and obtain a {\sc dnnf} of  as specified in Lemma \ref{dnnfproj}.
The correctness of this procedure follows from the above discussion. The time and space complexities easily follow from 
the combination of the complexities of intermediate stages. 

\begin{comment}
Apply the Tseitin transformation on  to transform it into a {\sc cnf} . 
Next, transform the tree decomposition  of  into a tree decomposition
 of  as specified in Lemma \ref{decomp}.
Further on, given  and , obtain a {\sc dnnf}  of  as specified in
Lemma \ref{dnnfcnf}. Since the number nodes of  is , and the width is at most ,  is constructed in time . Clearly, this time absorbs the runtime of the previous two transformations and hence can be considered as the runtime of the whole transformation. 
It follows from the combination of Lemmas \ref{tseitin}, \ref{tseitindecomp}, and \ref{dnnfcnf} that 
the function computed by  is the projection of the function computed by  to the set of original
variables of .  Following Theorem 9 in the paper \cite{DNNFJACM} of Darwiche, we transform  into a {\sc dnnf}
 computing the same function as  by simply replacing all wires whose inputs are literals of redundant variables
with wires having the same output but whose input is the  constant. Clearly, this operation does not affect the runtime
nor the size of the resulting {\sc dnnf}.  
\end{comment}


\subsection{Proof of Theorem \ref{dnnfcnf}} \label{dnnfcnfproof}

The proof of Theorem \ref{dnnfcnf} is based on the same idea as the proof that a CNF with the width of the primary graph
at most  has a {\sc dnnf} of size  \cite{DarwicheJACM}. The difference is that we have to take into account that
the bags of the tree decomposition contain clauses as well as variables. Let us introduce notation. Let  be the CNF whose
{\sc dnnf} we are going to construct,
 be the incidence graph of  and  be a tree decomposition of . In what follows we identify the vertices
of  with the respective variables and clauses. For each node  of , we denote the bag of  by . 
Recall that for an element  (either a variable or clause), we say 
that  \emph{contains} . 
We assume that  is a \emph{minimal} tree decomposition in the sense that removal of
any element from a bag violates a tree decomposition property. This assumption is not constraining
because such tree decomposition is easy to obtain by iterative removal of nodes from the bags until no
further removal is possible.  


We pick an arbitrary node  of  and let to be the root and in what follows
we consider  to be a rooted tree. We assume w.l.o.g. that  has at most  children. 
Indeed, otherwise, if some node  has
children  for , we introduce additional nodes  make the sequence  going from the parent to a child,  remains a child of  and for each , node  becomes the additional child.
The bags of  are made identical to the bag of . Such transformation increases the number of nodes at most twice and hence proving the theorem for such transformed tree preserves the desired asymptotic. 

We consider only sets of literals with at most one literal per variable. For a set  of literals, let 
be the set of variables whose literals occur in .
We denote by  and  the set of clauses and variables of . For a node  of  we denote by 
and  the set of clauses and variables contained in . For a subtree  of ,  and  denote
the set of clauses and variables contained in the nodes of . For a clause  and a set  of variables, we denote
by  the \emph{projection} of  to  i.e. the clause obtained by the removal from  the occurrences
of all the variables that are not in . Recall that for a set  of literals, we use  with the analogous meaning. 
For a CNF , we denote by  the CNF obtained from  by
projecting all of its clauses to . 
For a subtree  of , we denote  by .

\begin{comment}
Let  be the root of  and let  and let
 be a set of literals assigning a set of variables . We denote by
 the CNF obtained from  by removal of clauses of  and assigning the literals of  to 
(i.e. taking the residual CNF resulting from the assignment). When  or  is empty, we can use
 and  with the obvious meaning. We call  a \emph{residual} of  
(induced by  and  if the context requires mentioning it). If
 assigns all the variables contained in , we say that  is a \emph{basic residual} (BR).
Finally, we call the function  \emph{extended residual} (ER) (
means conjunction of all the literals of ) or, in case , \emph{extended basic residual} (EBR).
\end{comment}

Let us call two circuits (formulas including CNF are regarded a special cases of circuits)
equivalent if they have the same set of variables and the same set of satisfying assignments.
One way to create a formula equivalent to the given CNF is \emph{Shannon expansion}. Let 
be a CNF and let  be a variable of . Then  denotes the CNF obtained from  by removal
of all the clauses containing  and removal from of all the occurrences of  from the 
remaining clauses. It is known that  is equivalent to . Applying this 
transformation over a set  of variables works as follows. Let  be a set of literals such
that . Analogously to ,  is the CNF obtained from  by removal of all the
clauses containing the occurrences of  and removal of the occurrences of the opposite literals
from the remaining clauses. Let us call the disjunction  the
\emph{generalized Shannon expansion} of  w.r.t. . Applying the Shannon expansion inductively, it is
not hard to show that the generalized Shannon expansion of  w.r.t.  is equivalent to .

Let us extend our notation. We denote by  the set of clauses obtained from
 by removal of all the clauses of . Let  be the root of  and let  and let
 be a set of literals assigning a set of variables .
We denote  by  and call it a \emph{residual} of 
 (induced by  and  if the context requires mentioning it).
When  or  is empty, we can use  and  with the obvious meaning.
If  assigns all the variables contained in , we say that  is a \emph{basic residual} (BR).
Finally, we call the function  \emph{extended residual} (ER) (
means conjunction of all the literals of ) or, in case , \emph{extended basic residual} (EBR).

\begin{lemma} \label{localdisj}
Any residual or extended residual of  is equivalent to a disjunction of EBRs of . 
\end{lemma}
 
{\bf Proof.}
Let  be a residual of .
Let  be a disjunction over all  where  is a set
of literals of . Then  is equivalent to  because 
is a generalized Shannon expansion of  w.r.t  



\begin{lemma} \label{unnode}
Let  be a child of  and let  be the subtree rooted by .
Let  be a clause of  containing an occurrence of a variable .
Then  is contained in a node of .
\end{lemma}

{\bf Proof.}
By the adjacency property, there must be a node  of  containing both  and .
This node cannot be  by definition. This node cannot be anyone outside  because
otherwise, by the connectedness property, it will be required that  is contained in
 in contradiction to our assumption. It remains to conclude that  is a node
of . 

\begin{lemma} \label{unclause}
Let  and  be  children of  and let  and  be the
subtrees of  rooted by them. Let .
Then  contains occurrences of  and
of .
\end{lemma}

{\bf Proof.}
Assume that  does not contain occurrences of, say, .
We claim that the occurrences of  can be removed from all the nodes of 
in contradiction to the minimality of . This removal clearly does not
violate the connectedness property because the path between any two nodes outside
of  does not go through . As for adjacency property, let  be any variable
contained together with  in a node of . 
If  and  are adjacent then  and therefore,
their adjacency is witnessed by the bag of . 

Let  be a basic residual of .
Let  be the union of  and the set of clauses of  satisfied 
by . We call the set  the \emph{branching set}
of .

\begin{lemma} \label{t1t2}
Let  and  be the children of  rooting repective subtrees  and .
Then . Moreover,the set of clauses
containing occurrences of both  and 
is precisely the branching set of . 
\end{lemma}

{\bf Proof.}
By construction, . Furthermore, .
Since  assigns , it follows that\\ .

For the second statement, let  be a clause of  containing entries of both
 and . This means that there is a clause  of 
such that . According to Lemma \ref{unnode}, .
By construction, . It follows that  in particular contains
. 

Conversely, assume that  belongs to the branching set of .
It follows that there is a clause  related to  as defined above.
By the connectedness property,  that is,  is contained in .
Consequently, since , we conclude that  is not satisfied by .
It follows that  is a clause of .
According to Lemma \ref{unclause},  contains occurrences of  and
. By definition, both  and  belong to  and
hence they are preserved in . By the connectednes property,  and
, hence the opposite direction holds.    

Another method of equivalence preserving transformation is \emph{clausal expansion}. Let  be a clause
of a CNF  and  be a partition of . Then, it follows from De Morgan laws that
 is equivalent to .
We extend this to the generalized clausal expansion. Let  be a set of clauses of .
For each , define a partition . Let  be the set of all CNFs
 whose set of clauses are exactly one of  for each .
Then  is equivalent to  and called a
\emph{generalized clausal expansion} of  w.r.t. . 

\begin{lemma} \label{globaldisj}
Let  be a subtree of  with root  and assume that  has two children  and  and let 
and  be the subtrees of  rooted by  and , respectively. Then each basic residual 
of  is either  unsatisfiable or can be represented (for some ) 
as a  where 
each  is a conjunction of a residual of  and a residual of .
Moreover the number of such conjunctions of residuals that are needed to represent \emph{all} the basic residuals
 does not exceed , where  is the width of . 
\end{lemma}

{\bf Proof.}
The unsatisfiability clearly follows if  contains an empty clause.
Otherwise, according to Lemma \ref{t1t2}, all the occurrences of each clause of
 belong to . 
Let  be the set of clauses of  containing occurrences
of variables of both  and of .
For each , let  be the partition of  into literals of variables
of  and of .
Let  be the set of CNFs obtained from  by taking exactly one of  or 
for each . Let  be the clausal expansion of  w.r.t.  and .
We know that  is equivalent to . 

By construction,  is a disjunction of CNFs.
Let  be one of the disjuncts. Again by construction,  can be reprsented as the conjunction
of CNFs  whose clauses contain occurrences of  only and ,
whose clauses contain occurrences of . Let  be the subset of 
 consisting of the clauses  such that  is taken to  by the clausal
expansion and let , i.e. those clauses  of  that  is taken
to . According  to Lemma \ref{t1t2},  is nothing else than the branching set of .
It follows that for each  there is a set 
such that . Let  and let 
. Further on, let  and let .
Let  and let .
We claim that  and . We will prove only the former for the latter is symmetric.

Let  be a clause of . This means that there is a clause  of  and the clause
 of  such that  and  if  or
 otherwise. In any case .
Since  is not satisfied by , the operation  applied to any its subset is in
fact the projection to . With this in mind, we can write

According to our assumption,  is not empty. Let  be a variable occurring in .
By construction, . It follows from Lemma \ref{unnode}
that  is contained in a node of . By definition,  is not satisfied
by , and does not belong to , from whence it follows that .  
Also, by definition, if  belongs to a branching set then .
It follows that  and that  is not satisfied by .
Together with the fact that  is contained in a node of , this implies that
 is a clause of .

Conversely, let  be a clause of . Then there is a clause  of  that is contained
in some node of  such that . Then  is not satisfied by .
Indeed,  is not satisfied by  by definition of . If  is satisfied by
any element of  this means that  is contained in a node outside  and hence,
by the connectedness property,  is contained in . But then  in contradiction to the 
definition of . Taking into account that , 
is a clause of .  If  then, by definition of , 
and hence  is a clause of . If  then, according to
Lemma \ref{t1t2}, all the occurrences of  are of  or all the
occurrences of  are of . Notice that the latter case causes
contradiction. Indeed, since  does not contain empty clauses,  in particular is
not empty. Let  be a variable occurring in . By our assumption . 
In fact, by construction of , . It follows from Lemma \ref{unnode}
that  is contained in a node of . Since  is also contained in a node of , it follows from the
connectedness property that . Furthermore,  by definition
of . Consequently,  belongs to the branching set of . By Lemma \ref{t1t2},
 in contradiction to our assumption.It remains to assume that all the entries of 
belong to . In this case  is a clause of 
as required. 





Now, let us calculate the number of conjunctions  needed to represent all the EBRs of .
Each  is unambiguously determined by the set
, the partition  of  and the assignment of variables
contained in  Let  be the number of clauses and variables contained in , respectively. It follows that there
are at most  choices for , as required. 



\begin{lemma} \label{layerdnnf}
Let  be as in the statement of Lemma \ref{globaldisj} and let  be a DNNF  containing gates with outputs computing all the basic residuals of  and of .
Then a DNNF computing all the basic residuals of  can be computed by adding  new
gates, where  is the width of .
\end{lemma}

{\bf Proof.}
Each basic residual  is unambiguously defined by the set of clauses 
and  the assignment  to the variables contained in . Let  be the number of clauses
and  be the number of variables. Then the number of choices is at most .
The DNNF being constructed will have at most  {\sc or} gates whose outputs are the BRs of  
and the inputs are conjunctions of residuals of  and  as specified in
Lemma \ref{globaldisj}.  
Let  be a conjunction of a residual of  and a residual of . The number 
of such conjunctions needed to form inputs of the above {\sc or} gates is at most  according to 
Lemma \ref{globaldisj}. Each  is formed as a disjunction of EBRs of , according to Lemma 
\ref{localdisj}, contributing another  to the overall number of gates.
 
Let us calculate the number of EBRs of  we need in order to compute
all the required residuals of . For  the calculation will be analogous.
For each residual  participating in a conjunction  as above, 
 (see the construction
in the proof of Lemma \ref{globaldisj}). Let  and .
Then the number of ways to form the residual is at most . 
Applying the generalized Shannon expansion, we observe that each EBR
participating in the disjunction forming  is in the form
 where  is the set of literals of the remaining 
variables contained in . It is not hard to see that the number of possible 
is at most . It follows that the number of required EBRs is at most , each of them
formed as the conjunction of the respective BR, available as one of outputs of  and the set of at most 
literals requiring  gates for their computation. Thus we conclude that  gates will be enough for computing  
of all the required EBRs of  and .
Summing up numbers of gates considered throughout the proof, we conclude
that  additional gates will be sufficient for our purpose. 

{\bf Proof of Theorem \ref{dnnfcnf}.}
We order nodes of  so that every child appears before
its parent. By induction on this order relation, we prove that it is possible to construct
a DNNF of size  whose outputs compute all BRs of  for all the subtress
 of . To make Lemma \ref{layerdnnf} working for 
the case where a non-leaf node has only one child, we extend  so that such nodes have 
an additional child being a leaf node with the empty bag.

Let  be a subtree of  consisting of a single node being a leaf.
The only BRs of such node are constant  and  functions. Thus
the number of BRs over all leaf nodes is , so regarding these nodes the inductive claim
holds. Applying Lemma \ref{layerdnnf} inductively, for each non-singleton subtree , we observe that
in order to compute basic residuals of  requires at most  additional gates, so the claim stands
for each non-singleton subtree  as well and for  in particular. It remains to compute .
Applying the generalized Shannon expansion, we observe that  is a disjunction of at most  EBRs of
 , however the additional  gates preserve the asymptotic.  
The runtime of this construction is discussed in detail in the appendix. 
\section{Discussion}
In this paper we presented a theorem that shows that a circuit of treewidth  can be 
transformed into, roughly speaking, an equivalent circuit of treewidth  with at most  times 
more gates. A consequence of this statement is that any space-efficient knowledge compilation
parameterized by the \emph{treewidth} of the input circuit can be transformed into a space
efficient knowledge compilation parameterized  by the \emph{cliquewidth} of the input circuit.
We elaborated this consequence on the example of {\sc dnnf}. 
As a result we obtained a theoretically efficient but formidably
looking space complexity of . Therefore, the first natural question is how likely it is that this huge 
exponent base can be reduced. 
\begin{comment}
We believe there is a lot of room for improvement.
For example, the  increase of the treewidth bound compared to cliquewidth is the result of double multiplication by ,
first by a type respecting clique decomposition and then by associating each label with  gates. We believe that
the type respecting decomposition can be avoided at the price of associating each label with  gates: two {\sc and} ones
and two {\sc or} ones and thus the bound on the treewidth would be  instead .
\end{comment}

The next question for further investigation is to check if the proposed upper bound can be applied to {\sc sdd} \cite{SDD} which is more 
practical than {\sc dnnf} in the sense that it allows a larger set of queries to be efficiently handled. To answer this question
positively, it will be sufficient to extend Theorem \ref{dnnfcnf} to the case of {\sc sdd}, the `upper' levels of the reasoning will
be applied analogously to the case of {\sc dnnf}. 

It is important to note that rankwidth is a better parameter for capturing dense graphs than cliquewidth
in the sense that rankwidth of a graph does not exceed its treewidth plus one \cite{RWDvsTWD} as well as cliquewidth \cite{CWDApprox}, 
while cliquewidth can be exponentially larger than treewidth (and hence rankwidth) \cite{CorRo}.
Also, computing of rankwidth, unlike cliquewidth, is known to be FPT \cite{RWDCompute}. Therefore, it is interesting to 
investigate the relationship between rankwidth and treewidth of a Boolean function. For this purpose rankwidth has to be extended
to directed graphs \cite{DirRWD}. It is worth saying that if the question is answered negatively, i.e. that treewidth
of a circuit can be exponentially larger than its rankwidth, it would be an interesting circuit complexity result.

Finally, recall that all the upper bounds on the {\sc dnnf} size obtained in this paper are polynomial in the \emph{size} of the circuit
that can be much larger than the number of variables. On the other hand, the upper bound on the {\sc dnnf} size 
parameterized by the treewidth of the primal graph of the given {\sc cnf} is polynomial in the number of variables \cite{DarwicheJACM}. 
Can we do the same in the circuit case? 
\bibliographystyle{plain}
\bibliography{KnowComp}
\appendix
\section{Cliquewidth vs.simplified cliquewidth}
To define cliquewidth, we introduce a graph  where  is a function
from  to the set of natural numbers. 
To distinguish from the labeled graph in the {\sc scd}, we can call such graph
\emph{numerically labeled}.

We introduce the following operations on graphs.
\begin{itemize}
\item Let  be a number that   for all 
and let . The operation  adds a new vertex  to the graph 
and extends  so that the corresponding number of  is . 
\item Let  be two numbers having non-empty preimages in .
Then  adds all possible edges between vertices labeled with 
and vertices labeled with .
\item The operation  changes to  all vertices having label .
\item Let  and  be two graphs with disjoint
sets of vertices. Then the result of disjoint union  is the
graph .
\end{itemize}

A clique decomposition is a binary rooted tree  every node of which is 
associated with a numerically labeled  graph and the following rules are observed.
\begin{itemize}
\item Each leaf node is associated with a single vertex graph.
\item Let  be a node having the only child . Then  is obtained
from  by one of the first  operations in the above list.
\item If  is a binary node with children  and  then .
\end{itemize}

The width of the given clique decomposition is the smallest  such that the images
of all vertices of all graphs  are members of .
The cliquewidth of the given graph  is the smallest  such that there is a clique
decomposition  with the root  such that , i.e. the function
 may be arbitrary.


For the rest of the discussion we need to choose sutiable terminology.
First, abusing the notation, we associate the decompositions with their trees,
especally as the function  allows to obtain the graph associated with 
a particular node. Let  be a numerically labeled graph. Then  
is a labeled graph such that the elements of  are sets of vertices assigned
with the same number by . Let us call the number of images of the elements of the
numerically labeled graph  the \emph{width} of . Finally for a rooted tree  we denote by
 the root of .   

\begin{lemma} \label{widthrelation}
For any clique decomposition  there is an {\sc scd}  such that 
 and the width of  is at most twice larger
than the width of .
\end{lemma}

{\bf Proof.}
The proof is by induction on the height of . If  is a leaf with the only
node associated with a graph  then we create a single-node {\sc scd} 
associated with . Otherwise, assume that  has the only child
 ad let  be the subtree (and the respective clique decomposition)
rooted by . By the induction assumption, there is  satisfying
the statement of the lemma. If the operation associated with  is 
then  is a tree such that  has the only one child  rooting
subtree  and  is obtained from  by adding a new
vertex . If the operation associated with  is  then
 is obtained from  by the adding new edges operation
between labels  and  consisting of vertices labeled by  and ,
respectively, in . If the operation associated with  is 
then two sitations are possible. In the first situation, graph  has 
vertices labeled by  and . Let  and  be the sets of vertices of
 labeled by  and , respectively. Then  is obtained from
 by the union of labels  and . Otherwise, , that is,
we even do not add a new vertex. A direct inspection shows that the lemma holds
in all the considered cases. 

Assume now that  is a binary node and let  and  be the children of
 and let  and  be the subtrees of  rooted by  and ,
respectively. By the induction assumption, there are trees (and the respective {\sc scd}s)
 and  satisfying the conditions of the lemma. Let 
 (the union operation applies to he sets of vertices,
of edges, and of labels) and let . By definition of the involved operations,
there are ,  and one-to-one
correspondence  from  to  such that 


Let . Then , in addition to  and  contains nodes
 such that the children of  are  and  and, for for each
, the child of  is . Furthermore,  and for each 
,  is obtained from  by the union of labels  and .
Clearly, the widh of  is at most twice larger than the width of  and he width of the
rest of the additional nodes of  is smaller than the treewidth of . Finally,it is not hard
to see that . Thus the lemma holds for the considered case. 

That the {\sc scw} of a graph  is at most larger than the cliquewidth of  immediately
follows from Lemma \ref{widthrelation} 
\section{Runtime for Theorem \ref{finalwidth}}
\subsection{Data structure for clique decomposition}
The above approach to define the {\sc scd} is convenient for our reasoning, however the explicit
representation  is too time consuming as input for an algorithm. Instead, each node
of the tree can be associated with the respective operation with pointers to labels required to
perform the operation, thus requiring a constant memory per node of . 


It is not hard to see by an inductive argumentation that any two elements in  are either disjoint or one 
is a subset of the other. The labels are naturally organized into a binary tree according to the child-parent relation
with the singleton nodes being leaves. It is thus not hard to see that the number of labels ts at most .

We are going to show that the number of nodesof  is , where  i the width of .
Let  for some node  of . Then we say that  \emph{contains}
.

For each binary node , let us identify one of the subtrees rooted by a child of this node 
as the \emph{left} subtree and the other one as the \emph{right} subtree. Then define a DAG  on the
labels of  as follows. The pair  is an arc of  if one of
the following conditions hold.

\begin{itemize}
\item  is contained in the node where  is created as a result of union of
labels or adding a new vertex operation.
\item Both  ad  are contained in a binary node, so that  is contained in
the left subtree, while  is contained in the right subtree.
\end{itemize}

\begin{lemma} \label{dsize}
Labels  and  are contained in the same node of  if and only if either
 or  is an arc of . 
\end{lemma}

{\bf Proof.}
By induction on the height of the node of .
For a leaf this is obvious. Consider a non-leaf node . If this node satisfies
one of the two conditions above, we are done. Otherwise, if  is a unary node
then both  and  are contained in the only child of , so the statement
holds by the induction assumption. If none of the above happens then 
is a binary node and both  and  are contained in a node of either in the left subtree
or in the right subtree. In any case both  and  are contained in a node of a smaller
height and again the induction assumption applies. 

By definition of graph , the in-degree of each vertex is at most .
Since there are  labels, it follows that the number of arcs of 
is . It follows from Lemma \ref{dsize} that the number of pairs of
labels contained in the same node is . Consequently,the number of
new adjacency nodes is . Since the number of the rest ofthe nodes
is , we conclude that the number of nodes of  is .

\subsection{The procedure}
We are going to demonstrate an  time procedure that constructs a mixed (having both directed and undirected
edges) graph  whose nodes correspond to the labels and two labels will be connected by either directed child-parent arcs
(going from the child to the parent) or undirected adjacency arcs. The size of this graph (the number of vertices plus the number of arcs)
will be . Also, each label will be associated with a type ({\sc and}, {\sc or}, or unary).  can be straightforwardly obtained from 
by simply substituting labels with suitable gates and the arcs with suitable wires as specified by the description of , implying
the  construction time for .

Recall that for algorithmic purposes the {\sc scd} is represented as a tree whose nodes are associated with operations
with pointers to the labels. In the resulting graph the vertices will be associated with labels. Each label will be supplied
with the adjacency list specifying the parent and children and label connected by the adjacency arcs (if any).
Each label and each arc are the result of some operation. Therefore, exploring the tree in a topological
order from the leaves to the root, we will be able to reconstruct . 

We start from the empty graph. If the currently considered
operation is adding a new vertex (gate) of  then 
give the corresponding singleton label the type of this gate ({\sc and}, {\sc or}, or unary). If the operation is union of two 
labels  and  then introduce the child-parent arcs from  and  to . 
Technically this means following the pointer to the label  and adding pointers to  and 
to the adjacency list marking them as children and, similarly, adding  as the parent to the 
adjacency lists of  and . Also, the type of  is as the type of  (or of , they are the same by definition
of type respecting clique decomposition). Accordingly, the adjacency operation results in adding the adjacency arc between 
the respective labels. Notice that the binary node of the clique decomposition tree does not introduce any changes: it requires union
of two disjoint graphs but at the time of exploration of the node, the union has been already performed because all the modifications
specified above are done on the \emph{same} graph, whose nodes are the set of labels of the {\sc scd}.

It is not hard to see from the description that the above procedure takes  time per node of .
Since the number of nodes of the tree is , the desired bounds follow. 

It is not hard to observe that the graph  defined is Section \ref{twidth} is isomorphic to  except that  assigns types to
nodes and directions to edges. We will establish the tree decomposition of  as specified in the proof of lemma \ref{widthh} following
post-order exploration of  (children before the parents). The elements of bags will be represented by pointers to the corresponding labels.
The only element contained in leaf node  is the vertex corresponding to the singleton label of . Assume that  is not a leaf node.
If the operation of  is new adjacency then remove  and make the parent of  (if any) to be the parent of the only child of 
Otherwise, copy to the bag of  all the elements from the bags of the children of . Then, if the operation of  is the union of labels 
and , then replace the vertices corresponding to  and  by the vertex corresponding to . 
It only remains to replace each label by the respective gates of . This algorithm spends  time per node of . It follows 
that the overall time is . 

\section{Runtime calculation for Theorem \ref{dnnfcnf}}
The desired DNNF is constructed inductively from the leaves
to the root. First, BRs for the subtrees rooted by leaves are constructed.
Construction of BRs for a non-singleton subtree (having constructed BRs
for the immediate subtrees) is done in 2 stages. First, the required
residuals of the children are produced. Then the BRs of the considered subtree
are produced as disjunctions of conjunctions of residuals of the children as
specified in Lemma \ref{globaldisj}. Having constructed all the basic residuals,
the desired output  is constructed as a residual . 


The difficulty of this construction is
finding pointers to the in-neighbors of the gate currently constructed. 
If implemented straightforwardly, the whole array of the currently existing
gates may have been searched, making the construction runtime quadratic
is the size of the {\sc dnnf} being constructed. We propose a more sophisticated
procedure based on amortized analysis that makes the runtime asymptotically
the same as the size of the resulting {\sc dnnf}. The description of the procedure
provided below is divided into  subsections specifying the data structures,
computation of residuals of the given subtree having computed all the basic residuals
(including also computation of the root), and computation of the basic residuals. 
The final calculation of the runtime is given in the last subsection.

\subsection{Data structures}
The circuit is maintained in the form of adjacency list. Put it differently, there are records corresponding to each gate.
These records contain the gate and the pointers to the records of the other gates who are in and out-neighbors of
the corresponding gate of the considered record. The records are not located in a homogenouos array but rather grouped
around the nodes of the tree decomposition . Let us see how to do that. 

An important subset of the gates are those whose output are BRs. 
Sligtly abusing the notation, we call these gats BRs as well. 
The pointer to each BR  is conatined in the
record associated with the root of . At the time of construction of the circuit, it is important to very efficiently
find the record associated with each gate of the DNNF being constructed. For this purpose, each BR 
is associated with the elements of  and . In particular, such BRs are kept in an array, let us call it .
The sets of variables and clauses of the input CNF are linearly ordered. This linear order is naturally projected to the
set of clauses and variables contained in the root  of . Denote by  and  the set of clauses
and variables, respectively. Then the BRs  of  are put in correpondence with binary vectors indexed by .
The order of the respective coordinates is exactly as the order of the corresponding elements in the above mentioned order
of variables and clauses. Let  be a clause contained in  and let  be a vector corresponding to .
Then the coordinate of  is  if and only if , i.e.  is not removed. If  i a variable contained in 
then the coordinate of  in  is  if  and  otherwise, i.e. . The vectors , considered
as binary numbers, serve as array indices. This means that   contains the pointer to the gate whose output 
is . Consequently, given , this pointer can be obtained in  . We call  the \emph{characteristic vector}
of .

Assume that  is not the root and let  be the parent of . Then the storage of  also maintains 
an array  of pointers to the residuals  such that  and
. The vectors of  are enumerated analogously to 
but indexed by elements of  ordered according to the above
mentioned order of variables and clauses of .

\subsection{Construction of residuals given basic residuals}
It follows from Lemma \ref{localdisj} that each residual is a disjunction of EBRs. We are going to show how to construct
the circuit computing the residuals provided the gates computing the BRs have already been constructed. 
The first step is simple. We go along the array  and 
specify in the record of each corresponding gate that this gate is a disjunction. Now we are going to create
the rest of the circuit. The first step is to create a binary vector  indexed by  exactly in the
same order of coordinates as for  the  entries correspond precisely to the elements of . We also need a 
binary vector  indexed in the ame way the element equals one if and only if the corresponding element of
 is a clause. Both of these vectors can be prepared in a time polynomial in .
Since the whole time of the computation of  is exponential in , this runtime may be not taken into
account, so we do not elaborate on it anymore.  Next, we process each element of . The processing of the given
element  conists of  stages.
\begin{itemize}
\item {\bf Redundancy testing.} On that stage the algorithm tests if the given BR is needed at all for the forming
of the array . Let  be the BR of  corresponding to . Then  is redundant
if and only if . Such element exists if and only if there is a coordinate
 such that  and . Clearly,the whole testing can be done in  per vector 
just by straightforward exploration of the vectors.   
\item {\bf Construction of the corresponding EBR.}
We specify  such that . The elements of  correspond
to those coordinates  of  where . Create a new conjunction with inputs being precisely
elements of  and . This operation can be performed in  (we may safely assume that each coordinate
is accompanied with pointers to both of the variables). The output of the obtained conjunction is the EBR
. 
\item {\bf Connecting the EBR to the input of the corresponding residual.}
We create a new vector  and copy there the elements of  on coordinates  where .
Clearly,  can be created in . Then we connect the output of the conjunction created in the previous
item to the input of the residual pointedto by . This can be done in .     
\end{itemize}    

It follows from Lemma \ref{localdisj} and by construction that each gate pointed to by an element of
 is indeed a residual of  as specified. Notice also that we have not applied the reuse of
conjnctions of literals as was specified in the proof of Lemma \ref{layerdnnf}, however, it does not
increase the asymptotic space of  nor the runtime  spent to the contruction of residuals
of . In the case of root , we need to have the residual  whose
output is the function of the {\sc cnf} . This can be done according to the same scheme.
That is, we explore the array  extracting elements  and forming the dijunctions
of all .

\subsection{Construction of basic residuals}
We are now going to describe the construction of the rest of the DNNF including the gates whose outputs
are BRs, their in-neighbours and the rest of incident arcs. Let  be a subtree of  having only one
node, that is its root is a leaf of . In order to construct , we explore all the characteristic
vectors  of the basic residuals of . For the given ,  points to the  constant
if the corresponding BR is  constant and to the false constant otherwise (i.e. when the corresponding
BR is a  constant). In order to keep the complexity of this step within the desired boundary, it is
essential that the CNF would be represented in the form of adjacency matrix that allows  testing
if the given literal belongs to a particular clause. In this case, it is not hard to see that the complexity
ofthis step is . 

Assume that  contains more than one node. We assume w.l.o.g. that the root  has two children
 and  (the reasoning for one child is a restricted version of the reasoning for the case of
two children). Again, we explore all the characteristic vectors of . Let  be such vector and
let  be the corresponding BR. The first step is to see if there is 
such that  is not satisfied by any literal of . If such  is found then the respective BR is unsatisfiable
and all the algorithm has to do is to record the pointer to the  constant in .
Otherwise,  is represented as the disjunction of conjunctions of pairs of residuals of  and .
The number of such conjnctions over all the characteristic vectors is , hence it would not be difficult to
design a procedure whose runtime is proportional to  multiplied by a polynomial of . However, we want
to get rid of the polynomial factor and hence the procedure will be more tricky to enable the amortised analysis.

A standard data structure for amortised analysis is the binary counter. Consider a binary vector of  elements
and let us compute the runtime of  consecutive increments. Although the runtime of one particular increment
can be as large as  due to the carry the overall runtime is , i.e.  per increment.
In our construction, we use a refined version of binary counter which we call \emph{selective counter}.
In this counter, there are a number of \emph{fixed} digits and the increment is performed only on the digits
that are not fixed. There are a few ways how to keep information about non-fixed digits so that the next digit
can be found in . For example there may be a pointer to the rightmost non-fixed digit and each non-fixed
digit can contain a pointer to the next one and the last digit also records some bit telling the algorithm about
that.  Let  be the number of non-fixed digits. Then, it is not hard to see that  increments can
be performed in . It is important to notice that if we use decrement instead increment then we have
the same upperbound on the runtime.

Back to the DNNF construction, given , we introduce two vectors  and . The coordinates of 
correspond to . The element of  whose coordinate 
corresponds to a variable  equals  if and only if . Otherwise (i.e. if ) the element 
equals . The elements corresponding to clauses can be partitioned into the following  sets.
\begin{itemize}
\item Elements, whose coordinates correspond to clauses of , equal . 
\item Elements, whose coordinates coorespond to clauses of , are .
\item Elements, whose coordinates correspond to clauses of , are .
\end{itemize}

The structure of vector  is symmetric with the roles of  and  exchanged. The only difference is
that elements of coordinates as in the last item of the above list are . 

We treat vectors  and  as selective binary counters with  being
coordinates of non-fixed digits, the increment operation applied to  and the decrement operation applied to .
Then the algorithm proceeds as follows.
\begin{itemize}
\item We set the gate  points to as the OR-gate.
\item We create the data structure with two items whose initial value is  perceived as
      binary vectors as defined above. The only operation of this data strcture is the modification
      applying increment to the first item and decrement to the second one.
      Let  be the number of non fixed digits in the above selective vectors.
      Then this data structure can be in  possible states including  and the states obtained
      by sequences of modifications. The amortised analysis argument shows that all these states can be
      explored in  i.e. the time proportional to the number of states.
\item For each state  as above, create a conjunction whose inputs will be the gates
      pointed to by  and  and whose output is an input of the gate OR
      as in the first item of this list.       
\end{itemize} 
It follows by construction and from Lemma \ref{globaldisj} that the output of the OR gate of 
is indeed . The runtime spent to construction of  can be calculated as follows.
Checking whether the given BR is a  constant takes a polynomial time per , so the total time 
is  multiplied by a polynomial
of . The same can be said regarding creation of the data structure as in the above list. 
Exploration of the states the data structure over all the vectors  takes . This follows from
Lemma \ref{globaldisj} and from the fact that by construction, the algorithm spends  per such state.

The description of the procedure for creation of the {\sc dnnf} is now complete. Summarising, the runtime
calculations we see that it takes  time per node of the tree decomposition.
\end{document}
