\pdfoutput=1
\documentclass[11pt]{myclass}


\usepackage{epsfig}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{euscript}


\newcommand{\eps}{\varepsilon}

\renewcommand{\i}[1]{\ensuremath{\mathit{#1}}}
\renewcommand{\c}[1]{\ensuremath{\EuScript{#1}}}
\renewcommand{\b}[1]{\ensuremath{\mathbb{#1}}}
\newcommand{\B}[1]{\ensuremath{\textbf{#1}}}
\newcommand{\EuD}{\ensuremath{\EuScript{D}}}
\newcommand{\EuA}{\ensuremath{\EuScript{A}}}
\newcommand{\EuI}{\ensuremath{\EuScript{I}}}
\newcommand{\EuR}{\ensuremath{\EuScript{R}}}
\newcommand{\EuP}{\ensuremath{\EuScript{P}}}
\newcommand{\EuZ}{\ensuremath{\EuScript{Z}}}
\newcommand{\EuM}{\ensuremath{\EuScript{M}}}
\newcommand{\EuC}{\ensuremath{\EuScript{C}}}
\newcommand{\EuS}{\ensuremath{\EuScript{S}}}
\newcommand{\EuQ}{\ensuremath{\EuScript{Q}}}
\newcommand{\tight}{\textrm{tight }}
\newcommand{\tc}{\textrm{unit-disk curve}}
\newcommand{\tcs}{\textrm{unit-disk curves}}
\newcommand{\tp}{\textrm{unit-disk polygon}}
\usepackage[section]{algorithm}
\usepackage{algorithmic}
\usepackage{graphics}
\usepackage{graphicx}


\title{An Efficient Algorithm for 2D Euclidean 2-Center with Outliers\thanks{This work is supported by NSF under grants CNS-05-40347, CFF-06-35000, and DEB-04-25465, by ARO grants W911NF-04-1-0278 and W911NF-07-1-0376, by an NIH grant 1P50-GM-08183-01, by a DOE grant OEGP200A070505, and by a grant from the U.S. Israel Binational Science Foundation.}}
\author{Pankaj K. Agarwal
\thanks{Department of Computer Science, Duke University, Durham, NC 27708: \texttt{pankaj@cs.duke.edu}} 
\and Jeff M. Phillips
\thanks{Department of Computer Science, Duke University, Durham, NC 27708: \texttt{jeffp@cs.duke.edu}}
}






\begin{document}
\maketitle

\begin{abstract}
For a set  of  points in , the Euclidean -center problem computes a pair of congruent disks of the minimal radius that cover .  We extend this to the -center problem where we compute the minimal radius pair of congruent disks to cover  points of .  
We present a randomized algorithm with  expected running time for the -center problem.  
We also study the -center problem in  under the -metric for . 
We propose an  algorithm for computing a  -center and an  algorithm for computing a  -center. 
\end{abstract}

\section{Introduction}
Let  be a set of  points in .  For a pair of integers  and , a family of  congruent disks is called a \emph{-center} if the disks cover at least  points of ; -center is the standard -center.  The Euclidean -center problems asks for computing a -center of  of the smallest radius.  In this paper we study the -center problem.
We also study the -center problem under the -metric for small values of  and .  Here we wish to cover all but  points of  by  congruent axis-aligned squares of the smallest side length.  Our goal is to develop algorithms whose running time is .


\paragraph{\textbf{\emph{Related work.}}}
There has been extensive work on the -center problem in algorithms and operations research communities~\cite{AS98,DH02,Hoch95,CKMN01}.  
If  is part of the input, the problem is NP-hard~\cite{MS84} even for the Euclidean case in .  The Euclidean -center problem is known to be LP-type~\cite{MSW96}, and therefore can be solved in linear time for any fixed dimension.  
The Euclidean -center problem is not LP-type.  Agarwal and Sharir~\cite{AS94} proposed an  time algorithm for the 2-center problem.  The running time was improved to  by Sharir~\cite{Sha97}.  The exponent of the  factor was subsequently improved in \cite{Epp97,Chan99}.  The best known deterministic algorithm takes  time in the worst case, and the best known randomized algorithm takes  expected time.  




There is little work on the -center problem.
Using a framework described by Matou\v{s}ek~\cite{Mat95}, LP-type problems, with  violations and basis size , can be solved in  time, for any .  This is improved by Chan~\cite{Cha05} to  expected time, where  is a slow-growing inverse-Ackermann-like function and .  
The -center problem is LP-type with basis size , so these bounds apply.  
Matou\v{s}ek~\cite{Mat95} also gives a more general results for LP-type problems with  violations and with basis size  that runs in  time, if it is a feasible case where a solution with no violations exists.  In the infeasible case, no solution exists without violations and the algorithm runs in  time.  In fact, he shows in the feasible (resp. infeasible) case that there are  (resp. ) basis with at most  violations and his algorithm visits all of them by a path of length  (resp. ) where consecutive basis in the path differ by inserting or deleting one constraint.  


The -center problem under -metric is dramatically simpler.  
Sharir and Welzl~\cite{SW96} show how to compute the  -center in near-linear time for .  In fact, they show that the rectilinear - and -center problems are LP-type problems and can be solved in  time.  Also, they show the 1-dimensional version of the problem is an LP-type problem for any , with combinatorial dimension .  Thus applying Matou\v{s}ek's framework \cite{Mat95}, the  -center in  for , can be found in  time and in , for any , if the points lie in .  



\paragraph{\textbf{\emph{Our results.}}}
Our main result is a randomized algorithm for the Euclidean -center problem in  whose expected running time is .  
We follow the general framework of Sharir and subsequent improvements by Eppstein.  
We first prove, in Section 2, a few  structural properties of levels in an arrangement of unit disks, which are of independent interest.  

As in \cite{Sha97,Epp97}, our solution breaks the -center problem into two cases depending on the distance between the centers of the optimal disks; 
(i) the centers are further apart than the optimal radius, and 
(ii) they are closer than their radius.  The first subproblem, which we refer to as the \emph{well-separated case} and describe in Section 3, takes  time in the worst case and uses parametric search~\cite{Meg83}.  The second subproblem, which we refer to as the \emph{nearly concentric case} and describe in Section 4, takes  expected time.  Thus we solve the -center problem in  expected time.  
We can solve the nearly concentric case and hence the -center problem in  deterministic time, for any .  
We present near-linear algorithms for the  -center in  for .  The  -center problem takes  time, and the  -center problem takes  time.  
We have not made any attempt to minimize the exponent of .  We believe that it can be improved by a more careful analysis.  




\section{Arrangement of Unit Disks}
\label{sec:arrangementD}
Let  be a set of  unit disks in .  Let  be the arrangement of .\footnote{The \emph{arrangement} of  is the planar decomposition induced by ; its vertices are the intersection points of boundaries of two disks, its edges are the maximal portions of disk boundaries that do not contain a vertex, and its faces are the maximal connected regions of the plane that do not intersect the boundary of any disk.}   consists of  vertices, edges, and faces.  For a subset , let  denote the intersection of disks in .  Each disk in  contributes at most one edge in .  We refer to  as a \emph{unit-disk polygon} and a connected portion of  as a \emph{unit-disk curve}.  
We introduce the notion of a level in , prove a few structural properties of levels, and describe a procedure that will be useful for our overall algorithm.  

\paragraph{\textbf{\emph{Levels and their structural properties.}}}
For a point , the \emph{level} of  with respect to , denoted by , is the number of disks in  that \emph{do not} contain .  (Our definition of level is different from the more common definition in which it is defined as the number of disks whose interiors contain .)  All points lying on an edge or face  of  have the same level, which we denote by .  For , let  (resp. ) denote the set of points in  whose level is  (resp. at most ); see Figure \ref{fig:arrD}.  By definition, .  

The boundary of  is composed of the edges of .  
Let , for , be a vertex of .  We call  \emph{convex} (resp. \emph{concave}) if  lies in  (resp. ) in a sufficiently small neighborhood of ; see Figure \ref{fig:arrD}(a).   is composed of convex vertices.
We define the complexity of  to be the number of edges of  whose levels are at most .  Since the complexity of  is , the following lemma follows from the result by Clarkson and Shor~\cite{CS89} (see also Sharir~\cite{Sha91} and Chan~\cite{Cha07}).  

\begin{figure}
  \centering
  \includegraphics{arrD.pdf}
\caption{\label{fig:arrD} 
\small (a) ; shaded region is ; filled (resp. hollow) vertices are convex (resp. concave) vertices of ; covering of  edges by six unit-disk curves.  
(b) ; shaded region is ; and the covering of  edges by two concave chains.
(c) ; shaded region is ; and the covering of  edges by two convex chains.}
\end{figure}

\begin{lemma} \emph{\cite{CS89}} For , the complexity of  is .  
\label{lem:CS-nk}
\end{lemma}



\begin{remark}
The argument by Clarkson and Shor can also be used to prove that  has  connected components and that it has  local minima in -direction.  See also \cite{Cla93,Mat95}.  These bounds are tight in the worst case; see Figure \ref{fig:lb-k2}.
\end{remark}

\vspace{.1in}
It is well known that the edges in the -level of a line arrangement can be covered by  concave chains~\cite{Gus79}, as used in \cite{Dey98,Cha05}.  We prove a similar result for ; it can be covered by  unit-disk curves.  

For a disk , let  (resp. ) denote the set of points that lie in or below (resp. above) ;  consists of the upper semicircle of  plus two vertical downward rays emanating from the left and right endpoints of the semicircle --- we refer to these rays as left and right rays.  The curve  has a similar structure.  See Figures \ref{fig:arrD}(b) and (c).  Set  and .  Assuming that the -coordinates of the centers of all disks in  are distinct, each pair of curves  intersect in at most one point.  (If we assume that the left and right rays are not vertical but have very large positive and negative slopes, respectively, then each pair of boundary curves intersects in exactly one point.)  We define the level of a point with respect to , , or  in the same way as with respect to .  A point lies in a disk  if and only if it lies in both  and , so we obtain the following inequalities:



We cover the edges of  by  concave chains as follows.  The level of the st rightmost left ray is at most  at .  Let  be such a ray, belonging to .  We trace , beginning from the point at  on , as long as  remains in .  We stop when we have reached a vertex  at which it leaves ;  is a convex vertex on .  Suppose .  Then  follows  immediately to the right of , so we switch to  and repeat the same process.  It can be checked that we finally reach  on a right ray.  Since we always switch the curve on a convex vertex, the chain  we trace is a concave chain composed of a left ray, followed by a unit-disk curve , and then followed by a right ray.  Let  be the  chains traversed by this procedure.  These chains cover all edges of , and each edge lies exactly on one chain.  Similarly we cover the edges of  by  convex curves .  Let  be the family of unit-disk curves induced by these convex and concave chains.  By (\ref{eq:gam-leq-D}),  covers all edges of .  
Since a unit circle intersects a unit-disk curve in at most two points, we conclude the following.

\begin{lemma}
The edges of  can be covered by at most  unit-disk curves, and a unit circle intersects  edges of .  
\label{lem:k-udc}
\end{lemma}


The curves in  may contain edges of  whose levels are greater that .  If we wish to find a family of unit-disk curves whose union is the set of edges in , we proceed as follows.  
We add the -extremal points of each disk as vertices of , so each edge is now -monotone and lies in a lower or an upper semicircle.  By (\ref{eq:gam-leq-D}), only  such vertices lie in .  
We call a vertex of  \emph{extremal} if it is an -extremal point on a disk or an intersection point of a lower and an upper semicircle.  An extremal vertex of the latter type is an intersection point of .  Since each such pair intersects in at most two points, there are  extremal vertices.  
For each extremal vertex  we do the following.  If there is an edge  of  lying to the right of , we follow the arc containing  until we reach an extremal vertex or we leave .  In the former case we stop.  In the latter 
case we are at a convex vertex  of , and we switch to the other arc incident on  and continue.  These curves have been drawn in Figure \ref{fig:arrD}(a).  This procedure returns an -monotone unit-disk curve that lies in .  It can be shown that this procedure covers all edges of .  
If  is represented as a planar graph, we can compute these curves in time proportional to the number of edges in .  
We thus obtain the following:

\begin{lemma}
Let  be a set of  unit disks in .  Given , we can compute, in time , a family of  -monotone unit-disk curves whose union is the set of edges of .  
\label{lem:udcs-k2}
\end{lemma}


\begin{figure}
  \centering 
  \includegraphics[width=.3\linewidth]{lowerboundk2-full.pdf}
  \hspace{.5in}
  \includegraphics[width=.3\linewidth]{lowerboundk2.pdf}
\caption{\label{fig:lb-k2} 
Lower bound.   (shaded region) has  connected components.  The right image is zoomed in of the center of the left image.}
\end{figure}

\begin{remark}
Since  can consist of  connected components, the  bound is tight in the worst case; see Figure \ref{fig:lb-k2}.
\end{remark}


\paragraph{\textbf{\emph{Dynamic Data Structures.}}} 
We need a dynamic data structure for storing a set  of unit disks that supports the following two operations:
\begin{itemize}
\item{(O1)} Insert a disk into  or delete a disk from ;
\item{(O2)} For a given , determine whether .
\end{itemize}

Hershberger and Suri~\cite{HS91}, describe how to maintain  under insertion/deletion in  time per update and how to find the point in  with the smallest -coordinate in  time.
We use this in conjunction with Matou\v{s}ek's algorithm~\cite{Mat95} for visiting all basis of an LP-type problem with at most  violations.   Specifically we examine the LP-type problem of finding the smallest -coordinate of  with  violations, which has a basis size of  and may be infeasible.  Thus the path to visit all basis is of length  and using Hershberger and Suri's data structure we traverse each step of the path in  time by inserting or deleting a constraint and finding the discs defining the minimal -coordinate.  

\begin{lemma}
There exists a dynamic data structure for storing a set of  unit disks so that \emph{(O1)} can be performed in  time, and \emph{(O2)} takes  time.  
\label{lem:dynD}
\end{lemma}


Agarwal and Matou\v{s}ek~\cite{AM95} provide a data structure that can maintain the value of the radius of the smallest enclosing disk under insertions and deletions in  time per update, for any .  
We combine this with Matou\v{s}ek's algorithm for LP-type problems, specifically for the -center problem.  Similar to the above data structure, the algorithm determines a path of length  to traverse all basis with at most  violations, and each is traversed in  time by handling an insertion or deletion using Agarwal and Matou\v{s}ek's data structure.  

\begin{lemma}
The exists a dynamic data structure for a set of  points such that under insertion/deletion of a point, it can return the answer to the -center problem in , for any .  
\label{lem:dynC}
\end{lemma}

\section{Well-Separated Disks}
In this section we describe an algorithm for the case in which the two disks ,  of the optimal solution are well separated.  That is, let  and  be the centers of  and , and let  be their radius.  Then ; see Figure \ref{fig:well-sep}.  Without loss of generality, let us assume that  lies to the left of .
Let  be the semidisk lying to the left of the line passing through  in direction normal to .  
A line  is called a separator line if  and  separates  from , or  and  separates  from the intersection points .  
We first show that we can quickly compute a set of  lines that contains a separator line.  Next, we describe a decision algorithm, and then we describe the algorithm for computing  and  provided they are well separated.  

\paragraph{\textbf{\emph{Computing separator lines.}}}
We fix a sufficiently large constant  and choose a set  of directions, where .  

\begin{figure}
  \centering
  \includegraphics{well-sep.pdf}
\caption{\label{fig:well-sep} 
Let  is a separator line for disks  and .
}
\end{figure}




For a point  and a direction , let  be the projection of  in the direction normal to .  Let  be the sorted sequence of projections of points in the direction normal to .  For each pair  such that , we choose the interval  and we place  equidistant points in this interval.  See Figure \ref{fig:well-sep}(a).  Let  be the set of (oriented) lines in the direction normal to  and passing though these points.  Set 


The set  can be computed in  time.
We claim that  contains at least one separator line.  
Let  be the direction closest to .  Suppose  and  are the first and the last points of  in the direction  that lie inside .  Since , .  
Let  be the extreme point of  in direction  and let  be the extreme point of  in direction .
Since  is within a small constant angle of   
where  is a constant depending on .  Hence if at least  points are chosen in the interval , then one of the lines in  is a separator line.  We conclude the following.

\begin{lemma}
We can compute in  time a set  of  lines that contains a separator line.
\label{lem:separator-k2}
\end{lemma}

Let  be a -center of , let  be a line, and let  be the set of points that lie in the left halfplane bounded by .  We call  a -center \emph{consistent with } if , the center of  lies to the left of , and  contains at least one point of .  
We first describe a decision algorithm that determines whether there is a -center of unit radius that is consistent with .  Next, we describe an algorithm for computing a -center consistent with , which will lead to computing an optimal -center of , provided there is a well-separated optimal -center of .  

\paragraph{\textbf{\emph{Decision algorithm.}}}
Let  be a line.  We describe an algorithm for determining whether there is a unit radius -center of  that is consistent with .  Let  (resp. ) be the subset of points in  that lie in the left (resp. right) halfplane bounded by ; set , .  Suppose  is a unit-radius -center of  consistent with , and let  be their centers.  Then  and .
For a subset , let  where  is the unit disk centered at .  Let  and .  For a point , let .  Since  contains a point of  and at most  points of  do not lie in ,  lies on an edge of .  

We first compute  in  time.For each disk , we compute the intersection points of  with the edges of .  By Lemma \ref{lem:k-udc}, there are  such intersection points, and these intersection points split each edge into \emph{edgelets}.  The total number of edgelets is also .  
Using Lemma \ref{lem:k-udc}, we can compute all edgelets in time , because each disk boundary from  intersects at most  edges of  and each intersection can be found in  time be examining the covering unit disk curves.
All points on an edgelet  lie in the same subset of disks of , which we denote by .  Let  be the set of centers of disks in , and let  be the level of  in .  A unit disk centered at a point on  contains  and all but  points of .  If at least  points of  can be covered by a unit disk, which is equivalent to  being nonempty, then all but  points of  can be covered by two unit disks.  

When we move from one edgelet  of  to an adjacent one  with  as their common endpoint, then  (if  is a vertex of ),  (if  and ), or  (if  and ).  
We therefore traverse the graph induced by the edgelets of  and maintain  in the dynamic  data structure described  in Section \ref{sec:arrangementD} as we visit the edgelets  of .  At each step we process an edgelet , insert or delete a disk into , and test whether  where .  If the answer is yes at any step, we stop.  We spend  time at each step, by Lemma \ref{lem:dynD}.  Since the number of edgelets is , we obtain the following.

\begin{lemma}
Let  be a set of  points in ,  a line in ,  and  an integer.  
We can determine in  time whether 
there is a unit-radius -center of  that is consistent with .
\end{lemma}


\paragraph{\textbf{\emph{Optimization algorithm.}}}
Let  be a line in .  
Let  be the smallest radius of a -center of  that is consistent with .  
Our goal is to compute a -center of  of radius  that is consistent with .  
We use the parametric search technique \cite{Meg83} --- we simulate the decision algorithm generically at  and use the decision algorithm to resolve each comparison, which will be of the form: given , is ?  We simulate a parallel version of the decision procedure to reduce the number of times the decision algorithm is invoked.
Note that we need to parallelize only those steps of the simulation that depend on , i.e., that require comparing a value with .  Instead of simulating the entire decision algorithm, as in ~\cite{Epp97}, we stop the simulation after computing the edgelets and return the smallest -center found so far, i.e., the smallest radius for which the decision algorithm returned ``yes.''  Since we stop the simulation earlier, we do not guarantee that we find the a -center of  of radius  that is consistent with .  However, as argued below this is sufficient for our purpose.  


Let ,  be the same as in the decision algorithm.  Let ,  etc. be the same as above except that each disk is of radius  (recall that we do not know the value of ).  We simulate the algorithm to compute the edgelets of  as follows.  First, we compute the  order farthest point Voronoi diagram of  in time  \cite{AGSS89}.  Let  be an edge of the diagram with points  and  of  as its neighbors, i.e.,  is a portion of the bisector of  and .  Then for each point , the disk of radius  centered at  contains at least  points of .  We associate an interval .  By definition,  corresponds to a vertex of  if and only if ; namely, if , for some , then  is a vertex of , incident upon the edges that are portions of  and .  
Let  be the sorted sequence of the endpoints of the intervals.
By doing a binary search on  and using the decision procedure at each step, we can find two consecutive endpoints in  between which  lies.  We can now compute all edges  of the Voronoi diagram such that .  We thus compute all vertices of .  
Since we do not know , we do not have actual coordinates of the vertices.  We represent each vertex as a pair of points.  
Similarly, each edge is represented as a point , indiciating that  lies in , and it can be computed using the cells of the Voronoi diagram.  Given a vertex of  and an outgoing edge, represented by the point , we can compute the other endpoint as the next edge  of the Voronoi cell of the  that is a point in  by walking around the boundary of the cell.  
Once we have all the edges of , we can construct the graph induced by them and compute  -monotone unit-disk curves whose union is the set of edges in , using Lemma \ref{lem:udcs-k2}.  Since this step does not depend on the value of , we need not parallelize it.  Let , , be the set of these curves.  

Next, for each disk  and for each , we compute the edges of  that  intersects, using a binary search.  We perform these  binary searches in parallel and use the decision algorithm at each step.  Incorporating Cole's technique~\cite{Col87} in the binary search, the decision procedure is invoked only  times.  For an edge , let  be the set of disks whose boundaries intersect .  We sort the disks in  by the order in which their boundaries intersect .  By doing this in parallel for all edges and using a parallel sorting algorithm for each edge, we can perform this step by invoking the decision algorithm  times.  
The total time spent is .





\paragraph{\textbf{\emph{Putting pieces together.}}}
We repeat the optimization algorithm for all lines in  and return the smallest -center that is consistent with a line in .  
Since Lemma \ref{lem:separator-k2} shows that as long as the solution is well separated at least one line in  is a separator line for the optimal -center of , the smallest radius returned must be that of the optimal -center of .
Hence, we conclude the following:

\begin{lemma}
Let  be a set of  points in  and  an integer.  
If an optimal -center of  is well separated, then the -center problem for  can be solved in  time. 
\label{lem:far}
\end{lemma}








\section{Nearly Concentric Disks}
\label{sec:near}

\begin{figure}[ht]
  \centering
  \includegraphics{close.pdf}
  \caption{\label{fig:near}
          Two unit disks  and  or radius  with centers closer than a distance .  
      }
\end{figure}


In this section we describe an algorithm for the case in which the two disks  and  of the optimal solution are not well separated.  More specifically, let  and  be the centers of  and  and let  be their radius.  This section handles the case where .  

First, we find an \emph{intersector point}  of  and  --- a point that lies in .  
We show how  defines a set  of  possible partitions of  into two subsets, such that for one partition ,  the following holds: .
Finally, we show how to search through the set  in  time, deterministically, for any , or in  expected time.  

\paragraph{\textbf{\emph{Finding an intersector point.}}}
Let  be the circumcircle of .
Eppstein~\cite{Epp97} shows that we can select  points inside  such that at least one, , lies in .  
We can hence prove the following.

\begin{lemma}
Let  be a set of  points in .  We can generate in  time a set  of  points such that for any nearly concentric -center , one of the points in  is their intersector point.  
\end{lemma}

\begin{proof}
Using Matou\v{s}ek's~\cite{Mat95} algorithm for solving LP-type problems with violations, in  time we can find the smallest circle that contains  points of .  
Briefly, the algorithm runs by finding the three points defining the circumcircle, removing each one in turn, and recursing until  points have been removed.  Matou\v{s}ek shows that if we keep track of which nodes in the recursion we reach and halt the recursion if we have seen that node before, then the size of the recursion tree is only .  
In the running of this algorithm we generate all circles which include exactly  points of  for .  We claim that one of these circles must be . 

If the initial circle is not , then it must have at least one point on its 
boundary which is not in .  At least one path of the recursion removes this point.  Since we can reach the point set  in at most  steps, some step in this recursion must return .  


Finally, since the area of  is a constant fraction of  when  are nearly concentric, then by selecting a constant number of points in  one can be guaranteed to be an intersector point. 
\end{proof}




Let  be an intersector point of  and , and let ,  be the two rays from   to the points of .  
Since  and  are nearly concentric, the angle between them is at least some constant .  We choose a set  of  uniformly distributed directions.  For at least one , the line  in direction  and passing through  separates  and , see Figure \ref{fig:near}.  We fix a pair  in  and compute a -center of , as described below.  We repeat this algorithm for every pair.  If  and  are nearly concentric, then our algorithm returns an optimal -center.  

\paragraph{\textbf{\emph{Fixing  and .}}}
For a subset  and for an integer , let  denote the minimum radius of a -center of .  Let  (resp. ) be the subset of  lying above (resp. below) the -axis; set  and .  Sort  in clockwise order and  in counterclockwise order.  
For , , let  and .  
For , let 

For , we define an  matrix  such that .  

Suppose  is an intersector point of  and ,  separates  and , and  (resp. ) lies between  (resp. ).  Then ; see Fig \ref{fig:near}.  
If , then .  
The problem thus reduces to computing 

where the minimum is taken over , , and .  For each , we compute  and choose the smallest among them.  

We note two properties of the matrix  that will help search for :

\begin{itemize}
\item{(P1)} 
If  then  for  and .  These partitions only add points to  and removes points from , and thus cannot decrease  or increase .  
Similarly, if , then  for  and . 
\item{(P2)} Given a value , if , then  for  and , and if , then  for  and .
\end{itemize}


\paragraph{\textbf{\emph{Deterministic solution.}}}
We now have the machinery to use a technique of Frederickson and Johnson \cite{FJ82}.  
For simplicity, let us assume that  where .  The algorithm works in  phases.
In the beginning of the th phase we have a collection  of  submatrices of , each of size .  Initially .  In the th phase we divide each matrix  into four submatrices each of size  that overlap along one row and one column.  We call the cell common to all four submatrices the \emph{center cell} of .  Let  be the resulting set of matrices.  Let  be the set of center cells of matrices in .  We compute  for each .  We use (P1) to remove the matrices of  that are guaranteed not to contain the value .  
In particular, if  and there is a matrix  with the upper-left corner cell  such that  and , then we can remove .  
Similarly if  and there is a matrix  with the lower-right corner cell  such that  and , we can delete . 
We then set  to . 

\begin{figure}[h]
\center
\includegraphics{FJ-mat.pdf}
\caption{\label{fig:FJ-mat}
Example of running deterministic algorithm through 3 phases.  Shaded regions have been pruned.  Center cells are darkened.  
}
\end{figure}

\begin{lemma}
Before the th phase consider a diagonal from large  and  to small  and  that passes through at least one center cell of a matrix .  It passes through at most one more center cell of a matrix .  
\label{lem:diag-center}
\end{lemma}

\begin{proof}
We show this inductively.  The base case is clearly true for the single center cell in .  
Assume it is true for , then we show it is true for .  
See Figure \ref{fig:FJ-mat}.
We consider two cases, first the diagonal passes through a center cell of .  
In this case if it passes through two center cells of , then it passes through  center cells of , but the pruning step eliminates at least two of them.  
In the second case, the diagonal does not pass through a center cell of .  We can bound the number of center cells of matrices it passes through in  to  using the inductive hypothesis.  
Consider one of the interior center cells  it passes through, neither the first not the last.  When the pruning step for the matrix in  that contains  is called, it either eliminated the other matrixes in  that the diagonal passes to before or after .  If the diagonal passes through 3 center cells in , then this reduces it to two, if the diagonal passes through 4 center cells, the applying this analysis to both interior matrices reduces it to two.  
\end{proof}

Lemma \ref{lem:diag-center} implies that  cells remain in  after the pruning step and that they can be connected by two monotone paths in , which consists of  cells.
Since  differs from  and  by one point, we can compute  for all  using 
Lemma \ref{lem:dynC} in total time .
Hence, each phase of the algorithm takes  time.  

\begin{lemma}
Given , , and , 
 can be computed in time , for any .  
\end{lemma}


\paragraph{\textbf{\emph{Randomized solution.}}}
We can slightly improve the dependence on  by using the dynamic data structure in Section \ref{sec:arrangementD} and (P2).  
As before, in the th phase, for some constant , we maintain a set  of at most  submatrices of , each of side length , and their center cells .  Each submatrix is divided into four submatrices of side length , forming a set .  To prune , we choose a random center cell  from  and evaluate  in  time.  For each other center cell ,  with probability , and using (P2), we can remove a submatrix from . 
More specifically, if , then any matrix  with an lower right corner  such that  and  or a upper left corner  such that  and , then we can prune  from .  
Eppstein~\cite{Epp97} proves that by repeating this process a constant number of times, we expect to reduce the size of  to .





On each iteration we use the dynamic data structure described in Section \ref{sec:arrangementD}.  For  insertions and deletions, it can compare each center cell from  to  in  time.  
Thus, finding  takes expected  time.  

\begin{lemma}
Given , , and , 
 can be computed in expected time .
\label{lem:nearR}
\end{lemma}





\paragraph{\textbf{\emph{Putting pieces together.}}}
By repeating either above algorithm for all  and for all pair , we can compute a -center of  that is optimal if  and  are nearly concentric.  Combining this with Lemma \ref{lem:far}, we obtain the main result of the paper.

\begin{theorem}
Given a set  of  points in  and an integer , an optimal -center of  can be computed in  (deterministic) time, for any  
or in  expected time.
\end{theorem}













































\section{The -Center Problem Under the  Metric}

This section focuses on the  version of the -center problem, and hence all references to the -center problem herein are referring to the  variant.  We use extensively that for , the -center problem is LP-type~\cite{SW96}, and thus for  the -center problem can be solved in  time.  We also use that if all points lie in , then the -center problem is LP-type for any , with combinatorial dimension , and thus in , the -center problem can be solved in  time.  

Like in the  variant, we first study the decision version of the dual problem; here an arrangement of unit squares.  
Let  be a set of  unit squares (side length 1) in .  Let  be the arrangement of .  We say a point  \emph{stabs} a square  if .  Let  be the set of squares stabbed by .  

We seek to determine whether there exists a placement of  points  such that .  
We refer to this as the -stabbing decision problem.  
All of our algorithms also return a solution if one exists.  
By replacing each point in the -center problem with a unit square centered at that point, then the  stabbing points of the -stabbing decision problem serve as the center points of unit squares that contain  of the original point set.  


\paragraph{Structure.}
We start by reviewing structure observed by Sharir and Welzl~\cite{SW96} about the -stabbing decision problem.  

If a horizontal or vertical line  passes through all , then this -center decision problem reduces to a variant in  because any stabbing point  can be replaced with , the closest point on  to , so that .  We can then solve the -stabbing decision problem in  time or the -center problem in  time.  
We henceforth assume that this is not the case.  

Let  describe the line passing through the right boundary of the leftmost square.  Similarly, let  (resp. , ) describe the line passing through the left (resp. bottom, top) boundary of the rightmost (resp. topmost, bottommost) square.  
Let  describe the rectangle bounded on its left side by , its right side by , its bottom side by , and its top side by .  (See Figure \ref{fig:rect4}.)
 must have positive area otherwise a horizontal or vertical line would pass through the set of all squares.  

Let , for , describe the four boundary segments of .  Call the intersection of two boundary segments a corner of .  
If the -stabbing decision problem has a solution, we claim that each boundary segment of  contains a stabbing point in a solution of the -stabbing decision problem (in particular, the solution of  stabbing points contained in the smallest rectangle).  For instance, if  does not contain a stabbing point, then we can replace the point  stabbing the leftmost square with another point  on  such that .  

If a stabbing point  lies on corner, it lies on two boundary segments at once, and we can set  and then solve the -stabbing decision problem on .  Of course, we don't know which corner is a stabbing point, but there are a constant number and we can try them all.  

Define  (resp. , , ) as the line through the right (resp. left, bottom, top) boundary of the th leftmost (resp. th rightmost, th topmost, th bottommost) square.  
We can also define the rectangle  which is defined by the intersection of halfspaces defined by lines , , , and .  
We actually want to be slightly careful since one square may be in the th leftmost and th topmost squares.  We count squares first from left and right, then those remaining from top and bottom.  
Let  be the set of squares which intersect .  


\paragraph{Dynamic data structure.}
We will need a data structure to be able to maintain  and  under the removal of the set  for a possible stabbing point .  Sharir and Welzl \cite{SW96} provide a data structure that stores a set of canonical subsets, such that under this operation  can be stored as the union of  (not necessarily disjoint) canonical subsets.  The new boundary lines of  can be constructed in  time from the  subsets.  

The structure is built, and extended to handle outliers, as follows.
In the - and -directions store binary trees of  sorted by their coordinates.  Each node in the tree stores a canonical subset of all squares in its subtree.  For a query point , we can return all squares that cannot intersection  based on - and -coordinates independently, as a set of  canonical subsets each.  The union is .  
We may need to build this data structure  levels deep on each canonical subset for solving the -stabbing decision problem.  
To construct  quickly, we can find the maximum and minimum square in  and  coordinate over all  canonical subsets.  To instead construct , we can find the  minimum  coordinate in  time and similarly for , , and ; thus constructing  can be done in  time, where .  



\subsection{The -Stabbing Decision Problem}

First we choose positive integral values , , , and  such that  and create .  
If , , , and  are chosen correctly, then  is the smallest rectangle that contains the 4 stabbing points.  If the decision is true, then one of this set of  rectangles must match the solution because it can not exclude more than  rectangles in any one direction.
In what follows, we assume we have chosen  correctly, but in the full algorithm we try each until we find a solution.  
If  has non positive area then we can solve the problem in .  We then see if one of the corners, , of  can be a stabbing point by solving the -stabbing decision problem on .  If the answer is negative for each corner, and we assume that we have chosen , , ,  correctly, then each boundary segment of  must contain a distinct stabbing point.  
Let  be the subset so that each  does not intersection  --- these squares must be totally contained in .  Let .  

In the following we assume that  is the smallest rectangle to contain all stabbing points and to simplify notation we set , , and .  Finally, we assume that the solution to the -stabbing decision problem on  has no point on the corners of .  










\begin{figure}[h!!t]
  \centering
  \includegraphics{L-inf.pdf}
  \caption{\label{fig:rect4}
                Structure of a -center problem with -distance.  Rectangle  is shaded and bounded by lines  on the top, right, bottom, and left sides, respectively.  The four centers appear on the four sides of  labeled.  There are five outliers squares shown in bold.}
\end{figure}



\paragraph{4 Rotating Calipers.}
We can now apply a rotating calipers type technique with four calipers, with one point on each edge of .  Since each square can intersect each edge of  at most twice, the boundary of  is divided into  regions such that all points within a region of the boundary intersect the same set of squares.  Squares can intersect more than one edge of , either by also containing a corner point (i.e. left and top), intersect two opposite sides (i.e. left and right), or both (i.e. left, top, and right).  In the third case when a square intersects three sides it must entirely contain one of those sides, and thus any point chosen on that side must stab that square and we can ignore it.  Also only one pair, w.l.o.g. top and bottom, can have squares intersecting both, otherwise both pairs of opposite sides are shorter than a distance , and any square intersecting a pair of opposite sides must entirely contain one of the other sides.  Assuming the top and bottom edges are longer than 1 (so no square can intersect both the left and right edge) we consider two cases: where the point on the top side is right of the point on the bottom side, and vice versa.  We focus on the first case and handle the other one symmetrically.  

We treat the subset of squares  which intersect the top and bottom edges separately from the subset  of the ones that only intersection only one edge or two adjacent edges.  
Each square  describes one interval on the curve defined by .  Thus, given a placement of four stabbing points, one on each boundary side, the squares from  which are not stabbed lie in one of four intervals of  bounded by the stabbing points.  In the optimal solution let there be  unstabbed squares in  between the  and ,  squares between  and ,  squares between  and , and  squares between  and .  For any values , , , and  we can determine if there is placement of the stabbing points on  that has exactly those many unstabbed squares in the associated intervals.  
Given a placement of  in bottommost region of the right boundary edge, we can try to place  skipping  squares, then place  skipping  squares, and finally  skipping  squares.  If there are  squares remaining it is successful.  If it is not successful at any placement step, then we shift  to the next region up on the right boundary and try shifting the other stabbing points to the next region in a counter-clockwise direction to satisfy the constraints.  If all attempts are unsuccessful for all placements of  on the right edge, then this choice of , , , and  is incorrect.  Since there are only  regions, and each stabbing point is in each region at most once, since they only move counter-clockwise, this takes  time.  





Once a solution for  has been found, we attempt find a solution for .  These squares can be sorted left to right and a successful stabbing will have  unstabbed squares from  left of ,  squares between  and , and  squares right of , for some nonnegative integers .  We can now adjust  and  such that the sets  and  do not change.  The boundaries of the squares from  divide the regions into intervals so that within a interval  and  do not change.  After preprocessing to find the left boundary of the rightmost square in  and the right boundary of the leftmost square in , in  time we check if we can place  and  to satisfy  and .  
Quickly checking the  constraint requires preprocessing on the intervals created by the sorted ordering of  so each region contains the number of points stabbed and the number of unstabbed squares to the right.  Thus if  is in a region so that it stabs  squares and there are  squares to the right of the region that  is in, then there are  unstabbed squares from  between  and .  If  then we return true, if not we go back to dealing with  and shift the stabbing points in counter-clockwise order.  

Although, we do not know the values of , , , , , , and  we do know that , thus there are only  possible values.  
For each set of values, we require  time to handle  and for each step  time to handle , after preprocessing.   
Let  be the required time for the algorithms described above to solve the -stabbing decision problem on  unit squares.  

\begin{lemma}
 or just  if the squares are presorted along the - and -axis.  
\end{lemma}

\begin{theorem}
 or just  if the squares are presorted along the - and -axis.  
\label{thm:rect4-dec}
\end{theorem}

\subsection{The -Stabbing Decision Problem}
We first construct  rectangles  as above.  To simplify notation, also assume that  squares intersect or lie inside of  and that at least one center must lie on each side of .  We now have to consider  cases.  

First, one of the centers lies on a corner of .  In this case, we can try all corners, remove the squares that intersect that corner and apply the algorithm for  on the remaining squares.  

Second, all  of the centers lie on the rectangle  (not its interior), but none lie on a corner.  
Third,  centers lie on the boundary of , but none lie on a corner and the fifth center lies in the interior of .  
These cases are more complicated and requires the dynamic data structure described above.




In the second and third case we choose non-negative integers  through  such that .  These determine which points are outliers and not contained in the  centers.  We choose  sets of integers and complete the following for each set.  For what follows we assume we have chosen the correct set.  
Each side of  has at least one center, and one side has two.  We perform the following, assuming each side, in turn, has two centers; w.l.o.g. let it be the right side.
Guess that the left most interval on the bottom edge of  contains the center point, .  
Let  be the set of squares that do not contain .  Using the above 4-level dynamic data structure, obtain  and construct  on .  The bottommost  remaining squares have been designated as outliers, not to contain any center point.  
Now either the bottom left or the bottom right corner of  must contain a center point.  
Check each case by the following; w.l.o.g. assume its the bottom right corner, .  Create  using the dynamic data structure, and recalculate .  
Again the  rightmost squares and  bottommost squares are designated outliers.  
Now again either the bottom right or bottom left corner of  must be a center point.  Check either, remove  and  outliers, and proceed as before removing the squares contained in the third center.  
This process repeats once more, removing  and  outliers, and squares containing the fourth center.  There is now one center left to place.  We remove  and  outliers and can easily check if the last center can contains all remaining squares.  If it cannot then we update  by sliding it to the next interval on the bottom edge of .  We update our 4-level data structure in  time.  This repeats until either all squares can be stabbed by the last center, meaning the result is true, or all intervals on the bottom edge of  have been tried, meaning the result is false.  

Accounting for the  possible outliers to create the initial rectangle , and the  sets of integers , the final running time is .  

The third case is very similar to the second case.  We consider a case where , the center on the interior of , is above either the point on the left side or the right side of .  If this is not true, we would perform the process symmetrically by guessing a center on the top side instead of the bottom side.  We can remove squares containing the first two center points the same way as in the second case.  When there are three center points remaining, we can still claim that one lies on the corner of , but its not necessarily a bottom corner.  This just requires a few more cases to check.  It follows that this third case also takes  time.











\subsection{The - and -Center Problem}
We can solve the original primal problem of determining whether a set of  squares can contain all but  points from an  point set.  To find the minimum side length of the squares for this to be true we can use a matrix searching technique of Frederickson and Johnson \cite{FJ82,FJ83,FJ84} with  iterations of the above algorithm.  The minimal side length of a square is necessarily the difference in -coordinates between two points or the difference in -coordinates between two points.  We implicitly store these two orderings along the columns of two matrices,  and , corresponding to the - and the -coordinates of the points.  The cells contain the differences in their values, but are only computed as needed.  Using monotone properties of these matrices we can search for the minimum such difference where our algorithm returns true.  We take the minimum from both matrices.  

\begin{theorem}
Given a set  of  points in  and an integer , an optimal -center of  can be computed under the -metric in  time.
\end{theorem}

\begin{theorem}
Given a set  of  points in  and an integer , an optimal -center of  can be computed under the -metric in  time.  
\end{theorem}

\section*{Acknowledgements}
We thank Sariel Har-Peled for posing the problem and for several helpful discussions.  

\bibliographystyle{mystyle}
\bibliography{center-apx}


\end{document}