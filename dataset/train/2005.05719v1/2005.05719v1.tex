\documentclass{article}

\usepackage[final]{./style/corl_2020} 

\usepackage[pdftex]{graphicx}
\graphicspath{{images-bin/}}

\usepackage{xspace}
\usepackage[textsize=scriptsize]{todonotes} \setlength{\marginparwidth}{1.6cm}
\usepackage{url}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage[font=footnotesize]{caption}
\usepackage[font=footnotesize]{subcaption}
\usepackage{booktabs}
\usepackage{wrapfig}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{cleveref}
\usepackage{enumitem}

\definecolor{BrickRed}{cmyk}{0, .89, .5, 0}
\definecolor{Blue}{cmyk}{.8, .3, .2, 0}
\definecolor{Green}{cmyk}{1, 0.2, 1, 0}
\definecolor{Black}{cmyk}{1, 1, 1, 0}

\definecolor{aliceblue}{rgb}{0.94, 0.97, 1.0}
\definecolor{almond}{rgb}{0.94, 0.87, 0.8}
\definecolor{amber}{rgb}{1.0, 0.49, 0.0}

\newcommand{\red}{\color{BrickRed}}
\newcommand{\blue}{\color{Blue}}
\newcommand{\green}{\color{Green}}
\newcommand{\black}{\color{Black}}

\DeclareRobustCommand{\TODOCRITICAL}[1]{
\todo[backgroundcolor=red!20,inline]{\textcolor{BrickRed}{\the\value{section}.\the\value{subsection}) #1}}
}

\DeclareRobustCommand{\sidenote}[1]{
\todo{\the\value{section}.\the\value{subsection}) #1}
}
\DeclareRobustCommand{\TODO}[1]{
\todo[backgroundcolor=amber,inline]{TODO: #1}
}
\DeclareRobustCommand{\toni}[1]{
\todo[backgroundcolor=aliceblue,inline]{Toni: #1}
}
\DeclareRobustCommand{\freek}[2][]{
\todo[backgroundcolor=almond,linecolor=almond,#1]{Freek: #2} 
}
\DeclareRobustCommand{\gab}[1]{
\todo[backgroundcolor=green,inline]{Gab: #1}
}

\newcommand{\eg}{e.\,g.\ }
\newcommand{\ie}{i.\,e.\ }


\newcommand{\E}[2]{\operatorname{\mathbb{E}}_{#1}\left[#2\right]}
\newcommand{\voidarg}{{\,\cdot\,}}


\newcommand{\sspace}{\mathcal{S}}
\newcommand{\aspace}{\mathcal{A}}
\newcommand{\state}{\mathbf{s}}
\newcommand{\reward}{r}
\newcommand{\action}{\mathbf{a}}
\newcommand{\at}{{\action_t}}
\newcommand{\st}{{\state_t}}
\newcommand{\rt}{{\reward_t}}

\newcommand{\policy}{\pi}
\newcommand{\entropy}{\mathcal{H}}
\newcommand{\pilatent}{\mathbf{z_\mu}}

\newcommand{\normal}{\mathcal{N}}
\newcommand{\ent}{\entropy}
\newcommand{\noise}{\epsilon}

\newcommand{\sde}{State Dependent Exploration\xspace}
\newcommand{\SDE}{\textsc{SDE}\xspace}
\newcommand{\ourSDE}{\textit{g}\textsc{SDE}\xspace}
\newcommand{\aac}{\textsc{A2C}\xspace}
\newcommand{\ppo}{\textsc{PPO}\xspace}
\newcommand{\sac}{\textsc{SAC}\xspace}
\newcommand{\tddd}{\textsc{TD3}\xspace}

\newcommand{\hc}{\textsc{HalfCheetah}\xspace}
\newcommand{\hopper}{\textsc{Hopper}\xspace}
\newcommand{\ant}{\textsc{Ant}\xspace}
\newcommand{\walker}{\textsc{Walker2D}\xspace}
\newcommand{\mountaincar}{MountainCar\xspace}
 


\title{\LARGE \textbf{Generalized State-Dependent Exploration\\for Deep Reinforcement Learning in Robotics}}









\author{
  Antonin Raffin\\
  Robotics and Mechatronics Center (RMC)\\
  German Aerospace Center (DLR)
  Germany\\
  \texttt{antonin.raffin@dlr.de} \\
  \And
  Freek Stulp\\
  Robotics and Mechatronics Center (RMC)\\
  German Aerospace Center (DLR)
  Germany\\
  \texttt{freek.stulp@dlr.de} \\
}

\begin{document}



\maketitle


\begin{abstract}

Reinforcement learning (RL) enables robots to learn skills from interactions with the real world.
In practice, the unstructured step-based exploration used in Deep RL -- often very successful in simulation -- leads to jerky motion patterns on real robots. Consequences of the resulting shaky behavior are poor exploration, or even damage to the robot.
We address these issues by adapting state-dependent exploration (SDE)~\cite{ruckstiess2008state} to current Deep RL algorithms. To enable this adaptation, we propose three extensions to the original SDE, which leads to a new exploration method \textit{generalized state-dependent exploration} (\ourSDE).
We evaluate \ourSDE both in simulation, on PyBullet continuous control tasks, and directly on a tendon-driven elastic robot. \ourSDE yields competitive results in simulation but outperforms the unstructured exploration on the real robot.
The code is available at \url{https://github.com/DLR-RM/stable-baselines3/tree/sde}.

\end{abstract}
\keywords{Robotics, Reinforcement Learning, Exploration}

\section{Introduction}
\label{sec:intro}

One of the first robots that used artificial intelligence methods was called ``Shakey'', because it would shake a lot during operation~\cite{nilsson84shakey}.
Shaking has now again become quite prevalent in robotics, but for a very different reason. When learning robotic skills with deep reinforcement learning (Deep RL), the de facto standard for exploration is to sample a noise vector  from a Gaussian distribution independently at each time step , and then adding it to the policy output.



This approach can be very effective
in simulation~\citep{duan2016benchmarking,peng2018deepmimic, andrychowicz2018learning, fujimoto2018addressing, hwangbo2019learning}, and has therefore also been applied to robotics~\citep{haarnoja2018applications, kendall2019learning, zhu2020ingredients}.
But for experiments on real robots, such unstructured exploration has many drawbacks, which have been pointed out by the robotics community~\citep{ruckstiess2008state, kober2009policy, ruckstiess2010exploring, stulp2013robot, deisenroth2013survey}:

\begin{enumerate}
  \item sampling independently at each step leads to shaky behavior~\citep{drive-smoothly-in-minutes}, and noisy, jittery trajectories
\item the jerky motion patterns can damage the motors on a real robot, and lead to increased wear and tear.
  \item in the real world, the system acts as a low pass filter. Thus, consecutive perturbations may cancel each other, leading to poor exploration. This is particularly true for high control frequency~\citep{korenkevych2019autoregressive}.
\item it causes a large variance which grows with the number of time-steps~\citep{kober2009policy, ruckstiess2010exploring, stulp2013robot}
\end{enumerate}

To illustrate those limitations, we will first show a failure case of a state-of-the-art algorithm, Soft Actor-Critic (\sac)~\citep{haarnoja2018soft}, on the continuous version of the mountain car problem~\citep{sutton2018reinforcement, brockman2016openai}.
Although low-dimensional (2-dimensional state and 1-dimensional action), this environment was shown to be challenging for DDPG~\cite{colas2018gep}. Despite hyperparameter optimization, the problem cannot be solved without external noise~\footnote{See issue on the original \sac repository \url{https://frama.link/original-sac-mountaincar}}.
Because of the unstructured exploration, the commanded power oscillates at high frequency (cf~\Cref{fig:actions-mountain}), making the velocity stay around the initial value of zero. The policy thus converges to a local minimum of doing nothing, which minimizes the consumed energy.


\begin{figure}[htb]
  \begin{minipage}[b]{.3\linewidth}
  \centering\includegraphics[width=\linewidth]{mountaincar-png}
    \subcaption{\mountaincar Problem}
  \end{minipage}
  \begin{minipage}[b]{.33\linewidth}
    \centering\includegraphics[width=\linewidth]{noise_contrib_gaussian_500-pdf-crop}
    \subcaption{Unstructured Exploration}
  \end{minipage}
  \begin{minipage}[b]{.33\linewidth}
    \centering\includegraphics[width=\linewidth]{noise_contrib_sde_500-pdf-crop}
    \subcaption{\sde}
  \end{minipage}
  \caption{The \mountaincar problem. (a) An underpowered car must drive up the mountain to the flag on the right. This requires driving back-and-forth to build up momentum. (b) and (c) illustrate the exploration during the first 500 steps. Unstructured exploration (b) produces high-frequency noise while \SDE (c) provides smooth and consistent exploration, allowing the top of the mountain to be reached. The action executed is decomposed into its deterministic and exploratory component.}
  \label{fig:actions-mountain}
\end{figure}

In robotics, multiple solutions have been proposed to counteract this inefficient exploration strategy. These include correlated noise~\citep{haarnoja2018applications, korenkevych2019autoregressive}, low-pass filters~\citep{haarnoja2018learning, ha2020learning}, action repeat~\citep{neunert2020continuous} or lower level controllers~\citep{haarnoja2018learning, kendall2019learning}.
A more principled solution is to perform exploration in parameter space, rather than in action space~\citep{plappert2017parameter, pourchot2018cem}. This approach usually requires fundamental changes in the algorithm, and is harder to tune when the number of parameters is high. 



\sde (\SDE)~\citep{ruckstiess2008state, ruckstiess2010exploring} was proposed as a compromise between exploring in parameter and action space. \SDE replaces the sampled noise with a state-dependent exploration function, which during an episode returns the same action for a given state. This results in smoother exploration and less variance per episode.
To the best of our knowledge, no Deep RL algorithm has yet been successfully combined with \SDE. We surmise that this is because the problem that it solves -- shaky, jerky movement -- is not as noticeable in simulation, which is the current focus of the community.

Going back to the \mountaincar problem, \sac with \SDE can solve it with many different hyperparameter configurations~\footnote{See report \url{https://frama.link/MountainCarSDEHyperparametersReport}}.
Looking at the taken actions during early stage of training (cf~\Cref{fig:actions-mountain}), it is clear that \sde provides a smoother and more consistent exploration, permitting to drive up the hill.


In this paper, we aim at reviving interest in \SDE as an effective method for addressing exploration issues that arise from using independently sampled Gaussian noise on real robots. Our concrete contributions, which also determine the structure of the paper, are:

\begin{enumerate}
  \item highlighting the issues with unstructured Gaussian exploration (\Cref{sec:intro}).
  \item adapting \SDE to recent Deep RL algorithms, and addressing some issues of the original formulation (\Cref{sec:sde}).
  \item providing a full benchmark with tuned hyperparameters of recent model-free algorithms on the open source PyBullet~\citep{coumans2019bullet} continuous control environments (\Cref{sec:pybullet-envs}).
  \item performing an ablation study for \SDE (\Cref{sec:ablation}).
  \item successfully applying RL directly on a tendon-driven robot, without the need of a simulator or filters (\Cref{sec:exp-real}).
\end{enumerate}


\section{Background}
\label{sec:background}

In reinforcement learning, an agent interacts with its environment, usually modeled as a Markov Decision Process (MDP)  where  is the state space,  the action space and  the transition function. At every step , the agent performs an action  in state  following its policy . It then receives a feedback signal in the next state : the reward . The objective of the agent is to maximize the long-term reward. More formally, the goal is to maximize the expectation of the sum of discounted reward, over the trajectories  generated using its policy :



where  is the discount factor and represents a trade-off between maximizing short-term and long-term rewards.
The agent-environment interactions are often broken down into sequences called \textit{episodes}, that end when the agent reaches a terminal state.

\subsection{Exploration in action or policy parameter space}

In the case of continuous actions, the exploration is commonly done in the \textit{action space}~\citep{schulman2015trust, lillicrap2015continuous, mnih2016asynchronous, schulman2017proximal, haarnoja2017reinforcement, fujimoto2018addressing}. At each time-step, a noise vector  is independently sampled from a Gaussian distribution and then added to the controller output.



where  is the deterministic policy and  is the resulting stochastic policy, used for exploration.  denotes the parameters of the deterministic policy.\\
For simplicity, throughout the paper, we will only consider Gaussian distributions with diagonal covariance matrices. Hence, here,  is a vector with the same dimension as the action space .

Alternatively, the exploration can also be done in the \textit{parameter space}~\citep{ruckstiess2010exploring, plappert2017parameter, pourchot2018cem, khadka2018evolution}. At the beginning of an episode, the perturbation  is sampled and added to the policy parameters .
This usually results in more consistent exploration but becomes challenging with an increasing number of parameters~\citep{plappert2017parameter}.




\subsection{State Dependent Exploration}
\label{sec:sde}


\textit{\sde(\SDE)}~\citep{ruckstiess2008state, ruckstiess2010exploring} is an intermediate solution that consists in adding noise as a function of the state , to the deterministic action . At the beginning of an episode, the parameters  of that exploration function are drawn from a Gaussian distribution. The resulting action  is as follows:



In the linear case, \ie with a linear policy and a noise matrix, parameter space exploration and \SDE are equivalent:



This episode-based exploration is smoother and more consistent than the unstructured step-based exploration. Thus, during one episode, instead of oscillating around a mean value, the action  for a given state  will be the same.


In the remainder of this paper, to avoid overloading notation, we drop the time subscript , \ie we now write  instead of .  or  now refer to an element of the state or action vector.

In the case of a linear exploration function , by operation on Gaussian distributions, \citet{ruckstiess2008state} show that the action element  is normally distributed:



where  is a diagonal matrix with elements 

We can then obtain the derivative of the log-likelihood  with respect to the variance :




This can be easily plugged into the likelihood ratio gradient estimator~\citep{williams1992simple}, which allows to adapt  during training.
\SDE is therefore compatible with standard policy gradient methods, while addressing most shortcomings of the unstructured exploration.

For a non-linear exploration function, the resulting distribution  is most of the time unknown. Thus, computing the exact derivative w.r.t. the variance is not trivial and may require approximate inference. As we focus on simplicity, we leave this extension for future work.

\section{Generalized \sde (\ourSDE)}



Considering~\Cref{eq:sde-distri,eq:sde-logprob}, some limitations of the original formulation are apparent:

\begin{enumerate}[label=\roman*]
  \item the variance of the policy  depends on the state space dimension (it grows with it), which means that the initial  must be tuned for each problem. \label{item:variance-task}
  \item there is only a linear dependency between the state and the exploration noise, which limits the possibilities. \label{item:linear-noise}
  \item the state must be normalized, as the gradient and the noise magnitude depend on the state magnitude, otherwise one may have gradient issues. \label{item:gradient-issue}
  \item the noise does not change during one episode, which is problematic~\citep{hoof2017generalized} if the episode length is long, because the exploration will be limited. \label{item:episode-sampling}
\end{enumerate}



To mitigate the mentioned issues and adapt it to Deep RL algorithms, we propose three improvements:

\begin{enumerate}
  \item instead of the state , we can in fact use any features. We chose policy features  (last layer before the deterministic output ) as input to the noise function . \label{item:features}
  \item we sample the parameters  of the exploration function every  steps instead of every episode. \label{item:n-steps}
\item when applicable (here, for \aac~\citep{mnih2016asynchronous} and \ppo~\citep{schulman2017proximal}), we make use of parallelization and have multiple exploration matrices. That is to say, for each worker~\citep{mnih2016asynchronous}, we draw different parameters of the exploration function. \label{item:workers}
\end{enumerate}


Using \textit{policy features} allows to mitigate issues~\ref{item:variance-task}, \ref{item:linear-noise} and \ref{item:gradient-issue}: the variance of the policy only depends on the network architecture and the relationship between the state  and the noise  is non-linear. This permits for instance to use images as input. Also, because we can back-propagate through  (using the reparametrization trick~\citep{kingma2013auto}), the features can be learned.\\
This formulation is therefore more general and includes the original \SDE description. In practice, as encountered during our early experiments, relying on policy features makes the algorithm easier to tune and avoid the use of normalization: the weights of the policy are usually small at the beginning of training and evolve slowly, which mitigates gradient problem.


Sampling the parameters  every  steps tackles the issue~\ref{item:episode-sampling}. and yields a unifying framework~\cite{hoof2017generalized} which encompasses both unstructured exploration () and original \SDE (). This formulation follows the description of Deep RL algorithms that update their parameters every  step.
In the remainder of the paper,  is always the same (except for \ppo) as the update frequency (). This avoids having an additional hyperparameter.

Finally, using multiple exploration matrices for \aac and \ppo favor exploration and generally yield better results (cf~\Cref{sec:ablation}).

We call the resulting approach \textit{generalized} \sde (\ourSDE).

\paragraph{Deep RL algorithms}
Integrating this updated version of \SDE into recent Deep RL algorithms, such as those listed in \Cref{sec:algorithms}, is straightforward. For \aac, \ppo and \sac, that rely on a probability distribution, we can replace the original Gaussian distribution by the one derived in~\Cref{eq:sde-distri}, where the analytical form of the log-likelihood is known (cf~\Cref{eq:sde-logprob}). Regarding \tddd~\citep{fujimoto2018addressing}, which doesn't need any distribution, there is even more freedom in the choice of the exploration function. We chose an on-policy exploration based on \aac gradient update, as it allows to adapt the noise magnitude automatically, instead of relying on a scheduler for instance.
We provide pseudo-code for \sac with \ourSDE in the~\Cref{sec:implementation}




\section{Experiments}
\label{sec:experiments}

The goal of this section is to investigate the performance of \ourSDE compared to unstructured exploration in simulation and on a real system.
We first evaluate the two strategies on a set of simulated continuous control tasks. Then, we perform an ablation study to assess the usefulness and robustness of the proposed modifications. Finally, we apply \ourSDE directly on a real tendon-driven robot and compared it to a model-based controller


\subsection{Continuous Control Simulated Environments}
\label{sec:pybullet-envs}


\paragraph{Experiment setup}

In order to compare \ourSDE to unstructured exploration in simulation, we chose 4 locomotion tasks from the PyBullet~\citep{coumans2019bullet} environments: \hc, \ant, \hopper and \walker. They are similar to the one found in OpenAI Gym~\cite{brockman2016openai} but the simulator is open source and they are harder to solve~\footnote{\url{https://frama.link/PyBullet-harder-than-MuJoCo-envs}}.

We fix the budget to 1 Million steps for off-policy algorithms (\sac, \tddd), and to 2 Million for on-policy methods (\aac, \ppo) because they require less time to train but are sample inefficient.\\
We report the average score over 10 runs and the associated variance. This variance corresponds to the 68\% confidence interval for the estimation of the mean.
For each run, we test the learned policy on 10 evaluation episodes every 10000 steps, using the deterministic controller . In all learning curve figures, unless specified otherwise, the -axis represents the number of steps performed in the environment.

Regarding the implementation~\footnote{The code is available at \url{https://github.com/DLR-RM/stable-baselines3/tree/sde}}, we use a PyTorch~\citep{raffin2019baselines3} version of Stable-Baselines~\citep{hill2018stable}, with performances matching the ones published in the RL zoo~\citep{raffin2018zoo}.

The methodology we follow to tune the hyperparameters can be found in~\Cref{sec:optim}. \ppo and \tddd hyperparameters for unstructured exploration are reused from the original papers~\citep{schulman2017proximal, fujimoto2018addressing}. For \sac, the optimized hyperparameters for \ourSDE are performing better than the ones from \citet{haarnoja2018soft}, so we keep them for the unstructured exploration to have a fair comparison. No hyperparameters are available for \aac in \citet{mnih2016asynchronous} so we use the tuned one from \citet{raffin2018zoo}. Full hyperparameters details are listed in~\Cref{sec:hyperparameters}.


\paragraph{Results}

\begin{table}[h!]
\renewcommand{\arraystretch}{1.2}
\centering
\begin{tabular}{@{}l ll c ll@{}}

\toprule
 & \multicolumn{2}{c}{\textbf{\aac}} & \phantom{abc} & \multicolumn{2}{c}{\textbf{\ppo}} \\
 \cmidrule{2-3} \cmidrule{5-6}

 Environments & \multicolumn{1}{c}{\ourSDE} & \multicolumn{1}{c}{Gaussian} && \multicolumn{1}{c}{\ourSDE} &  \multicolumn{1}{c}{Gaussian} \\ \midrule
 \hc & \textbf{2028} +/- \textbf{107} & 1652 +/- 94 && \textbf{2760} +/- \textbf{52} & 2254 +/- 66 \\
 \ant & \textbf{2560} +/- \textbf{45} & 1967 +/- 104 && \textbf{2587} +/- \textbf{133} & 2160 +/- 63 \\
 \hopper & 1448 +/- 163 & 1559 +/- 129 && \textbf{2508} +/- \textbf{16} & 1622 +/- 220 \\
 \walker & \textbf{694} +/- \textbf{73} & 443 +/- 59 && \textbf{1776} +/- \textbf{53} & 1238 +/- 75 \\

\bottomrule \\
\end{tabular}

\caption{Final performance (higher is better) of \aac and \ppo on 4 environments with \ourSDE and unstructured Gaussian exploration (higher is better). We report the mean over 10 runs of 2 million steps.
For each benchmark, we highlight the results of the method with the best mean.
}
\label{tab:res-bullet-onpolicy}
\end{table}

\begin{table}[h!]
\renewcommand{\arraystretch}{1.2}
\centering
\begin{tabular}{@{}l ll c ll@{}}

\toprule
 & \multicolumn{2}{c}{\textbf{\sac}} & \phantom{abc} & \multicolumn{2}{c}{\textbf{\tddd}} \\
 \cmidrule{2-3} \cmidrule{5-6}

 Environments & \multicolumn{1}{c}{\ourSDE} & \multicolumn{1}{c}{Gaussian} && \multicolumn{1}{c}{\ourSDE}  &  \multicolumn{1}{c}{Gaussian} \\ \midrule
 \hc & 2945 +/- 95 & 2883 +/- 57 && 2578 +/- 44 & 2687 +/- 67 \\
 \ant & 3106 +/- 61 & 2859 +/- 329 && \textbf{3267} +/- \textbf{34} & 2865 +/- 278 \\
 \hopper & 2515 +/- 50 & 2477 +/- 117 && 2353 +/- 78 & 2470 +/- 111 \\
 \walker & 2270 +/- 28 & 2215 +/- 92 && 1989 +/- 153 & 2106 +/- 67 \\

\bottomrule \\
\end{tabular}

\caption{Final performance of \sac and \tddd on 4 environments with \ourSDE and unstructured Gaussian exploration. We report the mean over 10 runs of 1 million steps.
}
\label{tab:res-bullet-offpolicy}
\end{table}


The results in~\Cref{tab:res-bullet-onpolicy} show that on-policy algorithms with \ourSDE perform much better than with the unstructured exploration. This difference may be explained by better hyperparameters, as \ourSDE main advantage is on a real robot. \ppo reaches higher scores than \aac which confirms results previously published.

Regarding off-policy algorithms in~\Cref{tab:res-bullet-offpolicy}, the performance of \ourSDE is on-par with their independent exploration equivalent. As expected, no real difference is seen in simulation. The essential improvement of \ourSDE is shown on a real system (cf~\Cref{sec:exp-real}).
The off-policy algorithms are also much more sample efficient compared to their on-policy counterparts: they attain higher performances using half the budget. Those results comfort our choice of \sac for experiments on a real robot.

\subsection{Ablation Study}
\label{sec:ablation}

In this section, we investigate the contribution of the proposed modifications to the original \SDE: using policy features as input to the noise function, sampling the exploration function parameters every  steps and different exploration parameters per worker. We also examine how sensitive \sac is to the initial exploration variance , which is the only additional hyperparameter introduced by \SDE. This study is missing in the original paper.

\begin{figure}[h]
  \begin{minipage}[t]{.5\linewidth}
    \centering\includegraphics[width=\linewidth]{sensitivity_box_plot_sigma-pdf}
    \subcaption{Initial exploration variance  (\sac on \hopper)}
    \label{fig:sac-std-init}
  \end{minipage}
  \begin{minipage}[t]{.5\linewidth}
    \centering\includegraphics[width=\linewidth]{sample_freq_box_plot-pdf}
    \subcaption{Sampling frequency (\ppo on \walker)}
    \label{fig:ppo-sample-freq}
  \end{minipage}
  \caption{Sensitivity of \sac and \ppo to selected hyperparameters on PyBullet tasks. (a) \sac works for a wide range of initial exploration variance (b) The frequency of sampling the noise function parameters is crucial for \ppo with \ourSDE.}
  \label{fig:ablation}
\end{figure}

\paragraph{Initial Exploration Variance}

Robustness to hyperparameter choice is important for experiments in the real world, as hyperparameter tuning would be quite costly. Therefore, we investigate the influence of the initial exploration variance  on PyBullet environments. The results for \sac on the \hopper task is displayed in~\Cref{fig:sac-std-init}. \sac is working for a wide range of initial values: from  () to  (). This is also the case for the other PyBullet tasks, as shown in~\Cref{appendix:ablation}.


\paragraph{Sampling frequency}

\ourSDE is a -step version of \SDE, where  is set to the be the same as the update frequency (except for \ppo). This -step version allows to interpolate between the unstructured exploration  and the original \SDE per-episode formulation.
~\Cref{fig:ppo-sample-freq} shows the importance of that parameter for \ppo on the \walker task.
If the sampling interval is too large, the agent won't explore enough during long episodes. On the other hand, with a high sampling frequency , the issues mentioned in~\Cref{sec:intro} arise.




\begin{figure}[h]
  \begin{minipage}[t]{.5\linewidth}
    \centering\includegraphics[width=\linewidth]{sde_exploration_input-pdf}
    \subcaption{Exploration function input}
    \label{fig:sde-features}
  \end{minipage}
  \begin{minipage}[t]{.5\linewidth}
    \centering\includegraphics[width=\linewidth]{parallel_vs_no-pdf}
    \subcaption{Parallel sampling of the noise parameters}
    \label{fig:ppo-parallel}
  \end{minipage}
  \caption{(a) Influence of the input to the exploration function  for \sac and \ppo on PyBullet environments: using latent features from the policy  (Latent) is usually better than using the state  (Original). (b) Parallel sampling of the noise matrix has a positive impact for \ppo on PyBullet tasks.}
  \label{fig:ablation}
\end{figure}


\paragraph{Policy features as input}

~\Cref{fig:sde-features} shows the effect of changing the exploration function input for \sac and \ppo. Although it varies from task to task, using policy features is usually beneficial, especially for \ppo. It also requires less tuning and no normalization as it depends only on the policy network architecture. Here, the PyBullet tasks are low dimensional and the state space size is of the same order, so no careful per-task tuning is needed. Relying on features also allows to learn directly from pixels, which is not possible in the original formulation.



\paragraph{Parallel Sampling}
The effect of sampling a set of noise parameters per worker is shown for \ppo in~\Cref{fig:ppo-parallel}. This modification improves the performance for each task, as it allows a more diverse exploration. Although less significant, we observe the same outcome for \aac on PyBullet environments (cf~\Cref{fig:a2c-parallel}). Thus, making use of parallel workers improves both exploration and the final performance.


\subsection{Learning to Control a Tendon-Driven Elastic Robot}
\label{sec:exp-real}

\begin{figure}[h]
  \begin{minipage}[t]{.5\linewidth}
    \centering\includegraphics[width=0.8\linewidth]{david_neck_highlight-jpg}
    \subcaption{Tendon-driven elastic continuum neck in a humanoid robot}
    \label{fig:david-neck}
  \end{minipage}
  \begin{minipage}[t]{.5\linewidth}
    \centering\includegraphics[width=\linewidth]{training_success_robot-pdf-crop}
    \subcaption{Training success rate on the real robot}
    \label{fig:success-rate}
  \end{minipage}
  \caption{(a) The tendon-driven robot~\citep{reinecke2016structurally} used for the experiment. The tendons are highlighted in orange. (b) Training success rate on the real robot. The blue line is a moving average over 100 episodes and the x-axis is the wall-clock time in hours.}
\end{figure}

\paragraph{Experiment setup}

To assess the usefulness of \ourSDE, we apply it on a real system. The task is to control a tendon-driven elastic continuum neck~\citep{reinecke2016structurally} (see~\Cref{fig:david-neck}) to a given target pose. Controlling such soft robot is challenging as the deformation of the structure needs to be modeled accurately, which is computationally expensive~\cite{deutschmann2017position, deutschmann2019six} and requires assumptions.

The system is under-actuated (there are only 4 tendons), hence, the desired pose is a 4D vector: 3 angles for the rotation , ,  and one for the position . The input is a 16D vector composed of: the measured tendon lengths (4D), the current tendon forces (4D), the current pose (4D) and the target pose (4D). The reward is a weighted sum between the negative geodesic distance to the desired orientation and the negative Euclidean distance to the desired position. The weights are chosen such that the two components have the same magnitude. The agent receives an additional reward of  when reaching and staying at the target pose for half a second.
The action space consists in desired delta in tendon forces, limited to 5N. For safety reasons, the tendon forces are clipped below 10N and above 40N.
An episode terminates either when the agent reaches the desired pose or after a timeout of 5s, \ie each episode has a maximum length of 200 steps. The episode is considered successful if the desired pose is reached within a threshold of  for the position and  for the orientation. The agent controls the tendons forces at 30Hz, while a PD controller monitors the motor current at 3KHz on the robot. The gradient update was directly done on a 4-core laptop, after each episode.

\paragraph{Results}

We first ran the unstructured exploration on the robot but had to stop the experiment early: the high-frequency noise in the command was damaging the tendons and would have broken them due to their friction on the bearings.\\
Then, we trained a controller using \sac with \ourSDE for two hours. After one hour, the learned policy could already reach successfully  of the desired poses (cf~\Cref{fig:success-rate}).





\section{Related Work}


Exploration is a key topic in reinforcement learning~\citep{sutton2018reinforcement}. It has been extensively studied in the discrete case and most recent papers still focus on discrete actions~\cite{bellemare2016unifying, osband2016deep, fortunato2018noisy, osband2018randomized}.

Several works tackle the issues of unstructured exploration for continuous control by replacing it with correlated noise. \citet{korenkevych2019autoregressive} use an autoregressive process and introduce two variables that allows to control the smoothness of the exploration. In the same vein, \citet{hoof2017generalized} rely on a temporal coherence parameter to interpolate between the step- or episode-based exploration, making use of a Markov chain to correlate the noise. This smoothed noise comes at a cost: it requires an history, which changes the problem definition.


Exploring in parameter space~\cite{kober2009policy, sehnke2010parameter, ruckstiess2010exploring, stulp2013robot, mania2018simple, sigaud2019policy} is an orthogonal approach that also solves some issues of the unstructured exploration. It was successfully applied to real robot but relied on motor primitives~\citep{peters2008reinforcement, stulp2013robot}, which requires expert knowledge.
\citet{plappert2017parameter} adapt parameter exploration to Deep RL by defining a distance in the action space and applying layer normalization to handle high-dimensional space. This approach however adds both complexity, as defining a distance in the action space is not trivial, and computational load.

Population based algorithms, such as Evolution strategies (ES) or Genetic Algorithms (GA), also explore in parameter space. Thanks to massive parallelization, they were shown to be competitive~\cite{salimans2017evolution, such2017deep} with RL in terms of training time, at the cost of being sample inefficient. To address this problem, recent works~\cite{khadka2018evolution, pourchot2018cem} proposed to combine ES exploration with RL gradient update. This combination, although powerful, unfortunately adds numerous hyperparameters and a non-negligible computational overhead.




\section{Conclusion}

Motivated by a simple failure case, we highlighted several issues that arise from the unstructured exploration in Deep RL algorithms for continuous control. Due to those issues, these algorithms cannot be directly applied to real-world robotic problems.

To address these issues, we adapt \sde to Deep RL algorithms by extending the original formulation: we replace the exploration function input by learned features, sample the parameters every  steps, and make use of parallelism. This generalized version (\ourSDE), provides a simple and efficient alternative to unstructured Gaussian exploration.

\ourSDE achieves very competitive results on several continuous control benchmarks. We also investigate the contribution of each modification by performing an ablation study. Our proposed exploration strategy, combined with \sac, is robust to hyperparameter choice, which makes it suitable for robotics applications. To demonstrate it, we successfully apply \sac with \ourSDE directly on a tendon-driven elastic robot. The trained controller matches the performance of a model-based approach in less than two hours.

Although much progress is being made in \textit{sim2real} approaches, we believe there is still much truth in Rodney Brooks' assessment that ``the world is its own best model''. Reinforcement learning on real robots does not require the modeling of interaction forces, friction due to wear and tear, or sensor errors and failures; all of which are also difficult to cover with domain randomization. For these reasons, we believe more effort should be invested in learning on real systems, even if this poses challenges in terms of safety and duration of learning. This paper is meant as a step towards this goal, and we hope that it will revive interest in developing exploration methods that can be directly applied to real robots.

\acknowledgments{The work described in this paper was partially funded by the project ``Reduced Complexity Models'' from the ``Helmholtz-Gemeinschaft Deutscher Forschungszentren''.}












\clearpage



\bibliography{bibliography}  


\appendix

\section{Supplementary Material}

\subsection{Algorithms}
\label{sec:algorithms}

In this section, we shortly present the algorithms used in this paper. They correspond to state of the art methods in model-free RL for continuous control, either in terms of sample efficiency or wall-clock time.

\paragraph{\aac}
\aac is the synchronous version of Asynchronous Advantage Actor-Critic (A3C)~\citep{mnih2016asynchronous}.
It is an actor-critic method that uses parallel rollouts of -steps to update the policy. It relies on the \textsc{REINFORCE}~\cite{williams1992simple} estimator to compute the gradient. \aac is fast but not sample efficient.


\paragraph{\ppo}
\aac gradient update does not prevent large changes that lead to huge drop in performance.
To tackle this issue, Trust Region Policy Optimization (TRPO)~\citep{schulman2015trust} introduces a trust-region in the policy parameter space, formulated as a constrained optimization problem: it updates the policy while being close in terms of KL divergence to the old policy.
Its successor, Proximal Policy Optimization (\ppo)~\citep{schulman2017proximal} relaxes the constrain (which requires costly conjugate gradient step) by clipping the objective using importance ratio. \ppo makes also use of workers (as in \aac) and Generalized Advantage Estimation (GAE)~\citep{schulman2015high} for computing the advantage.


\paragraph{\tddd}
Deep Deterministic Policy Gradient (DDPG)~\citep{lillicrap2015continuous} combines the deterministic policy gradient algorithm~\cite{silver2014deterministic} with the improvements from Deep Q-Network (DQN)~\cite{mnih2013playing}: using a replay buffer and target networks to stabilize training.
Its direct successor, Twin Delayed DDPG (\tddd)~\citep{fujimoto2018addressing} brings three major tricks to tackle issues coming from function approximation: clipped double Q-Learning (to reduce overestimation of the Q-value function), delayed policy update (so the value function converges first) and target policy smoothing (to prevent overfitting).
Because the policy is deterministic, DDPG and \tddd rely on external noise for exploration.


\paragraph{\sac}
Soft Actor-Critic~\citep{haarnoja2017reinforcement}, successor of Soft Q-Learning (SQL)~\cite{haarnoja2018soft} optimizes the maximum-entropy objective, that is slightly different compared to the classic RL objective:

where  is the policy entropy and  is the entropy temperature and allows to have a trade-off between the two objectives.

\sac learns a stochastic policy, using a squashed Gaussian distribution, and incorporates the clipped double Q-learning trick from \tddd.
In its latest iteration~\citep{haarnoja2018applications}, \sac automatically adjusts the entropy coefficient , removing the need to tune this crucial hyperparameter.

\paragraph{Which algorithm for robotics?}

\aac and \ppo are both on-policy algorithms and can be easily parallelized, resulting in relatively small training time.
On the other hand, \sac and \tddd are off-policy and run on a single worker, but are much more sample efficient than the two previous methods, achieving equivalent performances with a fraction of the samples.

Because we are focusing on robotics applications, having multiple robots is usually not possible, which makes \tddd and \sac the methods of choice. Although \tddd and \sac are very similar, \sac embeds the exploration directly in its objective function, making it easier to tune. We also found, during our experiments in simulation, that \sac works for a wide range of hyperparameters. As a result, we adopt that algorithm for the experiment on a real robot and for the ablation study.


\subsection{Implementation Details}
\label{sec:implementation}

We used a PyTorch~\citep{raffin2019baselines3} version of Stable-Baselines~\citep{hill2018stable} library, with results matching the ones published in the RL zoo~\citep{raffin2018zoo}.
The training scripts are available at \url{https://github.com/DLR-RM/rl-baselines3-zoo/tree/sde} and implementation at \url{https://github.com/DLR-RM/stable-baselines3/tree/sde}.
It uses the common implementations tricks for \ppo~\citep{engstrom2020implementation} for the version using independent Gaussian noise.

For \sac, to ensure numerical stability, we clip the mean to be in range , as it was causing infinite values. In the original implementation, a regularization  loss on the mean and standard deviation was used instead. The algorithm for \sac with \ourSDE is described in~\Cref{algo:sac-sde}.

Compared to the original \SDE paper, we did not have to use the \textit{expln} trick~\citep{ruckstiess2008state} to avoid exploding variance for PyBullet tasks. However, we found it useful on specific environment like \textit{BipedalWalkerHardcore-v2}. The original \sac implementation clips this variance.


\begin{algorithm}[h]
\caption{Soft Actor-Critic with \ourSDE}
\label{algo:sac-sde}
\begin{algorithmic}
\State \mbox{Initialize parameters} , , , 
\State \mbox{Initialize replay buffer} 
\For{each iteration}
  \State  \Comment{Sample noise function parameters}
	\For{each environment step}
  	\State   \Comment{Get the noisy action}
  	\State  \Comment{Step in the environment}
  	\State 
    \Comment{Update the replay buffer}
	\EndFor
	\For{each gradient step}
    \State  \Comment{Sample noise function parameters}
    \State Sample a minibatch from the replay buffer 
    \State Update the entropy temperature 
    \State Update parameters using  and 
    \Comment{Update actor , critic  and noise variance }
    \State Update target networks
	\EndFor
\EndFor
\end{algorithmic}
\end{algorithm}


\subsection{Learning Curves}
\label{sec:learning-curves}

\Cref{fig:learning-curves-onpolicy} and \Cref{fig:learning-curves-offpolicy} show the learning curves for off-policy and on-policy algorithms on the four PyBullet tasks, using \ourSDE or unstructured Gaussian exploration.

\begin{figure}[h]
  \begin{minipage}[t]{.5\linewidth}
    \centering\includegraphics[width=\linewidth]{half_on_policy-pdf}
    \subcaption{\hc}
  \end{minipage}
  \begin{minipage}[t]{.5\linewidth}
    \centering\includegraphics[width=\linewidth]{ant_on_policy-pdf}
    \subcaption{\ant}
  \end{minipage}
  \begin{minipage}[t]{.5\linewidth}
    \centering\includegraphics[width=\linewidth]{hopper_on_policy-pdf}
    \subcaption{\hopper}
  \end{minipage}
  \begin{minipage}[t]{.5\linewidth}
    \centering\includegraphics[width=\linewidth]{walker_on_policy-pdf}
    \subcaption{\walker}
  \end{minipage}
  \caption{Learning curves for on-policy algorithms on PyBullet tasks. The line denotes the mean over 10 runs of 2 million steps.}
  \label{fig:learning-curves-onpolicy}
\end{figure}


\begin{figure}[h]
  \begin{minipage}[t]{.5\linewidth}
    \centering\includegraphics[width=\linewidth]{half_off_policy-pdf}
    \subcaption{\hc}
  \end{minipage}
  \begin{minipage}[t]{.5\linewidth}
    \centering\includegraphics[width=\linewidth]{ant_off_policy-pdf}
    \subcaption{\ant}
  \end{minipage}
  \begin{minipage}[t]{.5\linewidth}
    \centering\includegraphics[width=\linewidth]{hopper_off_policy-pdf}
    \subcaption{\hopper}
  \end{minipage}
  \begin{minipage}[t]{.5\linewidth}
    \centering\includegraphics[width=\linewidth]{walker_off_policy-pdf}
    \subcaption{\walker}
  \end{minipage}
  \caption{Learning curves for off-policy algorithms on PyBullet tasks. The line denotes the mean over 10 runs of 1 million steps.}
  \label{fig:learning-curves-offpolicy}
\end{figure}

\subsection{Ablation Study: Additional Plots}
\label{appendix:ablation}

\Cref{fig:ablation-additional} displays the ablation study on remaining PyBullet tasks. It shows that \sac is robust against initial exploration variance, and \ppo results highly depend on the sampling frequency.

\begin{figure}[h]
  \begin{minipage}[t]{.5\linewidth}
    \centering\includegraphics[width=\linewidth]{sensitivity_plot_log_std_init-pdf}
    \subcaption{Initial exploration variance  (\sac)}
  \end{minipage}
  \begin{minipage}[t]{.5\linewidth}
    \centering\includegraphics[width=\linewidth]{sensitivity_plot_sample_freq-pdf}
    \subcaption{Sampling frequency (\ppo)}
  \end{minipage}
  \caption{Sensitivity of \sac and \ppo to selected hyperparameters on PyBullet tasks}
  \label{fig:ablation-additional}
\end{figure}

~\Cref{fig:a2c-parallel} shows the effect of parallel sampling for \aac. The benefit is only clearly visible for the \hc task. On the other, this parameter does not really affects the final performance.

\begin{figure}[h]
  \centering
  \includegraphics[width=0.5\linewidth]{parallel_no_parallel_a2c-pdf}
  \caption{Effect of parallel sampling for \aac on PyBullet tasks}
  \label{fig:a2c-parallel}
\end{figure}

\subsection{Hyperparameter Optimization}
\label{sec:optim}

To tune the hyperparameters, we use a TPE sampler and a median pruner from Optuna~\citep{akiba2019optuna} library.
We give a budget of 500 candidates with a maximum of  time-steps on the \hc environment. Some hyperparameters are then manually adjusted (\eg increasing the replay buffer size) to improve the stability of the algorithms.



\subsection{Hyperparameters}
\label{sec:hyperparameters}

For all experiments with a time limit, as done in \citep{duan2016benchmarking, pardo2017time, rajeswaran2017towards, hill2018stable}, we augment the observation with a time feature (remaining time before the end of an episode) to avoid breaking Markov assumption. This feature has a great impact on performance, as shown in \Cref{fig:time-wrapper}.

~\Cref{fig:net-arch} displays the influence of the network architecture for \sac on PyBullet tasks. A bigger network usually yields better results but the gain is minimal passed a certain complexity (here, a two layers neural network with 256 unit per layer).

\begin{figure}[h]
  \begin{minipage}[t]{.5\linewidth}
    \centering\includegraphics[width=\linewidth]{net_arch-pdf}
    \subcaption{Influence of the network architecture}
    \label{fig:net-arch}
  \end{minipage}
  \begin{minipage}[t]{.5\linewidth}
    \centering\includegraphics[width=\linewidth]{time_feature-pdf}
    \subcaption{Influence of the time feature}
    \label{fig:time-wrapper}
  \end{minipage}
  \caption{(a) Influence of the network architecture (same for actor and critic) for \sac on PyBullet environments. The labels displays the number of units per layer. (b) Influence of including the time or not in the observation for \ppo and \sac.}
\end{figure}

\begin{table}[h]
\renewcommand{\arraystretch}{1.1}
\centering
\caption{\sac Hyperparameters}
\label{tab:sac_shared_params}
\vspace{1mm}
  \begin{tabular}{@{}l l| l@{}}
    \toprule
    \multicolumn{2}{l|}{Parameter} &  Value\\
    \midrule
    \multicolumn{2}{l|}{\textit{Shared}}& \\
    & optimizer & Adam~\citep{kingma2014adam}\\
    & learning rate & \\
    & learning rate schedule & constant \\
    & discount () &  0.98\\
    & replay buffer size & \\
    & number of hidden layers (all networks) & 2\\
    & number of hidden units per layer & [400, 300]\\
    & number of samples per minibatch & 256\\
    & non-linearity & \\
    & entropy coefficient () & auto\\
    & target entropy & \\
    & target smoothing coefficient ()& 0.02\\
    & target update interval & 64\\
    & train frequency & 64\\
    & gradient steps & 64\\
    & warm-up steps & 10 000\\
    & normalization & None\\
    \midrule
    \multicolumn{2}{l|}{\ourSDE}& \\
    & initial  & -3\\
    \bottomrule
  \end{tabular}
\end{table}

\begin{table}[h]
\renewcommand{\arraystretch}{1.1}
\centering
\caption{\sac Environment Specific Parameters}
\label{tab:sac_env_params}
\vspace{1mm}
  \begin{tabular}{@{}l r@{}}
    \toprule
    Environment 	& Learning rate schedule\\
    \midrule
    HopperBulletEnv-v0  & linear\\
    Walker2dBulletEnv-v0 & linear\\
    \bottomrule
  \end{tabular}
\end{table}

\begin{table}[h]
\renewcommand{\arraystretch}{1.1}
\centering
\caption{\tddd Hyperparameters}
\label{tab:td3_shared_params}
\vspace{1mm}
  \begin{tabular}{@{}l l| l@{}}
    \toprule
    \multicolumn{2}{l|}{Parameter} &  Value\\
    \midrule
    \multicolumn{2}{l|}{\textit{Shared}}& \\
    & optimizer & Adam~\citep{kingma2014adam}\\
    & discount () &  0.98\\
    & replay buffer size & \\
    & number of hidden layers (all networks) & 2\\
    & number of hidden units per layer & [400, 300]\\
    & number of samples per minibatch & 100\\
    & non-linearity & \\
    & target smoothing coefficient ()& 0.005\\
    & target policy noise & 0.2 \\
    & target noise clip & 0.5 \\
    & policy delay & 2\\
    & warm-up steps & 10 000\\
    & normalization & None\\
    \midrule
    \multicolumn{2}{l|}{\ourSDE}& \\
    & initial  & -3.62\\
    & learning rate for \tddd & \\
    & target update interval & 64\\
    & train frequency & 64\\
    & gradient steps & 64\\
    & learning rate for \ourSDE & \\
    \midrule
    \multicolumn{2}{l|}{\textit{Unstructured Exploration}}& \\
    & learning rate & \\
    & action noise type & Gaussian\\
    & action noise std & 0.1 \\
    & target update interval & every episode\\
    & train frequency & every episode\\
    & gradient steps & every episode\\
    \bottomrule
  \end{tabular}
\end{table}


\begin{table}[h]
\renewcommand{\arraystretch}{1.1}
\centering
\caption{\aac Hyperparameters}
\label{tab:a2c_shared_params}
\vspace{1mm}
  \begin{tabular}{@{}l l| l@{}}
    \toprule
    \multicolumn{2}{l|}{Parameter} &  Value\\
    \midrule
    \multicolumn{2}{l|}{\textit{Shared}}& \\
    & number of workers &  4\\
    & optimizer & RMSprop with \\
    & discount () &  0.99\\
    & number of hidden layers (all networks) & 2\\
    & number of hidden units per layer & [64, 64]\\
    & shared network between actor and critic & False\\
    & non-linearity & \\
    & value function coefficient & 0.4\\
    & entropy coefficient & 0.0\\
    & max gradient norm & 0.5\\
    & learning rate schedule & linear \\
    & normalization & observation and reward~\citep{hill2018stable}\\
    \midrule
    \multicolumn{2}{l|}{\ourSDE}& \\
    & number of steps per rollout &  8\\
    & initial  & -3.62\\
    & learning rate & \\
    & \textit{GAE} coefficient~\citep{schulman2015high} () &  0.9\\
    & orthogonal initialization~\citep{engstrom2020implementation} & no \\
    \midrule
    \multicolumn{2}{l|}{\textit{Unstructured Exploration}}& \\
    & number of steps per rollout & 32\\
    & initial  & 0.0\\
    & learning rate & \\
    & \textit{GAE} coefficient~\citep{schulman2015high} () &  1.0\\
    & orthogonal initialization~\citep{engstrom2020implementation} & yes \\

    \bottomrule
  \end{tabular}
\end{table}

\begin{table}[h]
\renewcommand{\arraystretch}{1.1}
\centering
\caption{\ppo Hyperparameters}
\label{tab:ppo_shared_params}
\vspace{1mm}
  \begin{tabular}{@{}l l| l@{}}
    \toprule
    \multicolumn{2}{l|}{Parameter} &  Value\\
    \midrule
    \multicolumn{2}{l|}{\textit{Shared}}& \\
    & optimizer & Adam~\citep{kingma2014adam}\\
    & discount () &  0.99\\
    & value function coefficient & 0.5\\
    & entropy coefficient & 0.0\\
    & number of hidden layers (all networks) & 2\\
    & shared network between actor and critic & False\\
    & max gradient norm & 0.5\\
    & learning rate schedule & constant \\
    & advantage normalization~\citep{hill2018stable} & True \\
    & clip range value function~\citep{engstrom2020implementation} & no \\
    & normalization & observation and reward~\citep{hill2018stable}\\
    \midrule
    \multicolumn{2}{l|}{\ourSDE}& \\
    & number of workers &  16\\
    & number of steps per rollout &  512\\
    & initial  & -2\\
    & \ourSDE sample frequency & 4\\
    & learning rate & \\
    & number of epochs & 20\\
    & number of samples per minibatch & 128\\
    & number of hidden units per layer & [256, 256]\\
    & non-linearity & \\
    & \textit{GAE} coefficient~\citep{schulman2015high} () &  0.9\\
    & clip range & 0.4 \\
    & orthogonal initialization~\citep{engstrom2020implementation} & no \\
    \midrule
    \multicolumn{2}{l|}{\textit{Unstructured Exploration}}& \\
    & number of workers &  1\\
    & number of steps per rollout & 2048\\
    & initial  & 0.0\\
    & learning rate & \\
    & number of epochs & 10\\
    & number of samples per minibatch & 64\\
    & number of hidden units per layer & [64, 64]\\
    & non-linearity & \\
    & \textit{GAE} coefficient~\citep{schulman2015high} () &  0.95\\
    & clip range & 0.2 \\
    & orthogonal initialization~\citep{engstrom2020implementation} & yes \\

    \bottomrule
  \end{tabular}
\end{table}


\begin{table}[h]
\renewcommand{\arraystretch}{1.1}
\centering
\caption{\ppo Environment Specific Parameters}
\label{tab:env_params}
\vspace{1mm}
  \begin{tabular}{@{}l l r r r@{}}
    \toprule
    & Environment 	& Learning rate schedule & Clip range schedule & initial \\
    \midrule
    \multicolumn{2}{l}{\ourSDE}& \\
      & AntBulletEnv-v0 & default & default & -1\\
      & HopperBulletEnv-v0 & default & linear & -1\\
      & Walker2dBulletEnv-v0 & default & linear & default\\
    \midrule
    \multicolumn{2}{l}{\textit{Unstructured Exploration}}& \\
      & Walker2dBulletEnv-v0 & linear & default & default\\
    \bottomrule
  \end{tabular}
\end{table}


\end{document}
