\documentclass[titlepage,12pt]{article}

\pdfoutput=1

\newif\ifmtr
\mtrtrue 

\newif\ifreleased
\releasedtrue 

\ifreleased
\else
\pagestyle{myheadings}
\markright{Draft of \today{}}
\fi


\usepackage{makeidx}
\usepackage{graphics}
\usepackage[matrix,arrow,curve]{xy}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{url}
\usepackage{hyperref}\hypersetup{colorlinks=true,}

\newtheorem{thm}{Theorem}
\newtheorem{lem}{Lemma}
\newcommand{\cpsa}{\textsc{cpsa}}
\newcommand{\pvs}{\textsc{pvs}}
\newcommand{\acp}{\textsc{acp}}
\newcommand{\cn}[1]{\ensuremath{\operatorname{\mathsf{#1}}}}
\newcommand{\dom}[1]{\ensuremath{\operatorname{\mathbf{#1}}}}
\newcommand{\fn}[1]{\ensuremath{\operatorname{\mathit{#1}}}}
\newcommand{\srt}[1]{\ensuremath{\mathsf{#1}}}
\newcommand{\typ}{\mathbin:}
\newcommand{\sdom}{\fn{Dom}}
\newcommand{\sran}{\fn{Ran}}
\newcommand{\seq}[1]{\ensuremath{\langle#1\rangle}}
\newcommand{\enc}[2]{\ensuremath{\{\!|#1|\!\}_{#2}}}
\newcommand{\invk}[1]{{#1}^{-1}}
\newcommand{\inbnd}{\mathord -}
\newcommand{\outbnd}{\mathord +}
\newcommand{\nat}{\ensuremath{\mathbb{N}}}
\newcommand{\zed}{\ensuremath{\mathbb{Z}}}
\newcommand{\all}[1]{\forall#1\mathpunct.}
\newcommand{\some}[1]{\exists#1\mathpunct.}
\newcommand{\funct}[1]{\lambda#1\mathpunct.}
\newcommand{\pow}[1]{\mathcal P(#1)}
\newcommand{\prefix}[2]{#1\mid#2}
\newcommand{\init}{\fn{init}}
\newcommand{\resp}{\fn{resp}}
\newcommand{\run}{\mathcal{R}}
\newcommand{\pt}{\fn{pt}}
\newcommand{\form}{\mathcal{K}}
\newcommand{\sent}{\mathcal{S}}
\newcommand{\lang}{\mathcal{L}}
\newcommand{\interp}{\mathcal{I}}
\newcommand{\alg}[1]{\ensuremath{\mathfrak#1}}
\newcommand{\tr}{\ensuremath{\mathfrak C}}
\newcommand{\rl}{\fn{rl}}
\newcommand{\skel}{\mathsf{k}}
\newcommand{\insta}{\mathsf{i}}
\newcommand{\nodes}{\fn{nodes}}
\newcommand{\evt}{\fn{evt}}
\newcommand{\role}{\mathsf{r}}
\newcommand{\orig}{\mathcal{O}}

\newcommand{\boot}{\cn{b}}
\newcommand{\extend}{\cn{ex}(\cn{d},\boot)}
\newcommand{\tran}{\ensuremath{\tau}}
\newcommand{\pth}{\ensuremath{\pi}}
\newcommand{\type}{\ensuremath{\mathfrak T}}
\newcommand{\up}{\mathord\uparrow}
\newcommand{\down}{\mathord\downarrow}

\makeindex

\title{Proving Security Goals With \\ Shape Analysis Sentences}
\author{John D.\ Ramsdell}


\begin{document}
\ifmtr








\begin{titlepage}
\begin{trivlist}\sffamily\bfseries\large
\item
MTR130488\1cm]
\LARGE
Proving Security Goals With\2.5cm]
\large
September 2013\\
~\\
\mdseries
John D.~Ramsdell
\vfill
\normalsize
\bfseries
\begingroup\footnotesize
\begin{tabbing}
Sponsor: \phantom{spo} \= NSA/R2D \phantom{phantom} \=
Contract No.: \phantom{pro}\= W15P7T-13-C-F600 \\
Dept. No.: \>G063 \>Project No.: \>0713N6BZ-TD\4mm]
{\copyright} 2013 The MITRE Corporation. All Rights Reserved.
\end{tabbing}
\endgroup
~\\
\noindent
\includegraphics{mitrelogo-0.mps}\\
Center for Integrated Intelligence Systems\\
Bedford, Massachusetts
\end{trivlist}
\end{titlepage}

\noindent
Approved by:\\label{eqn:security goal}
\all{\vec{x}}\Phi_0\supset\bigvee_{1\le i\le n}\some{\vec{y}_i}\Phi_i.
\begin{array}{r@{{}:{}}l}
A\to B&\enc{\enc{s}{\invk{a}}}{b}\\
B\to A&\enc{d}{s}
\end{array}\begin{array}{r@{{}:{}}l}
A\to M&\enc{\enc{s}{\invk{a}}}{b'}\\
M\to B&\enc{\enc{s}{\invk{a}}}{b}\\
B\to E&\enc{d}{s}
\end{array}\label{eq:amended protocol}
\begin{array}{r@{{}:{}}l}
A\to B&\enc{\enc{s,b}{\invk{a}}}{b}\\
B\to A&\enc{d}{s}
\end{array}
\label{eq:protocol}
\begin{array}{r@{\qquad}l}
\xymatrix@=.6em{\raisebox{-1ex}[0ex][0ex]{\strut\init}\\
  \bullet\ar@{=>}[d]\ar[r]&\enc{\enc{s}{\invk{a}}}{b}\\
  \bullet&\enc{d}{s}\ar[l]}&
\xymatrix@=.6em{&\raisebox{-1ex}[0ex][0ex]{\strut\resp}\\
\enc{\enc{s}{\invk{a}}}{b}\ar[r]&\bullet\ar@{=>}[d]\\
\enc{d}{s}&\bullet\ar[l]}
\end{array}
\label{eq:shape analysis}
\begin{array}{rcl}
\xymatrix@R=1em@C=3em{\raisebox{-0.5ex}[0ex][0ex]{\strut\resp}\\
\bullet\ar@{=>}[d]&\ar[l]_{\enc{\enc{s}{\invk{a}}}{b}}\\
\bullet\ar[r]^{\enc{d}{s}}&}&
\raisebox{-4.0ex}{implies}&
\xymatrix@R=1em@C=3em{\raisebox{-0.5ex}[0ex][0ex]{\strut\resp}&&
\raisebox{-0.5ex}[0ex][0ex]{\strut\init}\\
\bullet\ar@{=>}[d]&\succ\ar[l]_{\enc{\enc{s}{\invk{a}}}{b}}&\bullet
\ar[l]_{\enc{\enc{s}{\invk{a}}}{b'}}\\
\bullet\ar[r]^{\enc{d}{s}}&}
\end{array}
\begin{array}{ll@{{}\typ{}}ll}
\mbox{Sorts:}&
\multicolumn{3}{l}{\mbox{, , , }}\\
\mbox{Subsorts:}&
\multicolumn{3}{l}{\mbox{, , }}\\
\mbox{Operations:}&(\cdot,\cdot)&\top\times\top\to\top& \mbox{Pairing}\\
&\enc{\cdot}{(\cdot)}&\top\times\srt{A}\to\top&\mbox{Asymmetric encryption}\\
&\enc{\cdot}{(\cdot)}&\top\times\srt{S}\to\top&\mbox{Symmetric encryption}\\
&\invk{(\cdot)}&\srt{A}\to\srt{A}& \mbox{Asymmetric key inverse}\\
&\invk{(\cdot)}&\srt{S}\to\srt{S}& \mbox{Symmetric key inverse}\\
&\cn{a}_i,\cn{b}_i&\srt{A}& \mbox{Asymmetric key constants}\\
&\cn{s}_i&\srt{S}& \mbox{Symmetric key constants}\\
\mbox{Equations:}&\multicolumn{2}{l}{\invk{\cn{a}_i}=\cn{b}_i\quad
\invk{\cn{b}_i}=\cn{a}_i}
&(i\in\nat)\\
&\multicolumn{2}{l}{\all{k\typ\srt{A}}\invk{(\invk{k})}=k}
&\all{k\typ\srt{S}}\invk{k}=k
\end{array}\begin{array}{r@{{}={}}l}
\fn{create}(t\in\alg{B})&\seq{\outbnd t}\\
\fn{pair}(t_0\typ\top, t_1\typ\top)&
\seq{\inbnd t_0,\inbnd t_1,\outbnd (t_0,t_1)}\\
\fn{sep}(t_0\typ\top, t_1\typ\top)&
\seq{\inbnd (t_0, t_1),\outbnd t_0,\outbnd t_1}\\
\fn{enc}(t\typ\top, k\typ\srt{A}|\srt{S})&
\seq{\inbnd t,\inbnd k,\outbnd \enc{t}{k}}\\
\fn{dec}(t\typ\top, k\typ\srt{A}|\srt{S})&
\seq{\inbnd \enc{t}{k},\inbnd\invk{k},\outbnd t}
\end{array}\Sigma_k(\Upsilon)\Longleftrightarrow
\some{\delta}\delta\typ k\mapsto\Upsilon.\label{eqn:shape sentence}
\all{\Upsilon\in\run_{\pt(k_0)},X_0}\Phi_0 \Longleftrightarrow
\bigvee_i\some{X_i}\Delta_i\wedge\Phi_i,
\xymatrix{k_0\ar[r]^{\delta_i}\ar[dr]_{\delta'_0}&k_i\ar[d]^{\delta'_i} \\
&\Upsilon}\begin{array}{r@{{}:{}}l}
A\to B&\enc{\enc{s}{\invk{a}}}{b}\\
B\to A&\enc{d}{s}
\end{array}\label{eq:cpsa protocol}
\begin{array}{r@{{}={}}l}
\init(a,b\typ\srt{A},s\typ\srt{S},d\typ\srt{D})&
\role(\langle\outbnd\enc{\enc{s}{\invk{a}}}{b},\inbnd\enc{d}{s}\rangle,
\langle\emptyset,\emptyset\rangle,
\langle\{s\},\emptyset\rangle)\\
\resp(a,b\typ\srt{A},s\typ\srt{S},d\typ\srt{D})&
\role(\langle\inbnd\enc{\enc{s}{\invk{a}}}{b},\outbnd\enc{d}{s}\rangle,
\langle\emptyset,\emptyset\rangle,
\langle\emptyset,\emptyset\rangle)
\end{array}
\begin{array}{@{}r@{}c@{}l@{}}
k_0&{}={}&\skel_X(\begin{array}[t]{@{}ll}
\{\init(a_0,b_0,s_0,d_0),\resp(a_1,b_1,s_1,d_1)\},
&\mbox{Protocol}\\
\seq{\insta(\resp,2,\{a_1\mapsto a,b_1\mapsto b,s_1\mapsto s,d_1\mapsto d\})},
&\mbox{Instances}\\
\emptyset,
&\mbox{Node orderings}\\
\{\invk{a},\invk{b}\},
&\mbox{Non-origination}\\
\emptyset)
&\mbox{Unique origination}
\end{array}\\
&&\mbox{where }\\
k_1&{}={}&\skel_Y(\begin{array}[t]{@{}ll}
\{\init(a_0,b_0,s_0,d_0),\resp(a_1,b_1,s_1,d_1)\},
&\mbox{Protocol}\\
\langle\begin{array}[t]{@{}l}
\insta(\resp,2,\{a_1\mapsto a,b_1\mapsto b,s_1\mapsto s,d_1\mapsto d\}),\\
\insta(\init,1,\{a_0\mapsto a,b_0\mapsto b',s_0\mapsto s,d_0\mapsto d'\})\rangle
\end{array}
&\begin{array}[t]{@{}l}
\mbox{Instances}\\
\mbox{\emph{Note  is  not !}}
\end{array}\\
\{(1,0)\prec(0,0)\},
&\mbox{Node orderings}\\
\{\invk{a},\invk{b}\},
&\mbox{Non-origination}\\
\{s\})
&\mbox{Unique origination}
\end{array}\\
&&\mbox{where }\\
\delta_1&{}={}&(\seq{0},\{a\mapsto a, b\mapsto b, s\mapsto s, d\mapsto d\})
\end{array}\begin{array}{l}
\all{(\Theta,\to)\in\run_{\pt(k_0)}, a,b\typ\srt{A}, s\typ\srt{S},
  d\typ\srt{D}, z\in\sdom(\Theta)}\\
\quad\fn{htin}(\Theta,z,2,resp(a,b,s,d))\wedge
\cn{non}(\Theta,\invk{a})\wedge\cn{non}(\Theta,\invk{b})\\
\qquad\supset\some{a_0\typ\srt{A}, s_0\typ\srt{S}, d_0\typ\srt{D},
  z_0\in\sdom(\Theta)}\fn{htin}(\Theta,z_0,1,init(a_0,b,s_0,d_0))
\end{array}\begin{array}{l}
\all{(\Theta,\to)\in\run_{\pt(k_0)}, a_0,b_0\typ
\srt{A}, s_0\typ\srt{S}, d_0\typ\srt{D}, z_0\in\sdom(\Theta)}\\
\quad\fn{htin}(\Theta,z_0,2,\resp(a_0,b_0,s_0,d_0))\wedge
\fn{non}(\Theta,\invk{a_0})\wedge\fn{non}(\Theta,\invk{b_0})\\
\quad\Longleftrightarrow\\
\quad\some{a_1,b_1,b_2\typ\srt{A}, s_1\typ\srt{S},
  d_1,d_2\typ\srt{D}, z_1,z_2\in\sdom(\Theta)}\\
\qquad z_0=z_1\wedge a_0=a_1\wedge b_0=b_1\wedge s_0=s_1\wedge d_0=d_1\wedge{}\\
\qquad\fn{htin}(\Theta,z_1,2,\resp(a_1,b_1,s_1,d_1))\wedge{}\\
\qquad\fn{htin}(\Theta,z_2,1,\init(a_1,b_2,s_1,d_2))\wedge{}\\
\qquad(z_2,0)\prec_{(\Theta,\to)}(z_1,0)\wedge\fn{uniq}(\Theta,s_1,(z_2,0))\wedge{}\\
\qquad\fn{non}(\Theta,\invk{a_1})\wedge
\fn{non}(\Theta,\invk{b_1})
\end{array}\begin{array}{l}
\some{\role(C,N,U,A)\in\rl(s)}\\
\quad\fn{inst}(\Theta,s,\role(C,N,U,A))\wedge A(i)=\up a
\end{array}\fn{anode}((\Theta,\to),\rl)=\{n\in\fn{nodes}(\Theta)\mid
\some{a\typ\type}\fn{anno}((\Theta,\to),\rl,n,a)\}\begin{array}{l}
\all{\pi\in\fn{path},i,k\in\nat}\\
\quad i\leq k\supset{}\\
\qquad \pi(i)\geq \pi(k)\lor{}\\
\qquad \some{j\in\nat}
i<j\land j\leq k\land \pi(j)=\fn{bx}
\end{array}\begin{array}{rll}
\xymatrix@=.6em{\raisebox{-1ex}[0ex][0ex]{\strut\fn{buyer}}\\
  \bullet\ar@{=>}[d]\ar[r]&\enc{\mathit{buy},n_c,c}{b}\\
  \bullet\ar@{=>}[d]&\enc{n_c,n_b,b}{c}\ar[l]\\
  \bullet\ar[r]&(n_c,n_b)}&
\xymatrix@=.6em{&\raisebox{-1ex}[0ex][0ex]{\strut\fn{cashier}}\\
\enc{\mathit{buy},n_c,c}{b}\ar[r]&\bullet\ar@{=>}[d]\\
\enc{n_c,n_b,b}{c}&\bullet\ar@{=>}[d]\ar[l]\\
\enc{\mathit{one},b,c}{k}\ar[r]&\bullet\ar@{=>}[d]\\
\enc{\mathit{zero},b,c}{k}&\bullet\ar@{=>}[d]\ar[l]\\
(n_c,n_b)\ar[r]&\bullet}&
\xymatrix@=.6em{&\raisebox{-1ex}[0ex][0ex]{\strut\fn{new\ card}}\\
\fn{new}\ar[r]&\bullet\ar@{=>}[d]\\
\enc{\mathit{one},b,c}{k}&\bullet\ar[l]}
\end{array}b,c\typ A, k\typ S, n_b,n_c\typ D\begin{array}{l}
\all{\Upsilon,\rl}
\fn{compatible}(\Upsilon,\rl)\supset{}\\
\quad\all{n_0,n_1\in\fn{anode}(\Upsilon,\rl),a_0,a_1\in\pow{\tau},
s_0,s_1\in\upsilon}\\
\qquad\fn{anno}(\Upsilon,\rl,n_0,a_0)\land
\fn{anno}(\Upsilon,\rl,n_1,a_1)\land n_0\prec n_1\land{}\\
\qquad a_0\subseteq\{(s_2,s_3)\mid s_3=s_0\}\land
a_1\subseteq\{(s_2,s_3)\mid s_2=s_1\}\supset{}\\
\qquad\quad s_0\geq s_1\lor{}\\
\qquad\quad\some{n\in\fn{anode}(\Upsilon,\rl)}\\
\qquad\qquad\fn{anno}(\Upsilon,\rl,n,\{(s_2,s_3)\mid
s_3=\fn{bx}\})\land{}\\
\qquad\qquad n_0\prec n\land n\prec n_1
\end{array}
\end{lem}
\end{figure}

When analyzing the {\acp}, {\cpsa} has no means by which to enforce
the linear ordering of state encoding nodes in bundles, and it may
produce a shape analysis sentence that is incompatible with our notion
of state.  To verify state aware security goals, we will restrict our
attention to the bundles that are compatible with the role assignment
implied by the role definitions.  Because function~ in the
definition of compatibility is a bijection, annotated nodes in
compatible bundles must be linearly ordered.

The compatible bundle assumption allows one to infer the existence of
nodes that are not revealed by {\cpsa}.  In the case of the {\acp},
this is done by importing the Check or Issue Lemma into the strand space
world by proving the Bridge Lemma (Lemma~\ref{lem:bridge}).
The proof of the Bridge Lemma makes use of every part of the
definition of compatibility.

The implication in the Check or Issue Lemma corresponds to the second
implication in the Bridge Lemma.  The correspondence of the
conclusions of each implication is straightforward, however, the
hypothesis of the Bridge Lemma is much more complicated than the one
in the Check or Issue Lemma.  Yet all it is saying is that the
beginning and ending states over the range of the path are~
and~, where as in the Check or Issue Lemma, those states are
simply referred to by~ and~.

Dear reader, at this point I promised to describe the use of a shape
analysis sentence to complete the proof of the security goal.  I
fibbed.  This example is so simple and contrived, there is no need to
run {\cpsa} at all!  The fact that when there are two interactions
with cashiers, there must have been a new card issued between the
cashier interactions follows from the point-of-view skeleton one would
use to analyze this security goal.  In this respect, this is a very
unusual example.

The above procedure for verifying security goals of protocols with
state has been successfully applied to the Envelope
Protocol~\cite{ables2010escrowed}.  In this case, two shape analysis
sentences are required to prove the most interesting security goal.
The {\pvs} proof is detailed and involved, and relies on fundamental
properties of bundles.

For example, it was shown in {\pvs} that if node~ is before some
transmission node~, then either the nodes are on the same strand
or there is a reception node~ before~ on the same strand,
such that  is before~.  The compatibility assumption implies
a total ordering among transmission nodes with annotations.  The above
lemma is used to infer the correct ordering of nodes that receive
state encoding messages.  The lemma is also used in the proof of the
{\acp} security goal.

The proof of the Envelope Protocol security goal will be described in
the forthcoming paper mentioned earlier.

\printindex

\end{document}
