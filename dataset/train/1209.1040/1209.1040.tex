

\documentclass[12pt,a4paper]{book}
\usepackage[utf8]{inputenc}
\usepackage{amsthm,amssymb,euscript,latexsym}
\usepackage[all,2cell]{xy}
\usepackage[ruled,vlined,linesnumbered]{algorithm2e}
\usepackage{hyperref}
\hypersetup{linkbordercolor=1 1 1}
\usepackage{anysize} \marginsize{3cm}{2cm}{2.5cm}{2.5cm}
\usepackage{fancybox, calc} 
\usepackage{oz}
\usepackage[dvips,pdftex]{graphicx}

\newcounter{nivell}
\setcounter{nivell}{0}
\newcommand{\nounivell}{\addtocounter{nivell}{1}}
\newcommand{\nvl}{\value{nivell}}

\makeatletter
\def\cleardoublepage{\clearpage\if@twoside \ifodd\c@page\else
  \hbox{}
  \vspace*{\fill}
  \vspace{\fill}
  \thispagestyle{empty}
  \newpage
  \if@twocolumn\hbox{}\newpage\fi\fi\fi}
\makeatother




\textwidth 14.8cm
\textheight 22.2cm


\renewcommand{\baselinestretch}{1.}


\makeatletter
\def\thickhrulefill{\leavevmode \leaders \hrule height 1pt\hfill \kern \z@}
\def\s@btitle{\relax} 
\def\subtitle#1{\gdef\s@btitle{#1}} 
\renewcommand{\maketitle}{\begin{titlepage}\let\footnotesize\small
    \let\footnoterule\relax
    \parindent \z@
    \reset@font
    \null\vfil
    \hrule height 1ex\vskip 10\p@
    {\raggedright
      \LARGE 
      \strut \@title \par}
      \vskip 20\p@
     {\raggedleft\LARGE \strut \@author\par}
    
    \vskip 5\p@
    \hrule height 1ex\vskip 40\p@
    \vfil\null
  \end{titlepage}\setcounter{footnote}{0}}
\makeatother
\makeatletter
\def\thickhrulefill{\leavevmode \leaders \hrule height 1ex \hfill \kern \z@}
\def\@makechapterhead#1{\vspace*{10\p@}{\parindent \z@ \centering \reset@font
        \thickhrulefill\quad
        \scshape \@chapapp{} \thechapter
        \quad \thickhrulefill
        \par\nobreak
        \vspace*{10\p@}\interlinepenalty\@M
        \hrule
        \vspace*{10\p@}\Huge \bfseries #1\par\nobreak
        \par
        \vspace*{10\p@}\hrule
\vskip 40\p@
  }}
\def\@makeschapterhead#1{\vspace*{10\p@}{\parindent \z@ \centering \reset@font
        \thickhrulefill
        \par\nobreak
        \vspace*{10\p@}\interlinepenalty\@M
        \hrule
        \vspace*{10\p@}\Huge \bfseries #1\par\nobreak
        \par
        \vspace*{10\p@}\hrule
\vskip 40\p@
  }}

\theoremstyle{plain}
\newtheorem{theorem}{Theorem}
\newtheorem{proposition}{Proposition}
\newtheorem{problem}{Problem}
\newtheorem{lema}{Lemma}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{exercici}[theorem]{Exercici}

\theoremstyle{definition}
\newtheorem{defin}{Definición}
\newtheorem{definition}{Definition}
\newtheorem{example}{Example}
\newtheorem{notacio}{Notacio}
\newtheorem{objectiu}{Objectiu}
\newtheorem{indicacio}{Indicacio}
\newtheorem{propietat}{Propietat}

\theoremstyle{remark}
\newtheorem{obs}{Remark}
\newtheorem{observation}{Remark}
\newtheorem{note}{Note}
\newtheorem{remark}{Remark}
\newtheorem*{Proof}{Proof}


\usepackage{alltt, fancyhdr, boxedminipage}
\usepackage{makeidx, multirow, longtable, tocbibind, amssymb}

\newcommand{\pysrcprompt}[1]{\textcolor{py@ps1colour}{\small\textbf{#1}}}
\newcommand{\pysrcmore}[1]{\textcolor{py@ps2colour}{\small\textbf{#1}}}
\newcommand{\pysrckeyword}[1]{\textcolor{py@keywordcolour}{\small\textbf{#1}}}
\newcommand{\pysrcbuiltin}[1]{\textcolor{py@builtincolour}{\small\textbf{#1}}}
\newcommand{\pysrcstring}[1]{\textcolor{py@stringcolour}{\small\textbf{#1}}}
\newcommand{\pysrcdefname}[1]{\textcolor{py@defnamecolour}{\small\textbf{#1}}}
\newcommand{\pysrcother}[1]{\small\textbf{#1}}
\newcommand{\pysrccomment}[1]{\textcolor{py@commentcolour}{\small\textbf{#1}}}
\newcommand{\pysrcoutput}[1]{\textcolor{py@outputcolour}{\small\textbf{#1}}}
\newcommand{\pysrcexcept}[1]{\textcolor{py@exceptcolour}{\small\textbf{#1}}}
\newlength{\funcindent}
\newlength{\funcwidth}
\setlength{\funcindent}{1cm}
\setlength{\funcwidth}{\textwidth}
\addtolength{\funcwidth}{-2\funcindent}
\newlength{\varindent}
\newlength{\varnamewidth}
\newlength{\vardescrwidth}
\newlength{\varwidth}
\setlength{\varindent}{1cm}
\setlength{\varnamewidth}{.3\textwidth}
\setlength{\varwidth}{\textwidth}
\addtolength{\varwidth}{-4\tabcolsep}
\addtolength{\varwidth}{-3\arrayrulewidth}
\addtolength{\varwidth}{-2\varindent}
\setlength{\vardescrwidth}{\varwidth}
\addtolength{\vardescrwidth}{-\varnamewidth}
\newenvironment{Ventry}[1]{\begin{list}{}{\renewcommand{\makelabel}[1]{\texttt{##1:}\hfil}\settowidth{\labelwidth}{\texttt{#1:}}\setlength{\leftmargin}{\labelsep}\addtolength{\leftmargin}{\labelwidth}}}{\end{list}}
\usepackage{enumerate}
\usepackage{array}
\usepackage{makeidx}

\author{Adrià Alcalá Mena}
\title{Trivalent Graph isomorphism in polynomial time}
\date{\today}
\makeindex

\begin{document}
\clearpage{}\thispagestyle{empty}
\vspace*{7mm}
\begin{center}
{\Large\bf TRIVALENT GRAPH ISOMORPHISM }

{\Large\bf IN POLYNOMIAL TIME }\1cm]







{\large Junio 2012}\
 (j \; k+1) = (k \; k+1)(j \; k )(k \; k+1)

 S = \{ (i \; i+1 ) \; 1 \leq i < n \}

 ( 1 \ldots n)^i ( 1 \; 2 ) ( 1 \ldots n)^i = ( i+1 \; i+2) \qquad 1 \leq i \leq n-2
|E(X_2)| < |V(X_2)| \cdot t 
 (x,y) \in E \Leftrightarrow ( \varphi(x), \varphi(y) \in E 

 ( \varphi^{-1}(x), \varphi^{-1} (y) ) \in E \Leftrightarrow (x,y) \in E

 (x,y) \in E \Leftrightarrow (\varphi(x), \varphi(y) ) \in E \Leftrightarrow ( \varphi' ( \varphi (x)), \varphi' ( \varphi (y))) \in E

 1 = G_{n-1} \subseteq \cdots \subseteq G_1 \subseteq G_0 = G

 1 = H_{n-1} \subseteq \cdots H_2 \subseteq H_1 \subseteq H \subseteq G

 \hat{P} ( \gamma) = \hat{P}( g_j ( \alpha)) = \hat{P} ( g_j ( \beta)) = \hat{P} ( \delta) \supseteq P_i ( f_i ( \gamma)) \cup P_i ( f_i ( \delta ))

 | G_i : G_{i+1} | \leq \mbox{ number of blocks } - i 
V(X_1) = \{ a,b \} \; , \; E(X_1) = \{ (a,b) \} V ( X_r) = \{ b \in V( X) \; | \; \exists a \in V(X_{r-1} ) \mbox{ such that} (a,b) \in E(X) \} 
 E(X_r) =  \{ ( a,b) \in E( X) \; | \; \exists a \in V(X_{r-1} ) \mbox{ such that} (a,b) \in E(X) \}

 \pi_r : Aut_e(X_{r+1}) \rightarrow Aut_e(X_r)

 f: V_{r+1} \rightarrow A_r

  \sigma \in Aut_e(X_{r+1}) \Rightarrow f( \sigma (v)) = \sigma ( f(v))
 
w \in f(v) \Leftrightarrow ( w,v) \in E(X_{r+1}) \Leftrightarrow ( \sigma(w) , \sigma(v) ) \in E(X_{r+1}) 
\Leftrightarrow \sigma(w) \in f( \sigma (v))

 A' = \{ (v_1, v_2, ) \in A \; | \; ( v_1, v_2 ) \in  E(X_{r+1}) \}

 A_1 = \{ a \in A \; | \; a = f(v) \mbox{ for some unique } v \in V_{r+1} \}

 A_2 = \{ a \in A \; | \; a=f(v_1) = f(v_2 ) \mbox{ for some } v_1  \neq v_2 \}

 C_B( \sigma H) = \rho_1 \sigma_B(H) \qquad C_B ( \sigma \tau H)= \rho_2 C_B( H)

  T(n) = \left\lbrace \begin{array}{lcl} 1 & if & n = 1 \\ 2 T\left( \frac{n}{2} \right) & if & G \mbox{ is intransitive on } B \\
                       O(n^7) + 4 \left(\frac{n}{2} \right) & if & G \mbox{ is transitive on } B
                      \end{array} \right. 
 
 T(n) = O(n^7) + 4 \left( \frac{n}{2} \right) = \sum_{i=0}^{\log n}  O \left( 4^i \frac{n^7}{2^i} \right) + 4^{\log n} =O\left( 
 n^8 \right) + n^2 = O( n^8)

  \tau := g_j 
 
  \beta_i := \left\{ \begin{array}{lcl} g_i & \mbox{ if } & g_i \in H \\ \tau^{-1} g_i & \mbox{ if } & g_i \notin H \end{array} 
  \right. \mbox{ for } i = 1, \ldots, k
 
  \Pi_{i=1}^k [ G_{(i)}: G_{(i-1)}] = | G | = 2 |H| \geq 2 | H_{(k)}| = 1 \Pi_{i=1}^k [ H_{(i)}: H_{(i-1)} ] \geq \Pi_{i=1}^k 
  G_{(i)} : G_{(i-1)} ]
 
   \sigma (a) = \left\lbrace \begin{array}{lcl} a & if & a \notin \sigma \\ \sigma[i-1] & if & \mbox{the index} i \mbox{ of } a \mbox{ is odd}\\                              \\
                              \sigma[i+1] & if & \mbox{the index} i \mbox{ of } a \mbox{ is pair} 
                              
                             \end{array} \right.
  
 K_r = \Pi_{a \in A} Sym ( f^{-1}(a))

 A_s = \{ a \in A \; | \; f^{-1}(a) = s \} \qquad 0 \leq s \leq t-1

and the set  of new edges, we need  colors to color .

\chapter{Implementation test}
 
 Finally,  in this chapter we will present some examples and tests using our own  SAGE implementation. The first examples are to show that the 
 code correctly works, and the test are to prove that  runs in a reasonable time.  Although the SAGE algorithm itself runs more 
 quickly,  they are comparable.
 
 \begin{example}\label{ImpTestEx1}
  In this first example we will test two graphs who are isomorphics. The first graph, is the graph with edges  , and the second is the graph with edges  , Figure \ref{Example1X1} and \ref{Example1X2} shows this two graphs.

  \begin{figure}
\centering
 \includegraphics[scale=0.5]{graphics/Example1X1.png}
 \caption{The first graph of Example \ref{ImpTestEx1}}\label{Example1X1}
\end{figure}

\begin{figure}
\centering
\includegraphics[scale=0.5]{graphics/Example1X2.png}
 \caption{The second graph of Example \ref{ImpTestEx1}}\label{Example1X2}
\end{figure}

The instructions in SAGE for create these graphs area

\begin{verbatim}
 sage: X3=Graph([(1, 7), (1, 10), (2, 3), (2, 4), (3, 4),(4, 9), 
       (5,6),(6, 8), (7, 8), (7, 9),(8, 9)])
 sage: X4=Graph([(2, 3), (2, 10), (1, 7), (1, 4), (7, 4),(4, 9), 
       (5, 6),(6, 8), (3, 8), (3, 9),(8, 9)])
\end{verbatim}

Finally, we test if they are isomorphic: 

\begin{verbatim}
 sage: Isomorphism(X3,X4,10,Iso=True)
1 --> 2
2 --> 1
3 --> 7
4 --> 4
5 --> 5
6 --> 6
7 --> 3
8 --> 8
9 --> 9
10 --> 10
True
\end{verbatim}

Obviously, this produces  an isomorphism between  and .
\end{example}

\begin{example}\label{ImpTestEx2}

In the following  example we will check two graphs which  are not isomorphic. Figure \ref{Example2X1} and \ref{Example2X2} shows the two graphs 
 to be checked.
\begin{figure}
\centering
 \includegraphics[scale=0.5]{graphics/Example2X1.png}
 \caption{The first graph of Example \ref{ImpTestEx2}}\label{Example2X1}
\end{figure}

\begin{figure}
\centering
\includegraphics[scale=0.5]{graphics/Example2X2.png}
 \caption{The second graph of Example \ref{ImpTestEx2}}\label{Example2X2}
\end{figure}

The instructions in SAGE for create this graphs area
\begin{verbatim}
sage: X1=Graph([(1, 7), (1, 8), (1, 10), (2, 3), (3, 6),
      (4, 5), (5, 6), (6, 10), (7,9), (7, 10), (8, 9)])
sage: X2=Graph([(1, 7), (1, 9), (2, 3), (2, 5), (2, 10), 
      (4, 5), (4, 6), (4, 10), (6,8), (7, 8), (7, 10)])
sage: Isomorphism(X1,X2,10)
False  
\end{verbatim}

\end{example}

Now,  we will present some graphics of different time tests. The first graphic, Figure \ref{Graphic1}, shows the time expend by the 
algorithm to test if two random graphs are isomorphic. The times are so small because if we take two random graphs probably will 
take a different number of edges. Although in the major part of the example the algorithm ends because the graphs have a different 
time of edges, sometimes the algorithm enters in the loop, and in this case the algorithm is relatively efficient.
\begin{figure}
\centering
\includegraphics[scale=0.5]{graphics/Random0500.png}
\caption{Relation seconds-nodes with random graphs}\label{Graphic1}
\end{figure}

To make the graphs more similar, we perform another test. In this example the degree of the first  nodes are the same and the last is 
chosen randomly, this way a third part of the graphs will be isomorphic. In this case,  we also have reasonable times and  the relation 
time-nodes can be seen in Figure \ref{Graphic2} and Figure \ref{Graphic3}

\begin{figure}
\centering
\includegraphics[scale=0.5]{graphics/PseudoRandom0500.png}
\caption{Relation seconds-nodes with semirandom graphs}\label{Graphic2}
\end{figure}


\begin{figure}
\centering
\includegraphics[scale=0.5]{graphics/PseudoRandom0500Ymax2.png}
\caption{Relation seconds-nodes with semirandom graphs, with less than 2 seconds}\label{Graphic3}
\end{figure}

Finally, we will  show what happens if we test isomorphic graphs. In this case the time grows, but we can see in Figure \ref{Graphic4} 
that the time grows more slowly than . The Figure \ref{Graphic4} shows the comparison between the algorithm and the 
functions 

\begin{figure}
\centering
\includegraphics[scale=0.5]{graphics/IsoGraphs.png}
\caption{Comparison between the algorithm and the functions  }\label{Graphic4}
\end{figure}

\appendix


\include{n3logn-module}

\chapter*{Sumario}
\addcontentsline{toc}{chapter}{Sumario}

En este trabajo haremos un estudio teórico de un algoritmo para isomorfismo de grafos de valencia acotado propuesto por Eugene 
M. Luks(1982) y una implementación en el sistema SAGE de dicho algoritmo para el caso de valencia 3. 

Este trabajo tiene 4 partes claramente diferenciadas, a saber:
\begin{enumerate}
 \item Preliminares
 \item Algoritmos previos
 \item Algoritmo principal
 \item Pruebas de la implementación
\end{enumerate}

\section*{Preliminares}
En los preliminares tenemos 3 partes: teoría de grupos, teoría de grafos y teoría de la complejidad.

En la primera  presentamos las definiciones básicas de teoría de grupos centrandonos en el grupo de permutaciones, así 
definiciones importantes que se ven son \emph{orbita}, \emph{transitividad}, \emph{G-block} y \emph{G-block system}.

En la segunda, las  definiciones básicas de teoría de grafos, como por ejemplo que és un isomorfismo entre grafos, 
también presentamos algunos resultados, como por ejemplo  que el conjunto de automorfismos de un grafo forman un grupo. 

Finalmente en la tercera y última parte mostraremos conceptos generales  sobre complejidad,  algoritmos polinomiales y una idea intuitiva 
de reducibilidad.

\section*{Algoritmos previos}
En este capítulo presentamos dos tipos de algoritmos, primero veremos algoritmos que se basan en teoría de grupos y luego  
otros dentro de la teoría de grafos.

\subsection*{Algoritmos básicos en teoría de grupos}
Lo más importante y destacable  son los dos lemas siguientes:

\begin{lema}[Furst-Hopcroft-Luks]
Dado un conjunto de generadores para un subgrupo  de  se puede determinar en tiempo polinómico
\begin{enumerate}
 \item El orden de .
 \item Saber si una permutación  pertenece a .
 \item Los generadores de un subgrupo de  que sabemos que el índice en  tiene una cota polinomial y,  tenemos un test de 
 pertenencia que se puede ejecutar en tiempo polinomial.
\end{enumerate}
\end{lema}

\begin{lema}
 Dado  un conjunto de generadores para un subgrupo  de  y una orbita , se puede determinar en tiempo polinomial, 
un block system minimal en . 
\end{lema}

Con el primer lema obtenemos el Algoritmo \ref{alg1} y,  con el segundo obtenemos el Algoritmo \ref{alg2}, que serán importantes en 
el algoritmo principal.

\begin{algorithm}\label{alg1}\hypertarget{alg1}{}
 
\KwData{}
\KwResult{Add  to his }
\Begin{
\For{}{
    \If{}{
	  
	}
     \Else{ add  to  \\
	    \Return{}
      }
}

\Return{}
}
\caption{Filter}

\end{algorithm}


\begin{algorithm}\label{alg2}\hypertarget{alg2}{}
\KwData{, }
\KwResult{The smallest block which contains }
\Begin{
 \\
Set  \\
Add  to  \\
Set  \\
\While{ is nonempty}{
Delete  from  \\
\\
 \\
\While{}{
 \\
 \\
 \\
\If{}{
Ensure  by interchanging  and  if necessary. \\
\For{ }{
      Set 
}
Add  to .
}
}
}
\Return{C}
}
\caption{Smallest block which contains }
\end{algorithm}

\subsection*{Algoritmos básicos en teoría de grafos}
En esta parte se muestra un ejemplo ilustrando que no siempre es un problema complicado el saber si dos grafos son isomorfos. Para 
Mostramos un algoritmo que es  para el isomorfismo de arboles filogenéticos, este  lo presentamos  en Algoritmo \ref{alg3}


\begin{algorithm}\label{alg3}\hypertarget{alg3}{}
 
\KwData{}
\KwResult{Test if  and  are isomorphic}
\SetKwFunction{PostOrderIterator}{PostOrderIterator}
\SetKwFunction{parent}{parent}
\Begin{
Set  \\
Nodes  \PostOrderIterator{} \\
 \\
\While{Nodes.hasNext()}{
    \If{  is not a leaf}{
	\If{ none}{
	       child of  \\
	      Set  
	    }
	  \For{  child of }{
	      \If{ \parent{}}{
		  \Return{False}
		  }
	      }
      }
}

\Return{}
}
\caption{PhylogeneticTreeIsomorphism}
\end{algorithm}

\section*{Algoritmo principal}
En este capítulo veremos el algoritmo principal. La idea general se muestra  en el Algoritmo \ref{alg4}.

\begin{algorithm}\label{alg4}\hypertarget{alg4}{}
\KwData{ connected graphs of bounded valence}
\KwResult{Test if  and  are isomorphic}
\SetKwFunction{BuildX}{BuildX}
\SetKwFunction{Aut}{Aut}
\Begin{
 \\
\For{}{
	 \BuildX{}\\
	 \Aut() \\
	\For{ }{
	    \If{ }{
		\Return{ True}
	    }
	}
    }

\Return{False}
}
\caption{Isomorphism of graphs of bounded valence}

\end{algorithm}

La estructura de este capítulo esta dividida como sigue:
\begin{itemize}
 \item Valencia 3.
 \item Estudio de la complejidad para el caso de valencia 3.
 \item Mejoras para la implementación.
 \item Generalización al caso general
\end{itemize}
\subsection*{Valencia 3}
En esta parte mostramos como funciona el algoritmo cuando los grafos tienen valencia 3. Para eso,   calculamos  el 
grupo de automorfismos de un grafo, con este fin computamos  una sucesión de grafos y creamos una serie de homomorfismos entre 
los grupos de automorfismos de esa sucesión de grafos. Aqui usaremos el Algoritmo \ref{alg5} y obtendremos la sucesión de 
automorfismos que queríamos.

\begin{algorithm}\label{alg5}\hypertarget{alg5}{}
\KwData{A sequence of graphs , whose are the result of \texttt{BuildX}}
\KwResult{ where  is the last graph in the sequence}
\SetKwFunction{Ker}{Ker}
\SetKwFunction{Image}{Image}
\SetKwFunction{Pullback}{Pullback}
\Begin{

\For{}{
	 \Ker()\\
	 \Image() \\
	 \Pullback()\\
	
    }
\Return{}
}
\caption{The group }

\end{algorithm}
 
 \subsection*{Estudio de la complejidad}
 En esta parte mostramos de manera más detallada que el algoritmo anterior es polinómico y, que  es una 
 cota superior del coste de dicho algoritmo.
 
 \subsection*{Mejora para la implementación}
Dedicamos esta parte al  estudio de mejoras en vistas de la implementación, estas mejoras serán:
 
 \begin{itemize}
  \item Reducir el tamaño de .
  \item Representar los grupos mediante SGS.
  \item Precomputar los bloques.
  \item Otras mejoras.
 \end{itemize}
Con estas mejoras conseguiremos que el algoritmo sea , en el peor de los casos.

\subsection*{Caso general}
Finalmente veremos que para el caso general lo único que necesitamos es comprobar que el núcleo de los homomorfismos sigue 
siendo un 2-grupo y, por lo tanto podremos aplicar todo lo demás, adaptándolo para cada valencia.

\section*{Pruebas de la implementación}
Finalmente presentamos  algunos tests realizados con la implementación en el sistema SAGE, con estos 
mostramos  que la cota  superior de   no se alcanza y,  que en el caso medio el algoritmo tiene un coste, 
informalmente,  entre   y . 

El apéndice mostramos la documentación de la implementación, aunque se recomienda al lector  
 visitar la pagina {\it http:// www.alumnos.unican.es/aam35/sage-epydoc/index.html} donde hay una  detallada documentación 
en HTML  mucho más fácil y ágil de usar.
\nocite{*}





\bibliography{bibliografia}{}
\bibliographystyle{plain}

\printindex
\end{document}