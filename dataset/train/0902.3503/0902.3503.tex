\documentclass{llncs}
\usepackage{llncsdoc}
\usepackage{amsmath, amssymb}
\usepackage{amscd,amsfonts,amssymb, color}
\usepackage{latexsym, graphicx, pstricks}
\newtheorem{prop}{Proposition}
\newtheorem{defin}{Definition}
\newtheorem{rem}{Remark}
\newtheorem{lem}{Lemma}
\setlength{\oddsidemargin}{0pt}
\setlength{\evensidemargin}{0pt}
\setlength{\textwidth}{6.7in}
\setlength{\topmargin}{-0.3in}
\setlength{\textheight}{9in}
\long\def\symbolfootnote[#1]#2{\begingroup \def\thefootnote{\fnsymbol{footnote}}\footnote[#1]{#2}\endgroup}
\newcommand{\mr}{\mathrm}
\newcommand{\sa}{crossover~}
\newcommand{\sae}{crossover~}
\newcommand{\sg}{\Sigma}
\newcommand{\reg}{}
\newcommand{\ve}{\varepsilon}
\newcommand{\h}{}
\newcommand{\cd}{\cdot}
\newcommand{\p}{\mathrm{Prefix}}
\newcommand{\s}{\mathrm{Suffix}}
\newcommand{\sub}{\mathrm{sub}}
\newcommand{\rs}{\hspace{-3.5mm}-\hspace{-2mm}<}
\newcommand{\ers}{>\hspace{-2mm}-\hspace{-2mm}<}
\begin{document}
\title{ Generalised sequential crossover of words and languages}
\author{L Jeganathan \and R Rama \and Ritabrata Sengupta}
\institute{Department of Mathematics\\ Indian Institute of Technology
\\Chennai 600 036, India\\ {\tt lj, ramar, rits@iitm.ac.in}}
\maketitle
\begin{abstract}
In this paper, we propose a new operation, Generalised Sequential
Crossover (GSCO) of words, which in some sense an abstract model of
crossing over of the chromosomes  in the living organisms. We extend
GSCO over language  iteratively ( as well as iterated
GSCO over two languages ). Our study reveals that
 is subclass of regular languages for any . We compare
the different classes of GSCO languages with the prominent
sub-regular classes. \end{abstract}
\section{Introduction}

\par Self-assembly is a process in which smaller objects selectively
aggregate with each other into a complex structure, which in turn
self assemble into larger aggregates. It is a process wide spread in
nature - atoms self assemble into molecules, molecules into
crystals, cells into
 tissues, etc. It is an important tool  in nano-technology, since it takes
 nature as a model and tries to assemble structures from the atomic level
 (bottom-up approach). Self-assembly is considered as a promising technique
 in nano-technology, enabling the fabrication of small complex objects - such
 as computer circuits.

\par A particular case of self assembly is that of a linear self assembly,
 in which one dimensional objects such as DNA double strands interact with
  each other to form  longer strands. DNA recombination is  one such DNA
   self assembly by which Adleman solved an instance of Hamiltonian path
   problem \cite{Ad}. For more than a decade now, self assembly is the
   core of most experiments in DNA computing starting with the celebrated
   experiment of Adleman \cite{Ad,FCL,OK}. Recent developments in DNA computing
    have highlighted the intimate connection between self assembly and computation.
     Computational utilities of DNA self  assembly is studied in \cite{Win}.

\par Most complexity    theoretic studies of self assembly utilise mathematical models.
  Some alternate models, like self assembly of the objects by the use
  of capillary force, electrostatic force, and magnetic force were also studied.

\par In recent years, one can see convergent interests  in the study of
self assembly from Mathematics, Computer science, Physics,
Chemistry, and Biology point of view.
 Yet the mechanisms of these processes are so far little understood and
 pose a formidable challenge. Attempts were made to study   the self assembly
 in different frameworks like `tile based self-assembly' \cite{BW,L,Win,Win1,Win2}.
 Perhaps the best model for self assembly was proposed by \cite{Win2}.
 With an aim of making the process of self assembly more clear, studies
 of abstract models,  such as self assembly of strings was initiated
 \cite{CPV}. In \cite{bot} authors introduce an operation among strings
 and languages, called ``superposition'', which is similar to the
 Csuhaj-Varj\'{u}'s operation called self assembly on strings, but
 their approaches are different.

\par Inspired by the different models of self-assembly, in particular the string
self assembly of Csuhaj-Varj\'{u} \cite{CPV}, we planned to propose
a string based operation which may be a generalisation of
self-assembly operation proposed in  Csuhaj-Varj\'{u}'s paper
\cite{CPV}.  In Csuhaj-Varj\'{u}'s model, two strings  and 
self assemble over  and generate . Here  is the
overlapping string. Then comes the question : What will be the
process if we do not restrict the overlapping
 string to be in the end of the first string and in the beginning of the second string.
 As an answer to the above question we propose a new operation on two strings.
 Two strings 
  and  self assemble over the substring  (also called
  overlapping string, )
    and generate the strings  and  as illustrated
    in figure \ref{eqi}.
\begin{figure}[h]
\begin{center}
\setlength{\unitlength}{2mm}
\begin{picture}(14,10)(-7,-5)
\put(-4,0){\line(1,0){8}}
\put(-6,4){\line(1,-2){2}}
\put(-6,-4){\line(1,2){2}}
\put(6,4){\line(-1,-2){2}}
\put(6,-4){\line(-1,2){2}}
\put(-7,-4.3){}
\put(-7,4.3){}
\put(6.2,-4.3){}
\put(6.2,4.3){}
\put(-0.5,0.5){}
\put(-4,4){}
\put(-4,-4.5){}
\end{picture}
\end{center}
\caption{A scheme for \sa of two strings}
\label{eqi}
\end{figure}

Normally, in any self-assembly process, no portion of the components
(that take part in the self-assembly) should be lost.  In that
sense, our new operation on strings (where some portions of the
strings are lost) can no longer be called as the abstraction of the
self-assembly process.
\par
But, our operation resembles in one sense, the recombination process
of chromosomes by exchanging the segments between homologous
chromosomes, called crossing-over. A chromosome is a single piece of
DNA that contains many genes, regulatory elements and other
nucleotide sequences.  Each gene occupies a well-defined site or
locus in its chromosome, having corresponding locations in the pair
of homologous chromosomes.  Chromosomal cross over (or crossing
over)is the process by which two chromosomes pair up and exchange
their DNA.Crossover usually occurs when matching regions on matching
chromosomes (homologous chromosomes) break and then reconnect to the
other chromosomes.  The result of this process is an exchange of
genes, called genetic recombination, which leads to the genetic
variability.  Crossover can occur at one or more points along the
adjacent chromosomes.
\par
In \cite{mitrana1}, an operation on strings and languages having the
same feature is introduced.  Every chromosome is considered as a
string.  The operation is applicable to a pair of strings of equal
length as the crossing over is between the homologous chromosomes.
\par
Each string is cut in several fragments, but in the sites for both
of them and crossing these fragments by ligases.  A new string, of
the same length, is formed by starting at the left end of one
parent, copying a segment, crossing over to the next site in the
other parent, copying a substring, crossing back to the first parent
and so on until the right end of one parent is reached.  Obviously,
another new string can be obtained by starting with the other
parent.  This crossover operation \cite{mitrana1} among the strings
is similar to the chromosome crossing-over.  A generalisation of the
splicing system is proposed in \cite{mitrana2}.
\par
Our proposal, two strings 
  and  overlap at  the substring 
    and generate the strings  and , differs with
    the cross-over operation in two aspects. First, in our model,
    words of different lengths can participate in a crossover.
    Second, crossing over occurs at only one site between the words.
     For these reasons, we call our operation as
     {\em Generalised Sequential Cross Over (GCSO)}.  We use the
     adjective {\it generalised} in the sense that crossover can
     occur between any two words of any length and the adjective
     {\it sequential} in the sense that the crossover occurs between
     any two words at only one point(site) in contrary to the
     occurrence at one or more points between the chromosomes.


\par Any two strings may share more than one common overlap and so the result of GSCO
 of two strings is in general a set of strings. As usual in formal language theory,
  we extend GSCO to a language, iterated version of GSCO over a language.

\par Our study answers several questions in the sense of nano-scale fabrication;
like - can we decide if a given language can be obtained by iterated
GSCO and if so
 can we effectively construct a minimal finite set of initial strings. Given such
 a finite set of strings, what language can be generated by the
 GSCO?

\par Though the operation GSCO is just an abstraction of the  \sa operation introduced
 in \cite{mitrana1}, our study reveals many interesting results such as: iterated GSCO
  of any
 language will always be regular, and a subclass of GSCO languages matches exactly with
 the strictly locally testable
 language(SLT) \cite{Mc} leading to a new characterisation of SLT language using
 iterated GSCO.

\par Section 2 deals with the preliminaries required for this paper.
Section 3 introduces the GSCO operation on words and languages along
with some basic results. Section 4 discusses a variant of GSCO.
Section 4 shows that the operations 1-GSCO and 2-GSCO over a
language  are the same. Two types of iterations are defined for
GSCO and their equivalence is discussed in section 5. Section 6
discusses the regularity of GSCO languages. Section 7 compares the
GSCO languages with the other regular subclasses.
\section{Preliminaries}
\par Throughout this paper, we assume that the reader is familiar with
the fundamental concepts of formal language theory and automata, i.e.
 notations of grammar and finite automata \cite{HMU}.
We list here some notations and notions we use in this paper.
\subsection{Basic notations  of formal language theory}
\par An alphabet is always a finite set of letters denoted by . The set of
all words over an alphabet  is denoted by . The empty
word is denoted by . Further . Given
a word , the number of
 symbols in  is the length of the word and is denoted by . A word 
  is a sub-word (in literature, it is also called as {\it factor}) of  a word
    if there are words  and  (possibly empty) such that .
     is called prefix  of  () if . Similarly  is called the
     suffix of  () if .   and
     . The notation  means the set of
     symbols of  that
occurs in the word .   means the word  which is a sub-string
 of a word .  is the number of occurrence of  in .
  For a fixed  (which is a sub-string of ), 
  is the total number of the occurrence of  to the right of .
  We define a function  over the  such that,


The class of regular language is defined by REG. Every finite automaton
induces a right invariant equivalence relation defined on the set of input
 strings which is formalised in the following theorem (see \cite{HMU})

\begin{theorem}[Myhill-Nerode]
The following statements are equivalent.
\begin{enumerate}
\item The set  is accepted by some finite automaton.
\item  is the union of some of the equivalence classes of a right
invariant equivalence relation of finite index.
\item Let equivalence relation  be defined by  if and only if
  exactly when . Then  is of finite index.
\end{enumerate}
\end{theorem}
\subsection{Splicing}
\par A splicing rule (over alphabet ) is a quadruple 
of words   which is often written as
follows: u_3\#u_4\#\\sigma(L)=\{w_1,w_2\in\sg^*|x,y\in L,~r\in R,~ (x,y)\vdash_r w_1,w_2\}
&\sigma^0(L)=L\\
&\sigma^{i+1}(L)=\sigma^i(L)\cup\sigma(\sigma^i(L))\\
&\sigma^*(L)=\bigcup_{i\geq0}\sigma^i(L)
GSCO_x(w_1,w_2)=\{u_1xv_2,u_2xv_1\in\sg^*:  w_1=u_1xv_1, w_2=u_2xv_2,~
\ve\neq x\in R\}.GSCO_R(w_1,w_2)=\bigcup_{x\in R}w_1>^x\rs w_2.GSCO(w_1,w_2)= \bigcup_x GSCO_x(w_1,w_2),~~~~x\in\sub(w_1)\cap\sub(w_2).GSCO_\ve(w_1,w_2)=\mathrm{Pref}(w_1).\mathrm{Suff}(w_2)\cup \mathrm{Pref}(w_2).
\mathrm{Suff}(w_1).GSCO_R(L_1,L_2)=\bigcup_{\substack{w_1\in L_1\\w_2\in L_2}}GSCO_R(w_1,w_2).L_1L_2GSCO_R(L_1,L_2)=\bigcup_{\substack{w_1\in L_1\\w_2\in L_2}}GSCO(w_1,w_2).GSCO(L,L)GSCO(L)GSCO(L_1\cup L_2)=GSCO(L_1)\cup GSCO(L_2)\cup GSCO(L_1,L_2).GSCO_x(w_1,w_2)\subseteq GSCO_{a\in\sg_x}(w_1,w_2).u\in GSCO_{a_i}(w_1,w_2),i\in\{1,2,\cdots,n\}~\Rightarrow ~u\in
GSCO_{a\in\sg_x}(w_1,w_2). GSCO_{a\in\sg_x}(w_1,w_2)\not\subseteq GSCO_{x}(w_1,w_2).
ab \ers ab &=\{ab\} &ab\ers ba &=\{a,b,bab,aba\}\\
ab\ers bb &=\{ab,bb,b,abb\} &ba\ers bb &=\{b,bb,ba,bba\}\\
ba\ers ba &=\{ba\} &bb\ers bb &=\{bb\}.
GSCO(L)=\{a,b,ab,ba,bb,aba,bab,abb,bba\}.GSCO(L)=  \bigcup_{w_1,w_2\in L}~\bigcup_xGSCO(w_1,w_2),\hspace{3mm}x\in
\sub(w_1)\cap\sub(w_2)
,GSCO(w_1,w_2)=\bigcup_{a\in\sg_{w_1}\cap\sg_{w_2}}GSCO_a(w_1,w_2).GSCO(w_1,w_2)= \bigcup_{x\in\sub(w_1)\cap\sub(w_2)} GSCO_x(w_1,w_2), \bigcup_{x\in\sub(w_1)\cap\sub(w_2)} GSCO_x(w_1,w_2)=\bigcup_{a\in\sg_{w_1}
\cap\sg_{w_2}}GSCO_a(w_1,w_2).GSCO_{\sg_{w_1}\cap\sg_{w_2}}(w_1,w_2)\subseteq
GSCO_{\sub(w_1)\cap\sub(w_2)}(w_1,w_2). \bigcup_{a\in\sg_{w_1}\cap\sg_{w_2}} GSCO_a(w_1,w_2)
\subseteq\bigcup_{x\in\sub(w_1)\cap\sub(w_2)}GSCO_x (w_1,w_2).GSCO_x(w_1,w_2)\subseteq GSCO_{a\in\sg_{w_1}\cap\sg_{w_2}}(w_1,w_2).\Rightarrow \bigcup_{x\in\sub(w_1)\cap\sub(w_2)}GSCO_x(w_1,w_2)
\subseteq \bigcup_{a\in\sg_{w_1}\cap \sg_{w_2}}GSCO_a(w_1,w_2).\bigcup_{a\in\sg_{w_1}\cap\sg_{w_2}}GSCO_a(w_1,w_2)=\bigcup_{a\in\sg}GSCO_a(w_1,w_2).\label{e1}
\sg=(\sg_{w_1}\cap\sg_{w_2})\cup A,

\bigcup_{a\in
A}GSCO(w_1,w_2)=\bigcup_{a\notin\sg_{w_1}\cap\sg_{w_2}}GSCO(w_1,w_2)=\emptyset.

\bigcup_{a\in\sg}GSCO_a(w_1,w_2)&=&\big(\bigcup_{a\in\sg_{w_1}\cap\sg_{w_2}}
GSCO(w_1,w_2)\big)\bigcup\big(\bigcup_{a\in A}GSCO_{a\in A}(w_1,w_2)\big)\\
\Rightarrow\bigcup_{a\in\sg}GSCO_a(w_1,w_2)&=&\bigcup_{a\in\sg_{w_1}\cap
\sg_{w_2}}GSCO(w_1,w_2)\big).

GSCO(L)&=&\bigcup_{w_1,w_2\in L}GSCO(w_1,w_2)\\
    &=&\bigcup_{w_1,w_2\in L}\bigcup_{a\in\sg}GSCO_a(w_1,w_2).
GSCO_x(w_1,w_2)\subseteq GSCO_{a\in\sg_x}(w_1,w_2).GSCO(w_1,w_2)=\bigcup_x GSCO_{a\in\sg_x}(w_1,w_2),GSCO_x(w_1,w_2)=\bigcup GSCO_{a|x}(w_1,w_2)\label{m1}
GSCO_x(w_1,w_2)=\{u_1xv_2xv_3\cdots xv_{n+1},v_1xu_2xu_3\cdots
xu_{n+1};
        \cdots;u_1xu_2xv_3\cdots u_n xv_{n+1},v_1xv_2xv_3\cdots v_nxu_{n+1}\}.

 CGSCO_{a|x}(w_1,w_2)&=&CGSCO_{a|x}(u_1a_1\cdots a_ku_2x\cdots xu_{n+1},v_1a_1\cdots a_kv_2x\cdots xv_{n+1})\\
        &=&\{u_1a_1\cdots a_la_{l+1}a_kv_2x\cdots xv_{n+1},v_1a_1\cdots a_la_{l+1}a_ku_2x\cdots xu_{n+1}\}\\
        &=&\{u_1xv_2x\cdots xv_{n+1},v_1xu_2x\cdots xu_{n+1}.\}

 CGSCO_{a|x}(w_1,w_2)&=&CGSCO_{a|x}(u_1a_1\cdots a_ku_2x\cdots xu_{n+1},v_1a_1\cdots a_kv_2x\cdots xv_{n+1})\\
        &=&\{u_1a_1\cdots a_ja_{j+1}a_kv_2x\cdots xv_{n+1},v_1a_1\cdots a_ja_{j+1}a_ku_2x\cdots xu_{n+1}\}\\
        &=&\{u_1xv_2x\cdots xv_{n+1},v_1xu_2x\cdots xu_{n+1}.\}
GSCO_{a|x}(w_1,w_2)=\{u_1xu_2xv_3\cdots xv_{n+1},v_1xv_2xu_3\cdots xu_{n+1}\}.GSCO_{a|x}(w_1,w_2)=\{u_1xu_2x\cdots u_ixv_{i+1}\cdots xv_{n+1},v_1xv_2x\cdots v_i\cdots xu_{i+1}\cdots xu_{n+1}\}~\mbox{where~}I(x_{w_1})=I(x_{w_2})=2.\label{m2}
\begin{split}
\bigcup_{\substack{I{w_1}(x)=I_{w_2}(x)\\=1}}^jGSCO_{a|x}(w_1,w_2) & =\{u_1xu_2x\cdots u_jxv_{j+1}\cdots xv_{n+1},\\
    & \quad v_1xv_2x\cdots v_j\cdots xu_{j+1}\cdots xu_{n+1}: j=1,2,\cdots \min\{|w_1|_x,|w_2|_x\}\}.
\end{split}
GSCO_x(w_1,w_2)=\bigcup_{\substack{I(x_{w_1})=I(x_{w_2})\\=2}}^jGSCO_{a:x}(w_1,w_2),\label{m3}
u_1xv_4xv_5\cdots v_{n+1},v_1xv_2xv_3xu_2xu_3\cdots u_{n+1}\in
GSCO_x(w_1,w_2).
\label{m4}
u_1xv_4xv_5\cdots v_{n+1},v_1xv_2xv_3xu_2xu_3\cdots u_{n+1}\notin
\bigcup_{\substack{I{w_1}(x)=I_{w_2}(x)\\=1}}^jGSCO_{a|x}(w_1,w_2).
u_1xv_2
1GSCO(L)&=&\bigcup_{w_1,w_2\in L}1GSCO(\{w_1,w_2\})\\
    &=&\bigcup_{w_1,w_2\in L}\big(1GSCO(w_1,w_2)\cup1GSCO(w_2,w_2)\cup1GSCO(w_1,w_1)\cup1GSCO(w_2,w_2)\big)\\
    &=&\bigcup_{w_1,w_2\in L}\big(2GSCO(w_1,w_2)\cup2GSCO(w_1,w_1)\cup2GSCO(w_2,w_2) \big)\\
    &=&\bigcup_{w_1,w_2\in L}2GSCO(\{w_1,w_2\})\\
    &=&2GSCO(L).

uGSCO^0(L)&=&L\\
uGSCO^{i+1}(L)&=&uGSCO^{i}(L)\cup uGSCO(uGSCO^i(L))\\
uGSCO^*(L)&=&\bigcup_{i\geq0}uGSCO^{i}(L)

\p_x(w)&=&\{u:uxu'=w;~u,u'\in\sg^*\}\\
\s_x(w)&=&\{s:s'xs=w;~s,s'\in\sg^*\}\\
\p_x(L)&=&\bigcup_{w\in L}\p_x(w)\\
\s_x(L)&=&\bigcup_{w\in L}\s_x(w).
w_1>_1^x\rs w_2=\p_x(w_1)\cdot x\cdot\s_x(w_2).\p_x(\s_x(w))=\s_x(\p_x(w)).
&&u\in\s_x(\p_x(w)).\\
\Leftrightarrow&&\exists u'\in \sg^*~\mbox{such that~}u'xu\in\p_x(w)\\
\Leftrightarrow&&\exists u''\in \sg^*~\mbox{such that~}u'xuxu''=w\\
\Leftrightarrow&&uxu''\in\s_x(w)\\
\Leftrightarrow&&u\in\p_x(\s_x(w)).
 (w_1>_1^x\rs w_2)>_1^x\rs w_3=w_1>_1^x\rs (w_2>_1^x\rs w_3);
w_1>_1^x\rs w_2=\p_x(w_1)\cd x\cd\s_x(w_2).
\label{m5}
(w_1>_1^x\rs w_2)>_1^x\rs w_3 &=& [\p_x(w_1)\cd x\cd\s_x(w_2)]>_1^x\rs w_3\nonumber\\
    &=& \p_x[\p_x(w_1)\cd x\cd\s_x(w_2)]\cd x\cd \s_x(w_3)\nonumber \\
    &=& [(\p_x(\p_x(w_1)\cdot x))\cup
    (\p_x(w_1)\cd x\cd\p_x(\s_x(w_2)))]\cd x\cd \s_x(w_3)\nonumber\\
    &=& [\p_x(w_1)\cup \p_x(w_1)\cd x\cd\p_x(\s_x(w_2))]\cd x\cd \s_x(w_3)\nonumber\\
    && \hspace{1in}[\mbox{form definition it follows that .}]\nonumber\\
    &=& \p_x(w_1)\cd x\cd \s_x(w_3)\cup\p_x(w_1)\cd x\cd\p_x(\s_x(w_2))\cd x\cd \s_x(w_3)\nonumber\\
    &&
w_2>_1^x\rs w_3=\p_x(w_2)\cd x\cd \s_x(w_3).\label{m6}
w_1>_1^x\rs (w_2>_1^x\rs w_3) &=& \p_x(w_1)\cd x\cd\s_x[\p_x(w_2)\cd x\cd \s_x(w_3)]\nonumber\\
    &=& \p_x(w_1)\cd x\cd[\s_x(\p_x(w_2))\cd x\cd \s_x(w_3)\cup(\s_x(x\cdot\s_x(w_3)))]\nonumber \\
    &=& \p_x(w_1)\cd x\cd \s_x(\p_x(w_2))\cd x\cd\s_x(w_3)\cup\p_x(w_1)\cd x\cd \s_x(w_3)\nonumber\\
    && \hspace{1in}[\mbox{form definition it follows that .}]\nonumber\\
    &=& \p_x(w_1)\cd x\cd \p_x(\s_x(w_2))\cd x\cd\s_x(w_3)\cup\p_x(w_1)\cd x\cd \s_x(w_3)\nonumber \\
    &&\hspace{1in}\mbox{from the previous lemma}
(w_1>_1^x\rs w_2)>_1^x\rs w_3=w_1>_1^x\rs (w_2>_1^x\rs w_3).  (w_1>_1^x\rs w_2)>_1^x\rs w_3=w_1>_1^x\rs (w_2>_1^x\rs w_3)=w_1>_1^x\rs w_2>_1^x\rs w_3.L_1>_1^x\rs(L_2>_1^x\rs L_3)=(L_1>_1^x\rs L_2)>_1^x\rs L_3.L_1>_1^x\rs L_2=\bigcup_{\substack{w_1\in L_1\\w_2\in L_2}} (w_1>_1^x\rs w_2).w\in w^0>^x\rs w^1>^x\rs\cdots>^x\rs w^n.
w'\in w_0'>^x\rs w_1'>^x\rs\cdots>^x\rs w_{2^n-1}'\hspace{1in}w_0',w_1',\cdots w_{2^n-1}'\in L\\
w''\in w_0''>^x\rs w_1''>^x\rs\cdots>^x\rs
w_{2^n-1}''\hspace{1in}w_0'',w_1'',\cdots w_{2^n-1}''\in L.
 w\in(w_0'>^x\rs w_1'>^x\rs\cdots>^x\rs w_{2^n-1}')>^x\rs(w_0''>^x\rs w_1''>^x\rs\cdots>^x\rs w_{2^n-1}''). w\in w_0'>^x\rs w_1'>^x\rs\cdots>^x\rs w_{2^n-1}'>^x\rs w_0''>^x\rs w_1''>^x\rs\cdots>^x\rs w_{2^n-1}''.\bigcup_{a,b\in\sg}\big(w_1>^a\rs(w_2>^b\rs w_3)\big)=\bigcup_{a,b\in\sg}\big((w_1>^a\rs w_2)>^b\rs w_3\big).
w_2>^b\rs w_3&=&\p_b(w_2)\cd b\cd \s_b(w_3),\\
w_1>^a\rs w_2&=&\p_a(w_1)\cd a\cd \s_a(w_2).
\label{as1}
w_1>^a\rs(w_2>^b\rs w_3)&=&w_1>^a\rs(\p_b(w_2)\cd b\cd \s_b(w_3))\nonumber\\
        &=&\p_a(w_1)\cd a\cd\s_a\p_b(w_2)\cd b\cd\s_b(w_3) \nonumber\\      &&\cup~ \p_a(w_1)\cd a\cd\s_a\s_b(w_3).
\label{as2}
(w_1>^a\rs w_2)>^b\rs w_3&=&(\p_a(w_1)\cd a\s_a(w_2))>^b\rs w_3\nonumber\\
        &=&\p_a(w_1)\cd a\cd\p_b\s_a(w_2)\cd b\cd\s_b(w_3)\nonumber\\
        &&\cup~\p_b\p_a(w_1)\cd b\cd\s_b(w_3).

\big(\bigcup_{a=b}w_1>^a\rs(w_2>^b\rs w_3)\big)\bigcup\big( \bigcup_{a\neq b}w_1>^a\rs(w_2>^b\rs w_3)\big)=\\\big(\bigcup_{a=b}(w_1>^a\rs w_2)>^b\rs w_3\big)\bigcup\big(\bigcup_{a\neq b}(w_1>^a\rs w_2)>^b\rs w_3\big).
\label{as3}
\big(\bigcup_{a=b}w_1>^a\rs(w_2>^b\rs w_3)\big)\bigcup\big( \bigcup_{a\neq b}(\p_a(w_1)\cd a\cd\s_a\p_b(w_2)\cd b\cd\s_b(w_3)\\
\bigcup\p_a(w_1)\cd a\cd\s_a\s_b(w_3))\big)=\big(\bigcup_{a=b}(w_1>^a\rs w_2)>^b\rs w_3)\big)\bigcup\big( \bigcup_{a\neq b}(\p_b\p_a(w_1)\cd b\cd\s_b(w_3)
\\\bigcup\p_a(w_1)\cd a \cd\p_b\s_a(w_2)\cd b\cd\s_b(w_3))\big)

A &=&\bigcup_{a=b}w_1>^a\rs (w_2>^b\rs w_3)\\
    &=&\bigcup_a\{\p_a(w_1)\cd a\cd\s_a(w_3)\cup \p_a(w_1)\cd a\cd\s_a\p_a(w_2)\cd a\cd \s_a(w_3)\}

C &=&\bigcup_{a=b}(w_1>^a\rs w_2)>^b\rs w_3\\
    &=&\bigcup_a\{\p_a(w_1)\cd a\cd\s_a(w_3)\cup \p_a(w_1)\cd a\cd\p_a\s_a(w_2)\cd a\cd \s_a(w_3)\}

B_1&=&\bigcup_{a\neq  b}\p_a(w_1)\cd a\cd\s_a\p_b(w_2)\cd b\cd\s_b(w_3)\\
B_2&=&\bigcup_{a\neq  b} \p_a(w_1)\cd a\cd\s_a\s_b(w_3)

D_1&=&\bigcup_{a\neq  b}\p_a(w_1)\cd a\cd\p_b\s_a(w_2)\cd b\cd\s_b(w_3)\\
D_2&=&\bigcup_{a\neq  b}\p_b\p_a(w_1)\cd b\cd\s_b(w_3)
\label{as4}
A\cup B_1\cup B_2=C\cup D_1\cup D_2.

&& u\in\s_a(\s_b(w))\\
&\Rightarrow&\exists u'\in\sg^* \mbox{~such that~}u'au\in\s_b(w)\\
&\Rightarrow&\exists u''\in\sg^* \mbox{~such that~}u''bu'au=w\\
&\Rightarrow&w=(u''bu')au\\
&\Rightarrow&u\in\s_a(w).

 \p_a(w_1)\cd a\cd \s_a\s_b(w_3)&\subseteq&\p_a(w_1)\cd a\cd\s_a(w_3)\\
        &\subset&\p_a(w_1)\cd a\cd\s_a(w_3)\\
        &&\cup\p_a(w_1)\cd a\cd\s_a\p_a(w_2)\cd a\cd \s_a(w_3).
\label{as5}
A=C.
A\cup B_1=C\cup D_1.\p_b(\s_a(w))=\s_a(\p_b(w)).
&&u\in\p_b(\s_a(w)).\\
\Leftrightarrow&&\exists u'\in \sg^*~\mbox{such that~}ubu'\in\s_a(w)\\
\Leftrightarrow&&\exists u''\in \sg^*~\mbox{such that~}u''buau'=w\\
\Leftrightarrow&&u''au\in\p_b(w)\\
\Leftrightarrow&&u\in\s_a(\p_b(w)).
\label{as6}
B_1=D_1.
w_1>_1\rs(w_2>_1\rs w_3)=(w_1>_1\rs w_2)>_1\rs w_3.
w_1>_1\rs(w_2>_1\rs w_3)&=&w_1>_1\rs(\bigcup_{a\in\sg}w_2>_1^a\rs w_3)\\
        &=&\bigcup_{b\in\sg}w_1>_1^b\rs(\bigcup_{a\in\sg}w_2>_1^a\rs w_3)\\
        &=&\bigcup_{a,b\in\sg}w_1>_1^b\rs(w_2>_1^a\rs w_3).
 (w_1>_1\rs w_2)>_1\rs w_3=\bigcup_{a,b\in\sg}(w_1>_1^b\rs w_2)>_1^a\rs w_3.w\in1GSCO_x(1GSCO_x^j(L),L)
&&w\in w_1>^x\rs w_2>^x\ers\cdots w_n>^x\rs w_{n+1}\\
&&w\in (w_1>^x\rs w_2>^x\rs\cdots w_n)>^x\rs w_{n+1}\hspace{1in}\mbox{by associativity}\\
&\therefore&w\in1GSCO_x(w_1>^x\rs\cdots>^x\rs w_n,w_{n+1})\\
&\Rightarrow&w\in1GSCO_x(1GSCO_x^n(L),L).

rGSCO^0(L)&=&L\\
rGSCO^{i+1}(L)&=&rGSCO(rGSCO^i(L),L)\hspace{0.5in}i\geq1\\
rGSCO^*(L)&=&\bigcup_{i\geq0}rGSCO^i(L)
r1GSCO^*(L)\subseteq u1GSCO^*(L).u1GSCO^*(L)\subseteq r1GSCO^*(L).
&&w\in\big((\cdots((w_0\ers w_1)\ers(w_2\ers w_3))\ers\cdots\ers(w_{2^i-2}\ers w_{2^i-1}))\cdots)\big)\\
&\Rightarrow&w\in w_0\ers w_1\ers\cdots\ers w_{2^i-1}\hspace{1in}\mbox{Since  is associative}\\
&\Rightarrow&w\in \big(\cdots((w_0\ers w_1)\ers w_2)\ers\cdots w_{2^n-3})\ers w_{2^n-2}\big)\ers w_{2^n-1}\\
&\Rightarrow&w\in GSCO\big(\cdots GSCO(\cdots( GSCO(GSCO(GSCO(w_0,w_1),w_2),w_3)\cdots),w_{2^i-2}),w_{2^i-1}\big)\\
&\Rightarrow&w\in GSCO(\cdots(GSCO(GSCO(L),L)\cdots),L)\\
&\Rightarrow&w\in w\in r1GSCO^{2^i-1}(L).
GSCO^{n+1}(L)=GSCO(L,GSCO^n(L)).B(w)=\{u_1,u_2,\cdots,u_k:w\in GSCO^*(\{u_1,u_2,\cdots,u_k\})\}.
2B(w)=\{a_1a_2,a_2a_3,\cdots,a_{k-1}a_k\}. x R y~~ {\text iff~~}
2B(x)~=~2B(y); ~~\sg_{1} (x)~=~\sg_{1}(y);~~
\sg_{|x|}(x)~=~\sg_{|y|}(y). \symbolfootnote[1]{ is the
symbol in the  position of the word .}
 \label{bs}
2B(x)=2B(y);\hspace{1cm}\sg_{1}(x)=\sg_{1}(y);\hspace{1cm}
~~\sg_{|x|}(x)=\sg_{|y|}(y).
2B(xz)=2B(x)\cup\{\sg_{|x|}(x)\cd\sg_1(z)\}\cup2B(z).2B(yz)=2B(y)\cup\{\sg_{|y|}(y)\cd\sg_1(z)\}\cup2B(z).2B(xz)=2B(yz)~; \hspace{1cm} \sg_{1}(xz)=\sg_{1}(yz); \hspace{1cm} ~~~~~~~~
~\sg_{|x|+|z|}(xz)=\sg_{|y|+|z|}(yz),
GSCO^*(L) =  (\bigcup_{a \in GSCO^*(L) \cap \Sigma} \langle
a,\{a\},a\rangle ) \bigcup (\bigcup_{w \in GSCO^*(L) \cap \langle
s,2B,e\rangle } \langle s,2B,e\rangle). L = (GSCO^*(B)  \cap S \Sigma^* E)  \bigcup  (L \cap \Sigma) L = (GSCO^*(B)  \cap S \Sigma^* E)  \bigcup  (L \cap \Sigma) \sigma^*(A)=GSCO^*_R(L_0),
 & GSCO_a^i(L)\subseteq L\\
 \Rightarrow & \bigcup_iGSCO_a^i(L)\subseteq L.
GSCO^*(L)=L,L=GSCO_R^*(L_0),~~R\subseteq \sg_L^*.
  \forall x,y\in
L&GSCO_R(x,y)=z\in L.\\
  i.e. & GSCO(GSCO_R(x,y),z)\subseteq L, ~\forall x,y,z\in L\\
i.e. & GSCO^2(L)\subseteq L.

GSCO^i(L)&\subseteq& L,~\forall i\geq 0\\
\bigcup_i GSCO_R^i(L)&\subseteq& L\\
\Rightarrow ~GSCO_R^*(L)&\subseteq& L
L=GSCO_R^*(L).
\end{proof}
\par Head has proved that NCH=SLT \cite{head1}. Thus we have the
following theorem whose proof is immediate.
\begin{theorem}
 if and only if there exists  such that
 is closed with respect to the operation .
\end{theorem}

\begin{theorem}

\end{theorem}
\begin{proof}
Let .  Then, there exist  such that 
is a constant for . That is,  implies . Consider  implies
that .  Hence  which implies . Hence . But the converse is not true. The
language  is ESF, but for no  ,
 property holds.
\end{proof}
\begin{figure}[h]
\setlength{\unitlength}{2mm}
\begin{center}
\begin{picture}(50,45)(-25,-20)
\put(-2,-20){} \put(-0.5,-18){\vector(-2,1){7}}
\put(-10,-14){} \put(-9,-13){\vector(-2,1){13}}
\put(-24,-6){} \put(-8,-12){\vector(0,1){3}}
\put(-10,-8){}
\put(-8,-6){\vector(0,1){3}}\put(-12,-2){}
\put(-8,-1){\vector(0,1){3}}\put(-15,3){}
\put(-8,4.5){\vector(0,1){8}}\put(-10,13){}
\put(-8,14){\vector(0,1){3}}\put(-9,17){}
\put(-22,-4){\vector(2,3){12}}
\put(0,-18){\vector(0,1){5}}\put(-2,-12){}
\put(0,-10){\vector(1,4){1}}\put(0,-6){}
\qbezier(1,-5)(10,7)(-7,13)\put(-6,12){\vector(-1,1){1}}
\put(1,-18){\vector(2,1){8}}\put(6,-14){}
\put(-8,19){\vector(4,1){8}}\put(0,22){}
\qbezier(8,-12)(6,10)(3,20)\put(3,20){\vector(0,1){1}}
\put(10,0){}\qbezier(12,1)(14,10)(4,21) \put(4,21){\vector(-3,1){1}}
\qbezier(2,-18)(20,-15.5)(12,-0.5)
\put(12.55,-1.5){\vector(-2,3){1}}
\end{picture}
\end{center}
\caption{Relations between different subclasses of the regular
language and their relations with } \label{rel}
\end{figure}


\begin{theorem}
The relations in figure \ref{rel} hold; The arrows indicate strict
inclusions and every two families not linked by a path in this
diagram are incomparable.
\end{theorem}
\begin{proof}
This diagram appears in \cite{MPS} with out the GSCO classes.  Hence
all relations
 between families other than GSCO classes are known.
\begin{enumerate}
\item . Let , i.e. . 
is closed with respect to the GSCO operation. This implies 
is a crossover language. Hence .
\par This inclusion is strict.  but .
\item DEF and TSyGSCO are incomparable.
\par . . Since  is
not a crossover language.
\item TSyGSCO and NIL are incomparable.
\par . .
\item TSyGSCO and COMM are incomparable.
\par . The other way is obvious.
\end{enumerate}

\end{proof}
 



\section{Conclusion}
We have presented a new operation  over words and languages,
which in some sense abstracts the cross-over of chromosomes in the
living organisms. This study of  reveals many interesting
results, such as   is regular for any . This result
could be useful in places where a generation of regular languages
are required. \par we conclude this paper by pointing out some further directions of research.
A study of generalised parallel cross over of words and languages, where the
parallelism is allowed, (i.e. cross over may occur more than one places) can be
initiated and a comparison between the generalised sequential crossover and
generalised parallel crossover has the potential of bringing results of worth.
\par Though this study has come out with a characterisation of strictly locally
testable languages (SLT) in terms of , this result does not
compare the characterisations of SLT, which are available earlier
with the newly obtained one. That is, the characterisations of SLT
could be compared in the sense of complexity, which is worth
investigating.
\par In our opinion the construction of  set can  be used for data compression
in the following sense. To store a
 crossover language , which is closed under , it is sufficient to store the
sets  .  can be retrieved from these by iterated GSCO
operation.
 


\begin{thebibliography}{9}
\bibitem{Ad} L. Adleman; Molecular computations of solutions to combinatorial problems, {\itshape Science}, {\bfseries 266}, 1021-1024, 1994.

\bibitem{Ad1} L. Adleman; Towards a mathematical theory of self-assembly, {\itshape Technical Report (00-72)}, University of South California, 2000.

\bibitem{AS} Arto Saloma; Formal Languages, Academic Press Inc. 1973.

\bibitem{bot} P Bottoni;  A Labella, V Manca, Superposition based on Watson-Creek like complementarity,  {\itshape Theory of computing systems}, {\bfseries 34 (4)}, 503-524, 2006.

\bibitem{BW}  T H LaBeau, E Winfree, J H Rief; Experimental progress in computation by self-assembly of DNA tilings, {\itshape Proc. 5th international meeting on DNA based computation, MIT}, ed. E Winfree and D Gifford, 121-138, 1999.

\bibitem{CH} Karel Culik II, Tero Harju; Splicing semi-groups of
dominoes and DNA, {\itshape Discrete Applied Mathematics}, {\bfseries 31 (3)}, 261-277, 1991.

\bibitem{CPV} Erzsébet Csuhaj-Varj\'{u}, Ion Petre, Gy\"orgy Vaszil; Self
assembly of strings and languages, {\itshape Theoretical Computer  Science}, {\bfseries 374 (1-3)},  74-81, 2007.

\bibitem{CAP} Al C\u ar\u ausu, Gh P\u aun; String intersection and short concatenation, {\itshape Rev. Mod. Math. Pures. Appl.}, {\bfseries 26}, 713-726, 1981.


\bibitem{Das}  G Dassow, H Hornig; Conditional grammars with sub-regular conditions, {\itshape Words, language, combinatorics II}, ed. M Ito and H J\"urgensen, 71-86, World Scientific, Singapore, 1994.

\bibitem{FCL} D Faulhammer, A R Cukras, R J Lipton, L F Landweber; Molecular computation: RNA solution to chess problem, {\itshape Proc. Nat. Acad. Sci.}, {\bfseries 97 (4)},  1385-1389, 2000.

\bibitem{Gol} J S Golan; The theory of semirings with applications in Mathematics and Theoretical Computer Science, Longman Scientific and Technical, New York, 1994.

\bibitem{head}Tom Head; Formal language theory and DNA : An analysis
of the generative capacity of specific recombinant behaviours,
{\itshape Bull. Math. Biology}, {\bfseries 49}, 737-759, 1987.
\bibitem{head1}Tom Head; Splicing representations of strictly locally testabel languages,
{\itshape Discrete Appl. Math.}, {\bfseries 87, 1-3}, 139-147, 1998.

\bibitem{HMU} John Hopcroft, Rajeev Motwani, Jeffrey Ullman; Introduction to automata theory, languages, and computation (2e),
Pearson Indian reprint, 2001.

\bibitem{Je}  L Jeganathan, R Rama, Ritabrata Sengupta; A proposal to a generalised splicing with a  self-assembly approach, {\itshape Pre-Proc. 14th international meeting on DNA based computation}, 2008.

\bibitem{L}M G Lagoudakis, T H LaBean; 2D DNA self-assembly for satisfiability, {\itshape Proc. 5th international meeting on DNA based computation, MIT}, ed. E Winfree and D Gifford, 139-152, 1999.


\bibitem{Luc} A DeLuca, A Restivo; A characterisation of strictly locally testable languages and its application to sub-semigroups of a free semigroup, {\itshape Information and control}, {\bfseries 44},  300-319, 1980.


\bibitem{Mc}  R McNaughton, S Papert; Counter free automata, MIT Press, Cambridge, Mass., 1971.

\bibitem{MPS} A Matesscu, Gh P\u aun, A Salomaa; Simple splicing systems, {\itshape Disc. App. Math.}, {\bfseries 44},  300-319, 1980.

\bibitem{mitrana1}L.Llie, V.Mitrana; Crossing-over on languages: A
formal representation of the recombination of genes in a chromosome.

\bibitem{mitrana2} V.Mitrana; Crossover systems : a language theoretic approach to
DNA recombinations, {\itshape Proc. First IEEE symp. Intelligence in
Neural and Biological systems}, washington, 1995.
\bibitem{OK} Q Ouyang, P D Kaplan, S Lieu, A Libchabvi; DNA solution of natural clique problem, {\itshape Science}, {\bfseries 278},  446-449, 1997.

\bibitem{paun1}Gh. P\u aun;  On the Splicing operation, {\itshape Discrete Applied Mathematics}, {\bfseries 70},  57-79, 1996.

\bibitem{paun2}Gh.P\u aun, Grzegorz Rozenberg, Arto Salomaa; Computing by
Splicing, {\itshape Theoretical Computer Science}, {\bfseries 168(2)}, 321-336, 1996.



\bibitem{dna}Gh. P\u aun, Grzegorz Rozenberg, Arto Salomaa;  DNA Computing : New Computing Paradigms, Springer-Verlag, 1998.

\bibitem{swat} M P Schutzenberger; Sur certaines operations de fermetune dans les languages, {\itshape Symposium Mathematica}, {\bfseries 15}, 245-253, 1975.

\bibitem{Win}   E Winfree, X Yang, N C Seeman; Universal computation via self-assembly of DNA; some theory and experiments, {\itshape DNA based computation II}, ed. L F Landweber and E B Baun, {\bfseries DIMACS, AMS},  191-213, 1999.

\bibitem{Win1}   E Winfree, T Eng, G Rozenberg; String tiles models foe DNA computing by self-assembly, {\itshape Pre-proc. of 6th international meeting on DNA based computing, Leiden}, ed. A Condon and G Rozenberg, 65-84, 2000.

\bibitem{Win2} E Winfree; Algorithmic self-assembly of DNA, PhD thesis, Caltech, 1998.

\end{thebibliography}
 
\end{document}
