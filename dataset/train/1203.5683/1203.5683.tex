 
 \documentclass{ifacconf}

\usepackage{graphicx}          

 \usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{epsfig}
\usepackage{algorithm}
\usepackage{algorithmicx}
\usepackage{algpseudocode}
\usepackage{color}
\usepackage{subfig}


\newcommand{\red}[1]{{\color{red}  #1}}
\newcommand{\blue}[1]{{\color{blue}  #1}}
\newcommand{\green}[1]{{\color{green}  #1}}


\newtheorem{example}{Example}
\newtheorem{lemma}{Lemma}
\newtheorem{remark}{Remark}
\newtheorem{proposition}{Proposition}
\newtheorem{assumption}{Assumption}
\newtheorem{corollary}{Corollary}
\newtheorem{definition}{Definition}
\newtheorem{theorem}{Theorem}
\newtheorem{problem}{Problem}
\newtheorem{proof}{Proof}

\newcommand{\IR}{\ensuremath{\mathbb{R}}}
\newcommand{\conv}{\mathrm{Conv}}

\newcommand{\FNab}{{\cal F}(a,b)}
\newcommand{\RNset}{R_N(a^{\mathbb{X}},b^{\mathbb{X}})}
\newcommand{\VNset}{\mathcal{V}(a,b)}
\newcommand{\RNab}{R_N(a,b)}


\newcommand{\TS}{{\cal T}}
\newcommand{\XO}{\ensuremath{\mathbb{X}_0}}
\newcommand{\AUTOMATON}{\ensuremath{\mathcal{A}}}
\newcommand{\Fset}{{\cal E}}


\newcommand{\minSA}{\ensuremath{\min_{v \in \mathcal{V}(F)}  ((h(v) + Bk(v))_i) }}
\newcommand{\minSB}{\ensuremath{  \min_{v \in \mathcal{V}(\overline {F})}  ((h(v) + Bk(v))_i)}}

\newcommand{\minSAP}{\ensuremath{\min_{v \in \mathcal{V}(F)}  ((h(v) + Bk(v))_i) }}
\newcommand{\minSBP}{\ensuremath{  \min_{v \in \mathcal{V}( {\overline{F}})}  ((h(v) + Bk(v))_i)}}

\newcommand{\LTLUNTIL}{\ensuremath{\mathcal{U}}}
\newcommand{\LTLNEXT}{\ensuremath{\mathcal{X}}}
\newcommand{\LTLEVENTUALLY}{\ensuremath{\mathcal{F}}}
\newcommand{\PREDSET}{\ensuremath{\Pi}}
\newcommand{\TIMEBOUND}{\ensuremath{T}}

\newcommand{\ARUN}{\ensuremath{r}}
\newcommand{\scheck}{\textit{scheck2\ }}
\newcommand{\SCLTLX}{scLTL}
\newcommand{\SCLTL}{scLTL}


\begin{document}

\begin{frontmatter}

\title{Time-Constrained Temporal Logic Control of Multi-Affine Systems}
\thanks[footnoteinfo]{This work was partially supported at Boston University by grants AFOSR YIP FA9550-09-1-0209, ARO W911NF-09-1-0088, NSF CNS-0834260, ONR 
MURI N00014-10-10952, and ONR MURI N00014-09-1051.}

\author[First]{Ebru Aydin Gol}
\author[First]{Calin Belta}

\address[First]{Boston University, Boston, MA 02215, USA \\e-mail: \{ebru,cbelta\}@bu.edu}                                              


\begin{abstract}
In this paper, we consider the problem of controlling a dynamical system such that its trajectories satisfy a temporal logic property in a given amount of time. We focus on multi-affine systems and specifications given as syntactically co-safe linear temporal logic formulas over rectangular regions in the state space. The proposed algorithm is based on the estimation of time bounds for facet reachability problems and solving a time optimal reachability problem on the product between a weighted transition system and an automaton that enforces the satisfaction of the specification. A random optimization algorithm is used to iteratively improve the solution. 
\end{abstract}
\end{frontmatter}


\section{Introduction}\label{sec:intro}
Temporal logics and model checking algorithms have been primarily used for specifying and verifying correctness of software and hardware systems. 
Due to their expressivity and resemblance to natural language, temporal logics have gained popularity as specification languages in other areas including dynamical systems. Recently, there has been increasing interest in formal synthesis of dynamical systems, where the goal is to generate a control strategy for a dynamical system from a specification given as a temporal logic formula, such as Linear Temporal Logic (LTL)  (\cite{Kloetzer:2008,TP03,Girard:2010}), or fragments of LTL, such as  
GR(1) (\cite{Hadas-ICRA07,Tok-Ufuk-Murray-CDC09}) and syntactically co-safe LTL (\cite{Kavraki:MPlanning}).

We focus on a particular class of nonlinear affine
control systems, where the drift
is a multi-affine vector field ({\em i.e.,} affine in each state
component), the control distribution is constant, and the
control is constrained to a convex set. This class of
dynamics includes the
Euler, Volterra (\cite{Volterra1926}) and Lotka-Volterra
(\cite{Lotka1925}) equations, attitude and velocity control systems
for aircraft (\cite{vanderSchaft}) and underwater vehicles
(\cite{Belta-ICRA2004}), and models
of biochemical networks (\cite{jong2002}). 
In \cite{Belta-TAC06}, the authors studied the problem of synthesizing a state feedback controller such that the trajectories originating in a rectangle leave it through a specified facet. These results were generalized in \cite{Habets2006} by allowing the trajectories to leave through a set of exit facets. 

In this paper, we consider the following problem: given a multi-affine control system and a syntactically co-safe LTL formula over rectangular subregions of the state space, find a set of initial states for which there exists a control strategy such that all the trajectories of the closed-loop system satisfy the formula within a given time bound. Syntactically co-safe LTL formulas can be used to describe finite horizon specifications such as target reachability with obstacle avoidance: ``always avoid obstacle  until reaching target ", sequencing constraints ``do not go to  or  unless  was visited before", and more complex temporal and Boolean logic combinations of these. Our approach to this problem consists of two main steps. First, we construct a finite abstraction of the system by solving facet reachability problems on a rectangular partition of the state space. We build on the results from \cite{Belta-TAC06,Habets2006} to derive bounds for the exit times of the trajectories. 
Second, we solve time optimal reachability problems on the product between the abstraction and an automaton that enforces the satisfaction of the specification. 
We propose an iterative refinement procedure via a random optimization algorithm.

Finite abstractions for controlling dynamical systems have been widely used, e.g by \cite{TP03}. 
Time optimal control of dynamical systems through abstractions has been studied by \cite{Mazo:2011} and \cite{Girard:2010Opt}. In both cases, an optimal controller is synthesized for an approximate abstraction, which is then mapped to a suboptimal solution for the original system for specifications given in the form of ``reach and avoid'' sets. While our solution also involves an optimal control problem on the abstraction, our automata-theoretic approach allows for richer, temporal logic 
control specifications.

The remainder of the paper is organized as follows. We review some notions necessary throughout the paper in Sec.~\ref{sec:pre} before formulating the problem and outlining the approach in Sec.~\ref{sec:prob}. 
A review of facet reachability problems and the derivation of the exit time bounds are presented in Sec.~\ref{sec:control}. 
The control strategy providing a solution to the main problem is described in Sec.\ref{sec:controlStrategy} and the random optimization method for refinement is given in Sec.~\ref{sec:optimization}. 
An example is given in Sec.~\ref{sec:casestudy} and conclusions are summarized in Sec.~\ref{sec:conclusion}.




\section{Preliminaries}\label{sec:pre}

\subsection{Transition systems and linear temporal logic}
\begin{definition}
A weighted transition system is a tuple , where  and  are sets of states and inputs,  is a transition map,  is a set of observations,  is an observation map, and  is a map that assigns a positive weight to each state and input pair.
\end{definition}

 denotes the set of successor states of  under the input . If the cardinality of  is one, the transition  is deterministic. A transition system  is called deterministic if all its transitions are deterministic.

A finite input word , ,  and an initial state  define a trajectory  of the system with the property that  for all . The cost  of trajectory  is defined as the sum of the corresponding weights, i.e., 

A trajectory  produces a word  .


\begin{definition}( \cite{Vardi:safety}) A syntactically co-safe LTL (scLTL) formula over a set of atomic propositions  is inductively defined as follows:


where  is an atomic proposition,  (negation),  (disjunction),  (conjunction) are Boolean operators, and  (``until''), and  (``eventually'') are temporal operators \footnote{The scLTL syntax usually includes a ``next" temporal operator. We do not use it here 
because it is irrelevant for the particular semantics of continuous trajectories that we define later.}. 
\end{definition}

The semantics of scLTL formulas is defined over infinite words over . Informally, 
 states that  is true until  is true and  becomes eventually true in a word;  states that  becomes true at some position in the word. More complex specifications can be defined by combing temporal and Boolean operators (see Eqn. (\ref{eq:spec_case_study})). 

An important property of scLTL formulas is that, even though they have infinite-time semantics,
their satisfaction is guaranteed in finite time. Explicitly, for any scLTL formula  over ,
any satisfying infinite word over  contains a satisfying finite prefix. 

\begin{definition} A deterministic finite state automaton (FSA) is a tuple  where  is a finite set of states,  is an input alphabet,  is a set of initial states,  is a set of final states, and  is a deterministic transition relation.
\end{definition}

An accepting run  of an automaton  on a finite word  over  is a sequence of states  such that ,  and  for all . 
For any scLTL  formula over , there exists a FSA  with input alphabet  that accepts the prefixes of all the satisfying words. 
There are algorithmic procedures and off-the-shelf tools, such as \scheck by \cite{Latvala:scheck},
for the construction of such an automaton.

\begin{definition}\label{def:product_automaton}
Given a weighted transition system  and a FSA  with , their product automaton is a FSA  where  is the set of states,  is the input alphabet, 
 is the transition relation with ,
 is the set of initial states, and  is the set of final states.


An accepting run  of  defines an accepting run  of  over input word .
The weight function of the transition system can directly be used to assign weights to transitions of , i.e., we can define a weight function for the product automaton in the form . 
The corresponding cost for a run  of  over  is defined as 
 
\end{definition}
\newcommand{\SIGNLETTER}{\gamma}
\subsection{Rectangles and multi-affine functions}
For , an -dimensional rectangle  is
characterized by two vectors  and  with the property that  for all :


Let  and  be the set of vertices and facets of 
of , respectively. 
Let  denote the facet with normal , where 
,  denote the standard basis of .
For a facet ,   denotes its set of vertices
and  denotes its outer normal. For a vertex ,  denotes the set of facets containing . 

\begin{definition}
  \label{def:multiaffine}
  A {\em multi-affine function}  (with ) is a function that is affine in
  each of its variables, i.e.,  is of the form
  
  with  for all , and using the convention that if , then
  .
\end{definition}

\cite{Belta-TAC06} showed  that a multi-affine function  on a rectangle  is uniquely defined by its values at the vertices, and inside the rectangle the function is a convex combination of its values at the vertices:

where  is an indicator function such that  and  for all .

\section{Problem formulation}\label{sec:prob}

Consider a continuous-time multi-affine control system of the form

where , , and the control input  is restricted to a polyhedral set .

Rectangular regions of interests in  are defined using a set of atomic propositions . Each atomic proposition  is satisfied in a set of  rectangular subsets of the state space of system~\eqref{eq:system}, which is denoted as:



The specifications are given as scLTL formulas over the set of predicates . A trajectory of system~\eqref{eq:system} satisfies the specification if the word produced by the trajectory satisfies the corresponding formula. 
Informally, while a trajectory of system~\eqref{eq:system} evolves, it produces the satisfying predicates and the sequence of predicates defines the word produced by a trajectory. Specifically, a trajectory produces predicate  whenever it spends a finite amount of time in a rectangle where  is satisfied. 
For example, trajectories  and  shown in Fig.~\ref{fig:trajectory} produce the words  and , respectively. 
The word produced by a trajectory depends on how the rectangles are defined. The presented approach employs a refinement procedure based on adding hyperplanes, which induces smaller rectangles that inherit the predicate.
For example, if the dashed line in Fig.~\ref{fig:trajectory} is added, the trajectory  produces .
As discussed by \cite{Kloetzer:2008}, when LTL without next operator is considered,    and  satisfy the same set of LTL formulas.
\begin{remark}
In this paper, we study finite time trajectories of system~\eqref{eq:system}. 
When infinite time trajectories are of interest, invariant controllers can be considered as in \cite{Habets2006}.
\end{remark}
  \begin{figure}
\centering
\includegraphics[width=0.5\columnwidth]{trajectory2.pdf}
\caption{Examples of continuous trajectories of system~\eqref{eq:system}. The atomic propositions are shown in the rectangles where they are satisfied.}
\label{fig:trajectory}
\end{figure}



\begin{problem}\label{prob:main}
Given a syntactically co-safe LTL formula  over a set of predicates  and a time bound \TIMEBOUND,  find a set of initial states  
and a feedback control strategy such that all words produced by the closed-loop trajectories of system~\eqref{eq:system} originating in  satisfy the formula in time less than \TIMEBOUND.
\end{problem}


Our proposed solution to Prob.\ref{prob:main} starts with a proposition-preserving rectangular partition\footnote{We use the term ``partition" loosely in this paper. 
The rectangle boundaries are irrelevant, since due to the synthesized controllers the trajectories never slide along the boundaries.} of , i.e., each element of the partition is a rectangle  for some ,  from Eqn.~\eqref{eq:atomic_prop}.
For each rectangle in the partition, and for each subset of its set of facets, we derive state-feedback controllers driving all the initial states in the rectangle through the set of facets in finite time by using the sufficient conditions derived in \cite{Habets2006}. We compute upper bounds for these times and choose the feedback controllers that minimize the upper bounds for each rectangle and each set of exit facets. We then construct a weighted transition system, in which the states label the rectangles from the partition, the inputs label the controllers, and the weights capture the time bounds. We find an optimal run of this transition system that satisfies the formula by solving an optimal reachability 
problem on its product with an FSA that accepts the language satisfying the formula.
The rectangles corresponding to the initial states with costs less than  compose the set . In order to increase this set, we use an iterative refinement of  the partition based on a random optimization algorithm.

\section{Facet Reachability Problems}
\label{sec:control}

In this section, we focus on the derivation of the facet reachability 
controllers and their corresponding time bounds. We first summarize the 
sufficient conditions for facet reachability from \cite{Habets2006}:

\begin{theorem}\label{thm:facet_reachability}
Let  be a rectangle and  be a non-empty subset of its facets. There exists a multi-affine feedback controller  such that all the trajectories of the closed-loop system~\eqref{eq:system} originating in  leave it through a facet from the set  in finite time if the following conditions are satisfied:

where  denotes the convex hull.
\end{theorem}

In particular, when the cardinality of  is 1, i.e. , 
then Eqns. (\ref{eq:neg_speed}) and (\ref{eq:nozero}) imply that the speed towards the exit facet  has to be positive everywhere in , i.e.


As a consequence, for this particular case, the sufficient conditions (\ref{eq:neg_speed}) and (\ref{eq:nozero}) can be replaced with (\ref{eq:neg_speed}) and 
(\ref{eq:pos_speed}). 


The linear inequalities given in \eqref{eq:neg_speed} and \eqref{eq:pos_speed} (or  \eqref{eq:neg_speed} and  \eqref{eq:nozero}) 
define a set of admissible controls  for each vertex . By choosing a control for each vertex  from the corresponding set , we can construct a multi-affine state feedback controller  that solves the corresponding control problem by using Eqn. (\ref{eq:ma_convex}). We first provide a time upper bound for the case when there is only one exit facet (Prop. \ref{prop:time_bound}), and then use this result to provide an upper bound for the general case (Cor. \ref{prop:multi_facet_time_bound}). 

\begin{proposition}\label{prop:time_bound}
Assume that  is an admissible multi-affine feedback controller that solves the control-to-facet problem for a facet  with outer normal  of a rectangle . Then all the trajectories of the closed loop system starting in rectangle  leave the rectangle through facet  in time less than , where

with

where  denotes the facet opposite to , i.e. with normal .
\end{proposition}

{\bf Proof:} \newcommand{\lambdaP}{\ensuremath{\frac{b_i - x_i}{b_i - a_i}}} 
Let  and  be the projections of  on  and , respectively. Then, we have .  
For every ,  is a convex combination of 
  . Furthermore, if  belongs to
  a facet of , then  is a convex combination of the
  values of  at the vertices of that facet. 
  Therefore, we have
  
  Since  is a solution of the control-to-facet problem for facet , the speed towards  is positive everywhere in , hence
  

  For any , the speed in the  direction is lower bounded by  (Eqn. ~\eqref{eq:sx}), which depends linearly on .  Since system~\eqref{eq:slow} 
 defined below is always slower than the original one, its time upper bound to reach facet  gives a valid upper bound for the original system.

	
	The explicit solution of Eqn.~\eqref{eq:slow} is given in Eqn.~\eqref{eq:solnslow}, where  denotes the  component of the initial condition.
	
  	Solving~\eqref{eq:solnslow} for time  at  gives the time upper bound from Eqn.~\eqref{eq:timeb}. Any trajectory starting from an initial point  in  with  reaches the facet  in time less than . 
	
	As  attains its maximum when ,
	
	gives the upper bound for all .
\qed
  
Prop.~\ref{prop:time_bound} uses the fact that if  is a solution to the considered control-to-facet problem, then the speed   towards the exit facet is positive for all . By defining a slower system using minimum speeds on  and  towards the exit facet, a time bound for the original system is found. A more conservative time bound  can be computed using only the minimum speed towards , i.e. . While it is more efficient to compute ,  gives a tighter bound (). Indeed, the computation of  considers the change on the lower bound of speed with respect to . Moreover, while  gets closer to ,  approaches :
 

\begin{remark} The time bound  from Eqn.~\eqref{eq:TF} is attainable in some cases. Let  and . If 



then the trajectory originating at   reaches  at time .
\end{remark}


For each vertex , we can minimize the time bound 
given in Prop.~\ref{prop:time_bound} if we choose a control  that maximizes . Computationally, this involves 
solving a linear program at each vertex of a rectangle. Formally, at each vertex , the optimization problem can be written as: 


where , which is a robustness parameter guaranteeing  that a trajectory never reaches a facet other than  while moving towards . Decreasing  relaxes the problem~\eqref{eq:optim} by increasing the size of the feasible region, which results in higher speeds and tighter time bounds.
Note that when  the equalities given in Eqn.~\eqref{eq:TF_ACHIEVE}  can not hold, 
since for a vertex  the speed towards a facet  is upper bounded by . 
Therefore the robustness parameter  also affects the distance between the time bound from Eqn.~\eqref{eq:TF} and the actual maximal amount of time required to reach . 
\begin{figure}
\centering
\subfloat[]{\label{fig:ex_rec}\includegraphics[width=0.5\columnwidth]{rectra.pdf}}
\subfloat[]{\label{fig:ex_recTime}\includegraphics[width=0.5\columnwidth]{rectraTime2.pdf}}
\caption{(a) Rectangle  and sample trajectories originating in facet . 
(b) Simulation times according to the initial condition in  and time bounds  (red lines) computed using
Eqn. (\ref{eq:TF}) for controllers synthesized from \eqref{eq:optim} for  and .}
\label{fig:ex_r}
\end{figure} 

The tightness of the time bound from Eqn.~\eqref{eq:TF} and the effects of the robustness parameter  are illustrated through an example in Fig.~\ref{fig:ex_r}, where the control problem for exit facet  of rectangle  is considered for the control system from Eqn. (\ref{eq:case_system}). Some trajectories of the closed loop system obtained by using the feedback controller that minimizes  when  are shown in Fig.~\ref{fig:ex_rec}. 
The corresponding times for reaching  for  and  are shown in Fig.~\ref{fig:ex_recTime}. 
Note that when , the trajectory starting from  reaches facet  exactly at time .


\begin{corollary}\label{prop:multi_facet_time_bound}
Given a rectangle  and  an admissible multi-affine feedback  that solves the control problem from Thm. \ref{thm:facet_reachability} with set of exit facets , all trajectories of the closed loop system originating in rectangle  leave it through a facet  in time less than 

 where each  is computed as in Prop.~\ref{prop:time_bound} if  for all . Otherwise  is set to .
\end{corollary}


{\bf Proof:} Let  with  for all . Then by Prop.~\ref{prop:time_bound} every trajectory originating in  reaches  within time ~\eqref{eq:TF} unless it leaves  before reaching . Hence,  gives a valid bound to the control-to-set-of-facets problem for .
\qed

For a facet reachability problem with  as the set of exit facets,   is computed for each  through choosing controls that minimize ~\eqref{eq:TF} and satisfy the linear inequalities defined in Thm.~\ref{thm:facet_reachability}. Computationally, this translates to solving the following linear program for each  and for each : 

where  is defined as in optimization problem \eqref{eq:optim}.

As already stated,  for  is calculated as in~\eqref{eq:TF} if the speeds at all vertices are positive towards . In this case, the condition from~\eqref{eq:nozero} is trivially satisfied. Then a multi-affine feedback  is constructed by using the controls where  attains its minimum. 

\section{Control Strategy}\label{sec:controlStrategy}

In this section, we provide a solution to Prob.~\ref{prob:main} for a proposition-preserving partition of . We use the results from Sec.~\ref{sec:control} to construct a weighted transition system from the partition and find an optimal control strategy for the weighted transition system. The control strategy enforces the satisfaction of the specification and maps directly to a strategy for system~\eqref{eq:system}.



A proposition-preserving partition of  and solutions of facet reachability problems for the rectangles in the partition set define a weighted transition system .
Each state  of  corresponds to a rectangle  in the partition set. 
An input  of  indicates a non-empty subset of the facets of a rectangle and a transition  is introduced if the corresponding control problem has a solution. 
Specifically, we consider a facet reachability problem for each state  and each non-empty subset of , and find the multi-affine feedback control which minimizes the corresponding time bound as explained in Sec.~\ref{sec:control}.
The successors of   are the states  such that  and  have a common facet in . 
The transition weights are assigned according to the time bounds computed as described in Prop.~\ref{prop:time_bound} and Cor.~\ref{prop:multi_facet_time_bound}.  equals to the set of predicates  and  if .

All words that satisfy the specification formula  are accepted by a FSA  \footnote{In the general case, as described in Sec. \ref{sec:pre}, the input alphabet of this automaton is . However, since the words generated by system (\ref{eq:system})
are over , it is sufficient to consider  as the input alphabet for the automaton.}. We construct a product automaton   from  and  as described in Def.~\ref{def:product_automaton}.

\newcommand{\ControlSet}{{SC}}
\newcommand{\StateCost}{J}


A control strategy  for  is defined as a set of initial states  and a state feedback control function  implying that  will be the input at state . The state feedback function  characterizes the set of initial states  such that every run  of  starting from a state  in  is an accepting run over the word .
Since  is non-deterministic, there can be multiple runs starting from a state  under the feedback control . In literature (\cite{Kloetzer:2008NonDet}, \cite{Wolfgang2002}), non-determinism is resolved through a reachability game played between a protagonist and an adversary, and   is defined as the set of initial states such that the protagonist always wins the game by applying . 
Next, we introduce an algorithm based on fixed-point computation to find a maximal  and corresponding feedback control  through optimizing a cost for each . \cite{Asarin:1999} used a similar algorithm to solve optimal reachability problems on timed game automata. 

\begin{remark}
Generally, the reachability games are considered over an infinite horizon such as Buchi games, where winning a game for the protagonist means identifying and reaching an invariant set of ``good'' states.  
As we consider FSAs, the acceptance condition coincides with finite time reachability. 
Hence, a simple reachability algorithm is sufficient in our case.
\end{remark}

Let  be a cost function with respect to a set of final states  and feedback control  such that any run of  starting from  reaches a state  under the feedback control  with a cost upper bounded by  . Note that if there exists a run starting from  that can not reach , the cost is infinity, .

The solution of the fixed-point problem given in Eqn. (\ref{eq:fixed_point}) gives the optimal cost for each .
	


	
\begin{algorithm}\caption{\small{Compute  and  for  }}
\label{algo:fixed_point}
\small{
\begin{algorithmic}[1]
	\State 
	\State 
	\State  and  such that 
	\While{ }
		\State 
			\If{} \label{alg:update_rule}
				\State 			
				\State 
				\State 
			\EndIf
	\EndWhile
\end{algorithmic}
}
\end{algorithm}

Alg.~\ref{algo:fixed_point} implements the solution for the fixed-point problem in Eqn.~\eqref{eq:fixed_point} for the states of 
and finds the optimal feedback control . 
A finite state cost, , and a feedback control  resulted from Alg.~\ref{algo:fixed_point} means that every run starting from  reaches a state  in  under the feedback control  with a cost at most . Therefore,  is the maximal set of initial states of  such that under the feedback control  all runs starting from  are accepting. 
Consequently, 
 
is the maximal set of initial states such that under the feedback control  cost of a run starting from  is upper bounded by .

If only control-to-facet problems are considered while constructing the transition system ,  and the product automaton  become deterministic. Hence, in this case it is sufficient to use a shortest path algorithm to find optimum costs and feedback control  instead of Alg.~\ref{algo:fixed_point}.

If a multi-affine feedback  solves facet reachability problem for the set of exit facets  of rectangle , then  is a solution of the facet reachability problem for every superset  of  with the same time bound  by Cor.~\ref{prop:multi_facet_time_bound}. While constructing  of , a solution is searched for every subset of , hence
 
In line~ \ref{alg:update_rule} of Alg.~\ref{algo:fixed_point}, cost of a state is updated according to the state with maximum cost among a transitions successor states, hence Alg.~\ref{algo:fixed_point} tends to choose the  with minimum cardinality among the sets  with the same transition cost.


\textbf{\emph{Control Strategy for : }} (\cite{Kloetzer:2008NonDet})
We construct a control strategy  for  using the control strategy  for  resulted from Alg.~\ref{algo:fixed_point} and Eqn.\eqref{eq:s_omegaT}.
The set of initial states  is the projection of  to the states of .
Since the feedback control  for  becomes non-stationary when projected to the states of , we construct a feedback control for  in the form of a feedback control automaton . 
The feedback control automaton  reads the current state of  and outputs the input to be applied to that state. 
The set of states , the set of initial states  and the set of final states  of  are inherited from , the set of inputs  is the states of . 
The memory update function  is defined as   if  is defined. The output alphabet  is the input alphabet of .  is the output function,  if  and  is undefined otherwise. 



If we set the set of observations of  to  and define the observation map  as an identity map, then the product of  and  will have same states and transitions as . 
Hence, the words produced by trajectories of  starting from  in closed loop with  satisfy .


Control strategy  for  is used as a control strategy for system~\eqref{eq:system} by mapping the output of  to the corresponding multi-affine feedback controller. 
This strategy guarantees that every trajectory of system~\eqref{eq:system} originating in  given in Eqn.~\eqref{eq:X0} satisfies  in time less than \TIMEBOUND.
 
For every , there exists an initial state  and  such that  and  from Eqn.~\eqref{eq:s_omegaT}.
Let  be the multi-affine feedback which solves control-to-facet (or control-to-set-of-facets) problem on  for  as the set of exit facets. Starting from  multi-affine feedback  is applied to system~\eqref{eq:system} until the trajectory reaches a facet  with a positive speed towards . By construction of , it is guaranteed that the trajectory reaches a facet  in time less than .
Then the applied multi-affine feedback switches to  where  and . This process continues until a final state  of  is reached.



\begin{theorem}\label{thm:main}
The trajectories of system~\eqref{eq:system} originating in ~\eqref{eq:X0} with control strategy  satisfies  in time less than \TIMEBOUND.  
\end{theorem}	
{\bf Proof:}
By Def.~\ref{def:product_automaton}, every word produced by an accepting run of  satisfies . Hence, by construction of  and  the words produced by closed loop trajectories of system~\eqref{eq:system} originating in  satisfy .
Consider a finite trajectory  of system~\eqref{eq:system} with  evolving under the control strategy  .
Let   be the corresponding run of ,   be the corresponding trajectory of  and  be a time instant when control switch occurs, i.e. at time , the trajectory hits a facet  with a positive speed towards  while evolving under the multi-affine feedback , for all  and .
By Prop.~\ref{prop:time_bound} and Cor.~\ref{prop:multi_facet_time_bound}, for all :

By Alg.~\ref{algo:fixed_point},  and by Eqn.~\eqref{eq:X0} .
\qed


In Thm.~\ref{thm:main}, we showed that the proposed feedback control strategy solves Prob.~\ref{prob:main} for a proposition-preserving partition of .  Next we describe an iterative refinement procedure to increase the volume of .




\section{Refinement}\label{sec:optimization}
 \newcommand{\OPTVAR}{d_{i*}^{j}}
 \newcommand{\OPTVARS}{d_{i}^{j}}
 \newcommand{\OPTVARN}{d_{i+1}^{j}}
\newcommand{\NEWTH}{d^j_*}

An iterative refinement procedure is employed to enlarge the set ~\eqref{eq:X0}. 
As mentioned before, the rectangles defined by the set of predicates induce an initial proposition-preserving grid partition of . A grid partition is defined by a set of thresholds  for each dimension . 



 Introducing a new threshold  in dimension  can affect  in different ways and it does not always enlarge the set .  Consider a state  with  as computed in Alg.~\ref{algo:fixed_point} and corresponding rectangle  with .  Assume a multi-affine feedback  solves the control-to-facet problem for a facet  with outer normal  and assume the corresponding time bound is  as given in Prop.~\ref{prop:time_bound}. When  is partitioned into two rectangles  and  through a hyperplane ,  we need to consider two cases:  and , which are illustrated in Fig.~\ref{fig:partition} on a rectangle in .


  \emph{(a)}\{{\it }\} Since state feedback  solves the control-to-facet problem on  for , the speed towards the exit facet is positive for all . Moreover, no trajectory leaves  through another facet. Hence,  solves the control-to-facet problems on  and  for the facets with normal . Let  and  be the corresponding time bounds. Then when  is applied, any trajectory starting in  and  reaches  within time , which is upper bounded by . The proof follows from the proof of the Prop.~\ref{prop:time_bound}, the minimal speed towards  on the intersection of  and  is lower bounded by . As the actual minimal speed could be higher than  and other multi-affine feedbacks could solve the same problem on  and  with lower time bounds, when , partitioning results in tighter time bounds.
  
  
  \emph{(b)}\{{\it }\} The multi-affine feedback  solves the control-to-set-of-facets problem on  for exit facets  where  and . Moreover,  solves control-to-set-of-facets problem on   for exit facets  where  and . Then the corresponding time bounds  and   are upper bounded by  by Cor.~\ref{prop:multi_facet_time_bound}. However,  or  could be higher than , hence, the costs of the resulting automaton states could be higher than .

\begin{figure}
\centering
\includegraphics[width=0.8\columnwidth]{partitioning.pdf}
\caption{Two partitioning schemes for .}
\label{fig:partition}
\end{figure}
In \emph{(a)} and \emph{(b)}, the effects of partitioning are analyzed on a rectangular region for a simple case where the initial rectangle has a solution to the control-to-facet problem for facet . It is concluded that when a rectangle   of a state  with   is partitioned, the costs of the resulting states  and  can be higher or lower than . 
Hence, even for that simple case, partitioning can have negative and positive effects on the defined time bound for a single rectangle.
Moreover, there is no closed form relationship between the partitioning scheme   and the volume of the set .


In order to overcome these difficulties,
we use a Particle Swarm Optimization (PSO)(\cite{PSOTralea}) algorithm to find the new thresholds. The objective of the optimization is maximizing the volume of the set ~\eqref{eq:X0}. We run the PSO algorithm iteratively.
At each iteration, a new threshold  is added between two consecutive ones  depending on the distance between them and the value of the corresponding optimization variable. An optimization variable for  is defined with range  if the distance between two consecutive thresholds is twice as large as the minimum allowed edge size, . Part of the range  is used to decide whether to add the threshold or not, i.e. a new threshold is added only if . 
The dimension of the optimization problem depends on the grid configuration  of the iteration.
The iterative procedure terminates when either all the intervals are smaller than  or there is no change in the optimum objective value for the last two iterations. 

\begin{remark} Let , then the cardinality of the resulting partition is .
Construction of the transition system  (see Sec.~\ref{sec:controlStrategy}) from the partition  requires to solve  linear programs. For each partition, in addition to solving these linear programs, we take the product between  and , and run Alg.~\ref{algo:fixed_point} to find the volume of the set .
\end{remark}

\section{Case Study}\label{sec:casestudy}

Consider the following multi-affine system

where the state  and the control input  are constrained to sets 
 and , respectively.
The specification is to visit one of the rectangles that satisfy  or , then a rectangle where  is satisfied, while always avoiding the rectangles that satisfy . Moreover, if a trajectory visits a rectangle where  is satisfied, then it has to visit a rectangle that satisfies  before visiting a rectangle that satisfies . Predicates ,  are defined in Fig. \ref{fig:ex_env}. Formally, this specification translates to the following scLTL formula  over : 


A FSA  that accepts the language satisfying formula  is given in Fig.~\ref{fig:ex_fsa}. The regions of interests and the corresponding partition are given in Fig.~\ref{fig:ex_env}. The upper time bound to satisfy the specification is set to , the minimum edge length is set to  and the robustness parameter for optimization problems~\eqref{eq:optim} and~\eqref{eq:optimM} is set to .

\begin{figure}
\centering
\subfloat[]{\label{fig:ex_fsa}\includegraphics[width=0.55\columnwidth]{fsaA2.pdf}}
\subfloat[]{\label{fig:ex_env}\includegraphics[width=0.35\columnwidth]{caseenv.pdf}}
\caption{(a) FSA  that accepts the language satisfying ~\eqref{eq:spec_case_study} ( stands for Boolean constant true). The initial state of the automaton is filled with grey and the final state is marked with a double circle. (b) The initial partition induced by the predicate set . , , ,  and  are satisfied in cyan, magenta, red, green and orange colored rectangles, respectively and  is satisfied in white rectangles.}
\end{figure} 

To illustrate the main results of the paper, we use two approaches to generate a control strategy. In the first experiment, only control-to-facet problems are considered, hence a deterministic transition system is used.
As discussed in the paper, the resulting product automaton is also deterministic and it is sufficient to use a shortest path algorithm instead of Alg.~\ref{algo:fixed_point}. 
In the second approach, both control-to-facet and control-to-set-of-facets problems are considered. Hence, the resulting transition system and product automaton are non-deterministic, and Alg.~\ref{algo:fixed_point} is applied.

We use  and  to denote the control strategies as defined in Sec.~\ref{sec:controlStrategy} for the partition schemes resulted from the iterative refinement described in Sec.\ref{sec:optimization} for the first and second approach, respectively. We use  and  to denote the corresponding sets of initial states of system\eqref{eq:case_system}, respectively. 
These sets, together with sample trajectories of the closed loop systems, are shown in Fig.~\ref{fig:sim}. 
The volume of  is  and the volume of  is . 
A control-to-facet problem on a rectangle  does not have a solution for facets  and  because of the strong drift in that region. However, rectangles in the same region have solutions to control-to-set-of-facets problem for . Consequently, rectangles in that region is only covered by  as the construction of  considers non-determinism.


\begin{figure}[h]
\centering

\subfloat[]{\label{fig:ex_det}\includegraphics[width=0.45\columnwidth]{simDetEps.pdf}}
\subfloat[]{\label{fig:ex_nondet}\includegraphics[width=0.45\columnwidth]{simNonDetEps.pdf}}
\caption{The yellow regions in (a) and (b) represent  and , respectively. Some simulated satisfying trajectories of the corresponding closed-loop systems are shown (the initial states are marked by circles).}
\label{fig:sim}
\end{figure}

\section{Conclusion}\label{sec:conclusion}


We studied a time-constrained control problem for a continuous-time multi-affine system from a specification given as a syntactically co-safe LTL formula over a set of predicates in its state variables. 
Our approach was based on finding an optimal control strategy on the product between an abstraction of the system and an automaton enforcing the satisfaction of the specification. The abstraction was a weighted transition system constructed by solving facet reachability problems on a rectangular partition of the state space of the original system. We proposed an iterative refinement procedure via a random optimization algorithm to increase the set of admissible initial states.

\begin{thebibliography}{21}
\providecommand{\natexlab}[1]{#1}
\providecommand{\url}[1]{\texttt{#1}}
\expandafter\ifx\csname urlstyle\endcsname\relax
  \providecommand{\doi}[1]{doi: #1}\else
  \providecommand{\doi}{doi: \begingroup \urlstyle{rm}\Url}\fi

\bibitem[Asarin and Maler(2009)]{Asarin:1999}
E.~Asarin and O.~Maler.
\newblock As soon as possible: Time optimal control for timed automata.
\newblock In \emph{Hybrid Systems: Computation and Control}, pages 19--30.
  Springer, 2009.

\bibitem[Belta(2004)]{Belta-ICRA2004}
C.~Belta.
\newblock On controlling aircraft and underwater vehicles.
\newblock In \emph{{IEEE} International Conference on Robotics and Automation},
  volume~5, pages 4905 -- 4910, 2004.

\bibitem[Belta and Habets(2006)]{Belta-TAC06}
C.~Belta and L.C.G.J.M. Habets.
\newblock Control of a class of nonlinear systems on rectangles.
\newblock \emph{IEEE Transactions on Automatic Control}, 51\penalty0
  (11):\penalty0 1749 --1759, 2006.

\bibitem[Bhatia et~al.(2010)Bhatia, Kavraki, and Vardi]{Kavraki:MPlanning}
A.~Bhatia, L.~E. Kavraki, and Moshe~Y. Vardi.
\newblock Motion planning with hybrid dynamics and temporal goals.
\newblock In \emph{{IEEE} Conference on Decision and Control}, pages
  1108--1115, 2010.

\bibitem[de~Jong(2002)]{jong2002}
H.~de~Jong.
\newblock Modeling and simulation of genetic regulatory systems.
\newblock \emph{J. Comput. Biol.}, 9\penalty0 (1):\penalty0 69--105, 2002.

\bibitem[Gazit et~al.(2007)Gazit, Fainekos, and Pappas]{Hadas-ICRA07}
H.~Kress Gazit, G.~Fainekos, and G.~J. Pappas.
\newblock Where's {W}aldo? {S}ensor-based temporal logic motion planning.
\newblock In \emph{{IEEE} International Conference on Robotics and Automation},
  2007.

\bibitem[Girard(2010{\natexlab{a}})]{Girard:2010}
A.~Girard.
\newblock Synthesis using approximately bisimilar abstractions: state-feedback
  controllers for safety specifications.
\newblock In \emph{Hybrid Systems: Computation and Control}, pages 111--120.
  ACM, 2010{\natexlab{a}}.

\bibitem[Girard(2010{\natexlab{b}})]{Girard:2010Opt}
A.~Girard.
\newblock Synthesis using approximately bisimilar abstractions: time-optimal
  control problems.
\newblock In \emph{{IEEE} Conference on Decision and Control}, pages 5893
  --5898, 2010{\natexlab{b}}.

\bibitem[Habets et~al.(2006)Habets, Kloetzer, and Belta]{Habets2006}
L.C.G.J.M. Habets, M.~Kloetzer, and C.~Belta.
\newblock Control of rectangular multi-affine hybrid systems.
\newblock In \emph{{IEEE} Conference on Decision and Control}, pages 2619
  --2624, 2006.

\bibitem[Kloetzer and Belta(2008{\natexlab{a}})]{Kloetzer:2008}
M.~Kloetzer and C.~Belta.
\newblock A fully automated framework for control of linear systems from
  temporal logic specifications.
\newblock \emph{IEEE Transactions on Automatic Control}, 53\penalty0
  (1):\penalty0 287 --297, 2008{\natexlab{a}}.

\bibitem[Kloetzer and Belta(2008{\natexlab{b}})]{Kloetzer:2008NonDet}
M.~Kloetzer and C.~Belta.
\newblock Dealing with nondeterminism in symbolic control.
\newblock In \emph{Hybrid Systems: Computation and Control}, pages 287--300.
  Springer-Verlag, 2008{\natexlab{b}}.

\bibitem[Kupferman and Vardi(2001)]{Vardi:safety}
O.~Kupferman and M.~Y. Vardi.
\newblock Model checking of safety properties.
\newblock \emph{Formal Methods in System Design}, 19:\penalty0 291--314, 2001.

\bibitem[Latvala(2003)]{Latvala:scheck}
T.~Latvala.
\newblock Efficient model checking of safety properties.
\newblock In \emph{In Model Checking Software. 10th International SPIN
  Workshop}, pages 74--88. Springer, 2003.

\bibitem[Lotka(1925)]{Lotka1925}
A.~Lotka.
\newblock \emph{Elements of physical biology}.
\newblock Dover Publications, Inc., New York, 1925.

\bibitem[Mazo and Tabuada(2011)]{Mazo:2011}
M.~Mazo and P.~Tabuada.
\newblock Symbolic approximate time-optimal control.
\newblock \emph{Systems and Control Letters}, 60\penalty0 (4):\penalty0 256 --
  263, 2011.

\bibitem[Nijmeijer and van~der Schaft(1990)]{vanderSchaft}
H.~Nijmeijer and A.J. van~der Schaft.
\newblock \emph{Nonlinear Dynamical Control Systems}.
\newblock Springer-Verlag, 1990.

\bibitem[Tabuada and Pappas(2003)]{TP03}
P.~Tabuada and G.~Pappas.
\newblock Model checking {LTL} over controllable linear systems is decidable.
\newblock In \emph{Lecture Notes in Computer Science}. Springer-Verlag, 2003.

\bibitem[Trelea(2003)]{PSOTralea}
I.~C. Trelea.
\newblock The particle swarm optimization algorithm: convergence analysis and
  parameter selection.
\newblock \emph{Information Processing Letters}, pages 317 -- 325, 2003.

\bibitem[Volterra(1926)]{Volterra1926}
V.~Volterra.
\newblock Fluctuations in the abundance of a species considered mathematically.
\newblock \emph{Nature}, 118:\penalty0 558--560, 1926.

\bibitem[Wolfgang(2002)]{Wolfgang2002}
T.~Wolfgang.
\newblock Infinite games and verification.
\newblock In \emph{Computer Aided Verification}, pages 58--65. Springer Berlin
  / Heidelberg, 2002.

\bibitem[Wongpiromsarn et~al.(2009)Wongpiromsarn, Topcu, and
  Murray]{Tok-Ufuk-Murray-CDC09}
T.~Wongpiromsarn, U.~Topcu, and R.~M. Murray.
\newblock Receding horizon temporal logic planning for dynamical systems.
\newblock In \emph{{IEEE} Conference on Decision and Control}, pages
  5997--6004, 2009.

\end{thebibliography}
\end{document}