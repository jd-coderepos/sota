\documentclass{llncs}

  
\usepackage{algo}  
\usepackage{epsfig}  
\usepackage{url}  
\usepackage{latexsym}   
\usepackage{boxedminipage}  
\urlstyle{tt}  

  
\begin{document}  
  
  
\newcounter{algo}  
\setcounter{algo}{0}  
\newenvironment{algo}[1]{\refstepcounter{algo}  
\begin{center}\sl Algorithm \thealgo: #1  
\begin{boxedminipage}{0.95\textwidth}  
}{\end{boxedminipage}\end{center}}

\newcommand{\mC}{\mathcal{C}}  
\newcommand{\mF}{\mathcal{F}}  





\newenvironment{preuve}{\noindent {\it Proof.}}{\vskip1ex}  
\newenvironment{preuveA1}{\noindent {\it Proof of conservation of   
Property .}}{\vskip1ex}  
\newenvironment{preuveA2}{\noindent {\it Proof of conservation of   
Property .}}{\vskip1ex}  
\newenvironment{preuveB}{\noindent {\it Proof of the invariants.}}  
{\vskip1ex}  
\newenvironment{OJO}{\noindent {\bf OJO:}}{\vskip1ex}  
  


\title{A Note On Computing Set Overlap Classes}    
  
 

\author{Pierre Charbit\inst{1}\quad
Michel Habib\inst{1} \quad
Vincent Limouzy\inst{1}\\
Fabien de Montgolfier\inst{1}\quad
Mathieu Raffinot\thanks{Corresponding author. E-mail: {\tt raffinot@liafa.jussieu.fr}}\inst{1}\quad Micha\"el Rao\inst{2}}

\institute{LIAFA, Univ. Paris Diderot - Paris 7, 75205 Paris Cedex 13, France.
\and
LIRMM, 161 rue Ada, 34392 Montpellier, France.}
\maketitle 
  
  
\begin{abstract}
Let  be a finite set of  elements and  a family of  subsets of  Two sets
 and  of  overlap if   and  Two sets  are in the same overlap
class if there is a series  of sets of
 in which each  overlaps. In this note, we focus
on efficiently identifying all overlap classes in  time. We thus revisit the clever algorithm of Dahlhaus
\cite{Dahlhaus00} of which we give a clear presentation and that we
simplify to make it practical and implementable in its real worst case
complexity. An useful variant of Dahlhaus's approach is also explained.  
\end{abstract}  
  
\section{Introduction}  
\label{sec:intro}  

Let  be a finite set of  elements and  a family of  subsets of 
Two sets  and  of  overlap if   and  We denote  as the sum of the sizes of all
. We define the overlap graph  as the
graph with all  as vertices and  A connected
component of this graph is called an {\em overlap class.}

In this note we focus on efficiently identifying all overlap classes of
 This problem is a classical one in graph clustering
related topics but it also appears frequently in many graph problems
related to graph decomposition \cite{Dahlhaus00} or PQ-tree
manipulation \cite{McConnell04}.

An efficient  time algorithm has already been
presented by Dahlhaus in \cite{Dahlhaus00}. The algorithm is very
clever but uses an off-line Lowest Common Ancestor algorithm (LCA) as
subroutine. From a theoretical point of view, off-line LCA queries
have been proved to be solvable in constant time (after a linear time
preprocessing) in a RAM model (accepting an additional constant time
specific register operation) but also recently in a pointer machine
model \cite{BKRW98}. However, in practice, it is very difficult to
implement these LCA algorithms in their real linear
complexity. Another difficulty with Dahlhaus's algorithm comes from
that its original presentation is difficult to follow. These two
points motivated this note. Dahlhaus's algorithm is really clever and
deserves a clear presentation, all the more so we show how to replace
LCA queries by set partitioning, which makes Dahlhaus's algorithm
easily implementable in practice in its real complexity. We also
provide a source code freely available in \cite{OurImpl07}. We
eventually explain how to simply modify Dahlhaus's approach to
efficiently compute a spanning tree of each connected component of the
overlap graph. This simplifies a graph construction in
\cite{McConnell04}.

\section{Dahlhaus's algorithm}
\label{dahlhausalgorithm}

The overlap graph  might have  edges,
which can be quadratic in  For instance, if ,


The approach of Dahlhaus is quite surprising since that, instead of
computing a subgraph of the overlap graph, Dahlhaus considers
a second graph  on the same vertex set but with
different edges. This graph has however a strong property: its
connected components are the same than that of ,
although that in the general case  is not a subgraph
of 
 
Let  be the list of all  sorted in
decreasing size order. The ordering of sets of equal size is arbitrarily
fixed. Given , we denote  as the largest
 taken in  order such that  and 
overlaps . Note that  might be undefined for some
sets of  In this latter case, in order to simplify the
presentation of some technical points, we write
 Dahlhaus's algorithm is based on the
following observation:

\begin{lemma}[\cite{Dahlhaus00}]
\label{thelemma}
Let  such that . Then for
all  such that  and ,  overlaps  or 
\end{lemma}
\begin{preuve}
If  does not overlap , as  and ,  Thus  Then, if  does not overlap , then
. But in this case, as   and overlaps . Therefore 
overlaps  or 
\end{preuve}

Let us assume that we already computed all  For each
 we compute the list  of all sets  to which  belongs. This list is sorted in increasing order of
the sizes of the sets. Computing and sorting all lists for all  can be done in  time using a global bucket
sort.

Dahlhaus's graph  is built on those lists. Let  be a set
containing  such that . Then for all
consecutive pairs  after  in  ( included, i.e. 
can be instanced by ) and such that ,
create an edge  in the graph .


\begin{lemma}[\cite{Dahlhaus00}]
The two graphs  and  have the same
connected components.
\label{samecomponent}
\end{lemma}
\begin{preuve}
 Let  such that  By construction there exists  such that  and  are
consecutive on  and there exists  that appears before
 on  such that  and such that
 By lemma \ref{thelemma},
 and  overlap either  or  As  and
 overlap, the sets , , , and  belong to
the same overlap class of . By extension, the vertices
of any connected path in  belong to the same overlap
class of . 

\noindent
 Let  be two overlapping sets, {\em
  i.e. }  Let  Assume w.l.o.g. that
   Then  and  Therefore, in , there exits a serie of consecutive
  pairs  from  to  that are linked in  In
  consequence,  and  are connected in 
\end{preuve}


Notice that the order of equally sized sets in  lists has no
importance for the construction of a Dahlhaus's graph. Figure
\ref{allexample} shows an example of an overlap graph and a Dahlhaus's
graph.



\begin{figure}[htb]
\vspace{-0.3cm}
  \centering
\includegraphics[width=8cm]{all}
\caption{Global example: (A) input family of 11 sets; (B) Overlap graph; (C)  lists; (D) Dahlhaus's graph. On (C) intervals defined by  are overlined. Notice that Dahlhaus's graph is not a subgraph of the Overlap graph.}
 \label{allexample}
\vspace{-0.3cm}
\end{figure}

\begin{lemma}[\cite{Dahlhaus00}]
Given all , the graph 
can be built in  time and its number of edges is less
than or equal to 
\end{lemma}
\begin{preuve}
To build the graph  from the  lists, it suffices to
go through each  list from the smallest set to the largest and
remenber at each step the largest  already seen. If the size
of the current set is smaller than or equal to this value, an edge is
created between the last two sets considered.
  
Let us now consider the number of edges of  As at most
one edge is created for each set in a list , at most 
edges are created after processing all lists.
\end{preuve}

Identifying the overlap classes of  can therefore be
done by a simple Depth First Search on  in  time. It remains however to explain how to efficiently compute
all 


\section{Computing all }

Let  be the list of all  sorted in
decreasing size order. The order of sets of equal size is not
important. We consider a boolean matrix  of size  such that each row represents a set 
in the order of , and each column an element  The
value  is  if and only if 

The first step of Dahlhaus's algorithm is to sort the columns of
 in lexicographical order, although that there is no detail
in \cite{Dahlhaus00} on how to do it efficiently in 
time. We postpone all explanations concerning this step to section
\ref{partitions} and we consider below that all columns of  are
lexicographically sorted. Figure \ref{matrix} shows the  matrix
for the set family of Figure \ref{allexample}.

\begin{figure}[htb]
\vspace{-0.3cm}
  \centering
\includegraphics[width=7cm]{BM}
\caption{Example continued:  matrix which lines are sorted by
decreasing sizes of  and which columns are sorted in lexicographic order.}
 \label{matrix}
\vspace{-0.3cm}
\end{figure}

For each  we denote 
(resp. ) the number of the column of  containing the
leftmost (resp. rightmost)  in the row of .

\begin{lemma}
 Let  such that  overlaps  and let  be the
 row of  in . Then there exists a row  higher than or equal
 to  such that  and
 
\label{goodlemma}
\end{lemma}
\begin{preuve}
 As  overlaps ,  Let  be the row
 corresponding to  in  Since  overlaps , there
 exist two indices  and a row  such that
 , such that one of the value of
  and  is  and the other 

We consider the highest  that satisfies these conditions.

In a first step, if  and , then, as 
and as all columns has been sorted in increasing lexicographical
order, there must exist a row  higher than  such that
 and  We thus consider now
w.l.o.g that  and 

Among all pairs of indices  and  such that
 and that there exits  such
that  and  let us consider one
pair  and , , that is associated to the
highest such  that we denote 

We now prove that  and
 If  ,
thus  and as  and that the columns
are sorted in lexicographical order, there should exits an higher row
 such that  and
, which contradicts  to be the
highest such row. Thus  Symmetrically,
the same argument holds to prove that

\end{preuve}


\begin{lemma}
 Let  Then  if and only if
 there exists a row  in  such that
  and 
 corresponding to a set  verifying . 
\label{uplemma}
\end{lemma}
\begin{preuve}
 If a set  corresponds to a row  in  such
  that  and
    obviously overlaps . As
      Let us
  assume that  and let  be its row in
   Then, by lemma \ref{goodlemma}, there exists a row  in 
  such that  and
   and such that  is higher than or
  equal to . As  verifies  the set  corresponding to  is also such that 
\end{preuve}

\begin{lemma}[\cite{Dahlhaus00}]
Let  such that  Then
 corresponds to the highest row  in  such that
 and  
\label{lemup}
\end{lemma}
\vspace*{-3mm}
[Notice that this row might be lower than the row corresponding to
  . This is the case for  and  since
   but also  in our example.]\\{b\}\{c\}\{d\}\{h\}\{f,g\}\{e\}.BMP_f\mbox{left}(X)\mbox{right}(X)\mbox{left}(X)\mbox{right}(X)P_f.O(|{\cal F}|+n)X \in {\cal F}P_fAM1 \leq i \leq |V|P_fX
\in {\cal F}i=\mbox{right}(X)\mbox{left}(X).X \in {\cal F}AM[\mbox{right}(X)]O(1)O(n+m)P_V\mbox{Max}(X).LFC=\{v_1,\ldots,
v_k\}PY\in {\cal F}C'C''.X \in {\cal F}|X| \leq |Y|\mbox{left}(X) \in C'\mbox{right}(X)\in C''.Y=\mbox{Max}(X).|X| = |Y|XYLFrYBM\mbox{left}(X)\in
C'\mbox{right}(X) \in C''BM[r,\mbox{left}(X)]=0BM[r,\mbox{right}(X)]=1,YX.|X|
\leq |Y|,\mbox{Max}(X)\not=\emptyset.rBM[r,\mbox{left}(X)]=0BM[r,\mbox{right}(X)]=1XYLFY=\mbox{Max}(X).P_VY \in {\cal F}LF\mbox{Max}(X)\emptysetC'C''ll+1v \in C''AM[v]X\mbox{left}(X)\leq lX\mbox{Max}(X) \leftarrow YYY' <_{LF} Y|Y'|=|Y|YAM\mbox{Max}(X), \; X
\in {\cal F}BMP_f\mbox{left}(X)\mbox{right}(X)X \in {\cal F},AMPXAM\mbox{left}(X)\mbox{right}(X)PAMCC'C''Y\mbox{left}(X) \in C'' \mbox{right}(X) \in
C''AM\mbox{right}(X)
\in C''\mbox{left}(X)\leq llPCC''LFAMYCCC''AM|X|\leq |Y|Y=\mbox{Max}(X).\mbox{Max}(X)XY\mbox{Max}(X)Y\mbox{Max}(X)|X|\leq |Y|XAMY\mbox{left}(X)\not\in Y\mbox{right}(X)\in Y.YCC'C''\mbox{right}(X)>l\mbox{left}(X)\leq llPCC''.nVP=\{a\}\{i,j,k,l\}\{b\}\{c,d\}\{e,f,g,h\}.PYO(|Y|)[i,j]CC
\not\subset YkY[i,j] 1 \leq k \leq j-i[i,j]kYC[i,j-k][j-k+1,j]kY\mbox{Max}(X), \; X \in {\cal F},\Theta(n+|{\cal F}|)\Theta(|{\cal F}|+n)AMleft()YCC'C''X\mbox{left}(X) \in C\mbox{right}(X)
\in C''\Theta(|C|+K+1)KAMO(1)AM\Theta(|{\cal F}|+n)OG({\cal F},E).D({\cal F},L).X,Y \in {\cal F}X \cap Y \not= \emptyset\mbox{Max}(X)\not=\emptyset|X| \leq |Y| \leq
|\mbox{Max}(X)|.r_YYBM.BM[r_Y,\mbox{left}(X)]=0,YX.BM[r_Y,\mbox{right}(X)]=0YXBM[r_Y,\mbox{right}(X)]=1Y\mbox{Max}(X).r_XXBMr\mbox{Max}(X).BM[r_Y,left(X)]=0,BM[r_X,left(X)]=1X \cap Y \not=
\emptyset|X| \leq |Y|YXBM[r_Y,left(X)]=1.BM[r_Y,\mbox{right}(X)]=0,BM[r_X,right(X)]=1YX.BM[r_Y,\mbox{right}(X)]=1,BM[r,\mbox{right}(X)]=1BM[r,\mbox{left}(X)]=0|Y| \leq |\mbox{Max}(X)|Y\mbox{Max}(X)\mbox{LQ}_1\mbox{LQ}_2\mbox{right}(X)\mbox{left}(X)Pf_{\tiny \mbox{right}(X)}Pf_{\tiny \mbox{left}(X)}SLX..YW..SL(v)\mbox{Max}(X)\not=\emptyset|W|\leq |\mbox{Max}(X)|X-..Y-W-..D({\cal F},L)(X,\mbox{Max}(X))(\mbox{left(X)},\mbox{right}(X),X,Y,\mbox{Max}(X)),(\mbox{left(X)},\mbox{right}(X),X,W,\mbox{Max}(X)),..X\mbox{Max(X)}LQ_1(\mbox{left(X)},\mbox{right}(X),X,Y,\mbox{Max}(X))YSL(Pf_{\mbox{\tiny left(X)}})(X,Y).YSL(Pf_{\mbox{\tiny right}(X)}).(X,Y).(Y,\mbox{Max}(X)).LQ_1YSL(Pf_{\tiny \mbox{left(X)}})YSL(Pf_{\mbox{\tiny left(X)}})(\mbox{left(X)},\mbox{right}(X),X,Y,\mbox{Max}(X))LQ_2LQ_2(\mbox{left(X)},\mbox{right}(X),X,Y,\mbox{Max}(X))LQ_2YSL(Pf_{\mbox{\tiny right(X)}}).SL(v)LFLQ_1SL(v)LQ_1\mbox{left}(X)\mbox{left}(X)LFY.O(n+|{\cal F}|)LQ_1SL()O(n+|{\cal F}|)|V|LQ_2.{\cal F}O(n+|{\cal F}|)ABABX..Y..ZSL(v)|Y|\leq
|\mbox{Max}(X)||\mbox{Max}(X)| \leq |\mbox{Max}(Y)||Z|\leq
|\mbox{Max}(Y)|.X,Y,ZX\mbox{Max}(X)YX\mbox{Max}(X)Y\mbox{Max}(Y)ZY\mbox{Max}(Y)v \in A \cap B.|A|\leq |B|.\mbox{Max}(A)\not=\emptyset|\mbox{Max}(A)| \geq |B|.SL(v)kA..Y_1..Y_2..Y_k..B|B| \leq |\mbox{Max}(Y_k)|,|Y_k|
\leq |\mbox{Max}(Y_{k-1})|,|Y_1| \leq |\mbox{Max}(A)|.ABO(n+|{\cal F}|)$ time since
all steps can be done in this time.
\end{preuve}

\noindent
An example (continued) of the resulting subgraph is shown in Figure
\ref{allexample2}.

\begin{thebibliography}{1}

\bibitem{BKRW98}
A.~L. Buchsbaum, H.~Kaplan, A.~Rogers, and J.~R. Westbrook.
\newblock Linear-time pointer-machine algorithms for least common ancestors,
  mst verification, and dominators.
\newblock In {\em Proceedings of the thirtieth annual ACM symposium on Theory
  of computing (STOC)}, pages 279--288. ACM Press, 1998.

\bibitem{Dahlhaus00}
E.~Dahlhaus.
\newblock Parallel algorithms for hierarchical clustering and applications to
  split decomposition and parity graph recognition.
\newblock {\em J. Algorithms}, 36(2):205--240, 2000.

\bibitem{McConnell04}
R.~M. McConnell.
\newblock A certifying algorithm for the consecutive-ones property.
\newblock In {\em SODA}, pages 768--777, 2004.

\bibitem{OurImpl07}
M.~Rao.
\newblock Set overlap classes computation, source code.
\newblock 2007.
\newblock Freely available at
  \url{http://www.liafa.jussieu.fr/~raffinot/overlap.html}.

\end{thebibliography}

\end{document}
