\newif\ifICALP\ICALPtrue


\documentclass[11pt,onecolumn]{article}



\usepackage[left=1.0in,top=1.0in,right=1.05in,bottom=1.0in,nohead,textheight=10in,footskip=0.3in]{geometry}






\usepackage{amsfonts,amsmath,epsfig}

\usepackage{amsthm,amssymb,amsfonts,epsfig,graphicx}
\newtheorem{theorem}{Theorem}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{remark}[theorem]{Remark}


\newcommand{\myparagraph}[1]{{\vspace*{2pt}\noindent\bf{#1}~~}}


\def\D{{\cal D}}

\def\DeltaCeil{{\lceil\Delta\rceil}}

\long\def\ignore#1{}
\def\myps[#1]#2{\includegraphics[#1]{#2}}
\def\etal{{\em et al.}}
\def\Bar#1{{\bar #1}}
\def\br(#1,#2){{\langle #1,#2 \rangle}}
\def\setZ[#1,#2]{{[ #1 .. #2 ]}}
\def\Pr{\mbox{\rm Pr}}
\def\REACHED{\mbox{\rm REACHED}}
\def\setof#1{{\left\{#1\right\}}}
\def\suchthat#1#2{\setof{\,#1\mid#2\,}} \def\event#1{\setof{#1}}
\def\q={\quad=\quad}
\def\qq={\qquad=\qquad}
\def\calK{{\cal K}}
\def\calKhalf{{\calK^{\mbox{\tiny }}}}
\def\calB{{\cal B}}
\def\calA{{\cal A}}
\def\calC{{\mathscr C}}
\def\calD{{\cal D}}
\def\calE{{\cal E}}
\def\calG{{\cal G}}
\def\calL{{\cal L}}
\def\calN{{\cal N}}
\def\calP{{\cal P}}
\def\calR{{\cal R}}
\def\calS{{\cal S}}
\def\calT{{\cal T}}
\def\calU{{\cal U}}
\def\calV{{\cal V}}
\def\calO{{\cal O}}
\def\X{{\cal X}}
\def\Xmin{{\cal X^-}}
\def\Xmax{{\cal X^+}}
\def\Xminmax{{\cal X^\star}}
\def\Xint{{\cal X^\circ}}
\def\one{{\bf 1}}
\def\s{\footnotesize}
\def\calNG{{\cal N_G}}
\def\psfile[#1]#2{}
\def\psfilehere[#1]#2{}
\def\epsfw#1#2{\includegraphics[width=#1\hsize]{#2}}
\def\assign(#1,#2){\langle#1,#2\rangle}
\def\edge(#1,#2){(#1,#2)}
\def\VS{\calV^s}
\def\VT{\calV^t}
\def\inv{{\tt inv}}
\def\slack(#1){\texttt{slack}({#1})}
\def\barslack(#1){\overline{\texttt{slack}}({#1})}
\def\NULL{\texttt{NULL}}
\def\PARENT{\texttt{PARENT}}
\def\GRANDPARENT{\texttt{GRANDPARENT}}
\def\TAIL{\texttt{TAIL}}
\def\HEADORIG{\texttt{HEADORIG}}
\def\TAILORIG{\texttt{TAILORIG}}
\def\HEAD{\texttt{HEAD}}
\def\CURRENTEDGE{\texttt{CURRENTEDGE}}

\def\unitvec(#1){{{\bf u}_{#1}}}
\def\uvec{{\bf u}}
\def\vvec{{\bf v}}
\def\Nvec{{\bf N}}



\newcommand{\hatbx}{\mbox{\boldmath }}
\newcommand{\hatby}{\mbox{\boldmath }}
\newcommand{\hatbz}{\mbox{\boldmath }}
\def\dom{\texttt{dom~\!\!\!}}
\def\sign{\texttt{sign~\!\!\!}}
\def\INWARD{\texttt{INWARD}}
\def\OUTWARD{\texttt{OUTWARD}}
\def\NEIB{\texttt{NEIB}}
\def\barINWARD{\texttt{INWARD}^\ast}
\def\barOUTWARD{\texttt{OUTWARD}^\ast}
\def\barNEIB{\texttt{NEIB}^\ast}


\newcommand{\bb}{\mbox{\boldmath }}
\newcommand{\bx}{\mbox{\boldmath }}
\newcommand{\by}{\mbox{\boldmath }}
\newcommand{\bz}{\mbox{\boldmath }}

\newcommand{\bX}{\mbox{\boldmath }}
\newcommand{\bY}{\mbox{\boldmath }}
\newcommand{\bZ}{\mbox{\boldmath }}

\newcommand{\bu}{\mbox{\boldmath }}
\newcommand{\bv}{\mbox{\boldmath }}
\newcommand{\bw}{\mbox{\boldmath }}
\newcommand{\be}{\mbox{\boldmath }}
\newcommand{\bvarphi}{\mbox{\boldmath }}
\newcommand{\blambda}{\mbox{\boldmath }}
\newcommand{\bdelta}{\mbox{\boldmath }}













\begin{document}
\title{Submodularity on a tree: \\ Unifying -convex and bisubmodular functions}
\author{Vladimir Kolmogorov \\ ~ \\ \normalsize University College London \\ {\normalsize\tt v.kolmogorov@cs.ucl.ac.uk} }
\date{}

\maketitle              
\begin{abstract}
We introduce a new class of functions that can be minimized in polynomial time in the value oracle model.
These are functions  satisfying 
where the domain of each variable  corresponds to nodes of a rooted binary tree, and 
operations  are defined with respect to this tree.
Special cases include previously studied -convex and bisubmodular functions,
which can be obtained with particular choices of trees.
We present a polynomial-time algorithm for minimizing functions in the new class.
It combines Murota's steepest descent algorithm for -convex functions
with bisubmodular minimization algorithms.

\end{abstract}
\section{Introduction}\label{sec:intro}
Let  be a function of  variables  where ;
thus . We call elements of  {\em labels}, and the argument of  a {\em labeling}. 
Denote  to be the set of nodes. 
We will consider functions  satisfying

where binary operations  (expressed component-wise via operations )
are defined below.

There are several known cases in which function  can be minimized in polynomial time in the value oracle model.
The following two cases will be of particular relevance:
\begin{itemize}
\item {\em -convex functions\footnote{Pronounced as ``L-natural convex''.}}:  where  is integer, 
,
. Property~\eqref{eq:submodularity} is then called {\em discrete midpoint convexity}~\cite{Murota:book}.
\item {\em Bisubmodular functions}: , , 
.
\end{itemize}

In this paper we introduce a new class of functions which includes the two classes above as special cases.
We assume that labels in each set  are nodes of a tree  with a designated root .
Define a partial order  on  as follows:  if  is an ancestor of ,
i.e.\  lies on the path from  to  (). For two labels  let  be unique path from  to  in ,
 be the number of edges in this path, and  for integer  be the -th node of this path
so that  and . If  then we set by definition .

With this notation, we can now define , 
as the unique pair of labels satisfying the following two conditions:
(1) 
where , and (2)  (Figure~\ref{fig:trees}(a)).
We call functions  satisfying condition~\eqref{eq:submodularity} with such choice of  {\em strongly tree-submodular}.
Clearly, if each  is a chain with nodes  and  being the root (Figure~\ref{fig:trees}(b)) then strong tree-submodularity is equivalent
to -convexity. Furthermore, if each  is the tree shown in Figure~\ref{fig:trees}(c) then strong tree-submodularity is equivalent to bisubmodularity.

The main result of this paper is the following
\begin{theorem}
If each tree  is binary, i.e.\ each node has at most two children, then a strongly tree-submodular function 
can be minimized in time polynomial in  and .
\label{th:polynomiality}
\end{theorem}

\begin{figure*}[!t]
\begin{center}
\begin{tabular}{c@{\hspace{50pt}}c}
\includegraphics[scale=0.32]{trees1.eps} & \includegraphics[scale=0.32]{trees2.eps} \vspace{-10pt} \\ 
\hspace{30pt} (a) & (b) \hspace{50pt} (c) \hspace{50pt} (d) \hspace{28pt} \vspace{-10pt}
\end{tabular}
\end{center}
\caption{{\bf Examples of trees. Roots are always at the bottom.} (a) Illustration of the definition of , ,  and . 
(b) A tree for -convex functions. (c) A tree for bisubmodular functions. (d) A tree for which a weakly tree-submodular function can be minimized efficiently (see section~\ref{sec:weak}).
}
\label{fig:trees}
\end{figure*}

\myparagraph{Weak tree-submodularity} We will also study alternative operations on trees, which we denote as  and .
For labels  we define  as their highest common ancestor, i.e.\ the unique node on the path 
which is an ancestor of both  and . The label  is defined as the unique label on the path 
such that the distance between  and  is the same as the distance between  and  (Figure~\ref{fig:trees}(a)).

We say that function  is {\em weakly tree-submodular} if it satisfies

We will show that strong tree-submodularity~\eqref{eq:submodularity} implies weak tree-submodularity \eqref{eq:submodularity:weak},
which justifies the terminology. If all trees are chains shown in Figure~\ref{fig:trees}(b) ( with  being the root)
then  and  correspond to the standard operations ``meet'' and ''join'' ( and ) on an integer lattice.
It is well-known that in this case weakly tree-submodular functions can be minimized in time polynomial in  and ~\cite{Topkis:78,Murota:book}.
In section~\ref{sec:weak} we give a slight generalization of this result; namely, we allow trees shown in Figure~\ref{fig:trees}(d).



\subsection{Related work} 
Studying operations  that give rise to tractable optimization problems received a considerable attention in the literature. Some known examples of
such operations are reviewed below. For simplicity, we assume that domains  (and operations ) are the same for all nodes:
 for some finite set .


\myparagraph{Submodular functions on lattices} 
The first example that we mention is the case when  is a distributive lattice and  
are the meet and joint operations on this lattice. Functions that satisfy~\eqref{eq:submodularity} for this choice of  and  
are called {\em submodular functions} on ; it is well-known that they can be minimized in strongly polynomial time~\cite{Grotschel:88,Schrijver:00,Iwata:01}.

Recently, researchers considered submodular functions on non-distributive lattices.
It is known that a lattice is non-distributive if it contains as a sublattice either the pentagon 
or the diamond .
Krokhin and Larose~\cite{KrokhinLarose:08} proved tractability for the pentagon case, using nested applications of a submodular minimization algorithm.
The case of the diamond was considered by Kuivinen~\cite{Kuivinen:TR}, who proved pseudo-polynomiality of the problem.
The case of general non-distributive lattices is still open.

\myparagraph{-convex functions}
The concept of -convexity was introduced by Fujishige and Murota~\cite{FujishigeMurota:00} as a variant of -convexity by Murota~\cite{Murota:98}. -convexity is equivalent to the combination of submodularity and integral 
convexity~\cite{FavatiTardella:90} (see \cite{Murota:book} for details).

The fastest known algorithm for minimizing -convex functions is the {\em steepest descent} algorithm
of Murota~\cite{Murota:IEICE00,Murota:book,Murota:SIAM03}. 
Murota proved in~\cite{Murota:SIAM03} that algorithm's complexity is 
where  and  is the complexity of a submodular minimization algorithm for a function with  variables.
The analysis of Kolmogorov and Shioura~\cite{KS:09} improved the bound to .
In section~\ref{sec:alg} we review Murota's algorithm (or rather its version without scaling that has complexity .)

Note, the class of -convex functions is a subclass of submodular functions on a totally ordered set .

\myparagraph{Bisubmodular functions}
Bisubmodular functions were introduced by Chandrasekaran and Kabadi
as rank functions of {\em (poly-)pseudomatroids}~\cite{Chandrasekaran:88,Kabadi:90}.
Independently, Bouchet~\cite{Bouchet:87} introduced the concept of -matroids which is equivalent
to pseudomatroids.
Bisubmodular functions and their generalizations have also been considered by Qi~\cite{Qi:88},
Nakamura~\cite{Nakamura:88}, Bouchet and Cunningham~\cite{Bouchet:95} and Fujishige~\cite{Fujishige:91}.

It has been shown that some submodular minimization algorithms can be generalized to bisubmodular functions.
Qi~\cite{Qi:88} showed the applicability of the ellipsoid method.
Fujishige and Iwata~\cite{Fujishige:06} developed a weakly polynomial combinatorial algorithm for minimizing bisubmodular functions with
complexity  where  is the number of calls to the evaluation oracle and  is an upper bound on function values.
McCormick and Fujishige~\cite{McCormick:10} presented a strongly combinatorial version with
complexity , as well as a  fully combinatorial variant that does not use divisions.
The algorithms in \cite{McCormick:10} can also be applied for minimizing a bisubmodular
function over a {\em signed ring family}, i.e.\ a subset  closed under  and .

\myparagraph{Valued constraint satisfaction and multimorphisms}
Our paper also fits into the framework of {\em Valued Constraint Satisfaction Problems} (VCSPs)~\cite{Cohen:AI06}.
In this framework we are given a {\em language} , i.e.\ a set of cost functions 
where  is a fixed discrete domain and  is a function of arity  (different functions  may have different arities).
A {\em -instance} is any function  that can be expressed as a finite sum of functions from :

where  is a finite set of terms,  is a function of arity , and  are indexes in .
A finite language  is called {\em tractable} if any -instance can be minimized in polynomial time,
and {\em NP-hard} if this minimization problem is NP-hard. These definitions are extended to infinite languages  
as follows:  is called tractable if any finite subset  is tractable,
and NP-hard if there exists a finite subset  which is NP-hard.

Classifying the complexity of different languages has been an active research area.
A major open question in this line of research is the
\emph{Dichotomy Conjecture} of Feder and Vardi (formulated for the {\em crisp} case), which states that every
constraint language is either tractable or NP-hard~\cite{Feder98:monotone}.
So far such dichotomy results have been obtained for some special cases, as described below.

A significant progress has been made in the {\bf crisp} case, i.e.\ when  only contains functions .
The problem is then called {\em Constraint Satisfaction} (CSP). The dichotomy is known to hold 
for languages with a 2-element domain (Schaefer~\cite{Schaefer78:complexity}),
languages with a 3-element domain (Bulatov~\cite{Bulatov06:3-elementJACM}),
conservative languages\footnote{A crisp language  is called conservative if it contains all unary cost functions  \cite{Bulatov03:conservative}.
A general-valued language is called conservative if it contains all unary cost functions  \cite{KZ10:TRa,KZ10:TRb,K10:TRc}.
} (Bulatov \cite{Bulatov03:conservative}),
and languages containing a single relation without sources and sinks (Barto~\etal\ \cite{Barto09:siam}).
All dichotomy theorems above have the following form: if all functions in  satisfy a certain
condition given by one or more {\em polymorphisms} then the language is tractable, otherwise it is NP-hard.

For general VCSPs the dichotomy has been shown to hold for Boolean languages, i.e.\ languages with a 2-element domain (Cohen~\etal\ \cite{Cohen:AI06}),
conservative languages (Kolmogorov and \v{Z}ivn\'y~\cite{KZ10:TRa,KZ10:TRb,K10:TRc}, who generalized
previous results by Deineko~\etal~\cite{DeinekoJKK08} and Takhanov \cite{Takhanov10:stacs}),
and -valued languages with a 4-element domain (Jonsson~\etal~\cite{Jonsson:TR11}).
In these examples tractable subclasses are characterized by one or more {\em multimorphisms},
which are generalizations of polymorphisms. A multimorphism of arity  over  is
a tuple  where  is an operation .
Language  is said to admit multimorphism  if every function  satisfies

for all labelings  with , , .
(The pair of operations  used in~\eqref{eq:submodularity} is an example of a binary multimorphism.)
The tractable classes mentioned above (for ) are characterized by 
{\em complementary pairs of STP and MJN} multimorphisms~\cite{KZ10:TRb}
(that generalized {\em symmetric tournament pair (STP)} multimorphisms~\cite{Cohen:TCS08}),
and {\em 1-defect chain} multimorphisms~\cite{Jonsson:TR11}
(that generalized tractable weak-tree submodular functions in section \ref{sec:weak} originally introduced in~\cite{K10:TSv2}).

To make further progress on classifying complexity of VCSPs, it is important to study which
multimorphisms lead to tractable optimisation problems. Operations  and  introduced in this paper
represent new classes of such multimorphisms: to our knowledge, previously researchers have not considered multimorphisms
defined on trees.

\myparagraph{Combining multimorphisms} Finally, we mention that some constructions, namely {\em Cartesian products} and {\em Malt'stev products},
can be used for obtaining new tractable classes of binary multimoprhisms from existing ones~\cite{KrokhinLarose:08}.
Note, Krokhin and Larose~\cite{KrokhinLarose:08} formulated these constructions only
for lattice multimorphisms , but the proof in~\cite{KrokhinLarose:08} actually applies to arbitrary binary multimorphisms .


\section{Steepest descent algorithm}\label{sec:alg}

It is known that for -convex functions local optimality implies global optimality~\cite{Murota:book}.
We start by generalizing this result to strongly tree-submodular functions. 
Let us define the following ``local'' neighborhoods of labeling :

where  means that  for all , and  is the -distance between  and .
Clearly, the restriction of  to  is a submodular function,
and the restriction of  to  is bisubmodular assuming that each tree  is binary\footnote{If label 
has less than two children in  then variable's domain after restriction will be a strict subset of .
Therefore, we may need to use a bisubmodular minimization algorithm over a signed ring familiy ~\cite{McCormick:10}.}.

\begin{proposition} Suppose that {\em .} Then  is a global minimum of .
\label{prop:local}
\end{proposition}
\begin{proof}
First, let us prove that .
Let  be a minimizer of  in , and denote .
We treat set  as a tree with root .
Clearly, the restriction of  to  is an -convex function under 
the induced operations , . It is known that for -convex functions
optimality of  in sets  and 
suffices for optimality of  in ~\cite[Theorem 7.14]{Murota:book}, therefore .
This proves that .

Let us now prove that  is optimal in .
Suppose not, then there exists  with .
Among such labelings, let us choose  with the minimum distance . We must have , so . Clearly,
 and .
Strong tree-submodularity and the fact that 
imply that the cost of at least one of the labelings ,  is smaller than .
This contradicts to the choice of .
\end{proof}

Suppose that each tree  is binary.
The proposition shows that a greedy technique for computing a minimizer of  would work. We can start with an arbitrary labeling ,
and then apply iteratively the following two steps in some order:
\begin{itemize}
\item[(1)] Compute minimizer  by invoking a submodular minimization algorithm, replace  with  if .
\item[(2)] Compute minimizer  by invoking a bisubmodular minimization algorithm, replace  with  if . 
\end{itemize}
The algorithm stops if neither step can decrease the cost. Clearly, it terminates in a finite number of steps and produces an optimal solution.
We will now discuss how to obtain a polynomial number of steps. We denote .

\subsection{-convex case}
For -convex functions the {\em steepest descent} algorithm described above was first proposed by Murota~\cite{Murota:IEICE00,Murota:book,Murota:SIAM03},
except that in step 2 a submodular minimization algorithm was used.
Murota's algorithm actually computes both of  and  for the same  and then chooses a better one by comparing costs
 and . A slight variation was proposed by Kolmogorov and Shioura~\cite{KS:09}, who allowed an arbitrary order of steps.
Kolmogorov and Shioura also established a tight bound on the number of steps of the algorithm by proving the following theorem.

\begin{theorem}[\cite{KS:09}]
Suppose that each tree  is a chain. For a labeling  define

\ifICALP
~\!\!\!\!\!\!\!\!\rho^-(\bx)\!=\!\min \{ \rho(\bx,\by)  |  \by \!\in\! OPT^{-}[\bx] \}, OPT^-[\bx]\!=\!\arg\!\min \{f(\by) |\by\!\in\!\D,\by\preceq\bx\} \; ~ \label{eq:rho:a} \\
~\!\!\!\!\!\!\!\!\rho^+(\bx)\!=\!\min \{ \rho(\bx,\by)  |  \by \!\in\! OPT^{+}[\bx] \}, OPT^+[\bx]\!=\!\arg\!\min \{f(\by) |\by\!\in\!\D,\by\succeq\bx\} \; ~ \label{eq:rho:b}
\else
\rho^-(\bx)=\min \{ \rho(\bx,\by) \: | \: \by \in OPT^{-}[\bx] \}, \quad OPT^-[\bx]=\arg \min \{f(\by) \:|\:\by\in\D,\by\preceq\bx\} \label{eq:rho:a} \\
\rho^+(\bx)=\min \{ \rho(\bx,\by) \: | \: \by \in OPT^{+}[\bx] \}, \quad OPT^+[\bx]=\arg \min \{f(\by) \:|\:\by\in\D,\by\succeq\bx\} \label{eq:rho:b}
\fi

\begin{itemize}
\item[(a)] Applying step (1) or (2) to labeling  does not increase  and .
\item[(b)] If  then applying step (1) to  will decrease  by 1.
\item[(c)] If  then applying step (2) to  will decrease  by 1.
\end{itemize}
\label{th:KS}
\end{theorem}
In the beginning of the algorithm we have  and ,
so the theorem implies that after at most  calls to step (1) and  calls to step (2) we get
. The latter condition means that
,
and thus, by proposition~\ref{prop:local},  is a global minimum of .

\subsection{General case}
We now show that the bound  on the number of steps 
is also achievable for general strongly tree-submodular functions. 
We will establish it for the following version of the steepest descent algorithm:
\begin{itemize}
\item[S0] Choose an arbitrary labeling  and set .
\item[S1] Compute minimizer . If 
then set  and repeat step S1, otherwise go to step S2.
\item[S2] Compute minimizer . If  then set  and repeat step S2, otherwise terminate.
\end{itemize}
Note, one could choose  to be the root of tree  for each node , then step {\tt S1} would be redundant. 

\begin{theorem}
(a) Step {\tt S1} is performed at most  times. (b) Each step {\tt S2} preserves the following
property:

(c) Step {\tt S2} is performed at most  times.
(d) Labeling  produced upon termination of the algorithm is a minimizer of .
\label{th:complexity}
\end{theorem}





\begin{proof}
For a labeling  denote .
We will treat domain  as the collection of chains with roots  and leaves . Let  be the quantity defined in~\eqref{eq:rho:a}. There holds

Indeed, this equivalence can be obtained by applying proposition~\ref{prop:local} to function  restricted to .

\myparagraph{(a)}
When analyzing the first stage of the algorithm, we can assume without loss of generality
that , i.e.\ each tree  is a chain with the root  and
the leaf . 
Indeed, removing the rest of the tree will not affect the behaviour of steps {\tt S1}.
With such assumption, function  becomes -convex. 
By theorem~\ref{th:KS}(b), steps {\tt S1} will terminate after at most  steps.

\myparagraph{(b,c)} Property~\eqref{eq:complexity:b} (or equivalently ) clearly
holds after termination of steps {\tt S1}. Let  be the labeling upon
termination of steps {\tt S2}. 
When analyzing the second stage of the algorithm, we can assume without loss of generality
that , i.e.\ each tree  is a chain with the root  and
the leaf . 
Indeed, removing the rest of the tree will not affect the behaviour of steps {\tt S2}.
Furthermore, restricting  to  does not affect the definition of  for .

By theorem~\ref{th:KS}(a), steps {\tt S2} preserve ; this proves part (b).
Part (c) follows from theorem~\ref{th:KS}(c).

\myparagraph{(d)} When steps {\tt S2} terminate, we have .
Combining this fact with condition~\eqref{eq:complexity:b} and using proposition~\ref{prop:local}
gives that upon algorithm's termination  is a minimizer of .

\end{proof}




\section{Translation submodularity}\label{sec:sw}
In this section we derive an alternative definition of strongly tree-submodular functions.
As a corollary, we will obtain that strong tree submodularity~\eqref{eq:submodularity}
implies weak tree submodularity~\eqref{eq:submodularity:weak}.

Let us introduce another pair of operations on trees. 
Given labels  and an integer , we define 

In words,  is obtained as follows: (1) move from  towards  by  steps,
stopping if  is reached earlier; (2) keep moving until the current label becomes an ancestor of .
 is the label on the path  such that the distances
 and  are the same,
as well as distances  and .
Note, binary operations  
(and corresponding operations ) are in general non-commutative.
One exception is , in which case   reduce to the commutative
operations defined in the introduction:  and .

For fixed labels  it will often be convenient to rename nodes in  to be
consecutive integers so that  and . Then we have ,  and


\begin{theorem} (a) If  is strongly tree-submodular then for any  and integer  there holds
{\em

\em }
(b) If~\eqref{eq:submodularity:dir} holds for any  and  then  is strongly tree-submodular.
\label{th:submodularity:dir}
\end{theorem}

Note, this result is well-known for -convex functions~\cite[section 7.1]{Murota:book},
i.e.\ when all trees are chains shown in Figure~\ref{fig:trees}(b); inequality~\eqref{eq:submodularity:dir} was then written as 
, and was called {\em translation submodularity}.
In fact, translation submodularity is one of the key properties of -convex functions, and was heavily used, for example, in~\cite{KS:09}
for proving theorem~\ref{th:KS}.

Setting  in theorem \ref{th:submodularity:dir}(a) gives
\begin{corollary}
A strongly tree-submodular function  is also weakly tree-submodular, i.e.\ \eqref{eq:submodularity} implies \eqref{eq:submodularity:weak}.
\end{corollary}

A proof of parts (b) and (a) of theorem~\ref{eq:submodularity:dir} is given 
in sections \ref{ref:proof:partb} and \ref{ref:proof:parta} respectively.
In both proofs we always implicitly assume
that for each  labels in  are renamed to be consecutive integers with  and .

\subsection{Proof of theorem~\ref{th:submodularity:dir}(b)}\label{ref:proof:partb}
We prove inequality \eqref{eq:submodularity} for  using induction on .
The base case , or , is trivial; suppose that .
Denote  and . Two cases are possible.

\myparagraph{\underline{Case 1}}  is even.
We can assume without loss of generality that there exists  such that  and
.
(If there is no such , we can simply swap  and ; inequality \eqref{eq:submodularity}
will be unaffected since operations  are commutative, and ,  will not change.)
Consider labelings  defined as follows:

for each . We claim that

Indeed, for each node  one of the following holds:
\begin{itemize}
\item[] . Then , , so (a) and (b) hold for node .
We also have ,
which implies (c) and (d). 
\item[]  and . Then , , 
; as above, this implies (a)-(d). 
\item[]  and . Then , .
Checking that (a)-(d) hold is straightforward.
\end{itemize}
We have , and so . Therefore, 

where the first inequality follows from the induction hypothesis and the second one follows from \eqref{eq:submodularity:dir}.
Summing these inequalities and subtracting  from both sides using (a)-(d) gives \eqref{eq:submodularity}.

\myparagraph{\underline{Case 2}}  is odd.
By swapping  and , if necessary, we can assume without loss of generality that there exists  such that  and
. (Note, we cannot have  and  since  is odd).
Consider labelings  defined as follows:

for each . We claim that

Indeed, for each node  one of the following holds:
\begin{itemize}
\item[] . Then , , so (a) and (b) hold for node .
We also have ,
which implies (c) and (d).
\item[]  and . Then , ,
so (a) and (b) hold for node .
(c) and (d) hold since .
\item[]  and . Then ,
.
Checking that (a)-(d) hold is straightforward.
\end{itemize}
We have , and so . Therefore, 

where the first inequality follows from the induction hypothesis and the second one follows from \eqref{eq:submodularity:dir}.
Summing these inequalities and subtracting  from both sides using (a)-(d) gives \eqref{eq:submodularity}.


\subsection{Proof of theorem~\ref{th:submodularity:dir}(a)}\label{ref:proof:parta}

We say that the triplet  is {\em valid} if  and .
We denote ; we have .
Let us introduce a partial order  over valid triplets as the lexicographical order with variables
. Note, the last component  is the least significant.
We use induction on this partial order. 
The induction base is trivial: if the first  components are zeros then  so~\eqref{eq:submodularity:dir} is an equality,
and if the last component is minimal (i.e.\ ) then  and ,
so~\eqref{eq:submodularity:dir} is again an equality. Suppose that  and . 

Consider integer , and denote  and  for .
Suppose that  for all nodes . (This holds, for example, if .)
Denote , then .
We claim that

In order to prove it, let us consider node . Property (a) follows from the fact that .
Property (b) is the definition of . To prove (c), consider two possible cases:
\begin{itemize}
\item , so  and . The latter condition and the fact
 imply that , therefore . This leads to (c).
\item . If  then condition (c) is straightforward (it follows from ). 
Suppose that , then from definition of  we have , or . This leads to (c).
\end{itemize}
Finally, properties (c) and (d) are equivalent since
\ifICALP

\else

\fi

Now suppose that in addition to conditions  there holds  and . 
Then we have  and , so by the induction hypothesis

Summing these inequalities and subtracting  from both sides using (a)-(d) gives \eqref{eq:submodularity:dir}.

Let us describe cases when the argument above can be applied; such cases can be eliminated from consideration. First, suppose that  for some node ,
then there exists  such that the labeling  has at least one node 
with . Let us choose the minimum integer  that has this property. Then  for all
nodes , since  would contradict to the minimality of chosen . We also have  and 
 (since ), so the conditions above are satisfied. Therefore, from now on we assume without loss of generality
that  for all nodes .


We can also take . Condition  is then satisfied for all nodes. Therefore, we can assume without loss of generality 
that either  or  where , , otherwise the induction argument above could be applied.
Suppose that . This is equivalent to ,
or to the following condition for all nodes : either  or . It can be checked that
 and . Furthermore,
, so~\eqref{eq:submodularity:dir} follows by the induction hypothesis. We thus assume from now on
that .

Equations below summarize definitions and assumptions made so far:

z_i &=& x_i \uparrow^d y_i \\
y'_i &=& x_i \uparrow^{d+1} y_i = y_i \\
x'_i & = & x_i \downarrow_d y_i \\
\delta_i & = & y_i - z_i = x'_i - x_i \in \{0,1\}

i \in S\hspace{22pt}    & \Rightarrow & x_i + d = z_i = y_i-1 \\
i \in V-S & \quad\Rightarrow\quad & x_i \uparrow^d y_i = y_i \mbox{~~~and~~~} x_i\downarrow_d y_i=x_i=x'_i


If  is empty then , , so inequality~\eqref{eq:submodularity:dir}
is trivial. Thus, we can assume that  is non-empty.
Suppose that  contains two distinct nodes  and . Let us modify labelings  and  as follows:
for node  set , . It is straightforward to check that conditions~\eqref{eq:dir:proof} for 
still hold. Furthermore, , , so  and .
Applying the argument described above gives~\eqref{eq:submodularity:dir}.

We are left with the case when  contains a single node . 
We will consider 5 possible subcases.
In 4 of them, we will do the following: (i) specify new labelings  and  with  for each node ;
(ii) specify four identities involving  such that the right-hand sides contain expressions ,
 and the left-hand sides contain expressions of the form 
, , 
,  
where  is one of the operations 
and  is the corresponding ``symmetric'' operation. This will describe how to prove~\eqref{eq:submodularity:dir}:
we would need to sum two inequalities

that hold either by strong tree-submodularity or by the induction hypothesis, then use provided identities to prove~\eqref{eq:submodularity:dir}.
Checking the identities and the applicability of the induction hypothesis in the case of operations , 
is mechanical, and we omit it.

\vspace{3pt}
\noindent \underline{\bf Case 1}~~ (implying ). The identities are

and labelings  are defined as follows:
\begin{itemize}
\item if  set , ; 
\item otherwise if  set .
\item otherwise (if  or ) set .
\end{itemize}


The remainder is devoted to the case . Note that we must have .

\vspace{3pt}
\noindent \underline{\bf Case 2}~~,  and there exists node  with , .  Then

,  are defined as follows: 
\begin{itemize}
\item if  set , ; 
\item otherwise if  set ;
\item otherwise set .
\end{itemize}

\vspace{3pt}
\noindent \underline{\bf Case 3}~~,  and there is no node  with , . 
The identities are

,  are defined as follows: 
\begin{itemize}
\item if  set , ; 
\item otherwise if  set ;
\item otherwise (if ) set .
\end{itemize}
Note, to verify identities~\eqref{eq:GHAOUHAD} for node , one should consider cases  and  separately. 


\vspace{3pt}
\noindent \underline{\bf Case 4}~~ (implying , ) and there exists node 
with . Then

,  are defined as follows: 
\begin{itemize}
\item if  set , ; 
\item otherwise if ,  set ;
\item otherwise (if ) set .
\end{itemize}


\vspace{3pt}
\noindent \underline{\bf Case 5}~~ (implying , ) and there is no node  with . 
Thus,  for all . There holds , ,
so inequality~\eqref{eq:submodularity:dir} is trivial.










\section{Weakly tree-submodular functions}\label{sec:weak}
In this section we consider functions  that satisfy condition~\eqref{eq:submodularity:weak},
but not necessarily condition~\eqref{eq:submodularity}.
It is well-known~\cite{Topkis:78,Murota:book} that such functions can be minimized efficiently 
if all trees  are chains rooted at an endpoint and  is polynomially bounded.
The algorithm utilizes Birkhoff's representation theorem~\cite{Birkhoff:37} which says that there exists a {\em ring family} 
such that there is an isomorphism between sets  and  that preserves operations  and .
(A subset  is a ring family if it is closed under operations  and .)
It is known that submodular functions over a ring family can be minimized in polynomial time, which implies the result.
Note that the number of variables will be .

Another case when  satisfying~\eqref{eq:submodularity:weak} can be minimized efficiently is when  is bisubmodular, i.e.\ all trees
are as shown in Figure~\ref{fig:trees}(c). Indeed, in this case the pairs of operations  and  coincide.

An interesting question is whether there exist other classes of weakly tree-submodular functions that
can be minimized efficiently. In this section we provide one rather special example. We consider the tree shown in
Figure~\ref{fig:trees}(d). Each  has nodes  such that  is the root, the parent of
 for  is , and the parent of  and  is . 

In order to minimize function  for such choice of trees, we create  variables  for
each original variable . The domains of these variables are as follows:
, . Each domain 
is treated as a tree with root  and other nodes being the children of ; this defines operations  and 
for domains . The domain  is set as the Cartesian product of individual
domains over all nodes . Note, a vector  has  components.

For a labeling  let us define labeling  as follows:

\ignore{

}
It is easy to check that mapping  is injective and preserves operations  and .
Therefore,  is a {\em signed ring family}, i.e.\ a subset of  closed under operations  and .
It is known~\cite{McCormick:10} that bisubmodular functions over ring families can be minimized in polynomial time, leading to
\begin{proposition}
Functions that are weakly tree-submodular with respect to trees shown in Figure~\ref{fig:trees}(d) can be minimized
in time polynomial in  and .
\end{proposition}
















\ignore{
\subsection{TODO}

\begin{definition} (a) A {\em multimorphism class} is a set  containing tuples  where  is a finite set
and  are binary operations . (b) Function  is called -submodular
if  where , and

where operations  are defined component-wise via operations .
(c) A finite multimorphism class  is called {\em oracle-tractable} if any -submodular function  can be minimized in time polynomial in ,
assuming that  is given by an oracle and operations  for  are given together with  as input.
\end{definition}

A {\em congruence} on a tuple  is an equivalence relation  on 
such that conditions ,  imply that  and .
Given an equivalence relation  and an element , we denote  to be the -class of .
The set of -classes forms a {\em factor-multimorphism} which we denote by .

\begin{definition}
If  and  are multimorphism classes then their {\em Malt'sev product}, denoted ,
is the multimorphism class consisting of all tuples  such that there is a congruence  on  
with the following properties:
\begin{itemize}
\item Multimorphism  belongs to .
\item For every -class , multimorphism  belongs to . Here  denote restrictions of the respective
operations to .
\end{itemize}
\end{definition}

\begin{theorem}[\cite{KrokhinLarose:08}] If finite multimorphism classes  and  are oracle-tractable then so is .
\end{theorem}
\begin{proof}

Suppose that we are given an -submodular function  where
. For each component , consider the appropriate congruence  on .
(We may have different congruences  for different compoments, but for simplicity of notation we use the same symbol ). Define
a function  where  as follows:

where condition  means that  for all . Let us show that function  is -submodular.
For a labeling  denote .
Consider labelings . There exist labelings  such that
, 
and , , so we can write


By assumption, there exist fixed polynomials ,  such
that any -submodular function can be minimized in time 
where  is the time for function evaluation. Similarly, any -submodular function can be minimized in time .
It is now easy to see that function  can be minimized in time :
we need to invoke the algorithm for minimizing -submodular functions, and for every call to the evaluation oracle
for  invoke the algorithm for minimizing -submodular functions. After obtaining a minimizer of ,
one more call to the -submodular minimization algorithm gives a minimizer of .
\end{proof}

\begin{theorem}
Let  be a finite multimorphism class containing tuples  such
that  corresponds to a rooted binary tree and operations  are as defined in section~\ref{sec:intro}.
Then  is oracle-tractable.
\end{theorem}
\begin{proof}
Consider tuple  corresponding to the rooted tree .
We denote  to be the maximum number of nodes with two children
\end{proof}
}

\section{Conclusions and discussion}
We introduced two classes of functions (strongly tree-submodular and weakly tree-submodular)
that generalize several previously studied classes. For each class, we gave new examples of trees
for which the minimization problem is tractable.

Our work leaves a natural open question: what is the complexity of the problem for more general trees?
In particular, can we minimize efficiently strongly tree-submodular functions if trees are non-binary,
i.e.\ if some nodes have three or more children? Note that the algorithm in section~\ref{sec:alg}
and its analysis are still valid, but it is not clear whether the minimization procedure in step {\tt S2}
can be implemented efficiently. Also, are there trees besides the one shown in Figure~\ref{fig:trees}(d)
for which weakly tree-submodular functions can be minimized efficiently?

More generally, can one characterize for which operations  the minimization problem
is tractable? Currently known tractable examples are distributive lattices, some non-distributive lattices~\cite{KrokhinLarose:08,Kuivinen:TR},
operations on trees introduced in this paper, and combinations of the above operations obtained via Cartesian product and Malt'sev product~\cite{KrokhinLarose:08}.
Are there tractable cases that cannot be obtained via lattice and tree-based operations?

\small
\bibliographystyle{plain}
\begin{thebibliography}{10}

\bibitem{Barto09:siam}
L.~Barto, M.~Kozik and T.~Niven.
\newblock The {C}{S}{P} dichotomy holds for digraphs with
  no sources and no sinks (a positive answer to a conjecture of {B}ang-{J}ensen
  and {H}ell).
\newblock {\em {SIAM} Journal on Computing}, 38(5):1782--1802, 2009.

\bibitem{Birkhoff:37}
Garrett Birkhoff.
\newblock Rings of sets.
\newblock {\em Duke Mathematical Journal}, 3(3):443--454, 1937.

\bibitem{Bouchet:87}
A.~Bouchet.
\newblock Greedy algorithm and symmetric matroids.
\newblock {\em Math. Programming}, 38:147--159, 1987.

\bibitem{Bouchet:95}
A.~Bouchet and W.~H. Cunningham.
\newblock Delta-matroids, jump systems and bisubmodular polyhedra.
\newblock {\em SIAM J. Discrete Math.}, 8:17--32, 1995.

\bibitem{Bulatov03:conservative}
A.~A. Bulatov.
\newblock Tractable {C}onservative {C}onstraint {S}atisfaction {P}roblems.
\newblock In {\em Proceedings of the 18th {I}{E}{E}{E} {S}ymposium on {L}ogic in {C}omputer
  {S}cience ({L}{I}{C}{S}'03)}, pages 321--330, 2003.

\bibitem{Bulatov06:3-elementJACM}
A.~A. Bulatov.
\newblock A dichotomy theorem for constraint satisfaction problems on a
  3-element set
\newblock {\em Journal of the ACM}, 53(1):66--120, 2006.

\bibitem{Chandrasekaran:88}
R.~Chandrasekaran and Santosh~N. Kabadi.
\newblock Pseudomatroids.
\newblock {\em Discrete Math.}, 71:205--217, 1988.

\bibitem{Cohen:CP04}
David Cohen, Martin Cooper, and Peter Jeavons.
\newblock A complete characterization of complexity for boolean constraint
  optimization problems.
\newblock In {\em Principles and Practice of Constraint Programming}, number
  3258 in Lecture Notes in Computer Science, pages 212--226, 2004.

\bibitem{Cohen:CP03}
David Cohen, Martin Cooper, Peter Jeavons, and Andrei Krokhin.
\newblock Soft constraints: complexity and multimorphsims.
\newblock In {\em Principles and Practice of Constraint Programming}, number
  2833 in Lecture Notes in Computer Science, pages 244--258, 2003.

\bibitem{Cohen:TCS08}
David~A. Cohen, Martin~C. Cooper, and Peter~G. Jeavons.
\newblock Generalising submodularity and horn clauses: Tractable optimization
  problems defined by tournament pair multimorphisms.
\newblock {\em Theoretical Computer Science}, 401:36--51, 2008.

\bibitem{Cohen:AI06}
David~A. Cohen, Martin~C. Cooper, Peter~G. Jeavons, and Andrei~A. Krokhin.
\newblock The complexity of soft constraint satisfaction.
\newblock {\em Artificial Intelligence}, 170:983--1016, 2006.

\bibitem{DeinekoJKK08}
V.~Deineko, P.~Jonsson, M.~Klasson and A.~Krokhin.
\newblock The approximability of {Max}
  {C{S}{P}} with fixed-value constraints.
\newblock {\em Journal of the ACM}, 55(4), 2008.

\bibitem{FavatiTardella:90}
P.~Favati and F.~Tardella.
\newblock Convexity in nonlinear integer programming.
\newblock {\em Ricerca Operativa}, 53:3--44, 1990.

\bibitem{Feder98:monotone}
T.~Feder and M.~Vardi.
\newblock The {C}omputational {S}tructure of {M}onotone {M}onadic
  {S{N}{P}} and {C}onstraint {S}atisfaction: {A} {S}tudy through {D}atalog and
  {G}roup {T}heory.
\newblock {\em {SIAM} Journal on Computing}, 28(1):57--104, 1998.

\bibitem{Fujishige:91}
S.~Fujishige.
\newblock {\em Submodular Functions and Optimization}.
\newblock North-Holland, 1991.

\bibitem{FujishigeMurota:00}
S.~Fujishige and K.~Murota.
\newblock Notes on {L}-/{M}-convex functions and the separation theorems.
\newblock {\em Math. Program.}, 88:129--146, 2000.

\bibitem{Fujishige:06}
Satoru Fujishige and Satoru Iwata.
\newblock Bisubmodular function minimization.
\newblock {\em SIAM J. Discrete Math.}, 19(4):1065--1073, 2006.

\bibitem{Grotschel:88}
M. Gr\"{o}tschel,  L. Lov\'{a}sz and A. Schrijver.
\newblock Geometric Algorithms and Combinatorial Optimization.
\newblock {\em Springer Heidelberg}, 1988.

\bibitem{Iwata:01}
S. Iwata, L. Fleischer and S. Fujishige.
\newblock A combinatorial strongly polynomial algorithm for minimizing submodular functions.
\newblock {\em J. ACM}, 48:761--777, 2001.


\bibitem{Jonsson:TR11}
P. Jonsson, F. Kuivinen and J. Thapper.
\newblock Min {C}{S}{P} on Four Elements: Moving Beyond Submodularity.
\newblock Tech. rep. {\em arXiv:1102.2880}, February 2011.

\bibitem{Kabadi:90}
Santosh~N. Kabadi and R.~Chandrasekaran.
\newblock On totally dual integral systems.
\newblock {\em Discrete Appl. Math.}, 26:87--104, 1990.

\bibitem{KS:09}
V.~Kolmogorov and A.~Shioura.
\newblock New algorithms for convex cost tension problem with application to
  computer vision.
\newblock {\em Discrete Optimization}, 6(4):378--393, 2009.






\bibitem{KZ10:TRa}
V.~Kolmogorov and S.~\v{Z}ivn\'y.
\newblock The complexity of conservative finite-valued {C}{S}{P}s.
\newblock Tech. rep. {\em arXiv:1008.1555v1}, August 2010.

\bibitem{KZ10:TRb}
V.~Kolmogorov and S.~\v{Z}ivn\'y.
\newblock Generalising tractable {V}{C}{S}{P}s defined by symmetric tournament pair multimorphisms.
\newblock Tech. rep. {\em arXiv:1008.3104v1}, August 2010.

\bibitem{K10:TRc}
V.~Kolmogorov.
\newblock A dichotomy theorem for conservative general-valued {C}{S}{P}s.
\newblock Tech. rep. {\em arXiv:1008.4035v1}, August 2010.

\bibitem{K10:TSv2}
V.~Kolmogorov.
\newblock Submodularity on a tree: Unifying -convex and bisubmodular functions.
\newblock Tech. rep. {\em arXiv:1007.1229v2}, July 2010.

\bibitem{KrokhinLarose:08}
A.~Krokhin and B.~Larose.
\newblock Maximizing supermodular functions on product lattices, with application to maximum constraint satisfaction.
\newblock {\em SIAM Journal on Discrete Mathematics}, 22(1):312--328, 2008.

\bibitem{Kuivinen:TR}
F.~Kuivinen.
\newblock On the Complexity of Submodular Function Minimisation on Diamonds.
\newblock Tech. rep. {\em arXiv:0904.3183v1}, April 2009.

\bibitem{McCormick:10}
S.~Thomas McCormick and Satoru Fujishige.
\newblock Strongly polynomial and fully combinatorial algorithms for
  bisubmodular function minimization.
\newblock {\em Math. Program., Ser. A}, 122:87--120, 2010.

\bibitem{Murota:98}
K.~Murota.
\newblock Discrete convex analysis.
\newblock {\em Math. Program.}, 83:313--371, 1998.

\bibitem{Murota:IEICE00}
K.~Murota.
\newblock Algorithms in discrete convex analysis.
\newblock {\em IEICE Transactions on Systems and Information}, E83-D:344--352,
  2000.

\bibitem{Murota:book}
K.~Murota.
\newblock {\em Discrete Convex Analysis}.
\newblock SIAM Monographs on Discrete Mathematics and Applications, Vol. 10,
  2003.

\bibitem{Murota:SIAM03}
K.~Murota.
\newblock On steepest descent algorithms for discrete convex functions.
\newblock {\em SIAM J. Optimization}, 14(3):699--707, 2003.

\bibitem{Nakamura:88}
M.~Nakamura.
\newblock A characterization of greedy sets: universal polymatroids ({I}).
\newblock In {\em Scientific Papers of the College of Arts and Sciences},
  volume 38(2), pages 155--167. The University of Tokyo, 1998.

\bibitem{Qi:88}
Liqun Qi.
\newblock Directed submodularity, ditroids and directed submodular flows.
\newblock {\em Mathematical Programming}, 42:579--599, 1988.

\bibitem{Schaefer78:complexity}
T.~Schaefer.
\newblock The {C}omplexity of {S}atisfiability {P}roblems.
\newblock In {\em Proceedings
  of the 10th {A}nnual {A}{C}{M} {S}ymposium on {T}heory of {C}omputing
  ({S}{T}{O}{C}'78)}, pages 216--226, 1978.

\bibitem{Schrijver:00}
A. Schrijver.
\newblock A combinatorial algorithm minimizing submodular functions in strongly polynomial time.
\newblock {\em J. Combin. Theory Ser. B}, 80:346--355, 2000.

\bibitem{Takhanov10:stacs}
Rustem Takhanov.
\newblock A {D}ichotomy {T}heorem for the {G}eneral {M}inimum {C}ost
  {H}omomorphism {P}roblem.
\newblock In {\em Proceedings of the 27th International Symposium on
  Theoretical Aspects of Computer Science (STACS'10)}, pages 657--668, 2010.

\bibitem{Topkis:78}
Donald~M. Topkis.
\newblock Minimizing a submodular function on a lattice.
\newblock {\em Operations Research}, 26(2):305--321, 1978.





























\end{thebibliography}













\end{document}
