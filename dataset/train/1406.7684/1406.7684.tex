\documentclass{LMCS}

\def\dOi{10(3:2)2014}
\lmcsheading {\dOi}
{1--43}
{}
{}
{Mar.~17, 2011}
{Aug.~15, 2014}
{}

\ACMCCS{[{\bf Theory of computation}]: Logic; Theory and algorithms
  for application domains---Database theory---Logic and databases}

\keywords{Monadic Second-Order Logic, Fixed Points, Boundedness}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{graphicx,hyperref}


\newtheorem{observation}[thm]{Observation}
\newtheorem*{thm*}{Theorem}

\newcommand{\Cn}[1]{\expandafter\newcommand\csname#1\endcsname}

\Cn{cl}[2]{\lVert #1\rVert_{#2}}

\Cn{makemathname}[1]{\mathrm{#1}}
\Cn{mathname}[2]{\Cn{#1}{\makemathname{#2}}}
\Cn{mathownname}[1]{\mathname{#1}{#1}}

\Cn{calletter}[1]{\Cn{c#1}{{\mathcal #1}}}
\calletter{A}
\calletter{C}
\calletter{F}
\calletter{I}
\calletter{P}
\calletter{T}
\calletter{W}

\Cn{frakletter}[1]{\Cn{f#1}{{\mathfrak #1}}}
\frakletter{A}
\frakletter{B}
\frakletter{C}
\frakletter{L}
\frakletter{S}
\frakletter{T}
\frakletter{U}

\newcommand\powerset{\cP}

\Cn{AB}{\rand{Achim}}
\Cn{MO}{\rand{Martin}}
\Cn{mw}{\rand{Mark}}
\Cn{add}{\leftthreetimes}
\Cn{app}[2]{{#1}\parlr{#2}}
\Cn{arglr}[1]{\lr{[}{#1}{]}}
\Cn{bigset}[2]{\bigl\{\,#1\bigm|#2\,\bigr\}}
\Cn{bq}[1]{\lq{}#1\rq{}}
\Cn{card}{\midlr}
\Cn{code}[1]{\arglr{#1}}
\Cn{defn}{\emph}
\mathownname{DTIME}
\mathownname{NTIME}
\mathownname{DSPACE}
\Cn{eps}{\varepsilon}
\mathownname{FO}
\mathownname{MSO}
\mathownname{GSO}
\mathownname{GF}
\mathownname{ML}
\mathownname{SAT}
\mathownname{BDD}
\mathownname{fin}
\newcommand\ILT{\textrm{ILT}}
\Cn{BDDm}{\BDD^1}
\Cn{Lmu}{\mathrm L_\mu}
\Cn{AFO}{\FO_-(\forall^\ast)}
\Cn{EFO}{\FO_+(\exists^\ast)}
\Cn{muGF}{\mu\GF}
\Cn{GFs}{\GF^\ast}
\Cn{muGFs}{\muGF^\ast}
\Cn{GSOg}{\mathrm{GGSO}}
\Cn{GSOgs}{\GSOg^\ast}
\Cn{GSOs}{\GSO^\ast}
\Cn{gdd}{\mathrm{gdd}}
\Cn{len}{\midlr}
\Cn{lp}{\triangleright}
\Cn{Lpos}[1]{\MSO^{#1}_X[\tau]}
\Cn{lr}[3]{\left#1#2\right#3}
\Cn{midlr}[1]{\lr{\lvert}{#1}{\rvert}}
\Cn{mtype}[2]{\tp^{#1}_X(#2)}
\Cn{mType}[1]{\Tp^{#1}_X[\tau]}
\Cn{parlr}[1]{{\lr{(}{#1}{)}}}
\renewcommand{\phi}{\varphi}
\mathownname{poly}
\mathownname{qa}
\mathownname{qr}
\Cn{rand}[2]{\marginpar{{\bf #1:} #2}}
\Cn{rest}[2]{{#1\upharpoonright#2}}
\Cn{seq}{{\,=\,}}
\Cn{set}[2]{\{\,#1\mathrel{|}#2\,\}}
\Cn{setlr}[1]{{\lr{\{}{#1}{\}}}}
\Cn{size}[1]{\lr{\|}{#1}{\|}}
\Cn{subst}[3]{#1[#2/#3]}
\Cn{taux}{\tau\cup\setlr x}
\Cn{tauX}{\tau\cup\setlr X}
\Cn{tauXx}{\tau\cup\setlr{X,x}}
\mathownname{tp}
\mathownname{Tp}
\newcommand\emptyseq{\langle\rangle}
\Cn?{\kern0.08em}

\Cn{mi}[1]{{\triangleleft}#1}
\Cn{mo}[1]{{\triangleright}#1}




\begin{document}

\title[Decidability Results for the Boundedness Problem]{Decidability Results for the Boundedness Problem}

\author[A.~Blumensath]{Achim Blumensath\rsuper a}
\address{{\lsuper{a,b}}Fachbereich Mathematik, Technische Universit\"at Darmstadt}
\email{\{blumensath,otto\}@mathematik.tu-darmstadt.de}

\author[M.~Otto]{Martin Otto\rsuper b}
\address{\vspace{-18 pt}}


\author[M.Weier]{Mark Weyer\rsuper c}
\address{{\lsuper c}\vspace{-12 pt}}
\email{mark@weyer-zuhause.de}

\begin{abstract}
We prove decidability of the boundedness problem for
monadic least fixed-point recursion based on
positive monadic second-order () formulae over trees.
Given an -formula  that is positive in~, it is decidable
whether the fixed-point recursion based on~ is spurious
over the class of all trees in the sense that there is some uniform
finite bound for the number of iterations ~takes
to reach its least fixed point, uniformly across all trees.
We also identify the exact complexity of this problem.
The proof uses automata-theoretic techniques.

This key result extends, by means of model-theoretic interpretations,
to show decidability of the boundedness problem for 
and guarded second-order logic () over the classes of structures
of fixed finite tree-width. Further model-theoretic transfer arguments
allow us to derive major known decidability results for boundedness
for fragments of first-order logic as well as new ones.
\end{abstract}

\maketitle

\section{Introduction}
\label{sect:intro}

In applications one frequently employs tailor-made logics
to achieve a balance between expressive power and algorithmic manageability.
Adding fixed-point operators to weak logics turned out to be a good way
to achieve such a balance.
Think, for example of the addition of transitive closure operators
or more general fixed-point constructs to database
query languages, or of various fixed-point defined reachability
or recurrence assertions to logics used in verification, like 
linear or branching time temporal logics or the modal -calculus.
Fixed-point operators introduce a measure of relational recursion and
typically boost expressiveness in the direction of more dynamic and
less local properties. They offer relational recursion based on the 
iteration of relation updates that are definable in the underlying logic.
We here primarily consider monadic least fixed points, based on formulae
 that are monotone (positive) in the
monadic recursion variable~.
On a fixed structure~,
any such~ induces a monotone operation

on monadic relations .
The least fixed point of this operation over~,
denoted as , is also the first stationary point
of the monotone, ordinal-indexed iteration sequence of stages  starting from
, with updates

and unions in limits. 
The least~ for which
 is called the closure
ordinal for this fixed-point iteration on~.

For a concrete fixed-point process it may be hard to tell
whether the recursion employed is crucial or whether it is
spurious and can be eliminated.
Indeed this question comes in two versions\?:
(a) one can ask whether a resulting fixed point is also
uniformly definable in the base logic without fixed-point recursion
(purely an expressiveness issue)\?;
(b) one may also be interested to know whether the given fixed-point
iteration terminates within a uniformly bounded finite number
of steps (an algorithmic issue, concerning the dynamics of the
fixed-point recursion rather than its result).

The boundedness problem 
for a class of formulae~
and a class of structures~
concerns question~(b)\?: to decide, for a given formula ,
whether there is a finite upper bound on its closure
ordinal, uniformly across all structures .
We call such fixed-point iterations, or~ itself,
\emph{bounded over~.}

Interestingly, for first-order logic, as well as for many natural
fragments, the two questions concerning eliminability of least fixed
points coincide -- at least over the class of all structures.
By a classical theorem of
Barwise and Moschovakis~\cite{BarwiseMoschovakis78},
the only way that the fixed point  can be
first-order definable for every~, is that there is some finite~
for which 
for all~. The converse is clear from the fact that the unfolding
of the iteration to any fixed finite depth~ is easily mimicked
in .

In other cases -- and even for  over other, restricted classes of
structures, e.g., in finite model theory -- the two problems can
indeed be distinct, and of quite independent interest.

We here deal with the boundedness issue.
Boundedness (even classically, over the class of all structures, and
for just monadic fixed points as considered above) is
undecidable for most first-order fragments of interest (see, e.g.,~\cite{HillebrandEtAl95}).
Notable exceptions are monadic boundedness for positive existential
formulae (\textsc{Datalog})~\cite{CosmadakisGaKaVa88},
for modal formulae~\cite{Otto99}, and for
(a restricted class of) universal formulae without equality~\cite{Otto06}.

One common feature of these decidable cases of the boundedness problem
is that the fragments concerned have a kind of tree-model property
(not just for satisfiability in the fragment itself, but also for the
fixed points and for boundedness).
This is obvious for the modal fragment~\cite{Otto99}, but clearly
also true for positive existential  (derivation trees for monadic
\textsc{Datalog} programs can be turned into models of bounded tree-width),
and similarly also for the restricted universal fragment in~\cite{Otto06}.

Motivated by this observation,
\cite{KOS}~has made a first significant step
in an attempt to analyse the boundedness problem from the opposite perspective,
varying the class of structures rather than the class of formulae. The hope
is that this approach could go beyond an ad-hoc exposition of the
decidability of the boundedness problem for individual syntactic fragments,
and offer a unified model-theoretic explanation instead.
\cite{KOS}~shows that boundedness is decidable for
\emph{all} monadic fixed points in  over the class of all acyclic
relational structures.
Technically \cite{KOS}~expands on modal
and locality-based proof ideas and reductions to
the monadic second-order theory of trees from~\cite{Otto99,Otto06}
that also rest on the availability of a Barwise--Moschovakis
equivalence. These techniques do not seem to extend to either
the class of all trees (where Barwise--Moschovakis fails) or to
bounded tree-width (where certain simple locality criteria fail).

The present investigation offers another step forward in the alternative
approach to the boundedness problem, on a methodologically very
different note. Its most important novel feature may be that it deals 
with a setting where neither locality nor
Barwise--Moschovakis are available. On the one hand, the class of formulae
considered is extended from first-order logic 
to full monadic second-order logic  -- a leap which greatly increases
the robustness of the results w.r.t.\ interpretations, and hence
their model-theoretic impact. On the other hand, automata are crucially used
and the underlying structures are restricted to trees.
Using -interpretations it follows that
the boundedness problem for  is decidable
over any -definable class of bounded tree-width, and similarly
even for guarded second-order logic  instead of .

These ramifications demonstrate the strength and unifying explanatory
power of our main decidability result in the wider context of the
boundedness issue.
One of our strongest concrete decidability results
concerns the boundedness problem for  over
-definable classes of bounded tree-width, cf.~Corollary~\ref{cor:decidability of BDD(GF), etc}.
This, in its turn,
encompasses all the major, previously known decidability results
for natural fragments of  and, furthermore, settles decidability
of boundedness for the guarded fragment .
Equally importantly it goes a long way
to explain the perceived dichotomy between the many undecidability
results, which may typically be understood in terms of reductions from
the tiling problem over suitably grid-like structures, and the
comparatively rare cases of decidability, which can now be systematically
linked to some generalised tree-model property.

Among the classical and previously known decidability results
for the boundedness of (systems of) monadic least fixed points,
which can be integrated into this new picture, are those for
\begin{itemize}
\item[--] monadic \textsc{Datalog,} or systems of monadic least fixed points
  for the purely existential--positive fragment of first-order logic,
  \cite{CosmadakisGaKaVa88}\?;
\item[--] dually, (systems of) monadic least fixed points
  in the purely universal-negative fragment of first-order logic
  (which may equivalently be phrased in terms of the
  boundedness for greatest fixed points for \textsc{Datalog} or for
  existential--positive first-order), \cite{Otto06}\?;
\item[--] modal logic, \cite{Otto99}\?;
\item[--] monadic least fixed points for unconstrained 
  in restriction to the class of all acyclic relational structures, \cite{KOS}.
\end{itemize}

\noindent Our decidability results are based on a reduction of the monadic
boundedness problem to the \emph{limitedness problem} for
\emph{weighted parity automata,} whose decidability is due to
Colcombet and L\"oding \cite{ColcombetLoeding08}
(cf.~Theorems
\ref{thm:finite limitedness decidable}~and~\ref{thm:limitedness decidable}
below).
This reduction introduces a rather sophisticated annotation
(of ternary tree structures) that records dependencies between the stages
of a fixed-point iteration over these tree structures\?; it is
established that, subject to a limitedness condition on a related
cost function, these annotations can serve as certificates for boundedness.

The overall structure of the paper is as follows.
We divide the material into two major parts\?:
the first part, comprising Sections~\ref{sect:start I}--\ref{sect:end I},
is devoted to the development of the
new techniques and leads up to the core technical result\?:
the decidability of the boundedness problem for 
on the class of all ternary trees
through reduction to the limitedness problem for a certain class of automata.
The ramifications of this result are investigated
in the second half of the paper. 
Sections~\ref{sect:start II}--\ref{sect:end II} develop
transfer and reduction arguments that allow us to make links with previously
known decidability results and to derive several new concrete
decidability results. 
Section~\ref{sect:complexity}, finally, discusses complexity issues.

\section{Preliminaries}
\label{sect:prelims}

We assume some familiarity with basic concepts of logic
as can be found, e.g., in \cite{EbbinghausFlum95}.
Throughout the paper we assume that all vocabularies are finite
and that they contain only relation symbols and constant symbols,
but no function symbols.

Consider a second-order formula 
with free variables as indicated in an underlying vocabulary~.
Suppose that  is positive in the -ary
second-order variable~ and  is a matching
tuple of free first-order variables.
Any -positive formula of this format induces, over every
-structure~, an operation on the power set of \?:


As ~is -positive, this operation is monotone
( implies )
and hence possesses a unique least fixed point,
which we denote as . This least fixed point
is obtained as the limit of the monotone sequence of inductive stages

induced by~ on~. These stages are defined by transfinite
induction, for all ordinals , according to\?:


The \emph{finite stages} , for ,
are uniformly definable by formulae, which we also denote by~,
obtained from  by iterated substitution
of~ for~ in~.
Letting  stand for the result of
replacing all free occurrences of~ in atoms~
in~ by~, we obtain
formulae~ for , by


Clearly, for finite ,  for ,
and similarly for all natural fragments of first- and second-order logic that
are closed under this substitution operation. It is easy to see that
~defines the stage 
for finite , uniformly across all~. We therefore need not
distinguish between the two readings of  for
\emph{finite}~. For infinite~, on the other hand,
we do not regard~ as a formula (it would in general have to be
a formula in some infinitary extension of the base logic), but only
allow  as shorthand notation for the corresponding stage
of~ over~.

Because of monotonicity,

for the least ordinal~ for which
.
This ordinal~ is called the \emph{closure ordinal} for~
on~, denoted .
The \emph{stage} of an individual 
is the least ordinal~ such that \?;
therefore, the closure ordinal could also be described as the least
ordinal greater than the stages of all members of the fixed point .

The closure ordinal can in general only be bounded, for simple
cardinality reasons, by the successor cardinal of the cardinality
of~, or by  for finite~.

For instance, the fixed-point induction based on 
yields as its fixed point over  the set of elements
 that are well-founded w.r.t.\ \?;
over the well-ordering , the closure ordinal is~.
In fact, \?;
the stage of  is~.

The fixed-point induction based on~, or for simplicity\?: ~itself,
is said to be bounded if, for some finite ,
 for all~.
Similarly, ~is bounded
over the class~ if, for some ,
 for all .

\begin{defi}
{\normalfont (a)} Let ~be a formula over~, positive in~,
and let .
We say that ~is \emph{bounded by~} over a class~
if , for all .
We call~ \emph{bounded} over~
if it is bounded by some .

{\normalfont (b)} The \emph{boundedness problem} for a logic~
over a class~ is the problem to decide,
given a formula , whether ~is bounded over~.
We denote this decision problem as .

The \emph{monadic boundedness problem} is
the corresponding problem where we only consider formulae~
with \emph{monadic} variables~.
We denote it as .

If ~is the class of all structures,
we just write  or .
\end{defi}

A vocabulary~ is called a \emph{tree vocabulary,}
if ~consists of one binary relation symbol~
and, otherwise, only of constant symbols and unary relation symbols.
A -structure~ is called a \emph{tree structure,}
or \emph{tree} for short,
if  is a symmetric, acyclic, and connected relation on~.
In particular, tree structures are undirected.

In Part~I of the paper,
we shall exclusively look at 
for the class of -formulae  suitable for
monadic fixed points (positive in the monadic variable~)
over the class~ of all tree structures
and some of its subclasses. We refer to this core problem as
the boundedness problem for  over trees for short.

\begin{thm}[Main theorem]
, the monadic boundedness problem for 
over the class of all tree structures, is decidable.
\end{thm}

In Part~II we employ model-theoretic interpretations and similar transfer arguments
to deduce from this result the decidability of many other boundedness problems.
In particular, we obtain new proofs of many previous decidability results
for boundedness,
as well as some new results like the decidability for the guarded fragment
of first-order logic and for full guarded second-order logic over structures
of bounded tree-width.


\bigskip
\section*{Part I. The main result}


In this first part we prove the main technical result, the decidability
of the monadic boundedness problem for  on the class of all ternary trees.
The ramifications of this result will then be investigated
in the second half of the paper.



\medskip
To help the reader through the later technicalities,
we start with a simplified outline of the proof idea
towards the main theorem.
The key idea is to derive, for every formula~, a
bound  that provides a uniform strict upper bound on the
closure ordinals  over any tree structure~ in case
 \emph{is} bounded.
Then boundedness of  is equivalent to the unsatisfiability
of 
(over the class of all tree structures~).
In other words, a formula which (on the class of all trees)
is not bounded by this number~ is not bounded at all.
To reason towards such a uniform bound~,
assume that for some tree~,
some node~ enters the fixed point in stage~.
Then 
but .
Using a Feferman--Vaught style lemma (cf.~Proposition~\ref{prop:Feferman-Vaught}),
this change in the status of~ can be traced back to some other node~
such that 
but ,
which means that ~entered the fixed point in stage .
In this way we obtain a path of dependencies
which travels through the tree
and at places decreases the stage by~.
In a chain of ~such jumps,
we conclude that, if ~is large
in comparison to the number of types used in the Feferman--Vaught style lemma,
then the path has repetitions and we can use a pumping argument
to produce trees where some node enters the fixed point at arbitrarily large stages.
Consequently, ~is unbounded.

The actual proof has to deal with further difficulties,
so it does not exactly follow this outline.
One difficulty is that a pumping lemma essentially requires that
(in some very loose sense) we only use regular properties.
In particular, we have to weaken the counting of stages
and, consequently,
we will slightly relax the concept of a dependency.
Also, it is not sufficient to consider a single dependency path\?:
we have to do the pumping such that it works for all paths simultaneously.
Fortunately, there is already a suitable pumping theorem for a certain kind
of weighted automaton that we can reduce our problem to.
The main part of this paper describes this highly non-trivial reduction.

\paragraph*{\itshape Convention.}
For technical reasons we choose in the following not to distinguish
formally between (assignments to) free first and second-order variables
(and interpretations of) constant or relation symbols. For instance,
we shall often regard ~and~, which in usual parlance occur
free in , as part of the vocabulary, and think of
assignments  and  over some~
in terms of the expansion  of~.


\section{A Feferman--Vaught theorem for positive types}
\label{sect:Feferman-Vaught}
\label{sect:start I}


For a vocabulary~, we denote by
 the set of all -formulae
over~ with quantifier rank at most~
(we count both first- and second-order quantifiers).
If  is a unary predicate we write
 for the subset of all formulae
where the predicate~ occurs only positively.
Recall that, for finite vocabularies~, ,
and hence also ,
is finite up to logical equivalence.

\begin{defi}
Let ~be a vocabulary and .
The \emph{-positive -type} of a -structure~ is the set

We write 
for the set of all -positive -types of -structures.
\end{defi}

Let  and  be tree structures.
If  and  are disjoint,
and if furthermore no constant symbol is interpreted in both trees,
then we define a concatenation operation as follows\?:
let ~and~ be constant symbols from the structures
~and~, respectively.
Then we denote by  the tree
obtained from the disjoint union of the trees ~and~
by adding an edge between  and .
Note that every finite tree
can be constructed from one-element trees using this operation and reduct operations.

If  is a tree and  an edge of~,
then removing~ from~ produces two disjoint trees.
Of these, we denote the one containing the vertex~ by~.
Note that, if there are constants ~and~ for ~and~,
then .
If ~is a constant symbol not interpreted by~,
then we set ,
where the expansion interprets~ by~.

We will frequently need a derived operation\?:
let ~and~ be trees
such that  and  are disjoint, and
suppose that there is exactly one constant symbol~
that is interpreted both in ~and in~.
Let ~be a constant symbol which is interpreted in neither.
Then we denote by 
the reduct of 
that expels~ from the vocabulary ( denotes
the structure obtained from~ by renaming the constant symbol~
to~).
Intuitively,
~denotes the root of (directed versions of) the respective trees,
and ~appends its second argument as a new subtree
below the root of its first argument.
For a more uniform treatment,
we allow the empty tree~
as a neutral second argument to~, and
we use~ also for its type.

\begin{prop}\label{prop:Feferman-Vaught}
For every ,
there is a binary operation~ on -positive -types
such that,
for all trees  for which  is defined,
we have

Furthermore,  is monotone\?:

Finally,  is computable from , , and .
\end{prop}
\begin{proof}
Computability of the operation will be evident,
once we show how to compute with types in an effective way.
For this sake,
note that we can represent an -type by a finite
set of formulae where all maximal boolean combinations
are in disjunctive normal form without repetition of clauses
or of literals in clauses.

We proceed by induction on~.
Assume that we already know how to compute~ for all 
and all vocabularies.
For convenience, we set

We will describe~ solely in terms of ,~, ,
and the operations~ with .
Each formula in an -positive -type
is a positive boolean combination of atoms, negated atoms,
and formulae of the form , ,
, and ,
where ~is a first-order variable and ~is a set variable.
Whether the full formula belongs to~ is clearly determined
by whether the individual formulae in the positive boolean combination do.
Also, as the boolean combinations are positive,
monotonicity is preserved.
Hence it suffices to consider subformulae of the above form.

In the following we explicitly treat the cases of
atomic and negated atomic formulae and of
 and .
The remaining cases  and 
can be handled using combinations of the techniques
used in these cases.

\smallskip
First, we consider atoms and negated atoms.
Each (negated) atom that only uses constants from~
occurs in~ iff it occurs in~.
It remains to consider (negated) atoms
involving constants from both  and .
As ~is the only relation symbol of arity more than~,
such an atom must be of the form  or  where,
without loss of generality, ~is from the vocabulary of 
and ~from the vocabulary of .
In this case, we always have 
and, hence, \?;
so


\smallskip
Next, let us consider a formula of the form 
with .
We make use of~.
Let  and  be the -positive -types of  and ,
that is,  and .
Further, let  be the set of -positive -types
of expansions of  by some  interpreted for~,
and let  be the respective set of types of expansions of .
Clearly,  iff  for some .
For  and ,
the inductive hypothesis implies that

Note that .
The case where  is similar.
It follows that

As an artifact of positivity in~,
the set~ is not determined by~.
The point is that, for instance, if
,
then ~may or may not contain a type~
such that  but ,
because we do not know
about the status of .

Unlike , the following superset of~ is determined by~\?:

(Recall that representations of types are finite,
so  is in fact a formula.)
Hence it suffices to show that

(The corresponding statement for~ then follows by symmetry.)

 is trivial since .
For ,
assume that ~is a type such that
 and .
Let  be an element with ,
and set .
Clearly, .
Hence, monotonicity of~
implies that , as desired.

It remains to show monotonicity of~
(as far as the formula  is concerned).
We need to establish that, if ,
then this still holds after increasing ~or~.
This follows from the fact
that the sets ~and~ (defined analogously to~)
are monotone in  and~.

\smallskip
Finally, let us consider a formula of the form 
with .
This time let ~be the set of -positive -types
of expansions of~ by some unary predicate  interpreted for~,
and let ~be the respective set for~.
Using the equality

we obtain, similarly to the case above, that


Let us call a pair 
\emph{good for ,} if the following conditions hold\?:
\begin{itemize}
\item ~is a set of -positive -types
  of the vocabulary used for expansions of  by~ and
  ~is a corresponding set for of .
\item 
  and .
\item For all  and 
  we have .
\end{itemize}
If , then  is good, whence a good pair exists.
We claim that the converse also holds, i.e., that
the existence of a good pair implies .
Thus, we obtain a characterisation of whether 
solely in terms of ,~, and~.
Furthermore, being good for 
is clearly monotone in ~and~.

To prove the claim, suppose that  is a good pair
and let  and  be arbitrary.
We need to show that .
Fix a predicate~ such that .
By the second condition on good pairs, we have
.
Hence, there is some  such that .
This implies that .
Analogously, we obtain some  such that .
By the third condition on good pairs, we have .
Therefore, monotonicity of  implies that .
\end{proof}


The previous proof needed to consider different vocabularies.
From now on, a single vocabulary nearly suffices.
Let  be a fixed tree vocabulary without any constant symbols.
Let  be a unary relation symbol and  a constant symbol
such that .
We will consider fixed points with respect to ~and~.
The fixed points are evaluated in trees of vocabulary~.
Stages of the fixed-point induction are evaluated
in trees of vocabulary .
In order to determine whether a single tree node
belongs to some iteration for the fixed point,
we consider trees of vocabulary .
If  is present in the vocabulary,
its interpretation can be thought of as the root of the tree.

Let  be a -formula positive in~
and let  be the quantifier rank of~.

\begin{cor}
Let  be a new constant symbol.
We define a binary operation~
on -positive -types of -structures by

The operation~ is monotone and satisfies

for all non-empty tree structures ~and~ of vocabulary~.
\qed\end{cor}

We extend  by adjoining the -positive -type~ of the empty tree
as a right-neutral element.
This does not hurt monotonicity\?:
without loss of generality, assume that .
Then only~ contains 
and only this type does not contain ,
so it is incomparable to any other type.

In the first part, which contains the technical heart of the article,
we will only consider ternary trees, that is,
undirected trees where each node has degree at most~.
We assume that each such tree~ is implicitly equipped
with an edge-colouring using ~colours .
That means that, for every colour~,
each vertex~ of~ has at most one neighbour
that is connected to~ via an edge of colour~.
We call this neighbour ``the neighbour of~ in \emph{direction}~''
and we denote it by~.
If there is no such neighbour, we set .

To account for missing neighbours we extend the above
definition of~
by setting 
and letting .
Furthermore, let .
With this notation we have

where we assume that the operation~ is associative to the left.

We also need a variant of Proposition~\ref{prop:Feferman-Vaught}
that concerns a decomposition into a possibly infinite number of subtrees.
We omit the proof, which is similar to that of Proposition~\ref{prop:Feferman-Vaught}.
\begin{prop}\label{prop:Feferman-Vaught II}
Let  be a -tree and 
a sequence of pairwise distinct pairs ,
such that  and .
Further, let  and 
be sequences of -trees
such that  for all~.
Finally, let ~be the tree obtained from~
by adding~ as a child of~
in direction~ for all~,
and define~ analogously using~ instead of~.
Then, .
\qed\end{prop}


\section{Tilings}
\label{sect:tilings}


We are now in a position to provide a second, more precise proof outline.
Given a tree structure~ of vocabulary~,
we consider the fixed-point induction of~.
For every stage~ and every vertex~ of~
we consider the type .
We annotate~ with all these types.
At each vertex~ we write down the list of these types for all stages~.
These annotations can be used to determine the fixed-point rank of elements of~.
A vertex~ enters the fixed point at stage~ if the -th entry
of the list is the first one containing a type~ with .

We can regard the annotation as consisting of several layers, one for each stage of the
induction. At a vertex~ each change between two consecutive layers is caused
by some change at some other vertex in the previous step. In this way we can trace
back changes of the types through the various layers.

In order to determine whether the fixed-point inductions of the formula are bounded,
we construct a \emph{weighted automaton} (see Section~\ref{sect:automata} below)
that recognises (approximations of) such annotations and that computes
(an approximation of) the length of the longest path of changes in the annotation.

Actually, the annotations we use do not consist of single types but
of tuples of such types, called a \emph{tile.}
In this section we consider single layers of such tiles.
In the next section we will then introduce annotations
consisting of several such layers.

\begin{defi}
A \defn{letter} is a one-element -tree.
\end{defi}
Observe that, for each letter~,
there are exactly two -expansions of~\?:
one where the element belongs to~ and one where it does not.
Let us denote their -positive -types
by ~and~, respectively.
Note that  and that ,
for every . We omit the index~ whenever it is irrelevant.

We can decompose a -tree~ into its one-element
substructures~, i.e., its letters.
Each of these letters~ can be labelled with
its type and the types of the subtrees .
\begin{center}
\includegraphics{final-1.pdf}
\end{center}
For convenience, we will not only use the types  and 
of  and , , respectively,
but also the types~ of , 
and the type~ of the whole tree .
Our intuition regards the vertex~ as a processing unit
that receives as its inputs the types , , , 
and produces as output the types , , , .
The vertex~ receives from its neighbours~, ,
the inputs~ and it passes back to~ the outputs~.

\begin{defi}
\textup{(a)}
Let  be a letter.
An \defn{-tile} is an -tuple

of -positive -types over  where
\begin{itemize}
\item ,
\item ,
\item ,
\item , and
\item .
\end{itemize}
If we do not want to mention the letter,
we refer to an -tile simply as a \defn{tile.}
When ~is a tile,
we denote its components by  through .

\textup{(b)}
Let  be a -tree.
A \defn{-tiling} is a mapping~ that assigns to each
vertex  a -tile .

\textup{(c)}
Let ~be a -tree.
The \emph{canonical tiling}~ of~ is the function
assigning to a vertex~ the tile

\end{defi}

Intuitively the -component of a tile
contains information \emph{incoming} from direction~,
whereas the -component contains the information passed on in that direction.
Similarly, the -component contains information passed on to the next stage.
The -component is special, since it contains local information about the current vertex.

Note that the canonical tiling is indeed a tiling.
\begin{lem}\label{lem:tile is such}
Let  be a -tree and ~its -reduct.
Then ~is a -tiling.
\end{lem}
\begin{proof}
Let .
Since  is an expansion of ,
its type  must be one of  and~.

For the equalities concerning  with ,
we may by symmetry assume that . Then

as desired.
The equality for~ is obtained similarly.
\end{proof}

Not every tiling stems from an actual tree.
In the next definition we collect some simple consistency properties
a tiling should satisfy.
Note that these properties can be checked by an automaton.

\begin{defi}
Let  be a -tree and  a vertex.

\textup{(a)}
The \defn{orientation of~ towards }
is the mapping 
such that  and, for vertices ,
we define  such that the neighbour  is closer to~ than~.
\begin{center}
\includegraphics{final-2.pdf}
\end{center}

\textup{(b)}
A -tiling~ is \defn{locally consistent towards }
if, for all  and all directions  with ,
we have


\textup{(c)}
A -tiling~ is \defn{globally consistent towards }
if, for all vertices  and all directions  with ,
we have

where  is the expansion of~
by the set  interpreted for~.
\end{defi}

Of course, canonical tilings are globally consistent.
\begin{lem}\label{lem:tiling is such}
Let ~be a -tree and .
The -tiling  is
globally consistent towards each vertex .
\end{lem}
\begin{proof}
We have already seen in Lemma~\ref{lem:tile is such} that  is a -tiling.
Let . For global consistency, note that

as desired.
\end{proof}

Finally, let us show that global consistency implies
local consistency.
\begin{lem}\label{lem:global implies local for tiling}
Let  be a -tree and .
Every -tiling that is globally consistent towards~
is locally consistent towards~.
\end{lem}

\begin{proof}
Let  be a -tiling globally consistent towards~
and let~ be the -expansion of~ by the set
.
Let  and  be given.
Without loss of generality, we may assume that .
If , then  is the type of
.
Otherwise, let .
Since ~is a -tiling, ~is either 
or~. By definition of~ it follows that
. Consequently,

\end{proof}



\section{Annotations}
\label{sect:annots}


Ideally we would like to annotate a given tree with one tiling for each stage
of the fixed-point induction. Since this is an infinite amount of data we have
to opt for something less\?: at each vertex of the tree we do not store the
full sequence of tiles for each stage, but only a shortened sequence
obtained by removing all duplicates. This is a finite amount of information
we can label the tree with.
The drawback of this method is that, by removing duplicates,
we lose synchronisation between the sequences from adjacent vertices.
Here are the formal definitions.

For a -tree~ and an ordinal~,
let 
be the -expansion of~
by the th stage of the fixed-point induction.
Similarly, we set 
and .

We extend the order  on -positive -types
to tiles by requiring that  holds component-wise.

\begin{defi}
\textup{(a)}
Let  be a letter.
An \defn{-history} is a strictly increasing sequence

of -tiles such that
\begin{enumerate}
\item  and
\item  iff , for .
\end{enumerate}
The number~ is the \defn{length} of the history, denoted .

\textup{(b)}
Let  be a -tree and  a vertex.
\defn{The history} of~ at~
is the sequence~ of tiles ,
for all ordinals~, with duplicates removed.
\end{defi}

\begin{exa}\label{ex:paths}
For simplicity, we give an example of a fixed-point induction on
a path, instead of a tree, i.e., a tree where no vertex has a neighbour
in direction~.
We consider the fixed-point of the formula 
stating that

Figure~\ref{fig:annotated word} shows the histories of the
first ~elements of a finite path of length at least~.
All further elements, except for the last two,
have the same history as the third and fourth elements.
Here, we assume that the edges are alternatingly labelled by ~and~
and the tiles are drawn in the format
\begin{center}
\begin{tabular}{|c|c|c|c|}
\hline
&&&\\
\hline
&&&\\
\hline
\end{tabular}
\end{center}
where
\begin{itemize}\parskip=0pt\itemsep=0pt\item ~denotes the type of the empty tree,
\item ~denotes any type containing ,
\item ~denotes any type not containing ,
\item ~denotes any type containing the formula ,
\item ~denotes any type containing ,
  but not , and
\item  denotes any type not containing the formula . 
\end{itemize}
\begin{figure}\centering
\includegraphics{final-3.pdf}
\caption{Annotation for \label{fig:annotated word}}
\end{figure}
\end{exa}


Of course, the history of~ at~ is indeed a history.
\begin{lem}\label{lem:history is such}
Let ~be a -tree and  a vertex.
Then  is a -history.
\end{lem}

\proof
Let .
We have already seen in Lemma~\ref{lem:tile is such}
that each  is a -tile.
The sequence is increasing,
because we are considering positive (hence monotone) types
and the sequence  is increasing.
It is strictly increasing because we have removed duplicates.
For ordinals~, let  be the index
at which the th stage appears in~, i.e.,
.
As the sequence is increasing, so is~.

Since , we have

For , let  be the minimal ordinal with .
Then

Since elements enter the fixed point only at successor stages, we have


\noindent We would like to annotate each vertex~ of a tree~ by the sequence
. To obtain a finite object, we have to remove
duplicates and, therefore, we work with the history  instead.
For each~, we would like to have an automaton that can recover the
tiling~ from~.
In general, this is not possible.

For instance, in Example~\ref{ex:paths} the `real' tilings 
for a path~ of even length are words of the form 
where  is the `mirror image' of .
This language is not regular.

Hence, we use an approximation.
For each vertex~, each index~ of , and each direction~,
we record the index~ of  such that
 and  belong to the same ordinal~.
Of course, given~, there are several choices of~
and, hence, of~, so we lose information. It will turn out that
these two pieces of data,
the function~ and the function ,
are sufficient for our purposes.

\begin{defi}
\textup{(a)}
An \defn{annotated tree} is a tuple , where
\begin{enumerate}
\item  is a -tree,
\item  is a mapping that assigns to each vertex  a -history , and
\item  is a mapping assigning a natural number 
  to each vertex , each index , and every direction 
  with .
\end{enumerate}
We call ~the \defn{history map} and ~the \defn{synchronisation} of the annotated tree.

\textup{(b)}
Let  be an annotated tree.
For  and ,
the \defn{section} at 
is the tiling~ defined inductively as follows\?:
\begin{enumerate}
\item .
\item For , let .
  We assume by induction that  is already defined.
  Let  be the index such that .
  Then we set .
\end{enumerate}
\end{defi}

\noindent Of course, not every annotated tree 
encodes the `real' fixed-point induction.
The next definition collects some necessary conditions.
\begin{defi}
Let  be an annotated tree.

\textup{(a)}
~is \defn{locally consistent}
if, for all vertices , indices , and directions 
the following conditions are satisfied\?:
\begin{enumerate}
\item If ,
  then .
\item Otherwise, 
  and .
\end{enumerate}

\textup{(b)}
~is \defn{globally consistent}
if it is locally consistent
and if, for all  as above, the section at 
is globally consistent towards~.
\end{defi}

\begin{lem}\label{lem: sections are locally consistent}
Let  be a locally consistent annotated tree.
Every section~ at some  is locally consistent towards~.
\end{lem}
\begin{proof}
Let  be distinct vertices, , and let ~be the index
such that .
Then we have  and , or

\end{proof}

We have not yet defined the `real annotation' of a tree.
In fact, due to the choices involved in defining
the synchronisation there are several possible `real' annotations.
We obtain them by fixing an ordinal~ and selecting
that synchronisation that
selects from among all possible choices
the stage that is closest to~.

\begin{defi}\label{def: betasyndef}
Let  be a -tree and .
We denote by 
the annotated tree 
where the synchronisation~ is defined as follows.
For , ,
and  with ,
we define  such that

where the ordinal~ is chosen as follows\?:
\begin{enumerate}
\item if , then ,
\item if ,
  then  is maximal
  such that , and
\item if ,
  then  is minimal
  such that .
\end{enumerate}
\end{defi}

We start with a technical lemma containing a monotonicity property
for the sections of an annotation.
\begin{lem}\label{lem:sections monotone}
Let ~be a tree with vertices ,
let ~be the section of  at ,
and set .
\begin{enumerate}
\item[\normalfont(a)] If ,
  then , for all .
\item[\normalfont(b)] Let . If , then
  , for all .
\end{enumerate}
(Here we set .)
\end{lem}
\begin{proof}
We only prove the claims for . The argument for  is similar.
We prove both claims by induction on the distance between 
and~. The claims are immediate for .

For the inductive step assume that the claims hold for~
and let  be a neighbour of~ which is further away from~ than~,
so that .
It follows that  for some .
Let ~be the index such that .
By definition of ~and~, respectively, we have

for some ordinal~.

For (a), using the inductive hypothesis,
we have ,
which implies that .
Hence, .

Similarly, for (b), we have ,
which implies that .
Hence, .
\end{proof}

Let us also show that  is always globally consistent.
\begin{lem}\label{lem:annotated tree is such}
For all -trees  and all ,
 is a globally consistent annotated tree.
\end{lem}

\proof
We have seen in Lemma~\ref{lem:history is such} that  is a
-history.
Hence,  is an annotated tree.
For local consistency, fix  and let ~be the ordinal
from the definition of~
at~ in  (cf.~Definition~\ref{def: betasyndef}).
Then

as desired.

It remains to prove global consistency.
Fix a vertex  and an index ,
and let ~be the section at~.
For , let  be the ordinal closest to~
such that .
Let  be the expansion of 
by the set .
We need to show that
,
for all  and .
(Here, .)
By local consistency of~
(which holds by Lemma~\ref{lem: sections are locally consistent}),
it is sufficient to show that
,
for all  and .
We do this by induction on the distance between  and .

First, suppose that .
Then Lemma~\ref{lem:sections monotone}\,(a) implies that
, for all .
Consequently ,
and hence , as desired.

It remains to consider the case that .
By symmetry, we may assume that .
Let ~be the maximal subtree of 
that contains the vertex~ and
such that  for all .
Let  be the finite or infinite list
of all pairs  such that  and .
Let  be the missing neighbour.
Note that, by definition of~,  is the minimal ordinal~
such that
.
Hence,  and it follows that
 and .
By local consistency and the inductive hypothesis, we have

while, by definition of~, we have

It follows that

for each index~.
As the subtrees of
 and  induced by~ agree,
we can use Proposition~\ref{prop:Feferman-Vaught II}
to deduce that



\section{Ranks}
\label{sect:ranks}

It remains to compute the length of the fixed-point iteration from
a given annotated tree.
The goal essentially is to obtain an estimate for the stage of a designated
element of the fixed point\?; this estimate is extracted from an annotation
in terms of the weight of an accepting run of a weighted
automaton which checks consistency of the annotation.
The appropriate kind of weighted automata for this purpose will be
presented in the next section.

\begin{defi}
\textup{(a)}
Let  be an annotated tree and  a node.
We say that there is a \defn{jump} at~
if there is some index~ such that
 and .
Observe that this value of ~is uniquely determined.
We call the jump a \defn{base jump} if .

\textup{(b)}
Suppose that there is a jump at~ that is not a base jump.
We say that this jump \defn{depends} on another jump at a node~
if  where ~is the section at  and .
The \defn{rank} of a jump is the minimal number of jumps
on any dependency chain from this jump to some base jump.

\textup{(c)}
An annotated tree  is \defn{jump-consistent,}
if the set of vertices with a jump equals .
\end{defi}

The notion of \emph{dependency} in~(b) may warrant some comment, because
the terminology could easily be misunderstood. What the criterion is meant to
capture is not that there must be a (causal or temporal) dependence of the
appearance of~ in the fixed point on the (prior) appearance of~\?;
rather, it says that such a dependence cannot be ruled out.
At least any~ that ~does \emph{not} depend on in the sense of the definition can
have had no influence on the appearance of~.
In this sense our dependency relation provides a generous upper bound
on any intuitive `real' dependency\?:
it may be useful to think of ~as a \emph{potential} trigger for~.

Let us compare the rank of a jump with the stage of the corresponding vertex
in the fixed point (the stage at which the vertex enters the fixed point).
First, we show that in every annotation the latter bounds the former.
\begin{lem}\label{lem:stage bounds min rank}
Let 
be a globally consistent and jump-consistent annotated tree,
let ~be a vertex with a jump in~, and .
If ,
then the rank of~ is at most~.
\end{lem}

\proof
We proceed by induction on~.
For  there is nothing to do since
.
Hence, we may assume that  and that the claim already holds for smaller
ranks.
Let  be the index such that  and .

If , then there is a base jump at~ and its rank is .

For , let  be the section at 
and let .
From  we conclude that .
As  is globally consistent, it follows that .
On the other hand, .
By monotonicity,
there must be some vertex ,
which, by jump-consis\-tency, has a jump.
As , we have . Consequently, ~depends on~.
By inductive hypothesis, ~has rank at most .
Therefore, ~has rank at most~.
\qed

Some form of converse is true for annotations of the form .
\begin{lem}\label{lem:min rank bounds stage}
Let  be a -tree, , and .
If the rank of  in  is at most ,
then .
\end{lem}

\proof
We proceed by induction on .
As all ranks are positive, .
Let  be the index such that  and .
If ,
then .
Therefore,  and we are done.
Hence we may assume that , i.e., the jump at~ is not a base jump.

Let ~be the section at .
As the jump at~ is not a base jump and its rank is finite,
there is some vertex~ with a jump rank at most 
such that ~depends on~.
By the inductive hypothesis, we have .
Consequently, .
On the other hand, we have  by choice of~.
Therefore, .
By Lemma~\ref{lem:sections monotone}, this implies that

It follows that 
for any~ such that .
Therefore, there exists a maximal such ordinal~ and,
moreover, .

As ~is maximal such that ,
it follows that  is maximal
such that .
Accordingly, ~is maximal such that
.
Thus, 
and .
It follows that .
\qed

It follows that boundedness of the fixed-point iteration
is equivalent to the existence of a finite bound on the ranks of all annotations.
\begin{defi}
A \defn{proposal} is a tuple ,
where 
is a globally consistent and jump consistent annotated tree
and .
The \defn{rank} of such a proposal is the rank of the jump at~ in .
\end{defi}

\begin{prop}\label{prop: boundeness and ranks}
A formula~ is bounded over the class of all ternary trees
if, and only if, there is some number 
such that the rank of each proposal is at most~.
\end{prop}

\proof
 Suppose there exists a bound  on the ranks of proposals.
Let  be some ternary tree, and .
By Lemma~\ref{lem:annotated tree is such},
 is a proposal.
By choice of~, the rank of~ is at most~.
Hence, Lemma~\ref{lem:min rank bounds stage} implies that .
As  was arbitrary, it follows that .

 Suppose that ~is bounded by some number .
Let  be an arbitrary proposal.
Then 
and Lemma~\ref{lem:stage bounds min rank} implies
that the rank of the proposal is at most~.
\qed


\section{Weighted automata}
\label{sect:automata}
\label{sect:end I}

In order to decide the boundedness problem for 
we reduce it to the so-called \emph{limitedness problem}
for a certain kind of weighted automaton.
These automata have \defn{-labelled directed trees} as inputs.
Such a tree is a triple 
where  is a labelling of~
and  is a directed tree
(meaning that ,
 is a tree structure,
and there is some  called the \defn{root} of the tree
such that  for all ).

\begin{defi}
\textup{(a)}
A \emph{weighted parity automaton}  consists
of a finite \emph{state space}~, a finite \emph{input alphabet}~,
a set  of \emph{initial states,}
a finite \emph{transition relation}
,
a \emph{priority function} ,
and a \emph{weight function} .

A weighted parity automaton~ takes as input 
-labelled directed trees .
Let  be the projection
to the third component.
A \emph{run} of  on this tree is a mapping 
satisfying, for all vertices , the following condition\?:


A run~ is \emph{accepting,} if
\begin{itemize}
\item  for the root~ of~ and
\item for every branch  of , the limit
  
\end{itemize}
The \emph{language}  recognised by~
is the set of all -labelled directed trees~
on which there is an accepting run of~.

For a run~ on some tree~
and a branch~ of the tree, we set

with values in .

The associated \emph{cost function}  maps 
 to
the minimum of  
taken over all accepting runs~ on~.
If ,  returns~.

\textup{(b)}
We say that the automaton~ is \emph{limited,}
if there is some bound 
such that  for all .
We say that ~is \emph{limited in the finite,}
if there is a bound  such that
 for all \emph{finite} .
\end{defi}
Note that, if we only consider finite trees as input, we can omit the priority
function~ from the automaton. Weighted automata as defined above
are a special case of so-called \emph{cost tree automata}
introduced in~\cite{ColcombetLoeding08}.
In that paper it is shown than the limitedness problem for cost tree automata
over finite trees is decidable.
Hence, the following is a direct
consequence of~\cite{ColcombetLoeding08}.
\begin{thm}[Colcombet and L\"oding]\label{thm:finite limitedness decidable}
It is decidable whether a weighted parity automaton~ is limited in the
finite.
\qed\end{thm}
Colcombet and L\"oding have also announced a decidability result for the
general limitedness problem, but this result has not been published yet.
\begin{thm}[Colcombet and L\"oding]\label{thm:limitedness decidable}
It is decidable whether a weighted parity automaton~ is limited.
\qed\end{thm}

Although the proof is still not published, its key arguments appear
in \cite{VandenBoom12,Colcombet13}.
The following sketch of how they fit together was communicated to the
authors by Colcombet and L\"oding.

A \emph{cost function} 
associates with every tree a natural number or .
We say that such a cost function~ is \emph{dominated} by~ if
~is bounded over every subset  over which~ is bounded.
We denote this domination relation by .

We can state Theorem~\ref{thm:limitedness decidable} in terms of the
domination relation as follows.
Let ~be a weighted automaton and let ~be the language defined by~
if we consider it as an ordinary parity automaton without weight function.
Let ~be the cost function  associated with~ and let ~be the
cost function that maps every tree in~ to~ and every other tree
to~.
Then Theorem~\ref{thm:limitedness decidable} states that it is decidable
whether .

We would like to reduce this statement to Corollaire~8.11 of~\cite{Colcombet13},
which states -- in the terminology of~\cite{Colcombet13} --
that the domination relation  between cost functions
~and~ is decidable, provided that ~is given by a nondeterministic
-Muller automaton and ~is given by a nondeterministic -Muller
automaton.
The function~ from above is given by a parity automaton without weight
function.
Such an automaton can trivially be converted into a -Muller automaton.
Hence, to complete the proof it remains to find an -Muller automaton
recognising~.
This can be done in the same way as in the proof of Theorem~4.28
of~\cite{VandenBoom12}, where the author shows how to transform an
alternating -B\"uchi automaton into a nondeterministic one.
This proof uses game-theoretic techniques.
One key argument is the fact that the games, which correspond to the
automata in question, are positionally determined.
To adapt the proof to our case, one needs positional determinacy for games
whose winning condition is a disjunction between an unboundedness condition
and a parity condition.
This can be shown as in Proposition~7.14 of~\cite{Colcombet13},
which treats winning conditions consisting of a conjunction of a boundedness
condition and a Rabin condition.
One further step of adaptation consists in the construction of a so-called
`history-deterministic' automaton that checks whether a given positional
strategy is winning.
For finite words, the underlying translation of nondeterministic automata into
history-deterministic ones can be found in an unpublished note
(cf.~Lemma~58 of~\cite{Colcombet09b}) on the author's web-page.

\medskip
Using the results of the previous sections we can reduce
the boundedness problem for  on ternary trees
to Theorem~\ref{thm:limitedness decidable}.
To do so, we construct a weighted automaton computing the rank of a proposal
.
In order to use  as input for a tree automaton,
we encode it as a labelled directed tree with root~.
The labelling contains information about the unary predicates in~,
the histories, and the synchronisation.
As there is only a finite number of types,
there is a uniform bound on the length of histories
and we only need finitely many labels.

First we show that the set of all proposals is regular.
\begin{lem}\label{lem: proposals are regular}
Given a formula~,
we can effectively construct a parity automaton~ recognising
the set of all proposals for~.
\end{lem}

\proof
Let  be the quantifier rank of .
It is sufficient to show that the set of proposals can be defined in .
Being a locally consistent annotated tree can be expressed even in~
since it is a purely local property.

For global consistency, note that we can encode a section~
by a tuple of unary predicates~
(the precise number depends on the maximal length of a history)
such that there is an -formula 
stating that  encodes the section at .
Thus, the section at  is -definable and
the corresponding tiling is -interpretable.
In this tiling it is of course possible by means of 
to determine the -type (of quantifier rank at most~) of a subtree.
Consequently, we can express the global consistency of the tiling
and, hence, also the global consistency of the annotated tree.

As the set of jumps can be inferred from the tree labelling,
it is easy to check whether there is a jump at the root ().

It remains to consider jump-consistency,
that is, it remains to define 
(where  is the first component of the prospective proposal).
As  is positive in~, this can be achieved by



\begin{lem}\label{lem: proposals and automata}
Given a formula~,
we can effectively construct a weighted parity automaton~ such that
\begin{enumerate}
\item  is the set of proposals of finite rank\?;
\item if  is a proposal and ~its rank,
  then .
\end{enumerate}
\end{lem}

\begin{proof}
Let  be the quantifier rank of~
and let ~be the automaton from Lemma~\ref{lem: proposals are regular}.
We will construct the desired automaton~
as a product of~ and a weighted parity automaton~,
where the weight function of~ is that of .

Recall that the rank of a proposal 
is the minimal number of jumps
on a dependency chain from the jump at~ to some base jump.
By this minimality condition
we can restrict our attention to chains without cycles.
Each dependency in the chain, say from~ on~,
corresponds to a path in the section at  for a suitable~.
By minimality again, we only need to consider
pairwise disjoint paths, one for each dependency in the chain.
(If two paths intersected, we could form a new path witnessing the dependency
of some former jump in the chain to a latter one. This could be used to shorten
the dependency chain.)
These paths can be concatenated to form a single path in the annotated tree.
For a dependency path~ and a tree node~,
we say that ~is \defn{active}
if there is at least one jump on~ in the subtree rooted at~.

Since the tree is ternary, we can encode dependency paths by a tuple of unary predicates.
We first construct a weighted parity automaton~ that takes as input
a proposal together with such a path.
It checks that the path follows the synchronisation (except for the jumps),
and that it is indeed a single path.
Furthermore, ~is such that from its state at a node~
one can deduce whether ~is active.
We define the weight function of  such
that all transitions have weight ~or~, where we assign
a weight of~ if at least two children of the current node are active
or if there is a jump at the current node.

For a dependency path~ in a proposal~,
let us compare its number~ of jumps
with the weight computed by~.
Let ~be any accepting run of~
on the input .
We claim that .

For the second inequality,
let ~be a branch of  which realizes the maximum for~,
that is, .
With each node  such that 
we associate a jump in~ as follows\?:
if there is a jump at~, we just take this jump.
Otherwise, ~has at least two active children,
so it has at least one active child not in~.
We take some jump from the subtree rooted at that child.
It is clear that, for different , we have chosen different jumps.
Hence, .

For the other inequality, we construct a branch~ as follows\?:
the branch starts at the root
and, whenever we have constructed~ up to some node~
which is not a leaf, we extend~ with a child~ of~
such that the number of jumps on~ in the subtree rooted at~
is at least as large as the respective number for any other child of~.
Let us trace this number along~. Initially, it is~.
It never increases and, whenever it decreases,
the respective transition has weight~
by construction of~.
As we always descend into the fattest subtree,
the number cannot decrease indefinitely\?:
if it is~ for some node, it is at least  for its child
(recall that the original undirected tree is ternary,
so the directed tree has branching at most~,
and even at most~ apart from the root).
A very rough analysis gives that, if ,
then at least~ decreasing steps occur on~.
Hence,
.

Finally, we obtain the desired automaton~ from~
by nondeterministically guessing the extra component~.
To see that the product automaton~ has the claimed properties,
let~ be an input for~.
If  is a proposal of finite rank,
then it is in particular a proposal. Hence,  accepts~.
As the rank is finite, there is some dependency path  for~.
Therefore,  accepts  and  accepts~.
Consequently, also  accepts~.
For the converse, assume that  accepts~.
Then  is a proposal since  accepts~.
Furthermore, there is some~ such that  accepts .
Thus, ~is a dependency path in~ and  has finite rank.
Now, assume that  is a proposal of rank~
and let~ be a dependency path in~ with ~jumps.
Let  be the accepting run of  on 
and let  be the corresponding accepting run of  on .
For each accepting run of  on 
there is such a  by construction of~.
If  is such that  is minimal,
then we can deduce
.
If, on the other hand, ~is such that  is minimal,
we obtain
.
\end{proof}

Combining our results we obtain a proof of the following theorem.

\begin{thm}\label{thm:boundedness for ternary trees}
The boundedness problem for  on the class
of all ternary trees is decidable.
\end{thm}
\begin{proof}
Given an -formula~, we construct
the weighted automaton~ from Lemma~\ref{lem: proposals and automata}.
By Proposition~\ref{prop: boundeness and ranks}, it follows
that ~is bounded if, and only if,  is limited.
The latter we can decide with the help of
Theorem~\ref{thm:limitedness decidable}.
\end{proof}


\bigskip
\section*{Part II. Ramifications}


The boundedness problem has long been of interest
both in classical model theory and in the study of
the algorithmic properties of various fragments,
which in turn is partly motivated by applications
in computer science. The seminal result in the classical
model theory of the boundedness problem 
is the theorem of Barwise and Moschovakis~\cite{BarwiseMoschovakis78}
(see Theorem~\ref{thm:BMthm} below)\?;
the main interest in boundedness as a decision problem,
on the other hand, stems from an interest in \textsc{Datalog}
query optimisation as highlighted in the
first positive and negative results in
\cite{GaifmanMaSaVa93,HillebrandEtAl95}.
In both contexts, the natural emphasis
was on (not necessarily monadic) monotone inductions based on
first-order formulae or formulae in specific fragments of first-order
logic. Even in the study of rather weak fragments of first-order logic,
undecidability of the boundedness problem turned out to be the rule,
decidability the rare exception.


In this second part we link our new results to the wider setting
of the boundedness problem. After a short introduction to
this wider setting, we employ some rather more traditional tools
from model theory, like transfer results and interpretations,
to generalise the technical core results of Part~I and to
reap a number of further specific decidability results.
Some of these answer key open questions raised in the
more traditional setting, concerning, for instance, decidability
of boundedness for the guarded fragment or for the modal -calculus.


To this end, we first review the shift in perspective
from boundedness for syntactically restricted fragments of 
to boundedness over restricted classes of structures\?;
a shift that was first explicitly proposed in \cite{KOS}
where boundedness for otherwise unconstrained monadic 
is treated over the class of acyclic structures.
The class  of acyclic structures consists of those
structures whose Gaifman graph is acyclic.

\begin{thm*}[\cite{KOS}]
The boundedness problem for monadic least fixed points
of arbitrary -positive -formulae over the class of all
acyclic relational structures, , is decidable.
\qed\end{thm*}

The interest here was due to the observation
that reductions to settings involving tree-like structures seem to
be a common theme in most decidability results for boundedness.
On the other hand, availability of grid-like structures can
be widely used to show undecidability of boundedness issues via
reductions from tilings \cite{KOunpub}.
This suggested a rough dichotomy to
explain the borderline for decidability of (monadic)
boundedness problems for fragments of .
On the positive side, our present results bring this approach
to fruition in the much wider and unifying setting of .
Part of this success draws on the above-mentioned
change of perspective, which allows us to re-chart the
relevant fragments with a decidable boundedness problem
into a taxonomy of relevant classes of structures
to which we can lift and extend our decidability results
from Part~I.


We link the more traditional approach to
the boundedness problem to this new perspective
in the following section\?: in particular, we discuss some of
the more prominent fragments that have featured in the quest
for decidability of boundedness so far, and review key results
from that tradition.

In Sections \ref{sect:transfer}~and~\ref{sect:interpretations} we discuss the natural model-theoretic
techniques that can be used to translate and extend our results\?:
transfer properties and reductions (Section~\ref{sect:transfer})
and interpretations (Sections~\ref{sect:interpretations}).
In view of the above discussion this yields results both
in terms of applicability of our key result to
wider classes of structures, and in terms of decidability results
for new fragments.

\medskip
\paragraph*{\itshape Proviso.}
In this part all vocabularies are (finite and) purely relational.


\section{Boundedness in the classical setting}
\label{sect:classical boundedness}
\label{sect:start II}

The key result concerning boundedness from classical
model theory is the following.

\begin{thm}[Barwise--Moschovakis \cite{BarwiseMoschovakis78}]
\label{thm:BMthm}
The following are equivalent for least fixed points
based on any -positive \?:
\begin{enumerate}
\item  is bounded.
\item  is uniformly -definable.
\item  is -definable in each .
\qed\end{enumerate}
\end{thm}

The classical proof is based on compactness arguments
and works with -saturated models for the crucial
implication from~(3) to~(1). It is immediate that this argument
relativises to natural fragments of .
For formulae  from some such fragment of  we
may replace -definability by definability in the
fragment if that fragment has the natural closure properties
that render the finite stages definable\?; for truly natural
fragments like those to be considered below, however,
-definability will imply definability within the
fragment by classical preservation theorems.

While these considerations offer some guidelines as to
what the right candidates  for
decidable  might be, our results from Part~I take
us beyond the limitations of  and compactness --
which also means that boundedness becomes divorced from
definability of the fixed point.

\medskip
We start this section with a brief review of some logics and fragments
that feature prominently in connection with the boundedness problem --
be it in classical results or in new results flowing from our main theorem.
These may be grouped into three main categories\?:

\paragraph{\textit{Existential/universal fragments:}}
certain limited, purely existential/purely universal fragments
 and \?: these are the 
natural candidates
for a decidable monadic boundedness problem  in terms of quantifier
prefix classes 
(cf.\ the classical decision problem, \cite{BGG}).
For decidability of the boundedness problem
extra restrictions on the polarities of
the given relations,
which are statically used in the fixed-point recursion,
and on equality, are necessary.
See Section~\ref{subsec:existforall} below.

\paragraph*{\textit{Modal fragments:}}
the modal fragments of first-order and monadic second-order logic\?:
basic modal logic  and its monadic fixed-point extension
, the bisimulation invariant
fragments of  and , respectively.
See Section~\ref{subsec:modal} below.

\paragraph*{\textit{Guarded fragments:}} the corresponding but more general guarded fragments\?:
the basic guarded fragment  and its fixed-point extension
. These correspond to the fragments of
 and guarded second-order logic , respectively,
that are invariant under guarded bisimulation.
With these logics we also
extend the scope of our discussion beyond monadic fixed points.
See Section~\ref{subsec:guarded} below.

\smallskip
In relation to  or  it is useful
to have in mind the following observation, which severely limits
the expectations regarding decidability but also points to
natural candidates.

\begin{observation}\label{obs:SAT vs BDD}
Assume that  is non-trivial in the sense
that there are unbounded formulae .
Then simple closure properties of~ -- as for instance
closure under monadic relativisation and under conjunctions --
imply that the satisfiability problem 
reduces to the boundedness problem .
An analogous reduction applies w.r.t.\ to restricted classes of models, i.e.,
for  and  provided
 also satisfies some simple closure requirements --
as for instance closure under disjoint unions and trivial expansions by unary
predicates.
\end{observation}


We sketch one typical argument to this effect.
Fix some  that is unbounded.
Then a sentence
 is unsatisfiable if, and only if,
the formula  is bounded\?;
here  and  stand for the relativisations
to two distinct unary predicates ~and~,
which do not occur in either formula.
Clearly, unsatisfiability of~ implies that
 is unsatisfiable and hence
has closure ordinal . Conversely, if  is satisfiable, then
structures obtained as the disjoint union of a -coloured model
of  and a -coloured part show 
to be unbounded. The basic idea can be
modified to suit various other situations. For instance, for modal logic,
where disjoint unions are not the right choice,
one could look at boundedness for  to decide satisfiability of .

\medskip
We turn to the above-mentioned groups of logics.

\subsection{Purely existential and universal fragments}
\label{subsec:existforall}

 is the fragment of positive,
purely existential prenex first-order formulae (with equality), where
for  we also allow (positive occurrences of)
monadic second-order variables.
Dually, we let 
be the fragment of prenex universal
first-order formulae that are negative in all
relation symbols from the underlying relational vocabulary
 and equality, but of course we allow positive occurrences
of monadic second-order variables.

The first interest in boundedness as a decision problem
concerned the query language \textsc{Datalog}
corresponding to the evaluation of systems of least fixed
points of relational Horn clauses of the form

with relational atomic formulae~.
This Horn clause translates into

in our framework. In this connection
the first decidability results were obtained in
\cite{CosmadakisGaKaVa88}, and also the strict limitations for this
decidable case became apparent \cite{GaifmanMaSaVa93,HillebrandEtAl95}.

\begin{thm}\hfill
\begin{enumerate}[label=
  \psi(x) = \exists y ( Rxy \wedge \varphi(y))
  \quad\text{and, dually,}\quad
  \psi(x) = \forall y ( Rxy \to \varphi(y))

  \exists \bar y ( \alpha(\bar x) \land \varphi(\bar x) )
  \quad\text{and, dually,}\quad
  \forall \bar y ( \alpha(\bar x) \to \varphi(\bar x) )\,,

    \set{ \bar{a} \in A^r }{ (\fA,\bar{a}) \models \gdd(\bar{x}) }
  = \set{ \bar{a} \in A^r }{ \bar{a} \text{ guarded in } \fA }\,.

  \gdd(\bar x) \wedge \varphi(\bar x)
{\alph*}]
\item , , ,  and\/ 
  have the \emph{finite model property} for  just as for .
\item[\normalfont(b)]
   and\/  have the \emph{tree-property} for
   and\/ \?;
   even allows transfer to \emph{finite} tree-models
  of bounded branching.
\item , , , ,  and  all have
  the \emph{bounded-tree-width property} for  and\/ .
  Among these, the modal logics ,  even allow transfer to
  tree models of bounded branching\?;
  , ,  and  allow transfer to models of
  bounded tree-width, in the case of , ,  even
  to \emph{finite} models of bounded tree-width.
\end{enumerate}
\end{observation}


\noindent More specifically, the necessary tree-width~ in~(c) can be
bounded by the width of the underlying vocabulary~
in the modal and guarded cases,
and (for a rough bound) by the size of the given formula~
in the case of , .

Most of these statements follow
from corresponding properties for ,
which are well known from the literature
(cf.~in particular Observation~\ref{obs:SAT vs BDD} above).
The bounded-tree-width property for  in the
case of  and  is a direct consequence of
preservation of these logics under guarded bisimulation. Guarded
tree-unfoldings \cite{Graedel99,GHO} of arbitrary models yield
models possessing a tree decomposition whose bags are guarded subsets,
hence of width bounded by the width of~.
For the assertions concerning the fragments  and , which
are not closed under negation, we prove the following lemma.

\begin{lem}
 and  allow transfer for  to
finite models of bounded tree-width.\footnote{Here tree-width can be bounded by
the size of the given prenex formula \?; a better bound
would be the tree-width of the quantifier-free kernel formula.}
\end{lem}
\begin{proof}
We explicitly treat the case of \?; the argument for  is
strictly analogous.

For -positive  and finite ,
the stage increment

is uniformly definable by a conjunction of a purely existential
formula

and a purely universal
formula in  equivalent to the negation of .
Formulae of this kind are known to have the finite
model property\?:\footnote{They fall in particular within
the Bernays--Sch\"onfinkel class of prenex -formulae
with quantifier prefix , cf.~\cite{BGG},
but a more direct argument suffices here.}
from an arbitrary model  of some conjunction of a prenex
-formula  and a prenex
-formula , one obtains a finite model
by restricting  to  together with any chosen instantiation for the
existentially quantified variables in \?; this restriction
still satisfies , and as an induced substructure
of  it also still satisfies the universal
formula~.

To obtain suitable (finite) models of bounded tree-width,
though, we need to consider the stronger preservation properties of
the formulae ,
and to some extent use the polarity constraints in  and .
The following argument also makes an interesting connection
with .

Let w.l.o.g.\  be of the form

where ,
the  are conjunctions of relational -atoms
(not involving ), and .
For any -structure  let  be its expansion to
a -structure by new relations~
of arity , with ~defined by~.
In ,  is equivalent to the -formula


An analogous equivalence obtains for formulae 
and 
defining the finite stages w.r.t.\  and .

Obviously

where the
formula on the left-hand side is in .
Note, however, that implications of the form
,
which would be needed
towards the equivalence between  and 
cannot in general be expressed in .

Let  be a guarded bisimilar unfolding of~.
Its tree-width is bounded by the maximum of
the width of~ and .
We also write  for the -reduct of .
Let  be the
projection from the unfolding onto the base structure\?;
~is a homomorphism inducing the natural guarded bisimulation
between  and .
Preservation of  under guarded bisimulations implies
that, for all ,


Since  implies 
and, therefore, also ,
it follows with  above that 
 implies 
.

In the opposite direction,
since the~, as existential positive
formulae, are preserved under homomorphisms,
the implication
 is straightforward.
Therefore, for all  and all ,

whence .
Hence  is bounded iff it is bounded over structures
whose tree-width is bounded by the
maximum of the width of~ and .
In order to get back to finite models
of bounded tree-width, we may apply the simple
argument from above to find a finite induced substructure within
some  that still satisfies the corresponding
-conjunction
.
\end{proof}


\subsection{\boldmath Transfer for  over trees}

At the level of  we obtain a bounded-branching property
for  over trees. The availability of transfer at least
down to countable branching is essential to make a connection
via interpretations with our core result that was formulated over
ternary trees.

\begin{prop}\label{prop:countable branching property for MSO}
 has a countable branching property for monadic  over trees.
\end{prop}

This statement follows immediately from
Proposition~\ref{prop:Loewenheim-Skolem for trees} below,
whose proof relies on
the availability of tree automata for  and involves, as a key step,
a L\"owenheim--Skolem property for -theories of trees.
We employ a certain kind
of tree automata introduced by Walukiewicz~\cite{Walukiewicz02}.
\begin{defi}
An \emph{-automaton} is a tuple 
with a finite set of states~, an input alphabet~,
an initial state~, a parity function ,
and a transition function 
that, given a state~ and a letter~, returns an -formula
 over the signature .

Such an automaton takes a -labelled directed tree
 as input.
A \emph{run} of~ on~ is a function 
with  for the root  of 
such that

where the universe~ of the structure is the set of all children of~
and the unary predicates are .
The run~ is \emph{accepting}
if, and only if, for all infinite branches  of~

The \emph{language recognised by~} is the set 
of all trees~ such that there exists an accepting run
of~ on~.
\end{defi}

Over trees these automata have the same expressive power as monadic second-order logic.
\begin{thm}[Walukiewicz~\cite{Walukiewicz02}]
A class~ of directed trees is definable
by an -sentence~ if, and only if,
it is recognised by some -automaton~.
\qed\end{thm}

We use -automata to prove the following L\"owenheim-Skolem theorem.
\begin{prop}\label{prop:Loewenheim-Skolem for trees}
For every tree structure~ there exists a countable tree structure 
with the same -theory.
\end{prop}
\begin{proof}
We prove the proposition for directed trees.
Then the corresponding claim for undirected trees follows.
Suppose that  is a directed tree with root~.
Let us call a substructure  a
\emph{subtree} of~ if ~is a tree and it contains the root~.

To prove the claim, we construct a countable subtree 
such that every -automaton accepting~ also accepts~.
Since every -formula is equivalent (on trees) to an -automaton
and since  is closed under complement, it follows that
 and  have the same -theory.

To construct~ we proceed as follows.
For every -automaton~ that accepts~ and every vertex
, we fix a countable set  of children of~
such that the following holds\?:
\begin{itemize}[label=]
\item Every subtree  such that
  
  is accepted by~.
\end{itemize}
Let us call a subtree~ \emph{-closed} if
 implies .
We take for~ the minimal subset of~ containing
the root~ that is -closed for every~ accepting~.
The subtree~ induced by~ is countable and has the desired property.

To define  we fix an accepting run~ of~ on~.
Let  be a vertex with label~ and let ~be the set of children
of~ in~.
For each state , ~induces a structure 
satisfying the transition formula .
For every state , we select a set  as follows.
If ~is countable, we set .
Otherwise, we choose an arbitrary countably infinite subset .
Then we set


We claim that, for every -closed subtree ,
the restriction of~ to~ is an accepting run of~ on~.
Obviously, every infinite branch of~ is an infinite branch of~
and, hence, satisfies the parity condition. So we only need to check
that the transition formulae hold at each vertex.
Let  be a vertex with label~ and with set of children~, and
let  be the structure induced by~.
Since ~is a run, we have

Note that the structure  has only unary relations.
There is a well-known Ehrenfeucht-Fra\"\i ss\'e argument showing that
an -sentence of quantifier rank~ cannot distinguish
two such structures  and ,
provided that each quantifier-free -type is realised the same
number of times in both structures, or it is realised at least ~times
in each structure.

By definition of~, it follows that,
for all subsets  containing ,
the structures

have the same -theory.
Consequently,

In particular, this is the case for .
Therefore,  is a run.
\end{proof}
\begin{rem}
If, instead of the full -theory, we are only interested in
the preservation of a single -sentence,
the construction of the theorem yields a tree that is finitely branching.
\end{rem}

\begin{proof}[Proof of Proposition~\ref{prop:countable branching property for MSO}]
Clearly, if an -formula  is bounded over the class of all
trees, it is also bounded over the class of all countable trees.
Conversely, suppose that  is unbounded over arbitrary
trees. Then we can find, for every , a tree~
satisfying the formula
.
By the above proposition, we can choose  to be countably branching.
Hence,  is also unbounded over the class of all countably
branching trees.
\end{proof}

\section{Interpretations and reductions}
\label{sect:interpretations}

In the preceding section we have considered transfer of 
from one class~ to a subclass .
In this section we will study more general reductions
of  to  where both the logic~
and the class~ may change.

\subsection{\boldmath A reduction for }
\label{GFredsec}

We start by reducing  to .
The following normal form for -formulae is used in the proof
of the proposition below.
\begin{lem}\label{lem:normal form for GSOg}
Let  be a -formula with
free second-order variables ,~ and
free first-order variables~ that is positive in~.
We can effectively construct 
-formulae , , for ,
such that

where
\begin{itemize}
\item the formulae~ are quantifier-free and positive in~,
\item the formulae~ are positive in~ and such that ~only appears in subformulae
  of the form  and .
\end{itemize}
Furthermore, if ~is a -formula,
then so are the formulae , .
\end{lem}
\begin{proof}
We may assume that ~is in negation normal form.
The claim follows by induction on the structure of~.
All other cases being trivial, we present only the case of second-order quantifiers.

Hence, let us assume that , for .
By inductive hypothesis, we may assume that

with ~and~ as in the statement of the lemma.
In case of an existential quantifier, we are done since

For a universal quantifier, note that

Hence, the claim follows by another application of the distributive law.
\end{proof}
\begin{prop}\label{prop: GSOg reduces to GSOgs}
For every formula ,
we can effectively construct a formula 
such that  is bounded if, and only if,  is.

Furthermore, if ~is a -formula, then so is~.
\end{prop}
\begin{proof}
By the lemma we may assume that the formula  has the form

where the formulae~ are quantifier-free
and in the formulae~ every occurrence of~ is in a subformula
of the form  and .

Note that any occurrence of an atom~ that is in the
scope of some (guarded\?!) first-order quantification may be replaced by the formula
 without changing its semantics.
Therefore,

where  is the formula obtained from~
by replacing~ by its guarded restriction~ without affecting the semantics.
In the following a superscript 
is always used to indicate syntactic and/or semantic restriction to
the guarded part.

The fixed-point induction of 
is closely related to the fixed-point induction of the strictly guarded formula


Since ~implies~ and both formulae are positive in~,
it follows that the stages of~ are included in those for~.
In fact, it follows by a simple induction on~ that
.
Consequently, we have


If we can show that there exists a constant , depending only on~,
such that, for all structures~,

then it follows that ~is bounded if, and only if, ~is bounded.

To find the constant~, we consider the auxiliary formula

in vocabulary 
(with a new second-order variable~ of the same arity~ as~,
which is regarded as a parameter) and
we consider its fixed-point induction in the expansion
 of~ where ~is interpreted by the relation .
We claim that


Let . We have shown above that
.
Using monotonicity, it follows by a simple induction on~ that

The first inclusion implies that  while
the second inclusion implies that .
Setting , it follows that

Hence, , as desired.

We have shown that, for every structure~,

To conclude the proof it remains to prove that  is uniformly bounded.
Note that ~treats~ as a static parameter, and only involves
its fixed-point variable~ outside the scope of any quantifiers.
It follows that ~is trivially bounded (with a bound that is given by
the number of quantifier-free -types in vocabulary ).
\end{proof}

Hence we may restrict attention
to fixed points over strictly guarded formulae.
This means that  reduces to .
Let us remark that a corresponding result for  fails.

An argument analogous to the above
also applies to \?: according to \cite{GHO},
every -formula is equivalent to one where
every fixed-point operator is applied to a
strictly guarded formula.
For -formulae of this form,
a variant of Lemma~\ref{lem:normal form for GSOg} holds.
This is all we need for the proof of Proposition~\ref{prop: GSOg reduces to GSOgs}.
Consequently,  reduces to .


\subsection{\boldmath -interpretations in trees}


In the first part we have obtained the decidability of .
In this section, we use model-theoretic interpretations to
reduce the decidability of  to this problem.

\begin{defi}
Let ~and~ be relational signatures.

\textup{(a)} A \emph{definition scheme} for an -interpretation
from~ to~ is a list

of -formulae where
~is a sentence,
~has one free variable,  has two,
and the number of free variables of  equals the arity of the
relation symbol~.

\textup{(b)} The \emph{operation defined} by a definition scheme~
maps -structures~ to -structures .
A -structure~ such that
,  
and such that ~defines an equivalence relation~
on , 
is mapped to the -structure~ with universe

and, for each -ary relation , the relation

For any other -structure~, we let  be undefined.

\textup{(c)} An \emph{-interpretation} is an operation defined
by a definition scheme~.
If ~is a class of -structures, we set

\end{defi}

For the proof of Proposition~\ref{prop: boundedness and interpretations} below,
let us recall the following well-known lemma.
We include a proof, so that we may refer to a
precise format of the formulae~ later.
\begin{lem}[Interpretation Lemma]\label{lem:interpretations}
Let 
be an -interpretation.
For every -formula~,
there exists an -formula~ such that,
for all -structures~ and every tuple  in~, we have


If ~is positive in a predicate~ and the
formula  from~ is positive
in a predicate~, then ~is also positive in~.
\end{lem}
\begin{proof}
First, we define a formula~ by induction on~ as follows\?:

and the translation  commutes with boolean operations and set quantifiers.

Then we can set

where
the conjunction is over all free variables of~ and
 is the conjunction of~ with a formula~ stating
that ~defines an equivalence relation on~.
\end{proof}

\begin{prop}\label{prop: boundedness and interpretations}
Let ~be an -interpretation and
~a class of -structures.
If\/  is decidable then so is .
\end{prop}
\begin{proof}
We use the same notation as in the proof of Lemma~\ref{lem:interpretations}.
Suppose that 
and let  be a formula over the signature .
We extend the notation~ from above to formulae containing a free
set variable~ by treating~ as a relation defined by the formula~, i.e.,
we set

Let  be a structure such that  is defined.
Note that Lemma~\ref{lem:interpretations} implies that

For formulae ~and~, it follows by induction on the structure of~ that

A simple induction on~ yields

Since , it follows by the definition of the mapping 
that, for every , we have

Consequently, ~is bounded over 
if and only if  is bounded over~.
\end{proof}

\begin{cor}\label{cor:decidability and subclasses}
Let ~be a class of -structures and ~an -formula.
If\/  is decidable then so is
 where

\end{cor}
\proof
We can use the interpretation 
with



For the application to boundedness below we will need the following
interpretation results. First, let us consider classes of trees.
The proof of the following lemma is straightforward.
For (a)~and~(b), we use the usual first-child/next-sibling encoding of a tree,
while for~(c) we use a marking of the root, which can be used to recover the
orientation of the edges since we can express reachability in .
\begin{lem}\label{lem: tree interpretations}
There exist -interpretations mapping
\begin{enumerate}
\item the class~ of all ternary trees to the class~ of all countable trees\?;
\item the class of all finite ternary trees to the class of all finite trees\?;
\item the class of all undirected trees to the class of all directed trees.
\qed\end{enumerate}
\end{lem}

Next, we study structures of bounded tree-width.
\begin{defi}
Let  be a relational vocabulary and  a -structure.
A \defn{tree-decomposition} of~
is a -labelled directed tree 
satisfying the following conditions\?:
\begin{itemize}
\item .
\item For all relation symbols  of arity~ and all tuples
  ,
  there is some  such that .
\item For all ,
  the set 
  is connected in .
\end{itemize}
The \defn{width} of~ is .
The \defn{tree-width} of~ is the minimum width
of a tree decomposition of~.
\end{defi}

\begin{lem}\label{lem: interpretation for bounded twd}
For every  and all relational vocabularies~,
there exists an -interpretation
mapping the class of all trees to the class 
of all relational -structures of tree-width at most~,
and the class of all finite trees 
to the class of all finite structures from . 
\end{lem}
\proof
For finite trees, such an interpretation was first given
by Courcelle and Engelfriet~\cite{CourcelleEngelfriet95},
but using a slightly different notion of an interpretation.
We give a detailed proof, since the precise version needed here
does not appear in the literature.

We start by explaining how we can encode a structure 
into a tree.
Then we will construct an interpretation~ performing the inverse translation.
Let  be a -structure of tree-width at most~
and let  be a tree decomposition of~ of width at most~.
It is no restriction to assume that
no  is empty
and that there is some injective function 
with , for all~.
For every , we
fix an enumeration 
of  where 
and  for all .
We obtain a tree structure
by turning  into an undirected tree
expanded by the following monadic relations\?:
\begin{itemize}
\item a unary predicate~ containing only the root\?;
\item unary relations~, for ,
  containing those  such that ~has a parent~ and \?;
\item unary predicates , for every -structure~ with universe
  , for some ,
  where ~contains those  such that  is isomorphic
  to the substructure of  induced by 
  via the isomorphism .
\end{itemize}
The interpretation 
that reverses this encoding is defined as follows.
The formula ~states that
\begin{itemize}
\item  is a singleton, unless the universe is empty\?;
\item for all  with  and ,
   is disjoint from  and from \?;
\item the  are disjoint\?;
\item if  and  are such that ,
  then there is no  with  or .
\end{itemize}
For all ,
there is an -formula 
which defines the set of pairs  such that .
We set

Finally, for each relation symbol  of arity~, we define




\section{Decidability results for boundedness}
\label{sect:decidabilities}
\label{sect:end II}

Using the reduction techniques of the previous sections
we obtain a wealth of decidability results.
We start with  and .
\begin{prop}\label{prop:boundedness for all trees}
The monadic boundedness problem for  over the class of all trees is decidable.
\end{prop}
\begin{proof}
By Proposition~\ref{prop:Loewenheim-Skolem for trees}, an -formula
is bounded over the class of all trees if, and only if, it is bounded over
the class of all countable trees. Hence, it is sufficient to prove that
 is decidable.
By Lemma~\ref{lem: tree interpretations},
there exists an -interpretation~ mapping~
to . Hence, the decidability of 
follows by Proposition~\ref{prop: boundedness and interpretations}
and Theorem~\ref{thm:boundedness for ternary trees}.
\end{proof}
\begin{thm}\label{theo:tree-width extension}
For every  and all relational vocabularies~,
, the monadic boundedness problem for 
over the class~ of all relational -structures
of tree-width at most~ is decidable.
\end{thm}
\begin{proof}
With the help of
Lemma~\ref{lem: interpretation for bounded twd}
and Proposition~\ref{prop: boundedness and interpretations}
we can reduce  to .
The latter is decidable by
Proposition~\ref{prop:boundedness for all trees}.
\end{proof}

\begin{cor}
, , and\/  are decidable.
\end{cor}
\begin{proof}
For each of these logics,
Observation~\ref{obs:classical transfer results}
provides a transfer result
to (finite) structures of bounded tree-width.
\end{proof}

Using similar techniques as above, one can extend Theorem~\ref{theo:tree-width extension}
to the extension of  by counting quantifiers,
to guarded second-order logic , and to simultaneous fixed points.
Instead of replacing  by a stronger logic,
one can also replace tree-width by clique-width.

We only give a sketch of the proof.
Let us denote by  and  the extension
of the respective logic by predicates of the form
 and ,
where ~is a second-order variable and .
A \emph{simultaneous} fixed point is defined by a system of formulae

with first-order variables~ and ~second-order variables .
\begin{thm}\label{thm: bdd for GSO over bounded twd}
For every , the boundedness problem for simultaneous -fixed points
over the class of all relational structures of tree-width at most~
is decidable.
\end{thm}
\begin{proof}[Sketch]
Since structures of tree-width at most~ are sparse,
we can find, for every -formula, an equivalent -formula
(see \cite{Courcelle03,Blumensath10}).
Therefore, the boundedness problem reduces to the boundedness
of simultaneous -fixed points on that class.
Using the interpretation argument from above, we can reduce it further
to the boundedness for simultaneous -fixed points
on the class of all ternary trees. On ternary trees,
 collapses to .
Therefore, we only need to decide boundedness for simultaneous
-fixed points.
Finally, using again an interpretation argument we can replace
a simultaneous fixed point by an ordinary one (by making several copies of each vertex
of the tree, one for each component of the simultaneous fixed point).
\end{proof}
\begin{cor}\label{cor:decidability of BDD(GF), etc}
The following problems are decidable\?:
, , , , and\/
.
\end{cor}
\begin{proof}
By Observation~\ref{obs:classical transfer results},
 and  have the bounded-tree-width property for .
Hence,  and  reduce to  and , respectively,
which in turn are subsumed by .
According to Proposition~\ref{prop: GSOg reduces to GSOgs},
 reduces to  which is decidable
by Theorem~\ref{thm: bdd for GSO over bounded twd}.

For  note that, singletons being always guarded,
every -formula 
with a single free first-order variable~ belongs
to .
Hence,  reduces to 
and the claim follows again from Theorem~\ref{thm: bdd for GSO over bounded twd}.
\end{proof}


\bigskip
\section*{Part III. Complexity Results}

\medskip
\section{Complexity}
\label{sect:complexity}
\label{sect:start III}
\label{sect:end III}

In connection with our decision procedures we have not been
specific about the algorithmic complexities involved.
The fact that we have to deal with -positive -types
as basic data has a major impact on all upper bounds that
can be derived from our approach.
Space  is necessary to even
store such a type ( denotes
the -fold application of the exponentiation operation,
that is, a tower of height~).
Overall it is straightforward to check that, on input~,
our decision procedure runs
in time .

We now provide a corresponding lower bound,
even for monadic boundedness for first-order logic over just finite trees.
Note that, for most natural fragments of ,
one can obtain a lower bound from the complexity of the
satisfiability problem of the fragment.
For instance,  is \textsc{Pspace}-hard
since satisfiability for  is \textsc{Pspace}-complete.
For first-order logic over finite words \emph{with order,}
as well as over finite trees \emph{without order,}
we can similarly derive lower bounds from corresponding 
bounds for the satisfiability problem.

\begin{thm}\label{theo:lower complexity bound}
\textup{(a)}
The boundedness problem  for 
first-order logic over the class of finite words with order, 
is complete for .

\textup{(b)}
The boundedness problem 
 for first-order logic over the class
of all finite trees is hard for .
\qed\end{thm}

Part~(a) follows from the corresponding 
result for \?;
see \cite{Reinhardt02} for a proof and exposition.
Part~(b) is a consequence of the following complexity bound for
\?; although this is based on standard techniques,
we include a proof since this complexity bound does not seem to appear
in the literature.


\begin{prop}\label{Prop: SAT(FO,Tfin) hard}
 is hard for 
under polynomial time reductions.
\end{prop}
\begin{proof}
We show that  is hard for ,
which is the same as .
We use the following tiling problem, which is complete for
 (see~\cite{Harel85} for an overview)\?:
given a set~ of tiles, two relations , and
a natural number~ (in unary encoding), determine whether there exists a tiling
of the -grid, i.e., a function
 such that


For the reduction, we set .
One can show that the problem remains complete for

even if we require for convenience that there are at most~ tiles.
Thus, we can represent tiles by numbers less than~.
We construct a formula~ that is satisfied by some finite tree
if, and only if, there exists a tiling of the -grid.

We use an encoding of numbers by directed trees
introduced in~\cite{FlumGrohe06} (see also~\cite{DawarGrKrSchw07})
where numbers from  are encoded by trees of height at most~.
The encoding is such that there are first-order formulae
, , ,
 and ,
which can be constructed in time polynomial in~,
with the property that
\begin{itemize}
\item a vertex~ in a tree~ satisfies  if the
  subtree rooted at~ encodes a number from \?;
\item a vertex~ satisfies  or 
  if the subtree rooted at~ encodes the number ~or , respectively\?;
\item the formulae  and 
  similarly define equality and the successor relation for numbers
  encoded in the subtrees rooted at~ and~.
\end{itemize}

\noindent We use this encoding to represent triples of numbers as follows.
The triple  is encoded by a tree of the form
\begin{center}
\includegraphics{final-4.pdf}
\end{center}
where , , and  are the trees representing
, ,~and~, respectively.
Then, a tiling can by represented by a set of triples ,
where ~and~ are coordinates and  is the tile at position .
The respective set of trees is turned into a single tree
by making all these triples children of a new root.

To axiomatise the representation of a valid tiling,
we use a formula~ based on the formulae
, , ,
, and  from above.
The formula  expresses the following\?:
\begin{itemize}
\item All children of the root encode triples of numbers.
\item There is some triple  with .
\item Each triple has a neighbour to the right,
  unless the -coordinate already is .
  The tiles of the triple and its neighbour match.
\item Similarly, there is a neighbour above.
\item Each position occurs at most once.
\end{itemize}

Such a formula~ is constructible
in time polynomial in  and the size of the tile set.
Clearly, directed tree models of~
correspond to valid tilings of an -grid.
Hence, ~is satisfiable by such a tree if, and only if,
such a tiling exists.

To work inside the class ,
we need to replace the directed trees by undirected ones.
Observe that every model of~ is a tree of height at most .
Hence, we can uniquely mark the root by attaching a path of length  to it.
It is easy to modify~ to work with such undirected trees instead.
\end{proof}

\begin{cor}
The following boundedness problems are -complete\?:
\begin{enumerate}
\item  where ~is the class of all finite trees.
\item  where  is the class of all trees.
\item Boundedness for simultaneous -fixed points
  over the class of structures of bounded tree-width.
\end{enumerate}
\end{cor}
\begin{proof}
(1) follows from Proposition~\ref{Prop: SAT(FO,Tfin) hard}.
As (2)~reduces to~(3), for which we already have a trivial non-elementary upper
bound, it is sufficient to provide a lower bound for .
As we have seen,  reduces to
, which in turn reduces to .
Hence, the lower bound follows from~(1).
\end{proof}

This lower bound shows that, for many cases, our algorithm is best possible.
Of course, there are important fragments of  to which the lower bound is not applicable.
For instance, the following upper bounds are known from the literature\?:
\begin{thm}\leavevmode
\begin{enumerate}
\item  is in \textsc{Exptime} \textup{\cite{Otto99}.}
\item  is in \textsc{2-Exptime} \textup{\cite{CosmadakisGaKaVa88}.}
\qed\end{enumerate}
\end{thm}
Since it is not the main concern of this article, we leave the exact
complexity of , , , , , and  open.


\bibliography{bnd}
\bibliographystyle{plain}

\end{document}
