
\documentclass[acmtocl]{acmtrans2m}



\usepackage{amssymb,amsmath,proof,stmaryrd,txfonts}

\newtheorem{theorem}{Theorem}[section]
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{lemma}[theorem]{Lemma}
\newdef{example}[theorem]{Example}
\newdef{definition}[theorem]{Definition}
\newtheorem{property}[theorem]{Property}

\newcommand{\de}{\dot=}
\newcommand{\narroweq}{\hspace{-3pt}\de\hspace{-3pt}}
\newcommand{\narrowleq}{\hspace{-3pt}\leq\hspace{-3pt}}
\newcommand{\simplify}{\textbf{Simplify} }
\newcommand{\propagate}{\textbf{Propagate} }
\newcommand{\ill}{\textbf{ILL}}

\def\tuple#1{\langle #1 \rangle}
\newcommand{\stateva}[4]{\ensuremath{\tuple{#1 , #2 , #3, #4}}}
\newcommand{\statet}[6]{\ensuremath{\tuple{#1 , #2 , #3, #4}_{#5}^{#6}}}
\newcommand{\derva}{\ensuremath{\mapsto_{\omega_{va}}}}
\newcommand{\dert}{\ensuremath{\mapsto_{\omega_t}}}
 
\newcommand\state[1]{\langle #1 \rangle}
\newcommand\chreq{\equiv}
\newcommand\ent{\rhd}
\newcommand\entv{\blacktriangleright}
\renewcommand\sim{{\blacktriangleleft\blacktriangleright}}
\newcommand\equv{\equiv_\vee}
\newcommand\equivll{\dashv\vdash}
\newcommand\subxy{\left[x/y\right]}
\newcommand\subxt{\left[x/t\right]}
\newcommand\subxa{\left[x/a\right]}
\newcommand\psubxt{\left[x\wr t\right] }
\newcommand\xet{\ensuremath{x\doteq t}}
\newcommand\aci{\ensuremath{\equiv_{AC1}}}

\newcommand{\oesqv}{\ensuremath{\omega^\vee_e}}

\newcommand{\bbP}{\ensuremath{\mathbb{P}}}
\newcommand{\bbS}{\ensuremath{\mathbb{S}}}
\newcommand{\B}{\ensuremath{\mathbb{B}}}
\newcommand{\U}{\ensuremath{\mathbb{U}}}
\newcommand{\C}{\ensuremath{\mathbb{C}}}
\newcommand{\D}{\ensuremath{\mathbb{D}}}
\newcommand{\V}{\ensuremath{\mathbb{V}}}
\newcommand{\G}{\ensuremath{\mathbb{G}}}
\newcommand{\T}{\ensuremath{\mathbb{T}}}
\newcommand{\cN}{\ensuremath{\mathcal{N}}}
\newcommand{\cB}{\mathcal{B}}
\newcommand{\cA}{\ensuremath{\mathcal{A}}}
\newcommand{\cS}{\ensuremath{\mathcal{S}}}
\newcommand{\cC}{\ensuremath{\mathcal{C}}}
\newcommand{\bcA}{\ensuremath{\bar{\mathcal{A}}}}
\newcommand{\bcS}{\ensuremath{\bar{\mathcal{S}}}}
\newcommand{\bcC}{\ensuremath{\bar{\mathcal{C}}}}
\newcommand{\bcL}{\ensuremath{\bar{\mathcal{L}}}}
\newcommand{\cE}{\ensuremath{\mathcal{E}}}
\newcommand{\cD}{\ensuremath{\mathcal{D}}}
\newcommand{\cG}{\mathcal{G}}
\newcommand{\cL}{\mathcal{L}}
\newcommand{\cR}{\mathcal{R}}
\newcommand{\cV}{\mathcal{V}}
\newcommand{\Cb}{\ensuremath{C_b}}
\newcommand{\Cu}{\ensuremath{C_u}}
\newcommand{\Db}{\ensuremath{D_b}}
\newcommand{\Du}{\ensuremath{D_u}}
\newcommand{\cb}{\ensuremath{c_b(\bar t)}}
\newcommand{\cu}{\ensuremath{c_u(\bar t)}}
\newcommand{\db}{\ensuremath{d_b(\bar t)}}
\newcommand{\du}{\ensuremath{d_u(\bar t)}}
\newcommand{\Sct}{\ensuremath{\Sigma_{CT}}}
\newcommand{\Seq}{\ensuremath{\Sigma_{\doteq}}}
\newcommand{\Sp}{\ensuremath{\Sigma_\mathbb{P}}}
\newcommand{\hS}{\hat{S}}
\newcommand{\hT}{\hat{T}}
\newcommand{\hU}{\hat{U}}
\newcommand{\bS}{\bar{S}}
\newcommand{\bT}{\bar{T}}
\newcommand{\bU}{\bar{U}}
\newcommand{\bV}{\bar{V}}
\newcommand{\hbS}{\hat{\bar{S}}}
\newcommand{\hbT}{\hat{\bar{T}}}
\newcommand{\bt}{\bar{t}}
\renewcommand{\bt}{\bar{t}}
\newcommand{\by}{\bar{y}}
\newcommand{\bl}{\bar{l}}
\newcommand{\bs}{\bar{s}}
\newcommand{\bx}{\bar{x}}
\newcommand{\qv}{\ensuremath{\equiv_\vee}}
\newcommand{\nv}{\ensuremath{\rightarrow_\vee}}
\newcommand{\chrv}{CHR}
\newcommand{\omva}{\ensuremath{\omega_{va}}}
\newcommand{\omt}{\ensuremath{\omega_{t}}}
\newcommand{\omr}{\ensuremath{\omega_{r}}}
\newcommand{\omb}{\ensuremath{\omega_{b}}}
\newcommand{\oesq}{\ensuremath{\omega_{e}}}

\newcommand{\der}{\ensuremath{\mapsto}}
\newcommand{\nder}{\ensuremath{\not\mapsto}}
\newcommand{\deresq}{\ensuremath{\der_e}}

\newcommand{\CTm}{CT\models}
\newcommand\inintv[2]{\ensuremath{#1\in\{1,\ldots,#2\}}}

\newcommand{\x}{{\;\otimes\;}}
\newcommand{\lp}{\multimap}
\newcommand{\lpl}{\multimapboth}
\newcommand{\ex}{\exists}
\newcommand{\bang}{\; !}
\newcommand{\with}{\,\&\,}
\newcommand{\lone}{\boldsymbol{1}}
\newcommand{\lzero}{\boldsymbol{0}}
\newcommand{\ltop}{\boldsymbol{\top}}
\newcommand{\lbot}{\boldsymbol{\bot}}

\sloppy

\markboth{H. Betz and T. Fr\"uhwirth}{Linear-Logic Based Analysis of Constraint Handling Rules with Disjunction}
\title{Linear-Logic Based Analysis of Constraint Handling Rules with Disjunction}
\author{HARIOLF BETZ and THOM FR\"UHWIRTH\\
University of Ulm\\
}

\begin{abstract}
Constraint Handling Rules (CHR) is a declarative committed-choice programming
language with a strong relationship to linear logic. Its generalization CHR with
Disjunction (CHR) is a multi-paradigm declarative programming language
that allows the embedding of horn programs.

We analyse the assets and the limitations of the classical declarative semantics
of CHR before we motivate and develop a linear-logic declarative semantics for
CHR and CHR.

We show how to apply the linear-logic semantics to decide program properties and
to prove operational equivalence of CHR programs across the boundaries of
language paradigms.
\end{abstract}

\category{F.3.1}{Theory of Computation}{Logics and Meanings of Programs}[Specifying and Verifying and Reasoning about Programs]
\category{F.3.2}{Theory of Computation}{Logics and Meanings of Programs}[Semantics of Programming Languages]

\terms{Languages, Theory, Verification}

\keywords{Constraint Handling Rules, Linear Logic, Declarative Semantics}

\begin{document}

\begin{bottomstuff}
\end{bottomstuff}

\maketitle

\section{Introduction}
A declarative semantics is a highly desirable property for a programming
language. It offers a clean theoretical foundation for the language, allows to
prove program properties such as correctness and operational equivalence and
guarantees platform independence. Declarative programs tend to be shorter and
clearer as they contain, ideally, only information about the modeled problem and
not about control.

\emph{Constraint Handling Rules} (CHR)
\cite{DBLP:journals/lncs/Fruhwirth94,DBLP:journals/jlp/Fruhwirth98,fruehwirth09}
is a declarative committed-choice general-purpose programming language developed
in the 1990s as a portable language extension to implement user-defined
constraint solvers. Operationally, it mixes rule-based multiset rewriting over
constraints with calls to a built-in constraint solver with at least rudimentary
capabilities. It is Turing complete and it has been shown that every algorithm
can be implemented in CHR with optimal time complexity
\cite{Sneyers05thecomputational}. Hence, it makes an efficient stand-alone
general-purpose programming language.

\emph{Constraint Handling Rules with Disjunction} (CHR)
\cite{DBLP:conf/fqas/AbdennadherS98} extends the inherently non-deterministic
formalism of CHR with the possibility to include backtracking search and thus to
embed horn programs. It features both don't-care and don't-know
non-determinism. We can justly describe it as a multi-paradigm declarative
programming language.

Owing to its heritage in logic programming and constraint logic programming,
CHR features a declarative semantics in classical logic. We have
shown that for certain classes of programs, the classical declarative semantics
of CHR reflects the functionality of a program but poorly
\cite{DBLP:conf/cp/BetzF05}. Operationally, CHR is a state transition system
whereas the classical declarative semantics considers all states in a derivation
as logically equivalent. Hence, the directionality of the rules, the inherent
non-determinism of their execution and any change of state eludes this
declarative semantics.

\emph{Linear logic} is a sub-structural logical formalism
\cite{DBLP:journals/tcs/Girard87} that has been shown  to bear a close
relationship to concurrent committed-choice systems
\cite{DBLP:conf/elp/Miller92,DBLP:journals/iandc/FagesRS01}. It shows that it is
well-suited to model the committed-choice rules of CHR. It furthermore allows a
faithful embedding of classical logic, so we can straightforwardly embed the
constraint theory underlying the built-in constraint solver into linear logic.
Linear logic thus enables us to model the two reasoning mechanisms of CHR in a
single formalism. Moreover, it shows that we can encode CHR into linear
logic in a way that preserves its characteristic dichotomy of don't-know and
don't-care non-determinism.

In this article, we propose a linear-logic semantics for CHR and CHR that
incorporates all the features mentioned above. We found the semantics on the
intuitionistic segment of linear logic as it suffices for our purpose while
being easier to handle than the full segment. We propose two variants of the
semantics. The first variant is based on introducing proper axioms in the
sequent calculus of linear logic. The second variant is similar to the
semantics previously published in \citeN{DBLP:conf/cp/BetzF05} and
\citeN{Betz07}. The first formulation allows for considerably
more elegant proofs, in particular of its soundness and completeness. The
second formulation allows to perform a broader range of reasoning tasks. As we
formalize and prove the equivalence of both representations, so we can use
either representation according to the respective application.

This article is structured as follows:
2
In Sect.~\ref{sec:chr}, we recall the syntax and operational semantics of CHR.
3
In Sect.~\ref{sec:ill}, we introduce the intuitionistic segment of linear logic.
4
In Sect.~\ref{sec:ll_semantics}, we develop a linear-logic semantics
for constraint handling rules, and we show its soundness and completeness with
respect to the operational semantics.
5
In Sect. \ref{sec:chrv}, we extend our semantics to CHR and prove its
soundness and completeness. We show that the linear-logic semantics allows in
general for less precise reasoning over CHR than over CHR. We
then introduce a well-behavedness property for CHR programs that
amends this limitation.  In Sect. \ref{sec:application}, we show how our
semantics can be applied to reason about program observables as well as to
compare programs even across the boundaries of programming paradigms. In Sect.
\ref{sec:related}, we discuss related work before we conclude in Sect.
\ref{sec:conclusion}.

\section{Constraint Handling Rules}
\label{sec:chr}

In this section, we recall the syntax and the operational semantics  of
Constraint Handling Rules.

\subsection{The Syntax of CHR}
\label{sec:syn}

We distinguish two disjoint classes of atomic constraints: \emph{atomic built-in
constraints} and \emph{atomic user-defined constraints}. We denote the former as
 and the latter as , where  are -ary constraint symbols and
 is a sequence of  terms. Built-in constraints and user-defined
constraint are  possibly empty  conjunctions of their respective atomic
constraints. A conjunction of atomic constraints in general, irrespective of
their class, is called a \emph{goal}\footnote{Note that the term \emph{goal} is used in
CHR for historical reasons and does not imply that program execution is
understood as proof search.}. Empty goals and empty constraints are denoted as
.

The syntax of constraints is summarized in
Def.~\ref{def:constraint-syntax}.

\begin{definition}[Constraint Syntax]
\label{def:constraint-syntax}
Let  denote an -ary atomic built-in or user-defined constraint, respectively,
where  is an -ary sequence of terms:
\begin{tabular}{l @{\quad} r @{} l}
\\
Built-in constraint: &  &  \\
User-defined constraint: &  &  \\
Goal: &   &  \\
\\
\end{tabular}

 stands for the \emph{empty constraint} or the \emph{empty goal},
respectively. The set of built-in constraints furthermore contains at least
\emph{falsity} , and the binary constraint , standing for
\emph{syntactic equality}.
For any two goals , the goal equivalence relation 
denotes equivalence with respect to the \emph{associativity} and
\emph{commutativity} of  and the neutrality of the \emph{identity
element} .
\end{definition}

Both built-in and user-defined constraints are special cases of goals. The goal
equivalence relation  does not account for idempotence, thus
implicitly imposing a multiset semantics on goals. For example,
. We denote the set of variables occurring in a
goal  as .

A CHR program is a set of rules adhering to the following definition:

\begin{definition}[Rule Syntax] \label{def:chr_rule}
\begin{longenum}
\item A CHR rule is of
the form

The \emph{rule head}  consists of the \emph{kept head} 
and the \emph{removed head} . Both  are user-defined constraints.
At least one of them must be non-empty. The guard G is a built-in constraint.
The rule body is of the form , where  is a built-in
constraint and  is a user-defined constraint.  serves as an identifier
for the rule.

\item The identifier  is operationally irrelevant and can be omitted along
with the . An empty guard  can be omitted along with the . A
rule with an empty kept head  can be written as . Such a rule is called a \emph{simplification rule}. A
rule where the removed head  is empty can be written as . Such a rule is called a \emph{propagation
rule}. A rule where neither  nor  are empty is called a
\emph{simpagation rule}.

\item A \emph{variant} of a rule~ with variables~ is of the form  where  is an
arbitrary sequence of pairwise distinct variables.

\item A \emph{CHR program} is a set of CHR rules.
\end{longenum}
\end{definition}

In anticipation of Section~\ref{sec:op-sem}, we point out that propagation rules
may cause trivial non-termination of programs as they do not in general
eliminate the pre-condition of their firing. Hence, precautions have to be
taken. We refer the reader to \citeN{DBLP:conf/cp/Abdennadher97} and
\citeN{DBLP:conf/iclp/DuckSBH04} for the most common approach based on keeping a
history of applied rules and to \citeN{DBLP:journals/tplp/BetzRF10} for a
more recent approach based on finite representations of infinite program states and computations.

\subsection{The Equivalence-Based Semantics }
\label{sec:op-sem}

In this section, we recall the operational semantics of CHR. Several
formalizations of the operational semantics  exist in the literature. We
choose the so-called \emph{equivalence-based semantics}  as it contains
all the elements that we represent in our linear-logic semantics while allowing
for elegant proofs of theoretical properties.

Operationally, built-in and user-defined constraints are handled separately. For
the handling of built-in constraints, CHR requires a so-called
\emph{predefined constraint handler} whereas user-defined constraints are
handled by the actual user program. We assume that the predefined solver
implements a \emph{complete} and \emph{decidable} first-order \emph{constraint theory}
 over the built-in constraints.

\begin{definition}[Constraint Theory] A constraint theory  is a decidable
theory of intuitionistic logic over the built-in constraints. We assume that it
is given as a set of formulas  of the form  called
\emph{-axioms} where  are possibly empty built-in constraints and
 are possibly empty sets of variables.
\end{definition}

It should be noted that defining constraint theories explicitly over
\emph{intuitionistic} rather than full classical logic is non-standard. It is,
however, an unproblematic decision because in the operational semantics only
judgements over conjunctions of positive literals are considered. Furthermore,
this decision allows us to restrict ourselves to the intuitionistic fragment of
linear logic when translating constraint theories into linear logic.

CHR itself is a transition system over equivalence classes of program states,
which are defined as follows:

\begin{definition}[CHR State]
\label{def:binary-state}
\begin{enumerate}
\item  A CHR state is a tuple of the form  where  is a
goal called \emph{constraint store} and  is a set of variables called
\emph{global variables}.
\item For a CHR state , where  is a
user-defined constraint and  is a built-in constraint, we
call
\begin{enumerate}
\item \quad the
\emph{local variables} of S and
\item \quad the \emph{strictly local
variables} of S.
\end{enumerate}
\item A \emph{variant} of a state  with local variables
 is a state  of the form , where  is a sequence
of pairwise distinct variables that do not occur in .
\end{enumerate}
\end{definition}

The state transition system that formalizes the operational semantics
builds on the following definition of equivalence
between CHR states:

\begin{definition}[Equivalence of CHR States]
\label{def:s_equiv}

In the following, let  denote arbitrary user-defined
constraints,  built-in constraints, 
goals,  sets of variables  a variable and  a term.
State equivalence, written as , is the smallest
equivalence relation over CHR states that satisfies all of the following
conditions:

\begin{enumerate}
\item \label{cond:se_comm} \emph{(Goal Transformation)}

\item \label{cond:se_subst} \emph{(Equality as Substitution)}

\item \label{cond:se_appct} \emph{(Application of CT)} Let  be the strictly local variables of . If

then:

\item \label{cond:se_global} \emph{(Neutrality of Redundant Global Variables)}

\item \label{cond:se_fail} \emph{(Equivalence of Failed States)}
For all goals  and all sets of variables :

\end{enumerate}
Where there is no ambiguity, we usually write  rather than
.
\end{definition}

While we generally impose a multiset semantics over goals,
Definition~\ref{def:s_equiv}.\ref{cond:se_appct} implicitly restores the set
semantics for built-in constraints within states. When discussing \emph{pure
CHR} -- as opposed to its generalization CHR (cf. Sect.\ref{sec:chrv}) --
we will usually consider states in the following \emph{normal form}:

\begin{definition}[Normal Form of CHR States]
\label{def:ternary-state}
A CHR state  is considered in \emph{normal form} if it is of the form
 where  is a user-defined
constraint called the \emph{user-defined store} and  is a
built-in constraint called the \emph{built-in store}. Such a
state is usually written in ternary notation: .
\end{definition}

Any state with an inconsistent built-in store is called a \emph{failed state} as
formalized in the following definiton:

\begin{definition}[Failed State]
Any CHR state  for some  is called a
\emph{failed state}. We use  as the default
representative for the set of failed states.
\end{definition}

The following lemma states several properties following from
Def.~\ref{def:s_equiv} that have been presented and proven in
\citeN{Raiser2009a}:

\begin{lemma}[Properties of State Equivalence]
\label{lem:se_derived}
The following properties hold in general:
\begin{longenum}
\item \label{prop:se_rename} \emph{(Renaming of Local Variables)}

for  and  and  does not occur in  or .
\item \label{prop:se_partial} \emph{(Partial Substitution)} Let  be
a
user-defined constraint where \emph{some} occurrences of  are substituted with :

\item \label{prop:se_lequiv} \emph{(Logical Equivalence)} If

then ,  where  are the local variables of
, respectively.
\end{longenum}
\end{lemma}

Lemma~\ref{lem:se_derived}.\ref{prop:se_rename} allows us to assume without loss of generality that the local variables of any two specific states are renamed apart. Concerning Lemma~\ref{lem:se_derived}.\ref{prop:se_lequiv}, note that logical
equivalence of  and  is
a \emph{necessary} but not a \emph{sufficient} condition for state equivalence. The linear logic semantics will enable us to formulate a similar condition that is both necessary \emph{and} sufficient (cf. Sect.~\ref{sec:pt-sem}).

The task of deciding equivalence -- and more so: non-equivalence -- is not
always trivial using the axiomatic definition. We quote
Theorem~\ref{thm:sq_crit} which gives a necessary, sufficient, and decidable
criterion. It uses the following notion of \emph{matching}:

\begin{definition}[Matching of Constraints]
For user-defined constraints , the matching
relation  holds \emph{if and only if}  \emph{and} there exists a permutation 
such that

\end{definition}

The following theorem has been published and proven in
\cite{Raiser2009a}.

\begin{theorem}[Criterion for ]\label{thm:sq_crit}
\label{thm:criterion}
Consider CHR states  with local variables~ that have been renamed apart. Then 
\emph{if and only if}:

\end{theorem}

We define the notion of \emph{local variables} of CHR rules, which is necessary
for the definition of the operational semantics:

\begin{definition}[Local Variables in Rules]
For a CHR rule , we
call the set

the \emph{local variables} of .
\end{definition}


The transition system constituting the operational semantics of CHR is specified in the following
definition:

\begin{definition}[Transition System of ]
\label{def:chr-op-sem}

CHR is a state transition system over equivalence classes of CHR states defined
by the following transition rule, where  is a variant of a CHR rule whose local variables 
are renamed apart from any variable in :
\medskip


\medskip
If the applied rule is obvious from the context or irrelevant, we write
transition simply as . We denote its reflexive-transitive closure as
. In the following, we sometimes write  instead of
 to preserve clarity.
\end{definition}

The required disjointness of the local variables  from all variables
occurring in the pre-transition state outside  enforces that fresh variables
are introduced for the local variables of the rule. When reasoning about
programs, we usually refer to the following observables:

\begin{definition}[Computables States and Constraints]
\label{def:observables}
Let  be a CHR state,  be a program, and  be a constraint theory. We
distinguish three sets of observables:

\begin{tabular}{l @{\quad} r @{} l}
\\
Computable states:  &  &
 \\
Answers: &  &
 \\
Data-sufficient answers: &  &
 \\
\\
\end{tabular}

For all three sets, if the respective constraint theory  is clear from the
context or not important, it may be omitted from the  identifier of the
respective set.
\end{definition}

As the transition system does not allow transitions from an empty user-defined
store (nor from failed states), the data-sufficient answers
 are a subset of the answers  of any state
. The following property follows directly:

\begin{property}[Hierarchy of Observables]
For any state , program  and constraint theory , we have:

\end{property}

Confluence is an important property in transition systems. We define it in the
usual manner:

\begin{definition}[Confluence]
\label{def:confluence}
A CHR program  is \emph{confluent} if for all states  such that
 and , there exists a state  such that
 and .
\end{definition}

Confluence restricts the number of possible answers to a query:

\begin{property}\label{prop:confluence-answers}
Let  be a confluent CHR program. Then for every CHR state , we have
 and , where
 denotes cardinality.
\begin{proof}[sketch]
We assume that for some states  and some confluent program , we
have  and  and . Applying
Def.~\ref{def:confluence} leads to a contradiction.
\end{proof}
\end{property}

A necessary, sufficent and decidable criterion for confluence has been given in
\citeN{Abdennadher96onconfluence}. Example~\ref{example:leq} presents a
standard CHR example program to illustrate our definitions.

\begin{example}
\label{example:leq}

The following program implements a solver for the (user-defined) partial-order
constraint . Rule  implements idempotence of identical constraints,
 implements reflexivity,  symmmetry and  transitivity of the
partial-order relation:

\medskip


\medskip
The following is a sample derivation, starting from an initial state
. According
to the usual practice, all variables occurring in the initial state are global.
Equivalence transformations are stated explicitly:

\setcounter{equation}{0}


Usually, we do not make equivalence transformations explicit and list only
states where local variables are eliminated as far as possible such as the
labeled states~(\ref{eq:leq_1})-(\ref{eq:leq_4}). The derivation is then reduced
to:
\setcounter{equation}{0}

\end{example}

With respect to our observables, we have:

The set  is infinite
as the operational semantics  allows potentially unlimited applications of .

\section{Intuitionistic Linear Logic}
  \label{sec:ill}

Linear logic was introduced by
\citeN{DBLP:journals/tcs/Girard87}. Unlike classical logic, linear logic does
not allow free copying or discarding of assumptions. It furthermore features a fine
distinction between internal and external choice and a faithful embedding of
classical logic. In this section, we recall the intuitionistic fragment of linear
logic, which is easier to handle than the full fragment but sufficient for
our declarative semantics. It allows for a straightforward, faithful embedding of
intuitionistic logic.

\subsection{Definition}

We will give the formal definition in terms of a \emph{sequent calculus}. The
calculus is based on binary sequents of the form  where  is a multiset of formulas (written without braces) called
\emph{antecedent} and  is a formula called \emph{consequent}. A sequent
 represents the fact that assuming the formulas in
, we can conclude . A \emph{proof tree} -- or simply:
\emph{proof} -- is a finite labeled tree whose nodes are labeled with
sequents such that the relationship between every sequent node and its direct
children corresponds to one of the inference rules of the calculus. We
distinguish a special set of sequents called \emph{axioms}. A proof tree is
called \emph{complete} if all its leaves are axioms. We call a sequent
 \emph{valid} if there exists a complete proof tree 
with  at the root.

The following two structural rules are common to many logical systems. They establish
reflexivity and a form of transitivity of the judgement relation.



The tokens of (intuitionistic) linear logic are commonly considered as
representing \emph{resources} rather than \emph{truths}. This terminology
reflects the fact that assumptions may not be copied nor discarded freely in
linear logic, but must be used exactly once. From a different point of view, we
might say that linear logic \emph{consumes} assumptions in judgements and is
aware of their \emph{multiplicities}.

\emph{Multiplicative conjunction} is distinguished from classical or
intuitionistic conjunction as it lacks idempotence. Hence, 
represents \emph{exactly} one instance of  and one instance of .
The formula  is not equivalent to . Multiplicative
conjunction is introduced by the following inference rules:



The constant  represents the empty resource and is consequently the
neutral element with respect to multiplicative conjunction.



\emph{Linear implication } allows the application of \emph{modus ponens}
where the preconditions of a linear implication are consumed on application. For
example, the sequent  is valid whereas
 is not. The following inference
rules introduce :



The \textit{! (``bang'') modality} marks stable facts or unlimited resources,
thus recovering propositions in the classical (or intuitionistic) sense. Like an
classical proposition, a \emph{banged} resource may be freely copied or
discarded. Hence,  is a
valid sequent. Four inference rules introduce the bang:




\begin{example}
We can model the fact that one cup of coffee () is one euro () as . A ``bottomless cup'' is an offer including an unlimited number of refills.
We assume that any natural number of refills is possible. We model this as
. From this, we may judge that it is possible to get two cups of
coffee for one euro: .
Fig.~\ref{fig:coffee-example} gives an examplary proof tree, proving this
judgement.

\begin{figure}
\label{fig:coffee-example}
\begin{center}

\end{center}
\caption{A sample proof tree}
\end{figure}
\end{example}

In classical (and intuitionistic) logic, internal choice is an aspect of
conjunction, as exemplified by the judgement .
This is inherited by the \textit{additive conjunction } of linear logic. The
formula  expresses a choice between  and , i.e. the
sequents  and  are valid,
but  is not.



The  (``top'') is the resource that all other resources can be mapped to,
i.e. for every , the implication  is a tautology. It is
hence the neutral element with respect to additive conjunction.



External choice is an aspect of classical (and intuitionistic) disjunction. In
linear logic, it is represented by the \textit{additive disjunction }.
Analogous to classical logic,  is not valid.
However,  is
valid.



Analogous to falsity in the classical sense, \emph{absurdity}  is
a constant that yields every other resource. It is the neutral element with
respect to .


\begin{example} We assume that, besides coffee, the cafeteria offers also pie
() at the price of one euro per piece: . We infer that for one
euro, we have the choice between an arbitrary amount of coffee and a piece of
pie: . Let us furthermore assume that rather than
with euros, we can also pay with dollars () at a  ratio: . We may infer either one of \emph{one dollar} or \emph{one euro}
buys us a choice between an arbitrary amount of coffee and one pie.:

\end{example}

We can extend intuitionistic linear logic into a first-order system with the
quantifiers  and . Their introduction rules are the same as in
classical logic. In the following rules,  stands for an arbitrary term whereas  stands for a variable
that is not free in ,  or :


\vspace{1mm}

\vspace{1mm}


\subsection{Properties of Intuitionistic Linear Logic}

The resulting first-order system allows for a faithful embedding of
intuitionistic first order logic. This is widely considered one of the most important
features of linear logic. The following translation from intuitionistic logic
into intuitionistic linear logic is a variant of a translation proposed by
\citeN{DBLP:journals/mscs/Negri95}:

\begin{definition}
\label{def:negri}
 is a translation from formulas of intuitionistic logic to
formulas of intuitionistic linear logic, recursively defined by the following
rules:
\begin{center}
\begin{tabular}{r  @{\hspace{1mm}::=\hspace{1mm}} l}
             &  \\
                &  \\
                &  \\
         &  \\
             &  \\
     &  \\
        &  \\
        &  \\
\end{tabular}
\end{center}
\end{definition}

 stands for an atomic proposition. The definition is extended to
sets and multisets of formulas in the obvious manner. It has been proven in
\citeN{DBLP:journals/mscs/Negri95} that an intuitionistic sequent
 is valid \emph{if and only if}
 is valid in linear logic.

We distinguish two sorts of axioms in the sequent calculus. The 
axiom and the constant axioms , ,  and 
constitute the \emph{logical axioms} of intuitionistic linear logic. All axioms
we add to the system on top of these are called \emph{non-logical axioms} or
\emph{proper axioms}. We usually use the letter  to denote the set of
proper axioms.

We express the fact that a judgement  is provable using a
non-empty set  of proper axioms by indexing the judgement relation with
the set of proper axioms: .

\begin{definition}[Linear-Logic Equivalence]
	\label{def:ll-equiv}
\begin{longenum}
 \item We call two linear-logic formulas  \emph{logically
 equivalent} if both  and  are provable. We write
this as .
 \item For any set of proper axioms , we call two linear-logic formulas
  \emph{logically equivalent modulo } if both
  and  are provable. We
 write this as .
\end{longenum}
\end{definition}

As a well-behaved logical system, linear logic features a cut-elimination
theorem \cite{DBLP:journals/tcs/Girard87}:

\begin{theorem}[Cut Elimination Theorem]
\label{thm:cut-elim}
\begin{longenum}
  \item \label{prop:cut-free} If a sequent  has a proof 
  that does not contain any proper axioms, then it has a proof  that
  contains neither proper axioms nor the  rule.
  \item \label{prop:cut-red} If a sequent  has a proof
   containing proper axioms, then it has a proof  where the 
  rule is only used at the leaves such that one of its premises is an axiom.
\end{longenum}
\end{theorem}

A proof without any applications of  is called \emph{cut-free}. A proof where
 is only applied at the leaves is called \emph{cut-reduced}.

A important consequence of cut elminiation is the \emph{subformula property}. We
quote a weak formulation of the property, which will suffice for our purpose:
Every formula  in a cut-free proof of a sequent  is a
subformula of either  or , modulo variable renaming. In a
cut-reduced proof of a sequent , every formula 
 is a subformula of  or , modulo variable renaming, or there
exists a proper axiom  such that  is a
subformula of  or , modulo variable renaming.

\section{A Linear-Logic Semantics for CHR}
\label{sec:ll_semantics}

In this section, we motivate and develop the linear-logic semantics for
Constraint Handling Rules. We firstly recall the classical declarative semantics
in Sect.~\ref{sec:classical-analysis}. Then we motivate and present a
linear-logic semantics based on proper axioms in Sect.~\ref{sec:pt-sem}. We will
henceforth call this the \emph{axiomatic} linear-logic semantics for CHR. Its
soundness with respect to the operational semantics is shown in
Sect.~\ref{sec:pt-soundness}. We continue in Sect.~\ref{sec:entailment} by
introducing the notion of \emph{state entailment}, which we use to formulate and
prove the completeness of our semantics in Sect.~\ref{sec:pt-completeness}.
Finally, in Sect.~\ref{sec:enc-sem}, we show an alternative linear-logic
semantics that encodes programs and contraints theories into linear logic.

\subsection{Analysis of the Classical Declarative Semantics}
  \label{sec:classical-analysis}

CHR is founded on a classical declarative semantics, which is reflected in its
very syntax. In this section, we recall the classical declarative semantics and
discuss its assets and limitations.

In the following,  stands for existential quantification of
all variables except those in , where  is a set of variables.
The classical declarative semantics is given in the following table, where
 stand for translation to classical logic:

\begin{center}
\begin{tabular}{l @{\hspace{1em}} l @{\hspace{1mm} ::= \hspace{1mm}} l}
States:&
 &
 \\
Rules: &
 &

\\
Programs: &
 &
\\
\end{tabular}
\end{center}

 denotes the local variables of the respective rule. The following lemma
-- cited from \citeN{Fruhwirth03} -- establishes the relationship between the
logical readings of programs, constraint theories and states:

\begin{lemma}[(Logical Equivalence of States)]
Let  be a CHR program and  be a state. Then for all computable states
 and  of , the following holds: .
\end{lemma}

The declarative semantics of CHR must be distinguished from LP languages and
related paradigms as CHR is not based on the notion of \emph{execution as proof
search}. Declaratively, execution of a CHR program means stepwise transformation
of the information contained in the state under logical equivalence as defined
by the program's logical reading  and the constraint theory .
Founding CHR on such a declarative semantics is an obvious choice for several
reasons:

Firstly, the notion of \emph{execution as proof search} naturally implies a
notion of \emph{search}. This stands in contrast to the committed-choice execution of CHR.
Furthermore, the forward-reasoning approach faithfully captures the one-sided
variable matching between rule heads and constraints in CHR, as opposed to
unification. For example, a CHR state  (where 
is a variable) does not match with the rule head  (where
 is a constant) just as we cannot apply modus ponens on a fact  and an implication . In contrast, an LP goal
 would be unified with a rule head , accounting
for the fact that application of the rule might lead to a proof of an instance
of .

There are, however, several limitations to the classical declarative semantics
of CHR, which shall be discussed in the following:

\paragraph*{Directionality} One limitation lies in the fact that the classical
declarative semantics does not capture the inherent directionality of CHR rules.
Rather, all states within a computation are considered logically equivalent.
Consider e.g. the minimal CHR program

In this program, we can compute a state  from a state
 but not vice versa. This is not captured in its
logical reading  which e.g. implies .
The classical declarative semantics cannot be used e.g. to show that the state
 is not a computable state
.

\paragraph*{Dynamic Change} Any program state that does not only
contain declarative information about a supposedly static object world but also
meta-information about the program state eludes the semantics. Consider the
following program which computes the minimum of a set:

On a fixed-point execution, the program correctly computes the minimum of all
arguments of  constraints found in the store at the beginning of the
computation. Its logical reading, however, is unhelpful at best:


\paragraph*{Deliberate Non-Determinism} Any program that makes deliberate use of
the inherent non-determinism of CHR has a misleading declarative semantics as
well. Consider the following program, which simulates a coin throw in an appropriate
probabilistic semantics of CHR (cf. \citeN{DBLP:journals/entcs/FruhwirthPW02}).
(Note that  is a variable,  and  are constants.)

The logical reading of this program implies . From this follows  and -- since
 and  are distinct constants -- falsity . The program's logical
reading is thus inconsistent, trivially implying anything.

\paragraph*{Multiplicities} Finally, while CHR faithfully keeps track of the
multiplicities of constraints, this aspect eludes the classical semantics.
Consider the idempotence rule from Example~\ref{example:leq}, which removes
multiple occurrences of the same constraint:

The logical reading of this rule is a tautology, falsely suggesting that
the rule is redundant:

In conclusion, the classical declarative semantics is a powerful tool to prove
the soundness and a certain notion of completeness of any program whose states
contain only model information about a static object world and no explicit
meta-information. It faithfully captures the logical theory behind those
programs. However, it is not adequate to capture the logic behind programs that
deal with any form of meta-information, make deliberate use of non-determinism or
rely on the multiplicities of constraints. As it does not capture the inherent
directionality of CHR rules, it is not suitable to prove safety conditions, i.e.
to show that a certain intermediate or final state cannot be derived from a
certain initial state.

\subsection{The Axiomatic Linear-Logic Semantics for CHR}
  \label{sec:pt-sem}

Our linear-logic semantics is based on two observations: Firstly, the difference in behaviour
between built-in and user-defined constraints in CHR resembles the difference
between linear and banged atoms in linear logic. Secondly, the application of
simplification rules on user-defined constraints resembles the application
of modus ponens in linear logic.

Building on the first observation, we define an adequate representation of CHR
constraints in linear logic. Translation to linear logic will be denoted as
. For atomic constraints, the choice is obvious:

Classical conjunction is mapped to multiplicative conjunction for both built-in
and user-defined constraints.

This mapping is motivated by the fact that
multiplicative conjunction is aware of multiplicities and has no notion of
weakening, thus capturing the multiset semantics of user-defined constraints. For
any built-in constraint , the mapping equals the translation quoted in
Def.~\ref{def:negri}: . Accordingly, we map the empty goal  to
 and falsity  to . The translation of CHR states is
analogous to the classical case:

The translation of
constraints, goals and states is summed up in Fig.~\ref{fig:states}.

\begin{figure}
	\label{fig:states}
	\begin{center}
	\fbox{
	\begin{tabular}{l @{\quad} r @{} l}
	\textrm{Atomic built-in constraints:} &  &  \\
	\textrm{Atomic user-defined constraints:} &  &  \\
	\textrm{Falsity:} &  &  \\
	\textrm{Empty constraint/goal:} &  &  \\
	\textrm{Constraints/goals:} &
		 & \\
	\textrm{States:} &  &  \\
	\end{tabular}
	}
	\caption{Translation of constraints, goals and states}
	\end{center}
\end{figure}

\paragraph*{Proper axioms} The constraint theory , the interaction between
equality constraints (which are by definition built-in) and user-defined
constraints, and programs are translated to proper axioms. Firstly, we define a
set of proper axioms encoding the constraint theory as well as modelling the
interaction between equality  and user-defined constraints.

\begin{definition}[()] For built-in constraints 
and sets of variables  such that , the following is a proper axiom:

We denote the set of all such axioms as .
\end{definition}

\begin{definition}[()]
If  is an n-ary user-defined constraint and  are terms such that
 is the th argument of  then

is a proper axiom. We denote the set of all such axioms as .
\end{definition}

\begin{definition}[()] If  is a variant of a rule with local variables , the sequent

is a proper axiom. For a program , we denote the set of all axioms derived
from its rules as .
\end{definition}

The existential quantification of the local variables  corresponds to the
fact that these variables are by definition disjoint from
, assuring that fresh variables are introduced for the
local variables of the rule. Fig.~\ref{fig:chr-axiomatic-semantics} sums up the
three sets of proper axioms, represented as inference rules.

\begin{figure}
\label{fig:chr-axiomatic-semantics}
\begin{center}
\fbox{
	\begin{tabular}{c}
	
	\\
	\\
	
	\end{tabular}
}
\end{center}
\caption{The axiomatic linear-logic semantics, represented as inference rules}
\end{figure}

In anticipation of the soundness theorem presented in
Sect.~\ref{sec:pt-soundness}, we give an example of a CHR derivation and show
that it corresponds to a valid linear logic judgement:

\begin{example}
	\label{example:pt-sem-soundness}
Let  be the partial-order constraint solver from
Example~\ref{example:leq} and let  be a minimal constraint theory. We
observe that under , we have:

This corresponds to the judgement
 or
, respectively, where
. The following is a proof of this judgement:

The sequent  is a tautology and as
such could be derived without proper axioms, but it is also trivially included in
.
\end{example}

While the soundness result for our semantics is straightforward, defining
completeness is not quite as simple. Consider the following example:

\begin{example}
	\label{example:pt-sem-completeness-problem}
In the proof tree given in Example~\ref{example:pt-sem-soundness} we use the
following proper axiom from :

This implies:

We observe, however, that
 is untrue.
\end{example}

In the following section, we prove the soundness of our semantics. In
Sect.~\ref{sec:entailment}, we develop the notion of \emph{state entailment}. We
will apply this notion to specify and prove a completeness result in
Sect.~\ref{sec:pt-completeness}.

\subsection{Soundness of the Linear Logic Semantics}
\label{sec:pt-soundness}

In this section, we prove the soundness of the axiomatic linear-logic
semantics for CHR with respect to the operational semantics.

\begin{lemma}[()]
  \label{lemma:sq-ll}
  Let  be a constraint theory and . For arbitrary CHR
  states , we have: 
\begin{proof}[sketch] We prove that state equivalence 
implies linear judgement  by showing that every of the conditions
given for  in Def.~\ref{def:s_equiv}
implies : Def.~\ref{def:s_equiv}.\ref{cond:se_comm}
implies linear judgement since multiplicative conjunction is associatice, commutative and invariant w.r.t.
  , thus corresponding to goal equivalence. For
  Def.~\ref{def:s_equiv}.\ref{cond:se_subst}, linear judgement is guaranteed, as
   allow us to prove . For
  Def.~\ref{def:s_equiv}.\ref{cond:se_appct}, it is similarly guaranteed by .
  Def.~\ref{def:s_equiv}.\ref{cond:se_global} implies linear judgement since
  the addition or removal of a global variable not occurring
   in a state does not change the logical reading of the state.
  W.r.t. Def.~\ref{def:s_equiv}.\ref{cond:se_fail}, linear judgement holds since
   is valid for any .
All the above arguments can be shown to apply in the reverse direction as well,
thus proving compliance with the implicit symmetry of . The
implicit reflexivity and transitivity of state equivalence comply with linear
judgement due to the  and  rules.
\end{proof}
\end{lemma}

Theorem~\ref{thm:soundness} states the soundness of our semantics.

\begin{theorem}[Soundness]
  \label{thm:soundness}
  Let  be a program,  be a constraint theory, and
  . Then for arbitrary states , we have:
  
\begin{proof}
Let  be states such that . According to
Def.~\ref{def:chr-op-sem}, there exists a variant of a rule with fresh variables
 and states
,   such that  and .
Consequently,  contains:

From which we prove:

The local variables  of  are by Def.~\ref{def:chr-op-sem} disjoint
from . Hence, we have:

This corresponds to . Lemma~\ref{lemma:sq-ll} proves that
. As the judgement relation  is transitive and reflexive, we can generalize the relationship
to the reflexive-transitive closure .
\end{proof}
\end{theorem}

\subsection{State Entailment}
	\label{sec:entailment}

In this section, we define the notion of \emph{entailment}, which we will use to
formulate our theorem of completeness. We present it alongside various properties
that follow from it and that will be used in upcoming sections.

\begin{definition}
\label{def:s_entail}

\emph{State entailment}, written as , is the smallest
partial-order relation over equivalence classes of CHR states that satisfies the
following conditions:

\begin{enumerate}
	\item \label{cond:sn_wea} \emph{(Weakening of the Built-In Store)} For states  with  local variables  such that
	, we have:
	
	\item \label{cond:sn_omit} \emph{(Omission of Global Variables)}
	

\end{enumerate}
\end{definition}

To simplify notation, we often write  instead of .
Theorem~\ref{thm:se_crit} gives a decidable criterion for state entailment. The
criterion requires that the global variables of the entailed state are contained
in the global variables of the entailing state. This is never a problem, as we
may choose representatives of the respective equivalence classes that satisfy the
condition.

\begin{theorem}[Criterion for ]\label{thm:se_crit} Let  be CHR states with local
variables~ that have been renamed apart and where .
Then we have:

\begin{proof}
\noindent'': We show that the explicit axioms of entailment, as well as the implicit conditions reflexivity,
anti-symmetry and transitivity comply with the criterion:
\begin{description}
	\item[Def.~\ref{def:s_entail}.\ref{cond:sn_wea}] We assume w.l.o.g. that the strictly local variables of  are renamed apart. We observe that
	 is
	a tautology for any . Hence, from  follows
	, which proves:
	
	\item[Def.~\ref{def:s_entail}.\ref{cond:sn_omit}] Let  be the
	local variables of . For any  we have:
	
	\item[Reflexivity] Let  be CHR
states
	such that , i.e.
	. Assuming that the local
	variables  have been named apart, Thm.~\ref{thm:sq_crit}
implies
	.
	\item[Anti-Symmetry] Let  be CHR
states
	with local variables  such that  and  . By
Thm.~\ref{thm:sq_crit},
	we have that  and hence
	.
	\item[Transitivity] Let
	 be CHR
states
	where the local variables have been renamed apart and
such
	that  and
	.
	Therefore, . As the sets of local
variables
	are disjoint, we get  and finally
	
\end{description}

\noindent'': Let  be
CHR states with local variables~ that have been renamed apart and such
that  and
.
We apply Def.~\ref{def:s_entail}.\ref{cond:sn_wea} to infer:
.
By Def.~\ref{def:s_equiv}.\ref{cond:se_subst} and
Def.~\ref{def:s_equiv}.\ref{cond:se_appct}, we get
.
Since , several applications of
Def.~\ref{def:s_entail}.\ref{cond:sn_omit} give us
.
\end{proof}
\end{theorem}

Corollary~\ref{crl:ent-equiv} is a direct consequence of Theorem~\ref{thm:sq_crit}
and Theorem~\ref{thm:se_crit}. It establishes the relationship between state
equivalence and state entailment.

\begin{corollary}[()]
\label{crl:ent-equiv}
  For arbitrary CHR states , state equivalence  holds \emph{if
  and only if} both  and  hold.
\end{corollary}

Lemma~\ref{lemma:exchange} establishes an important relationship between state transition and state entailment.

\begin{lemma}\label{lemma:exchange}
  Let  be CHR states. If  and  then there exists a state  such that
   and .

\begin{proof}
 Let  and
let  be the
    local variables of .
  By definition,  implies that there is a variant of a CHR rule
 such that
     and
    .

  Now let .
  From  follows by Thm.~\ref{thm:se_crit}:
    .
  Assuming w.l.o.g. that , we can apply
Def.~\ref{def:s_equiv}.\ref{cond:se_appct} to get
    
  and then
    .
  According to Def.~\ref{def:chr-op-sem}, we have . We apply
Def.~\ref{def:s_entail} to show that .
\end{proof}
\end{lemma}

In anticipation of Section~\ref{sec:pt-completeness}, the following example shows
how the notion of entailment fills the gap between the computability
relation between states and the judgement relation between their
respective linear-logic readings.

\begin{example}
	\label{example:pt-sem-entailment}
In Example~\ref{example:pt-sem-completeness-problem}, we showed that the
following judgement, which does not correspond to any transition in CHR, is
 provable in our sequent calculus system:

We observe that the two states are connected by the entailment
relation:

In the following section, we will show that state entailment precisely covers
the discrepance between transitions in a CHR
program and judgements in its corresponding sequent
calculus system as exemplified in
Example~\ref{example:pt-sem-completeness-problem}
\end{example}

\subsection{Completeness of the Axiomatic Semantics}
	\label{sec:pt-completeness}

The notion of merging is an important tool for the proofs in this section. We
define it as follows:

\begin{definition}[()]
	\label{def:merging}
  Let  be CHR
  states that share the same set of global variables and whose local variables
  are renamed apart. Their \emph{merging} is defined as:
  
\end{definition}

The following property assures that we can without loss of generality assume
the existence of  for any two states :

\begin{property}\label{prop:generalityofmerging}
For any CHR states , there exist states  where  such that  exists.
\begin{proof}[sketch]
Lemma~\ref{lem:se_derived}.\ref{prop:se_rename} allows to rename the local
variables apart, and Def.~\ref{def:s_equiv}.\ref{cond:se_global} allows the
union of their respective sets of global variables.
\end{proof}
\end{property}

Lemma~\ref{lemma:merging_derived} states two properties of merging that will be
used in upcoming proofs:

\begin{lemma}[Properties of ]
	\label{lemma:merging_derived}

Let  be CHR states such that both  and 
exist. The following properties hold:

\begin{enumerate}
  \item \label{prop:mrg:entail}
  
  \item \label{prop:mrg:maps}
  
\end{enumerate}

\begin{proof}
Lemma~\ref{lemma:merging_derived}.\ref{prop:mrg:entail}: We assume w.l.o.g. that
the states  share the same set of global variables. Let
 with local vars
.
From  follows by Thm.~\ref{thm:sq_crit}:
.
As  is a tautology, we get 
which proves .

Lemma~\ref{lemma:merging_derived}.\ref{prop:mrg:maps}: We assume w.l.o.g. that
the states  share the same set of global variables. According to
Def.~\ref{def:chr-op-sem}, there exists a variant of a CHR rule , such that  and . By Prop.~\ref{prop:generalityofmerging}, there
exists a state  such that  whose local
variables are renamed apart from those of  and . By
Def.~\ref{def:chr-op-sem}, we get .
\end{proof}
\end{lemma}

Lemma~\ref{lemma:proof-structure} sets the stage for the completeness theorem:

\begin{lemma}
\label{lemma:proof-structure}
Let  be some cut-reduced proof of a sequent , where
 are arbitrary CHR states and  for a program
 and a constraint theory . Any formula  in  is either of the form
 where  is a CHR state or of the form
 where  is some built-in constraint.
\begin{proof}
We observe that both the root of  and all proper axioms in  are of
the form  where  are CHR states. The subformula property hence
guarantees that every formula  in  is a subformula of the logical
reading  of some CHR state . The general form of such a logical reading
is  where  are the local
variables of ,  are its user-defined
constraints and  are its built-in constraints.
We observe that any subformula  of  is either of the form
 for some CHR state  or of the form
, where  is a built-in constraint.
\end{proof}
\end{lemma}

The completeness of our semantics is formulated in
Theorem~\ref{thm:completeness}:

\begin{theorem}[Completeness]
\label{thm:completeness}
   Let  be CHR states,  be a CHR program,  be a constraint theory
   and let  . If , then there
   exists a state  such that  and  in .
\begin{proof}
To preserve of clarity, we will omit the set  of proper axioms from the
judgement symbol . Throughout the proof,  denotes
the fact that for CHR states , there exist states  such that:
	
Consequently,  equals .

Secondly, we define an operator on formulas analogoous to merging on states: For
any two (possibly empty) sequences of variables  and quantifier-free formulas  let
.
We observe that for arbitrary CHR states  where  exists, we
have .
In the following, we assume w.l.o.g. that all existentially quantified variables
in the antecedent of a sequent occuring in  are renamed apart. Hence, for
every two formulas of the form  occurring in
the antecedent of one sequent in , both  and 
exist.

We introduce a completion function , defined by the following table,
where  is a CHR state,  is a built-in constraint and
 is a sequent:

	\medskip
	\begin{tabular}{l @{\hspace{1mm}  \hspace{1mm}} l}
	   &  \\
	   &  \\
	   &  \\
	   & 
	  	\quad for non-empty  \\
	   &  \\
	\end{tabular}

\medskip
For a sequent , we call  the
-completion of . From Lemma~\ref{lemma:proof-structure}
follows that for every sequent  in , its
-completion  is of the form  for
some CHR states . For example,
	

	We show by induction over the depth of  that for every such
	, we have , where  is the number of
	-axioms in the proof of .

	\textbf{Base case:}
	In case the proof of  consists of a single leaf, it is either an
	instance of a , , or , or a proper axiom
	.

	\begin{itemize}
	    \item , , :
	    	
	    In the case of , we have  for some CHR state . In the case of , we have
	     for . As the
	    entailment relation is reflexive, we have . In the case of
	    , we have  where .
	    By  Def.~\ref{def:s_equiv}.\ref{cond:se_fail} and
	    Def.~\ref{def:s_entail}.\ref{cond:sn_wea}, we have that  and
	    therefore .

		\item For a proper axiom  we have
		 where  are CHR states such
		that  and therefore .

		\item For a proper axiom  we have
		 where  are CHR states such that
		 and therefore .
	\end{itemize}

	\textbf{Induction step:} We distinguish nine cases according to
	which is the last inference rule applied in the proof. Cut reduction
	implies that it must be one of , , ,
	, , , , ,
	and .
	\begin{itemize}
	\item : For  and ,
	the banged formula must be an atomic built-in constraint :
	
	Since  and , each
	of these rule is invariant to the -completion of the sequent, thus
	trivially satisfying the hypothesis.
	\item :
	
	We assume that  and 
	are CHR states such that , ,
	and . Then by
	Def.~\ref{def:s_equiv}.\ref{cond:se_appct}, we have
	 where
	. As
	, this proves the hypothesis.
	\item : By Lemma~\ref{lemma:proof-structure}, we have that the
	introduced formula is of the form .
	
	We assume that  and  are
	CHR states such that ,  and
	. Furthermore,
	let . Since
	 and ,
	Lemma~\ref{lemma:exchange} proves the hypothesis.
	  \item : By the subformula property, we have that the
contracted
	  formula is of the form .
	  
	  Since 
	  we prove the hypothesis analogously to .

	  \item : The subformula property implies that the joined
	  formulas must be CHR states  and  without local variables:
	  
	  Let  be CHR states such that
	  ,
	  . The induction hypothesis gives us
	   and  for some . By
	  Lemma~\ref{lemma:merging_derived}.\ref{prop:mrg:entail} and
	  Lemma~\ref{lemma:merging_derived}.\ref{prop:mrg:maps} we have
	   and
	  . By
Lemma~\ref{lemma:exchange},
	  we get .

	  \item : Since  is a cut-reduced proof and all axioms are of the
	  form , the eliminated formula must be the logical reading of
	  a CHR state :
	  
	  Let  be CHR states such that
,
	  , and . The induction
	  hypothesis gives us  and . Applying
Lemma~\ref{lemma:merging_derived}, we get
	  . By
Lemma~\ref{lemma:exchange},
	  we get  which proves
	  the hypothesis.

	  \item : In the preconditional sequent, the quantified
	  variable  is by definition replaced by a
	  fresh constant  that does not occur in , , or
	  :
	  
	  Let  and  be CHR
	  states such that
	  , , and
	  . The
	  definition of state equivalence gives us . Furthermore, we have .
By the induction hypothesis, we have states
	  
	  such that  where
	   for .
Neither the binding  nor the set of global variables affect rule
	applicability. Hence, we can construct an analogous derivation
	 where
	 for . Since  and 
	must not occur in , we also have have .
Therefore, we have . As
	  , this proves the
hypothesis.

	  \item : By definition, the quantified variable 
	  substitutes an
	  arbitrary term .
		
	  Let  be CHR states such that ,
	  , and . By the
	  induction
	  hypothesis we have  for some . Let
	   and .
	  We have
	,
	and therefore, .
	\end{itemize}
	Finally, we have  for some , i.e. there exist states
	 such that:
	
	It follows that for , we have  and .
\end{proof}
\end{theorem}

Lemma~\ref{lemma:judge-entail} states that when excluding the proper axioms in
, logical judgement implies state entailment:

\begin{lemma}[()]
\label{lemma:judge-entail}
   For arbitrary CHR states , entailment  holds \emph{if and only
   if} the judgement  is provable for
   . \begin{proof}[sketch] \noindent : We
   apply Thm.~\ref{thm:completeness} to the empty program .

\noindent : We proof that all conditions in
Def.~\ref{def:s_entail} comply with the judgement relation : For
Def.~\ref{def:s_entail}.\ref{cond:sn_wea}, 
implies that  contains an axiom . Hence, we can prove
. For
Def.~\ref{def:s_entail}.\ref{cond:sn_omit}, it is valid since  holds for any . Concerning the implicit conditions of a partial order
relation, reflexivity and anti-symmetry hold for the judgement relation 
as well and anti-symmetry is a natural consequence of Def.~\ref{def:ll-equiv}.
\end{proof}
\end{lemma}

Theorem~\ref{thm:equiv-ll} defines the relationship between state equivalence
and the linear-logic semantics. It is a direct consequence of
Corollary~\ref{crl:ent-equiv} and
Lemma~\ref{lemma:judge-entail} and therefore goes without proof:

\begin{theorem}[()]
\label{thm:equiv-ll}
Let  be a constraint theory and .
For arbitrary CHR states , we have:

\end{theorem}

The following example illustrates the completeness theorem:

\begin{example}
We consider the partial-order program  given in Example~\ref{example:leq} and a minimal
constraint
theory . For , we have

which equals:

This corresponds to:

\end{example}

\subsection{Encoding Programs and Constraint Theories}
\label{sec:enc-sem}

In the axiomatic linear-logic semantics presented in Sect.~\ref{sec:pt-sem} to
Sect.~\ref{sec:pt-completeness}, only states are represented in logical
judgements. Both programs and constraint theories disappear into the proper
axioms of a sequent calculus system and hence are not objects of logical
reasoning.

In this section, we show how to encode programs and constraint theories into
logical judgements, enabling us to reason directly about them as well. In
Sect.~\ref{sec:app:comparison}, we will use this encoding to decide operational
equivalence of programs. As a further benefit, a complete encoding of programs
and constraint theories assures the existence of cut-free proofs for the
respective judgements and ensure compatibility with established methods for
automated proof search methods relying on this property.

As usual, 
stands for translation into linear logic.

\paragraph*{Encoding of Constraint Theories}
The constraint theory  itself is encoded according to the translation quoted
in Def.~\ref{def:negri}. Furthermore, for every n-ary
user-defined constraint symbol  and every , we add the
following formula to the translation of the theory, where  and
 are variables:

We obtain the following encoding of constraint theories:
\begin{definition}[()]
\label{def:ct-l}
Let  be a constraint theory. Its linear-logic reading  is given
as:

\end{definition}
\paragraph*{Encoding of } The translation of CHR rules follows the same
lines as the encoding of the  axioms:
\begin{definition}[()]
\label{def:rp-l}
\begin{enumerate}
\item \label{def:rp-l:r-l} Let  be a CHR rule with local variables . Then its linear-logic reading  is defined as:

\item \label{def:rp-l:p-l} Let  be a CHR program. Then
its linear-logic
reading  is defined as:

\end{enumerate}
\end{definition}

For the encoding semantics, the following soundness and completeness theorem
holds:

\begin{theorem}[Soundness and Completeness]
  \label{theorem:embed_soundness_completeness}
  Let  be CHR states. There exists a state  such that
  
  in a program  and a constraint theory  \emph{if and only if}
  
\begin{proof}
  We prove Thm. \ref{theorem:embed_soundness_completeness} by showing that any
  proof tree in the axiomatic semantics can be transformed into a proof tree in
  the encoding semantics and vice versa. To ensure of clarity, we will omit
  the set of proper axioms from the judgement symbol.

  \paragraph*{Axiomatic to encoding:} We assume a proof  of a sequent
   in the axiomatic semantics. We replace
  every axiom  in  by a sub-tree proving
  . The same is done for every
  equality axiom in . Similarly, every axiom  in  is replaced with a
  sub-tree proving . We propagate the thus
  introduced instances of  and  throughout the proof tree, thus
  producing a proof  of
  
  We insert  into:
  

  \paragraph*{Encoding to axiomatic:} Let  stand for element-wise
  multiplicative conjunction of a set and let  be a proof of a sequent
   in the encoding semantics.

  For every , we
  have  where
  . Hence, there exists a proof  of
  . Similarly, there exists a proof 
  of .

  

As we can transform the respective proof tree from the axiomatic to the
encoding semantics and vice versa, the two representations are equivalent.
\end{proof}
\end{theorem}



\section{A Linear-Logic Semantics for CHR}
  \label{sec:chrv}

In this section, we extend our linear logic semantics to \emph{CHR with
Disjunction} (CHR), a common extension of CHR. To avoid ambiguity, we
will henceforth use the term \emph{pure CHR} to refer to the regular segment of
CHR without disjunction.

We will firstly recall the syntax and semantics of CHR in
Sect.~\ref{sec:vee-intro}. Then we define an equivalence-based formalization of
its operational semantics in Sect.~\ref{sec:vee-oesq}, analogous to  for
pure CHR. In Sect.~\ref{sec:vee-extend}, we apply this equivalence-based
formalization to define a linear-logic semantics for CHR and proof its soundness and
completeness. In Sect.~\ref{sec:vee-congruence}, we show that in the case of
CHR, the linear-logic semantics has less desirable properties than for
pure CHR: Concretely, linear-logic based reasoning over CHR
programs produces in general less precise results than over CHR programs. We
then introduce the well-behavedness properties of \emph{compactness} and
\emph{analyticness} which amend this limitation.

\subsection{Introduction to CHR}
\label{sec:vee-intro}

CHR has a richer syntax than pure CHR: The definition of goals
is extended by the disjunction operator . Alluding to its operational meaning,
we may also refer to  as the \emph{split operator}. We also introduce the
notion of \emph{configuration}, which can be read as a disjunction of CHR states,
and we extend the definition of goal equivalence to account for
distributivity.

\begin{definition}[Goals, States, Configurations]
	\label{chrv-state-conf}
We adapt the definitions of goal and state, and we define configuration as
follows:

\medskip
\begin{tabular}{l @{\quad} r @{\,::=\,} l}
	Built-in constraint: &
		 &
			\\
	User-defined constraint: &
		 &
			\\
	\chrv\ goal: &
		 &
			\\
	\chrv\ state: &
		  &
			 \\
	Configuration: &
		 &
			
\end{tabular}

\medskip For any two goals , goal equivalence  denotes
equivalence between goals with respect to \emph{associativity} and
\emph{commutativity} of , the \emph{neutrality} of  with respect to
, and the \emph{distributivity} of  over . 
stands for the empty configuration, which is operationally equivalent to a
failed state .

A goal which does not contain disjunctions is called \emph{flat}. A
state  where  is flat is also called flat. A
configuration  is called flat if it is empty or consists only of flat
states.
\end{definition}

Allowing  to distribute over  guarantees that every goal is
equivalent to its disjunctive normal form (DNF). We do not allow the opposite
law of distributivity. For example, we have  but . Thus any finite goal has only a finite
number of equivalent representations.

In CHR, we use the same definition for state equivalence as in pure CHR.
However, as the
definition of goal equivalence is extended, this implicitly carries over to
state equivalence. For example:
.

As in goals, CHR allows disjunctions in rule bodies. The clear
seperation between user-defined constraints and built-in constraints in the
rule body no longer applies. This is reflected in the following definition:

\begin{definition}[\chrv\ Rules]
	\label{def:chrv-rule}
A \chrv\ rule is of the form

The \emph{kept head}  and the \emph{removed head}  are
user-defined constraints. The guard  is a built-in
constraint. The rule body  is a \chrv\ goal.  serves as an identifier for
the rule and may be omitted along with the . An empty guard may be omitted
along with the .
\end{definition}

We observe that restricting \chrv\ to the segment without disjunction restores
pure CHR. Hence, pure CHR is a subset of \chrv. The operational semantics of
CHR has originally been defined in \cite{DBLP:conf/fqas/AbdennadherS98}.
An additional transition rule called \textbf{Split} resolves disjunctions by
branching the computation. Adjusted to our syntax, we express that transition rule as
follows:


We can straightforwardly adapt the operational semantics  to the syntax of
CHR. Adding one rule to handle equivalence transformations of states and
two more rules to handle composition of configurations gives us the following
operational semantics for CHR:

\begin{definition}[Operational Semantics of CHR]
CHR is a state transition system over configurations
defined by the following transition rules, where  is a variant of a CHR rule whose local
variables  are renamed apart from any variable occurring in :



\vspace{1mm}

If the applied rule is obvious from the context or irrelevant, we write
transition simply as . We denote its reflexive-transitive closure
as .
\end{definition}

\noindent The following example shows a possible computation in \chrv:

\begin{example}
	\label{example:albatross}
Consider the following CHR program:

Running this program with the initial state  produces the following fixed-point computation:

The first transition step is justified by the  as well as the
 transition rule. The last transition step is justified by  and
.
\end{example}

\subsection{An Equivalence-Based Operational Semantics for CHR}
\label{sec:vee-oesq}

While the operational semantics presented in Sect.~\ref{sec:vee-intro}
precisely formalizes the execution of a CHR program, it is of limited use
for program analysis. For example, we would intuitively assume that two
configurations should be considered equivalent if they differ only in the order of
their member states.

In this section, we propose a notion of equivalence of configurations, we show
its compliance with rule application and we propose a formalization of the
operational semantics based on equivalence classes of configurations.

\begin{definition}[Equivalence of Configurations]
\label{def:vee-config-equiv}
Equivalence of configurations, denoted as , is the
smallest equivalence relation over configurations satisfying all of the following
properties:
  \begin{enumerate}
      \item \label{cond:vce_ac}
	\emph{Associativity and Commutativity:}
      
      \item \label{cond:vce_steq}
	\emph{State Equivalence}
      
      \item \label{cond:vce_fail}
	\emph{Neutrality of Failed States:}
      
      \item \label{cond:vce_split}
	\emph{Split:}
      
  \end{enumerate}
\end{definition}

Compliance of configuration equivalence with rule application is formalized as
follows:

\begin{property}[Compliance with Rule Application] Let
 be arbitrary configurations such that  and
. Then there exists a  such that  and
. \begin{proof}[sketch] Element states of a configuration
are handled independently of each other, making associativity and commutativity
idempotent to rule application. Equivalence transformation of states complies due
to the \textbf{StateEquiv} rule. Failed states do not allow rule
application. Any application of the
\emph{Split} axiom hindering rule application can be reversed by application of
the \textbf{Split} transition.
\end{proof}
\end{property}

The compliance property allows us to define an operational semantics based on
equivalence classes of configurations using only a single transition rule. In
analogy to the equivalence-based semantics  for pure CHR, we will refer
to this operational semantics as .

\begin{definition}[Transition System of ]
\label{def:vee-tr-system}
CHR is a state transition system over equivalence classes of configurations. It
is defined by the following transition rule, where  is a variant of a CHR rule whose local variables
 are renamed apart from any variable occurring in :

\medskip


\medskip
If the applied rule is obvious from the context or irrelevant, we write
transition simply as . We denote its reflexive-transitive closure
as .
\end{definition}

Analogously to pure CHR, we define a notion of confluence:

\begin{definition}[Confluence]
\label{def:vee-confluence}
A CHR program  is called \emph{confluent}, if for arbitrary
configurations  such that  and
, there exists a configuration  such that
 and .
\end{definition}

Furthermore, we define three sets of observables based on equivalence classes of
configurations:

\begin{definition}[Observables]
	\label{def:observables-vee}
Let  be a CHR state,  be a program, and  be a constraint theory. We
distinguish the following sets of observables:

\medskip
\begin{tabular}{l @{\,} r @{\,} l}
Computable config.: &
	 &
		\\
Answer: &
	 &
		\\
Data-sufficient answer: &
	 &
		 \\
\multicolumn{2}{c}{} & \quad
		
\end{tabular}

\medskip
Note that the parameters for all three sets are states rather than
configurations, as we assume that every computation starts from a singular
state. For all three sets, if the constraint theory  is clear from the
context or not important, we may omit it from the respective identifier.
\end{definition}

Analogously to Property~\ref{prop:op-equiv-hierarchy}, we have a hierarchy of
observables:

\begin{property}[Hierarchy of Observables]
For any state , program  and constraint theory , we have:

\end{property}

The following example illustrates our definitions:

\begin{example}
\label{example:albatross_vee}
We recur to the program from Example~\ref{example:albatross}.

Using , we can construct the following derivation starting from the
initial state :


In comparison with Example~\ref{example:albatross}, we now obtain our result with
one less transition. More importantly, our transition system consists of only one
transition rule now. The equivalence relation over configurations allows us to
omit the failed state from the final configuration, producing a more elegant
representation of the answer.

With respect to the observables, we have , , and .
\end{example}

\subsection{Extending the Linear-Logic Semantics to \chrv}
\label{sec:vee-extend}

In this section, we develop a linear-logic semantics for CHR, based on
the equivalence-based operational semantics .

\subsubsection{Definition of the Semantics}

Since pure CHR is completely contained in CHR and represents a
significant subset thereof, it stands to reason that the linear logic semantics
for pure CHR should be preserved for that segment. Hence, a large part of the
semantics carries directly over to CHR. Now consider a pure CHR program
 of the following form:

The logical reading of this program in the encoding semantics is:

This is logically equivalent to:


We gain the insight that don't-care non-determinism in CHR is already
\emph{implicitly} mapped to additive conjunction  in linear logic.

Mapping the split connective  to multiplicative disjunction  is
an obvious choice, as: (1)  distributes over , (2)
absurdity 0 -- representing failed states -- is neutral with respect to
, and (3)  complements , which represents committed choice.
Hence we preserve the clear distinction between the two types of
non-determinism. We furthermore adapt the translations of states and programs to
the syntax of CHR, thus obtaining the semantics given in
Fig.~\ref{fig:chrv-axiomatic-semantics}

\begin{figure}
	\begin{center}
	\fbox{
	\begin{tabular}{l @{\quad} r @{} l}
	\textrm{Atomic built-in constraints:} &  &  \\
	\textrm{Atomic user-defined constraints:} &  &  \\
	\textrm{Falsity:} &  &  \\
	\textrm{Empty constraint/goal:} &  &  \\
	\textrm{Constraints/goals:} &
		 & \\
	\textrm{Disjunction within goals:} &
		 &  \\
	\textrm{States:} &  &  \\
	\textrm{Configurations:} &
		 &  \\
	\textrm{Empty configuration:} &  &  \\
	\\
	\multicolumn{3}{c}{} \\
	\\
		\multicolumn{3}{c}{}
	\end{tabular}
}
\end{center}
\caption{The axiomatic linear-logic semantics for CHR}
\label{fig:chrv-axiomatic-semantics}
\end{figure}

\subsubsection{Soundness of the Linear Logic Semantics for CHR}

In this section, we prove the soundness of our semantics with respect to
. At first, we show that configuration equivalence implies logical
judgement:

\begin{lemma}[]
\label{lemma:vee-ce-ll}
\begin{longenum}
 \item \label{prop:vel:goal} For goals  such that ,
 we have .
 \item \label{prop:vel:state} For CHR states  and an arbitrary
 constraint theory CT such that such that ,
 we have  where .
 \item \label{prop:vel:conf} For configurations  and an arbitrary
 constraint theory CT such that such that , we have  where .
\end{longenum}
\begin{proof}
  Lemma~\ref{lemma:vee-ce-ll}.\ref{prop:vel:goal}: The property holds,
  as  is associative, commutative, has the neutral element  and
  distributes over .
  Lemma~\ref{lemma:vee-ce-ll}.\ref{prop:vel:state}: Proof is analogous
  to Lemma~\ref{lemma:sq-ll}.
  Lemma~\ref{lemma:vee-ce-ll}.\ref{prop:vel:conf}: We consider the properties
  given in Def.~\ref{def:vee-config-equiv} --
	Def.~\ref{def:vee-config-equiv}.\ref{cond:vce_ac}: For all ,
	we have  and
	.
	Def.~\ref{def:vee-config-equiv}.\ref{cond:vce_steq}: The property follows from Lemma~\ref{lemma:vee-ce-ll}.\ref{prop:vel:state}.
	Def.~\ref{def:vee-config-equiv}.\ref{cond:vce_fail}: For all , we have .
	Def.~\ref{def:vee-config-equiv}.\ref{cond:vce_split}: For all , we have .
\end{proof}

\end{lemma}

Theorem~\ref{thm:soundness} states the soundness of the axiomatic linear-logic
semantics for CHR.

\begin{theorem}[Soundness]
  \label{thm:vee-soundness}
  For any CHR program , constraint theory  and configurations ,
  
  where .
\begin{proof}
Let  be configurations such that . According to
Def.~\ref{def:chr-op-sem}, there exists a variant of a rule with fresh variables
 and configurations
,   such that  and .
Consequently,  contains:

Analogous to the proof of Thm.~\ref{thm:soundness}, we proceed to:

And then to:

This corresponds to . Lemma~\ref{lemma:sq-ll} then
proves that . As the judgement relation
 is transitive and reflexive, the relationship can be generalized
to the reflexive-transitive closure .
\end{proof}
\end{theorem}

\subsubsection{Configuration Entailment}

Analogously to state entailment for pure CHR, we define a notion of
\emph{configuration entailment} to characterize the discrepance between
transitions in a CHR program and judgements in its corresponding sequent
calculus system and thus to completeness of the linear-logic semantics:

\begin{definition}[Entailment of Configurations]
\label{def:c_entail}
Entailment of configurations, denoted as , is the smallest
reflexive-transitive relation over equivalence classes of configurations satisfying
the following conditions:
  \begin{enumerate}
    \item \label{cond:cn_wea}
    \emph{Weakening:} For any state  and configuration
    :
    
    \item \label{cond:cn_stronger}
    \emph{Redundance of Stronger States:} For any CHR
      states  such that
      :
      
    \end{enumerate}
\end{definition}

The following property follows from the definition:

\begin{property}[()]
For CHR states  such that :

\begin{proof}

\end{proof}
\end{property}

Lemma~\ref{lemma:vee-exchange} corresponds to Lemma~\ref{lemma:exchange} for
the case of pure CHR.

\begin{lemma}[Exchange of  and ]\label{lemma:vee-exchange}
  Let  be configurations. If  and  then there exists a configuration  such that
   and .
\begin{proof}
Firstly, we consider hypothesis with respect to the axioms of configuration
entailment (cf. Def.~\ref{def:c_entail}):
\begin{description}
 \item [Def.~\ref{def:c_entail}.\ref{cond:cn_wea}]
	Assume that . It follows that either (i)
	 and  or (ii)  and
	. In case (i), we have  and .
	In case (ii), we have  and .
 \item [Def.~\ref{def:c_entail}.\ref{cond:cn_stronger}]
	Assume that  where
	. It follows that either (i)  and
	 or (ii)  and .
	In case (i), Lemma~\ref{lemma:exchange} proves that there exists an  such
	that  and . Hence, we get
	 and . In case
	(ii), we have  and .
\end{description}
For the reflexive closure of these axioms, the hypothesis is true as
 implies . For their transitive closure, it follows by
induction. Hence, the hypothesis holds for configuration entailment in general.
\end{proof}
\end{lemma}

\subsubsection{Completeness of the Linear-Logic Semantics for
CHR}

Lemma~\ref{lemma:vee-proof-structure} sets the stage for the completeness
theorem. Its proof is analogous to the proof of Lemma~\ref{lemma:proof-structure}
and will be omitted here:

\begin{lemma}
\label{lemma:vee-proof-structure}
Let  be a cut-reduced proof of a sequent  where 
are arbitrary configurations. Any formula  in  is either of the form
 or of the form  where  is a
configuration and  is a built-in constraint.
\end{lemma}

It should be noted that the configuration
 is not necessarily unique, i.e. more than one configuration might
map to a specific formula. For example, let formula . We
then have
. However, we
have by Def.~\ref{def:vee-config-equiv}.\ref{cond:vce_split} that
.

\begin{theorem}[Completeness of the Semantics for CHR]
\label{thm:vee-completeness}
   Let  be configurations, let  be a program and  be a
   constraint theory. Then the sequent  is provable in a
   sequent calculus system with proper axioms 
   \emph{if and only if} there exists a configuration  such that
    and .

\begin{proof}
To preserve clarity, we will omit the set of proper axioms from the judgement
symbol. Furthermore,  denotes the fact that for configurations
,  there exist configurations  for some  such
that:
	
Entailment  implies . We define
 as in the proof of Thm.~\ref{thm:completeness}.

Let  be a cut-reduced proof of .
We assume w.l.o.g. that all existentially quantified variables
in the antecedent of a sequent in  are renamed apart. We define  as an
extension of the completion function from the proof
of Thm.~\ref{thm:completeness} to configurations:

	\medskip
	\begin{tabular}{l @{\hspace{1mm}  \hspace{1mm}} l}
	   &  \\
	   &  \\
	   &  \\
	   & 
	  	\quad for non-empty  \\
	   &  \\
	\end{tabular}

	\medskip
	From Lemma~\ref{lemma:vee-proof-structure} follows that for every
	sequent  in , we have
	 for some configurations . We
	show by induction over the depth of  that for every such , we have .

	\textbf{Base case:}
	In case the proof of  consists in a leaf, it is
	an instance of , , , or a proper axiom
	.
	We apply the same arguments as in the proof of Thm.~\ref{thm:completeness}.
	Thm.~\ref{thm:completeness}.

	\textbf{Induction step:}
	As  is cut-reduced, the final inference rule either has to be one of
	, , , , , ,
	, ,  and , or one of ,
	, and . In the former case, we can follow the same
	arguments as in the proof of Thm.~\ref{thm:completeness}. In the following,
	we consider ,  and .

	\begin{itemize}
	  \item :
		
		Let  be goals, let
 be a state
		and let  be a configuration such that
,
		,  and
		. Let furthermore  and . Hence,
		,
		, and
		.
		The induction hypothesis gives us
		 and
		.
		By Def.~\ref{def:vee-config-equiv}.\ref{cond:vce_split} we have that
		.
		Finally by Lemma~\ref{lemma:vee-exchange}, we get .

	  \item ,  :
	  	
		We consider : By the subformula property, there exist
		configurations , such that
		, , and
		. By the induction hypothesis, we have
		. By
		Def.~\ref{def:c_entail}.\ref{cond:cn_wea}, we have
		 and therefore
		. (The proof for 
		works analogously.)
	\end{itemize}

	Finally, we have , i.e. there exist configurations  such that:
	
	It follows that for , we have  and .
\end{proof}
\end{theorem}

\begin{lemma}[()]
\label{lemma:vee-cn-ll}
For configurations , we have  \emph{if and only if}  where .
\end{lemma}

\begin{proof}
\noindent ('') Follows from Thm.~\ref{thm:vee-completeness} by
assuming an empty program .

\noindent ('')
We consider the axioms for configuration entailment in
Def.~\ref{def:c_entail}: W.r.t. axiom (\ref{cond:cn_wea}),
 implies  since
. For
Def.~\ref{def:c_entail}.\ref{cond:cn_stronger}, 
implies  by Lemma~\ref{lemma:sq-ll}. From a proof of
, we can construct a proof of . As  is
furthermore reflexive and transitive, the hypothesis is reduced to
Lemma~\ref{lemma:vee-ce-ll}.
\end{proof}

Analogously to the encoding semantics for pure CHR, we define an encoding
semantics for CHR. The translation of states and configurations is
unchanged from the axiomatic semantics. The translation of constraint
theories is the same as in the encoding semantics for pure CHR. The translation
of rules and programs is updated to the syntax of CHR as shown in
Fig.~\ref{fig:vee-encoding-semantics}.

\begin{figure}
\begin{center}
\fbox{
	\begin{tabular}{l @{\quad} r @{} l} \\
	\textrm{Rules:} & 
	&  \\
	\textrm{Programs:} &  &
	 \\
	\\
	\end{tabular}
}
\caption{The linear-logic encoding semantics for CHR}
\end{center}
\label{fig:vee-encoding-semantics}
\end{figure}

The soundness and completeness of the encoding semantics is proven analogously
to Theorem~\ref{thm:vee-completeness}:

\begin{theorem}[Soundness and Completeness of the Encoding Semantics]
  \label{theorem:chrv_embed_soundness_completeness}
  Let  be configurations. There exists a configuration  such that
  
  in a program  and a constraint theory  \emph{if and only if}
  
\end{theorem}

As the encoding semantics is logically equivalent to the one proposed in
\citeN{Betz07}, Theorem~\ref{theorem:chrv_embed_soundness_completeness}
also proves the equivalence of the axiomatic linear-logic semantics with that
earlier semantics.

\subsection{Congruence and Analyticness}
\label{sec:vee-congruence}

The operational semantics  for \emph{pure} CHR features the pleasant
property that state equivalence coincides with mutual entailment of states (cf.
Corollary~\ref{crl:ent-equiv}). In this section, we show that the property of
mutual configuration entailment, henceforth called \emph{congruence of
configurations}, does not in general coincide with configuration equivalence.

To overcome this limitation, we introduce a well-behavedness property on
configurations -- \emph{compactness} -- and one on CHR programs --
\emph{analyticness} -- which guarantee that congruence coincides with equivalence.

\begin{definition}[Congruence of Configurations] Given a constraint theory ,
two configurations  are considered \emph{congruent} if  and
. Congruence of  and  is denoted as .
\end{definition}

Congruence of configurations does not generally comply with rule applications
as the following example shows.

\begin{example}[Non-Compliance with Rule Application] By compliance, we mean the
property that for arbitrary configurations  such that
 and , there exists a  such that
 and .

Let  and  be
configurations. As , we have congruence:
. Now consider the following minimal CHR program:  We observe that we have 
whereas  is an answer configuration i.e. it does not allow any further
transition. We thus observe that congruence of configurations is not in general
compliant with rule application.
\end{example}

However, we can make a somewhat weaker statement about the relationship between
congruence and rule application:

\begin{property}[Weak Compliance with Rule Application] Let  be
configurations such that . Then  implies that
there exists a  such that  and .
\begin{proof}
 implies . Furthermore, we have . Hence, Lemma~\ref{lemma:vee-exchange} proves  and .
\end{proof}
\end{property}

As the congruence relation does not strongly comply with rule application, it is
not appropriate as a general equivalence relation over configurations. On the
other hand, from Lemma~\ref{lemma:vee-cn-ll} follows that congruence of
configurations coincides with logical equivalence over the respective
linear-logic readings:

\begin{property}
For arbitrary configurations , we have .
\end{property}

Hence, any reasoning over CHR via the linear-logic semantics is
necessarily modulo congruence. In order to allow precise logical reasoning over
CHR, we identify a segment of CHR where congruence and equivalence
of configurations coincide. Firstly, we introduce the notion of
\emph{compactness}:

\begin{definition}[Compactness]
 A configuration  is called \emph{compact} if it does not have a
 representation  of the form  where
  are flat states such that  and .
\end{definition}

We extend the compactness property to equivalence classes of configurations in
the obvious manner. The following lemma states that compactness guarantees that
congruence and equivalence coincide.

\begin{lemma}
 Let  be compact configurations such that . Then .
\begin{proof}
 Considering Def.\ref{def:vee-config-equiv}, we observe that every configuration
  has a representation of the form , where
  for . By
 Def.~\ref{def:c_entail}, any two configurations  where 
 have representations  such that for every  where , we have the exists
 a  such that .

 As , we have representations  such that for every consistent , we have a
  such that , and for every consistent  there is an 
 such that . It follows that for every consistent , we have
  such that . As  is compact, 
 implies  and furthermore . As  is compact,
 there is exactly one  such that .

 Since every consistent  has a unique corresponding state  with
  and vice versa, Def.~\ref{def:vee-config-equiv} implies that
 .
\end{proof}
\end{lemma}

We furthermore introduce a well-behavedness property for CHR programs
which guarantees compactness of derived configurations by assuring that
disjoint member states of a configuration have contradicting built-in states. It
appears that a large number of practical CHR programs satisfy this property.

\begin{definition}[Analytic Program]
\label{def:analytic}
A CHR program is called \emph{analytic} if for any flat state 
and configuration  where , we have that  is compact.
\end{definition}

We give a sufficient (although not necessary) criterion for analyticness
of CHR programs:

\begin{lemma}[Criterion for Analyticness]
\label{lemma:vee-analytic-criterion}

Let  be a CHR program consisting of rules . Assume
that every rule  is of the form  such that
 for every . Then 
is analytic.

\begin{proof} We assume a single rule application  where the
applied rule be of the form  such that
 for .

It follows that for every
 such that , we have . It
follows by Lemma~\ref{thm:se_crit} that .

As the built-in store grows monotonically stronger, correctness for the
transitive closure of  follows by induction. For the reflexive closure
it follows from the fact that the state  is trivially a compact
configuration.
\end{proof}
\end{lemma}

\section{Application}
\label{sec:application}

In this section, we outline how our results can be applied to reason over
programs and their respective observables. We separate it into two broad
application domains: In Section~\ref{sec:app:observables}, we discuss the
relationship between the linear-logic semantics and program observables. In
Section~\ref{sec:app:comparison}, we show how we can compare the operational
semantics of programs by means of their linear-logic semantics.

\subsection{Reasoning About Observables}
\label{sec:app:observables}

In this section, we show how to apply our results to reason about observables
in both pure CHR and CHR. We will first discuss pure CHR in detail and
then show how the results are generalized to CHR.

\subsubsection{Reasoning About Observables in Pure CHR}

We define two sets of observables based on the linear logic
semantics, paralleling the observable sets of computable states and
data-sufficient answers.

\begin{definition}
Let  be a pure CHR program,  a constraint theory, and 
an initial state. Assuming that , we distinguish
two sets of observables based on the linear logic semantics:


If the constraint theory  is clear from
the context or not important, we write the sets as .

\end{definition}

The following definition and property establish the relationship between the
logical observables  and  and the operational
observables  and 

\begin{definition}[Lower Closure of ]
For any set  of equivalence classes of CHR states,

\end{definition}

The following property follows directly from
Theorem~\ref{theorem:embed_soundness_completeness}:

\begin{property}[Relationship Between Observables]
For a pure CHR program , a constraint theory , and an initial
state , we have:

\end{property}

From this relationship follow several properties that we can use to reason about
the operational semantics. Firstly, in order to prove that a state  cannot
develop into a failed state, it suffices to show that there exists any state ,
such that  is not contained in :

\begin{property}[Exclusion of Failure]
\label{lemma:app-exclude-fail}
Under a program , a constraint theory , and a CHR state  if there
exists a state  such that  then
.
\end{property}

Secondly, we can guarantee data-sufficient answers for a state , if we can
prove the empty resource 1 in linear logic:

\begin{property}[Assuring Data-Sufficient Answers]
\label{lemma:app-assure-ds}
\begin{longenum}
\item Under a program , a constraint theory , and a CHR state , if
 then  has at least one
data-sufficient answer.
\item If  is furthermore confluent,  has exactly one
data-sufficient answer.
\end{longenum}
\begin{proof}[sketch]
The first property follows from the fact that for any data-sufficient state
, we have
. The second property
follows from Prop.~\ref{prop:confluence-answers}.
\end{proof}
\end{property}

Finally, if a specific state does not follow in linear logic, it is guaranteed
not to follow in the operational semantics:

\begin{property}[Safety Properties]
\label{lemma:app-safety-properties}
For a program , a constraint theory , and any two CHR states , if
 then .
\end{property}

\begin{example}
	\label{example::philosophers}
This example shows how to exploit the completeness of our semantics
to prove safety properties for CHR programs. By \emph{safety property}, we mean
a problem of non-existence of a derivation between two CHR states. The general
form of a safety property is .

We implement the -Dining-Philosophers Problem for an arbitrary
number of philosphers and we show using the phase semantics that the program can
never reach a state in which any two philosophers directly neighboring each
other are eating at the same time.

We assume that 
includes the constraint theory for natural numbers.

We want to prove that two philosophers (among  philosophers) which
are seated side by side cannot be eating at the same time. This can be
formalized by the following safety property (we naturally assume
there are at least two philosophers):

Showing that a certain state is not included in , or -- more
generally -- that a certain linear-logic judgement is not valid is in general
not trivial. Having an automated theorem prover try all possible inference
rules exhaustively is an option. In \cite{Betz2008}, a method to
prove safety properties using the phase semantics of linear logic has been
proposed. At this point, it shall suffice to state that we can show:

This proves that no two philosophers seated side by side can be eating at the
same time.
\end{example}

\subsubsection{Generalization to CHR}

As for pure CHR, we define two sets of linear logic observables, paralleling
the sets of computable configurations and data-sufficient answer configurations.

\begin{definition}
Given a CHR program , a constraint theory , and an initial
state , we distinguish two sets of observables based on the linear logic
semantics:

\begin{tabular}{r @{\,} l}
	\multicolumn{2}{c}{}\\
	 &
		\\
	 &
		 \\
	\multicolumn{1}{c}{} & \quad
		\\
	\multicolumn{2}{c}{}\\
\end{tabular}
\end{definition}

The relationship between the
logical observables and the operational
observables is parallel to pure CHR, though generalized to the
lower closure of configuration entailment

\begin{definition}[Lower Closure of ]
For any set  of equivalence classes of CHR states,

\end{definition}

By Theorem~\ref{theorem:chrv_embed_soundness_completeness}, we then have:

\begin{property}[Relationship Between Observables]
For a CHR program , a constraint theory , and an initial
state , we have:

\end{property}

Furthermore, each of Property~\ref{lemma:app-exclude-fail},
Property~\ref{lemma:app-assure-ds}, and
Property~\ref{lemma:app-safety-properties} have their obvious
counterparts in CHR.

\subsection{Comparison of Programs}
\label{sec:app:comparison}

In this section, we put special emphasis on the comparison of CHR and CHR
programs across programming paradigms. Hence, we will not treat pure CHR in an
isolated manner but as a subset of CHR. Note also that we use the
encoding rather than the axiomatic formulation of our semantics in this section.

We define three notions of operational equivalence, each one corresponding to
one set of observables as introduced in Section~\ref{sec:op-sem}.

\begin{definition}[Operational Equivalence]
\begin{longenum}
  \item Two CHR programs  are \emph{operationally
  -equivalent} under a given constraint theory  if for any state , we have
  .
  \item Two CHR programs  are \emph{operationally
  -equivalent} under a given constraint theory  if for
  any state , we have .
  \item Two CHR programs  are \emph{operationally
  -equivalent} under a given constraint theory  if for any state , we have
  .
\end{longenum}
\end{definition}

We will mainly focus on -eqivalence and -equivalence.
What we call -equivalence has been researched extensively in the past
(cf. \citeN{DBLP:journals/constraints/AbdennadherFM99}). It shows in this
section that the linear-logic semantics is not adequate to reason about
-equivalence.

\begin{definition}[Logical Equivalence of Programs] Two CHR programs
 are called \emph{logically equivalent} under a given constraint
theory  if , where the unary
operator  stands for element-wise multiplicative conjunction and
 is shorthand for
.
\end{definition}

The following proposition relates - and -equivalence.

\begin{proposition}\label{prop:op-equiv-hierarchy}
Operational -equivalence is a necessary but not a
sufficient condition for -equivalence.
\begin{proof}
To show that -equivalence is a necessary condition, we assume two
-equivalent programs . For every state , we have
. As each  is the projection of
 to configurations with empty user-defined stores, we also have
.

To show that -equivalence is not a sufficient condition, consider the
following two programs:

Both programs ultimately map every  and  to . Hence, they
are -equivalent. For  and
 we have  but
. Hence, the programs are not -equivalent.
\end{proof}
\end{proposition}

We can show that operational -equivalence implies logical equivalence of
programs:

\begin{proposition}\label{prop:ll-equiv-impl-confl}Let  be two
-equivalent  programs under . Then
.
\begin{proof}
Since  and  are -equivalent, we have that
 for all .
For every rule , we have by Def.~\ref{def:vee-tr-system}:

where
 and then by our hypothesis .
Therefore, we get . Applying this to all
rules , we show .
Analogously, we get .
\end{proof}
\end{proposition}

The reverse direction does not hold in general as the following example shows:

\begin{example}
Let the constraint theory  contain at least the theory of natural numbers.
Compare the following two programs:

The greater-or-equal constraint  is a built-in constraint. Hence, it is
translated as . As , we have
.
We observe that  and
. As the
sets are not equal,  and  are not operationally -equivalent
and hence, by Prop.~\ref{prop:op-equiv-hierarchy}, not -equivalent.
\end{example}

However, if we restrict ourselves to analytic, confluent
programs, we can show that logical equivqalence of programs implies operational
-equivalence:

\begin{proposition}\label{prop:confl-impl-ll-equiv} Let  be two
analytic confluent  programs such that
.
Then  are -equivalent.
\begin{proof}
As both  and  are confluent, we have
 for any state  and ,
where  denotes cardinality. If 
then . Otherwise,
. In the former case, our
proposition is trivially true since . In the
following, we assume .

Logical equivalence implies that 
for all . Since  is the projection of  to configurations with
empty user-defined stores, we also have
 and hence
.

Since  for , each lower
closure  has a maximum
 such that  and
. As
,
we have . As both programs are analytic, we furthermore
have that  are compact. Hence, we have  and therefore: .
\end{proof}
\end{proposition}

The following example shows that logical equivalence does not imply
operational -equivalence:

\begin{example}
We consider the program  and the empty
program :

As the logical reading  of  is a logical
tautology, it follows that  for any
. Yet, for , we have
 whereas .
Therefore . \end{example}

The following final example shows how we can apply the linear-logic
semantics to compare programs across programming paradigms.

\begin{example}
\label{example:append}
We begin with the following
classic Prolog program which implements a ternary \emph{append} predicate for
lists, where the third argument is the concatenation of the first two: 
We can embed this program into CHR by explicitly stating the
don't-know non-determinism using the  operator.

The linear-logic reading of the embedded program looks as follows:
  
Secondly, we write a program to implement the \emph{append} predicate the way it
would be expected in CHR:

The two programs are not \emph{per se} -equivalent. Consider their
behaviour in case the first argument of  is bound to anything else than a list. For
, we have 
but  .

Now let us assume that the first argument is always bound to a list. We can model
this by the following formula:  It shows that
. Hence, under the
assumption that the first argument is always bound to a (non-empty or empty)
list, the two programs are operationally -equivalent.

Moreover, we observe that  is equivalent to the logical reading of the
CHR rule :  Moreover
 implies that

Hence, the programs  and  are operationally -equivalent (without any further assumptions).
\end{example}

\section{Related Work}
\label{sec:related}

From its advent in the 1980ies, linear logic has been studied in relationship
with programming languages.

Common linear logic programming languages such as
LO\cite{DBLP:conf/oopsla/AndreoliP90}, Lolli\cite{DBLP:conf/lics/HodasM91},
LinLog\cite{Andreoli92logicprogramming}, and
Lygon\cite{DBLP:conf/amast/HarlandPW96} rely on generalizations of
backward-chaining backtracking resolution of horn clauses.

The earliest approach at defining a linear-logic semantics for a
committed-choice programming language that we are aware of has been proposed in
\cite{DBLP:conf/kgc/Zlatuska93}. The corresponding language is indeed a fragment
of pure CHR without multiple heads and with substantial restrictions on the use
of built-in constraints.

The linear-logic programming language LolliMon, proposed in
\cite{DBLP:conf/ppdp/LopezPPW05}, integrates backward-chaining proof search with
committed-choice forward reasoning. It is an extension of the aforementioned
language Lolli. The sequent calculus underlying Lolli extended by a set of
dedicated inference rules. The corresponding connectives are syntactically
detached from Lolli's own connectives and operationally they are processed within
a monad. The actual committed-choice behaviour comes by the explicit statement in
the operational semantics, that these inference are to be applied in a
committed-choice manner during proof search. With respect to Lolli, committed
comes thus comes at the cost of giving up the general notion of execution as
proof search, although it is retained outside the monad.

The class LCC of linear logic concurrent constraint programming languages
\cite{DBLP:journals/iandc/FagesRS01} has a close relationship with CHR, although
the former is based on agents whereas the latter is based on rules. Similar to
CHR, LCC languages are non-deterministic and execution is committed-choice. The
linear logic semantics of LCC is similar to our linear logic semantics for pure
CHR and, as far as the two are comparable, it features similar results for
soundness and completeness. Unlike CHR however, LCC has no notion of
disjunction.

Furthermore, Fages et al. have proposed the so-called
\emph{frontier semantics}\cite{DBLP:journals/iandc/FagesRS01} for LCC, in which
the committed-choice operator is interpreted analogously to the
disjunction operator  in CHR. In the linear-logic interpretation of
the frontier semantics, it is correspondingly mapped to the multiplicative
disjunction . However, the frontier semantics does not constitute a distinct
programming language but is viewed as a tool to reason about properties of LCC
programs. Hence, committed choice never co-exists with disjunction as in the
linear logic semantics for CHR. Rather, the two are viewed as different
interpretations of the same connective for different purposes.

More recently, Simmons et al. proposed the linear logic-based committed-choice
programming language \emph{Linear Logical Algorithms}
\cite{DBLP:conf/icalp/SimmonsP08}. While the language itself corresponds to a
segment of pure CHR, the aim of the work is to define a cost semantics for
algorithms that feature non-deteministic choices.

\section{Conclusion}
\label{sec:conclusion}

In this article, we have presented a detailed analysis of the relationship
between both pure CHR and CHR with intuitionistic linear logic and we have
shown its applications from reasoning about programs observables to deciding
operational equivalence of multi-paradigm CHR programs.

Our first main contribution is the linear-logic semantics for the segment of pure
CHR. It encodes both CHR programs and constraint theories to proper axioms of the
sequent calculus. We have shown that equivalence of CHR states coincides with
logical equivalence of the logical readings of state. Furthermore, we have
introduced the notion of state entailment, which precisely characterizes the
discrepance between the transition relation between states in CHR and judgements
between their corresponding logical readings. It is a key notion for the study
and the application of our semantics.

Our second main contribution is the definition of a linear-logic semantics for
CHR. This semantics maps the dualism between don't-care and don't-know
non-determinism in CHR to the dualism of internal and external choice in
linear logic. Analogously to pure CHR, we have defined a notion of configuration
entailment to characterize the discrepance between state transition and logical
judgement.

We have shown that the linear-logic semantics for CHR has somewhat less
desirable properties than the one for pure CHR. Concretely, mutual configuration
entailment does not coincide with configuration equivalence. This makes
linear-logic based reasoning over CHR in general more imprecise. However,
we have presented a well-behavedness property for CHR -- analyticness --
that amends this limitation.

As our third main contribution, we have shown how to apply our results to reason
about CHR and CHR programs. We have defined sets of linear-logic based
observables that correspond with the usual program observables of computable
state and data-sufficient answer by means of state entailment or confguration
entailment, respectively. We have presented criteria to prove various program
properties, foremost safety properties, which consist in the non-computability of
a specific state from a certain initial state. Furthermore, we have given a
criterion to prove operational equivalence with respect to data-sufficient
answers for multi-paradigm programs.

As a further contribution, we have for the first time defined an equivalence
relation over configurations and shown its compliance with rule application.
Based on this relation, we have defined an elegant formalization of the
operational semantics of CHR based on equivalence classes of
configurations. The equivalence-based semantics provides a language to express
properties of programs such as operational equivalence across the boundaries of
programming paradigms.

Our results entail a wide range of possible future work. An obvious line of
future work lies in the application of established methods for automated proof
search in linear logic to reason about CHR and CHR programs. As
significant effort has been put in the current result on amending the discrepance
between linear judgement and the semantics of CHR, it furthermore suggests itself
to investigate whether a ``purer'' formalism to reason about CHR could be
extracted from linear logic that avoids these discrepances.

\begin{acks} We are grateful to the reviewers of an earlier version of this paper
for their helpful remarks. Hariolf Betz has been funded by the University of Ulm
with LGFG grant \#0518.
\end{acks}

\bibliographystyle{acmtrans}
\bibliography{linlogsem}

\end{document}
