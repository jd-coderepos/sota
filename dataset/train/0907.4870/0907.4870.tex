\documentclass[onecolumn]{IEEEtran}
\makeatletter
\def\ps@headings{\def\@oddhead{\mbox{}\scriptsize\rightmark \hfil \thepage}\def\@evenhead{\scriptsize\thepage \hfil \leftmark\mbox{}}\def\@oddfoot{}\def\@evenfoot{}}
\makeatother
\pagestyle{headings}

\usepackage{epsfig} \usepackage{amsmath} \usepackage{amssymb}
\usepackage{amsfonts} \usepackage{graphicx} \usepackage{subfigure}
\newtheorem{theorem}{Theorem} \newtheorem{lemma}[theorem]{Lemma}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{corollary}[theorem]{Corollary}
\begin{document}
\title{Tunable Locally-Optimal Geographical Forwarding in Wireless
  Sensor Networks with\\ Sleep-Wake Cycling Nodes}
\author{K.P. Naveen and Anurag Kumar\\
  {Dept. of E.C.E.,}
  {Indian Institute of Science, Bangalore 560 012, India.}\\
  {\{naveenkp, anurag\}@ece.iisc.ernet.in}}
\maketitle
\begin{abstract}
  We consider a wireless sensor network whose main function is to
  detect certain infrequent alarm events, and to forward alarm packets
  to a base station, using geographical forwarding. The nodes know
  their locations, and they sleep-wake cycle, waking up periodically
  but not synchronously. In this situation, when a node has a packet
  to forward to the sink, there is a trade-off between how long this
  node waits for a suitable neighbor to wake up and the progress the
  packet makes towards the sink once it is forwarded to this
  neighbor.  Hence, in choosing a relay node, we consider the problem
  of minimizing average delay subject to a constraint on the average progress. By
  constraint relaxation, we formulate
  this next hop relay selection problem as a Markov decision process
  (MDP). The exact optimal solution (BF (Best Forward)) can be found,
  but is computationally intensive.  Next, we consider a
  mathematically simplified model for which the optimal policy (SF (Simplified Forward)) turns out to
  be a simple one-step-look-ahead rule.  Simulations show that SF is
  very close in performance to BF, even for reasonably small node
  density.  We then study the end-to-end performance  of
  SF in comparison with two extremal policies: Max Forward (MF) and First Forward (FF), and an end-to-end
  delay minimising policy proposed by Kim et al. \cite{kim-etal09optimal-anycast}. We find that, with appropriate
  choice of one hop average progress constraint, SF can be \emph{tuned} to provide a favorable trade-off
  between end-to-end packet delay and the number of hops in the
  forwarding path.
\end{abstract}
\section{Introduction}
An important application of wireless sensor networks (WSN) is dense
embedded sensing for the purpose of detecting certain infrequently
occuring events, such as failures in a large structure, or intrusion
into a secure region. Such an event can occur anywhere in a large WSN,
and once an event is detected, the alarm needs to be rapidly sent to
the sink  for further action. In such WSNs, typically the
nodes rely on batteries, or energy harvested from their surroundings,
and, hence, need to be extremely parsimonius in their use of energy.
In order to conserve energy, the nodes operate in sleep-wake cycles;
when a node wakes up it performs sensing, and also can assist in
forwarding any alarm packets towards the sink. In this paper, we
consider the situation in which the sleep-wake cycles of nodes are
\emph{not synchronized.}  In such a setting, stateful routing is not
possible. 
Instead, if the nodes
know their own locations and that of the sink, then it is possible to
dynamically select forwarding nodes that are successively nearer to
the sink.  This is called \emph{geographical routing,} and has been
widely studied as a simple scalable approach for routing in sensor
networks \cite{takagi-kleinrock84optimaltransmission,hou-etal86rangecontrol,karp-etal00gpsr,kuhn-etal08algorithmicapproach}.
 For the purpose of location determination, low cost GPS
devices are now becoming available, and can be incorporated in the
nodes; alternatively, approximate localization algorithms based on
various geometrical principles can also be used (see, for example,
\cite{dulman-etal06hop-count,nath-kumar08distance-hop}. For a
survey on routing and localization, see
\cite{mauve-hartenstein01survey,Akkaya-younis05survey}. 
   In this paper we assume that nodes know their exact
locations and also the location of the sink.

\noindent
\emph{The relay node selection problem:} In geographical forwarding,
in our setting, there arises the problem of optimal relay node
selection, which we now discuss.  One approach is that of \emph{greedy
  forwarding}, in which an intermediate node forwards the packet to
its neighbor node that makes maximum progress towards the sink. This
scheme is referred to as Most Forward within Radius (MFR)
(\cite{takagi-kleinrock84optimaltransmission,hou-etal86rangecontrol}).
If the node density is large such that every node has a neighbor that
is closer to the sink than itself, then the greedy approach can find
routes close to the minimum hop paths. Following a minimum hop path is
beneficial since it reduces the number of times the network needs to
transmit the packet.

However, when the nodes are sleep-wake cycling in an asynchronous
manner there is a trade-off between the delay in relay node selection
and the progress made towards the sink. For example, if MFR is
implemented, then for an intermediate node to forward the packet to a
relay node that makes the maximum progress towards the sink, the
intermediate node will need to wait for all its neighbors closer to
the sink than itself to wake up. This will result in an increase in
the delay of the alarm that is being forwarded. In fact, a counterpart
to the MFR policy could be the policy that forwards the packet to the
first node that wakes up and is nearer to the sink than the
intermediate node. In this paper we call this latter policy First
Forward (FF), and the MFR policy, simply, Max Forward (MF).

In this paper we study the above trade-off for the following one hop
relaying problem. A node needs to forward a packet to the sink. There
is a set of neighbors of the node that are nearer to the sink than the
node; the \emph{forwarding set}. The nodes are asynchronously
sleep-wake cycling according to a certain model. We seek policies for
relay node selection so as to minimize the delay in determining the
relay node, subject to a constraint on the progress made towards the
sink. We assume that each node has at least one neighbor that is strictly
closer to the sink than itself so that greedy forwarding will always
find a path to sink.  This is a reasonable assumption for large node
densities.

\noindent
\emph{Our contributions:} 
\begin{itemize}
\item The problem of minimizing average one hop delay subject to a
  constraint on the average progress made, when nodes wake up
  periodically, but not synchronously, is formulated as a Markov
  decision problem (MDP), and solved to yield the optimal policy which
  we call Best Forward (BF).  See Section~\ref{problem_formulation}
  and Section~\ref{optimal_policy}.
\item In a mathematically simplified setting (i.i.d., exponentially
  distributed inter-wakeup times) the MDP approach is used to derive a
  threshold type policy, called Simplified Forward (SF). The threshold
  is a function of the constraint on progress, and the policy is to
  transmit to the first node which wakes up and makes a progress of
  more than the threshold. See Section~\ref{suboptimal_policy}.  While
  such a policy has been proposed heuristically in previous works (\cite{paruchuri-etal04RAW,liu-etal07CMAC}), we 
  have derived it from the MDP formulation and we
  show through simulations that the performance of this policy is
  close to that of BF.  The simulation results are in
  Section~\ref{simulation_results}.
\item Finally, we compare the end to end performance (average delay
  and hop counts) of the SF policy with the forwarding policy proposed
  by Kim et al.\ \cite{kim-etal09optimal-anycast}. The approach of Kim
  et al.  aims to achieve minimum average end-to-end delay, but at the
  expense of an initial configuration phase. The SF policy, however,
  does not need any global organization phase, and the progress
  constraint  can be used to \emph{tune}
  the end-to-end performance to suitably trade-off between end-to-end
  delay and the number of hops in the forwarding path. These results
  are reported in Section~\ref{simulation_results}.
\end{itemize}


\section{Related Work} 
\label{related_work} 
Zorzi and Rao (\cite{Zorzi-rao03geographicrandom}) consider a scenario
similar to ours: geographical forwarding in a wireless mesh network in
which the nodes know their locations, and are sleep-wake cycling. They
propose GeRaF (Geographical Random Forwarding), a distributed relaying
algorithm, whose objective is to carry a packet to its destination in
as few hops as possible, by making as large progress as possible at
each relaying stage. Thus, the objective is similar to the MFR
algorithm, mentioned above
(\cite{takagi-kleinrock84optimaltransmission,hou-etal86rangecontrol}).  For their algorithm, the authors
obtain the average number of hops (for given source-sink distance) as
a function of the node density. These authors do not consider the trade-off between relay selection
delay and the progress towards the sink, which is a major contribution
of our work.

Liu et al.\ (\cite{liu-etal07CMAC}) propose a relay selection approach
as a part of CMAC, a protocol for geographical packet forwarding. With
respect to the fixed sink, a node  has a forwarding set consisting
of all nodes that make progress greater than  (an algorithm
parameter). If  represent the delay until the first wake-up instant
of a node in the forwarding set, and  is the corresponding progress
made, then, under CMAC, node  chooses an  that minimizes the
expected normalized latency . The Random
Asynchronous Wakeup (RAW) protocol (\cite{paruchuri-etal04RAW}) also
considers transmitting to the first node to wake up that makes a
progress greater than a threshold .  Interestingly, this is also the structure
of the optimal policy provided by one of our Markov decision process
formulations.

Kim et al.\ (\cite{kim-etal09optimal-anycast}) consider a dense WSN in
which the traffic model and sleep-wake cycling are similar to ours. An
occasional alarm packet needs to be sent, from wherever in the network
it is generated, to the sink. The nodes are asynchronously sleep-wake
cycling. The authors develop an optimal anycast scheme to minimize
average end-to-end delay from any node  to the sink. The
optimization is also done over sleep-wake cycling patterns and rates.
A dynamic programming approach is taken, with the stages being the
number of hops to the sink. While the framework is similar to ours,
Kim et al.\ do not consider the objective of spatial progress at each
hop, which results in the reduction of hop counts along the forwarding
paths, and thus in the reduction of node energy utilization. In our
work, we have studied the trade-off, at a typical forwarding stage,
between forwarding delay and the distance that the packet covers in
the hop.

Rossi et al.\ (\cite{rossi-etal08SARA}) consider the problem of
geographical forwarding in a wireless sensor network in which each node
knows its hop distance from the sink. For each link, there is a link
cost (for example, energy cost) for forwarding a packet over that
link. Thus, there are two end-to-end cost criteria for a forwarding
path: the total link cost of the path, and the number of hops in the
path. When a node, say , has a packet to forward to the sink, it
has to consider the trade-off between cost reduction and hop distance
reduction; note that cost can be reduced by forwarding the packet to a
neighbor node with the same hop distance to the sink, but using which
the total link cost could be lower.  The information available at 
is the cost to all its neighbors, and the statistics of the
costs-to-go from the neighbors. The major difference in our work is
that we have a sequential decision problem \emph{at each stage}, since
the costs (wake-up delay) and rewards (progress towards the sink) are
revealed as the nodes wake up, and only the statistics are known a
priori.

Chaporkar and Proutiere (\cite{chaporkar-proutiere08joint-probing})
consider the problem of a transmitter that needs to transmit over one
of several available channels. The transmitter can probe the channels
to determine channel state information in order to encode its
transmissions. The trade-off is between the time taken to probe and
the throughput advantage of finding a good channel. Some important
differences between their model and ours are the following.  In our
work the trade-off is between the time taken to wait for a relay to
wake up, and the \emph{spatial} progress the relay makes towards the
sink. In \cite{chaporkar-proutiere08joint-probing}, the transmitter
can use an unprobed channel, whereas in our problem a relay that has
not yet woken up cannot be used. In
\cite{chaporkar-proutiere08joint-probing}, the transmitter can probe
the channels in an order that it can choose (e.g., the stochastically
best channel first); in our problem the relays wake up in a random
order that is not under the control of the transmitter. In
\cite{chaporkar-proutiere08joint-probing} it is shown that if the use
of an unprobed channel is not allowed then a one-step-look-ahead rule
is optimal. This is similar to the solution we obtain for a simplified
version of our model. Note that whereas the concern in
\cite{chaporkar-proutiere08joint-probing} is only with one-step
relaying, we also study how the one-step policy performs in terms of
end-to-end objectives, namely, path delay and path hop count.

\section{System Model}
\label{system_model}
\subsection{Node Deployment}
 identical sensor nodes are uniformly deployed in the square region
. We take  to be a Poisson random variable of rate
 where  is the node density. Let ,
, be the locations of the nodes. Additional \emph{source} and
\emph{sink} nodes are placed at fixed locations  and
 respectively. Thus including the source and sink
nodes, there are a total of  nodes in the disk.  is the
communication range of each node. Two nodes  and  are called
neighbors if and only if . The distance between
node  and sink () is .
\subsection{The Sleep-Wake Process}
To conserve energy, each node performs periodic sleep-wake cycling.
The sleep-wake times of the nodes are \emph{not synchronized}. Since
we are interested in studying the delay incurred in routing due to
sleep-wake cycling alone, we neglect the transmission delay,
propagation delay and other overhead delays. This means that if node
 has a packet to transmit to its neighboring node , then 
can transmit immediately at the instant  wakes up.  We model this
by taking the time for which a node stays awake to be zero.

More formally, let ,  be \emph{i.i.d.} random variables
which are uniform on , where  is the period of the sleep
wake cycle. Then node  wakes up at the periodic instants .  We define the \emph{waiting time for i} to wake up at time
 as,
 
\subsection{Forwarding Rules and Assumptions}
Forwarding rules dictate the actions a node can take when it has to
transmit. We are interested in decentralized policies where a node can
take decisions only by observing the activities in its neighborhood
(\emph{i.e.,} the disk of radius  centered around the node of
interest). In this regard we impose some restrictions on the network.

\noindent
\emph{Traffic Model:} There is a single packet in the network which is
to be routed from the source to sink.  At time , the packet is
given to the source and the routing process begins. The nodes which
get the packet for forwarding are called relay nodes. The packet
traverses a sequence of relay nodes to eventually reach the sink, at
which time the routing ends.  Thus there is a single flow and further
the flow consists of only one packet. This set up is reasonable,
because in sensor networks we can assume that the events are
sufficiently separated in time and/or location so that the flows due
to two events do not intersect. To avoid multiple packet transmission
by different nodes detecting the same event, the nodes can resolve
among themselves to select one node (say the one closest to the sink),
which can then transmit. Further, the information about an event
comprises its location, and possibly target classification data, which
along with some control bits can be easily incorporated in a single
packet. This justifies the idea to study the performance of a single
packet alone. 

\noindent
\emph{Forwarding Set:} Each node knows its location and the location
of the sink. The \emph{forwarding set} of a node is the set of its
neighbors that are closer to the sink then itself.  A relay node
considers forwarding the packet only to a node in its forwarding set.
Each node knows the number of neighbors in its forwarding set, but is
not aware of their locations and wake times.  While in this paper we
assume that each node knows the number of nodes in its forwarding set,
it would be desirable to develop forwarding algorithms that do not
require even this knowledge. We leave this as future work, but in
Section \ref{end_subsec} we provide simulation results on the
performance of our algorithm when the node takes the number of nodes
in its forwarding region to be just the expected number of nodes.
\subsection{Some Notation}
\label{notation_sec}
To define a forwarding policy more formally, we begin by setting up
some notation. Consider a generic node  which gets the packet to
forward at some instant . Let .   is the set of all points that are
within the communication radius of  and are strictly closer to the
sink than  (see Fig. \ref{forwardset_figu}) (we ignore edge effects
by assuming that ).  If
 then the progress made by  is .
Let  be the number of nodes in . Note that
, where  is
the area of the region . Recall that node  knows
 and hence we focus on the event  for some .

Let the indices of the nodes in  be arranged as
, such that .  The corresponding values of progress are
. For simplicity, from here on we
neglect  in the subscript and simply use 
and .
\begin{figure}[ht]
\centering
\includegraphics[scale=0.5]{forward_set.eps}
\caption{ and  are the locations of node  and sink
  respectively.  is the distance between them,  is the
  communication radius.   is the set of all points that
  are within the communication radius of node  and closer to sink
  than .  is the shaded region in the figure.
  \label{forwardset_figu}}
\end{figure}

The locations of each of these  nodes are uniformly distributed in
the region  independent of the others. Hence the
progress made by them are \emph{i.i.d.} whose distribution is same as .
The \emph{p.d.f.} of  is supported on  and is given by,

Where  denotes the area of the region , 


Let  and  for . We refer to  as the \emph{inter-wakeup} times. These are
the waiting times between the wakeup instants of sucessive nodes in
 (see Fig. \ref{wakeinstants_figu}). Further  and  are independent.
\begin{figure}[ht]
\centering
\includegraphics[scale=0.5]{wake_instants.eps}
\caption{ represents the wake instant and the
  progress respectively, made by the Node  in .
  These are shown as points in .  is the
  inter-wakeup time between node  and
  .\label{wakeinstants_figu}}
\end{figure}
 
The waiting times   are the order
statistics of  \emph{i.i.d.} random variables that are uniform on .
The \emph{p.d.f.} of the  order statistics is \cite[Chapter
2]{orderstatistics},

for .  Also the joint \emph{p.d.f.} of the  and 
order statistics (for ) is \cite[Chapter 2]{orderstatistics},

for . Later we will be interested in  the  conditional \emph{p.d.f.}   for . Using the above equations we can write ,

for  and .

\subsection{Single Hop Policy}\label{policy_sec}
Decision process begins at the instant  at which node 
gets the packet to forward. This is \emph{stage} .  The 
() decision instant is the time at which node  wakes up.\\
A \emph{\textbf{Single Hop (SH) policy }} is a sequence of
mappings , where
 and for 
.  should
also satisfy . The function 
maps the state at stage  to an action  (continue) or  (stop).  Let  and
 denote the delay incurred and progress made by node 
using policy .  Forwarding rules for node , using policy 
are as follows:
\begin{itemize}
\item At stage , node  has to wait for further nodes to wake up.
  We represent this by allowing the only \emph{state} at stage  to
  be  and the corresponding action to be to 
  (continue to wait) \emph{i.e.,} .
\item If , then wait for sink to wake up and transmit to
  it.  In this case, the delay and progress made are
   and  respectively.
\item Otherwise (\emph{i.e.,} if ), wait for the nodes in
   to wake up. When node  wakes up , evaluate  where . If , then transmit to the node
  . The delay incurred is
   and the progress made is . If
  , ask the node which makes the most progress so far to stay
  awake, put the other node to sleep and wait for further nodes to
  wake up.
\item The requirement  in the definition of
   ensures that node  transmits at or before the instant the
  last node wakes up.
\end{itemize}

Since the distribution of  are not
dependent on the value of , the average values of  and
 also do not depend on . Hence to compute these average
values we can, without loss of generality, take  and use
 and  to simplify the notation.

Let 
 represent the class of all SH policies.
Note that many policies are excluded from class .
  For instance, the policy which waits for all the
  nodes to wake up and then transmits to the one which makes least
  progress does not
  belong to the class . This is because for a policy in , transmission
  is allowed only to the  node that makes the most progress so far.
 We would like to explicitly mention two SH policies namely Max Forward (MF) and First Forward(FF):

\noindent
A node using \textbf{Max Forward} policy will wait for all the  nodes in its forwarding set to wake up and then transmit to the one which makes  most progress. We use  to represent this policy. For this policy,  if and only if . This policy obtains maximum delay and maximum progress  among all other policies in class .\\
A node using \textbf{First Forward} policy will always transmit to the
node in the forwarding set which wakes up first irrespective of the
progress made by it.  is used to represent this policy. For
this policy, .  obtains minimum
delay and minimum progress among all the policies in
class .

\section{Problem Formulation}
\label{problem_formulation}
From here on, without loss of generality we fix  and . Let
 (where ) denote the probability law conditioned
on the event  \emph{i.e.,}
. Similarly we define the
conditional expectation . Define
 and
, average progress made by the
MF and FF policies respectively.

Our interest in this work are, at a relay node  with , to
minimize the average delay subject to a constraint on the average
progress achieved.  More formally the problem is,

where . 

This formulation embodies the one-step tradeoff between the need to
forward the packet quickly while attempting to make substantial
progress towards the sink. The parameter  controls the
tradeoff. A large  indicates our desire to make large progress
in each step, which will come at a cost of a large one hop forwarding
delay.

To solve the problem in (\ref{SH1_prob}), we consider the following
unconstrained problem, 

Where .  Let  (Best Forward) be the optimal
solution for this problem.
\begin{lemma} \label{lem:conversion_to_mdp}
  For a given  in problem (\ref{SH1_prob}), suppose there is
  an  such that
  , then
   is optimal for the problem in
  (\ref{SH1_prob}) as well.
\end{lemma}
\begin{proof}
 Since  is optimal for the problem in (\ref{SH2_prob}), 

Therefore for any  such that , we have

\end{proof}
In the subsequent sections we focus on solving the problem in (\ref{SH2_prob}).


\section{Optimal Policy for the Exact Model}
\label{optimal_policy}
To solve the problem in (\ref{SH2_prob}), we develop it in a Markov
Decision Process (MDP) framework \cite{optimalcontrol}.
 is the state space (recall that
 and ).   is the terminating state.
 is the control space where  is for
\emph{stop} and  is for \emph{continue}. A small change to the
 defined earlier in section (\ref{policy_sec}), is the inclusion
of  in the domain of . Let  be the
state at stage  where  is the best (maximum) progress made by
the nodes waking up until stage  \emph{i.e.,}
. Conditioned on being in state
 at stage , transition to the next state depends on
 through  whose \emph{p.d.f.} is 
(Equation (\ref{condorderstat_equn})). The other disturbance component
, is independent of the . \emph{p.d.f.} of  is
 (Equation (\ref{distribution_equn})). We define the
conditional expectation,

\noindent
Then using expression (\ref{condorderstat_equn}) we can write,

\noindent
Initial state  and initial action  always.
Therefore the next state is  and the cost incurred at
stage  is .  If  is the
action taken at stage , then the next state 
is,

and the one step  cost  function is,

If the state at stage  is  then  and
 irrespective of .  Also if  is the state
of the system at the last stage, there is a cost of termination,
 given as,

The total average cost incurred with policy  is, 

The expectation in the cost function above is taken over the joint distribution of . Note that, 
 
 Therefore the optimal cost is,


Let  be the optimal cost to go when the system is in state
 at stage . When the stage is  (\emph{i.e.,}
all the nodes have woken up), then invariably transmission has to
happen. Therefore,

where, we define  for all . Next when there is
one more node to wake up (\emph{i.e.,} stage is ) then both actions,
 and  are possible. Therefore,

The terms in the  expression are the costs when 
(stop) and  (continue) respectively. Using the expression
for  in (\ref{extbell1_equn}) we obtain,

where,

The following lemma is obtained easily.
\begin{lemma}
For every , the following equations holds,

where,

\end{lemma}
\begin{proof}
Suppose for some  equations (\ref{optbellk_equn}) and
  (\ref{phik_equn}) holds, then following similar lines which was used
  to obtain  (\ref{extbell2_equn}) and (\ref{phiK_equn})
  (just replace  by ) we can show that 
  (\ref{optbellk_equn}) and (\ref{phik_equn}) holds for  as well.
  Since we have already shown that these equations hold for ,
  from induction argument we can conclude that it holds for every
  .
\end{proof}
\noindent
The structure of the optimal policy is given in the following corollary.

\begin{corollary}
  The optimal policy  is of the following form,

for . Where  for all  and for ,  is given in equation (\ref{phik_equn}).
\hfill 
\end{corollary}

\noindent
\emph{Remarks:} The optimal policy requires threshold functions  which are
computionally intensive. For our later numerical work in Section
(\ref{simulation_results}), we discretize the state space into
 equally spaced points and use the approximate values of the
functions  at these discrete points.

\section{Optimal Policy for a Simplified Model}
\label{suboptimal_policy}
The random variables  are identically distributed
\cite[Chapter 2]{orderstatistics} (but not independent). Their common
\emph{c.d.f.} is .  From Fig.~\ref{cdf_figu} we
observe that the \emph{c.d.f.} of  is close to that of
the \emph{c.d.f.} of an exponential random variable of parameter  and the
approximation becomes better for large values of . This motivates
us to consider a \emph{simplified model} where 
are distributed as \emph{Exponential(K)}. Further in our simplified
model we take these random variables to be independent.
\begin{figure}[ht]
\centering
\subfigure[]{
\includegraphics[scale=0.3]{cdf1.eps}
\label{cdf1}
}
\subfigure[]{
\includegraphics[scale=0.3]{cdf2.eps}
\label{cdf2}
}
\caption{The \emph{c.d.f.}'s   and  where  are plotted for \subref{cdf1}  and \subref{cdf2} .\label{cdf_figu}}
\end{figure}

For the simplified model, the cost function (similar to (\ref{extcostfunc_equn})) when the system is in state  at stage  is,

We observe that due to the \emph{i.i.d.} inter-wake time assumption the cost
function is not dependent on the value of . Also we need not
consider conditioning on  unlike in the previous section
since the \emph{p.d.f.} of  does not depend on .  Hence, the
optimal policy for this model is going to be independent of  for
each .  So we simplify the state space by ignoring the values of
 for each , \emph{i.e.,} the state space is
. Control space 
and the other disturbance component  remain the same.  Since
the state space is different, we make a small change to the definition
of policy  by allowing
.  The state
transition and cost functions remain same as in the previous section
with  replaced by . Let  represent the
optimal policy for this model.


Let  be the optimal cost to go at stage  when the state is
. Then, for all ,

Next when the stage is , for , 

where  is a function, which for  is given by, 
	
Here we have made use of the fact that
 and . The \emph{p.d.f.} of
 is given in (\ref{distribution_equn}).  Evidently, at
stage , the optimal action is to stop and transmit the packet if
 and to continue otherwise.
The following results about  can easily be obtained, the proof of which we provide in Appendix.
\begin{lemma}
  \label{lem:beta_properties}
  \begin{enumerate}
  \item  is continuous, increasing and convex in .
  \item If , then  for all .
  \item If , then there is a unique 
    such that .
  \item If , then  for
     and  for
    .
  \end{enumerate}
\hfill 
\end{lemma}
If , then define . Otherwise
 is defined by . Then

We proceed  to evaluate .

where,

\begin{lemma}
\label{beta2_lem}
	 for any . In particular, if  then .
\end{lemma}
\begin{proof}
  The first part follows easily because 
  . 
  Next, if
   then from Lemma~\ref{lem:beta_properties}, 
  , so that . Therefore,
	
\end{proof}
\begin{lemma}
For every   the following holds,

where, 

and has the property,  for any . In particular,
if  then .
\end{lemma}
\begin{proof}
Proof is along the lines  used to obtain Equations (\ref{expbell3_equn}), (\ref{beta2_equn}) and Lemma~\ref{beta2_lem}.
\end{proof}
\vspace{2mm}
\begin{corollary}
The  policy  is of the following form,\\  and

for . 
\hfill 
\end{corollary}

\noindent
\emph{Remarks:} The policy is a simple one-step-look-ahead rule where
at each   the policy compares the cost of stopping
at  () with the cost of continuing for one more step
and then stopping at 
. The policy is to stop
if  (simplification yields, stop if ),
continue otherwise.  The policy is to transmit to the first node which
makes a progress of more than . If all the nodes, make
progress of less than  then transmit to the node whose
progress is maximum at the instant the last node wakes up.
\section{Analytical Results}
\label{analytical_results}
In this section we apply the policy  obtained from the
simplified model to the actual model and  obtain  expressions for 
average progress and average delay incurred by node .  First we need 
some more notation. We abuse the notation  by allowing 
 .  
is the set of points that are closer to  the sink than  by atleast  (see Fig. \ref{forwardsetoverloaded_figu}).  When , we simply use   instead of . Let , where  denotes the area of the region .  is the conditional probability that a node falls in the region  conditioned on the event that the node belongs to .
\begin{figure}[ht]
\centering
\includegraphics[scale=0.5]{forward_set_overloaded.eps}
\caption{ and  are the locations of node  and sink
  respectively.  is the distance between them,  is the
  communication radius.   is the set of all points that
  are within the communication radius of node  and are closer to sink
  than  by atleast .  is the shaded region in the figure.
  \label{forwardsetoverloaded_figu}}
\end{figure}
\subsection{Average values for }
When using policy , node  transmits to the first node which makes a progress of more than . If there are  nodes in the  region , since the wake time of each of these is uniform on  and independent of each other, the average time until the first one wakes up is . If the region    is empty, then node  will wait for all the nodes in  to wake up and then transmit to the one which makes the maximum progress. In this case the average delay is . Therefore,
 
The expression for average progress can be written as,

When  then  the event  is same as the event that at least one node makes a progress of more than . 
Therefore for ,

When  then the event  is the same as the event that the region  is non-empty and the node to wake up first in this region makes a progress of more than , the probabilty of which is .
Therefore for ,

\subsection{Average Values for }
The policy  (First Forward) transmits to the node in the region  which wakes up first, irrespective of the progress made by it. Therefore,

Average progress is,

\subsection{Average Values for }
The policy  (Max Forward) always waits for all the nodes to wake up and then transmits to the node which makes the maximum progress. Therefore,

Average progress is given by, 

\section{Simulation Results}
\label{simulation_results}
\subsection{One Hop Performance}
We apply the policies  and  to the
actual model and obtain average progress and average one hop delay for
 and . Expressions for the average values for policies
,  and  were obtained in Section~\ref{analytical_results}.
 Since it is
difficult to obtain similar analytical expressions for policy
, we have performed simulations to obtain these
values.  In Figs.~\ref{progress_figu} and \ref{delay_figu} we plot
the average values as a function of .  The minimum and maximum
values of average delay and progress are achieved by  and
 respectively. From the figures we can observe that for
values of  less than  the
performance of  is same as . This is because
for  less than , we have , and therefore
the threshold used is  which is same as that used by
.

By using a large value of , a node will value progress more and
will end up waiting for better nodes to wake up thus incurring a large
delay as well. Hence, delay and progress for both the policies
( and ) are increasing with . We can
conclude from Lemma~\ref{lem:conversion_to_mdp}, that for each policy,
BF or SF, and a given , the corresponding delay value is the
minimum that can be obtained using that policy, subject to a
constraint on progress equal to the progress value obtained for that
.  These corresponding average delay vs.\ average progress values are shown in
Fig.~\ref{progdelay_figu}, for  and .  Each point on the
curve for each  corresponds to a different value of , which
increases along the curves as shown.  We see that the performance of
the  policy is close to that of the optimal BF policy, even for
small values of . The way  serves to trade-off one hop
progress and delay is clearly shown by these curves.

\begin{figure*}[t]
  \centering
\subfigure[]{
\includegraphics[scale=0.26]{one_hop_progress.eps}
        \label{progress_figu}
}
\subfigure[]{
\includegraphics[scale=0.26]{one_hop_delay.eps}
        \label{delay_figu} 
}
\subfigure[]{
\includegraphics[scale=0.26]{progress_vs_delay.eps}
\label{progdelay_figu}
}
\caption{One Hop Performance: \subref{progress_figu}: Average one hop progress 
  as a function of  for  various policies. The plots are for
   and . Maximum and minimum progress are achieved by
   and  respectively. \subref{delay_figu}: Average one hop delay
  as a function of  for  various
  policies. The plots are for  and . Maximum and minimum
  delay are achieved by  and . \subref{progdelay_figu}: Average one
  hop delay vs. the corresponding average one hop progress for the class of policies  and  are
  plotted for  and . The  parameter  controls the delay-progress trade-off. Each point
  on the curve corresponds to a different value of  which
  increases along the direction shown.}
\end{figure*}

\subsection{End to End Performance} \label{end_subsec} 

Although our policies have been developed for one-hop optimality, it
is interesting to study their end-to-end performance if they were
used, heuristically, at each hop.  We compare the end-to-end
performance of our policy with the work of Kim et
al.~\cite{kim-etal09optimal-anycast} who have developed end-to-end
delay optimal geographical forwarding in a setting similar to ours. We
first give a brief description of their work. They minimize, for a
given network, the average delay from any node to the sink when each
node  wakes up asynchronously with rate . They show that
periodic wake up patterns obtain minimum delay among all sleep-wake
patterns with the same rate. A relay node with a packet to forward,
transmits a sequence of beacon-ID signals. They propose an algorithm
called LOCAL-OPT \cite{kim-etal08tech-report} which yields, for each
neighbor  of node , an integer  such that if 
wakes up and listens to the  beacon signal from node  and if
, then  will send an ACK to receive the packet
from . Otherwise (if )  will go back to sleep. A
\emph{configuration phase} is required to run the LOCAL-OPT algorithm.

As before, we fix  and ~\emph{sec}. Each node wakes up
periodically with rate  but asynchronously.  To make a
fair comparision with the work of Kim et al.\ we introduce beacon-ID
signals of duration  \emph{msec} and packet transmission duration of
 \emph{msec}. We fix a network by placing  nodes randomly in  where .  is sampled from
\emph{Poisson()} where .  Additional source
and sink nodes are placed at locations  and 
respectively. Further we have considered a network where the
forwarding set of each node is non-empty.  The wake times of the
nodes are sampled independently from \emph{Uniform([0,1])}. Description of the policies that we have implemented is given below.

\noindent
\emph{}: We fix  as a network parameter.  Each relay
node chooses an appropriate  (in other words, chooses an appropriate threshold 
) such that the average one hop progress made 
using the policy  is equal to . Note 
that   depends on node  (\emph{i.e.,} on the values
of  and ). At a relay node  if  is less (greater) than 
the average progress made by  () then we allow node  to 
use  () to forward. When a node  wakes up and if it hears a beacon signal
from , it waits for the ID signal and then sends an ACK signal containing its location information. 
If the progress made by  is more than the threshold, then  forwards
the packet to  (packet duration is ~\emph{msec}). If the progress
made by  is less than the threshold, then  asks  to stay
awake if its progress is the maximum among all the nodes that have
woken up thus far, otherwise  asks  to return to sleep. If more
than one node wakes up during the same beacon signal, then contentions
are resolved by selecting the one which makes the most progress among
them. In the simulation, this happens instantly (as also for the Kim et al. algorithm that we compare with); in practice this will require a splitting algorithm; see, for example, \cite[Chapter 4.3]{bertsekas-gallager87data-networks}. We assume that within  \emph{msec} all these transactions
(beacon signal, ID, ACK and contention resolution if any) are over.
 and  can be thought of as special cases of
 with thresholds of  and  respectively.

\noindent
\emph{}: This is same as  except that here a
relay node does not know , but \emph{estimates} its value as
 nodes where  is the area of the region  (Equation~(\ref{area_equn})). If there is no eligible
node even after the  beacon signal (one case when
this is possible is when the actual number of nodes  is less than
 and none of the nodes make a
progress of more than the threshold) then  will select one which
makes the maximum progress among all nodes.

\noindent
\emph{Kim et al.}: We run the LOCAL-OPT algorithm
\cite{kim-etal08tech-report} on the network and obtain the values
 for each pair  where  and  are neighbors. We
use these values to route from source to sink in the presence of sleep
wake cycling. Contentions, if any, are resolved (instantly, in the simulation) by selecting a node
 with the highest  index.

\begin{figure}
	\centering 
	\includegraphics[scale=0.5] {end_performance.eps}
	\caption{End-to-end performance: Plot of average end-to-end delay vs. average end-to-end hop count when the 
          one hop optimal policy for the progress constraint  is used at each hop.
          The  operating points of the policies ,  and Kim et al.
          are also shown in the figure. Each point on the curve
          corresponds to a different value of  which increases
          along the direction shown. \label{endperformance_figu}}
\end{figure}

In Fig.~\ref{endperformance_figu} we plot average total delay vs.
average hop count for different policies for fixed node placement, while the averaging is over the wake
times of the nodes. Each point on the curve is obtained by averaging  over 1000 transfers of the packet from the source node to the sink.
 As expected, Kim et al.  achieves minimum average delay.
In comparision with , Kim et al. also achieves smaller
average hop count. Notice, however that using  policy and properly choosing
, it is possible to obtain hop count similar to that of Kim et
al., incurring only slightly higher delay. 

The advantage of 
over Kim et al. is that there is \emph{no need for a configuration phase}.
Each relay node has to only compute a threshold that depends on the
parameter  which can be set as a network parameter during
deployment. A more interesting approach would be to allow the source
node to set  depending on the type of application. For delay
sensitive applications it is appropriate to use a smaller value of
 so that the delay is small, whereas, for energy constrained
applications (where the network energy needs to conserved) it is
better to use large  so that the number of hops (and
hence the number of transmissions) is reduced. For other applications, moderate
values of  can be used.  can be a part of the ID signal so
that it is made available to the next hop relay.

Another interesting observation from Fig.~\ref{endperformance_figu} is
that the performance of  is close to that of
. In practice it might not be reasonable to expect a node to
know the exact number of relays in the forwarding set.
 works with average number of nodes instead of the
actual number. For small values of  both the policies 
and , most of the time, transmit to the first node to
wake up.  Hence the performance is similar for small .  For
larger , we observe that the delay incurred by  is larger.

\section{Summary and Future Work}\label{conclusion}

The problem of optimal relay selection for geographical forwarding was
formulated as one of minimizing the forwarding delay subject to a
constraint on progress.  The simple policy (SF)  of
transmitting to the first node that wakes up and makes a progress of
more than a threshold was found to be close in performance to the
optimal policy.  We then compared the end-to-end performance (average
delay and average hop count) of using SF at each relay node
enroute to the sink with that of the policy proposed by Kim et
al.~\cite{kim-etal09optimal-anycast}, which is designed to achieve
minimum average end-to-end delay. However, the delay obtained by the
 policy in \cite{kim-etal09optimal-anycast}  is only a little smaller than that obtained by the
FF policy.  Further, by using the SF policy with a
appropriate , performance very close to that of the policy in \cite{kim-etal09optimal-anycast}
can be obtained without the need for an initial global configuration
phase.  We note that  is self-configuring; each node takes
decisions based only on local information. The end-to-end performance
obtained can be tuned by the use of a single parameter .  For
a small  we obtain low end-to-end delay but the number of hops
is large and vice versa.

In this work we have assumed that each node knows the number of
neighbors in its forwarding set. We had given a heuristic policy
 when the actual number of forwarding neighbors is not
known. In future work we aim to obtain optimal forwarding policies by
relaxing this assumption. Also, the use of a one-hop optimal policy
for end-to-end forwarding is  a heuristic. In future work we
propose to directly formulate the end-to-end problem and derive
optimal policies. In addition, we could also include aspects such as
the relay's link quality  in our formulation.


\bibliographystyle{IEEEtran}
\bibliography{IEEEabrv,related_work}


 \appendix[Proof of Lemma \ref{lem:beta_properties}]
 \noindent
 \begin{proof}[Proof of \ref{lem:beta_properties}.1]
 Recall from Equation (\ref{beta1_equn}) that 
 
 Let  represent the  of . For  , the  of  is,
 
 
   and  implies that  is continuous, increasing and convex in .
 \end{proof}
 \vspace{2mm}
 \begin{proof}[Proof of \ref{lem:beta_properties}.2]
 Since ,  and  , we have  . 
 Also  is convex (from \emph{Lemma} \ref{lem:beta_properties}.1). Hence we can write,
 
 \end{proof}
 \vspace{2mm}
 \begin{proof}[Proof of \ref{lem:beta_properties}.3]
   Let . Then,  and
    (because ). Also  is continuous (being differentiable) on
   . Hence,  an  such that
   .

 Suppose  an  such that
 . Then by convexity of 
 (from \emph{Lemma} \ref{lem:beta_properties}.1),
 
  . Contradicts the fact that, .
 \end{proof}
 \vspace{2mm}
 \begin{proof}[Proof of \ref{lem:beta_properties}.4]
   Again consider .  is continuous (being
   differentiable) on .  Suppose  
   such that , then  and . This implies that
     in  such that . Contradicts the
   uniqueness of  shown in \emph{Lemma} \ref{lem:beta_properties}.3.  Similarly
   it can be shown that  for .
 \end{proof}
\end{document}
