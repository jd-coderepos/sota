









\documentclass[10pt,journal,cspaper,compsoc]{IEEEtran}
\pdfoutput=1


\usepackage{graphicx}
\usepackage{color}

















\ifCLASSOPTIONcompsoc
\else
\fi






\ifCLASSINFOpdf
\else
\fi































































\hyphenation{op-tical net-works semi-conduc-tor}


\begin{document}
\title{A Practical, Secure, and Verifiable Cloud Computing for Mobile Systems}


\author{Sriram~N.~Premnath, Zygmunt~J.~Haas,~\IEEEmembership{Fellow,~IEEE}\IEEEcompsocitemizethanks{\IEEEcompsocthanksitem S.N. Premnath is with the School
of Electrical and Computer Engineering, Cornell University, Ithaca,
NY, 14853.\protect\\
E-mail: sriram.np@cornell.edu
\IEEEcompsocthanksitem Z.J. Haas is with the School of Electrical and Computer Engineering, Cornell University, Ithaca, NY, 14853, and Department of Computer Science, University of Texas at Dallas, Richardson, TX 75080.\protect\\
E-mail: haas@ece.cornell.edu}\thanks{}}





\markboth{IEEE TRANSACTIONS ON CLOUD COMPUTING,~Vol.~x, No.~x, January~20xx}{Premnath \MakeLowercase{\textit{et al.}}: A Practical, Secure, and Verifiable Cloud Computing for Mobile Systems}









\IEEEcompsoctitleabstractindextext{\begin{abstract}
Cloud computing systems, in which clients rent and share computing resources of third party platforms, have gained widespread use in recent years. Furthermore, cloud computing for mobile systems (i.e., systems in which the clients are mobile devices) have too been receiving considerable attention in technical literature. We propose a new method of delegating computations of resource-constrained mobile clients, in which multiple servers interact to construct an encrypted program known as garbled circuit. Next, using garbled inputs from a mobile client, another server executes this garbled circuit and returns the resulting garbled outputs. Our system assures privacy of the mobile client's data, even if the executing server chooses to collude with all but one of the other servers. We adapt the garbled circuit design of Beaver et al. and the secure multiparty computation protocol of Goldreich et al. for the purpose of building a secure cloud computing for mobile systems. Our method incorporates the novel use of the cryptographically secure pseudo random number generator of Blum et al. that enables the mobile client to efficiently retrieve the result of the computation, as well as to verify that the evaluator actually performed the computation. We analyze the server-side and client-side complexity of our system. Using real-world data, we evaluate our system for a privacy preserving search application that locates the nearest bank/ATM from the mobile client. We also measure the time taken to construct and evaluate the garbled circuit
for varying number of servers, demonstrating the feasibility of our secure and verifiable cloud computing for mobile systems.\vspace{-2 mm}
\end{abstract}


\begin{keywords}
Secure Cloud Computing, Garbled Circuits, Secure Multiparty Computation
\end{keywords}}


\maketitle


\IEEEdisplaynotcompsoctitleabstractindextext



\IEEEpeerreviewmaketitle


\section{Introduction}
\label{sec_introduction}

\IEEEPARstart{C}{loud} computing systems, in which the clients rent and share computing resources of third party platforms such as Amazon Elastic Cloud, Microsoft Azure, etc., have gained widespread use in recent years. Provisioned with a large pool of hardware and software resources, these cloud computing systems enable clients to perform computations on a vast amount of data without setting up their own infrastructure \cite{armbrust10}. However, providing the cloud service provider with the client data in {\em plaintext form} to carry out the computations will result in complete loss of data privacy.


Homomorphic encryption \cite{rivest78} is an approach to tackle the problem of preserving data privacy, which can allow the cloud service providers to perform specific computations directly on the encrypted client data, without requiring private decryption keys. Recently, fully homomorphic encryption (FHE) schemes (e.g., Gentry et al. \cite{gentry10}) have been proposed, which enable performing any arbitrary computation on encrypted data. {\em However, FHE schemes are currently impractical for mobile cloud computing applications due to \underline{extremely large cipher text size}}. For instance, to achieve -bit security, the client is required to exchange a few Giga bytes of ciphertext with the cloud server, for each bit of the plain text message \cite{gentry10}. {\em Thus, there is a need for a more efficient alternative suitable for mobile systems.}


Yao's garbled circuits approach \cite{yao82,yao86}, which we consider in our work, is a potential alternative to FHE schemes that can drastically reduce the ciphertext size. Any computation can be represented using a Boolean circuit, for which, there exists a corresponding garbled circuit \cite{yao82,yao86,goldreich04,goldreich87}. Each gate in a garbled circuit can be unlocked using a pair of input {\em wire keys} that correspond to the underlying plaintext bits; and the association between the wire keys and the plaintext bits is kept secret from the cloud server that performs the computation. Unlocking a gate using a pair of input wire keys reveals an output wire key, which, in turn, serves as an input wire key for unlocking the subsequent gate in the next level of the circuit. Thus, garbled circuits can enable {\em oblivious evaluation} of any arbitrary function, expressible as a Boolean circuit, on a third-party cloud server.


While garbled circuits preserve the privacy of client data, they are, however, one time programs -- using the same version of the circuit more than once compromises the garbled circuit and reveals to an adversarial evaluator whether the semantics have changed or remained the same for a set of input and output wires between successive evaluations. Expecting the client to create a new version of the garbled circuit for each evaluation, however, is an unreasonable solution, since creating a garbled circuit is at least as expensive as evaluating the underlying Boolean circuit! {\em Thus, in contrast to FHE schemes such as that of Gentry \cite{gentry10}, that can directly delegate the desired computation to the cloud servers, a scheme using garbled circuits, presents the additional challenge of efficiently delegating to the cloud servers the creation of garbled circuit.}


We propose a new method, in which whenever the client needs to perform a computation, the client employs a number of cloud servers to create a new version of the garbled circuit in a distributed manner. Each server generates a set of private input bits using unique seed value from the client and interacts with all the other servers to create a new garbled circuit, which is a function of the private input bits of all the servers. Essentially, the servers engage in a secure multiparty computation protocol (e.g., Goldreich et al. \cite{goldreich04,goldreich87}) to construct the desired garbled circuit without revealing their private inputs to one another. Once a new version of the garbled circuit is created using multiple servers, the client delegates the evaluation to an arbitrary server in the cloud. The resulting version of the garbled circuit, the garbled inputs that can unlock the circuit, and the corresponding garbled outputs, remain unrecognizable to the evaluator, even if it chooses to collude with any strict-subset of servers that participated in the creation of the garbled circuit.


Our proposed system is designed to readily exploit the real-world asymmetry that exists between typical mobile clients and cloud servers -- while the mobile client-s are resource constrained, the cloud servers, on the other hand, are sufficiently provisioned to perform numerous intensive computation and communication tasks. To achieve secure and verifiable computing capability, our system requires very little computation and communication involvement from the mobile client beyond the generation and exchange of \underline{\em compact cipher text messages}. However, using significantly larger resources available to them, the cloud servers can efficiently generate and exchange a large volume of random bits necessary for carrying out the delegated computation. Thus, our proposed scheme is very suitable for mobile environments\footnote{While our proposed system is especially beneficial for clients in a mobile environment, due to compact cipher text messages, it is also suitable for clients in other environments that need to delegate its computations to the cloud servers in a secure manner.}.





We adapt the garbled circuit design of Beaver, Micali, Rogaway (BMR \cite{beaver90,rogaway91}), and the secure multiparty computation protocol of Goldreich et al. \cite{goldreich04,goldreich87} to suit them for the purpose of building a secure cloud computing system. To facilitate the construction of the garbled circuit, and also to enable the client to {\em efficiently retrieve and verify the result of the computation}, our method incorporates the novel use of the cryptographically secure pseudo random number generator of Blum, Blum, Shub \cite{blum86,schneier95}, whose strength relies on the computational difficulty of factorizing large numbers into primes. {\em Our proposed system enables the client to efficiently verify that the evaluator actually and fully performed the requested computation.}


Our major contributions in this work include the following: (i) we design a secure mobile cloud computing system using multiple servers that enables the client to delegate any arbitrary computation, (ii) our system assures the privacy of the client input and the result of the computation, even if the evaluating server colludes with all but one of the servers that created the garbled circuit, (iii) our system enables the client to efficiently retrieve/recover the result of the computation and to verify whether the evaluator actually performed the computation, (iv) we present an analysis of the server-side and client-side complexity of our proposed scheme. Our findings show that in comparison to Gentry's FHE scheme, our scheme uses very small cipher text messages suitable for mobile clients, (v) using real-world data, we evaluate our system for a privacy preserving search application that locates the nearest bank/ATM from the mobile client, and (vi) we measure the time taken to construct and evaluate the garbled circuit for varying number of servers, demonstrating the feasibility of our system.\vspace{-2 mm}


 \section{A High-level Overview of our\\ System}


In the proposed system, the client employs a set of  servers, . Initially, the client sends a description of the desired computation (such as addition of two numbers, computation of hamming distance between two bit sequences, etc.), and a unique seed value  to each server . Each of these  servers first creates (or retrieves from its repository, if available already) a Boolean circuit () that corresponds to the requested computation. Using the unique seed value , each server  generates a private pseudorandom bit sequence whose length is proportional to the total number of wires in the Boolean circuit (). Then, using the private pseudorandom bit sequences and the Boolean circuit () as inputs, these  servers interact with one another, while performing some local computations, according to a secure multiparty computation protocol, to create their shares () for an one-time program called garbled circuit.


Once the shares for the garbled circuit are created, the client requests each server, , to send its share, , to the server . Performing an XOR operation on these shares, the server  creates the desired circuit, . Subsequently, the client instructs the server  to send the garbled circuit  to another server  for evaluation.



Now, using the unique seed values , the client generates on its own garbled input values for each input wire in the circuit and sends them to the server  for evaluation. Using these garbled inputs, the server  unlocks the gates in the first level of the circuit to obtain the corresponding garbled outputs, which, in turn, unlocks the gates in the second level of the circuit, and so on. In this manner, the server  unlocks all the gates in the circuit, obtains the garbled outputs of the circuit, and sends them to the client. The client now converts these garbled output values into plaintext bits to recover the result of the desired computation.


\begin{figure}[t]
\centering
\includegraphics[width=3.25in]{Our_Secure_Cloud_Computing_System_Model_Ver5.pdf}
\vspace{-3 mm}
\caption{Our secure cloud computing model with  servers. 1.) Client sends unique seed value, , to each ; 2.)  interact () to construct shares of the garbled circuit ; 3.) Each  sends its share () to ; 4.)  computes , and sends it to ; 5.) Client generates garbled inputs, and sends them to ; 6.)  evaluates , and sends the garbled outputs to the client.\vspace{-4 mm}}
\label{fig_our_secure_cloud_computing_Model}
\end{figure}


Fig.~\ref{fig_our_secure_cloud_computing_Model} depicts an overview of our secure cloud computing system model with  servers.


\subsection{Our Adversary Model}
\label{sec_adversary_model}

We assume the existence of a secure communication channel between the client and each of the  servers, , for sending unique seed values for pseudorandom bit generation, identity of the other servers, etc. We assume that all pairs of communicating servers authenticate one another. We assume a very capable adversary, where the evaluator  may individually collude with any proper subset of the  servers, , and still remain unable to determine the semantics of any garbled value that the evaluator observes during evaluation. Thus, our adversary model depicts a very realistic scenario -- where the client may be certain that some (however, not all) of the parties are corrupt, however, it is uncertain which of the parties are corrupt. If any adversarial party attempts to eavesdrop and analyze the set of all message exchanges between different parties, and also analyze the set of all the messages that it has legitimately received from the other parties, it still cannot determine the shares of the other parties, or the semantics of the garbled value pairs that are assigned to each wire in the circuit. Further, if the evaluator, , returns arbitrary numbers as outputs to the client, the client can detect this efficiently. In our model, a new garbled circuit is created for every evaluation. This prevents an adversarial evaluator from determining the set of inputs and outputs that have changed or remained the same between different evaluations.


\subsection{Main Characteristics of our system}
\label{sec_features_of_our_secure_cloud_computing_model}
We highlight some of the main features of our secure cloud computing system in this subsection.
\begin{enumerate}
    \item{{\em Offloaded Computation}: The client delegates the intensive computational tasks to the cloud servers of creating and evaluating the garbled circuit. The client only chooses the cloud servers, provides them with unique seed values, generates garbled inputs during evaluation, and interprets garbled outputs returned by the evaluator.}

    \item{{\em Compact cipher text}: While Gentry's scheme has an extremely large cipher text size (on the order of several Gigabits), the cipher text size can be as small as a few hundred bits with our scheme, as we have shown in Section~\ref{}. Thus, our proposed method is far more practical for cloud computing in mobile systems in comparison to FHE schemes.}

    \item{{\em Decoupling}: The process of creating the garbled circuit is decoupled from the process of evaluating the garbled circuit. While the servers, , interact with one another for creating the garbled circuit, the server  evaluates the garbled circuit, {\em independently}.}

    \item{{\em Precomputation of garbled circuits}: Since evaluation of the garbled circuit requires no interaction among the servers, if several versions of the garbled circuit for a given computation are precomputed and stored at the evaluator, {\em in advance}, then it can readily carry out the requested computation. {\em Thus, the client will only incur the relatively short time taken to evaluate the garbled circuit. In other words, precomputation will drastically improve the response time for the client.}}

    \item{{\em Collusion Resistance}: To interpret any garbled value, the evaluator, , would need to collude with all the  servers, . Thus, even if  out of the  servers are corrupt and collude with the evaluator, the privacy of the client's inputs and the result of the computation are still preserved.}

    \item{{\em Verification of outputs}: The client has the ability to verify that the evaluator actually carried out the requested computation. }
\end{enumerate}

 \section{Background}
\label{sec_background}
We briefly describe the construction and evaluation of Yao's garbled circuits \cite{yao82,yao86}, as well as the oblivious transfer protocols of Naor and Pinkas \cite{naor01,naor05}.


\subsection{Yao's Garbled Circuit}

\begin{figure}[ht]
\centering
\includegraphics[width=2.4in]{Figure_Yao_Circuit_3_Gates_for_Paper.pdf}
\vspace{-3 mm}
\caption{A circuit with three gates, , and seven wires, .\vspace{-3 mm}}
\label{fig_sample_circuit}
\end{figure}


Each wire in the circuit is associated with a pair of keys known as {\em garbled values} that correspond to the underlying binary values. For example, the circuit in Figure~\ref{fig_sample_circuit} has seven wires, , and three gates, , denoting OR, AND, XOR gates respectively. Keys ,  represent the garbled values corresponding to binary values ,  respectively on the wire .


\begin{table}[!t]
\renewcommand{\arraystretch}{1.3}
\caption{Garbled Tables for Gates .}
\label{table_garbled_tables}
\centering
\begin{tabular}{||c||c||c||}
\hline
\bfseries P & \bfseries Q & \bfseries R\\
\hline
 &  & \\
 &  & \\
 &  & \\
 &  & \\
\hline
\end{tabular}
\vspace{-3 mm}
\end{table}


Each gate in the circuit, is associated with a list of four values, in a random order, known as {\em garbled table}. Table~\ref{table_garbled_tables} shows the garbled tables for the gates  of Fig.~\ref{fig_sample_circuit}. Let . Let  denote the encryption of  using  as the key. Then, each entry in the garble table for  is of the form, . Similarly, each entry in the garble table for  and  are of the forms,  and , respectively.


Suppose that the client wishes to delegate the computation of Fig.~\ref{fig_sample_circuit}, i.e., , to a server in the cloud. The server is provided with a description of the circuit (Fig.~\ref{fig_sample_circuit}) along with the set of the garbled tables (Table~\ref{table_garbled_tables}), which together represents a {\em garbled circuit}. However, the client keeps the mapping between the garbled values and the underlying binary values as secret. For example, to evaluate the circuit with inputs , the client provides the set of garbled inputs, , to the cloud server.


Now, assume that there exists a mechanism to determine whether a value is decrypted correctly; for example, through zero-padding. Using  as keys, the server attempts to decrypt all the four entries in the garbled table for gate ; however, only the fourth entry will decrypt correctly to reveal the garbled output . Similarly, on using  as keys, the first entry in the garbled table for gate  reveals the garbled output . Finally, on using  as keys, the third entry in the garbled table for gate  reveals the garbled output . Thus, the server can perform an {\em oblivious evaluation} of the garbled circuit and return the result of the computation  to the client. Using the secret mapping, the client can determine that the garbled value  corresponds to the binary value .


In our work, we use an alternative garbled circuit design from Beaver, Micali, Rogaway (BMR \cite{beaver90,rogaway91}), and adapt it, as we describe in Section~\ref{sec_our_cloud_computing_model}, for the purpose of building a secure cloud computing system.


\subsection{1-out-of-2 Oblivious Transfer}
\label{sec_1_out_of_2_OT}
There are two parties, a sender and a chooser. The sender holds two messages, , and the chooser holds a choice bit, . At the end of the 1-out-of-2 oblivious transfer (OT) protocol, the chooser learns  only, while the sender learns nothing.


Let  denote a safe prime number; i.e.,  is also a prime number. Let , which denotes the set of integers that are relatively prime to . Let  denote a subgroup of , where . Let  denote the generator for .


The sender randomly chooses an element, , and sends it to the chooser. Note that the discrete logarithm of  is unknown to the chooser. The chooser randomly selects an integer, , and sets , and . The chooser sends  to the sender. Note that  does not reveal the choice bit  to the sender.


The sender calculates  on its own, and randomly chooses two elements, . Let  denote the output of the hash function (e.g., SHA) on input . Let  denote the encryption of , . Then, the sender calculates , and sends both ,  to the chooser.


The chooser decrypts  to obtain  as follows. Let  and  denote the first and second numbers respectively in . The chooser calculates  using the relation, . Note that since the discrete logarithm of , and hence , is unknown to the chooser, it cannot retrieve  from .


\subsection{1-out-of-4 Oblivious Transfer}
\label{sec_1_out_of_4_OT}

There are two parties, a sender and a chooser. The sender holds four messages, , , , , and the chooser holds two choice bits, . At the end of the 1-out-of-4 oblivious transfer (OT) protocol, the chooser learns  only, while the sender learns nothing.


The sender randomly generates two pairs of keys, , and computes the encryptions of , , ,  as follows. Let  denote the output of a pseudorandom function such as AES-128, that is keyed using  on the input . Let  denote the encryption of , . Then, .


The sender and the chooser engage in 1-out-of-2 OT twice. In the first 1-out-of-2 OT, the sender holds two messages, , and the chooser holds the choice bit, ; at the end of this OT, the chooser obtains . In the second 1-out-of-2 OT, the sender holds two messages, , and the chooser holds the choice bit, ; at the end of this OT, the chooser obtains .


Now, the sender sends all the four encryptions, , , , , to the chooser. Using , , the chooser decrypts  to obtain , as .

 \section{Secure and Verifiable Cloud Computing for Mobile Systems}
\label{sec_our_cloud_computing_model}

In Section~\ref{sec_garbled_circuit_BMR}, we present the construction of BMR garbled circuit \cite{beaver90,rogaway91} using  servers through the secure multiparty computation protocol of Goldreich et al. \cite{goldreich04,goldreich87}. In Section~\ref{sec_key_changes_to_BMR_Goldreich}, we highlight how we adapt the protocol of Goldreich and the garbled circuit design of BMR, in order to suit them for our secure cloud computing model. In our model, each server , generates shares of garbled values using cryptographically secure pseudorandom number generation method of Blum, Blum, Shub \cite{blum86,schneier95}. In Section~\ref{sec_output_verification}, we present our method of how the client efficiently recovers the result of the delegated computation, as well as how the client verifies that the evaluator in fact carried out the computation. We summarize our secure cloud computing model in Section~\ref{sec_our_secure_cloud_computing_model_summary}.


\subsection{Construction and Evaluation of Garbled Circuits}
\label{sec_garbled_circuit_BMR}


\subsubsection{Construction of the garbled circuit, }
\label{sec_garbled_circuit_BMR_construction}

\underline{\em Garbled Value Pairs:} Each wire in the circuit is associated with a pair of garbled values representing the underlying plaintext bits  and . Let  denote a specific gate in the circuit, whose two input wires are ; and whose output wire is . Let ,  and  denote the pair of garbled values associated with the wires ,  and , respectively. Note that  and .


Each garbled value is  bits long, where  denotes the number of servers and  denotes the security parameter. Essentially, each garbled value is a concatenation of shares from the  servers. Let . Then the garbled values are expressed as follows: ; ; ; where , ,  are shares of server .


\underline{\em  Value:} Each wire in the circuit is also associated with a -bit  value that determines the semantics for the pair of garbled values. Specifically, the garbled value whose  represents the underlying plaintext bit .


\underline{\em Collusion Resistance:} Let  denote the  values for the wires  respectively. Then, , , , where  are shares of server . Note that the  value of each wire is unknown to any individual server. Consequently, the evaluator of the garbled circuit must collude with all the  servers to interpret the garbled values.


\underline{\em Garbled Table:} Each gate, , in the circuit, is associated with an ordered list of four values, , which represents the garbled table for gate . Let  denote the binary operation of gate . Then, the value of one specific entry, , where  and  are pseudorandom functions that expand  bits into  bits. Specifically, let  denote a pseudorandom generator, which on providing a -bit input seed, outputs a sequence of  bits, i.e., if , then .  may represent the output of AES block cipher in output feedback mode, for example. Then,  and  denote the first and last  bits of  respectively.


To compute a garbled table entry , such as the one shown above, the  servers use the secure multiparty computation protocol of Goldreich \cite{goldreich04,goldreich87} (Section~\ref{sec_secure_multiparty_construction_Goldreich}), where , and for each server, , its private input,  is a vector of length  bits. In this manner, the  servers jointly compute each entry in the garbled table for each gate in the circuit.



\subsubsection{Secure multiparty computation of an entry, }
\label{sec_secure_multiparty_construction_Goldreich}

Assume that  parties need to compute the value of an arbitrary function of their private inputs, namely  without revealing their private inputs to one another. Assume that the function  is expressed as a Boolean circuit ()\footnote{Boolean circuit  is different from Boolean circuit . While  is a circuit that corresponds to the computation requested by the client (e.g., addition of two numbers),  is a circuit that creates the entries such as  in the garbled tables of the garbled circuit .} using a set of XOR and AND gates.


We briefly describe the secure multipary computation protocol of Goldreich \cite{goldreich04,goldreich87} as follows. For each wire in the Boolean circuit, the actual binary value corresponds to the XOR-sum of shares of all the  parties.


Evaluation of each XOR gate in the circuit is carried out locally. Specifically, each party merely performs an XOR operation over its shares for the two input wires to obtain its share for the output wire.


Evaluation of each AND gate in the circuit, on the other hand, requires communication between all pairs of parties. For the two inputs wires to the AND gate, let  denote the shares of party ; and let  denote the shares of party . Then, the XOR-sum of the shares for the output wire of the AND gate is expressed as follows:

, where   .


Each party  locally computes ; and the computation of each {\em partial-product}, , is accomplished using 1-out-of-4 oblivious transfer (OT) between  and , such that no party reveals its shares to the other party \cite{goldreich04,goldreich87}.


Following the above procedure, the  parties evaluate every gate in the circuit. Thus, in the end, for the BMR protocol, as we have described above,  each server , obtains the share, , such that .


\subsubsection{Evaluation of the garbled circuit, }
\label{sec_garbled_circuit_BMR_evaluation}

The garbled table for each gate, , in the circuit is an ordered list of four values, .


Let  denote the garbled values for the two input wires of a gate during evaluation. Let  denote the LSB values of  respectively. Then, the garbled value for the output wire, , is recovered using , as shown in the two-step process below:

\begin{enumerate}
    \item{split the most significant  bits of  into  parts, , each with  bits; similarly, split the most significant  bits of  into  parts, , each with  bits; i.e., , where .}

    \item{compute .}\end{enumerate}

Thus, the garbled output for any gate in the circuit can be computed using the garbled table and the two garbled inputs to the gate. Note that while the construction of the garbled circuit requires interaction among all the  parties, , the server  can perform the evaluation {\em independently}.


\subsection{Secure and Verifiable Cloud Computing through Secure Multiparty Computation}
\label{sec_key_changes_to_BMR_Goldreich}

In a secure multiparty computation protocol, multiple parties hold private inputs, and receive the result of the computation. However, in our proposed secure cloud computing system, while multiple parties participate in the creation of garbled circuits, only the client holds private inputs and obtains the result of the computation in garbled form. {\em Therefore, we adapt the protocols of Goldreich and BMR in a number of ways, as we discuss in this section, to build an efficient, secure cloud computing system, that also enables the client to easily verify the outputs of the computation.}


First, note that in the protocol of Goldreich \cite{goldreich04,goldreich87}, each party  sends its share  to {\em all the other parties}. Using these shares, each party computes  as . In our secure cloud computing system, however, we require each server , to send its share to {\em only one server}, , which combines them using the XOR operation to produce entries such as  for each garbled table in the garbled circuit, .


Second, in the BMR protocol \cite{beaver90,rogaway91}, which is also a secure multiparty computation protocol, in addition to creating the garbled circuit, for evaluation, the  parties also create garbled inputs using secure multiparty computation. Then, {\em each of these  parties evaluates the garbled circuit and obtains the result of the computation}. In our system model, since only the client holds the inputs for the computation, it generates the corresponding garbled input for each input wire on its own using the seed values it sends to each server, . Then, it sends these garbled values to server  for evaluating the garbled circuit and obtains the result in garbled form. Note that in our model, {\em only the server  evaluates the garbled circuit, and
that  cannot interpret any garbled value, unless it colludes with all the  servers, }.


Third, in the BMR protocol \cite{beaver90,rogaway91}, the  value is set to zero for each output wire in the Boolean circuit. Therefore, each party evaluating the garbled circuit obtains the result of the computation in plaintext form from the LSB of the garbled output for each output wire in the circuit. In our system model, however, the  value for each output wire is also determined using the XOR-sum of the shares from all the  servers, . {\em As a consequence, result of the computation in plaintext form remains as secret for the evaluator }.


Fourth, in the protocol of Goldreich \cite{goldreich04,goldreich87}, each party splits and shares each of its private input bits with all the other parties over pairwise secure communication channels. In our approach, we eliminate this communication using a unique seed value  that the client shares with all pairs of parties, . To split and share each of its  private input bits , party  generates , using the seed value . More specifically, party  sets its own share as , where  corresponds to the output of the pseudorandom bit generator using the seed value  for the  private input bit of party , for a specific garbled table entry () of one of the gates () in the circuit. Likewise, party  sets its own share as . The total number of pseudorandom bits generated by each party for the protocol of Goldreich equals , where , and  denotes the total number of gates in the circuit. {\em In other words, our approach eliminates the exchange of a very large number of bits ( bits) between the  parties.}


Fifth, our novel use of the Blum, Blum, Shub pseudorandom number generator for generating garbled value shares {\em enables the client to efficiently recover and verify the outputs of the computation}. The client can detect a {\em cheating evaluator}, if it returns arbitrary values as output. We present this in a greater detail in Section~\ref{sec_output_verification}.\vspace{-1 mm}


\subsection{Recovery and Verification of Outputs}
\label{sec_output_verification}

We address the following questions in this subsection. {\em First, how does the client efficiently retrieve/recover the result of the computation without itself having to repeat the delegated computations? Second, how does the client verify that the evaluator, in fact, evaluated the garbled circuit? In other words, is it possible for the client to determine whether the evaluator returned arbitrary numbers without carrying out any computation at all, instead of the actual garbled output for each output wire?}


We can enable the client to efficiently retrieve and verify the outputs returned by the evaluator, . To achieve this, each of the  parties that participates in the creation of the garbled circuit uses the cryptographically secure Blum, Blum, Shub pseudorandom number generator \cite{blum86,schneier95}, as we have outlined below.


Let  denote the product of two large prime numbers, , which are congruent to   . The client chooses a set of  seed values, , where each seed value  belongs to , the set of integers relatively prime to . The client sends the modulus value  and a unique seed value  to each party  over a secure communication channel. However, the client keeps the prime factors, , of  as a secret.


Let  denote the  bit generated by the party . Then, , where   , and .


Each wire  in the circuit is associated with a pair of garbled values, , and a -bit  value. Then, , ; and . In these three expressions,  and  are shares of the party . Note that , and .


For each wire , in the circuit, each party, , needs to generate  pseudo random bits, where  denotes the total number of wires in the circuit. Thus, each party, , generates a total of  pseudorandom bits.


Party  generates its shares  and  for wire  as a concatenation of the  values, where the indices  belong to the range: . For concise notation, let . Then,


,


,


.


\underline{\em Short-cut:} Notice that each party  is required to compute all the previous  bits before it can compute the  bit. However, using its knowledge of the prime factors of , i.e., , the client can directly calculate any  (hence, the bit ) using the relation: , where  denotes the {\em Carmichael function}, which equals the least common multiple of  and .


{\em Therefore, using the secret values , the client can readily compute  and  for any output wire  in the circuit; i.e., without having to compute  and  for any intermediate wire in the circuit. Using the  values for the output wires, the client can translate each of the garbled values returned by the evaluator  into a plaintext bit and recover the result of the requested computation. The client declares successful output verification only if the garbled output returned by the evaluator matches with either  or , for each output wire  of the circuit.}


\underline{\em Collusion Resistance:} Note that, without performing any computation, the evaluator can return one of the two actual garbled outputs for each output wire in the circuit, if and only if it colludes with all the  servers, , that participated in the creation of the garbled circuit, or factorizes  into its prime factors,  and , which is infeasible.


\underline{\em Unpredictability:} Further, the Blum, Blum, Shub pseudorandom number generator guarantees that one cannot predict the next/previous bit output from the generator, even with the knowledge of all the previous/future bits \cite{blum86,schneier95}. Thus, based on the observations of the garbled values during evaluation, the evaluator cannot predict the preceding or subsequent garbled values, or the  values for any wire in the circuit.


\subsection{Summary of our Proposed System}
\label{sec_our_secure_cloud_computing_model_summary}
We summarize our secure cloud computing model in this subsection.

\begin{enumerate}
    \item{The client chooses a set of  servers in the cloud, . Then, it provides a description of the desired computation, and a unique seed value  to each server . It also provides another seed value  to each pair of servers, .}

    \item{Each server, , creates (or retrieves from its repository, if already available) a Boolean circuit (B) that corresponds to the requested computation.}

    \item{Each server, , uses  to generate its shares for the pair of garbled values and a  value for each wire in the circuit () using the pseudo random generator of Blum, Blum, Shub.

        Using seed , each server, , generates a pseudorandom bit sequence whose length equals , where  denotes the total number of wires in the Boolean circuit ().}

    \item{The client instructs the  servers, , to use their shares as private inputs for the secure multiparty computation protocol of Goldreich, to construct shares () of a BMR garbled circuit, .

        While using the protocol of Goldreich, each pair of servers, , generates pseudorandom bits using pairwise seed values .

        Let  denote the shares of server  for the four garbled table entries of gate . Then, , in turn, is a concatenation of all bit strings of the form , where the concatenation is taken over all the gates in the circuit.}

    \item{The client instructs all  servers,  to send their shares  to the server . Performing only XOR operations, the server  creates the desired circuit, . Now, the client instructs the server  to send the garbled circuit  to server  for evaluation.}

    \item{Using the unique seed values , the client generates garbled input values for each input wire in the circuit, and sends them to the server  for evaluation. Using these seed values, the client also generates the  values and the two possible garbled values for each output wire in the circuit, and keeps them secret.}

    \item{Using the garbled inputs, the server  evaluates , and obtains the garbled outputs for each output wire in the circuit and sends them to the client. Using the  values, the client now translates these garbled values into plaintext bits to recover the result of the requested computation.}

    \item{The client checks whether the garbled output for each output wire in the circuit that is returned by the evaluator, , matches with one of the two possible garbled values that it computed on its own. If there is a match for all output wires, then the client declares that the evaluator in fact carried out the requested computation.}

\end{enumerate}


 \section{Complexity}
\label{sec_complexity}
\subsection{Circuit size of one garbled table entry}

In this section, we analyze the size of the Boolean circuit () that computes one specific entry () in the garbled table. Assume that each gate takes two input bits to produce one output bit. Recall from Section~\ref{sec_garbled_circuit_BMR_construction} that , where  denotes the binary operation of gate .

Let . Computing  requires a total of  XOR gates and   gate, since , , , where  are shares of server .


Boolean circuit  includes a {\em multiplexer} that chooses  using the expression, . This expression is composed of  XOR gates and  AND gate. Since , and  , multiplexing is performed on the most significant  bits. We can build this multiplexer using a total of  XOR gates and  AND gates.


Now, the expression  has  terms, which are combined using  XOR operations. Since, each term has a length of  bits, computing this expression requires a total of  XOR gates.


To summarize, the Boolean circuit () that computes one specific garbled table entry () has a total of  XOR gates,  AND gates, and   gate.


\begin{figure}[t]
\centering
\includegraphics[width=3.25in]{Fig_no_of_gates_aux_circuit_vs_n.pdf}
\vspace{-3 mm}
\caption{Number of gates in the circuit that computes one garbled table entry as a function of .\vspace{-4 mm}}
\label{fig_num_gates_aux_bool_circuit}
\end{figure}


Fig.~\ref{fig_num_gates_aux_bool_circuit} shows the total number of gates in the circuit that computes , when  is an AND gate, as a function of  for a fixed value of  bits. Notice the relatively small number of AND gates in the circuit. For example, when , the circuit that computes  has a total of  XOR and  AND gates. {\em While the number of XOR gates increases quadratically with , the number of AND gates increases only linearly with }.


Let  denote the Boolean circuit that corresponds to the desired computation such as addition of two numbers. Then, while creating the garbled circuit  for , the  parties use the circuit  for the protocol of Goldreich to compute each one of the four garbled table entries of the form  for each gate  in the circuit .







\subsection{Communication cost to compute one garbled table entry}
\label{sec_communication_cost_to_compute_one_entry}

A 1-out-of-2 OT exchange between two parties involves the exchange of: (i) a random element  from the prime order subgroup, , of ; (ii) a public key, ; and (iii) the encryptions, , of the plaintext messages . Let  denote the security parameter, which equals the size of the plaintext messages, . Let  denote the total number of bits that are exchanged during a 1-out-of-2 OT. Then, .


A 1-out-of-4 OT exchange between two parties includes: (i) two 1-out-of-2 OTs, and (ii) four encryptions, . Let  denote the total number of bits that are exchanged during a 1-out-of-4 OT. Then, . Note that  and  are public and symmetric key security parameters, respectively. For example,  achieves the equivalent of -bit security \cite{nist_key_len_recommendations2012}; in this case, the sum of the sizes of all messages exchanged during a 1-out-of-4 OT is  bytes.


For each AND gate in the circuit , all possible pairs of the  servers, , engage in a 1-out-of-4 OT, and there are a total of  combinations of . Since the number of AND gates in the circuit  is at most , the total number of 1-out-of-4 OTs is .


At the completion of the secure multiparty computation protocol of Goldreich, each server, , sends its share  to another server, , to create the desired garbled table entry, . Since , the server  receives a total of  bits from the other  servers.


To summarize, in order to create one entry, , the total amount of network traffic, . {\em When the security parameters,  and , are fixed, the network traffic is a cubic function of .}

\begin{figure}[t]
\centering
\includegraphics[width=3.25in]{Fig_network_traffic_vs_n.pdf}
\vspace{-3 mm}
\caption{Amount of network traffic to compute one garbled table entry as a function of .\vspace{-4 mm}}
\label{fig_network_traffic}
\end{figure}

Fig.~\ref{fig_network_traffic} shows the network traffic to create one garbled table entry as a function of . For example, when , the cloud servers exchange a total of  MB of data in order to create a single entry in the garbled table.


Let  denote the total number of gates in the circuit  that corresponds to the desired computation. Then, in the process of creating the garbled circuit, , the total amount of network traffic equals .


\subsection{Computation cost of creating the garbled circuit}

Let  denote the total number of wires in the circuit . For each wire, each server, , generates  bits using the Blum, Blum, Shub (BBS) pseudorandom number generator (PRNG) for its share of garbled values and the  value. Therefore, the  servers collectively generate a total of  bits using the BBS PRNG. Let  denote the modulus value in BBS PRNG (note:  achieves -bit security \cite{nist_key_len_recommendations2012}). Then,  modular multiplication operations in  are necessary to generate bits using BBS PRNG.


Let  denote the number of output wires in the circuit . Let  denote the PRNG, which we have described in Section~\ref{sec_garbled_circuit_BMR_evaluation}, that outputs a sequence of  bits on providing a -bit input seed. Each server uses the PRNG , on its share of each garbled value for every non-output wire in the circuit . Then, in the process of creating the garbled circuit, the  servers collectively use the PRNG ,  times to generate a total of  bits.


Let  denote the total number of gates in the circuit . For protocol of Goldreich, the total number of pseudorandom bits generated by each party using the PRNG , equals , where  (Section~\ref{sec_key_changes_to_BMR_Goldreich}). Thus, the  parties collectively generate a total of  bits using the PRNG .


Note that both the PRNG  and PRNG  can be realized using a block cipher such as AES operating in output feedback mode.


Let  denote the number of 1-out-of-4 OTs to create one garbled table entry (Section~\ref{sec_communication_cost_to_compute_one_entry}). Then, the total number of 1-out-of-4 OTs to create the complete garbled circuit  is at most .


During a 1-out-of-2 oblivious transfer, the sender and chooser generate a total of  bits. Each 1-out-of-4 oblivious transfer involves the cost of two 1-out-of-2 oblivious transfers, in addition to generating a total of  bits. {\em A very small constant number of modular arithmetic operations, AES and SHA crypto operations are carried out during each OT} (Section~\ref{sec_1_out_of_2_OT} and Section~\ref{sec_1_out_of_4_OT}). While creating the garbled circuit , these sets of operations are performed  times; and a total of  bits are generated during the OTs.







To summarize, the total number of bits that are generated by the  parties while creating the garbled circuit is . {\em Thus, for any given Boolean circuit, when the security parameters  and  are fixed, the total number of bits generated randomly is a cubic function of .}

\begin{figure}[t]
\centering
\includegraphics[width=3.25in]{Fig_num_rand_bits_one_garbled_table_entry_vs_n.pdf}
\vspace{-3 mm}
\caption{Total number of Mega bits that are generated randomly in the process of creating one garbled table entry for the -bit adder.\vspace{-2 mm}}
\label{fig_num_rand_bits}
\end{figure}


For example, consider the construction of a garbled circuit for adding two -bit numbers. The corresponding Boolean circuit has a total of  wires,  output wires, and  gates\footnote{The -bit adder circuit in \cite{boolean_circuits} has  AND gates,  XOR gates and  NOT gates. Note that a NOT gate is equivalent to an XOR gate, since NOT).}. Fig.~\ref{fig_num_rand_bits} shows the total number of Mbits that are generated randomly while creating one garbled table entry (i.e., ) for the -bit adder. As an example, when , these parties collectively generate a total of  Mbits, randomly, to create one garbled table entry.


\subsection{Cost of evaluating the garbled circuit}

In order to perform the requested computation, the server  obtains the garbled circuit, , from the server . Let  denote the total number of gates in the circuit . Each entry in the garbled table has a length of  bits. Therefore, the size of the garbled circuit equals  bits.


\begin{figure}[t]
\centering
\includegraphics[width=3.25in]{Fig_size_of_garbled_circuit_vs_n.pdf}
\vspace{-3 mm}
\caption{Size of the garbled circuit in kilo bits for the -bit adder.\vspace{-3 mm}}
\label{fig_size_of_garbled_circuit}
\end{figure}


Fig.~\ref{fig_size_of_garbled_circuit} shows the size of the garbled circuit in kilo bits for the 32-bit adder. This circuit has  gates. The security parameter .


Let  and  denote the total number of wires and output wires, respectively, in the Boolean circuit . During evaluation, for each non-output wire of the circuit, the server  uses the PRNG   times. Therefore,  is used for a total of  times.


\subsection{Cost for the client}
\label{sec_cost_for_client}
To enable the creation of the garbled circuit, the client provides: (i) a unique seed value, , to each server , and (ii) a seed value, , to each pair of servers .


For the BBS PRNG, the length of each seed value, . For the PRNG , which can be implemented using a block cipher such as AES in output feedback mode, the length of each seed is . Therefore, the total number of bits that the client exchanges for the seed values is .



For each plaintext input bit to the circuit, the client is required to generate the garbled input. Each garbled value is  bits long, whose least significant bit depends on the  value. Since the  value, in turn, depends on the -bit shares for the  parties, the number of bits that the client needs to generate for each input wire equals .


To enable verification of outputs, the client needs to generate both possible garbled outputs for each output wire. Therefore, the number of bits that the client needs to generate for each output wire equals .


To summarize, the client generates/exchanges a total of  bits, where  and  denote the number of input and output wires, respectively, in the Boolean circuit .

\begin{figure}[t]
\centering
\includegraphics[width=3.25in]{Fig_num_bits_client_vs_n.pdf}
\vspace{-3 mm}
\caption{Total number of kilo bits that the client generates to delegate the construction and evaluation of the garbled circuit, and to verify the outputs for the -bit adder.\vspace{-3 mm}}
\label{fig_num_bits_client}
\end{figure}


Fig.~\ref{fig_num_bits_client} shows the total number of kilo bits that the client generates in order to enable the servers to construct and evaluate the garbled circuit, as well as for the verification of outputs for the -bit adder. This circuit has  input wires and  output wires. The security parameters are  and .


Comparing Fig.~\ref{fig_num_bits_client} with Figs.~\ref{fig_network_traffic} and Fig.~\ref{fig_num_rand_bits}, we notice that while the servers generate and exchange Gigabytes of information to create the garbled circuit, the mobile client, on the other hand, generates and exchanges only kilobytes of information with the evaluator and the other servers.


\subsection{Comparison of Our Scheme with Gentry's FHE Scheme}
While Gentry's FHE scheme \cite{gentry10} uses only one server, it, however, requires the client to exchange  bits with the evaluating server, for each input and output wire of the circuit. In our secure cloud computing system, since each garbled value has a length of  bits, for each input and output wire, the client only exchanges  bits with the server . For example, with , the size of each encrypted plain text bit equals several Gigabits with Gentry's scheme, while it equals a mere  bits in our approach with . {\em Thus, our approach is far more practical for cloud computing in mobile systems in comparison to FHE schemes.}


\subsection{Construction and evaluation time}

\begin{figure}[t]
\centering
\includegraphics[width=3.25in]{Fig_time_taken_construction_vs_n.pdf}
\vspace{-3 mm}
\caption{Time taken to construct one garbled table.\vspace{-2 mm}}
\label{fig_time_construction}
\end{figure}

We implemented our secure cloud computing system using BIGNUM routines and crypto functions from the OpenSSL library. We built our system as a collection of modules, and the servers communicate using TCP sockets. We evaluated our system on a server with Intel Xeon  GHz processor, with  cores and  GB RAM \footnote{We thank Srinivasa Vamsi Laxman Perala (email: sxp136630@utdallas.edu) for implementing various components of our system.}. Fig.~\ref{fig_time_construction} shows the time taken to construct one garbled table as a function of . {\em We note that the garbled tables for any number of gates in the circuit can be constructed in parallel, which will significantly reduce the construction time.}

\begin{figure}[t]
\centering
\includegraphics[width=3.25in]{Fig_time_taken_evaluation_vs_n.pdf}
\vspace{-3 mm}
\caption{Time to evaluate one garbled gate.\vspace{-3 mm}}
\label{fig_time_evaluation}
\end{figure}

Fig.~\ref{fig_time_evaluation} shows the time taken to evaluate one garbled gate as a function of . Comparing Fig.~\ref{fig_time_construction} and Fig.~\ref{fig_time_evaluation}, we observe that {\em evaluation is significantly faster than construction, where the latter can be done offline.} If the garbled circuits are {\em pre-computed}, and made available to the evaluator, in advance, it can readily carry out the requested computation, and therefore, drastically reduce the {\em response time} for the mobile client.





 \section{Privacy Preserving Search for the Nearest Bank/ATM}
\label{sec_manhattan_distance}


We examine the following privacy preserving application in this section. A mobile client, which is located at the intersection of two streets, needs to determine the location of the nearest Chase or Wells Fargo bank or ATM machine in a privacy preserving manner. We evaluate our application using real-world data available for Salt Lake City, UT, whose streets are arranged in a {\em grid pattern}. Our application assures the privacy of the following -- (i) the mobile client's input location, (ii) the computed bank/ATM location nearest to the client, and (iii) the computed distance to the nearest ATM. Note that these secrets are revealed to the evaluator only if it colludes with all the  servers that participate in the creation of the garbled circuit.


\begin{table}[!t]
\renewcommand{\arraystretch}{1.3}
\caption{Locations of Banks and ATMs in Salt Lake City, UT {\em (source: www.chase.com, www.wellsfargo.com).}}
\label{table_atm_locations}
\centering
\begin{tabular}{||c||c||}
\hline
\bfseries Bank/ATM & \bfseries Location\\
\hline
Chase &  South  East\\
\hline
Chase &  South  East\\
\hline
Chase &  East  South\\
\hline
Chase &  East  South\\
\hline
Wells Fargo &  South  East\\
\hline
Wells Fargo &  East  South\\
\hline
Wells Fargo &  South  East\\
\hline
Wells Fargo &  South  East\\
\hline
Wells Fargo &  South  East\\
\hline
Wells Fargo &  South  East\\
\hline
\end{tabular}
\end{table}


We consider an area of Salt Lake City, UT that lies between Main street (which represents  East street),  East street, South Temple street (which represents  South street), and  South street. This area consists of  ATM locations that are shown in Table~\ref{table_atm_locations}.


Each East/South coordinate in this area is an -bit unsigned number. Therefore, the location of the mobile client at an intersection, or any bank/ATM in this area can be identified using  bits.


\subsection{Circuit for Computing Manhattan Distance}

Let  represent the coordinates of the mobile client at an intersection. Similarly, let  represent the coordinates of a bank/ATM. Since the streets are arranged in a grid pattern, the shortest distance () between  and  equals the sum of the absolute differences between the respective coordinates: . This distance metric is more commonly referred to as the Manhattan distance.

\begin{figure}[t]
\centering
\includegraphics[width=3.35in]{Fig_Manhattan_Distance_ABS_DIFF.pdf}
\caption{Absolute difference between the  and  coordinates.}\label{fig_absolute_diff}
\end{figure}

\begin{figure}[t]
\centering
\includegraphics[width=3.0in]{Fig_Manhattan_Distance_FINAL_STEP.pdf}
\caption{Manhattan Distance Computation.}\label{fig_manhattan_dist_final_step}
\end{figure}


We design a Boolean circuit for computing the Manhattan distance between two points,  and . Assume that each coordinate is an  bit unsigned number. Figure~\ref{fig_absolute_diff} and Figure~\ref{fig_manhattan_dist_final_step} show the block diagram of our circuit. We use the  and  blocks of Kolesnikov et al. \cite{kolesnikov09}.


Each / block is composed of  -bit subtractors/adders; each -bit subtractor/adder, in turn, is composed of  XOR gates,  AND gate. Note that  output bit of  block equals the complement of carry-out bit from the  -bit subtractor.


If , then the output of  block equals the absolute difference, . Otherwise, the output of  block equals the negative value, , in  complement form. Since  for negative values, we use  as one of the inputs for the  gates in the  block to compute the  complement of the absolute difference. Then, we subsequently use  as a carry-in input bit for the  block. Thus, the output of the  block accounts for both  and  cases.


Similarly, for the  coordinates we use the  and  blocks to compute the absolute difference in  complement form. To account for the case when , we use an  block that adds the value of the bit  to the output of the  block. The  block is composed of  half-adder(HA) blocks, where each  block, in turn, is composed of   and   gate.

\begin{table}[!t]
\renewcommand{\arraystretch}{1.3}
\caption{Circuit size for Manhattan distance calculation.}
\label{table_manhattan_dist_calc}
\centering
\begin{tabular}{||c||c||c||}
\hline
\bfseries Block & \bfseries  gates & \bfseries  gates\\
\hline
 &  & \\
\hline
 &  & \\
\hline
 &  & \\
\hline
 &  & \\
\hline
 &  & \\
\hline
\end{tabular}
\end{table}

The output of the  block represents the -bit Manhattan distance between  and . Using the circuit design of Figure~\ref{fig_absolute_diff} and Figure~\ref{fig_manhattan_dist_final_step}, a list of distances between the location of the mobile client and any number () of ATM locations can be computed. Table~\ref{table_manhattan_dist_calc} shows that our Boolean circuit for computing the Manhattan distance between two points has a total of   gates and   gates.


{\em Note:} In a more direct alternative to compute Manhattan distance, we may first find  and , and always subtract  from  (similarly for the  coordinates). While this approach would eliminate  and  blocks, it however would require the use of two comparator and conditional swap blocks \cite{huang2012private}, which together introduce  new  gates and   gates. Consequently, this alternative approach to compute Manhattan distance would require a total of   gates and   gates. Thus, in comparison to this more direct alternative, our design shown above in Figure~\ref{fig_absolute_diff} and Figure~\ref{fig_manhattan_dist_final_step} requires a significantly smaller number of   and   gates.


\subsection{Circuit for Computing the Nearest ATM}

\begin{figure}[t]
\centering
\includegraphics[width=3.0in]{Fig_Manhattan_Distance_MIN_TREE_ver3.pdf}
\caption{Finding minimum value and index.}\label{fig_min_tree}
\end{figure}

\begin{table}[!t]
\renewcommand{\arraystretch}{1.3}
\caption{Circuit size of  Min block.}
\label{table_one_min_value_index_block}
\centering
\begin{tabular}{||c||c||c||}
\hline
\bfseries Block & \bfseries  gates & \bfseries  gates\\
\hline
 &  & \\
\hline
 &  & \\
\hline
 &  & \\
\hline
 &  & \\
\hline
\end{tabular}
\end{table}

Following the computation of distance between the mobile client and  ATM locations, it is necessary to find the nearest ATM, along with its distance. We use the approach of Kolesnikov et al. \cite{kolesnikov09} to find the minimum value and its index, given a list of values. Kolesnikov et al. have designed a  block to find the minimum of two input values -- it uses the result of a comparator to multiplex the minimum value, as well as the corresponding index as shown in Figure~\ref{fig_min_tree}. Table~\ref{table_one_min_value_index_block} shows the size of the circuit that computes the minimum of two values, along with its index. In our privacy preserving application, each distance is an -bit number, and each index that identifies an ATM using its East and South coordinates is an -bit number.


Given  values and their indices, using   blocks organized as a tree, the minimum value and the corresponding index are propagated from the leaves to the root. Figure~\ref{fig_min_tree} shows the computation of the minimum of  input values, , , , , and the corresponding index, , as an example.


\begin{table}[!t]
\renewcommand{\arraystretch}{1.3}
\caption{Complete circuit size for nearest ATM.  denotes distance to  locations.  denotes the tree of MIN blocks.}
\label{table_complete_circuit_closest_ATM}
\centering
\begin{tabular}{||c||c||c||}
\hline
\bfseries Block & \bfseries  gates & \bfseries  gates\\
\hline
 &  & \\
\hline
 &  & \\
 &  & \\
\hline
 &  &\\
\hline
\hline
 &  & \\
\hline
\end{tabular}
\end{table}

Table~\ref{table_complete_circuit_closest_ATM} shows the number of  and  gates in the complete circuit that computes the nearest ATM location. It shows that in our privacy preserving application of finding the nearest Chase or Wells Fargo ATM in Salt Lake City, the circuit has a total of   and   gates.


\subsection{Server-side and Client-side Cost}

\begin{figure}[t]
\centering
\includegraphics[width=3.25in]{Fig_network_traffic_closest_ATM_SLC_vs_n.pdf}
\caption{Server-side network traffic to construct the garbled circuit for determining the nearest ATM.}\label{fig_server_side_network_traffic_closest_ATM}
\end{figure}


Figure~\ref{fig_server_side_network_traffic_closest_ATM} shows the network traffic as a function of the number of servers () involved in the creation of the garbled circuit that can compute the nearest ATM and the corresponding distance in a privacy preserving manner. For example, with  servers, the servers exchange a total of   of information to create the garbled circuit. This result demonstrates the feasibility of our approach for performing real-world privacy-preserving computations.


\begin{figure}[t]
\centering
\includegraphics[width=3.25in]{Fig_cost_of_client_closest_ATM_SLC_vs_n.pdf}
\caption{Client-side cost to determine the nearest ATM.}\label{fig_client_side_cost_closest_ATM}
\end{figure}


In order to facilitate the creation of the garbled circuit, and for the evaluation, the mobile client sends -- (i) the seed values to the  servers, and (ii) the garbled values representing the coordinates of the input location to the evaluator. Since the ATM locations are publicly known, they are assumed to be hard-coded in the garbled circuit. i.e., the client is not required to transmit the ATM locations to the servers.


Figure~\ref{fig_client_side_cost_closest_ATM} shows the total number of bits generated by the client to delegate the privacy preserving computation of the nearest ATM. To preserve location privacy, the client exchanges a very small amount of information with the servers -- less than  kilo bits, with  servers, for example. Comparing Figure~\ref{fig_server_side_network_traffic_closest_ATM} and Figure~\ref{fig_client_side_cost_closest_ATM}, we note that {\em the client-side cost grows much slowly with the number of servers, in comparison to the server-side cost.}

 \section{Related Work}
\label{sec_related_work}

Homomorphic encryption is an approach that enables performing computations directly on the encrypted data, without requiring private decryption keys. For example, in the RSA public key system, the product of two ciphertext messages produces a ciphertext corresponding to the product of the underlying plain text messages \cite{rivest78}. Domingo-Ferrer et al. \cite{domingoFerrer02} present a homomorphic scheme that represents ciphertext as polynomials, allowing both addition and multiplication operations on the underlying plain text; however, in this scheme, multiplication operations drastically increase the size of the cipher text. Recently, fully homomorphic encryption (FHE) schemes (e.g., Gentry et al. \cite{gentry10}) have been proposed, which enable performing any arbitrary computation on encrypted data. However, FHE schemes are currently impractical for cloud computing applications due to extremely large cipher text size (Section~\ref{sec_cost_for_client}).


Yao's garbled circuits have been primarily used in conjunction with oblivious transfer protocols for secure two-party computation \cite{yao82,yao86,lindell09}. Lindell et al. \cite{lindell_survey09} present an excellent survey of secure multiparty computation, along with numerous potential applications, such as privacy preserving data mining, private set intersection, electronic voting and electronic auction. A number of secure two-party and multiparty computation systems have been built over the years (e.g., \cite{henecka10,malkhi04,david08}). Note that in secure multiparty computation systems multiple parties hold private inputs and receive the result of the computation; however, in a secure cloud computing system, such as ours, while multiple parties participate in the creation of garbled circuits, only the client holds private inputs and obtains the result of the computation in garbled form. In our work, we adapt secure multiparty computation protocols \cite{goldreich04,goldreich87,beaver90,rogaway91}, as we have described in Section~\ref{sec_key_changes_to_BMR_Goldreich}, for building a secure and verifiable cloud computing for mobile systems.


Some existing works \cite{burkhart10,damgaard12} use arithmetic circuits for performing homomorphic addition and multiplication operations. However, Boolean circuits are sufficient for our purpose of creating the garbled table entries as it only involves simple binary operations such as XOR and AND (Section~\ref{sec_garbled_circuit_BMR_construction}). Additionally, Boolean circuits are more efficient than arithmetic circuits for homomorphic comparison of numbers, which we have used abundantly in our privacy preserving search application (Section~\ref{sec_manhattan_distance}), since comparison using an arithmetic circuit involves a large number of multiplications and communication rounds among the participants \cite{burkhart10,damgaard12}.


Twin clouds \cite{bugiel11} is a secure cloud computing architecture, in which the client uses a {\em private} cloud for creating garbled circuits and a {\em public} commodity cloud for evaluating them.
Our solution, on the other hand, employs multiple public cloud servers for creating as well as evaluating the garbled circuits. {\em In other words, our solution obviates the requirement of private cloud servers. Furthermore, in twin clouds, the privacy of the client data is lost if the evaluator colludes with the sole/only server that constructs the garbled circuit. In our work, on the other hand, the use of multiple servers for construction of garbled circuits offers greater resistance to collusion (Section 2).}


While FHE schemes currently remain impractical, they, however, offer interesting constructions, such as reusable garbled circuits \cite{goldwasser13} and verifiable computing capabilities that permit a client to verify whether an untrusted server has actually performed the requested computation \cite{gennaro10}. {\em In our proposed system, we enable the client to efficiently verify whether an untrusted server has actually evaluated the garbled circuit, without relying on any FHE scheme.}


Naehrig et al. \cite{naehrig11} present an implementation of a ``somewhat" homomorphic encryption scheme, which is capable of computing simple statistics such as mean, standard deviation and regression, which require only addition operations, and a very few multiplication operations. Another recent work (P4P \cite{duan10}) provides privacy preservation for computations involving summations only. In comparison, our scheme, which is based on Yao's garbled circuits, is not limited to computation of simple statistics or summations only; i.e., our scheme is more generic, and can perform any arbitrary computation.


Carter et al. \cite{carter13} have proposed an atypical secure two party computation system with three participants: Alice, Bob and a Proxy. In their work, Bob is a webserver that creates garbled circuits, and Alice is a mobile device that delegates the task of evaluating the garbled circuits to the Proxy, which is a cloud server. We note that the computation and adversary models in Carter et al.'s work are very different from that of our work. First, in their work, being a secure two party computation system, {\em both Alice and Bob} provide private inputs for the computation that they wish to perform jointly; however, in our secure cloud computing model, {\em only one party, i.e., the mobile client}, provides inputs and obtains result of the computation in garbled form. Second, Cartel et al.'s scheme requires that neither Alice nor Bob can collude with the Proxy; in a sharp contrast, our method preserves the privacy of the client data even if the evaluating server colludes with all but one of the cloud servers that participated in the creation of the garbled circuit. 

 \section{Concluding Remarks}
\label{sec_conclusion}

We proposed a novel secure and verifiable cloud computing for mobile system using multiple servers. Our method combines the secure multiparty computation protocol of Goldreich et al. and the garbled circuit design of Beaver et al. with the cryptographically secure pseudorandom number generation method of Blum et al. Our method preserves the privacy of the mobile client's inputs and the results of the computation, even if the evaluator colludes with all but one of the servers that participated in the creation of the garbled circuit. Further, our method can efficiently detect a cheating evaluator that returns arbitrary values as output without performing any computation. We presented an analysis of the server-side and client-side complexity of our system. Using real-world data, we evaluated our system for a privacy preserving search application that locates the nearest bank/ATM from the mobile client. We evaluated the time taken to construct and evaluate a garbled circuit for varying number of servers, and demonstrated the feasibility of our proposed approach.
 











\ifCLASSOPTIONcompsoc
\section*{Acknowledgments}
\else
\section*{Acknowledgment}
\fi


Our work is part of the National Science Foundation (NSF) Future Internet Architecture Project, and is supported by NSF under the following grant numbers: CNS-1040689, ECCS-1308208 and CNS-1352880.

\ifCLASSOPTIONcaptionsoff
  \newpage
\fi














\bibliographystyle{abbrv}
\bibliography{paper}






















\end{document}
