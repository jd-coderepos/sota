\documentclass[11pt]{article}

\usepackage{latexsym,amsfonts,amssymb,float}

\usepackage{epic,eepic,epsf}
\usepackage{subfigure}
\usepackage{wrapfig}
\usepackage{verbatim}
\usepackage{algorithmic}
\usepackage{algorithm}

\usepackage{stmaryrd}

\usepackage{fullpage}

\newtheorem{theorem}{Theorem}
\newtheorem{lemma}{Lemma}
\newtheorem{note}{Note}
\newtheorem{proposition}{Proposition}
\newenvironment{proof}{\noindent\textbf{Proof:}}{\hfill}

\floatstyle{ruled}
\newfloat{algorithm}{Algorithm}{tbhp}[section]

\begin{document}

\renewcommand{\thefootnote}{\fnsymbol{footnote}}

\title{Stabilizing Data-Link over non-FIFO Channels\\ with Optimal Fault-Resilience}

\author{
Shlomi Dolev\footnotemark[1] \and 
Swan Dubois\footnotemark[2] \and 
Maria Potop-Butucaru\footnotemark[2] \and 
S\'ebastien Tixeuil\footnotemark[3]}
\date{}

\maketitle

\footnotetext[1]{Department of Computer Science, Ben-Gurion University of the Negev, Beer-Sheva, 84105, Israel. Email: {\tt dolev@cs.bgu.ac.il}. The work started while this author was a visiting professor at LIP6.
Research supported in part by the ICT Programme of the European Union under contract
number FP7-215270 (FRONTS), Deutsche Telekom, US Air-Force
and Rita Altura Trust Chair in Computer Sciences.}

\footnotetext[2]{UPMC Sorbonne Universit\'es \& INRIA, France.}

\footnotetext[3]{UPMC Sorbonne Universit\'es \& IUF, France. This work is supported in part by ANR projects SHAMAN, ALADDIN, and SPADES}


\begin{abstract}
Self-stabilizing systems have the ability to converge to a correct behavior when started in any configuration. Most of the work done so far in the self-stabilization area assumed either communication via shared memory or via FIFO channels. 

This paper is the first to lay the bases for the design of self-stabilizing message passing algorithms over unreliable non-FIFO channels. We propose an optimal stabilizing data-link layer that emulates a reliable FIFO communication channel over unreliable capacity bounded non-FIFO channels.   
\end{abstract}

\maketitle

\renewcommand{\thefootnote}{\arabic{footnote}}

\section{Introduction}

Self-stabilization~\cite{D74j,D00b,T09bc} is one of the most versatile techniques to sustain availability, reliability, and serviceability in modern distributed systems. After the occurrence of a catastrophic failure that placed the system components in some arbitrary global state, self-stabilization guarantees recovery to a correct behavior in finite time without external (\emph{i.e.} human) intervention. 

As self-stabilization is usually considered a hard property to satisfy, most related works used a simple communication model where processes can determine the current state of every neighbors (and update their own state accordingly) in an atomic manner (this model is referred to in the literature as the \emph{state model} or systems with \emph{central/distributed daemon}). Asynchronous message passing is a more realistic way, compared to the state model, for the communication of processes in distributed systems. In such settings processes communicate by exchanging messages, where sending and receiving message are two separate atomic actions. Transformers for shared memory protocols to act in message passing systems, assuming the existence of FIFO channels, have been suggested, see \emph{e.g.} \cite{DIM93j,D00b}. At the core of those transformers are the \emph{data-link} protocols, that permit to reliably exchange information between neighboring processes in the message passing model. In addition, several self-stabilizing protocols (\emph{i.e.} \cite{DT06c,AADDPT10c}) that are directly written in the message-passing model use an underlying data-link protocol as a building block.

\paragraph{Related Works.} The most studied data-link protocol, namely the alternating bit protocol (ABP), was proved to satisfy some stabilization properties~\cite{AB93j,DIM97j,BGM93j}: in any execution of ABP, there exists a suffix that satisfies the specification (\emph{i.e.} the ABP is \emph{pseudo-stabilizing}). However, the impossibility to bound the amount of time before this suffix is reached makes the ABP unsuitable for most tasks. In~\cite{GM91j,DIM93j}, Gouda and Multari and Dolev, Israeli, and Moran independently prove that for a wide class of problems (including data-link construction) guaranteeing self-stabilization when channels have unbounded initial capacity requires some kind of unboundedness in the protocol (either unbounded memory in~\cite{GM91j}, the existence of some aperiodic function~\cite{AB93j}, or access to a probabilistic variable~\cite{AB93j}). In other words, those approaches require to implement unbounded capacities with finite memory, and are thus unlikely to be actually used in real systems. Also, the expected time before reaching a stable global state depends on the initial contents of communication channels, and is thus unbounded.

Most recent works took the more realistic approach of assuming channels with bounded initial capacity. The token passing protocol in~\cite{DIM97j} can be used as a self-stabilizing ABP on bounded channels and only uses bounded memory. Howell \emph{et al.} \cite{HNM99c} provide another data-link protocol over bounded channels with the additional desirable property that the underlying communication channels are unreliable (\emph{i.e.} they may loose or duplicate messages). Later, Varghese~\cite{V00j} presented self-stabilizing solutions for a wide class of problems (including data-link) in the same setting using only bounded memory. The FIFO ordering is crucial for the stabilization since solution relies on the fact that a sequence number that is unique in the system is eventually generated and flushes every stale message in transit. A common drawback of all aforementioned self-stabilizing data-link solutions is that they assume a FIFO order on messages in the underlying communication channels. 

A notable exception are the protocols provided in \cite{BK97j} that assumed a non-FIFO message passing system. The main difference with our approach stands in the fact that their system is enhanced with some failure detector whereas we assume a fully asynchronous system.

Another drawback of previously mentioned self-stabilizing data-link solutions is that they do not consider the quantitative impact of faults from the perspective of the upper layer protocol (\emph{i.e.} the layer that actually uses the data-link). Indeed, starting from an arbitrary global state where channels may initially contain messages 
of arbitrary content, being able to bound the number of messages sent that are lost or duplicated, or the number of fake messages that are actually delivered to the destination is a very important matter. The bound on the number of faulty messages delivered by a data-link protocol is an important criteria for the data-link usability in larger application, in order to ensure the fault-resiliency of the global protocol stack. To our knowledge, only~\cite{DT06c,DDNT10j} addresses, to some extent, this concern. A snap-stabilizing data-link (and global reset) for bounded capacity FIFO channels appears in \cite{DT06c}. In \cite{DDNT10j} a snap-stabilizing solution to the propagation of information with feedback (PIF) problem is presented. The solution can be seen as a data-link protocol when reduced to a 2-processes system. Snap-stabilization implies that any message that is actually sent by the sender process is eventually received by the receiver process, so the number of lost messages is . However, we cannot provide bounds on the number of duplications of a given message or on the number of ghost messages (that is, messages that are not sent by the sender  but received by the receiver due to the arbitrary content of communication channels in the initial configuration). Concerning the self-stabilizing protocols, only an order of magnitude on those numbers can be inferred from the stabilization time (if  messages sent or received are required to enter a legitimate global state from any arbitrary initialization, then at most  messages could be lost, duplicated, or wrongly delivered). To our knowledge, the question of fault-resilience optimality for data-link protocols has never been raised before, although it has important practical consequences. 

\paragraph{Our contribution.} Our contribution in this paper is twofold:
\begin{enumerate}
\item We define complexity metrics that are related to the fault-resilience of data-link protocols, and present impossibility results in the context of self-stabilization (\emph{i.e.} the ability to recover from any arbitrary initial global state). In particular, we prove that no data-link protocol can prevent one message duplication, the delivery of a single fake message, or the reordering of a single message.
\item We present a data-link protocol that is optimal with respect to all presented fault-resilience metrics. Moreover, unlike previous self-stabilizing solutions that operate assuming the underlying communication channels preserve FIFO ordering, the channels we consider may indeed reorder messages, having some of them remain in the channel for an arbitrary long time. The strong fault-resilience property exhibited by our protocol makes it particularly suitable for inclusion as a building block in more complex applications.
\end{enumerate}

\paragraph{Paper organization.} The paper is organized as follows. Section \ref{sec:model} proposes the network model and hypothesis and then, the data-link problem specification. Section \ref{sec:impossibility} introduces three lower bounds results that justify our optimality claim. In Section \ref{sec:solution}, we propose our optimal stabilizing data-link protocol altogether with its correctness proof.

\section{Model}\label{sec:model}

\subsection{System Model}

A \emph{message-passing distributed system} consists of  {\em processes}, , connected by {\em communication links} through which messages are sent and received. Two processes connected through a communication link are referred in the following as neighboring processes.

As emphasized in \cite{AB93j} the purpose of a data-link protocol is to reliably transmit messages from one end of a communication medium (link) to the other end. Ideally, messages have to arrive without duplication or loss and in the order they have been sent. Therefore, we focus in the following on the communication between two neighboring processes  and  where  acts as the sender and  acts as the receiver. The communication link between the two processes  and  is denoted in the following  and is composed of two virtual directed channels  and . The channel  is used to send messages from  to  while the channel  is used to send acknowledgments from  to . In systems where  is also message sender, two additional virtual channels are used to carry the messages from  to  and acknowledgments from  to .

We assume in the following that the capacity of each directed channel is  packets (\emph{i.e.} low level messages). Note that in the scope of self-stabilization, where the system copes with an arbitrary starting configuration, there is no deterministic data-link simulation that uses bounded memory when the capacity of channels is unbounded~\cite{GM91j,DIM97j}.

The channels are non-FIFO and not necessarily reliable (\emph{i.e. } packets may not follow the FIFO order and may be lost). Additionally, their delivery time is unbounded. That is, any non lost packet is received in a finite but unbounded time. Each channel  is \emph{weakly fair} in the sense that if the sender sends infinitely often a packet on the channel, then the receiver receives this packet an infinite number of time. Sending a packet to a channel whose capacity is exhausted (\emph{i.e.} the channel already contains  packets) results in loosing a packet (either a packet already in the channel or the packet being sent). 

As we deal with arbitrary initial corruption, a channel may initially contain up to  ghost packets (\emph{i.e.} packets that have never been sent and contain arbitrary content).

A processor is modeled by a state machine that executes \emph{steps}. Channels are modeled as sets (rather than queues to reflect the non-FIFO order). For example, the -bounded channel  (used to send messages from  to ) is modeled by a -sized set denoted by .

In each step, a processor changes its local state (\emph{i.e.} the state of its local memory), and executes a single communication operation, which is either a {\em send}  operation or a {\em receive} operation. The communication operation changes the state of an attached channel. In case the communication operation is a send operation from  to  then  is a union of  in the previous state with the sent packet. If the obtained union does not respect the bound  then an arbitrary message in the obtained union is deleted. In case the communication operation is a receive operation of a (non null) packet  ( must exist in  of the previous state), then  is removed from . A receive operation by  from  may result in a null packet even when the  is not empty, thus allowing unbounded delay for any particular packet. Packet losses are modeled by allowing spontaneous packet removals from the set.
 
A \emph{configuration} of the system is the product of the local states of processes in the system and of their incident channels.

An {\em execution} is a sequence of configurations,  such that , , is obtained from  when at least one process in the system executes a step.

\subsection{Problem Specification}\label{sub:specification}

The specification we provide in this section is borrowed from \cite{L96b} but we adapt it to the self-stabilizing context. In particular, we introduce the idea to bound the number of lost, duplicated, ghost and re-ordered messages by some constants.

Consider a system of two processors  and . A distributed application needs to send some messages from  to . We say that the application layer of  \emph{sends} a message when it requests the communication protocol to carry this message to . This message is \emph{delivered} to  when the communication protocol releases this message to the application layer of . A \emph{ghost} message is a message delivered to  whereas  did not send it previously (due to the arbitrary content of communication channels in the initial configuration). A \emph{duplicated} message is a message that is delivered several times to  whereas  sent it only once. A message is \emph{lost} when  sends it but  never delivers it. A message  is \emph{reordered} when it is delivered to  before a message  whereas  has been sent after  by . Intuitively, the goal of a Stabilizing Data-Link protocol is to provide a communication black box that ensures some properties on the number of lost, duplicated, ghost and reordered messages starting from any arbitrary configuration. In the sequel, we formally specify the Stabilizing Data-Link problem

We associate to any execution  the sequence  of messages sent by  in  and the sequence  of messages delivered to  in . Note that we consider that all sent messages are different (even if their actual content are identical, we can distinguish them as external observer of the system). We introduce the following notations. For any sequence  and any integers  and ,  is the prefix of  of length  and  is the suffix of  such that . The notation  denotes the empty sequence. For example, . For any message , we define the  as the repetition of  an arbitrary number of times (possibly 0). For any sequence , the sequence  is the result of the application of the  operator to each message of . 

For any non negative integers , , , and , the \textbf{()-Stabilizing Data-Link communication} over -bounded channels satisfies the following properties starting from an arbitrary configuration (with  and  being respectively the sender and the receiver) for any execution :
\begin{itemize}
\item \textbf{-Loss:} The first  messages sent by  (in the worst case) may be lost.

\item \textbf{-Duplication:} The first  messages delivered to  (in the worst case) may be duplicated ones.

\item \textbf{-Creation:} The first  messages delivered to  (in the worst case) may be ghost messages.

\item \textbf{-Reordering:} The first  messages delivered to  (in the worst case) may be reordered.

\end{itemize}

In the following section, we show that it is impossible to perform a ()-Stabilizing Data-Link communication with , , or . Then, we can deduce that a  ()-Stabilizing Data-Link communication achieves optimal fault-resiliency. The above definitions imply that such a communication protocol ensures that  or  (where  is an arbitrary message, it may be present in ) for any execution . In other words, the sequence of received messages by  is identical to the sequence of emitted messages by  excepted the first delivery in the worst case.

\section{Lower Bounds}\label{sec:impossibility}

In this section, we propose three impossibility results related to the possible values for the parameters , , and . We prove that the lower bounds for , , and  parameters is . These results confirm the claim that the protocol we propose is optimal since it implements a -Stabilizing data-link.

\begin{theorem}\label{th:impGamma}
There exists no -Stabilizing Data-Link communication algorithm over -bounded channels with .
\end{theorem}

\begin{proof}
By contradiction, let  be any -Stabilizing Data-Link communication algorithm over -bounded channels must have an instruction that delivers messages to the receiver processor. As the program counter may be corrupted and channels may contain up to  ghost messages in the initial configuration, the receiver processor may execute this instruction during the first step of an execution . In consequence, the first message of  may be a ghost message . Hence, we can assume that .

It is possible to construct the execution  such that . In conclusion, we have:  (recall that  denotes the empty sequence). This is contradictory with the 0-Creation property of  and implies that  for any -Stabilizing Data-Link communication algorithm over -bounded channels.
\end{proof}

\begin{theorem}\label{th:impBeta}
There exists no -Stabilizing Data-Link communication algorithm over -bounded channels with .
\end{theorem}

\begin{proof}
By contradiction, let  be any -Stabilizing Data-Link communication algorithm over -bounded channels. Following Theorem \ref{th:impGamma}, we have . This implies that the first message delivered to  in an execution  by  may be a ghost message . Hence, we can assume that .

It is possible to construct the execution  such that the first (real) message sent by  to  and delivered to  by  is the same message . This message has been sent by  only once but has been delivered to  at least twice. In conclusion, we have:  (recall that  denotes the empty sequence). This is contradictory with the 0-Duplication property of  and implies that  for any -Stabilizing Data-Link communication algorithm over -bounded channels.
\end{proof}

\begin{theorem}\label{th:impDelta}
There exists no -Stabilizing Data-Link communication algorithm over -bounded channels with .
\end{theorem}

\begin{proof}
By contradiction, let  be any -Stabilizing Data-Link communication algorithm over -bounded channels. Following Theorem \ref{th:impGamma}, we have .  This implies that the first message delivered to  by  in an execution  may be a ghost message . Hence, we can assume that .

It is possible to construct the execution  such that  and . As  satisfies the -Loss and the 0-Reordering properties, it follows that  (otherwise, we have a contradiction since either  lost at least  messages or reordered at least one message, that is contradictory). As , we obtain a contradiction that shows that  for any -Stabilizing Data-Link communication algorithm over -bounded channels.
\end{proof}

In the next section, we present a protocol that is optimal with respect to , , , and  parameters. That is, our protocol satisfies the -Stabilizing Data-Link specification.

\section{A -Stabilizing Data-Link Protocol}\label{sec:solution}

\subsection{Presentation of the Protocol}

\paragraph{Key ideas of the protocol.} The rationale of the protocol consists in adding safety extensions to the well-known alternating bit protocol (\emph{a.k.a.} ABP). The concept used in the design of the data-link protocol is to let the sender use a mechanism based on the capacity  of communication channels so that the sender can ensure the execution of an operation in the receiver side. More precisely, the receiver acts only upon receiving a packet from the sender. The sender may repeatedly send a particular packet, and each time the receiver receives a packet it acknowledges the packet arrival.

First, the receiver can deliver a message only if  copies of this message have been previously received: this ensures that at least one of them is genuine (\emph{i.e.} was actually sent by the sender). Moreover, a message is delivered only if the expected bit alternates with the one of the previously received message (similarly to the ABP) in order to ensure that no message is duplicated. Indeed, the sender may still send copies of the message with the same alternating bit value until it receives a sufficient number of acknowledgments. 

Second, the sender will expect for each message sent at least  acknowledgments with a matching alternating bit. As up to  acknowledgments could be ghost, this implies that  of these acknowledgments were actually sent by the receiver. One such acknowledgment could be sent by the received due to bad initialization,  of them could be due to  initial ghost messages in the reverse direction, and the remaining  can only originate from genuine messages from the sender, that triggered a delivery at the receiver. 

At this stage, the protocol does not ensure the -Loss property due to the use of the alternating bit. Indeed, if the alternating bit values of the sender and of the receiver are not synchronized at the first delivery, the receiver drops the first message. To avoid this message loss, the sender alternates between actual messages and synchronization messages. In other words, to send a message , the sender first sends a synchronization message (denoted by ) until it receives  acknowledgments of this synchronization message and then send the actual message  until it receives  acknowledgments of . It follows that only the synchronization message may be lost and the actual message is always delivered to the receiver.

\begin{figure*}[t]
\noindent \begin{centering} \scriptsize{\clearpage{}\ifx\JPicScale\undefined\def\JPicScale{1}\fi
\unitlength \JPicScale mm
\begin{picture}(147.5,85)(0,0)
\put(27.5,15){\makebox(0,0)[cc]{Physical Channel}}

\put(27.5,50){\makebox(0,0)[cc]{Stabilizing Data-Link}}

\put(27.5,75){\makebox(0,0)[cc]{Application Layer}}

\linethickness{0.3mm}
\put(7.5,80){\line(1,0){40}}
\put(7.5,70){\line(0,1){10}}
\put(47.5,70){\line(0,1){10}}
\put(7.5,70){\line(1,0){40}}
\linethickness{0.3mm}
\put(7.5,55){\line(1,0){40}}
\put(7.5,40){\line(0,1){15}}
\put(47.5,40){\line(0,1){15}}
\put(7.5,40){\line(1,0){40}}
\linethickness{0.3mm}
\put(7.5,20){\line(1,0){40}}
\put(7.5,10){\line(0,1){10}}
\put(47.5,10){\line(0,1){10}}
\put(7.5,10){\line(1,0){40}}
\linethickness{0.3mm}
\put(17.5,55){\line(0,1){15}}
\put(17.5,55){\vector(0,-1){0.12}}
\linethickness{0.3mm}
\put(17.5,20){\line(0,1){20}}
\put(17.5,20){\vector(0,-1){0.12}}
\linethickness{0.3mm}
\multiput(42.5,39.5)(0,0.5){1}{\line(0,1){0.5}}
\multiput(42.49,39)(0,0.5){1}{\line(0,1){0.5}}
\multiput(42.49,38.51)(0.01,0.5){1}{\line(0,1){0.5}}
\multiput(42.48,38.01)(0.01,0.5){1}{\line(0,1){0.5}}
\multiput(42.46,37.51)(0.01,0.5){1}{\line(0,1){0.5}}
\multiput(42.44,37.02)(0.02,0.49){1}{\line(0,1){0.49}}
\multiput(42.42,36.53)(0.02,0.49){1}{\line(0,1){0.49}}
\multiput(42.4,36.04)(0.02,0.49){1}{\line(0,1){0.49}}
\multiput(42.37,35.55)(0.03,0.49){1}{\line(0,1){0.49}}
\multiput(42.35,35.06)(0.03,0.48){1}{\line(0,1){0.48}}
\multiput(42.31,34.58)(0.03,0.48){1}{\line(0,1){0.48}}
\multiput(42.28,34.1)(0.04,0.48){1}{\line(0,1){0.48}}
\multiput(42.24,33.63)(0.04,0.47){1}{\line(0,1){0.47}}
\multiput(42.2,33.16)(0.04,0.47){1}{\line(0,1){0.47}}
\multiput(42.15,32.69)(0.04,0.47){1}{\line(0,1){0.47}}
\multiput(42.11,32.23)(0.05,0.46){1}{\line(0,1){0.46}}
\multiput(42.06,31.77)(0.05,0.46){1}{\line(0,1){0.46}}
\multiput(42,31.32)(0.05,0.45){1}{\line(0,1){0.45}}
\multiput(41.95,30.88)(0.06,0.45){1}{\line(0,1){0.45}}
\multiput(41.89,30.43)(0.06,0.44){1}{\line(0,1){0.44}}
\multiput(41.83,30)(0.06,0.43){1}{\line(0,1){0.43}}
\multiput(41.77,29.57)(0.06,0.43){1}{\line(0,1){0.43}}
\multiput(41.7,29.15)(0.07,0.42){1}{\line(0,1){0.42}}
\multiput(41.63,28.73)(0.07,0.42){1}{\line(0,1){0.42}}
\multiput(41.56,28.33)(0.07,0.41){1}{\line(0,1){0.41}}
\multiput(41.49,27.92)(0.07,0.4){1}{\line(0,1){0.4}}
\multiput(41.41,27.53)(0.08,0.39){1}{\line(0,1){0.39}}
\multiput(41.33,27.14)(0.08,0.39){1}{\line(0,1){0.39}}
\multiput(41.25,26.77)(0.08,0.38){1}{\line(0,1){0.38}}
\multiput(41.17,26.4)(0.08,0.37){1}{\line(0,1){0.37}}
\multiput(41.08,26.04)(0.09,0.36){1}{\line(0,1){0.36}}
\multiput(40.99,25.68)(0.09,0.35){1}{\line(0,1){0.35}}
\multiput(40.9,25.34)(0.09,0.34){1}{\line(0,1){0.34}}
\multiput(40.81,25)(0.09,0.33){1}{\line(0,1){0.33}}
\multiput(40.71,24.68)(0.09,0.33){1}{\line(0,1){0.33}}
\multiput(40.62,24.36)(0.1,0.32){1}{\line(0,1){0.32}}
\multiput(40.52,24.06)(0.1,0.31){1}{\line(0,1){0.31}}
\multiput(40.42,23.76)(0.1,0.3){1}{\line(0,1){0.3}}
\multiput(40.32,23.48)(0.1,0.29){1}{\line(0,1){0.29}}
\multiput(40.21,23.2)(0.1,0.28){1}{\line(0,1){0.28}}
\multiput(40.11,22.93)(0.11,0.27){1}{\line(0,1){0.27}}
\multiput(40,22.68)(0.11,0.25){1}{\line(0,1){0.25}}
\multiput(39.89,22.44)(0.11,0.24){1}{\line(0,1){0.24}}
\multiput(39.78,22.2)(0.11,0.23){1}{\line(0,1){0.23}}
\multiput(39.67,21.98)(0.11,0.22){1}{\line(0,1){0.22}}
\multiput(39.56,21.77)(0.11,0.21){1}{\line(0,1){0.21}}
\multiput(39.44,21.57)(0.11,0.2){1}{\line(0,1){0.2}}
\multiput(39.33,21.38)(0.12,0.19){1}{\line(0,1){0.19}}
\multiput(39.21,21.21)(0.12,0.18){1}{\line(0,1){0.18}}
\multiput(39.09,21.04)(0.12,0.16){1}{\line(0,1){0.16}}
\multiput(38.97,20.89)(0.12,0.15){1}{\line(0,1){0.15}}
\multiput(38.85,20.75)(0.12,0.14){1}{\line(0,1){0.14}}
\multiput(38.73,20.62)(0.12,0.13){1}{\line(0,1){0.13}}
\multiput(38.61,20.5)(0.12,0.12){1}{\line(1,0){0.12}}
\multiput(38.49,20.4)(0.12,0.1){1}{\line(1,0){0.12}}
\multiput(38.37,20.3)(0.12,0.09){1}{\line(1,0){0.12}}
\multiput(38.25,20.22)(0.12,0.08){1}{\line(1,0){0.12}}
\multiput(38.12,20.16)(0.12,0.07){1}{\line(1,0){0.12}}
\multiput(38,20.1)(0.12,0.06){1}{\line(1,0){0.12}}
\multiput(37.87,20.06)(0.12,0.04){1}{\line(1,0){0.12}}
\multiput(37.75,20.02)(0.12,0.03){1}{\line(1,0){0.12}}
\multiput(37.62,20.01)(0.12,0.02){1}{\line(1,0){0.12}}
\multiput(37.5,20)(0.12,0.01){1}{\line(1,0){0.12}}
\multiput(37.38,20.01)(0.12,-0.01){1}{\line(1,0){0.12}}
\multiput(37.25,20.02)(0.12,-0.02){1}{\line(1,0){0.12}}
\multiput(37.13,20.06)(0.12,-0.03){1}{\line(1,0){0.12}}
\multiput(37,20.1)(0.12,-0.04){1}{\line(1,0){0.12}}
\multiput(36.88,20.16)(0.12,-0.06){1}{\line(1,0){0.12}}
\multiput(36.75,20.22)(0.12,-0.07){1}{\line(1,0){0.12}}
\multiput(36.63,20.3)(0.12,-0.08){1}{\line(1,0){0.12}}
\multiput(36.51,20.4)(0.12,-0.09){1}{\line(1,0){0.12}}
\multiput(36.39,20.5)(0.12,-0.1){1}{\line(1,0){0.12}}
\multiput(36.27,20.62)(0.12,-0.12){1}{\line(1,0){0.12}}
\multiput(36.15,20.75)(0.12,-0.13){1}{\line(0,-1){0.13}}
\multiput(36.03,20.89)(0.12,-0.14){1}{\line(0,-1){0.14}}
\multiput(35.91,21.04)(0.12,-0.15){1}{\line(0,-1){0.15}}
\multiput(35.79,21.21)(0.12,-0.16){1}{\line(0,-1){0.16}}
\multiput(35.67,21.38)(0.12,-0.18){1}{\line(0,-1){0.18}}
\multiput(35.56,21.57)(0.12,-0.19){1}{\line(0,-1){0.19}}
\multiput(35.44,21.77)(0.11,-0.2){1}{\line(0,-1){0.2}}
\multiput(35.33,21.98)(0.11,-0.21){1}{\line(0,-1){0.21}}
\multiput(35.22,22.2)(0.11,-0.22){1}{\line(0,-1){0.22}}
\multiput(35.11,22.44)(0.11,-0.23){1}{\line(0,-1){0.23}}
\multiput(35,22.68)(0.11,-0.24){1}{\line(0,-1){0.24}}
\multiput(34.89,22.93)(0.11,-0.25){1}{\line(0,-1){0.25}}
\multiput(34.79,23.2)(0.11,-0.27){1}{\line(0,-1){0.27}}
\multiput(34.68,23.48)(0.1,-0.28){1}{\line(0,-1){0.28}}
\multiput(34.58,23.76)(0.1,-0.29){1}{\line(0,-1){0.29}}
\multiput(34.48,24.06)(0.1,-0.3){1}{\line(0,-1){0.3}}
\multiput(34.38,24.36)(0.1,-0.31){1}{\line(0,-1){0.31}}
\multiput(34.29,24.68)(0.1,-0.32){1}{\line(0,-1){0.32}}
\multiput(34.19,25)(0.09,-0.33){1}{\line(0,-1){0.33}}
\multiput(34.1,25.34)(0.09,-0.33){1}{\line(0,-1){0.33}}
\multiput(34.01,25.68)(0.09,-0.34){1}{\line(0,-1){0.34}}
\multiput(33.92,26.04)(0.09,-0.35){1}{\line(0,-1){0.35}}
\multiput(33.83,26.4)(0.09,-0.36){1}{\line(0,-1){0.36}}
\multiput(33.75,26.77)(0.08,-0.37){1}{\line(0,-1){0.37}}
\multiput(33.67,27.14)(0.08,-0.38){1}{\line(0,-1){0.38}}
\multiput(33.59,27.53)(0.08,-0.39){1}{\line(0,-1){0.39}}
\multiput(33.51,27.92)(0.08,-0.39){1}{\line(0,-1){0.39}}
\multiput(33.44,28.33)(0.07,-0.4){1}{\line(0,-1){0.4}}
\multiput(33.37,28.73)(0.07,-0.41){1}{\line(0,-1){0.41}}
\multiput(33.3,29.15)(0.07,-0.42){1}{\line(0,-1){0.42}}
\multiput(33.23,29.57)(0.07,-0.42){1}{\line(0,-1){0.42}}
\multiput(33.17,30)(0.06,-0.43){1}{\line(0,-1){0.43}}
\multiput(33.11,30.43)(0.06,-0.43){1}{\line(0,-1){0.43}}
\multiput(33.05,30.88)(0.06,-0.44){1}{\line(0,-1){0.44}}
\multiput(33,31.32)(0.06,-0.45){1}{\line(0,-1){0.45}}
\multiput(32.94,31.77)(0.05,-0.45){1}{\line(0,-1){0.45}}
\multiput(32.89,32.23)(0.05,-0.46){1}{\line(0,-1){0.46}}
\multiput(32.85,32.69)(0.05,-0.46){1}{\line(0,-1){0.46}}
\multiput(32.8,33.16)(0.04,-0.47){1}{\line(0,-1){0.47}}
\multiput(32.76,33.63)(0.04,-0.47){1}{\line(0,-1){0.47}}
\multiput(32.72,34.1)(0.04,-0.47){1}{\line(0,-1){0.47}}
\multiput(32.69,34.58)(0.04,-0.48){1}{\line(0,-1){0.48}}
\multiput(32.65,35.06)(0.03,-0.48){1}{\line(0,-1){0.48}}
\multiput(32.63,35.55)(0.03,-0.48){1}{\line(0,-1){0.48}}
\multiput(32.6,36.04)(0.03,-0.49){1}{\line(0,-1){0.49}}
\multiput(32.58,36.53)(0.02,-0.49){1}{\line(0,-1){0.49}}
\multiput(32.56,37.02)(0.02,-0.49){1}{\line(0,-1){0.49}}
\multiput(32.54,37.51)(0.02,-0.49){1}{\line(0,-1){0.49}}
\multiput(32.52,38.01)(0.01,-0.5){1}{\line(0,-1){0.5}}
\multiput(32.51,38.51)(0.01,-0.5){1}{\line(0,-1){0.5}}
\multiput(32.51,39)(0.01,-0.5){1}{\line(0,-1){0.5}}
\multiput(32.5,39.5)(0,-0.5){1}{\line(0,-1){0.5}}
\multiput(32.5,40)(0,-0.5){1}{\line(0,-1){0.5}}
\put(32.5,40){\vector(-0,1){0.12}}

\put(7.5,62.5){\makebox(0,0)[cc]{Send(m)}}

\put(0,27.5){\makebox(0,0)[cc]{SendPacket(m,ab)}}

\put(52.5,30){\makebox(0,0)[cc]{}}

\put(132.5,55){\makebox(0,0)[cc]{}}

\put(117.5,15){\makebox(0,0)[cc]{Physical Channel}}

\put(117.5,50){\makebox(0,0)[cc]{Stabilizing Data-Link}}

\put(117.5,75){\makebox(0,0)[cc]{Application Layer}}

\linethickness{0.3mm}
\put(97.5,80){\line(1,0){40}}
\put(97.5,70){\line(0,1){10}}
\put(137.5,70){\line(0,1){10}}
\put(97.5,70){\line(1,0){40}}
\linethickness{0.3mm}
\put(97.5,55){\line(1,0){40}}
\put(97.5,40){\line(0,1){15}}
\put(137.5,40){\line(0,1){15}}
\put(97.5,40){\line(1,0){40}}
\linethickness{0.3mm}
\put(97.5,20){\line(1,0){40}}
\put(97.5,10){\line(0,1){10}}
\put(137.5,10){\line(0,1){10}}
\put(97.5,10){\line(1,0){40}}
\linethickness{0.3mm}
\put(127.5,55){\line(0,1){15}}
\put(127.5,70){\vector(0,1){0.12}}
\linethickness{0.3mm}
\put(107.5,20){\line(0,1){20}}
\put(107.5,20){\vector(0,-1){0.12}}
\put(147.5,62.5){\makebox(0,0)[cc]{DeliverMessage(m)}}

\linethickness{0.3mm}
\put(92.5,85){\line(1,0){50}}
\put(92.5,5){\line(0,1){80}}
\put(142.5,5){\line(0,1){80}}
\put(92.5,5){\line(1,0){50}}
\linethickness{0.3mm}
\put(2.5,85){\line(1,0){50}}
\put(2.5,5){\line(0,1){80}}
\put(52.5,5){\line(0,1){80}}
\put(2.5,5){\line(1,0){50}}
\put(27.5,0){\makebox(0,0)[cc]{}}

\put(117.5,0){\makebox(0,0)[cc]{}}

\linethickness{0.3mm}
\put(47.5,17.5){\line(1,0){50}}
\put(97.5,17.5){\vector(1,0){0.12}}
\put(27.5,45){\makebox(0,0)[cc]{(Send part)}}

\put(117.5,45){\makebox(0,0)[cc]{(Receive part)}}

\put(67.5,35){\makebox(0,0)[cc]{ReceivePacket(ack,(m,ab))}}

\put(85,27.5){\makebox(0,0)[cc]{SendPacket(ack,(m,ab))}}

\put(147.5,35){\makebox(0,0)[cc]{ReceivePacket(m,ab)}}

\linethickness{0.3mm}
\put(47.5,12.5){\line(1,0){50}}
\put(47.5,12.5){\vector(-1,0){0.12}}
\put(72.5,20){\makebox(0,0)[cc]{Messages}}

\put(72.5,10){\makebox(0,0)[cc]{Acknowledgements}}

\linethickness{0.3mm}
\put(127.5,20){\line(0,1){20}}
\put(127.5,40){\vector(0,1){0.12}}
\linethickness{0.3mm}
\put(37.5,55){\line(0,1){15}}
\put(37.5,70){\vector(0,1){0.12}}
\put(52.5,62.5){\makebox(0,0)[cc]{DeliverAck(m)}}

\linethickness{0.3mm}
\put(107.5,55){\line(0,1){15}}
\put(107.5,55){\vector(0,-1){0.12}}
\put(97.5,62.5){\makebox(0,0)[cc]{Receive()}}

\end{picture}
\clearpage{}}
  \par\end{centering}
 \caption{General organization of our system.}
\label{fig:schema}
\end{figure*}

\paragraph{General organization of the system.}
Our system is organized as follows. The application layer generates messages to be send from  to . To perform this goal, it invokes our stabilizing data-link protocol. Furthermore, this layer invokes procedures provided by the physical channel.

In more details, the stabilizing data-link protocol is composed of two functions: \textbf{Send} (which is executed on the sender side) and \textbf{Receive} (which is executed on the receiver side). When the application layer on the sender side wants to send a message , it invokes \textbf{Send(m)}. \textbf{Send} procedure is blocking, that is if \textbf{Send} is already in execution, the application layer waits its termination whereas the \textbf{Receive} function is always executed on the receiver side. When the \textbf{Receive} function has a message to deliver at the application layer on the receiver side, it executes \textbf{DeliverMessage()} that transmits  to the application layer. When the \textbf{Receive} function wants to discard a synchronization message (since this kind of messages is useless to the application layer), it uses the \textbf{DropMessage} function that only deletes the message. Finally, each delivered message is acknowledged to the application layer on the sender side by \textbf{DeliverAck()}.

Functions \textbf{Send} and \textbf{Receive} must interact with the physical channel in order to exchange messages. For this, we assume that the channel provides two operations. First, it provides an operation to send a message or an acknowledgment, respectively \textbf{SendPacket(,)} and \textbf{SendPacket(ack,(,))} where  is the message and  its alternating bit value. This operation puts  (or its acknowledgment) in the channel if it is possible (if this operation leads to more than  messages in the channel, one of them is arbitrarily deleted). Second, it provides an operation to receive a message or an acknowledgment, respectively \textbf{ReceivePacket(,)} and \textbf{ReceivePacket(ack,(,))} where  is the message and  its alternating bit value. On the receiver side, \textbf{ReceivePacket(,)} is executed when the channel has a message to deliver and when \textbf{Receive} is not in execution. It sets then  and  to actual values of the delivered message. In other words, the reception (for the data-link protocol) on the receiver side is message-driven. On the sender side, \textbf{ReceivePacket(ack,(,))} is executed by the data-link protocol and does polling. That is it checks whether the first waiting message in the channel (if any) matches with an acknowledgment of the parameter (,). It returns \textbf{true} if this is the case, \textbf{false} otherwise. In any case, the first waiting message (if any) is deleted from the channel. The architecture of our system is summarized in Figure \ref{fig:schema}.

\paragraph{Detailed presentation of the protocol.}
Our -stabilizing data-link protocol  is presented as Figure \ref{algo:SDL}. In the following, we provide details about the two functions \textbf{Send} and \textbf{Receive}.

The function \textbf{Send} takes a message  as parameter and stores the current alternating bit value in the variable . First, it alternates the value of  (line 01) before sending a synchronization message (line 02) using an auxiliary function \textbf{SendMessage}. Then, lines 03 and 04 repeat these instructions with the message . Once the last invocation of \textbf{SendMessage} returns, it delivers to the application layer the acknowledgment of  using \textbf{DeliverAck}. Now, let us describe the auxiliary function \textbf{SendMessage}. This function repeatedly (while loop of line 02) sends its parameter message  (line 03) until receiving  acknowledgment for this message (line 04-05).

The function \textbf{Receive} takes no parameter and uses two variables. The first one is the alternating bit value of the last delivered or dropped message stored in  and the second one is a queue  that stores the number of receptions of at most  different messages. Each element of this queue is a  -tuple , where  is a message,  is an alternating bit value, and  is an integer denoting the number of packets  received for the corresponding  and  since the last \textbf{DeliverMessage} or \textbf{DropMessage} occurred. The queue  operator takes a message  and a boolean  as operands, and either enqueues  (if  is not present in , then if the queue contained  elements, the last element of the queue is dequeued) or returns a pointer to the  value associated to  and  in . Any time a tuple value is changed in the queue, this tuple is promoted at the top of the queue (in order to keep in memory the  latest received messages), and the size of the queue does not change. The  assignment to a queue  denotes the fact that  is emptied. At each reception of a message  (line 01), the corresponding entry in the queue is updated (or created if needed) by line 02. If  already received  copies of  since the last \textbf{DeliverMessage} or \textbf{DropMessage} occurred (test on line 03) then the queue is emptied (line 10). Moreover, if the alternating bit value of the message is different from  (test on line 04), then the message is either delivered with \textbf{DeliverMessage} (line 06) or dropped with \textbf{DropMessage} (line 08) depending if it is a synchronization message or not (test on line 05). Then, the  value is updated by line 09. Finally, in any case, the message is acknowledged to the sender with line 11.


\begin{figure*}[htb!]
\scriptsize
\centering
\begin{tabular}{|p{4.75in}|}
\hline
\vspace*{0.1cm}
\begin{minipage}[t]{4.75in}
\centering
{\it\bf Send}
\begin{tabbing}
X: \= d \= d \= d \= d \= d \= d \= d \= d \= \kill

\textbf{input:}\\ 
: message to be sent\\

\textbf{persistent variable:}\\
: boolean that states the current alternating bit value\\
\\

01: \>\> \\
02: \>\>\textbf{SendMessage}  \\
03: \>\> \\
04: \>\>\textbf{SendMessage}  \\
05: \>\>\textbf{DeliverAck} () \\
\end{tabbing}

\centering
{\it\bf SendMessage}
\begin{tabbing}
X: \= d \= d \= d \= d \= d \= d \= d \= d \= \kill

\textbf{input:}\\ 
: message to be sent\\
: boolean that states the alternating bit value associated to \\

\textbf{variable:}\\
: integer denoting the number of acknowledgments received for the current  value\\
\\

01: \>\>\\
02: \>\>\emph{while}  \\
03: \>\> \>\textbf{SendPacket}  \\
04: \>\> \>\emph{if} \textbf{ReceivePacket}  \\
05: \>\> \> \>; \\

\end{tabbing}
\end{minipage}
\tabularnewline
 \hline
\vspace*{0.1cm}
\begin{minipage}[t]{4.75in}
\centering
{\it\bf Receive}
\begin{tabbing}
X: \= d \= d \= d \= d \= d \= d \= d \= d \= \kill 

\textbf{persistent variables:}\\
\begin{minipage}{4.75in}
: boolean that states the alternating bit
value of the last delivered message\\
: queue of size  of -tuples ,
where  is a message,  is an alternating bit value,
and  is an integer denoting the number of packets
 received for the corresponding  and 
since the last \textbf{DeliverMessage} or \textbf{DropMessage} occurred.
\vspace*{0.1cm}
\end{minipage}
\\
\\
01: \>\>\emph{upon} \textbf{ReceivePacket}  \\
02: \>\> \>\\
03: \>\> \>\emph{if}  \emph{then} \\
04: \>\> \> \>\emph{if}  \emph{then}\\ 
05: \>\> \> \> \>\emph{if}  \emph{then}\\
06:\> \> \> \> \> \>\textbf{DeliverMessage} ()\\
07: \>\> \> \> \>\emph{else}\\
08:\> \> \> \> \> \>\textbf{DropMessage} ()\\
09:\> \> \> \> \>\\
10: \>\> \> \> \\
11: \>\> \>\textbf{SendPacket} \\
\end{tabbing}
\end{minipage}\1ex]
\hline
\end{tabular}
\normalsize
\caption{, a -Stabilizing Data-Link protocol} 
\label{algo:SDL}
\end{figure*}

\subsection{Correctness Proof}

In this section, let  and  be two neighboring nodes that execute ,  being the sender and  the receiver. Let  be an execution starting from an arbitrary configuration. 

We say that a message  is \emph{processed} by  when  executes \textbf{DeliverMessage} () (line 06 of \textbf{Receive} function) if  is a normal message or when  executes \textbf{DropMessage} () (line 08 of \textbf{Receive} function) if  is a  message.

First, we need two preliminaries results related to the result of the execution of the procedure \textbf{SendMessage} by  depending on the configuration in which  starts to execute this procedure.

\begin{lemma}\label{lem:firstabneqld}
When  starts to execute \textbf{SendMessage}  in a configuration where  , the message  (either a  message or a normal message) and every message parameter to a subsequent invocation of \textbf{SendMessage} is processed by  in a finite time.
\end{lemma}

\begin{proof}
Consider a configuration  where . Assume that  starts to execute \textbf{SendMessage}  in . By contradiction, assume  is never processed by  in the remainder of . That is,  never executes lines 06 or 08 in the \textbf{Receive} procedure. In turn, tests on lines 03 or 04 never evaluate to true simultaneously. 

As  in  and  may change only when  is processed (line 09), we know that the test on line 04 is always true (since  is never processed by assumption).

This implies that  never evaluates to true (test on line 03). This implies that the sender stops sending  before the  counter reached , which is impossible. The reason is as follows. In order to stop sending the same message,  must get  acknowledgments with the expected content . If such  acknowledgments are indeed received, this implies that the receiver issued at least  of those acknowledgments, and thus received  packets . Consider the first such packet  received by . If there is no reset of 's queue following this packet, the head of the queue now contains an entry  that can not be deleted until the receiver resets the entire queue. Indeed, at most  packets are initially present in the receiver's input channel, that can create at most  entries in the queue. Since the queue is of size , the  tuple remains. Now, if the receiver sends  packets , it implies that the receiver's queue for entry  was incremented  times, which invalidates the assumption. It follows that  is processed in a finite time.

Note that after the processing of ,  and  have the same value with the execution of the line 09 of \textbf{Receive} procedure. Hence the next invocation of the \textbf{SendMessage} primitive by  will make the values  and  different. Applying the above reasoning, the lemma follows.
\end{proof}

\begin{lemma}\label{lem:firstab=ld}
When  starts to execute \textbf{SendMessage}  in a configuration where  , only  (either a  message or a normal message) is not processed by .
\end{lemma}

\begin{proof}
Consider a configuration  where . Assume that  starts to execute \textbf{SendMessage}  in .

Since the test in the line 04 of the \textbf{Receive} procedure evaluates to false, the processing of  is not executed. However, since  keeps sending  and  acknowledges these packets the \textbf{SendMessage} procedure returns. Note that  executes line 01 or 03 of the \textbf{Send} procedure before the next invocation of \textbf{SendMessage} procedure.
 
It follows that the system reaches in a finite time a configuration where . Then, Lemma \ref{lem:firstabneqld} implies that every message that is parameter of subsequent invocations of \textbf{SendMessage} is eventually processed by . 
\end{proof}

Now, we can prove that  satisfies the four properties of the specification (see Section \ref{sub:specification}) starting from any configuration.

\begin{lemma}\label{lem:loss}
 satisfies the 0-Loss property.
\end{lemma}

\begin{proof}
Assume that  has to send a message  to  starting from an arbitrary configuration. Note that proofs of Lemmas \ref{lem:firstabneqld} and \ref{lem:firstab=ld} imply that any invocation of the \textbf{Send} procedure eventually ends. This implies in turn that  starts to execute \textbf{Send} in a finite time. 

Then,  invokes first \textbf{SendMessage} with a  message as parameter (see line 02 of the \textbf{Send} procedure). Note that this  message may be lost if  when  starts to execute \textbf{SendMessage} by Lemma \ref{lem:firstab=ld}. 

Then, following Lemma \ref{lem:firstab=ld} that we have  when  starts to execute \textbf{SendMessage} with  as parameter (see line 04 of the \textbf{Send} procedure) since it has executed line 03 of the \textbf{Send} procedure. By Lemma \ref{lem:firstabneqld}, it follows that  is eventually processed by . As  is a normal message, this implies by definition that  is delivered to  in a finite time.

As this result holds whatever the state of the system when  requests to send , we obtain that . It is sufficient to observe that  to obtain the result.
\end{proof}

\begin{lemma}\label{lem:duplication}
 satisfies the 1-Duplication property.
\end{lemma}

\begin{proof}
By contradiction, assume that there exists an execution  of  such that . In particular, this property is true for . Hence, . In other words, there exists in  a message  sent by  delivered several times to . Moreover  is not the first message received by .

This implies that the line 06 in the \textbf{Receive} procedure is executed several times for the message . It is impossible and the reason is the following. After the first delivery of  the receiver empties the queue and makes  (see proof of Lemma \ref{lem:firstab=ld}). Note that  modifies  only when it stops to send . Even if  keeps invoking \textbf{SendPacket}  until it receives the  acknowledgments, none of these messages will be delivered since for each of them the test in line 04 in the \textbf{Receive} procedure returns false.

This contradiction implies that only the first message received by  may be duplicate. The lemma follows. 
\end{proof}

\begin{lemma}\label{lem:creation}
 satisfies the 1-Creation property.
\end{lemma}

\begin{proof}
By contradiction, assume that there exists an execution  of  such that . In particular, this property is true for . Hence, . In other words, there exists in  a message  not sent by  but delivered to . Moreover  is not the first message received by .

Initially the channel  may contain at most  ghosts messages. In the worst case, the receiver's queue also contains an entry for each of the ghost with the counters initialized to  or .

Let  be the first ghost message received by  with alternated bit set to . Let us study the two possible cases. First, assume that . Then  delivers  (line 06 of \textbf{Receive} procedure) and empties the queue (line 10 of \textbf{Receive} procedure). Second, assume that . Then  does not deliver  (due to the test of line 04 of \textbf{Receive} procedure) but it empties the queue (line 10 of \textbf{Receive} procedure).

In both cases, there is at most one ghost message delivered to  and the queue has been emptied. In turn, it remains now at most  ghosts messages in the channel . If one of them is received by  (after an invocation of \textbf{ReceivePacket}), its associated counter cannot reach the value  (unless  starts to send the same message but in this case, it is no longer a ghost message) since there are at most  copies of the same message. Consequently, none of the  remaining ghost messages can be delivered, that contradicts the construction of  and proves the result.  
\end{proof}

\begin{lemma}\label{lem:reordering}
 satisfies the 1-Reordering property.
\end{lemma}

\begin{proof}
Following Lemma \ref{lem:creation},  delivers at most one ghost message to  in . Let us consider the two following possible cases.

\begin{description}
\item[Case 1:]  delivers no ghost message to  in .\\
According to Lemmas \ref{lem:loss} and \ref{lem:duplication}, any message sent from  is delivered to  exactly once in this case. Now, observe that any message is delivered to  between the beginning and the end of the corresponding execution of the procedure \textbf{Send} by . Indeed, the message is delivered to  when it receives the -th copy of the message whereas  waits to receive the -th acknowledgment of the message to stop sending it (see proof of Lemmas \ref{lem:firstabneqld} and \ref{lem:firstab=ld}). Since the \textbf{Send} procedure is blocking for ,  for any execution  where  delivers no ghost message to . Hence, .
\item[Case 2:]  delivers one ghost message to  in .\\
Assume that the ghost message delivered by  is . Lemma \ref{lem:creation} allows us to state that  is the first message delivered to . Then, a similar reasoning to the one of case 1 allows us to conclude that  for any execution  where  delivers one ghost message  to  and then, . Hence, .
\end{description}

In both cases, we show that  satisfies the 1-Reordering property.
\end{proof}

Now, we can conclude on the following corollary of Lemmas \ref{lem:loss}, \ref{lem:duplication}, \ref{lem:creation} and \ref{lem:reordering}.

\begin{theorem}
 satisfies the -Stabilizing Data-Link Communication specification.
\end{theorem}

\section{Conclusion}\label{sec:conclusion}

In this paper, we focused on stabilizing data-link protocols over channels of bounded capacity . First, we introduced some measures for fault-resilience following the specification presented in \cite{L96b} that is suitable to the self-stabilizing setting. Then, we proved lowers bounds on these parameters. Finally, we proposed a stabilizing data-link protocol that emulates FIFO reliable links over unreliable bounded non-FIFO communication environment with an optimal fault-resilience. To achieve this optimal fault-resilience, our protocol sends  packets (and their corresponding acknowledgements) to deliver one message to the application layer.

Some interesting open questions follow. Is it possible to achieve optimal fault-resilience with a (significantly) lower message complexity for a given channel capacity ? Recently, some works on snap-stabilizing point-to-point communication \cite{CDV09ca,CDV09cb,CDLPV10c} across multiples hops have been presented in a coarse grained communication model. Is it possible to extend these results to the more realistic message passing model using our Stabilizing Data-link as a communication black box? If so, is it possible to provide optimal fault resilience as in the one hop case?

\bibliographystyle{plain}
\bibliography{biblio}

\end{document}                 
