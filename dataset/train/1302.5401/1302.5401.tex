\documentclass[12pt]{article}
\usepackage[dvips]{epsfig}
\usepackage{amsmath,amssymb,amsfonts,enumerate,bbm}
\usepackage{caption}
\usepackage{url}
\usepackage{ifthen}
\usepackage{graphicx}

\usepackage{subfigure}
\usepackage[pdftex]{hyperref}
\usepackage{color,soul}

\newcommand{\Ot}{\tilde{O}}


\long\def\commabs #1\commabsend{}
\long\def\commful #1\commfulend{}
\long\def\comment #1\commentend{}


\setlength{\textheight}{8.9in}
\setlength{\textwidth}{6.3in}
\setlength{\evensidemargin}{-0.1in}
\setlength{\oddsidemargin}{-0.1in}
\setlength{\headheight}{10pt}
\setlength{\headsep}{10pt}
\setlength{\topsep}{0.1in}
\setlength{\topmargin}{0.0in}
\setlength{\itemsep}{0in}
\renewcommand{\baselinestretch}{1.1}
\parskip=0.07in



\newtheorem{theorem}{Theorem}[section]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{observation}[theorem]{Observation}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{claim}[theorem]{Claim}
\newtheorem{fact}[theorem]{Fact}
\newtheorem{definition}[theorem]{Definition}

\newcommand{\REAL}{\mathbb R}
\def\deg{\mbox{\tt deg}}
\def\depth{\mbox{\tt depth}}
\def\LCA{\mbox{\tt LCA}}
\def\Port{\mbox{\tt Port}}
\def\Set{\mathfrak{F}}

\def\Cost{\mbox{\tt Cost}}
\def\TreeCost{\mbox{\tt TreeCost}}
\newcommand{\dist}{\mbox{\rm dist}}
\def\origpath{{\cal P}}
\def\shortcutpath{{\cal P}^*}
\def\TC{\mbox{\sf Tree\_Cons}}
\def\FP{\mbox{\sf Find\_Paths}}
\def\ME{\mbox{\sf Merge}}
\def\MAIN{\mbox{\sf Main}}
\def\cC{{\cal C}}

\def\inline#1:{\par\vskip 7pt\noindent{\bf #1:}\hskip 10pt}
\def\Proof{\par\noindent{\bf Proof:~}}
\def\blackslug{\hbox{\hskip 1pt \vrule width 4pt height 8pt
    depth 1.5pt \hskip 1pt}}
\def\QED{\quad\blackslug\lower 8.5pt\null\par}
\def\inQED{\quad\quad\blackslug}


\newcommand{\Figure}[0]{Figure}

\newcommand{\cS}[0]{{\cal S}}
\newcommand{\Sensitive}[0]{{\mathcal{S}}}
\newcommand{\New}[0]{\mbox{\tt New}}
\def\LAB{\mbox{\tt Label}}
\def\LABArray{\mbox{\tt LArray}}
\def\NodeB{\mbox{\tt N}}
\def\EdgeF{\mbox{\tt E}}
\def\LastE{\mbox{\tt LastE}}
\def\NewP{\mbox{\tt NewP}}

\def\NSource{\sigma}
\def\Root{\mbox{\tt r}}
\def\Leaf{\mbox{\tt Leaf}}
\def\NLeaf{\mbox{\tt nLeaf}}
\def\NodesIn{\mbox{\tt N}}

\def\Diameter{\mbox{\tt Diam}}
\def\Depth{\mbox{\tt Depth}}

\def\FTMBFS{\mbox{\tt FT-MBFS}}
\def\FTMFCBFS{\mbox{\tt FT-FCMBFS}}
\def\FCBFS{\mbox{\tt FCBFS}}
\def\MultiBFS{multi-source BFS}

\def\FTBFS{\mbox{\tt FT-BFS}}
\def\ApproxSetCover{\mbox{\tt ApproxSetCover}}
\def\dnsitem{\vspace{-4pt}\item}
\def\dnsparagraph#1{\par\vspace{2pt}\noindent{\bf #1}.}

\pagestyle{plain}
\begin{document}





\title{Sparse Fault-Tolerant BFS Trees}
\author{
Merav Parter
\thanks{The Weizmann Institute of Science, Rehovot, Israel.
Email: {\tt \{merav.parter,david.peleg\}@ weizmann.ac.il}.
Supported in part by the Israel Science Foundation
(grant 894/09), the United States-Israel Binational Science Foundation
(grant 2008348), the Israel Ministry of Science and Technology
(infrastructures grant), and the Citi Foundation.}
\thanks{Recipient of the Google Europe Fellowship in distributed computing;
 research supported in part by this Google Fellowship.}
\and
David Peleg 
}


\maketitle

\begin{abstract}
A {\em fault-tolerant} structure for a network is required to continue
functioning following the failure of some of the network's edges or vertices.
This paper considers {\em breadth-first search (BFS)} spanning trees,
and addresses the problem of designing a sparse {\em fault-tolerant} BFS tree,
or {\em FT-BFS tree} for short, namely, a sparse subgraph  of the given network 
such that subsequent to the failure of a single edge or vertex,
the surviving part  of  still contains a BFS spanning tree for
(the surviving part of) . For a source node , a target node  and an edge , the shortest  path  that does not go through   is known as a \emph{replacement path}. Thus, our \FTBFS\ tree contains the collection of all replacement paths  for every  and every failed edge .
\par
Our main results are as follows. We present an algorithm that
for every -vertex graph  and source node  constructs
a (single edge failure) \FTBFS\ tree rooted at  with
 edges,
where  is the depth of the BFS tree rooted at .
This result is complemented by a matching lower bound, showing that
there exist -vertex graphs with a source node  for which any edge
(or vertex) \FTBFS\ tree rooted at  has  edges.
\par
We then consider {\em fault-tolerant multi-source BFS trees},
or {\em \FTMBFS\ trees} for short,
aiming to provide (following a failure) a BFS tree rooted at each source
 for some subset of sources .
Again, tight bounds are provided,
showing that there exists a poly-time algorithm that
for every -vertex graph and source set  of size 
constructs  a (single failure) \FTMBFS\ tree
 from each source , with 
edges, and on the other hand there exist -vertex graphs with source sets
 of cardinality , on which any \FTMBFS\
tree from  has  edges.
\par
Finally, we propose an  approximation algorithm for constructing
\FTBFS\ and \FTMBFS\ structures. The latter is complemented by a hardness
result stating that there exists no  approximation algorithm
for these problems under standard complexity assumptions. In comparison with the randomized  construction implicit in \cite{GW12},
our algorithm is deterministic  and may improve the number of edges
by a factor of up to  for some instances.
All our algorithms can be extended to deal with one \emph{vertex} failure as well, with the same performance.
\end{abstract}

\section{Introduction}
\paragraph{Background and motivation}
Modern day communication networks support a variety of logical structures
and services, and depend on their undisrupted operation.
As the vertices and edges of the network may occasionally fail or malfunction,
it is desirable to make those structures robust against failures.
Indeed, the problem of designing fault-tolerant constructions for various
network structures and services has received considerable attention
over the years.

Fault-resilience can be introduced into the network in several different ways.
This paper focuses on a notion of fault-tolerance whereby the structure at hand
is augmented or ``reinforced'' (by adding to it various components)
so that subsequent to the failure of some of the network's vertices or edges,
the surviving part of the structure is still operational.
As this reinforcement carries certain costs, it is desirable to minimize the number of added components.

To illustrate this type of fault tolerance,
let us consider the structure of graph -spanners
(cf. \cite{Peleg00:book,PelegS-89,PelegU-89}).
A graph spanner  can be thought of as a skeleton structure
that generalizes the concept of spanning trees and allows us
to faithfully represent the underlying network using few edges,
in the sense that for any two vertices of the network, the distance
in the spanner is stretched by only a small factor.
More formally, consider a weighted graph  and let  be an integer.
Let  denote the (weighted) distance between  and  in .
Then a -spanner  satisfies that
 for every .
\par Towards introducing fault tolerance, we say that a subgraph  is
an {\em -edge fault-tolerant -spanner} of  if

for any set  of size at most ,
and any pair of vertices . A similar definition applies to
-vertex fault-tolerant -spanners. Sparse fault-tolerant spanner
constructions were presented in \cite{CLPR09-span,DK11}.

This paper considers {\em breadth-first search (BFS)} spanning trees,
and addresses the problem of designing {\em fault-tolerant} BFS trees,
or {\em \FTBFS}\ trees for short.
By this we mean a subgraph  of the given network ,
such that subsequent to the failure of some
of the vertices or edges,
the surviving part  of  still contains a BFS spanning tree for
the surviving part of .
We also consider a generalized structure referred to as a
{\em fault-tolerant multi-source BFS tree}, or {\em \FTMBFS\ tree} for short,
aiming to provide a BFS tree rooted at each source  for some subset
of sources .

The notion of {\em \FTBFS}\ trees is closely related to the problem of
constructing \emph{replacement paths} and in particular to its
{\em single source} variant,
the \emph{single-source replacement paths} problem,
studied in \cite{GW12}. That problem requires to compute the collection
 of all  replacement paths  for every 
and every failed edge  that appears on the  shortest-path in .
The vast literature on \emph{replacement paths} (cf. \cite{BK09,GW12,RTREP05,TZ05,WY10}) focuses on \emph{time-efficient} computation of the these paths as well as their efficient maintenance in data structures (a.k.a {\em distance oracles}).
In contrast, the main concern in the current paper is with optimizing
the \emph{size} of the resulting fault tolerant structure that contains the
collection  of all replacement paths given a source node .
A typical motivation for such a setting is where the graph edges represent
the channels of a communication network, and the system designer would like
to purchase or lease a minimal collection of channels
(i.e., a subgraph ) that maintains its functionality
as a ``BFS tree" with respect to the source  upon any single
edge or vertex failure in .
In such a context, the cost of computation at the preprocessing stage may
often be negligible compared to the purchasing/leasing cost of the resulting
structure. Hence, our key cost measure in this paper is the \emph{size} of
the fault tolerant structure, and our main goal is to achieve {\em sparse}
(or {\em compact}) structures.

Most previous work on sparse / compact fault-tolerant structures and services
concerned structures that are {\em distance-preserving}
(i.e., dealing with distances, shortest paths or shortest routes),
{\em global} (i.e., centered on ``all-pairs'' variants),
and {\em approximate} (i.e., settling for near optimal distances),
such as {\em spanners}, {\em distance oracles} and
{\em compact routing schemes}.
The problem considered here, namely, the construction of \FTBFS\ trees,
still concerns a distance preserving structure.
However, it deviates from tradition with respect to the two other features,
namely, it concerns a ``single source'' variant,
and it insists on exact shortest paths.
Hence our problem is on the one hand easier, yet on the other hand harder,
than previously studied ones.
Noting that in previous studies, the ``cost'' of adding fault-tolerance
(in the relevant complexity measure) was often low (e.g., merely polylogarithmic
in the graph size ),
one might be tempted to conjecture that a similar phenomenon may reveal itself
in our problem as well.
Perhaps surprisingly, it turns out that our insistence on exact distances
plays a dominant role and makes the problem significantly harder,
outweighing our willingness to settle for a ``single source'' solution.

\paragraph{Contributions}
We obtain the following results.
In Sec. \ref{sec:prelim}, we define the \emph{Minimum \FTBFS} and
\emph{Minimum \FTMBFS} problems, aiming at finding the minimum such
structures tolerant against a single edge or vertex fault.
Section \ref{sc:lb} presents lower bound constructions for these problems.
For the single source case, in Subsec. \ref{sc:lb_single}, we present a lower bound stating that for every  there exists an -vertex
graph and a source node  for which any
\FTMBFS\ tree from  requires  edges.
In Subsec. \ref{sec:multiedge_lb},
we then show that there exist
-vertex graphs with source sets  of size ,
on which any \FTMBFS\ tree from the source set  has
 edges.

These results are complemented by matching upper bounds.
In Subsec. \ref{subsec:1edge_alg}, we present a simple algorithm that for every
-vertex graph  and source node , constructs a (single edge failure)
\FTBFS\ tree rooted at  with  edges.
A similar algorithm yields an \FTBFS\ tree tolerant to one vertex failure,
with the same size bound.
In addition, for the multi source case, in Subsec. \ref{subsec:multisource}, we show that there exists a polynomial
time algorithm that for every -vertex graph and source set 
of size  constructs  a (single failure) \FTMBFS\ tree 
from each source , with  edges.

In Sec. \ref{sec:hardness}, we show that the minimum \FTBFS\ problem is NP-hard and moreover, cannot be approximated
(under standard complexity assumptions) to within a factor of ,
where  is the number of vertices of the input graph .
Note that while the algorithms of Sec. \ref{sec:upper} match the worst-case lower bounds, they might still be far from optimal for certain instances, as illustrated
in Sec. \ref{sec:approx}.  Consequently, in Sec. \ref{sec:approx}, we complete the upper bound analysis by presenting an  approximation algorithm for the Minimum \FTMBFS\ problem.
This approximation algorithm is superior in instances where the graph enjoys
a sparse \FTMBFS\ tree, hence paying  edges
(as does the algorithm of Sec. \ref{sec:upper}) is wasteful.
In light of the hardness result for these problems (of Sec. \ref{sec:hardness}),
the approximability result is tight (up to constants).

\paragraph{Related work}
To the best of our knowledge, this paper is the first to study
the sparsity of fault-tolerant BFS structures for graphs.
The question of whether it is possible to construct a sparse fault tolerant
\emph{spanner} for an arbitrary undirected weighted graph,
raised in \cite{CZ03},
was answered in the affirmative in \cite{CLPR09-span}, presenting algorithms
for constructing an -vertex fault tolerant -spanner
of size  and an
-edge fault tolerant  spanner of size 
for a graph of size .
A randomized construction attaining an improved tradeoff for vertex
fault-tolerant spanners was shortly afterwards presented in \cite{DK11},
yielding (with high probability) for every graph ,
odd integer  and integer , an -vertex fault-tolerant -spanner
with  edges.
This should be contrasted with the best stretch-size tradeoff currently
known for non-fault-tolerant spanners \cite{TZ01}, namely,
 stretch with  edges.

An efficient algorithm that given a set  of  points
in -dimensional Euclidean space constructs an -vertex
fault tolerant geometric -spanner for , namely,
a sparse graph  satisfying that
 for any set
 of size  and any pair of points ,
was presented in \cite{LNS98}. A fault tolerant geometric spanner
of improved size was later presented in \cite{L99}; finally,
a fault tolerant geometric spanner of optimal maximum degree
and total weight was presented in \cite{CZ03}.
The distinction between the stronger type of fault-tolerance obtained
for geometric graphs (termed {\em rigid} fault-tolerance)
and the more flexible type required for handling general graphs
(termed {\em competitive} fault-tolerance) is elaborated upon in \cite{P09}.

A related network service is the {\em distance oracle} \cite{BS06,RTZ05,TZ05},
which is a succinct data structure capable of supporting
efficient responses to distance queries on a weighted graph .
A distance query  requires finding,
for a given pair of vertices  and  in , the distance
(namely, the length of the shortest path) between  and  in .
The query protocol of an oracle  correctly answers distance queries on .
In a {\em fault tolerant distance oracle}, the query
may include also a set  of failed edges or vertices (or both),
and the oracle  must return, in response to a query ,
the distance between  and  in .
Such a structure is sometimes called an {\em -sensitivity distance oracle}.
The focus is on both fast preprocessing time, fast query time and low space.
It has been shown in~\cite{DTCR08} that given a directed weighted graph 
of size , it is possible to construct in time 
a -sensitivity fault tolerant distance oracle of size 
capable of answering distance queries in  time in the presence
of a single failed edge or vertex.
The preprocessing time was recently improved to ,
with unchanged size and query time ~\cite{BK09}.
A -sensitivity fault tolerant distance oracle of size ,
capable of answering -sensitivity queries in  time,
was presented in~\cite{DP09}.
\par
Recently, distance sensitivity oracles have been considered for weighted
and directed graphs in the \emph{single source} setting \cite{GW12}.
Specifically, Grandoni and Williams considered the problem of
\emph{single-source replacement paths} where one aims to compute
the collection of all replacement paths for a given source node ,
and proposed an efficient randomized algorithm that does so in
 where  is the time required to compute
all-pairs-shortest-paths in a weighted graph with integer weights .
Interestingly, although their algorithm does not aim explicitly at minimizing
the total number of edges used by the resulting collection of
replacement paths, one can show that the resulting construction yields
a rather sparse path collection, with at most  edges
(although it may also be far from optimal in some instances).


Label-based fault-tolerant distance oracles for graphs of bounded clique-width
are presented in \cite{CT07}. The structure is composed of a label 
assigned to each vertex , and handles queries of the form 
for a set of failures . For an -vertex graph of tree-width or
clique-width , the constructed labels are of size .

A relaxed variant of distance oracles, in which distance queries are answered
by {\em approximate} distance estimates instead of {\em exact} ones,
was introduced in~\cite{TZ05}, where it was
shown how to construct, for a given weighted undirected -vertex graph ,
an approximate distance oracle of size 
capable of answering distance queries in  time,
where the {\em stretch} (multiplicative approximation factor)
of the returned distances is at most .
\par
An -sensitivity approximate distance oracle  was presented in
\cite{CLPR09-do}.
For an integer parameter , the size of  is
, where  is the weight of the
heaviest edge in , the stretch of the returned distance is ,
and the query time is ,
where  is the distance between  and  in .
\par
A fault-tolerant label-based -approximate distance oracle
for the family of graphs with doubling dimension bounded by 
is presented in \cite{ACGP10}.
For an -vertex graph  in this family,
and for desired precision parameter ,
the distance oracle constructs and stores
an -bit label at each vertex.
Given the labels of two end-vertices  and  and of collections 
and  of failed (or ``forbidden'') vertices and edges,
the oracle computes, in time polynomial in the length of the labels,
an estimate for the distance between  and  in the surviving graph
, which approximates the true distance
by a factor of .

Our final example concerns fault tolerant routing schemes.
A fault-tolerant routing protocol is a distributed algorithm
that, for any set of failed edges , enables any source vertex 
to route a message to any destination vertex  along a shortest
or near-shortest path in the surviving network 
in an efficient manner (and without knowing  in advance).
\par
In addition to route efficiency, it is often desirable to optimize also
the amount of memory stored in the routing tables of the vertices, possibly
at the cost of lower route efficiency, giving rise to the problem
of designing compact routing schemes
(cf. \cite{ABLP-89:stoc,S12,Peleg00:book,PU-89:tables,TZ01}).

Label-based fault-tolerant routing schemes for graphs of
bounded clique-width are presented in \cite{CT07}.
To route from  to , the source needs to specify the labels
 and  and the set of failures , and the scheme
efficiently calculates the shortest path between  and  that avoids .
For an -vertex graph of tree-width or clique-width , the
constructed labels are of size .
\par
Fault-tolerant compact routing schemes are considered
in \cite{CLPR09-do}, for up to two edge failures.
Given a message  destined to  at a source vertex , in the
presence of a failed edge set  of size  (unknown to ),
the scheme presented therein routes  from  to 
in a distributed manner, over a path of length at most  times
the length of the optimal path (avoiding ).
The total amount of information stored in vertices of 
on average is bounded by .
This should be compared with the best memory-stretch tradeoff currently
known for non-fault-tolerant compact routing \cite{TZ01}, namely,
 stretch with  memory per vertex.
\par
A compact routing scheme capable of handling multiple edge failures
is presented in \cite{S12}.
The scheme routes messages (provided their source  and destination 
are still connected in the surviving graph )
over a path whose length is proportional to the distance between  and 
in , to  and to some poly-log factor.
The routing table required at a node  is of size proportional to
's degree and some poly-log factor.
\par
A routing scheme with stretch  for graphs of bounded
doubling dimension is also presented in \cite{ACGP10}.
The scheme can be generalized also to the family of weighted graphs
of bounded doubling dimension and bounded degree.
In this case, the label size will also depend linearly on the maximum
vertex degree , and this is shown to be necessary.

\section{Preliminaries}
\label{sec:prelim}
\paragraph{Notation}
Given a graph  and a source node , let  be
a shortest paths (or BFS) tree rooted at . For a source node set ,
let  be a union of the single source BFS trees.
Let  be the  shortest-path in tree , when the tree , we may omit it and simply write .
Let  be the set of  neighbors in . Let  be the set of edges incident to 
in the graph  and let  denote the degree of node  in . When the graph  is clear from the context,
we may omit it and simply write .
Let  denote the {\em depth} of 
in the BFS tree . When the source node  is clear from the context,
we may omit it and simply write .
Let  be the {\em depth}
of .
For a subgraph 
(where  and )
and a pair of nodes , let  denote the
shortest-path distance in edges between  and  in .
For a path , let  be the last edge of path . Let  denote the length of the path and  be the subpath of  from  to . For paths  and ,  denote the path obtained by concatenating  to . Assuming an edge weight function , let  be the set of  shortest-paths in  according to the edge weights of .  Throughout, the edges of these paths are considered to be directed away from the source node . Given an  path  and an edge , let  be the distance (in edges) between  and  on . In addition, for an edge , define  if  and .
\begin{definition}
A graph  is an edge (resp., vertex) \FTBFS\ tree for  with respect to a source node , iff for every edge  (resp., vertex ) and for every ,

\par
A graph  is an edge (resp., vertex) \FTMBFS\ tree for  with respect to source set , iff for every edge  (resp., vertex ) and for every  and ,

\end{definition}
To avoid cumbersome notation, we refer to
edge \FTBFS\ (resp., edge \FTMBFS) trees simply by \FTBFS\ (resp., \FTMBFS) trees. Throughout, we focus on edge fault, yet the entire analysis extends trivially to the case of vertex fault as well.

\paragraph{The Minimum \FTBFS\ problem}
Denote the set of solutions for the instance  by
.
Let 
be the minimum number of edges in any \FTBFS\ subgraph of .
These definitions naturally extend to the multi-source case where we are
given a source set  of size .
Then 
and 
\par In the \emph{Minimum \FTBFS} problem we are given a graph  and a
source node  and the goal is to compute an \FTBFS\ 
of minimum size, i.e., such that .
Similarly, in the \emph{Minimum \FTMBFS} problem we are given a graph  and a
source node set  and the goal is to compute an \FTMBFS\

of minimum size i.e., such that .

\section{Lower Bounds}
\label{sc:lb}
In this section we establish lower bounds on the size of the \FTBFS\ and
\FTMBFS\ structures.
In Subsec. \ref{sc:lb_single} we consider the single source case and
in Subsec. \ref{sec:multiedge_lb} we consider the case of multiple sources.

\subsection{Single Source}
\label{sc:lb_single}
We begin with a lower bound for the case of a single source.
\begin{theorem}
\label{thm:lowerbound_edgeonef}
There exists an -vertex graph  and a source node  such
that any \FTBFS\ tree rooted at  has  edges,
i.e., .
\end{theorem}
\Proof
Let us first describe the structure of the graph .
Set .

The graph consists of four main components.
The first is a path  of length .
The second component consists of a node set 
and a collection of  disjoint paths of deceasing length, ,
where  connects  with  and its length is , for every .
Altogether, the set of nodes in these paths, ,
is of size .
The third component is a set of nodes  of size ,
all connected to the terminal node .
The last component is a complete bipartite graph 
connecting  to .
Overall,  and .
Note that  for sufficiently large . Consequently,
, and .

\begin{figure}[htb!]
\begin{center}
\includegraphics[scale=0.36]{lowerboundonef}
\caption{Lower bound construction for \FTBFS\.
The original BFS tree consists of the non-dashed edges.
The dashed edges are the ones necessary to make it an \FTBFS\ tree.
For example, the bold dashed edge  is required
upon failure of the edge . \label{fig:lowerbound1f}}
\end{center}
\end{figure}

A BFS tree  rooted at  for this 
(illustrated by the solid edges in Fig. \ref{fig:lowerbound1f})
is given by

where  for every .
We now show that every \FTBFS\ tree  must contain
all the edges of , namely, the edges 
for every  and 
(the dashed edges in Figure \ref{fig:lowerbound1f}).
Assume, towards contradiction, that there exists
a  that does not contain 
(the bold dashed edge  in the figure).
(the bold dashed edge  in Figure \ref{fig:lowerbound1f}).
Note that upon the failure of the edge ,
the unique  shortest-path connecting  and  in
 is ,
and all other alternatives are strictly longer.
Since , also , and therefore
,
in contradiction to the fact that  is an \FTBFS\ tree.
It follows that every \FTBFS\ tree  must contain at least
 edges. The theorem follows.
\QED

\subsection{Multiple Sources}
\label{sec:multiedge_lb}
We next consider an intermediate setting where it is necessary to construct
a fault-tolerant subgraph \FTMBFS\ containing several \FTBFS\ trees in parallel,
one for each source  , for some .
We establish the following.
\begin{theorem}
\label{thm:lowerbound_f_multisource}
There exists an -vertex graph  and a source set 
of cardinality , such that any \FTMBFS\ tree from
the source set  has  edges,
i.e., .
\end{theorem}
\Proof
Our construction is based on the graph ,
which consists of three components:
(1) a set of vertices  connected by a path
,
(2) a set of terminal vertices 
(viewed by convention as ordered from left to right),
and
(3) a collection of  vertex disjoint paths  of length
 connecting  and 
for every .
Thus .
The vertex  is fixed as the root of , hence
the edges of the paths  are viewed as directed away from ,
and the terminal vertices of  are viewed as the \emph{leaves} of the graph,
denoted .
See Fig. \ref{fig:lowerboundg1} for illustration.

\begin{figure}[h!]
\begin{center}
\includegraphics[scale=0.4]{g1}
\caption{\label{fig:lowerboundg1} The graph .}
\end{center}
\end{figure}

Overall, the vertex and edge sets of  are
 and
.

\begin{observation}
\label{obs:rel}
\begin{description}
\item{(a)}
The number of leaves in  is .
\item{(b)}
 for some constant .
\end{description}
\end{observation}

Take  copies, , of ,
where .
Note that Obs. \ref{obs:rel}, each copy  consists of 
nodes.
Let  be the node  and  in the th copy .
Add a node  connected to a set  of  nodes and connect 
to each of the nodes , for .
Finally, connect the set  to the  leaf sets
 by a complete bipartite graph,
adjusting the size of the set  in the construction so that .
Since  (see Obs. \ref{obs:rel}),
overall .
Since the path from each source  to  cannot aid the nodes of 
for , the analysis of the single-source case can be applied
to show that each of the bipartite graph edges in necessary
upon a certain edge fault.
See Fig. \ref{fig:lowerboundmulti} for an illustration.
\QED

\begin{figure}[h!]
\begin{center}
\includegraphics[scale=0.5]{lowerboundmulti_new}
\caption{\label{fig:lowerboundmulti}
Illustration of the lower bound for the multi-source case.}
\end{center}
\end{figure}



\section{Upper Bounds}
\label{sec:upper}
In this section we provide tight matching upper bounds to the lower bounds
presented in Sec. \ref{sc:lb}.

\subsection{Single Source}
\label{subsec:1edge_alg}
For the case of \FTBFS\ trees, we establish the following.
\begin{theorem}
There exists an  time algorithm that for every -vertex graph 
and source node  constructs an \FTBFS\ tree rooted at  with
 edges.
\end{theorem}
To prove the theorem, we first describe a simple algorithm for the problem
and then prove its correctness and analyze the size
of the resulting \FTBFS\ tree.
We note that using the sparsity lemma of \cite{RTREP05} and the tools of
\cite{GW12}, one can provide a randomized construction for an \FTBFS\ tree
with  edges with high probability.
In contrast, the algorithm presented in this paper is
\emph{deterministic} and achieve an \FTBFS\ tree with  edges,
matching exactly the lower bound established in Sec. \ref{sc:lb}.

\paragraph{The Algorithm}
To avoid complications due to shortest-paths of the same length,
we assume all shortest-path are computed with a weight assignment 
that guarantees the uniqueness of the shortest-paths. This can be achieved
by considering
a weight function  defined so as to ensure that the shortest paths are also
of minimal number of edges but at the same time guarantees the uniqueness
of the  shortest-path, for every . Let  be some arbitrary ordering of . Then set .
Let  be the BFS tree rooted at  in , computed according
to the weight assignment . For every , let  be the
BFS tree rooted at  in .
Then the final \FTBFS\ tree is given by

The correctness is immediate by construction.
\begin{observation}
\label{obs:correctness}
 is an \FTBFS\ tree.
\end{observation}
\def\APPENDUPCORRECT{
\Proof
Consider a vertex  and an edge .
If ,
then , hence . Otherwise, . Then by construction, . By definition, . The observation follows.
\QED
}\APPENDUPCORRECT


Due to \cite{TH99} each of the  BFS trees  can be constructed in  time, hence  rounds are required in total.
It therefore remains to bound the size of .

\paragraph{Size Analysis}
We first provide some notation.
For a path , let  be the weighted cost of , i.e., the sum of its edge weights.
An edge  is defined as \emph{new} if .
For every  and , let

be the optimal \emph{replacement path} of  and  upon
the failure of .
Let  and

be the set of  new edges appearing as the last edge in the replacement paths  of  and .
It is convenient to view the edges of  as directed away from .
We then have that

I.e., the set of new edges that participate in the final \FTBFS\ tree 
are those that appear as a last edge in some replacement path.
\par We now upper bound the size of the \FTBFS\ tree .
Our goal is to prove that  contains at most  edges for every .
The following observation is crucial in this context.
\begin{observation}
\label{obs:new_edge}
If , then
.
\end{observation}
\def\APPENDONENEWEDGE{
\Proof
Assume, towards contradiction, that  and let
 be the  replacement path in
 according to the weight assignment .
Since ,
we have two different  shortest paths in , namely,
 and
. By the optimality of  in , i.e.,
,
it holds that .
On the other hand, by the optimality of  in , i.e.,
, we have that
. Contradiction.
\QED
}\APPENDONENEWEDGE

Obs. \ref{obs:new_edge} also yields the following.
\begin{corollary}
(1) 
and \\
(2) 
\end{corollary}
This holds since the edges of  are coming from at most
 replacement paths 
(one for every ),
and each such path contributes at most one edge incident to .
\par For the reminder of the analysis, let us focus on
one specific node  and let  , .
For every edge , we define the following parameters.
Let  be the failed edge such that 
appears in the replacement path  for .
(Note that  might appear as the last edge on the path 
for several edges ; in this case, one such  is chosen arbitrarily).

Let  be the \emph{last} divergence point of
 and , i.e., the last vertex on the
replacement path  that belongs to
.
Since ,
it holds that  is not the neighbor of  in .
\par Let  be sorted in non-decreasing order
of the distance between  and , .
I.e.,

We consider the set of truncated paths  and show that these paths are vertex-disjoint except for the last common endpoint .
We then use this fact to bound the number of these paths, hence bound the number  of new edges. The following observation follows immediately by the definition of .
\begin{observation}
\label{obs:notinpath}
.
\end{observation}
\begin{lemma}
\label{cl:disjointpathmulti}
 for every
, .
\end{lemma}
\Proof
Assume towards contradiction that there exist , and a node
 in the intersection.
Since , by Obs. \ref{obs:notinpath} we have that .
The faulty edges  belong to .
Hence there are two distinct  shortest paths in .
By the optimality of  in ,
(i.e., ), we have that
.
In addition, by the optimality of
 in , (i.e., ),
we have that .
Contradiction.
\QED
We are now ready to prove our key lemma.
\begin{lemma}
\label{lem:upper_bound}
 for every .
\end{lemma}
\Proof
Assume towards contradiction that .
By Lemma \ref{cl:disjointpathmulti}, we have that  are distinct and by definition they all appear on the path .
Therefore, by the ordering of the , we have that the
inequalities of Eq. (\ref{eq:order}) are strict, i.e.,
.
Since  (by definition),
we also have that
. We Conclude that

Next, note that each  is a replacement  path and hence it cannot be shorter than , implying that . Combining, with Eq. (\ref{eq:depthprot}), we have that

Since by Lemma \ref{cl:disjointpathmulti}, the paths  are vertex disjoint (except for the common vertex ), we have that

where the first inequality follows by Eq. (\ref{eq:depthprotk}) and the last inequality by the assumption that .
Since there are a total of  nodes in , we end with contradiction.
\QED

Turning to the case of a single vertex failure, the entire
proof goes through almost without change, yielding the following.
\begin{theorem}
\label{thm:vertexonef}
There exists a polynomial time algorithm that for every -vertex graph
and source node  constructs  an \FTBFS\ tree from 
tolerant to one vertex failure,
with  edges.
\end{theorem}

\subsection{Multiple Sources}
\label{subsec:multisource}
For the case of multiple sources, we establish the following upper bound.
\begin{theorem}
\label{thm:multi_source_edgeonef}
There exists a polynomial time algorithm that for every -vertex graph
 and source set  of size  constructs
an \FTMBFS\ tree  from each source ,
tolerant to one edge or vertex failure,
with a total number of
 edges.
\end{theorem}
\def\APPENDUPPERMULTI{

\paragraph{The algorithm}
As in the single source case, to avoid complications due to shortest-paths
of the same length, all shortest path distances in  are computed using
a weight function  defined so as to ensure the uniqueness of a single 
shortest-path.
For every  and every , let  be the BFS tree rooted at  in .
Let 
be the joint structure containing all the BFS trees of .
Then by the previous section, the \FTBFS\ tree for  is . Define the \FTMBFS\ for  as


\paragraph{Analysis}
The correctness follows immediately by the single source case.
It remains to bound the number of edges of .
An edge  is \emph{new} if .
For every , define its new edge set in the graph  by

To bound the size of , we focus on node ,
and bound its new edges .
Obs. \ref{obs:new_edge} yields the following.
\begin{corollary}
\label{cor:multi_depth}
.
\end{corollary}
Towards the end of this section, we prove that  contains at most  new edges.
For ease of notation, let  for every
. For every edge ,
we define the following parameters. Let  and
 be such that .
I.e., the edge  appears in the replacement  path
, where  is
the BFS tree rooted at  in .
By Obs. \ref{obs:new_edge}, .
(Note that for a given new edge  there might be several 
and  such that ; in this case one such pair  is chosen arbitrarily.)
For every replacement path  (whose last edge is ), denote by
 the \emph{last} divergence point of  and the collection of shortest
 paths .
I.e.,  is the last point on  that belongs to .
Let  be the truncated path from the divergence point  to .
Note that since  is a new edge,
it holds that  and  is
in .
The following observation is useful.
\begin{observation}
\label{obs:pathmulti}
 for every 
\end{observation}
We now show that the paths  are vertex disjoint
except for their endpoint  (this is regardless of their respective source
).
\begin{lemma}
\label{cl:disjointpathmulti2}
 for every .
\end{lemma}
\Proof
Assume towards contradiction that there exists ,
and a node 
in the intersection. Since  and
by Obs. \ref{obs:pathmulti}, ,
and the faulty edges ,
we have two distinct  replacement paths in .
By the optimality of  in ,
(i.e.,  ),
we have that .
Similarly, by the optimality of  in ,
(i.e.,  ),
we have that , contradiction. The lemma follows.
\QED
We are now ready to state and prove our main lemma.
\begin{lemma}
\label{cl:multi_nnew_node}
.
\end{lemma}
We begin by classifying the set of new edges  into 
classes according to the position of the divergence point .
For every , let  be some source node such that the divergence point  appears on its  shortest path .
If there are several such sources for the edge ,
one is chosen arbitrarily.
\par For every , let

be the set of new edges in  that are mapped to .
Then, .
Let .
\par We now focus on . For every , , let  for  be the replacement path such that  and  be its corresponding (last) divergence point with  (). In addition, the truncated path is given by . Note that .
\par Consider the set of divergence points  sorted in non-decreasing order of the distance between  and  on the shortest  path  i.e., , where

Note that by Lemma \ref{cl:disjointpathmulti2},  for every . In addition, since each , .
Hence, since , combining with Eq. (\ref{eq:sorted_multi}) we get that

Since  is an alternative  replacement path, we have that

where the last inequality follows by Eq. (\ref{eq:sorted_multi}).
Hence, since all  are vertex disjoint, except for the last node , we get the total number of nodes 
occupied by  paths is

Since the nodes of  and  are disjoint for every , by Lemma \ref{cl:disjointpathmulti2},
it follows that  but . Therefore, .
\QED
As there are  nodes, combining with Cor. \ref{cor:multi_depth}, we get that the total number of edges in  is given by

as required. Thm. \ref{thm:multi_source_edgeonef} is established.
The analysis for the case of vertex faults follows with almost no changes.
\QED
}\APPENDUPPERMULTI
\section{Hardness of Approximation of the Minimum \FTBFS\ Problem}
\label{sec:hardness}
In this section we establish the following.
\begin{theorem}
\label{thm:hardness}
The Minimum \FTBFS\ problem is NP-complete and cannot be approximated to within a factor  for some constant  unless .
\end{theorem}
We prove Theorem \ref{thm:hardness} by showing a gap preserving reduction
from the Set-Cover problem to the Minimum \FTBFS\ problem.
An instance  of the Set-Cover problem consists of
a set of  elements  and
a collection of  sets 
such that  and .
The task is to choose the minimal number of sets
in  whose union covers all of .
Fiege \cite{Feige98} showed that the Set Cover problem cannot be approximated
within a ratio of  unless .

\paragraph{The Transformation.}
Given a Set-Cover instance ,
we construct a Minimum \FTBFS\ instance 
as follows. Let  (resp.,  )
be the vertex set corresponding to the collection of sets 
(resp., elements of ). Let  be the bipartite
graph corresponding to the input , where
.
Embed the bipartite graph  in  in the following manner.
Construct a length- path ,
connect a vertex  to  and connect a set of vertices  for   to the vertex  by the edges of .
Connect these vertices to the bipartite graph  as follows.
For every , connect the node  of  to the node  of  by a path  where .
Thus the paths  are monotonely decreasing and vertex disjoint.
In addition, connect the vertices  and  to every vertex of , adding the edge sets  and .
Finally, construct a complete bipartite graph  where
.
This completes the description of . For illustration, see
Fig. \ref{fig:reducbfs}.
Overall,

and

Note that  and that .

\begin{figure}[ht!]
\begin{center}
\includegraphics[scale=0.5]{reducbfs}
\caption{
\label{fig:reducbfs}
Schematic illustration of the reduction
from Set-Cover to Minimum .
In this example 
where , , ,
 and . Thus,  and .
The minimal vertex cover is given by 
and . The vertex set  is fully connected to .
In the optimal \FTBFS\ ,  is required to be connected to the  nodes that corresponds to the sets appearing in the optimal cover. For example, 
is connected to  and  which ``covers" the  nodes.
The red edges are necessary upon the fault of
. All edges described except for the  edges are required in any
 \FTBFS\ tree. }
\end{center}
\end{figure}

First, note the following.
\begin{observation}
\label{obs:reduc_triv_edges}
Upon the failure of the edge , , the following happen:\\
(a) the unique  shortest path in  is given
by .\\
(b) the shortest-paths connecting  and the vertices of  disconnect and hence the replacement paths in  must go through the  nodes.
\end{observation}
\par We begin by observing that all edges except those of  are necessary in every \FTBFS\ tree .
Let .
\begin{observation}
\label{obs:everyftbfs}
 for every
.
\end{observation}
\Proof
The edges of the paths  and the edges of  are trivially part of every \FTBFS\ tree.
The edges of the path  are necessary, by Obs. \ref{obs:reduc_triv_edges}(a), upon the failure of  for every .
To see that the edges of  are necessary, note
that upon the failure of the edge  or the
edge , the unique  replacement path goes through  for every .
Similarly, the edges  are necessary
upon the failure of  or .
\par It remains to consider the edges of . Assume, towards contradiction, that there exists some  that does not contain .
Note that by Obs. \ref{obs:reduc_triv_edges}(a), upon the failure of the edge , the unique  shortest-path in
 is , and all other alternatives are strictly longer.
Since , also , and therefore
,
in contradiction to the fact that .
The observation follows.
\QED
We now prove the correctness of the reduction and then consider gap-preservation.
Let  and define by 
the  nodes that are connected to  in , for every .
Let .
Note that since the edges of  are necessary in every  it follows that


\begin{lemma}
\label{cl:reduc_a}
If  then
there exists a Set-Cover for 
of size at most .
\end{lemma}
\Proof
Consider  and let  be such that
.
A cover  for  for size  is constructed as follows.
Let .
By definition, .
We now claim that it is a cover for .
Assume, towards contradiction, that there exists some 
not covered by . Consider the graph  where . Recall that by Obs. \ref{obs:reduc_triv_edges}(a),  is the  path in . Note that  for every 
and  for every .
Hence denoting the set of neighbors of  in  by
, by Obs. \ref{obs:reduc_triv_edges}(b),
the unique  shortest-path, for every  such that , is given by .
Therefore the  shortest-paths in  are all given by , for every . But since  for every , we have that , in contradiction to the fact that .
\QED
\begin{lemma}
\label{cl:reduc_b}
If there exists a Set-Cover of size  then
.
\end{lemma}
\Proof
Given a cover , , construct a \FTBFS\ tree  with  edges as follows. Add  to . In addition, for every , add the edge  to  for every . Clearly, . It remains to show that .
Note that there is no  replacement path that uses any  as a relay, for any  and ; this holds as  is connected by two alternative shortest-paths to both  and to  and the path through  is strictly longer. In addition, if the edge  fails, then the  shortest path in  goes through any neighbor  of . Since each  has at least one  node neighbor in , it holds that .
\par Since the only missing edges of , namely, , are the edges of , it follows that
it remains to check the edges  for every . Let  such that . Since  is a cover, such  exists. Hence, the optimal  replacement path in
, which is by Obs. \ref{obs:reduc_triv_edges}(b), , exists in  for every .
It follows that , hence . The lemma follows.
\QED
Let  be the cost of the optimal Set-Cover for the instance . We have the following.
\begin{corollary}
\label{cor:reduc_opt}
.
\end{corollary}
\Proof
Let  be such that .
It then holds that

where the first inequality holds by Eq. (\ref{eq:costset}) and the second inequality follows by Lemma \ref{cl:reduc_b}. Hence, .
Since by Lemma \ref{cl:reduc_a},
there exists a cover of size , we have that  .
It follows that  and  as desired.
\QED
We now show that the reduction is gap-preserving.
Assume that there exists an  approximation algorithm  for the Minimum \FTBFS\ problem. Then applying our transformation to an instance  would result in an \FTBFS\ tree  such that

where the first inequality follows by Eq. (\ref{eq:costset}), the second by the approximation guarantee of  and by Cor. \ref{cor:reduc_opt}, and the third inequality follows by the fact that .
By Lemma \ref{cl:reduc_a}, a cover of size  can be constructed given , which results in a  approximation to the Set-Cover instance. As the Set-Cover problem is inapproximable within a factor of , under an appropriate complexity assumption \cite{Feige98}, we get that the Minimum \FTBFS\ problem is inapproximable within a factor of  for some constant .
This complete the proof of Thm. \ref{thm:hardness}.



\section{-Approximation for FT-MBFS Trees}
\label{sec:approx}
In Sec. \ref{subsec:1edge_alg}, we presented an algorithm that for every graph  and source  constructs an \FTBFS\ tree
 with  edges.
In Sec. \ref{sc:lb_single},
we showed that there exist graphs  and  for which , establishing tightness of our algorithm in the worst-case.
Yet, there are also inputs  for which the algorithm of Sec. \ref{sec:upper}, as well as algorithms based on the analysis of \cite{GW12} and \cite{RTREP05}, might still produce an \FTBFS\
 which is denser by a factor of
 than the size of the optimal \FTBFS\ tree, i.e., such that .
For an illustration of such a case consider the graph  which is a modification of the graph  described in
Sec. \ref{sc:lb_single}.
The modifications are as follows.
First, add a node  to  and connect it to every .
Replace the last edge  of the  path  by a
vertex  that is connected to the endpoints of the edge 
for every .
Let  be the  modified path where .
Finally, connect the node  to all nodes  for every .
See Fig. \ref{fig:badexamp} for illustration.

\begin{figure}[h!]
\begin{center}
\includegraphics[scale=0.36]{badexamp}
\caption{Bad example for the algorithm of Sec. \ref{sec:upper}.
The weights of the  edges are larger than those of the other edges. Thus, the entire complete bipartite graph  of
size  is included in the resulting \FTBFS\ tree
 returned by the algorithm.
However, an \FTBFS\ tree  of  edges
can be given by including the edges of  for every .
The red edges are two optional edges necessary upon the failure of . Adding the edge  is better, yet the algorithm of Sec. \ref{sec:upper} adds  to  for every .
\label{fig:badexamp}}
\end{center}
\end{figure}

Observe that whereas ,
the modified  has , as the edges of the
complete bipartite graph  that are required in
every 
are no longer required in every ;
it is sufficient to connect the nodes of  to  only,
and by that ``save" the  edges of  in .
Nevertheless, as we show next, for certain weight assignments the algorithm of
Sec. \ref{sec:upper} constructs an \FTBFS\ tree  of size
.
Specifically, let  be such that each of the edges of

is assigned a weight which is strictly larger than the weights of the other edges. That is,  for every  and
.
Note that for every edge , ,
there are two alternative  replacement paths of the same length, namely,
 that goes through 
and 
that goes through . Although ,
the weight assignment implies that

and hence  for
every  and every .
Therefore, , for every \FTBFS\ tree
 computed by the
algorithm of Sec. \ref{sec:upper} with the weight assignment .
Hence  while .

Clearly, a universally optimal algorithm is unlikely given the hardness
of approximation result of Thm. \ref{thm:hardness}.
Yet the gap can be narrowed down.
The goal of this section is to present an  approximation algorithm
for the Minimum \FTBFS\ Problem (hence also to its special case,
the Minimum \FTBFS\ Problem, where ).

To establish this result, we first describe the algorithm and
then bound the number of edges.
Let  be an 
approximation algorithm for the Set-Cover problem,
which given a collection of sets 
that covers a universe  of size , returns a cover
 that is larger by at most
 than any other  that covers  (cf. \cite{Vazirani97}).

\paragraph{The Algorithm}
Starting with , the algorithm adds edges to  until it becomes an \FTMBFS\ tree.
\par Set an arbitrary order on the vertices
 and on the edges
 where  is a new fictitious edge whose role will be explained later on.
For every node , define

The algorithm consists of  rounds, where in round 
it considers . Let 
be the set of neighbors of  in some arbitrary order, where . For every neighbor , define a set  containing certain source-edge pairs . Informally, a set  contains the pair   iff there exists an  shortest path in  that goes through the neighbor  of .
Note that  contains the pair  
iff there exists an  shortest-path in  that goes through . I.e., the fictitious edge  is meant to capture the case where no fault occurs, and thus we take care of true shortest-paths in . Formally, every pair  is included
in every set  satisfying that

Let .
The edges of  that are added to  in round  are now selected by using algorithm  to generate an approximate solution for the set cover problem on the collection .
Let .
For every , add the edge
 to .
We now turn to prove the correctness of this algorithm
and establish Thm. \ref{thm:edgeonef-approx}.

\paragraph{Analysis}
We first show that algorithm constructs an \FTMBFS\
 and then bound its size.
\begin{lemma}
\label{lem:correct}
.
\end{lemma}
\Proof
Assume, towards contradiction, that .
Let  be some source node such that  is not an \FTBFS\ tree with respect to . By the assumption, such  exists. Let

be the set of ``bad pairs," namely, vertex-edge pairs  for which the  shortest path distance in  is greater than that in .
(By the assumption that , it holds that .)
For every vertex-edge pair , where  and ,
define an  shortest-path  in  in the following manner.
Let  be such that the pair 
is covered by the set  of  and  is included in the cover returned by the algorithm  in round . Thus,  and
.
Let  and define

By definition,  and by construction, .
Define
 to be the set of ``bad edges,''
namely, the set of  edges that are missing in .
By definition,  for every bad pair .
Let  be the maximal depth
of a missing edge in , and let  denote that ``deepest
missing edge'' for , i.e., the edge  on  satisfying
.
Finally, let  be the pair that minimizes ,
and let  be
the deepest missing edge on , namely, .
Note that  is the {\em shallowest} ``deepest missing edge''
over all bad pairs .
Let ,  and
;
see Fig. \ref{fig:guidedpaths} for illustration.
Note that since , it follows that also .
(Otherwise, if , then any  shortest-path

, where , can be appended to  resulting in

such that (1)  and (2)
, contradicting the fact that
.)
Thus we conclude that .
Finally, note that  by definition, and therefore
the deepest missing edge of  must be shallower, i.e.,
. However, this is in contradiction to our choice
of the pair . The lemma follows.
\QED

\begin{figure}[htb!]
\begin{center}
\includegraphics[scale=0.7]{guidedpaths_approx_2}
\caption{\label{fig:guidedpaths}
Red solid lines correspond to new edges.
The ``deepest missing edge'' for , edge , is the shallowest
such edge over all bad pairs in . Yet the pair  is bad too.
As the last (green) edge of  is included in the \FTMBFS\ tree,
and since  and  are of the same length, it follows that 
has a shallower ``deepest missing edge''.}
\end{center}
\end{figure}

Let  be the weight assignment that guarantees the uniqueness of shortest-paths. Note that the algorithm did not use  in the computation of the shortest-paths. For every node , let
 be its ordered neighbor set
as considered by the algorithm.
For every \FTMBFS\ tree
,  and , let  be an  shortest-path in . Let

be the edges of  that appear as last edges in the shortest-paths and replacement paths from  to  in .
Define

We then have that

The correctness of the algorithm (see Lemma \ref{lem:correct})
established that if a subgraph  satisfies that
 is a cover of
 for every , then .
We now turn to show the reverse direction.
\begin{lemma}
\label{lem:cover_tree}
For every , the collection  is a cover of , namely,
.
\end{lemma}
\Proof
Assume, towards contradiction, that there exists an \FTMBFS\ tree
 and a vertex 
whose corresponding collection of sets 
does not cover .
Hence there exists at least one uncovered pair , i.e.,

By definition . We next claim that  does not contain an optimal
 path when the edge  fails,
contradicting the fact that .
That is, we show that

Towards contradiction, assume otherwise, and let

where ,
hence 
and .
By the contradictory assumption, 
and hence .
This implies that , in contradiction to Eq. (\ref{eq:notcovered}),
stating that  is not covered by .
The lemma follows.
\QED
We now turn to bound that number of edges in .
\begin{lemma}
\label{lem:numbersize}
.
\end{lemma}
\Proof
Let  be the approximation
ratio guarantee of .
For ease of notation, let
 for every .
Let  be the collection of
 sets considered at round  where 
is the set of the neighbor  computed according to
Eq. (\ref{eq:intset}).
\par Let 
be the cover returned by the algorithm and define

as the collection of edges whose corresponding sets are included in
.
Thus, by Eq. (\ref{eq:set_size}),
 and  for every .
\begin{observation}
\label{cl:a_i}
 for every .
\end{observation}
\Proof
Assume, towards contradiction, that there exists some  such that
. Then by Eq. (\ref{eq:set_size})
and by the approximation guarantee of \ApproxSetCover\, where in
particular 
for every  that covers , it follows that  is not a cover of .
Consequently, it follows by Lemma \ref{lem:cover_tree}
that , contradiction.
The observation follows.
\QED
Since  contains precisely the edges that are added by the algorithm to the constructed \FTMBFS\ tree , we have that

where the second inequality follows by Obs. \ref{cl:a_i} and
the third by the fact that  (as every edge in  can be counted at most twice, by both its endpoints). The lemma follows.
\QED

The following theorem is established.

\begin{theorem}
\label{thm:edgeonef-approx}
There exists a polynomial time algorithm that for every -vertex graph 
and source node set  constructs an \FTMBFS\ tree

such that .
\end{theorem}



\bigskip
\paragraph{Acknowledgment}
We are grateful to Gilad Braunschvig, Alon Brutzkus, Adam Sealfon
and Oren Weimann for helpful discussions.

\clearpage


\begin{thebibliography}{10}



\bibitem{ABLP-89:stoc}
B. Awerbuch, A. {Bar-Noy}, N. Linial, and D. Peleg.
\newblock Compact distributed data structures for adaptive network routing.
\newblock
In {\em Proc. 21st ACM Symp. on Theory of Computing},
230--240, 1989.






\bibitem{ACGP10}
I. Abraham, S. Chechik, C. Gavoille and D. Peleg.
\newblock Forbidden-Set Distance Labels for Graphs of Bounded Doubling
Dimension.
\newblock
In {\em Proc. 29th ACM Symp. on Principles of Distributed Computing},
2010, 192--200.


\bibitem{BS06}
S.~Baswana and S.~Sen.
\newblock Approximate distance oracles for unweighted graphs in expected
  {} time.
\newblock {\em ACM Trans. Algorithms}, 2(4):557--577, 2006.


\bibitem{BK09}
A.~Bernstein and D.~Karger.
\newblock A nearly optimal oracle for avoiding failed vertices and edges.
\newblock
In {\em Proc. 41st ACM Symp. on Theory of Computing},
101--110, 2009.


\bibitem{CLPR09-do}
S.~Chechik, M.~Langberg, D.~Peleg, and L.~Roditty.
\newblock -sensitivity distance oracles and routing schemes.
\newblock {\em Algorithmica}, 861--882, 2012.

\bibitem{CLPR09-span}
S.~Chechik, M.~Langberg, D.~Peleg, and L.~Roditty.
\newblock Fault-tolerant spanners for general graphs.
\newblock
In {\em Proc. 41st ACM Symp. on Theory of computing},
435--444, 2009.

\bibitem{S12}
S. Chechik.
\newblock Fault-Tolerant Compact Routing Schemes for General Graphs.
\newblock
In {\em Proc. 38th Int. Colloq. on Automata, Languages \& Prog.},
101--112, 2011.



\bibitem{CT07}
B.~Courcelle and A.~Twigg.
\newblock Compact forbidden-set routing.
\newblock
In {\em Proc. 24th Symp. on Theoretical Aspects of Computer Science},
37--48, 2007.

\bibitem{CZ03}
A.~Czumaj and H.~Zhao.
\newblock Fault-tolerant geometric spanners.
\newblock {\em Discrete \& Computational Geometry}, 32, 2003.

\bibitem{DTCR08}
C.~Demetrescu, M.~Thorup, R.~Chowdhury, and V.~Ramachandran.
\newblock Oracles for distances avoiding a failed node or link.
\newblock {\em SIAM J. Computing}, 37:1299--1318, 2008.

\bibitem{DK11}
M. Dinitz and R. Krauthgamer.
\newblock Fault-tolerant spanners: better and simpler.
\newblock
In {\em Proc. ACM Symp. on Principles of Distributed Computing},
2011, 169-178.


\bibitem{DP09}
R.~Duan and S.~Pettie.
\newblock Dual-failure distance and connectivity oracles.
\newblock
In {\em Proc. 20th ACM-SIAM Symp. on Discrete Algorithms},
2009.







\bibitem{Feige98}
U.~Feige.
\newblock A Threshold of ln n for Approximating Set Cover.
\newblock {\em J. ACM}, 634--652, 1998.

\bibitem{GW12}
F.~Grandoni and V.V~Williams.
\newblock Improved Distance Sensitivity Oracles via Fast Single-Source Replacement Paths.
\newblock
In {\em Proc. 53rd IEEE Symp. on Foundations of Computer Science},
2012.

\bibitem{LNS98}
C.~Levcopoulos, G.~Narasimhan, and M.~Smid.
\newblock Efficient algorithms for constructing fault-tolerant geometric
  spanners.
\newblock
In {\em Proc. 30th ACM Symp. on Theory of computing},
186--195, 1998.

\bibitem{L99}
T.~Lukovszki.
\newblock New results of fault tolerant geometric spanners.
\newblock
In {\em Proc. 6th Workshop on Algorithms and Data Structures}, London
193--204, 1999.



\bibitem{Peleg00:book}
D.~Peleg.
\newblock {\em Distributed Computing: A Locality-Sensitive Approach}.
\newblock SIAM, 2000.


\bibitem{P09}
D. Peleg.
\newblock As good as it gets: Competitive fault tolerance in network structures.
\newblock
In {\em Proc. 11th Symp. on Stabilization, Safety, and Security
of Distributed Systems}, LNCS 5873,
2009, 35--46.



\bibitem{PelegS-89}
D. Peleg and A.A. Sch\"affer.
\newblock Graph spanners.
\newblock {\em J. Graph Theory}, 13:99--116, 1989.

\bibitem{PelegU-89}
D. Peleg and J.D. Ullman.
\newblock An optimal synchronizer for the hypercube.
\newblock {\em SIAM J. Computing}, 18(2):740--747, 1989.


\bibitem{PU-89:tables}
D.~Peleg and E.~Upfal.
\newblock A trade-off between space and efficiency for routing tables.
\newblock {\em J. ACM}, 36:510--530, 1989.

\bibitem{RTZ05}
L.~Roditty, M.~Thorup, and U.~Zwick.
\newblock Deterministic constructions of approximate distance oracles and
  spanners.
\newblock
In {\em Proc. 32nd Int. Colloq. on Automata, Languages \& Prog.},
261--272, 2005.


\bibitem{RTREP05}
L.~Roditty and U.~Zwick.
\newblock Replacement paths and k simple shortest paths in unweighted directed graphs.
\newblock {\em ACM Trans. Algorithms} ,2012.


\bibitem{TZ01}
M.~Thorup and U.~Zwick.
\newblock Compact routing schemes.
\newblock
In {\em Proc. 14th ACM Symp. on Parallel Algorithms and Architecture}, Hersonissos, Crete,
1--10, 2001.

\bibitem{TZ05}
M.~Thorup and U.~Zwick.
\newblock Approximate distance oracles.
\newblock {\em J. ACM}, 52:1--24, 2005.

\bibitem{TH99}
M.~Thorup.
\newblock Undirected single-source shortest paths with positive integer weights in linear time.
\newblock {\em J. ACM}, 362--394, 1999.

\bibitem{Vazirani97}
V.~Vazirani.
\newblock Approximation Algorithms.
\newblock
{\em College of Computing, Georgia Institute of Technology},
1997.

\bibitem{WY10}
O.~Weimann and R.~Yuster.
\newblock Replacement paths via fast matrix multiplication.
\newblock
In {\em Proc. 51th IEEE Symp. on Foundations of Computer Science},
2010.


\end{thebibliography}


\end{document}
