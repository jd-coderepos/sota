\documentclass[11pt,letterpaper]{article}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{epic,eepic,amsmath,latexsym,fullpage,amssymb,color,amsthm}
\usepackage{ifthen,graphics,epsfig}
\usepackage{float}
\usepackage{xspace}
\usepackage[english]{babel}
\bibliographystyle{plain}
\usepackage{times}
\usepackage{ifpdf}

\newlength{\mymargin}
\setlength{\mymargin}{0.95in}
\usepackage[lmargin=\mymargin,rmargin=\mymargin,tmargin=\mymargin,bmargin=\mymargin]{geometry}


\newlength {\squarewidth}
\renewenvironment {square}
{
\setlength {\squarewidth} {\linewidth}
\addtolength {\squarewidth} {-12pt}
\renewcommand{\baselinestretch}{0.75}
\footnotesize
\begin{center}
\begin{tabular}{|c|}\hline
\begin{minipage}{\squarewidth}
\medskip
}{
\end{minipage}
\\\hline
\end{tabular}
\end{center}
}
\newtheorem{definition}{Definition}
\newtheorem{theorem}{Theorem}
\newtheorem{lemma}{Lemma}
\newtheorem{corollary}{Corollary}
\newtheorem{property}{Property}
\newtheorem{specification}{Specification}

\newlength {\afterproof}
\setlength {\afterproof}{1mm}

\newcommand{\toto}{xxx}
\newenvironment{proofT}{\noindent{\bf Proof }}
{\hspace*{\fill}\par\vspace{\afterproof}}
\newenvironment{proofL}{\noindent{\bf Proof }}
{\hspace*{\fill}\par\vspace{\afterproof}}
\newenvironment{proofC}{\noindent{\bf Proof }}
{\hspace*{\fill}\par\vspace{\afterproof}}
\newenvironment{proofP}{\noindent{\bf Proof }}
{\hspace*{\fill}\par\vspace{\afterproof}}


\newenvironment{lemma-repeat}[1]{\begin{trivlist}
\item[\hspace{\labelsep}{\bf\noindent Lemma~\ref{#1} }]}{\end{trivlist}}

\newenvironment{theorem-repeat}[1]{\begin{trivlist}
\item[\hspace{\labelsep}{\bf\noindent Theorem~\ref{#1} }]}{\end{trivlist}}

\newcommand{\Xomit}[1]{}
\newcounter{linecounter}
\newcommand{\linenumbering}{\ifthenelse{\value{linecounter}<10}
{(0\arabic{linecounter})}{(\arabic{linecounter})}}
\renewcommand{\line}[1]{\refstepcounter{linecounter}\label{#1}\linenumbering}
\newcommand{\resetline}{\setcounter{linecounter}{0}}
\renewcommand{\thelinecounter}{\ifnum \value{linecounter} >
9\else 0\fi \arabic{linecounter}}
\newenvironment{mycenter}{\begin{list}{}{\topsep0pt \partopsep0pt \parskip0pt \leftmargin0pt}\centering\item\relax}{\end{list}}
\newsavebox{\mybox}
\newenvironment{myalgo}[1][aaaaa\=aa\=aa\=aa\=aa\=\kill]{
\begin{lrbox}{\mybox}
\footnotesize
\let\oldbaselinestretch\baselinestretch
\renewcommand{\baselinestretch}{2.5}
\begin{minipage}[t]{0pt}
\begin{tabbing}#1
}{\end{tabbing}
\end{minipage}\normalsize
\renewcommand{\baselinestretch}{\oldbaselinestretch}
\end{lrbox}
\begin{mycenter}
\fbox{\usebox{\mybox}}
\end{mycenter}
}



\newcommand{\CM}{{\cal CAMP}_{n,t}}
\newcommand{\CMprim}{{\cal CAMP}_{n',t}}
\newcommand{\BM}{{\cal BAMP}_{n,t}}
\newcommand{\BMprim}{{\cal BAMP}_{n',t}}
\newcommand{\SA}{\mathit{SA}}

\begin{document}





\title{\bf From Byzantine Failures to Crash Failures in\\ 
             Message-Passing Systems: 
            a BG Simulation-based approach}
\author{Damien Imbs,     Michel Raynal, Julien Stainer\\~\\
 Institut Universitaire de France\\
 Department of Mathematics, University of Bremen, Germany\\
 IRISA, Université de Rennes, 35042 Rennes, France \\
 École Polytechnique Fédérale de Lausanne, Switzerland\\
{\footnotesize {\tt
imbs@uni-bremen.de~~~raynal@irisa.fr~~~julien.stainer@epfl.ch
}}
}

\date{}
\maketitle


\begin{abstract}
The BG-simulation  is a powerful reduction
algorithm designed for asynchronous read/write crash-prone systems.
It allows a  set of  asynchronous
sequential processes to wait-free simulate (i.e., despite the crash of up
to  of them) an arbitrary number  of processes under the assumption
that at most  of them may crash.  
The BG simulation shows that, in
read/write  systems, the  crucial parameter is not the number  of processes, 
but the upper bound  on the number of process crashes.

The paper extends the concept of BG simulation to asynchronous message-passing 
systems prone to Byzantine failures.
Byzantine failures are the most general type of failure: a faulty process 
can exhibit any arbitrary behavior. Because of this, they are also the most 
difficult to analyze and to handle algorithmically. 
The main contribution of the paper 
is a signature-free reduction of Byzantine failures to crash failures.
Assuming ,  the paper presents an algorithm that simulates 
a system of
 processes where up to  may crash, on top of a basic system
of  processes where up to  may be  Byzantine. 
While topological techniques have been used to relate the computability of
Byzantine failure-prone systems to that of crash failure-prone ones, 
this simulation is the first, to our knowledge, that establishes this relation 
directly, in an algorithmic way. 


In addition to extending the basic BG simulation to  message-passing systems
and failures more severe than process crashes, being modular and direct,
this simulation provides us with a deeper insight in  the nature and
understanding of crash and Byzantine failures in the context of
asynchronous message-passing systems. Moreover, it 
also allows crash-tolerant algorithms, designed for   
asynchronous read/write systems,  to be executed on top of asynchronous
message-passing systems  prone to  Byzantine failures.\\


\noindent
{\bf Keywords:} Asynchronous processes,  BG simulation, Byzantine process,
Distributed computability, Fault-tolerance, Message-passing system,
Process crash,  Read/write shared memory system, Reduction algorithm,
-Resilience, System model, Wait-freedom.
\end{abstract}



\thispagestyle{empty}
\newpage
\setcounter{page}{1}

\section{Introduction}
\paragraph{What is the Borowsky-Gafni (BG) simulation and why is it important?}
Considering an asynchronous system where processes can crash, the -set
agreement problem is a basic distributed decision task defined as
follows~\cite{C93}.
Each of  the  processes  proposes a value,  and every process  that does
not crash has  to decide a value (termination), such  that a decided value
is a proposed value (validity) and at most  different values are decided
(agreement). The consensus problem corresponds to the particular case .

The -set agreement is fundamental because it captures the essence 
of fault-tolerant distributed computability issues. 
A central  question related to asynchronous distributed computability is
the following: 
{\sl ``Can we use a  solution to the -set
agreement problem as a subroutine to solve the  -set
agreement problem, when at most  processes may crash?''}
(``Is -set agreement  reducible to -set agreement?''.)
The BG simulation (initially sketched in~\cite{BG93}
and then formalized  in a journal version~\cite{BGLR01},
 where, in addition, a formal definition of ``reducibility'' is given) 
answers this  fundamental question.
It states that the answer is ``yes'' if  and  ``no'' if
. As we can see, the answer ``yes'' does not depend on
the number of processes.


To this end, the algorithm described in~\cite{BGLR01} allows 
processes  to simulate a large number  of asynchronous processes that
communicate through  read/write registers, and collectively solve a decision
task, in the presence of at most  crashes.
Each of the   simulator processes simulates all the  processes.
These  simulator processes cooperate through underlying objects
that allow them to agree on a single output for each  of the non-deterministic
statements  issued by every simulated process. (These underlying objects,
called safe agreement objects, can be built of top of read/write atomic
registers.)


Let  BG(RW,C) denote the  basic BG simulation algorithm~\cite{BGLR01} (RW
stands for ``read/write communication'', and C stands for ``crash failures'').
BG(RW,C) is ``symmetric'' in  the sense that  each of the  
processes is  simulated by every simulator, and  the  simulators
are ``equal'' with respect  to each  simulated process, namely,
(1)  every simulator fairly  simulates all the processes,
and (2) the  crash  of  a simulator  entails the crash  of  at most  one
simulated process.  This symmetry allows  BG(RW,C) to be
suited to  colorless tasks (i.e., distributed computing problems where the
value decided by a process can be decided by any process~\cite{HR97}).
BG(RW,C) has then been extended to colored tasks
(i.e.,  tasks such as renaming~\cite{ABDPR90}, where a process cannot
systematically borrow its output from another process).
Extended BG simulation is addressed in~\cite{G09,IR09}.
Algorithmic pedagogical
presentations of the BG simulation can be found in~\cite{HRR13,IR09}.
A topological view on distributed computability issues in Byzantine
asynchronous message-passing systems has been  recently
presented in~\cite{HKR14,MTH14}.  A pedagogical topology-based 
presentation of the BG-simulation is given in chapter 7 of~\cite{HKR14}. 



\paragraph{What is learned from the BG simulation}
The  important  lesson  learned  from the BG simulation is  that, in a
failure-prone  context,  what is important  is  not the number of processes
but  the maximal  number of   possible failures  and the  actual  number of
values that are proposed to a  decision task.
An interesting  consequence  of  the  BG simulation  (among  several
of its  applications  \cite{BGLR01})  is  the  proof  that  there is no
-resilient -set agreement algorithm for  .
This is obtained as follows.  As (1)
the BG simulation allows reducing the -set agreement problem to the
-set agreement problem in  a system with up to   failures,
and (2) the -set agreement problem is known to be impossible
in presence of  failures \cite{BG93,HS99,SZ00}, it follows that there is
no   -resilient -set agreement algorithm. 


\paragraph{Content of the paper: on the BG-simulation side}
As already indicated, the BG simulation has been explored in asynchronous
systems where processes
(1) communicate through atomic read/write registers~\cite{L86}, and
(2) may commit  only  crash failures. This paper extends it in two directions.
The first is the communication model, namely, it considers
that processes cooperate by sending and receiving messages
via asynchronous reliable channels.
The second dimension is related to the type of failures; more precisely, it
considers two  types of failures: process crash failures, and
the more severe  process Byzantine failures.
The  paper presents the following contributions.

A first is an algorithm,  denoted BG(MP,C), which simulates the execution 
of a colorless task running in an asynchronous message-passing system of 
processes, where up to  may crash, on top of an  asynchronous
message-passing system of   processes where up to  may crash.
This simulation  requires  (which is a necessary and sufficient
condition to  simulate read/write registers in asynchronous message-passing
systems of  processes~\cite{ABD95}). While the number of simulated
processes  can be any integer, for the simulation to be non-trivial
we consider that .

A second contribution is an
algorithm, denoted BG(MP,B), which simulates the execution of a
colorless task running in an asynchronous message-passing system of 
processes, where up to  may crash, on top of an asynchronous message-passing 
system of  processes where up to  may be Byzantine~\cite{LSP82}.
This simulation requires  (according to the task 
which is simulated, additional constraint on  may be needed, 
see~\cite{HKR14}; see also Section~\ref{sec:conclusion}). 
As in the case of  BG(MP,C), and for the same reason, we consider that .
This algorithm has two noteworthy features: it is the first BG simulation
algorithm that considers Byzantine failures, and it allows to run a
crash-tolerant algorithm solving a colorless task on top of an asynchronous
system prone to Byzantine failures.
Both the algorithms BG(MP,C) and  BG(MP,B) are {\it genuine} in the 
sense they do not rely on the simulation of an underlying shared memory. 


While the  full-information algorithm presented
in~\cite{MTH14} can be used to decide when there is a simulation
between two models, the present paper is the first (to our knowledge)
that allows the direct execution in the presence of Byzantine failures
of any crash-tolerant algorithm that solves a colorless task.
BG(MP,B) provides an algorithmic approach which complements the
topology-based simulation framework of~\cite{MTH14}, and may also be
of practical interest.  It has the interesting property that the
simulation of a message only requires a polynomial number of messages
in the base system, and the increase in size of these messages, when
compared to the size of the simulated message, is also polynomial.
Additionally, differently from early works on Byzantine failures
like~\cite{GMW87}, it does not use any cryptography-based mechanism. 


\paragraph{Content of the paper: on the safe agreement objects side}
The core of the previous algorithms  lies in 
  new  underlying safe agreement objects, which allow the
 simulators to agree on the next operation executed by each of the 
simulated  processes. Such a  safe agreement object ensures that all the
simulators produce the very same simulation. At the operational level,
a safe agreement object
provides processes with two operations, denoted 
and , which  are invoked in this order by each correct process.
The termination property associated with  a safe agreement object  is
the following: if no simulator commits a failure while executing
, then any invocation of  
by a non-faulty simulator terminates. Moreover, no two correct processes 
decide differently. 

On the algorithmic side, a novelty of the paper lies in the algorithms
implementing these new safe agreement objects. Differently from their
read/write memory counterparts, they are not based on underlying
snapshot objects~\cite{AADGMS93}.  They instead rely heavily on
message communication patterns inspired from the reliable broadcast
algorithms  introduced in~\cite{B87}.

A last and noteworthy contribution of the paper lies in the second algorithm
(which implements safe agreement in a  Byzantine message-passing system).
This object is the core of a simulation when one wants to execute     
asynchronous read/write crash-tolerant algorithms  on top of asynchronous
message-passing systems prone to Byzantine failures.


\paragraph{Existing simulations considering Byzantine failures}
Simulations of crash failures in a Byzantine system have been
addressed in the context of synchronous systems~\cite{BN91,NT90,ST87}.
The only articles we are aware of concerning such a simulation in
asynchronous systems are~\cite{C88,HKR14,HDR07}.  As noticed
in~\cite{AW04}, \cite{C88} considers a restricted class of round-based
deterministic algorithms.  The
simulation presented in~\cite{HKR14} executes a full-information
asynchronous crash-tolerant algorithm in an asynchronous Byzantine
failure-prone system. The article~\cite{HDR07} considers an
agent/host model and focuses mainly on reliable broadcast. 



\paragraph{Roadmap}
The paper is composed of~\ref{sec:conclusion} sections.
Section~\ref{sec:model} presents both the crash-prone and the Byzantine
asynchronous message-passing models, and the notion of a task.
Section~\ref{sec:simu-structure} presents the structure of the simulation
algorithms. Section~\ref{sec:BG-crash-model} presents the  simulation
algorithm BG(MP,C), while Section~\ref{sec:BG-byzantine-model}
presents the simulation algorithm  BG(MP,B).
Finally, Section~\ref{sec:conclusion}  addresses 
the computability implications of the  Byzantine-tolerant 
simulation and its underlying safe agreement object. 


\section{Computation Models and Tasks}
\label{sec:model}

\subsection{Computation models}

\paragraph{Computing entities}
The system is made up of a set  of  sequential processes,
denoted , , ..., . These processes are asynchronous
in the sense that each process  progresses at  its own speed,
which can  be arbitrary and remains always unknown to the other processes.

During an execution, processes may deviate from their specification.
In that case, the corresponding processes are said to be {\it faulty}.
A process that does not deviate from its specification is {\it correct}
(or {\it non-faulty}).
The model parameter  denotes the maximal number of processes that can
be faulty in a given execution. Two failure types are considered below.



\paragraph{Communication model}
The processes cooperate by sending and receiving messages through
bi-directional channels. The communication network is a complete network,
which means that each process   can directly send a message to any
process  (including itself).
Each channel is reliable (no loss, corruption, or creation of messages),
not necessarily first-in/first-out, and asynchronous (while the transit
time of each message is finite,  there is no upper bound on message
transit times).

The macro-operation `` {\sc type}'', where {\sc type} is
a message type and  is its content,  is a shortcut for the following
statement: `` {\sc type} to each process (including itself)''.




\paragraph{The process crash failure model}
In the crash failure model, a process may prematurely stop its execution.
A process executes correctly its algorithm until it possibly crashes.
Once crashed, a process remains crashed forever.
It is assumed that at most  processes may crash.
If there is no specific constraint on , the corresponding model
is denoted  .
When  it is assumed that at most  processes
may crash,  the corresponding model is denoted .


\paragraph{The Byzantine failure model}
A  Byzantine process is a process that behaves
arbitrarily: it may crash, fail to send or receive messages, send
arbitrary messages, start in an arbitrary state, perform arbitrary state
transitions, etc. Hence, a Byzantine process, which is assumed to send the
same message  to all the processes, can send a message  to some
processes, a different message   to another subset of processes, and no
message at all to the other processes. Moreover, Byzantine processes can
 collude to ``pollute'' the computation.

It is assumed that Byzantine processes cannot control the network, hence,
when  a process receives a  message, it can unambiguously identify its sender.
As previously,  denotes the upper bound on the number of processes that
may commit Byzantine failures.
If there is no constraint on , the corresponding model
is denoted  .
When  it is assumed that at most  processes may be faulty,
the corresponding model is denoted .


\subsection{Decision tasks and algorithms solving a task}

\paragraph{Decision tasks}
The problems we are interested in are called {\it decision tasks}
(the reader interested in a more formal presentation of  decision tasks can
consult the literature, e.g., \cite{BGLR01,HS99}).
In every run, each process proposes a value and the proposed values define
an input vector , where  is the value proposed by process .
Let  denote the set of  allowed input vectors.
Each process has to decide a value. The decided values define an
output  vector ,  such that   is  the value  decided by  .
Let  be the  set of  the output vectors.

A decision task is a binary relation  from  into .
A task is {\it colorless} if,  
when a value   is proposed by a process
 (i.e., ), then  can be proposed by any number of processes and,
when a value   is decided by a process
 (i.e., ), then  can be decided by any number of processes.
Consensus, and more generally -set agreement, are colorless tasks.
Otherwise the task is  {\it colored}.  Symmetry breaking and renaming are
colored tasks~\cite{ABDPR90,CRR11,IRR11}.


\paragraph{Algorithm solving a task}
An algorithm solves a task in a -resilient  environment if, given
any , (1)  each correct process   decides a value ,
 and (2) there is an output vector  such that
 where  is defined as follows.
If  decides , then  .
If  does not decide,  is set to any  value  that preserves
the relation .


Considering a system of  processes, a
task  is  -resiliently solvable if there is  an
algorithm that solves  it in the presence of at most  faulty processes.
As an example, consensus is  not  -resiliently solvable
in asynchronous crash-prone systems, be the communication medium a set of
read/write registers~\cite{LA87}, or a message-passing  system~\cite{FLP85}.
Differently,  renaming  with  new names is -resiliently solvable
in asynchronous read/write crash-prone systems~\cite{CR12,HS99}, and
is -resiliently solvable in asynchronous crash-prone message-passing
systems for ~\cite{ABDPR90}.




\section{Structure of the Simulation Algorithms}
\label{sec:simu-structure}

\paragraph{Aim}
Let  be an algorithm that solves a colorless decision task among 
processes in the  system model  . The aim is to design an algorithm that simulates  in the
system model    (resp.,  ).
As already indicated, the corresponding simulation algorithm is denoted
BG(MP,C) in the first case, and BG(MP,B) in the second case.


\paragraph{Notation}
A simulated process is denoted , where .
Similarly, a simulator process (``simulator'' in short') is  denoted ,
where .
The set  denote the set of the simulator indexes,
i.e., .

The safe agreement objects, build in the simulation and used by the simulators,
are identified with upper case letters, e.g., .  The  variables local to
simulator  is identified with lower case letters, and the resulting
identifiers are subscripted with .


\paragraph{Behavior of a simulator }

Each simulator is given the code of all the simulated processes
, ..., . It manages  threads, one associated with each
simulated process, and executes them in a fair way.

The code of a simulated process  contains local statements,
send statements, and receive statements. It is assumed that
the behavior of a simulated process  is deterministic in the sense
it is entirely defined from its local input (as defined by the task instance),
and the order in which   receives messages.

The simulation has to ensure that (1) all simulators simulate the
same behavior of the set of  simulated processes, and (2) a faulty simulator
entails the failure of at most one simulated process. The way
this is realized depends, of course, on the failure model that is considered.

\section{BG(MP,C): BG in the Crash-prone Asynchronous Message-Passing  Model}
\label{sec:BG-crash-model}

This section presents the algorithm BG(MP,C).
As previously indicated, this algorithm simulates, in the model  ,
an algorithm   solving a task in . It is  made up of two
parts:
an algorithm implementing a safe agreement object, and the simulation itself,
which uses several of these objects to allow the simulators to cooperate.



\subsection{Safe agreement object in : definition}
This object type (or variants of it), briefly sketched in the Introduction,
is at the core of both the BG simulation~\cite{BG93,BGLR01, G09,IR09}, and
the liveness guarantees of concurrent objects~\cite{IR11,IR11-a}.
It is a one-shot object that solves consensus in failure-free scenarios,
and allows processes to agree with  a weak termination guarantee
in the presence of failures.

A safe agreement object provides each simulator ,
,  with two operations
denoted  and  , that  can invoke
at most once, and in this order;   allows  to propose
a value, while   allows it to decide a value.
Considering the crash failure model, the properties associated with this
object are the following ones.
\begin{itemize}
\vspace{-0.2cm}
\item Validity. A decided value is a proposed value.
\vspace{-0.2cm}
\item Agreement. No two simulators decide distinct values.
\vspace{-0.2cm}
\item Propose-Termination.
An invocation of   by a correct simulator terminates.
\vspace{-0.2cm}
\item Decide-Termination.
If no simulator crashes while executing  , then any
invocation of  by a correct simulator terminates.
\end{itemize}
It is easy to see that a safe agreement object is a consensus object whose
termination condition is failure-dependent. Algorithms implementing 
safe agreement
objects (or variants of it) can be found in~\cite{BG93,BGLR01,IR11-a}.


\subsection{Safe agreement object in : algorithm}
An algorithm implementing a safe agreement object in  is described
in Figure~\ref{algo-SA-msg-passing-crash}.

\paragraph{Local data structures}
Each simulator , , manages three local
data structures, namely, the arrays , ,
, all initialized to  , where
 denotes  a default value that cannot be proposed to the safe agreement
object  by the  simulators.
\begin{itemize}
\vspace{-0.2cm}
\item
The aim of  is to contain, as currently known by ,
the value proposed to the  safe agreement object by the simulator .
\vspace{-0.2cm}
\item
The aim of  is to contain, as known by , the value
proposed to the safe agreement object by the simulator , as witnessed
by  strictly more than   distinct simulators
(i.e., at least a correct process). 
\vspace{-0.2cm}
\item
The aim of  is to contain what to 's knows
about the view seen by  .
\end{itemize}


\paragraph{Algorithm: the operation }
The algorithm implementing the operation  invoked
by a simulator  is described at lines~C\ref{SA-C-01}-C\ref{SA-C-14}
(client side)  and lines~C\ref{SA-C-20}-C\ref{SA-C-22} (server side).
This algorithm is made up of three parts.
\\

First part.
A simulator  first broadcasts the message {\sc value} , where
 is the value it proposes to the safe agreement object
 (line~C\ref{SA-C-01}). Then, it waits until it knows that strictly 
more than 
simulators know its value (line~C\ref{SA-C-02}).
On its ``server'' side, when   receives for the first time
the message {\sc value} , it first saves  in
; then it  forwards  the received message
to cope with the (possible) crash of  (this witnesses the fact that
 knows the value proposed by , line~C\ref{SA-C-20})\footnote{
Let us observe that the lines~C\ref{SA-C-01} and~C\ref{SA-C-20}
implement a reliable broadcast of the  message {\sc value} .
Similarly,  the lines~C\ref{SA-C-12} and~C\ref{SA-C-22}
implement a reliable broadcast of the message {\sc view} .
It is easy to see that the cost of such a reliable broadcast
is  messages.}).

\renewcommand{\linenumbering}{\ifthenelse{\value{linecounter}<10}
{(C0\arabic{linecounter})}{(C\arabic{linecounter})}}
\begin{figure}[th!]
\begin{myalgo}
\resetline
{\bf operation}  () {\bf is}\\
\line{SA-C-01}
~~\=  {\sc value} ;\\

\line{SA-C-02}
\> {\bf wait} \big({\sc value}     
             from strictly more than  different simulators\big);\\

\line{SA-C-03}
\> {\bf for  each}   {\bf do}
       {\sc read}   {\bf end for};\\

\line{SA-C-04}
\> {\bf for  each}   {\bf do} \\


\line{SA-C-05}
\> \>\>  {\bf wait} \big(\={\sc read'answer}   
             from strictly more than  different  simulators\\

\line{SA-C-06}
\> \> \>\>     {\sc value}  
             from strictly more than  different  simulators\big);\\

\line{SA-C-07}
\> \>\> {\bf if} (predicate of line~C\ref{SA-C-06} satisfied)\\

\line{SA-C-08}
\> \>\> \> {\bf then} \= \\

\line{SA-C-09}
\> \>\> \> {\bf else} \> \\

\line{SA-C-10}
\> \>\>\> {\bf  end if}\\

\line{SA-C-11}
\> {\bf end for};\\

\line{SA-C-12}
\>   {\sc view} ;\\

\line{SA-C-13}
\>  {\bf wait} \big({\sc view}   
             from strictly more than  different simulators\big);\\

\line{SA-C-14}
\> .\\~\\


{\bf operation}  () {\bf is}\\
\line{SA-C-15}
\>  {\bf wait}
       \big( a non-empty set :\\

\line{SA-C-16}
\> \> ~;\\

\line{SA-C-17}
\> {\bf let}  {\bf be} the set   of smallest size; \\

\line{SA-C-18}
\>  {\bf let}  {\bf be} ;\\

\line{SA-C-19}
\> .\\~\\

\%----------------------------------------------------------------------------------------------------------------~\\

{\bf when the message} {\sc value} 
     {\bf is}    {\bf for the first time}:\\

\>  \%
  ``for the first time'' is with respect to  each pair of values  \%\\
\line{SA-C-20}
\>  
            {\sc value} .\\~\\


{\bf when the message} {\sc read} 
     {\bf is}  {\bf for the first time}:\\

\line{SA-C-21}
\>  {\sc read'answer}  .
\\~\\



{\bf when the message} {\sc view} 
          {\bf is}  {\bf for the first time}:\\


\line{SA-C-22}
\>   ;
      {\sc view} .

\end{myalgo}
\caption{Safe agreement object in  (code for the simulator )}
\label{algo-SA-msg-passing-crash}
\end{figure}


Second part. In this part,   builds a local view of the values
proposed by the  simulators. To this end, it first broadcasts  messages
{\sc read} , , to learn the value proposed by
each simulator    (line~C\ref{SA-C-03}). On its server side, when 
receives such a message, it broadcasts by return its current
knowledge of the value proposed by   (line~C\ref{SA-C-21}).


Then, the  simulator   builds its local view of the values that have been
proposed. For each simulator ,  waits until it has received
from strictly more than  distinct  simulators  the very 
same message, namely, either the message {\sc read'answer} , 
or the message {\sc value}    (lines~C\ref{SA-C-05}-C\ref{SA-C-06}).
In the first case,   considers that  has not yet proposed a value,
while in the second case it considers that    proposed the value 
(let us observe that, while  can receive both {\sc read'answer} 
 and messages  {\sc value} , it stops waiting as soon as 
it received strictly more than  of one of them) 
(lines~C\ref{SA-C-07}-C\ref{SA-C-10}). 

Third part. Finally, the simulator   informs the other simulators
on its local view . To this  end,  it broadcasts the message
{\sc view} . When it has received the corresponding
``acknowledgments'',  returns from its invocation of the operation
 (line~C\ref{SA-C-12}-C\ref{SA-C-14}).
(The behavior of   when it receives a message {\sc view} 
is similar to the one when it receives  a message {\sc value} .
The only difference is that  is now replaced by
, line~C\ref{SA-C-22}.)


\paragraph{Algorithm: the operation }
The algorithm implementing the operation  is described at
lines~C\ref{SA-C-15}-C\ref{SA-C-19}. It consists in a ``closure'' computation.
A simulator  waits until it knows a non-empty set of simulators
  such that (a) it knows their views, and (b) this set is closed
under the relation ``has in its published view the value of'' which means
that the processes whose values appear in a view of a process of 
are also in   (lines~C\ref{SA-C-15}-C\ref{SA-C-16}).

Let us observe that it is possible that, locally,  several sets satisfy this
property. If it is the case,  selects the smallest of them.
Let  be this set of simulators (lines~C\ref{SA-C-17}).
The  value that is returned by  is then the smallest
value among the the values proposed by the simulators in  
(lines~C\ref{SA-C-18}-C\ref{SA-C-19}).


\subsection{Safe agreement object in : proof}
This section proves that the algorithm presented in
Figure~\ref{algo-SA-msg-passing-crash} implements a safe agreement object,
i.e., any of its runs in    satisfies the validity, agreement,
and termination properties, which define it.


\begin{lemma}
\label{lemma:safe-agr-term-propose}
An invocation of   by a simulator that does not crash
during this  invocation,  terminates.
\end{lemma}

\begin{proofL}
Let us consider a simulator  that does not crash during its invocation of
  .
Hence,  broadcast the message {\sc value} 
at line~C\ref{SA-C-01}.
This message is received by strictly more than  correct 
simulators, and each
of them  broadcasts this message when it receives it. It follows that
 cannot block forever at line~C\ref{SA-C-02}.

Let us now consider the wait statement at lines~C\ref{SA-C-05}-C\ref{SA-C-06}.
There are two cases. Let  {\sc read}~ be a message
broadcast by  the simulator  at line~C\ref{SA-C-03}.
\begin{itemize}
\vspace{-0.2cm}
\item Case 1:
No correct simulator ever receives a message {\sc value}~.
In this case, each correct simulator   is such that
 remains always equal to .
It follows  that, when   receives the  message {\sc  read}~,
it sends back to  the message {\sc read'answer}~
(line~C\ref{SA-C-21}).
As there are strictly more than  correct simulators, 
 eventually receives the   message  {\sc read'answer}~ 
from strictly  more than 
different  simulators, and the predicate of line~C\ref{SA-C-05}
is then satisfied.
\vspace{-0.2cm}
\item Case 2:
At least one correct simulator  receives a message {\sc value}~.
In  this case,    broadcasts  the message  {\sc  value}~ when  it
receives it (line~C\ref{SA-C-20}).
It follows from the broadcasts issued at this line  that  eventually
receives {\sc value}~ from strictly more than  different 
simulators.
When this occurs, the predicate of line~C\ref{SA-C-06} is satisfied,
and  exits the wait statement.
\end{itemize}
As this is true for any message  {\sc read}~ broadcast by
the simulator  at line~C\ref{SA-C-03}, it follows that  cannot
remain block forever at lines~C\ref{SA-C-05}-C\ref{SA-C-06}.



Let us finally consider  the lines~C\ref{SA-C-12}-C\ref{SA-C-13}.
As the message  {\sc view}   broadcast by 
at line~C\ref{SA-C-12} is received by at least all the correct processes,
and  each of them broadcast it when it receives it for the first time,
it follows that  receives the message  {\sc view}  from
strictly more than  distinct processes, and stops waiting at 
line~C\ref{SA-C-13},
which concludes the proof of the lemma.
\renewcommand{\toto}{lemma:safe-agr-term-propose}
\end{proofL}


\begin{lemma}
\label{lemma:safe-agr-validity}
The value returned by an invocation of  is a value
that was  proposed by a simulator.
\end{lemma}

\begin{proofL}
Let us observe that (due to its definition) the  set 
is non-empty, and (due the first predicate of line~C\ref{SA-C-06})
the simulator indexes  it contains are such that .
As, for any of those ,   is set to a non- value (only
once) at line~C\ref{SA-C-20}, it follows that  received a message
{\sc value} . Hence, the values in the  variables  
are values proposed by the corresponding simulators .
It follows that the value computed at line~C\ref{SA-C-18} is a value that
was proposed by a simulator, which concludes the proof of the lemma.
\renewcommand{\toto}{lemma:safe-agr-validity}
\end{proofL}

\begin{lemma}
\label{lemma:safe-agr-agreement}
No two invocations of  return different values.
\end{lemma}

\begin{proofL}
Let us first observe that, due to the reliable broadcast of the messages
{\sc value}~() (lines~C\ref{SA-C-01} and~C\ref{SA-C-20})  and
{\sc view}~() (lines~C\ref{SA-C-12} and~C\ref{SA-C-22}), 
and the fact that a simulator broadcast a single message {\sc value}~, 
we have:
\begin{itemize}
\vspace{-0.2cm}
\item .
\vspace{-0.2cm}
\item .
\end{itemize}

Let us assume, by contradiction, that two simulators  and 
decide different values. This means that the sets  
  computed at line~C\ref{SA-C-17} by     and  ,
respectively,  are different.

Since  and  are different,
let us consider 
(if ,  swap  and ).
According to the closure predicate used at line~C\ref{SA-C-16},
as ,
we have  .
It follows that any simulator  such that  does not
fulfill the condition of line~C\ref{SA-C-07} for  .
Consequently,  received at line~C\ref{SA-C-05} a message
{\sc read'answer}()
from a set of simulators  of size strictly greater
than .
Consequently when  executed line~C\ref{SA-C-03} for , all the
simulators  of  verified .

When the simulator  stops waiting at line~C\ref{SA-C-02}, it received
messages {\sc value}(,)
(where  is the value sent by  at line~C\ref{SA-C-01})
from a set  of strictly more than  simulators.
It follows that , consequently
there is a  simulator  that sent
a message {\sc read'answer}() to  and a message
{\sc value}(,) to .
Since  is never reset to  after being assigned,
the simulator  necessarily executed line~C\ref{SA-C-03} for 
strictly before  stops waiting at line~C\ref{SA-C-02}. Consequently
 stopped waiting at line~C\ref{SA-C-02} before 
executes line~C\ref{SA-C-03} for . It does so after receiving
messages {\sc value}(,)
(where  is the value sent by  at line~C\ref{SA-C-01})
from a set  of strictly more than  simulators
, and each of these simulators then verifies .
These simulators do not send {\sc read'answer}() messages when
they receive the {\sc read}() message sent by .
Thus, it is impossible that  receives these messages from strictly
more than  processes,
it consequently cannot verify the predicate of line~C\ref{SA-C-05}. It
follows that  executes line~C\ref{SA-C-12} with
 and this entails that
.

Since , ,
.
According to the predicate of line~C\ref{SA-C-16}, this entails that
, and since the previous reasoning holds for any
, it shows that .
It follows that, when  executes line~C\ref{SA-C-17},  and,
consequently, . It entails that if
,
then  would have been chosen by  at
line~C\ref{SA-C-17}, which proves that 
and contradicts the fact that  and  decide differently.
\renewcommand{\toto}{lemma:safe-agr-agreement}
\end{proofL}

\begin{lemma}
\label{lemma:safe-agr-term-decide}
If no simulator crashes while executing  , then any
invocation of  by a correct simulator terminates.
\end{lemma}

\begin{proofL}
If no simulator crashes while executing  ,
it follows from Lemma~\ref{lemma:safe-agr-term-propose}
that every simulator  that invokes   broadcasts
a message  {\sc value}  at line~C\ref{SA-C-01} and
a message  {\sc view}  at line~C\ref{SA-C-12}.

Assuming no  simulator  crashes while executing  ,
let  be the set of simulators that invoke , and
suppose that one of them, , invoke  and never terminates.
This can only happen if  waits forever for the condition of
lines~C\ref{SA-C-15}-C\ref{SA-C-16} to be fulfilled.
Since eventually the messages broadcast by the
simulators of  are all delivered to , after some finite time
. Moreover, since
the views broadcast by the  simulators of  are built at
line~C\ref{SA-C-08} from the messages {\sc value}~(,)
they receive, it follows that these views can contain non- values
only for the entries corresponding to the simulators of  (the simulators
that are not in  do not sent  messages {\sc value}(,)).
Consequently,  eventually verifies .
It follows that the property of lines~C\ref{SA-C-15}-C\ref{SA-C-16} is
eventually true for , which contradicts the fact that 
never terminates its  operation.
\renewcommand{\toto}{lemma:safe-agr-term-decide}
\end{proofL}


\begin{theorem}
\label{theorem-safe-agreement}
The algorithm in Figure~{\em\ref{algo-SA-msg-passing-crash}}
implements a safe agreement object in .
\end{theorem}

\begin{proofT}
The proof follows from
Lemma~\ref{lemma:safe-agr-term-propose} (Propose-Termination),
Lemma~\ref{lemma:safe-agr-validity} (Validity),
Lemma~\ref{lemma:safe-agr-agreement} (Agreement),  and
Lemma~\ref{lemma:safe-agr-term-decide} (Decide-Termination).
\renewcommand{\toto}{theorem-safe-agreement}
\end{proofT}


\subsection{Simulation algorithm}

The simulation algorithm takes as input a distributed algorithm 
solving a (colorless) task in the system model , and
simulates it in  .  Each simulator , ,
is given a copy  of the  processes of , and a private input vector
, with one input per simulated processes .


The simulation consists in a fair simulation by each of the 
simulators  of the  simulated processes .
To that end,  each simulator manages  threads
(each simulating a process ), and the  threads
associated with the simulation of a process  cooperate
through safe agreement objects.


\paragraph{Objects shared by the simulators}
To produce a consistent simulation, for each simulated process ,
the  simulators have to agree on the  same sequence of the messages
received by . To that end, they use an array of safe agreement objects,
denoted , such that   allows them to agree on the
-th message received by the   threads simulating  at each
simulator .

\paragraph{Objects managed by each simulator }
Each simulator manages the following data structures, with respect to each
simulated process .
\begin{itemize}
\vspace{-0.2cm}
\item
 contains the input of the simulated process ,
proposed by the simulator . (Simulators are allowed to propose
different input vectors for the simulated processes).
\vspace{-0.2cm}
\item
 is the sequence number (from the simulation point of view) of the
next message received by the simulated process .
\vspace{-0.2cm}
\item
 is  a sequence containing  messages sent by the simulated
processes  to the simulated process . It is assumed that the 
threads of  access  in mutual exclusion
(when they add messages to or  withdraw  messages from this sequence).
The symbol  is used to add messages at the end of a sequence.
Sometimes  is used as a set.
\vspace{-0.2cm}
\item
 is  a set containing the messages received by the simulated
process  (init.~).
\vspace{-0.2cm}
\item
 contains the current local state of the simulated process
.  is a part of .

It is assumed that the behavior of each simulated process  
is described by a deterministic
transition function , such that  
(a) simulates  until its next message reception, and (b)
returns a pair. This pair is made up of the new local state of  plus
an array  where   contains  messages sent by 
to the simulated process .
\end{itemize}


In addition to the previous local data, each simulator   uses a
starvation-free
mutual exclusion lock, whose operations are denoted 
and . This lock is used to ensure that, at any time,
at most one of the  threads of  access a safe agreement object.
This is to guarantee that the crash of a simulator   entails the crash
of {\it at most one} simulated process  (line~\ref{Simu-C-09}).
More precisely, if  crashes while executing ,
it can block forever  only the invocations of  ,
issued by the other simulators, thereby preventing  the simulation of 
from terminating.

\renewcommand{\linenumbering}{\ifthenelse{\value{linecounter}<10}
{(0\arabic{linecounter})}{(\arabic{linecounter})}}
\begin{figure}[th!]
\begin{myalgo}
\resetline
\line{Simu-C-01}
\> \\

\line{Simu-C-02}
\> ;\\

\line{Simu-C-03}
 \>  ;\\

\line{Simu-C-04}
 \>  {\bf for each}   {\bf do}
   {\bf end for}; \\


\line{Simu-C-05}
\> ;\\

\line{Simu-C-06}
\> {\bf repeat forever}\\

\line{Simu-C-07}
\> \> ;\\

\line{Simu-C-08}
\> \> {\bf wait} ;\\

\line{Simu-C-09}
\> \> ;\\

\line{Simu-C-10}
\> \> ; 
      ;\\

\line{Simu-C-11}
\> \> \\

\line{Simu-C-12}
\> \> ;\\

\line{Simu-C-13}
\> \>      ;\\

\line{Simu-C-14}
\> \>  {\bf for each}   {\bf do}
   {\bf end for}; \\


\line{Simu-C-15}
\> \>  {\bf if} (no value yet decided by  ~
                     allows  to decide a value )  \\

\line{Simu-C-16}
\> \> \>  {\bf then}  the simulated process  decides  \\

\line{Simu-C-17}
\> \>  {\bf end if} \\

\line{Simu-C-18}
\> {\bf end repeat}.

\end{myalgo}
\caption{Thread of the simulator  , , simulating
the process , }
\label{algo:simulation-crash}
\end{figure}




\paragraph{The simulation algorithm}
The algorithm describing the simulation of a process 
by the associated thread of the simulator  is presented in
Figure~\ref{algo:simulation-crash}.

The simulators have first to agree on the same input for process .
To this end, they use the safe agreement object 
(lines~\ref{Simu-C-01}-\ref{Simu-C-02}).  Moreover, when considering all
the simulated processes, it follows from the
mutual exclusion lock that, whatever the number of simulated processes,
a simulator  is engaged in at most one
invocation of  at a time.
Then, according to the decided  input of ,  locally simulate 
until it invokes a message  reception (lines~\ref{Simu-C-03}-\ref{Simu-C-04}).


After this initialization, each simulator  enters a loop whose aim
is to locally  simulate . To this end,  first determines
the message that  will receive; this message is saved in 
and added to  (lines~\ref{Simu-C-07}-\ref{Simu-C-12}).
When this message has been determined,  simulates the behavior of 
until its next message reception  (lines~\ref{Simu-C-13}-\ref{Simu-C-14}).
Finally, if  allows  to decide a value with respect to
the simulated decision task, this value is decided
(lines~\ref{Simu-C-15}-\ref{Simu-C-17}).

\subsection{Proof of the simulation}
The reader interested in a formal definition of the term {\it simulation}
--as used here-- will consult~\cite{BGLR01}.

\begin{lemma}
\label{lemma:at-most-one-crash}
The crash of a simulator  entails the crash of at most one simulated
 process .
\end{lemma}

\begin{proofL}
The only places where a simulator  can block is during the invocation of
the safe agreement operation . Such invocations appear at
line~\ref{Simu-C-02}, and line~\ref{Simu-C-11}. It follows from the
termination property of the safe agreement objects that such an invocation
can block forever the invoking process only if a simulator crashes
during the invocation of  the operation  on the same object.
But, due to the mutual exclusion lock used at line~\ref{Simu-C-01} and
line~\ref{Simu-C-10}, a simulator can be engaged in at most one
invocation of propose at a time. It follows that the crash of a simulation
 can entail the definitive halting (crash) of at most one simulated
process .
\renewcommand{\toto}{lemma:at-most-one-crash}
\end{proofL}

\begin{lemma}
\label{lemma:same-seq-of-messages}
The simulation of the reception of the -th
message received by a simulated process , returns the same message
at all simulators.
\end{lemma}

\begin{proofL}
The simulation of the message receptions for a simulated process ,
are executed at each simulator  at lines~\ref{Simu-C-08}-\ref{Simu-C-11},
and all the simulators use the same sequence of sequence numbers
(line~\ref{Simu-C-07}).
It then follows from the agreement property of the safe agreement object
, that no two simulators obtain different messages
when they invoke  , and the lemma follows.
\renewcommand{\toto}{lemma:same-seq-of-messages}
\end{proofL}

\begin{lemma}
\label{lemma:one-dec-value}
For every simulated processes , no two simulators return
different values.
\end{lemma}

\begin{proofL}
The only non-deterministic elements of the simulation are the input vectors
 at each simulator , and the reception of the simulated
messages.

The lines~\ref{Simu-C-01}-\ref{Simu-C-02} of the
simulation force  the simulators to agree on the same input value
for each simulated process , .
Similarly,  as shown by Lemma~\ref{lemma:same-seq-of-messages},
for each simulated process , the lines~\ref{Simu-C-07}-\ref{Simu-C-11}
direct the simulators to  agree on the very same sequence of messages
received by . It follows from the fact that the function 
is deterministic, that   any two simulators  and ,
that execute  lines~\ref{Simu-C-15}-\ref{Simu-C-16} during the
same ``round number'' , are such that ,
from which the lemma follows.
\renewcommand{\toto}{lemma:one-dec-value}
\end{proofL}

\begin{lemma}
\label{lemma:correct-simulation}
The sequences of message receptions simulated by each simulator 
on behalf of each simulated process , define a correct execution of
the simulated algorithm.
\end{lemma}

\begin{proofL}
To prove the correctness of the simulation, we have  to show that
\begin{enumerate}
\vspace{-0.2cm}
\item
\label{item1}
Every message that was sent by a simulated process to another simulated
process (whose simulation is not blocked either), is received, and
\vspace{-0.2cm}
\item
\label{item2}
The simulated messages respect a simulated physical order
(i.e., no message is ``received'' before being  ``sent'').
\end{enumerate}

Item~\ref{item1} is satisfied because the messages sent by
the simulated process  to the simulated process  are received
(lines~\ref{Simu-C-09}-\ref{Simu-C-11}) in their sending order
(as defined at line~\ref{Simu-C-04}  and line~\ref{Simu-C-14}).
Hence, if  is not blocked (due to the crash of a simulator)
it obtains the messages from  in their sending order.


For Item~\ref{item2}, let us define a (simulated) physical order as follows.
For each simulated message , let us consider the first time at which the
reception of   was simulated (i.e., this occurs when
 --for the first time-- a simulator terminates  the invocation  of
  that returns ).
A message that is decided has been proposed by a simulator to a safe agreement
object before  being decided (validity property).The  sending time of  a
simulated message is defined as  the first time at which
 is  invoked by a simulator.
It follows that any simulated  message is sent before being received,
which concludes the lemma.
\renewcommand{\toto}{lemma:correct-simulation}
\end{proofL}


\begin{lemma}
\label{lemma:nb-simulated-proc}
Each correct simulator  computes the decision value of
at least  simulated processes.
\end{lemma}

\begin{proofL}
Due to Lemma~\ref{lemma:at-most-one-crash}, and the fact that at most 
simulators may crash, it follows that at most  simulated processes may be
prevented from progressing. As (a) by assumption the simulated algorithm 
is -resilient, and (b) due to Lemma~\ref{lemma:correct-simulation}
the simulation produces a correct simulation of , it follows that at
least  simulated processes decide a value.
\renewcommand{\toto}{lemma:nb-simulated-proc}
\end{proofL}



\begin{theorem}
\label{theorem:main-simulation}
Let  be an algorithm solving a decision task in .
The algorithm described in Figure~\ref{algo:simulation-crash} is a
correct simulation of  in~.
\end{theorem}

\begin{proofT}
The theorem follows from  Lemma~\ref{lemma:correct-simulation} and Lemma~\ref{lemma:nb-simulated-proc}.
\renewcommand{\toto}{theorem:main-simulation}
\end{proofT}




\section{BG(MP,B): BG in the Byzantine Asynchronous Message-Passing  Model}
\label{sec:BG-byzantine-model}

This section presents an algorithm, denoted BG(MP,B), which implements the BG
simulation in the Byzantine asynchronous message-passing model .
To this end, an appropriate  safe agreement object is first built, and then
used by the simulation algorithm.



\subsection{From crash failures to Byzantine behaviors}
The idea is to extend the algorithm of Figure~\ref{algo-SA-msg-passing-crash}
to obtain an algorithm that copes with Byzantine simulators.
The main issues that have to be solved are the following.
\begin{itemize}
\vspace{-0.2cm}
\item
The simulators  need a  mechanism to  control the  validity of the inputs
to the safe agreement objects. (See below for the notion of a valid value.)
\vspace{-0.2cm}
\item
The simulators must be able to check if a given simulator  is
participating in more than one operation  at the same time
(on the same or several safe agreement objects).
If it is the case,  is faulty and its definitive stop  can block forever
several simulated processes. Hence, such a faulty simulator has to be ignored.
\end{itemize}
To solve these issues, each safe agreement object may no longer be considered
as a separate abstraction: each new instance depends on the previous ones. This
is captured in the following specification customized to the Byzantine
model, and, at the operational level, in the predicate 
used in the algorithm implementing the operation .


\subsection{Safe agreement in  : definition}
\label{sec:spec-Byzantine-SA}
To cope with  the previous observations, the fact that
a faulty process may decide an arbitrary  value,
and the fact  that the safe agreement objects are used  to solve
specific problems (a simulation in our case),
the specification of the safe agreement object is reshaped as follows.

A value proposed by a process to a safe agreement object must be
{\it valid}. At each correct simulator , the validity of a value is 
captured by a predicate denoted 
where  is the value and  the simulator that proposed it.
This predicate is made up of two parts (defined in Section~\ref{sec:is-valid} 
and  Section~\ref{sec:simulation-byzantine}, respectively).
If  is correct, the predicate  eventually 
returns  at . If
 is faulty,    returns   at 
only if
 (a) the value   could have been proposed by a correct simulator and (b) 
 to 's knowledge,  does not participate concurrently in several 
invocations of  .
\vspace{-0.1cm}
\begin{itemize}
\item Validity.
If a correct simulator  decides the value , there is 
a correct simulator  such that .
( was validated by a correct simulator.)
\vspace{-0.2cm}
\item Agreement. No two correct simulators decide distinct values.
\vspace{-0.2cm}
\item Propose-Termination.
Any invocation of   by a correct simulator terminates.
\vspace{-0.2cm}
\item Decide-Termination.
The invocations by all the correct simulators  of 
on all the safe agreement objects terminate, except for at most 
safe agreement objects.
\end{itemize}


\subsection{Safe agreement in  : algorithm}
\label{sec:is-valid}

The local variables , ,
,  and the algorithm implementing the operation
 are the same as in Figure~\ref{algo-SA-msg-passing-crash}
(lines~C\ref{SA-C-15}-C\ref{SA-C-19}).
The  new algorithm implementing the  operation , and the
processing of the associated messages, are  described in
Figure~\ref{algo-SA-msg-passing-byzantine-propose} and
Figure~\ref{algo-SA-msg-passing-byzantine-answers}.


This implementation uses an additional local array
, all entries of which are initialized to
``?''. The meaning of  ``'' 
(where  is a proposed value or ) is the following:
to the knowledge of , the simulator  answered  value  when
it received  the message {\sc read} sent by .
(A simulator  broadcasts such a message when it needs to know the value
proposed by  the simulator ;  means that  does not 
know this value yet.) This  means that, from  's point of
view, the value proposed by , as known by  when it received 
the request by , is .



\begin{lemma}
\label{lemma:quorum-intersection}
Any two sets of simulators  and  of more than 
elements have at least one correct simulator in their intersection.
\end{lemma}

\begin{proofL}
As  we   consider  integers,  ``strictly  more  than  ''
is equivalent to ``at least ''.

 \begin{itemize}
\vspace{-0.2cm}
\item
. Hence, .
\vspace{-0.2cm}
\item
.
Hence,  . It follows that  
contains at least one correct simulator.
\end{itemize}
\vspace{-0.4cm}
\renewcommand{\toto}{lemma:quorum-intersection}
\end{proofL}


The fact that, despite Byzantine processes,  the intersection of any two
simulator  sets of  size greater than  have at least one
correct simulator in common, is used in many places in the algorithm.
This property will be used in the proof to show that the local views
of the correct processes are mutually consistent.


\paragraph{The operation }
The client side of the algorithm implementing the operation 
is described in Figure~\ref{algo-SA-msg-passing-byzantine-propose}; its server
side is described in Figure~\ref{algo-SA-msg-passing-byzantine-answers}.
The client side  algorithm is very close to the one of the crash failure case
(Figure~\ref{algo-SA-msg-passing-crash}).  They differ in two points.
\begin{itemize}
\vspace{-0.2cm}
\item
The  message tags {\sc value} and {\sc view} (used at
lines~C\ref{SA-B-02},~C\ref{SA-B-06},  and~C\ref{SA-B-13}
in Figure~\ref{algo-SA-msg-passing-crash}) are replaced
in Figure~\ref{algo-SA-msg-passing-byzantine-propose}
by the  tags  {\sc value'ack} and {\sc view'ack}, respectively. 
The role of these message tags is explained below.
\vspace{-0.2cm}
\item
The predicate of line~B\ref{SA-B-05}  is replaced by the predicate
.
This predicate states that more than  simulators
answered   to the request message {\sc  read} broadcast by ,
(i.e.,  they  did   not know the  value   proposed   by    when  they
received the  read request).
\end{itemize}

\renewcommand{\linenumbering}{\ifthenelse{\value{linecounter}<10}
{(B0\arabic{linecounter})}{(B\arabic{linecounter})}}
\begin{figure}[ht!]
\begin{myalgo}
\resetline
{\bf operation}  () {\bf is}\\
\line{SA-B-01}~~ \=  {\sc value} ;\\
\line{SA-B-02}    \>   {\bf    wait}    \big({\sc   value'ack}    
  from    different
simulators\big);\\

\line{SA-B-03}    \>   {\bf    for   each}        {\bf   do}
 {\sc read}  {\bf end for};\\

\line{SA-B-04} \> {\bf for each}  {\bf do}\\

\line{SA-B-05}          \>      \>            \>
 {\bf wait}
  \big(\=() \\

\line{SA-B-06}   \> \> \>  \>(   {\sc    value'ack}   
    from   different simulators)\big);\\

\line{SA-B-07}  \>   \> \> 
{\bf if} (predicate of line~B\ref{SA-B-06} satisfied)\\
\line{SA-B-08}  \>   \> \> \> {\bf then} \= \\

\line{SA-B-09}   \>  \> \> \> {\bf else} \> \\

\line{SA-B-10}  \>   \> \> {\bf end if}\\
\line{SA-B-11} \> {\bf end for};\\

\line{SA-B-12} \>  {\sc view} ;\\

\line{SA-B-13}   \>  {\bf   wait}   \big({\sc  view'ack}   
  from    different simulators\big);\\

\line{SA-B-14} \> .\\~\\


{\bf operation}  () {\bf is}\\
(C\ref{SA-C-15})
\>  {\bf wait}
       \big( a non-empty set :\\

(C\ref{SA-C-16})
\> \> ~;\\

(C\ref{SA-C-17})
\> {\bf let}  {\bf be} the set   of smallest size; \\

(C\ref{SA-C-18})
\>  {\bf let}  {\bf be} ;\\

(C\ref{SA-C-19})
\> .
\end{myalgo}
\caption{Safe agreement object in :
operation   of simulator }
\label{algo-SA-msg-passing-byzantine-propose}
\end{figure}



\begin{figure}[ht!]
\begin{myalgo}


{\bf when the message} {\sc value}  {\bf is}
  {\bf for the first time}:\\
\line{SA-B-15} \= {\bf wait} \big( ()\big);
 {\sc value'valid} .\\~\\

{\bf when the message} {\sc value'valid}  {\bf is}
 :\\
\line{SA-B-16} \> {\bf if}
  \=\big(({\sc value'valid} 
     from   different simulators)    ({\sc
value'witness}  never broadcast)\big)\\
\line{SA-B-17} \> \> {\bf then}  {\sc value'witness}  {\bf end if}.\\~\\


{\bf when the message} {\sc value'witness}  {\bf is}
 :\\

\line{SA-B-18}   \>   {\bf    if}   \=\big(({\sc   value'witness}   
   from     different  simulators)     ({\sc
value'witness}  never broadcast)\big)\\

\line{SA-B-19} \> \>
    {\bf then}  {\sc value'witness} \\
\line{SA-B-20} \> {\bf end if};\\
\line{SA-B-21} \> {\bf if}
  \=({\sc value'witness} 
     from   different simulators)\\
\line{SA-B-22} \> \> {\bf then}
   \=;  {\sc value'ack} \\

\line{SA-B-23} \> {\bf end if}.\\~\\

--------------------------------------------------------------------------------------------------------------------------------------------------\\



{\bf  when  the message}  {\sc  read}    {\bf is}   {\bf for the first time}:\\

\line{SA-B-24}    \>    {\bf    wait}    \big({\sc    value'ack}    
  from   different simulators\big);\\

\line{SA-B-25}      \>       ;
 {\sc value'ack} ;\\

\line{SA-B-26}      \>           {\sc      read'answer}
.\\~\\



{\bf   when   the   message}   {\sc   read'answer}      {\bf   is}
 {\bf for the first time}:\\

\line{SA-B-27}  \> {\bf  if} ({\sc  read'answer'witness}   never
broadcast)   {\bf  then}     {\sc  read'answer'witness}
 {\bf end if}.\\~\\



{\bf when the message}
{\sc read'answer'witness}  {\bf is} :\\

\line{SA-B-28} \> {\bf if} \=\big(\=({\sc read'answer'witness}
  from  different simulators)\\

\line{SA-B-29} \> \>
 ({\sc read'answer'witness}  never broadcast)\big)\\
\line{SA-B-30} \> \>
{\bf then}  {\sc read'answer'witness} \\
\line{SA-B-31} \> {\bf end if};\\
\line{SA-B-32} \> {\bf if}
\=({\sc read'answer'witness}  
          from  different simulators)\\
\line{SA-B-33} \> \> {\bf then} \\
\line{SA-B-34} \> {\bf end if}.\\~\\
--------------------------------------------------------------------------------------------------------------------------------------------------\\
{\bf when the message} {\sc view}  {\bf is}  {\bf for the first time}:\\
\line{SA-B-35} \> {\bf if} \=\big(({\sc view'witness}  never broadcast)  ()\big)\\
\line{SA-B-36} \> \>{\bf then} \={\bf for} \= {\bf do}\\
\line{SA-B-37} \> \> \> \> {\bf if} \=()\\
\line{SA-B-38} \> \>  \> \> \>
   {\bf then} \={\bf  wait} \big({\sc value'ack}
         from 
       different simulators\big)\\
\line{SA-B-39} \> \> \> \> \>
     {\bf else} \>
     {\bf wait} \big(\big)\\
\line{SA-B-40} \> \> \> \>{\bf end if}\\
\line{SA-B-41} \> \> \> {\bf end for};\\
\line{SA-B-42} \> \> \>  {\sc view'witness} \\
\line{SA-B-43} \>{\bf end if}.\\~\\


{\bf when the message}
{\sc view'witness}  {\bf is} :\\
\line{SA-B-44} \> {\bf if} \=\big(({\sc view'witness} 
          from  different simulators)
 ({\sc view'witness}  never broadcast)\big)\\

\line{SA-B-45} \> \>
{\bf then}  {\sc view'witness} \\
\line{SA-B-46} \> {\bf end if};\\

\line{SA-B-47} \>
     {\bf if} \=({\sc view'witness}  
       from  different simulators)\\

\line{SA-B-48} \> \>{\bf then} \=;
           {\sc view'ack}   \\


\line{SA-B-49} \> {\bf end if}.

\end{myalgo}
\caption{Safe agreement object in :
server side of simulator }
\label{algo-SA-msg-passing-byzantine-answers}
\end{figure}


\paragraph{Messages {\sc value},  {\sc value'valid}, 
{\sc value'witness} and {\sc value'ack}}
When a simulator  invokes the operation  , it first
broadcasts the message {\sc value} , and waits for
 acknowledgments (messages {\sc value'ack},
lines~B\ref{SA-B-01}-B\ref{SA-B-02}).
Then, as in the crash failure case (Figure~\ref{algo-SA-msg-passing-crash}),
it builds its  local view of the values proposed to the safe agreement object
(lines~B\ref{SA-B-03}-B\ref{SA-B-11}).  Finally, it sends  its local  view to
all other simulators (lines~B\ref{SA-B-12}-B\ref{SA-B-13}).


On its server side, when a simulator  receives a message
{\sc value} , it first checks if this message is valid
(line~B\ref{SA-B-15}).
If the message is valid,  broadcasts (echoes) the message
{\sc value'valid}  to inform the other simulators
that it agrees to take into account the pair  (line~B\ref{SA-B-15}).

When the simulator   has received the message {\sc value'valid} 
from more than  simulators, it broadcasts the message 
{\sc value'witness}  to inform the other processes that 
at least   correct simulators,
have validated the pair  . 


When  has received the message {\sc value'witness} 
from  simulators (i.e., from at least one correct simulator) it
broadcasts this message, if not yet done (lines~B\ref{SA-B-18}-B\ref{SA-B-20}).
This is to prevent  invocations of  
from blocking forever (while waiting {\sc value'ack} 
messages at line~B\ref{SA-B-02}, B\ref{SA-B-06}, B\ref{SA-B-24} or
B\ref{SA-B-38}),   because not enough {\sc value'witness}  messages
have been broadcast\footnote{A similar mechanism is used in~\cite{B87}
to ensure that the proposed reliable broadcast abstraction guarantees
that a  message is received by all or none of the correct processes.}.
Then, if   has received the message {\sc value'witness} 
from more than  simulators,
it takes  into account  (writes it into ) and sends an
acknowledgment to  (lines~B\ref{SA-B-21}-B\ref{SA-B-23}).
The corresponding message {\sc value'ack}  broadcast by 
will  also inform the other simulators  that  took  into account the
value     proposed by  . Hence,  this message  will help  
progress at line~B\ref{SA-B-02}, and all correct simulators  progress at
line~B\ref{SA-B-06}.




\paragraph{First part of the predicate }
\label{sec:def-is-valid}
As already indicated, the aim of this predicate is  to help a simulator 
detect if the value  proposed by the simulator   is valid.
It is always satisfied when    is correct, and it can return 
  or  when  is faulty. 
It is made up of two sub-predicates  and .

\begin{itemize}
\vspace{-0.2cm}
\item
The first sub-predicate  
checks if, for the messages {\sc value}  (from ) and 
{\sc value'valid}  (from more than  different simulators) 
that  has  received for other safe agreement objects,   has also 
received the associated messages {\sc view'witness}~ 
from at least  different simulators.
This allows  to check if the simulator  is not
simultaneously  participating in other invocations of 
on  other safe agreement  objects.
\vspace{-0.2cm}
\item
The aim of the second  sub-predicate  (defined in
Section~\ref{sec:simulation-byzantine} and used in the simulation) is 
to allow the simulators to check that the simulation is consistent.
As  the present section considers safe agreement objects independently 
from its use in the simulation, we consider, for now,
 that  is always satisfied.
\end{itemize}
If the full predicate  is never satisfied,  
 will, collectively with the other correct simulators,
prevent the faulty simulator  from progressing
with respect to the corresponding safe agreement object.


\paragraph{Messages {\sc read}, {\sc read'answer} and
          {\sc read'answer'witness}}
 After the value  it proposes to the safe agreement object has been
taken  into  account by  simulators,    builds a
local view  of all the values proposed (array ). To this end, as in  the crash
failure model,    sends to each simulator  the customized message
{\sc read}~ (line~B\ref{SA-B-03}).
Its behavior is then similar to the one of the crash failure model
(line~B\ref{SA-B-04}-B\ref{SA-B-11}), where the new predicate
 is now used at
line~B\ref{SA-B-05}.


When   receives  the message   {\sc read}~  from  the simulator
, it first waits until it knows that the  value proposed by 
is known by more than  simulators (line~B\ref{SA-B-24}).
This is to check that  broadcast its proposed value before
reading the other simulator values used  to build its own view.
When  this   occurs,   answers the  message {\sc  read}~
by broadcasting the message  {\sc read'answser}~
 to inform all the simulators on what it currently knows on the value
proposed by  (line~B\ref{SA-B-26}). (Let us remind that, in  the
crash failure model,  was sending this message only to .)



When it receives the message {\sc read'answer}~ from a simulator
,  if not yet done,    broadcasts the message
{\sc read'answser'witness}~.
The lines~B\ref{SA-B-27}-B\ref{SA-B-31} implement a reliable broadcast
\cite{B87}, i.e., the message {\sc read'answser'witness}~
is   received by all correct  processes  or none of  them,  and is  always
received if the sender is correct. The reliable  reception of  this
message entails the assignment of  to 
(line~B\ref{SA-B-33}).


\paragraph{Messages {\sc view}, {\sc view'witness}
           and {\sc view'ack}}
Finally, as in Figure~\ref{algo-SA-msg-passing-crash},
the simulator  broadcasts its local view of proposed values to
all  simulators, waits until more than   of them sent back an
acknowledgment, and returns  from  the  invocation  of
 (lines~B\ref{SA-B-12}-B\ref{SA-B-14}).


When  receives for the first time the message  {\sc view}~,
it realizes an enriched reliable broadcast whose aim is to assign
 to . Let us first observe that if ,
then  is Byzantine. If it has not yet broadcast
{\sc  view'witness}~ and  if 
(line~B\ref{SA-B-35}),  first
checks if all the  values in   are  consistent.
From its  point of view, this means that, for each simulator ,
(a) if , it must  receive messages {\sc value'ack}~
from more than  simulators, and (b) if  ,
the same predicate as in line~B\ref{SA-B-05} must become satisfied.
This consistency check is realized by the lines~B\ref{SA-B-36}-B\ref{SA-B-41}.


Finally, when   receives a message  {\sc view'witness}~,
it does the following. First, if  it has  received this message from at
least one correct simulator, and has not yet broadcast it,  does it
(lines~B\ref{SA-B-44}-B\ref{SA-B-46}). This part of the reliable broadcast is
to prevent the correct simulators from blocking forever.
Then, if it has received  {\sc view'witness}~ from more than
  simulators and  has not yet assigned a value to
,  does it and sends to  the acknowledgment
message {\sc view'ack}~ to inform   that it knows its view
(lines~B\ref{SA-B-47}-B\ref{SA-B-49}).

\subsection{A communication pattern}
When considering the algorithm of
Figure~\ref{algo-SA-msg-passing-byzantine-answers}, it appears
that the  processing of the messages 
{\sc value'witness}~  (lines~B\ref{SA-B-18}-B\ref{SA-B-23}), 
{\sc read'answer'witness}~ (lines~B\ref{SA-B-28}-B\ref{SA-B-34}), and
{\sc view'witness}~ (lines~B\ref{SA-B-44}-B\ref{SA-B-49}), 
follow the same generic pattern. 
This pattern, inspired from~\cite{B87} and 
where {\sc witness} is used as message tag, 
is described in Figure~\ref{algo:generic-pattern}.


\renewcommand{\linenumbering}{\ifthenelse{\value{linecounter}<10}
{(GP0\arabic{linecounter})}{(GP\arabic{linecounter})}}
\begin{figure}[ht]

\centering{\fbox{
\begin{minipage}[t]{150mm}
\footnotesize
\renewcommand{\baselinestretch}{2.5}
\resetline
\begin{tabbing}
aaaaaaaaa\=aaa\=aaaaa\=aaaaaa\=\kill
{\bf when} {\sc witness}  {\bf is} :\\

\line{GP-01}  \> 
{\bf if} \=\big(\={\sc witness}   
                                   from  different simulators\\

\line{GP-02} \> \>
 {\sc witness}  never broadcast\big)\\

\line{GP-03} \> \>
{\bf then}  {\sc witness} \\

\line{GP-04} \> {\bf end if};\\

\line{GP-05} \> {\bf if}
\=({\sc witness}  
          from  different simulators)\\

\line{GP-06} \> \> {\bf then} execute statement \\

\line{GP-07} \> {\bf end if}.

\end{tabbing}
\end{minipage}
}
\caption{Generic communication pattern in }
\label{algo:generic-pattern}
}
\end{figure}


\begin{theorem}
\label{theo-generic-pattern}
{\em (i)} If a correct simulator  executes  action ,
all correct simulators do it.\\
{\em(ii)}  If  correct simulators execute 
{\sc witness},  all correct simulators execute action .
\end{theorem}

\begin{proofT}
Proof of (i). Let  be a correct process that executes .
It follows from line GP\ref{GP-05} that it has received the message
{\sc witness}  from more than  different simulators.
As , ,
 received the message {\sc witness}  from at least 
correct simulators. It then follows from lines~GP\ref{GP-01}-GP\ref{GP-02}
that all correct simulators broadcast {\sc witness}  and, consequently,
each correct simulator receives {\sc witness}  from at least 
simulators. The proof follows from .


Proof of (ii). If  correct simulators broadcast {\sc witness} ,
the predicate of line~GP\ref{GP-01} is eventually  satisfied
at every correct simulator.  As  As ,
it follows that the predicate of line~GP\ref{GP-05}  will also be
satisfied at each correct simulator, which concludes the proof.
\renewcommand{\toto}{theo-generic-pattern}
\end{proofT}
\subsection{Safe agreement object in : proof}
This section proves that the algorithm presented in
Figures~\ref{algo-SA-msg-passing-byzantine-propose}
and~\ref{algo-SA-msg-passing-byzantine-answers} implements a
safe agreement object in the presence of Byzantine simulators,
i.e., any of its runs in    satisfies the validity, agreement,
and termination properties that define this object.



\paragraph{Propose-termination}

\begin{lemma}
\label{lemma-termination-if-valid}
Let  be a correct simulator.
If the predicate  eventually becomes satisfied
at the correct simulators ,
then the invocation of  by  terminates.
\end{lemma}

\begin{proofL}
A correct simulator  can be blocked forever in a  statement
(1) at line B\ref{SA-B-02},  (2) at lines B\ref{SA-B-05}-B\ref{SA-B-06}, or
(3) at line B\ref{SA-B-13}. We show that, if the predicate
  is eventually  satisfied at the correct simulators
,   cannot block forever in the invocation of .

\begin{itemize}
\vspace{-0.2cm}
\item  instruction at line B\ref{SA-B-02}. \\
Simulator  first broadcasts the message {\sc value}
(line B\ref{SA-B-01}), then waits for {\sc value'ack} messages from more than
 different simulators.
When a correct simulator  receives {\sc value} for the
first time, it waits until   becomes satisfied.
By assumption, this  happens.  Simulator   then broadcasts
{\sc value'valid}. It follows that each of the at least 
correct simulators  broadcasts the message {\sc value'valid}.

As  , it follows that each
correct simulator   receives the message {\sc value'valid}
from more than  simulators and broadcasts the message
{\sc value'witness}.

 According to Theorem~\ref{theo-generic-pattern},  updates 
 with  , and broadcasts {\sc value'ack}
(lines~B\ref{SA-B-21}-B\ref{SA-B-23}).
The correct simulator  will then receive the message
{\sc value'ack} from at least  
simulators. Hence, it cannot block forever at line  B\ref{SA-B-02}.

\vspace{-0.2cm}
\item  instruction at lines B\ref{SA-B-05}-B\ref{SA-B-06}.\\
In this waiting statement,  waits until
either  becomes true, or
until it receives {\sc value'ack} from more than 
different simulators.
\vspace{-0.3cm}
\begin{itemize}
\item
If  is a correct simulator that  invoked ,
the reasoning is the same as above. Consequently,  will receive
{\sc value'ack} from at least  different
simulators.
\vspace{-0.1cm}
\item
If  is faulty or never invokes ,  may never
receive {\sc value'ack} from more than  different
simulators. We will show that, in this case, the wait predicate
  eventually becomes true.
\end{itemize}

We  first show that, if a correct simulator receives
{\sc value'ack} from more than  different simulators,
then all correct simulators do receive {\sc value'ack} from more
than  different simulators.
If a correct simulator receives
{\sc value'ack} from more than  different simulators,
at least  correct simulators broadcast it.
Every correct simulator will then receive the message {\sc value'ack}
from at least  different simulators and, if not already done,
 broadcasts it (lines~B\ref{SA-B-24}-B\ref{SA-B-25}).
All correct simulators will then receive the message {\sc value'ack}
from at least  different simulators.\\


According to the previous observation, let us
consider the case in which no correct simulator ever receives  the message
{\sc value'ack}  from more than different simulators.
A correct simulator  assigns a non- value to  only
if  it receives {\sc value'witness} from more than
 different simulators (line~B\ref{SA-B-22}), or if it receives
{\sc value'ack} from more than  different simulators
(line~B\ref{SA-B-25}). If a correct simulator receives
{\sc value'witness} from more than  different
simulators, according to Theorem~\ref{theo-generic-pattern}, all correct
simulators  receive {\sc value'witness} from more than
 different simulators, and  broadcast
the message {\sc value'ack}.
Because no correct simulator ever receives {\sc value'ack} messages
from more than  different simulators, no correct simulator 
will ever assign a non- value to  (line~B\ref{SA-B-22}).

When a correct simulator receives a {\sc read} message from , it
waits until it has received {\sc value'ack} messages
from more than  different simulators (line~B\ref{SA-B-24}).
The reasoning above (first item)
shows that this will eventually become true.

Every correct simulator  will then broadcast
{\sc read'answer}. This will cause all correct simulators to
broadcast mess sages {\sc read'answer'witness},
which will be received by  the simulator . This
will then assign  to  for
at least  different values of .
Consequently, it  will not remain blocked at
lines~B\ref{SA-B-05}-B\ref{SA-B-06}.

\vspace{-0.2cm}
\item  instruction at line B\ref{SA-B-13}.\\
As simulator   broadcasts its view with a message
{\sc view}  (line~B\ref{SA-B-12}),
every correct simulator  checks if this view is
consistent when it receives it (lines~B\ref{SA-B-36}-B\ref{SA-B-41}).
Let us first consider the entries  such that .
This means that  has received {\sc value'ack} from more than
 different simulators. All the
correct simulators then receive the same message from a sufficient number of
different simulators and do not remain blocked at line~B\ref{SA-B-38}
(Theorem~\ref{theo-generic-pattern}).

Let us now consider the entries  such that .
Simulator  assigned  to 
 because it received
{\sc read'answer'witness} from more than
 different simulators (lines~B\ref{SA-B-32}-\ref{SA-B-33}).
 According to 
Theorem~\ref{theo-generic-pattern}, all the correct simulators 
will also receive {\sc read'answer'witness} from more than
 different simulators, and will assign  to
. They will thus not remain blocked at line~B\ref{SA-B-39}.

All the correct simulators will then broadcast the message
{\sc view'witness} (line~B\ref{SA-B-42}).
By Theorem~\ref{theo-generic-pattern}, they will
all send {\sc view'ack} to . This will allow  to
terminate its invocation of , which concludes the
proof of the lemma.
\end{itemize}
\vspace{-0.6cm}
\renewcommand{\toto}{lemma-termination-if-valid}
\end{proofL}



\begin{lemma}
\label{lemma-valid-if-correct}
Let  be the values proposed by a correct simulator
 to a sequence of safe agreement objects. If  does not invoke
 operations concurrently and  is
eventually satisfied at every correct simulator , then
 is also eventually satisfied at .
\end{lemma}

\begin{proofL}
We  consider here that the sub-predicate  is always satisfied, and
thus consider only the sub-predicate . Let us recall that  states
that, for every message {\sc value} that  received from ,
and for every message {\sc value'valid} that  received from 
at least  different simulators, it has also
received the corresponding messages {\sc view'witness}.

By hypothesis,  is eventually satisfied at the
correct simulator . Once  broadcasts the message
{\sc value},   only needs  to receive the corresponding
{\sc view'witness} for  to be satisfied.
By Lemma \ref{lemma-termination-if-valid},  terminates its invocation
of , from which we conclude that it  received
{\sc view'ack} from more than   different simulators
(line~B\ref{SA-B-13}).
A correct simulator sends such a message only if it has received
{\sc view'witness} from more than   different
simulators (lines~B\ref{SA-B-47}-B\ref{SA-B-48}).
According to Theorem~\ref{theo-generic-pattern},
all the correct simulators  also broadcast it
(lines~B\ref{SA-B-44}-B\ref{SA-B-45}). The correct simulator   then
receives them from more than  different simulators.
The predicate  is then eventually satisfied at 
.
\renewcommand{\toto}{lemma-valid-if-correct}
\end{proofL}

\paragraph{Decide-termination}

\begin{lemma}
\label{lemma:one-decides-all-decide}
If a correct simulator terminates its invocation of , 
then all correct simulators terminate their invocation of .
\end{lemma}

\begin{proofL}
Suppose, by way of contradiction, that the invocation of 
by a correct simulator  terminates, and that the invocation of 
 by another correct simulator  does not.

The invocation of  by  can terminate only if 
the predicate at lines~C\ref{SA-C-15}-C\ref{SA-C-16} is satisfied.
Let  be any simulator in the set  defined at 
line~C\ref{SA-C-15}. We  show that  implies that 
we  eventually have , and thus that  must 
decide.

Simulator  assigns  to  at line~B\ref{SA-B-48}. 
This can happen only because  received 
{\sc view'witness} messages from more than 
 different simulators. According to 
Theorem~\ref{theo-generic-pattern},    eventually  receives
enough {\sc view'witness} messages
and  also assigns  to . Simulator
 will then also have to decide.
\renewcommand{\toto}{lemma:one-decides-all-decide}
\end{proofL}

\begin{lemma}
\label{lemma:at-most-one-blocked-byz}
The invocations of  by all the correct simulators 
on all the safe agreement objects terminate, except for at most 
safe agreement objects.
\end{lemma}

\begin{proofL}
Suppose, by way of contradiction, that there are  safe agreement 
objects such that at least one correct simulator never terminates its 
invocation of . By Lemma 
\ref{lemma:one-decides-all-decide}, there must be 
  different safe agreement objects in which 
no correct simulator  terminates its invocations of .



The invocation of the  operation by a correct simulator 
 on a safe agreement object can only be blocked at 
lines~C\ref{SA-C-15}-C\ref{SA-C-16}, if the corresponding predicate is 
never satisfied. This can happen if (1) there is no simulator  such 
that  or, (2) for every non-empty set of 
simulators , there are  two  simulators  and   
such that .
Because a correct simulator  invokes    
before invoking , case (1) cannot happen; we always have 
. We then consider case (2). 

Case (2) can happen if  starts an invocation of 
 and communicates its proposed value to other processes, 
but does not terminate its invocation by communicating its view.
Because there are at most  faulty simulators, by the pigeonhole 
principle, there must be a faulty simulator  that prevents  from 
deciding on two different safe agreement objects.

A correct simulator  broadcasts a {\sc value'valid}
after receiving a {\sc value} message only if the predicate 
 is satisfied (line~B\ref{SA-B-15}). 
Due to the predicate , this is true only if  received 
{\sc view'witness} messages from at least  different 
simulators, each of these messages corresponding to the all the  
{\sc value} and {\sc value'valid} messages 
that it has previously received (see the definition of the predicate  of 
). 

Let  be the invocation of  by  on 
the first safe agreement object on which  is blocked, and 
 the one on the second safe agreement object on which 
 is blocked. Because there is a simulator  such that 
 in the two invocations of  by 
, in both cases, more than  different simulators
have broadcast a {\sc view'witness} message (line~B\ref{SA-B-48}). 
Both sets  include correct simulators. They 
must then have received {\sc value'ack} and 
{\sc value'ack} from more than  different 
simulators (line~B\ref{SA-B-38}). Again, both sets  include correct 
simulators that must have received {\sc value'witness} and 
{\sc value'witness} from more than  different 
simulators (line~B\ref{SA-B-21}).

In order to broadcast a {\sc value'witness} message,
a correct simulator must either (a) receive {\sc value'witness} 
messages from at least  different simulators (line~B\ref{SA-B-18}),
or (b) receive {\sc value'valid} messages from more than  
different simulators (line~B\ref{SA-B-16}). The first correct simulator 
that broadcasts a 
{\sc value'witness} message must then have received 
{\sc value'valid} messages from more than  
different simulators.

According to Lemma 
\ref{lemma:quorum-intersection}, there is a least one correct simulator 
 that broadcasts both {\sc value'valid} messages 
(line~B\ref{SA-B-15}). 
In order to 
do so, the predicate  must have been verified 
 at the time that   broadcast the 
{\sc value'valid} message. It must then have received 
the {\sc view'witness} messages that correspond to  
from more than  different 
simulators. According to Theorem~\ref{theo-generic-pattern},
 must then also have received these messages from more than 
 different 
simulators and assigned  to  (line~B\ref{SA-B-48}) 
in the instance that corresponds to the invocation of  
by , a contradiction that concludes the proof of the lemma.
\renewcommand{\toto}{lemma:at-most-one-blocked-byz}
\end{proofL}



\paragraph{Agreement}

\begin{lemma}
For any simulator  and any correct simulator , if  assigns a
non- value  to ,
then   no  value  is  ever assigned  to   by a
correct  simulator   and     each  such  correct simulator  
eventually assigns  to .
\label{lemma-byz-uniform}
\end{lemma}

\begin{proofL}
Let  be the first simulator that assigns  to .
Since  executes line~B\ref{SA-B-22},
it received strictly  more than  {\sc value'witness}~
messages from different simulators.
At least   correct  simulators consequently sent  this message  to all
processes at line~B\ref{SA-B-17} or at line~B\ref{SA-B-19}.
By Theorem~\ref{theo-generic-pattern},
every  correct  simulator    consequently eventually  receives  such  a
message from each correct simulator and assigns  to .

Suppose that there exists a value  such that
there is a correct simulator  that assigns  to .
Suppose that  is the first process to do so.
It follows that  received {\sc value'witness}~ messages
from strictly more than  different processes 
(line~B\ref{SA-B-21} or line~B\ref{SA-B-24}).

Consider the first correct simulator that broadcasts a 
{\sc value'witness}~ message. In order to do so, it must have 
received {\sc value'valid}~ messages
from strictly more than  different processes 
(lines~B\ref{SA-B-16}-B\ref{SA-B-17}).
However, the first correct simulator that broadcasts a 
{\sc value'witness}~ message must also have 
received {\sc value'valid}~ messages
from strictly more than  different processes.
There must then be a correct simulator that sent both 
{\sc value'valid}~ messages. The only place a correct simulator can 
send a {\sc value'valid}~ message is at Line~\ref{SA-B-15} and it 
does so only once for each simulator , a contradiction which concludes 
the proof of the lemma.
\renewcommand{\toto}{lemma-byz-uniform}
\end{proofL}

\begin{lemma}
For any  simulators   and any correct  simulator , if
 assigns a non- value   to , then
 no value  is ever assigned to  by
a  correct simulator   and   each  such  correct  simulator 
eventually assigns  to .
\label{lemma-byz-uniform-reads}
\end{lemma}

\begin{proofL}
The proof is the same as for Lemma~\ref{lemma-byz-uniform}.
\renewcommand{\toto}{lemma-byz-uniform-reads}
\end{proofL}


\begin{lemma}
For any simulator  and any correct simulator , if  assigns a
non- value    to ,
then (1) no value  is ever assigned to  by
a  correct simulator    and   (2) each  such  correct simulator  
eventually assigns  to .
\label{lemma-byz-uniform-view}
\end{lemma}

\begin{proofL}
The proof is the same as for Lemma~\ref{lemma-byz-uniform}.
\renewcommand{\toto}{lemma-byz-uniform-view}
\end{proofL}

\begin{lemma}
\label{lemma:safe-byz-agreement}
No two invocations of  return different values.
\end{lemma}

\begin{proofL}
Let us recall that the algorithm implementing the operation 

is described at lines~C\ref{SA-C-15}-C\ref{SA-C-19}.
Let  and  be two correct simulators.
According  to  Lemmas~\ref{lemma-byz-uniform}-\ref{lemma-byz-uniform-view},
we have:
\begin{itemize}
\vspace{-0.2cm}
\item .
\vspace{-0.2cm} 
\item .
\vspace{-0.2cm} 
\item .
\end{itemize}  
 
Let us assume, by contradiction, that  and 
decide different values. This means that the sets   and
  computed at line~C\ref{SA-C-17} by     and  ,
respectively,  are different.

Since  and  are different,
let us consider 
(if ,  swap  and ).
According to the closure predicate used at line~C\ref{SA-C-16},
as ,
we have  .

It  follows  that   received  {\sc view'witness}  ()
messages  (with )
from  a  set  of  simulators     of  size  strictly  larger  than
 (the subscript  stands for ``view witness'').
The correct simulators  of  sent these messages  after checking at
line~B\ref{SA-B-39} that
a set  of strictly more than  reliably broadcast
(thanks to the mechanism of lines~B\ref{SA-B-26} to B\ref{SA-B-33})
a {\sc read'answer} () message.
The   correct   simulators  of      sent   these  messages   at
line~B\ref{SA-B-26} after they  received  {\sc value'ack} () messages
from a set  of strictly more than  simulators
 (the subscript  stands for ``witness'').
Each  correct simulator   of   had   when it
sent this message and it happens
strictly  before the  first  correct simulator  sends  a {\sc  read'answer}
() message.

Since , the correct simulator  received
{\sc view'witness} () messages
from a set  of strictly more than  simulators.
The correct simulators of  sent these messages
after the check of the values at lines~B\ref{SA-B-38}-B\ref{SA-B-39}.

Suppose that some of them verified the predicate of line~B\ref{SA-B-39}
for .
It entails  that a set   of strictly more  than 
simulators reliably broadcast a {\sc read'answer} ().
The correct simulators of  sent this message after receiving at
line~B\ref{SA-B-24}  {\sc value'ack} () messages from a set 
of strictly more than  simulators.
This  happens  strictly before  the  first  {\sc read'answer}  ()
message is sent by a correct simulator.
Since       ,        contains
at least a correct simulator .


Simulator  thus broadcast a {\sc read'answer} () message
and a {\sc read'answer} () message (line B\ref{SA-B-26}). It then 
had   before broadcasting the  
{\sc read'answer} () message and  before 
broadcasting the {\sc read'answer} ().
Because of the first instruction of line~B\ref{SA-B-25} this is impossible,
and thus each correct
process that sends a {\sc view'witness} () message ended
the wait instruction
of   lines~B\ref{SA-B-38}-B\ref{SA-B-39}  by   verifying  the   predicate  of
line~B\ref{SA-B-38}. 
This entails that
.   Consequently, .

Since ,  and thus
.
According to the predicate of line~C\ref{SA-C-16}, this entails that
, and since the previous reasoning holds for any
, it shows that .
It follows that, when  executes line~C\ref{SA-C-17},  and,
consequently, . It entails that if
,
then  would have been chosen by  at
line~C\ref{SA-C-17}, which proves that 
and contradicts the fact that  and  decide differently.
\renewcommand{\toto}{lemma:safe-byz-agreement}
\end{proofL}




\paragraph{Correct values are valid}
\begin{lemma}
\label{lemma-correct-is-valid}
If a correct simulator  decides the value , there is 
a correct simulator  such that .
\end{lemma}
\begin{proofL}


Let  be the value decided by a correct simulator . Value  has
then be proposed by a simulator  such that 
(definition of  at lines~\ref{SA-C-15}-C\ref{SA-C-16} 
and choice of value at 
line~C\ref{SA-C-18}). In order to assign a non- value to 
,  must have received {\sc view'witness}
messages from more than  different  simulators 
(lines~B\ref{SA-B-47}-B\ref{SA-B-48}), and 
consequently from at least one correct 
simulator. Consider the first correct simulator  that has broadcast a
{\sc view'witness} message. Before sending it, it must have assigned 
a non- value to  (lines B\ref{SA-B-35}-B\ref{SA-B-42}).
It then has received either (a) {\sc value'witness} messages from 
more than  different  simulators or 
(b) {\sc value'ack} messages from more than  different  
simulators.

In case (a), consider the first correct simulator  that has 
broadcast a {\sc value'witness} message. In order to do so, 
it must have received {\sc value'valid} messages from more 
than  different  
simulators (lines~B\ref{SA-B-16}-\ref{SA-B-17}).
The predicate  must have been satisfied at the 
simulators that broadcast these messages(line~B\ref{SA-B-15}). 
In case (b), the first correct simulator  that has 
broadcast a {\sc value'ack} message must first have received 
{\sc value'witness} messages from more than  
different  simulators (lines B\ref{SA-B-21}-B\ref{SA-B-23}). 
The situation is then similar to Case (a).
\renewcommand{\toto}{lemma-correct-is-valid}
\end{proofL}


\begin{theorem}
\label{theorem-SA-object-is-correct}
The algorithms described in 
Figure~{\em\ref{algo-SA-msg-passing-byzantine-propose}} and 
 Figure~{\em\ref{algo-SA-msg-passing-byzantine-answers}} implement a 
safe-agreement object in  .
\end{theorem}

\begin{proofT}
The proof follows from the previous lemmas. 
\renewcommand{\toto}{theorem-SA-object-is-correct}
\end{proofT}

\subsection{Simulation algorithm and its proof in  }
\label{sec:simulation-byzantine}
\paragraph{Simulation algorithm}
When we consider the simulation algorithm described in
Figure~\ref{algo:simulation-crash}, we observe that the  simulators
communicate  only through  safe agreement objects.  It follows  that
the same algorithm works in , when the crash-tolerant
safe agreement objects are replaced by Byzantine-tolerant
safe agreement objects previously described.
Two  things remain to be done: define the specific sub-predicate
 of the predicate , and
do a specific proof of this algorithm
(i.e., a proof based on the specification of the  Byzantine-tolerant
safe agreement objects defined in Section~\ref{sec:spec-Byzantine-SA}).



\paragraph{Sub-predicate }
As far as  is concerned we have the following.
Let us consider the simulator  that invokes  ,
with respect to the simulation of a process .
In the simulation algorithm, the parameter  is the message 
that  proposes to a safe agreement object from which will be decided
the next message to be received  by the simulated process 
(lines~\ref{Simu-C-08}-\ref{Simu-C-09} of Figure~\ref{algo:simulation-crash}).
 checks, from 's local point of view,  that, if the message 
has been sent in the simulation, then it has not yet been consumed,
i.e., .



\paragraph{Proof of the simulation algorithm in }

\begin{lemma}
\label{lemma:at-most-one-crash-byz}
The simulation of at most  simulated processes can be blocked.
\end{lemma}

\begin{proofL}
The only places where a correct simulator  can block is 
during the invocation of
the safe agreement operation . Such invocations appear at
line~\ref{Simu-C-02}, and line~\ref{Simu-C-11}. 


Because the invocations by all the correct simulators  of 
on all the safe agreement objects terminate, except for at most 
safe agreement objects (Lemma \ref{lemma:at-most-one-blocked-byz}),
the simulation of at most  simulated processes can be blocked.
\renewcommand{\toto}{lemma:at-most-one-crash-byz}
\end{proofL}

\begin{lemma}
\label{lemma:same-seq-of-messages-byz}
The simulation of the reception of the -th
message received by a simulated process , returns the same message
at all correct simulators.
\end{lemma}

\begin{proofL}
The simulation of the message receptions for a simulated process ,
are executed at each correct simulator  at lines~\ref{Simu-C-08}-\ref{Simu-C-11},
and all the correct simulators use the same sequence of sequence numbers
(line~\ref{Simu-C-07}).
It then follows from the agreement property of the safe agreement object
, that no two correct simulators obtain different messages
when they invoke  , and the lemma follows.
\renewcommand{\toto}{lemma:same-seq-of-messages-byz}
\end{proofL}

\begin{lemma}
\label{lemma:one-dec-value-byz}
For every simulated processes , no two correct simulators return
different values.
\end{lemma}

\begin{proofL}
The only non-deterministic elements of the simulation are the input vectors
 at each simulator , and the reception of the simulated
messages.

The lines~\ref{Simu-C-01}-\ref{Simu-C-02} of the
simulation force  the correct simulators to agree on the same input value
for each simulated process , .
Similarly,  as shown by Lemma~\ref{lemma:same-seq-of-messages-byz},
for each simulated process , the lines~\ref{Simu-C-07}-\ref{Simu-C-11}
direct the simulators to  agree on the very same sequence of messages
received by . It follows from the fact that the function 
is deterministic, that   any two correct simulators  and ,
that execute  lines~\ref{Simu-C-15}-\ref{Simu-C-16} during the
same ``round number'' , are such that ,
from which the lemma follows.
\renewcommand{\toto}{lemma:one-dec-value-byz}
\end{proofL}

\begin{lemma}
\label{lemma:correct-simulation-byz}
The sequences of message receptions simulated by each simulator 
on behalf of each simulated process , define a correct execution of
the simulated algorithm.
\end{lemma}

\begin{proofL}
To prove the correctness of the simulation, we have  to show that
\begin{enumerate}
\vspace{-0.2cm}
\item
\label{item0-byz}
Every message that was received by a simulated process was sent
 by another simulated process,
\vspace{-0.2cm}
\item
\label{item1-byz}
Every message that was sent by a simulated process to another simulated
process (whose simulation is not blocked either), is received, and
\vspace{-0.2cm}
\item
\label{item2-byz}
The simulated messages respect a simulated physical order
(i.e., no message is ``received'' before being  ``sent'').
\end{enumerate}

Item~\ref{item0-byz} follows from Lemma \ref{lemma-correct-is-valid}
 and from the definition of .
Item~\ref{item1-byz} is satisfied because the messages sent by
the simulated process  to the simulated process  are received
(lines~\ref{Simu-C-09}-\ref{Simu-C-11}) in their sending order
(as defined at line~\ref{Simu-C-04}  and line~\ref{Simu-C-14}).
Hence, if  is not blocked (due to a faulty simulator)
it obtains the messages from  in their sending order.


For Item~\ref{item2-byz}, let us define a (simulated) physical order as follows.
For each simulated message , let us consider the first time at which the
reception of   was simulated (i.e., this occurs when
 --for the first time-- a simulator terminates  the invocation  of
  that returns ).
A message that is decided has been proposed by a simulator to a safe agreement
object before  being decided (validity property).The sending time  of a
simulated message is then the first time at which
 is  invoked by a simulator.
It follows that any simulated  message is sent before being received,
which concludes the lemma.
\renewcommand{\toto}{lemma:correct-simulation-byz}
\end{proofL}


\begin{lemma}
\label{lemma:nb-simulated-proc-byz}
Each correct simulator  computes the decision value of
at least  simulated processes.
\end{lemma}

\begin{proofL}
Due to Lemma~\ref{lemma:at-most-one-crash-byz}, and the fact that at
most  simulators may be byzantine, it follows that at most 
simulated processes may be prevented from progressing. As (a) by
assumption the simulated algorithm  is -resilient, and (b) due
to Lemma~\ref{lemma:correct-simulation-byz} the simulation produces a
correct simulation of , it follows that at least 
simulated processes decide a value.
\renewcommand{\toto}{lemma:nb-simulated-proc-byz}
\end{proofL}



\begin{theorem}
\label{theorem:main-simulation-byz}
Let  be an algorithm solving a decision task in .
The algorithm described in Figure~\ref{algo:simulation-crash},
in which Byzantine-tolerant safe agreement objects are used, is a
correct simulation of  in~.
\end{theorem}

\begin{proofT}
The theorem follows from Lemma~\ref{lemma:correct-simulation-byz} and
Lemma~\ref{lemma:nb-simulated-proc-byz}.
\renewcommand{\toto}{theorem:main-simulation-byz}
\end{proofT}

Additionally, the reader can easily check that the simulation of a message only requires 
a polynomial number of messages in the base system, and the increase in size of these messages,
when compared to the size of the simulated message, is
also polynomial.

\section{Implications of the Simulation} \label{sec:conclusion}
\paragraph{BG-simulation in Byzantine message-passing systems} 
A main result of this  paper is a signature-free
distributed algorithm that solves  
BG-simulation in Byzantine asynchronous message-passing systems.
In addition to being the first  algorithm  that solves
BG-simulation in such a severe failure context, the proposed simulation
algorithm has noteworthy applications as shown below. 


\paragraph{From Byzantine-failures to crash 
failures in message-passing systems}
The simulation presented here allows the execution of a 
-resilient crash-tolerant algorithm in an asynchronous
message-passing system where up to  processes may be Byzantine.
A  feature that is sometimes required from a Byzantine-tolerant algorithm
solving a task (not usually  considered in the crash failure case)
is that the value decided by any correct process should be based only
on  inputs of  correct processes. This prevents Byzantine processes
from ``polluting'' the computation with their inputs.
 A way to guarantee that an input has
been proposed by a correct process is to check that it has been
proposed by at least  different processes. Assuming that
in any execution at most  values are proposed,  this constraint
translates as ~\cite{HKR14,MTH14}. 


In the case of the simulation presented in
Section~\ref{sec:BG-byzantine-model}, this requirement can easily be
satisfied by adding a first step of computation before the start of
the simulation. Simulators first broadcast their input. They then echo
every value that they receive from more than  different
simulators, and consider these values (and only these values) as valid
inputs. An input considered valid by a correct simulator is then
eventually considered valid by all correct simulators, and the only
inputs allowed in the simulation are inputs of correct simulators.
Because we consider colorless tasks, the choice of output is done in the 
same way as in the original BG-simulation: a simulator can adopt the 
output of any simulated process that has decided a value.

The possible Byzantine behaviors are restrained by the underlying
Byzantine-tolerant safe agreement objects used in the simulation.
Surprisingly, this shows that, from the point of view of the
computability of colorless tasks and assuming  (this
requirement always implies  when at least two different values
can be proposed), Byzantine failures are equivalent to crash-failures.
This provides us with a new understanding of Byzantine failures and
shows that their impact can be restricted to the much simpler
crash-failure case.


\paragraph{From wait-free shared memory to message-passing}
The proposed simulation can be combined with previous works
to further extend the  scope of the result. 
Consider an algorithm  that solves a colorless task, where ,
in a wait-free read/write memory system of  processes, denoted 
.
Using the basic BG-simulation~\cite{BG93}, 
this algorithm can be transformed into an algorithm  
that works in the -resilient read/write memory system 
of  processes, in which at most  can crash. 
This model is denoted .
Using an implementation
of a read/write memory in a crash-prone message-passing system in which a 
majority of processes are correct~\cite{ABD95}, we obtain an algorithm  
  which work in 
(message-passing system 
system of  processes, in which at most  can crash; 
notice that ). 
Finally, using the simulation presented in this paper, we  obtain 
Byzantine-tolerant algorithm  which works in 
  (message-passing  system of  
processes, of which at most  can be Byzantine; notice that
).

These transformations show that, as far as the computability of
colorless tasks that admit up to  different input values is
concerned, an -process Byzantine-prone message-passing system, in
which up to  processes can be Byzantine, is equivalent to
a wait-free shared memory system of  processes, which at most
commit crash failures.  When considering colorless tasks with , a
figure relating these transformations is depicted in
Figure~\ref{figure-stacking}.  Differently from the 
full-information algorithm presented in~\cite{MTH14}, 
the simulation presented in the present paper
(along with~\cite{BG93} and~\cite{ABD95}) allows a {\it direct}
transformation of any wait-free shared-memory algorithm that solves a
colorless task into a message-passing Byzantine-tolerant algorithm.


\label{figure-stacking}
\begin{figure}[h]
\centering{
\hspace{-1.5cm}
\ifpdf
\scalebox{0.6}{\begin{picture}(0,0)\includegraphics{figure-modular.pdf}\end{picture}\setlength{\unitlength}{4144sp}\begingroup\makeatletter\ifx\SetFigFont\undefined \gdef\SetFigFont#1#2#3#4#5{\reset@font\fontsize{#1}{#2pt}\fontfamily{#3}\fontseries{#4}\fontshape{#5}\selectfont}\fi\endgroup \begin{picture}(6852,4336)(-824,-6830)
\put(  1,-2761){\makebox(0,0)[lb]{\smash{{\SetFigFont{20}{24.0}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0} in }}}}}
\put(1351,-4111){\makebox(0,0)[lb]{\smash{{\SetFigFont{20}{24.0}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0} in }}}}}
\put(-809,-3526){\makebox(0,0)[lb]{\smash{{\SetFigFont{20}{24.0}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}BG simulation \cite{BG93}}}}}}
\put(316,-4876){\makebox(0,0)[lb]{\smash{{\SetFigFont{20}{24.0}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}ABD  simulation \cite{ABD95}}}}}}
\put(3331,-6181){\makebox(0,0)[lb]{\smash{{\SetFigFont{20}{24.0}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}This paper}}}}}
\put(2656,-5461){\makebox(0,0)[lb]{\smash{{\SetFigFont{20}{24.0}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0} in }}}}}
\put(3916,-6721){\makebox(0,0)[lb]{\smash{{\SetFigFont{20}{24.0}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0} in }}}}}
\end{picture} }
\else
\scalebox{0.6}{\input{figure-modular.pstex_t}}
\fi
\caption{From crash in read/write to Byzantine in message-passing (with )}
\label{modular-construction}
}
\end{figure}







\section*{Acknowledgments}
This work has been partially supported by the Franco-German DFG-ANR Project 
40300781. This project (named DISCMAT) is devoted to mathematical methods in 
distributed computing.
The authors would like to thank Sergio Rajsbaum for discussions on the
BG simulation.





\begin{thebibliography}{99}
\footnotesize{
\setlength{\baselineskip}{1.03\baselineskip}

\bibitem{AADGMS93} 
Afek Y., Attiya H., Dolev D., Gafni E., Merritt M. and Shavit N., 
Atomic snapshots of shared memory. 
{\em Journal of the  ACM}, 40(4):873-890, 1993.


\bibitem{ABD95}
Attiya H., Bar-Noy A. and Dolev D.,
 Sharing memory robustly in  message passing systems.
{\it Journal of the ACM}, 42(1):121-132, 1995.


\bibitem{ABDPR90}
Attiya H., Bar-Noy A., Dolev D., Peleg D. and Reischuk R.,
Renaming in an asynchronous environment.
{\it Journal of the ACM}, 37(3):524-548, 1990.

\bibitem{AW04}
Attiya H. and Welch J.,
{\it Distributed computing, fundamentals, simulation and advanced topics
(Second edition)}.
Wiley Series on Parallel and Distributed Computing, 414 pages, 2004.

\bibitem{BN91}
Bazzi R. A., and Neiger G.,
Optimally simulating crash failures in a Byzantine environment.
{\it Proc.  5th International Workshop on Distributed Algorithms (WDAG'91)},
Springer LNCS 579, pp.~108-128, 1991. 


\bibitem{BG93}
Borowsky E. and Gafni E.,
Generalized FLP impossibility results for -resilient asynchronous
computations.
{\em Proc. 25th ACM  Symposium on Theory of Computing (STOC'93)},
ACM Press, pp. 91-100, 1993.

\bibitem{BGLR01}
 Borowsky E.,  Gafni E., Lynch N.  and  Rajsbaum S.,
The BG distributed simulation algorithm.
{\em Distributed  Computing}, 14:127-146, 2001.

\bibitem{B87}
Bracha G.,
Asynchronous Byzantine agreement protocols.
{\it Information \& Computation}, 75(2):130-143, 1987.


\bibitem{CR12}
Casta\~neda A., Rajsbaum S.,
New combinatorial topology bounds for renaming: the upper bound.
{\it Journal of the  ACM}, 59(1), article 3, 49 pages, 2012.


\bibitem{CRR11}
Casta\~neda A., Rajsbaum S., and Raynal M.,
The renaming problem in shared memory systems: an introduction.
{\it Computer Science Review}, 229-251, 2011.

\bibitem{C93}
Chaudhuri S.,
More {\em choices} allow more {\em faults:} set consensus
problems in totally asynchronous systems.
{\em Information and Computation,} 105:132-158, 1993.



\bibitem{C88}
Coan B.A.,
A compiler that increases the fault-tolerance of asynchronous protocols. 
{\it IEEE Transactions on Computers}, 37(12):1541—1553 (1988).


\bibitem{FLP85}
Fischer M.J., Lynch N.A. and Paterson M.S.,
Impossibility of distributed consensus with one faulty process.
{\em Journal of the ACM}, 32(2):374-382, 1985.


\bibitem{G09}
Gafni E.,
The extended BG simulation and the characterization of -resiliency.
{\em Proc. 41th ACM  Symposium on Theory of Computing (STOC'09)},
ACM Press,  pp.~85-92,  2009.

\bibitem{GMW87}
Goldreich O., Micali S. and Wigderson A.,
How to play any mental game or a completeness theorem for 
protocols with honest majority.
{\em Proc. 19th ACM  Symposium on Theory of Computing (STOC'87)},
ACM Press,  pp.~218-229,  1987.



\bibitem{HKR14}
Herlihy M.P.,  Kozlov D., and  Rajsbaum S.,
{\it Distributed computing  through combinatorial topology},
Morgan Kaufmann/Elsevier,  336 pages,  2014
(ISBN 9780124045781).

\bibitem{HR97}
Herlihy M. and Rajsbaum S.,
The decidability of distributed decision tasks (Extended Abstract).
{\it Proc.  29th ACM Symposium on Theory of Computing (STOC'97)},
 ACM Press, pp.~589-598, 1997


\bibitem{HRR13}
Herlihy M.,  Rajsbaum S., and Raynal M.,
 Power and limits of distributed computing shared memory models.
{\it  Theoretical  Computer  Science},  509:3-24, 2013.

\bibitem{HS99}
Herlihy M., Shavit N.,
The topological structure of asynchronous computability.
{\it Journal of the  ACM}, 46(6):858-923, 1999.

\bibitem{HDR07}
Ho Ch.,  Dolev D. and  van Renesse R., 
Making distributed applications robust.
{\it Proc. 11th Int'l Conference on Principles of Distributed Computing
(OPODIS'15)}, Springer LNCS 4878, pp.~232-246, (2007). 

\bibitem{IRR11}
Imbs D., Rajsbaum S., and Raynal M.,
 The universe of symmetry breaking tasks.
{\it Proc.  18th Int'l Colloquium on Structural Information and
Communication Complexity (SIROCCO'11)}, Springer, LNCS 6796, pp. 66-77, 2011.



\bibitem{IR09}
Imbs D. and Raynal M.,
Visiting Gafni's Reduction Land:
From the BG simulation to the extended BG simulation.
{\it Proc. 11th  Int'l Symposium on Stabilization, Safety, and Security
of Distributed Systems (SSS'09)}, Springer LNCS 5873, pp. 369-383, 2009.


\bibitem{IR11}
Imbs D. and Raynal M.,
The multiplicative power of consensus numbers.
{\it Proc.  29th ACM Symposium on Principles of Distributed Computing
(PODC'11)}, ACM Press, pp.~26-35, 2011.

\bibitem{IR11-a}
Imbs D. and Raynal M.,
A Liveness Condition for Concurrent Objects: -Wait-Freedom.
{\it Concurrency and Computation: Practice and Experience},
 23(17): 2154-2166, 2011.






\bibitem{L86}
Lamport L.,
On Interprocess communication, Part I: Basic formalism.
{\it Distributed Computing}, 1(2):77-85, 1986.


\bibitem{LSP82}
Lamport L., Shostack R., and Pease M., The Byzantine generals problem.
{\it ACM Transactions on Programming Languages and Systems},
4(3):382-401, 1982.


\bibitem{LA87}
Loui M.C., and Abu-Amara H.H., Memory requirements for agreement
among unreliable asynchronous processes.
{\it Par. and Distributed Computing: vol.~4 of Advances
in Comp. Research,} JAI Press, 4:163-183, 1987.



\bibitem{MTH14}
Mendes H., Tasson Ch., and Herlihy M.,
Distributed computability in Byzantine asynchronous systems.
{\it Proc.  46th  Symposium on the Theory of Computing (STOC'14)},
ACM Press, pp.~704-713, 2014.

\bibitem{NT90}
Neiger G., and Toueg S.,
Automatically increasing the fault-tolerance of distributed algorithms.
{\it Journal of  Algorithms}, 11(3): 374-419, 1990.




\bibitem{SZ00}
Saks M. and Zaharoglou F.,
Wait-free -set agreement is impossible: the topology of public knowledge.
{\em SIAM Journal on Computing}, 29(5):1449-1483, 2000.

\bibitem{ST87}
Srikanth T.K. and  Toueg S., 
Simulating authenticated broadcasts to derive simple fault-tolerant algorithms.
{\it  Distributed Computing}, 2(2):80-94  (1987).

}


\end{thebibliography}

\end{document}
