\pdfoutput=1
\newif\ifFull
\Fulltrue
\ifFull
\documentclass[11pt]{article}
\else
\documentclass{llncs}
\fi

\usepackage{graphicx}
\usepackage{amsmath}
\ifFull
\usepackage{amsthm}
\usepackage{fullpage}
\usepackage{hyperref}
\fi
\usepackage{amssymb}
\usepackage{times}
\usepackage{url}
\ifFull
\setlength{\pdfpagewidth}{8.5in}
\setlength{\pdfpageheight}{11in}
\fi

\ifFull\else
\usepackage{cramped}
\renewcommand{\subsection}[1]{\paragraph{\textbf{#1}.}}
\fi

\ifFull
\newtheorem{theorem}{Theorem}[section]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{corollary}[theorem]{Corollary}
\fi

\ifFull
\let\oldendproof\endproof
\def\endproof{\qed\oldendproof}
\fi

\newcommand{\abs}[1]{{\lvert#1 \rvert}}

\title{Extended -Index Parameterized Data Structures for Computing Dynamic Subgraph Statistics}

\ifFull
\author{
David Eppstein \\
Dept. of Computer Science \\
\url{http://www.ics.uci.edu/~eppstein/}
\and
Michael T. Goodrich \\
Dept. of Computer Science \\
Univ. of California, Irvine \\
\url{http://www.ics.uci.edu/~goodrich/}
\and 
Darren Strash \\
Dept. of Computer Science \\
Univ. of California, Irvine \\
\url{http://www.ics.uci.edu/~dstrash/}
\and
Lowell Trott \\
Dept. of Computer Science \\
\url{http://www.ics.uci.edu/~ltrott/}
}
\date{}
\else
\author{David Eppstein \and Michael T. Goodrich \and Darren Strash \and Lowell Trott}
\institute{Computer Science Department, University of California, Irvine, USA.}
\fi

\begin{document}

\maketitle

\pagestyle{plain}


\begin{abstract} We present techniques for maintaining 
subgraph frequencies in a dynamic graph,
using data structures that are parameterized in terms of , the 
\emph{-index} of the graph.
Our methods extend previous results of Eppstein and Spiro for
maintaining statistics for undirected subgraphs of size three to
directed subgraphs and to subgraphs of size four.
For the directed case, we provide a data 
structure to maintain counts for all 3-vertex induced subgraphs 
in  amortized time per update.
For the undirected case, we maintain the counts of size-four subgraphs
in  amortized time per update.
These extensions enable a number of new applications in
Bioinformatics and Social Networking research.
\end{abstract}

\section{Introduction}
\ifFull
Deriving inspiration from work done on
fixed-parameter tractable algorithms for NP-hard problems (e.g.,
see~\cite{cllor-fpadf-08,dffht-fparp-05,df-fptcb-95,gghnw-cbfp-06,nr-oefpa-03}),
\else
Deriving inspiration from work done on
fixed-parameter tractable algorithms for NP-hard problems (e.g.,
see~\cite{dffht-fparp-05,df-fptcb-95,nr-oefpa-03}),
\fi
the area of
\emph{parameterized algorithm design} involves defining numerical
parameters for input instances, other than just the input size,
and designing data structures and algorithms whose performance
can be characterized in terms of those parameters.
The goal, of course, is to find useful parameters and
then design data structures and algorithms that are efficient for
typical values of those parameters 
(e.g., see~\cite{eg-snprn-08,es-hgadss-09}).
In this paper, we are interested in extending previous applications
of this approach in the context of dynamic subgraph statistics---where 
one maintains the counts of all (induced and non-induced) subgraphs 
of certain types---from undirected size-three
subgraphs~\cite{es-hgadss-09} to applications involving directed size-three
subgraphs and undirected subgraphs of size four.

Upon cursory examination this contribution may seem incremental, but these 
extensions allow for the possibility of significant computational improvement in several important applications.
For instance, in bioinformatics, statistics involving the frequencies of 
certain small subgraphs, called \emph{graphlets}, have been applied
to protein-protein interaction networks~\cite{tp-ubnfv-08,pcj-eegfd-06} 
and cellular networks~\cite{p-bncug-07}.
In these applications, the frequency statistics for the
subgraphs of interest
have direct bearing on biological network structure and function.
In particular, in these graphlets applications,
the undirected subgraphs of interest include 
one size-two subgraph (the 1-path), two size-three subgraphs
(the 3-cycle and 2-path), and six size-four subgraphs
(the 3-star, 3-path, triangle-plus-edge, 4-cycle,  minus an
edge, and ), which we respectively illustrate later in 
Fig.~\ref{fig-quadrangles}
as 
, 
, 
, 
, 
, 
and .

In addition,
maintaining subgraph counts in a dynamic graph is of crucial
importance to statisticians and social-networking researchers using the 
\emph{exponential random graph model} 
\ifFull
(ERGM)~\cite{Fra-SN-91,RobMor-SN-07,Sni-JoSS-02,WasPat-Psy-96}
\else
(ERGM)~\cite{Fra-SN-91,Sni-JoSS-02,WasPat-Psy-96}
\fi
to generate random graphs.
ERGMs can be tailored to
generate random graphs that possess
specific properties, which makes ERGMs an ideal tool for Social
Networking research~\cite{WasPat-Psy-96,Sni-JoSS-02}.
This tailoring is accomplished by
a Markov Chain Monte Carlo (MCMC) method~\cite{Sni-JoSS-02},
which generates random 
graphs via a sequence of incremental changes.
These incremental changes are accepted or rejected based on
the values of subgraph statistics, which must
be computed exactly for each incremental change in order to
facilitate acceptance or rejection.
Thus, there is a need for dynamic graph statistics in ERGM
applications.

Typical graph attributes of interest in ERGM applications include
the frequencies of undirected stars and triangles, 
which are used in the triad model~\cite{FraStr-JASA-86}
to study friends-of-friends relationships, as well as
other more-complex subgraphs~\cite{SniPatRob-SM-06},
including undirected 4-cycles and two-triangles ( minus an edge), 
and directed transitive triangles, which we illustrate as graph 
in Fig.~\ref{fig-triangles}.
Therefore, there is
a salient need for algorithms to maintain subgraph statistics
in a dynamic graph involving directed subgraphs of size three and
undirected subgraphs of size four.

Interestingly, extending the previous approach, of 
Eppstein and Spiro~\cite{es-hgadss-09},
for maintaining undirected size-three subgraphs to these new contexts involves
overcoming some algorithmic challenges.
The previous approach uses a parameterized algorithm
design framework for counting three-vertex induced 
subgraphs in a dynamic undirected graph. Their data structure
has running time  amortized time per graph
update (assuming constant-time hash table lookups), 
where  is the largest integer such that there exists
 vertices of degree at least , which is a parameter 
known as the \emph{-index} of the graph.
This parameter was introduced by Hirsch~\cite{Hir-PNAS-05} as a combined
way of measuring productivity and
impact in the academic achievements of researchers. 
\ifFull
In spite of its
drawbacks for this purpose~\cite{AdlEwiTay-JCQAR-08}, it is a useful
parameter for dynamic graph algorithms, as demonstrated 
by Eppstein and Spiro.
\fi
As we will show,
extending the approach of Eppstein and Spiro to directed
subgraphs of size three and undirected subgraphs of size four involves
more than doubling the 
complexity of the algebraic expressions and supporting data structures needed.
Ensuring the directed size-three procedure maintains the complexity bounds of 
previous work required extensive understanding of dynamic graph composition.  Developing 
the approach for size-four subgraphs that would allow only the addition of a single 
factor of  required innovative work with the structure of stored graph elements.


\subsection{Other Related Work}
Although subgraph isomorphism is known to be NP-complete,
it is solvable in polynomial time for small subgraphs.
For example, all triangles and four-cycles can be found 
in an -vertex graph with  edges 
in  time~\cite{ItaRod-SJC-78,ChiNis-SICOMP-85}. 
All cycles up to length seven can be counted (but not listed) in 
 time~\cite{AloYusZwi-Algo-97},
where  is the exponent for the asymptotically 
fastest known matrix multiplication algorithm~\cite{CopWin-JSC-90}.
\ifFull
In addition,
fast matrix multiplication has also been used for other problems of finding
and counting small cliques in graphs and
hypergraphs~\cite{EisGra-TCS-04,KloKraMue-IPL-00,NesPol-CMUC-85,VasWil-STOC-09,Yus-IPL-06}.
\fi
Also, in planar graphs, 
the number of copies of any fixed subgraph may be found in linear
time~\cite{Epp-JGAA-99,Epp-Algo-00}.
These previous approaches run too slowly for the iterative nature of
ERGM Markov Chain Monte Carlo simulations, however.

\subsection{Our Results}
In this paper,
we present an extension of the -index parameterized data structure
design from statistics for undirected subgraphs of size three to
directed subgraphs of size three and undirected subgraphs of size
four.
We show that in a dynamic directed graph one can maintain the
counts of all directed three-vertex subgraphs in  
amortized time per update, and in a dynamic undirected graph one
can maintain the four-vertex subgraph counts in  
amortized time per update, assuming constant-time hash-table lookups
(or worst-case amortized times that are a logarithmic factor larger).
These results therefore provide techniques for application domains,
in Bioinformatics and Social Networking,
that can take advantage of these extended types of statistics.
In addition, our data structures are based a number of novel insights
into the combinatorial structure
of these different types of subgraphs.

\section{Preliminaries}
As mentioned above, we define the \emph{h-index}
of a graph to be the largest  such that the graph contains  vertices
of degree at least . We define the -partition of a graph to be
the sets , where  is the set of vertices that 
form the -index.

\subsection{The H-Index}


\begin{figure}[hb!]
\vspace{-24pt}
\begin{center}
\includegraphics[scale=0.95]{h-index.pdf}
\end{center}
\vspace{-24pt}
\caption{Scatter plot of h-index and network size from Eppstein and Spiro~\cite{es-hgadssarx-09}}
\label{fig-h-index}
\vspace{-18pt}
\end{figure}

\begin{figure}[hb!]
\vspace{-24pt}
\begin{center}
\includegraphics[scale=0.95]{h-loglog.pdf}
\end{center}
\vspace{-24pt}
\caption{Scatter plot of h-index and network size, on log-log scale from Eppstein and Spiro~\cite{es-hgadssarx-09}}
\label{fig-h-loglog}
\vspace{-18pt}
\end{figure}

It is easy to see that the -index of a graph with  edges 
is ; hence it is  for sparse graphs with a
linear number of edges, where  is the number of vertices.
Moreover,
this bound is optimal in the worst-case, e.g., for a graph consisting
of  stars of size  each.
As can be seen in Fig.~\ref{fig-h-index} Eppstein and Spiro~\cite{es-hgadss-09} 
show experimentally that real-world social networks often have
-indices much lower than the indicated worst-case bound.
These indices, perhaps more easily viewed in log-log scale in Fig~\ref{fig-h-loglog}, were calculated on
networks with a range of ten to just over ten-thousand nodes. The -index of these networks were consistently below forty with only a few exceptions, 
none greater than slightly above one-hundred.
Moreover, many large real-world networks possess
\emph{power laws}, so that their number of vertices 
with degree  is proportional to , for 
some constant .
Such networks are said to be 
\ifFull
\emph{scale-free}~\cite{AlbJeoBar-Nat-99,LilEdlAma-Nat-01,New-SIAM-03,Pri-Sci-65}, and it is often the case that
\else
\emph{scale-free}~\cite{AlbJeoBar-Nat-99,New-SIAM-03,Pri-Sci-65}, and it is often the case that
\fi
the parameter  is between  and  in real-world networks.
Note that the -index of a scale-free graph is
 , since it must satisfy the equation
 .
 Thus, for instances of scale-free graphs with  between 
 and , an algorithmic performance of  is much better than
  the worst-case  bound for graphs without power-law degree 
  distributions. For example, an  time bound for a scale-free
  graph with
   would give a bound of  while for 
  it would give an  bound. 
  Likewise, an algorithmic performance of  is much better
  than a worst-case performance of  for these instances, for
   would give a bound of  while for 
  it would give an  bound. 
Thus, by taking a parametric algorithm design approach, we can,
in these cases, achieve running times
better than worst-case bounds characterized strictly
in terms of the input size, .



\subsection{Maintaining Undirected Size-3 Subgraph Statistics}
As mentioned above,
Eppstein and Spiro~\cite{es-hgadss-09} 
develop an algorithm for maintaining the -index and 
the -partition of a graph among edge insertions, edge deletions,
and insertions/deletions of isolated vertices in constant time plus a constant
number of dictionary operations per update. Observing that the -index 
doubles after  updates, Eppstein and Spiro further show a 
partitioning scheme requiring amortized  partition changes per 
graph update. This partitions the graph into sets of \emph{low}- and
\emph{high}-degree vertices, which we summarize in Theorem~\ref{thm-partition}. 

\begin{theorem}[\cite{es-hgadss-09}]
\label{thm-partition}
For a dynamic graph , we can maintain a partition  
such that for ,  and ;
and for ,  in constant time per
update, with amortized  changes to the partition per update.
\end{theorem}

Using this partitioning scheme, one can develop a triangle-counting 
algorithm as follows. For each pair of vertices  and , store 
the number of length-two paths  that have an intermediate 
low-degree vertex. Whenever an edge  is added to the graph, 
increase the number of triangles by , and update the number of
length-two paths containing  in  time. One can
then iterate over all the high-degree vertices, adding to a 
triangle count when a 
high-degree vertex is adjacent to both  and . Since there are 
 high-degree vertices, this method takes  time. These same steps 
can be done in reverse for an edge removal.

Whenever the partition changes, one must update  values
to reflect vertices moving from high to low, or low to high, which 
requires  time. Since there are amortized  partition 
changes per graph update, this updating takes  amortized time 
per update. The randomization comes from the choice of dictionary 
scheme used. The data structure as described requires  space, 
which is sufficient to store the length-two paths with an intermediate 
low-degree vertex. 

Finally, to maintain counts of all induced undirected 
subgraphs on three vertices,
it suffices to solve a simple four-by-four 
system of linear equations relating induced
subgraphs and non-induced subgraphs. This allows one to keep counts 
of the induced subgraphs of every type with a constant amount of 
work in addition to counting triangles.
Extending this to directed subgraphs of size three and undirected
subgraphs of size four requires that we come up with a much larger
system of equations, which characterize the combinatorial
relationships between such types of subgraphs.

\section{Directed Three-Vertex Induced Subgraphs}

Using the partitioning scheme detailed in Theorem~\ref{thm-partition}, we
can maintain counts for the all possible induced subgraphs on three vertices (see 
Fig.~\ref{fig-triangles}) in  amortized time per update for a dynamic
directed graph. We begin by maintaining counts for induced subgraphs that are a
directed triangle, we then show how to maintain counts of all induced
subgraphs on three vertices.

\begin{figure}[hb!]
\vspace{-24pt}
\begin{center}
\includegraphics[scale=0.45]{triangles.pdf}
\end{center}
\vspace{-24pt}
\caption{The 16 possible directed graphs on three vertices, excluding 
isomorphisms, organized in left-to-right order by number of edges in the graph. We
label these graphs  to .}
\label{fig-triangles}
\vspace{-18pt}
\end{figure}

\subsection{Counting Directed Triangles}

Let a \emph{directed triangle} be a three-vertex directed graph 
with at least one directed edge between each pair of vertices. There
are seven possible directed triangles, labeled  to  in 
Fig.~\ref{fig-ditriangles}. We let  denote the count of induced directed 
triangles of type  in the dynamic graph. We now show how to maintain  
each count  by extending Eppstein and Spiro's technique.
\begin{figure}[hb!]
\vspace{-24pt}
\begin{center}
\includegraphics[scale=0.45]{ditriangles.pdf}
\end{center}
\vspace{-24pt}
\caption{The 7 directed triangles, labeled  to .}
\label{fig-ditriangles}
\vspace{-12pt}
\end{figure}

\ifFull
When an edge  is added or removed from the graph, we would like 
to quickly compute the number of directed triangles containing ,
in order to update the current counts. The third vertex of this
directed triangle can either be low- or high-degree. We handle these
cases separately.\fi

For a pair of vertices  and , we define a \emph{joint} to 
be a third vertex  that is adjacent to both  and . Vertices , 
 and  are said to form an \emph{elbow}. Fixing a vertex to be a joint, 
there are nine unique elbows which we label  to 
(see Fig.~\ref{fig-elbows}). We store a dictionary mapping pairs of 
vertices  and  to the number of elbows of type  formed by  and  and a 
low-degree joint, denoted . 

\begin{figure}[t!]
\vspace{-24pt}
\begin{center}
\includegraphics[scale=0.45]{elbows.pdf}
\end{center}
\vspace{-24pt}
\caption{The nine elbows with a fixed joint.}
\label{fig-elbows}
\vspace{-12pt}
\end{figure}

We now discuss how the directed triangle counts change when adding an edge
. We do not discuss edge removal since its effects are symmetric 
to edge insertion.

For directed triangles with a third low-degree vertex, we update our counts 
using the dictionary of elbow counts. If edge  is 
not in the graph, directed triangle counts increase as follows.

\vspace*{-8pt}
{\small

}

\vspace*{-16pt}
If edge  is present in the graph, adding  destroys
some directed triangles containing . Therefore, the directed 
triangle counts change as follows.

\vspace*{-8pt}
{\small

}
\vspace*{-16pt}

To complete the directed triangle counting step, we iterate over the 
 high-degree vertices to account for directed triangles formed with  
and  and a high-degree vertex, taking  time.

If either  or  is a low-degree vertex, we must also update the elbow 
counts involving the added edge . We consider, without loss of generality,
the updates when  is considered the low-degree elbow joint. For ease of notation,
we categorize the different relationships between adjacent vertices as follows:

\vspace*{-6pt}
{\small
 
}

\vspace*{-6pt}
We summarize the elbow count updates in Table~\ref{tab-elbowupdate}.

\begin{table}[!b]
\vspace*{-12pt}
\caption{Summary of updating elbow counts when  is considered a low-degree joint.}
\label{tab-elbowupdate}
\begin{center}
\begin{tabular}{l|c|c}
&  &  \\ \hline
 &
 & 

 \\ \hline

 &
 & 

 \\ \hline

 &
 & 

 \\
\end{tabular}
\end{center}
\end{table}


Finally, when there is a partition change, we must update the elbow counts.
If node  moves across the partition, then we consider all pairs of neighbors of 
 and update their elbow counts appropriately. Since there are  pairs
of neighbors, and a constant number of elbows, this step takes  time. Since
 amortized partition changes occur with each graph update, this step requires
 amortized time.



\subsection{Subgraph Multiplicity}

Let the count for induced subgraph  be called .  Furthermore, for
a vertex , let , 
 and .
We can represent the relationship between the number of induced and non-induced 
subgraphs using the matrix equation

\vspace*{-10pt}
{\small
\setcounter{MaxMatrixCols}{16}

}

On the right hand side, each  is the count of the number of
non-induced  subgraphs in the dynamic graph. Each  (excluding
directed triangle counts) is maintained in constant time per update by 
storing a constant amount of structural information at each node, 
such as indegree, outdegree, and reciprocity of neighbors. On the left 
hand side, position  in the matrix counts how many non-induced 
subgraphs of type  appear in . We are counting non-induced 
subgraphs in two ways: (1) by counting the number of appearances within 
induced subgraphs and (2) by using the structure of the graph. Since 
the multiplicand is an upper (unit) triangular matrix, this matrix 
equation is easily solved, yielding the induced subgraph counts. Thus,
we can maintain the counts for three-vertex induced subgraphs in a directed
dynamic graph in  amortized time per update, and  space, 
plus the additional overhead for the choice of dictionary.


\section{Four-Vertex Subgraphs}

\begin{figure}[!b]
\vspace{-20pt}
\begin{center}
\includegraphics[scale=0.45]{quadstore.pdf}
\end{center}
\vspace{-24pt}
\caption{We store counts of these eight non-induced subgraphs to maintain counts of
four-vertex non-induced subgraphs  to . The counts are indexed by the
labels of the white vertices, and the blue vertices indicate a vertex 
has low-degree.}
\label{fig-quadstore}
\end{figure}

We begin by describing the data structure for our algorithm.  It will be necessary to maintain the counts of various subgraph structures.  The data structure in whole consists of the following information:



\begin{itemize}
\item Counts of the non-induced subgraph structures,  through .

\item A set E of the edges in the graph, indexed such that given a pair of endpoints there is a constant-time lookup to determine if they are linked by an edge.

\item A partition of the vertices of the graph into two sets  and . 

\item A dictionary  mapping each vertex  to a pair , .  This pair contains the counts for the structures  and  that involve vertex  ( see  Fig.~\ref{fig-quadstore}). That is, the count of the number of two-edge paths that begin at  and pass through two vertices in  and the number of these paths that connect back to  forming a triangle.  We only maintain nonzero values for these numbers in ; if there is no entry in  for the vertex  then there exist no such path from .

\item A dictionary  mapping each pair of vertices ,  to a tuple , , , , .  This tuple contains the counts for the structures  through  that involve vertices  and  ( see  Fig.~\ref{fig-quadstore}).  That is, the number of two-edge paths from u to v via a vertex of , the number of three-edge paths from u to v via two vertices of , the number of structures in which both  and  connect to the same vertex in  which connects to another vertex in , the number of structures similar to the last in which the final vertex in  shares an edge connection with  or , and the number of structures where between  and  there are two two-edge paths through vertices of  in which the two vertices in  share an edge connection.  Again, we only maintain nonzero values.

\item A dictionary  mapping each triple of vertices , ,   to a number .  This value is the count for the structure  that involves vertices , , and  ( see  Fig.~\ref{fig-quadstore}). This is, the number of vertices in  that share edge connections with all three vertices.  As before, we only maintain nonzero values for these numbers.


\end{itemize}

\begin{figure}
\vspace{-24pt}
\begin{center}
\includegraphics[scale=0.45]{quadrangles.pdf}
\end{center}
\vspace{-24pt}
\caption{The 11 possible graphs on four vertices, excluding 
isomorphisms, organized in left-to-right order by number of edges in the graph.}
\label{fig-quadrangles}
\end{figure}




Upon insertion of an edge between vertices  and  we will need to update the dictionaries , , and . If both  and  are in , no update is necessary.


If  and  are both in  then we will need to update the counts  through .  First find which vertices in  connect to  or to .  Increment  for these vertices.  If both vertices in  connect to the same vertex in  then increment  for this vertex.  Increment  for  and the vertices that connect to , and for  and the vertices that connect to .  Then increment  based on pairs of neighbors of  and  and neighbors of neighbors in .  If either  or  connect to two vertices in  increment  for the vertices in .  Considering  to be the vertex with edge connections to two vertices in , for each vertex in  that connects to  increment .  For two vertices in  such that  and  each connect to both, increment  for the vertices in .  

If  and  are such that one is in  and the other in  we will proceed as follows.  Consider  to be the vertex in . First, determine the number of vertices in  connected to  and increase  for  by that amount.  Upon discovering these adjacent vertices in  test their connection to .  For each of those connected, increment  for .  It is necessary to determine which vertices in  share an edge with .  After these connections have been determined increment the appropriate dictionary entries.  Form pairs with  and the connected vertices in  and update the  counts.  Form triples with  and two other connected vertices in  and update the counts in . The  update comes from determining the triangles formed by the additional edge and using the degree of the vertices in , and the count of the connected triangles, which can be calculated by searching for attached vertex pairs in  and using . In order to update the count for  begin with location of vertex pairs as with the elbow update.  For each of the  vertex pairs increase the stored value by the number of vertices in  that share an edge with  and with both of the vertices in , which can be retrieved from .


Examining the time complexity we can see that in order to generate the dictionary updates the most complex operation involves examination of two sets of connected vertices consecutively that are  in size each.  This results in  operations to determine which updates are necessary.  Since it is possible to see from the structure of the stored items that no single edge insertion can result in more than  new structures, this will be the upper bound on dictionary updates, and make  the time complexity bound.

These maintained counts will have to be modified when the vertex partition is updated. If a vertex is moved from  to  then it is necessary to count the connected structures it now forms.  This can be done by examining all edges formed by this vertex, and following the procedure for edge additions.  
When a vertex is moved into  it is necessary to count the structures it had been forming as a vertex in  and decrement the appropriate counts.  This can be done similarly to the method for generating new structures.  In analysis of the partition updates we see that since we are working with a single vertex with  degree the complexity has an additional  factor to use the edge-based dictionary update scheme. This results in  time per update.  Since this partition update is done an average of  times per operation, the amortized time for updates, per change to the input graph, is .


\subsection{Subgraph Structure Counts}



The following section covers the update of the subgraph structure counts after an edge between vertices  and  has been inserted.  Let these vertices have degree count  and  respectively. Recall that  refers to the count of the non-induced subgraph of the structure  (see Fig.~\ref{fig-quadrangles}).

The  count will be increased by , where  is the number of edges in the graph.  Since this structure consists of two edges that do not share vertices, the increase of the count comes from a selection of a second edge to be paired with the inserted edge.  The second term in the update value reflects the number of edges that connected to the inserted edge.

The  count will be updated as follows.  Each of the two vertices can be the end of a claw structure.  From each end two edges in addition to the newly inserted edge must be selected.  Thus the value to update the count is . 

The  count is updated by calculating the number of additional triangles the edge addition would add, which can be done with the 
Eppstein-Spiro~\cite{es-hgadss-09}
method, and multiplying that by a factor of  to reflect the selection of the additional vertex, where  is the number of vertices in the graph.


The update for  is done in parts based on which position in the structure the edge is forming.  The increase to the count for the new structures in which the additional edge is the center in the three-edge path is .  

This value will be increased by the count when the new edge is not the center of the structure.  The process to calculate the count increase will assume that  connects to the rest of this structure.  The same process can be done without loss of generality with the assumption  connects to the rest of the structure.  These values will then both be added to form the final part of the count update.  If  is an element of  then we will sum the results from the following subcases.  First we consider the case where the vertex adjacent to  is in .  The number of these paths of length two originating at  can be counted by summing the degree of these vertices minus 1. We must also subtract one for each of the adjacent vertices in  that are adjacent to .  If  is not an element of , then it has h or less neighbors.  Sum over all neighbors the following value.  If the vertex does not have an edge connecting it to  then the degree of the vertex; if it does the degree minus one.


The  count is updated as follows.  An inserted edge can form the structure in three positions, so our final update will be the sum of those three counts.  For the first case let the inserted edge be the additional edge connected to the triangle.  For this case, we must do all of the following for both vertices and sum the result.  If the vertex is in  retrieve .  This gives us the connected triangles through vertices in .  Then determine which vertices in  connect to the vertex.  Form the triangle counts with all vertices in . Form those with one additional vertex in  using .  If the vertex is in , then determine its neighbors connections and form a connected triangle count.

In the second case the edge is in the triangle and shares a vertex with the additional edge.  The count can be determined in two parts.  First the triangles.  If either  or  are in  then the triangle count can be calculated.  If both are in  then a lookup to  will determine the number of triangles. The number of additional edges can then be calculated using the degrees of the vertices of the inserted edge, with care to not count the edges used to form the triangle.  The product of the triangle and additional edge will form the increase for this case.

The final case occurs when the inserted edge is part of the triangle, but does not share a vertex with the additional edge. If either  or  are in  then the triangle count can be calculated, and the degree of the vertices used to form these triangles can be used to calculate the count increase.  If both   or  are in  then there are three remaining subcases.  The count if all vertices are in  can be determined.  If the vertex on the additional edge that is not in the triangle is in , then using the three known vertices in  and a lookup from  can yield the counts.  If both remaining vertices are in  this is the structure stored in , and counts can be retrieved.  Sum the counts for these subcases to calculate the total increase for this case.


The count for  is increased upon edge update by a sum of the following.  The count of the length three path through vertices in  can be looked up in .  There are two possible types of length three paths remaining.  In the first, both vertices are in .  These paths can be counted be examining the connections between , , and all vertices in .  The second contains one vertex in  and one in . These paths can be counted by establishing which vertices in  connect to either  or , and then using the count in  of the length two paths from the vertices in  to  or  respectively.



The  count can be increased by an edge insert in two positions.  The first is between the opposite ends of the cycle.  If either  or  is in  then the edge connections can be determined and the count calculated.  If both  and  are in  then the count of the two two-edge paths that form the cycle must be determined.  These paths will either pass through a vertex in  or a vertex in .  The former can be counted by examining the vertices in , and the latter by a lookup to .

The second possible position for an edge insert is on the outer path of a cycle that already has an edge through it.  If either  or  are in  calculate the count as follows, summing with an additional calculation considering the vertices reversed. If the vertex connected to the triangle is in  then the count can be determined by examining neighbors and their edge connections.  If the vertex not connected to the triangle is in  then examine the neighbors.  For those neighbors that are in  the count can be determined by examining additional edge connections of neighbors.  For the neighbors in  a lookup  is required to completely determine the counts.  If both  and  are in  then the count is calculated as follows. If all vertices of the structure are in , determine the count by examining edge connections.  If both remaining vertices are in  the count can be determined by lookup to .  Otherwise, one of the two remaining vertices is in .  This will leave a structure that can be completed and provide a count by using a lookup to , or 


The  count update is separated by the membership of  and .  If either vertex is contained in , consider , then it is possible to determine which vertices connect to  and which of these share edges with  and each other.  This count can be calculated and the total count can be updated.  If both  and  are in  then we will sum the values determined in the following three subcases.  First, all four vertices are in .  This count can be determined by examining the edge connections of the vertices in .  If three vertices in  form the correct structure, the count of cliques formed with one vertex in  can be determined by a look up to .  These counts should be summed for all vertices in  that form the correct structure with  and .  The final count, with both of the remaining vertices in  can be determined by an  lookup.

The time complexity for the updates of the stored subgraphs is .  Calculations and lookups can be performed in constant time, and subcase calculations can be done independently.  The most complicated subcase count computations involve examination of two sets of connected vertices consecutively that are  in size each.  This results in  operations.  The space complexity for our data structure is  for the maintained subgraph counts,  for E,  for the partition to maintain , and  for the dictionaries, because each edge belongs to at most  subgraph structures.

\subsection{Subgraph Multiplicity}
The data structure in the previous section only maintains counts of certain subgraph structures.  With the addition of , , and the count of length two paths, where  is the number of edges and  the number of vertices, it is possible to use these counts to determine the counts of all subgraphs on four vertices.  The additional values , , and the count of length two paths can be maintained in constant time per update.  Values for  and  are modified incrementally.  Adding an edge  will increase the count of length two paths by , the degrees of  and  respectively. Removing the edge will decrease the value by .

\setcounter{MaxMatrixCols}{11}
{\small

}

Similar to the matrix for size three subgraphs, we can use the counts of the non-induced subgraphs on the right and the composition of the induced subgraphs to determine the counts of any desired subgraph.

\section{Conclusion}

The work we present here can maintain counts for all 3-vertex directed subgraphs 
 amortized time per update.  This can be done in 
 space.  For the undirected case, we maintain counts of size-four subgraphs
in  amortized time per update and  space.  Although we do not discuss the specifics in this paper, the methodology presented 
can be used to count directed size-four subgraphs with similar complexity. 
These developments open significant possibility for improvement in calculating \emph{graphlet} 
frequencies within Bioinformatics and in ERGM applications for 
social network analysis. 

\bibliographystyle{abbrv}
\begin{thebibliography}{10}

\bibitem{AdlEwiTay-JCQAR-08}
R.~Adler, J.~Ewing, and P.~Taylor.
\newblock {\em {Citation Statistics: A report from the International
  Mathematical Union (IMU) in cooperation with the International Council of
  Industrial and Applied Mathematics (ICIAM) and the Institute of Mathematical
  Statistics}}.
\newblock Joint Committee on Quantitative Assessment of Research, 2008.

\bibitem{AlbJeoBar-Nat-99}
R.~Albert, H.~Jeong, and A.-L. Barabasi.
\newblock {The diameter of the world wide web}.
\newblock {\em Nature}, 401:130{--}131, 1999.

\bibitem{AloYusZwi-Algo-97}
N.~Alon, R.~Yuster, and U.~Zwick.
\newblock {Finding and counting given length cycles}.
\newblock {\em Algorithmica}, 17(3):209{--}223, 1997.

\bibitem{cllor-fpadf-08}
J.~Chen, Y.~Liu, S.~Lu, B.~O'Sullivan, and I.~Razgon.
\newblock A fixed-parameter algorithm for the directed feedback vertex set
  problem.
\newblock {\em J. ACM}, 55(5):1--19, 2008.

\bibitem{ChiNis-SICOMP-85}
N.~Chiba and T.~Nishizeki.
\newblock {Arboricity and subgraph listing algorithms}.
\newblock {\em SIAM J. Comput.}, 14(1):210{--}223, 1985.

\bibitem{CopWin-JSC-90}
D.~Coppersmith and S.~Winograd.
\newblock {Matrix multiplication via arithmetic progressions}.
\newblock {\em Journal of Symbolic Computation}, 9(3):251{--}280, 1990.

\bibitem{dffht-fparp-05}
E.~D. Demaine, F.~V. Fomin, M.~Hajiaghayi, and D.~M. Thilikos.
\newblock Fixed-parameter algorithms for (k, r)-center in planar graphs and map
  graphs.
\newblock {\em ACM Trans. Algorithms}, 1(1):33--47, 2005.

\bibitem{df-fptcb-95}
R.~G. Downey and M.~R. Fellows.
\newblock Fixed-parameter tractability and completeness i: Basic results.
\newblock {\em SIAM J. Comput.}, 24(4):873--921, 1995.

\bibitem{EisGra-TCS-04}
F.~Eisenbrand and F.~Grandoni.
\newblock {On the complexity of fixed parameter clique and dominating set}.
\newblock {\em Theoretical Computer Science}, 326(1{--}3):57{--}67, 2004.

\bibitem{Epp-JGAA-99}
D.~Eppstein.
\newblock {Subgraph isomorphism in planar graphs and related problems}.
\newblock {\em Journal of Graph Algorithms {\&} Applications}, 3(3):1{--}27,
  1999.

\bibitem{Epp-Algo-00}
D.~Eppstein.
\newblock {Diameter and treewidth in minor-closed graph families}.
\newblock {\em Algorithmica}, 27:275{--}291, 2000.

\bibitem{eg-snprn-08}
D.~Eppstein and M.~T. Goodrich.
\newblock Studying (non-planar) road networks through an algorithmic lens.
\newblock In {\em GIS '08: Proceedings of the 16th ACM SIGSPATIAL international
  conference on Advances in geographic information systems}, pages 1--10, New
  York, NY, USA, 2008. ACM.

\bibitem{es-hgadss-09}
D.~Eppstein and E.~S. Spiro.
\newblock The -index of a graph and its application to dynamic subgraph
  statistics.
\newblock In F.~Dehne, M.~Gavrilova, J.-R. Sack, and C.~D. T{\'o}th, editors,
  {\em WADS 2009}, volume 5664 of {\em LNCS}, pages 278--289. Springer-Verlag,
  2009.

\bibitem{es-hgadssarx-09}
D.~Eppstein and E.~S. Spiro.
\newblock The -index of a graph and its application to dynamic subgraph
  statistics.
\newblock {\em arXiv:0904.3741}, 2009.

\bibitem{Fra-SN-91}
O.~Frank.
\newblock {Statistical analysis of change in networks}.
\newblock {\em Statistica Neerlandica}, 45:283{--}293, 199.

\bibitem{FraStr-JASA-86}
O.~Frank and D.~Strauss.
\newblock {Markov graphs}.
\newblock {\em J. Amer. Statistical Assoc.}, 81:832{--}842, 1986.

\bibitem{gghnw-cbfp-06}
J.~Guo, J.~Gramm, F.~H\"{u}ffner, R.~Niedermeier, and S.~Wernicke.
\newblock Compression-based fixed-parameter algorithms for feedback vertex set
  and edge bipartization.
\newblock {\em J. Comput. Syst. Sci.}, 72(8):1386--1396, 2006.

\bibitem{Hir-PNAS-05}
J.~E. Hirsch.
\newblock {An index to quantify an individual's scientific research output}.
\newblock {\em Proc. National Academy of Sciences}, 102(46):16569{--}16572,
  2005.

\bibitem{ItaRod-SJC-78}
A.~Itai and M.~Rodeh.
\newblock {Finding a minimum circuit in a graph}.
\newblock {\em SIAM J. Comput.}, 7(4):413{--}423, 1978.

\bibitem{KloKraMue-IPL-00}
T.~Kloks, D.~Kratsch, and H.~M{\"u}ller.
\newblock {Finding and counting small induced subgraphs efficiently}.
\newblock {\em Information Processing Letters}, 74(3{--}4):115{--}121, 2000.

\bibitem{LilEdlAma-Nat-01}
F.~Liljeros, C.~R. Edling, L.~A.~N. Amaral, H.~E. Stanley, and Y.~{\AA}berg.
\newblock {The web of human sexual contacts}.
\newblock {\em Nature}, 411:907{--}908, 2001.

\bibitem{tp-ubnfv-08}
T.~Milenkovi{\'c} and N.~Pr\v{z}ulj.
\newblock Uncovering biological network function via graphlet degree
  signatures.
\newblock {\em Cancer Informatics}, 6:257--273, 2008.

\bibitem{NesPol-CMUC-85}
J.~Ne{\v{s}}et{\v{r}}il and S.~Poljak.
\newblock {On the complexity of the subgraph problem}.
\newblock {\em Commentationes Mathematicae Universitatis Carolinae},
  26(2):415{--}419, 1985.

\bibitem{New-SIAM-03}
M.~E.~J. Newman.
\newblock {The structure and function of complex networks}.
\newblock {\em SIAM Review}, 45:167{--}256, 2003.

\bibitem{nr-oefpa-03}
R.~Niedermeier and P.~Rossmanith.
\newblock On efficient fixed-parameter algorithms for weighted vertex cover.
\newblock {\em J. Algorithms}, 47(2):63--77, 2003.

\bibitem{Pri-Sci-65}
D.~J. d.~S. Price.
\newblock {Networks of scientific papers}.
\newblock {\em Science}, 149(3683):510{--}515, 1965.

\bibitem{p-bncug-07}
N.~Pr\v{z}ulj.
\newblock Biological network comparison using graphlet degree distribution.
\newblock {\em Bioinformatics}, 23(2):e177--e183, 2007.

\bibitem{pcj-eegfd-06}
N.~Pr\v{z}ulj, D.~G. Corneil, and I.~Jurisica.
\newblock Efficient estimation of graphlet frequency distributions in
  protein--protein interaction networks.
\newblock {\em Bioinformatics}, 22(8):974--980, 2006.

\bibitem{RobMor-SN-07}
G.~Robins and M.~Morris.
\newblock {Advances in exponential random graph () models}.
\newblock {\em Social Networks}, 29(2):169{--}172, 2007.
\newblock Special issue of journal with four additional articles.

\bibitem{Sni-JoSS-02}
T.~A.~B. Snijders.
\newblock {Markov chain Monte Carlo estimation of exponential random graph
  models}.
\newblock {\em Journal of Social Structure}, 3(2):1{--}40, 2002.

\bibitem{SniPatRob-SM-06}
T.~A.~B. Snijders, P.~E. Pattison, G.~Robins, and M.~S. Handcock.
\newblock {New specifications for exponential random graph models}.
\newblock {\em Sociological Methodology}, 36(1):99{--}153, 2006.

\bibitem{VasWil-STOC-09}
V.~Vassilevska and R.~Williams.
\newblock {Finding, minimizing and counting weighted subgraphs}.
\newblock In {\em Proc. 41st ACM Symposium on Theory of Computing}, 2009.

\bibitem{WasPat-Psy-96}
S.~Wasserman and P.~E. Pattison.
\newblock {Logit models and logistic regression for social networks, I: an
  introduction to Markov graphs and }.
\newblock {\em Psychometrika}, 61:401{--}425, 1996.

\bibitem{Yus-IPL-06}
R.~Yuster.
\newblock {Finding and counting cliques and independent sets in -uniform
  hypergraphs}.
\newblock {\em Information Processing Letters}, 99(4):130{--}134, 2006.

\end{thebibliography}

\end{document}
