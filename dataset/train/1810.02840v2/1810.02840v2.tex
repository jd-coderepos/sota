\documentclass[letterpaper]{article}

\usepackage{times}
\usepackage{helvet}
\usepackage{courier}
\usepackage{url}
\usepackage{graphicx}
\frenchspacing
\setlength{\pdfpagewidth}{8.5in}
\setlength{\pdfpageheight}{11in}

\usepackage[utf8]{inputenc} \usepackage[T1]{fontenc}    \usepackage{booktabs}       \usepackage{amsfonts}       \usepackage{nicefrac}       \usepackage{microtype}      \usepackage{tikz}
\usetikzlibrary{shapes.misc, positioning}
\usepackage{thmtools,thm-restate}
\usepackage{parskip}
\usepackage{authblk}

\usepackage{floatrow}
\newfloatcommand{capbtabbox}{table}[][\FBwidth]

\usepackage{macros}
\usepackage{basic}



\newcommand{\AvgGainOverGold}[0]{20.2}
\newcommand{\AvgGainOverMV}[0]{6.8}
\newcommand{\AvgGainOverDP}[0]{4.1}
\newcommand{\RelPercentAvgGainOverMV}[0]{30.4}

\newcommand{\AvgJointOverSingle}[0]{2.0}

\newcommand{\AvgEMOverLM}[0]{3.4}

\newcommand{\AvgUnipolarBoost}[0]{2.8}

\newcommand{\AvgNumLFsPerTask}[0]{13}
\newcommand{\AvgLinesCodePerLF}[0]{4} 
\title{Training Complex Models with Multi-Task Weak Supervision}

\renewcommand\Authsep{\hspace{2em}}
\renewcommand\Authand{\hspace{2em}}
\renewcommand\Authands{\hspace{2em}}

\renewcommand\Authfont{\normalfont}
\renewcommand\Affilfont{\small}

\author[]{Alexander~Ratner}
\author[]{Braden~Hancock}
\author[]{Jared~Dunnmon}

\author[]{Frederic~Sala}
\author[]{Shreyash~Pandey}
\author[]{Christopher~R{\'e}}

\affil[]{Department of Computer Science, Stanford University}
\affil[ ]{\footnotesize{\texttt{\{ajratner, bradenjh, jdunnmon, fredsala, shreyash, chrismre\}@stanford.edu}}}

\begin{document}

\maketitle

\newcommand{\figpathA}{fig/LF_example2b_wide.png}
\newcommand{\figwidthA}{\textwidth}
\newcommand{\figpathB}{fig/ontonotes_scaleup_plot_log.pdf}
\newcommand{\figwidthB}{0.5\linewidth}

\newcommand{\versionswitch}[2]{#2}

\begin{abstract}
  

As machine learning models continue to increase in complexity, collecting large hand-labeled training sets has become one of the biggest roadblocks in practice.
Instead, weaker forms of supervision that provide noisier but cheaper labels are often used.
However, these weak supervision sources have diverse and unknown accuracies, may output correlated labels, and may label different tasks or apply at different levels of granularity.
We propose a framework for integrating and modeling such weak supervision sources by viewing them as labeling different related sub-tasks of a problem, which we refer to as the \textit{multi-task weak supervision} setting.
We show that by solving a matrix completion-style problem, we can recover the accuracies of these \textit{multi-task} sources given their dependency structure, but without any labeled data, leading to higher-quality supervision for training an end model.
Theoretically, we show that the generalization error of models trained with this approach improves with the number of \textit{unlabeled} data points, and characterize the scaling with respect to the task and dependency structures.
On three fine-grained classification problems, we show that our approach leads to average gains of  points in accuracy over a traditional supervised approach,  points over a majority vote baseline, and  points over a previously proposed weak supervision method that models tasks separately.
 \end{abstract}

\section{Introduction}
\label{sec:intro}
One of the greatest roadblocks to using modern machine learning models is collecting hand-labeled training data at the massive scale they require.
In real-world settings where domain expertise is needed and modeling goals change frequently, hand-labeling training sets is prohibitively slow, expensive, and static.
For these reasons, practitioners are increasingly turning to weak supervision techniques wherein noisier, often programmatically-generated labels are used instead.
Common \textit{weak supervision sources} include external knowledge bases~\cite{mintz2009distant,zhang:cacm17,craven:ismb99,takamatsu:acl12}, heuristic patterns~\cite{gupta2014improved,ratner2018snorkel}, feature annotations~\cite{mann2010generalized,zaidan:emnlp08}, and noisy crowd labels~\cite{karger2011iterative,dawid1979maximum}. The use of these sources has led to state-of-the-art results in a range of domains~\cite{zhang:cacm17,xiao2015learning}.
A theme of weak supervision is that using the full diversity of available sources is critical to training high-quality models~\cite{ratner2018snorkel,zhang:cacm17}.

The key technical difficulty of weak supervision is determining how to combine the labels of multiple sources that have different, unknown accuracies, may be correlated, and may label at different levels of granularity.
In our experience with users in academia and industry, the complexity of real world weak supervision sources makes this integration phase the key time sink and stumbling block.
For example, if we are training a model to classify entities in text, we may have one available source of high-quality but coarse-grained labels (e.g. ``Person'' vs. ``Organization'') and one source that provides lower-quality but finer-grained labels (e.g. ``Doctor'' vs. ``Lawyer''); moreover, these sources might be correlated due to some shared component or data source~\cite{bach2017learning,varma2017inferring}.
Handling such diversity requires addressing a core technical challenge: estimating the unknown accuracies of multi-granular and potentially correlated supervision sources without any labeled data.

To overcome this challenge, we propose \systemx, a framework for modeling and integrating weak supervision sources with different unknown accuracies, correlations, and granularities.
In \systemx, we view each source as labeling one of several related sub-tasks of a problem---we refer to this as the \textit{multi-task weak supervision} setting.
We then show that given the dependency structure of the sources, we can use their observed agreement and disagreement rates to recover their unknown accuracies.
Moreover, we exploit the relationship structure between tasks to observe additional cross-task agreements and disagreements, effectively providing extra signal from which to learn.
In contrast to previous approaches based on sampling from the posterior of a graphical model directly~\cite{ratner2016data,bach2017learning}, we develop a simple and scalable matrix completion-style algorithm, which we are able to analyze by applying strong matrix concentration bounds~\cite{tropp2015introduction}.
We use this algorithm to learn and model the accuracies of diverse weak supervision sources, and then combine their labels to produce training data that can be used to supervise arbitrary models, including increasingly popular multi-task learning models~\cite{Caruana93multitasklearning,DBLP:journals/corr/Ruder17a}.

Compared to previous methods which only handled the single-task setting~\cite{ratner2016data,ratner2018snorkel}, and generally considered conditionally-independent sources~\cite{anandkumar2014tensor,dawid1979maximum}, we demonstrate that our multi-task aware approach leads to average gains of  points in accuracy in our experiments, and has at least three additional benefits.
First, many dependency structures between weak supervision sources may lead to non-identifiable models of their accuracies, where a unique solution cannot be recovered.
We provide a compiler-like check to establish identifiability---i.e. the existence of a unique set of source accuracies---for arbitrary dependency structures, without resorting to the standard assumption of non-adversarial sources~\cite{dawid1979maximum}, alerting users to this potential stumbling block that we have observed in practice.
Next, we provide sample complexity bounds that characterize the benefit of adding additional unlabeled data and the scaling with respect to the user-specified task and dependency structure.
While previous approaches required thousands of sources to give non-vacuous bounds, we capture regimes with small numbers of sources, better reflecting the real-world uses of weak supervision we have observed.
Finally, we are able to solve our proposed problem directly with SGD, leading to over  faster runtimes compared to prior Gibbs-sampling based approaches~\cite{ratner2016data,platanios2017estimating}, and enabling simple implementation using libraries like PyTorch.

We validate our framework on three fine-grained classification tasks in named entity recognition, relation extraction, and medical document classification, for which we have diverse weak supervision sources at multiple levels of granularity.
We show that by modeling them as labeling hierarchically-related sub-tasks and utilizing unlabeled data, we can get an average improvement of  points in accuracy over a traditional supervised approach,  points over a basic majority voting weak supervision baseline, and  points over data programming~\cite{ratner2016data}, an existing weak supervision approach in the literature that is not multi-task-aware.
We also extend our framework to handle unipolar sources that only label one class, a critical aspect of weak supervision in practice that leads to an average  point contribution to our gains over majority vote.
From a practical standpoint, we argue that our framework represents an efficient way for practitioners to supervise modern machine learning models, including new multi-task variants, for complex tasks by opportunistically using the diverse weak supervision sources available to them.
To further validate this, we have released an open-source implementation of our framework.\footnote{\url{github.com/HazyResearch/metal}}

\begin{figure*}
	\centering
	\includegraphics[width=5in]{fig/MeTaL_pipeline_full.png}
	\caption{
		A schematic of the \systemx pipeline.
		To generate training data for an \textit{end model}, such as a multi-task model as in our experiments, the user inputs a \textit{task graph}  defining the relationships between \textit{task labels} ; a set of \textit{unlabeled} data points ; a set of \textit{multi-task weak supervision sources}  which each output a vector  of task labels for ; and the dependency structure between these sources, .
		We train a \textit{label model} to learn the accuracies of the sources, outputting a vector of probabilistic training labels  for training the end model.
	}
	\label{fig:ws_pipeline}
\end{figure*} 
\section{Related Work}
\label{sec:related_work}


Our work builds on and extends various settings studied in machine learning.

\textit{Weak Supervision:}
We draw motivation from recent work which models and integrates weak supervision using generative models~\cite{ratner2016data,ratner2018snorkel,bach2017learning} and other methods~\cite{guan2017said,khetan2017learning}.
These approaches, however, do not handle multi-granularity or multi-task weak supervision, require expensive sampling-based techniques that may lead to non-identifiable solutions, and leave room for sharper theoretical characterization of weak supervision scaling properties. 
More generally, our work is motivated by a wide range of specific weak supervision techniques, which include traditional distant supervision approaches~\cite{mintz2009distant,craven:ismb99,zhang:cacm17,hoffmann:acl11,takamatsu:acl12}, co-training methods~\cite{blum1998combining}, pattern-based supervision~\cite{gupta2014improved,zhang:cacm17}, and feature-annotation techniques~\cite{mann2010generalized,zaidan:emnlp08,liang:icml09}.

\textit{Crowdsourcing:}
Our approach also has connections to the crowdsourcing literature~\cite{karger2011iterative,dawid1979maximum}, and in particular to spectral and method of moments-based approaches~\cite{zhang2014spectral,dalvi:www13,Ghosh:2011:MMC:1993574.1993599,anandkumar2014tensor}.
In contrast, the goal of our work is to support and explore settings not covered by crowdsourcing work, such as sources with correlated outputs, the proposed multi-task supervision setting, and regimes wherein a small number of labelers (weak supervision sources) each label a large number of items (data points).
Moreover, we theoretically characterize the generalization performance of an end model trained with the weakly labeled data.

\textit{Multi-Task Learning:}
Our proposed approach is motivated by recent progress on multi-task learning models~\cite{Caruana93multitasklearning,DBLP:journals/corr/Ruder17a,sogaard2016deep}, in particular their need for multiple large hand-labeled training datasets.
We note that the focus of our paper is on generating supervision for these models, not on the particular multi-task learning model being trained, which we seek to control for by fixing a simple architecture in our experiments.

Our work is also related to recent techniques for estimating classifier accuracies without labeled data in the presence of structural constraints~\cite{platanios2017estimating}.
We use matrix structure estimation~\cite{loh2012structure} and concentration bounds~\cite{tropp2015introduction} for our core results. 
\section{Programming Machine Learning with Weak Supervision}
\label{sec:setup}


\begin{figure}
	\centering
	\includegraphics[width=\figwidthA]{\figpathA}
	\caption{
		An example fine-grained entity classification problem, where weak supervision sources label three sub-tasks of different granularities: (i) \texttt{Person} vs. \texttt{Organization}, (ii) \texttt{Doctor} vs. \texttt{Lawyer} (or \textit{\texttt{N/A}}), (iii) \texttt{Hospital} vs. \texttt{Office} (or \textit{\texttt{N/A}}).
		The example weak supervision sources use a pattern heuristic and dictionary lookup respectively.
	}
	\label{fig:lf_example}
\end{figure}

As modern machine learning models become both more complex and more performant on a range of tasks, developers increasingly interact with them by programmatically generating noisier or \textit{weak} supervision.
These approaches of effectively \textit{programming} machine learning models have recently been formalized by the following pipeline~\cite{ratner2016data,ratner2018snorkel}:
First, users provide one or more \textit{weak supervision sources}, which are applied to unlabeled data to generate a set of noisy labels.
These labels may overlap and conflict; we model and combine them via a \textit{label model} in order to produce a final set of training labels.
These labels are then used to train some discriminative model, which we refer to as the \textit{end model}.
This programmatic weak supervision approach can utilize sources ranging from heuristic rules to other models, and in this way can also be viewed as a pragmatic and flexible form of multi-source \textit{transfer learning}.

In our experiences with users from science and industry, we have found it critical to utilize all available sources of weak supervision for complex modeling problems, including ones which label at multiple levels of \textit{granularity}.
However, this diverse, multi-granular weak supervision does not easily fit into existing paradigms.
We propose a formulation where each weak supervision source labels some sub-task of a problem, which we refer to as the \textit{multi-task weak supervision} setting.
We consider an example:
\begin{example}
	\label{ex:example-1}
	A developer wants to train a fine-grained Named Entity Recognition (NER) model to classify mentions of entities in the news (Figure~\ref{fig:lf_example}).
	She has a multitude of available weak supervision sources which she believes have relevant signal for her problem---for example, pattern matchers, dictionaries, and pre-trained generic NER taggers.
	However, it is unclear how to properly use and combine them: some of them label phrases coarsely as \texttt{PERSON} versus \texttt{ORGANIZATION}, while others classify specific fine-grained types of people or organizations, with a range of unknown accuracies.
	In our framework, she can represent them as labeling tasks of different granularities---e.g. , , , where the label  applies, for example, when the type-of-person task is applied to an organization.
\end{example}

In our proposed multi-task supervision setting, the user specifies a set of structurally-related \textit{tasks}, and then provides a set of \textit{weak supervision sources} which are user-defined functions that either label each data point or abstain for each task, and may have some user-specified dependency structure.
These sources can be arbitrary black-box functions, and can thus subsume a range of weak supervision approaches relevant to both text and other data modalities, including use of pattern-based heuristics, distant supervision~\cite{mintz2009distant}, crowd labels, other weak or biased classifiers, declarative rules over unsupervised feature extractors~\cite{varma2017inferring}, and more.
Our goal is to estimate the unknown accuracies of these sources, combine their outputs, and use the resulting labels to train an end model. 
\section{Modeling Multi-Task Weak Supervision}
\label{sec:label_model}


The core technical challenge of the \textit{multi-task weak supervision} setting is recovering the unknown \textit{accuracies} of weak supervision sources given their dependency structure and a schema of the tasks they label, but without any ground-truth labeled data.
We define a new algorithm for recovering the accuracies in this setting using a matrix completion-style optimization objective.
We establish conditions under which the resulting estimator returns a unique solution.
We then analyze the sample complexity of our estimator, characterizing its scaling with respect to the amount of \textit{unlabeled data}, as well as the task schema and dependency structure, and show how the estimation error affects the generalization performance of the end model we aim to train.
Finally, we highlight how our approach handles abstentions and \textit{unipolar} sources, two critical scenarios in the weak supervision setting.

\subsection{A Multi-Task Weak Supervision Estimator}

\paragraph*{Problem Setup}
Let  be a data point and  be a vector of categorical \textit{task labels}, , corresponding to  tasks, where  is drawn i.i.d. from a distribution \versionswitch{.\footnote{The variables we introduce throughout this section are summarized in a glossary in the Appendix, which can be accessed at \url{https://arxiv.org/abs/1810.02840}.}}{ (for a glossary of all variables used, see Appendix~\ref{appendix:glossary}).}

The user provides a specification of how these tasks relate to each other; we denote this schema as the \textit{task structure} .
The task structure expresses logical relationships between tasks, defining a \textit{feasible set} of label vectors , such that .
For example, Figure~\ref{fig:lf_example} illustrates a hierarchical task structure over three tasks of different granularities pertaining to a fine-grained entity classification problem.
Here, the tasks are related by logical subsumption relationships: for example, if , this implies that , and that , since the task label  concerns types of organizations, which is inapplicable to persons.
Thus, in this task structure,  is in  while  is not.
While task structures are often simple to define, as in the previous example, or are explicitly defined by existing resources---such as ontologies or graphs---we note that if no task structure is provided, our approach becomes equivalent to modeling the  tasks separately, a baseline we consider in the experiments.

In our setting, rather than observing the true label , we have access to  \textit{multi-task weak supervision} sources  which emit label vectors  that contain labels for some subset of the  tasks.
Let  denote a null or abstaining label, and let the \textit{coverage set}  be the fixed set of tasks for which the th source emits non-zero labels, such that .
For convenience, we let  so that .
For example, a source from our previous example might have a coverage set , emitting coarse-grained labels such as .
Note that sources often label multiple tasks implicitly due to the constraints of the task structure; for example, a source that labels types of people () also implicitly labels people vs. organizations (), and types of organizations (as ).
Thus sources tailored to different tasks still have agreements and disagreements; we use this additional \textit{cross-task} signal in our approach.

\versionswitch{
	\begin{figure}
		\begin{subfigure}{.5\linewidth}
			\centering
			\begin{tikzpicture}[every node/.style={inner sep=0,outer sep=0}]
			
\draw (0,1.25) node[draw,circle,fill=white,minimum size=0.6cm](y) {};
			
\draw (-1.35,0) node[draw,fill=lightgray,circle,minimum size=0.6cm](l1x) {};
			\draw (-0.45,0) node[draw,fill=lightgray,circle,minimum size=0.6cm](l2x) {};
			\draw (0.45,0) node[draw,fill=lightgray,circle,minimum size=0.6cm](l3x) {};
			\draw (1.35,0) node[draw,fill=lightgray,circle,minimum size=0.6cm](l4x) {};
	
\draw (y) -- (l1x);
			\draw (y) -- (l2x);
			\draw (l1x) -- (l2x);
			\draw (y) -- (l3x);
			\draw (y) -- (l4x);
			
			\end{tikzpicture}
			\label{fig:g-source}
		\end{subfigure}\begin{subfigure}{.5\linewidth}
			\centering
			\begin{tikzpicture}[every node/.style={inner sep=0,outer sep=0}]
			
\draw (0,1.25) node [
				draw,
				rounded rectangle,
				fill=white,
				minimum height=0.75cm,
				minimum width=1.75cm
			] (jtn1) {};
			\draw (-1,0) node [
				draw,
				rounded rectangle,
				fill=white,
				minimum height=0.75cm,
				minimum width=1.25cm
			] (jtn2) {};
			\draw (1,0) node [
				draw,
				rounded rectangle,
				fill=white,
				minimum height=0.75cm,
				minimum width=1.25cm
			] (jtn3) {};
	
\draw (jtn1) -- (jtn2);
			\draw (jtn1) -- (jtn3);
	
\draw (1,0.75) node [] (ss12) {};
			\draw (-1,0.75) node [] (ss13) {};
			
			\end{tikzpicture}
			\label{fig:g-source-jt}
		\end{subfigure}\caption{
			An example of a weak supervision source dependency graph  (left) and its junction tree representation (right), where  is a vector-valued random variable with a feasible set of values, .
			Here, the output of sources 1 and 2 are modeled as dependent conditioned on .
			This results in a junction tree with singleton separator sets, .
			Here, the observable cliques are .
		}
		\label{fig:g-source-example}
	\end{figure}
}{
\begin{figure}
	\begin{subfigure}{.5\textwidth}
		\centering
		\begin{tikzpicture}[every node/.style={inner sep=0,outer sep=0}]
		
\draw (0,1.5) node[draw,circle,fill=white,minimum size=0.7cm](y) {};
		
\draw (-1.5,0) node[draw,fill=lightgray,circle,minimum size=0.7cm](l1x) {};
		\draw (-0.5,0) node[draw,fill=lightgray,circle,minimum size=0.7cm](l2x) {};
		\draw (0.5,0) node[draw,fill=lightgray,circle,minimum size=0.7cm](l3x) {};
		\draw (1.5,0) node[draw,fill=lightgray,circle,minimum size=0.7cm](l4x) {};

\draw (y) -- (l1x);
		\draw (y) -- (l2x);
		\draw (l1x) -- (l2x);
		\draw (y) -- (l3x);
		\draw (y) -- (l4x);
		
		\end{tikzpicture}
		\label{fig:g-source}
	\end{subfigure}\begin{subfigure}{.5\textwidth}
		\centering
		\begin{tikzpicture}[every node/.style={inner sep=0,outer sep=0}]
		
\draw (0,1.5) node [
			draw,
			rounded rectangle,
			fill=white,
			minimum height=0.75cm,
			minimum width=1.75cm
		] (jtn1) {};
		\draw (-1.5,0) node [
			draw,
			rounded rectangle,
			fill=white,
			minimum height=0.75cm,
			minimum width=1.25cm
		] (jtn2) {};
		\draw (1.5,0) node [
			draw,
			rounded rectangle,
			fill=white,
			minimum height=0.75cm,
			minimum width=1.25cm
		] (jtn3) {};

\draw (jtn1) -- (jtn2);
		\draw (jtn1) -- (jtn3);

\draw (1,0.85) node [] (ss12) {};
		\draw (-1,0.85) node [] (ss13) {};
		
		\end{tikzpicture}
		\label{fig:g-source-jt}
	\end{subfigure}\caption{
		An example of a weak supervision source dependency graph  (left) and its junction tree representation (right), where  is a vector-valued random variable with a feasible set of values, .
		Here, the output of sources 1 and 2 are modeled as dependent conditioned on .
		This results in a junction tree with singleton separator sets, .
		Here, the observable cliques are .
	}
	\label{fig:g-source-example}
\end{figure}
}

The user also provides the conditional dependency structure of the sources as a graph , where  (Figure~\ref{fig:g-source-example}).
Specifically, if  is not an edge in , this means that  is independent of  conditioned on  and the other source labels.
Note that if  is unknown, it can be estimated using statistical techniques such as~\cite{bach2017learning}.
Importantly, we do not know anything about the strengths of the correlations in , or the sources' accuracies.

Our overall goal is to apply the set of weak supervision sources  to an unlabeled dataset  consisting of  data points, then use the resulting weakly-labeled training set to supervise an \textit{end model}  (Figure~\ref{fig:ws_pipeline}).
This weakly-labeled training set will contain overlapping and conflicting labels, from sources with unknown accuracies and correlations.
To handle this, we will learn a \textit{label model} , parameterized by a vector of source correlations and accuracies , which for each data point  takes as input the noisy labels  and outputs a single probabilistic label vector .
Succinctly, given a user-provided tuple , our key technical challenge is recovering the parameters  without access to ground truth labels .

\paragraph*{Modeling Multi-Task Sources}
To learn a label model over multi-task sources, we introduce sufficient statistics over the random variables in .
Let  be the set of cliques in , and define an indicator random variable for the event of a clique  taking on a set of values :

where .
We define  as the vector of indicator random variables for all combinations of all but one of the labels emitted by each variable in clique ---thereby defining a minimal set of statistics---and define  accordingly for any set of cliques .
Then  is the vector of sufficient statistics for the label model we want to learn.

We work with two simplifying conditions in this section.
First, we consider the setting where  is \textit{triangulated} and has a junction tree representation with singleton separator sets.
If this is not the case, edges can always be added to  to make this setting hold; otherwise, we describe how our approach can directly handle non-singleton separator sets in \versionswitch{the Appendix}{Appendix~\ref{appendix:non-singleton-sep-sets}}.

Second, we use a simplified \textit{class-conditional} model of the noisy labeling process, where we learn one accuracy parameter for each label value  that each source  emits.
This is equivalent to assuming that a source may have a different accuracy on each different class, but that if it emits a certain label incorrectly, it does so uniformly over the different true labels .
This is a more expressive model than the commonly considered one, where each source is modeled by a single accuracy parameter, e.g. in~\cite{dawid1979maximum,ratner2016data}, and in particular allows us to capture the \textit{unipolar} setting considered later on.
\versionswitch{}{For further details, see Appendix~\ref{appendix:rank-one-reduction}.}

\paragraph*{Our Approach}
The chief technical difficulty in our problem is that we do not observe .
We overcome this by analyzing the covariance matrix of an observable subset of the cliques in , leading to a matrix completion-style approach for recovering .
We leverage two pieces of information: (i) the observability of \textit{part of} , and (ii) a result from \citep{loh2012structure} which states that the inverse covariance matrix  is structured according to , i.e., if there is no edge between  and  in , then the corresponding entries are 0.

We start by considering two disjoint subsets of : the set of observable cliques, ---i.e., those cliques not containing ---and the separator set cliques of the junction tree, . In the setting we consider in this section,  (see Figure~\ref{fig:g-source-example}).
We can then write the covariance matrix of the indicator variables for , , in block form, similar to~\cite{chandrasekaran2010latent}, as:

and similarly define its inverse:

Here,  is the observable block of , where .
Next,  is the unobserved block which is a function of , the label model parameters that we wish to recover.
Finally,  is a function of the class balance .

We make two observations about .
First, while the full form of  is the covariance of the  indicator variables for each individual value of  but one, given our simplified class-conditional label model, we in fact only need a single indicator variable for  (see Appendix\versionswitch{}{ \ref{appendix:rank-one-reduction}}); thus,  is a scalar.
Second,  is a function of the class balance , which we assume is either known, or has been estimated according to the unsupervised approach we detail in \versionswitch{the Appendix}{Appendix~\ref{appendix:recovering-class-balance}}.
Thus, given  and  , our goal is to recover the vector  from which we can recover .
	
Applying the block matrix inversion lemma, we have:

where .
Let ; we can then express (\ref{eqn:block-inv-cov-main}) as:

The right hand side of (\ref{eqn:matrix-completion-form-main}) consists of an empirically observable term, , and a rank-one term, , which we can solve for to directly recover .
For the left hand side, we apply an extension of Corollary 1 from \citep{loh2012structure} (see Appendix\versionswitch{}{ \ref{appendix:model-estimation}}) to conclude that  has graph-structured sparsity, i.e., it has zeros determined by the structure of dependencies between the sources in .
This suggests an algorithmic approach of estimating  as a matrix completion problem in order to recover an estimate of  (Algorithm~\ref{alg:method}).
In more detail: let  be the set of indices  where , determined by , yielding a system of equations,

which is now a matrix completion problem.
Define  as the Frobenius norm of  with entries not in  set to zero; then we can rewrite (\ref{eqn:constraints}) as .
We solve this equation to estimate , and thereby recover , from which we can directly recover the label model parameters  algebraically.

\paragraph*{Checking for Identifiability}
A first question is: which dependency structures  lead to unique solutions for ?
This question presents a stumbling block for users, who might attempt to use non-identifiable sets of correlated weak supervision sources.

We provide a simple, testable condition for identifiability.
Let  be the inverse graph of ; note that  is the edge set of  expanded to include all indicator random variables .
Then, let  be a matrix with dimensions  such that each row in  corresponds to a pair  with 's in positions  and  and 0's elsewhere.

Taking the log of the squared entries of (\ref{eqn:constraints}), we get a system of linear equations ,
where  and .
Assuming we can solve this system (which we can always ensure by adding sources; see Appendix), we can uniquely recover the , meaning our model is identifiable \textit{up to sign}.

Given estimates of the , we can see from (\ref{eqn:constraints}) that the sign of a single  determines the sign of all other  reachable from  in .
Thus to ensure a unique solution, we only need to pick a sign for each connected component in  .
In the case where the sources are assumed to be independent, e.g.,~\cite{Dalvi:2013:ACB:2488388.2488414,zhang2014spectral,dawid1979maximum}, it
suffices to make the assumption that the sources are {\em on average} non-adversarial; i.e., select the sign of the  that leads to higher average accuracies of the sources.
Even a single source that is conditionally independent from all the other sources will cause  to be fully connected, meaning we can use this symmetry breaking assumption in the majority of cases even with correlated sources.
Otherwise, a sufficient condition is the standard one of assuming non-adversarial sources, i.e. that all sources have greater than random accuracy.
\versionswitch{}{For further details, see Appendix~\ref{appendix:identifiability}.}


\paragraph*{Source Accuracy Estimation Algorithm}

Now that we know when a set of sources with correlation structure 
is identifiable, yielding a unique , we can estimate the accuracies  using Algorithm~\ref{alg:method}.
We also use the function ExpandTied, which is a simple algebraic expansion of tied parameters according to the simplified class-conditional model used in this section; see Appendix\versionswitch{}{ \ref{appendix:rank-one-reduction}} for details.
In Figure~\ref{fig:synthetic_fig}, we
plot the performance of our algorithm on synthetic data, showing its
scaling with the number of unlabeled data points , the density of pairwise dependencies in , and the runtime performance as compared to a prior Gibbs sampling-based approach. Next, we theoretically analyze
the scaling of the error .

\begin{algorithm}[tb]
	\caption{Source Accuracy Estimation for Multi-Task Weak Supervision}
   	\label{alg:method}
	\begin{algorithmic}
\State \textbf{Input:}
			Observed labeling rates  and covariance ;
			class balance  and variance ;
			correlation sparsity structure 

		\State 

\State , 
		\State 
			\\
		\Return 
	\end{algorithmic}
\end{algorithm}

\begin{figure*}
    \centering
    \includegraphics[width=\textwidth]{fig/synthetic_figs.pdf}
    \caption{(Left) Estimation error  decreases with increasing . (Middle) Given , our model successfully recovers the source accuracies even with many pairwise dependencies among sources, where a naive conditionally-independent model fails. (Right) The runtime of \systemx~is independent of  after an initial matrix multiply, and can thus be multiple orders of magnitude faster than Gibbs sampling-based approaches~\cite{ratner2016data}.}
    \label{fig:synthetic_fig}
\end{figure*}

\subsection{Theoretical Analysis: Scaling with Diverse Multi-Task Supervision}
Our ultimate goal is to train an \textit{end model} using the source labels, denoised and combined by the label model  we have estimated.
We connect the generalization error of this end model to the estimation error of Algorithm~\ref{alg:method}, ultimately showing that the generalization error scales as , where  is the number of unlabeled data points.
This key result establishes the same asymptotic scaling as traditionally supervised learning methods, but with respect to \textit{unlabeled} data points.

Let  be the probabilistic label (i.e. distribution) predicted by our label model, given the source labels  as input, which we compute using the estimated .
We then train an \textit{end} multi-task discriminative model  parameterized by , by minimizing the expected loss with respect to the label model over  unlabeled data points.
Let  be a bounded multi-task loss function such that without loss of generality ; then we minimize the empirical \textit{noise aware loss}:

and let  be the  that minimizes the true noise-aware loss.
This minimization can be performed by standard methods and is not the focus of our paper; let the solution  satisfy .
We make several assumptions, following \cite{ratner2016data}: (1) that for some label model parameters , sampling  is the same as sampling from the true distribution, ; and (2) that the task labels  are independent of the features of the end model given  sampled from , that is, the output of the optimal label model provides sufficient information to discern the true label.
Then we have the following result:
\begin{theorem}
	Let  minimize the expected noise aware loss, using weak supervision source parameters  estimated with Algorithm~\ref{alg:method}.
	Let  minimize the empirical noise aware loss with , , and let the assumptions above hold. Then the generalization error is bounded by:
    
\end{theorem}
Thus, to control the generalization error, we must control , which
we do in Theorem~\ref{thm:mu_est}:

\versionswitch{
\begin{restatable}{theorem}{thmmuest}
\label{thm:mu_est}
Let  be an estimate of  produced by Algorithm~\ref{alg:method} run over  unlabeled data points.
Let  and .
Then, we have:

\end{restatable}
}{
\begin{restatable}{theorem}{thmmuest}
\label{thm:mu_est}
Let  be an estimate of  produced by Algorithm~\ref{alg:method} run over  unlabeled data points.
Let  and .
Then, we have:

\end{restatable}
}
 
\paragraph{Interpreting the Bound} 
We briefly explain the key terms controlling the bound in Theorem~\ref{thm:mu_est}; more detail is found in \versionswitch{the Appendix}{Appendix~\ref{appendix:theoretical}}.
Our primary result is that the estimation error scales as .
Next, , the largest singular value of the pseudoinverse , has a deep connection to the density of the graph .
The smaller this quantity, the more information we have about , and the easier it is to estimate the accuracies. 
Next, , the smallest eigenvalue of the observed covariance matrix, reflects the conditioning of ; better conditioning yields easier estimation, and is roughly determined by how far away from random guessing the worst weak supervision source is, as well as how conditionally independent the sources are.
, the largest eigenvalue of the upper-left block of the inverse covariance matrix, similarly reflects the overall conditioning of .
Finally, , the smallest entry of the inverse observed matrix, reflects the smallest non-zero correlation between source accuracies; distinguishing between small correlations and independent sources requires more samples.

\subsection{Extensions: Abstentions \& Unipolar Sources}
\label{sec:extensions}
We briefly highlight two extensions handled by our approach which we have found empirically critical: handling \textit{abstentions}, and modeling \textit{unipolar} sources.

\textit{Handling Abstentions. }
One fundamental aspect of the weak supervision setting is that sources may abstain from labeling a data point entirely---that is, they may have incomplete and differing coverage~\cite{ratner2018snorkel,Dalvi:2013:ACB:2488388.2488414}.
We can easily deal with this case by extending the coverage ranges  of the sources to include the vector of all zeros, , and we do so in the experiments.

\textit{Handling Unipolar Sources. }
Finally, we highlight the fact that our approach models \textit{class conditional} source accuracies, in particular motivated by the case we have frequently observed in practice of \textit{unipolar} weak supervision sources, i.e., sources that each only label a single class or abstain.
In practice, we find that users most commonly use such unipolar sources; for example, a common template for a heuristic-based weak supervision source over text is one that looks for a specific pattern, and if the pattern is present emits a specific label, else abstains. 
As compared to prior approaches that did not model class-conditional accuracies, e.g.~\cite{ratner2016data}, we show in our experiments that we can use our class-conditional modeling approach to yield an improvement of  points in accuracy.
 
\section{Experiments}
\label{sec:experiments}


\begin{table*}[t]
    \centering
    \begin{tabular}{lrrrr}
      \toprule
              & NER & RE & Doc & Average\\
      \midrule
      Gold (Dev)
        & 63.7  2.1
        & 28.4  2.3
        & 62.7  4.5
        & 51.6 
        \\
      MV
        & 76.9  2.6
        & 43.9  2.6
        & 74.2  1.2
        & 65.0
        \\
      DP \cite{ratner2016data}
        & 78.4  1.2
        & 49.0  2.7
        & 75.8  0.9
        & 67.7
        \\
      \midrule
      \systemx
        & \textbf{82.2}  0.8
        & \textbf{56.7}  2.1
        & \textbf{76.6}  0.4
        & \textbf{71.8}
        \\
      \bottomrule
    \end{tabular}
    \caption{\textbf{Performance Comparison of Different Supervision Approaches.} We compare the micro accuracy (avg. over 10 trials) with 95\% confidence intervals of an end multi-task model trained using the training labels from the hand-labeled development set (Gold Dev), hierarchical majority vote (MV), data programming (DP), and our approach (\systemx).}
    \label{tab:results}
\end{table*}

We validate our approach on three fine-grained classification problems---entity classification, relation classification, and document classification---where weak supervision sources are available at both coarser and finer-grained levels (e.g. as in Figure~\ref{fig:lf_example}).
We evaluate the predictive accuracy of end models supervised with training data produced by several approaches, finding that our approach outperforms traditional hand-labeled supervision by 20.2 points, a baseline majority vote weak supervision approach by  points, and a prior weak supervision denoising approach~\cite{ratner2016data} that is not multi-task-aware by  points.

\paragraph*{Datasets}
\label{sec:data}
Each dataset consists of a large (3k-63k) amount of unlabeled training data and a small (200-350) amount of labeled data which we refer to as the \textit{development set}, which we use for (a) a traditional supervision baseline, and (b) for hyperparameter tuning of the end model (see Appendix\versionswitch{}{ \ref{appendix:exp_details}}). 
The average number of weak supervision sources per task was , with sources expressed as Python functions, averaging  lines of code and comprising a mix of pattern matching heuristics, external knowledge base or dictionary lookups, and pre-trained models.
In all three cases, we choose the decomposition into sub-tasks so as to align with weak supervision sources that are either available or natural to express.

\textit{Named Entity Recognition (NER):}
We represent a fine-grained named entity recognition problem---tagging entity mentions in text documents---as a hierarchy of three sub-tasks over the OntoNotes dataset \cite{weischedel2011ontonotes}:   ,   ,   , where again we use  to represent ``not applicable''.

\textit{Relation Extraction (RE):}
We represent a relation extraction problem---classifying entity-entity relation mentions in text documents---as a hierarchy of six sub-tasks which either concern labeling the subject, object, or subject-object pair of a possible or \textit{candidate} relation in the TACRED dataset~\cite{zhang2017position}.
For example, we might label a relation as having a  subject,  object, and  relation type.

\textit{Medical Document Classification (Doc):}
We represent a radiology report triaging (i.e. document classification) problem from the OpenI dataset~\cite{NationalInstitutesofHealth2017Open-i:Engine} as a hierarchy of three sub-tasks:   ,   ,   .

\paragraph*{End Model Protocol}
Our goal was to test the performance of a basic multi-task end model using training labels produced by various different approaches.
We use an architecture consisting of a shared bidirectional LSTM input layer
with pre-trained embeddings, shared linear intermediate layers, and a separate final linear layer (``task head'') for each task.
Hyperparameters were selected with an initial search for each application (see Appendix), then fixed.


\paragraph*{Core Validation}
We compare the accuracy of the end multi-task model trained with labels from our approach versus those from three baseline approaches (Table~\ref{tab:results}):
\begin{itemize}
  \item \textit{Traditional Supervision} \textbf{[Gold (Dev)]}:
  We train the end model using the small hand-labeled development set.
  
  \item \textit{Hierarchical Majority Vote} \textbf{[MV]}:
  We use a hierarchical majority vote of the weak supervision source labels: i.e. for each data point, for each task we take the majority vote and proceed down the task tree accordingly.
  This procedure can be thought of as a hard decision tree, or a cascade of if-then statements as in a rule-based approach.

  \item \textit{Data Programming} \textbf{[DP]}:
  We model each task separately using the data programming approach for denoising weak supervision \cite{ratner2018snorkel}.
\end{itemize}
In all settings, we used the same end model architecture as described above.
Note that while we choose to model these problems as consisting of multiple sub-tasks, we evaluate with respect to the broad primary task of fine-grained classification (for subtask-specific scores, see Appendix).
We observe in Table~\ref{tab:results} that our approach of leveraging multi-granularity weak supervision leads to large gains--- points over traditional supervision with the development set,  points over hierarchical majority vote, and  points over data programming.

\paragraph*{Ablations}
We examine individual factors:

\textit{Unipolar Correction:}
Modeling unipolar sources (Sec~\ref{sec:extensions}), which we find to be especially common when fine-grained tasks are involved, leads to an average gain of  points of accuracy in \systemx performance.

\textit{Joint Task Modeling:}
Next, we use our algorithm to estimate the accuracies of sources for each task separately, to observe the empirical impact of modeling the multi-task setting jointly as proposed.
We see average gains of 1.3 points in accuracy (see Appendix).

\textit{End Model Generalization:}
Though not possible in many settings, in our experiments we can directly apply the label model to make predictions.
In Table~\ref{tab:end_model_boost}, we show that the end model improves performance by an average  points in accuracy, validating that the models trained do indeed learn to generalize beyond the provided weak supervision.
Moreover, the largest generalization gain of 7 points in accuracy came from the dataset with the most available unlabeled data (=63k), demonstrating scaling consistent with the predictions of our theory (Fig.~\ref{fig:onto_scale}).
This ability to leverage additional unlabeled data and more sophisticated end models are key advantages of the weak supervision approach in practice.

\begin{figure}
  \centering
  \includegraphics[width=\figwidthB]{\figpathB}\caption{In the OntoNotes dataset, end model accuracy scales with the amount of available \textit{unlabeled} data.}
  \label{fig:onto_scale}
\end{figure}

\begin{figure}
  \centering
\begin{tabular}{lrrrr}
      \toprule
        & \# Train & LM & EM & \textit{Gain} \\
      \midrule
      NER
        & 62,547
        & 75.2
        & 82.2
        & \textit{7.0}
        \\
      RE
        & 9,090
        & 55.3
        & 57.4
        & \textit{2.1}
        \\
      Doc
        & 2,630
        & 75.6
        & 76.6
        & \textit{1.0}
        \\
      \bottomrule\\
    \end{tabular}
  \caption{Using the label model (LM) predictions directly versus using an end model trained on them (EM).}
  \label{tab:end_model_boost}
\end{figure}
 
\section{Conclusion}
\label{sec:conclusion}


We presented \systemx, a framework for training models with weak supervision from diverse, \textit{multi-task} sources having different granularities, accuracies, and correlations.
We tackle the core challenge of recovering the unknown source accuracies via a scalable matrix completion-style algorithm, introduce theoretical bounds characterizing the key scaling with respect to unlabeled data, and demonstrate empirical gains on real-world datasets.
In future work, we hope to learn the task relationship structure and cover a broader range of settings where labeled training data is a bottleneck.

\paragraph*{Acknowledgements}
We gratefully acknowledge the support of DARPA under Nos. FA87501720095 (D3M) and FA86501827865 (SDH), NIH under No. N000141712266 (Mobilize), NSF under Nos. CCF1763315 (Beyond Sparsity), CCF1563078 (Volume to Velocity), and DGE-114747 (NSF GRF), ONR under No. N000141712266 (Unifying Weak Supervision), the Moore Foundation, NXP, Xilinx, LETI-CEA, Intel, Google, NEC, Toshiba, TSMC, ARM, Hitachi, BASF, Accenture, Ericsson, Qualcomm, Analog Devices, the Okawa Foundation, and American Family Insurance, the Stanford Interdisciplinary Graduate and Bio-X fellowships, the Intelligence Community Postdoctoral Fellowship, and members of the Stanford DAWN project: Intel, Microsoft, Teradata, Facebook, Google, Ant Financial, NEC, SAP, and VMWare.
The U.S. Government is authorized to reproduce and distribute reprints for Governmental purposes notwithstanding any copyright notation thereon.
Any opinions, findings, and conclusions or recommendations expressed in this material are those of the authors and do not necessarily reflect the views, policies, or endorsements, either expressed or implied, of DARPA, NIH, ONR, or the U.S. Government. 
\bibliography{metal}
\bibliographystyle{abbrv}

\pagebreak
\begin{appendix}
\section{Problem Setup \& Modeling Approach}
  \label{appendix:setup-and-model}
  \allowdisplaybreaks


In Section~\ref{appendix:setup-and-model}, we review our problem setup and modeling approach in more detail, and for more general settings than in the body.
In Section~\ref{appendix:theoretical}, we provide an overview, additional interpretation, and the proofs of our main theoretical results.
Finally, in Section~\ref{appendix:exp_details}, we go over additional details of our experimental setup.

We begin in Section~\ref{appendix:glossary} with a glossary of the symbols and notation used throughout this paper.
Then, in Section~\ref{appendix:problem-setup} we present the setup of our multi-task weak supervision problem, and in Section~\ref{appendix:modeling-approach-overview} we present our approach for modeling multi-task weak supervision, and the matrix completion-style algorithm used to estimate the model parameters.
Finally, in Section~\ref{appendix:hierarchical}, we present in more detail the subcase of hierarchical tasks considered in the main body of the paper.

\subsection{Glossary of Symbols}
\label{appendix:glossary}

\begin{table*}[h]
\centering
\begin{tabular}{l l}
\toprule
Symbol & Used for \\
\midrule
 & Data point,  \\
 & Number of data points \\
 & Label for one of the  classification tasks,  \\
 & Number of tasks \\
 & Vector of task labels  \\
 & Cardinality of the output space,  \\
 & Task structure graph \\
 & Output space of allowable task labels defined by ,  \\
 & Distribution from which we assume  data points are sampled i.i.d. \\
 & Weak supervision source, a function mapping  to a label vector\\
 & Label vector  output by the th source for  \\
 & Number of sources \\
 &  matrix of labels output by the  sources for  \\
 & Source output space, which is  augmented to include elements set to zero \\
 & Coverage set of - the tasks  gives non-zero labels to; for convenience,  \\
 & The output space for  given coverage set  \\
 & The output space  with all but the first value, for defining a minimal set of statistics \\
 & Source dependency graph, ,  \\
 & Cliqueset (maximal and non-maximal) of  \\
 & The maximal cliques (nodes) and separator sets of the junction tree over  \\
 & The indicator variable for the variables in clique  taking on values ,  \\
 & The parameters of our label model we aim to estimate;  \\
 & The set of observable cliques, i.e. those corresponding to cliques without  \\
 & Generalized covariance matrix of ,  \\
 & The inverse generalized covariance matrix  \\
 & The dimensions of  and  respectively \\
 & The augmented source dependencies graph  \\
 & The edge set of the inverse graph of  \\
 & Diagonal matrix of class prior probabilities,  \\
 & The \textit{label model} parameterized by  \\
 & The probabilistic training label, i.e.  \\
 & The \textit{end model} trained using  \\
\end{tabular}
\caption{
	Glossary of variables and symbols used in this paper.
}
\label{table:glossary}
\end{table*}

\subsection{Problem Setup}
\label{appendix:problem-setup}
Let  be a data point and  be a vector of \textit{task labels} corresponding to  tasks.
We consider categorical task labels,  for .
We assume  pairs are sampled i.i.d. from distribution ; to keep the notation manageable, we do not place subscripts on the sample tuples.

\paragraph*{Task Structure}
The tasks are related by a \emph{task graph} .
Here, we consider schemas expressing logical relationships between tasks, which thus define \textit{feasible sets} of label vectors , such that .
We let  be the number of feasible task vectors.
In section~\ref{appendix:hierarchical}, we consider the particular subcase of a \textit{hierarchical} task structure as used in the experiments section of the paper.
\paragraph*{Multi-Task Sources}
We now consider \textit{multi-task} weak supervision sources , which represent noisy and potentially incomplete sources of labels, which have unknown accuracies and correlations.
Each source  outputs label vectors , which contain non-zero labels for \textit{some} of the tasks, such that  is in the feasible set  but potentially with some elements set to zero, denoting a null vote or abstention for that task.
Let  denote this extended set which includes certain task labels set to zero.

We also assume that each source has a fixed \textit{task coverage set} , such that  for , and  for ; let  be the range of  given coverage set .
For convenience, we let  so that .
The intuitive idea of the task coverage set is that some labelers may choose not to label certain tasks; Example~\ref{ex:task_structure} illustrates this notion.
Note that sources can also \textit{abstain} for a data point, meaning they emit no label (which we denote with a symbol ); we include this in .
Thus we have , where, again,  denotes the output of the function .


\paragraph*{Problem Statement}
Our overall goal is to use the noisy or \textit{weak}, \textit{multi-task} supervision from the set of  sources, , applied to an unlabeled dataset  consisting of  data points, to supervise an \textit{end model} .
Since the sources have unknown accuracies, and will generally output noisy and incomplete labels that will overlap and conflict, our intermediate goal is to learn a \textit{label model}  which takes as input the source labels and outputs a set of probabilistic label vectors, , for each , which can then be used to train the end model.
Succinctly, given a user-provided tuple , our goal is to recover the parameters .

The key technical challenge in this approach then consists of learning the parameters of this label model---corresponding to the conditional accuracies of the sources (and, for technical reasons we shall shortly explain, cliques of correlated sources)---given that \textit{we do not have access to the ground truth labels }.
We discuss our approach to overcoming this core technical challenge in the subsequent section.


\subsection{Our Approach: Modeling Multi-Task Sources}
\label{appendix:modeling-approach-overview}
Our goal is to estimate the parameters  of a \textit{label model} that produces probabilistic training labels given the observed source outputs, , \textit{without access to the ground truth labels }.
We do this in three steps:
\begin{enumerate} 
	\item We start by defining a graphical model over the weak supervision source outputs and the true (latent) variable , , using the conditional independence structure  between the sources.
\item Next, we analyze the \textit{generalized covariance matrix}   (following Loh \& Wainwright~\cite{loh2012structure}), which is defined over binary indicator variables for each value of each clique (or specific subsets of cliques) in .
	We consider two specific subsets of the cliques in , the observable cliques  and the separator sets , such that:
	
	where  is the block of  that we can observe, and  is a function of , the parameters (corresponding to source and  clique accuracies) we wish to recover.
	We then apply a result by Loh and Wainwright \cite{loh2012structure} to establish the sparsity pattern of .
	This allows us to apply the block-matrix inversion lemma to reformulate our problem as solving a matrix completion-style objective.
\item Finally, we describe how to recover the class balance ; with this and the estimate of , we then describe how to compute the probabilistic training labels .
\end{enumerate}

We start by focusing on the setting where  has a junction tree with singleton separator sets; we note that a version of  where this holds can always be formed by adding edges to the graph.
We then discuss how to handle graphs with non-singleton separator sets, and finally describe different settings where our problem reduces to rank-one matrix completion.
In Section~\ref{appendix:theoretical}, we introduce theoretical results for the resulting model and provide our model estimation strategy.

\subsubsection{Defining a Multi-Task Source Model}
\label{appendix:model}

\begin{figure}
	\begin{subfigure}{.5\textwidth}
		\centering
		\begin{tikzpicture}[every node/.style={inner sep=0,outer sep=0}]
		
\draw (0,1.5) node[draw,circle,fill=white,minimum size=0.7cm](y) {};
		
\draw (-1.5,0) node[draw,fill=lightgray,circle,minimum size=0.7cm](l1x) {};
		\draw (-0.5,0) node[draw,fill=lightgray,circle,minimum size=0.7cm](l2x) {};
		\draw (0.5,0) node[draw,fill=lightgray,circle,minimum size=0.7cm](l3x) {};
		\draw (1.5,0) node[draw,fill=lightgray,circle,minimum size=0.7cm](l4x) {};

\draw (y) -- (l1x);
		\draw (y) -- (l2x);
		\draw (l1x) -- (l2x);
		\draw (y) -- (l3x);
		\draw (y) -- (l4x);
		
		\end{tikzpicture}
		\label{fig:g-source-appendix}
	\end{subfigure}\begin{subfigure}{.5\textwidth}
		\centering
		\begin{tikzpicture}[every node/.style={inner sep=0,outer sep=0}]
		
\draw (0,1.5) node [
			draw,
			rounded rectangle,
			fill=white,
			minimum height=0.75cm,
			minimum width=1.75cm
		] (jtn1) {};
		\draw (-1.5,0) node [
			draw,
			rounded rectangle,
			fill=white,
			minimum height=0.75cm,
			minimum width=1.25cm
		] (jtn2) {};
		\draw (1.5,0) node [
			draw,
			rounded rectangle,
			fill=white,
			minimum height=0.75cm,
			minimum width=1.25cm
		] (jtn3) {};

\draw (jtn1) -- (jtn2);
		\draw (jtn1) -- (jtn3);

\draw (1,0.85) node [] (ss12) {};
		\draw (-1,0.85) node [] (ss13) {};
		
		\end{tikzpicture}
		\label{fig:g-source-jt-appendix}
	\end{subfigure}\caption{
		A simple example of a weak supervision source dependency graph  (left) and its junction tree representation (right).
		Here  is as a vector-valued variable with a feasible set of values, , and the output of sources 1 and 2 are modeled as dependent conditioned on .
		This results in a junction tree with singleton separator sets .
		Here, the observable cliques are .
	}
	\label{fig:g-source-example-appendix}
\end{figure}

We consider a model , where , and  consists of pairwise interactions (i.e. we consider an Ising model, or equivalently, a graph rather than a hypergraph of correlations).
We assume that  is provided by the user.
However, if  is unknown, there are various techniques for estimating it statistically~\cite{bach2017learning} or even from static analysis if the sources are heuristic functions~\cite{varma2017inferring}.
We provide an example  with singleton separator sets in Figure~\ref{fig:g-source-example-appendix}.

\paragraph*{Augmented Sufficient Statistics}
Finally, we extend the random variables in  by defining a matrix of indicator statistics over all cliques in , in order to estimate all the parameters needed for our label model .
We assume that the provided  is \textit{chordal}, meaning it has no chordless cycles of length greater than three; if not, the graph can easily be \emph{triangulated} to satisfy this property, in which case we work with this augmented version.

Let  be the set of maximal and non-maximal cliques in the chordal graph .
We start by defining a binary indicator random variable for the event of a clique  in the graph  taking on a set of values :

where  and  contains all but one values of , thereby leading to a minimal set of statistics.
Note that in our notation, , , and .
Accordingly, we define  as the vector of indicator random variables for all combinations of all but one of the labels emitted by each variable in clique , and define  accordingly for any set of cliques .
Then  is the vector of sufficient statistics for the label model we want to learn.
Our model estimation goal is now stated simply: we wish to estimate , \textit{without access to the ground truth labels} .

\subsubsection{Model Estimation without Ground Truth Using Inverse Covariance Structure}
\label{appendix:model-estimation}
Our goal is to estimate ; this, along with the class balance  (which we assume we know, or else estimate using the approach in Section~\ref{appendix:recovering-class-balance}), is sufficient information to compute .
If we had access to a large enough set of ground truth labels , we could simply take the empirical expectation ; however in our setting we cannot directly observe this.
Instead, we proceed by analyzing a sub-block of the covariance matrix of , which corresponds to the \textit{generalized covariance matrix} of our graphical model as in~\cite{loh2012structure}, and leverage two key pieces of information:
\begin{itemize}
	\item A sub-block of this generalized covariance matrix is observable, and
\item By a simple extension of Corollary 1 in~\cite{loh2012structure}, we know the sparsity structure of the inverse generalized covariance matrix , i.e. we know that it will have elements equal to zero according to the structure of .
\end{itemize}
Since  is triangulated, it admits a \textit{junction tree} representation~\cite{koller2009probabilistic}, which has maximal cliques (nodes)  and separator sets .
Note that we follow the convention that  includes the full powerset of separator set cliques, i.e. all subset cliques of separator set cliques are also included in .
We proceed by considering two specific subsets of the cliques of our graphical model : those that are observable (i.e. not containing ), , and the set of separator set cliques (which will always contain , and thus be unobservable).

For simplicity of exposition, we start by considering graphs  which have singleton separator sets; given our graph structure, this means that .
Note that in general we will write single-element sets without braces when their type is obvious from context, so we have .
Intuitively, this corresponds to models where weak supervision sources are correlated in fully-connected clusters, corresponding to real-world settings in which sources are correlated due to shared data sources, code, or heuristics.
However, we can always either (i) add edges to  such that this is the case, or (ii) extend our approach to many settings where  does not have singleton separator sets (see Section~\ref{appendix:non-singleton-sep-sets}).

In this singleton separator set setting of , we now have:

where  and  are the corresponding vectors of minimal indicator variables.
We define corresponding dimensions  and :


We now decompose the generalized covariance matrix and its inverse as:

This is similar to the form used in~\cite{chandrasekaran2010latent}, but with several important differences: we consider discrete (rather than Gaussian) random variables and have additional knowledge of the graph structure.
Here,  is the observable block of the generalized covariance matrix , and  is the unobserved block which is a function of , the parameters (corresponding to source and source clique accuracies) we wish to recover.
Note that with the singleton separator sets we are considering,  is a function of the class balance , which we assume is either known, or has been estimated according to the unsupervised approach we detail in Section~\ref{appendix:recovering-class-balance}.
Therefore, we assume that  is also known.
Concretely then, our goal is to recover  given .

We start by applying the block matrix inversion lemma to get the equation:


Next, let .
We justify this decomposition by showing that this term is positive semidefinite.
We start by applying the Woodbury matrix inversion lemma:

Now, note that  and  are both covariance matrices themselves and are therefore PSD.
Furthermore, from~\cite{loh2012structure} we know that  must exist, which implies that  and  are invertible (and thus in fact positive definite).
Therefore we also have that , and therefore (\ref{eqn:middle-term}) is positive definite, and can therefore always be expressed as  for some .
Therefore, we can write (\ref{eqn:block-inv-cov}) as:

Finally, define ; we then have:

Note that , where , and therefore  is a rank- matrix.
Therefore, we now have a form (\ref{eqn:matrix-completion-form}) that appears close to being a matrix completion-style problem.
We complete the connection by leveraging the known sparsity structure of .

Define  to be the augmented version of our graph .
In other words, let  and  according to the indexing scheme of our augmented indicator variables; then,  if  are subsets of the same maximal clique in .
Then, let  be the inverse graph of , such that  and vice-versa.

We start with a result that extends Corollary 1 in Loh \& Wainwright~\cite{loh2012structure} to our specific setting where we consider a set of the variables that contains all observable cliques, , and all separator sets  (note that this result holds for all , not just ):

\begin{corollary}
	\label{cor:o-h-partition}
	Let .
	Let  be the generalized covariance matrix for .
	Then  whenever  correspond to cliques  respectively such that  are not subsets of the same maximal clique.
\end{corollary}
\textit{Proof:}
We partition the cliques  into two sets,  and .
Let  be the full generalized covariance matrix (i.e. including all maximal and non-maximal cliques) and .
Thus we have:

By the block matrix inversion lemma we have:

We now follow the proof structure of Corollary 1 of~\cite{loh2012structure}.
We know  is graph structured by Theorem 1 of~\cite{loh2012structure}.
Next, using the same argument as in the proof of Corollary 1 of~\cite{loh2012structure}, we know that , and therefore , is block-diagonal.
Intuitively, because the set  contains all of the separator set cliques, and due to the running intersection property of a junction tree, each clique in  belongs to precisely one maximal clique- leading to block diagonal structure of .
We thus need only to show that the following quantity is zero for two cliques  that are not subsets of the same maximal clique, with corresponding indices :

where  are the indices corresponding to the blocks in , which correspond to maximal cliques.
Our argument follows again as in Corollary 1 of~\cite{loh2012structure}: since  contains the separator sets, if the two cliques  are not subsets of the same maximal clique, then for each , either  or  must be zero, completing the proof.

Now, by Corollary 1, we know that  if .
Let  denote a matrix  with all entries  masked to zero.
Then, we have:


Thus, given the dependency graph , we can solve for  as a rank- matrix completion problem, with mask .
Defining the semi-norm , we can solve:


Now, we have an estimate of .
Note that at this point, we can only recover  up to orthogonal transformations.
We proceed by considering a reduced rank-one model, detailed in Section~\ref{appendix:rank-one-reduction}, and in Section~\ref{appendix:identifiability} establish concrete conditions under which this model is uniquely identifiable.

We denote this rank-one setting by switching to writing  as , in which case we now have:

Once we have recovered  uniquely (see Section~\ref{appendix:identifiability}), we next need to recover .
We use the fact that , which we can confirm explicitly below, starting from the definition of :

Thus, we can directly recover an estimate of  from the observed , known , and estimated .
Finally, we have:

Here, we can clearly observe , and given that we know the class balance , we also have ; therefore we can compute .
Our goal now is to recover the columns , which together make up ; we can do this based on the constraints of our rank-one model (Section~\ref{appendix:rank-one-reduction}), thus recovering an estimate of , which given the uniqueness of  (Section~\ref{appendix:identifiability}) is also unique.
The overall procedure is described in the main body, in Algorithm~\ref{alg:method}.

\subsubsection{Handling Non-Singleton Separator Sets}
\label{appendix:non-singleton-sep-sets}

Now, we consider the setting where  has arbitrary separator sets.
Let .
We see that we could solve this using our standard approach---this time, involving a rank- matrix completion problem---except for the fact that we do not know , as it now involves terms besides the class balance.

Note first of all that we can always add edges between sources to  such that it has singleton separator sets (intuitively, this consists of ``completing the clusters''), and as long as our problem is still identifiable (see Section~\ref{appendix:identifiability}), we can simply solve this instance as above.

Instead, we can also take a multi-step approach, wherein we first consider one or more subgraphs of  that contain only singleton separator sets, and contain the cliques in .
We can then solve this problem as before, which then gives us the needed information to identify the elements of  in our full problem, which we can then solve.
In particular, we see that this multi-step approach is possible whenever the graph  has at least three components that are disconnected except for through .

\subsubsection{Rank-One Settings}
\label{appendix:rank-one-reduction}

We now consider settings where we can estimate the parameters of our label model, , involving only a rank-one matrix completion problem.

First, in the simplest setting of a single-task problem with binary class variable,  and  with singleton separator sets,  and our problem is directly a rank-one instance.

Next, we consider the setting of general , with  and  with singleton separator sets.
By default, our problem now involves a rank- matrix completion problem.
However, we can reduce this to involving only a rank-one matrix completion problem by adding one simplifying assuption to our model: namely, that sources emit different incorrect labels with uniform conditional probability.
Concretely, we add the assumption that:

Note that this is the same assumption as in the main body, but expressed more explicitly with respect to a clique .
For example, under this assumption,  is the same for all  such that .
As another example,  is the same for all  such that .
Intuitively, under this commonly-used model, we are not modeling the different class-wise errors a source makes, but rather just whether it is correct or not given the correctness of other sources it is correlated with.
The idea then is that with assumption (\ref{eqn:simplified-model-appendix}) even though  (and thus  has  columns), we only actually need to solve for a single parameter per element of .

We can operationalize this by forming a new graph with a binarized version of , , such that the  classes are mapped to either  or .
We see that this new variable still results in the same structure of dependencies , and still allows us to recover the parameters  (and thus ).
We now have:

We now solve in the same rank-one way as in the binary  case.
Now, for singleton cliques, , given that we know , we can directly recover  for all , given our simplified model.

For non-singleton cliques , note that we can directly recover  in the exact same way.
From these, computed for all cliques, we can then recover any probability in our model.
For example, for :

In this way, we can recover all of the parameters  while only involving a rank-one matrix completion problem.
Note that this also suggests a way to solve for the more general model, i.e. without (\ref{eqn:simplified-model-appendix}), using a hierarchical classification approach.



\subsubsection{Recovering the Class Balance  \& Computing }
\label{appendix:recovering-class-balance}
We now turn to the task of recovering the class balance , for .
In many practical settings,  can be estimated from a small labeled sample, or may be known in advance.
However here, we consider using a subset of conditionally independent sources,  to estimate .
We note first of all that simply taking the majority vote of these sources is a biased estimator.

Instead, we consider a simplified version of the matrix completion-based approach taken so far.
Here, we consider a subset of the sources  such that they are conditionally independent given , i.e. , and consider only the unary indicator statistics.
Denote the vector of these unary indicator statistics over the conditionally independent subset of sources as , and let the observed overlaps matrix between sources  and  be .
Note that due to the conditional independence of  and , for any  we have:

Letting  be the  matrix of conditional probabilities, , and  be the diagonal matrix such that , we can re-express the above as:

Since  is composed of strictly positive elements, and is diagonal (and thus PSD), we re-express this as:

where .
We could now try to recover  by decomposing the observed  to recover the , and from there recover  via the relation:

since summing the column of  corresponding to label  is equal to  by the law of total probability.
However, note that  for any orthogonal matrix  also satisfies~(\ref{eqn:ind-decomp}), and could thus lead to a potentially infinite number of incorrect estimates of .

\paragraph*{Class Balance Identifiability with Three-Way View Constraint}
A different approach involves considering the three-way overlaps observed as .
This is equivalent to performing a tensor decomposition.
Note that above, the problem is that matrix decomposition is typically invariant to rotations and reflections; tensor decompositions have easier-to-meet uniqueness conditions (and are thus more rigid).

Specifically, we apply Kruskal's classical identifiability condition for unique 3-tensor decomposition.
Consider some tensor 

where  are column vectors that make up the matrices . 
The Kruskal rank  of  is the largest  such that any  columns of  are linearly independent.
Then, the decomposition above is unique if ~\cite{kruskal77, bhaskara14}.
In our case, our triple views have , and we have

Thus, if , we have identifiability.
Thus, it is sufficient to have the columns of each of the 's be linearly independent.
Note that each of the 's have columns with the same sum, so these columns are only linearly dependent if they are equal, which would only be the case if the sources were random voters.

Thus, we can use (\ref{eqn:ind-tensor-decomp}) to recover the  in a stable fashion, and then use (\ref{eqn:p-recovery}) to recover the .

\subsubsection{Predicting Labels with the Label Model}
\label{appendix:label-model-predictions}
Once we have an estimate of , we can make predictions with the label model---i.e. generate our \textit{probabilistic} training labels ---using the junction tree we have already defined over .
Specifically, let  be the set of maximal cliques (nodes) in the junction tree, and let  be the set of separator sets.
Then we have:

where again, , where  and .
Thus, we can directly compute the predicted labels  based on the estimated parameters .

\subsection{Example: Hierarchical Multi-Task Supervision}
\label{appendix:hierarchical}
We now consider the specific case of \textit{hierarchical} multi-task supervision, which can be thought of as consisting of coarser- and finer-grained labels, or alternatively higher- and lower-level labels, and provides a way to supervise e.g. fine-grained classification tasks at multiple levels of granularity.
Specifically, consider a task label vector  as before, this time with , where we will explain the meaning of the special value  shortly.
We then assume that the tasks  are related by a \textit{task hierarchy} which is a hierarchy  with vertex set  and directed edge set .
 The task structure reflects constraints imposed by higher level (more general) tasks on lower level (more specific) tasks.
 The following example illustrates a simple tree  task structure:

\begin{example}
Let  classify a data point  as either a \texttt{PERSON} () or \texttt{BUILDING} ().
If , indicating that  represents a \texttt{PERSON}, then  can further label  as a \texttt{DOCTOR} or \texttt{NON-DOCTOR}.
 is used to distinguish between \texttt{HOSPITAL} and \texttt{NON-HOSPITAL} in the case that .
The corresponding graph  is shown in Figure~\ref{fig:tree_task}.
If , then task  is not applicable, since  is only suitable for persons; in this case,  takes the value .
In this way the task hierarchy defines a feasible set of task vector values:  are valid, while e.g.  is not.
\label{ex:task_structure}
\end{example}

As in the example, for certain configurations of 's, the parent tasks logically constrain the one or more of the children tasks to be irrelevant, or rather, to have inapplicable label values.
In this case, the task takes on the value .
In Example~\ref{ex:task_structure}, we have that if , representing a building, then  is inactive (since  corresponds to a building).
We define the symbol  (for incompatible) for this scenario.
More concretely, let  be the in-neighborhood of .
Then, the values of the members of  determine whether , i.e.,  is deterministic conditioned on . 
\begin{figure}
\centering
\begin{tikzpicture}[scale=1.0]
\node [circle,fill,inner sep=0pt,minimum size=5pt] (a0) at (0,1) [label={above:}]{};
\node [circle,fill,inner sep=0pt,minimum size=5pt] (a1) at (-1,0) [label={below:}]{};
\node [circle,fill,inner sep=0pt,minimum size=5pt] (a2) at (1,0) [label={below:}]{};
\draw[->] (a0) -- (a1);
\draw[->](a0) -- (a2);
\end{tikzpicture}
\caption{
	Example task hierarchy  for a three-task classification problem.
	Task  classifies a data point  as a \texttt{PERSON} or \texttt{BUILDING}.
	If  classifies  as a \texttt{PERSON},  is used to distinguish between \texttt{DOCTOR} and \texttt{NON-DOCTOR}.
	Similarly, if  classifies  as a \texttt{BUILDING},  is used to distinguish between \texttt{HOSPITAL} and \texttt{NON-HOSPITAL}.
	Tasks  are more specific, or \textit{finer-grained} tasks, constrained by their parent task .
}
\label{fig:tree_task}
\end{figure}
\paragraph*{Hierarchical Multi-Task Sources}
Observe that in the mutually-exclusive task hierarchy just described, the value of a descendant task label  determines the values of all other task labels in the hierarchy besides its descendants.
For example, in Example~\ref{ex:task_structure}, a label ; in other words, knowing that  is a \texttt{DOCTOR} also implies that  is a \texttt{PERSON} and not a \texttt{BUILDING}.

For a source  with coverage set , the label it gives to the lowest task in the task hierarchy which is non-zero and non- determines the entire label vector output by .
E.g. if the lowest task that  labels in the hierarchy is , then this implies that it outputs vector .
Thus, in this sense, we can think of each sources  as labeling one specific task in the hierarchy, and thus can talk about coarser- and finer-grained sources.
\paragraph*{Reduced-Rank Form: Modeling Local Accuracies}
In some cases, we can make slightly different modeling assumptions that reflect the nature of the task structure, and additionally can result in reduced-rank forms of our model.
In particular, for the hierarchical setting introduced here, we can divide the statistics  into \textit{local} and \textit{global} subsets, and for example focus on modeling only the \textit{local} ones to once again reduce to rank-one form.

To motivate with our running example: a finer-grained source that labels \texttt{DOCTOR} versus \texttt{NON-DOCTOR} probably is not accurate on the building type subtask; we can model this source using one accuracy parameter for the former label set (the \textit{local} accuracy) and a different (or no parameter) for the \textit{global} accuracy on irrelevant tasks.
More specifically, for cliques involving , we can model  for all  with only non- values in the coverage set of  using a single parameter, and call this the \textit{local} accuracy; and we can either model  for the other  using one or more other parameters, or simply set it to a fixed value and not model it, to reduce to rank one form, as we do in the experiments.
In particular, this allows us to capture our observation in practice that if a developer is writing a source to distinguish between labels at one sub-tree, they are probably not designing or testing it to be accurate on any of the other subtrees. 
\section{Theoretical Results}
  \label{appendix:theoretical}
  \allowdisplaybreaks

In this section, we focus on theoretical results for the basic rank-one model considered in the main body of the paper.
In Section~\ref{appendix:identifiability}, we start by going through the conditions for identifiability in more detail for the rank-one case.
In Section~\ref{appendix:interpreting-bound}, we provide additional interpretation for the expression of our primary theoretical result bounding the estimation error of the label model.
In Section~\ref{appendix:theorem-1}, we then provide the proof of Theorem 1, connecting this estimation error to the generalization error of the end model; and in Section~\ref{appendix:theorem-2}, we provide the full proof of the main bound.


\subsection{Conditions for Identifiability}
\label{appendix:identifiability}
We consider the rank-one setting as in the main body, where we have

where  is the inverse augmented edge set, i.e. a pair of indices , corresponding to elements of , and therefore to cliques , is in  if  are not part of the same maximal clique in  (and therefore ).
This defines a set of  equations, which we can encode using a matrix , where if  is the th entry in , then

Let  and ; then by squaring and taking the log of both sides of~\ref{eqn:rank-one-constraints}, we get a system of linear equations:

Thus, we can identify  (and therefore ) \textit{up to sign} if the system of linear equations (\ref{eqn:M-eqn}) has a solution.

\paragraph*{Notes on Invertibility of }
Note that if the inverse augmented edge graph consists of a connected triangle (or any odd-numbered cycle), e.g. , then we can solve for the  up to sign, and therefore  must be invertible:

and so on for .
Note additionally that if other  are connected to this triangle, then we can also solve for them up to sign as well.
Therefore, if  contains at least one triangle (or odd-numbered cycle) per connected component, then  is invertible.

Also note that this is all in reference to the \textit{inverse} source dependency graph, which will generally be dense (assuming the correlation structure between sources is generally sparse).
For example, note that if we have one source  that is conditionally independent of all the other sources, then  is fully connected, and therefore if there is a triangle in , then  is invertible.

\paragraph*{Identifying the Signs of the }
Finally, note that if we know the sign of one , then this determines the signs of every other  in the same connected component.
Therefore, for  to be uniquely identifiable, we need only know the \textit{sign} of one of the  in each connected component.
As noted already, if even one source  is conditionally independent of all the other sources, then  is fully connected; in this case, we can simply assume that the average source is better than random, and therefore identify the signs of  without any additional information.

\subsection{Interpreting the Main Bound} 
\label{appendix:interpreting-bound}
We re-state Theorem~\ref{thm:mu_est}, which bounds the average error on the estimate of the label model parameters, providing more detail on and interpreting the terms of the bound.

\thmmuest*

\paragraph*{Influence of } the largest singular value of the pseudoinverse . Note that . As we shall see below,  measures a quantity related to the structure of the graph . The smaller this quantity, the more information we have about , and the easier it is to estimate the accuracies. The smallest value of  (corresponding to the largest value of the eigenvalue) is ; the square of this quantity in the bound reduces the  cost of estimating the covariance matrix to .

It is not hard to see that  Here,  are the degrees of the nodes in  and  is its adjacency matrix. This form closely resembles the graph Laplacian, which differs in the sign of the adjacency matrix term: . We bound

where  is the lowest-degree node in  (that is, the source  with fewest appearances in ). In general, computing  can be challenging. A closely related task can be done via \emph{Cheeger inequalities}, which state that 

where  is the smallest non-zero eigenvalue of  and  is the \emph{Cheeger constant} of the graph \cite{cheeger}. The utility of the Cheeger constant is that it measures the presence of a bottleneck in the graph; the presence of such a bottleneck limits the graph density and is thus beneficial when estimating the structure in our case. Our Cheeger-constant like term  acts the same way.

Now, in the easiest and most common case is that of conditionally independent sources~\cite{dalvi:www13,zhang2014spectral,dalvi:www13,karger2011iterative}.,  has 1's everywhere but the diagonal, and we can compute explicitly that 
 
In the general setting, we must compute the minimal eigenvalue of the adjacency matrix, which is tractable, for example, for tree structures.  

\paragraph*{Influence of } the smallest eigenvalue of the observed matrix. This quantity reflects the conditioning of the observed (correlation) matrix; the better conditioned the matrix, the easier it is to estimate .

\paragraph*{Influence of } the smallest entry of the inverse observed matrix. This quantity contributes to , the geenralized precision matrix that we centrally use; it is a measure of the smallest non-zero correlation between source accuracies (that is, the smallest correlation between non-independent source accuracies). Note that the tail bound of Theorem~\ref{thm:mu_est} scales as . This is natural, as distinguishing between small correlations and independencies requires more samples. 


\subsection{Proof of Theorem 1}
\label{appendix:theorem-1}

Let  be the true data generating distribution, such that .
Let  be the label model parameterized by  and conditioned on the observed source labels .
Furthermore, assume that:
\begin{enumerate}
	\item For some optimal label model parameters , ;
	\item The label  is independent of the features of our end model given the source labels 
\end{enumerate}
That is, we assume that (i) the \textit{optimal} label model, parameterized by , correctly matches the true distribution of source labels  drawn from the true distribution, ; and (ii) that these labels  provide sufficient information to discern the label .
We note that these assumptions are the ones used in prior work~\citep{ratner2016data}, and are intended primarily to illustrate the connection between the estimation accuracy of , which we bound in Theorem~\ref{thm:mu_est}, and the end model performance.

Now, suppose that we have an end model parameterized by , and that to learn these parameters we minimize a normalized bounded loss function , such that without loss of generality, .
Normally our goal would be to find parameters that minimize the expected loss, which we denote :

However, since we do not have access to the true labels , we instead minimize the expected noise-aware loss, producing an estimate :

In practice, we actually minimize the \textit{empirical} version of the noise aware loss over an unlabeled dataset , producing an estimate :

Let  be the minimizer of the expected loss , let  be the minimizer of the noise-aware loss for estimated label model parameters , , and let  be the minimizer of the empirical noise aware loss .
Our goal is to bound the \textit{generalization risk}- the difference between the expected loss of our empirically estimated parameters and of the optimal parameters,


Additionally, since analyzing the empirical risk minimization error is standard and not specific to our setting, we simply assume that the error , where  is a decreasing function of the number of unlabeled data points .

To start, using the law of total expectation first, followed by our assumption (2) about condtional independence, and finally using our assumption (1) about our optimal label model , we have that:

Now, we have:

where in the first step we use our result that  as well as add and subtract terms; and in the second step we use the fact that .
We now have our generalization risk controlled primarily by , which is the difference between the expected noise aware losses given the estimated label model parameters  and the true label model parameters .
Next, we see that, for any :

where we have now bounded  by the size of the structured output space , and a term having to do with the difference between the probability distributions of  and .

Now, we use the result from~\citep{honorio2012lipschitz} (Lemma 19) which establishes that the log probabilities of discrete factor graphs with indicator features (such as our model ) are -Lipschitz with respect to their parameters, and the fact that for  s.t. , , to get:

where we use the fact that the statement of Lemma 19 also holds for every marginal distribution as well.
Therefore, we finally have:


\subsection{Proof of Theorem~\ref{thm:mu_est}}
\label{appendix:theorem-2}
\textit{Proof:} 
First we briefly provide a roadmap of the proof of Theorem~\ref{thm:mu_est}.
We consider estimating  with our procedure in the rank-one setting, and we seek a tail bound on .
The challenge here is that the observed matrix  we see is itself constructed from a series of observed i.i.d. samples .
We bound (through a matrix concentration inequality) the error , and view  as a perturbation of .
Afterwards, we use a series of perturbation analyses to ultimately bound , and then use this directly to bound ; each of the perturbation results is in terms of .

We begin with some notation. We write the following perturbations (note that all the terms written with  are additive, while the  term is relative)


Now we start our perturbation analysis:


Subtracting , we get


The rest of the analysis requires us to bound the norms for each of these terms. 

{\bf Left-most term}. We have that


Here, we bounded  by , since . 
Then, note that , since  and , so therefore .
In the last inequality, we use this to imply that . 
Next we work on bounding . We have


Thus,


{\bf Bounding }. We will need a bound on  to bound . We have that 
	
Applying the Woodbury matrix inversion lemma, we have:

Now, by the blockwise inversion lemma, we know that

So we then have:


{\bf Bounding }. We'll  use our bound on , since . 


In the last inequality, we used the fact that . Now we want to control .  

{\bf Perturbation bound}. We have the perturbation bound


We need to work on the term . To avoid overly heavy notation, we write , , and . 
Then we have:

Here, the second inequality uses , and the fourth inequality sums over squared values. Next, we use the perturbation bound , so that we have 


Then, plugging this into \eqref{eq:lpb}, we get that



{\bf Bounding} . Note also that . We have that

where in the fourth step, we used the bound  for small . Then, we have

 
{\bf Putting it together}.
Using \eqref{eq:maindmu}, we have that

Where in the first inequality, we use the triangle inequality and the fact that , and in the third inequality, we relied on the fact that we can control  (through ) so that we can make it small enough and thus take .
Now we can plug in our bounds on  and  from before:


For convenience, we set .
Recall that

and

Then, we have
 

Again we can take  small so that . Simplifying further, we have

Finally, since the  is smaller than the left-hand term inside the parentheses, we can write

 
{\bf Concentration bound.}
We need to bound , the error when estimating  from observations   over  unlabeled data points.

To start, recall that  is the set of observable cliques,  is the corresponding vector of minimal statistics, and .
For notational convenience, let , , and , and .
Then we have:

We start by applying the matrix Hoeffding inequality~\citep{tropp2015introduction} to bound the first term, .
Let , and thus clearly .
We seek a sequence of symmetric matrices  s.t. .
First, note that, for some vectors ,

using Cauchy-Schwarz; therefore , so that

Next, note that .
Now, we use this to see that:

Therefore, let , and note that .
We then have

And thus,


Next, we bound .
We see that:

where  is the perturbation for a single element of .
We can then apply the standard Hoeffding's bound to get:

Combining the bounds for  and , we get:

 
{\bf Final steps} 
Now, we use the bound on  in \eqref{eq:tbound} and the concentration bound above to write
 
 where .

Given , we recover .
We assume  is known, and we can bound the error introduced by  as above, which we see can be folded into the looser bound for the error in .

Finally, we expand the rank-one form  into  algebraically, according to our weight tying in the rank one model we use.
Suppose in the rank one reduction (see Section~\ref{appendix:rank-one-reduction}), we let .
Then each element of  that we track corresponds to either the probability of being correct,  or the probability of being incorrect, , for each source clique  and label output combination , and this value is simply copied  times (for the other, weight-tied incorrect values), except for potentially one entry where it is multiplied by  and then subtracted from  (to transform from incorrect to correct).
Therefore, .
Thus, we have:

where  is defined as above.
We only have one more step:

Here, we used the fact that . \hfill 
 
\section{Experimental Details}
  \label{appendix:exp_details}
  

\subsection{Data Balancing and Label Model Training Procedure}
For each application, rebalancing was applied via direct subsampling to the training set in the manner that was found to most improve development set micro-averaged accuracy.  Specifically, we rebalance with respect to the median class for OpenI (i.e., removing examples from majority class such that none had more than the original median class), the minimum class for TACRED, and perform no rebalancing for OntoNotes.  For generative model training, we use stochastic gradient descent with a step size, step number, and  penalty listed in Table \ref{table:hyperparameters} below.  These parameters were found via 10-trial coarse random search, with all values determined via maximum micro-averaged accuracy evaluated on the development set. 

\begin{table}[h!]
    \begin{center}
    \begin{tabular}{lrrr} 
        \toprule
        & OntoNotes & TACRED  & OpenI  \\ \midrule \midrule
        \textbf{Label Model Training} & & \\ \midrule
        Step Size & 5e-3 & 1e-2 & 5e-4 \\
          Regularization& 1e-4 &  4e-4 & 1e-3 \\
        Step Number &  50 & 25 & 50\\
        \midrule
        \textbf{End Model Architecture} & & \\ \midrule
        Embedding Initialization & PubMed & FastText EN & Random \\
        Embedding Size & 100 & 300 & 200\\
        LSTM Hidden Size & 150 & 250 & 150 \\
        LSTM Layers & 1 & 2 & 1 \\
        Intermediate Layer Dimensions & 200, 50 & 200, 50, 25  & 200, 50\\ \midrule
        \textbf{End Model Training} & & \\ \midrule
        Learning Rate & 1e-2 & 1e-3 & 1e-3 \\
         Regularization & 1e-4 & 1e-4  & 1e-3 \\
        Epochs & 20 & 30 & 50 \\
        Dropout & 0.25 & 0.25 & 0.1 \\ 
        \bottomrule
    \end{tabular}
    \caption{Model architecture and training parameter details.}
    \label{table:hyperparameters}
    \end{center}
    \end{table}

\subsection{End Model Training Procedure}
Before training over multiple iterations to attain averaged results for reporting, a 10-trial random search over learning rate and  regularization with the Adam optimizer was performed for each application based on micro-averaged development set accuracy.  Learning rate was decayed by an order of magnitude if no increases in training loss improvement or development set accuracy were observed for 10 epochs, and the learning rate was frozen during the first 5 epochs.  Models are reported using early stopping, wherein the best performing model on the development set is eventually used for evaluation on the held-out test set, and maximum epoch number is set for each application at a point beyond which minimal additional decrease in training loss was observed.

\subsection{Dataset Statistics}
We give additional detail in here (see Table \ref{tab:datasets}) on the different datasets used for the experimental portion of this work.  All data in the development and test sets is labeled with ground truth, while data in the training set is treated as unlabeled.  Each dataset has a particular advantage in our study.  The OntoNotes set, for instance, contains a particularly large number of relevant data points (over 63k), which enables us to investigate empirical performance scaling with the number of unlabeled data points.  Further, the richness of the TACRED dataset allowed for the creation of an 8-class, 7-sub-task hierarchical classification problem, which demonstrates the utility of being able to supervise at each of the three levels of task granularity.  Finally, the OpenI dataset represents a real-world, non-benchmark problem drawn from the domain of medical triage, and domain expert input was directly leveraged to create the relevant supervision sources.  The fact that these domain expert weak supervision sources naturally occurred at multiple levels of granularity, and that the could be easily integrated to train an effective end model, demonstrates the utility of the \systemx framework in practical settings.
\begin{table}[hbt!]
\setlength\tabcolsep{5pt}
{
\vspace{10pt}
\centering
\begin{tabular}{lrrrccccccc}
      \toprule
           & \# Train & \# Dev & \# Test & Tree Depth & \# Tasks & \# Sources/Task \\
      \midrule
      OntoNotes (NER)
        & 62,547
        & 350
        & 345
        & 2
        & 3
        & 11
        \\
      TACRED (RE)
        & 9,090
        & 350
        & 2174
        & 3
        & 7
        & 9
        \\
      OpenI (Doc)
        & 2,630
        & 200
        & 378
        & 2
        & 3
        & 19
        \\
      \bottomrule\\
    \end{tabular}
    \caption{Dataset split sizes and sub-task structure for the three fine-grained classification tasks on which we evaluate \systemx.}
    \label{tab:datasets}
}
\end{table}

\subsection{Task Accuracies}
\label{appendix:task_accuracies}

For clarity, we present in Table \ref{table:task_accuracies} the individual task accuracies of both the learned \systemx model and MV for each experiment.  These accuracies are computed from the output of evaluating each model on the test set with ties broken randomly.  
      
\begin{table}[hbt!]
\begin{center}
\begin{tabular}{cccc} \toprule
   & OntoNotes  & TACRED  & OpenI  \\ \midrule    
  \underline{Task 1}  & & &\\
  MV   & 93.3  & 74.2  & 83.9 \\
  \systemx & 91.9  & 80.5 & 84.1 \\ \midrule
    \underline{Task 2}  & & &\\
  MV   & 73.3  & 46.2  &  77.8 \\
  \systemx & 75.6  & 65.9 & 83.7 \\ \midrule
      \underline{Task 3}  & & &\\
  MV   & 71.4  & 74.9 & 61.7 \\
  \systemx & 74.1   & 74.8 & 61.7 \\ \midrule
        \underline{Task 4}  & & &\\
  MV   & -  & 34.4 & - \\
  \systemx &  - & 60.2 & - \\ \midrule
          \underline{Task 5}  & & &\\
  MV   & -  & 36.2 & - \\
  \systemx &  - & 40.2 & - \\ \midrule
            \underline{Task 6}  & & &\\
  MV   & -  & 56.3 & - \\
  \systemx &  - &  49.9 & - \\ \midrule
              \underline{Task 6}  & & &\\
  MV   & -  & 36.8 & - \\
  \systemx &  - &  56.3 & - \\ 
  
\bottomrule
\end{tabular}
\caption{Label model task accuracies for each task for for both our approach and majority vote (\systemx/MV)}
\label{table:task_accuracies}
\end{center}
\end{table}


\subsection{Ablation Study: Unipolar Correction and Joint Modeling}
\label{appendix:unipolar}

We perform an additional ablation to demonstrate the relative gains of modeling unipolar supervision sources and jointly modeling accuracies across multiple tasks with respect to the data programming (DP) baseline \citep{ratner2018snorkel}.  Results of this investigation are presented in Table \ref{tab:unipolar}. We observe an average improvement of  points using the unipolar correction (DP-UI), and an additional 1.3 points from joint modeling within \systemx, resulting in an aggregate gain of   accuracy points over the data programming baseline.

\begin{table}[hbt!]
    \centering
    \begin{tabular}{lrrrr}
      \toprule
              & OntoNotes (NER) & TACRED (RE) & OpenI (Doc) & Average\\
      \midrule
      DP \citep{ratner2016data}
        & 78.4  1.2
        & 49.0  2.7
        & 75.8  0.9
        & 67.7
        \\
       \midrule
      DP-UI
         & 81.0  1.2
         & 54.2  2.6
         & 76.4  0.5
         & {70.5}
         \\
      \midrule
      \systemx
        & \textbf{82.2}  0.8
        & \textbf{56.7}  2.1
        & \textbf{76.6}  0.4
        & \textbf{71.8}
        \\
      \bottomrule
    \end{tabular}
    \caption{\textbf{Effect of Unipolar Correction.} We compare the micro accuracy (avg. over 10 trials) with 95\% confidence intervals of a model trained using data programming (DP), data program with a unipolar correction (DP-UI), and our approach (\systemx).}
    \label{tab:unipolar}
\end{table}
 
\end{appendix}

\end{document}
