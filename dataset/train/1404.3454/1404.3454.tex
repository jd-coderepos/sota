

\documentclass[conference]{IEEEtran}
\usepackage{graphicx}
\usepackage{subfigure}
\usepackage{color}
\usepackage{algorithm}
\usepackage[noend]{algorithmic}
\usepackage{float}



\newtheorem{property}{Property}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\newtheorem{definition}{Definition}
\newtheorem{corollary}{Corollary}
\newtheorem{example}{Example}
\newtheorem{proposition}{Proposition}


\linespread{0.95}


\usepackage{geometry}
\geometry{left=2cm,right=2cm,top=2cm,bottom=2cm}


\begin{document}

\title{Scalable Steiner Tree for Multicast Communications in Software-Defined Networking}



\author{\IEEEauthorblockN{Liang-Hao Huang,~Hui-Ju Hung,~Chih-Chung Lin, and~De-Nian Yang}
\IEEEauthorblockA{Academia Sinica, Taipei, Taiwan\\
\{lhhuang, hjhung, chchlin, dnyang\}@iis.sinica.edu.tw}}

\maketitle

\begin{abstract}
Software-Defined Networking (SDN) enables flexible network resource
allocations for traffic engineering, but at the same time the scalability
problem becomes more serious since traffic is more difficult to be
aggregated. Those crucial issues in SDN have been studied for unicast but have not
been explored for multicast traffic, and addressing those issues for
multicast is more challenging since the identities and the number of
members in a multicast group can be arbitrary. In this paper, therefore, we
propose a new multicast tree for SDN, named Branch-aware Steiner Tree (BST).
The BST problem is difficult since it needs to jointly minimize the numbers of the edges and the branch nodes in a tree, and we prove that it is NP-Hard and
inapproximable within , which denotes the number of group members. We further
design an approximation algorithm, called Branch Aware Edge Reduction
Algorithm (BAERA), to solve the problem. Simulation results demonstrate that
the trees obtained by BAERA are more bandwidth-efficient and scalable than
the shortest-path trees and traditional Steiner trees. Most importantly,
BAERA is computation-efficient to be deployed in SDN since it can generate a
tree on massive networks in small time.
\end{abstract}


\begin{IEEEkeywords}
SDN, multicast, NP-Hard, traffic engineering, scalability
\end{IEEEkeywords}

\section{Introduction}

\IEEEPARstart{S}{oftware-Defined} Networking (SDN) is an emerging
architecture that is manageable, dynamic, cost-effective, and adaptable,
making it ideal for the high-bandwidth, huge data, and dynamic nature of
numerous network services  \cite{sdnwebsite}. This novel architecture decouples the network
control and forwarding functions. It enables the network control to become
directly programmable and the underlying infrastructure to be abstracted for
varied applications. The OpenFlow protocol has been recognized as a crucial
element for building SDN solutions \cite{sdnwebsite, McKeown2008, OpenFlow2013}.

SDN comprises two main components: SDN controller (SDN-C) and SDN
forwarding element (SDN-FE) \cite{OpenFlow2013}. Compared with the
traditional shortest-path routing, SDN-C enables the centralized computation on
unicast routing for traffic engineering \cite{Agarwal2013} to improve the network
throughput. Nevertheless, since the routing paths no longer need to be the
shortest ones, the paths can be distributed flexibly inside the network and
thus are more difficult to be aggregated in the flow table of SDN-FE, and
the scalability has been regarded as a serious issue to deploy SDN in a
large network \cite{Agarwal2013, Kanizo2013}.

\begin{figure}[h]
\centering
\subfigure[Original network]{
    \label{fig1:subfig:a}
    \includegraphics[scale=0.50]{Fig1_a}}
\subfigure[Shortest-path tree]{
    \label{fig1:subfig:b}
    \includegraphics[scale=0.50]{Fig1_b}}
\subfigure[Steiner tree]{
    \label{fig1:subfig:c}
    \includegraphics[scale=0.50]{Fig1_c}}
\subfigure[Branch-aware Steiner tree]{
    \label{fig1:subfig:d}
    \includegraphics[scale=0.50]{Fig1_d}}
\caption{An example of multicase tree}
\label{fig1:subfig}
\end{figure}

Multicast is an efficient technique for point-to-multipoint (P2M) and
multipoint-to-multipoint (M2M) communications because it exploits a tree,
instead of disjoint paths, in the routing of the traffic. Current multicast
standard on Internet, i.e., PIM-SM \cite{Fenner2006}, employs a shortest-path tree to
connect the terminal nodes in a multicast group, where a terminal node is a designated router connecting to a LAN with at least one user client joining the group \cite{Cain2002}. Traffic engineering is
difficult to be supported in a shortest-path tree since the path from the
root, i.e., the traffic source in P2M or the rendezvous point in M2M in
PIM-SM, to each destination in the tree is still the shortest path. By contrast, a
Steiner Tree (ST) \cite{Takahashi1980} in Graph Theory is more promising because it minimizes
the network resource consumption, i.e., the number of edges in a tree,
required for a multicast group. However, finding an ST is more computation
intensive and thus is difficult to be deployed as a distributed protocol on
Internet. By contrast, now it becomes feasible by first finding an ST in
SDN-C and then storing the forwarding information in the group tables of
SDN-FEs on the tree.

Similar to unicast traffic engineering in SDN, multicast traffic engineering
also suffers from the scalability problem since each SDN-FE in the tree
needs to store a forwarding entry in the group table for each multicast
group. Nevertheless, the scalability problem for multicast communications is
even more serious since the number of possible multicast group is , where  is the number of nodes in a network, and the number of possible
unicast connections is . To remedy this issue, a promising way is
to exploit the \textit{branch forwarding technique} \cite{Yang2008, YangLiao2008, Tian1998, Stoica2000, Wong2000}, which stores the
entries in only the branch nodes, instead of every node, of a multicast
tree. More specifically, a branch node in a tree is the node with at least
three incident edges, such as white circle nodes in Fig. 1, and the square nodes are the terminal nodes. To
minimize the total number of edges in an ST, the path connecting two
neighboring branch nodes (such as nodes \textit{c} and \textit{y} in Fig. 1(d))
needs to be the shortest path between them. Note that an ST is not a
shortest-path tree because the branch nodes can be located anywhere in the
network. This branch forwarding technique can remedy the multicast
scalability problem since packets are forwarded in a unicast tunnel from the
logic port of a branch node in SDN-FE \cite{OpenFlow2013}. In other words, all nodes
in the path (such as black circle nodes in
Fig. 1) exploit unicast forwarding in the tunnel and are no longer necessary to maintain a forwarding entry for the multicast
group.

To effectively address the multicast scalability problem in SDN, it is
crucial to minimize the number of branch nodes in a tree. However, this
important factor has not been considered in ST. In this paper, therefore, we
propose a new multicast tree for SDN, named \textit{Branch-aware Steiner Tree} (\textit{BST}). The objective of BST problem is to minimize the summation
of the number of edges and the number of branch nodes in the tree, where a
branch node can be assigned a higher weight to further improve the
scalability. Fig. 1 presents an illustrative example with the weight of each
branch node set as 20. Square nodes are the terminal nodes that are required
to be connected in a tree, while the black and white circle nodes are the
other nodes in the network. Fig. 1(a) is the network topology. The
shortest-path tree in Fig. 1(b) includes 27 edges and 7 branch nodes with
the total cost of the tree as . The Steiner tree in Fig.
1(c) has 23 edges and 8 branch nodes with the total cost as . By contrast, Fig. 1(d) presents the BST with 26 edges and 5 branch
nodes and the total cost as . Therefore, compared with the
shortest-path trees on Internet, BST effectively reduces the network
resource consumption by minimizing the number of edges in the tree. Compared
with ST, more BSTs can be supported in SDN since the number of branch nodes
is effectively minimized.

Finding an BST is very challenging. The ST problem is NP-Hard but can be
approximated within ratio 1.55 \cite{Robins2000} and is thus in APX of complexity theory. In other words, there exists an approximation algorithm for ST that can find
a tree with the total cost at most 1.55 times of the optimal solution. By
contrast, we prove that BST is NP-Hard but cannot be approximated within
\textit{k}, which denotes the number of terminal nodes in a multicast group. In
other words, the BST problem is more difficult to be approximated. To
effectively solve BST, we propose a \textit{k}-approximation algorithm,
named \textit{Branch Aware Edge Reduction Algorithm} (BAERA), that can be
deployed in SDN-C. BAERA includes
two phases, Edge Optimization Phase and Branch Optimization Phase, to
effectively minimize the number of edges and branch nodes. Since no -approximation algorithm exists in BST for arbitrarily
small , BAERA achieves the best approximation ratio.

{The rest of this paper is organized as follows. Section II briefly
summarizes the literature on SDN traffic engineering, SDN flow table
scalability, multicast scalability, and the Steiner tree. Section III formally
presents the problem formulation with Integer Programming and the hardness
result. We design a \textit{k}-approximation algorithm in Section IV, and
Section V presents the simulation results to evaluate the performance of the
proposed algorithm in real networks. We conclude this paper in Section VI.}

\section{Related Works}

Previous works have extensively explored the issues on traffic engineering
and flow table scalability for \textit{unicast traffic} in SDN. Mckeown et al. \cite{McKeown2008} pointed out that OpenFlow can
be deployed with heterogeneous switches. Sushant et al. \cite{Sushant2013} shared their experience of SDN development for the private WAN of Google Inc.
Qazi et al. \cite{Qazi2013} proposed a new system design using SDN for the middleboxes (e.g., firewalls, VPN gateways, proxies).
Agarwal et al. \cite{Agarwal2013} considered the incremental deployment of traffic engineering in the case
where a SDN-C controls only a few SDN-FEs in the network, and the rest of
the network adopts a standard routing protocol, such as OSPF. The merits of
traffic engineering brought by only a limited number of SDN-capable nodes
are demonstrated. Mueller et al. \cite{Mueller2013} presented a cross-layer framework
in SDN, which integrates a novel dynamic traffic engineering approach with
an adaptive network management, to bridge the gap between the network and
application layers for overall system optimizations.

On the other hand, flow table scalability is crucial to enable a large-scale
deployment of SDN. For unicast traffic, Kanizo et al. \cite{Kanizo2013} pointed out that
the restriction on table sizes is the major bottleneck in SDN and proposed a
framework, called Palette, to decompose a large SDN table into small ones
and then distribute them across the network. Lee et al. \cite{Lee2013} observed that
Data Center traffic frequently meets few elephant flows and a lot of mice
flows. However, elephant flows are inclined to be evicted because of the
limited flow table sizes. They proposed a differential flow cache framework
that uses a hash-based cache placement and localized Least Recently Used
(LRU)-based replacement to reduce the loss of elephant flows.

The scalability issue is more serious in multicast, and the previous works
\cite{Yang2008}, \cite{YangLiao2008, Tian1998, Stoica2000, Wong2000} have demonstrated that the branch forwarding technique is a promising
way since forwarding from a branch node to a neighbor branch node or terminal node can exploit the
existing unicast tunneling technique, and tunneling can be facilitated in
SDN with logic ports specified in the group table \cite{OpenFlow2013}. In other words, the
intermediate nodes between two neighbor branch routers no longer need to
store a multicast forwarding entry for the tree. However, the above works
were designed for shortest-path trees and did not explore the possibility of more flexible multicast routing. On the other hand, Steiner tree \cite{Takahashi1980} can
effectively minimize the bandwidth consumption in a network, but so far it
is not adopted on Internet since finding the optimal Steiner tree is more
computation intensive and thus difficult to be deployed as a distributed
protocol. To remedy this issue, overlay
Steiner trees \cite{YangL07IPDS, Aharoni1998} for P2P environments are proposed, where only the terminal nodes can
act as branch nodes. Nevertheless, the merit of traffic engineering from the
above work is limited since no other router can act as the branch node to reduce the bandwidth consumption. Moreover,
multicast scalability is not studied in the above works. Therefore, the
above works are difficult for bandwidth-efficient and scalable multicast in
SDN.



\section{Preliminaries}

\subsection{Problem Formulation}

In this paper, we propose a scalable and bandwidth-efficient multicast tree
for SDN, called \textit{Branch-aware Steiner Tree (BST)}. This paper aims to
minimize the bandwidth consumption (i.e., the total number of links/edges)
and the number of forwarding entries maintained for the multicast group
(i.e., the total branch nodes). Therefore, the BST problem is to find a tree
connecting a given set of terminal nodes such that the sum of the number of
edges and the number of branch nodes is minimized, where a branch node can
be assigned a larger weight  to ensure a higher scalability.\footnote{Note that this problem can be simply extended to support different weights
on each edges and each nodes. For example, a congested edge or a node with
the group table almost fulled can be assigned a higher weight.}

\begin{definition}
Consider a network , where  and  denote the set of nodes and
edges, respectively. Given , a terminal node set , and
a non-negative value , the BST problem is to find a tree  spanning the
terminal node set  such that  is minimized, where  is
the number of edges on , and  is
the number of branch nodes (i.e., nodes with the degree at least 3 on ).
\end{definition}

In BST, a network operator can increase the scalability of multicast in SDN by
assigning a larger weight  for branch nodes. Compared with ST,  may
slightly increase, but much fewer branch nodes will be selected in .
Compared with the shortest-path trees adopted on Internet currently, BST
allows more flexible routing of a tree and thus can effectively reduce the
network resource consumption and improve the scalability in SDN.

In the following, we first formulate the BST\ problem as an Integer
Programming problem. Afterwards, we show that the BST problem is very
challenging in complexity theory by proving that it is NP-Hard and not able
to be approximated within  for every .

\subsection{Integer Programming}
\label{subsec:integer_programming}

Let  denote the set of neighbor nodes of  in , and  is in  if  is an edge from  to  in . Let any terminal node  act as the
root of , i.e., the source, and the destination set  contains the other terminals in , i.e., . The output tree  needs to ensure that there is
only one path in  from  to every node in . To achieve this goal,
our problem includes the following binary decision variables. Let binary
variable  denote if edge  is in the path from  to a destination node  in . Let binary variable 
denote if edge  is in , where . Let binary variable  denote if  is a branch node in . Intuitively, when we are able to find the path from  to each destination
node  with  on every edge  in the path, the
routing of the tree with  for every edge  in  can be constructed with the union of the paths from  to all destination
nodes in , and every branch node  in  with  in 
can be identified accordingly.

Most importantly, to guarantee that the union of the paths is a tree, i.e.,
a subgraph without any cycle, the objective function of our Integer
Programming formulation (IP) is as follows.If the tree  contains any cycle,  is not optimal since we are able to
remove at least one edge from the cycle to reduce the objective value, and
ensure that there still exist a path from  to every destination node  in .
To find  and  from , our IP
formulation includes the following constraints.

\begin{center}
\begin{tabular}{cc}
,  & (1)\\
\vspace{2pt}
,  & (2)\\
\vspace{2pt}
, \\ ,  & (3)\\
\vspace{2pt}
, ,  & (4)\\
\vspace{2pt}
,  & (5)\end{tabular}
\end{center}

The first three constraints, i.e., (1), (2), and (3), are the flow-continuity constraints to find the
path from  to every destination node  in . More specifically,  is the
flow source, i.e., the source of the path to every destination node , and
constraint (1) states that the net outgoing flow from  is one, implying
that at least one edge  from  to any neighbor node  needs to
be selected with . Note that here decision variables  and  are two different variables because the flow is
directed. On the other hand, every destination node  is the flow destination,
and constraint (2) ensures that the net incoming flow to  is one,
implying that at least one edge  from any neighbor node  to 
must be selected with . For every other node , constraint
(3) guarantees that  is either located in the path or not. If  is
located in the path, both the incoming flow and outgoing flow for  are at
least one, indicating that at least one binary variable  is 
for the incoming flow, and at least one binary variable  is 
for the outgoing flow. Otherwise, both  and  are
. Note that the objective function will ensure that  for
at most one neighbor node  to achieve the minimum cost. In other words,
both the incoming flow and outgoing flow among  and  cannot exceed .

Constraints (4) and (5) are formulated to find the routing of the tree and
its corresponding branch nodes, i.e.,  and .
Constraint (4) states that  must be  if edge  is
included in the path from  to at least one , i.e., . The tree  is the
union of the paths from  to all destination nodes. Note that here  and  represent the same binary
decision variable because  is not directed. In other words,  if edge  is in a path (i.e., a directed flow) from either
direction. The last constraint is the most crucial one. For each node ,
if the degree of  is at least  in ,  holds, and thus the left-hand-side of
constraint (5) becomes positive, thereby enforcing that  and  acts as a branch node. Otherwise, the left-hand-side of constraint (5)
is  or negative, allowing  to be  to minimize the cost in
the objective function. In this case, node  is not a branch node in .

\subsection{Hardness result}

The BST problem is NP-Hard because it is equivalent to the ST\ problem when  is 0. In other words, the ST problem is a special case of the BST
problem. However, the BST is much more challenging because the ST problem
can be approximated within ratio 1.55 \cite{Robins2000} and is thus in APX in
complexity theory, but we find out that BST is much more difficult to be
approximated. The following theorem proves that the BST problem cannot be
approximated within  for every , by a gap-introducing reduction
from the Hamiltonian path problem, which determines whether there exists a
path going through every node on a graph exactly once.



\begin{theorem}
\label{hardness} For any , there exists no 
approximation algorithm for the BST problem, assuming P  NP.
\end{theorem}

\begin{proof}
We prove the theorem with the gap-introducing reduction from the Hamiltonian
path problem. For an instance  of the Hamiltonian path
problem with any node  on , we build an instance of the BST
problem on , such that \newline
 if a Hamiltonian path starting at  exists in , , and\newline
 if no Hamiltonian path starting at  exists in ,  \newline
, where  is the number of nodes in  and  is the
optimal solution of  for the BST problem.

We first detail how to build the instance of the BST problem from the
Hamiltonian path problem. For any given , we construct a new graph 
which consists of  copies of , where  is the number of
nodes in  and  is the smallest integer following . One additional node  is added to  to connect to the node  of each of the  copies.
The  is set to  and  is set to , where  is the number
of nodes in , i.e., .


If  has a Hamiltonian path starting at , consider a tree rooted at , which
includes 1) the edges between  and  of all copies and 2) the edges on
the Hamiltonian path of all copies. The tree is a feasible solution of the
BST problem with only one branch node , and it can act as an upper bound
of the BST in .
Thus, . On the other hand, if  does
not have a Hamiltonian path starting at , there must exist at least one
additional branch node in each copy of . Hence, . Since  can be
arbitrarily small, for any , there is no 
approximation algorithm for the BST problem, assuming P  NP. The theorem
follows.
\end{proof}

\section{Algorithm Design}

For BST, the shortest-path tree is not a good solution since the shortest
path for each node  in  is constructed individually. With the aim to
minimize the number of the edges, substituting the shortest path of  with a
longer path can reduce the total edge number when the path mostly overlaps
with the path to another node  \cite{Takahashi1980}. Therefore, it is expected
that aggregating two paths that share more common edges can effectively
reduce the number of edges in . Nevertheless, aggregating two paths that
partially overlap will generate a new branch node, and more branch nodes are
inclined to be created when more paths are aggregated. Without considering
the number of branch nodes created, the solution quality may deteriorate
even though the number of edges in  is effectively reduced. In the
following, therefore, we propose a -approximation algorithm for BST,
called \textit{Branch Aware Edge Reduction Algorithm} (BAERA), to jointly
minimize the numbers of edges and branch nodes in . As Theorem~\ref {hardness} proves that no -approximation algorithm for
any  for the BST problem, BAERA achieves the best approximation
ratio. Due to space constraint, the pseudo code is presented in \cite{DBLP}.


BAERA includes two phases: 1) Edge Optimization Phase and 2) Branch
Optimization Phase. In the first phase, BAERA iteratively chooses and adds a
terminal node in  to the solution tree  for constructing
a basic BST, where  and  denote the nodes and edges currently
in , respectively at each itereation. Initially, a random root node is added to .
Afterwards, for each terminal node  that is not in , BAERA
first finds the minimal distance  from  to . Precisely, let  denote the shortest path from  to  on the network , and  is the number of edges in . The
minimal distance  from  to  is , and  here represents the node closest to  in . After finding  for every , BAERA extracts the node 
with the smallest , i.e.,  and adds  to .\footnote{In this paper, we connect  to  via the shortest path.
Nevertheless, it is also allowed to connect  to  with an
alternate path derived according to unicast traffic engineering \cite {Agarwal2013} to meet the unicast traffic requirements.} Most importantly,
to avoid constantly generating a new branch node, BAERA will choose ,
i.e., let the node  connect to  which already acted as a branch node in , if there are multiple  sharing the same minimal distance . Edge Optimization Phase ends when all nodes in  are
added to .

Fig. 2(a) presents an example of Edge Optimization Phase, where node 1 is
the root. Node 2 is first connected to node 1 with 2 edges via node . Node 3 is then connected to  with 3 edges via nodes  and . Node 4 is then connected to  with 2 edges via . Afterwards,
node 5 and node 6 are connected to  sequentially. For node 7
and node 8, note that  and  are both 4 in Fig. 1(a), and considering  will not generate another branch node, therefore node 8
is first connected to  and then node 7 is connected to  via the created branch node .
Afterwards, node 9 and node 10 are connected to  sequentially.

\begin{figure}[t]
\centering
\subfigure[Edge Optimization Phase]{
    \label{fig2:subfig:a}
    \includegraphics[scale=0.50]{Fig2_a}}
\smallskip
\subfigure[Deletion Step]{
    \label{fig2:subfig:b}
    \includegraphics[scale=0.50]{Fig2_b}}
\caption{An example of BAERA (refer to Fig.1)}
\label{fig2:subfig}
\end{figure}

Afterwards, Branch Optimization Phase re-routes the tree  to reduce the
number of branch nodes. Intuitively, if more branch nodes are allowed in , the nodes in  can connect to  with shorter paths, as
the plan in Edge Optimization Phase. Nevertheless, as the weight  of a
branch node increases, it is necessary for a terminal node to pursue a
longer path that directly connects to an existing branch node in  to
avoid creating a new branch node. To address this issue, Branch Optimization
Phase includes two steps: 1) Deletion Step and 2) Alternation Step. Deletion
Step first tries to remove some branch nodes in  obtained from Edge
Optimization Phase, and then Alternation Step tries to iteratively move each of remaining branch nodes to its neighbor node. In the above two steps, the
solution  will be replaced by the new one only if its objective value  is improved (i.e., reduced).

More specifically, Deletion Step first sorts the branch nodes by the ascending order of the
degree in . In other words, a branch node owning fewer neighbor branch
nodes and neighbor terminal nodes\footnote{Herein, the examples for the neighbor terminal node and neighbor branch node are presented. In Fig. 2(b), node 2 is a neighbor terminal node of  because there is
no other branch node or terminal node between them, while node 4 is not the neighbor terminal node of . Node  is a neighbor branch node of , but is not a neighbor branch node of .}
will be examined first because the solution has a higher chance to be
improved.
When a branch node  is removed, because  is partitioned into multiple connected components, 's neighbor branch node and neighbor terminal node will correspond to different
connected components.
Deletion Step will re-route  to the 's closest branch node  in another connected component via its shortest path  to merge the two
connected components.\footnote{If a cycle is created by adding , the longest path between two
neighbor branch nodes in the cycle can be removed.} This process is repeated
such that different connected components will be connected together to
create a new tree.
Fig. 2(b) presents an example of deleting branch node  from Fig. 2(a).
After  is deleted, node 1 and node 2 are re-routed to the other connected component's node  via node . Therefore, the number of
branch nodes can be reduced when Deletion Step ends.

Afterwards, Alternation Step sorts the branch nodes in the ascending order
of the degree again. This step tries to move each branch node  to a
neighbor node . For each neighbor branch node or neighbor terminal
node  of ,  is replaced by .\footnote{Any cycle created by adding  is also necessary to be removed.}
This step will choose the neighbor node  leading to the most
reduction on the objective value , and each branch nodes can be
moved multiple times until no neighbor node is able to reduce the objective
value. The difference between Alternation Step and Deletion Step is that
here every  in different connected component will connect to the same
node (i.e., ), leading to a chance on the reduction of the edge
number. {Fig. 1(d) presents the result of altering branch node } to its
neighbor  in Fig. 2(b). Paths  and  are replaced by
paths  and  with  reduced by .

In the following, we prove that BAERA with the above two phases is a -approximation algorithm if the optimal solution includes at least one
branch node. On the other hands, when the optimal solution has no branch
node, it will become a path, instead of a tree.  We will discuss this case later.


\begin{theorem}
BAERA is a -approximation algorithm for the BST problem.
\label{thm:k_ratio}
\end{theorem}

\begin{proof}
In Edge Optimization Phase, since  is constructed by adding shortest
paths to ,  as explained early in this
section. Because 
and the root node , , where  is
the number of edges in the shortest path from  to . Let 
denote the optimal BST, and  denote number of edges in the
path from  to  on , which may not be the shortest path
between  and  in . In other words, .
Apparently, , and thus we conclude that  after the first phase ends. On the
other hand,  cannot have more than  branch nodes because each step in
this phase creates at most one branch node. Therefore,  since , and the tree  generated in the
first phase is -approximated. Since the second phase re-routes the tree
only if the objective value  can be reduced, the tree 
outputed in the second phase is also -approximated. The theorem follows.
\end{proof}



In the following, we discuss the cases when  the optimal solution has no branch node, i.e., the optimal solution is a path, instead of a tree. Let  denote the optimal BST.

\begin{proposition}
If , then BAERA is a -approximation algorithm.
\label{thm:2k_approx}
\end{proposition}

\begin{proof}
Denote  as the tree generated by BAERA. First, since  is constructed by adding shortest paths to , we know that  according to Theorem~\ref{thm:k_ratio}. Second, since BAERA includes at most one additional branch node in each iteration, there are at most  branch nodes in , i.e., .  In addition, since  connects all terminals in , the number of edges in  must be at least , i.e., . Thus, we obtain . Therefore,  and BAERA is a -approximation algorithm when . The theorem follows.
\end{proof}





BAERA tends to generate a solution with branch nodes. For the case with a large w, we explore another direction that leverages the Hamiltonian path to find a solution with the performance guarantee. In the following, we first introduce the Ore's Theorem~\cite{Ore1960}, and then prove that an Hamiltonian path must exist if the degree of selected nodes are large enough in  Proposition~\ref{thm:no_branch}.

\begin{theorem}[Ore's Theorem]
Let  be a connected simple graph with  vertices.
If for each pair of non-adjacent vertices
 such that ,  contains a Hamiltonian cycle.
\end{theorem}



\begin{proposition}
Assume there exists a connected subgraph  of  and for each pair of non-adjacent vertices , .
If  and , then we can find a Hamiltonian
path  with .
\label{thm:no_branch}
\end{proposition}

\begin{proof}
In the following, we discuss the case when .\footnote{Note that a connected  with  contains two nodes and a link between them, and the Hamiltonian path can be easily derived.} Since  is connected and for each pair of non-adjacent vertices ,  holds,  has a Hamiltonian cycle  according to Ore's Theorem. Thus we can find a path  from  such that the start node and end node are in  and connects all terminal nodes which satisfies . Since  (as mentioned in Proposition~\ref{thm:2k_approx}), we obtain . The theorem follows.
\end{proof}

Note that those  can be obtained by examining dense subgraphs \cite{Khuller09ICALP} or -cores \cite{Seidman1983}. Moreover, if such  exists, the corresponding Hamiltonian Path  could be derived by an existing algorithm \cite{Palmer1997}.

\textbf{Time Complexity. }We first find the shortest path between any two
nodes in  with Johnson's algorithm in  time
as a pre-processing procedure for quickly lookup afterwards. The advantage is
that the preprocessing only needs to be performed once but can be exploited
during the construction of all BSTs afterwards. In each iteration of Edge Optimization Phase, BAERA finds  and extracts  in  time, and this phase
requires  time to connect all terminal nodes to .

In Branch Optimization Phase, let  denote the set of branch nodes in .
Let  denote the maximal degree of a node in , and  and  must hold, where 
is the maximal degree of a node in . Deletion Step first sorts the branch
nodes in the ascending order of the degree in . Since , the
sorting requires  time. We then build a heap for each branch node to store the
shortest-path distance from other branch nodes to  in  time. To
remove a branch node , it is necessary to connect each neighbor
branch node and neighbor terminal node  to the existing closest branch
node  in  in  time. Therefore, Deletion Step takes  time to delete a branch node, and thus  for trying to delete all branch nodes. In Alternation Step, first the branch nodes are sorted in  time.
Then, BAERA tries to move each branch node in order. Note that each branch node  can be moved at most  times, and moving  to a neighbor takes  time. Alternation Step takes  time. Therefore, the time
complexity of Branch Optimization Phase is ,
and BAERA takes  time after the
pre-processing procedure. As shown in Section V later,  is
usually small, and thus the time complexity of BAERA after pre-processing is . Moreover,  in the above analysis represents an upper bound of the cost for scanning the tree . Since the tree size is usually much smaller than , the computation cost is actually close to .

\begin{algorithm}[t]
\caption{Branch Aware Edge Reduction Algorithm (BAERA)}
\label{alg}
\begin{algorithmic}[1]
\REQUIRE {A network , a nonnegative value  and a terminal set .}
\ENSURE {A Steiner tree .}
\STATE{//Edge Optimization Phase}
\STATE{Choose a terminal node  as the root}
\STATE{, , }
\WHILE{}
	\FOR{}
		\STATE{ the minimum distance from  to }
		\STATE{ the shortest path from  to }
	\ENDFOR
	\STATE{}
	\IF{ there exists a  such that  does not generate a new branch node}
		\STATE{}
	\ELSE{}
		\STATE{Choose a  and } 	
	\ENDIF
	\STATE{}		
\ENDWHILE
\STATE{ //The weight of the tree }
\STATE{}
\STATE{//Branch Optimization Phase 1) Deletion Step}
\STATE{Obtain an order  which sorts the branch nodes in the ascending order of the degree in }
\FOR{}
	\STATE{}
	\FOR{neighbor branch node or neighbor terminal node  of }
		\STATE{Reroute the 's closest branch node  in another connected component via its shortest path }
\STATE{}
	\ENDFOR
	\IF{}
		\STATE{ and }
	\ENDIF
\ENDFOR
\STATE{}
\STATE{//Branch Optimization Phase 2) Alternation Step}
\STATE{Obtain an order  which sorts the branch nodes in the ascending order of the degree in }
\FOR{}
	\STATE{}
	\STATE{Choose a neighbor node  of }
	\FOR{neighbor branch node or neighbor terminal node  of }
		\STATE{The shortest path  is replaced by the shortest path }
		\STATE{}
	\ENDFOR
	\IF{}
		\STATE{ and }
	\ENDIF
\ENDFOR
\RETURN{ and }	
\end{algorithmic}
\end{algorithm}

\section{Simulation Results}

In this section, we evaluate BAERA in both real networks and massive
synthetic networks.

\subsection{Simulation Setup}

The simulation is conducted in the following real networks \cite{Zoowebsite}: 1) the Uunet network with 49 nodes and 84 links, and
2) the Deltacom network with 113 nodes and 183 links. Many recent SDN works
\cite{Agarwal2013, Qazi2013} evaluate the proposed approaches in real
networks with at most hundreds of nodes. By contrast, we also evaluate our
algorithm in the networks generated by Inet \cite{Tangmunarunkit2002,
Inetwebsite} with tens of thousands of nodes to test the scalability of
BAERA. In our simulation,  is chosen randomly from .

We compare BAERA with the following algorithms: 1) the shortest-path tree
algorithm (SPT), 2) a Steiner tree (ST) algorithm \cite{Takahashi1980}, and 3)
Integer Programming solver CPLEX \cite{cplexwebsite}, which finds the
optimal solution of the BST problem by solving the Integer Programming
formulation in Section~\ref{subsec:integer_programming}. The performance
metrics include: 1) the objective value of the BST problem , 2)
the number of branch nodes in , 3) the number of edges in , and 4) the
running time. All algorithms are implemented in an HP DL580 server with four
Intel Xeon E7-4870 2.4 GHz CPUs and 128 GB RAM. Each simulation result is
averaged over 100 samples.

\subsection{Small Real Networks}

\begin{figure}[t]
\subfigure[Uunet
network]{\includegraphics[width=1.6in]{figures/1_cplex_uunet}} \subfigure[Deltacom network]{\includegraphics[width=1.6
in]{figures/2_cplex_deltacom}}
\caption{Varied  in different real networks ()}
\label{fig:comparing_with_cplex}
\end{figure}

In this subsection, we compare the performance of BAERA, ST and SPT with the
optimal solutions obtained by CPLEX under different . Since the BST
problem is NP-Hard, CPLEX is able to find the optimal solutions for small
instances of the BST problem, and thus we only find the optimal solutions
for the Uunet and Deltacom networks. As shown in Fig.~\ref {fig:comparing_with_cplex}, the tree  grows and includes more branch
nodes as  increases, because a network is inclined to generate a large
tree. Nevertheless, BAERA outperforms SPT and ST in the two networks since
both the edge number and the branch node number are effectively minimized.
 In addition, the solutions of BAERA are very close to the optimal solutions.

\subsection{Large Synthetic Networks}

\begin{figure}[t]
\subfigure[Objective value in various ]
{\includegraphics[width=1.6in]{figures/3_w_o1}} \subfigure[Number of branch
nodes in various ]{\includegraphics[width=1.6 in]{figures/4_w_b}} \newline
\subfigure[Number of edges in various ]{\includegraphics[width=1.6
in]{figures/5_w_e}} \subfigure[Objective value in various
]{\includegraphics[width=1.6 in]{figures/6_k_o1}} \newline
\subfigure[Number of branch nodes in various ]{\includegraphics[width=1.6
in]{figures/7_k_b}} \subfigure[Number of edges in various
]{\includegraphics[width=1.6 in]{figures/8_k_e}}
\caption{Varied  and  in the synthetic network by Inet}
\label{fig:synthetic_w_k}
\end{figure}

In the following, we evaluate BAERA, ST and SPT in large networks with 10000
nodes generated by Inet. Fig.~\ref{fig:synthetic_w_k}(a), Fig.~\ref {fig:synthetic_w_k}(b), and Fig.~\ref{fig:synthetic_w_k}(c) first discover
the impact of  with  as 200. Fig.~\ref{fig:synthetic_w_k}(a)
demonstrates that the objective value  increases as  grows in
all algorithms. For a larger , BST with BAERA can effectively limit the number of the created branch
nodes by slightly increasing more edges necessarily included to span all terminal nodes in . Nevertheless, BAERA outperforms
SPT and ST, especially for a large , because SPT and ST focus on only the
edge number and thus tend to create a tree with more branch nodes. By
contrast, the number of branch nodes in the solutions obtained by BAERA is
much smaller, but the edge number of BAERA is very close to ST.

Fig.~\ref{fig:synthetic_w_k}(d), Fig.~\ref{fig:synthetic_w_k}(e), and Fig.~\ref{fig:synthetic_w_k}(f) evaluate the impact of  with  as 100. As
shown in Fig.~\ref{fig:synthetic_w_k}(d), the objective value 
becomes larger as  increases, since more branch nodes are necessary to
participate in the tree. BAERA still requires fewer branch nodes from Fig.~\ref{fig:synthetic_w_k}(e). Moreover,
the increment of the objective value in BAERA grows slower than ST and BT,
showing that BAERA can further reduce the total cost in a larger  with the proposed optimization methods.

Table I and Table II evaluate the running time of BAERA with various  and
different Inet graph sizes. The running time of BAERA is too small to be
measured in the Uunet and Deltacom networks for arbitrary . It
demonstrates that the running time of BAERA only slightly grows for a larger , and most instances can be solved around 6 seconds when the network has
10000 nodes. In addition, for a smaller graph, ex. 4000 nodes, BAERA takes
only 1 second. Therefore, BAERA can both achieve a performance bound
(i.e., -approximation) in theory and find a good solution with small time
in practice.

\begin{table}[t]
\caption{The running time of BAERA in different  (=10000)}\centering
\label{table:time_k}
\begin{tabular}{|c|c|c|c|c|}
\hline
 & 100 & 200 & 300 & 400 \\ \hline
Running time (sec.) & 6.064 & 6.418 & 6.816 & 7.430 \\ \hline
\end{tabular}\end{table}

\begin{table}[t]
\caption{The running time of BAERA in different graph sizes ()}\centering
\label{table:time_v}
\begin{tabular}{|c|c|c|c|c|}
\hline
 & 4000 & 6000 & 8000 & 10000 \\ \hline
Running time (sec.) & 1.216 & 2.422 & 4.148 & 6.362 \\ \hline
\end{tabular}\end{table}

\section{Conclusions}
Traffic engineering and flow table scalability have been studied for unicast
traffic in SDN, but those issues in multicast SDN have not been carefully
addressed. In this paper, therefore, we exploited the branch forwarding
technique and proposed Branch-aware Steiner Tree (BST) for SDN. The BST
problem is more difficult since it needs to jointly minimize the edge and
branch node numbers in a tree, and we proved that this problem is NP-Hard
and inapproximable within . To solve this problem, we designed a -approximation algorithm, named Branch Aware Edge Reduction Algorithm
(BAERA). Simulation results manifest that the trees obtained by BAERA
include fewer edges and branch nodes, compared to the shortest-path trees
and Steiner trees. In addition, BAERA is efficient to be deployed in SDN because it can
generate a scalable and bandwidth-efficient multicast tree in massive
networks with only a few seconds.

\linespread{0.98}
\bibliographystyle{IEEEtran}
\bibliography{IEEEabrv,reference}


\end{document}
