\documentclass{article}
\pdfoutput=1




\usepackage[final]{nips_2017}

\usepackage[utf8]{inputenc} \usepackage[T1]{fontenc}    \usepackage{hyperref}       \usepackage{url}            \usepackage{booktabs}       \usepackage{amsfonts}       \usepackage{nicefrac}       \usepackage{microtype}      \usepackage{graphicx}
\usepackage{color}
\usepackage{subfigure} \usepackage{wrapfig} \usepackage{amsmath}
\usepackage{comment}
\usepackage{multirow}

\title{PointNet++: Deep Hierarchical Feature Learning on Point Sets in a Metric Space}




\author{
  Charles R. Qi~~~~~Li Yi~~~~~Hao Su~~~~~Leonidas J. Guibas \\
  Stanford University
}

\newcommand{\hao}[1]{{\textcolor{red}{[\emph{HS}: #1]}}}
\newcommand{\rqi}[1]{{\textcolor{blue}{[\emph{CQ}: #1]}}}
\newcommand{\eric}[1]{{\textcolor{green}{[\emph{EY}: #1]}}}
\newcommand{\todo}[1]{{\textcolor{red}{[\emph{TODO}: #1]}}}


\begin{document}


\maketitle

\begin{abstract}
  

Few prior works study deep learning on point sets.
PointNet~\cite{qi2016pointnet} is a pioneer in this direction. However, by design PointNet does not capture local structures induced by the metric space points live in, limiting its ability to recognize fine-grained patterns and generalizability to complex scenes.
In this work, we introduce a hierarchical neural network that applies PointNet recursively on a nested partitioning of the input point set. By exploiting metric space distances, our network is able to learn local features with increasing contextual scales.
With further observation that point sets are usually sampled with varying densities, which results in greatly decreased performance for networks trained on uniform densities, we propose novel set learning layers to adaptively combine features from multiple scales.
Experiments show that our network called PointNet++ is able to learn deep point set features efficiently and robustly. In particular, results significantly better than state-of-the-art have been obtained on challenging benchmarks of 3D point clouds. \end{abstract}

\section{Introduction}


We are interested in analyzing geometric point sets which are collections of points in a Euclidean space. A particularly important type of geometric point set is point cloud captured by 3D scanners, e.g., from appropriately equipped autonomous vehicles. As a set, such data has to be invariant to permutations of its members. In addition, the distance metric defines local neighborhoods that may exhibit different properties. For example, the density and other attributes of points may not be uniform across different locations --- in 3D scanning the density variability can come from perspective effects, radial density variations, motion, etc.

Few prior works study deep learning on point sets. PointNet~\cite{qi2016pointnet} is a pioneering effort that directly processes point sets. The basic idea of PointNet is to learn a spatial encoding of each point and then aggregate all individual point features to a global point cloud signature.
By its design, PointNet does not capture local structure induced by the metric. However, exploiting local structure has proven to be important for the success of convolutional architectures. A CNN takes data defined on regular grids as the input and is able to progressively capture features at increasingly larger scales along a multi-resolution hierarchy. At lower levels neurons have smaller receptive fields whereas at higher levels they have larger receptive fields. The ability to abstract local patterns along the hierarchy allows better generalizability to unseen cases.

We introduce a hierarchical neural network, named as PointNet++, to process a set of points sampled in a metric space in a hierarchical fashion. The general idea of PointNet++ is simple. We first partition the set of points into overlapping local regions by the distance metric of the underlying space. Similar to CNNs, we extract local features capturing fine geometric structures from small neighborhoods; such local features are further grouped into larger units and processed to produce higher level features. This process is repeated until we obtain the features of the whole point set. 

\begin{wrapfigure}{R}{7cm}
\begin{center}
    \includegraphics[width=7cm]{./fig/raw_scans_wcolor.pdf}
  \end{center}  \caption{Visualization of a scan captured from a Structure Sensor (left: RGB; right: point cloud).}
  \label{fig:rawscans}
\end{wrapfigure}

The design of PointNet++ has to address two issues: how to generate the partitioning of the point set, and how to abstract sets of points or local features through a local feature learner. The two issues are correlated because the partitioning of the point set has to produce common structures across partitions, so that weights of local feature learners can be shared, as in the convolutional setting. We choose our local feature learner to be PointNet. As demonstrated in that work, PointNet is an effective architecture to process an unordered set of points for semantic feature extraction. In addition, this architecture is robust to input data corruption. As a basic building block, PointNet abstracts sets of local points or features into higher level representations. In this view, PointNet++ applies PointNet recursively on a nested partitioning of the input set. 

One issue that still remains is how to generate overlapping partitioning of a point set. Each partition is defined as a neighborhood ball in the underlying Euclidean space, whose parameters include centroid location and scale. To evenly cover the whole set, the centroids are selected among input point set by a farthest point sampling (FPS) algorithm. Compared with volumetric CNNs that scan the space with fixed strides, our local receptive fields are dependent on both the input data and the metric, and thus more efficient and effective. 

Deciding the appropriate scale of local neighborhood balls, however, is a more challenging yet intriguing problem, due to the entanglement of feature scale and non-uniformity of input point set. We assume that the input point set may have variable density at different areas, which is quite common in real data such as Structure Sensor scanning \cite{occipital2016structure} (see Fig.~\ref{fig:rawscans}).  Our input point set is thus very different from CNN inputs which can be viewed as data defined on regular grids with uniform constant density. In CNNs, the counterpart to local partition scale is the size of kernels. \cite{simonyan2014very} shows that using smaller kernels helps to improve the ability of CNNs. Our experiments on point set data, however, give counter evidence to this rule. Small neighborhood may consist of too few points due to sampling deficiency, which might be insufficient to allow PointNets to capture patterns robustly. 

A significant contribution of our paper is that PointNet++ leverages neighborhoods at multiple scales to achieve both robustness and detail capture. Assisted with random input dropout during training, the network learns to adaptively weight patterns detected at different scales and combine multi-scale features according to the input data. Experiments show that our PointNet++ is able to process point sets efficiently and robustly. In particular, results that are significantly better than state-of-the-art have been obtained on challenging benchmarks of 3D point clouds.






















%
 

\section{Problem Statement}
Suppose that  is a discrete metric space whose metric is inherited from a Euclidean space , where  is the set of points and  is the distance metric. In addition, the density of  in the ambient Euclidean space may not be uniform everywhere. We are interested in learning set functions  that take such  as the input (along with additional features for each point) and produce information of semantic interest regrading . In practice, such  can be classification function that assigns a label to  or a segmentation function that assigns a per point label to each member of .




\begin{comment}
\subsection{Properties of Point Sets in Metric Spaces}
\rqi{Shall we shorten this paragraph to fit Section 1 and 2 into the first two pages?}

As a set, points are unordered requiring the network to be permutation invariant to all possible input orders.

Compared with generic sets, points sampled from a metric space have two additional properties:
\begin{itemize}
    \item Point-to-point relations are defined by a metric. While previous works like PointNet and Deep Sets have looked into the problem of learning representations for generic sets, they consider each point in the set as an independent element and relied on the global normalization of points to effectively aggregate point information by a max or average operation. Therefore, the generic set network only learns single point embedding or global point set feature. In our network, we regard the metric distance as first-class citizen and explicitly model point-to-point relations and learn local context features at increasing scales.
    
    \item Variable sampling density in local neighborhoods defined by the metric. While there is no clear definition of sampling density in a generic set, we can define sampling density in point sets sampled from a metric space. There is no guarantee that a model trained or tuned at certain sampling density would perform well at another density at test time. It is also likely that sampling density varies in different regions in the metric space at test time. The model needs to adapt to sampling densities and use its ``best judgement'' to extract useful and reliable features in those regions. 
    
\end{itemize}
\end{comment} 
\section{Method}
\begin{figure}[ht!]
    \vspace{-0.3cm}
    \centering
    \includegraphics[width=0.9\linewidth]{fig/pnpp}
    \caption{Illustration of our hierarchical feature learning architecture and its application for set segmentation and classification using points in 2D Euclidean space as an example. Single scale point grouping is visualized here. For details on density adaptive grouping, see Fig.~\ref{fig:multiscale}}
    \label{fig:pnpp}
    \vspace{-0.5cm}
\end{figure}


Our work can be viewed as an extension of PointNet~\cite{qi2016pointnet} with added hierarchical structure. We first review PointNet (Sec.~\ref{sec:pointnet}) and then introduce a basic extension of PointNet with hierarchical structure (Sec.~\ref{sec:pointnet2}). Finally, we propose our PointNet++ that is able to robustly learn features even in non-uniformly sampled point sets (Sec.~\ref{sec:pointnet2++}).

\vspace{-0.3cm}
\subsection{Review of PointNet~\cite{qi2016pointnet}: A Universal Continuous Set Function Approximator}
\label{sec:pointnet}

Given an unordered point set  with , one can define a set function  that maps a set of points to a vector:
\vspace{-0.3cm}

where  and  are usually multi-layer perceptron (MLP) networks.

The set function  in Eq.~\ref{eq:pointnet} is invariant to input point permutations and can arbitrarily approximate any continuous set function~\cite{qi2016pointnet}. Note that the response of  can be interpreted as the spatial encoding of a point (see \cite{qi2016pointnet} for details). 







PointNet achieved impressive performance on a few benchmarks. However, it lacks the ability to capture local context at different scales. We will introduce a hierarchical feature learning framework in the next section to resolve the limitation.    








\vspace{-0.3cm}
\subsection{Hierarchical Point Set Feature Learning}
\label{sec:pointnet2}


While PointNet uses a single max pooling operation to aggregate the whole point set, our new architecture builds a hierarchical grouping of points and progressively abstract larger and larger local regions along the hierarchy. 

Our hierarchical structure is composed by a number of \emph{set abstraction} levels (Fig.~\ref{fig:pnpp}). At each level, a set of points is processed and abstracted to produce a new set with fewer elements. The set abstraction level is made of three key layers: \emph{Sampling layer}, \emph{Grouping layer} and \emph{PointNet layer}. The \emph{Sampling layer} selects a set of points from input points, which defines the centroids of local regions. \emph{Grouping layer} then constructs local region sets by finding ``neighboring'' points around the centroids. \emph{PointNet layer} uses a mini-PointNet to encode local region patterns into feature vectors.





A set abstraction level takes an  matrix as input that is from  points with -dim coordinates and -dim point feature. It outputs an  matrix of  subsampled points with -dim coordinates and new -dim feature vectors summarizing local context. We introduce the layers of a set abstraction level in the following paragraphs.







\vspace{-0.3cm}
\paragraph{Sampling layer.}
Given input points , we use iterative farthest point sampling (FPS) to choose a subset of points , such that  is the most distant point (in metric distance) from the set  with regard to the rest points. Compared with random sampling, it has better coverage of the entire point set given the same number of centroids. In contrast to CNNs that scan the vector space agnostic of data distribution, our sampling strategy generates receptive fields in a data dependent manner. 





\vspace{-0.3cm}
\paragraph{Grouping layer.}
The input to this layer is a point set of size  and the coordinates of a set of centroids of size . The output are groups of point sets of size , where each group corresponds to a local region and  is the number of points in the neighborhood of centroid points. Note that  varies across groups but the succeeding \emph{PointNet layer} is able to convert flexible number of points into a fixed length local region feature vector.

In convolutional neural networks, a local region of a pixel consists of pixels with array indices within certain Manhattan distance (kernel size) of the pixel. In a point set sampled from a metric space, the neighborhood of a point is defined by metric distance.

Ball query finds all points that are within a radius to the query point (an upper limit of  is set in implementation). An alternative range query is  nearest neighbor (kNN) search which finds a fixed number of neighboring points. Compared with kNN, ball query's local neighborhood guarantees a fixed region scale thus making local region feature more generalizable across space, which is preferred for tasks requiring local pattern recognition (e.g. semantic point labeling).






\vspace{-0.3cm}
\paragraph{PointNet layer.}
In this layer, the input are  local regions of points with data size . Each local region in the output is abstracted by its centroid and local feature that encodes the centroid's neighborhood. Output data size is .

The coordinates of points in a local region are firstly translated into a local frame relative to the centroid point:  for  and  where  is the coordinate of the centroid. We use PointNet~\cite{qi2016pointnet} as described in Sec.~\ref{sec:pointnet} as the basic building block for local pattern learning. By using relative coordinates together with point features we can capture point-to-point relations in the local region.



\vspace{-0.3cm}
\subsection{Robust Feature Learning under Non-Uniform Sampling Density}
\label{sec:pointnet2++}

\begin{wrapfigure}{R}{4cm}
  \vspace{-10pt}
  \begin{center}
    \includegraphics[width=4cm]{./fig/multiscale.pdf}
  \end{center}  \vspace{-15pt}
  \caption{(a) Multi-scale grouping (MSG); (b) Multi-resolution grouping (MRG).}
  \label{fig:multiscale}
\end{wrapfigure}

As discussed earlier, it is common that a point set comes with non-uniform density in different areas. Such non-uniformity introduces a significant challenge for point set feature learning. Features learned in dense data may not generalize to sparsely sampled regions. Consequently, models trained for sparse point cloud may not recognize fine-grained local structures.


Ideally, we want to inspect as closely as possible into a point set to capture finest details in densely sampled regions. However, such close inspect is prohibited at low density areas because local patterns may be corrupted by the sampling deficiency. In this case, we should look for larger scale patterns in greater vicinity. To achieve this goal we propose density adaptive PointNet layers (Fig.~\ref{fig:multiscale}) that learn to combine features from regions of different scales when the input sampling density changes.
We call our hierarchical network with density adaptive PointNet layers as \emph{PointNet++}.


Previously in Sec.~\ref{sec:pointnet2}, each abstraction level contains grouping and feature extraction of a single scale.
In PointNet++, each abstraction level extracts multiple scales of local patterns and combine them intelligently according to local point densities. In terms of grouping local regions and combining features from different scales, we propose two types of density adaptive layers as listed below.\vspace{-0.3cm}
\paragraph{Multi-scale grouping (MSG).} As shown in Fig.~\ref{fig:multiscale} (a), a simple but effective way to capture multi-scale patterns is to apply grouping layers with different scales followed by according PointNets to extract features of each scale. Features at different scales are concatenated to form a multi-scale feature.

We train the network to learn an optimized strategy to combine the multi-scale features. This is done by randomly dropping out input points with a randomized probability for each instance, which we call \emph{random input dropout}. Specifically, for each training point set, we choose a dropout ratio  uniformly sampled from  where . For each point, we randomly drop a point with probability . In practice we set  to avoid generating empty point sets. In doing so we present the network with training sets of various sparsity (induced by ) and varying uniformity (induced by randomness in dropout). During test, we keep all available points.

\vspace{-0.3cm}
\paragraph{Multi-resolution grouping (MRG).} The MSG approach above is computationally expensive since it runs local PointNet at large scale neighborhoods for every centroid point. In particular, since the number of centroid points is usually quite large at the lowest level, the time cost is significant. 

Here we propose an alternative approach that avoids such expensive computation but still preserves the ability to adaptively aggregate information according to the distributional properties of points.
In Fig.~\ref{fig:multiscale} (b), features of a region at some level  is a concatenation of two vectors. One vector (left in figure) is obtained by summarizing the features at each subregion from the lower level  using the set abstraction level. The other vector (right) is the feature that is obtained by directly processing all raw points in the local region using a single PointNet. 

When the density of a local region is low, the first vector may be less reliable than the second vector, since the subregion in computing the first vector contains even sparser points and suffers more from sampling deficiency. In such a case, the second vector should be weighted higher. On the other hand, when the density of a local region is high, the first vector provides information of finer details since it possesses the ability to inspect at higher resolutions recursively in lower levels.



Compared with MSG, this method is computationally more efficient since we avoids the feature extraction in large scale neighborhoods at lowest levels. 
















\vspace{-0.3cm}
\subsection{Point Feature Propagation for Set Segmentation}
In set abstraction layer, the original point set is subsampled. However in set segmentation task such as semantic point labeling, we want to obtain point features for \emph{all} the original points. One solution is to always sample all points as centroids in all set abstraction levels, which however results in high computation cost. Another way is to propagate features from subsampled points to the original points.

We adopt a hierarchical propagation strategy with distance based interpolation and across level skip links (as shown in Fig.~\ref{fig:pnpp}). In a \emph{feature propagation} level, we propagate point features from  points to  points where  and  (with ) are point set size of input and output of set abstraction level . We achieve feature propagation by interpolating feature values  of  points at coordinates of the  points. Among the many choices for interpolation, we use inverse distance weighted average based on  nearest neighbors (as in Eq.~\ref{eq:idw}, in default we use , ). The interpolated features on  points are then concatenated with skip linked point features from the set abstraction level. Then the concatenated features are passed through a ``unit pointnet'', which is similar to one-by-one convolution in CNNs. A few shared fully connected and ReLU layers are applied to update each point's feature vector. The process is repeated until we have propagated features to the original set of points.

\vspace{-0.3cm}
 
\section{Experiments}
\label{sec:exp}

\vspace{-0.15cm}
\paragraph{Datasets} We evaluate on four datasets ranging from 2D objects (MNIST~\cite{lecun1998gradient}), 3D objects (ModelNet40~\cite{wu20153d} rigid object, SHREC15~\cite{3dor.20151064} non-rigid object) to real 3D scenes (ScanNet~\cite{dai2017scannet}). Object classification is evaluated by accuracy.
Semantic scene labeling is evaluated by average voxel classification accuracy following \cite{dai2017scannet}. We list below the experiment setting for each dataset:
\begin{itemize}
    \item MNIST: Images of handwritten digits with 60k training and 10k testing samples.
    \item ModelNet40: CAD models of 40 categories (mostly man-made). We use the official split with 9,843 shapes for training and 2,468 for testing.
    \item SHREC15: 1200 shapes from 50 categories. Each category contains 24 shapes which are mostly organic ones with various poses such as horses, cats, etc. We use five fold cross validation to acquire classification accuracy on this dataset.
\item ScanNet: 1513 scanned and reconstructed indoor scenes. We follow the experiment setting in~\cite{dai2017scannet} and use 1201 scenes for training, 312 scenes for test.
\end{itemize}


\vspace{-0.3cm}
\subsection{Point Set Classification in Euclidean Metric Space}

We evaluate our network on classifying point clouds sampled from both 2D (MNIST) and 3D (ModleNet40) Euclidean spaces. MNIST images are converted to 2D point clouds of digit pixel locations. 3D point clouds are sampled from mesh surfaces from ModelNet40 shapes. In default we use 512 points for MNIST and 1024 points for ModelNet40. In last row (ours normal) in Table~\ref{tab:modelnet}, we use face normals as additional point features, where we also use more points () to further boost performance. All point sets are normalized to be zero mean and within a unit ball. We use a three-level hierarchical network with three fully connected layers~\footnote{See supplementary for more details on network architecture and experiment preparation.}











\vspace{-0.3cm}
\paragraph{Results.} In Table~\ref{tab:mnist} and Table~\ref{tab:modelnet}, we compare our method with a representative set of previous state of the arts. Note that PointNet (vanilla) in Table~\ref{tab:modelnet} is the the version in~\cite{qi2016pointnet} that does not use transformation networks, which is equivalent to our hierarchical net with only one level.

Firstly, our hierarchical learning architecture achieves significantly better performance than the non-hierarchical PointNet~\cite{qi2016pointnet}. In MNIST, we see a relative 60.8\% and 34.6\% error rate reduction from PointNet (vanilla) and PointNet to our method. In ModelNet40 classification, we also see that using same input data size (1024 points) and features (coordinates only), ours is remarkably stronger than PointNet.
Secondly, we observe that point set based method can even achieve better or similar performance as mature image CNNs. In MNIST, our method (based on 2D point set) is achieving an accuracy close to the Network in Network CNN. In ModelNet40, ours with normal information significantly outperforms previous state-of-the-art method MVCNN~\cite{su15mvcnn}. 

\begin{table}[t!]
    \begin{minipage}{.45\textwidth}
        \centering
        \small
        \begin{tabular}{lc}
        \toprule
        Method     & Error rate (\%) \\
        \midrule
        Multi-layer perceptron~\cite{simard2003best} & 1.60     \\
        LeNet5~\cite{lecun1998gradient}     & 0.80      \\
        Network in Network~\cite{lin2013network}      & \textbf{0.47} \\
PointNet (vanilla)~\cite{qi2016pointnet}    & 1.30  \\
        PointNet~\cite{qi2016pointnet}    & 0.78  \\ \midrule
        Ours    & 0.51 \\
        \bottomrule
        \end{tabular}
        \caption{MNIST digit classification.}
        \label{tab:mnist}
    \end{minipage}
    \begin{minipage}{.55\textwidth}
        \centering
        \small
        \begin{tabular}[width=\linewidth]{lcccc}
        \toprule
        Method  & Input & Accuracy (\%) \\
        \midrule
Subvolume~\cite{qi2016volumetric} &vox & 89.2 \\
MVCNN~\cite{su15mvcnn} &img & 90.1 \\
PointNet (vanilla)~\cite{qi2016pointnet} &pc & 87.2 \\
        PointNet~\cite{qi2016pointnet} &pc & 89.2 \\ \midrule
        Ours  &pc & 90.7 \\ 
        Ours (with normal)   &pc&  \textbf{91.9} \\
        \bottomrule
        \end{tabular}
        \caption{ModelNet40 shape classification.}
        \label{tab:modelnet}
    \end{minipage}
  \end{table}

\vspace{-0.3cm}
\paragraph{Robustness to Sampling Density Variation.}
Sensor data directly captured from real world usually suffers from severe irregular sampling issues (Fig.~\ref{fig:rawscans}).
Our approach selects point neighborhood of multiple scales and learns to balance the descriptiveness and robustness by properly weighting them. 

\begin{figure}[t!]
\vspace{-0.5cm}
\centering
\begin{subfigure}
\centering
\includegraphics[width=0.45\linewidth,height=3cm]{./fig/chairs}
\end{subfigure}
\begin{subfigure}
\centering
\includegraphics[width=0.5\linewidth]{./fig/robustness3}
\end{subfigure}
\caption{Left: Point cloud with random point dropout. Right: Curve showing advantage of our density adaptive strategy in dealing with non-uniform density. DP means random input dropout during training; otherwise training is on uniformly dense points. See~Sec.\ref{sec:pointnet2++} for details.}
\label{fig:rb_classification}
\vspace{-0.5cm}
\end{figure}


We randomly drop points (see Fig.~\ref{fig:rb_classification} left) during test time to validate our network's robustness to non-uniform and sparse data.
In Fig.~\ref{fig:rb_classification} right, we see MSG+DP (multi-scale grouping with random input dropout during training) and MRG+DP (multi-resolution grouping with random input dropout during training) are very robust to sampling density variation. MSG+DP performance drops by less than  from  to  test points. Moreover, it achieves the best performance on almost all sampling densities compared with alternatives.
PointNet vanilla \cite{qi2016pointnet} is fairly robust under density variation due to its focus on global abstraction rather than fine details. However loss of details also makes it less powerful compared to our approach.
SSG (ablated PointNet++ with single scale grouping in each level) fails to generalize to sparse sampling density while SSG+DP amends the problem by randomly dropping out points in training time.


\vspace{-0.3cm}
\subsection{Point Set Segmentation for Semantic Scene Labeling}






\begin{wrapfigure}{R}{7cm}
  \vspace{-10pt}
  \begin{center}
    \includegraphics[width=7cm]{./fig/sceneseg_larger_wmrg.pdf}
  \end{center}  \vspace{-15pt}
  \caption{Scannet labeling accuracy. }
  \label{fig:sceneseg}
\end{wrapfigure}

To validate that our approach is suitable for large scale point cloud analysis, we also evaluate on semantic scene labeling task. The goal is to predict semantic object label for points in indoor scans. \cite{dai2017scannet} provides a baseline using fully convolutional neural network on voxelized scans. They purely rely on scanning geometry instead of RGB information and report the accuracy on a per-voxel basis. To make a fair comparison, we remove RGB information in all our experiments and convert point cloud label prediction into voxel labeling following \cite{dai2017scannet}.
We also compare with \cite{qi2016pointnet}. The accuracy is reported on a per-voxel basis in Fig.~\ref{fig:sceneseg} (blue bar).

Our approach outperforms all the baseline methods by a large margin. In comparison with \cite{dai2017scannet}, which learns on voxelized scans, we directly learn on point clouds to avoid additional quantization error, and conduct data dependent sampling to allow more effective learning. Compared with \cite{qi2016pointnet}, our approach introduces hierarchical feature learning and captures geometry features at different scales. This is very important for understanding scenes at multiple levels and labeling objects with various sizes.
We visualize example scene labeling results in Fig.~\ref{fig:sceneseg_vis}.


\begin{wrapfigure}{R}{6.5cm}
  \vspace{-10pt}
  \begin{center}
    \includegraphics[width=6.5cm]{./fig/sceneseg_vis.pdf}
  \end{center}  \vspace{-15pt}
  \caption{Scannet labeling results. \cite{qi2016pointnet} captures the overall layout of the room correctly but fails to discover the furniture. Our approach, in contrast, is much better at segmenting objects besides the room layout.}
  \label{fig:sceneseg_vis}
  \vspace{-0.3cm}
\end{wrapfigure}





\vspace{-0.3cm}
\paragraph{Robustness to Sampling Density Variation}
To test how our trained model performs on scans with non-uniform sampling density, we synthesize virtual scans of Scannet scenes similar to that in Fig.~\ref{fig:rawscans} and evaluate our network on this data. We refer readers to supplementary material for how we generate the virtual scans.
We evaluate our framework in three settings (SSG, MSG+DP, MRG+DP) and compare with a baseline approach \cite{qi2016pointnet}.


Performance comparison is shown in Fig.~\ref{fig:sceneseg} (yellow bar). We see that SSG performance greatly falls due to the sampling density shift from uniform point cloud to virtually scanned scenes. MRG network, on the other hand, is more robust to the sampling density shift since it is able to automatically switch to features depicting coarser granularity when the sampling is sparse. Even though there is a domain gap between training data (uniform points with random dropout) and scanned data with non-uniform density, our MSG network is only slightly affected and achieves the best accuracy among methods in comparison. These prove the effectiveness of our density adaptive layer design.






\vspace{-0.3cm}
\subsection{Point Set Classification in Non-Euclidean Metric Space}

In this section, we show generalizability of our approach to non-Euclidean space. In non-rigid shape classification (Fig.~\ref{fig:intrinsic_shape_diff}), a good classifier should be able to classify  and  in Fig.~\ref{fig:intrinsic_shape_diff} correctly as the same category even given their difference in pose, which requires knowledge of intrinsic structure.
Shapes in SHREC15 are 2D surfaces embedded in 3D space. Geodesic distances along the surfaces naturally induce a metric space. We show through experiments that adopting PointNet++ in this metric space is an effective way to capture intrinsic structure of the underlying point set.

\begin{wrapfigure}{R}{4.5cm}
  \vspace{-15pt}
  \begin{center}
    \includegraphics[width=4.5cm]{./fig/intrinsic_shape_diff.png}
  \end{center}  \vspace{-15pt}
  \caption{An example of non-rigid shape classification.}
  \label{fig:intrinsic_shape_diff}
\end{wrapfigure}

For each shape in \cite{3dor.20151064}, we firstly construct the metric space induced by pairwise geodesic distances. We follow \cite{rustamov2009interior} to obtain an embedding metric that mimics geodesic distance. Next we extract intrinsic point features in this metric space including WKS \cite{aubry2011wave}, HKS \cite{sun2009concise} and multi-scale Gaussian curvature \cite{meyer2002discrete}. We use these features as input and then sample and group points according to the underlying metric space. In this way, our network learns to capture multi-scale intrinsic structure that is not influenced by the specific pose of a shape. Alternative design choices include using  coordinates as points feature or use Euclidean space  as the underlying metric space. We show below these are not optimal choices.



\vspace{-0.3cm}
\paragraph{Results.}  
We compare our methods with previous state-of-the-art method \cite{luciano2017deep} in Table~\ref{tab:nonrigid_classification}. \cite{luciano2017deep} extracts geodesic moments as shape features and use a stacked sparse autoencoder to digest these features to predict shape category.
Our approach using non-Euclidean metric space and intrinsic features achieves the best performance in all settings and outperforms \cite{luciano2017deep} by a large margin.

Comparing the first and second setting of our approach, we see intrinsic features are very important for non-rigid shape classification.  feature fails to reveal intrinsic structures and is greatly influenced by pose variation.
Comparing the second and third setting of our approach, we see using geodesic neighborhood is beneficial compared with Euclidean neighborhood. Euclidean neighborhood might include points far away on surfaces and this neighborhood could change dramatically when shape affords non-rigid deformation. This introduces difficulty for effective weight sharing since the local structure could become combinatorially complicated. Geodesic neighborhood on surfaces, on the other hand, gets rid of this issue and improves the learning effectiveness.


\begin{table}[h!]
\centering
\small
\begin{tabular}{lccc}
\toprule
& Metric space & Input feature & Accuracy (\%) \\ \midrule
DeepGM \cite{luciano2017deep} & - & Intrinsic features & 93.03 \\ \midrule
\multirow{3}{*}{Ours} & Euclidean & XYZ & 60.18\\
& Euclidean & Intrinsic features & 94.49\\
& Non-Euclidean & Intrinsic features & \textbf{96.09}\\\bottomrule
\end{tabular}
\caption{SHREC15 Non-rigid shape classification.}
\label{tab:nonrigid_classification}
\vspace{-0.7cm}
\end{table}

\subsection{Feature Visualization.}

\begin{wrapfigure}{R}{6cm}
  \vspace{-15pt}
  \begin{center}
    \includegraphics[width=6cm]{./fig/features.pdf}
  \end{center} 
  \caption{3D point cloud patterns learned from the first layer kernels. The model is trained for ModelNet40 shape classification (20 out of the 128 kernels are randomly selected). Color indicates point depth (red is near, blue is far). } \vspace{-25pt}
  \label{fig:visu}
  \vspace{-0.6cm}
\end{wrapfigure}

In Fig.~\ref{fig:visu} we visualize what has been learned by the first level kernels of our hierarchical network. We created a voxel grid in space and aggregate local point sets that activate certain neurons the most in grid cells (highest 100 examples are used). Grid cells with high votes are kept and converted back to 3D point clouds, which represents the pattern that neuron recognizes. Since the model is trained on ModelNet40 which is mostly consisted of furniture, we see structures of planes, double planes, lines, corners etc. in the visualization.






 
\vspace{-0.1cm}
\section{Related Work}
The idea of hierarchical feature learning has been very successful. Among all the learning models, convolutional neural network \cite{krizhevsky2012imagenet,simonyan2014very,he2016deep} is one of the most prominent ones.
However, convolution does not apply to unordered point sets with distance metrics, which is the focus of our work.

A few very recent works \cite{qi2016pointnet,vinyals2015order} have studied how to apply deep learning to unordered sets. They ignore the underlying distance metric even if the point set does possess one. As a result, they are unable to capture local context of points and are sensitive to global set translation and normalization. In this work, we target at points sampled from a metric space and tackle these issues by explicitly considering the underlying distance metric in our design.

Point sampled from a metric space are usually noisy and with non-uniform sampling density. This affects effective point feature extraction and causes difficulty for learning. One of the key issue is to select proper scale for point feature design. Previously several approaches have been developed regarding this \cite{pauly2006point, mitra2004estimating, belton2006classification,demantke2011dimensionality, gressin2013towards,weinmann2015semantic} either in geometry processing community or photogrammetry and remote sensing community.
In contrast to all these works, our approach learns to extract point features and balance multiple feature scales in an end-to-end fashion.

In 3D metric space, other than point set, there are several popular representations for deep learning, including volumetric grids \cite{qi2016volumetric,riegler2016octnet,wang2017cnn}, and geometric graphs \cite{bruna2013spectral,masci2015geodesic,yi2016syncspeccnn}. However, in none of these works, the problem of non-uniform sampling density has been explicitly considered.













%
 
\vspace{-0.1cm}
\section{Conclusion}
In this work, we propose PointNet++, a powerful neural network architecture for processing point sets sampled in a metric space. PointNet++ recursively functions on a nested partitioning of the input point set, and is effective in learning hierarchical features with respect to the distance metric. To handle the non uniform point sampling issue, we propose two novel set abstraction layers that intelligently aggregate multi-scale information according to local point densities. These contributions enable us to achieve state-of-the-art performance on challenging benchmarks of 3D point clouds.

In the future, it's worthwhile thinking how to accelerate inference speed of our proposed network especially for MSG and MRG layers by sharing more computation in each local regions. It's also interesting to find applications in higher dimensional metric spaces where CNN based method would be computationally unfeasible while our method can scale well.
%
 \vspace{-0.1cm}
{\small
\bibliographystyle{ieee}
\bibliography{pcl}
}
\newpage
\appendix
\section*{Supplementary}

\section{Overview}
This supplementary material provides more details on experiments in the main paper and includes more experiments to validate and analyze our proposed method.

In Sec~\ref{supp_details} we provide specific network architectures used for experiments in the main paper and also describe details in data preparation and training. In Sec~\ref{supp_exp} we show more experimental results including benchmark performance on part segmentation and analysis on neighborhood query, sensitivity to sampling randomness and time space complexity.

\section{Details in Experiments}
\label{supp_details}
\paragraph{Architecture protocol.}
We use following notations to describe our network architecture.

SA(,,[]) is a set abstraction (SA) level with  local regions of ball radius  using PointNet of  fully connected layers with width  (). SA([]) is a global set abstraction level that converts set to a single vector. In multi-scale setting (as in MSG), we use SA(, [], [[],...,[]]) to represent MSG with  scales.

FC(,) represents a fully connected layer with width  and dropout ratio . FP() is a feature propagation (FP) level with  fully connected layers. It is used for updating features concatenated from interpolation and skip link. All fully connected layers are followed by batch normalization and ReLU except for the last score prediction layer.

\subsection{Network Architectures}
For all classification experiments we use the following architecture (Ours SSG) with different  (number of categories):


The multi-scale grouping (MSG) network (PointNet++) architecture is as follows:


The cross level multi-resolution grouping (MRG) network's architecture uses three branches:

~~~~~~~~~~~~~~~~Branch 1: 

~~~~~~~~~~~~~~~~Branch 2:  using  regions of original points

~~~~~~~~~~~~~~~~Branch 3:  using all original points.

~~~~~~~~~~~~~~~~Branch 4: . 

Branch 1 and branch 2 are concatenated and fed to branch 4. Output of branch 3 and branch4 are then concatenated and fed to  for classification. 


Network for semantic scene labeling (last two fully connected layers in FP are followed by dropout layers with drop ratio 0.5):



Network for semantic and part segmentation (last two fully connected layers in FP are followed by dropout layers with drop ratio 0.5):


\subsection{Virtual Scan Generation}
In this section, we describe how we generate labeled virtual scan with non-uniform sampling density from ScanNet scenes. For each scene in ScanNet, we set camera location  above the centroid of the floor plane and rotate the camera orientation in the horizontal plane evenly in  directions. In each direction, we use a image plane with size  by  and cast rays from camera through each pixel to the scene. This gives a way to select visible points in the scene. We could then generate  virtual scans for each test scene similar and an example is shown in Fig.~\ref{fig:virtual_scan}. Notice point samples are denser in regions closer to the camera.

\begin{figure}[h!]
  \begin{center}
    \includegraphics[width=0.5\linewidth]{./fig/virtual_scan.pdf}
  \end{center}
  \caption{Virtual scan generated from ScanNet}
  \label{fig:virtual_scan}
\end{figure}

\subsection{MNIST and ModelNet40 Experiment Details}
For MNIST images, we firstly normalize all pixel intensities to range  and then select all pixels with intensities larger than 0.5 as valid digit pixels. Then we convert digit pixels in an image into a 2D point cloud with coordinates within , where the image center is the origin point. Augmented points are created to add the point set up to a fixed cardinality (512 in our case). We jitter the initial point cloud (with random translation of Gaussian distribution  and clipped to 0.03) to generate the augmented points. For ModelNet40, we uniformly sample  points from CAD models surfaces based on face area.

For all experiments, we use Adam~\cite{adam} optimizer with learning rate 0.001 for training. For data augmentation, we randomly scale object, perturb the object location as well as point sample locations. We also follow~\cite{qi2016volumetric} to randomly rotate objects for ModelNet40 data augmentation. We use TensorFlow and GTX 1080, Titan X for training. All layers are implemented in CUDA to run GPU. It takes around 20 hours to train our model to convergence.


\subsection{ScanNet Experiment Details}
To generate training data from ScanNet scenes, we sample 1.5m by 1.5m by 3m cubes from the initial scene and then keep the cubes where  of the voxels are occupied and  of the surface voxels have valid annotations (this is the same set up in \cite{dai2017scannet}). We sample such training cubes on the fly and random rotate it along the up-right axis. Augmented points are added to the point set to make a fixed cardinality (8192 in our case). During test time, we similarly split the test scene into smaller cubes and get label prediction for every point in the cubes first, then merge label prediction in all the cubes from a same scene. If a point get different labels from different cubes, we will just conduct a majority voting to get the final point label prediction.

\subsection{SHREC15 Experiment Details}
We randomly sample 1024 points on each shape both for training and testing. To generate the input intrinsic features, we 
to extract 100 dimensional WKS, HKS and multiscale Gaussian curvature respectively, leading to a 300 dimensional feature vector for each point. Then we conduct PCA to reduce the feature dimension to 64. We use a 8 dimensional embedding following \cite{rustamov2009interior} to mimic the geodesic distance, which is used to describe our non-Euclidean metric space while choosing the point neighborhood.

\section{More Experiments}
\label{supp_exp}
In this section we provide more experiment results to validate and analyze our proposed network architecture. 

\subsection{Semantic Part Segmentation}
Following the setting in \cite{Yi16}, we evaluate our approach on part segmentation task assuming category label for each shape is already known. Taken shapes represented by point clouds as input, the task is to predict a part label for each point. The dataset contains 16,881 shapes from 16 classes, annotated with 50 parts in total. We use the official train test split following~\cite{shapenet2015}.

We equip each point with its normal direction to better depict the underlying shape. This way we could get rid of hand-crafted geometric features as is used in \cite{Yi16,yi2016syncspeccnn}. 
We compare our framework with traditional learning based techniques \cite{Yi16}, as well as state-of-the-art deep learning approaches \cite{qi2016pointnet,yi2016syncspeccnn} in Table~\ref{tab:partseg}. Point intersection over union (IoU) is used as the evaluation metric, averaged across all part classes. Cross-entropy loss is minimized during training. On average, our approach achieves the best performance. In comparison with \cite{qi2016pointnet}, our approach performs better on most of the categories, which proves the importance of hierarchical feature learning for detailed semantic understanding. Notice our approach could be viewed as implicitly building proximity graphs at different scales and operating on these graphs, thus is related to graph CNN approaches such as \cite{yi2016syncspeccnn}. Thanks to the flexibility of our multi-scale neighborhood selection as well as the power of set operation units, we could achieve better performance compared with \cite{yi2016syncspeccnn}. Notice our set operation unit is much simpler compared with graph convolution kernels, and we do not need to conduct expensive eigen decomposition as opposed to \cite{yi2016syncspeccnn}. These make our approach more suitable for large scale point cloud analysis.
\begin{table}[th!]
    \scriptsize
    \centering
    \begin{tabular}[width=\linewidth]{l|c|p{0.3cm}p{0.25cm}p{0.25cm}p{0.25cm}p{0.25cm}p{0.3cm}p{0.3cm}p{0.3cm}p{0.3cm}p{0.4cm}p{0.4cm}p{0.25cm}p{0.3cm}p{0.3cm}p{0.35cm}p{0.3cm}}
    \toprule
    ~        & mean & aero & bag & cap & car & chair & ear phone & guitar & knife & lamp & laptop & motor & mug & pistol & rocket & skate board& table \\ 
    \midrule
Yi~\cite{Yi16} & 81.4 & 81.0 & 78.4 & 77.7 & 75.7 & 87.6 & 61.9 & 92.0 & 85.4 & 82.5 & 95.7 & 70.6 & 91.9 & 85.9 & 53.1 & 69.8 & 75.3 \\
PN~\cite{qi2016pointnet} & 83.7 & 83.4 & 78.7 & 82.5 & 74.9 & 89.6 & 73.0 & 91.5 & 85.9 & 80.8 & 95.3 & 65.2 & 93.0 & 81.2 & 57.9 & 72.8 & 80.6 \\
    SSCNN~\cite{yi2016syncspeccnn} & 84.7 & 81.6 & 81.7 & 81.9 & 75.2 & 90.2 & 74.9 & 93.0 & 86.1 & 84.7 & 95.6 & 66.7 & 92.7 & 81.6 & 60.6 & 82.9 & 82.1 \\
    \midrule
    Ours & 85.1 & 82.4 & 79.0 & 87.7 & 77.3 & 90.8 & 71.8 & 91.0 & 85.9 & 83.7 & 95.3 & 71.6 & 94.1 & 81.3 & 58.7 & 76.4 & 82.6 \\
    \bottomrule
    \end{tabular}
    \caption{Segmentation results on ShapeNet part dataset.}
    \label{tab:partseg}
\end{table}

\subsection{Neighborhood Query: kNN v.s. Ball Query.}
Here we compare two options to select a local neighborhood. We used radius based ball query in our main paper. Here we also experiment with kNN based neighborhood search and also play with different search radius and . In this experiment all training and testing are on ModelNet40 shapes with uniform sampling density. 1024 points are used. As seen in Table~\ref{tab:neighborhood}, radius based ball query is slightly better than kNN based method. However, we speculate in very non-uniform point set, kNN based query will results in worse generalization ability. Also we observe that a slightly large radius is helpful for performance probably because it captures richer local patterns.

\begin{table}[h!]
\centering
\begin{tabular}{cccc}
\toprule
kNN (k=16) & kNN (k=64) & radius (r=0.1) & radius (r=0.2) \\ \midrule
89.3 & 90.3 & 89.1 & 90.7 \\ \bottomrule
\end{tabular}
\caption{Effects of neighborhood choices. Evaluation metric is classification accuracy (\%) on ModelNet 40 test set.}
\label{tab:neighborhood}
\end{table}



\begin{comment}
\paragraph{Effect of Input Set Density (number of points).}
\begin{table}[h!]
\centering
\begin{tabular}{cccc}
\toprule
512 & 1024 & 2048 & 4096 \\ \midrule
89.83 & 90.7 & 90.44 & 89.5 \\ \bottomrule
\end{tabular}
\caption{\todo{Effects of number of points/set sampling density (using ModelNet40).}}
\end{table}
\end{comment}

\subsection{Effect of Randomness in Farthest Point Sampling.}
For the \emph{Sampling layer} in our set abstraction level, we use farthest point sampling (FPS) for point set sub sampling. However FPS algorithm is random and the subsampling depends on which point is selected first. Here we evaluate the sensitivity of our model to this randomness. In Table~\ref{tab:fps}, we test our model trained on ModelNet40 for feature stability and classification stability.

To evaluate feature stability we extract global features of all test samples for 10 times with different random seed. Then we compute mean features for each shape across the 10 sampling. Then we compute standard deviation of the norms of feature's difference from the mean feature. At last we average all std. in all feature dimensions as reported in the table. Since features are normalized into 0 to 1 before processing, the 0.021 difference means a 2.1\% deviation of feature norm.

For classification, we observe only a 0.17\% standard deviation in test accuracy on all ModelNet40 test shapes, which is robust to sampling randomness.
\begin{table}[h!]
\centering
\begin{tabular}{cc}
\toprule
Feature difference std. & Accuracy std. \\ \midrule
 0.021 & 0.0017\\ \bottomrule
\end{tabular}
\caption{Effects of randomness in FPS (using ModelNet40). }
\label{tab:fps}
\end{table}




\subsection{Time and Space Complexity.}

Table~\ref{tab:timespace} summarizes comparisons of time and space cost between a few point set based deep learning method. We record forward time with a batch size 8 using TensorFlow 1.1 with a single GTX 1080. The first batch is neglected since there is some preparation for GPU. While PointNet (vanilla)~\cite{qi2016pointnet} has the best time efficiency, our model without density adaptive layers achieved smallest model size with fair speed.

It's worth noting that ours MSG, while it has good performance in non-uniformly sampled data, it's 2x expensive than SSG version due the multi-scale region feature extraction. Compared with MSG, MRG is more efficient since it uses regions across layers.

\begin{table}[h]
    \centering
    \small
    \begin{tabular}{lccccc}
        \toprule
        & PointNet (vanilla)~\ref{eq:pointnet} & PointNet~\ref{eq:pointnet} & Ours (SSG) & Ours (MSG) & Ours (MRG) \\ \midrule
        Model size (MB) & 9.4 & 40 & 8.7 & 12 & 24 \\
        Forward time (ms) & 11.6 & 25.3 & 82.4& 163.2& 87.0\\
        \bottomrule
    \end{tabular}
    \caption{Model size and inference time (forward pass) of several networks.}
    \label{tab:timespace}
\end{table} \end{document}