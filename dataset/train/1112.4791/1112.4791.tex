\pdfoutput = 1
\documentclass[11pt]{article}
\usepackage{url}
\usepackage{graphicx}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{latexsym}
\usepackage{color}
\usepackage{enumerate}
\usepackage{hyperref}

\topmargin 0in              \headheight 0pt                 \headsep 0in                    \textheight 9in              

\textwidth 6.5in
\oddsidemargin 0in              

\newcommand{\notyet}[1]{}
\newcommand{\squeezelist}{\setlength{\itemsep}{0pt}}
\newcommand\R{\mathbb{R}}
\newcommand\red[1]{\textcolor{red}{#1}}
\newcommand\blue[1]{\textcolor{blue}{#1}}






\newcommand{\ABox}{
\raisebox{3pt}{\framebox[6pt]{\rule{6pt}{0pt}}}
}
\newenvironment{proof}{{\bf Proof:}}{\hfill\ABox}

\newtheorem{theorem}{{\bf Theorem}}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{claim}[theorem]{Claim}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{conjecture}[theorem]{Conjecture}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{openquestion}[theorem]{Open question}

{\makeatletter
 \gdef\xxxmark{\expandafter\ifx\csname @mpargs\endcsname\relax \expandafter\ifx\csname @captype\endcsname\relax \marginpar{xxx}\else
       xxx \fi
   \else
     xxx \fi}
 \gdef\xxx{\@ifnextchar[\xxx@lab\xxx@nolab}
 \long\gdef\xxx@lab[#1]#2{{\bf [\xxxmark #2 ---{\sc #1}]}}
 \long\gdef\xxx@nolab#1{{\bf [\xxxmark #1]}}
\gdef\turnoffxxx{\long\gdef\xxx@lab[##1]##2{}\long\gdef\xxx@nolab##1{}}}

\def\P{{\mathcal P}}
\def\bP{{\partial P}}
\def\bI{{\partial I}}
\def\bU{{\partial U}}


\def\nothing{\ast}

\begin{document}

\title{Unfolding Orthogonal Polyhedra with Quadratic Refinement:\\
The Delta-Unfolding Algorithm}
\author{Mirela Damian\thanks{Dept. of Computing Sciences, Villanova University, Villanova,
    PA 19085, USA.
   \protect\url{mirela.damian@villanova.edu}.}
\and
Erik D. Demaine\thanks{Computer Science and Artificial Intelligence Laboratory,
       Massachusetts Institute of Technology,
       32 Vassar St., Cambridge, MA 02139, USA. \protect\url{edemaine@mit.edu}.
       Partially supported by NSF CAREER award CCF-0347776.}
\and
Robin Flatland\thanks{Dept. of Computer Science, Siena College, Loudonville, NY 12211, USA.
    \protect\url{flatland@siena.edu}.}
}

\date{}
\maketitle

\begin{abstract}
  We show that every orthogonal polyhedron homeomorphic to a sphere can be
  unfolded without overlap while using only polynomially many (orthogonal) cuts.
  By contrast, the best previous such result used exponentially many cuts.
  More precisely, given an orthogonal polyhedron with  vertices,
  the algorithm cuts the polyhedron only where it is met by
  the grid of coordinate planes passing through the vertices,
  together with  additional coordinate planes
  between every two such grid planes.
\end{abstract}

\section{Introduction}

One of the major unsolved problems in geometric folding is whether every
polyhedron (homeomorphic to a sphere) has an ``unfolding''
\cite{Bern-Demaine-Eppstein-Kuo-Mantler-Snoeyink-2003,Demaine-O'Rourke-2007}.
In general, an \emph{unfolding} consists of cutting along the polyhedron's
surface such that what remains flattens into the plane without overlap.
Convex polyhedra have been known to unfold
since at least the 1980s \cite[Sec.~24.1.1]{Demaine-O'Rourke-2007}.

A recent breakthrough for nonconvex polyhedra is the unfolding of
any ``orthogonal'' polyhedron (homeomorphic to a sphere)
\cite{Damian-Flatland-O'Rourke-2007-epsilon}.
A polyhedron is \emph{orthogonal} if all of its edges are parallel
to a coordinate axis, and thus all edges and faces meet at right angles.
While very general, a disadvantage of this unfolding algorithm
is that the cutting is inefficient,
making exponentially many cuts in the worst case, 
resulting in an unfolding that is long and thin (``epsilon thin'').
         
In this paper, we show how to unfold any orthogonal polyhedron
using only a polynomial number of cuts.

\paragraph{Grid refinement.}
To more precisely quantify the cuts required by an unfolding,
several models of allowed cuts have been proposed.
See \cite{Demaine-O'Rourke-2005,Demaine-O'Rourke-2007,O'Rourke-2008-orthosurvey}
for surveys.

For convex polyhedra, the major unsolved goal is to just cut along the edges
(which implies a linear number of cuts) \cite[ch.~22]{Demaine-O'Rourke-2007}.
For nonconvex polyhedra, however, this goal is unattainable, even
when the polyhedron is ``topologically convex''
\cite{Bern-Demaine-Eppstein-Kuo-Mantler-Snoeyink-2003}
or is orthogonal
\cite{Biedl-Demaine-Demaine-Lubiw-Overmars-O'Rourke-Robbins-Whitesides-1998}.
A simple example of the latter is a small box on top of a larger box.
More generally, deciding whether an orthogonal polyhedron has an edge
unfolding is strongly NP-complete \cite{Abel-Demaine-2011}.

For orthogonal polyhedra, it seems most natural to consider orthogonal cuts.
The smallest extension from edge unfolding seems to be \emph{grid unfolding}
(a concept implicit in
\cite{Biedl-Demaine-Demaine-Lubiw-Overmars-O'Rourke-Robbins-Whitesides-1998}),
where we slice the polyhedron with all axis-aligned planes that pass through
at least one polyhedron vertex, and allow cutting along all slice lines.
Even with these additional edges, few nontrivial subclasses of
orthogonal polyhedra are known to have grid unfoldings: ``orthotubes''
\cite{Biedl-Demaine-Demaine-Lubiw-Overmars-O'Rourke-Robbins-Whitesides-1998},
``orthostacks'' composed of orthogonally convex slabs
\cite{Damian-Meijer-2004-orthostacks}, and
``well-separated orthotrees''
\cite{Damian-Flatland-Meijer-O'Rourke-2005-orthotrees}.
On the negative side, there are four orthogonal polyhedra with no
\emph{common} grid unfolding
\cite{Aloupis-Bose-Collette-Demaine-Demaine-Douieb-Dujmovic-Iacono-Langerman-Morin-2010}.

The next extension beyond grid unfolding is \emph{grid refinement} ,
which additionally slices with  planes in between every grid plane
(as above), and allows cuts along any edges of the refined grid.
With constant grid refinement, a few more classes of orthogonal polyhedra
have been successfully unfolded: orthostacks
\cite{Biedl-Demaine-Demaine-Lubiw-Overmars-O'Rourke-Robbins-Whitesides-1998},
and Manhattan towers \cite{Damian-Flatland-O'Rourke-2008-manhattan}.

The breakthrough was the discovery that arbitrary orthogonal polyhedra
(homeomorphic to a sphere) unfold with finite grid refinement
\cite{Damian-Flatland-O'Rourke-2007-epsilon}.
Unfortunately, the amount of grid refinement is exponential
in the worst case (though polynomial for ``well-balanced'' polyhedra).
For this reason, the unfolding algorithm was called
\emph{epsilon-unfolding}.

\paragraph{Our results.}
We show how to modify the epsilon-unfolding algorithm of
\cite{Damian-Flatland-O'Rourke-2007-epsilon}
to reduce the refinement from worst-case exponential ()
to worst-case quadratic (), while still unfolding
any orthogonal polyhedron (with  vertices) homeomorphic to a sphere.
We call our algorithm the \emph{delta-unfolding} algorithm,
to suggest that the resulting surface strips are still narrow
but wider than those produced by epsilon-unfolding.

Our central new technique in delta-unfolding is the concept of ``heavy''
and ``light'' nodes from ``heavy-path decomposition''
\cite{Sleator-Tarjan-1983}.  Interestingly, heavy-path decomposition
is a common technique for balancing trees in the field of data structures,
but not so well known in computational geometry.

Even with this technique in hand, however, delta-unfolding requires a
careful modification and engineering of the techniques used by
epsilon-unfolding.  Thus, Sections~\ref{sec:overview}
and~\ref{Epsilon-Unfolding Extrusions} start with reviewing the
main techniques of epsilon-unfolding; then Section~\ref{sec:Delta}
modifies those techniques; and finally
Section~\ref{Delta-Unfolding of Genus-Zero Orthogonal Polyhedra}
puts these techniques together to obtain our main result.


\section{Overview of Epsilon-Unfolding}
\label{sec:overview}

We begin with a review the epsilon-unfolding algorithm~\cite{Damian-Flatland-O'Rourke-2007-epsilon},
starting in this section with a high-level overview,
and then in Section~\ref{Epsilon-Unfolding Extrusions}
detailing those aspects of the algorithm
that we modify to achieve quadratic refinement.


Throughout this paper,
 denotes a genus-zero orthogonal polyhedron whose edges are parallel to the
coordinate axes and whose surface is a -manifold.
We take the -axis to define the \emph{vertical} direction,
the -axis to determine \emph{left} and \emph{right},
and the -axis to determine \emph{front} and \emph{back}.
We consistently take the viewpoint from .
The faces of  are distinguished by their outward normal:
forward is ; rearward is ; left is ; right is ; bottom is ;
top is .\footnote{The  faces are given the awkward names
  ``forward'' and ``rearward'' to avoid confusion with other uses
  of ``front'' and ``back'' introduced later.}



The epsilon-unfolding algorithm partitions  into \emph{slabs}
by slicing
it with -perpendicular planes through each vertex. Let 
be the slicing planes sorted by  coordinate. A \emph{slab}  is a connected component of
 located between two consecutive planes  and .
Each slab is a simple orthogonal polygon extruded in the -direction.
The cycle of
\{left, right, top, bottom\} faces surrounding  is called a \emph{band}, and
the band edges in  (and similarly in ) form a cycle called a \emph{rim}.
A -\emph{beam} is a narrow vertical strip on a forward or rearward face of 
connecting the rims of two bands.
The order in which the bands unfold is determined
by an \emph{unfolding tree}  whose nodes are bands,
and whose arcs correspond to -beams, each of which connects a
parent band to a child band in . The unfolding tree
 will be further described in Section~\ref{sec:Tree} below.

The unfolding of a band  is determined by
a thin surface spiral, denoted , that starts on one of 's rims,
cycles around  while displacing toward the other rim, where it
turns around and returns to the point
it started.  As the spiral passes by a -beam connecting  to one of its children, it enters through the -beam to the child's rim, and then recursively
visits the subtree rooted at the child.
Once the complete spiral is determined, it can be thickened in the  direction so that
it entirely covers all band faces.
The thickened spiral is such that it can be laid flat in the plane to form a
monotonic staircase strip. The forward and rearward faces of  can then be laid flat without overlap
by attaching them in strips above and below the staircase.

\section{Epsilon-Unfolding Extrusions}
\label{Epsilon-Unfolding Extrusions}

Almost all algorithmic issues in epsilon-unfolding are present in unfolding polyhedra
that are -extrusions of simple orthogonal polygons in the  plane.
Therefore, we follow~\cite{Damian-Flatland-O'Rourke-2007-epsilon} in describing
the algorithm for this simple shape class, before extending the ideas
to all orthogonal polyhedra.  All modifications needed for
delta-unfolding
are also present in unfolding orthogonal extrusions, and so we
describe them in terms of this simple shape class.
We therefore review in detail the epsilon-unfolding algorithm for orthogonal extrusions.

\subsection{Unfolding Tree}
\label{sec:Tree}
Let  be a polyhedron that is the vertical extrusion of a simple orthogonal polygon, such
as that illustrated in Figure~\ref{fig:partition}a.
The algorithm
begins by slicing  into slabs, which in this special case are all
blocks (cuboids),
using -perpendicular planes through each vertex.
The dual graph is a tree, , having a node for each band and an edge
between each pair of adjacent bands.
In this special case, all -beams are degenerate, i.e., of zero -height.
The root is selected arbitrarily from among
all bands with a rim of
minimum  coordinate. For example, the
polyhedron in Figure~\ref{fig:partition}a is sliced into nine
blocks, with  as the root and
its unfolding tree as shown in Figure~\ref{fig:partition}b.
\begin{figure}[htbp]
\centering
\includegraphics[width=.7\linewidth]{partition}
\caption{(a) Extrusion of an orthogonal polygon, partitioned by  perpendicular planes. (b) Unfolding
  tree. Back children are represented by shaded nodes.}
\label{fig:partition}
\end{figure}


The rim of the root band with the
smaller  coordinate is its \emph{front rim}, and the other rim
is its \emph{back rim}. For any other band, the rim adjacent to its parent in  is
its front rim, and its other rim is its back rim.
Children attached along the front rim of their parent are \emph{front children}; children attached
along the back rim of their parent are \emph{back children}.
Note that ``front'' and ``back'' modifiers for rims and children derive from the structure of
, and are not related to the ``forward'' and ``rearward'' 
directions.
For example,  is a front-child of , although it is attached
to
the rearward face of , and the front rim of  lies
on the rearward face of .



\subsection{Recursive Unfolding}

The key to the epsilon-unfolding method is the existence of a thin, non-crossing \emph{spiral}  that cycles around each band
at least once, and unfolds to a staircase when flattened into the
plane.
A \emph{staircase} is an orthogonal path in the plane whose turns
alternate between  left and   right, and so is a
monotone path.
The path that  follows is determined recursively.
We review this \emph{spiral} , starting with the base case.

\subsubsection{Single Band Base Case}
\label{sec:basecase}

Figure~\ref{fig:Rts}a shows the path followed by  for a single band corresponding to a leaf of .
It starts at an \emph{entering point}  on the top edge of
the front rim and spirals in a clockwise direction around the top, right, bottom, and left band faces toward the back rim. We call this spiral piece up to the point it reaches the back rim the
\emph{entering spiral}.
When it reaches the back rim,  crosses the rearward face upward toward the top face.
From there, it retraces the entering spiral in the opposite (counterclockwise)
direction toward an \emph{exiting point}   lying next to  on
the front rim.
When  is cut out, unfolded, and laid horizontally in the plane,
it forms a monotonic staircase strip, as shown in
Figure~\ref{fig:Rts}b, because the turns alternate between left and
right,  each.
Observe that
the -parallel segments of , corresponding to the cycling
clockwise and counterclockwise around the band, form the stair ``treads'';
the -parallel segments of  and the -parallel strip from the rearward face
form the stair ``risers.''


\begin{figure}[htbp]
\centering
\includegraphics[width=\linewidth]{Rts}
\caption{(a)  block spiral, with
mirror views of faces that cannot be seen directly.
(b) Unfolded spiral.
(c) Abstract 2D representation.}
\label{fig:Rts}
\end{figure}


Three-dimensional illustrations of  like that in Figure~\ref{fig:Rts}a
are impractical for
more complex orthogonal shapes. To easily illustrate more complex unfoldings, we
use the 2D representation
depicted in Figure~\ref{fig:Rts}c.
Note that the 2D representation captures the direction of the entering spiral and
the relative position of  and . The arc connecting the entrance to the exit
symbolizes the reversal of the unfolding direction
using a rearward face strip.

Eight variations of the base case spiral are illustrated in Figure~\ref{fig:R}.
They differ in the manner in which  enters and exits the band  to be unfolded.
The four variations labeled , , ,  in the top row are
used when the -coordinate of 's front rim is smaller than the -coordinate of its back rim.  is similar to , but with  and , and the clockwise/counterclockwise
cycling direction reversed;  and  are (respectively) mirrors of
 and  in an -perpendicular plane. Note that the  and  labels indicate
the spiral's cycling direction when it enters the band:  is clockwise,
 is counterclockwise. The spiral exits the band cycling in the opposite direction.
The four variations in the bottom row
are labeled , and they are
used when
the -coordinate of 's front rim is greater than the -coordinate
of its back rim.
They are exact reflections of , , , and , respectively, in
a -perpendicular plane.
The mirror symmetries imply that the 3D spiral corresponding to each 2D
abstract representation can be easily derived from  configuration, illustrated in Figure~\ref{fig:Rts}.
\begin{figure}[htbp]
\centering
\includegraphics[width=0.8\linewidth]{R}
\caption{Abstract 2D representations of the eight path types visiting one slab.}
\label{fig:R}
\end{figure}




\subsubsection{Recursive Path}
\label{sec:eps-recursive}

For a node  in  that is not a leaf, we describe the path that the spiral 
recursively follows when visiting .
We assume that  has one of the eight configuration
labels shown in Figure~\ref{fig:R}.
As in the base cases, the label
identifies the relative order of points  and  on 's front rim, the spiral's direction
when entering , and 's rim of lower  coordinate.
Without loss of generality, we assume that
's label is ; the other seven labels are equivalent by symmetry.
The inductive assumption is
that, for any subtree shorter than the subtree of  rooted at , and for
any configuration label assigned to the root band of the shorter subtree,
there is a (non-crossing) path  consistent with that label
that cycles around each band in the smaller subtree at least once,
and unfolds in the plane as a staircase strip.


After  enters  at point ,
it visits each of
's front children,
starting with the front child, call it ,
first encountered as it cycles clockwise along the front rim of .
(See Figure~\ref{fig:epsfrontchildren}).
For reasons soon to be explained,
child  is assigned the label  with two points
 and  identified on the top edge of its front rim, with 
right of .
The spiral 
enters  at point  and recursively visits it (and the subtree
it roots).
By the inductive hypothesis,  exits  at point  cycling counterclockwise.
The label  is assigned to  because
 is cycling in the direction  (to the right, or clockwise)
on  just before it enters , and so it enters
 with that same direction; the  superscript is necessary
because the -coordinate of the front rim of  is higher than
that of its back rim; and the
 ordering is necessary to prevent  from being
trapped beneath the portion of  between  and  upon
returning to , thus cutting itself off from reaching 's other children
(because it cannot cross itself).


\begin{figure}[htbp]
\centering
\includegraphics[width=0.9\linewidth]{epsunffront}
\caption{Nested inside-out alternating path visits the front children. Dotted lines show 
where it cycles underneath on the bottom face.}
\label{fig:epsfrontchildren}
\end{figure}


After recursively visiting ,  cycles counterclockwise on 
to the first unvisited child it passes when on 's top face. This child, call it ,
is assigned the label  with identified points  and  on its front
rim, consistent with its label,  and it is recursively visited.
In this nested manner,  visits the
children clockwise and counterclockwise from  from the inside out,
alternately assigning the labels  and .
Figure~\ref{fig:epsfrontchildren} illustrates the path  takes
when  has four
front children. (To keep the example simple, only
one level of recursion is illustrated, with all children leaves of .)

\begin{figure}[htbp]
\centering
\includegraphics[width=0.9\linewidth]{epsunfback}
\caption{Nested outside-in alternating path visits the back children.}
\label{fig:epsbackchildren}
\end{figure}


After visiting the front children,  makes a complete cycle around  and
then begins visiting the back children. Assume for concreteness that after visiting the
front children,  is cycling clockwise on , as shown in Figure~\ref{fig:epsbackchildren}. It then travels clockwise to the back child farthest to the right
along the top face. (See child  in Figure~\ref{fig:epsbackchildren}).
When it returns from recursively visiting this back child, it will be cycling counterclockwise
(by the inductive hypothesis).
It is thus important that the child's exit point be to the left
of its entering point so that  is not blocked from visiting other back children.
(See points  and  in Figure~\ref{fig:epsbackchildren}.)
Thus this first back child is assigned the configuration  and is recursively visited.  The spiral then moves to the unvisited child
farthest to the left
(see child ) and visits it in a similar way, assigning it the label .
Thus the nesting of 's alternating path is outside-in for back children,
with the labels  and  being alternately assigned.


The last back child visited, , however, is an exception when it comes to
its label assignment, for the following reason.
When the spiral exits  (see  in Figure~\ref{fig:epsbackchildren}),
it will retrace its path (in reverse direction) back
to the front rim of  and then exit at point .
For band ,  define its \emph{entering spiral}, , to be the portion of  that begins
at  and ends at the exiting point  of 
( in Figure~\ref{fig:epsbackchildren}).
Its \emph{exiting spiral}, , is the portion of  that
begins at 
and ends at  on the front rim of .
The exiting spiral  simply parallels alongside the
entering spiral ,
retracing the portion of  from  to  but in the opposite direction.
Since  has a  label, the exiting spiral must leave  with the entering
spiral on its left, from the point of view of one walking on 
along the path taken by . Thus 
must also be assigned the label  (consistent
with  's label), so that from the beginning of the retrace and throughout,  has
the entering spiral to its left. We call this a \emph{left retrace}; when  keeps
the entering spiral on its right during a retrace, we call it a \emph{right retrace}.
We note that if  has no back children,
then the spiral reverses direction using a strip from 's rearward face, as in
the base cases.

\subsection{Completing the Unfolding}
\label{sec:frontback}

We have focused on 's recursive path because that is where the modifications
for delta-unfolding occur. But for completeness, we briefly summarize the
remainder of the epsilon-unfolding algorithm for extrusions, and
refer the reader to~\cite{Damian-Flatland-O'Rourke-2007-epsilon} for  additional details.
To complete the unfolding of ,  is thicken in the  and  direction (as viewed
in the 3D coordinate system of Figure~\ref{fig:Rts}a) so that it completely covers
each band. This results in a thicker unfolded staircase strip. Then the
forward and rearward faces of  are partitioned by imagining the band's top rim edges illuminating downward light rays in these
faces. The illuminated pieces are then ``hung" above and below the thickened staircase,
along the corresponding illuminating rim segments which lie along the horizontal edges of
the staircase.

\subsection{Level of Refinement}

In~\cite{Damian-Flatland-O'Rourke-2007-epsilon} it was shown that the unfolding technique discussed so far can make an exponential
number of cuts on the family of polyhedra
depicted in Figure~\ref{fig:expcase}. Each polyhedron consists of , , blocks
arranged as shown for  in Figure~\ref{fig:expcase}a, and for  in Figure~\ref{fig:expcase}b. For analysis purposes, we formally define a \emph{visit} to a band to begin
when the spiral crosses its front rim to enter the band (either the first time, or in a retrace) and
end when it crosses the front rim to exit the band.
In Figure~\ref{fig:expcase}a, 's visit begins when  enters it at
point  cycling counterclockwise. The spiral visits back child
 and then . The visit of  triggers a retrace which involves a second visit of , and then
back through  to exiting point , which completes 's visit.
\begin{figure}[htbp]
\centering
\includegraphics[width=\linewidth]{expcase}
\caption{Family of polyhedra requiring exponential refinement. Block  is visited two times in (a), four times in (b), and in general  times for an -block object.}
\label{fig:expcase}
\end{figure}
We can write this visit order using the string
, where an open parenthesis followed by a starting point
marks the start of a visit and  an exiting point followed by
a closing parenthesis marks the end.
The subscript on  is the number of blocks in the polyhedron. Observe that block 
is visited twice.
For the five block polyhedron in
Figure~\ref{fig:expcase}b,  starts at point  on ,
recursively visits block  in the
manner just described, then visits  which triggers a retrace through .
After revisiting ,  returns to  and exits at point . The corresponding visit string is
.
The number of visits to  doubles to . In general,
an  block polyhedron in this family gives rise to
 visits to , resulting in an exponential
number of cuts on .

\section{Delta-Unfolding Extrusions}
\label{sec:Delta}

To achieve quadratic refinement, we modify the
order in which children are visited
based on the heavy/light classification of nodes used in
\emph{heavy-path decomposition}~\cite{Sleator-Tarjan-1983}.
In heavy-path decomposition,
each tree node  is
assigned a weight , which is the number of descendants in its
subtree, including itself.  An edge from parent  to child  is
\emph{heavy} if , and \emph{light} otherwise. We say a child
 is \emph{heavy} (\emph{light}) if the edge between  and its parent is heavy (light). Observe that
a node can have at most one heavy child.

If a node  in  has a heavy child, then we modify the
path of the entering spiral  so
that it visits the heavy child last, to prevent the need for revisiting the heavy child; we will show that this strategy quadratically bounds the
number of visits  makes to each child.
For example, consider the polyhedron in Figure~\ref{fig:expcase}b, and observe that
 is a heavy child. With epsilon-unfolding,  visited child 
before . The visit to  triggered a complete retrace of the subtree rooted
at , thus leading to the visit string ,
and a total of four visits to .
But if we reverse the visit order so that  visits  after ,
then the visit
string becomes , and no
block is visited more than twice.


Since any front or back child could be heavy, we focus first on the challenge of
finding a route for the entering spiral so that it visits any specified child
last.
If we can achieve this, then we can organize the visits to minimize
retracing.
We then
formally present the algorithm and
analyze the resulting level of refinement.

\subsection{Front Child Visited Last}
\label{sec:heavyfront}

We start with the case when we desire to visit
a front child, call it , last.
The idea is to visit all the front children excluding ,
and all the back children in exactly the manner described in Section~\ref{sec:eps-recursive}, as if  were not present.
Figure~\ref{fig:unfex} shows the entering spiral  visiting all
but .
(Note that the complete cycle that  makes between
 visiting the front and back children is not fully depicted in the
2D representation.)
After visiting the last back child ( in the figure),  retraces its
path in reverse.
It is during this retrace step that child  is visited.
We explain the modifications necessary to accomplish this for a parent block
 with a label of type  or ; labels of type  and  are handled symmetrically.
\begin{figure}[htbp]
\centering
\includegraphics[width=0.8\linewidth]{unfex}
\caption{Entering spiral  visits front and back children, with the exception of front child ,
which gets visited last (see Figure~\ref{fig:unfex2}).}
\label{fig:unfex}
\end{figure}


\begin{figure}[htbp]
\centering
\includegraphics[width=0.8\linewidth]{unfex2}
\caption{Entering and return spirals. The return spiral passes by  so that 
can be visited.}
\label{fig:unfex2}
\end{figure}


Observe first  that since  alternately visits all the front children
except for  and then makes a complete cycle
around ,
some contiguous section of it, call it , runs
alongside the top edge of 's front rim.
Specifically,  is the section of  hit by -parallel rays shot from
's top front rim edge toward the back rim of . See Figure~\ref{fig:unfex} where
 is marked. Note that since
 is cycling toward the back rim of ,  represents the first
time  passes by 's top edge.
All subsequent passes are behind .

During the retrace step,
  needs to run in front of , so that it has unobstructed
access to .
If the entering spiral
is cycling clockwise in section , then the retracing spiral (which runs alongside
 in the opposite direction) needs to
right-retrace, because that will keep the entering spiral to its right and
position it in front of .
(Recall that clockwise is to the right and counterclockwise is
to the left.)
To trigger a right-retrace, we assign the last visited back child the label .
If the entering spiral
is cycling counterclockwise in section , then the retracing spiral needs to
left-retrace, thus keeping the entering spiral on its left.
To trigger a left-retrace, we assign the last back child the label .
So instead of matching the  or  label of the last visited back
child to that of  (as in epsilon-unfolding),
we instead assign it so that the retracing spiral passes alongside .
When the retracing spiral reaches section , it suspends
the retrace, enters  at point , and visits it. We call the portion of 
from the exiting point of the last visited back child to  the
\emph{return spiral} and label it . See Figure~\ref{fig:unfex2}
which shows  in red extending from  to .


Upon exiting  at point , the spiral retraces its path
in the reverse direction, bringing it to the exit point  on .
Specifically, it follows the entire path from  to  in reverse.
This second retrace is 's exiting spiral, .
(In Figure~\ref{fig:unfex2},  is not illustrated, but
it begins at  and follows the red and then the black path
to , keeping them to its left.)
The label  or  assigned to  must be consistent
with 's label in the following way. If  has the label , a left retrace
starting from  is needed so that the spiral exits at  on
the correct side of  consistent with 's  label. Thus,
 is assigned the label , the opposite of 's label. If, however,  has the label ,
a right retrace is needed, and so  is assigned the label .

Because the label assigned to the last back child visited depends
on the direction of  in the -section of the path, we show here that
determining that direction is straightforward.
We discuss the case in which  enters 
cycling clockwise; the case when it is cycling counterclockwise
is symmetric. We also assume that there are at least two front children
(not including ) and
they are labeled , , ,
in the order in which they are visited along the alternating path (as in Figure~\ref{fig:unfex}).
Observe that, if  is located between  and  (as viewed from above),
then  first passes by 's top edge cycling clockwise, and
the same is true if it is located between  and ,
for  odd (). Thus in these cases,  is traversed clockwise.
If  is located between  and  or
between  and , for , then
 first passes by the top edge of  cycling counterclockwise. Thus
in these cases  is traversed counterclockwise.
If the top edge of  is to the right of the last  odd
numbered child or to the left of the last even numbered child, then
 first passes over  during its complete cycle around .
During this cycle,  is heading
clockwise  if the last visited child was even and counterclockwise
if the last visited child was odd. Cases when there are fewer than two
front children are easily handled: if  is the only front child,
or if it is located between  and , then then  is traversed clockwise;
otherwise,  is traversed counterclockwise.


\subsection{Back Child Visited Last}
\label{sec:heavyback}

In this section we discuss the situation in which we desire
to visit a particular back child  last.
In this case,  visits the front children as described in
Section~\ref{sec:eps-recursive}. It then visits the back children as described
in Section~\ref{sec:eps-recursive} but with an altered visiting order.
We consider the case when  has a  or  type configuration
label and the
entering spiral  is cycling counterclockwise after visiting the front children;
the other cases are symmetric.

Let  be the number of back children of  not including ,
and let  be the front children, for .
Consider the back children of  in the cyclic clockwise order in which their top edges
occur around 's back rim.
When  is odd, we label the  back children
,
according to their positions relative to  in this cyclic ordering.
When  is even, the labeling is ,
as depicted in Figure~\ref{fig:unfback}. The spiral
 visits the back children from the outside-in, following the visit order
.
It is always possible to visit  first,
with a full cycle of the spiral around  (if necessary) to get the spiral
to the top edge of . This is illustrated in Figure~\ref{fig:unfback}
for five back children (and no front children).



\begin{figure}[htbp]
\centering
\includegraphics[width=0.8\linewidth]{unfback2}
\caption{Labels and path followed by spiral when visiting back children, when the last child
to be visited is back child ;
dashed
lines depict spiral pieces on the bottom of the parent block.}
\label{fig:unfback}
\end{figure}


The assignment of  and  labels to the back children of  is the same as described
in Section~\ref{sec:eps-recursive}.
Specifically, the labels for the children alternate between 
and  with respect to the visiting order.  The spiral  is cycling
counterclockwise (to the left) when it reaches , which
matches 's  label.
The recursive unfolding of  reverses the direction of the spiral, so
that it enters

cycling clockwise (to the right), thus matching
's  label,
and similarly for the other back children.  The
alternating ,  labels of the children ensures an outside-in
nesting of , which enables it to reach each back
child.  As in Section~\ref{sec:eps-recursive}, the one exception to the
alternating labels is the last visited child , whose  or  label
needs to match that of its parent .
After visiting , the exiting spiral follows the entering spiral in reverse to 
as in Section~\ref{sec:eps-recursive}, thus completing the visit of .


\subsection{The Delta-Unfolding Algorithm for Extrusions}
\label{sec:analysis}

What we call the {\em delta-unfolding} algorithm is
a modified version of the epsilon-unfolding algorithm, which requires that at each node  in 
with a heavy child, the spiral  visits the heavy child last.
Specifically, if the heavy child is a front child, then  follows the
path described in Section~\ref{sec:heavyfront}; if the heavy child is a back child, then  follows the
path described in Section~\ref{sec:heavyback}.
If  has no heavy child, then its children are visited in the
epsilon-unfolding order (Section~\ref{sec:eps-recursive}).
All remaining steps of the delta-unfolding algorithm for extrusions---the
thickening of , the unfolding of  as a staircase in the plane,
and the partitioning and hanging of the frontward and rearward faces from the
flattened staircase---are the same as for epsilon-unfolding.

\subsection{Refinement Analysis}

We now turn to analyzing the refinement for extrusions. The path taken by 
on a band is composed of a series of
axis-parallel segments.
We determine an asymptotic upper bound on the number
of such segments on any band face,
because this is an asymptotic upper bound on the total
number of cuts on a grid face in the unfolding. We compute this by bounding the number
of segments on any top face, as the number of segments on all four faces of a
band is asymptotically bounded by the number of segments on its top face.

Define the {\em first visit} of  to a band  to begin
when  {\em first} enters  at point , includes the recursive visiting of
's children, and ends when it exits  at point .
Band
 and the bands in its subtree may be revisited by  many times during
subsequent retracings, but each of these retracings merely follows the path traced
during the first visit to .
Let  be an asymptotic upper bound on the number of segments that
's first visit to 
induces on a top face of any band in the unfolding subtree rooted at .
Then a bound on the number of
 segments on any top face in 's subtree induced by  (in its entirety) is 
multiplied by the total number of times  visits .
We now establish three properties of 's first visit to :
\begin{enumerate}[(i)]
\item  induces at most   segments on 's top face;
\item the light children of  are each visited at most four times; and
\item if  has a heavy child, the heavy child is visited only once.
\end{enumerate}

For (i), the worst case occurs when
 has  children and a heavy front child .
In this case, the
alternating paths of 's entering spiral 
that have it visit each front child (excluding ) may induce
  segments on 's top face, and similarly for the alternating paths to each
back child.
Then 's return spiral  retraces these alternating paths up to the point
that it reaches , which
at most doubles the number of  segments.
After visiting  ,
the exiting spiral  retraces the path  and then the path
 in reverse back to point  on , which again
at most doubles the number of  segments
on . Thus the total number of  segments is .

For~(ii), the maximum visits to light children occur when
 has a heavy front child. In this case,
 visits each light child once.
Then 
visits each light child at most once on its way to the heavy front child. After visiting the heavy
front child,  retraces

and then retraces
 to the entering point of , thus visiting each light child
at most twice more. Therefore,
each light child is visited at most four times.


For~(iii), if  has a heavy front child, then the path traversed by 
(detailed in Section~\ref{sec:heavyfront}) immediately establishes that the heavy front
child is visited only once. Similarly, if  has a heavy back child, the path detailed
in Section~\ref{sec:heavyback} establishes that the heavy back child is visited exactly once.


Properties (i), (ii) and (iii) established above imply that  is determined
by the larger of three quantities:
\begin{enumerate}[(a)]
\item the number of  segments on 's top face induced during 's
first visit to ;
\item , where  are 's
light
children;
\item , where  is 's heavy child, if it has one.
\end{enumerate}
A multiplier of four is necessary in case~(b) because light children may be visited up to four times during 's first visit; no multiplier is
necessary for the heavy child~(c) because it is visited only once. For the base case,
, for some constant , because the first visit of  to
a leaf node band (as described in Section~\ref{sec:basecase}) induces a constant
number of  segments.
And in general,

noting that the light children's subtrees contain at most  nodes,
and the heavy child's subtree contains at most  nodes. It is
straightforward to verify by induction that .
Applying this to the root  of  with  nodes
and noting that  visits  only once in the delta-unfolding
algorithm,
yields a maximum of   parallel segments on any top face.

This also bounds the number of cuts on any grid face in the unfolding.
Specifically, in the thickening step  expands in the  and 
direction so as to cover the entire band, but this does not asymptotically
increase its number of edges.
After the thickening, disjoint sections of
 run along the entirety of both band rims. In the partitioning
step, the disjoint sections along the top rim edges
induce the division of the frontward and rearward faces into strips;
i.e., each disjoint section delimits the vertical strip beneath it. Because 
bounds the number of disjoint sections along the top edge, it also bounds the number of strips
a frontward/rearward face is partitioned into.

\subsubsection{A worst case refinement example.}
A simple example establishes that the bound  is tight: a
polyhedron with  blocks,
whose unfolding tree  is a perfect
binary tree of height  (i.e., each internal node has two children, and all
leaves are at the same level).
There are no heavy nodes in , and the number of cuts in a visit of
the root is given by the recurrence relation

because

And since , for some constant , it follows that ,
establishing our claim.

\section{Delta-Unfolding of Genus-Zero Orthogonal Polyhedra}
\label{Delta-Unfolding of Genus-Zero Orthogonal Polyhedra}

The delta-unfolding algorithm and its refinement analysis
generalizes to all genus-zero orthogonal polyhedra in the same
way the epsilon-unfolding algorithm does, so we summarize the idea here and refer the
reader to~\cite{Damian-Flatland-O'Rourke-2007-epsilon} for details. Instead of partitioning  into blocks, the general algorithm
partitions  into slabs as defined in Section~\ref{sec:overview}.
It then creates an unfolding tree, , where each node corresponds to a band surrounding a slab.
Each parent-child arc in  corresponds to a -beam, which is a vertical strip from a frontward or rearward face connecting the parent's rim to the child's rim.
For a parent band , its front (back) children are those
whose -beams connect to 's front (back) rim.


The spiral  enters and exits  at points  and 
located at the intersection between 's front rim and the -beam
connecting  to its parent.
Observe that there is a natural cyclic ordering of 's front (back) children that is determined by their
-beam connections around 's front (back) rim.  Using this cyclic ordering, it
is straightforward to generalize the paths that  follows to reach the
front and back children, described in Sections~\ref{sec:heavyfront} and~\ref{sec:heavyback}.
See for example Figure~\ref{fig:genUnfEx} that shows a band with its faces flattened in the plane (the lighter color marks top/bottom faces, and
the darker color marks right/left faces). Also depicted are
the -beam connections (flattened into the plane) and the path   follows
to visit the children, assuming  is a heavy child. Observe that the path is
the same as in Figure~\ref{fig:unfex}, except that it extends across multiple band faces.
When  visits a child, it moves from  to
the connecting -beam and travels vertically (in 3D) along the -beam to reach the child;
when it exits the child it travels along the -beam back to .
In the unfolded staircase, the portion
of  on the -beam corresponds to a vertical riser. Thickening  is done
as in the case of extrusions. The partitioning of the
forwards and rearwards faces is also done as in the case of extrusions, but
in addition to shooting illuminating rays down from top rim edges, bottom rim edges that are not hit by these rays must
themselves shoot rays upward to illuminate portions of faces not illuminated by
the top edges. The face pieces resulting from this partitioning method
are hung from the staircase as described in Section~\ref{sec:frontback}. \begin{figure}[htbp]
\centering
\includegraphics[width=0.8\linewidth]{genUnfEx}
\caption{Band  of a slab, cut and laid flat with top/bottom faces light gray and right/left
faces dark gray. -beam connections to 's parent, children , and child 
are marked along the front and back rim. The path that  follows
when  is heavy is depicted.}
\label{fig:genUnfEx}
\end{figure}


The  upper bound on the level of grid refinement for extrusions also applies to general orthogonal polyhedra by the following argument. In the case of extrusions, for any block  with children,  makes turns only
on 's top face, because all access to the children is
from the top face; it makes no turns on the other three faces of .
Therefore, we analyze the
number of segments (each corresponding to a turn) on the top face. For a band 
of an arbitrary orthogonal polyhedra,  visits 's children in the same manner as for
an extrusion, except that the turns made to access the children are made
on whatever top or bottom face has the connecting -beam, as in Figure~\ref{fig:genUnfEx}. In particular, for a band  with a given number
of front and back children, the same number of turns are made, whether
 surrounds a block of an extrusion or a slab of a arbitrary orthogonal polyhedron.
In terms of maximum refinement, the worst case occurs when all the turns are
concentrated on a single face, which is exactly the situation handled by our upper bound
analysis in the case of extrusions.


\section{Conclusion}
We present modifications to the epsilon-unfolding algorithm from~\cite{Damian-Flatland-O'Rourke-2007-epsilon} that reduce the level of grid
refinement necessary to grid-unfold any
genus-zero orthogonal polyhedron from exponential to quadratic.
The next natural step is to seek a refined grid edge-unfolding of all genus-zero
orthogonal polyhedra that requires subquadratic refinement of the
grid faces, to date only achieved for highly restricted classes of
orthogonal polyhedra~\cite{Biedl-Demaine-Demaine-Lubiw-Overmars-O'Rourke-Robbins-Whitesides-1998,Damian-Flatland-O'Rourke-2008-manhattan,Damian-Meijer-2004-orthostacks}.
It is unlikely
that the technique used in this paper could be extended to produce such an unfolding, due
to the backtracking nature of our recursive unfolding algorithm. However, our preliminary
investigations embolden us
to conjecture that a constant refinement of the vertex grid
suffices to grid-unfold all orthogonal polyhedra.


\paragraph{Acknowledgement.} The authors would like to thank Joseph O'Rourke for his careful 
reading and helpful suggestions.

\bibliographystyle{alpha}
\bibliography{unfolding}

\end{document}
