\newcommand*{\LONG}{}\pdfpagewidth=8.5in
\pdfpageheight=11in

\pdfoutput=1

\ifdefined\LONG
\documentclass[11pt]{article}
\usepackage{amsfonts,amsmath,amssymb,latexsym,comment,amsthm}


\usepackage[letterpaper]{geometry}
\usepackage{fullpage}



\usepackage{mathrsfs}
\usepackage{times}


\else \documentclass{sig-alternate-2013}
\usepackage{amsfonts,amsmath,amssymb,latexsym,comment }

\fi


\usepackage{qtree}
\usepackage{epsfig}
\usepackage{graphicx}
\usepackage{subfigure}

\usepackage{xspace}
\usepackage{cases}
\ifx\pdftexversion\undefined
\usepackage[colorlinks,linkcolor=black,filecolor=black,citecolor=black,urlcolor=black,pdfstartview=FitH]{hyperref}
\else
 \usepackage[colorlinks,linkcolor=blue,filecolor=blue,citecolor=blue,urlcolor=blue,pdfstartview=FitH]{hyperref}
\fi
\usepackage[lined,ruled,boxed,commentsnumbered,noresetcount]{algorithm2e}
\usepackage{enumitem}

\usepackage{pifont}





\newcommand{\wbox}{\mbox{\llap{}}}

\def\squarebox#1{\hbox to #1{\hfill\vbox to #1{\vfill}}}




\newtheorem{theorem}{Theorem}
\newtheorem{conjecture}{Conjecture}
\newtheorem{lemma}{Lemma}
\newtheorem{proposition}[lemma]{Proposition}
\newtheorem{property}{Property}
\newtheorem{definition}{Definition}
\newtheorem{example}{Example}
\newtheorem{claim}{Claim}
\newtheorem{corollary}{Corollary}
\newtheorem{introtheorem}{Theorem}
\newtheorem{assumption}{Assumption}
\newtheorem{observation}{Observation}
\newtheorem{remark}{{\sc Remark}\rm }[section]





\newcommand\Cycle{\mbox{\slshape Cycle}\xspace}
\newcommand\cyclemin{\mbox{}}
\newcommand\cyclemax{\mbox{}}
\newcommand{\lineref}[1]{Line~{\tt #1}}




\newcommand{\namedref}[2]{\hyperref[#2]{#1~\ref*{#2}}}
\newcommand{\sectionref}[1]{\namedref{Section}{#1}}
\newcommand{\observationref}[1]{\namedref{Observation}{#1}}
\newcommand{\appendixref}[1]{\namedref{Appendix}{#1}}
\newcommand{\propertyref}[1]{\namedref{Property}{#1}}
\newcommand{\subsectionref}[1]{\namedref{Subsection}{#1}}
\newcommand{\theoremref}[1]{\namedref{Theorem}{#1}}
\newcommand{\defref}[1]{\namedref{Definition}{#1}}
\newcommand{\figureref}[1]{\namedref{Figure}{#1}}
\newcommand{\figref}[1]{\namedref{Figure}{#1}}
\newcommand{\claimref}[1]{\namedref{Claim}{#1}}
\newcommand{\lemmaref}[1]{\namedref{Lemma}{#1}}
\newcommand{\tableref}[1]{\namedref{Table}{#1}}
\newcommand{\corollaryref}[1]{\namedref{Corollary}{#1}}
\newcommand{\pref}[1]{\namedref{Property}{#1}}
\newcommand{\appref}[1]{\namedref{Appendix}{#1}}
\newcommand{\proporef}[1]{\namedref{Proposition}{#1}}
\newcommand{\definitionref}[1]{\namedref{Definition}{#1}}
\newcommand{\properref}[1]{\namedref{Property}{#1}}
\newcommand{\algref}[1]{\namedref{Algorithm}{#1}}
\newcommand{\ruleref}[1]{\namedref{Rule}{#1}}
\newcommand{\lref}[1]{\namedref{Line}{#1}}
\newcommand{\dagree}{{\em Detect/Agree\ }}
\newcommand{\IR}{\mbox{}}
\newcommand{\remarkref}[1]{\namedref{Remark}{#1}}

\newcommand{\etal}{et~al.\xspace}
\renewcommand{\S}{\mathcal{S}}
\newcommand{\PR}{\cal{R}}
\newcommand{\PS}{\cal{S}}
\newcommand{\C}{\mathcal{C}}
\renewcommand{\P}{\mathcal{P}}
\newcommand{\false}{\mathit{false}}
\newcommand{\true}{\mathit{true}}
\newcommand{\ack}{\mathit{ack}}
\newcommand{\info}{{\mbox{\it correct}}}
\newcommand\all{N}
\newcommand{\none}{\phi'}
\newcommand{\best}{\mathrm{best}}
\newcommand{\majority}{\mathrm{majority}}
\newcommand\alone{\{i\}}
\newcommand{\secret}{\mathit{sec}}
\newcommand{\sigmact}{\sigma_{\mbox{\footnotesize\sc ct}}}
\newcommand{\Gammact}{\Gamma_{\!\mbox{\footnotesize\sc ct}}}
\newcommand{\Grush}{\Gamma_{\textrm{rush}}}
\newcommand{\vecsigmact}{\sigma_{\mbox{\footnotesize\sc ct}}}
\newcommand{\fsc}[1]{\mbox{\footnotesize\sc {#1}}}
\newcommand{\EU}{{\mathrm{EU}}}
\newcommand{\ok}{\textsc{ok}}
\newcommand{\status}{\textsc{status}}
\newcommand{\bif}{\textbf{if}}
\newcommand{\bthen}{\textbf{then}}
\newcommand{\belse}{\textbf{else}}
\newcommand{\default}{\mathit{default}}

\newcommand{\ASMfm}{\mbox{ASM\!}\xspace}
\newcommand{\SMPfm}{\mbox{SMP\!}\xspace}
\newcommand{\SMPm}{\mbox{SMP}\xspace}
\newcommand{\SBMPfm}{\mbox{SBMP\!}\xspace}


\newcommand{\si}{{\sigma}}
\newcommand{\sip}{{\sigma p}}


\newcommand{\ie}{\emph{i.e.,\xspace}}
\newcommand{\etc}{\emph{etc.}\xspace}
\newcommand{\Ie}{\emph{I.e.,\ }}

\newcommand{\tri}[1]{\left<#1 \right>}
\newcommand{\abs}[1]{\left|#1 \right|}


\newcommand{\uT}{u^T}
\newcommand{\msg}{{\sf m}}

\newcommand{\ceil}[1]{\left\lceil{#1}\right\rceil}
\newcommand{\pare}[1]{\left({#1}\right)}
\newcommand{\set}[1]{\left\{{#1}\right\}}
\newcommand{\ang}[1]{\left\langle {#1} \right\rangle}
\newcommand{\range}[2]{\set{{#1},\dots,{#2}}}
\setlength{\parskip}{.5ex}
\def\beginsmall#1{\vspace{-\parskip}\begin{#1}\itemsep-\parskip}
\def\endsmall#1{\end{#1}\vspace{-\parskip}}


\newcommand{\cycle}{\textsc{cycle}\xspace}
\newcommand{\simpleAgree}{\textsc{DynamicByzConsensus}\xspace}
\newcommand{\kSetCons}{\textsc{Dynamic -vector-set Consensus}\xspace}
\newcommand{\mSetCons}{\textsc{Dynamic -vector-set Consensus}\xspace}
\newcommand{\mAD}{{\textit{m-}\textsc{ad}}\xspace}
\newcommand{\oAD}{{{\small 1-}\textsc{ad}}\xspace}

\newcommand{\setup}{\mbox{{\sc setup}}}
\newcommand{\transfer}{\mbox{{\sc transfer}}}
\newcommand{\itransfer}{\emph{transfer}}
\renewcommand{\transfer}{\mathit{transfer}}
\newcommand{\send}{\mbox{{\sc send}}}
\newcommand{\V}{\mathcal{V}}
\newcommand{\SD}{\mathcal{D}_{\textrm{send}}}
\newcommand{\TD}{\mathcal{D}_{\textrm{transfer}}}
\newcommand{\U}{\mathcal{E}_{\textrm{forge}}}
\newcommand{\inter}{\cap}
\newcommand{\T}{\mathcal{T}\!}
\newcommand{\RT}{\mathcal{RT}\!}
\newcommand{\PT}{\mathcal{PT}\!}
\newcommand{\RTo}{\mathcal{RT}\!\!.o}
\newcommand{\RTe}{\mathcal{RT}(\epsilon)}
\newcommand{\RTp}[1]{\PT_{#1}}
\newcommand{\HT}{\mathcal{HT}\!}
\newcommand{\CT}{\mathcal{CT}\!}
\newcommand{\DRT}{\mathcal{DRT}}
\newcommand{\IT}{\mathcal{IT}\!}
\newcommand{\ITs}{\mathcal{IT_{\!\sigma}}}
\newcommand{\GT}{\mathcal{GT}}
\newcommand{\VT}{\mathcal{VT}}
\newcommand{\sig}{\textrm{sig}}
\newcommand{\rsig}{\textrm{real-sig}}
\newcommand{\FO}{\mathcal{F}1}
\newcommand{\FZ}{\mathcal{F}0}
\newcommand{\F}{\mathcal{F}}
\newcommand{\FA}{\mathcal{F\!A}}
\newcommand{\D}{\mathcal{D\!}}
\newcommand{\Df}{\mathcal{D}_{\!\phi}}
\newcommand{\bad}{\mbox{\sc bad}\xspace}



\newcommand{\mes}[2]{\left\langle {\textrm{#1}},{#2} \right\rangle}

\newcounter{linenumbers}
\newcommand{\linenumberspecific}[1]{{\tt #1}}
\newcommand{\linenumber}{\stepcounter{linenumbers}\linenumberspecific{\arabic{linenumbers}:}}

\newcounter{todocounter}
\newcommand{\todonum}
{\stepcounter{todocounter}{(\thetodocounter)}}


\newcommand{\alert}[1]{\textbf{\color{red}
[[[#1]]]}}
\newcommand{\dd}[1]{\textbf{\color{blue}
[[\todonum\ dd: #1]]}}


\newcommand{\eli}[1]{\textbf{\color{green}
[[\todonum\ Eli: #1]]}}


\newcommand{\tb}{\makebox[0.6cm]{}}
\newcommand{\due}{\makebox[1cm]{}}
\newcommand{\tre}{\makebox[1.3cm]{}}
\newcommand{\quat}{\makebox[1.6cm]{}}


\newcommand{\hide}[1]{}



\newcommand{\eps}{\mbox{--}}

\newcommand{\fullv}[1]{\commentout{#1}}
\newcommand{\shortv}[1]{#1}
\newcommand{\commentout}[1]{}
\newcommand{\mediator}{\mathit{mediator}}
\newcommand{\Dom}{{\it DOM}}
\newcommand{\punish}{{\textsc{punish}}}
\newcommand{\pass}{{\textsc{pass}}}
\newcommand{\detect}{{\textsc{detect}}\xspace}

\newcommand{\idea}[1]{\textsf{#1}}
\newcommand{\M}{\mathcal{M}}
\newcommand{\Mrush}{\mathcal{M}_{\textrm{rush}}}
\newcommand{\R}{\mathcal{R}}
\newcommand{\I}{\mathcal{I}}
\newcommand{\cS}{\mathcal{S}}
\newcommand{\view}{\textsc{view}}
\newcommand{\PUNISH}{\textit{PUNISH}}
\newcommand{\DETECT}{\textit{DETECT}}
\newcommand{\WEAK}{\textit{WEAK}}
\newcommand{\EQUIV}{\textit{INDIST}}
\newcommand{\ERROR}{\textit{ERROR}}
\newcommand{\complaint}{\textit{complaint}}
\newcommand{\reconstruct}{\textit{Reconstruct}}







\newcommand{\Byzantine}[0]{\mbox{\emph{Byzantin}\hspace{-0.15em}\emph{e}}\xspace}


\newcommand{\gradecast}{\textsc{gradecast}\xspace}
\newcommand{\ca}{{\small\textsc{commit\!\_adopt}}\xspace}
\newcommand{\vote}{{\small \bf \textsc{vote}}\xspace}
\newcommand{\fourcast}{\textsc{4cast}\xspace}
\newcommand{\gc}{\textsc{gradecast}\xspace}
\newcommand{\gcs}{\textsc{gradecast}s\xspace}
\newcommand{\gcsup}{\textsc{gc-support}\xspace}
\newcommand{\gradecastgo}{\textsc{gradecasf-go}\xspace}
\newcommand{\gcgo}{\textsc{gradecasf-go}\xspace}
\newcommand{\gcreport}{\mbox{\textsc{gc-report}}}
\newcommand{\gcrprt}{\mbox{\textsc{gc-report}}}
\newcommand{\go}{\textsc{go}\xspace}
\newcommand{\agree}{\mbox{\textsc{agree}}\xspace}

\newcommand{\kfd}{\mbox{K{\sc fd}}}
\newcommand{\kgo}{\mbox{K{\sc go}}}
\newcommand{\kval}{\mbox{K{\sc val}}}
\newcommand{\f}{\mbox{\textsc{f}}\xspace}
\newcommand{\kf}{\mbox{\textsc{K-f}}\xspace}
\newcommand{\val}{\mbox{}}
\newcommand{\lp}{\mbox{}}
\newcommand{\fault}{\mbox{\sl fault}}
\newcommand{\faulty}{\mbox{\sl faulty}}
\newcommand{\suspect}{\mbox{\sl suspect}}
\newcommand{\suspected}{\mbox{\sl suspected}}
\newcommand{\grade}{\mbox{\sl grade}}
\newcommand{\early}{\mbox{\sl early}}
\newcommand{\stopped}{\mbox{\sl Stopped}}





\newcommand{\itrule}{\textsc{it-to-rt rule}\xspace} \newcommand{\earlyitrule}{\textsc{early\!\_it-to-rt rule}\xspace} \newcommand{\strongitrule}{\textsc{strong\_it-to-rt rule}\xspace} \newcommand{\decayrule}{\textsc{decay rule}\xspace} \newcommand{\gcrule}{\textsc{resolve rule}\xspace} \newcommand{\rgcrule}{\textsc{relaxed rule}\xspace} \newcommand{\srule}{\textsc{special-bot rule}\xspace} \newcommand{\srootrule}{\textsc{special-root-bot rule}\xspace} \newcommand{\haltingrule}{\textsc{halting rule}\xspace} \newcommand{\lastroundrule}{\textsc{round  rule}\xspace} 

\newcounter{linecounter}
\newcommand{\linenumbering}{\ifthenelse{\value{linecounter}<10}
{(0\arabic{linecounter})}{(\arabic{linecounter})}}
\renewcommand{\line}[1]{\refstepcounter{linecounter}\label{#1}\linenumbering}
\newcommand{\resetline}[1]{\setcounter{linecounter}{0}#1}
\renewcommand{\thelinecounter}{\ifnum \value{linecounter} > 
9\else 0\fi \arabic{linecounter}}


\begin{document}


\title{Synchronous Hybrid Message-Adversary}
\author{Danny Dolev (HUJI)\footnote{Email: danny.dolev@mail.huji.ac.il.} \ and
Eli Gafni (UCLA)\footnote{Email: gafnieli@gmail.com.}\A_i=\{p_\ell\mid \ell=1+ ((j-1+(i-1)(m+1))\mod n), \mbox{ for }1\le j\le m+1\}\,.

Thus a processor appears in at most  rounds. Thus, the largest number of rounds for which
we can attribute at least one id to the -fixed omission set is . Since we need at least
one processor from the -fixed set in each round we get the condition 
which yields .
}
\end{proof}
The lower bound proof implies that if we take  we will not be able to explain the run as an  run.
What is left is to show that indeed for  we have an algorithm that obtains ()-vector-set consensus.

An easy repetition of the lower bound arguments above show that if  we cannot solve -set consensus.


 


\section{Binary--vector-set Consensus}
For simplicity of exposition we will use only the binary--vector-set consensus even for \SMPfm as we know we can solve
the multi-valued one using \cite{Rachid}.
To show the phenomenon of consensus power growing gradually with  given fixed  and ,
we assume for convenience  that  and .
The algorithm rely on the idea of the rotating coordinator \cite{Reischuk198523,Chandra:1991:TME:112007.112027}.
Only that in hindsight we know that each phase of the implementation hides a \ca protocol \cite{Gafni98}.
\footnote{The \ca protocol is the concept behind last two rounds  of the original
Gradecast \cite{62225} protocol. }
Hence, we first pause the presentation and show how we solve \ca in \SMPfm and then in \SBMPfm.

\subsection{Commit-Adopt implementation for \SMPfm, and \SBMPfm }

In the \ca protocol each processor invokes \ca with an initial value. Each processor, ,  returns as an output a pair , where . \ca ensures that:
\beginsmall{enumerate}
\item[\textup{ CA1:}]
If all processors invoke \ca with the same value, then every processor, , returns with that value and with  {\sc commit}.
\item[\textup{ CA2:}]
If a processor, , returns  with {\sc commit}, then for any processor , . 
\endsmall{enumerate}

A \ca algorithm in \cite{Gafni98} is given in a wait-free shared-memory model.
To use this algorithm in different models we either implement the shared-memory in the model, or just show an implementation that 
comply with the properties that make \ca algorithm in shared-memory work.
The properties are to have two iteration where at most one value will be observed as a proposal to commit
in the second round, and if a processor views only commit proposal in the second round, then any
other processor in the second round will observe a proposal to commit.

In \SMPfm if all processors start with the same bit, every processor will get all messages of the same bit and there will be at least  of them.
A processor that receives all same bit, will propose in the second round to commit that bit.
Obviously, since majority sent same bit, no other processor will propose to commit a different bit.
 
In the second round, a processor commits if it obtains at least  proposals to commit.
A processor that does not propose to commit does not send a message.
Obviously if one processor receives  at least  proposals to commit, others cannot miss all these proposals and will see at least one proposal to commit,
and hence will adopt that bit.

In \SBMPfm we have to worry about the  processors  whose messages the adversary is allowed to tamper with.
Thus, we cannot require to see all messages of the same bit, since then the adversary can prevent commit in the case
that all started with the same bit. Nevertheless we know that if all started with the same bit then a processor will get 
at least  of that bit, and at most  of the complement bit.

Hence, we use this test in order to propose commit at the second round. Since in the worst case the complement bit
was send by ``correct'' processors, we nevertheless are left with more than quarter of correct processors whose input is that bit.
Hence, this set of processors in the first round will prevent any other processor to propose to commit the complement bit, 
as the size of the set is greater than . A processor that does not propose to commit does not send anything in the second round.

In the second round for a processor to ``read'' a commit proposal it is enough if it obtains at least  commit proposals of the same
bit. To commit, a processor needs to receive again at least  proposals of commit of the same bit (We can now ignore commit
of the different bit since there can be anyway at most  of them). 
Again we can argue that in the second round, if any processors commits, 
we must have at least  correct processors which send commit proposal of that bit and hence all will at least adopt that bit.


\figureref{figure:ca-omm} and \figureref{figure:ca} present both versions of the \ca protocol. 


\begin{algorithm}[!ht]
\footnotesize
\SetNlSty{textbf}{}{:}
 \setcounter{AlgoLine}{0}
\begin{tabular}{ r l }
\lnl{line:o-vote1} &  {\bf round 1:}   send  to all;\hspace{2.2in}\hfill\textit{/* executed by processor  */}\\
\\
\lnl{line:o-test}&  {\bf round 2:}  {\bf if}  all ``bits'' received are the same  {\bf then} {\bf send} the ``bit'' to all  {\bf else} {\bf do not send};\\
\nl & \tb\due \textit{/* Notations */}\\
\nl & \tb\due {\bf let}  be the bit received and let  be the number of processors that sent it;\\
\\
\nl &  \textit{/* Scoring */}\\
\lnl{line:o-commit}& \tb {\bf if}   {\bf then} {\bf set}  {\sc commit}  {\bf else} {\bf set}  {\sc adopt};\\
\lnl{line:o-value}& \tb {\bf if}  {\bf then} {\bf set}  ;\hfill\textit{/* otherwise remain with the original  */}\\
\\
\nl & {\bf return} .
\end{tabular}
\caption{ \ca\!: The Commit Adopt protocol for omission faults}\label{figure:ca-omm}
\end{algorithm}



\begin{algorithm}[!ht]
\footnotesize
\SetNlSty{textbf}{}{:}
 \setcounter{AlgoLine}{0}
\begin{tabular}{ r l }
\lnl{line:vote1} &  {\bf round 1:}   send  to all;\hspace{2.2in}\hfill\textit{/* executed by processor  */}\\
\nl & \tb\due \textit{/* Notations */}\\
\lnl{line:1st}& \tb\due {\bf let}  be the bit received the most and let be the number of processors that sent it;\\
\nl & \tb\due {\bf let}  be the bit received the least and let its number be ;\\
\\
\lnl{line:test}&  {\bf round 2:}  {\bf if}  and  {\bf then} {\bf send}    {\bf else} {\bf do not send};\\
\nl & \tb\due \textit{/* Notations */}\\
\nl & \tb\due {\bf let}  be the bit received the most and let  be the number of processors that sent it;\\
\\
\nl &  \textit{/* Scoring */}\\
\lnl{line:commit}& \tb {\bf if}   {\bf then} {\bf set}  {\sc commit}  {\bf else} {\bf set}  {\sc adopt};\\
\lnl{line:value}& \tb {\bf if}  {\bf then} {\bf set}  ;\hfill\textit{/* otherwise remain with the original  */}\\
\\
\nl & {\bf return} .
\end{tabular}
 \caption{ \ca\!: The Commit Adopt protocol for Byzantine faults}\label{figure:ca}
\end{algorithm}



\subsection{Binary--vector-set Consensus Protocol}



We first focus on the case of   For the discussion below assume that  
The idea of the protocol is to run in parallel the basic process for each of the  entries in the binary--vector-set consensus.  The process below will ensure that in each entry in the output vector different processors never produce conflicting outputs, and that for at least one entry all processors report an output.

We assign  coordinators to each phase of the protocol, one per entry in the vector.  The coordinators play a role in a specific round of sending messages in each phase, as described below.  We run the protocol for  phases, each takes three rounds of message exchange. 

For a given entry all processors repeatedly exchange their values in each phase.  Each phase begins with concurrently running a \ca on the current values of all processors.  In the first phase processors use their initial input values, and later phases the values  computed by the end of the previous phase. 

Following the \ca step the coordinator of the current phase broadcasts the value it obtained from the recent \ca.  

A processor that completed the recent \ca with {\sc commit} ignores the coordinator's message and updates its value to be the committed value of the \ca.
A processor that did not complete the recent \ca with {\sc commit} adopts the value it receives from the coordinator, if it received a value, if no value was received it remains with its original value.

By the end of this value updating we are guaranteed that if the coordinator was correct when it sent its coordinator's value, then all processors will end up holding identical values.  
The reason is 
that the \ca properties imply that if a processor returns from the \ca with {\sc commit}, all processors  return from the \ca with identical values, so this is also the value the correct coordinator sends.  
If this is not the case, every processor adopts the coordinator's value, and again they hold identical values.

Observe that our assumptions are that all processors receive the values from all correct processors, even when the adversary chooses to change their messages. Therefore, the current coordinator received the correct value from the \ca as every other processor.

Once all processors hold identical values, in all future phases the \ca at each processor will return {\sc commit} with that value, no matter who the rest of the coordinators are.

The above basic process is repeated for  phases for all the  entries of the -vector-set consensus.
After the end of the last phase each processor reports output for every entry in which the latest \ca returned  {\sc commit}. 
The \ca properties imply that there will not be any conflict on output values in any index. 
Moreover, for each entry for which in one of the first  phases there happened to be a correct coordinator sending its value,  all processors return that value for that entry.

What we are left  to discuss is why there would always be at least one correct coordinator in at least one entry in at least one phase. 
Although this argument is repetition of the argument in the lower-bound section, we repeat it here.  Observe that we assign to each phase    different coordinators.
The assignment of  coordinators to phases is such that for  each one appears in exactly  different phases.  This implies that there can be at most  phases in which at least one of the coordinators assigned to entries in that phase is from the fixed set .  Look at a phase in which no coordinator is from the fixed set.  The adversary can drop messages from at most  of the coordinators that send their coordinators' values in that phase.  Therefore, there should be an entry at which the coordinator sending the coordinator's value is correct.






\begin{algorithm}[!ht]
\footnotesize
\SetNlSty{textbf}{}{:}
 \setcounter{AlgoLine}{0}
\begin{tabular}{ r l }
\nl & \textit{/* Initialization */}\mbox{\hspace{2.5in}}\hfill\textit{/* executed by processor */}\\
\lnl{line:input}& {\bf let}  be the initial input to consensus index , ;\hfill\textit{/* the input values*/}\\
\nl &\tb\textit{/* the permutation over the set of   processors */}\\
\lnl{line:assign} & {\bf let} , where , for , ;\\
\\
\nl & \textit{/* Main loop for each of the  indices, , all of them in parallel */}\\
\nl & {\bf for} phase  to  {\bf do}\\

\lnl{line:ca} & \tb   {\bf \ca};\\
\\
\lnl{line:sender} & \tb  {\bf if}  {\bf then}    send  to all;\hfill\textit{/* the rotating coordinator for index  sends its value */}\\
\lnl{line:vote} & \tb\tb  {\bf let}  be the value received from ;\hfill\textit{/*  if no value was received */}\\
\\
\lnl{line:update1} & \tb {\bf if}  {\bf then}  \\
\lnl{line:update2} & \tb\tb  {\bf else if}  {\bf then} {\bf set} ;\hfill\textit{/*  adopt coordinator    value*/}\\
\nl & {\bf end for}\\
\\
\lnl{line:output}& {\bf for each} , : {\bf if}  {\bf then}   {\bf else} ;\\
\\
\nl & {\bf return} .
\end{tabular}
 \caption[caption]{:  \\\hspace{\textwidth}\mbox{\ \hspace{0.75in}}a  \Byzantine -vector-set consensus algorithm}\label{figure:mSetCons}
\end{algorithm}














Observe that for binary values one can replace the condition in \lref{line:value} of \figureref{figure:ca} to ,  since if  no processor returns with {\sc commit} then  non-Byzantine processors have sent both  and .  
For non-binary values, instead of testing for  we need to test for non- values,
and can replace the condition in \lref{line:value} of \figureref{figure:ca} to .
Moreover, 
one can  add a filtering  in \lref{line:1st}  to filter out values that do not conform with what one expects to receive, since they are clearly being sent by Byzantine processors.
Similar filter can be used in \lref{line:vote} of \figureref{figure:mSetCons}. 
We do not have any use for such a filtering in the protocols of the current paper.



One can generalize the lower bound proof of \sectionref{sec:lower-bound} for
-vector-set consensus algorithm for  to obtain a lower bound of .  
The \mSetCons protocol of
\figureref{figure:mSetCons} can be changed accordingly and will run in  phases. 
When increasing the number of of processors by  one can device a protocol that runs 
for only  phase.  Thus for  we can solve -set consensus.
for  we can solve  set consensus, etc. 



All the formal proofs appear in the appendix.






















 \section{Conclusions}

We introduced a new type of distributed-system call Hybrid-Message-Adversary.
It gives rise to phenomenon never seen before of set-consensus power changing gradually
even though the various types and number of faults do not change.
In our mind the only notion of set consensus that makes sense
in the Byzantine setting is that of binary-vector-set-consensus.
To our knowledge we are the first to ask this question, and in fact we
are still at loss but not far, we suspect, from an answer.

Next, we can imagine message adversary with mobile Byzantine faults
and combinations thereof with omission fixed or mobile faults etc..
In fact, the analogue of message adversary with mobile Byzantine faults
was studied in the domain of Cryptography under the name of mobile viruses, transient or proactive faults 
\cite{Ostrovsky:1991,Canetti1994,Rabin1998,Castro:2000},
but none looked at the relative power of tasks, let alone the set-consensus power.


Why should we? We recently \cite{CSC} 
started to suspect that ``natural systems'' can be characterized 
by their set consensus power. Thus if this is proved and we equate the set-consensus power of synchronous Byzantine
of  faults and \SBMPfm with , then they will be equivalent.

 
\newpage

\thispagestyle{empty}
\bibliographystyle{plain}
\bibliography{bibliography}
\newpage
\appendix

\noindent {\Large \bf Appendix}

\section{Proofs}\label{sec:Proofs}
We prove the correctness of \ca for the \SBMPfm model. The proof for the \SMPfm is much simpler.



\begin{claim}\label{claim:CA}
Assume  and \SBMPfm adversary.  The protocol of \figureref{figure:ca} meets the \ca requirements.
\end{claim}
\begin{proof}
To prove property CA1 observe that if all processors send an identical value in \lref{line:vote1} of \figureref{figure:ca} then each processor can receive at most   different values, from processors the adversary tampers with their messages. Therefore, at every processor the test in \lref{line:test} will bring it to propose this identical value.  Exactly for the same reasons each processor, , will set up  to be {\sc commit} and will return the identical value.

For CA2, assume that  processor  proposes a value in the second round of the protocol. Thus, the test in \lref{line:test} is .
Denote by  ,   and   the parameters processor  used in \lref{line:test} and  the multiset of  values it received, and 
respectively for another arbitrary processor .  
Consider two cases. The first case is when . 
In our model  may not contain at most the  values from omission faults and some of the values from the Byzantine processors. Since  and  there are at least  
values in  from  processors that are correct at the current sending step  and sent  to all.   should contain all these processors' values. The assumption that  implies that  contains at least  value of , therefore, \lref{line:test} of \figureref{figure:ca} implies that if  decides to propose a value it should be that .  Now consider the case that .  In this case the condition  implies that  This implies that   contains at least   values from  processors that are correct at the current sending step that sent , thus at least , and the rest of the above arguments hold.

The above argument implies that no two non-Byzantine processors send different values in the second round. 
Assume that  processor  commits in \lref{line:commit}.
Let  be a value committed to.  
Assume the above notations for the messages received in the 2nd round.
Neither  nor  can contain more than  non  values the are not .
Thus, the protocol implies that .
By definition we know that , all of which are correct at the current message sending step. 
Since  and ,   contains at least  copies of , thus more than  and more than .  
\end{proof}


\begin{claim}\label{claim:samev}
Assume  and \SBMPfm adversary.  In the \mSetCons protocol, if all processors' initial values to a given index  are the same, they output that value for that index at the end.
\end{claim}
\begin{proof}
In \mSetCons processors update their initial values either in \lref{line:update1} or \lref{line:update2} of \figureref{figure:mSetCons}.  By \claimref{claim:CA} we know that any invocation of it will result with all processors obtaining the identical value and with evaluation ``commit", therefore \lref{line:update2} will never be executed, and at the end of the protocol all will produce an identical value.
\end{proof}



\begin{claim}\label{claim:correct-coordinator}
Assume  and \SBMPfm adversary.  In the \mSetCons protocol, if  for some index  at some phase the coordinator  is correct when executing \lref{line:sender}, then after executing \lref{line:update1} or \lref{line:update2} of \figureref{figure:mSetCons} in that phase,  is identical at all processors. 
\end{claim}
\begin{proof}
Let  be the correct processor executing \lref{line:sender} of some index , in some phase . Consider two cases.  If there is any processor that completes  the \ca in \lref{line:ca} of phase  with ``commit" and the other if none.  In the first case, by the \ca properties we know that all processors complete the \ca with the same value (including the faulty processors).  Therefore, the value  will send in \lref{line:sender} is the same, and therefore all processors will complete \lref{line:vote} with the same value. This implies that no matter which of the two lines, \lref{line:update1} or \lref{line:update2}, any processor executes, all obtain the same value.
In the second case, no processor completes \lref{line:ca} with ``commit", and therefore all will execute \lref{line:update2} and will obtain the value the correct sender sent when it was correct while executing  \lref{line:sender}.
\end{proof}




\begin{theorem}\label{thm:mSetCons}
If  and assuming \SBMPfm adversary, the \mSetCons protocol satisfies the properties of -vector-set consensus, for .
\end{theorem}
\begin{proof}
In order to prevent having any correct coordinator in a phase all  processors assigned to be coordinators in that phase need to either be in the fixed set of  faulty, or one of the  processors that suffer from omission in that phase.
The definition of , where , for ,  assigns each processor  to exactly  times in the first  phases.  The fix set of  processors appear in at most  phases.  Therefore, there is a phase in which none of them appear.  Since omission faults can silence at most  processors in that phase, there is a correct processor executing \lref{line:sender}  of \figureref{figure:mSetCons}  in that phase. Let  be the index of that processor.

By \claimref{claim:correct-coordinator} we know that by the end of  that phase all processors hold the same values in their .  From the next phase on, until the end of phase  all will complete \lref{line:ca} in \figureref{figure:mSetCons} with ``commit", and will end up having the same value in the -th index.  Moreover,  for any other index , two processors that  assign a value to that index, assign the same value, since it is the value they completes \lref{line:ca} of index  with ``commit", and it is an identical value.
The remaining property of \kSetCons obviously holds as well.
\end{proof}




 \end{document}
