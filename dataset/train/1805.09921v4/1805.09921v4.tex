\documentclass{article} 

\usepackage[table]{xcolor}
	\definecolor{lightgray}{gray}{0.95}
\definecolor{C1}{HTML}{1F77B4}
    \definecolor{C2}{HTML}{FF7F0E}
    \definecolor{C3}{HTML}{2CA02C}
    \definecolor{C4}{HTML}{D62728}
    \definecolor{C5}{HTML}{9467BD}
    \colorlet{C1light}{C1!20!white}
    \colorlet{C2light}{C2!20!white}
    \colorlet{C3light}{C3!20!white}
    \colorlet{C4light}{C4!20!white}
    \colorlet{C5light}{C5!20!white}


\usepackage{iclr2019_conference,times}



\usepackage{amsmath,amsfonts,bm}

\newcommand{\figleft}{{\em (Left)}}
\newcommand{\figcenter}{{\em (Center)}}
\newcommand{\figright}{{\em (Right)}}
\newcommand{\figtop}{{\em (Top)}}
\newcommand{\figbottom}{{\em (Bottom)}}
\newcommand{\captiona}{{\em (a)}}
\newcommand{\captionb}{{\em (b)}}
\newcommand{\captionc}{{\em (c)}}
\newcommand{\captiond}{{\em (d)}}

\newcommand{\newterm}[1]{{\bf #1}}


\def\figref#1{figure~\ref{#1}}
\def\Figref#1{Figure~\ref{#1}}
\def\twofigref#1#2{figures \ref{#1} and \ref{#2}}
\def\quadfigref#1#2#3#4{figures \ref{#1}, \ref{#2}, \ref{#3} and \ref{#4}}
\def\secref#1{section~\ref{#1}}
\def\Secref#1{Section~\ref{#1}}
\def\twosecrefs#1#2{sections \ref{#1} and \ref{#2}}
\def\secrefs#1#2#3{sections \ref{#1}, \ref{#2} and \ref{#3}}
\def\eqref#1{equation~\ref{#1}}
\def\Eqref#1{Equation~\ref{#1}}
\def\plaineqref#1{\ref{#1}}
\def\chapref#1{chapter~\ref{#1}}
\def\Chapref#1{Chapter~\ref{#1}}
\def\rangechapref#1#2{chapters\ref{#1}--\ref{#2}}
\def\algref#1{algorithm~\ref{#1}}
\def\Algref#1{Algorithm~\ref{#1}}
\def\twoalgref#1#2{algorithms \ref{#1} and \ref{#2}}
\def\Twoalgref#1#2{Algorithms \ref{#1} and \ref{#2}}
\def\partref#1{part~\ref{#1}}
\def\Partref#1{Part~\ref{#1}}
\def\twopartref#1#2{parts \ref{#1} and \ref{#2}}

\def\ceil#1{\lceil #1 \rceil}
\def\floor#1{\lfloor #1 \rfloor}
\def\1{\bm{1}}
\newcommand{\train}{\mathcal{D}}
\newcommand{\valid}{\mathcal{D_{\mathrm{valid}}}}
\newcommand{\test}{\mathcal{D_{\mathrm{test}}}}

\def\eps{{\epsilon}}


\def\reta{{\textnormal{}}}
\def\ra{{\textnormal{a}}}
\def\rb{{\textnormal{b}}}
\def\rc{{\textnormal{c}}}
\def\rd{{\textnormal{d}}}
\def\re{{\textnormal{e}}}
\def\rf{{\textnormal{f}}}
\def\rg{{\textnormal{g}}}
\def\rh{{\textnormal{h}}}
\def\ri{{\textnormal{i}}}
\def\rj{{\textnormal{j}}}
\def\rk{{\textnormal{k}}}
\def\rl{{\textnormal{l}}}
\def\rn{{\textnormal{n}}}
\def\ro{{\textnormal{o}}}
\def\rp{{\textnormal{p}}}
\def\rq{{\textnormal{q}}}
\def\rr{{\textnormal{r}}}
\def\rs{{\textnormal{s}}}
\def\rt{{\textnormal{t}}}
\def\ru{{\textnormal{u}}}
\def\rv{{\textnormal{v}}}
\def\rw{{\textnormal{w}}}
\def\rx{{\textnormal{x}}}
\def\ry{{\textnormal{y}}}
\def\rz{{\textnormal{z}}}

\def\rvepsilon{{\mathbf{\epsilon}}}
\def\rvtheta{{\mathbf{\theta}}}
\def\rva{{\mathbf{a}}}
\def\rvb{{\mathbf{b}}}
\def\rvc{{\mathbf{c}}}
\def\rvd{{\mathbf{d}}}
\def\rve{{\mathbf{e}}}
\def\rvf{{\mathbf{f}}}
\def\rvg{{\mathbf{g}}}
\def\rvh{{\mathbf{h}}}
\def\rvu{{\mathbf{i}}}
\def\rvj{{\mathbf{j}}}
\def\rvk{{\mathbf{k}}}
\def\rvl{{\mathbf{l}}}
\def\rvm{{\mathbf{m}}}
\def\rvn{{\mathbf{n}}}
\def\rvo{{\mathbf{o}}}
\def\rvp{{\mathbf{p}}}
\def\rvq{{\mathbf{q}}}
\def\rvr{{\mathbf{r}}}
\def\rvs{{\mathbf{s}}}
\def\rvt{{\mathbf{t}}}
\def\rvu{{\mathbf{u}}}
\def\rvv{{\mathbf{v}}}
\def\rvw{{\mathbf{w}}}
\def\rvx{{\mathbf{x}}}
\def\rvy{{\mathbf{y}}}
\def\rvz{{\mathbf{z}}}

\def\erva{{\textnormal{a}}}
\def\ervb{{\textnormal{b}}}
\def\ervc{{\textnormal{c}}}
\def\ervd{{\textnormal{d}}}
\def\erve{{\textnormal{e}}}
\def\ervf{{\textnormal{f}}}
\def\ervg{{\textnormal{g}}}
\def\ervh{{\textnormal{h}}}
\def\ervi{{\textnormal{i}}}
\def\ervj{{\textnormal{j}}}
\def\ervk{{\textnormal{k}}}
\def\ervl{{\textnormal{l}}}
\def\ervm{{\textnormal{m}}}
\def\ervn{{\textnormal{n}}}
\def\ervo{{\textnormal{o}}}
\def\ervp{{\textnormal{p}}}
\def\ervq{{\textnormal{q}}}
\def\ervr{{\textnormal{r}}}
\def\ervs{{\textnormal{s}}}
\def\ervt{{\textnormal{t}}}
\def\ervu{{\textnormal{u}}}
\def\ervv{{\textnormal{v}}}
\def\ervw{{\textnormal{w}}}
\def\ervx{{\textnormal{x}}}
\def\ervy{{\textnormal{y}}}
\def\ervz{{\textnormal{z}}}

\def\rmA{{\mathbf{A}}}
\def\rmB{{\mathbf{B}}}
\def\rmC{{\mathbf{C}}}
\def\rmD{{\mathbf{D}}}
\def\rmE{{\mathbf{E}}}
\def\rmF{{\mathbf{F}}}
\def\rmG{{\mathbf{G}}}
\def\rmH{{\mathbf{H}}}
\def\rmI{{\mathbf{I}}}
\def\rmJ{{\mathbf{J}}}
\def\rmK{{\mathbf{K}}}
\def\rmL{{\mathbf{L}}}
\def\rmM{{\mathbf{M}}}
\def\rmN{{\mathbf{N}}}
\def\rmO{{\mathbf{O}}}
\def\rmP{{\mathbf{P}}}
\def\rmQ{{\mathbf{Q}}}
\def\rmR{{\mathbf{R}}}
\def\rmS{{\mathbf{S}}}
\def\rmT{{\mathbf{T}}}
\def\rmU{{\mathbf{U}}}
\def\rmV{{\mathbf{V}}}
\def\rmW{{\mathbf{W}}}
\def\rmX{{\mathbf{X}}}
\def\rmY{{\mathbf{Y}}}
\def\rmZ{{\mathbf{Z}}}

\def\ermA{{\textnormal{A}}}
\def\ermB{{\textnormal{B}}}
\def\ermC{{\textnormal{C}}}
\def\ermD{{\textnormal{D}}}
\def\ermE{{\textnormal{E}}}
\def\ermF{{\textnormal{F}}}
\def\ermG{{\textnormal{G}}}
\def\ermH{{\textnormal{H}}}
\def\ermI{{\textnormal{I}}}
\def\ermJ{{\textnormal{J}}}
\def\ermK{{\textnormal{K}}}
\def\ermL{{\textnormal{L}}}
\def\ermM{{\textnormal{M}}}
\def\ermN{{\textnormal{N}}}
\def\ermO{{\textnormal{O}}}
\def\ermP{{\textnormal{P}}}
\def\ermQ{{\textnormal{Q}}}
\def\ermR{{\textnormal{R}}}
\def\ermS{{\textnormal{S}}}
\def\ermT{{\textnormal{T}}}
\def\ermU{{\textnormal{U}}}
\def\ermV{{\textnormal{V}}}
\def\ermW{{\textnormal{W}}}
\def\ermX{{\textnormal{X}}}
\def\ermY{{\textnormal{Y}}}
\def\ermZ{{\textnormal{Z}}}

\def\vzero{{\bm{0}}}
\def\vone{{\bm{1}}}
\def\vmu{{\bm{\mu}}}
\def\vtheta{{\bm{\theta}}}
\def\va{{\bm{a}}}
\def\vb{{\bm{b}}}
\def\vc{{\bm{c}}}
\def\vd{{\bm{d}}}
\def\ve{{\bm{e}}}
\def\vf{{\bm{f}}}
\def\vg{{\bm{g}}}
\def\vh{{\bm{h}}}
\def\vi{{\bm{i}}}
\def\vj{{\bm{j}}}
\def\vk{{\bm{k}}}
\def\vl{{\bm{l}}}
\def\vm{{\bm{m}}}
\def\vn{{\bm{n}}}
\def\vo{{\bm{o}}}
\def\vp{{\bm{p}}}
\def\vq{{\bm{q}}}
\def\vr{{\bm{r}}}
\def\vs{{\bm{s}}}
\def\vt{{\bm{t}}}
\def\vu{{\bm{u}}}
\def\vv{{\bm{v}}}
\def\vw{{\bm{w}}}
\def\vx{{\bm{x}}}
\def\vy{{\bm{y}}}
\def\vz{{\bm{z}}}

\def\evalpha{{\alpha}}
\def\evbeta{{\beta}}
\def\evepsilon{{\epsilon}}
\def\evlambda{{\lambda}}
\def\evomega{{\omega}}
\def\evmu{{\mu}}
\def\evpsi{{\psi}}
\def\evsigma{{\sigma}}
\def\evtheta{{\theta}}
\def\eva{{a}}
\def\evb{{b}}
\def\evc{{c}}
\def\evd{{d}}
\def\eve{{e}}
\def\evf{{f}}
\def\evg{{g}}
\def\evh{{h}}
\def\evi{{i}}
\def\evj{{j}}
\def\evk{{k}}
\def\evl{{l}}
\def\evm{{m}}
\def\evn{{n}}
\def\evo{{o}}
\def\evp{{p}}
\def\evq{{q}}
\def\evr{{r}}
\def\evs{{s}}
\def\evt{{t}}
\def\evu{{u}}
\def\evv{{v}}
\def\evw{{w}}
\def\evx{{x}}
\def\evy{{y}}
\def\evz{{z}}

\def\mA{{\bm{A}}}
\def\mB{{\bm{B}}}
\def\mC{{\bm{C}}}
\def\mD{{\bm{D}}}
\def\mE{{\bm{E}}}
\def\mF{{\bm{F}}}
\def\mG{{\bm{G}}}
\def\mH{{\bm{H}}}
\def\mI{{\bm{I}}}
\def\mJ{{\bm{J}}}
\def\mK{{\bm{K}}}
\def\mL{{\bm{L}}}
\def\mM{{\bm{M}}}
\def\mN{{\bm{N}}}
\def\mO{{\bm{O}}}
\def\mP{{\bm{P}}}
\def\mQ{{\bm{Q}}}
\def\mR{{\bm{R}}}
\def\mS{{\bm{S}}}
\def\mT{{\bm{T}}}
\def\mU{{\bm{U}}}
\def\mV{{\bm{V}}}
\def\mW{{\bm{W}}}
\def\mX{{\bm{X}}}
\def\mY{{\bm{Y}}}
\def\mZ{{\bm{Z}}}
\def\mBeta{{\bm{\beta}}}
\def\mPhi{{\bm{\Phi}}}
\def\mLambda{{\bm{\Lambda}}}
\def\mSigma{{\bm{\Sigma}}}

\DeclareMathAlphabet{\mathsfit}{\encodingdefault}{\sfdefault}{m}{sl}
\SetMathAlphabet{\mathsfit}{bold}{\encodingdefault}{\sfdefault}{bx}{n}
\newcommand{\tens}[1]{\bm{\mathsfit{#1}}}
\def\tA{{\tens{A}}}
\def\tB{{\tens{B}}}
\def\tC{{\tens{C}}}
\def\tD{{\tens{D}}}
\def\tE{{\tens{E}}}
\def\tF{{\tens{F}}}
\def\tG{{\tens{G}}}
\def\tH{{\tens{H}}}
\def\tI{{\tens{I}}}
\def\tJ{{\tens{J}}}
\def\tK{{\tens{K}}}
\def\tL{{\tens{L}}}
\def\tM{{\tens{M}}}
\def\tN{{\tens{N}}}
\def\tO{{\tens{O}}}
\def\tP{{\tens{P}}}
\def\tQ{{\tens{Q}}}
\def\tR{{\tens{R}}}
\def\tS{{\tens{S}}}
\def\tT{{\tens{T}}}
\def\tU{{\tens{U}}}
\def\tV{{\tens{V}}}
\def\tW{{\tens{W}}}
\def\tX{{\tens{X}}}
\def\tY{{\tens{Y}}}
\def\tZ{{\tens{Z}}}


\def\gA{{\mathcal{A}}}
\def\gB{{\mathcal{B}}}
\def\gC{{\mathcal{C}}}
\def\gD{{\mathcal{D}}}
\def\gE{{\mathcal{E}}}
\def\gF{{\mathcal{F}}}
\def\gG{{\mathcal{G}}}
\def\gH{{\mathcal{H}}}
\def\gI{{\mathcal{I}}}
\def\gJ{{\mathcal{J}}}
\def\gK{{\mathcal{K}}}
\def\gL{{\mathcal{L}}}
\def\gM{{\mathcal{M}}}
\def\gN{{\mathcal{N}}}
\def\gO{{\mathcal{O}}}
\def\gP{{\mathcal{P}}}
\def\gQ{{\mathcal{Q}}}
\def\gR{{\mathcal{R}}}
\def\gS{{\mathcal{S}}}
\def\gT{{\mathcal{T}}}
\def\gU{{\mathcal{U}}}
\def\gV{{\mathcal{V}}}
\def\gW{{\mathcal{W}}}
\def\gX{{\mathcal{X}}}
\def\gY{{\mathcal{Y}}}
\def\gZ{{\mathcal{Z}}}

\def\sA{{\mathbb{A}}}
\def\sB{{\mathbb{B}}}
\def\sC{{\mathbb{C}}}
\def\sD{{\mathbb{D}}}
\def\sF{{\mathbb{F}}}
\def\sG{{\mathbb{G}}}
\def\sH{{\mathbb{H}}}
\def\sI{{\mathbb{I}}}
\def\sJ{{\mathbb{J}}}
\def\sK{{\mathbb{K}}}
\def\sL{{\mathbb{L}}}
\def\sM{{\mathbb{M}}}
\def\sN{{\mathbb{N}}}
\def\sO{{\mathbb{O}}}
\def\sP{{\mathbb{P}}}
\def\sQ{{\mathbb{Q}}}
\def\sR{{\mathbb{R}}}
\def\sS{{\mathbb{S}}}
\def\sT{{\mathbb{T}}}
\def\sU{{\mathbb{U}}}
\def\sV{{\mathbb{V}}}
\def\sW{{\mathbb{W}}}
\def\sX{{\mathbb{X}}}
\def\sY{{\mathbb{Y}}}
\def\sZ{{\mathbb{Z}}}

\def\emLambda{{\Lambda}}
\def\emA{{A}}
\def\emB{{B}}
\def\emC{{C}}
\def\emD{{D}}
\def\emE{{E}}
\def\emF{{F}}
\def\emG{{G}}
\def\emH{{H}}
\def\emI{{I}}
\def\emJ{{J}}
\def\emK{{K}}
\def\emL{{L}}
\def\emM{{M}}
\def\emN{{N}}
\def\emO{{O}}
\def\emP{{P}}
\def\emQ{{Q}}
\def\emR{{R}}
\def\emS{{S}}
\def\emT{{T}}
\def\emU{{U}}
\def\emV{{V}}
\def\emW{{W}}
\def\emX{{X}}
\def\emY{{Y}}
\def\emZ{{Z}}
\def\emSigma{{\Sigma}}

\newcommand{\etens}[1]{\mathsfit{#1}}
\def\etLambda{{\etens{\Lambda}}}
\def\etA{{\etens{A}}}
\def\etB{{\etens{B}}}
\def\etC{{\etens{C}}}
\def\etD{{\etens{D}}}
\def\etE{{\etens{E}}}
\def\etF{{\etens{F}}}
\def\etG{{\etens{G}}}
\def\etH{{\etens{H}}}
\def\etI{{\etens{I}}}
\def\etJ{{\etens{J}}}
\def\etK{{\etens{K}}}
\def\etL{{\etens{L}}}
\def\etM{{\etens{M}}}
\def\etN{{\etens{N}}}
\def\etO{{\etens{O}}}
\def\etP{{\etens{P}}}
\def\etQ{{\etens{Q}}}
\def\etR{{\etens{R}}}
\def\etS{{\etens{S}}}
\def\etT{{\etens{T}}}
\def\etU{{\etens{U}}}
\def\etV{{\etens{V}}}
\def\etW{{\etens{W}}}
\def\etX{{\etens{X}}}
\def\etY{{\etens{Y}}}
\def\etZ{{\etens{Z}}}

\newcommand{\pdata}{p_{\rm{data}}}
\newcommand{\ptrain}{\hat{p}_{\rm{data}}}
\newcommand{\Ptrain}{\hat{P}_{\rm{data}}}
\newcommand{\pmodel}{p_{\rm{model}}}
\newcommand{\Pmodel}{P_{\rm{model}}}
\newcommand{\ptildemodel}{\tilde{p}_{\rm{model}}}
\newcommand{\pencode}{p_{\rm{encoder}}}
\newcommand{\pdecode}{p_{\rm{decoder}}}
\newcommand{\precons}{p_{\rm{reconstruct}}}

\newcommand{\laplace}{\mathrm{Laplace}} 

\newcommand{\E}{\mathbb{E}}
\newcommand{\Ls}{\mathcal{L}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\emp}{\tilde{p}}
\newcommand{\lr}{\alpha}
\newcommand{\reg}{\lambda}
\newcommand{\rect}{\mathrm{rectifier}}
\newcommand{\softmax}{\mathrm{softmax}}
\newcommand{\sigmoid}{\sigma}
\newcommand{\softplus}{\zeta}
\newcommand{\KL}{D_{\mathrm{KL}}}
\newcommand{\Var}{\mathrm{Var}}
\newcommand{\standarderror}{\mathrm{SE}}
\newcommand{\Cov}{\mathrm{Cov}}
\newcommand{\normlzero}{L^0}
\newcommand{\normlone}{L^1}
\newcommand{\normltwo}{L^2}
\newcommand{\normlp}{L^p}
\newcommand{\normmax}{L^\infty}

\newcommand{\parents}{Pa} 

\DeclareMathOperator*{\argmax}{arg\,max}
\DeclareMathOperator*{\argmin}{arg\,min}

\DeclareMathOperator{\sign}{sign}
\DeclareMathOperator{\Tr}{Tr}
\let\ab\allowbreak
 
\usepackage{hyperref}
\usepackage{url}

\usepackage{url}            \usepackage{booktabs}       \usepackage{multicol}
\usepackage{multirow}
\usepackage{sidecap}
\usepackage{array}			\usepackage{amsfonts}       \usepackage{nicefrac}       \usepackage{graphicx}       \usepackage{bibunits}
\usepackage{capt-of}
\usepackage[activate={true,nocompatibility},final,tracking=true,kerning=true,spacing=true,factor=1100,stretch=10,shrink=20]{microtype}
\SetTracking{encoding={*}, shape=sc}{20}


\usepackage{fontawesome}
\DeclareFontFamily{U}{fontawesome1}{}
    \DeclareFontShape{U}{fontawesome1}{m}{n}{<->FontAwesome--fontawesomeone}{}
    \DeclareFontFamily{U}{fontawesome2}{}
    \DeclareFontShape{U}{fontawesome2}{m}{n}{<->FontAwesome--fontawesometwo}{}
    \DeclareFontFamily{U}{fontawesome3}{}
    \DeclareFontShape{U}{fontawesome3}{m}{n}{<->FontAwesome--fontawesomethree}{}
    \DeclareRobustCommand{\FAone}{\usefont{U}{fontawesome1}{m}{n}}
    \DeclareRobustCommand{\FAtwo}{\usefont{U}{fontawesome2}{m}{n}}
    \DeclareRobustCommand{\FAthree}{\usefont{U}{fontawesome3}{m}{n}}

\usepackage[normalem]{ulem}	\usepackage{enumitem}
  \newlist{inlinelist}{enumerate*}{1}
  \setlist*[inlinelist,1]{label=(\roman*),
      }
\usepackage{bm}
\usepackage{bbm} 
\usepackage{wrapfig}
\usepackage[capbesideposition=outside,capbesidesep=quad]{floatrow}
\floatsetup[table]{capposition=top}
\usepackage{mathtools}
\usepackage{pgfmath}
\usepackage{pgf}
\usepackage{tikz}
\usepackage{pgfplots}
	\usepgfplotslibrary{groupplots}
  \usetikzlibrary{calc}
  \usetikzlibrary{positioning}
  \usetikzlibrary{angles,quotes}
  \usetikzlibrary{backgrounds}
  \usetikzlibrary{external}
  \usetikzlibrary{fit}
  \usetikzlibrary{bayesnet}
  \usetikzlibrary{calc}
  \usetikzlibrary{fit}
  \usetikzlibrary{spy, shadows}
  \usetikzlibrary{arrows.meta}
  \usetikzlibrary{shadings}
  \usetikzlibrary{fadings}
\usetikzlibrary{matrix}
\usepackage[font=small,labelfont=bf]{caption}
\usepackage[capitalize]{cleveref}
\usepackage{subcaption}
\usepackage{amsfonts}

\usepackage{standalone}
\usepackage{xargs}
\usepackage{amssymb}

\newcommand*{\nolink}[1]{{\protect\NoHyper#1\protect\endNoHyper}}



\usepackage[colorinlistoftodos,prependcaption,textsize=tiny]{todonotes}
\newcommandx{\mbnote}[2][1=]{\todo[linecolor=red,backgroundcolor=red!25,bordercolor=red,#1]{JR: #2}}
\newcommandx{\jbnote}[2][1=]{\todo[linecolor=blue,backgroundcolor=blue!25,bordercolor=blue,#1]{JB: #2}}
\newcommandx{\jgnote}[2][1=]{\todo[linecolor=green,backgroundcolor=green!25,bordercolor=green,#1]{JG: #2}}
\newcommandx{\retnote}[2][1=]{\todo[linecolor=purple,backgroundcolor=purple!25,bordercolor=purple,#1]{RT: #2}}
\newcommandx{\snnote}[2][1=]{\todo[linecolor=yellow,backgroundcolor=yellow!25,bordercolor=yellow,#1]{SN: #2}}
\newcommandx{\thiswillnotshow}[2][1=]{\todo[disable,#1]{#2}}
\setlength{\marginparwidth}{3.4cm}

\newcommand{\mbadd}[1]{{\color{red} MB: #1}}
\newcommand{\jbadd}[1]{{\color{blue} JB: #1}}
\newcommand{\jgadd}[1]{{\color{red} JG: #1}}

\begin{filecontents*}{nll_planes.dat}
	x   y yerr   label
	0 0.645 0.0 cvae
    1 0.640 0.0 versa
\end{filecontents*}

\begin{filecontents*}{nll_chairs.dat}
	x   y yerr   label
	0 0.650 0.0 cvae
    1 0.643 0.0 versa
\end{filecontents*}

\begin{filecontents*}{mse_planes.dat}
	x y yerr label
	0 0.0208 0.0 cvae
    1 0.0099 0.0 versa
\end{filecontents*}

\begin{filecontents*}{mse_chairs.dat}
	x y yerr label
	0 0.0320 0.0 cvae
    1 0.0173 0.0 versa
\end{filecontents*}


\begin{filecontents*}{ssim_planes.dat}
	x y yerr    label
	0 0.779 0.0 cvae 
    1 0.894 0.0 versa
\end{filecontents*}


\begin{filecontents*}{ssim_chairs.dat}
	x y yerr    label
	0 0.560 0.0 cvae
    1 0.727 0.0 versa
\end{filecontents*}

\usepackage{filecontents}
\begin{filecontents*}{5way1shot.dat}
	x y yerr    label
	0 98.1 0.0  matching
	2 98.1 0.0  neural
	3 98.4 0.0  memory
	4 98.8 0.1  prototypical 
	5 98.7 0.4  maml
	7 97.7 0.1  reptile
	8 99.37 0.28 ours
\end{filecontents*}

\begin{filecontents*}{5way5shot.dat}
	x y yerr    label
	0 98.9 0.0  matching
	2 99.5 0.0  neural
	3 99.6 0.0  memory
	4 99.7 0.1  prototypical 
	5 99.9 0.1  maml
	7 99.5 0.06  reptile
	8 99.62 0.15 ours
\end{filecontents*}

\begin{filecontents*}{20way1shot.dat}
	x y yerr    label
	0 93.8 0.0  matching
	2 93.2 0.0  neural
	3 95.0 0.0  memory
	4 96.0 0.0  prototypical 
	5 95.8 0.3  maml
	7 89.4 0.1  reptile
	8 97.37 0.32 ours 
\end{filecontents*}

\begin{filecontents*}{20way5shot.dat}
	x y yerr    label
	0 98.5 0.0  matching
	2 98.1 0.0  neural
	3 98.6 0.0  memory
	4 98.9 0.0  prototypical 
	5 98.9 0.2  maml
	7 97.1 0.1  reptile
	8 98.72 0.17 ours 
\end{filecontents*}


\begin{filecontents*}{5way1shot_mi.dat}
	x y    yerr    label
	0 46.6 0.0  matching
	1 43.3 0.8  meta
	4 49.4 0.1  prototypical 
	5 48.7 1.8  maml
	6 49.4 1.8  llama
	7 50.1 1.9  platipus
	8 50.0 0.3  reptile
	9 53.4 1.87  ours
\end{filecontents*}


\begin{filecontents*}{5way5shot_mi.dat}
	x y    yerr    label
	0 60.0 0.0  matching
	1 60.6 1.5  meta
	4 68.2 0.7  prototypical 
	5 63.1 0.9  maml
	8 66.0 0.6  reptile
	9 64.76 0.95  ours
\end{filecontents*}


\newcommand{\Versa}{\textsc{Versa}}
\renewcommand{\d}{\mathrm{d}}
\newcommand{\miniimagenet}{\textit{mini}ImageNet}


\title{Meta-Learning Probabilistic Inference For Prediction}



\author{Jonathan Gordon\thanks{Authors contributed equally}, John Bronskill\footnotemark[1]\\
University of Cambridge\\
\texttt{\{jg801,jfb54\}@cam.ac.uk} \\
\And
Matthias Bauer \\
University of Cambridge\\
Max Planck Institute for Intelligent Systems\\
\texttt{bauer@tue.mpg.de} \\
\AND
Sebastian Nowozin\thanks{Work done while at Microsoft Research}\\
Google AI Berlin\\
\texttt{nowozin@google.com }
\And
Richard E.~Turner\\
University of Cambridge\\
Microsoft Research\\
\texttt{ret26@cam.ac.uk}
}



\newcommand{\fix}{\marginpar{FIX}}
\newcommand{\new}{\marginpar{NEW}}

\iclrfinalcopy \begin{document}


\maketitle

\begin{abstract}
This paper introduces a new framework for data efficient and versatile learning. Specifically:
1) We develop ML-PIP, a general framework for Meta-Learning approximate Probabilistic Inference for Prediction. ML-PIP extends existing probabilistic interpretations of meta-learning to cover a broad class of methods. 
2) We introduce \Versa{}, an instance of the framework employing a flexible and versatile amortization network that takes few-shot learning datasets as inputs, with arbitrary numbers of shots, and outputs a distribution over task-specific parameters in a single forward pass. \Versa{} substitutes optimization at test time with forward passes through inference networks, amortizing the cost of inference and relieving the need for second derivatives during training.
3) We evaluate \Versa{} on benchmark datasets where the method sets new state-of-the-art results, handles arbitrary numbers of shots, and for classification, arbitrary numbers of classes at train and test time. The power of the approach is then demonstrated through a challenging few-shot ShapeNet view reconstruction task. 
\end{abstract}

\section{Introduction}
\label{sec:intro}

Many applications require predictions to be made on myriad small, but related datasets. In such cases, it is natural to desire learners that can rapidly adapt to new datasets at test time. These applications have given rise to vast interest in \textit{few-shot learning} \citep{fei2006one, lake2011one}, which emphasizes \textit{data efficiency} via information sharing across related tasks. Despite recent advances, notably in meta-learning based approaches \citep{ravi2016optimization,vinyals2016matching,edwards2016towards,finn2017model,lacoste2018uncertainty}, there remains a lack of general purpose methods for flexible, data-efficient learning.


Due to the ubiquity of recent work, a unifying view is needed to understand and improve these methods. Existing frameworks \citep{grant2018recasting,finn2018probabilistic} are limited to specific families of approaches. In this paper we develop a framework for meta-learning approximate probabilistic inference for prediction (ML-PIP), providing this view in terms of amortizing posterior predictive distributions. In \cref{sec:related_work}, we show that ML-PIP re-frames and extends existing point-estimate probabilistic interpretations of meta-learning \citep{grant2018recasting, finn2018probabilistic} to cover a broader class of methods, including gradient based meta-learning \citep{finn2017model,ravi2016optimization}, metric based meta-learning \citep{snell2017prototypical}, amortized MAP inference \citep{qiao2017few} and conditional probability modelling \citep{garnelo2018conditional, garnelo2018neural}.


The framework incorporates three key elements. First, we leverage shared statistical structure between tasks via hierarchical probabilistic models developed for multi-task and transfer learning \citep{heskes2000empirical,bakker2003task}. 
Second, we share information between tasks about how to learn and perform inference using meta-learning \citep{naik1992meta,thrun2012learning,schmidhuber1987evolutionary}. Since uncertainty is rife in small datasets, we provide a procedure for meta-learning probabilistic inference.
Third, we enable fast learning that can flexibly handle a wide range of tasks and learning settings via amortization \citep{kingma2013auto,rezende2014stochastic}. 


Building on the framework, we propose a new method -- \Versa{} -- which substitutes optimization procedures at test time with forward passes through inference networks. This amortizes the cost of inference, resulting in faster test-time performance, and relieves the need for second derivatives during training. \Versa{} employs a flexible amortization network that takes few-shot learning datasets, and outputs a distribution over task-specific parameters in a single forward pass. The network can handle arbitrary numbers of shots, and for classification, arbitrary numbers of classes at train and test time (see \cref{sec:amortisation}). In \cref{sec:experiments}, we evaluate \Versa{} on 
\begin{inlinelist}
    \item standard benchmarks where the method sets new state-of-the-art results,
    \item settings where test conditions (shot and way) differ from training, and
    \item a challenging one-shot view reconstruction task.
\end{inlinelist}


























\section{Meta-Learning Probabilistic Inference For Prediction}
\label{sec:MLPIP}

We now present the framework that consists of
\begin{inlinelist}
\item a multi-task probabilistic model, and
\item a method for meta-learning probabilistic inference.
\end{inlinelist}

\subsection{Probabilistic Model} 
\label{sec:model}
Two principles guide the choice of model. First, the use of discriminative models to maximize predictive performance on supervised learning tasks \citep{ng2002discriminative}. Second, the need to leverage shared statistical structure between tasks (i.e.~multi-task learning). These criteria are met by the standard multi-task directed graphical model shown in \cref{fig:model_graph} that employs shared parameters , which are common to all tasks, and task specific parameters . Inputs are denoted  and outputs . Training data  , and  test data  are explicitly distinguished for each task , as this is key for few-shot learning. 
\begin{figure}[h]
	\centering
	\includestandalone[scale=0.8]{graphs/mtl_graph}
	\caption[short]{Directed graphical model for multi-task learning.}
	\label{fig:model_graph}
\end{figure}


Let  and  denote all the inputs and outputs (both test and train) for task . The joint probability of the outputs and task specific parameters for  tasks, given the inputs and global parameters is:



In the next section, the goal is to meta-learn fast and accurate approximations to the posterior predictive distribution  for unseen tasks .



\subsection{Probabilistic Inference}

This section provides a framework for meta-learning approximate inference that is a simple reframing and extension of existing approaches \citep{finn2017model, grant2018recasting}. We will employ point estimates for the shared parameters  since data across all tasks will pin down their value. Distributional estimates will be used for the task-specific parameters since only a few shots constrain them.

Once the shared parameters are learned, the probabilistic solution to few-shot learning in the model above comprises two steps. First, form the posterior distribution over the task-specific parameters . Second, compute the posterior predictive . These steps will require approximation and the emphasis here is on performing this quickly at test time. We will describe the form of the approximation, the optimization problem used to learn it, and how to implement this efficiently below. In what follows we initially suppress dependencies on the inputs  and shared parameters  to reduce notational clutter, but will reintroduce these at the end of the section.

\paragraph{Specification of the approximate posterior predictive distribution.} Our framework approximates the posterior predictive distribution by an amortized distribution . That is, we learn a feed-forward inference network with parameters  that takes any training dataset  and test input  as inputs and returns the predictive distribution over the test output . We construct this by amortizing the approximate posterior  and then form the approximate posterior predictive distribution using:

This step may require additional approximation e.g.~Monte Carlo sampling. The amortization will enable fast predictions at test time. The form of these distributions is identical to those used in amortized variational inference \citep{edwards2016towards,kingma2013auto}. In this work, we use a factorized Gaussian distribution for  with means and variances set by the amortization network. However, the training method described next is different. 

\paragraph{Meta-learning the approximate posterior predictive distribution.} 
The quality of the approximate posterior predictive for a single task will be measured by the KL-divergence between the true and approximate posterior predictive distribution . The goal of learning will be to minimize the expected value of this KL averaged over tasks, 

Training will therefore return parameters  that best approximate the posterior predictive distribution in an average KL sense. So, if the approximate posterior  is rich enough, \textit{global} optimization will recover the true posterior  (assuming  obeys identifiability conditions \citep{casella2002statistical}).\footnote{Note that the true \textit{predictive} posterior  is recovered regardless of the identifiability of .} Thus, the amortized procedure meta-learns approximate inference that supports accurate prediction. \cref{app:bdt_derivation} provides a generalized derivation of the framework, grounded in Bayesian decision theory \citep{jaynes2003probability}.
 
The right hand side of \cref{eqn:predictive_kl_objective} indicates how training could proceed: 
\begin{inlinelist}
    \item select a task  at random,
    \item sample some training data ,
    \item form the posterior predictive  and,
    \item compute the log-density  at test data  \emph{not included in} .
\end{inlinelist}   
Repeating this process many times and averaging the results would provide an unbiased estimate of the objective which can then be optimized. This perspective also makes it clear that the procedure is scoring the approximate inference procedure by simulating approximate Bayesian held-out log-likelihood evaluation. Importantly, while an inference network is used to approximate posterior distributions, the training procedure differs significantly from standard variational inference. In particular, rather than minimizing , our objective function directly focuses on the posterior predictive distribution and minimizes .

\paragraph{End-to-end stochastic training.} 
Armed by the insights above we now layout the full training procedure. We reintroduce inputs and shared parameters  and the objective becomes:

We optimize the objective over the shared parameters  as this will maximize predictive performance (i.e., Bayesian held out likelihood). An end-to-end stochastic training objective for  and  is:

and , where  represents the data distribution (e.g., sampling tasks and splitting them into disjoint training data  and test data ). This type of training therefore uses episodic train / test splits at meta-train time.
We have also approximated the integral over  using  Monte Carlo samples. The local reparametrization \citep{kingma2015variational} trick enables optimization. Interestingly, the learning objective does not require an explicit specification of the prior distribution over parameters, , learning it implicitly through  instead. 
 
In summary, we have developed an approach for Meta-Learning Probabilistic Inference for Prediction (ML-PIP). A simple investigation of the inference method with synthetic data is provided in \cref{sec:toy_experiment}. In \cref{sec:related_work} we will show that this formulation unifies a number of existing approaches, but first we discuss a particular instance of the ML-PIP framework that supports versatile learning. 

\section{Versatile Amortized Inference}
\label{sec:amortisation}
A versatile system is one that makes inferences both rapidly \textit{and} flexibly. By rapidly we mean that test-time inference involves only simple computation such as a feed-forward pass through a neural network.  By flexibly we mean that the system supports a variety of tasks -- including variable numbers of shots or numbers of classes in classification problems -- without retraining. Rapid inference comes automatically with the use of a deep neural network to amortize the approximate posterior distribution . However, it typically comes at the cost of flexibility: amortized inference is usually limited to a single specific task. Below, we discuss design choices that enable us to retain flexibility.
\paragraph{Inference with sets as inputs.} The amortization network takes data sets of variable size as inputs whose ordering we should be invariant to. We use permutation-invariant \textit{instance-pooling} operations to process these sets similarly to \citet{qi2017pointnet} and as formalized in \citet{zaheer2017deep}.
The instance-pooling operation ensures that the network can process any number of training observations. \begin{figure}[t]
	\centering
    \includestandalone[mode=buildnew, width=\textwidth]{figures/amortization_schematic_v2} \\
	\caption{Computational flow of \Versa{} for few-shot classification with the context-independent approximation. \textit{Left:} A test point  is mapped to its softmax output through a feature extractor neural network and a linear classifier (fully connected layer). The global parameters  of the feature extractor are shared between tasks whereas the weight vectors  of the linear classifier are task specific and inferred through an amortization network with parameters . \textit{Right:} Amortization network that maps the extracted features of the  training examples of a particular class to the corresponding weight vector of the linear classifier.}
	\label{fig:approximation_scheme}
\end{figure}


\paragraph{\Versa{} for Few-Shot Image Classification.}
For few-shot image classification, our parameterization of the probabilistic model is inspired by early work from \citet{heskes2000empirical, bakker2003task} and recent extensions to deep learning \citep{bauer2017discriminative, qiao2017few}. A feature extractor neural network , shared across all tasks, feeds into a set of task-specific linear classifiers with softmax outputs and weights and biases  (see \cref{fig:approximation_scheme}).

A naive amortization requires the approximate posterior  to model the distribution over full weight matrices in  (and biases). This requires the specification of the number of few-shot classes  ahead of time and limits inference to this chosen number. 
Moreover, it is difficult to meta-learn systems that directly output large matrices as the output dimensionality is high. We therefore propose specifying  in a \textit{context independent} manner such that each weight vector  depends only on examples from class , by amortizing individual weight vectors associated with a single softmax output instead of the entire weight matrix directly. To reduce the number of learned parameters, the amortization network operates directly on the extracted features :

Note that in our implementation, end-to-end training is employed, i.e., we backpropagate to  through the inference network. Here  is the number of observed examples in class  and  denotes the weight vector and bias of the linear classifier associated with that class. Thus, we construct the classification matrix  by performing  feed-forward passes through the inference network  (see \cref{fig:approximation_scheme}). 

The assumption of context independent inference is an approximation. In \cref{app:empirical_justification}, we provide theoretical and empirical justification for its validity. Our theoretical arguments use insights from Density Ratio Estimation \citep{mohamed2018blog, sugiyama2012density}, and we empirically demonstrate that full approximate posterior distributions are close to their context independent counterparts. Critically, the context independent approximation addresses all the limitations of a naive amortization mentioned above: (i) the inference network needs to amortize far fewer parameters whose number does not scale with number of classes  (a single weight vector instead of the entire matrix); (ii) the amortization network can be meta-trained with different numbers of classes per task, and (iii) the number of classes  can vary at test-time.
\begin{figure}[t] 
	\centering
\includestandalone[mode=buildnew, width=\textwidth]{graphs/shapenet_diagram} \\
	\caption{Computational flow of \Versa{} for few-shot view reconstruction. \textit{Left:} A set of training images and angles  are mapped to a stochastic input  through the amortization network .  is then concatenated with a test angle  and mapped onto a new image through the generator . \textit{Right:} Amortization network that maps  image/angle examples of a particular object-instance to the corresponding stochastic input.}
\label{fig:approximation_scheme_shapenet}
\end{figure}


\paragraph{\Versa{} for Few-Shot Image Reconstruction (Regression).} We consider a challenging few-shot learning task with a complex (high dimensional and continuous) output space. We define view reconstruction as the ability to infer how an object looks from any desired angle based on a small set of observed views. We frame this as a multi-output regression task from a set of training images with known orientations to output images with specified orientations. 

Our generative model is similar to the generator of a GAN or the decoder of a VAE: A latent vector , which acts as an object-instance level input to the generator, is concatenated with an angle representation and mapped through the generator to produce an image at the specified orientation. In this setting, we treat all parameters  of the generator network as global parameters (see \cref{app:view_reconstruction_networks} for full details of the architecture), whereas the latent inputs  are the task-specific parameters. We use a Gaussian likelihood in pixel space for the outputs of the generator. To ensure that the output means are between zero and one, we use a sigmoid activation after the final layer.  parameterizes an amortization network that first processes the image representations of an object, concatenates them with their associated view orientations, and processes them further before instance-pooling. From the pooled representations,  produces a distribution over vectors . This process is illustrated in \cref{fig:approximation_scheme_shapenet}. 



\section{ML-PIP Unifies Disparate Related Work}
\label{sec:related_work}

In this section, we continue in the spirit of \citet{grant2018recasting}, and recast a broader class of meta-learning approaches as approximate inference in hierarchical models. We show that ML-PIP unifies a number of important approaches to meta-learning, including \textit{both} gradient and metric based variants, as well as amortized MAP inference and conditional modelling approaches \citep{garnelo2018conditional}. We lay out these connections, most of which rely on point estimates for the task-specific parameters  corresponding to . In addition, we compare previous approaches to \Versa{}.

\paragraph{Gradient-Based Meta-Learning.}
Let the task-specific parameters  be all the parameters in a neural network. Consider a point estimate formed by taking a step of gradient ascent of the training loss, initialized at  and with learning rate .

This is an example of semi-amortized inference \citep{kim2018semi}, as the only shared inference parameters are the initialization and learning rate, and optimization is required for each task (albeit only for one step). Importantly, \cref{eqn:maml} recovers \textit{Model-agnostic meta-learning} \citep{finn2017model}, providing a perspective as semi-amortized ML-PIP. This perspective is complementary to that of \cite{grant2018recasting} who justify the one-step gradient parameter update employed by MAML through MAP inference and the form of the prior . Note that the episodic meta-train / meta-test splits do not fall out of this perspective. Instead we view the update choice as one of amortization which is trained using the predictive KL and naturally recovers the test-train splits. More generally, multiple gradient steps could be fed into an RNN to compute  which recovers \citet{ravi2016optimization}. In comparison to these methods, besides being distributional over , \Versa{} relieves the need to back-propagate through gradient based updates during training and compute gradients at test time, as well as enables the treatment of both local and global parameters which simplifies inference. 

\paragraph{Metric-Based Few-Shot Learning.} 
Let the task-specific parameters be the top layer softmax weights and biases of a neural network . The shared parameters are the lower layer weights. Consider amortized point estimates for these parameters constructed by averaging the top-layer activations for each class, 

These choices lead to the following predictive distribution:

which recovers \textit{prototypical networks} \citep{snell2017prototypical} using a Euclidean distance function  with the final hidden layer being the embedding space. In comparison, \Versa{} is distributional and it uses a more flexible amortization function that goes beyond  averaging of activations.

\paragraph{Amortized MAP inference.} \citet{qiao2017few} proposed a method for predicting weights of classes from activations of a pre-trained network to support i) online learning on a single task to which new few-shot classes are incrementally added, ii) transfer from a high-shot classification task to a separate low-shot classification task. This is an example usage of hyper-networks \citep{ha2016hypernetworks} to amortize learning about weights, and can be recovered by the ML-PIP framework by pre-training  and performing MAP inference for . 
\Versa{} goes beyond point estimates and although its amortization network is similar in spirit, it is more general, employing end-to-end training and supporting full multi-task learning by sharing information between many tasks.

\paragraph{Conditional models trained via maximum likelihood.} In cases where a point estimate of the task-specific parameters are used the predictive becomes 

In such cases the amortization network that computes  can be equivalently viewed as part of the model specification rather than the inference scheme. From this perspective, the ML-PIP training procedure for  and  is equivalent to training a conditional model  via maximum likelihood estimation, establishing a strong connection to neural processes \citep{garnelo2018conditional, garnelo2018neural}.

\paragraph{Comparison to Variational Inference (VI).} Standard application of amortized VI \citep{kingma2013auto,rezende2014stochastic,kingma2015variational,blundell2015weight} for  in the multi-task discriminative model optimizes the Monte Carlo approximated free-energy w.r.t.~ and :   

where . In addition to the conceptual difference from ML-PIP (discussed in \cref{sec:model}), this differs from the ML-PIP objective by i) not employing meta train / test splits, and ii) including the KL for regularization instead.
In \cref{sec:experiments}, we show that \Versa{} significantly improves over standard VI in the few-shot classification case and compare to recent VI/meta-learning hybrids. 

\section{Experiments and Results}
\label{sec:experiments}

We evaluate \Versa{} on several few-shot learning tasks. We begin with toy experiments to investigate the properties of the amortized posterior inference achieved by \Versa{}. We then report few-shot classification results using the Omniglot and \textit{mini}ImageNet datasets in \cref{sec:classification}, and demonstrate \Versa{}'s ability to retain high accuracy as the shot and way are varied at test time. In \cref{sec:view_recovery}, we examine \Versa{}'s performance on a one-shot view reconstruction task with ShapeNet objects.\footnote{Source code for the experiments is available at \url{https://github.com/Gordonjo/versa}.}

\subsection{Posterior Inference with Toy Data}
\label{sec:toy_experiment}

To investigate the approximate inference performed by our training procedure, we run the following experiment. We first generate data from a Gaussian distribution with a mean that varies across tasks:

We generate  tasks in two separate experiments, having  train observations and  test observations. We introduce the inference network , amortizing inference as:

The learnable parameters  are trained with the objective function in \cref{eqn:stochastic_bdt_ml}. The model is trained to convergence with Adam \citep{kingma2014adam} using mini-batches of tasks from the generated dataset. Then, a separate set of tasks is generated from the same generative process, and the posterior  is inferred with the learned amortization parameters. The true posterior over  is Gaussian with a mean that depends on the task, and may be computed analytically. \cref{fig:approx_posteriors} shows the approximate posterior distributions inferred for unseen test sets by the trained amortization networks. The evaluation shows that the inference procedure is able to recover accurate posterior distributions over , despite minimizing a predictive KL divergence in data space.

\renewcommand{\star}{{\usefont{OML}{cmm}{m}{it}\symbol{63}}}
\begin{figure}
\centering
\begin{tikzpicture}
\node (one) {\includegraphics[width=0.2\textwidth]{figures/toy_inference/toy_inference_1.pdf}};
\node[right=0. cm of one] (two) {\includegraphics[width=0.2\textwidth]{figures/toy_inference/toy_inference_2.pdf}};
\node[right=0.5 cm of two] (three) {\includegraphics[width=0.2\textwidth]{figures/toy_inference/toy_inference_3.pdf}};
\node[right=0. cm of three] (four) {\includegraphics[width=0.2\textwidth]{figures/toy_inference/toy_inference_4.pdf}};
\node[below=-0.2cm of one] {};
\node[below=-0.2cm of two] {};
\node[below=-0.2cm of three] {};
\node[below=-0.2cm of four] {};
\end{tikzpicture}
\vskip-1.em
\caption{True posteriors  (\protect\tikz[baseline=(current bounding box.base),inner sep=0pt]{\protect\draw[line width=1.pt, solid, red] (0pt,3pt) --(15pt,3pt);}) and approximate posteriors  (\protect\tikz[baseline=(current bounding box.base),inner sep=0pt]{\protect\draw[line width=1.pt, solid, blue] (0pt,3pt) --(15pt,3pt);}) for unseen test sets (\star) in the experiment. In both cases (five and ten shot), the approximate posterior closely resembles the true posterior given the observed data.}
\label{fig:approx_posteriors}
\end{figure}
\subsection{Few-shot Classification}
\label{sec:classification}

We evaluate \Versa{} on standard few-shot classification tasks in comparison to previous work. Specifically, we consider the Omniglot \citep{lake2011one} and \miniimagenet{} \citep{ravi2016optimization} datasets which are -way classification tasks with  examples per class. \Versa{} follows the implementation in \cref{sec:MLPIP,sec:amortisation}, and the approximate inference scheme in \cref{eqn:vector_inference}. We follow the experimental protocol established by \citet{vinyals2016matching} for Omniglot and \citet{ravi2016optimization} for \textit{mini}Imagenet, using equivalent architectures for . Training is carried out in an episodic manner: for each task,  examples are used as training inputs to infer  for each class, and an additional set of examples is used to evaluate the objective function. Full details of data preparation and network architectures are provided in \cref{app:experimention_details_classification}.

\cref{table:classification_results_main} details few-shot classification performance for \Versa{} as well as competitive approaches. 
The tables include results for only those approaches with comparable training procedures and convolutional feature extraction architectures. Approaches that employ pre-training and/or residual networks \citep{bauer2017discriminative, qiao2017few, rusu2018meta, gidaris2018dynamic, oreshkin2018tadam, garcia2017few, lacoste2018uncertainty} have been excluded so that the quality of the learning algorithm can be assessed separately from the power of the underlying discriminative model.


For Omniglot, the training, validation, and test splits have not been specified for previous methods, affecting the comparison. 
\Versa{} achieves a new state-of-the-art results (67.37\% - up 1.38\% over the previous best) on 5-way - 5-shot classification on the \textit{mini}ImageNet benchmark and (97.66\% - up 0.02\%) on the 20-way - 1 shot Omniglot benchmark for systems using a convolution-based network architecture and an end-to-end training procedure. \Versa{} is within error bars of state-of-the-art on three other benchmarks including 5-way - 1-shot \textit{mini}ImageNet, 5-way - 5-shot Omniglot, and 5-way - 1-shot Omniglot. Results on the Omniglot 20 way - 5-shot benchmark are very competitive with, but lower than other approaches. While most of the methods evaluated in \cref{table:classification_results_main} adapt all of the learned parameters for new tasks, \Versa{} is able to achieve state-of-the-art performance despite adapting only the weights of the top-level classifier.
\paragraph{Comparison to standard and amortized VI.} To investigate the performance of our inference procedure, we compare it in terms of log-likelihood (\cref{table:log_likelihood_results}) and accuracy (\cref{table:classification_results_main}) to training the same model using both amortized and non-amortized VI (i.e., \cref{eqn:vi_objective}). Derivations and further experimental details are provided in \cref{app:vi_derivation}. \Versa{} improves substantially over amortized VI even though the same amortization network is used for both. This is due to VI's tendency to under-fit, especially for small numbers of data points  \citep{trippe2018overpruning,turner2011two} which is compounded when using inference networks \citep{cremer2018inference}. 
\begin{table}[h]
\centering
\scriptsize
\rowcolors{1}{white}{lightgray}
\caption{Negative Log-likelihood (NLL) results for different few-shot settings on Omniglot and \textit{mini}ImageNet. The  sign indicates the 95\% confidence interval over tasks using a Student's t-distribution approximation.}
\label{table:log_likelihood_results}
\vskip-0.75em
\makebox[\textwidth][c]{
\begin{tabular}{ l c c c c c c}
\toprule
\hiderowcolors
                        &\multicolumn{4}{c}{\textit{Omniglot}} & \multicolumn{2}{c}{\textit{\textit{mini}ImageNet}} \\ 
                        &\multicolumn{2}{c}{\textbf{5-way NLL}} & \multicolumn{2}{c}{\textbf{20-way NLL}} & \multicolumn{2}{c}{\textbf{5-way NLL}}\\ 
\textbf{Method}        & \multicolumn{1}{c}{1-shot} & \multicolumn{1}{c}{5-shot} & \multicolumn{1}{c}{1-shot} & \multicolumn{1}{c}{5-shot} & \multicolumn{1}{c}{1-shot} & \multicolumn{1}{c}{5-shot} \\ 
\showrowcolors
\midrule
Amortized VI           & 0.179  0.009 &  0.137  0.004 & 0.456  0.010 & 0.253  0.004 & 1.328  0.024 & 1.165  0.010 \\
Non-Amortized VI       & 0.144  0.005 &  0.025  0.001 & 0.393  0.005 & 0.078  0.002 & & \\
\textbf{\Versa{}}      & 0.010  0.005 & 0.007  0.003 &  0.079  0.009 &  0.031  0.004 & 1.183  0.023 & 0.859  0.015 \\
\bottomrule
\end{tabular}}
\vspace{2mm}
\end{table}
Using non-amortized VI improves performance substantially, but does not reach the level of \Versa{} and forming the posterior is significantly slower as it requires many forward / backward passes through the network. This is similar in spirit to MAML \citep{finn2017model}, though MAML dramatically reduces the number of required iterations by finding good global initializations e.g., five gradient steps for \miniimagenet{}. This is in contrast to the single forward pass required by \Versa{}.

\paragraph{Versatility.} \Versa{} allows us to vary the number of classes  and shots  between training and testing (\cref{eqn:vector_inference}). \cref{fig:acc2way} shows that a model trained for a particular -way retains very high accuracy as  is varied. For example, when  \Versa{} is trained for the 20-Way, 5-Shot condition, at test-time it can handle  way conditions and retain an accuracy of approximately 94\%. \cref{fig:acc2shot} shows similar robustness as the number of shots  is varied. \Versa{} therefore demonstrates considerable flexibility and robustness to the test-time conditions, but at the same time it is efficient as it only requires forward passes through the network. The time taken to evaluate 1000 test tasks with a 5-way, 5-shot \textit{mini}ImageNet trained model using MAML (\url{https://github.com/cbfinn/maml}) is 302.9 seconds whereas \Versa{} took 53.5 seconds on a NVIDIA Tesla P100-PCIE-16GB GPU. This is more than  speed advantage in favor of \Versa{} while bettering MAML in accuracy by 4.26\%.
\begin{figure}[ht]
	\centering
    \hfill
	\begin{subfigure}[b]{.40\textwidth}
		\centering
        \includestandalone[mode=buildnew]{graphs/accuracy_versus_way_graph} \\
        \subcaption{Way ()}
		\label{fig:acc2way}
	\end{subfigure} \hfill
	\begin{subfigure}[b]{.40\textwidth}
		\centering
        \includestandalone[mode=buildnew]{graphs/accuracy_versus_shot_graph} \\
        \subcaption{Shot ()}
		\label{fig:acc2shot}
	\end{subfigure}
    \hfill \hspace{0cm}
	\caption{Test accuracy on Omniglot when varying (a) way (fixing shot to be that used for training) and (b) shot. In \cref{fig:acc2shot}, all models are evaluated on 5-way classification. Colors indicate models trained with different way-shot episodic combinations.}
	\label{fig:omni_flexibility}
\end{figure}





\subsection{ShapeNet View Reconstruction}
\label{sec:view_recovery}
ShapeNetCore v2 \citep{shapenet2015} is a database of 3D objects covering 55 common object categories with 51,300 unique objects. For our experiments, we use 12 of the largest object categories. We concatenate all instances from all 12 of the object categories together to obtain a dataset of 37,108 objects. This dataset is then randomly shuffled and we use 70\% of the objects for training, 10\% for validation, and 20\% for testing. For each object, we generate 36 views of size  pixels spaced evenly every 10 degrees in azimuth around the object.

We evaluate \Versa{} by comparing it to a conditional variational autoencoder (C-VAE) with view angles as labels \citep{kingma2014semi,narayanaswamy2017learning} and identical architectures. We train \Versa{} in an episodic manner and the C-VAE in batch-mode on all 12 object classes at once. We train on a single view selected at random and use the remaining views to evaluate the objective function. For full experimentation details see \cref{app:experimental_details_shapenet}. \cref{fig:shapenet} shows views of unseen objects from the test set generated from a single shot with \Versa{} as well as a C-VAE and compares both to ground truth views. Both \Versa{} and the C-VAE capture the correct orientation of the object in the generated images. However, \Versa{} produces images that contain much more detail and are visually sharper than the C-VAE images. Although important information is missing due to occlusion in the single shot, \Versa{} is often able to accurately impute this information presumably due to learning the statistics of these objects.
\cref{table:shapenet_metrics} provides quantitative comparison results between \Versa{} with varying shot and the C-VAE. The quantitative metrics all show the superiority of \Versa{} over a C-VAE. As the number of shots increase to 5, the measurements show a corresponding improvement.

\begin{table}[h]
\begin{flushleft}
\small
\rowcolors{1}{white}{lightgray}
\floatbox[\capbeside]{table}
{\caption{View reconstruction test results. Mean squared error (MSE -- lower is better) and the structural similarity index (SSIM - higher is better) \citep{wang2004image} are measured between the generated and ground truth images. Error bars not shown as they are insignificant.}\label{table:shapenet_metrics}}
{\begin{tabular}{lcc}
  \toprule
  \hiderowcolors
  \textbf{Model} & \textbf{MSE} & \textbf{SSIM} \\
  \showrowcolors
  \midrule
  C-VAE 1-shot    & 0.0269 & 0.5705 \\
  \Versa{} 1-shot & 0.0108 & 0.7893 \\
\Versa{} 5-shot & 0.0069 & 0.8483 \\
  \bottomrule
\end{tabular}}
\end{flushleft}
\end{table}

\section{Conclusions}
\label{sec:conclusions}

We have introduced ML-PIP, a probabilistic framework for meta-learning. ML-PIP unifies a broad class of recently proposed meta-learning methods, and suggests alternative approaches. Building on ML-PIP, we developed \Versa{}, a few-shot learning algorithm that avoids the use of gradient based optimization at test time by amortizing posterior inference of task-specific parameters. We evaluated \Versa{} on several few-shot learning tasks and demonstrated state-of-the-art performance and compelling visual results on a challenging 1-shot view reconstruction task.     



\begin{table}[h]
\caption{Accuracy results for different few-shot settings on Omniglot and \textit{mini}ImageNet. The  sign indicates the 95\% confidence interval over tasks using a Student's t-distribution approximation. Bold text indicates the highest scores that overlap in their confidence intervals.}
\vskip-1.em
\label{table:classification_results_main}
\centering
\resizebox{0.8\textwidth}{!}{\rowcolors{1}{white}{lightgray}
\makebox[\textwidth][c]{
\begin{tabular}{ p{40mm} c c c c c c}
\toprule
\hiderowcolors
                        &\multicolumn{4}{c}{\textit{Omniglot}} & \multicolumn{2}{c}{\textit{\textit{mini}ImageNet}} \\ 
                        &\multicolumn{2}{c}{\textbf{5-way accuracy (\%)}} & \multicolumn{2}{c}{\textbf{20-way accuracy (\%)}} & \multicolumn{2}{c}{\textbf{5-way accuracy (\%)}}\\ 
 \textbf{Method}        & \multicolumn{1}{c}{1-shot} & \multicolumn{1}{c}{5-shot} & \multicolumn{1}{c}{1-shot} & \multicolumn{1}{c}{5-shot} & \multicolumn{1}{c}{1-shot} & \multicolumn{1}{c}{5-shot} \\ 
 \showrowcolors
 \midrule
 Siamese Nets \newline \citep{koch2015siamese}              & 97.3 & 98.4 & 88.1 & 97.0 & & \\
 Matching Nets \newline \citep{vinyals2016matching}         & 98.1 & 98.9 & 93.8 & 98.5 & 46.6 & 60.0 \\
 Neural Statistician \newline \citep{edwards2016towards}    & 98.1 & 99.5 & 93.2 & 98.1 & & \\
 Memory Mod \newline \citep{kaiser2017aurko}                & 98.4 & 99.6 & 95.0 & 98.6 & & \\
 Meta LSTM \newline \citep{ravi2016optimization}            & & & & & 43.44  0.77 & 60.60  0.71\\
 MAML \newline \citep{finn2017model}                        & 98.7  0.4 & \textbf{99.9  0.1} & 95.8  0.3 & 98.9  0.2 & 48.7  1.84 & 63.11  0.92 \\
 Prototypical Nets\footnote{\scriptsize We report the performance of Prototypical Networks when training and testing with the same ``shot" and ``way", which is consistent with the experimental protocol of the other methods listed. We note that Prototypical Networks perform better when trained on higher ``way" than that of testing. In particular, when trained on 20-way classification and tested on 5-way, the model achieves .} \newline \citep{snell2017prototypical}   & 97.4 & 99.3 & 95.4 & 98.7 & 46.61  0.78 & 65.77  0.70 \\
 mAP-SSVM \newline \citep{triantafillou2017few}             & 98.6 & 99.6 & 95.2 & 98.6 & 50.32  0.80 & 63.94  0.72 \\
 mAP-DLM \newline \citep{triantafillou2017few}              & 98.8 & 99.6 & 95.4 & 98.6 & 50.28  0.80 & 63.70  0.70 \\
 LLAMA \newline \citep{grant2018recasting}                  & & & & & 49.40  1.83 & \\
 PLATIPUS \newline \citep{finn2018probabilistic}            & & & & & 50.13  1.86 & \\
 Meta-SGD \newline \citep{li2017meta}                       & \textbf{99.53  0.26} & \textbf{99.93  0.09} & 95.93  0.38 & 98.97  0.19 & 50.47  1.87 & 64.03  0.94 \\
 SNAIL \newline \citep{mishra2018simple}                    & 99.07  0.16 & 99.78  0.09 & \textbf{97.64  0.30} & \textbf{99.36  0.18} & 45.1 & 55.2 \\
 Relation Net \newline \citep{yang2018learning}             & \textbf{99.6  0.2} & \textbf{99.8  0.1} & \textbf{97.6  0.2} & \textbf{99.1  0.1} & 50.44  0.82 & 65.32  0.70 \\
 Reptile \newline \citep{nichol2018reptile}                 & 97.68  0.04 & 99.48  0.06 & 89.43  0.14 & 97.12  0.32 & 49.97  0.32 & \textbf{65.99  0.58} \\
 BMAML \newline \citep{kim2018bayesian}                     & & & & & \textbf{53.8  1.46} & \\
 \midrule
 Amortized VI           & 97.77  0.55 & 98.71  0.22 & 90.56  0.54 & 96.12  0.23 & 44.13  1.78 & 55.68  0.91  \\
 Non-Amortized VI       & 98.77  0.18 & 99.74  0.06 & 95.28  0.19 & 98.84  0.09 &  & \\
 \textbf{\Versa{}} (Ours)     & \textbf{99.70  0.20} & \textbf{99.75  0.13} & \textbf{97.66  0.29} & 98.77  0.18 & \textbf{53.40  1.82} & \textbf{67.37  0.86} \\
 \bottomrule
\end{tabular}}
}
\end{table}
\clearpage



\newpage
\begin{figure}
    \centering
    \includegraphics[width=\textwidth, trim=.02cm .02cm .02cm .02cm, clip]{figures/shapenet_iclr.pdf}
    \caption{Results for ShapeNet view reconstruction for unseen objects from the test set (shown left). The model was trained to reconstruct views from a single orientation. \textit{Top row:} images/views generated by a C-VAE model; \textit{middle row} images/views generated by \Versa{}; \textit{bottom row:} ground truth images. Views are spaced evenly every 30 degrees in azimuth.}
    \label{fig:shapenet}
\end{figure}
\clearpage

\newpage
\subsection*{Acknowledgements}
We thank Ravi and Larochelle for providing the miniImageNet dataset, and Yingzhen Li, Niki Kilbertus, Will Tebbutt, Maria Lomelli, and Robert Pinsler for their useful feedback. J.G. acknowledges funding from a Samsung Doctoral Scholarship. M.B. acknowledges funding by the EPSRC and a Qualcomm European Scholarship in Technology. R.E.T. acknowledges support from EPSRC grants EP/M0269571 and EP/L000776/1. 

\bibliography{iclr2019_conference}
\bibliographystyle{abbrvnat}






\newpage
\appendix

\renewcommand\thefigure{\thesection.\arabic{figure}} 
\renewcommand\thetable{\thesection.\arabic{table}} 
\renewcommand\theequation{\thesection.\arabic{equation}} 

\setcounter{figure}{0}
\setcounter{table}{0}
\setcounter{equation}{0}


\section{Bayesian Decision Theoretic Generalization of ML-PIP}
\label{app:bdt_derivation}

A generalization of the new inference framework presented in \cref{sec:MLPIP} is based upon Bayesian decision theory (BDT). BDT provides a recipe for making predictions  for an unknown test variable  by combining information from observed training data  (here from a single task ) and a loss function  that encodes the cost of predicting  when the true value is  \citep{berger2013statistical,jaynes2003probability}. In BDT an optimal prediction minimizes the expected loss (suppressing dependencies on the inputs and  to reduce notational clutter):\footnote{For discrete outputs the integral may be replaced with a summation.}

is the Bayesian predictive distribution and  the posterior distribution of  given the training data from task . 

BDT separates test and training data and so is a natural lens through which to view recent episodic approaches to training that utilize many internal training/test splits \citep{vinyals2016matching}. Based on this insight, what follows is a fairly dense derivation of an ultimately simple stochastic variational objective for meta-learning probabilistic inference that is rigorously grounded in Bayesian inference and decision theory.

\paragraph{Distributional BDT.} We generalize BDT to cases where the goal is to return a full predictive \emph{distribution}  over the unknown test variable  rather than a point prediction. 
The quality of  is quantified through a distributional loss function . Typically, if  (the true value of the underlying variable) falls in a low probability region of  the loss will be high, and vice versa. 
The optimal predictive  is found by optimizing the expected distributional loss with  constrained to a  distributional family :

\paragraph{Amortized variational training.} 
Here, we amortize  to form quick predictions at test time and learn parameters by minimizing average expected loss \emph{over tasks}. Let  be a set of shared variational parameters such that  (or  for shorthand). Now the approximate predictive distribution can take any training dataset  as an argument and directly perform prediction of . The optimal variational parameters are found by minimizing the expected distributional loss across tasks

Here the variables  and  are placeholders for integration over all possible datasets, test inputs and outputs. Note that \cref{eqn:variational_objective_2} can be stochastically approximated by sampling a task  and randomly partitioning into training data  and test data , which naturally recovers episodic mini-batch training over tasks and data \citep{vinyals2016matching,ravi2016optimization}. Critically, this does not require computation of the true predictive distribution. It also emphasizes the meta-learning aspect of the procedure, as the model is \textit{learning how to infer} predictive distributions from training tasks. 

\paragraph{Loss functions.} We employ the log-loss: the negative log density of  at . In this case,

where  is the KL-divergence, and  is the entropy of . 
\cref{eqn:proper_score_objective} has the elegant property that the optimal  is the closest member of  (in a KL sense) to the true predictive , which is unsurprising as the log-loss is a proper scoring rule \citep{huszar2013scoring}. This is reminiscent of the sleep phase in the wake-sleep algorithm \citep{hinton1995wake}. Exploration of alternative proper scoring rules \citep{dawid2007geometry} and more task-specific losses \citep{lacoste2011approximate} is left for future work.

\paragraph{Specification of the approximate predictive distribution.} Next, we consider the form of . Motivated by the optimal predictive distribution, we replace the true posterior by an approximation:




\section{Justification for Context-Independent Approximation}
\label{app:empirical_justification}
\setcounter{figure}{0}   
\setcounter{table}{0}
\setcounter{equation}{0}

In this section we lay out both theoretical and empirical justifications for the context-independent approximation detailed in \cref{sec:amortisation}.

\subsection{Theoretical Argument -- Density Ratio Estimation}

A principled justification for the approximation is best understood through the lens of density ratio estimation \citep{mohamed2018blog, sugiyama2012density}. We denote the conditional density of each class as  and assume equal a priori class probability . Density ratio theory then uses Bayes' theorem to show that the optimal softmax classifier can be expressed in terms of the conditional densities \citep{mohamed2018blog, sugiyama2012density}:

This implies that the optimal classifier will construct estimators for the conditional density for each class, that is . Importantly for our approximation, notice that these estimates are constructed \emph{independently} for each class, similarly to training a naive Bayes classifier. \Versa{} mirrors this optimal form using: 

where  for each class in a given task. Under ideal conditions (i.e., if one could perfectly estimate ), the context-independent assumption holds, further motivating our design.


\subsection{Empirical Justification}

Here we detail a simple experiment to evaluate the validity of the context-independent inference assumption. The goal of the experiment is to examine if weights may be context-independent without imposing the assumption on the amortization network. To see this, we randomly generate fifty tasks from a dataset, where classes may appear a number of times in different tasks. We then perform free-form (non-amortized) variational inference on the weights for each of the tasks, with a Gaussian variational distribution:


If the assumption is reasonable, we may expect the distribution of the weights of a specific class to be similar regardless of the additional classes in the task.

We examine 5-way classification in the MNIST dataset. We randomly sample and fix fifty such tasks. We train the model twice using the same feature extraction network used in the few-shot classification experiments, and fix the  to be 16 and 2. We then train the model in an episodic manner by mini-batching tasks at each iteration. The model is trained to convergence, and achieves 99\% accuracy on held out test examples for the tasks. After training is complete we examine the optimized  for each class in each task.
\begin{figure}
	\centering
    \begin{subfigure}[b]{.65\textwidth}
		\centering
		\includegraphics[width=1.\textwidth]{figures/weight_approximation_vi_ntheta64}
		\subcaption{}
		\label{fig:tsne_weights}
	\end{subfigure} \begin{subfigure}[b]{.65\textwidth}
		\centering
		\includegraphics[width=1.\textwidth]{figures/weights_colormap}
		\subcaption{}
		\label{fig:weights_colormap}
	\end{subfigure} \caption{Visualizing the learned weights for . (a) Weight dimensionality is reduced using T-SNE \citep{maaten2008visualizing}. Weights are colored according to class. (b) Each weight represents one column of the image. Weights are grouped by class.}
    \label{fig:approx_16}
\end{figure}
\cref{fig:tsne_weights} shows a t-SNE \citep{maaten2008visualizing} plot for the 16-dimensional weights. We see that when reduced to 2-dimensions, the weights cluster according to class. \cref{fig:weights_colormap} visualizes the weights in their original space. In this plot, weights from the same class are grouped together, and clear similarity patterns are evident across the image, showing that weights from the same class have similar means across tasks.
\begin{figure}
	\centering
    \begin{subfigure}[b]{.45\textwidth}
		\centering
		\includegraphics[width=1.\textwidth]{figures/all_tasks}
		\subcaption{}
		\label{fig:all_tasks}
	\end{subfigure} \begin{subfigure}[b]{.45\textwidth}
		\centering
		\includegraphics[width=1.\textwidth]{figures/one_and_two_tasks}
		\subcaption{}
		\label{fig:one_and_two_tasks}
	\end{subfigure} \caption{Visualizing the task weights for . (a) All training tasks. (b) Only training tasks containing both `1's and `2's.}
    \label{fig:approx_2}
\end{figure}
\cref{fig:approx_2} details the task weights in 2-dimensional space. Here, each pentagon represents the weight means learned for one training task, where the nodes of the pentagon are colored according to the class the weights represent. In \cref{fig:all_tasks} we see that overall, the classes cluster in 2-dimensional space as well. However, there is some overlap (e.g., classes `1' and `2'), and that for some tasks a class-weight may appear away from the cluster. \cref{fig:one_and_two_tasks} shows the same plot, but only for tasks that contain both class `1' and `2'. Here we can see that for these tasks, class `2' weights are all located away from their cluster. 

This implies that each class-weights are typically well-approximated as being independent of the task. However, if the model lacks capacity to properly assign each set of class weights to different regions of space, for tasks where classes from similar regions of space appear, the inference procedure will `move' one of the class weights to an `empty' region of the space.











\section{Variational Inference Derivations for the Model}
\label{app:vi_derivation}
\setcounter{figure}{0}   
\setcounter{table}{0}
\setcounter{equation}{0}

We derive a VI-based objective for our probabilistic model. By ``amortized" VI we mean that  is parameterized by a neural network with a fixed-sized . Conversely, ``non-amortized" VI refers to local parameters  that are optimized independently (at test time) for each new task , such that . However, the derivation of the objective function does not change between these options. For a single task , an evidence lower bound (ELBO; \citep{wainwright2008graphical}) may be expressed as:

We can then derive a stochastic estimator to optimize \cref{eqn:task_vi} by sampling  (approximated with a training set of tasks) and simple Monte Carlo integration over  such that :

\cref{eqn:aevb} differs from our objective function in \cref{eqn:stochastic_bdt_ml} in two important ways:
\begin{inlinelist}
\item \cref{eqn:stochastic_bdt_ml} does not contain a KL term for  (nor any other form of prior distribution over , and
\item \cref{eqn:task_vi} does not distinguish between training and test data within a task, and therefore does not explicitly encourage the model to generalize in any way.
\end{inlinelist}













\section{Experimentation Details}
\label{app:experimention_details_classification}
\setcounter{figure}{0}   
\setcounter{table}{0}
\setcounter{equation}{0}

In this section we provide comprehensive details on the few-shot classification experiments.

\label{app:complete_few_shot_classification_results}





\subsection{Omniglot Few-shot Classification Training Procedure}
\label{app:experimention_details_omniglot}

Omniglot \citep{lake2011one} is a few-shot learning dataset consisting of 1623 handwritten characters (each with 20 instances) derived from 50 alphabets. We follow a pre-processing and training procedure akin to that defined in \citep{vinyals2016matching}. First the images are resized to  pixels and then character classes are augmented with rotations of 90 degrees. The training, validation and test sets consist of a random split of 1100, 100, and 423 characters, respectively. When augmented this results in 4400 training, 400 validation, and 1292 test classes, each having 20 character instances. For -way, -shot classification, training proceeds in an episodic manner. Each training iteration consists of a batch of one or more tasks. For each task  classes are selected at random from the training set. During training,  character instances are used as training inputs and 15 character instances are used as test inputs. The validation set is used to monitor the progress of learning and to select the best model to test, but does not affect the training process. Final evaluation of the trained model is done on 600 randomly selected tasks from the test set. During evaluation,  character instances are used as training inputs and  character instances are used as test inputs. We use the Adam \citep{kingma2014adam} optimizer with a constant learning rate of 0.0001 with 16 tasks per batch to train all models. The 5-way - 5-shot and 5-way - 1-shot models are trained for 80,000 iterations while the 20-way - 5-shot model is trained for 60,000 iterations, and the 20-way - 1-shot model is trained for 100,000 iterations. In addition, we use a Gaussian form for  and set the number of  samples to . 



\subsection{\textit{mini}ImageNET Few-shot Classification Training Procedure}
\label{app:experimention_details_miniImageNet}

\textit{mini}ImageNet \citep{vinyals2016matching} is a dataset of 60,000 color images that is sub-divided into 100 classes, each with 600 instances. The images have dimensions of  pixels. For our experiments, we use the 64 training, 16 validation, and 20 test class splits defined by \citep{ravi2016optimization}. Training proceeds in the same episodic manner as with Omniglot. We use the Adam \citep{kingma2014adam} optimizer and a Gaussian form for  and set the number of  samples to . For the 5-way - 5-shot model, we train using 4 tasks per batch for 100,000 iterations and use a constant learning rate of 0.0001. For the 5-way - 1-shot model, we train with 8 tasks per batch for 50,000 iterations and use a constant learning rate of 0.00025.



\subsection{Few-shot Classification Network Architectures}
\label{app:experimention_networks}

\cref{table:feature_extraction_omniglot,table:feature_extraction_mini_imagenet,table:amortization_network_omniglot,table:linear_classifier_omniglot} detail the neural network architectures for the feature extractor , amortization network , and linear classifier , respectively. The feature extraction network is very similar to that used in \citep{vinyals2016matching}. The output of the amortization network yields mean-field Gaussian parameters for the weight distributions of the linear classifier . When sampling from the weight distributions, we employ the local-reparameterization trick \citep{kingma2015variational}, that is we sample from the implied distribution over the logits rather than directly from the variational distribution. To reduce the number of learned parameters, we share the feature extraction network  with the pre-processing phase of the amortizaion network .

\begin{table}[h]
    \caption{Feature extraction network used for Omniglot few-shot learning. Batch Normalization and dropout with a keep probability of 0.9 used throughout.}
	\centering
	\begin{tabular}{cl}
		\multicolumn{2}{l}{\textbf{Omniglot Shared Feature Extraction Network ():} } \\
		\toprule
		\textbf{Output size} & \textbf{Layers} \\
        \midrule
		 & Input image \\
		 & conv2d (, stride 1, SAME, RELU), dropout, pool (, stride 2, SAME) \\
		 & conv2d (, stride 1, SAME, RELU), dropout, pool (, stride 2, SAME) \\
		 & conv2d (, stride 1, SAME, RELU), dropout, pool (, stride 2, SAME) \\
		 & conv2d (, stride 1, SAME, RELU), dropout, pool (, stride 2, SAME) \\
         & flatten \\
        \bottomrule
	\end{tabular}
    \vspace{2mm}
	\label{table:feature_extraction_omniglot}
\end{table}

\begin{table}[h]
    \caption{Feature extraction network used for \textit{mini}ImageNet few-shot learning. Batch Normalization and dropout with a keep probability of 0.5 used throughout.}
	\centering
	\begin{tabular}{cl}
		\multicolumn{2}{l}{\textbf{\textit{mini}ImageNet Shared Feature Extraction Network ():} } \\
		\toprule
		\textbf{Output size} & \textbf{Layers} \\
        \midrule
		 & Input image \\
		 & conv2d (, stride 1, SAME, RELU), dropout, pool (, stride 2, VALID) \\
		 & conv2d (, stride 1, SAME, RELU), dropout, pool (, stride 2, VALID) \\
		 & conv2d (, stride 1, SAME, RELU), dropout, pool (, stride 2, VALID) \\
		 & conv2d (, stride 1, SAME, RELU), dropout, pool (, stride 2, VALID) \\
		 & conv2d (, stride 1, SAME, RELU), dropout, pool (, stride 2, VALID) \\
         & flatten \\
        \bottomrule
	\end{tabular}
    \vspace{2mm}
	\label{table:feature_extraction_mini_imagenet}
\end{table}


\begin{table}[h]
    \caption{Amortization network used for Omniglot and \textit{mini}ImageNet few-shot learning.}
	\centering
	\begin{tabular}{lcl}
	  \multicolumn{3}{l}{\textbf{Amortization Network ():} } \\
      \toprule
      \textbf{Phase} & \textbf{Output size} & \textbf{Layers} \\
      \midrule
      feature extraction &  & shared feature network  \\
    instance pooling &  & mean \\
     weight distribution &  & 2  fully connected, ELU + \\
    & &  linear fully connected to  \\
      \bottomrule
	\end{tabular}
    \vspace{2mm}
	\label{table:amortization_network_omniglot}
\end{table}

\begin{table}[h]
    \caption{Linear classifier used for Omniglot and \textit{mini}ImageNet few-shot learning.}
	\centering
	\begin{tabular}{ll}
		\multicolumn{2}{l}{\textbf{Linear Classifier ():} } \\
 		\toprule
        \textbf{Output size} & \textbf{Layers} \\
        \midrule
		 & Input features \\
		 & fully connected, softmax \\ 
		\bottomrule
	\end{tabular}
    \vspace{2mm}
	\label{table:linear_classifier_omniglot}
\end{table}
\section{ShapeNet Experimentation Details}
\label{app:experimental_details_shapenet}
\setcounter{figure}{0}  
\setcounter{table}{0}
\setcounter{equation}{0}

\subsection{View Reconstruction Training Procedure and  Network Architectures}
\label{app:view_reconstruction_networks}

ShapeNetCore v2 \citep{shapenet2015} is an annotated database of 3D objects covering 55 common object categories with 51,300 unique objects. For our experiments, we use 12 of the largest object categories. Refer to \cref{table:shapenet_categories} for a complete list. We concatenate all instances from all 12 of the object categories together to obtain a dataset of 37,108 objects. This concatenated dataset is then randomly shuffled and we use 70\% of the objects (25,975 in total) for training, 10\% for validation (3,710 in total) , and 20\% (7423 in total) for testing. For each object, we generate ,  pixel image views spaced evenly every 10 degrees in azimuth around the object. We then convert the rendered images to gray-scale and reduce their size to be  pixels. Again, we train our model in an episodic manner. Each training iteration consists a batch of one or more tasks. For each task an object is selected at random from the training set. We train on a single view selected at random from the  views associated with each object and use the remaining 35 views to evaluate the objective function. We then generate 36 views of the object with a modified version of our amortization network which is shown diagrammatically in \cref{fig:approximation_scheme_shapenet}. To evaluate the system, we generate views and compute quantitative metrics over the entire test set. \cref{table:feature_extraction_shapenet,table:amortization_network_shapenet,table:decoder_shapenet} describe the network architectures for the encoder, amortization, and generator networks, respectively. To train, we use the Adam \citep{kingma2014adam} optimizer with a constant learning rate of 0.0001 with 24 tasks per batch for 500,000 training iterations. In addition, we set ,  and number of  samples to 1.

\begin{table}[!h]
    \caption{List of ShapeNet categories used in the \Versa{} view reconstruction experiments.}
	\centering
	\begin{tabular}{lcr}
		\toprule
		\textbf{Object Category} & \textbf{sysnet ID} & \textbf{Instances} \\
        \midrule
        airplane & 02691156 & 4045 \\
        bench    & 02828884 & 1813 \\
        cabinet  & 02933112 & 1571 \\
        car      & 02958343 & 3533 \\
        phone    & 02992529 & 831  \\
        chair    & 03001627 & 6778 \\
        display  & 03211117 & 1093 \\
        lamp     & 03636649 & 2318 \\
        speaker  & 03691459 & 1597 \\
        sofa     & 04256520 & 3173 \\
        table    & 04379243 & 8436 \\
        boat     & 04530566 & 1939 \\
        \bottomrule
	\end{tabular}
    \vspace{2mm}
	\label{table:shapenet_categories}
\end{table}


\begin{table}[!h]
    \caption{Encoder network used for ShapeNet few-shot learning. No dropout or batch normalization is used.}
	\centering
	\begin{tabular}{cl}
		\multicolumn{2}{l}{\textbf{ShapeNet Encoder Network ():} } \\
		\toprule
		\textbf{Output size} & \textbf{Layers} \\
        \midrule
		 & Input image \\
		 & conv2d (, stride 1, SAME, RELU), pool (, stride 2, VALID) \\
		 & conv2d (, stride 1, SAME, RELU), pool (, stride 2, VALID) \\
		 & conv2d (, stride 1, SAME, RELU), pool (, stride 2, VALID) \\
		 & conv2d (, stride 1, SAME, RELU), pool (, stride 2, VALID) \\
         & fully connected, RELU \\
        \bottomrule
	\end{tabular}
    \vspace{2mm}
	\label{table:feature_extraction_shapenet}
\end{table}
\begin{table}[!h]
    \caption{Amortization network used for ShapeNet few-shot learning.}
	\centering
	\begin{tabular}{lcl}
	  \multicolumn{3}{l}{\textbf{ShapeNet Amortization Network ():} } \\
      \toprule
      \textbf{Phase} & \textbf{Output size} & \textbf{Layers} \\
      \midrule
       &  & encoder network  \\
      concatenate  and  &  +  & concat(, ) \\
	   &  &  fully connected, ELU \\
      instance pooling &  & average \\
       &  &  fully connected, ELU \\
       distribution &  & fully connected linear layers to  \\
      \bottomrule
	\end{tabular}
    \vspace{2mm}
	\label{table:amortization_network_shapenet}
\end{table}
\begin{table}[!h]
    \caption{Generator network used for ShapeNet few-shot learning. No dropout or batch normalization is used.}
	\centering
	\begin{tabular}{cl}
		\multicolumn{2}{l}{\textbf{ShapeNet Generator Network ():} } \\
		\toprule
		\textbf{Output size} & \textbf{Layers} \\
        \midrule
         +  & concat(, ) \\
         & fully connected, RELU \\
         & fully connected, RELU \\
         & reshape \\
		 & deconv2d (, stride 2, SAME, RELU) \\
		 & deconv2d (, stride 2, SAME, RELU) \\
		 & deconv2d (, stride 2, SAME, RELU) \\
		 & deconv2d (, stride 2, SAME, sigmoid) \\
        \bottomrule
	\end{tabular}
    \vspace{2mm}
	\label{table:decoder_shapenet}
\end{table}

\clearpage
\pagebreak
\newpage
\end{document}
