\documentclass[fleqn]{llncs}



\usepackage{latexsym}
\usepackage{amssymb}
\usepackage{stmaryrd}
\usepackage{graphicx}
\usepackage{color}
\usepackage{url}
\usepackage{phonetic}
\usepackage{amsmath}

\newcommand{\additionu}[1]{\textcolor{blue}{#1}}
\newcommand{\additionuqe}[1]{\textcolor{red}{#1}}

\newcommand{\be}{\begin{enumerate}}
\newcommand{\ee}{\end{enumerate}}
\newcommand{\bi}{\begin{itemize}}
\newcommand{\ei}{\end{itemize}}
\newcommand{\bc}{\begin{center}}
\newcommand{\ec}{\end{center}}
\newcommand{\bsp}{\begin{sloppypar}}
\newcommand{\esp}{\end{sloppypar}}

\newtheorem{thm}{Theorem}[subsection]
\newtheorem{cor}[thm]{Corollary}
\newtheorem{lem}[thm]{Lemma}
\newtheorem{prop}[thm]{Proposition}
\newtheorem{rem}[thm]{Remark}
\newtheorem{eg}[thm]{Example}
\newtheorem{df}[thm]{Definition}




\newcommand{\sglsp}{\ }
\newcommand{\dblsp}{\ \ }

\newcommand{\sC}{\mbox{}}
\newcommand{\sD}{\mbox{}}
\newcommand{\sE}{\mbox{}}
\newcommand{\sG}{\mbox{}}
\newcommand{\sH}{\mbox{}}
\newcommand{\sJ}{\mbox{}}
\newcommand{\sL}{\mbox{}}
\newcommand{\sM}{\mbox{}}
\newcommand{\sP}{\mbox{}}
\newcommand{\sS}{\mbox{}}
\newcommand{\sT}{\mbox{}}
\newcommand{\sV}{\mbox{}}
\newcommand{\sW}{\mbox{}}

\renewcommand{\phi}{\varphi}

\newcommand{\churchqe}{}
\newcommand{\qzero}{}
\newcommand{\qzerou}{}
\newcommand{\qzerouqe}{}
\newcommand{\iotaAlt}{\mbox{\it \i}}
\newcommand{\iotaAltS}{\mbox{{\scriptsize \it \i}}}
\newcommand{\pfsys}{}
\newcommand{\pfsysu}{}
\newcommand{\pfsysuq}{}
\newcommand{\pfsysuqeplus}{}
\newcommand{\pfsysuqe}{}
\newcommand{\sub}{\d{\sf S}}

\newcommand{\seq}[1]{{\langle #1 \rangle}}
\newcommand{\set}[1]{{\{ #1 \}}}
\newcommand{\sembrack}[1]{\llbracket#1\rrbracket}
\newcommand{\synbrack}[1]{\ulcorner#1\urcorner}
\newcommand{\commabrack}[1]{\lfloor#1\rfloor}
\newcommand{\mname}[1]{\mbox{\sf #1}}
\newcommand{\mcolon}{\mathrel:}
\newcommand{\mdot}{\mathrel.}
\newcommand{\tarrow}{\rightarrow}
\newcommand{\LambdaApp}{\lambda\,}
\newcommand{\Neg}{\neg}
\newcommand{\NegAlt}{{\sim}}
\newcommand{\Andd}{\wedge}
\newcommand{\Implies}{\supset}
\newcommand{\Or}{\vee}
\newcommand{\Iff}{\equiv}
\newcommand{\Forall}{\forall}
\newcommand{\ForallApp}{\forall\,}
\newcommand{\Forsome}{\exists}
\newcommand{\ForsomeApp}{\exists\,}
\newcommand{\ForsomeUniqueApp}{\exists\,!\,}
\newcommand{\Iota}{\mbox{\rm I}}
\newcommand{\IsDef}{\downarrow}
\newcommand{\IsUndef}{\uparrow}
\newcommand{\Equal}{=}
\newcommand{\QuasiEqual}{\simeq}
\newcommand{\Undefined}{\bot}
\newcommand{\If}{\mname{if}}
\newcommand{\IsDefApp}{\!\IsDef}
\newcommand{\IsUndefApp}{\!\IsUndef}
\newcommand{\invertediota}{\rotatebox[origin=c]{180}{}}
\newcommand{\pf}{\mbox{\sc pf}}
\newcommand{\pfstar}{}
\newcommand{\imps}{\mbox{\sc imps}}
\newcommand{\tps}{\mbox{\sc tps}}
\newcommand{\hol}{\mbox{\sc hol}}
\newcommand{\pvs}{\mbox{\sc pvs}}
\newcommand{\lutins}{\mbox{\sc lutins}}
\newcommand{\sttwu}{\mbox{{\sc stt}{\small w}{\sc u}}}
\newcommand{\modelsa}{\mathrel{\models^{\rm ef}\!}}
\newcommand{\modelsb}{\mathrel{\overline{\models^{\rm ef}}\!}}
\newcommand{\modelsn}{\mathrel{\models_{\rm n}}}
\newcommand{\modelsna}{\mathrel{\models^{\rm ef\!}_{\rm n}}}
\newcommand{\modelsnb}{\mathrel{\overline{\models^{\ast}_{\rm n}}}}
\newcommand{\proves}[2]{#1 \vdash #2}
\newcommand{\provesa}[2]{#1 \mathrel{\vdash^{\rm ef}\!} #2}
\newcommand{\provesb}[2]{#1 \mathrel{\overline{\vdash^{\rm ef}}\!} #2}
\newcommand{\wff}[1]{{\rm wff}_{#1}}
\newcommand{\xwff}[1]{{\rm xwff}_{#1}}
\newcommand{\wffs}[1]{{\rm wffs}_{#1}}
\newcommand{\xwffs}[1]{{\rm xwffs}_{#1}}

\newcommand{\TRUE}{\mbox{{\sc t}}}
\newcommand{\FALSE}{\mbox{{\sc f}}}

\newcommand{\nbg}{\mbox{\sc nbg}}
 
\title{Incorporating Quotation and Evaluation into Church's Type
  Theory:\\ Syntax and Semantics\thanks{Published in: M. Kohlhase et
    al., eds, \emph{Intelligent Computer Mathematics (CICM 2016)},
    \emph{Lecture Notes in Computer Science}, Vol.~9791, pp.~83--98,
    Springer, 2016. The final publication is available at Springer via
    http://dx.doi.org/10.1007/978-3-319-42547-4\_7. This research was
    supported by NSERC.}}

\author{William M. Farmer}

\institute{Computing and Software, McMaster University, Canada\\
\email{wmfarmer@mcmaster.ca}\V^{\cal
      M}_{\phi}(\textbf{C}_\gamma) = V^{\cal
      M}_{\phi}(\sE^{-1}(V^{\cal M}_{\phi}(\textbf{A}_\epsilon))). \setcounter{equation}{0}
&
\sV^{\cal M}_{\phi}(\synbrack{\textbf{A}_\alpha}) \\
&=
\sE(\textbf{A}_\alpha) \\
&=
\sV^{\cal M}_{\phi}(\sE(\textbf{A}_\alpha))
 \setcounter{equation}{0}
&
\sV^{\cal M}_{\phi}(\sembrack{\synbrack{\textbf{A}_\alpha}}_\alpha) \\
&=
\sV^{\cal M}_{\phi}(\sE^{-1}(\sV^{\cal M}_{\phi}(\synbrack{\textbf{A}_\alpha}))) \\
&=
\sV^{\cal M}_{\phi}(\sE^{-1}(\sE(\textbf{A}_\alpha))) \\
&=
\sV^{\cal M}_{\phi}(\textbf{A}_\alpha)
\LambdaApp x_\epsilon \mdot \LambdaApp y_\epsilon \mdot
(\mname{app}_{\epsilon \tarrow \epsilon \tarrow \epsilon} \,
(\mname{app}_{\epsilon \tarrow \epsilon \tarrow \epsilon} \,
\synbrack{\Implies_{o \tarrow o \tarrow o}} \, x_\epsilon) \,
y_\epsilon).\LambdaApp x_\epsilon \mdot
\ForsomeApp y_\epsilon \mdot \ForsomeApp z_\epsilon
\mdot x_\epsilon = (\mname{app}_{\epsilon \tarrow \epsilon
  \tarrow \epsilon} \, y_\epsilon \, z_\epsilon).\mname{make-implication}_{\epsilon \tarrow \epsilon \tarrow
  \epsilon} \, \synbrack{\textbf{A}_o} \, \synbrack{\textbf{B}_o}\sembrack{\mname{make-implication}_{\epsilon \tarrow \epsilon \tarrow
  \epsilon} \, \synbrack{\textbf{A}_o} \, \synbrack{\textbf{B}_o}}_o\mname{app}_{\epsilon \tarrow
  \epsilon \tarrow \epsilon} \, \synbrack{\Neg_{o \tarrow o}} \,
(\mname{app}_{\epsilon \tarrow \epsilon \tarrow \epsilon} \,
(\mname{app}_{\epsilon \tarrow \epsilon \tarrow \epsilon}
\synbrack{\wedge_{o \tarrow o \tarrow o}} \, \sE'(\textbf{A}_o))
\, \textbf{B}_\epsilon).\ForallApp x_\epsilon \mdot 
\mname{is-expr}_{\epsilon \tarrow o}^{o} \, x_\epsilon \Implies
\sembrack{x_\epsilon}_o \Or \Neg \sembrack{x_\epsilon}_o.\ForallApp x_\epsilon \mdot 
\mname{is-expr}_{\epsilon \tarrow o}^{o} \, x_\epsilon \Implies
\sembrack{\synbrack{\commabrack{x_\epsilon} \Or \Neg
    \commabrack{x_\epsilon}}}_o.
&
\ForallApp f_\epsilon \mdot 
(\mname{is-expr}_{\epsilon \tarrow o}^{\iota \tarrow o} \, f_\epsilon \Andd
\mname{is-peano}_{\epsilon \tarrow o} \, f_\epsilon) \Implies {} \\
&
\hspace{4ex}
((\sembrack{f_\epsilon}_{\iota \tarrow o} \, 0 \Andd
(\ForallApp x_\iota \mdot \sembrack{f_\epsilon}_{\iota \tarrow o} \, x_\iota \Implies
\sembrack{f_\epsilon}_{\iota \tarrow o} \, 
(\mname{S}_{\iota \tarrow \iota} \, x_\iota)))
\Implies 
\ForallApp x_\iota \mdot \sembrack{f_\epsilon}_{\iota \tarrow o} \, x_\iota)

&
\ForallApp u_\epsilon \mdot \ForallApp v_\epsilon \mdot
(\mname{is-var}_{\epsilon \tarrow o} \, u_\epsilon
 \Andd
\mname{is-expr}_{\epsilon \tarrow o}^{\iota} \, u_\epsilon
 \Andd
\mname{is-poly}_{\epsilon \tarrow o} \, v_\epsilon) \Implies {} \\
&
\hspace{4ex}
\mname{deriv}_{(\iota \tarrow \iota) \tarrow (\iota \tarrow \iota)}
(\sembrack{\mname{abs}_{\epsilon \tarrow  \epsilon \tarrow \epsilon} \,
u_\epsilon \, v_\epsilon}_{\iota \tarrow \iota}) = {} \\
&
\hspace{4ex}
\sembrack{\mname{abs}_{\epsilon \tarrow  \epsilon \tarrow \epsilon} \,
u_\epsilon \, 
(\mname{poly-diff}_{\epsilon \tarrow \epsilon \tarrow \epsilon} \, 
v_\epsilon \, u_\epsilon)}_{\iota \tarrow \iota}.\footnotemark
 \setcounter{equation}{0}
&
\mname{deriv}_{(\iota \tarrow \iota) \tarrow (\iota \tarrow \iota)}
(\LambdaApp x_\iota \mdot x_{\iota}^{2})\\
&=
\mname{deriv}_{(\iota \tarrow \iota) \tarrow (\iota \tarrow \iota)}
(\sembrack{\synbrack{\LambdaApp x_\iota \mdot x_{\iota}^{2}}}_{\iota \tarrow \iota})\\
&=
\mname{deriv}_{(\iota \tarrow \iota) \tarrow (\iota \tarrow \iota)}
(\sembrack{\mname{abs}_{\epsilon \tarrow  \epsilon \tarrow \epsilon} \,
\synbrack{x_{\iota}} \, \synbrack{x_{\iota}^{2}}}_{\iota \tarrow \iota})\\
&=
\sembrack{\mname{abs}_{\epsilon \tarrow  \epsilon \tarrow \epsilon} \,
\synbrack{x_{\iota}} \, 
(\mname{poly-diff}_{\epsilon \tarrow \epsilon \tarrow \epsilon} \, 
\synbrack{x_{\iota}^{2}} \, \synbrack{x_{\iota}})}_{\iota \tarrow \iota}\\
&=
\sembrack{\mname{abs}_{\epsilon \tarrow  \epsilon \tarrow \epsilon} \,
\synbrack{x_{\iota}} \, \synbrack{2 \ast x_{\iota}}}_{\iota \tarrow \iota}\\
&=
\sembrack{\synbrack{\LambdaApp x_\iota \mdot 2 \ast x_{\iota}}}_{\iota \tarrow \iota}\\
&=
\LambdaApp x_\iota \mdot 2 \ast x_{\iota}
\mname{sub}_{\epsilon \tarrow \epsilon \tarrow \epsilon \tarrow
  \epsilon} \, \synbrack{\textbf{A}_\alpha} \,
\synbrack{\textbf{x}_\alpha} \, \synbrack{\textbf{B}_\beta} =
\synbrack{\textbf{C}_\beta}.
&
(\mname{is-expr}_{\epsilon \tarrow o}^{\beta} \, 
((\LambdaApp \textbf{x}_\alpha \mdot \textbf{B}_\epsilon) \, \textbf{A}_\alpha) \Andd 
\Neg(\mname{is-free-in}_{\epsilon \tarrow \epsilon \tarrow o} \,
\synbrack{\textbf{x}_\alpha} \, ((\LambdaApp \textbf{x}_\alpha \mdot
\textbf{B}_\epsilon) \, \textbf{A}_\alpha))) \Implies {} \\
&
\hspace{4ex}
(\LambdaApp \textbf{x}_\alpha \mdot
\sembrack{\textbf{B}_\epsilon}_\beta) \, \textbf{A}_\alpha =
\sembrack{(\LambdaApp \textbf{x}_\alpha \mdot \textbf{B}_\epsilon) \,
  \textbf{A}_\alpha}_\beta.

Here  would
be a new logical constant in , and the second condition would say
that  is not free in the expression whose syntax
tree is represented by .  As a result, there would
be no free occurrences of  in the right-hand side
of the conclusion after the evaluation is eliminated.  Details of this
approach will be given in a future paper that presents the proof
system for {\churchqe} that we have sketched.

\section{Conclusion}

Quotation and evaluation provide a basis for metaprogramming as seen
in Lisp and other programming languages.  We believe that these
mechanisms can also provide a basis for metareasoning in traditional
logics like first-order logic or simple type theory.  However,
incorporating quotation and evaluation into a traditional logic is
much more challenging than incorporating them into a programming
language due to the three problems we described in the Introduction.

In this paper we have introduced {\churchqe}, a logic based on
{\qzero}~\cite{Andrews02}, Andrews' version of Church's type theory,
that includes quotation and evaluation.  We have presented the syntax
and semantics of {\churchqe}, sketched a proof system for it, and
given examples that show the practical benefit of having quotation and
evaluation in a logic.

{\churchqe} is a simpler version of {\qzerouqe}~\cite{FarmerArxiv14},
a richer, but more complicated, version of {\qzero} with
undefinedness, quotation, and evaluation.  In {\qzerouqe}, quotation
may be applied to expressions containing evaluations, expressions may
be undefined and functions may be partial, and substitution is
implemented explicitly as a logical constant.  Allowing quotation to
be applied to all expressions makes {\qzerouqe} much more expressive
than {\churchqe} but also much more difficult to implement since
substitution in the presence of evaluations is highly complex.  We
believe that {\churchqe} would not be hard to implement.  Since it is
a version of Church's type theory, it could be implemented by
extending an implementation of HOL~\cite{GordonMelham93} such as
HOL Light~\cite{Harrison09}.

Our approach for incorporating quotation and evaluation into Church's
type theory --- introducing an inductive type of constructions, a
quotation operator, and a typed evaluation operator --- can be applied
to other logics including many-sorted first-order logic.  We have
shown that developing the needed syntax and semantics is relatively
straightforward, while developing a proof system for the logic is
fraught with difficulties.

\section*{Acknowledgments}

The author thanks the reviewers for their helpful comments and
suggestions.

\bibliography{$HOME/research/lib/imps}\bibliographystyle{plain}

\end{document}
