\documentclass[sigconf]{acmart}

\usepackage{booktabs} \usepackage{xcite}
\usepackage{xr}
\usepackage{graphicx}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{multirow}
\usepackage{bigstrut}
\usepackage{enumitem}
\usepackage[skip=0pt]{caption}
\usepackage[ruled,linesnumbered]{algorithm2e}
\usepackage{bm}
\usepackage{tabularx,ragged2e}
\usepackage{xcolor}
\usepackage{verbatim}

\usepackage{amsmath}

\externalcitedocument{introduction}
\externaldocument{introduction}
\externalcitedocument{methods}
\externaldocument{methods}
\externalcitedocument{evaluation}
\externaldocument{evaluation}

\settopmatter{printacmref=false} \renewcommand\footnotetextcopyrightpermission[1]{} \pagestyle{empty} 



\setcounter{secnumdepth}{3}

\makeatletter
\def\subsubsection{\@startsection{subsubsection}{3}\z@{.3\linespacing\@plus.7\linespacing}{.1\linespacing}{\normalfont\itshape}}
\makeatother



\copyrightyear{2019} 
\acmYear{2019} 
\setcopyright{acmcopyright}
\acmConference[KDD '19]{The 25th ACM SIGKDD Conference on Knowledge Discovery and Data Mining}{August 4--8, 2019}{Anchorage, AK, USA}
\acmBooktitle{The 25th ACM SIGKDD Conference on Knowledge Discovery and Data Mining (KDD '19), August 4--8, 2019, Anchorage, AK, USA}
\acmPrice{15.00}
\acmDOI{10.1145/3292500.3330984}
\acmISBN{978-1-4503-6201-6/19/08}

\fancyhead{}

\begin{document}
\title{Hierarchical Gating Networks for Sequential Recommendation}

\author{Chen Ma}
\affiliation{\institution{School of Computer Science\\McGill University}}
\email{chen.ma2@mail.mcgill.ca}

\author{Peng Kang}
\affiliation{\institution{Department of Computer Science\\Northwestern University}}
\email{pengkang2022@u.northwestern.edu}

\author{Xue Liu}
\affiliation{\institution{School of Computer Science\\McGill University}}
\email{xueliu@cs.mcgill.ca}


\begin{abstract}
The chronological order of user-item interactions is a key feature in many recommender systems, where the items that users will interact may largely depend on those items that users just accessed recently. However, with the tremendous increase of users and items, sequential recommender systems still face several challenging problems: (1) the hardness of modeling the long-term user interests from sparse implicit feedback; (2) the difficulty of capturing the short-term user interests given several items the user just accessed. To cope with these challenges, we propose a hierarchical gating network (HGN), integrated with the Bayesian Personalized Ranking (BPR) to capture both the long-term and short-term user interests. Our HGN consists of a feature gating module, an instance gating module, and an item-item product module. In particular, our feature gating and instance gating modules select what item features can be passed to the downstream layers from the feature and instance levels, respectively. Our item-item product module explicitly captures the item relations between the items that users accessed in the past and those items users will access in the future. We extensively evaluate our model with several state-of-the-art methods and different validation metrics on five real-world datasets. The experimental results demonstrate the effectiveness of our model on Top-N sequential recommendation.
\end{abstract}

\begin{CCSXML}
<ccs2012>
<concept>
<concept_id>10002951.10003317.10003347.10003350</concept_id>
<concept_desc>Information systems~Recommender systems</concept_desc>
<concept_significance>500</concept_significance>
</concept>
</ccs2012>
\end{CCSXML}

\ccsdesc[500]{Information systems~Recommender systems}

\keywords{Sequential Recommendation; Feature Gating; Instance Gating; Item-item Product}

\maketitle

\section{Introduction}
As the Internet service and mobile device usages keep growing, Internet users can easily access a large number of online products and services. Although this growth provides users with more available choices, it is also difficult for users to pick up one of the most favorite items out of plenty of candidates. To reduce information overload and satisfy the diverse needs of users, personalized recommender systems come into being and play more and more important roles in modern society. These systems can provide personalized experiences, serve huge service demands, and bring significant benefits to at least two parties: (1) help users easily discover products that they are interested in; (2) create opportunities for product providers to increase the revenue.

In all kinds of Internet services, users access the products or items in a chronological order, where the items a user will interact may be closely relevant to those items she just accessed. This property facilitates a non-trivial recommendation task---sequential recommendation, which treats the user behavior history as an action sequence ordered by the operating timestamp. This task is challenging to address due to one major reason: the difficulty of inferring users' short-term interests and intentions. Indeed, both the long-term and short-term interests of users together determine the users' actions on items. With the large accumulated data, the long-term user interests can be effectively modeled. However, within a short-term context, how to take advantage of the sequential dynamics for predicting user actions in the near future is non-trivial.

To capture the sequential dynamics in the user action history, effective models are proposed to learn the short-term user preference in the sequential user interactions, such as Markov Chains (MCs), convolutional neural networks (CNNs), and recurrent neural networks (RNNs). MC-based methods \cite{DBLP:conf/www/RendleFS10,DBLP:conf/icdm/HeM16} apply a -order Markov chain to make recommendations based on the  previous actions. CNN-based methods \cite{DBLP:conf/wsdm/TangW18} utilize convolutional filters and sliding window strategies to capture the short-term contexts for future prediction. RNN-based methods \cite{DBLP:journals/corr/HidasiKBT15,DBLP:conf/recsys/QuadranaKHC17,DBLP:conf/cikm/HidasiK18} adopt gated recurrent (GRU) or long short-term memory (LSTM) units to learn the user-item sequence, where the short-term user interests are captured by the hidden states of RNNs.

Although existing methods have proposed effective models and achieved satisfactory results, we argue that there are still several factors to be considered for enhancing the performance. First, previous studies \cite{DBLP:conf/wsdm/TangW18,DBLP:journals/corr/HidasiKBT15,DBLP:conf/recsys/QuadranaKHC17,DBLP:conf/cikm/HidasiK18} learn the user action sequence by CNN or RNN structures, which does not consider the specific parts of features of different items. Neglecting the representative features may fail to capture the true user interests in a short context. Second, these CNN or RNN based methods also do not discriminate the item importance based on users' preferences. Equally treating those informative items along with other items may lead to the incomplete understanding of user intentions. Third, it is also important to note that the relations between items are neglected in previous works \cite{DBLP:conf/icdm/KangM18,DBLP:conf/cikm/HidasiK18,DBLP:conf/wsdm/TangW18}. It is very likely that closely related items may be interacted by users one after the other. As such, explicitly capturing the item-item relations will largely benefit predicting subsequent items users will interact.

To address the problems mentioned above, we propose a novel recommendation model, hierarchical gating network (HGN), for the sequential recommendation task without using complex recurrent or convolutional neural networks. HGN consists of a feature gating module, an instance gating module, and an item-item product module, integrated with the matrix factorization model and optimized by the Bayesian Personalized Ranking (BPR) objective. In particular, the feature gating module allows the adaptive selections of attractive latent features of items based on the user preference, where the selected user-specific features will be passed to the instance gating module. At the instance gating module, important items that reflect the short-term user interests will be distinguished and selected for future item prediction. Thus, the feature gating and instance gating modules form a hierarchical gating network to control what features or items can be passed to the downstream layers. On the other hand, item-item relations provide important auxiliary information to predict users' sequential behaviors, since closely related items may be interacted by users one after the other. Thus, we apply an item-item product module to explicitly capture the relations between the items users have interacted and those items user will interact in the future. We extensively evaluate our model with many state-of-the-art methods and different validation metrics on five real-world datasets. The experimental results not only demonstrate the improvements of our model over other baselines but also show the effectiveness of the gating and item-item product modules.

To summarize, the major contributions of this paper are listed as follows:
\begin{itemize}[leftmargin=*]
\item To infer the user interests in a short-term context, we propose a hierarchical gating network to control what item latent features and which relevant item can be passed to the downstream layers. Our hierarchical gating network achieves better performance compared with complex recurrent or convolutional neural networks yet with fewer parameters and faster training speed.
\item To explicitly capture the item-item relations, we utilize an item-item product module to learn the relationships between the items users have interacted and those items user will interact in the near future.
\item Experiments on five real-world datasets show that the proposed HGN model significantly outperforms the state-of-the-art methods for the sequential recommendation task.
\end{itemize}



 




 
\section{Related Work}
In this section, we illustrate related work about the proposed model: personalized recommendation with user implicit feedback and the sequential recommendation.

\subsection{Recommendation with Implicit Feedback}
In many real-world recommendation scenarios, user implicit data \cite{DBLP:conf/kdd/WangWY15,DBLP:conf/cikm/TranLL018}, e.g., browsing or clicking history, is more ubiquitous and common than the explicit feedback \cite{DBLP:conf/www/SarwarKKR01,DBLP:conf/icml/SalakhutdinovMH07}, such as user ratings. The implicit feedback only provides positive samples, which is also called one-class collaborative filtering (OCCF) \cite{DBLP:conf/icdm/PanZCLLSY08}. Effective methods are proposed to tackle the OCCF problem. Early works either apply a uniform weighting scheme to treat all missing data as negative samples \cite{DBLP:conf/icdm/HuKV08}, or sample negative instances from missing data to learn the pair-wise user preference between positive and negative samples \cite{DBLP:conf/uai/RendleFGS09}. Recently, several works \cite{DBLP:conf/sigir/HeZKC16,DBLP:conf/www/LiangCMB16} are proposed to weigh the missing data. In \cite{DBLP:conf/www/TranLLK19,DBLP:conf/www/HsiehYCLBE17}, metric learning is applied to compute the distance between users and items. With the ability to represent non-linear and complex data, (deep) neural networks have been utilized in the domain of recommendation and bring more opportunities to reshape the conventional recommendation architectures. In \cite{DBLP:conf/wsdm/WuDZE16,DBLP:conf/cikm/MaZWL18,DBLP:conf/wsdm/MaKWWL19}, (denoising) autoencoders are proposed capture the user-item interaction from user implicit feedback. In \cite{DBLP:conf/www/HeLZNHC17}, He et al. propose a neural network-based collaborative filtering model, where a multi-layer perceptron is utilized to learn the non-linear user-item interactions. In \cite{DBLP:conf/ijcai/XueDZHC17,DBLP:conf/ijcai/GuoTYLH17,DBLP:conf/kdd/LianZZCXS18}, conventional matrix factorization and factorization machine methods are also benefited by the representation ability of deep neural networks.

\subsection{Sequential Recommendation}
Some early sequential recommendation methods rely on item-item transition matrices to capture the sequential patterns in the user interaction sequence. The Markov chain \cite{DBLP:conf/ijcai/ChengYLK13} is a classical option to solve this problem. For example, Rendle et al. \cite{DBLP:conf/www/RendleFS10} propose to factorize personalized Markov chains for capturing long-term preferences and short-term transitions. He et al. \cite{DBLP:conf/icdm/HeM16} combines similarity-based models with high-order Markov chains to make personalized sequential recommendations. In \cite{DBLP:conf/recsys/HeKM17}, the translation-based method is proposed for sequential recommendation. Recently, benefited by the advantages of sequence learning in natural language processing, (deep) neural network based methods are proposed to learn the sequential dynamics. For instance, Tang et al. \cite{DBLP:conf/wsdm/TangW18} propose to apply the convolutional neural network (CNN) on item embedding sequence, where the short-term contexts can be captured by the convolutional operations. In \cite{DBLP:journals/corr/HidasiKBT15,DBLP:conf/recsys/QuadranaKHC17,DBLP:conf/cikm/LiRCRLM17,DBLP:conf/cikm/HidasiK18}, recurrent neural network (RNN), especially gated recurrent unit (GRU), based methods are utilized to model the sequential patterns  for the session-based recommendation \cite{DBLP:journals/corr/HidasiKBT15}, where the hidden states of RNNs reflect the summary of the (sub)sequence. On the other hand, self-attention \cite{DBLP:conf/nips/VaswaniSPUJGKP17} exhibits promising performance in sequence learning and is utilized in sequential recommendation. In \cite{DBLP:conf/icdm/KangM18}, Kang et al. propose to leverage self-attention for adaptively considering interacted items. In \cite{DBLP:conf/wsdm/ChenXZT0QZ18,DBLP:conf/sigir/HuangZDWC18}, memory networks \cite{DBLP:conf/nips/SukhbaatarSWF15} are adopted to memorize the important items that will play a role in predicting future user actions.

However, our hierarchical gating network is different from the above studies. We apply feature-level and instance-level gating modules to adaptively control what item latent features and which relevant item can be passed to the downstream layers. While previous works either do not consider the representative items, or only consider the instance-level importance by the attention model but neglecting the feature-level ones. On the other hand, we adopt an item-item product to explicitly capture the relations between the items users have interacted and those items users will access in the near future, where the explicit modeling of item relations is rarely considered in previous works.
 
\section{Problem Formulation}
The recommendation task considered in this paper takes sequential implicit feedback as training data. The user preference is presented by a user-item sequence in the chronological order , where  is an item index that user  has interacted with. Given the earlier subsequence  of  users, the problem is to recommend a list of items from  items to each user and evaluate whether the items in  will appear in the recommended list.

Here, following common symbolic notation, upper case bold letters denote matrices, lower case bold letters denote column vectors without any specification, and non-bold letters represent scalars. The major symbols are listed in Table \ref{tab:notations}.

\begin{table}[ht]
\centering
\caption{List of notations.}
\label{tab:notations}
\begin{tabular}{ll}
 \hline
,  & the number of users and items \\
 & the item sequence of user  \\
 & the embeddings of the -th subsequence of user  \\
 & the learnable parameters in the gating layers \\
 & the user embedding matrix \\
 & the input item embedding matrix \\
 & the output item embedding matrix \\
 & the dimension of the embeddings \\
 & the prediction score of user  on item  \\
 & the regularization term \\ \hline
\end{tabular}
\vspace{-0.3cm}
\end{table}


\begin{figure*}[t!]
    \centering
    \begin{subfigure}[t]{0.33\textwidth}
        \centering
        \includegraphics[width=\linewidth]{pic/feature_gating.png}
        \caption{\label{fig:feature_gating}Feature gating}
    \end{subfigure}\begin{subfigure}[t]{0.33\textwidth}
        \centering
        \includegraphics[width=\linewidth]{pic/instance_gating.png}
        \caption{\label{fig:instance_gating}Instance gating}
    \end{subfigure}\begin{subfigure}[t]{0.33\textwidth}
        \centering
        \includegraphics[width=\linewidth]{pic/item_product.png}
        \caption{\label{fig:item_product}Item-item product}
    \end{subfigure}
    \Description{An illustrative example}
    \caption{\label{fig:three_modules}An illustrative example of the feature gating, instance gating, and item-item product modules. In Figure \ref{fig:feature_gating}, the gray lines on items denote those latent features are masked off. In Figure \ref{fig:instance_gating}, the darker blue means the item is more important. In Figure \ref{fig:item_product}, the line linked between two items denotes the inner product, which captures the relations between the items users have accessed and the items users will access in the future.}
\end{figure*}


\section{Methodologies}
To model the sequential recommendation task, for each user , we extract every , i.e. , successive items as input and their next  items as the targets to be predicted. The problem can be formulated as: in the user-item interaction sequence , given the  successive items, how likely other  items will be interacted subsequently.

In the sequential recommendation problem, the prediction of users' preferences on items can be modeled in two perspectives: long-term interests and short-term interests. The long-term user preference modeling has been widely investigated in the conventional Top-N recommendation methods, such as matrix factorization \cite{DBLP:conf/icdm/HuKV08,DBLP:conf/uai/RendleFGS09}. On the other hand, how to capture the short-term user interests from the sequential data is the key point for performance improvement.

For the short-term interest modeling, we argue that there are two kinds of relationships existing between items users have interacted and items users will interact in the future: group-level and instance-level relations. The group-level influence illustrates a phenomenon that several items in  together have an impact on the items user may interact in the future. For example, if a user has bought a bed frame and a mattress, a pillow is probably a more suitable recommendation than a table. On the other hand, the instance-level influence depicts the strong relation between a single item in  and a single item in . For example, if a user bought a mobile phone, she may also need to buy a screen protector or a case. Thus, these two kinds of relations together determine users' short-term interests.

In this section, we introduce the proposed model to capture both the long-term interests and short-term interests of users for the sequential recommendation, which is shown in Figure \ref{fig:three_modules} and Figure \ref{fig:whole_model}. We first illustrate the hierarchical gating network for learning users' group-level preferences. Next, we present the inner product of item embeddings to model the item-item relations. Then we introduce the prediction layer for aggregating the long-term and short-term interests of users. Lastly, we go through the loss function and training process of the proposed model. 

\subsection{Hierarchical Gating for Group-level Influence}
In the sequential recommendation, taking advantage of the properties of sequential data to learn the (sub)sequence representation is a critical point, where an item may be closely related to its previous or subsequent items, or a group of previous items will have an impact on the items in the near future. In previous works, researchers have utilized various methods to model the group-level sequential interactions, e.g., convolutional neural networks \cite{DBLP:conf/wsdm/TangW18}, recurrent neural networks \cite{DBLP:journals/corr/HidasiKBT15,DBLP:conf/cikm/PeiYSZBT17,DBLP:conf/recsys/QuadranaKHC17,DBLP:conf/cikm/HidasiK18}, and the self-attention model \cite{DBLP:conf/icdm/KangM18}. Different from previous works, we propose a hierarchical gating network for modeling group-level user-item interactions, which consists of two components: a feature gating module and an instance gating module. These two modules allow the selection of effective latent features and relevant items, respectively, for predicting the subsequent items. Our proposed gating network is both effective and efficient (section \ref{sec:evaluation}).

\begin{figure*}[t!]
    \centering
    \includegraphics[width=0.9\linewidth]{pic/HGN_model.png}
    \caption{\label{fig:whole_model}The architecture of HGN. HGN consists of three major components: the embedding layer, the hierarchical gating layer, and the prediction layer. Specifically, \textit{F Gating} denotes the feature gating module, \textit{I Gating} denotes the instance gating module, \textit{Aggregation} denotes the aggregation layer, and  denotes the element-wise multiplication.}
\end{figure*}

\subsubsection{Feature Gating}
Unlike previous works \cite{DBLP:conf/wsdm/TangW18,DBLP:conf/cikm/HidasiK18,DBLP:conf/icdm/KangM18} that only operate on the item-level, we provide a learnable feature gating module to select salient latent features of items from the feature-level. For a certain item, some parts of the latent features are more relevant to predict the subsequent items. For example, for a big fan of Robert Downey Jr., after watching Iron Man I and Iron Man II, it is better to recommend Iron Man III rather than Aquaman, although Aquaman is also a superhero movie. Thus, to capture the representative item features based on users' long-term preferences is a necessary point to capture.

\textbf{Embedding Layer}. In the proposed module, the input is a sequence of  items, where each item is represented by a unique index. At the embedding layer, the item index is converted into a low-dimensional real-valued dense vector representation by an item embedding matrix , where  is the dimension of the item embedding and  is the number of items. After converted by the embedding layer, the item subsequence embeddings are represented as:

where  indicates the embeddings of the -th subsequence of user ,  is the -th column of the embedding matrix .

\textbf{Gated Linear Unit}. Inspired by the gated linear unit (GLU) proposed by Dauphin et al. in \cite{DBLP:conf/icml/DauphinFAG17}, which is utilized to control what information should be propagated for predicting the next word in the language modeling task, we also adopt a similar model to select what features are relevant to predict future items. The GLU in the original paper is shown:
 
where  is the input embeddings, , , ,  are learnable parameters,  is the sigmoid function,  is the convolution operation, and  is the element-wise product between matrices.

\textbf{Personalized Feature Gating}. However, directly applying the GLU to select item features does not explicitly consider the user preference on items. For a certain item, a user may just focus a specific part of the item and neglect other unattractive parts. For example, a user may only care about whether the starring role is Tom Cruise rather than the movie content. 

Therefore, to capture the item features that tailored to users' preferences, we need to modify the GLU to be user-specific. To reduce the number of learnable parameters, we apply the inner product instead of the convolution operation in the original GLU (the superscript  indicates the item sequence embeddings are learned from the feature gating module):

where  is the embedding of user ,  and  are learnable parameters, and  is the element-wise product between matrices. By doing this, user-specific features of items can be passed to downstream layers.

\subsubsection{Instance Gating}
\textbf{Personalized Instance Gating}. Since our formulated problem is: given  successive items, how likely other items will appear after  in the near feature, we argue that there are some items are more relevant in  to predict the items users will interact. However, existing works either do not consider the representative items in  \cite{DBLP:conf/wsdm/TangW18,DBLP:conf/cikm/HidasiK18} or apply attention models to capture the representative items \cite{DBLP:conf/cikm/LiRCRLM17,DBLP:conf/icdm/KangM18}. Unlike previous works benefiting from attention models, we adopt an instance-level gating module to select the informative items that are helpful to predict items in the near future according to users' preferences:

where  is the sequence embedding after the instance gating, ,  are learnable parameters. By applying the instance gating, the representative items will contribute more to make predictions about the future items and irrelevant items will be largely neglected.

\textbf{Aggregation Layer}. To make the item embeddings  into one group-level latent representation, we can either apply average pooling or max pooling on :


where . Since the item embeddings have manipulated by the feature-level and instance-level gating modules, the informative features and items have been selected and irrelevant ones have been eliminated. Thus, the average pooling will accumulate the informative parts in these embeddings. On the other hand, max-pooling directly selects the most representative features from each embedding to form the group-level representation.

\subsection{Item-item Product}
The relation between two single items is an important factor to model in the recommendation task and has been widely studied in many years \cite{DBLP:reference/sp/NingDK15,DBLP:conf/kdd/KabburNK13}, e.g., item-based collaborative filtering methods utilizing the rating vectors of two items to calculate the similarity. However, most of the recent works \cite{DBLP:conf/wsdm/TangW18,DBLP:conf/cikm/HidasiK18,DBLP:conf/icdm/KangM18} only consider the sequential recommendation from the group-level, but do not explicitly capture the item-item relations between the items in  and the items user will interact in the future. Since strongly related item pairs will appear in  and  simultaneously. Unlike previous works, we apply the inner product between the input item embeddings and the output item embeddings to capture the item relations between  and :

where  is the output item embeddings, the sum of multiplication results captures the accumulated item-item relation scores from each item in  to all other items.

\subsection{Prediction Layer}
After applying the hierarchical gating network to capture the short-term interests of users and item-item product to capture the relevant item pairs, we adopt the classical matrix factorization term to capture the global and long-time interests of users. Given the -th subsequence to predict, the prediction score of user  on item  is:

where  is the -th column of the output item embedding . In the prediction layer, the first term captures the user long-term interests, the second term models the user short-term interests, and the third term reflects the relations between item pairs.

\subsection{Network Training} \label{sec:network training}
As the training data is from the user implicit feedback, we optimize the proposed model by the Bayesian Personalized Ranking objective \cite{DBLP:conf/uai/RendleFGS09}: optimizing the pairwise ranking between the positive and non-observing items:

where  denotes one of the  successive items of user ,  denotes the item that in , and  denotes the randomly sampled negative item,  is the parameters in the gating network,  is the regularization parameter. By minimizing the objective function, the partial derivatives with respect to all the parameters can be computed by gradient descent with back-propagation. We apply Adam \cite{DBLP:journals/corr/KingmaB14} to automatically adapt the learning rate during the learning procedure. 

\textbf{Time complexity}. The computational complexity of our model for each  is mainly due to the feature gating layer and item-item product module, which is  ( is the length of ,  is the dimension of embeddings, and  is the number of items). This computational complexity makes our model scalable on large datasets. We empirically test the training speed with other state-of-the-art methods and find that our model is faster than other methods (section \ref{sec:training_efficiency}). 

\begin{comment}

\begin{algorithm}
  \textbf{Input}: , , , ,  \;
Initialize parameters , ,  \;
  numBatches =    \;
  \Repeat {convergence} {
    Shuffle(, , , , ) \;
    \For{batch = 0; batch < numBatches; batch++} {
       = ExtractBatchData(batch, , , , ) \;
      For each item  in , apply Eq. \ref{eq:slice_operation} to get  \;
      Apply Eq. \ref{eq:attention_matrix}, Eq. \ref{eq:item_embedding_matrix} and Eq. \ref{eq:item_content_embedding} to get  \;
      For each item  in , apply Eq. \ref{eq:rating_AE} to get  \;
      Apply Eq. \ref{eq:gated_fusion} to fuse  and  to get  \;
      Apply Eq. \ref{eq:neighbor_attention} to get 's neighborhood hidden representation  based on  \;
      Apply Eq. \ref{eq:rating_decoder} to get  \;
      Apply Eq. \ref{eq:final_loss} to get  and backpropagate the error through the entire network \;
    }
  }

\caption{Joint Training Algorithm}
\label{alg:batch_training_algorithm}
\end{algorithm}

\end{comment}
 
\section{Experiments} \label{sec:evaluation}
In this section, we evaluate the proposed model with the state-of-the-art methods on five real-world datasets\footnote{The code is available on Github: https://github.com/allenjack/HGN}.

\subsection{Datasets}
The proposed model is evaluated on five real-world datasets from various domains with different sparsities: \textit{MovieLens-20M} \cite{DBLP:journals/tiis/HarperK16}, \textit{Amazon-Books} and \textit{Amazon-CDs} \cite{DBLP:conf/www/HeM16}, \textit{Goodreads-Children} and \textit{Goodreads-Comics} \cite{DBLP:conf/recsys/WanM18}. \textit{MovieLens-20M} is a user-movie dataset collected from the \textit{MovieLens} website, where this dataset has 20 million user-movie interactions. The \textit{Amazon-Books} and \textit{Amazon-CDs} datasets are adopted from the Amazon review dataset\footnote{http://jmcauley.ucsd.edu/data/amazon/} with different categories, i.e., CDs and Books, which cover a large amount of user-item interaction data, e.g., user ratings and reviews. \textit{Goodreads-Children} and \textit{Goodreads-Comics} datasets\footnote{https://sites.google.com/eng.ucsd.edu/ucsdbookgraph/home} are collected in late 2017 from \textit{goodreads} website with different genres, and we use the genres of Children and Comics. In order to be consistent with the implicit feedback setting, we keep those with ratings no less than four (out of five) as positive feedback and treat all other ratings as missing entries on all datasets. To filter noisy data, we only keep the users with at least ten ratings and the items at least with five ratings. The data statistics after preprocessing are shown in Table \ref{tab:data_statistics}. 

For each user, we hold the 70\% of interactions in the user sequence as the training set and use the next 10\% of interactions as the validation set for hyper-parameter tuning. The remaining 20\% constitutes the test set for reporting model performance. Note that during the testing procedure, the input sequences include the interactions in both the training set and validation set. The execution of all the models is carried out five times independently, and we report the average results.

\begin{table}[ht]
\centering
\caption{\label{tab:data_statistics}The statistics of datasets.}
\begin{tabular}{ |c|c|c|c|c|c| }
 \hline
 Dataset & \#Users & \#Items & \#Interactions & Density \\
 \hline
 \textit{ML20M} & 129,797 & 13,649 & 9,921,393 & 0.560\% \\ 
 \hline
 \textit{Books} & 52,406 & 41,264 & 1,856,747 & 0.086\% \\ 
 \hline
 \textit{CDs} & 17,052 & 35,118 & 472,265 & 0.079\% \\ 
 \hline
 \textit{Children} & 48,296 & 32,871 & 2,784,423 & 0.175\% \\ 
 \hline
 \textit{Comics} & 34,445 & 33,121 & 2,411,314 & 0.211\% \\ 
 \hline
\end{tabular}
\vspace{-0.3cm}
\end{table}

\subsection{Evaluation Metrics}
We evaluate our model versus other methods in terms of \textit{Recall@k} and \textit{NDCG@k}. For each user, Recall@k (R@k) indicates what percentage of her rated items can emerge in the top  recommended items. NDCG@k (N@k) is the normalized discounted cumulative gain at , which takes the position of correctly recommended items into account. 

\begin{comment}


where  is number of users,  is a set of top- unrated items recommended to user  excluding those items in the training, and  is a set of items that are rated by user  in the testing.  is the precision of a cut-off rank list from  to , and  is an indicator function that equals to  if the item is rated in the testing, otherwise equals to .

\end{comment}


\subsection{Methods Studied}
To demonstrate the effectiveness of our model, we compare to the following recommendation methods.

\textit{Classical methods for implicit feedback}:
\begin{itemize}
\item \textbf{BPRMF}, the Bayesian Personalized Ranking based matrix factorization \cite{DBLP:conf/uai/RendleFGS09}, which is a classic method for learning pairwise personalized rankings from user implicit feedback. Specifically, we use BPR-MF for model learning.
\end{itemize}

\textit{State-of-the-art session-based recommendation methods}:
\begin{itemize}
\item \textbf{GRU4Rec}, gated recurrent unit for recommendation \cite{DBLP:journals/corr/HidasiKBT15}, which uses recurrent neural networks to model user-item interaction sequences for session-based recommendation. Each user sequence is treated as a session.
\item \textbf{GRU4Rec+}, an improved version of GRU4Rec \cite{DBLP:conf/cikm/HidasiK18}, which adopts a different loss function and sampling strategy, and shows significant performance gains on Top-N recommendation.
\item \textbf{NextItNet}, the next item recommendation net \cite{DBLP:conf/wsdm/YuanKAJ019}, applies dilated convolutional neural networks to increase the receptive fields without relying on the pooling operation.
\end{itemize}

\textit{State-of-the-art sequential recommendation methods}:
\begin{itemize}
\item \textbf{Caser}, convolutional sequence embedding model \cite{DBLP:conf/wsdm/TangW18}, which captures high-order Markov chains by applying convolution operations on the embeddings of the  recent items.
\item \textbf{SASRec}, self-attention based sequential model \cite{DBLP:conf/icdm/KangM18}, which uses an attention mechanism to identify relevant items for predicting the next item.
\end{itemize}

\textit{The proposed method}:
\begin{itemize}
\item \textbf{HGN}, the proposed model, applies a hierarchical gating network to learn the group-level representations of a sequence of items and adopts the item-item product to explicitly capture the item-item relations.
\end{itemize}

Given our extensive comparisons against the state-of-the-art methods, we omit comparisons with methods such as FMC and FPMC \cite{DBLP:conf/www/RendleFS10}, Fossil \cite{DBLP:conf/icdm/HeM16}, since they have been outperformed by the recently proposed Caser and SASRec.

\subsection{Experiment Settings}
In the experiments, the latent dimension of all the models is set to 50. For those session-based methods, we treat each user sequence as one session. For GRU4Rec and GRU4Rec+, we find that when the learning rate is , and batch size is  can achieve good performance. These two methods adopt Top1 loss and BPR-max loss, respectively. For NextItNet, we following the original settings in the paper to set the learning rate to , the kernel size to , the dilated levels to  and , the batch size to . For Caser, we follow the settings in the author-provided code to set , , the number of horizontal filters to , the number of vertical filters to , where Caser can achieve good results. For SASRec, we set the number of self-attention blocks to , the batch size to , and the maximum sequence length to . The network architectures of above methods are also set the same with the original papers. The hyper-parameters are tuned using the validation set.

For HGN, we follow the same setting in Caser to set  and , where the length effects are shown in the section \ref{subsec:parameter_sensitivity}. Hyper-parameters are tuned by grid search on the validation set. The network embedding size  is also set to . The learning learning rate and  are set to  and , respectively. The batch size is set to . Our experiments are conducted with PyTorch\footnote{https://pytorch.org/} running on GPU machines (Nvidia GeForce GTX 1080 Ti).

\subsection{Performance Comparison}
The performance comparison results are shown in Figure \ref{fig:ml20m}, \ref{fig:books}, \ref{fig:cds}, \ref{fig:children}, \ref{fig:comics}, and Table \ref{tab:performance_comparison}. 

\begin{table*}[ht]
\caption{\label{tab:performance_comparison}The performance comparison of all methods in terms of \textit{Recall@10} and \textit{NDCG@10}. The best performing method is boldfaced. The underlined number is the second best performing method. , ,  indicate the statistical significance for , , and , respectively, compared to the best baseline method based on the paired t-test. \textit{Improv.} denotes the improvement of our model over the best baseline method.}
\begin{tabular}{|c|c| c c c| c c| l| c|}
\hline
& \textbf{BPRMF} & \textbf{GRU4Rec} & \textbf{GRU4Rec+} & \textbf{NextItRec} & \textbf{Caser} & \textbf{SASRec} & \textbf{HGN} & \multicolumn{1}{l|}{\textbf{Improv.}} \\\hline
\multicolumn{9}{|c|}{Recall@10} \\
\hline
\textit{MovieLens-20M} & 0.0774 & 0.0804 & 0.0904 & 0.0833 & \underline{0.1169} & 0.1069 & \textbf{0.1255*} & 7.36\% \\
\textit{Amazon-Books} & 0.0260 & 0.0266 & 0.0301 & 0.0303 & 0.0297 & \underline{0.0358} & \textbf{0.0429***} & 19.83\% \\
\textit{Amazon-CDs} & 0.0269 & 0.0302 & \underline{0.0356} & 0.0310 & 0.0297 & 0.0341 & \textbf{0.0426**} & 19.66\% \\
\textit{GoodReads-Children} & 0.0814 & 0.0857 & 0.0978 & 0.0879 & 0.1060 & \underline{0.1165} & \textbf{0.1263*} & 8.41\% \\
\textit{GooReads-Comics} & 0.0788  & 0.0958 & 0.1288 & 0.1078 & 0.1473 & \underline{0.1494} & \textbf{0.1743***} & 16.67\% \\
\hline
\multicolumn{9}{|c|}{NDCG@10} \\ 
\hline
\textit{MovieLens-20M} & 0.0785 & 0.0815 & 0.0946 & 0.0828 & \underline{0.1116} & 0.1014 & \textbf{0.1195*} & 7.07\% \\
\textit{Amazon-Books} & 0.0151  & 0.0157 & 0.0173 & 0.0174 & 0.0216 & \underline{0.0240} & \textbf{0.0298***} & 24.17\% \\ 
\textit{Amazon-CDs} & 0.0145 & 0.0154 & 0.0171 & 0.0155 & 0.0163 & \underline{0.0193} & \textbf{0.0233**} & 20.73\% \\
\textit{GoodReads-Children} & 0.0664 & 0.0715 & 0.0821 & 0.0720 & 0.0943 & \underline{0.1007} & \textbf{0.1130*} & 12.21\% \\
\textit{GoodReads-Comics} & 0.0713 & 0.0912 & 0.1328 & 0.1171 & \underline{0.1629} & 0.1592 & \textbf{0.1927***} & 18.29\% \\
\hline
\end{tabular}
\vspace{-0.3cm}
\end{table*}

\begin{figure}[t!]
    \centering
    \begin{subfigure}[t]{0.25\textwidth}
        \centering
        \includegraphics[width=\linewidth]{pic/ML20M_recall.pdf}
        \caption{\label{fig:ml20m_recall} Recall@k on MovieLens-20M}
    \end{subfigure}\begin{subfigure}[t]{0.25\textwidth}
        \centering
        \includegraphics[width=\linewidth]{pic/ML20M_ndcg.pdf}
        \caption{\label{fig:ml20m_ndcg} NDCG@k on MovieLens-20M}
    \end{subfigure}
    \caption{\label{fig:ml20m}The performance comparison on MovieLens-20M.}
\vspace{-0.3cm}
\end{figure}

\begin{figure}[t!]
    \centering
    \begin{subfigure}[t]{0.25\textwidth}
        \centering
        \includegraphics[width=\linewidth]{pic/Books_recall.pdf}
        \caption{\label{fig:Books_recall} Recall@k on Amazon-Books}
    \end{subfigure}\begin{subfigure}[t]{0.25\textwidth}
        \centering
        \includegraphics[width=\linewidth]{pic/Books_ndcg.pdf}
        \caption{\label{fig:Books_ndcg} NDCG@k on Amazon-Books}
    \end{subfigure}
    \caption{\label{fig:books}The performance comparison on Amazon-Books.}
\vspace{-0.3cm}
\end{figure}

\begin{figure}[t!]
    \centering
    \begin{subfigure}[t]{0.25\textwidth}
        \centering
        \includegraphics[width=\linewidth]{pic/CDs_recall.pdf}
        \caption{\label{fig:CDs_recall} Recall@k on Amazon-CDs}
    \end{subfigure}\begin{subfigure}[t]{0.25\textwidth}
        \centering
        \includegraphics[width=\linewidth]{pic/CDs_ndcg.pdf}
        \caption{\label{fig:CDs_ndcg} NDCG@k on Amazon-CDs}
    \end{subfigure}
    \caption{\label{fig:cds}The performance comparison on Amazon-CDs.}
\vspace{-0.3cm}
\end{figure}

\begin{figure}[t!]
    \centering
    \begin{subfigure}[t]{0.25\textwidth}
        \centering
        \includegraphics[width=\linewidth]{pic/Children_recall.pdf}
        \caption{\label{fig:Children_recall} Recall@k on Children}
    \end{subfigure}\begin{subfigure}[t]{0.25\textwidth}
        \centering
        \includegraphics[width=\linewidth]{pic/Children_ndcg.pdf}
        \caption{\label{fig:Children_ndcg} NDCG@k on Children}
    \end{subfigure}
    \caption{\label{fig:children}The performance comparison on Children.}
\vspace{-0.3cm}
\end{figure}

\begin{figure}[t!]
    \centering
    \begin{subfigure}[t]{0.25\textwidth}
        \centering
        \includegraphics[width=\linewidth]{pic/Comics_recall.pdf}
        \caption{\label{fig:Comics_recall} Recall@k on Comics}
    \end{subfigure}\begin{subfigure}[t]{0.25\textwidth}
        \centering
        \includegraphics[width=\linewidth]{pic/Comics_ndcg.pdf}
        \caption{\label{fig:Comics_ndcg} NDCG@k on Comics}
    \end{subfigure}
    \caption{\label{fig:comics}The performance comparison on Comics.}
\vspace{-0.3cm}
\end{figure}


\textbf{Observations about our model}. First, the proposed model---HGN, achieves the best performance on five datasets with all evaluation metrics, which illustrates the superiority of our model. Second, HGN achieves better performance than SASRec. The reasons are three-fold: (1) SASRec only applies the instance-level selection but neglecting the feature-level one, which plays an important role in learning short-term user interests (section \ref{sec:ablation}); (2) SASRec adopts a hyper-parameter---the maximum sequence length to reduce the computation burden, where only using part of the user data may lead to the insufficient understanding of long-term user interests; (3) SASRec does not explicitly model the item-item relations between two closely relevant items, which is captured by our item-item product module. Third, HGN outperforms Caser, one major reason is that Caser only applies CNNs to learn the group-level representation of several successive items without considering the item importance for different users. Fourth, HGN obtains better results than GRU4Rec, GRU4Rec+, and NextItNet. Two possible reasons are: (1) these models are session-based methods without explicitly modeling the long-term user interests; (2) these methods equally treat all the items in a short context, which may fail to capture the short-term user intentions. Fifth, HGN outperforms BPRMF. Since BPRMF only captures the long-term interests of users, which does not incorporate the sequential patterns of user-item interactions. On the top of BPRMF, HGN adopts a hierarchical gating network to capture the sequential dynamics in the user actions and an item-item product module to explicitly capture the item-item relations, which leads to better performance.

\textbf{Other observations}. First, all the results reported on MovieLens-20M, GoodReads-Children and GoodReads-Comics are better than the results on other datasets, the major reason is that other datasets are more sparse and the data sparsity declines the recommendation performance. Second, SASRec outperforms Caser on most of the datasets. The main reason is that SASRec adaptively attends items that would reflect the short-term user interests. Third, SASRec and Caser achieve better performance than GRU4Rec, GRU4Rec+, and NextItNet in most cases. One possible reason is that SASRec and Caser both explicitly plug the user embeddings in their models, which allows the long-term user interests modeling. Fourth, GRU4Rec+ performs better than other methods on one dataset. The reason is that GRU4Rec+ not only captures the sequential patterns in the user-item sequence but also has a promising object function---\textit{BPR-max}. Fifth, all the methods perform better than BPR. This illustrates that only effectively modeling the long-term user interests is not sufficient to capture the user sequential behaviors.

\begin{table}[ht]
\centering
\caption{\label{tab:ablation_analysis}The ablation analysis on GoodReads-Comics and Amazon-Books datasets. \textit{F} denotes the feature gating module, \textit{I} denotes the instance gating module, \textit{avg} denotes the average pooling, and \textit{max} denotes the max pooling.}
\begin{tabular}{ |l|c|c|c|c| }
\hline
\multirow{2}{*}{Architecture} & \multicolumn{2}{c|}{\textit{Comics}} & \multicolumn{2}{c|}{\textit{Books}} \bigstrut \\\cline{2-5} 
& R@10 & N@10 & R@10 & N@10 \bigstrut \\ 
\hline
(1) BPR & 0.0911 & 0.0802 & 0.0310 & 0.0177 \\
(2) BPR+F+avg & 0.1555 & 0.1624 & 0.0361 & 0.0266 \\
(3) BPR+F+max & 0.1456 & 0.1550 & 0.0355 & 0.0240 \\
(4) BPR+I+avg & 0.1538 & 0.1591 & 0.0351 & 0.0254 \\
(5) BPR+I+max & 0.1489 & 0.1585 & 0.0329 & 0.0241 \\
(6) BPR+GRU & 0.1456 & 0.1581 & 0.0289 & 0.0216 \\
(7) BPR+CNN & 0.1305 & 0.1387 & 0.0278 & 0.0207 \\
(8) BPR+F+I+avg & 0.1635 & 0.1791 & 0.0391 & 0.0250 \\
(9) BPR+F+I+max & 0.1569 & 0.1658 & 0.0355 & 0.0234 \\
(10) HGN & \textbf{0.1743} & \textbf{0.1927} & \textbf{0.0429} & \textbf{0.0298} \\
\hline
\end{tabular}
\vspace{-0.3cm}
\end{table}

\subsection{Ablation Analysis} \label{sec:ablation}

To verify the effectiveness of the proposed feature gating, instance gating, and item-item product modules, we conduct an ablation analysis in Table \ref{tab:ablation_analysis} to demonstrate the importance each module contributes to the HGN model. In (1), we utilize only the BPR matrix factorization without any other components. In (2), we only incorporate the feature gating and apply the average pooling on the embeddings after the feature gating, on the top of (1). In (3), we replace the average pooling in (2) with max pooling. In (4), we only include the instance gating and apply the average pooling on the top of (1). In (5), we replace the average pooling in (4) with max-pooling. In (6), we adopt a recurrent neural network structure---gated recurrent unit (GRU) \cite{DBLP:conf/emnlp/ChoMGBBSB14} to learn the group-level representations of items. In (7), we replace the GRU in (6) with a convolutional neural network (CNN), where the structure and hyper-parameters are set the same in Caser \cite{DBLP:conf/wsdm/TangW18}. In (8), we both apply the feature and instance gating with average pooling. In (9), we replace the average pooling with max pooling. In (10), we present the overall HGN model to show the significance of the item-item product module.

From the results shown in Table \ref{tab:ablation_analysis}, we have some observations. First, from (1) and all others, we can observe that the conventional BPR matrix factorization to capture the long-term user interests cannot effectively model the short-term user interests. Second, from (2), (3), (4) and (5), the feature gating seems to achieve slightly better results than the instance gating. And the average pooling is slightly better than the max pooling, one possible reason is that the average pooling makes the representative item features accumulated, which results in a more effective representation of a group of  successive items. Third, from (6), (7), and (8), we observe that our hierarchical gating network achieves better performance than GRU and CNN but with \textit{fewer} learnable parameters\footnote{We verified the number of parameters of all three models by the \textit{named\_parameters()} function provided by PyTorch.} (if we set the item embedding size to 50 (), then the number of learnable parameters of our hierarchical gating network is 5,350, the number of parameters of the one-recurrent-layer GRU is 15,300, the number of parameters of the CNN in \cite{DBLP:conf/wsdm/TangW18} is 26,154). This result demonstrates that the proposed hierarchical gating network can effectively capture the sequential patterns in the user-item interaction sequence. Lastly, from (1), (8), and (9), we observe that by incorporating the item-item product, the performance further improves. The results demonstrate that explicitly capturing the relations between the items users accessed and those items users may interact in the future can provide a significant supplementary to model the user sequential dynamics.

\subsection{Training Efficiency} \label{sec:training_efficiency}
In this section, we evaluate the training efficiency with other state-of-the-art methods in terms of the training speed (time taken for one epoch of training). Since GRU4Rec+ has been compared with SASRec in \cite{DBLP:conf/icdm/KangM18}, we omit the training time comparison with GRU4Rec+. To make a fair comparison, we set the max sequence length of SASRec as  to cover more than 95\% of the sequence. All the experiments are conducted on a single GPU of Nvidia GeForce GTX 1080 Ti. All the compared methods are executed  epochs and we report the average computation time, which is shown in Table \ref{tab:training_time}. Note that the time reported only includes the training time of models without including the negative sampling time.

\begin{table}[ht]
\centering
\caption{\label{tab:training_time}The training time per epoch comparison on five datasets in terms of seconds.}
\begin{tabular}{ |c|c|c|c|c|c| }
 \hline
 & CDs & Books & ML20M & Children & Comics \\
\hline
HGN & \textbf{0.957s} & \textbf{2.086s} & \textbf{28.304s} & \textbf{3.496s} & \textbf{2.228s} \\
SASRec & 2.242s & 16.154s & 39.937s & 14.913s & 10.468s \\
Caser & 5.063s & 17.577s & 63.702s & 28.593s & 25.657s \\
\hline
\end{tabular}
\vspace{-0.3cm}
\end{table}

From the results in Table \ref{tab:training_time}, we can observe that HGN yields the fastest training speed on all datasets. As we have discussed in section \ref{sec:network training}, our model has less item complexity than SASRec, which is . Thus, our proposed model has better training efficiency both theoretically and practically.

\begin{table}[ht]
\centering
\caption{\label{tab:L_and_T}The effect of the length  and .}
\begin{tabular}{ |l|c|c|c|c| }
\hline
\multirow{2}{*}{Settings} & \multicolumn{2}{c|}{\textit{CDs}} & \multicolumn{2}{c|}{\textit{Comics}} \bigstrut \\\cline{2-5} 
& R@5 & R@10 & R@5 & R@10 \bigstrut \\ 
\hline
=3, =1 & 0.0260 & 0.0415 & 0.1202 & 0.1684 \\
=3, =2 & \textbf{0.0291} & 0.0448 & 0.1275 & 0.1758 \\
=3, =3 & 0.0289 & 0.0450 & \textbf{0.1296} & \textbf{0.1793} \\
=5, =1 & 0.0254 & 0.0417 & 0.1155 & 0.1645 \\
=5, =2 & 0.0261 & 0.0432 & 0.1215 & 0.1711 \\
=5, =3 & 0.0290 & \textbf{0.0456} & 0.1238 & 0.1738 \\
=8, =1 & 0.0220 & 0.0372 & 0.1083 & 0.1566 \\
=8, =2 & 0.0248 & 0.0401 & 0.1142 & 0.1636 \\
=8, =3 & 0.0260 & 0.0413 & 0.1160 & 0.1658 \\
\hline
\end{tabular}
\vspace{-0.3cm}
\end{table}

\subsection{The Sensitivity of Hyper-parameters} \label{subsec:parameter_sensitivity}

\begin{figure}[t!]
    \centering
    \begin{subfigure}[t]{0.25\textwidth}
        \centering
        \includegraphics[width=\linewidth]{pic/Children_d.pdf}
        \caption{\label{fig:CDs_da_var} on Children}
    \end{subfigure}\begin{subfigure}[t]{0.25\textwidth}
        \centering
        \includegraphics[width=\linewidth]{pic/Comics_d.pdf}
        \caption{\label{fig:Foursquare_da_var} on Comics}
    \end{subfigure}
    \caption{\label{fig:d_var}The dimension variations of embeddings.}
\vspace{-0.3cm}
\end{figure}

We present the effect of two hyper-parameters: the dimension of the item embeddings  and the length of successive items  and . The effects of these two parameters are shown in Figure \ref{fig:d_var} and Table \ref{tab:L_and_T}. Due to the space limit, we only present the effects on two datasets, the parameter effects on other datasets have similar trends.

The variation of  is shown in Figure \ref{fig:d_var}. We can observe that a small dimension of item embeddings is not sufficient to express the latent features of items. By increasing the dimension of item embeddings, the model has more capacity to model the complex features of items. With the increase of , the model performance largely improves and becomes steady.

The variation of  and  is shown in Table \ref{tab:L_and_T}. We observe that when  is fixed, a larger value of , i.e. 3, can achieve better performance. This may illustrate that a group of  items may determine several items that user will interact in the near future. We also observe that smaller  has better results than larger ones. One possible reason is that larger  may include too many irrelevant items for predicting future items. 
\section{Conclusion}
In this paper, we propose a hierarchical gating network with an item-item product module for the sequential recommendation. The model adopts a feature gating module and an instance gating module to control what item features can be passed to downstream layers, where informative latent features and items can be selected. Moreover, we apply an item-item product module to capture the relations between closely relevant items. Experimental results on five real-world datasets clearly validate the performance of our model over many state-of-the-art methods and demonstrate the effectiveness of the gating and item-item product modules. 

\bibliographystyle{ACM-Reference-Format}
\bibliography{seq} 

\end{document}