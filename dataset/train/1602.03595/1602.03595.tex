\documentclass[UKenglish]{eptcs}


\usepackage{doc}
\usepackage{makeidx}

\usepackage{hyperref}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{amsbsy}
\usepackage{enumerate}
\usepackage{stackrel}
\usepackage{bm}
\usepackage[toc,page]{appendix}
\usepackage{stmaryrd}
\usepackage{wasysym}
\usepackage{color}
\usepackage{rotating}
\def\introrule{{\cal I}}\def\elimrule{{\cal E}}\def\andintro{\using{\land}\introrule\justifies}\def\impelim{\using{\Rightarrow}\elimrule\justifies}\def\allintro{\using{\forall}\introrule\justifies}\def\allelim{\using{\forall}\elimrule\justifies}\def\falseelim{\using{\bot}\elimrule\justifies}\def\existsintro{\using{\exists}\introrule\justifies}

\def\andelim#1{\using{\land}#1\elimrule\justifies}\def\orintro#1{\using{\lor}#1\introrule\justifies}

\def\impintro#1{\using{\Rightarrow}\introrule_{#1}\justifies}\def\orelim#1{\using{\lor}\elimrule_{#1}\justifies}\def\existselim#1{\using{\exists}\elimrule_{#1}\justifies}



\newdimen\proofrulebreadth \proofrulebreadth=.05em
\newdimen\proofdotseparation \proofdotseparation=1.25ex
\newdimen\proofrulebaseline \proofrulebaseline=2ex
\newcount\proofdotnumber \proofdotnumber=3
\let\then\relax
\def\hfi{\hskip0pt plus.0001fil}
\mathchardef\squigto="3A3B
\newif\ifinsideprooftree\insideprooftreefalse
\newif\ifonleftofproofrule\onleftofproofrulefalse
\newif\ifproofdots\proofdotsfalse
\newif\ifdoubleproof\doubleprooffalse
\let\wereinproofbit\relax
\newdimen\shortenproofleft
\newdimen\shortenproofright
\newdimen\proofbelowshift
\newbox\proofabove
\newbox\proofbelow
\newbox\proofrulename
\def\shiftproofbelow{\let\next\relax\afterassignment\setshiftproofbelow\dimen0 }
\def\shiftproofbelowneg{\def\next{\multiply\dimen0 by-1 }\afterassignment\setshiftproofbelow\dimen0 }
\def\setshiftproofbelow{\next\proofbelowshift=\dimen0 }
\def\setproofrulebreadth{\proofrulebreadth}

\def\prooftree{\ifnum  \lastpenalty=1
\then   \unpenalty
\else   \onleftofproofrulefalse
\fi
\ifonleftofproofrule
\else   \ifinsideprooftree
        \then   \hskip.5em plus1fil
        \fi
\fi
\bgroup \setbox\proofbelow=\hbox{}\setbox\proofrulename=\hbox{}\let\justifies\proofover\let\leadsto\proofoverdots\let\Justifies\proofoverdbl
\let\using\proofusing\let\endprooftree\fi
\proofdotsfalse\doubleprooffalse
\let\thickness\setproofrulebreadth
\let\shiftright\shiftproofbelow \let\shift\shiftproofbelow
\let\shiftleft\shiftproofbelowneg
\let\ifwasinsideprooftree\ifinsideprooftree
\insideprooftreetrue
\setbox\proofabove=\hbox\bgroup\egroup  \shortenproofleft=\dimen0
\shortenproofright=\dimen1
\proofrulebreadth=\dimen2
\proofbelowshift=\dimen3
\proofdotseparation=\dimen4
\proofdotnumber=\count255
}

\def\proofover{\eproofbit \setbox\proofbelow=\hbox\bgroup \let\wereinproofbit\proofover
\displaystyle
}\def\proofoverdots{\eproofbit \proofdotstrue
\setbox\proofbelow=\hbox\bgroup \let\wereinproofbit\proofoverdots

}

\def\endprooftree{\eproofbit \dimen5 =0pt\dimen0=\wd\proofabove \advance\dimen0-\shortenproofleft
\advance\dimen0-\shortenproofright
\dimen1=.5\dimen0 \advance\dimen1-.5\wd\proofbelow
\dimen4=\dimen1
\advance\dimen1\proofbelowshift \advance\dimen4-\proofbelowshift
\ifdim  \dimen1<0pt
\then   \advance\shortenproofleft\dimen1
        \advance\dimen0-\dimen1
        \dimen1=0pt
\ifdim  \shortenproofleft<0pt
        \then   \setbox\proofabove=\hbox{\kern-\shortenproofleft\unhbox\proofabove}\shortenproofleft=0pt
        \fi
\fi
\ifdim  \dimen4<0pt
\then   \advance\shortenproofright\dimen4
        \advance\dimen0-\dimen4
        \dimen4=0pt
\fi
\ifdim  \shortenproofright<\wd\proofrulename
\then   \shortenproofright=\wd\proofrulename
\fi
\dimen2=\shortenproofleft \advance\dimen2 by\dimen1
\dimen3=\shortenproofright\advance\dimen3 by\dimen4
\ifproofdots
\then
        \dimen6=\shortenproofleft \advance\dimen6 .5\dimen0
        \setbox1=\vbox to\proofdotseparation{\vss\hbox{}\vss}\setbox0=\hbox{\advance\dimen6-.5\wd1
                \kern\dimen6
                \unhbox\proofrulename}\else   \dimen6=\fontdimen22\the\textfont2 \dimen7=\dimen6
        \advance\dimen6by.5\proofrulebreadth
        \advance\dimen7by-.5\proofrulebreadth
        \setbox0=\hbox{\kern\shortenproofleft
                \ifdoubleproof
                \then   \hbox to\dimen0{\mkern-2mu=\mkern-2mu}\else   \vrule height\dimen6 depth-\dimen7 width\dimen0
                \fi
                \unhbox\proofrulename}\ht0=\dimen6 \dp0=-\dimen7
\fi
\let\doll\relax
\ifwasinsideprooftree
\then   \let\VBOX\vbox
\else   \ifmmode\else\fi
        \let\VBOX\vcenter
\fi
\VBOX   {\baselineskip\proofrulebaseline \lineskip.2ex
        \expandafter\lineskiplimit\ifproofdots0ex\else-0.6ex\fi
        \hbox   spread\dimen5   {\hfi\unhbox\proofabove\hfi}\hbox{\box0}\hbox   {\kern\dimen2 \box\proofbelow}}\doll \global\dimen2=\dimen2
\global\dimen3=\dimen3
\egroup \ifonleftofproofrule
\then   \shortenproofleft=\dimen2
\fi
\shortenproofright=\dimen3
\onleftofproofrulefalse
\ifinsideprooftree
\then   \hskip.5em plus 1fil \penalty2
\fi
}


%
 





\newtheorem{definition}{Definition}[section]
\newtheorem{lemma}[definition]{Lemma}
\newtheorem{proposition}[definition]{Proposition}
\newtheorem{theorem}[definition]{Theorem}
\newtheorem{corollary}[definition]{Corollary}
\newtheorem{remark}[definition]{Remark}
\newtheorem{example}[definition]{Example}
\newtheorem{claim}[definition]{Claim}
\newtheorem{fact}[definition]{Fact}

\DeclareMathAlphabet{\mathpzc}{OT1}{pzc}{m}{it}

\newcommand{\qde}{\hfill }




\renewcommand{\vec}[1]{\bm{#1}}
\newcommand{\set}[1]{\{#1\}}



\newcommand{\Comment}[1]{ }




\newcommand{\ByDef}{\triangleq}

\newcommand{\rev}[1]{{\not\! #1}}


\newcommand{\ckpt}{_{\tiny\mbox{}}\!}
\newcommand{\whiteckpt}{_{\tiny\mbox{}}\!}
\newcommand{\mop}{\varobslash}

\newcommand{\Rel}{\mathpzc R}
\newcommand{\RelKK}{\mathpzc K}
\newcommand{\RelK}{{\cal K}}
\newcommand{\Fun}{{\cal F}}
\newcommand{\FunH}{{\cal H}}
\newcommand{\FunK}{{\cal K}}
\newcommand{\FunJ}{{\cal J}}
\newcommand{\FunC}{{\cal C}}

\newcommand{\receive}{{\sf receive }}
\newcommand{\rcv}[2]{{\sf rcv}_{1}^{n}#1.#2}

\newcommand{\cons}{\!:\!}




\newcommand{\true}{{\sf true}}
\newcommand{\false}{{\sf false}}
\newcommand{\notOp}{{\sf not}}



\newcommand{\PiS}{}

\newcommand{\Ports}{{\cal P}}
\newcommand{\Channels} {{\cal C}}
\newcommand{\TermVariables} {{\cal TV}}
\newcommand{\ProcVariables} {{\cal PV}}

\newcommand{\inact}{\mbox{}}
\newcommand{\accept}[3]{\mbox{\sf accept}\; #1 (#2).#3}
\newcommand{\Paccept}[2]{\mbox{\sf accept}\; #1 (#2)}
\newcommand{\request}[3]{\mbox{\sf request}\; #1 (#2).#3}
\newcommand{\Prequest}[2]{\mbox{\sf request}\; #1 (#2)}
\newcommand{\send}[3]{#1 ! [#2].#3}
\newcommand{\Psend}[2]{#1 ! [#2]}
\newcommand{\Preceive}[2]{#1 ? (#2)}
\newcommand{\catch}[3]{\mbox{\sf catch\;} #1 (#2).#3}
\newcommand{\Pcatch}[2]{\mbox{\sf catch\;} #1 (#2)}
\newcommand{\throw}[3]{\mbox{\sf throw\;} #1 [#2].#3}
\newcommand{\throwname}{{\sf throw}}
\newcommand{\Pthrow}[2]{\mbox{\sf throw\;} #1 [#2]}
\newcommand{\select}[3]{#1 \triangleleft #2.#3}
\newcommand{\Pselect}[2]{#1 \triangleleft #2}
\newcommand{\branch}[2]{#1 \triangleright \{#2\}}
\newcommand{\Pbranch}[2]{#1 \triangleright #2}
\newcommand{\chA}[2]{#1\!\triangleleft#2}
\newcommand{\Subst}[2]{\{#1/#2\}}
\newcommand{\DefIn}[2]{\mbox{\sf def} \; #1\; \mbox{\sf in} \; #2}
\newcommand{\AndInDef}{~\mbox{\sf and}~}
\newcommand{\IfThenElse}[3]{\mbox{\sf if}\; #1 \; \mbox{\sf then}\; #2 \; \mbox{\sf else} \; #3}
\newcommand{\Label}[1]{\mbox{\sc #1}}

\newcommand{\bn}[1]{\mbox{\sc bn}(#1)}
\newcommand{\fn}[1]{\mbox{\sc fn}(#1)}
\newcommand{\bp}[1]{\mbox{\sc bp}(#1)}
\newcommand{\fp}[1]{\mbox{\sc fp}(#1)}
\newcommand{\bc}[1]{\mbox{\sc bc}(#1)}
\newcommand{\fc}[1]{\mbox{\sc fc}(#1)}
\newcommand{\bv}[1]{\mbox{\sc bv}(#1)}
\newcommand{\fv}[1]{\mbox{\sc fv}(#1)}
\newcommand{\bpv}[1]{\mbox{\sc bpv}(#1)}
\newcommand{\fpv}[1]{\mbox{\sc fpv}(#1)}



\newcommand{\last}[1]{{#1}^{/\!\!/}} 


\newcommand{\E}{\mathcal E}
\newcommand{\SC}{\mathcal S}                                     \newcommand{\B}{\mathcal B}
\newcommand{\scong}{\equiv}
\newcommand{\evaluatesTo}{\downarrow}
\newcommand{\act}{\alpha}
\newcommand{\ored}[1]{\stackrel{#1}{\longrightarrow}}      \newcommand{\Ored}[1]{\stackrel{#1}{\Longrightarrow}} 
\newcommand{\ired}[1]{\stackrel{#1}{\mbox{\tiny }\!\!\!\!\,\longrightarrow}} \newcommand{\Ired}[1]{\stackrel{#1}{\mbox{\tiny }\!\!\!\!\,\Longrightarrow}}
\newcommand{\iredaux}[1]{\stackrel{#1}{\rightarrowtail}}    \newcommand{\rred}[1]{\hspace{6pt}\stackrel{\hspace{-6pt}#1}{\mbox{\tiny }\!\!\!\!\!\!\!\longrightarrow}}
\newcommand{\rlbk}{\sf rbk}
\newcommand{\rb}{\sf rb}
\newcommand{\Rred}[1]{\hspace{6pt}\stackrel{\hspace{-6pt}#1}{\mbox{\tiny }\!\!\!\!\!\!\!\Longrightarrow}}
\newcommand{\ltred}[1]{\stackrel{#1}{\longrightarrow}}
\newcommand{\cred}[1]{\stackrel{#1}{\Longrightarrow}}
\newcommand{\bred}[1]{\hspace{4pt}\stackrel{#1}{\mbox{\tiny }\hspace{0.5pt}\!\!\!\!\!\looparrowright}}
\newcommand{\pbredaux}[1]{\stackrel{#1}{\looparrowright\!\!\!\!\mbox{\tiny }}}
\newcommand{\pbred}[1]{\hspace{4pt}\stackrel{#1}{\mbox{\tiny }\hspace{0.5pt}\!\!\!\!\!\looparrowright\!\!\!\!\mbox{\tiny }}}
\newcommand{\bredaux}[1]{\stackrel{#1}{\looparrowright}}
\newcommand{\ckptfreered}{\longrightarrow_{\!\!\!\!\mbox{\tiny \!-{\sf free}}}}
\newcommand{\ckptred}{\longrightarrow_{\!\!\!\!\mbox{\tiny }}}



\newcommand{\mbred}[1]{\stackrel{#1}{\bredaux{}_{\hspace{-10pt}\,\mbox{\normalsize }}}}
\newcommand{\mpbred}[1]{\stackrel{#1}{\bredaux{}_{\hspace{-10pt}\,\mbox{\normalsize }}}}
\newcommand{\fbred}[1]{\stackrel{#1}{\bm \looparrowright\hspace{-9.7pt}\bm\looparrowright}}
\newcommand{\red}{\longrightarrow}
\newcommand{\starred}{\stackrel{*}{\red}}

\newcommand{\RLink}{\mbox{\sc Link}}
\newcommand{\RCom}{\mbox{\sc Com}}
\newcommand{\RLabel}{\mbox{\sc Label}}
\newcommand{\RIntChoice}{\mbox{\sc Int-Cho}}
\newcommand{\RExtChoice}{\mbox{\sc Ext-Cho}}
\newcommand{\RPass}{\mbox{\sc Pass}}
\newcommand{\RStr}{\mbox{\sc Str}}
\newcommand{\RScop}{\mbox{\sc Scop}}
\newcommand{\RPar}{\mbox{\sc Par}}
\newcommand{\RDef}{\mbox{\sc Def}}
\newcommand{\RIftrue}{\mbox{\sc If-T}}
\newcommand{\RIffalse}{\mbox{\sc If-F}}




\newcommand{\CommRule}{\textsf{comm}}
\newcommand{\OneRbkRule}{\textsf{1-rbk}}
\newcommand{\RbkRule}{\textsf{rbk}}

\newcommand{\Lts}[1]{\stackrel{#1}{\Longrightarrow}}
\newcommand{\ext}[1]{#1_+}

\newcommand{\one}{\! \bullet}
\newcommand{\any}{\ast}
\newcommand{\comply}{\dashv}
\newcommand{\complyR}{~\begin{sideways}\begin{sideways}\end{sideways}\end{sideways}~}\newcommand{\ncomplyR}{\not\!\!\!\complyR}
\newcommand{\complyF}{\comply}\newcommand{\altcomplyR}{\comply^{\mbox{\tiny }}_{\mathsf a}}
\newcommand{\fcomplyR}{\comply^{\mbox{\tiny }}_{\mbox{\scriptsize {\sf fw}}}}
\newcommand{\altfcomplyR}{\comply^{\mbox{\tiny }}_{\mbox{\scriptsize {\sf fw-a}}}}
\newcommand{\complyP}{\dashv\!\!\!\dashv}
\newcommand{\complyA}{\complyP^{\mbox{\tiny {\sf A}}}}
\newcommand{\complyO}{\complyG^{\mbox{\tiny {\sf O}}}}
\newcommand{\complyG}{\comply^{\mbox{\tiny {\tt skp}}}}
\newcommand{\complyGco}{{\comply}^{\mbox{\tiny {\tt skp}}}_{co}}
\newcommand{\complyGcok}[1]{{\comply}^{\mbox{\tiny {\tt skp}}}_{co.#1}}
\newcommand{\complyRco}{{\comply}^{\mbox{\tiny }}_{co}}
\newcommand{\complyRcok}[1]{{\comply}^{\mbox{\tiny }}_{co.#1}}
\newcommand{\complyGcoII}{{\comply}^{\mbox{\tiny {\tt skp}}}_{co2}}


\newcommand{\labred}[1]{\stackrel{#1}{\red}}

\newcommand{\EAcc}{\mbox{\sc E-Acc}}
\newcommand{\EReq}{\mbox{\sc E-Req}}
\newcommand{\ELink}{\mbox{\sc E-Link}}
\newcommand{\EInput}{\mbox{\sc E-Input}}
\newcommand{\EOutput}{\mbox{\sc E-Output}}
\newcommand{\ECat}{\mbox{\sc E-Cat}}
\newcommand{\EThr}{\mbox{\sc E-Thr}}
\newcommand{\EBrn}{\mbox{\sc E-Brn}}
\newcommand{\ESel}{\mbox{\sc E-Sel}}
\newcommand{\ECom}{\mbox{\sc E-Com}}
\newcommand{\ERes}{\mbox{\sc E-Res}}
\newcommand{\EOpen}{\mbox{\sc E-Open}}
\newcommand{\EClose}{\mbox{\sc E-Close}}
\newcommand{\EPar}{\mbox{\sc E-Par}}
\newcommand{\EDef}{\mbox{\sc E-Def}}
\newcommand{\EVar}{\mbox{\sc E-Var}}
\newcommand{\EIfT}{\mbox{\sc E-IfT}}
\newcommand{\EIfF}{\mbox{\sc E-IfF}}
\newcommand{\EStruct}{\mbox{\sc E-Struct}}




\newcommand{\Bag}{\textsf{bag}}
\newcommand{\DBag}{\Dual{\Bag}}
\newcommand{\Belt}{\textsf{belt}}
\newcommand{\DBelt}{\Dual{\Belt}}
\newcommand{\Price}{\textsf{price}}
\newcommand{\DPrice}{\Dual{\Price}}
\newcommand{\Card}{\textsf{card}}
\newcommand{\DCard}{\Dual{\Card}}
\newcommand{\Cash}{\textsf{cash}}
\newcommand{\DCash}{\Dual{\Cash}}




\newcommand{\Types}{{\cal T}}
\newcommand{\STypes}{{\cal ST}}
\newcommand{\PSTypes}{{\cal ST}\!_{\downharpoonright\!\peer}}
\newcommand{\GHTypes}{{\cal GHT}}

\newcommand{\Bool}{\mbox{}}
\newcommand{\Int}{\mbox{}}
\newcommand{\Real}{\mbox{}}
\newcommand{\sessionT}[1]{\,\uparrow\!\![#1]}
\newcommand{\EndT}{{\sf end}}
\newcommand{\InputT}[1]{\,?(#1)}
\newcommand{\InputTbold}[2]{\,\mbox{\boldmath }\mbox{\small  ()}^{\mbox{\boldmath }}\mbox{\boldmath } }
\newcommand{\OutputT}[1]{\,![#1]}
\newcommand{\OutputTbold}[2]{\,\mbox{\boldmath }\mbox{\small  ()}^{\mbox{\boldmath }}\mbox{\boldmath } }
\newcommand{\HiCommT}[1]{\,[#1]}

\newcommand{\abs}[1]{\left\lvert#1\right\rvert}

\newcommand{\csAct}{\mbox{\bf csAct}}
\newcommand{\hoAct}{\mbox{\bf HoAct}}
\newcommand{\InputAct}[1]{? (#1)}
\newcommand{\OutputAct}[1]{! [#1]}
\newcommand{\skipAct}{{\tt noMt\hspace{-1pt}ch}}
\newcommand{\skipA}[1]{\skipAct(\hspace{-1pt}#1\hspace{-1pt})}
\newcommand{\orchAct}[2]{\langle\mbox{\small },\mbox{\small }\rangle}
\newcommand{\nullorch}{{\shortmid\!\boldmath\asymp}}
\newcommand{\orchActH}[3]{\langle\mbox{\small },#2,\mbox{\small }\rangle}


\newcommand{\BranchT}[1]{\&\langle #1 \rangle}
\newcommand{\SelT}[1]{\oplus\langle #1 \rangle}

\newcommand{\intChoice}[1]{{\boldmath \oplus}(#1)}
\newcommand{\extChoice}[1]{ {\boldmath +} (#1)}

\newcommand{\plus}{ +\!}

\newcommand{\HasType}{\;\blacktriangleright\;}
\newcommand{\HasTypeB}{\;\triangleright\;}

\newcommand{\Dual}[1]{\overline{#1}}
\newcommand{\aDual}[1]{\tilde{#1}}

\newcommand{\SDual}[1]{#1^\bot}  \newcommand{\cDual}[1]{#1^{\bot_c}}  \newcommand{\sDual}[1]{#1^{\bot_s}}  

\newcommand{\subtype}{\leq:}  

\newcommand{\subcontr}{\pfeq}

\newcommand{\Prefix}{\eqslantless}
\newcommand{\PrefixS}{\curlyeqprec}
\newcommand{\PrefixInv}{\eqslantgtr}
\newcommand{\PrefixB}{\eqslantless}
\newcommand{\PrefixBinv}{\eqslantgtr}

\newcommand{\Sem}[1]{[\hspace{-0.6mm}[ #1 ]\hspace{-0.6mm}]}

\newcommand{\unfold}[1]{\mbox{{\sf unfold\/}}(#1)}

\newcommand{\subterms}[1]{\mbox{\sf Sub}(#1)} 
\newcommand{\mo}[1]{\mbox{\sf op}(#1)}

\newcommand{\der}{\;\vartriangleright\;}
\newcommand{\nder}{\;\not\vartriangleright\;}
\newcommand{\Deriv}{{\cal D}}
\newcommand{\Jleq}{\triangleleft}



\newcommand{\TName}{\mbox{\sc T-Name}}
\newcommand{\TNil}{\mbox{\sc T-Nil}}
\newcommand{\TPar}{\mbox{\sc T-Par}}
\newcommand{\TRep}{\mbox{\sc T-Rep}}
\newcommand{\TNew}{\mbox{\sc T-New}}
\newcommand{\TNewS}{\mbox{\sc T-NewS}}
\newcommand{\TReq}{\mbox{\sc T-Req}}
\newcommand{\TAcc}{\mbox{\sc T-Acc}}
\newcommand{\TSend}{\mbox{\sc T-Send}}
\newcommand{\TRcv}{\mbox{\sc T-Rcv}}
\newcommand{\TThr}{\mbox{\sc T-Thr}}
\newcommand{\TCat}{\mbox{\sc T-Cat}}
\newcommand{\TSel}{\mbox{\sc T-Sel}}
\newcommand{\TBr}{\mbox{\sc T-Br}}
\newcommand{\TSub}{\mbox{\sc T-Sub}}
\newcommand{\TSubS}{\mbox{\sc T-SubS}}
\newcommand{\TSubC}{\mbox{\sc T-SubC}}
\newcommand{\TAxC}{\mbox{\sc T-Ax-C}}
\newcommand{\TAxS}{\mbox{\sc T-Ax-S}}
\newcommand{\TAxP}{\mbox{\sc T-Ax-P}}

\newcommand{\TSubBranch}{\mbox{\sc T-Sub-}}
\newcommand{\TSubSel}{\mbox{\sc T-Sub-}}
\newcommand{\TSubId}{\mbox{\sc T-Sub-Id}}
\newcommand{\TSubTrans}{\mbox{\sc T-Sub-Trans}}
\newcommand{\TSubHyp}{\mbox{\sc T-Sub-Hyp}}
\newcommand{\TSubUnfoldL}{\mbox{\sc T-Sub-Unf-L}}
\newcommand{\TSubUnfoldR}{\mbox{\sc T-Sub-Unf-R}}
\newcommand{\TSubUnfold}{\mbox{\sc T-Sub-Unf}}
\newcommand{\TSubFold}{\mbox{\sc T-Sub-Fld}}





\newcommand{\ScomplUnfoldL}{\mbox{\scriptsize \sc Unf-L}}
\newcommand{\ScomplUnfoldR}{\mbox{\scriptsize \sc Unf-R}}
\newcommand{\ScomplHyp}{\mbox{\scriptsize {\sc Hyp}}}
\newcommand{\ScomplRbk}{\mbox{\scriptsize \sc Rbk}}
\newcommand{\ScomplAx}{\mbox{\scriptsize \sc Ax}}
\newcommand{\ScomplSumOplus}{\mbox{\scriptsize \sc .}}
\newcommand{\ScomplOplusOplus}{\mbox{\scriptsize \sc .}}
\newcommand{\ScomplOplusSum}{\mbox{\scriptsize \sc .}}




\newcommand{\CkptcomplRbk}{\mbox{\scriptsize \sc Rbk}}
\newcommand{\CkptcomplUnfoldL}{\mbox{\scriptsize \sc Unf-L}}
\newcommand{\CkptcomplUnfoldR}{\scriptsize \mbox{\sc Unf-R}}
\newcommand{\CkptcomplHyp}{\scriptsize \mbox{\sc Hyp}}
\newcommand{\CkptcomplAx}{\mbox{\scriptsize\sc Ax}}
\newcommand{\CkptcomplSumOplus}{\mbox{\scriptsize \sc .}}
\newcommand{\CkptcomplOplusSum}{\mbox{\scriptsize \sc .}}




\newcommand{\TSubSigma}{\mbox{\sc T-Sub-}}
\newcommand{\TSubSkip}{\mbox{\sc T-Sub-}}

\newcommand{\TSubIN}{\mbox{\sc T-Sub-In}}
\newcommand{\TSubOUT}{\mbox{\sc T-Sub-Out}}

\newcommand{\TSubINskip}{\mbox{\sc T-Sub-In-Skip}}
\newcommand{\TSubOUTskip}{\mbox{\sc T-Sub-Out-Skip}}

\newcommand{\TPrefS}{\mbox{\sc T-PrefS}}
\newcommand{\TPrefC}{\mbox{\sc T-PrefC}}



\newcommand{\basis}{\ensuremath{\Gamma}}
\newcommand{\basistype}{\ensuremath{\Theta}}
\newcommand{\typeenv}{\ensuremath{\Delta}}


\newcommand{\compatib}[2]{#1 \asymp #2}
\newcommand{\Wcompatib}[2]{#1 \!\smile\! #2}
\newcommand{\comp}{\circ}
\newcommand{\Wcomp}{\bullet}
\newcommand{\tinbasis}[2]{\ensuremath{#1: #2 \in \Gamma}}
\newcommand{\basisext}[2]{\ensuremath{\Gamma, \ #1: #2}}
\newcommand{\exbasisext}[3]{\ensuremath{#1, \ #2: #3}}
\newcommand{\basism}[1]{\ensuremath{\Gamma \backslash #1}}







\newcommand{\Nat}{\mathbb{N}} 
\newcommand{\tuple}[1]{\langle #1 \rangle}
\newcommand{\Set}[1]{\{#1\}}
\newcommand{\Dom}[1]{\mbox{\em dom}(#1)}
\newcommand{\union}{\cup}
\newcommand{\intersect}{\cap}
\newcommand{\DefEq}{=_{\mbox{\tiny def}}}
\newcommand{\Iff}{\text { iff }}
\newcommand{\Impl}{\Rightarrow}
\newcommand{\prefix}{\sqsubseteq}
\newcommand{\complies}{\dashv}

\newcommand{\Or}{\;\vee\;}

\renewcommand{\implies}{\text{ implies }}




\newcommand{\lts}[1]{\stackrel{#1}{\longrightarrow}}
\newcommand{\llts}[1]{\stackrel{#1}{-\!\!\!-\!\!\!-\!\!\!\longrightarrow}}
\newcommand{\notlts}[1]{\stackrel{#1}{\;\;\not\!\!\longrightarrow}}
\newcommand{\olts}[1]{\stackrel{#1}{\longmapsto}}
\newcommand{\ltsOrch}[1]{\stackrel{#1}{\longmapsto}}
\newcommand{\ltsRed}[1]{\stackrel{#1}{\rightarrowtail}}
\newcommand{\LtsM}[1]{\stackrel[max]{#1}{\Longrightarrow}}
\newcommand{\rec}{{\sf rec} \, }

\newcommand{\substr}{\sqsubseteq}

\newcommand{\sumacts}[1]{{\mathcal A^+}(#1)}
\newcommand{\oplusacts}[1]{{\mathcal A^\oplus}(#1)}

\newcommand{\peer}{\ast}

\newcommand{\Names}{{\cal N}}
\newcommand{\CoNames}{\overline{\Names}}

\newcommand{\stopA}{{\bf 1}}
\newcommand{\Act}{\mbox{\bf Act}}
\newcommand{\ckptAct}{\mbox{\bf ckptAct}}
\newcommand{\OrchAct}{\mbox{\bf OrchAct}}
\newcommand{\BAct}{\mbox{\bf Basic Acts}}
\newcommand{\Usages}{\mbox{\bf Usg}}
\newcommand{\ActSel}{\triangleleft}
\newcommand{\ActBrn}{\triangleright}
\newcommand{\Trace}[1]{\mbox{\it Tr}\,(#1)}
\newcommand{\Val}{\mbox{\it Val}}
\newcommand{\Restr}{\!\!\upharpoonright\!\!}
\newcommand{\Unfold}{{\sf unfold}}



\newcommand{\bound}[1]{\mbox{\raisebox{-2pt}{}}\!#1\!\mbox{\raisebox{-2pt}{}}}
\newcommand{\boundR}[1]{\lfloor#1\rfloor}
\newcommand{\folded}{\mbox{\sf fld}}
\newcommand{\expandRec}{\mbox{\sf expd}}

\newcommand{\preceqG}{\preceq^{\mbox{\tiny {\tt skp}}}}
\newcommand{\preceqP}{\preceq^{\mbox{\tiny {\sf P}}}}
\newcommand{\preceqO}{\preceq^{\mbox{\tiny {\sf O}}}}
\newcommand{\preceqBdL}{\preceq^{\mbox{\tiny {\sf BdL}}}}
\newcommand{\preceqGH}{\preceq^{\mbox{\tiny {\sf GH}}}}

\newcommand{\leqG}{\leq^{\mbox{\tiny {\sf G}}}}

\newcommand{\invpol}[1]{\breve{#1}}
\newcommand{\Behav}{{\cal B}}
\newcommand{\Rbehav}{{\sf BE}}
\newcommand{\Sbehav}{{\sf RC}}
\newcommand{\SbehavH}{{\sf RCH}}
\newcommand{\Stacks}{{\sf Histories}}
\newcommand{\Abehav}{{\cal AB}}
\newcommand{\PSbehav}{{\cal SB}_{\downharpoonright\!\peer}}
\newcommand{\HObehav}{{\cal H\!S}}
\newcommand{\Red}{\rightarrowtail}
\newcommand{\Client}[1]{{\sf Client}(#1)}
\newcommand{\Server}[1]{{\sf Server}(#1)}
\newcommand{\Peer}[1]{{\sf Peer}(#1)}
\newcommand{\Clienti}[2]{{\sf Client}_{#1}(#2)}
\newcommand{\Serveri}[2]{{\sf Server}_{#1}(#2)}
\newcommand{\Peeri}[2]{{\sf Peer}_{#1}(#2)}
\newcommand{\Diverges}{\hspace{-1mm}\uparrow}
\newcommand{\Converges}{\!\downarrow}
\newcommand{\ConvergeEquiv}{\!\downdownarrows\!}
\newcommand{\behSubtype}{\preceq{\!\!:}\;}


\newcommand{\MustLeq}{\sqsubseteq_{\sf must}}
\newcommand{\Approx}[1]{{\cal A}(#1)}

\newcommand{\alg}{\mbox{\tiny \sf A}}

\newcommand{\orth}{\;\bot\;}
\newcommand{\Orth}{\mbox{\rm Ort}}
\newcommand{\NoAction}{\lambda}
\newcommand{\Diverg}{\!\!\uparrow}
\newcommand{\Convg}{\!\!\downarrow}
\newcommand{\Notorth}{\not\!\!\!\!\orth}
\newcommand{\IntChoice}{\oplus}
\newcommand{\unfoldAction}{\rec}


\newcommand{\weightA}[1]{{\sf w}(#1)}
\newcommand{\Converge}[2]{#1\!\Downarrow#2}
\newcommand{\notConverge}[2]{#1\!\not\Downarrow#2}

\newcommand{\emptystack}{[\;]}


\newcommand{\myshrink}{}
\newcommand{\Grel}{{\cal G}}

\newcommand{\cut}[3]{{#1}_{/^{#3}#2 }}
\newcommand{\norm}[1]{|#1|}

\newcommand{\Rank}[1]{{\sf rank}( #1 )}

\newcommand{\trace}{\mbox{\sf Tr}}
\newcommand{\cstrace}{\mbox{\sf csTr}}
\newcommand{\maxtrace}{\mbox{\sf maxTr}}

\newcommand{\sync}[2]{#1\; \mbox{\sf synch}\, #2}
\newcommand{\nosync}[2]{#1\; \mbox{\sf nosynch}\, #2}
\newcommand{\Cut}[2]{#1\! \downarrow \!#2}

\newcommand{\back}{\prec}
\newcommand{\md}[1]{\textcolor{red}{#1}}
\newcommand{\sbcb}{\Sbehav_{\tiny\back}}
\newcommand{\np}[2]{#1\back#2}
\newcommand{\p}[2]{{\mathbf b}(#1,#2)}
\newcommand{\pp}{~\|~}
\newcommand{\Rels}{~\Rel~}
\newcommand{\sbc}{\Sbehav^{\blacktriangle}}
\newcommand{\s}{\Sbehav}
\newcommand{\leg}[1]{|#1|}



\newcommand{\getsea}{\mbox{\sf sea}}
\newcommand{\getmount}{\mbox{\sf mount}}
\newcommand{\gethouse}{\mbox{\sf house}}
\newcommand{\getbung}{\mbox{\sf bung}}
\newcommand{\getgarden}{\mbox{\sf garden}}

\newcommand{\sendsea}{\overline{\getsea}}
\newcommand{\sendmount}{\overline{\getmount}}
\newcommand{\sendhouse}{\overline{\gethouse}}
\newcommand{\sendbung}{\overline{\getbung}}
\newcommand{\sendgarden}{\overline{\getgarden}}

\newcommand{\ctrs}{contracts}
\newcommand{\ctr}{contracts}
\newcommand{\Ctrs}{Contracts}



\newcommand{\Prove}{\textbf{Prove}}
\newcommand{\IF}{\textbf{if}}
\newcommand{\THEN}{\textbf{then}}
\newcommand{\ELSE}{\textbf{else}}
\newcommand{\AND}{\textbf{and}}
\newcommand{\LET}{\textbf{let}}
\newcommand{\BST}{\textbf{be such that}}
\newcommand{\FAIL}{\textbf{fail}}
\newcommand{\IN}{\textbf{in}}
\newcommand{\FOREACH}{\textbf{foreach}}
\newcommand{\FS}{\textbf{for some}}
\newcommand{\FA}{\textbf{for all}}



 



\begin{document}

\title{Retractable Contracts\thanks{This work was partially supported by Italian MIUR PRIN
Project CINA Prot.\ 2010LHT4KM and COST Action IC1201 BETTY.}
}



\def\titlerunning{Retractable Contracts}

\author{
Franco Barbanera\institute{Dipartimento di Matematica e Informatica,
  University of Catania,
  \email{barba@dmi.unict.it}} \and
Mariangiola Dezani-Ciancaglini\institute{Dipartimento di Informatica,
University of Torino,
\email{dezani@di.unito.it}} \thanks{This author was partially supported by the Torino University/Compagnia San Paolo Project SALT.}
\and
Ivan Lanese\institute{Dipartimento di Informatica - Scienza e Ingegneria,
   University of Bologna/INRIA,
 \email{ivan.lanese@gmail.com}} \thanks{This author was partially supported by the French ANR project REVER n.\ ANR 11 INSE 007 and COST Action IC1405.}
\and
Ugo de'Liguoro\institute{Dipartimento di Informatica,
University of Torino,
\email{deliguoro@di.unito.it}}  \thanks{This author was partially supported by the Torino University/Compagnia San Paolo Project SALT.}
}



\def\authorrunning{Barbanera, Dezani, Lanese and de'Liguoro}

\providecommand{\publicationstatus}{To appear in EPTCS.}

\clearpage




\maketitle


\begin{abstract}
In calculi for modelling communication protocols, internal and external choices play dual roles. Two external choices can be viewed naturally as dual too, as they represent an agreement between the communicating  parties. If the interaction fails, the past agreements are good candidates as points where to roll back, in order to take a different agreement. We propose a variant of contracts with synchronous rollbacks to agreement points in case of deadlock. The new calculus is equipped with a compliance relation which is shown to be decidable. 
\end{abstract}


\thispagestyle{empty}

\section{Introduction}
\label{sect:introduction}

In human as well as  automatic negotiations, an interesting feature is the ability of rolling back to some previous point in case of failure, undoing previous choices and  possibly trying a different path. {\em Rollbacks} are familiar to the users of web browsers, and so are also the troubles that these might cause during ``undisciplined'' interactions. Clicking the ``back'' button, or going to some previous point in the chronology when we are in the middle of a transaction, say the booking of a flight, can be as smart as dangerous. In any case, it is surely a behaviour that service programmers want to discipline. Also the converse has to be treated with care: a server discovering that an auxiliary service becomes available after having started a conversation could take advantage of it using some kind of rollback. However, such a server would be quite unfair if the rollback were completely hidden from the client. 

Let us consider an example.
A  is looking for a bag () or a belt (; she will decide how to pay, either by credit card () or by cash (), after knowing the  from a . The  behaviour can be described by the process:

where dot is sequential composition and  is internal choice. 
The  does not accept credit card payments for items of low price, like belts, but only for more expensive ones, like bags:

where  is external choice.
According to contract theory~\cite{CGP10},  is not compliant with , since she can choose to pay the belt by card. Also, there is no obvious way to represent the buyer's will to be free in her decision about the payment and be compliant with a seller without asking the seller in advance. Nonetheless, when interacting with , the buyer's decision is actually free at least in the case of purchase of a bag. For exploiting such a possibility the client (but also the server) should be able to tolerate a partial failure of her protocol, and to try a different path. 

To this aim we add to (some) choices a possibility of rollback, in
case the taken path fails to reach a success configuration. In
this setting, choices among outputs are no more purely internal, since
the environment may oblige to undo a wrong choice and choose a
different alternative. For this reason, we denote choices between outputs which allow rollback as external, hence we use  below instead of :

We thus explore a model of contract interaction in which synchronous
rollback is triggered when client and server fail to reach an agreement.


In defining our model we build over some previous work reported in
\cite{BarbaneraDdL14}, where we have considered contracts with
rollbacks. However, we depart from that model on three main
aspects. First, in the present model rollback is used in a
disciplined way to tolerate failures in the interaction, thus
improving compatibility, while in \cite{BarbaneraDdL14} it is an
internal decision of either client or server, which makes
compatibility more difficult. Second, we embed checkpoints in the
structure of contracts, avoiding explicit checkpoints. Third, we
consider a stack of ``pasts'', called histories, instead of just one
past for each participant, as in~\cite{BarbaneraDdL14}, thus allowing
to undo many past choices looking for a successful alternative.


\section{Contracts for retractable interactions}
\label{sect:contracts}
Our \ctrs\ can be obtained from the session behaviours of~\cite{BdL10} or from the session contracts of~\cite{BH13} just adding external retractable choices between outputs.

\begin{definition}[Retractable \Ctrs]
\label{Adef:ckpt-behav}
Let  {\em (set of names)} be some countable set of symbols and  {\em (set of conames)}, with
. 
The set  of {\bf retractable \ctrs} is defined as the set of the {\bf closed} expressions generated by the following 
grammar, 
1mm]
       &     & \mid ~\sum_{i\in I} a_i.\sigma_i  & \mbox{(retractable) input} \1mm]
       &     & \mid ~\bigoplus_{i\in I} \Dual{a}_i.\sigma_i & \mbox{unretractable output}\1mm]
       &     & \mid ~\rec x. \sigma &  \mbox{recursion}
\end{array}
\vec{\gamma} ::= \emptystack \mid  \vec{\gamma} \cons  \sigma\SbehavH = \{ \np{\vec{\gamma}}\sigma \mid \vec{\gamma}\in \Stacks, \sigma\in \Sbehav\cup\{\circ\}\, \}.\begin{array}{rl@{\hspace{16mm}}ll}
(+) & \np{\vec{\gamma}}{\alpha.\sigma + \sigma'}
			\ored{\alpha} 
	\np{\vec{\gamma} \cons \sigma'}\sigma  & 
(\oplus) &  \np{\vec{\gamma}}{{ \Dual{a}.\sigma \oplus \sigma'}}
			\ored{\tau} 
		\np{\vec{\gamma}}\Dual{a}.\sigma 
\\ [2mm]
(\alpha)
& \np{\vec{\gamma}}\alpha.\sigma \ored{\alpha} \np{\vec{\gamma}\cons\circ}{\sigma}
&
(\rb)  &
	\np{\vec{\gamma}\cons\sigma'}{\sigma}  \lts{\rb}  \np{\vec{\gamma}}\sigma'
\end{array}\begin{array}{c}
\prooftree
\np{\vec{\delta}}\rho \ored{\alpha} \np{\vec{\delta'}}{\rho'} \qquad \np{\vec{\gamma}}\sigma \ored{\Dual{\alpha}} \np{\vec{\gamma'}}{\sigma'} 
\justifies
\np{\vec{\delta}}\rho\pp \np{\vec{\gamma}}\sigma \ored{} \np{\vec{\delta'}}{\rho'}\pp \np{\vec{\gamma'}}{\sigma'}
\using (\text{\em \CommRule})
\endprooftree \8mm] \prooftree
\np{\vec{\gamma}}{\rho} \lts{\rb} \np{\vec{\gamma'}}{\rho'} \qquad \np{\vec{\delta}}{\sigma} \lts{\rb} \np{\vec{\delta'}}{\sigma'} 
	\qquad  \rho\neq\stopA
\justifies
\np{\vec{\gamma}}{\rho}\pp\np{\vec{\delta}}{\sigma} \ored{} \np{\vec{\gamma'}}{\rho'}\pp\np{\vec{\delta'}}{\sigma'}
\using (\text{\em \RbkRule})
\endprooftree 
\end{array}\begin{array}{lrcl}
  &
\np{\emptystack}{\textsf{Buyer}'}
 & \pp & \np{\emptystack}{\textsf{Seller}}\2mm]

 \ored{\CommRule} &
	\np{\DBag.\Price.(\DCard \oplus \DCash)\cons \circ }{(\DCard \oplus \DCash)}
 & \pp & \np{\Bag.\DPrice.(\Card + \Cash)\cons \circ }{\Cash}\2mm]

\ored{\RbkRule} &
	\np{\DBag.\Price.(\DCard \oplus \DCash)}{\circ }
 & \pp & \np{\Bag.\DPrice.(\Card + \Cash)}{\circ }\2mm]

\ored{\CommRule} &
	\np{\circ}{\Price.(\DCard \oplus \DCash) }
 & \pp & \np{\circ}{\DPrice.(\Card + \Cash)}\2mm]

\ored{\tau} &
	\np{\circ\cons\circ}{\DCard }
 & \pp & \np{\circ\cons\circ}{(\Card + \Cash)}\2mm]

\,\,\not\!\!\ored{}
	
\end{array}\begin{array}{llrcl}
\rho\pp\sigma&
 \ored{\tau} &
	\np{\emptystack}{\Dual{a}.c.\rho}
& \pp &\np{\emptystack}{\rec x.(b.x + a.\Dual{e}.x)}\2mm]
&
 \ored{\RbkRule } &
	\np{\emptystack}{\circ}
& \pp & \np{\emptystack }{b.\sigma }\
}
\end{example}

\begin{example}\label{exampleRed2}
{\em
Let us now modify the above example by using retractable outputs in the client, so making the two contracts in parallel always reducible. The following reduction shows that there can be an infinite number of  rollbacks in a sequence, even if it is not possible to have an infinite reduction
containing only rollbacks.
Notice how the stack keeps growing indefinitely.

\noindent
Let  and  
     .
2mm]
&
 \ored{ \RbkRule} &
	\np{\emptystack}{\Dual{b}.\rho}
& \pp & \np{\emptystack }{b.\sigma}\2mm]
&
 \ored{\CommRule} &
	\np{\circ\cons \Dual{b}.\rho}{c.\rho}
& \pp &\np{\circ\cons b.\sigma}{\Dual{e}.\sigma}\2mm]
&
 \ored{\CommRule } &
	\np{\circ\cons\circ}{\rho}
& \pp & \np{ \circ\cons\circ}{\sigma}\
}
\end{example}

\section{Compliance}

The compliance relation for standard \ctrs\  consists in requiring that, whenever no reduction is possible, all client requests and offers have been satisfied, i.e.\ the client is in the success state . For  retractable \ctrs\ we can adopt the same definition. 

\begin{definition}[Compliance Relation ]\label{ccr}\hfill
\begin{enumerate}[i)]
\item \label{c1}
The relation  on \ctrs\ with histories is defined by:\\
\centerline{}
\item\label{c2} The relation  on \ctrs\ is defined by:\\
\centerline{}
\end{enumerate}

\end{definition}






We now provide a formal system characterising 
compliance on retractable \ctrs.\\
The judgments are of the shape , 
where  is a set of expressions of the form
.
We write  when  is empty. The only non standard rule is rule , which assures compliance of two retractable choices when they contain respectively a name and the corresponding coname followed by compliant contracts. This contrasts with the rules  and , where all conames in unretractable choices between outputs must have corresponding names in the choices between inputs, followed by compliant contracts. 

\begin{definition}[Formal System for Compliance]\label{def:formalCompl}

\vspace{2mm}
10mm]
\prooftree 
    \forall i\in I.~ \Gamma,\mbox{\small }_{j\in I\cup J} a_j.{\sigma}_j\complyF \mbox{\small }_{i\in I} \Dual{a}_i.{\rho}_i \der 
    	\rho_i
    	\complyF
    		\sigma_i
  \justifies
    \Gamma\der\mbox{\small }_{j\in I\cup J} a_j.{\sigma}_j\complyF \mbox{\small }_{i\in I} \Dual{a}_i.{\rho}_i    	
\using (+,\oplus)
\endprooftree 
\end{array}
\prooftree
 \prooftree
      \prooftree
\prooftree 
             \justifies
                    \Gamma'' \der \stopA \complyF \stopA
             \using(\CkptcomplAx)
             \endprooftree
\qquad
\prooftree 
             \justifies
                    \Gamma'' \der \stopA \complyF \stopA
             \using(\CkptcomplAx)
             \endprooftree
\justifies
            \Gamma'  \der \DCard \oplus \DCash \complyF \Card + \Cash
       \using(\oplus,+)
       \endprooftree
   \justifies
       \textsf{Buyer}'  \complyF \textsf{Seller} \der \Price.(\DCard \oplus \DCash) \complyF \DPrice.(\Card + \Cash)
    \using(+,+)
   \endprooftree
\justifies
     \der \textsf{Buyer}'  \complyF \textsf{Seller} 
\using(+,+)
\endprooftree

\prooftree
 \prooftree
   \justifies
      \Dual{b}.\rho + \Dual{a}.c.\rho \complyF  b.\sigma + a.\Dual{e}.\sigma \der \rho \complyF \sigma
   \using(\CkptcomplHyp)
   \endprooftree
\justifies
     \der \Dual{b}.\rho + \Dual{a}.c.\rho \complyF  b.\sigma + a.\Dual{e}.\sigma
\using(+,+)
\endprooftree
2mm]
\> \> \> \AND~~~{\bf exists}  {\bf s.t.}  \Prove \\ [2mm]
\>  \THEN  ~~~~~
	 ~~~~\ELSE ~~\FAIL\\ [2mm]
\ELSE \> \IF \> ~~~ ~\AND~ ~\AND~ \
\prooftree
	\Gamma, \rho \complyF \sigma \der \rho_1 \complyF \sigma_1 \quad \cdots \quad
	\Gamma, \rho \complyF \sigma \der \rho_n \complyF \sigma_n
\justifies
	\Gamma \der \rho \complyF \sigma
\endprooftree
 \np{\vec{\delta}}{\rho} \pp \np{\vec{\gamma}}{\sigma} ~ \ored{*} ~ \np{\vec{\delta}_i}{\rho_i} \pp \np{\vec{\gamma}_i}{\sigma_i}\np{\emptystack}{\rho} \pp
\np{\emptystack}{\sigma} \ored{*} \np{\emptystack}{\rho'} \pp
\np{\emptystack}{\sigma'} \not\!\!\ored{}\np{\emptystack}{a.\rho_k + \rho''} \pp
\np{\emptystack}{\Dual{a}.\sigma_k + \sigma''} \ored{*}
\np{\emptystack}{\rho''} \pp \np{\emptystack}{\sigma''} \ored{*}
\np{\emptystack}{\rho'} \pp \np{\emptystack}{\sigma'} \not\ored{}.\np{\emptystack}{a.\rho_k + \rho''} \pp
\np{\emptystack}{\Dual{a}.\sigma_k + \sigma''} \ored{}
\np{\rho''}{\rho_k} \pp \np{\sigma''}{\sigma_k}\ored{*}
\np{\rho''}{\rho'_k} \pp \np{\sigma''}{\sigma'_k} \ored{}
\np{\emptystack}{\rho''} \pp \np{\emptystack}{\sigma''} 
\np{\emptystack}{\rho_k} \pp
\np{\emptystack}{\sigma_k} \ored{*} \np{\emptystack}{\rho'_k} \pp
\np{\emptystack}{\sigma'_k} \not\ored{}.
\nder\rho'' \complyF \sigma'' ~\text{and}~\nder\rho_k \complyF 
\sigma_k ~~ \text{imply} ~~  \nder a.\rho_k + \rho''  \complyF \Dual{a}.\sigma_k + \sigma''
a.\rho_k + \rho''  \complyF \Dual{a}.\sigma_k + \sigma'' \der  \rho''  \complyF \sigma''
~~\mbox{and}~~
a.\rho_k + \rho''  \complyF \Dual{a}.\sigma_k + \sigma'' \der \rho_k  \complyF \sigma_k.\np{\emptystack}\rho\pp \np{\emptystack}\sigma
                    \ored{*}
                     \np{\vec{\delta}}\rho'\pp \np{\vec{\gamma}}\sigma'
                     \not\!\!\ored{} \der\rho\complyF \sigma~~ \Impl ~~ \rho\complyR\sigma.\np{\emptystack}\rho\pp \np{\emptystack}\sigma
                    \ored{*}
                     \np{\vec{\delta'}}\rho'\pp \np{\vec{\gamma'}}\sigma'
                     \not\!\!\ored{} \np {\vec{\delta}}{\rho} \complyR \np {\vec{\gamma}}{\sigma} \implies 
	\np {\rho' \cons \vec{\delta}}{\rho} \complyR \np {\vec{\gamma}}{\sigma} \text{ and }
	\np { \vec{\delta}}{\rho} \complyR \np {\sigma' \cons \vec{\gamma}}{\sigma}
\np {\rho' \cons \vec{\delta}}{\rho} \pp \np {\vec{\gamma}}{\sigma} \ored{*} \np {\vec{\delta}'}{\rho''} \pp \np {\vec{\gamma}'}{\sigma''}
\not\!\!\ored{} \text{ and } \rho''\neq \stopA
\np {\vec{\delta}}{\rho} \pp \np {\vec{\gamma}}{\sigma} 
\ored{*} \np {\vec{\delta}''}{\rho''} \pp \np \emptystack{\sigma''} \not\!\!\ored{}\np {\rho' \cons \vec{\delta}}{\rho} \pp \np {\vec{\gamma}}{\sigma} \ored{*} \np {\rho'}{\rho''} \pp \np {\vec{\gamma}'}{\sigma''}
\ored{} \np\emptystack\rho'\pp\np {\vec{\gamma}''}{\sigma'''}\np {\vec{\delta}}{\rho} \pp \np {\vec{\gamma}}{\sigma} \ored{*} \np {\emptystack}{\rho''} \pp \np {\vec{\gamma}''}{\sigma''} \not\!\!\ored{}\np\emptystack\rho_{k_i} \pp \np\emptystack\sigma_{k_i} \ored{*} \np{\vec{\delta}_i}{\rho'_i} \pp \np{\vec{\gamma}_i}{\sigma'_i} \not\!\!\ored{}\np{\mbox{\small}_{i\in I\setminus\Set{k_1}}\alpha_i.\rho_i}\rho_{k_1} \pp \np{\mbox{\small}_{j\in J\setminus\Set{k_1}}\Dual{\alpha}_j.\sigma_j}\sigma_{k_1} \ored{*}
 \np{\mbox{\small}_{i\in I\setminus\Set{k_1}}\alpha_i.\rho_i}{\rho'_1} \pp \np{\mbox{\small}_{j\in J\setminus\Set{k_1}}\Dual{\alpha}_j.\sigma_j}{\sigma'_1}\begin{array}{llll}
\np\emptystack\rho \pp \np\emptystack\sigma & \ored{} &
\np{\sum_{i\in I\setminus\Set{k_1}}\alpha_i.\rho_i}\rho_{k_1} \pp \np{\sum_{j\in J\setminus\Set{k_1}}\Dual{\alpha}_j.\sigma_j}\sigma_{k_1} & \mbox{by }\\
&\ored{*}&
 \np{\sum_{i\in I\setminus\Set{k_1}}\alpha_i.\rho_i}{\rho'_1} \pp \np{\sum_{j\in J\setminus\Set{k_1}}\Dual{\alpha}_j.\sigma_j}{\sigma'_1} \\
 &\ored{}&
 \np\emptystack{\sum_{i\in I\setminus\Set{k_1}}\alpha_i.\rho_i} \pp \np\emptystack{\sum_{j\in J\setminus\Set{k_1}}\Dual{\alpha}_j.\sigma_j}
 	& \mbox{by }\\
	&~~\vdots&~\qquad\qquad\qquad\qquad\quad\vdots\\
	&\ored{*}&
 \np{\sum_{i\in I'}\alpha_i.\rho_i}{\rho'_n} \pp \np{\sum_{j\in J'}\Dual{\alpha}_j.\sigma_j}{\sigma'_n} \\
 &\ored{}&
 \np\emptystack{\sum_{i\in I'}\alpha_i.\rho_i} \pp \np\emptystack{\sum_{j\in J'}\Dual{\alpha}_j.\sigma_j}
 	& \mbox{by }
\end{array}\begin{array}{llll}
\np\emptystack\rho \pp \np\emptystack\sigma & \ored{} &
\np{\emptystack}{\Dual{a}_k.\rho_k}\pp \np\emptystack{\sigma} & \mbox{by } \\
& \not\!\!\ored{} &
\end{array}\np\emptystack\rho_k \pp \np\emptystack\sigma_k \ored{*} \np\emptystack{\rho'} \pp \np\emptystack{\sigma'} \not\!\!\ored{}  \np{\circ}{\rho_k}\pp \np{\mbox{\small}_{j\in J\setminus\Set{k}}a_j.\sigma_j}{\sigma_k} 
 \ored{*} \np{\circ}{\rho'}\pp \np{\mbox{\small}_{j\in J\setminus\Set{k}}a_j.\sigma_j}{\sigma'}\begin{array}{llll}
\np\emptystack\rho \pp \np\emptystack\sigma 
& \ored{} &
\np{\emptystack}{\Dual{a}_k.\rho_k}\pp \np\emptystack{\sigma} & \mbox{by } \\
&\ored{} & \np{\circ}{\rho_k}\pp \np{\sum_{j\in J\setminus\Set{k}}a_j.\sigma_j}{\sigma_k} & \mbox{by } \\
& \ored{*} & \np{\circ}{\rho'}\pp \np{\sum_{j\in J\setminus\Set{k}}a_j.\sigma_j}{\sigma'} &\\
& \ored{} & \np\emptystack\circ \pp \np\emptystack{\sum_{j\in J\setminus\Set{k}}a_j.\sigma_j} & \mbox{by } \\
& \not\!\!\ored{} &
\end{array}
In both cases we conclude that .

\bigskip

The proof for the case  ,  is similar.
\end{proof}

\begin{theorem}[Completeness] \label{thr:completeness} If
, then 
\end{theorem}

\begin{proof}
By Theorem \ref{the:a} each computation of  
\Prove always terminates.
By Lemma \ref{lem:coinductiveChar} and Fact \ref{fact:provecorr},  implies that 
\Prove \FAIL, and hence . 
\end{proof}

\section{Related work and conclusions}



Since the pioneering work by Danos and Krivine~\cite{DK04}, reversible
concurrent computations have been widely studied. A main point is that
understanding which actions can be reversed is not trivial in a
concurrent setting, since there is no unique ``last''
action. Since~\cite{DK04}, the most common notion of reversibility in
concurrency is \emph{causal-consistent} reversibility: any action can
be undone if no other action depending on it has been executed (and
not yet undone). The name highlights the 
relation with causality, which 
makes the approach applicable even in settings where there is no
unique notion of time, but makes it quite complex.

The first calculus for which a causal-consistent reversible extension has been defined is CCS in~\cite{DK04}, using a stack of
memories for each thread. Later, causal-consistent reversible extensions have been defined by Phillips and
Ulidowski~\cite{PU07} for calculi definable by SOS rules in a general
format (without mobility), using keys to bind synchronised actions
together, and by Lanese et al.~\cite{LMS10} for the higher-order
-calculus, using explicit memory processes to store history
information and tags to track causality. A survey of causal-consistent
reversibility can be found in~\cite{LMT14}.

In~\cite{LMSS11}, Lanese et al.\ enrich the calculus of~\cite{LMS10}
with a fine-grained rollback primitive, showing the subtleties of
defining a rollback operator in a concurrent setting.  The first papers
exploring reversibility in a context of sessions (see, e.g., \cite{LaneveP08} for a comparison between
session types and contracts) are~\cite{TY14,TY15}, by
Tiezzi and Yoshida. These papers define the semantics for reversible
sessions by adapting the approach in~\cite{LMS10}, but do not
consider compliance. Compliance has been first studied
in~\cite{BarbaneraDdL14}. We already discussed the differences between
the present work and~\cite{BarbaneraDdL14} in the Introduction.


A main point of our approach is that it exploits the fact that
contracts describe sequential interactions (in a concurrent setting)
to avoid the complexity of causal-consistent reversibility, allowing
for a simpler semantics (compared, e.g., to the one of~\cite{LMSS11}).

Similarly to our approach, long running transactions with
compensations, and in particular interacting
transactions~\cite{VriesKH10}, allow to undo past agreements. In
interacting transactions, however, a new possibility is tried when an
exception is raised, not when an agreement cannot be found as in our
case. Also, the possible options are sorted: first the normal
execution, then the compensation.  Finally, compliance of interacting
transactions has never been studied. In the field of sessions, the
most related works are probably the ones studying exceptions in binary
sessions~\cite{CarboneHY08} and in multi-party
sessions~\cite{CapecchiGY10}. As for transactions, they aim at dealing
with exceptions more than at avoiding to get stuck since an agreement
cannot be found.

We plan to investigate whether our approach can be extended to
multi-party sessions~\cite{HYC08}, the rationale being that parallelism
is controlled by the global type, hence possibly part of the
complexity due to concurrency can be avoided. The sub-behaviour
relation induced by our notion of compliance is also worth being
thoroughly studied.


\paragraph{Acknowledgments.} 
We are grateful to the anonymous reviewers for their useful remarks.
\label{sect:bib}
\bibliographystyle{eptcs}
\bibliography{session}











\end{document}
