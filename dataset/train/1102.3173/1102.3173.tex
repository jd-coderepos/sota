



\documentclass[10pt,twocolumn,twoside]{IEEEtran} \newlength{\pic}
\setlength{\pic}{3.3in}
\newlength{\bigPic}
\setlength{\bigPic}{6.5in}

\usepackage{graphicx}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{pgf,pgfarrows,pgfnodes}
\usepackage{tikz}
\usepackage{algorithm, algorithmic}
\usepackage{setspace}
\usepackage{lpic}
\usetikzlibrary{arrows,decorations.pathmorphing,backgrounds,positioning,fit,calc} \newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\newtheorem{corollary}{Corollary}
\newtheorem{proposition}{Proposition}
\newtheorem{conjecture}{Conjecture}
\theoremstyle{definition}
\newtheorem{definition}{Definition}
\newtheorem{example}{Example}
\theoremstyle{remark}
\newtheorem{remark}{Remark}
\newtheorem{note}{Note}
\theoremstyle{plain}



\begin{document}

\title{Coding for Cryptographic Security Enhancement using Stopping Sets}

\author{*Willie~K.~Harrison,~\IEEEmembership{Student~Member,~IEEE,}
        Jo\~{a}o~Almeida,~\IEEEmembership{Student~Member,~IEEE,}
        Steven~W.~McLaughlin,~\IEEEmembership{Fellow,~IEEE,}
        and~Jo\~{a}o~Barros,~\IEEEmembership{Member,~IEEE}\ifCLASSOPTIONpeerreview
\thanks{W. K. Harrison: Mailing address: Georgia Institute of Technology, Atlanta, GA 30332 USA. Affiliation: Same as S. W. McLaughlin. Phone: (+1)435-512-0294. Fax: (+1)404-894-7883. E-mail: harrison.willie@gatech.edu.}
\thanks{S. W. McLaughlin: Mailing address: Georgia Institute of Technology, A. French Building, Suite 111 Atlanta, GA 30332-0740 USA. Affiliation: School of Electrical and Computer Engineering, Georgia Institute of Technology. Phone: (+1)404-385-3383. Fax: (+1)404-385-6690. E-mail: steven.mclaughlin@provost.gatech.edu.}
\thanks{J. Almeida: Mailing address: Instituto de Telecomunica\c{c}\~{o}es (IT-Porto), FEUP, Departamento de Engenharia Electrot\'{e}cnica e de Computadores, Rua do Dr. Roberto Frias, s/n, 4200-465 Porto, Portugal, Visitors: Building I, Office I322. Affiliation: Instituto de Telecomunica\c{c}\~{o}es, Departamento de Engenharia Electrot\'{e}cnica e de Computadores, Faculdade de Engenharia da Universidade do Porto (FEUP). E-mail: jpa@fe.up.pt.}
\thanks{J. Barros: Mailing address: Same as J. Almeida, Visitors: Building I, Office I338. Affiliation: Instituto de Telecomunica\c{c}\~{o}es, Departamento de Engenharia Electrot\'{e}cnica e de Computadores, FEUP. Phone: (+351)225081825. E-mail: jbarros@fe.up.pt.}
\else
\fi}



\ifCLASSOPTIONpeerreview
\markboth{Submission to IEEE Transactions on Information Forensics and Security}{Achieving Physical-Layer Security through Stopping Sets in a Feedback Wiretap Scenario} \else
\fi

\maketitle

\begin{abstract}


In this paper we discuss the ability of channel codes to enhance cryptographic secrecy. Toward that end, we present the secrecy metric of degrees of freedom in an attacker's knowledge of the cryptogram, which is similar to equivocation. Using this notion of secrecy, we show how a specific practical channel coding system can be used to hide information about the ciphertext, thus increasing the difficulty of cryptographic attacks. The system setup is the wiretap channel model where transmitted data traverse through independent packet erasure channels with public feedback for authenticated ARQ (Automatic Repeat reQuest). The code design relies on puncturing nonsystematic low-density parity-check codes with the intent of inflicting an eavesdropper with stopping sets in the decoder. Furthermore, the design amplifies errors when stopping sets occur such that a receiver must guess all the channel-erased bits correctly to avoid an expected error rate of one half in the ciphertext. We extend previous results on the coding scheme by giving design criteria that reduces the effectiveness of a maximum-likelihood attack to that of a message-passing attack. We further extend security analysis to models with multiple receivers and collaborative attackers. Cryptographic security is enhanced in all these cases by exploiting properties of the physical-layer. The enhancement is accurately presented as a function of the degrees of freedom in the eavesdropper's knowledge of the ciphertext, and is even shown to be present when eavesdroppers have better channel quality than legitimate receivers.

\end{abstract}



\ifCLASSOPTIONpeerreview
\begin{center} \bfseries EDICS Categories: SYS-PROT, SEC-MLEV, CRY-INTE, MOD-SECU, and CRY-CRYP \end{center}
\fi
\IEEEpeerreviewmaketitle

\section{Introduction}\label{sec:intro}

\subsection{Cryptography and the Physical Layer}

\IEEEPARstart{M}any cryptosystems in place today measure security computationally. If all known attacks are computationally intractable, then the system is deemed to be secure. The chief failings of this notion of security are the assumptions placed on the attacker. First, it is assumed that the attacker has limited resources to confront the problem, even if those resources are state of the art. Second, it is assumed that the attacker uses attacks which are publicly known, even though a better attack may exist. Claude Shannon addressed these shortcomings by defining the notion of \emph{perfect secrecy} \cite{Shannon49}. If a secret message  is encrypted into a cryptogram  using a secret key , then perfect secrecy is achieved if . Shannon also proved that perfect secrecy is only attainable if the key is at least as long as , which is clearly impractical. However, perfect secrecy also makes the limiting assumption that an attacker has access to an error-free cryptogram, which may not be the case in practice.

Aaron Wyner later introduced the wiretap channel model, along with a new condition for secrecy \cite{Wyner75}. Let a message  of length  be encoded into a codeword  of length , and then transmitted. The rate of the encoder is . A legitimate receiver obtains  over the \emph{main channel} denoted , and an eavesdropper obtains  over a \emph{wiretap channel} denoted . The secrecy condition is 
Wyner showed that for rates up to the secrecy capacity , encoders and decoders exist which can satisfy (\ref{eq:weakSecrecy}) and also achieve arbitrarily low probability of error for intended parties when  is a Markov chain. This is known as the \emph{degraded} wiretap channel model. Csisz\'{a}r and K\"{o}rner \cite{Csiszar78} later generalized these results removing the degraded restriction, but still showing that , only if  is \emph{less noisy} than .

Understanding of the theoretically achievable secrecy rates of communication systems has continued to grow, as outlined in e.g. \cite{Wyner84}, \cite{Bloch06}, and \cite{Maurer00}. But another of the main challenges in this area has been the design of practical systems which achieve the secrecy rates indicated by the theory. These systems exploit noise in the channel at the physical layer of the communications system. Practical designs maximizing the information-theoretic secrecy are not trivial. Most currently suffer from one or more of several drawbacks. For instance, code designs are oftentimes a function of specific channel parameters (channel state information or CSI) seen by legitimate receivers and eavesdroppers.  Without accurate CSI, the results of these systems are not guaranteed; therefore, channels with varying or unknowable parameters present design issues. Other codes offer secrecy for only specific types of channels, or only when the eavesdropper's channel is degraded. Still other designs are impractical in the real world due to design complexity, necessary side information for legitimate decoding, or other limitations. Finally, the most glaring shortcoming of any scheme which derives security from the physical layer of a communications system, is that if an eavesdropper has a \emph{better} channel than a legitimate receiver, the scheme is likely to fail. The extreme case is when an eavesdropper has a noise-free channel and . Clearly this necessitates any physical-layer security scheme to be coupled with some other protection in order to maintain secrecy in the worst case.

\subsection{Main Contributions}

The intent of this paper is to develop the notion of \emph{combined security} due to cryptography and channel coding, thus providing a more complete security solution. To accomplish this goal, we cast coding into a cryptographic enhancement role, and seek to prevent an attacker from obtaining a noise-free cryptogram using channel coding. We present a new security metric for physical-layer schemes; namely, degrees of freedom  in an attacker's knowledge of the cryptogram. As a comparison, if bits in  are uniformly zero or one and independent and identically distributed (i.i.d.), then perfect secrecy implies . In fact we show that  for a specific case. Our notion of physical-layer security using  addresses the effectiveness of attacks on a cryptographic layer. To be more precise, our notion of security answers the practical question, how does the complexity of an attack on the cryptography change without perfect knowledge of the cryptogram?

It has been shown previously using correlation attacks on stream ciphers that certain cryptographic attacks are still possible even on noisy cryptograms, although a threshold on the noise level exists such that errors beyond the threshold cause the attack to fail \cite{Meier89, Harrison09_ICC, Harrison09_ISIT, Harrison09_ITW}. Practical schemes should provide enough confusion to exploit even the smallest amount of noise in an eavesdropper's received data to cause failure of these attacks on the cryptographic layer. Such systems should be robust to varying channel parameters, imperfect CSI at the encoder, and nondegraded system models. In fact, good designs still offer security enhancement to cryptography, even when attackers have an advantage in signal quality over legitimate receivers. Of course, all of this must be done while guaranteeing reliable communication between friendly parties.

Therefore, along with the new metric, this paper also analyzes combined cryptographic and physical-layer security in a \emph{practical coding scheme} using degrees of freedom to characterize security. In \cite{Harrison10_ITW}, this scheme was shown to inflict a passive eavesdropper using a message-passing decoder with stopping sets with very high probability when a legitimate receiver and an eavesdropper view transmitted data through statistically independent packet erasure channels (PEC). The scheme relies on a nonsystematic low-density parity-check (LDPC) code design, with puncturing and interleaving steps in the encoder. Legitimate receivers are given access to an authenticated public feedback channel for Automatic Repeat-reQuest (ARQ). In this paper, we broaden the security analysis of the scheme given in \cite{Harrison10_ITW} by addressing the following points.
\begin{itemize}
  \item \emph{Degrees of Freedom:} The system security is analyzed using the new metric. Computational secrecy is shown to grow exponentially with , which is also shown to be equal to  for the prescribed encoder.
  \item \emph{Encoder Description:} End-to-end details of the encoder and decoder are provided, as well as simulation results which match theoretical expectations.
  \item \emph{Optimization:} Design criteria are specified to maximize the degrees of freedom in the maximum-likelihood attack as well as the message-passing attack. This involves comparison of irregular LDPC codes with regular LDPC codes.
  \item \emph{Extensions:} Security results are made general so as to apply to multiple receivers and multiple collaborative attackers. Ultimately, bounds on the increase in computational secrecy of an underlying cryptosystem are specified when the physical-layer encoding system is employed.
\end{itemize}
Ultimately, this scheme has very few design constraints, offers enhanced cryptographic secrecy over a wide range of CSI parameters, and requires no secret key and no rate reduction in data transmission.

\subsection{Related Works}

Our encoder makes use of fundamental practical design ideas which have been shown to offer secrecy. For example, our encoder employs nonsystematic LDPC codes in order to hide information bits and magnify coding errors. Secrecy properties of these codes have been studied in \cite{Baldi10}. We further employ intentional puncturing of encoded bits, a technique shown to offer security in \cite{KlincITW09, Klinc09GC}. Our scheme punctures with the goal of inducing \emph{stopping sets} in an eavesdropper's received data. As a result, every transmitted bit is crucial for decoding. Our intent is to punish an eavesdropper for every missing piece of information. Finally, in order to distribute erasures throughout the data set, the encoder interleaves coded bits among several transmitted packets. Similar ideas of interleaving coded symbols have been used in \cite{Bloch08, MANETISIT09} in conjunction with wiretap codes developed in \cite{Thangaraj07} to offer secrecy to various systems. The works \cite{Lai08, Latif09} give results for ARQ and feedback wiretap systems.

It can be argued that the first practical secrecy coding scheme was presented by Ozarow and Wyner in an extension of the original wiretap paper \cite{Wyner84}. Here the general idea of partitioning a group code into cosets to achieve secrecy was first presented. This technique was shown to apply to LDPC codes much more recently in \cite{Thangaraj07}, and achieves the secrecy condition in (\ref{eq:weakSecrecy}) for noiseless main channels when the wiretap channel is either a binary erasure channel (BEC) or a binary symmetric channel (BSC). This work in LDPC codes for secrecy has been furthered in \cite{Arun10_ITW}, where large-girth LDPC codes are considered, and shown to meet the secrecy constraint in (\ref{eq:weakSecrecy}) for noiseless main channel and BEC wiretap channel. A stronger notion of secrecy than (\ref{eq:weakSecrecy}) is also achieved for these codes in certain cases. Finally, it should be noted that Ar{\i}kan's polar codes \cite{Arikan09} can offer secrecy for general symmetric channels, although code construction is an issue for non-erasure channels. Schemes have been presented in \cite{Hof10} and \cite{Mahdavifar10} which achieve the secrecy capacity under the condition in (\ref{eq:weakSecrecy}), although these schemes only offer secrecy for degraded wiretap channels. Furthermore, design of these codes is heavily contingent on perfect CSI at the encoder.

Although our codes can be shown to achieve (\ref{eq:weakSecrecy}) only under certain puncturing criteria, the main contribution of the coding scheme presented here is the cryptographic security enhancements shown using degrees of freedom as a security metric. Our scheme is robust against imperfect CSI, and for that matter, undetected eavesdroppers. According to our knowledge, it is also the first \emph{practical} secrecy scheme which can operate on the general wiretap channel (nondegraded case) when both  and  are erasure channels.

The rest of the paper is outlined as follows. In Section \ref{sec:system}, we discuss the system model for which our encoder is designed, which is an adaptation of the wiretap channel model from \cite{Wyner75}. The precise definition of degrees of freedom is also given. Section \ref{sec:stoppingSets} addresses background information regarding LDPC codes and stopping sets. Our novel encoder and decoder designs are presented in Sections \ref{sec:encoder} and \ref{sec:decoder}, respectively. Analysis of the security inherent in the system is then completed in Section \ref{sec:analysis} for various scenarios, ultimately culminating in the most general case which encompasses multiple users and collaborating eavesdroppers. Finally, bounds regarding enhancements of cryptographic security are presented in Section \ref{sec:crypto} along with end-to-end simulations of the system. Conclusions are provided in Section \ref{sec:conclusion}.

\section{System Model and Degrees of Freedom}\label{sec:system}

We begin by presenting the wiretap channel model \cite{BlochBook} with the addition of feedback in Fig. \ref{fig:wiretapChannel}. A user named Alice wishes to transmit an \emph{encrypted} binary message  to a legitimate receiver named Bob, where  for . It will be helpful to think of  as being broken up into  blocks of length , where  is the dimension of the encoder to follow. The final block  can be filled by concatenating random bits if needed. Let us also define the blocklength  of the encoder. Then the coding rate is . To be clear,  is the length of a codeword after it has been punctured. We will also assume that  has been compressed, so that all possible bit combinations are equally likely in the alphabet . Prior to transmission, Alice encodes , resulting in a collection of  packets  for transmission. Bob receives the packets as  through , a PEC with probability of erasure . An eavesdropper named Eve obtains the packets , although through , an independent PEC with probability of erasure . An obvious extension of this model is to consider correlated erasures in  and ; however, in this paper we always assume erasures are statistically independent. Finally,  and  are the respective estimates of  by Bob and Eve.

\begin{figure}
\begin{center}
  \begin{tikzpicture}
[node distance=0.8cm, rounded corners=2pt, channel/.style={rectangle,draw=blue,fill=blue!10,thick,
    text centered,minimum size=8mm},
    boxedNode/.style={rectangle,draw,fill=black!10,thick,text centered, minimum size=8mm},
    inner sep=1mm]
\node (Alice) {Alice};
    \node [boxedNode] (Encoder) [right=of Alice] {Encoder};
    \node [channel] (Qm) [right=of Encoder,label=above:] {PEC()};
    \node [boxedNode] (Decoder) [right=of Qm] {Decoder};
    \node (Bob) [right=of Decoder] {Bob};
    \node [channel] (Qw) [below=of Qm,label=above:] {PEC()};
    \node [boxedNode] (Decoder_w) [right=of Qw] {Decoder};
    \node (Eve) [right=of Decoder_w] {Eve};
\draw[->] (Alice) -- node [above] {} (Encoder);
    \draw[->] (Encoder) -- node [above] {} (Qm);
    \draw[->] (Qm) -- node [above] {} (Decoder);
    \draw[->] (Decoder) -- node [above] {} (Bob);
    \draw[->] (Qw) to node [above] {} (Decoder_w);
    \draw[->] (Decoder_w) to node [above] {} (Eve);
    \draw[->] () |- (node cs:name=Qw,anchor=west);
    \draw [->] (Bob) -- ++(0,1.1)
        -| node[near start, above] {Feedback Channel} (Encoder);
  \end{tikzpicture}
\end{center}
\caption{Wiretap channel model with feedback assuming packet erasure channels for both the main channel  and the wiretap channel .}\label{fig:wiretapChannel}
\end{figure}

The encoder and decoder exploit the independent nature of erased packets across  and . Of course, the system must guarantee that , while at the same time making Eve as ignorant as possible. The authenticated feedback channel available to Bob plays a key role in accomplishing both of these endeavors. This public noiseless channel is used to request the retransmission of erased packets. Since it is authenticated, Alice is able to deduce whether Bob sent the request, and can detect any tampering with the data \cite{Stinson_CryptoBook}, which restricts Eve to passive status \cite{MaurerPart1}. Requests by Bob are public, and there is no \emph{secret key} employed at the physical layer. The sole source of confusion for Eve is her own naturally occurring erasure pattern across .\footnote{It is noted that results in Section \ref{sec:analysis} are provided for this system, as well as the more general model which allows an arbitrary number of legitimate receivers and eavesdroppers.}

As mentioned in Section \ref{sec:intro}, we define \emph{physical-layer security} for this system with the cryptographic layer in mind. Cryptographic attacks often assume an attacker has the luxury of an error-free version of  (or even some of the plaintext), but our design aims to prevent this from occurring, by creating degrees of freedom in the attacker's knowledge of .
\begin{definition}\label{def:degsFreedom}
 The number of \emph{degrees of freedom} in a received codeword is a random variable  which takes on the number of encoded symbols for which an eavesdropper has no information. Therefore, the probabilities of all symbol values on these  symbols are equally likely.
\end{definition}
For binary codes with , a codeword of length  can be any of  equally likely codewords, each mapping to a unique -bit message in . Since we assume that the attacker knows the encoder, the maximum value of  is , and can be shown to have an information-theoretic definition. Since an attacker has no knowledge of these bits, an average of  guesses must be made to obtain them. Using this reasoning, the goals of our physical-layer design are: first, to ensure that  for Bob so that ; second, to make  as large as possible for Eve; and third, to ensure that attacks on the cryptogram fail if .

\section{LDPC Codes and Stopping Sets}\label{sec:stoppingSets}
We employ LDPC codes \cite{Gallager63} and exploit the phenomenon of stopping sets to obtain security from the physical layer. This section provides limited background of LDPC codes and stopping sets in order to establish the foundation upon which to present our encoder.

Let us define a general binary LDPC code  with blocklength , and dimension . Note that this  is identical to  from section \ref{sec:system}, but  the blocklength of the LDPC code, is different from  the blocklength of the encoder because  is the codeword length after puncturing. The parity check matrix  fully defines the code, and is . We will find it helpful to think of  in terms of its corresponding Tanner graph  \cite{MoonArches,UrbankeModern}. The set of variable nodes is , while the set of check nodes is . Variable nodes correspond to the  bits in a codeword. Checks correspond to rows in , where the set of bits that participate in the check  is denoted  \cite{MoonArches}. Then the th check is calculated in GF(2) as . The notation  signifies all bits in the th check except the th bit. The th variable node shares an edge with the th check node in  if and only if . The Tanner graph for a simple example is shown in Fig. \ref{fig:stoppingSet}.

Decoding of an LDPC codeword over a BEC can be accomplished using maximum-likelihood (ML) decoding \cite{Burshtein04}, by solving a system of equations. However, the iterative message-passing (MP) decoder is commonly used due to its computational efficiency. We briefly explain both decoders.

\begin{figure}
\begin{center}
  \begin{tikzpicture}
   [variableNode/.style={circle,draw,thick},
   stopNode/.style={circle,draw,thick},
   stopBlock/.style={rectangle,rounded corners=2pt,fill=black!10,thick,draw=black!50,inner sep=3mm,yshift=1.25mm},
   checkNode/.style={rectangle,draw,thick}, node distance=6mm]
\node [variableNode] (v_one) [label=left:] {};
    \node [variableNode] (v_two) [below=of v_one,label=left:] {};
    \node [stopBlock] [below=of v_two] {};
    \node [stopNode] (v_three) [below=of v_two,label=left:] {};
    \node [variableNode] (v_four) [below=of v_three,label=left:] {};
    \node [stopBlock] [below=of v_four] {};
    \node [stopNode] (v_five) [below=of v_four,label=left:] {};
    \node [variableNode] (v_six) [below=of v_five,label=left:] {};
    \node [variableNode] (v_seven) [below=of v_six,label=left:] {};
\begin{scope}[node distance=5cm]
    \node [checkNode] (u_one) [right=of v_two,label=right:] {};
    \node [checkNode] (u_two) [right=of v_four,label=right:] {};
    \node [checkNode] (u_three) [right=of v_six,label=right:] {};
    \end{scope}

    \draw (v_one) -- node[pos=0.05, above,text height=1.5ex, text depth=.25ex] (messageNode1) {1} node[pos=0.25, above,text height=1.5ex,text depth=.25ex] (arrowNode1) {} (u_one);
    \draw [->,xshift=5pt,yshift=5pt] (messageNode1) -- (arrowNode1);
    \draw (v_two) -- node[pos=0.05, above] {0} (u_two);
    \draw (u_one) -- node[pos=0.95, above] {} (v_three) -- node[pos=0.05, below] {} (u_two);
    \draw (v_four) -- node[pos=0.05, above] {0} (u_three);
    \draw (u_one) -- node[pos=0.95, above] {} (v_five) -- node[pos=0.05, below] {} (u_two);
    \draw (v_six) -- node[pos=0.05, above] {1} (u_three);
    \draw (u_one) -- node[pos=0.95, above] {1} (v_seven) -- node[pos=0.05, below] {1} (u_three);

  \end{tikzpicture}
\end{center}
\caption{Tanner graph for MP decoding over the BEC with a highlighted stopping set due to erasures at variable nodes  and .}\label{fig:stoppingSet}
\end{figure}

\subsection{Maximum-Likelihood Decoding}\label{subsec:ML}
Let us consider an LDPC codeword  transmitted over a BEC and let  denote the received codeword. Note that  and  where  signifies an erased bit. We let  denote the set of known bits in , and  denote the set of erased bits in . Furthermore,  and  can be understood to be matrices formed by the columns of  indexed by  and , respectively. Similarly,  and  are vectors composed of only the bits indexed by the respective sets  and .

Clearly, , where , and thus  is known. The maximum likelihood decoder must then solve for the channel-erased bits  using the system of equations given by

This system has a unique solution when the erased bits are such that the columns of  are linearly independent \cite{Urbanke01}. We can obtain a bound from this statement which we will use to analyze security in the worst-case.
\begin{proposition}\label{prop:boundOnSizeKbar}
For a linear code  with blocklength  and dimension , the ML decoder over the BEC cannot have a unique solution if the number of erasures exceeds , that is if .
\end{proposition}
\begin{IEEEproof}
The rank of  equals the number of linearly independent rows or columns of the matrix (\cite{MoonBlack}, pg. 244). Since  is the number of rows in , the rank of  can never exceed , and thus the ML decoder cannot produce a unique solution when .
\end{IEEEproof}
In fact, when the number of erasures exceeds , the system in (\ref{eq:systemML}) will be such that the degrees of freedom in the ML decoder , where we achieve equality if there are  linearly independent columns in  \cite{Burshtein04}. In any case,  is equal to the difference in the number of erased bits, and the number of linearly independent columns of , and is zero if this difference is negative. This definition clearly satisfies the notion of degrees of freedom from Definition \ref{def:degsFreedom} for this decoder. Thus we see that the effectiveness of the decoder is strictly bounded by the redundancy of the code. While faster methods have been discovered for solving a linear system of equations, the straightforward decoder is known to have complexity , where  is the rate of the code,  and  are constants which are also a function of the elimination algorithm chosen to solve the system of equations,  is the erasure probability in the channel, and  is the blocklength of the code \cite{Burshtein04}.

\subsection{Message-Passing Decoding}\label{subsec:MP}

Let , , and  hold the same definitions as for the ML decoder. The MP decoder is an iterative decoder based on the Tanner graph representation of . The decoding process passes \emph{messages} between  and  along the edges of . One version of the decoder is given as Algorithm \ref{alg:MPdecoding} (adapted from \cite{Urbanke01}). The number of degrees of freedom in the MP decoder  is the cardinality of the smallest set of bit values that must be supplied in order to decode all remaining bits. If the decoder succeeds, then . Clearly, this maintains the definition of degrees of freedom given in Definition \ref{def:degsFreedom} when restricted to this decoder, because any bit combination of these  values decodes to a valid codeword, and each is equally likely without further information. A bound on the correction capabilities of the MP decoder is given by the following proposition.
\begin{proposition}\label{prop:maxDecodMP}
  The MP decoder over the BEC can correct no more than  erasures.
\end{proposition}
\begin{IEEEproof}
 In Algorithm \ref{alg:MPdecoding}, each check node can correct at most one variable node, and .
\end{IEEEproof}
The MP decoder is suboptimal compared with the ML decoder, although the MP decoder has linear complexity in the blocklength \cite{MoonArches}. A more detailed comparison of the two decoders is offered in \cite{Lee07}.

\algsetup{indent=2em}
\begin{algorithm}[h]
\caption{Message-Passing Decoder over the BEC \cite{Urbanke01}.}
\begin{algorithmic}[1]
\STATE \textbf{Initialize:} For , set  and declare all such variable nodes as known.
  \IF {(No variable nodes are known and no check node has degree one)}
    \STATE Output the (possibly partial) codeword and stop.
  \ELSE
    \STATE Delete all known variable nodes along with their adjacent edges.
  \ENDIF
  \STATE For each variable node  connected to a degree one check node , declare  as known and set . Jump to 2.
\end{algorithmic}
\label{alg:MPdecoding}
\end{algorithm}

\subsection{Stopping Sets}\label{subsec:stoppingSets}

In order to make  as large as possible for our system when an eavesdropper uses an MP decoder, we would like to design the encoder block from Fig. \ref{fig:wiretapChannel} so that every bit erased by the channel adds a degree of freedom to the decoder. Stopping sets provide a means of accomplishing this task.
\begin{definition}[Di, et. al. \cite{Di02StoppingSets}]\label{def:stoppingSet}
 A \emph{stopping set} is a set  such that all check nodes in  are connected to  by at least two edges, where  signifies the \emph{neighborhood} of  and is defined as the set of all adjacent nodes to any member of  in .
\end{definition}
Notice that the empty set, by definition, is a stopping set, as is any union of stopping sets. Thus, any set of variable nodes has a unique maximal stopping set in it.\footnote{For our purposes, we will sometimes ignore the empty set as a stopping set and say that a set  \emph{contains no stopping sets}, meaning that the maximal stopping set in  is .} See Fig. \ref{fig:stoppingSet} for a simple example; clearly the erasures cannot be resolved using Algorithm \ref{alg:MPdecoding}. This gives way to the following lemma, proved in \cite{Di02StoppingSets}.
\begin{lemma}[Di et. al. \cite{Di02StoppingSets}, Lemma 1.1] \label{lem:stoppingSets}
   Let  be the Tanner graph defined by the parity check matrix  of a binary linear block code , and assume that  is used to transmit over the BEC. Let  be the set of erased bits in the received codeword. Then, using Algorithm \ref{alg:MPdecoding} on , the set of erasures which remain after decoding comprise the unique maximal stopping set in .
\end{lemma}

Since stopping sets cause the MP decoder to fail, puncturing in the encoder will be done with an attempt to inflict Eve with stopping sets. However, the ML decoder will still succeed, even in the presence of stopping sets, as long as the erased bits have linearly independent columns in . We account for both decoders in our design by using a particular ensemble of LDPC codes where  can be made equal to , thus ensuring secrecy regardless of the decoder used by Eve. The simplicity of MP decoding is also preserved for all legitimate receivers.\footnote{For further information on stopping sets as they relate to LDPC code ensembles, see \cite{Rosnes09} and \cite{Orlitsky05}.}

\section{Encoder}\label{sec:encoder}

The encoder design is based on the fact that  because processing cannot increase information, and  is a Markov process \cite{Cover}. The key idea in the decoder is to reduce  to the decoding threshold. In other words,  can be used to recover  by design, but if any erasures remain in  following transmission, unique decodability is not possible. Proper design maximizes  for Eve. The stages of encoding are portrayed in Fig. \ref{fig:encoder}, where each stage fulfills a specific purpose within the overall goals of obtaining secrecy and reliability. The following principles are addressed in the design of this encoder.
\begin{itemize}
  \item Bits of  are hidden from immediate access in the decoded words using nonsystematic LDPC codes.
  \item Scrambling prior to coding magnifies errors due to the physical layer of the communication system.
  \item The error-correction capabilities of the LDPC code are restricted by intentional puncturing of encoded bits. (Bob obtains reliability through ARQ, rather than error correction.)
  \item Bits from encoded blocks are interleaved amongst several transmitted packets so that a single erased packet results in erasures in many encoded blocks of data.
\end{itemize}

\begin{singlespace}
\begin{figure}
\begin{center}
  \begin{tikzpicture}
  [node distance=0.35cm, rounded corners=2pt, boxedNode/.style={rectangle,draw,fill=black!10,thick,
  text centered, minimum size=8mm},
  multiLine/.style={rectangle,text centered, text width=1.3cm, minimum size=8mm},
  boxMultiLine/.style={rectangle,draw,fill=black!10,thick,
  text centered, text width=1.3cm, minimum size=8mm},
  inner sep=1mm]
    \node [boxMultiLine] (Encoder) {LDPC Encoder};
    \node [boxMultiLine] (Puncture)  [right=of Encoder]  {Puncture Block};
    \node [boxedNode] (Buffer)  [right=of Puncture]  {Buffer};
    \node [boxedNode] (Interleaver)  [right=of Buffer]  {Interleaver};
    \draw[->] () -- node [midway, above] {} node [midway, below=14pt, text width=1.5cm, text centered] { blocks length } (Encoder);
    \draw[->] (Encoder) to node [above, midway] {} node [below=14pt, text width=1.5cm, text centered, midway] { blocks length } (Puncture);
    \draw[->] (Puncture) to node [above] {} node [below=14pt, text width=1.5cm, text centered, midway] { blocks length } (Buffer);
    \draw[->] (Buffer) to (Interleaver);
    \draw[->] (Interleaver) to node [midway, above] {} node [midway, below=12pt, text width=1.6cm, text centered] { packets size } ();
  \end{tikzpicture}
\end{center}
\caption{Detailed block diagram of the encoder. Number and size of blocks or packets are indicated at each step.}\label{fig:encoder}
\end{figure}
\end{singlespace}

\subsection{Nonsystematic LDPC Codes}\label{subsec:nonsystematic}

Recall from Section \ref{sec:system} that , where  for . These  blocks of encrypted message form the input to the nonsystematic LDPC encoder with blocklength  and dimension . The output of the LDPC encoder  is given as  codewords of length , denoted as  where each vector . Certainly, if the code  were systematic, then the bits of  would appear explicitly in the encoded block . For secrecy purposes, nonsystematic codes are employed.

Nonsystematic LDPC coding is typically implemented as a two stage process to improve encoder complexity \cite{Alloum05, Shamir05, Baldi10}. Let  be an invertible  \emph{scrambling} matrix in GF(2), and let  be a  systematic generator matrix. Let  be a length- message. Then our LDPC encoding process applies the scrambling matrix to  as

The data are then encoded using  by  to obtain a length- block of encoded data. Clearly at the decoder the inverse operation first requires the bits of  to be obtained through either MP or ML decoding. Since  is systematic, the bits of  are explicit in . The bits of  can then be found by applying the inverse of  in the descrambling operation

This process amplifies errors in the decoding process as a function of the sparsity of . Note that  can be obtained through e.g. LU decomposition \cite{MoonBlack}, with modifications for GF(2). In our experience, randomly generated scrambling matrices which are nonsingular are likely to have inverses with just less than 50\% of the entries equal to one on average. If  matrices are randomly generated until one can be inverted to obtain , the resulting despreading operation is enough to cause even a single error in  to result in roughly a 50\% error rate in  as shown in Section \ref{sec:crypto}. Although this can be made more precise, the result is intuitive because a bit in  is a linear combination of bits in . Thus, if there are an odd number of bits in error in a given combination of say , then that bit will be in error. On average, the row weight in  is approximately , and the expectation of  bits in error holds for any number of errors in .

Since only one  pair need be used by the system, the matrices can be generated off-line, which does not affect encoding and decoding complexity. However, the complexity of both the encoder and the decoder is increased due to the matrix multiplications in (\ref{eq:scramble}) and (\ref{eq:inverseScramble}). Both of these operations are . General systematic encoder complexity is  because  is not sparse by design \cite{MoonArches}, although improvements can be made using appropriate preprocessing as outlined in \cite{Urbanke01}. The encoding technique specified in \cite{Urbanke01} gives encoder complexity of  where  is the \emph{gap} in an approximate lower triangular form of the parity check matrix and is less than . The complexities for the ML and MP decoders are given in Sections \ref{subsec:ML} and \ref{subsec:MP} as  and , respectively.

\subsection{Puncturing}\label{subsec:puncturing}

The next step in the encoding process is to apply a puncturing pattern to each codeword in . Let the puncturing pattern  indicate which bits in each  are to be punctured. Recall that  is the set of variable nodes in the Tanner graph . The punctured blocks , where each  are shown in Fig. \ref{fig:encoder} to have length , which was defined in Section \ref{sec:system} to be the blocklength of the encoder. All bits which are not punctured belong to the set  so that ; therefore, the length of each block in  is equal to . The puncturing pattern is chosen in order to induce stopping sets in an eavesdropper's received data.
\begin{definition}\label{def:acceptable}
 A puncturing pattern  is deemed \emph{acceptable} if and only if there are no stopping sets in , and  contains some nonempty stopping set  for every variable node .
\end{definition}
Such a set  can be constructed using the random technique outlined in Algorithm \ref{alg:findR}, which also calls Algorithm \ref{alg:isThereStoppingSet} in order to check for stopping sets in a computationally tractable manner \cite{Harrison10_ITW}.

\algsetup{indent=2em}
\begin{algorithm}[h]
\caption{Finds an acceptable puncturing pattern  within the set of all variable nodes .}
\begin{algorithmic}[1]
\STATE \textbf{Initialize:} , for a randomly chosen , and .
  \IF{ ()}
    \STATE Choose another  randomly from .
    \STATE Run Algorithm \ref{alg:isThereStoppingSet} with  to check for stopping sets.
    \IF{( has a stopping set, i.e. Algorithm \ref{alg:isThereStoppingSet} returns true)}
      \STATE .
    \ELSE
        \STATE .
    \ENDIF
    \STATE Jump to 2.
  \ELSE
    \STATE Terminate.
  \ENDIF
\end{algorithmic}
\label{alg:findR}
\end{algorithm}

\algsetup{indent=2em}
\begin{algorithm}[h]
\caption{Checks for the existence of stopping sets in a subset of variable nodes,  \cite{Harrison10_ITW}.}
\begin{algorithmic}[1]
\STATE \textbf{Initialize:} 
  \IF {  }
    \STATE Induce subgraph  in  using (.
    \IF{ ( a check node in  with degree 1)}
      \STATE Delete variable nodes from  which are adjacent to check nodes of degree 1 in , jump to 2.
    \ELSE
      \STATE Return true.  is the maximal nonempty stopping set in .
    \ENDIF
  \ELSE
    \STATE Return false. There is no nonempty stopping set in .
  \ENDIF
\end{algorithmic}
\label{alg:isThereStoppingSet}
\end{algorithm}

\begin{lemma}\label{lem:algorithmFindR}
 The output of Algorithm \ref{alg:findR} is always an \emph{acceptable} puncturing pattern R as defined in Definition \ref{def:acceptable}.
\end{lemma}
\begin{IEEEproof}
We must first show that upon completion of Algorithm \ref{alg:findR}, there are no stopping sets in . Assume for a contradiction that  has a stopping set. Then there is a bit  which when added to  during the construction process, caused a stopping set to first appear. Then by Algorithm \ref{alg:findR}, . This provides the contradiction. It remains to be proved that Algorithm \ref{alg:isThereStoppingSet} operates as expected.
\begin{proposition} \label{prop:algIsThereSSWorks}
 Algorithm \ref{alg:isThereStoppingSet} always returns true when  has a nonempty stopping set, and always returns false otherwise.
\end{proposition}
\begin{IEEEproof}[Proof of Proposition] Suppose that the bits in  were actually erasures over the BEC, and Algorithm \ref{alg:MPdecoding} was used to decode. Realize that erasures recovered in the th iteration of Algorithm \ref{alg:MPdecoding} correspond exactly to the nodes deleted in the th iteration of Algorithm \ref{alg:isThereStoppingSet}. If all bits can be resolved using MP decoding then all nodes will be deleted in Algorithm \ref{alg:isThereStoppingSet}, and false is returned. If, however, MP decoding returns a partial codeword, then Algorithm \ref{alg:isThereStoppingSet} will return true because all remaining bits have degree greater than one in the induced subgraph . Therefore, by Lemma \ref{lem:stoppingSets}, the remaining nodes comprise the maximal stopping set of .
\end{IEEEproof}

To complete the proof of Lemma \ref{lem:algorithmFindR}, we must also show that for any ,  has a nonempty stopping set. Since in Algorithm \ref{alg:findR} every  is such that for some subset ,  has a stopping set, therefore  has a stopping set for any .
\end{IEEEproof}
Thus, puncturing according to  in each  for , guarantees that every bit in each  is crucial for successful MP decoding.

Complexity of Algorithm \ref{alg:findR} is linear in the blocklength , because it chooses  bits in a random order, and calls Algorithm \ref{alg:isThereStoppingSet} after each choice. The complexity of Algorithm \ref{alg:isThereStoppingSet} in the worst case, is quadratic in  the number of check nodes in . Line 5 of the algorithm will be repeated a maximum of  times if a single node is deleted each time the line is executed. Therefore, the complexity of finding an acceptable puncturing pattern  is at most quadratic in , and linear in , i.e. has complexity . Thus the algorithm can be used in practical system design to compute  off-line.

\subsection{Regular vs. Irregular Codes}\label{subsec:regVsIrreg}

The overall rate  of the nonsystematic and punctured code is a function of the rate of the systematic LDPC code, and . Simulations have shown that the size of  is very much a function of the degree distribution on , although the exact relationship is still unknown.
\begin{example}\label{ex:punct}
Let  be a regular rate-1/2 code with , , and , where  and  are the fixed column and row weights of the parity check matrix, respectively. The size of  appears to be Gaussian-distributed for this family of codes with a mean size of approximately 436, with variance roughly equal to 15. Let us examine, however, an irregular ensemble with the same rate and blocklength, but having the following edge degree distribution pair:  on variable node weights, and  on check node weights (see \cite{MoonArches} pg. 664), where  is formed using the socket approach given in \cite{Burshtein04}. Here the distribution on  is much tighter, ranging from 496 to 500. The size on  is equal to 500 with probability roughly equal to 0.1, 499 with probability around 0.56, and 498 with probability near 0.26. Thus with some degree of confidence, we can claim that for this rate-1/2 irregular code ensemble the random technique given in Algorithm \ref{alg:findR} yields a puncturing pattern with size nearly equal (and equal in some cases) to .
\end{example}

As a direct result, a puncturing pattern generated for the irregular code of the example has a unique property. Namely, that for some patterns .
\begin{lemma}\label{lem:degsFree}
Let  denote the indices of the channel-erased bits of , and  and  denote the degrees of freedom using MP decoding and ML decoding, respectively. If an irregular LDPC code is employed over the BEC with intentional puncturing determined by Algorithm \ref{alg:findR} in which , then .
\end{lemma}
\begin{IEEEproof} The ML portion of this lemma follows from Proposition \ref{prop:boundOnSizeKbar}, i.e. that the system of equations in (\ref{eq:systemML}) can resolve a maximum of  erasures. Since , any erasure by the channel is guaranteed to give a degree of freedom in the decoder. The MP case is the same because by Proposition \ref{prop:maxDecodMP}, the MP decoder can correct at most  erasures. Thus any bits erased by the channel (or perhaps another set of bits of equal size) must be guessed in order to decode. Therefore, the effectiveness of the ML decoder is equal to that of the MP decoder when .
\end{IEEEproof}

It should be noted that if the sum of systematic bits in  is less than , a brute-force attack on these bits might be more appealing to an attacker than decoding the entire codeword. To cover this possibility,  can be thought of as the minimum between the number of systematic bits missing to the eavesdropper, and the degrees of freedom in the decoder. Although, in practice the number of systematic bits removed through puncturing or erased by the channel usually exceeds the degrees of freedom in the decoder.

\subsection{Interleaving}\label{subsec:interleaving}

The role of the interleaver is to ensure that all packets must be obtained error-free for successful decoding in any and all encoded blocks. To do this, we construct a collection of  packets to be transmitted  in the following manner. Alice defines  a small positive integer which is assumed to divide  (not necessary but convenient for notation and analysis) such that , and the th packet is formed as

for . In words, we form the packet  by concatenating  bits from each encoded and punctured block  for . Therefore, a single erased packet causes  erasures in each punctured block at the decoder. Since we have designed  so that any erasure of a bit in  results in MP decoding failure, we can be assured that any erased packet will cause all  blocks to fail in the MP decoder due to this interleaving. If  can be designed so that , then the same result holds for ML decoding by Lemma \ref{lem:degsFree}.
\begin{corollary}\label{lem:security}
If  and packets are formed according to (\ref{eq:packets}), then the number of degrees of freedom in the th codeword is  for , where  is a list of all erased packets. Furthermore, .
\end{corollary}
\begin{IEEEproof}
 The first part is trivial and follows directly from Lemma \ref{lem:degsFree} and (\ref{eq:packets}). We see that  because a missing packet means exactly  degrees of freedom in each block, irrespective of decoder choice.
\end{IEEEproof}

\section{Decoder for Legitimate Users}\label{sec:decoder}

The decoder for legitimate users is simply the inverse of all encoder operations. A user can decode all data as long as every packet is received error-free. Legitimate users make use of the authenticated feedback channel to request retransmission of packets erased in the main channel during transmission. Time delay and queueing aspects of ARQ protocols are well-addressed in the literature, e.g. \cite{Konheim80} and its references. The decoding process is shown pictorially in Fig. \ref{fig:decoder}. Once all packets are obtained in , the bits are deinterleaved back into their intentionally punctured codewords . The MP decoder is then guaranteed to decode the puncturing in linear time with the blocklength to obtain  \cite{MoonArches}, and the inverse of the scrambling matrix is applied to the systematic decoded bits using (\ref{eq:inverseScramble}) to obtain . Once all packets are known, this decoder guarantees that .


\begin{figure}
\begin{center}
  \begin{tikzpicture}
  [node distance=0.35cm, rounded corners=2pt, boxedNode/.style={rectangle,draw,fill=black!10,thick,
  text centered, minimum size=8mm},
  boxMultiLine/.style={rectangle,draw,fill=black!10,thick,
  text centered, text width=1.3cm, minimum size=8mm},
  inner sep=1mm]
    \node [boxedNode] (Buffer) {Buffer};
    \node [boxedNode] (Deinterleaver)  [right=of Buffer]  {Deinterleaver};
    \node [boxMultiLine] (messPass)  [right=of Deinterleaver]  {Message Passing};
    \node [rectangle,draw,fill=black!10,thick,text centered, text width=1cm, minimum size=8mm] (map)  [right=of messPass]  {Map to };
    \draw[->] () -- node [midway, above] {} node [midway, below=12pt, text width=1.6cm, text centered] { packets size } (Buffer);
    \draw[->] (Buffer) to (Deinterleaver);
    \draw[->] (Deinterleaver) to node [above] {} node [below=14pt, text width=1.5cm, text centered, midway] { blocks length } (messPass);
    \draw[->] (messPass) to node [above] {} node [below=14pt, text width=1.5cm, text centered, midway] { blocks length } (map);
    \draw[->] (map) to node [midway, above] {} node [midway, below=14pt, text width=1.5cm, text centered] {  blocks length } (); \end{tikzpicture}
\end{center}
\caption{Detailed block diagram of Bob's decoder. Number and size of blocks or packets are indicated at each step.}\label{fig:decoder}
\end{figure}


\section{Security against Wiretappers}\label{sec:analysis}

An eavesdropper can decode the data using Bob's decoder in Fig. \ref{fig:decoder} if all packets are obtained error-free. The independence of  and , however, prevents Eve from receiving packets as a function of  and , the respective probabilities of erasures in  and . Let  be the event that a single packet is \emph{received error-free} by at least one eavesdropper after all retransmissions of the packet requested by any legitimate receiver have been filled. This section shows the blanket security effect of our encoder over nearly the entire region of possible  pairs by completely characterizing  for the system. We first show  to be binomially distributed, and then provide security results for all scenarios studied as a function of . Expressions for  follow for the wiretap channel case, the broadcast scenario with  intended receivers, the case with  collaborating eavesdroppers, and the most general case with both  legitimate receivers and  collaborating eavesdroppers. For cases beyond the simple wiretap scenario, all  legitimate receivers are given access to the feedback channel, and all  eavesdroppers are restricted to passive status through authentication on the channel. Retransmissions in the ARQ protocol are executed only after requests are received from all legitimate parties.

Since proper design of the encoder was shown to cause  to have the same realization for every codeword and be independent of the decoder in Corollary \ref{lem:security}, we understand  to represent the degrees of freedom in every codeword assuming either the ML or MP decoder for the rest of the paper.

\subsection{General Security Theorems}

\begin{lemma}\label{lem:DisBinomial}
 The random variable  which governs the number of degrees of freedom in a received codeword is a scaled binomial random variable. Thus, for ,
 
\end{lemma}
\begin{IEEEproof}
 By definition, packets are erased for eavesdroppers with probability . Since there are  independent Bernoulli trials, each identically distributed, the sum of erased packets  is a binomial random variable with parameters  and  \cite{Grimmett_ProbBook}. Then, by Corollary \ref{lem:degsFree},  where  bits from every codeword are sorted into each packet. Thus,  is a scaled binomial random variable; specifically . Since , then  implies that . Clearly, this requires that . The result in (\ref{eq:thm2}) follows directly.
\end{IEEEproof}

The expected value is therefore known due to the binomial structure of . We also prove an important property in regards to .
\begin{theorem}\label{thm:expectedValD}
 If  in the encoder, then , and .
\end{theorem}
\begin{IEEEproof}
 Since , then . Let us consider the model for a single codeword (). We can then assume  independent uses of a PEC with packets of length . Let  be the input to the channel, and  the output, where  bits are erased with probability  or received error-free with probability  with each channel use. The input distribution on  bits is uniform because the input distribution on  is uniform, and the encoding function of rate one forms a bijection on  bits. Thus, . Clearly , and  (see \cite{Cover}, pg. 188). Then,
 
 Therefore, with  independent uses of the channel (one for each packet), . Since the mean of a binomial random variable is the product of its two parameters, , and therefore
 
\end{IEEEproof}
Thus we see that  is equal to the information-theoretic value of equivocation when the puncturing is accomplished so that . Therefore, \emph{perfect} secrecy is obtained when . Of course, this occurs when , which implies that the eavesdropper obtains zero packets. Thus, this scheme cannot achieve perfect secrecy. However, it can be shown using the achievable rates in \cite{Wyner84} that  approaches the maximum achievable equivocation for . These results now require expressions for  to complete the security characterization in .

\subsection{One Receiver and One Wiretapper}

The simplest case matches the setup given in Fig. \ref{fig:wiretapChannel}, and was originally proved in \cite{Harrison10_ITW}.
\begin{lemma}[Harrison, et. al. \cite{Harrison10_ITW}]\label{lem:wiretap1}
 In the wiretap channel scenario with feedback, the probability that Eve obtains a single transmitted packet is given as
 
\end{lemma}

Intuition of security for the wiretap channel in terms of  can be gained by using the expression for  in (\ref{eq:thm1}) to plot (\ref{eq:thm2}) for different values of , , and . Fig. \ref{fig:oneUser} shows  for  . Note that when ,  is not required to evaluate (\ref{eq:thm2}). This case is provided to show the plateau and falloff regions in the  grid for . Throughout the plateau region, stopping sets occur in the MP decoder and the ML decoder has linearly dependent columns in  with probability very close to one. The results of Lemmas \ref{lem:DisBinomial} and \ref{lem:wiretap1} give , which can be examined in the limit as . It is immediate that except for when  or ,  goes to one for all  pairs as  gets large. From Theorem \ref{thm:expectedValD}, if , then . Clearly  grows with ; therefore, the probability of security approaches one as  gets large. Since large  necessitates large  and , the same holds true for these blocklength parameters. Codes with blocklength  are deemed practical by today's standards. For  and for a carefully chosen  with size roughly 5000, then . This case is shown in Fig. \ref{fig:oneUserN5000}, where as expected, all nontrivial  pairs show .

\begin{figure}
\begin{center}
  \begin{lpic}{singleUserBeta1(0.6,0.6)}
    \lbl[t]{42,8;}
    \lbl[t]{100,8;}
    \lbl[t]{75,110; with  }
  \end{lpic}
\end{center}
  \caption{ when , as a function of the respective erasure probabilities in  and ,  and .} \label{fig:oneUser}
\end{figure}

\begin{figure}
\begin{center}
  \begin{lpic}{singleUserN5000(0.6,0.6)}
    \lbl[t]{42,8;}
    \lbl[t]{100,8;}
    \lbl[t]{75,110; with  }
  \end{lpic}
\end{center}
  \caption{ when , as a function of the respective erasure probabilities in  and ,  and .} \label{fig:oneUserN5000}
\end{figure}

But of course, a single degree of freedom is easily guessed in an attack. Let us examine the effects on security when  takes on a larger value. This perspective is provided in Fig. \ref{fig:oneUserN5000Beta50}, where  and  with . As can be seen in the figure, there exists a cutoff region, where  pairs within the plateau region will experience at least  degrees of freedom with probability very close to one, while pairs outside the region will have  with probability close to one. Owing to the severity of the cutoff, the threshold can be approximated by setting  in (\ref{eq:thm2}), and deriving a function of  and . This technique provides a unique threshold for each specific set of values for , , and .

\begin{figure}
\begin{center}
  \begin{lpic}{singleUserN5000Beta50(0.6,0.6)}
    \lbl[t]{42,8;}
    \lbl[t]{100,8;}
    \lbl[t]{75,110; with  and }
  \end{lpic}
\end{center}
  \caption{ when  and , as a function of the respective erasure probabilities in  and ,  and .} \label{fig:oneUserN5000Beta50}
\end{figure}

Finally, let us inspect the  according to Theorem \ref{thm:expectedValD} for this case.

This function grows linearly with  which is equal to  when . Thus, to drive  to a large number in practice, we simply must use a larger dimension in the encoder. Note that in the expectation the choice of  does not affect security; although,  allows  to be as large as possible, which provides more confidence that  by the law of large numbers (\cite{Grimmett_ProbBook}, pg. 193).

\subsection{Multiple Intended Receivers}
In this section, we move past the single user case, and address the more general broadcast channel originally presented in \cite{Cover72}. There is also a single eavesdropper with probability of an erased packet equal to  as before. This case allows us to understand the repercussions on security of having more than one user for which we allow feedback requests. We can characterize security using Lemma \ref{lem:DisBinomial} and Theorem \ref{thm:expectedValD} in the  user case by finding an expression for . Recall that  is the event that Eve receives a single transmitted packet as before. Let each user have an independent PEC with probability of erasure in the th user's channel as  for . The following lemma is necessary to obtain .
\begin{lemma}\label{lem:maxMusersGeomRVs}
 If  are independent geometrically distributed random variables with success parameters , and , then the probability mass function on  is given as
 
\end{lemma}
\begin{IEEEproof}
 The proof is omitted for the sake of brevity, but follows from an inductive assumption on .
\end{IEEEproof}

Armed with this lemma, we can obtain  for the broadcast channel case.
\begin{lemma}\label{thm:3}
 Using the broadcast channel with  independent legitimate receivers and an eavesdropper
 
 where the notation  means the summation traverses over all pairs  such that  and , and similarly for , etc.
\end{lemma}
\begin{IEEEproof}
Note that if the th user requests a single packet until it is received, and in each transmission it is received with probability , then the total number of times the user must request the packet is governed by a geometric random variable with success parameter  \cite{Grimmett_ProbBook}. Define  as the geometric random variables governing the total number of transmissions necessary for users , respectively, to obtain the packet error-free. Then, let .  governs the total number of transmissions necessary for all legitimate parties to receive the packet.

By Lemma \ref{lem:maxMusersGeomRVs}, we know that

because the success parameter for  is  for . Finally, we point out that

which implies that


With these pieces in place, we commence proving the lemma.

\end{IEEEproof}

\subsection{Collaborating Eavesdroppers}
In this section we consider the case with  eavesdroppers working together in order to obtain the cryptogram , each with a possibly unique probability of packet erasure . All are assumed to obtain packets through independent PECs. It is simpler to first consider a single legitimate user Bob with probability of packet erasure . Then the general result which assumes  friendly parties with  collaborating eavesdroppers comes easily.
\begin{lemma}\label{thm:5}
 For  eavesdroppers and a single legitimate receiver,
 
\end{lemma}
\begin{IEEEproof}
 The proof is straightforward if we note that collaborating eavesdroppers receive a single sent packet if at least one of them obtains the packet error-free. Let  be a geometric random variable with success parameter . This governs the number of transmissions for each packet. Therefore,
 
\end{IEEEproof}

This answer provides an easy bridge to an extremely general result.
\begin{corollary}\label{thm:6}
For the scenario with  intended parties and  eavesdroppers with similar notation as before,
 
 where .
\end{corollary}
\begin{IEEEproof}
 This proof is not included for the sake of brevity, but is nearly identical to the proof of Lemma \ref{thm:3} with slight alterations as indicated by the proof of Lemma \ref{thm:5} to allow for multiple eavesdroppers.
\end{IEEEproof}

\section{Cryptographic Security Enhancements}\label{sec:crypto}
The probabilistic security analysis in Section \ref{sec:analysis} assumes that attacks on the cryptography become more difficult or completely infeasible as  gets large. It remains to show the effect of the coding scheme on attacks of the cryptography. As an example, fast correlation attacks on stream ciphers are known to be possible, even if the cryptogram is error-prone. It was noted in \cite{Harrison09_ICC,Harrison09_ISIT,Harrison09_ITW} that specific attacks from \cite{Meier89} were made more difficult, and in some cases impossible due to error rates in the cryptogram beyond a certain threshold. Certainly as bit error rates approach 0.5 in the cryptogram, attacks of the fast-correlation variety break down completely.

Let  be the collection of punctured codewords obtained by Eve, where , and let  be the decoded codewords, where . Finally, define the implied block structure of Eve's decoder output as , where . Each channel-erased bit in  yields a degree of freedom in , and complete recovery of  requires that  bits in  be guessed correctly. If a guess is incorrect, there will be at least as many errors in  as the minimum distance of the LDPC code. The descrambling process in (\ref{eq:inverseScramble}) magnifies any errors in  to an expected bit error rate of 0.5 in . Therefore, since all guesses are equally likely, a brute-force attack on  bits must be accomplished to obtain each .

Simulations of the end-to-end encoder and decoder clearly indicate the expected bit error rate in  of 0.5 for an incorrect guess. Simulations were performed using the irregular LDPC code of Example \ref{ex:punct} with  and . Puncturing patterns used were such that  bits.  was formed randomly by setting roughly half of the  entries equal to one until such a matrix was invertible using the LU decomposition in GF(2). Let  be the number of bits in Eve's guess which are incorrect. We offer simulation results for  1, 2, 3, 4, 5, 10, 15, 20, 25, 30, 40, 50, 60, 70, 80, 90, 100, 200, 300, and 400 in Fig. \ref{fig:cryptoErrorRates}. Each  value was tested 300 times on both the MP and ML decoder, while a new puncturing pattern  was generated every 10 experiments, and a new code from the ensemble was selected every 30 experiments. All tests produced error rates in between 0.414 and 0.578 in , while the mean depicted a 0.5002 bit error rate with no noticeable difference between MP and ML decoders, or between  values, as Fig. \ref{fig:cryptoErrorRates} indicates.

\begin{figure}
\begin{center}
  \begin{lpic}{cryptoErrorRates(0.6,0.6)}
    \lbl[t]{75,5;}
    \lbl[t]{75,113; Error propagation for incorrect guesses}
    \lbl[l]{5,37,90;Error rate in }
  \end{lpic}
\end{center}
  \caption{The simulated error rates in Eve's decoded cryptogram  when  errors are made in guessing bit values for  degrees of freedom in Eve's received codewords.} \label{fig:cryptoErrorRates}
\end{figure}

These results imply that unless  bits are guessed exactly, the cryptography must be attacked with an average bit error rate of 0.5 in . We can certainly expect such an attack to fail for fast correlation attacks on stream ciphers, but the notion that any attack on a cryptosystem could absorb such error rates and still succeed is obviously shortsighted. However, since an attack could feasibly be staged using a single block of , we will only guarantee failure of the attack if every block in  is incorrect. Using similar logic, it can be said that if an attack would succeed using the error-free ciphertext , then it may fail even if a single block in  is in error.
\begin{theorem}
 Define the complexity of a cryptographic attack to be . Let  be the degrees of freedom of each of  blocks in . Then the expected complexity  of a successful attack on the system is bounded as
 
\end{theorem}
\begin{IEEEproof}
 By Corollary \ref{lem:security} each codeword in  has the same number of degrees of freedom. Thus,  is the average number of bits that must be guessed in each of  punctured codewords in . Assume that an attacker guesses bit patterns on all codewords in  simultaneously. The correct bit patterns of the channel-erased bits in the  codewords  are uniformly distributed over  possibilities in each block. The lower bound is formulated by the expected number of guesses until at least one of  codewords is found. Model the correct bit patterns in the  codewords as i.i.d. discrete uniform random variables on , say . Without loss of generality, assume that an attacker begins by guessing zero for each  and proceeds in an orderly fashion. Then, the expected number of guesses until at least one is correct is given by . Thus, we calculate 
 
 Now, solve for  in  for a close bound on the expectation to get the lower bound.

 The upper bound is calculated similarly, but we assume that \emph{all} patterns must be guessed in order to guarantee success, therefore, the bound is given by finding the  that solves .
\end{IEEEproof}
As a check on these bounds, for  we expect  guesses on average for a successful attack. In this case, both bounds meet at , as expected. Although these bounds are helpful, when  the bounds are not as tight, and thus provide limited insight into the true increase in complexity of the attack. More than likely, an attack will require at least a certain number of consecutive blocks in  to execute successfully \cite{Meier89}. Clearly a 0.5 bit error rate in any block would destroy an attack with these requirements. Therefore, the upper bound in (\ref{eq:lastTheorem}) serves as a good approximation to the expected amount of work necessary to complete the attack, with  being set by the attack specifications. Thus we see, that our system appends a multiplier which is exponential in  to the complexity of a cryptographic attack through practical physical-layer security.

\section{Conclusions}\label{sec:conclusion}
In conclusion, we have presented the security metric of degrees of freedom  in an eavesdropper's received codewords, and applied this metric to a physical-layer coding scheme to show cryptographic security enhancements due to channel coding. The coding scheme relies on the nature of independent packet erasure channels and ARQ to provide secrecy and reliability, respectively. End-to-end details of the encoder and decoder were provided. Design criteria were specified to maximize  in a maximum-likelihood attack as well as a message-passing attack. This involved security performance comparisons of LDPC codes with varying degree distributions, where irregular codes were shown to outperform regular codes in maximizing . The expected value of  was also shown to be equal to  in our encoder. Probabilistic security results were obtained and made general so as to apply to multiple receivers and multiple collaborative attackers. Simulation results were provided which show that unless an attacker can guess  symbols in the received data correctly, the system yields a bit error rate of 0.5 in the cryptogram, thus necessitating a brute-force attack on  bits for each codeword. The end result on the expected increase in attack complexity on the cryptosystem due to our scheme is a multiplier which is exponential in . The system was shown to provide cryptographic security enhancement, even when eavesdroppers have an advantage over legitimate receivers in signal quality.



\bibliographystyle{ieeetran}
\bibliography{references_StopSetsJournal}

\ifCLASSOPTIONpeerreview
\pagebreak
\listoffigures
\listoftables
\fi

\end{document}
