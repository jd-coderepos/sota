\documentclass{ws-ijmpc}
\usepackage[T1]{fontenc}
\usepackage[latin9]{inputenc}
\synctex=-1
\usepackage{array}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage[numbers]{natbib}

\makeatletter

\providecommand{\tabularnewline}{\\}

\usepackage{amsmath}

\usepackage{shuffle}
\usepackage{enumerate}
\DeclareMathOperator{\dist}{dist}
\DeclareMathOperator{\reg}{reg}
\DeclareMathOperator{\Ndist}{N}
\DeclareMathOperator{\Rd}{\mathbb{R}^2}
\DeclareMathOperator{\rd}{\mathbb{R}^2}
\DeclareMathOperator{\exi}{\exists}
\DeclareMathOperator{\all}{\forall}
\DeclareMathOperator{\real}{\mathbb{R}}
\DeclareMathOperator{\din}{in}
\DeclareMathOperator{\dout}{out}
\DeclareMathOperator{\spa}{Span}
\DeclareMathOperator{\M}{M}
\DeclareMathOperator{\Eq}{Eq}
\DeclareMathOperator{\D}{D}
\DeclareMathOperator{\DC}{D_C}
\DeclareMathOperator{\Z}{Z}
\DeclareMathOperator{\zl}{l}
\DeclareMathOperator{\m}{m}
\DeclareMathOperator{\SW}{SW}
\DeclareMathOperator{\PARTS}{PARTS}
\DeclareMathOperator{\LINKS}{LINKS}
\DeclareMathOperator{\adr}{adr}
\DeclareMathOperator{\disj}{disj}
\DeclareMathOperator{\C}{C}
\DeclareMathOperator{\CS}{CS}
\DeclareMathOperator{\CSmax}{CSmax}
\DeclareMathOperator{\CSmin}{CSmin}
\DeclareMathOperator{\B}{B}
\DeclareMathOperator{\Y}{Y}

\makeatother

\begin{document}
\title{\uppercase{On Basic Properties of Jumping Finite Automata}\footnote{Research supported by the Czech Science Foundation grant GA14-10799S and the GAUK grant No. 52215.}}

\author{\uppercase{Vojt\v{e}ch Vorel}}
\address{Department of Theoretical Computer Science and Mathematical Logic,\\
Charles University,\\ Malostransk\'{e} n\'{a}m. 25, Prague, Czech Republic\\ vorel@ktiml.mff.cuni.cz}

\maketitle

\begin{abstract} We complete the initial study of jumping finite automata, which was started in a former article of Meduna and Zemek \citep{athMED1}. The open questions about basic closure properties are solved. Besides this, we correct erroneous results presented in the article. Finally, we point out important relations between jumping finite automata and some other models studied in the literature. \end{abstract}

\keywords{Jumping Finite Automata, Insertion-Deletion Systems}  


\section{Introduction}

In 2012, Meduna and Zemek \citep{athMED1} introduced \emph{general
jumping finite automata} as a model of discontinuous information processing.
A general jumping finite automaton (GJFA) is described by a finite
set  of states, a finite alphabet , a finite set 
of \emph{rules }from , an initial state
, and a set  of final states. In a step of
the computation, the automaton switches from a state  to a state
 using a rule  and deletes a factor
equal to  from any part of the input word. The choices of the
rule used and of the factor deleted are made nondeterministically.
A word can be accepted only if there is a computation resulting in
the empty word.

There is an infinite hierarchy of GJFA according to the maximum length
of factor deleted in a single step -- a GJFA is of \emph{degree} 
if  for each . A GJFA
of degree  is called a jumping finite automaton\emph{ }(JFA).
Bold symbols  and  denote the classes
of languages accepted by these types of automata. 

The present paper contains the following contributions:
\begin{romanlist}
\item We correct erroneous claims from \citep{athMED1} and \citep{athMED1book}
about the closure properties of the class  -- in fact
it is neither closed under homomorphism and under inverse homomorphism.
\item We answer the open questions about closure properties of 
formulated in these two publications. Specifically, we disprove the
closure under shuffle, Kleene star, and Kleene plus, and prove the
closure under reversal.
\item We relate the new models with the existing ones, pointing out that
the expressive power of GJFA is equivalent to a basic type of graph-controlled
insertion systems, and that the intersection emptiness of GJFA is
undecidable.
\end{romanlist}

\section{Preliminaries}

As described above, a GJFA is a quintuple .
The following formal description of the computation performed by a
GJFA was introduced in \citep{athMED1}.
\begin{definition}
Any string from the language  is called a
\emph{configuration }of . For  and ,
we write 

if  and . By 
we denote the reflexive-transitive closure of the binary relation
 over configurations, i.e. 
for configurations  of  if and only if
 or 

for some configurations  of
 with , ,
. Finally,

is the language accepted by . If  is fixed, we write just
 and .
\end{definition}
The placement of the state symbol  in a configuration 
marks the position of an imaginary tape head. Note that this information
is redundant -- the head is allowed to move anywhere in each step. 

In the present paper we heavily use the natural notion of sequential
insertion, as it was described e.g. in \citep{reaHAU1} and \citep{athKAR2}:
\begin{definition}
Let  be languages. The \emph{insertion }of
 to  is 

More generally, for each  we denote

where  stands for . In expressions with 
and , a singleton set  may be
replaced by . A chain 
of insertions is evaluated from the left, e.g. 
means . According
to \citep{reaEHR2},  is a\emph{ unitary language}
if  for  and finite .
\end{definition}
Next, we fix additional notation that turns out to be very useful
in our proofs. The notions of \emph{paths }and \emph{labels }naturally
correspond to graphical representations of GJFA, where vertices stand
for states and labeled directed edges stand for rules.
\begin{definition}
\label{def: A-path}Let  be a GJFA.
Each sequence of the form 

with  is a \emph{path }from  to .
The path is \emph{accepting }if  and . The
\emph{labeling }of the path is the sequence 
of words from .
\end{definition}
The lemma below is very natural, its proof only has to deal with formal
combination of different approaches. The symbol  stands
for the empty word.


\begin{lemma}
\label{conf vs task}Let  be a GJFA.
For each  and  the following are equivalent:
\begin{romanlist}
\item \label{enu:conf}
for  with 
and .
\item \label{enu:path} and , or 

where  is a labeling of a path from 
to , .
\end{romanlist}
\end{lemma}
\begin{proof}
First, assume that (\ref{enu:conf}) holds and denote ,
. If , then
 and , so we are done. Otherwise, 
for some configurations  of
 with , ,
. We use induction by . 

If , then  and
according to the definition of , there are
 such that ,
, , , and .
Thus,  and  is a path
from  to .

If , then 
for some configuration . Denote .
According to the induction assumption applied to  we
obtain a path denoted by 

with , , , and .
To conclude the proof it is enough to show that 
and  for , which both follow from
 according to the above
analysis of the case . 

Second, let (\ref{enu:path}) hold. If  and , then 
for , , and . Otherwise,
we fix the path 

from  to , , and use induction by .
Denote . 

Let . We have  and .
According to the definition of , there are 
such that  and . Obviously, 
follows from the definition of . As 
is a special case of , we are done. 

Let . From (\ref{eq: comp on path}) and the definition of
 it follows that 

for some  with 

Denote . According to the induction assumption applied to
 we obtain 

for some  with 
and .

It remains to show that 
for some  with . Due to (\ref{eq: prv})
there are  such that  and
. From the definition of , together
with  and 
it follows that 

We conclude by denoting  and .
\end{proof}

\begin{corollary}
\label{lem: paths vs accept}Let 
be a GJFA and . Then 
if and only if  and , or 

where  is a labeling of an accepting path
in , .\end{corollary}
\begin{proof}
If , then  for 
with  and . We apply the forward
implication of Lemma \ref{conf vs task} to , , , and
. On the other hand, an accepting path ends in some 
and we apply the backward implication of Lemma \ref{conf vs task}
to , , , and .
\end{proof}
The above corollary suggests a generative approach to GJFA -- the
computation of a GJFA may be equivalently described in terms of inserting
factors instead of deleting them. A word is accepted by a GJFA if
and only if it can be composed by inserting factors to the empty word
according to labels of an accepting path. This characterization of
 will be used very frequently throughout
the paper, so we omit explicit referring to Corollary \ref{lem: paths vs accept}.

Next, we give two simple lemmas that imply the membership in 
for each language that can be described using finite languages and
insertions. 
\begin{lemma}
\label{fin sub GJFA}Each finite language 
lies in .\end{lemma}
\begin{proof}
The language  is accepted by the two-state GJFA  with 

Indeed, all the accepting paths in  are of length  and their
labels are exactly the words from . 
\end{proof}

\begin{lemma}
\label{GJFA closed under <- and <-hv}Let 
lie in  and  be finite. Then
\begin{romanlist}
\item  lies in  and
\item  lies in . 
\end{romanlist}
\end{lemma}
\begin{proof}
Let  be a GJFA
recognizing . To obtain  with ,
we put 

First, let , which means 
for  and . As ,
we have  and , or 

for some accepting path  in  labeled by ,
. In the case of  and , we
have  and  due to .
Otherwise, observe that  is
an accepting path in  and  lies in

which matches the labeling of .
Thus, .

Second, let , whence 
and , or 

where  is a labeling of an accepting path
in , . As , we assume the second case.
We have  for some 

According to the construction of ,  and 
is a labeling of an accepting path in . Thus, 
and hence .

To obtain  with ,
we put 

First, let , which means 
for , .
\begin{romanlist}
\item If , then  and we show that .
Indeed, due to Corollary \ref{lem: paths vs accept} for each 
it holds that  and , or 

for some accepting path  in  labeled by ,
. If  and , then 
due to Corollary \ref{lem: paths vs accept} applied to the path 
together with . Otherwise, 
due to Corollary \ref{lem: paths vs accept} applied to the path 
together with


\item Let . According to the definition of , we
have 

where  and . As 
and , there is an accepting path 
in  labeled by  with

It remains to observe that 

is an accepting path in  and 


\end{romanlist}

\noindent Second, let , whence
 and , or 

such that there is an accepting path 

in , . As , we assume the second case.
According to the construction of , there is a unique 
such that .
Denote ,
where  is labeled by words from  and 
is an accepting path in . Both  and 
may stand for empty strings, their lengths are  and  respectively.
We get

where

Together, .

\end{proof}
Let us give a few examples of GJFA languages that are used later in
this paper and follow easily from the above lemmas. Note that a GJFA
over an alphabet  can be seen as operating over any alphabet
. 
\begin{example}
\label{The-following-languages}The following languages lie in :
\begin{romanlist}
\item The trivial language  over
an arbitrary .
\item The language  for 
over an arbitrary .
\item The Dyck language  over .
We have .
\item Any semi-Dyck language  over .
We have . 
\item Any unitary language.
\end{romanlist}
\end{example}
However, there are GJFA languages that cannot be simply obtained from
finite languages by applying Lemma \ref{GJFA closed under <- and <-hv},
such as the following classical language that is not context-free
and lies even in . By  we denote
the number of occurrences of a letter  in a word .
\begin{example}
The JFA  with

accepts the language 
over .
\end{example}
The above example shows that the class  is not a subclass
of context-free languages, but it was pointed out in \citep{athMED1}
that each GJFA language is context-sensitive. The class 
does not stick to classical measures of expressive power -- in the
next section we give examples of regular languages that do not lie
in . As for JFA languages, in \citep{athMED1book}
the authors show that a language lies in  if and only
if it is equal to the permutation closure of a regular language.


\section{A Necessary Condition for Membership in GJFA}

In order to formulate our main tools for disproving membership in
GJFA, the following technical notions remain to be defined.
\begin{definition}
A language  is a \emph{composition }if 
or 

for some , . A composition
 is of \emph{degree}  if 
or for each .
For each , let  denote the class of languages
 that can be written as 

where  is any (possibly infinite) set of compositions
of degree . We also denote .
\end{definition}


The class\textbf{  }itself does not seem to be of practical
importance -- we use the membership in  only as a necessary
condition for membership in . The acronym \textbf{UC}
stands for \emph{union of compositions}\@.
\begin{lemma}
\label{Lem:neces zob}.\end{lemma}
\begin{proof}
Let  be a GJFA. Let 
be the set of all accepting paths in . According to Corollary
\ref{lem: paths vs accept}, we have 

where  is the
labeling of , . As 
is a composition, we have ,
where .
\end{proof}
The following lemma deals with the language ,
which serves as a canonical non-GJFA language in the proofs of our
main results.
\begin{lemma}
\label{lem:gjfa ab star}The language 
does not lie in .\end{lemma}
\begin{proof}
Assume for a contradiction that . Due to Lemma
\ref{Lem:neces zob},  and thus 
for some . If , observe that ,
which is a contradiction. Otherwise, fix .
According to the definition of  ,  lies in a
composition  of the form

of degree . Due to , there exists the least 
with  and . Moreover,

for suitable  and . Thus,  for .
As , at least one of the following cases holds:
\begin{romanlist}
\item Assume that  and write .
If  starts by , we have .
If  starts by , we have .
\item Assume that  and write .
If  starts by , we have .
If  starts by , we have .
\end{romanlist}

In each case,  contains a word having some of the factors ,
. Thus , which is a contradiction. Informally,
each  coming from a language  must contain
a factor  of length at most  that can be inserted to any other
place in  such that the result stays in . In the
case of  this property fails.

\end{proof}

\section{Closure Properties of GJFA Languages}

The table below lists various unary and binary operators on languages.
The symbols  tell that a class is closed or is not closed under
an operator, respectively. A similar table was presented in \citep{athMED1,athMED1book},
containing several question marks. In this section we complete and
correct these results. The symbol  marks answers to
open questions and the symbol  marks corrections.

\begin{center}
\begin{tabular}{|l|>{\raggedleft}p{10mm}>{\centering}p{3mm}|>{\centering}p{17mm}|}
\cline{2-4} 
\multicolumn{1}{l|}{} & \multicolumn{2}{c|}{} & \tabularnewline
\hline 
Endmarking &  &  & \tabularnewline
\hline 
Concatenation &  &  & \tabularnewline
\hline 
Shuffle &  &  & \tabularnewline
\hline 
Union &  &  & \tabularnewline
\hline 
Complement &  &  & \tabularnewline
\hline 
Intersection &  &  & \tabularnewline
\hline 
Int. with regular languages &  &  & \tabularnewline
\hline 
Kleene star &  &  & \tabularnewline
\hline 
Kleene plus &  &  & \tabularnewline
\hline 
Reversal &  &  & \tabularnewline
\hline 
Substitution &  &  & \tabularnewline
\hline 
Regular substitution &  &  & \tabularnewline
\hline 
Finite substitution &  &  & \tabularnewline
\hline 
Homomorphism &  &  & \tabularnewline
\hline 
-free homomorphism &  &  & \tabularnewline
\hline 
Inverse homomorphism &  &  & \tabularnewline
\hline 
\end{tabular}\medskip{}

\par\end{center}

Before proving the new results, let us deal with the closure under
intersection. The authors of \citep{athMED1,athMED1book} claim that
the theorem below follows from an immediate application of De Morgan's
laws to the results about union and complement. We find this argument
invalid and present an explicit proof of the claim.
\begin{theorem}
\label{inters} is not closed under intersection.\end{theorem}
\begin{proof}
Let  and 
for 

as depicted in Figure \ref{fig:The-GJFA M inters}. For each 
there is exactly one accepting path of length  in . According
to Corollary \ref{lem: paths vs accept}, we have 

where  and 
for . We show that 

where  is the Dyck language from Example \ref{The-following-languages},
and  does not lie in\textbf{
} due to Lemma \ref{lem:gjfa ab star}. The backward
inclusion is easy. As for the forward one, we have 

so it is enough to verify that 
for each . The case  is trivial since .
In order to continue inductively, fix . For any ,
we have  for .
From  it follows that ,
, and thus, . By the induction
assumption, . Hence

or .
The first case implies , which is a contradiction, and
the second case implies . 
\end{proof}
The next theorem shows that some of our results actually follow very
easily from Lemma \ref{lem:gjfa ab star}, which claims that .
Theorems \ref{inv hom} and \ref{thm: GJFA unary shuffle} provide
special counter-examples for the closure under inverse homomorphism
and shuffle.
\begin{figure}
\begin{centering}
\includegraphics{jump_pictures/inters}
\par\end{centering}

\caption{\label{fig:The-GJFA M inters}The GJFA  with }
\end{figure}
\begin{figure}
\begin{centering}
\includegraphics{jump_pictures/inhom}
\par\end{centering}

\caption{\label{fig:The-GJFA M}The GJFA  with }
\end{figure}

\begin{theorem}
 is not closed under:\end{theorem}
\begin{romanlist}
\item Kleene star,
\item Kleene plus,
\item -free homomorphism,
\item homomorphism,
\item finite substitution.\end{romanlist}
\begin{proof}
We have  and 
due to Lemma \ref{lem:gjfa ab star}. As  is closed
under union,  as well.
As for -free homomorphism, consider 
with . We have 
and .
Trivially,  is also a general homomorphism and a finite
substitution.\end{proof}
\begin{theorem}
\label{inv hom} is not closed under inverse homomorphism. \end{theorem}
\begin{proof}
Let 
and 

see Figure \ref{fig:The-GJFA M}. Let .
Observe that  where 
is the semi-Dyck language with two types of brackets: 
and . According to Example~\ref{The-following-languages},
. Let 
be defined as

and let us claim that 

which is not a GJFA language according to Lemma \ref{lem:gjfa ab star}.

The backward inclusion is easy -- for each 
with  we have 
if , and  if . In
both cases,  and thus . 

As for the forward inclusion, take any 
and fix  with . As ,
we have  for  and .
As ,  starts with 
or  and ends with  or . Because
 cannot start with  nor 
and end  cannot end with  nor , we
have  and .
Denote  for .
As , , , and

where

None of the factors  and 
can occur in . It follows that  and for each 
it holds that 

which together implies .
\end{proof}
For languages , a word 
belongs to  if and only if there
are words 
such that , ,
and . Furthermore, we denote
, where
 is the reversal of .
\begin{theorem}
\label{thm: GJFA unary shuffle} is not closed under
shuffle.\end{theorem}
\begin{proof}
Again, we fix 
and consider the semi-Dyck language  over
. We claim that .
According to Lemma \ref{Lem:neces zob} we assume for a contradiction
that 
for . Denote .
The word  lies in a composition  of degree  having the
form , so  for .
Clearly, there is  such that at
least one of the following assumptions is fulfilled:
\begin{romanlist}
\item Assume that  contains . As , it cannot
contain . The word  lies in  but
it contains an occurrence of  with no occurrence of 
on the right, so it does not lie in .
\item Assume that  contains . As ,
it cannot contain . The word  lies in  but it
contains an occurrence of  with no occurrence 
on the left, so it does not lie in .
\end{romanlist}
\end{proof}
\begin{lemma}
\label{rev ins}For each  it holds that .\end{lemma}
\begin{proof}
First, let , which means
 for  and .
We have ,
while  and .
Thus, . Second, let
, which means 
for  and . Thus,
 and .
As ,
it follows that  and thus . \end{proof}
\begin{theorem}
\label{thm:gjfa reversal} is closed under reversal.\end{theorem}
\begin{proof}
For arbitrary GJFA , we define a GJFA
 as follows: 

Trivially, 
for each GJFA . We claim that 

which means that  is always
a GJFA language.

First, we show .
Let , i.e. ,
which means that  and , or 

where  is a labeling of an accepting path
in , . If  and , it
follows easily that .
Otherwise, observe that 

according to Lemma \ref{rev ins}, and 
is a labeling of an accepting path in .
Together, . 

Second, we show .
According to the first inclusion applied to 
instead of , it holds that


which is trivially equivalent to .
\end{proof}

\section{\label{sec:Relations-to-Other}Relations to the Other Models}

An \emph{insertion-deletion system}, as introduced in \citep{reaPAU4},
generates words from a finite set of axioms by nondeterministic inserting
and deleting factors according to insertion rules and deletion rules.
An insertion or deletion rule may specify left and right contexts
that are needed to perform the operation. Such a system is an \emph{insertion
system }if there are no deletion rules. The language accepted by an
insertion system contains all the words that can be obtained from
the axioms using the insertion rules. Generally, an insertion-deletion
system may use nonterminals, but this does not make sense for insertion
systems.

For each , the term  denotes
the class of languages accepted by insertion systems where each insertion
rule inserts a factor of length at most  and depends on left and
right contexts of lengths at most  respectively. The symbol
 says that a parameter is not bounded. For example, 
contains exactly finite unions of unitary languages (one unitary language
for each axiom).

In \citep{reaALH1} and \citep{reaVER1}, the authors introduce \emph{graph-controlled
insertion systems}. Such systems may be described by a set of axioms
and a directed multigraph with edges labeled by insertion rules. The
vertices are called \emph{components}. An initial component and a
final component are specified. A graph-controlled insertion system
accepts a word if and only if the word is obtained from an axiom using
a sequence of insertion rules that forms a path from the initial component
to the final component.

For each , the term 
denotes the class of languages accepted by graph-regulated insertion
systems with at most  components where the properties of insertion
rules are bounded by  as above. It turns out that\emph{ 

}Indeed, with the generative approach to GJFA in mind, a GJFA may
be transformed to a graph-regulated insertion system with the same
structure, using only the axiom  and insertion rules with
empty contexts. For the backward inclusion we just encode the axioms
to rules specifying that the computation ends by deleting an axiom.

Other related models were introduced in 1980's in the scope of Galiukschov
semicontextual grammars, see \citep{reaPAU6}. For , a \emph{semicontextual
grammar of degree  without appearance checking} is actually an
insertion system with left and right contexts of length at most .
Moreover, such grammar may involve a \emph{regular control}. In this
case, a regular language  over the alphabet of insertion rules
is specified, and a string is accepted only if it can be obtained
from an axiom using a sequence of insertion rules that belongs to
. The symbol  denotes the class of languages
accepted by \emph{regular control semicontextual grammars of degree
 without appearance checking}. The equivalence of 
and 
is immediate. Thus 



Finally, an interesting result follows from the fact that each unitary
language lies in . According the main result of the
Haussler's article \citep{reaHAU1}, for a given a prefix-disjoint
instance of the Post correspondence problem (PCP)\footnote{We do not introduce PCP nor prefix-disjoint instances in this paper.} over a range alphabet , one can algorithmically construct
sets  over an alphabet  with 
such that the PCP instance is positive if and only if the intersection
of  and  contains
a non-empty string. For given  and , it is trivial to construct
two GJFA over  accepting 
and  respectively. On the other hand, PCP can be easily reduced
to a binary range alphabet with preserving prefix-disjointness (see,
e.g., \citep{athSAL1}). Together, we get the following:
\begin{theorem}
Given GJFA  over an -letter alphabet, it is undecidable
whether .
\end{theorem}

\section{Conclusions}

We have completed the list of closure properties of the class 
under classical language operators. Besides of that, we have pointed
out that the class  can be put into the frameworks
of graph-controlled insertion-deletion systems and Galiukschov semicontextual
grammars, and we have referred to a former result that implies undecidability
of intersection emptiness for GJFA languages.

It is a task for future research to provide really alternative descriptions
of the class . There also remain open questions about
decidability, specifically regarding equivalence, universality, inclusion,
and regularity of GJFA, see \citep{athMED1book}.

\bibliographystyle{C:/Users/Vojta/Desktop/SYNCHRO2/ACT/ijfcs/ws-ijfcs}
\bibliography{C:/Users/Vojta/Desktop/SYNCHRO2/bib/ruco}

\end{document}
