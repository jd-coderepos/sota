\documentclass [10pt]{article}


\usepackage[utf8]{inputenc}
\usepackage{fullpage}
\usepackage{amsmath, cite, amssymb, graphicx}


\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\newtheorem{corollary}{Corollary}
\newtheorem{definition}{Definition}
\newtheorem{prop}{Proposition}
\newtheorem{asump}{Assumption}

\newcommand{\qed}{\hfill\ensuremath{\Box}\medskip\\\noindent}
\newenvironment{proof}{\noindent\emph{Proof. }}{}


\newcommand{\ceil}[1]{\left\lceil{#1}\right\rceil}
\newcommand{\floor}[1]{\left\lfloor{#1}\right\rfloor}
\renewcommand{\angle}[1]{\langle{#1}\rangle}

\newcommand{\pre}{\ensuremath{\mathrm{pre}}}
\newcommand{\height}{\ensuremath{\mathrm{height}}}
\newcommand{\ldepth}{\ensuremath{\mathrm{ldepth}}}
\newcommand{\size}{\ensuremath{\mathrm{size}}}
\newcommand{\depth}{\ensuremath{\mathrm{depth}}}


\newcommand{\LA}{\ensuremath{\mathrm{LA}}}
\newcommand{\NCA}{\ensuremath{\mathrm{NCA}}}
\newcommand{\LCE}{\ensuremath{\mathrm{LCE}}}
\newcommand{\LCEPP}{\ensuremath{\mathrm{LCE}_{\mathit{PP}}}}
\newcommand{\LCEPT}{\ensuremath{\mathrm{LCE}_{\mathit{PT}}}}
\newcommand{\LCETT}{\ensuremath{\mathrm{LCE}_{\mathit{TT}}}}


\newcommand{\sort}{\ensuremath{\mathrm{sort}}}
\newcommand{\llog}{\ensuremath{\log\!\log}}
\newcommand{\apex}[1]{\ensuremath{\mathrm{apex}(#1)}}
\newcommand{\HP}{\ensuremath{\mathrm{HP}}}
\newcommand{\lab}{\ensuremath{\mathrm{label}}}
\newcommand{\dist}{\ensuremath{\mathrm{dist}}}

\newcommand{\polylog}{\text{\hspace{1mm}polylog}}

\usepackage[dvipsnames,usenames]{color}
\usepackage[colorlinks=true,urlcolor=Blue,citecolor=Green,linkcolor=BrickRed]{hyperref}
\urlstyle{same}

\begin{document}
\title{Longest Common Extensions in Trees\footnote{A preliminary version of this paper appeared in the Proceedings of the 26th Annual symposium on Combinatorial Pattern Matching, 2015.}}
\author{Philip Bille\thanks{Partially supported by the Danish Research Council (DFF – 4005-00267, DFF – 1323-00178) and the Advanced Technology Foundation.} \\  \href{mailto:phbi@dtu.dk}{phbi@dtu.dk} \and Pawe{\l} Gawrychowski\thanks{Work done while the author held a post-doctoral position
at the Warsaw Center of Mathematics and Computer Science.}\\ \href{mailto:gawry@mimuw.edu.pl}{gawry@mimuw.edu.pl} \and Inge Li G{\o}rtz\\
 \href{mailto:inge@dtu.dk}{inge@dtu.dk}    \and  
 Gad M. Landau\thanks{Partially supported by the National Science Foundation
Award 0904246, Israel Science Foundation grant  571/14,
Grant No. 2008217 from the United States-Israel
Binational Science Foundation (BSF) and DFG.} \\  \href{mailto:landau@cs.haifa.ac.il}{landau@cs.haifa.ac.il}   
\and Oren Weimann\thanks{Partially supported by  the Israel Science Foundation grant 794/13.} \\  \href{mailto:oren@cs.haifa.ac.il}{oren@cs.haifa.ac.il} }
\date{}

\maketitle


\begin{abstract}

The longest common extension (LCE) of two indices in a string is the length of the longest identical substrings starting at these two indices. The LCE problem asks to preprocess a string into a compact data structure that supports fast LCE queries.
 
In this paper we generalize the LCE problem to trees and suggest a few applications of LCE in trees to tries and XML databases. Given a labeled and rooted tree  of size , the goal is to preprocess  into a compact data structure that support the following LCE queries between subpaths and subtrees in . Let  , , , and  be nodes of  such that  and  are descendants of  and  respectively.

\begin{itemize}
\item : (path-path ) return the longest common  prefix of the paths  and .
\item : (path-tree ) return maximal path-path LCE of the path  and any path from  to a descendant leaf.
\item : (tree-tree ) return a maximal path-path LCE of any pair of paths from  and  to  descendant leaves.
\end{itemize}
We present the first non-trivial bounds for supporting these queries. For  queries, we present a linear-space solution with  query time. For   queries, we present a linear-space solution with  query time, and complement this with a lower bound showing that any path-tree LCE structure of size  must necessarily
use  time to answer queries.
For  queries, we present a time-space trade-off, that given any parameter , , leads to an  space and  query-time solution (all of these bounds hold on a standard unit-cost RAM model with logarithmic word size). This is complemented with a reduction from the set intersection problem implying that a fast linear space solution is not likely to exist.  \\\\
{\bf Keywords.}
longest common prefix,
suffix tree of a tree,
pattern matching in trees.

\end{abstract}

\section{Introduction}
Given a string , the \emph{longest common extension} (LCE) of two indices is the length of the longest identical substring starting at these indices. The \emph{longest common extension problem} (LCE problem) is to preprocess  into a compact data structure supporting fast LCE queries. The LCE problem is a well-studied basic primitive~\cite{BGK2012,INL2010,BGSV2014, BGKLV2015, FH2006} with a wide range of applications in problems  such as approximate string matching, finding exact and approximate tandem repeats, and  finding palindromes~\cite{ALP2004,CH2002, LV1989, Myers1986,GS2004,LSS2001, LMS1998, ML1984}. The classic textbook solution to the LCE problem on strings combines a suffix tree with a nearest common ancestor (NCA) data structure leading to a linear space and constant query-time solution~\cite{Gusfield1997}. 


In this paper we study generalizations of the LCE problem to trees. The goal is to preprocess an edge-labeled, rooted tree  to support the various  queries between paths in . Here a path starts at a node  and ends at a descendant of , and the LCEs are on the strings obtained by concatenating the characters on the edges of the path from top to bottom (each edge contains a single character). We consider path-path LCE queries between two specified paths in , path-tree LCE queries defined as the maximal path-path LCE of a given path and \emph{any} path starting at a given node, and tree-tree LCE queries defined as the maximal path-path LCE between \emph{any} pair of paths starting from two given nodes.   We next define these problems formally. 


\paragraph{\bf Tree LCE Problems.}
Let  be an edge-labeled, rooted tree with  nodes. 
We denote the subtree rooted at a node  by , and  given nodes  and  such that  is in  the path going down from  to  is denoted . A \emph{path prefix} of  is any subpath  such that  is on the path . Two paths  and  \emph{match} if  concatenating the labels of all edges in the paths gives the same string. Given nodes   such that  and nodes  such that   define the following queries:
\begin{itemize}
\item : (path-path ) return the longest common matching prefix of the paths  and .
\item : (path-tree ) return the maximal path-path LCE of the path  and any path from  to a descendant leaf.
\item : (tree-tree ) return a maximal path-path LCE of any pair of paths from  and  to  descendant leaves.
\end{itemize}
The queries are illustrated in Fig.~\ref{fig:LCEexample}. We assume that the output of the queries is reported compactly as the endpoint(s) of the . This allows us to report the shared path in constant time. Furthermore, we will assume w.l.o.g. that for each node  in , all the edge-labels to children of   are distinct. If this is not the case, then we can merge all identical edges of a node to its children in linear time, without affecting the result of all the above  queries. 


\begin{figure}[t] \centering
   \includegraphics[scale=.55]{LCEexample} 
   \caption{LCE in trees.  is the path ''ab'',  is the path ''abc'', and  is the path ''acad''.}
   \label{fig:LCEexample}
\end{figure}
We note that the direction of the paths in  is important for the LCE queries. In the above LCE queries, the paths start from a node and go downwards. If we instead consider paths from a node going upwards towards the root of , the problem is easier and can be solved in linear space and constant query-time by combining Breslauer's suffix tree of a tree~\cite{Breslauer1998} with a nearest common ancestor (NCA) data structure~\cite{HT1984}.






\paragraph{\bf Our Results.}
First consider the  and  problems. To answer an  query, a straightforward solution is to traverse both paths in parallel-top down. Similarly, to answer an  query we can traverse   top-down while traversing the matching path from  (recall that all edges to a child are distinct and hence the longest matching path is unique). This approach leads to a linear-space  solution with  query-time  to both problems, where  is the height of . Note that for worst-case trees we have that . 

We show the following results. For  we give a linear  space and  query-time solution. For    we give a linear   space and  query-time solution, and complement this with a lower bound stating that any   solution using  space must necessarily
have  query time.
 


Next consider the  problem. Here, the simple top down traversal does not  work and it seems that substantially different ideas are needed. We first show a reduction from the \emph{set-intersection problem}, i.e., preprocessing a family of sets of total size  to support disjointness queries between any pairs of sets. In particular, the reduction implies that a fast linear space solution is not likely assuming a widely believed conjecture on the complexity of the set-intersection problem. We complement this result with a time-space trade-off that achieves  space and  query time for any parameter .


All results assume the standard word RAM model with word size . We also assume the alphabet is either sorted or is linear-time sortable.




\paragraph{\bf Applications.}
We suggest a few immediate applications of LCE in trees. Consider a set of strings  of total length  and let  be the \emph{trie} of  of size , i.e.,  is the labeled, rooted tree obtained by merging shared prefixes in  maximally. If we want to support  queries between suffixes of strings in , the standard approach is to build a generalized suffix tree for the strings and combine it with an NCA data structure. This leads to a solution using  space and  query time. We can instead implement the  query between the suffixes of strings in  as an  on the trie , i.e., any suffix of a string in  corresponds to a path in  and hence the  of two suffixes in  corresponds to an  query in . With our data structure for  , this leads to  a solution using  space and  query time. In general,  can be significantly smaller than , depending on the amount of shared prefixes in .  Hence, this solution provides a more space-efficient representation of  at the expense of a tiny increase in query time. An  query on  corresponds to computing a maximal  of a suffix of a string in  with suffixes of strings in  sharing a common prefix. An  query on  corresponds to computing a maximal  over pairs of suffixes of strings in  that share a common prefix. To the best of our knowledge these queries are novel one-to-many and many-to-many  queries. Since tries are a basic data structure for storing strings we expect these queries to be of interest in a number of applications.

Another interesting application is using  in trees as a query primitive for XML data. XML documents can be viewed as a labeled tree and typical queries (e.g., XPath queries) involve traversing and identifying paths in the tree. The  queries provide simple and natural primitives for comparing paths and subtrees without explicit traversal. For instance, our  solution for  queries can be used to quickly identify the ``best match'' of a given path in a subtree.


\section{Preliminaries} 

Given a node  and an integer , the \emph{level ancestor} of  at depth , denoted  is the ancestor of  at depth .
We explicitly compute and store the depth of every node , denoted .
Given a pair of nodes  and  the \emph{nearest common ancestor} of  and , denoted , is the common ancestor of  and  of greatest depth. Both  and  queries can be supported in constant time with a linear space data structures, see e.g.,~\cite{BV1994, Dietz1991, BFC2004, AH2000, GRV2006, AGKR2004,HT1984, BFC2000, FH2011}

Finally, the \emph{suffix tree of a tree}~\cite{Kosaraju1989, Breslauer1998, shibuya1999} is the compressed trie of all suffixes of leaf-to-root paths in . The suffix tree of a tree uses  space and  can be constructed  in  time for general alphabets~\cite{shibuya1999}. Note that the suffix tree of a tree combined with \NCA\ can support \LCE\ queries in constant time for paths going upwards. Since we consider paths going downwards, we will only use the suffix tree to check (in constant time) if two paths are completely identical.

We also need the following three primitives. {\em Range minimum queries:} A list of  numbers  can be augmented with  bits of additional
data in  time, so that for any  the position of the smallest number among  can be found in 
time~\cite{FH2011}.  {\em Predecessor queries:} Given a sorted collection of  integers from , a structure of size  answering predecessor queries in
 time can be constructed in time ~\cite{BKZ1977}, where a predecessor query locates, for a given , the largest 
such that . Finally,  {\em Perfect hashing:}  given a collection  of  integers a perfect hash table can be constructed in expected  time~\cite{FKS},
where a perfect hash table checks, for a given , if , and if so returns its associated data in  time. The last result can be
made deterministic at the expense of increasing the preprocessing time to ~\cite{Ruzic2004}, but then we need one additional step
in our solution for the path-tree LCE as to ensure  total construction time.

\section{Difference Covers for Trees}
In this section we introduce a generalization of difference covers from strings to trees. This will be used to decrease the space of our data structures. We believe it is of independent interest.

\begin{lemma}\label{lem:difference}
For any tree  with  nodes and a parameter , it is possible to mark  nodes of , so that for any two nodes 
at (possibly different) depths at least , there exists  such that the -th ancestors of both  and 
are marked. Furthermore, such  can be calculated in  time and the set of marked nodes can be determined in  time.
\end{lemma}

\begin{proof}
We distinguish between two types of marked nodes. Whether a node  is marked or not depends only on its depth.
The marked nodes are determined as follows.

\begin{description}
\item[Type I.] For every , let  be the set of nodes at depth leaving a remainder of  when divided by . Because
 and all  are disjoint, there exists  such that . Then  is a type I marked node
iff .
\item[Type II.]  For every , let  be the set of nodes  such that  leaves a remainder
of  when divided by . By the same argument as above, there exists  such that . Then  is a type II marked
node iff .
\end{description}

Now, given two nodes  and  at depths at least , we need to show that there exists an appropriate . Let
 and choose . Then the -th ancestor of  is a type I marked node, because
its depth is , which leaves a remainder of  when divided by .
Our  will be of the form . Observe that regardless of the value of , we can be sure that the -th ancestor
of  is a type I marked node. Let  be the -th ancestor of ,  and choose
. The -th ancestor of  is a type II marked node, because
, which leaves a remainder of  when divided by .
Therefore, choosing  guarantees that , so the -th ancestors of  and  are both
defined, the -th ancestor of  is a type I marked node, and the -th ancestor of  is a type II marked node.

The total number of marked nodes is clearly at most , and the values of  and  can be determined by a single traversal of .
To determine , we only need to additionally know  and  and perform a few simple arithmetical operations.
\qed
\end{proof}

\noindent {\bf Remark.} Our difference cover has the following useful property: whether a node  is marked or not depends only on
the value of . Hence, if a node at depth at least  is marked then so is its -th ancestor. Similarly, if
a node is marked, so are all of its descendants at distance .

\section{Path-Path LCE} 
\label{sec:path-path}

In this section we prove the following theorem.

\begin{theorem}\label{thm:lcepp}
For a tree  with  nodes, a data structure of size  can be constructed in  time to answer path-path LCE queries in
 time. 
\end{theorem}

We start with a simple preliminary -space -query data structure which will serve as a starting point for the more complicated final implementation. We note that a data structure with similar guarantees to Lemma~\ref{lem:simple path-path} is also implied from~\cite{Bannai2013}.



\begin{lemma}
For a tree  with  nodes, a data structure of size  can be constructed in  time to answer path-path LCE queries in
 time.
\label{lem:simple path-path}
\end{lemma}

\begin{proof}
The structure consists of  separate parts, each of size . The -th part answers in  time path-path LCE queries such that both
paths are of the same length . This is enough to answer a general path-path LCE query in the same time complexity, because we can first
truncate the longer path so that both paths are of the same length , then calculate  such that . Then
we have two cases.

\begin{enumerate}
\item The prefixes of length  of both paths are different. Then replacing the paths by their prefixes of length  does not
change the answer.
\item The prefixes of length  of both paths are the same. Then replacing the paths by their suffixes of length  does not
change the answer.
\end{enumerate}

We can check if the prefixes are the same and then (with level ancestor queries) reduce the query so that both paths are
of the same length , all in  time.

Consider all paths of length  in the tree. There are at most  of them, because every node  creates at most one new path
. We lexicographically sort all such paths and store the longest common extension of every two neighbours
on the sorted list. Additionally, we augment the longest common extensiones with a range minimum query structure, and keep at every  the
position of the path  (if any) on the sorted list. This allows us to answer
 in  time: we lookup the positions of 
and  on the sorted list and use the range minimum query structure to calculate their longest common
prefix, all in  time. The total space usage is , because every node stores one number and additionally we have a list of at most
 numbers augmented with a range minimum query structure.

To construct the structure efficiently, we need to lexicographically sort all paths of length . This can be done in  time for every  after
observing that every path of length  can be conceptually divided into two paths of length . Therefore, if we have already
lexicographically sorted all paths of length , we can lexicographically sort all paths of length  by sorting pairs of numbers
from , which are the positions of the prefix and the suffix of a longer path on the sorted list of all paths of length . With
radix sorting, this takes  time. Then we need to compute the longest common extension of ever two neighbours on the sorted list,
which can be done in  time by using the already constructed structure for paths of length . Consequently, the total construction
time is .
\qed
\end{proof}

To decrease the space usage of the structure from Lemma~\ref{lem:simple path-path}, we use the difference covers developed in
Lemma~\ref{lem:difference}. Intuitively, the first step is to apply the lemma with  and preprocess only paths of length 
ending at the marked nodes. Because we have only  marked nodes, this requires  space. Then, given two paths of length
, we can either immediately return their LCE using the preprocessed data, or reduce the query to computing
the LCE of two paths of length at most . Using the same reasoning again with ,
we can reduce the length even further to at most  and so on. After  such reduction steps, we guarantee that the
paths are of length , and the answer can be found naively. Formally, every step is implemented using the following lemma.

\begin{lemma}
For a tree  with  nodes and a parameter , a data structure of size  can be constructed in  time, so that given two paths of
length at most  ending at  and  in  time we can either compute the path-path LCE or reduce the query so that
the paths are of length at most .
\label{lem:path-path reduction}
\end{lemma}

\begin{proof}
We apply Lemma~\ref{lem:difference} with . Then, for every  separately, we consider all paths of length
 ending at marked nodes. As in the proof of Lemma~\ref{lem:simple path-path}, we lexicographically sort all such paths
and store the longest common extension of every two neighbours on the sorted list augmented with a range minimum query structure. Because
we have only  marked nodes, the space decreases to . Furthermore, because the length of the paths is of the form
 (as opposed to the more natural choice of ), all lists can be constructed in  total time by radix sorting, as
a path of length  ending at a marked node can be decomposed into two paths of length  ending
at marked nodes, because if a node is marked, so is its -th ancestor.

Consider two paths of the same length  ending at  and . We need to either determine their
LCE, or reduce the query to determining the LCE of two paths of length at most .
If , there is nothing to do.
Otherwise, first we check if the prefixes of length  of both paths are different in  time. If so, we replace the paths
with their prefixes of such length and we are done. Otherwise, if  we replace the paths with their suffixes of length
 and we are done. The remaining case is that the prefixes of length
 are identical and . In such case, we can calculate  such that
. Having such , we cover the suffixes of length  with two
(potentially overlapping) paths of length exactly . More formally, we create two pairs of paths:
\begin{enumerate}
\item  and ,
\item  and .
\end{enumerate}
If the paths from the first pair are different, it is enough to compute their LCE. If they are are identical, it is enough to
compute the LCE of the paths from the second pair. Because we can distinguish between these two cases in  time,
we focus on computing the LCE of two paths of length  ending at some  and .
The important additional property guaranteed by how we have defined the pairs is that the paths of length  ending at
 and  are the same. Now by the properties of the difference cover
we can calculate in  time  such that the -th ancestors of  and  are marked. We conceptually slide both paths up
by , so that they both end at these marked nodes. Because of the additional property, either the paths of length  ending at
 and  are identical, or their first mismatch actually corresponds to the LCE
of the original paths ending at  and . These two cases can be distinguished in  time. Then we either use the preprocessed data
to calculate the LCE in  time, or we are left with the suffixes of length  of the paths ending at  and .
But because , also in the latter case we are done.
\qed
\end{proof}

We apply Lemma~\ref{lem:path-path reduction} with  terminating when .
The total number of applications is just ,
because  for  large enough\footnote{This follows from
.}. Therefore, the total space usage becomes  and, by iteratively applying the reduction step,
for any two paths of length at most  ending at given  and  we can in  time either compute their LCE,
or reduce the query to computing the LCE of two paths of length , which can be computed naively in additional
 time.

To prove Theorem~\ref{thm:lcepp}, we need to decrease the space usage from  down to .
To this end, we create a smaller tree  on  nodes, where  is the parameter of the difference cover, as follows. 
Every marked node  becomes a node of . The parent of  in  is the node corresponding in  to the -th ancestor
of  in , which is always marked. Additionally, we add one artificial node, which serves as the root of the whole , and make it the parent
of all marked nodes at depth (in ) less than . Now edges of  correspond to paths of length  in  (except for the
edges outgoing from the root; we will not be using them). We need to assign unique names to these paths, so that the
names of two paths are equal iff the paths are the same. This can be done by traversing the suffix tree of  in  time.
Finally,  is preprocessed by applying Lemma~\ref{lem:path-path reduction}  times as described above. Because
its size of  is just , the total space usage preprocessing time is just  now.

To compute the LCE of two paths of length  ending at  and , we first compare their
prefixes of length . If they are identical, by the properties of the difference cover we can calculate  such that
the -th ancestors of both  and , denoted  and , are marked, hence exist in . Consequently, if the prefixes of length
 of the paths are different, we can calculate their first mismatch by computing the first mismatch of the paths of length
 ending at  and . This follows because every edge of  corresponds to a path of length
 in , so a path of length  in  corresponds to a path of length belonging to 
in , and we have already verified that the first mismatch is outside of the prefix of length  of the original paths.
Hence the first mismatch of the corresponding paths in  allows us to narrow down where the first mismatch of the original paths in 
occurs up to  consecutive edges.
All in all, in  time plus a single path-path LCE query in  we can reduce the original query to a query concerning
two paths of length at most .

The final step is to show that  can be preprocessed in  time and space, so that the LCE of any two
paths of length at most  can be calculated in  time. We assign unique names to all paths of length  in , which can be
again done by traversing the suffix tree of  in  time. More precisely, every  such that  stores
a single number, which is the name of the path of length  ending at . To calculate the LCE of
two paths of length at most  ending at  and , we proceed as follows. We traverse both paths in parallel
top-down moving by  edges at once. Using the preprocessed names, we can check if the first mismatch occurs on these 
consecutive edges, and if so terminate. Therefore, after at most  steps we are left with two paths of length at most , such
that computing their LCE allows us to answer the original query. But this can be calculated by
by naively traversing both paths in parallel top-down. The total query time is .

To summarize, the total space and preprocessing time is  and the query time remains , which proves
Theorem~\ref{thm:lcepp}.

\section{Path-Tree LCE}
\label{sec:path-tree}

In this section we prove the following theorem.
\begin{theorem}
For a tree  with  nodes, a data structure of size  can be constructed in  time to answer path-tree LCE queries in
 time. 
\label{thm:lcept}
\end{theorem}

\noindent The idea is to apply the difference covers recursively with the following lemma.

\begin{lemma}
For a tree  with  nodes and a parameter , a data structure of size  can be constructed in  time, so that given a path of
length  ending at  and a subtree rooted at  we can reduce the query  in  time so that
the path is of length at most .
\label{lem:path-tree reduction}
\end{lemma}

\begin{proof}
The first part of the structure is designed so that we can detect in  time if the path-tree LCE is of length at most .
We consider all paths of length exactly  in the tree. We assign names to every such path, so that testing if two paths are identical
can be done by looking at their names. Then, for every node  we gather all paths of length  starting at  (i.e.,
, where ) and store their names in a perfect hash table, where every name
is linked to the corresponding node . This allows us to check if the answer is at least  by first looking
up the name of the prefix of length  of the path, and then querying the perfect hash table kept at .
If the name does not occur there, the answer is less than  and we are done. Otherwise, we can move by  down, i.e.,
decrease  by  and replace  with its descendant of distance . 


The second part of the structure is designed to work with the marked nodes. We apply Lemma~\ref{lem:difference} with 
and consider \emph{canonical paths} of length  in the tree, where , ending at marked nodes. The total
number of such paths is , because every marked node is the endpoint of at most  of them.
We lexicographically sort all canonical paths and store the longest common extension of every two neighbours on the global
sorted list augmented with a range minimum query structure. Also, for every marked node  and every  , we save the position of the path
 on the global sorted list. 
Additionally, at every node  we gather all canonical paths starting there, i.e.,  such that 
for some , sort them lexicographically and store on the local sorted list of . Every such path is represented by a pair .
The local sorted list is augmented with a predecessor structure storing the positions on the global sorted list.

Because we have previously decreased  and replaced , now by the properties of the difference cover we can find 
such that the -th ancestor of  and the -th ancestor of  are marked, and then increase  by  and replace
 by its -th ancestor. Consequently, from now on we assume that both  and  are marked.

Now we can use the second part of the structure. If , there is nothing to do. Otherwise, the prefix of
length  of the path is a canonical path (because ),
so we know its position on the global sorted list.
We query the predecessor structure stored at  with that position to get the lexicographical predecessor and successor of the prefix
among all canonical paths starting at . This allows us to calculate the longest common extension  of the prefix and all canonical paths
starting at  by taking the maximum of the longest common extension of the prefix and its predecessor, and the prefix and its successor.
Now, because canonical paths are all paths of the form , the length of the path-tree LCE cannot exceed .
Furthermore, with a level ancestor query we can find  such that the paths  and
 are identical. Then, to answer the original query, it is enough to calculate the path-tree LCE for
 and the subtree rooted at .
Therefore, in  time we can reduce the query so that the path is of length at most  as claimed.

To achieve  construction time, we need to assign names to all paths of length  in the tree, which can be done in
 by traversing the suffix tree of . We would also like to lexicographically sort all canonical paths, but this seems
difficult to achieve in . Therefore, we change the lexicographical order as follows: we assign names to all canonical
paths of length exactly , so that different paths get different names and identical paths get identical names
(again, this can be done in  time by traversing the suffix tree). Then we treat every canonical path of length 
as a sequence consisting of  names, and sort these sequences lexicographically in  time with radix sort.
Even though this is not the lexicographical order, the canonical paths are only used to approximate the answer up to an additive
error of , and hence such modification is still correct.
\qed
\end{proof}

We apply Lemma~\ref{lem:path-tree reduction} with . The total number of applications is
. Therefore, the total space usage becomes , and by applying the reduction step iteratively,
for any path of length  ending at  and a subtree rooted at  we can compute the path-tree LCE in  time.
The total construction time is .

To prove Theorem~\ref{thm:lcept}, we need to decrease the space usage and the construction time. The idea is similar to the one
from Section~\ref{sec:path-path}: we create a smaller tree  on  nodes, where  is the parameter
of the difference cover. The edges of  correspond to paths of length  in . We preprocess  as described
above, but because its size is now just , the preprocessing time and space become .

To compute the path-tree LCE for a given path of length  ending at  and a subtree rooted at , we first check if the
answer is at least . This can be done in  time by preprocessing all paths of length  in ,
as done inside Lemma~\ref{lem:path-tree reduction} for paths of length . If so, we can decrease  and
replace  with its descendant, so that both  and  are marked, hence exist in . Then
we use the structure constructed for  to reduce the query, so that the path is of length at most . Therefore,
it is enough how to answer a query, where a path is of length at most , in  time after  time
and space preprocessing.

The final step is to preprocess  in  time and space, so that the path-tree LCE of a path of length at most 
and any subtree can be computed in  time. We assign unique names to all paths of length  in . Then, for every 
we gather the names of all paths  of length  in a perfect hash table. To calculate the path-tree LCE, we traverse
the path top-down while tracing the corresponding node in the subtree. Initially, we move by  edges by using the
perfect hash tables. This allows us to proceed as long as the remaining part of the LCE is at least . Then, we traverse the remaining
part consisting of at most  edges naively. In total, this takes  time. The space is clearly  and the preprocessing
requires constructing the perfect hash tables, which can be done in  time.

\subsection{Lower Bound}

In this section, we prove that any path-tree LCE structure of size  must necessarily
use  time to answer queries. 
As shown by P{\v{a}}tra{\c{s}}cu and Thorup~\cite{PT2006}, for  any predecessor structure consisting
of  words needs  time to answer queries, assuming that the word size is .
We show the following reduction, which implies the aforementioned lower bound.

\begin{theorem}
For any , given an  structure that uses  space and answers queries in  time we can build
a predecessor structure using  space and  query time for any  of
size .
\end{theorem}

\begin{proof}
We construct a tree  consisting of two parts, which are then glued together by adding an artificial root. One part is simply a full binary trie
on  leaves (for simplicity, we assume that  is a power of ), each of them corresponding to an element of
. The other is a binary trie containing all elements of .
More precisely, for every  we consider the binary expansion of , which is of length , and insert the corresponding path
into the trie. The resulting tree is of size . Then we can find the predecessor of any  in  with  queries as
follows. First, observe that a predecessor query can be seen as starting at the root of the binary trie containing the elements of  and
navigating it according to the binary expansion of  as long as possible. There are three cases.

\begin{enumerate}
\item the search ends at a leaf. In such case, .
\item the search ends at a node  such that the next binary digit of  is  but  has no left child. Then the predecessor of  is
the predecessor of the element corresponding to the leftmost leaf in the right subtree of .
\item the search ends at a node  such that the next binary digit of  is  but  has no right child. Then the predecessor of  corresponds
to the rightmost leaf in the left subtree of .
\end{enumerate}

In the first case, we are done. In the second and third case, the answer depends only on the node , so by storing an additional data of size 
at every node of  we can locate the predecessor in  time after having found the node .

We split the binary expansion of  into
 chunks  and process them one-by-one. First, we determine the largest  such that the binary
trie containing all elements of  contains a node  corresponding to the prefix  of the binary expansion of .
This can be done in  time and  space using perfect hashing. If ,  and we are done. Otherwise, let
 be the root of the full binary trie and  its leaf corresponding to , which can be explicitly stored for every element of
. Then a single  query allows us to determine the node . Overall, the query takes
 time. \qed
\end{proof}

By applying the reduction with  and , we get that an  structure using  space and answering queries
in  time implies a predecessor structure using  space and answering queries in  time,
which is not possible.

\section{Tree-Tree LCE} 
We now consider the  problem. We show that the problem is set intersection hard and give a time-space trade-off. 

\subsection{The Set Intersection Reduction}
The \emph{set intersection problem} is defined as follows. Given a family  of sets of total size  the goal is to preprocess  to answer queries: given two sets  and  determine if . The set intersection problem is widely believed to require superlinear space in order to support fast queries. A folklore conjecture states that for sets of size polylogarithmic in , supporting queries in constant time requires  space~\cite{PR2014} (see also~\cite{CP2010}).


We show the following reduction. 
\begin{theorem}
Let  be a tree with  nodes. Given an  data structure that uses  space and answers queries in  time we can build a set intersection data structure using  space and  query time, for input sets containing  elements.
\end{theorem}
\begin{proof}
Let  be an instance of set intersection with . We transform the sets into a tree  with root . For each set  create a node  as a child of . For each element  create a child node of  and label the edge by . See Fig.~\ref{fig:setintersection} for an example. To answer an intersect query for  and  we compute . If  then  and  intersect and if  they don't. \qed
\end{proof}
\begin{figure}
\begin{center}
\includegraphics[scale=0.6]{SetIntersection}
\end{center}
\caption{Set intersection lower bound example.  . For example, =1 since   but =0 since  . }
\label{fig:setintersection}
\end{figure}


\subsection{The Time-Space Trade-Off} 
We now give a time-space trade-off for the  problem as stated by the following theorem. 

\begin{theorem}\label{thm:lcett}
For a tree  with  nodes and a parameter , , a data structure of size  can be constructed in  time to answer tree-tree LCE queries in  time. 
\end{theorem}

First consider the following two extreme solutions. Given nodes  and  we can simply traverse the entire subtrees  and  in parallel and report the maximal path-path LCE. Since we only need to store , this solution uses  space and  query time. On the other hand, if we preprocess and store the maximal tree-tree LCE for every pair of nodes we use  space and support queries in  time. We show how to efficiently balance between these solutions by clustering  into  overlapping subtrees of size .

\paragraph{Clustering.} 
Let  be a connected subgraph of . A node in  adjacent to a node in  is called a \emph{boundary node} of . A \emph{cluster} of  is a connected subgraph of  with at most two boundary nodes and at least  edge. A set of clusters  is a \emph{cluster partition} of  iff , , and for any , . We will use the following clustering results which follows from Frederickson~\cite{frederickson1997} (see also~\cite{AHLT1997, AHT2000, BG2011}).

\begin{lemma}\label{lem:clustering}
Given a tree  with  nodes and a parameter , we can construct a cluster partition  in  time, such that  and  for any . 
\end{lemma}

\paragraph{The data structure.}
Our data structure consists of the following parts: 
\begin{itemize} 
\item A cluster partition  of  with parameter .
\item For each pair , where  is a node in  and  is a boundary node, we store . By Lemma~\ref{lem:clustering}, the total number of boundary nodes is  hence this uses  space. 
\end{itemize}

\paragraph{Answering queries.}
Let  and  be nodes in clusters  and , respectively. We compute   as follows. If  or  is a boundary node we return the precomputed stored answer in  time. Otherwise, we traverse  in parallel the part of subtree  inside  and the part of subtree  inside . If either endpoint of the traversal reaches a boundary node we lookup the precomputed answer. The corresponding  is then the distance to the endpoint plus the precomputed answer. The answer to  is the maximal path-path LCE found during the traversal.

Since  and  contain  nodes the total time is . Hence, our solution uses  space and  query time, thus completing the proof of Theorem~\ref{thm:lcett}.

\medskip 

\noindent Finally, we note that the above data structure can be easily modified (while maintaining the same time and space bounds) to support the following tree-tree LCE query:
Given nodes  and , find the largest common subtree (rather than subpath) starting at  and  (i.e., the largest connected subgraph that includes  and  descendants of  and is equal to a connected subgraph that includes  and  descendants of ).

\bibliographystyle{abbrv}
\bibliography{paper}

\end{document}
