
\documentclass{llncs}





\usepackage{verbatim}
\usepackage[utf8x]{inputenc}
\usepackage{graphicx}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{latexsym}
\usepackage{amsmath}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{stmaryrd}
\usepackage{graphicx}
\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage{subfigure}
\usepackage{amsfonts,amssymb,latexsym}
\usepackage{yfonts}
\usepackage{color}
\usepackage[all]{xy}
\usepackage{wrapfig}
\usepackage{cases}
\usepackage{gastex,amsfonts,amssymb,latexsym}
\usepackage{times}
\usepackage{gastex}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{stmaryrd}

\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage{subfigure}
\usepackage{gastex,amsfonts,amssymb,latexsym}
\usepackage{yfonts}
\usepackage{color}
\usepackage[all]{xy}
\usepackage{arrows}
\usepackage{wrapfig}
\usepackage{tabularx,colortbl}








\newcommand{\rbox}[2]{\raisebox{#1}[-#1]{#2}}


\renewcommand{\emptyset}{\varnothing}

\newcommand{\mc}[1]{\mathcal{#1}}
\newcommand{\inv}[1]{\{#1\}}
\newcommand{\nil}{{\bf 0}}
\newcommand{\mydef}{\stackrel{{\rm def}}{=}}
\newcommand{\mb}{\mathbb}
\newcommand{\lb}{\llbracket}
\newcommand{\rb}{\rrbracket}
\newcommand{\llb}{\llbracket}
\newcommand{\rrb}{\rrbracket}

\newcommand{\eoe}{\hfill}

\newcommand{\<}{\langle}
\renewcommand{\>}{\rangle}
\newcommand{\les}{\leqslant}
\newcommand{\ges}{\geqslant}

\newcommand{\nv}[1]{\mathrel{\hspace{.4em}\not\hspace{-.4em}\trans{#1\;}}}


\renewcommand{\iff}{\mathrm{iff}}

\newcommand{\bigO}{{\cal O}}
\newcommand{\mX}{\mathcal{X}}
\newcommand{\mP}{\mathcal{P}}
\newcommand{\mG}{\mathcal{G}}
\newcommand{\mD}{\mathcal{D}}
\newcommand{\mC}{\mathcal{C}}
\newcommand{\mM}{\mathcal{M}}
\newcommand{\mB}{\mathcal{B}}
\newcommand{\mA}{\mathcal{A}}
\newcommand{\mL}{\mathcal{L}}
\newcommand{\mU}{\mathcal{U}}
\newcommand{\mR}{\mathcal{R}}
\newcommand{\mE}{\mathcal{E}}
\newcommand{\mF}{\mathcal{F}}
\newcommand{\mK}{\mathcal{K}}
\newcommand{\mV}{\mathcal{V}}
\newcommand{\mZ}{\mathcal{Z}}
\newcommand{\mQ}{\mathcal{Q}}

\newcommand{\sI}{Z}
\newcommand{\sO}{\mathsf{O}}

\newcommand{\trule}{\rule[-3mm]{0mm}{8mm}}

\newcommand{\BDD}{\textsc{BDD}}
\newcommand{\MTBDD}{\textsc{NTBDD}}
\newcommand{\BSCC}{\textsc{BSCC}}
\newcommand{\DAG}{\textsc{DAG}}
\newcommand{\DFT}{\textsc{DFT}}
\newcommand{\IOIMC}{\textsc{i/o-IMC}}
\newcommand{\WCC}{\textsc{WCC}}
\newcommand{\SCC}{\textsc{SCC}}
\newcommand{\BF}{\textsc{BF}}
\newcommand{\CTL}{\textsc{CTL}}
\newcommand{\CSP}{\textsc{CSP}}
\newcommand{\ACTL}{\textsc{ACTL}}
\newcommand{\ECTL}{\textsc{ECTL}}
\newcommand{\CSLTA}{\CSL}
\newcommand{\cpCTL}{\begin{small}{cp}\end{small}\textsc{CTL}}
\newcommand{\pCTMC}{\begin{small}\end{small}\textsc{CTMC}}
\newcommand{\pctmcL}{{\cal C}^{(\mX)}=(S,\R^{(\mX)},s_0,L)}
\newcommand{\CTMC}{\textsc{{CTMC}}}
\newcommand{\CTMDP}{\textsc{{CTMDP}}}
\newcommand{\ICTMC}{\textsc{ICTMC}}
\newcommand{\CTMP}{\textsc{CTMP}}
\newcommand{\DTMP}{\textsc{DTMP}}
\newcommand{\DTA}{\textsc{DTA}}
\newcommand{\DTAr}{\DTA}
\newcommand{\DTAo}{\DTA}
\newcommand{\DMTAr}{\DMTA}
\newcommand{\DMTAo}{\DMTA}
\newcommand{\TA}{\textsc{TA}}
\newcommand{\DBTA}{\textsc{DBTA}}
\newcommand{\RA}{\textsc{RA}} \newcommand{\DFnA}{\textsc{DFA}}
\newcommand{\DRaA}{\textsc{DRA}}
\newcommand{\DFS}{\textsc{DFS}}
\newcommand{\DBA}{\textsc{DBA}}
\newcommand{\DTMA}{\textsc{DTA}}
\newcommand{\NBA}{\textsc{NBA}}
\newcommand{\ECL}{\textsc{ECL}}
\newcommand{\MITL}{\textsc{MITL}}
\newcommand{\MTL}{\textsc{MTL}}
\newcommand{\uMTL}{{\MITL_{0,\infty}}}
\newcommand{\uMITL}{{\MITL_{0,\infty}}}
\newcommand{\TBA}{\textsc{TBA}}
\newcommand{\BFS}{\textsc{BFS}}
\newcommand{\DTMC}{\textsc{DTMC}}
\newcommand{\FPS}{\textsc{FPS}}
\newcommand{\MRM}{\textsc{MRM}}
\newcommand{\MUS}{\textsc{MUS}}
\newcommand{\False}{\mathrm{f\!f}}
\newcommand{\HKSP}{\textsc{HKSP}}
\newcommand{\FKSP}{\textsc{FKSP}}
\newcommand{\HSP}{\textsc{HSP}}
\newcommand{\KSP}{\textsc{KSP}}
\newcommand{\FSP}{\textsc{FSP}}
\newcommand{\SP}{\textsc{SP}}
\newcommand{\LTL}{\textsc{LTL}}
\newcommand{\LTS}{\textsc{LTS}}
\newcommand{\MDP}{\textsc{MDP}}
\newcommand{\MRMC}{\textsc{MRMC}}
\newcommand{\PCTL}{\textsc{PCTL}}
\newcommand{\PRCTL}{\textsc{PRCTL}}
\newcommand{\CSL}{\textsc{CSL}}
\newcommand{\PRISM}{\textsc{PRISM}}
\newcommand{\REA}{\textsc{REA}}
\newcommand{\PTaB}{\textsc{PTaB}}
\newcommand{\RE}{\textsc{RE}}
\newcommand{\PTA}{\textsc{PTA}}
\newcommand{\PTS}{\textsc{PTA}}
\newcommand{\MTA}{\textsc{MTA}}
\newcommand{\DMTA}{\textsc{DMTA}}
\newcommand{\MPTA}{\textsc{MPTA}}
\newcommand{\MECA}{\textsc{MECA}}
\newcommand{\PDP}{\textsc{PDP}}
\newcommand{\PDMP}{\textsc{PDP}}
\newcommand{\IMC}{\textsc{IMC}}
\newcommand{\PDMDP}{\textsc{PDDP}}
\newcommand{\SCA}{\textsc{CSA}}
\newcommand{\ECA}{\textsc{ECA}}
\newcommand{\True}{\mathrm{t\!t}}
\newcommand{\XOR}{\mathop{\,\textsc{xor}\,}}
\newcommand{\ODE}{\textsc{ODE}}
\newcommand{\PDE}{\textsc{PDE}}
\newcommand{\NP}{\textsc{NP}}
\newcommand{\PTIME}{\textsc{PTIME}}
\newcommand{\PNF}{\textsc{PNF}}
\newcommand{\GNBA}{\textsc{GNBA}}


\newcommand{\sgn}{{\it sgn}}
\newcommand{\Exp}{{\it Exp}}


\newcommand{\Expand}{\textit{Expand}}
\newcommand{\Refine}{\textit{Refine}}
\newcommand{\Access}{\textit{Access}}
\newcommand{\Stable}{\textit{Stable}}

\newcommand{\ulpath}[4]{\pi^{#1}_{\lbrack #2,\,#3 \rbrack}(s,#4)}
\newcommand{\ulQ}[4]{Q^{#1}_{\lbrack #2,\,#3 \rbrack}(s, #4)}

\newcommand{\PI}{\mathbf{\Pi}}



\newcommand{\mv}[1]{\singlearrow{#1}}
\newcommand{\wmv}[1]{\mathrel{\stackrel{#1}{\Rightarrow}}}

\newcommand{\mdpm}{{\cal M}}
\newcommand{\mdp}{{\cal M}=(S,\steps,L)}

\newcommand{\dtmc}{\mathcal{D}=(S,\P,L)}
\newcommand{\dtmca}{\mathcal{D}=(S,\P,\hat{s})}

\newcommand{\DRA}{{\cal A}=(Q,\Sigma,\delta,q_0,Acc)}
\newcommand{\DFA}{{\cal A}=(S,\Sigma,s_0,\delta,\hat{t})}
\newcommand{\DFAD}{{\cal A}_{\cal D}=(S,\Sigma,s_0,\delta,Acc)}

\newcommand{\embm}{\mathit{emb}({\cal M})}
\newcommand{\emb}{\textsl{emb}}
\newcommand{\unif}{\mathit{unif}}

\newcommand{\bdU}{{\bf U}}
\newcommand{\bdD}{{\bf D}}
\newcommand{\bdE}{{\bf E}}
\newcommand{\bdF}{{\bf F}}
\newcommand{\bdB}{{\bf B}}
\newcommand{\bdW}{{\bf W}}
\newcommand{\bdM}{{\bf M}}
\newcommand{\bdI}{{\bf I}}
\newcommand{\bdPhi}{{\bf \Phi}}
\newcommand{\bdPi}{\mathbf{\Pi}}

\renewcommand{\P}{{\bf P}}
\newcommand{\bfU}{{\bf U}}
\newcommand{\R}{{\bf R}}
\newcommand{\pR}[1]{\R(#1)}
\newcommand{\Q}{{\bf Q}}
\newcommand{\pQ}[1]{\Q(#1)}
\newcommand{\E}{\vec{E}}
\newcommand{\mr}{\mathbb{R}}
\newcommand{\mrp}{\mathbb{R}_{\geqslant 0}}

\newcommand{\AP}{\textsc{AP}}
\newcommand{\Act}{\textit{Act}}
\newcommand{\Sched}{\mathit{Sched}}


\newcommand{\pathABS}{\mathit{Paths}_{\it abs}}
\newcommand{\pgphi}{\pathABS(s,\phi)}
\newcommand{\pathM}{\mathit{Paths}}

\newcommand{\DA}{{\cal D}\otimes{\cal A}}
\newcommand{\MA}{{\cal M}\otimes{\cal A}}


\newcommand{\reward}{w}

\newcommand{\Loc}{\textit{Loc}}
\newcommand{\distr}{{\it Distr}}
\newcommand{\Distr}{{\it Distr}}
\newcommand{\steps}{{\it Steps}}
\newcommand{\Steps}{{\it Steps}}

\newcommand{\paths}{{\it Paths}}
\newcommand{\Paths}{{\it Paths}}
\newcommand{\Pathsn}{{\it Paths^n}}
\newcommand{\Pathss}{{\it Paths^*}}
\newcommand{\Path}{{\it Paths}}
\newcommand{\pathsfin}{{\it Paths}^{\star}}
\newcommand{\Pathsfin}{{\it Paths}^{\star}}
\newcommand{\infPaths}{{\it Paths}^{\omega}}
\newcommand{\Pathsinf}{{\it Paths}^{\omega}}
\newcommand{\pathinf}{{\it Paths}^{\omega}}

\newcommand{\AccPaths}{{\it AccPaths}}

\newcommand{\last}{{\it last}}
\newcommand{\diag}{{\it diag}}

\newcommand{\goal}{{\it goal}}

\newcommand{\simp}{{\it simple}}

\newcommand{\simple}{{\it sim}}
\newcommand{\all}{{\it all}}
\newcommand{\Prob}{{\it Prob}}
\newcommand{\fair}{{\it fair}}
\newcommand{\pr}{{\it pr}}
\newcommand{\Unif}{{\it Unif}}
\newcommand{\PP}{{\it PP}}
\newcommand{\qt}{{\it qt}}
\newcommand{\prj}[2]{#1{\downharpoonright_{#2}}}

\newcommand{\Pro}{{\mathbb{P}}}

\newcommand{\Pref}{{\it Pref}}
\newcommand{\Pre}{{\it Pred}}
\newcommand{\Pred}{{\it Pred}}

\newcommand{\size}{{\it size}}

\newcommand{\U}{\mathbin{\mathsf{U}}}
\newcommand{\Release}{\mathbin{\mathsf{R}}}
\renewcommand{\S}{\mathbin{\mathsf{S}}}
\newcommand{\Since}{\mathbin{\mathsf{S}}}
\newcommand{\bU}[1]{\mathbin{\mathsf{U}^{\leqslant #1}}}  \newcommand{\oU}[1]{\mathbin{\mathsf{U}^{#1}}}  \newcommand{\W}{\mathbin{\mathsf{W}}}   \newcommand{\bW}[1]{\mathbin{\mathsf{W}^{\leqslant #1}}}

\newcommand{\bP}[1]{\mathcal{P}_{#1}}
\newcommand{\csls}{\bP{p}(\Phi\bU{t}\Psi)}
\newcommand{\cslp}{\Phi \bU{t} \Psi}

\newcommand{\Sat}[1]{\mbox{\sl Sat}(#1)}

\newcommand{\F}{\mathop{\diamondsuit}}
\newcommand{\bF}[1]{\mathop{\diamondsuit^{\leqslant #1}}}
\newcommand{\G}{\mathop{\square}}
\newcommand{\bG}[1]{\mathop{\square^{\leqslant #1}}}
\newcommand{\inva}{\textit{inv}}
\newcommand{\Inv}{\mathit{Inv}}
\newcommand{\gp}{\mathit{gp}}
\newcommand{\gc}{\mathit{gc}}
\newcommand{\lp}{\mathit{lp}}
\newcommand{\ip}{\mathit{ip}}









\newcommand{\set}[1]{\{ \, #1 \, \}}
\newcommand{\Union}{\, \cup \,}
\newcommand{\To}{\longrightarrow}
\newcommand{\sem}[1]{[\![\, #1 \, ]\!]}


\newcommand{\HS}{\hat{S}}
\newcommand{\SQ}{S^?}
\newcommand{\SYES}{S^{\it{Yes}}}
\newcommand{\SNO}{S^{\it{No}}}
\newcommand{\HAP}{\hat{\AP}}
\newcommand{\ePr}{\Pr_{\textit{emb}}}

\renewcommand{\tt}{\textrm{tt}}
\newcommand{\ff}{\textrm{ff}}



\newcommand{\Nats}{\mathbb{N}}
\newcommand{\Reals}{\mathbb{R}}
\newcommand{\pReals}{\mathbb{R}_{\geqslant0}}
\newcommand{\Rationals}{\mathbb{Q}}
\newcommand{\Int}{\mathbb{Z}}
\newcommand{\real}{\Reals}
\newcommand{\Always}{\mathop{\square}}
\newcommand{\Ever}{\F}
\newcommand{\Next}{\mbox{}}
\newcommand{\X}{\Next}


\newcommand{\updownrightarrow}[2]{\mathop{\longrightarrow}\limits^{#1}_{#2}}

\newcommand{\updownstackrel}[3]{\overset{#1}{\underset{#2}{#3}}}

\newcommand{\updownmapsto}[4]{\xymatrix{#1\;\ar @{|->}[r]^{#2}_{#3}&#4}}

\newcommand{\updownsquigarrow}[4]{\xymatrix{#1\;\ar @{~>}[r]^{#2}_{#3}&#4}}

\newcommand{\updownhookarrow}[4]{\xymatrix{#1\;\ar @{^{(}->}[r]^{#2}_{#3}&#4}}

\newcommand{\trans}[1]{\stackrel{#1}{\rightarrow}}

\newcommand{\smv}[1]{\stackrel{#1}{\rightarrow}}

\newenvironment{packed_itemize}{
\begin{itemize}
  \setlength{\itemsep}{1pt}\setlength{\parskip}{-3pt}
  \setlength{\parsep}{-1pt}
}{\end{itemize}}


\newenvironment{packed_enumerate}{
\begin{enumerate}
  \setlength{\itemsep}{-2ex}
  \setlength{\parskip}{0pt}
  \setlength{\parsep}{0pt}
}{\end{enumerate}}


\newcommand{\fref}[1]{Fig.\,\ref{#1}}



\newcommand{\tpred}{\mathsf{timepred}}
\newcommand{\tsplit}{\mathsf{timesplit}}
\newcommand{\dpred}{\mathsf{discpred}}
\newcommand{\ppred}{\mathsf{discpred}}
\newcommand{\tsucc}{\mathsf{timesucc}}
\newcommand{\psucc}{\mathsf{discsucc}}
\newcommand{\until}{\textsf{until}}
\newcommand{\veck}{\vec{k}}

\newenvironment{ft}{
\begin{footnotesize}
}{\end{footnotesize}}


\newcommand{\mpar}[1]{\marginpar{\framebox{\begin{minipage}{2cm}#1\end{minipage}}}}

\def\topbotatom#1{\hbox{\hbox to 0pt{\hss}}}
\newcommand*{\topbot}{\mathrel{\mathchoice{\topbotatom\displaystyle}
{\topbotatom\textstyle}
{\topbotatom\scriptstyle}
{\topbotatom\scriptscriptstyle}}}


\makeatletter
\newcommand{\be}{\begin{group}
\eqnarray \@ifstar{\nonumber}{}}
\newcommand{\ee}{\endeqnarray\endgroup}
\makeatother
 


\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{amstext}
\usepackage{amssymb}
\usepackage{times}


\usepackage{graphicx}
\graphicspath{{figures/}}
\usepackage{subfigure}


\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage{wrapfig}
\usepackage[all]{xy}
\usepackage{hyperref}
\usepackage{breakurl}






\usepackage{gastex}









\raggedbottom

\begin{document}
\title{A Two Step Perspective for Kripke Structure Reduction}








\author{Arpit Sharma}
\institute{Software Modeling and Verification Group, RWTH Aachen University, Germany \\
arpit.sharma@cs.rwth-aachen.de}
\maketitle
\begin{abstract}
This paper presents a novel theoretical framework for the state space reduction of Kripke structures. We define two equivalence relations, Kripke minimization equivalence (KME) and weak Kripke minimization equivalence (WKME). We define the quotient system under these relations and show that these relations are strictly coarser than strong (bi)simulation and divergence-sensitive stutter (bi)simulation, respectively. We prove that the quotient system obtained under KME and WKME preserves linear-time and stutter-insensitive linear-time properties. Finally, we show that KME is compositional w.r.t. synchronous parallel composition.      
\end{abstract}
\keywords{Kripke structure, bisimulation, linear-time property, divergence-sensitive relation, synchronous parallel composition.}
\section{Introduction}
Model checking Kripke structures (KSs) \cite{KB08} suffers from the well-known \emph{state-space explosion} problem where the number of states grows exponentially in the number of parallel components. Abstraction techniques based on equivalence relations reduce the state space of KSs, by aggregating equivalent states into a single state. The reduced state space obtained under an equivalence relation, called a quotient, can then be used for analysis provided it preserves a rich class of properties of interest. For KSs, one usually distinguishes between linear-time and branching-time equivalence relations \cite{RJG01}. The standard example of a linear-time equivalence is trace equivalence \cite{Hoare78,Rem87,JLA85}. Informally, two states are trace equivalent if the possible sequences of words starting from these states are the same. Several extensions of trace equivalence have been proposed, e.g., failure semantics and readiness semantics \cite{CSAR84,CAR85,RDNMH84,Nicola87,CH86,APnueli85,BBWK87,LPomello85,VeglioniN98}. In the weak setting, stutter trace equivalence has been proposed where a pair of sequences are considered to be equivalent if they differ in at most the number of times a set of propositions may adjacently repeat \cite{LLamport83}. Checking trace equivalence is PSPACE-complete. In branching-time semantics, various relations on KSs have been defined such as strong and stutter variants of bisimulation and simulation pre-orders \cite{MilnerR80,DPark81,Milner71,JFGrooteV90,EBrowneCG88,WPWGlabbeekW96}. Strong bisimulation and divergence-sensitive stutter bisimulation coincide with Computation Tree Logic  and , respectively \cite{EBrowneCG88,FWVNicolaV90a}. Strong simulation agrees with a “preorder” on the universal (or existential) fragment of  \cite{ODClarkeGL94}. Several papers report data showing that bisimulation minimization can substantially reduce the state-space of models to be verified \cite{AVSRKB94,KFMYV98}. The use of simulation relations for abstraction has been studied in, e.g., \cite{ODClarkeGL94,PCousotC02,LoiseauxGSBB95}. Unfortunately, (stutter) (bi)simulation is too fine, and it is often desirable to obtain a quotient system smaller than (stutter) (bi)simulation such that properties of interest are still preserved. This is particularly important if the properties to be verified belong to the class of (stutter-insensitive) linear-time properties, e.g. safety properties, liveness properties and in general (stutter-insensitive) -regular properties. These properties can be expressed using temporal logics such as Linear Temporal Logic  \cite{KB08}, Property Specification Language  \cite{IEEE05} and  semi-extended   \cite{DaxKL09}.   

In this paper our focus is on Kripke minimization equivalence (KME) that allows for a more aggressive state space reduction than strong (bi)simulation. In the weak setting we define weak Kripke minimization equivalence (WKME) such that state space reduction under WKME can potentially be much larger than for divergence-sensitive stutter (bi)simulation. Whereas bisimulation compares states on the basis of their direct successors, KME considers a \emph{two-step} perspective. Two states  and  are KME equivalent if for each pair of their direct predecessors it is possible to directly move to any equivalence class via the equivalence class . The main principle is captured in Fig. 1 where only those states can be merged into equivalence class  for whom  and  can reach equivalence classes  and  via  and this should hold for each pair of predecessors of . Intuitively, each predecessor of  should reach the same set of equivalence classes in two steps via . In Fig. 1 it may be possible that some of these predecessors have only one successor in  while others have multiple successors in . For WKME, we abstract from stutter steps and thus each predecessor of  should reach the same set of equivalence classes in two or more steps such that all extra steps are taken within .    
\begin{figure}
 \centering
\scalebox{0.6}{
\Large\begin{picture}(74,58)(0,-58)
\node[Nfill=y,fillcolor=Black,ExtNL=y,NLangle=0.0,Nw=3.82,Nh=3.28,Nmr=1.64](n0)(28.0,-8.0){}
\node[Nfill=y,fillcolor=Black,ExtNL=y,NLangle=0.0,Nw=3.82,Nh=3.28,Nmr=1.64](n7)(44.0,-8.0){}
\node[NLangle=0.0,Nw=25.13,Nh=9.83,Nmr=2.46](n10)(36.0,-28.0){}
\node[NLangle=0.0,Nw=25.13,Nh=9.83,Nmr=2.46](n14)(16.0,-48.0){}
\drawbpedge(n10,-161,1.73,n14,-180,3.0){}
\drawedge(n0,n10){}
\drawedge(n7,n10){}
\node[NLangle=0.0,Nw=25.13,Nh=9.83,Nmr=2.46](n23)(56.0,-48.0){}
\drawedge(n10,n23){}
\end{picture}}
\caption{Kripke minimization equivalence}
\end{figure} 
\paragraph*{Contributions.} The main contributions of this paper are as follows:
\begin{itemize}
 \item We provide a structural definition of KME on KSs, define the quotient under KME and show that KME is strictly coarser than strong (bi)simulation.
 \item We show that linear-time (LT) properties defined over infinite words are preserved under KME quotienting. 
 \item In the weak setting, we provide a structural definition of WKME on KSs, define the quotient under WKME and show that WKME is strictly coarser than divergence-sensitive stutter (bi)simulation.
 \item Next, we prove that stutter-insensitive LT properties defined over infinite words are preserved under WKME quotienting. 
 \item Finally, we show that KME is compositional w.r.t. synchronous parallel compositon (SCCS-like parallel composition \cite{CCMilner83}).    
\end{itemize}
The theory presented in this paper forms the basis for developing an efficient algorithm that can obtain quotient systems that are smaller than (stutter) (bi)simulation. This is particularly helpful in situations where several components have to be combined using synchronous parallel composition \cite{CCMilner83}, as KME based reduction can be applied at each step of the iterative composition. Both KME and WKME defined in this paper can be seen as state space reduction techniques induced by trace equivalence and stutter trace equivalence, respectively.                                      
\paragraph*{Related work.} In the stochastic context, T-Lumpability has been defined over sequential Markovian process calculus (SMPC) \cite{BM08}. T-Lumpability is defined using four process-algebraic axioms, and allows for a more aggressive state space aggregation than ordinary lumpability. In \cite{SK11} a novel structural definition of  weighted lumpability (WL) has been provided on continuous-time Markov chains (CTMCs) that coincides with T-Lumpability. For WL it has been proved that probability of properties specified using deterministic timed automaton and metric temporal logic are preserved under WL quotienting. Recently, the notion of WL has been extended to discrete-time Markov chains (DTMCs) and the preservation result for probability of -regular properties has been established \cite{Sharma12}. Our definition of equivalence for strong case, i.e., KME here builds on that investigated in \cite{SK11} for CTMCs.                       
\paragraph*{Organisation of the paper.}
Section 2 briefly recalls the basic concepts of KSs. 
Section 3 defines Kripke minimization equivalence and discusses the preservation of LT properties under KME quotienting. 
Sections 4 defines weak Kripke minimization equivalence and discusses the preservation of stutter-insensitive LT properties under WKME quotienting. In section 5, we prove that WPE is compositional w.r.t. synchronous parallel composition. Finally, section 6 concludes the paper.
\section{Preliminaries}
This section recalls the basic concepts of Kripke structures with a finite state space.  
\begin{definition}[KS]
A Kripke structure (KS) is a tuple  where:
\begin{itemize}
\item  is a non-empty finite set of states,
\item , is a transition relation s.t.  with ,
\item  is a finite set of atomic propositions,
\item  is a labeling function,
\item  is the initial state.
\end{itemize} 
\end{definition}
For simplicity, we write  instead of  . Let  and , then . Let . For , let . 
\begin{definition}[KS paths]
Let  be a KS. An infinite \emph{path}  in  is an infinite state sequence, i.e.,  with .
\end{definition}
Note that, since we do not allow KS  to have terminal states, i.e., which do not have any outgoing transitions, we only consider infinite paths (starting from the initial state).  
Let  denote the set of all infinite paths in  that start in . For infinite path  and any , let , the -st state of . Let  denote the suffix of path  starting in the -st state.
\begin{definition}[KS traces]
Let  be a KS. The \emph{trace} of an infinite path  is . 
\end{definition}
Intuitively a trace of an infinite path is the infinite sequence of sets of atomic propositions that are valid in the states of the path, i.e. an infinite word over the alphabet . Let  denote the set of all infinite traces in  that start in .
\begin{definition}[Trace-equivalent paths]
Let  be a KS and  .  and  are \emph{trace-equivalent}, denoted by , if  for all . 
\end{definition}
\begin{definition}[Stutter step]
Transition  in Kripke structure  is a \emph{stutter step} if .  
\end{definition}
The notion of stuttering is lifted to paths as follows.
\begin{definition}[Stutter-equivalent paths]
Let  be a KS and  .  and  are stutter-equivalent, denoted by , if there exists an infinite sequence  with  and natural numbers   s.t. 

   
where  denotes for all , .       
\end{definition}
Note that  only refers to the first block, for other blocks it is defined in an analogous manner. Accordingly, stutter-equivalence for any two infinite traces  (denoted by ) can be defined. 
\begin{example}
Consider the KS  in Fig. 2 (left), where ,  and  is the initial state. An example finite path  is . Here . The trace for  is given by . 
\end{example}

\paragraph{Assumptions.}
Throughout this paper we assume that every state of KS  has at least one predecessor, i.e.,  for any . 
This is not a restriction, as any KS  can be transformed into an equivalent KS  which fulfills this condition.
This is done by adding a new state  to  equipped with a self-loop and which has a transition to each state in  without predecessors.
To distinguish this state from the others we set  with .
(All other labels, states and transitions remain unaffected.) Let .
It follows that all states in  have at least one predecessor.
Moreover, the reachable state space of both KSs coincides.
We also assume that the initial state  of a KS is distinguished from all other states by a unique label, say \{ s_0 \}\hat{s}\
Pbr(s,C,D)=
\left\{\begin{array}{ll}
1 & \mbox{if } \exists s'\in Post(s,C) \mbox{ s.t. } \\ 
  & Post(s',D)\neq \emptyset\\ 
0 & \mbox{otherwise.} 
\end{array}\right.

\mathcal{K}\models P\Leftrightarrow \mathcal{K/}_{\mathcal{R}}\models P. 

\mathcal{K}\models\varphi \Leftrightarrow \mathcal{K/}_{\mathcal{R}}\models \varphi.

WPbr(s,C,D)=
\left\{\begin{array}{ll}
1 & \mbox{if } \exists s'\in Post(s,C), s''\in D \mbox{ s.t.}\\
  & s'\mv{*}s''\\ 
0 & \mbox{otherwise.} 
\end{array}\right.

\P_{n}:=\{w\in (2^{\{p\}})^{\omega}:&\mbox{ the number of occurrences of the sub-}\\
                                    &\mbox{word }\{p\}\emptyset \mbox{ in } w \mbox{ is divisible by }\},

\mathcal{K}\models P\Leftrightarrow \mathcal{K/}_{\mathcal{R}}\models P. 

\mathcal{K}\models\varphi \Leftrightarrow \mathcal{K/}_{\mathcal{R}}\models \varphi.

\frac{s_{1}\mv{}_{1}s'_{1}\wedge s_{2}\mv{}_{2}s'_{2}}{(s_{1},s_{2})\mv{}(s'_{1},s'_{2})}.

(\mathcal{K}\otimes \mathcal{K}_{1})\star (\mathcal{K/}_{R}\otimes \mathcal{K}_{1}).

\end{theorem}  
\section{Conclusions and Future Work}
We have presented two equivalence relations, Kripke minimization equivalence (KME) and weak Kripke minimization equivalence (WKME) on KSs. We defined the quotient system under these relations and proved that these relations are coarser than strong (bi)simulation and divergence-sensitive stutter (bi)simulation, respectively. Preservation results for LT properties and stutter-insensitive LT properties have been established under KME and WKME quotienting. Finally we show that KME is compositional w.r.t. synchronous parallel composition.

Developing and implementing an efficient quotienting algorithm is left for future work. Note that any algorithm that generates a quotient system under (weak) KME can potentially achieve a state space reduction that is larger than (stutter) (bi)simulation, but it cannot guarantee the smallest quotient system that is (stutter) trace equivalent to the original one.     
\paragraph*{Acknowledgements.}
The author would like to thank Joost-Pieter Katoen for his valuable feedback and comments. This work was supported by the European Commission under the India4EU project. 
 \begin{footnotesize}
\bibliographystyle{abbrv}
\bibliography{myBib,mybibProceedings,mybibArticles,mybibInbooks}
\end{footnotesize}
\end{document}
