\documentclass[submission,copyright,creativecommons,hidelinks]{eptcs}
\providecommand{\event}{ICE 2015} 

\usepackage[colorinlistoftodos,bordercolor=white]{todonotes}


\newcommand{\todoCWI}[2][color=green!40]{\todo[#1]{{\bf CWI: } {#2}}}
\newcommand{\todoRiSD}[2][color=blue!40]{\todo[#1]{{\bf RiSD: } {#2}}}
\newcommand{\todoAll}[2][color=red!40]{\todo[#1]{{\bf All: } {#2}}}
\newcommand{\todoCWIin}[2][inline,color=green!40]{\todo[#1]{{\bf CWI: } {#2}}}
\newcommand{\todoRiSDin}[2][inline,color=blue!40]{\todo[#1]{{\bf RiSD: } {#2}}}
\newcommand{\todoAllin}[2][inline,color=red!40]{\todo[#1]{{\bf All: } {#2}}}



\usepackage{dokter}

\usetikzlibrary{matrix}
\usepackage{mathtools}
\usepackage{stmaryrd} \usepackage{verbatim}
\usepackage[export]{adjustbox}
\usepackage{wrapfig}
\pagestyle{plain}
\tikzset{elliptic state/.style={draw,ellipse}}

\usepackage{amsthm}
\theoremstyle{plain} \newtheorem{theorem}{Theorem}
\newtheorem{lemma}{Lemma}
\newtheorem{proposition}{Proposition}
\newtheorem{corollary}{Corollary}
\theoremstyle{definition}
\newtheorem{definition}{Definition}
\newtheorem{conjecture}{Conjecture}
\newtheorem{example}{Example}
\theoremstyle{remark}
\newtheorem*{remark}{Remark}
\newtheorem*{note}{Note}
\newtheorem{case}{Case}

\usepackage[utf8]{inputenc}

\newcommand\xqed[1]{\leavevmode\unskip\penalty9999 \hbox{}\nobreak\hfill
  \quad\hbox{#1}}
\newcommand\tri{\xqed{}}

\DeclareMathOperator{\BIPa}{\operatorname{\sf bip}_1}
\DeclareMathOperator{\Reoa}{\operatorname{\sf reo}_1}
\DeclareMathOperator{\BIPb}{\operatorname{\sf bip}_2}
\DeclareMathOperator{\Reob}{\operatorname{\sf reo}_2}
\DeclareMathOperator{\fa}{\operatorname{\sf f}_1}
\DeclareMathOperator{\ga}{\operatorname{\sf g}_1}
\DeclareMathOperator{\fb}{\operatorname{\sf f}_2}
\DeclareMathOperator{\gb}{\operatorname{\sf g}_2}
\newcommand{\PA}{\mathrm{PA}}
\newcommand{\Arch}{\mathrm{Arch}}
\newcommand{\LTS}{\mathrm{LTS}}
\newcommand{\CA}{\mathrm{CA}^\pm}
\newcommand{\BC}{\mathrm{IM}}
\DeclareMathOperator{\tp}{\operatorname{top}}
\DeclareMathOperator{\bt}{\operatorname{bot}}

\newcommand{\todos}[1]{\todo{#1\mdash Simon}}
\newcommand{\mdash}[1][]{---#1}
\newcommand{\ndash}[1][]{--#1}
\newcommand{\ie}[1][\ ]{i.e.{#1}}
\newcommand{\etc}[1][\ ]{etc.{#1}}
\newcommand{\eg}[1][\ ]{e.g.{#1}}
\newcommand{\cf}[1][\ ]{cf.{#1}}
\newcommand{\wrt}[1][\ ]{w.r.t.{#1}}



\newcommand{\defn}[1]{Definition~\ref{defn:#1}}
\newcommand{\fig}[2][]{Figure~\ref{fig:#2}\ensuremath{#1}}
\newcommand{\tab}[1]{Table~\ref{tab:#1}}
\newcommand{\eq}[1]{(\ref{eqn:#1})}
\newcommand{\res}[1]{(\ref{res:#1})}
\newcommand{\ex}[1]{Example~\ref{ex:#1}}
\newcommand{\secn}[1]{Section~\ref{sec:#1}}
\newcommand{\rem}[1]{Rem.~\ref{rem:#1}}
\newcommand{\ntn}[1]{Not.~\ref{ntn:#1}}
\newcommand{\lem}[1]{Lemma~\ref{lem:#1}}
\newcommand{\cor}[1]{Corollary~\ref{cor:#1}}
\newcommand{\thm}[1]{Theorem~\ref{thm:#1}}
\newcommand{\app}[1]{App.~\ref{app:#1}}
\newcommand{\axs}[1]{Ax.~\ref{ax:#1}}
\newcommand{\axss}[2]{Ax.~\ref{ax:#1}, \ref{ax:#2}}
\newcommand{\ax}[1]{Ax.~\ref{ax:#1}}
\newcommand{\prop}[1]{Proposition~\ref{prop:#1}}

\newcommand{\bydef}[1]{\ensuremath{\stackrel{\Delta}{#1}}}
\newcommand{\oftype}{\ensuremath{\!:\!}}
\newcommand{\suchthat}{\ensuremath{\,|\,}}
\newcommand{\rightsuchthat}{\ensuremath{\,\right|\,}}
\newcommand{\leftsuchthat}{\ensuremath{\,\left|\,}}
\newcommand{\setdef}[2]{\ensuremath{\{{#1}\,|\,{#2}\}}}
\newcommand{\Setdef}[2]{\ensuremath{\Big\{{#1}\,\Big|\,{#2}\Big\}}}
\newcommand{\goesto}[2][]{\ensuremath{\xrightarrow[#1]{#2}}}

\newcommand{\mix}{\ensuremath{\smallfrown}}
\newcommand{\true}{\ensuremath{\mathtt{t\!t}}}
\newcommand{\false}{\ensuremath{\mathtt{f\!f}}}
\newcommand{\data}[1][]{\ensuremath{\cD^{#1}}}
\newcommand{\local}[1]{\ensuremath{{#1}^{l}}}
\newcommand{\guard}{\ensuremath{g}}
\newcommand{\up}{\ensuremath{up}}
\newcommand{\down}{\ensuremath{dn}}
\newcommand{\combine}[1][{}]{\ensuremath{c^{#1}}}
\newcommand{\portdata}[1]{\ensuremath{\mathbf{#1}}}
\newcommand{\dtspliti}{\ensuremath{.}}
\newcommand{\dtsplitii}{\ensuremath{:\ }}
\newcommand{\dtsplit}{\ensuremath{\,/\!/\,}}
\newcommand{\connector}[4]
 {\ensuremath{(#1)\dtspliti{}[{#2}\dtsplitii{}{#3}\dtsplit{}{#4}]}}
\newcommand{\Connector}[4]
 {\ensuremath{(#1)\dtspliti{}\bigl[{#2}\dtsplitii{}{#3}\dtsplit{}{#4}\bigr]}}

\newcommand{\domD}[0]{\mathsf{D}}
\newcommand{\xdom}[1]{\domD[#1]}
\renewcommand{\vec}[1]{\mathbf{#1}}
\newcommand{\sem}[2]{[\![ #1 ]\!](#2)}
\newcommand{\expr}[2]{#1[\![ #2 ]\!]}
\newcommand{\actcomp}{\ensuremath{;}}

\newcommand{\an}{a}
\newcommand{\An}{A}
\newcommand{\compmodel}{T/B component}
\newcommand{\compmodels}{T/B components}
\newcommand{\Compmodel}{T/B Component}
\newcommand{\Compmodels}{T/B Components}
\newcommand{\tbbot}[1]{\ensuremath{#1^{bot}}}
\newcommand{\tbtop}[1]{\ensuremath{#1^{top}}}
\newcommand{\pbot}{\tbbot{P}}
\newcommand{\ptop}{\tbtop{P}}
\newcommand{\topo}[1]{\ensuremath{\tau({#1})}}
\newcommand{\undata}[1]{\ensuremath{\sigma\left({#1}\right)}}

\newcommand{\head}[1] {\ensuremath{\mathit top(#1)}}
\newcommand{\tail}[1] {\ensuremath{\mathit bot(#1)}}
\newcommand{\support}[1] {\ensuremath{\mathit supp(#1)}}

\newcommand{\intsem}[1]{\ensuremath{\|{#1}\|}}
\newcommand{\aisem}[1]{\ensuremath{|{#1}|}}

\newcommand{\ai}{\ensuremath{\mathcal{A\hspace{-0.6ex}I\!}}}
\newcommand{\ct}{\ensuremath{\mathcal{T\!}}}
\newcommand{\cru}{\ensuremath{\mathcal{CR\!}}}
\newcommand{\ac}{\ensuremath{\mathcal{AC}\!}}

\newcommand{\cA}{\ensuremath{\mathcal{A}}}
\newcommand{\bB}{\ensuremath{\mathbf{B}}}
\newcommand{\cB}{\ensuremath{\mathcal{B}}}
\newcommand{\sB}{\ensuremath{\mathbb{B}}}
\newcommand{\cC}{\ensuremath{\mathcal{C}}}
\newcommand{\sC}{\ensuremath{\mathbb{C}}}
\newcommand{\cD}{\ensuremath{\mathcal{D}}}
\newcommand{\cE}{\ensuremath{\mathcal{E}}}
\newcommand{\sE}{\ensuremath{\mathbb{E}}}
\newcommand{\cF}{\ensuremath{\mathcal{F}}}
\newcommand{\cG}{\ensuremath{\mathcal{G}}}
\newcommand{\cH}{\ensuremath{\mathcal{H}}}
\newcommand{\cI}{\ensuremath{\mathcal{I}}}
\newcommand{\sI}{\ensuremath{\mathbb{I}}}
\newcommand{\cM}{\ensuremath{\mathcal{M}}}
\newcommand{\cN}{\ensuremath{\mathcal{N}}}
\newcommand{\sN}{\ensuremath{\mathbb{N}}}
\newcommand{\cP}{\ensuremath{\mathcal{P}}}
\newcommand{\sP}{\ensuremath{\mathbb{P}}}
\newcommand{\cQ}{\ensuremath{\mathcal{Q}}}
\newcommand{\sQ}{\ensuremath{\mathbb{Q}}}
\newcommand{\cR}{\ensuremath{\mathcal{R}}}
\newcommand{\sR}{\ensuremath{\mathbb{R}}}
\newcommand{\cS}{\ensuremath{\mathcal{S}}}
\newcommand{\sS}{\ensuremath{\mathfrak{S}}}
\newcommand{\cT}{\ensuremath{\mathcal{T}}}
\newcommand{\fT}{\ensuremath{\mathsf{T}}}
\newcommand{\sT}{\ensuremath{\mathbb{T}}}
\newcommand{\sZ}{\ensuremath{\mathbb{Z}}}

\newcommand{\derrulesep}{\hspace{2mm}}
\newcommand{\derrule}[3][1]{\ensuremath{\begin{array}{*{#1}{@{\derrulesep}c@{\derrulesep}}}
      #2\\
      \hline
      \multicolumn{#1}{c}{#3}
    \end{array}}}
\newcommand{\derrulerow}[2]{\ensuremath{\begin{array}{*{#1}{@{\derrulesep}c@{\derrulesep}}}
    #2
    \end{array}}}




\title{Relating BIP and Reo}
\author{Kasper Dokter, Sung-Shik Jongmans, Farhad Arbab \\
\institute{Centrum Wiskunde \& Informatica, \\ Amsterdam, Netherlands}
\and
Simon Bliudze \\ 
\institute{\'Ecole Polytechnique F\'ed\'erale de Lausanne, \\ Lausanne, Switzerland}} 

\def\titlerunning{Relating BIP and Reo}
\def\authorrunning{K. Dokter, S.-S. T. Q. Jongmans, F. Arbab \& S. Bliudze}

\begin{document}

\maketitle

\begin{abstract}
Coordination languages simplify design and development of concurrent systems. 
Particularly, exogenous coordination languages, like BIP and Reo, enable system designers to express the interactions among components in a system explicitly. 
In this paper we establish a formal relation between BI(P) (i.e., BIP without the priority layer) and Reo, by defining transformations between their semantic models. 
We show that these transformations preserve all properties expressible in a common semantics. 
This formal relation comprises the basis for a solid comparison and consolidation of the fundamental coordination concepts behind these two languages. 
Moreover, this basis offers translations that enable users of either language to benefit from the toolchains of the other.
\end{abstract}

\raggedbottom

\section{Introduction}
\label{sec:intro}

\paragraph{Context.} 
Over the past decades, architecture description languages (ADL) and coordination languages have emerged as fundamental tools for tackling complexity in the design of correct-by-construction componentised software systems \cite{Garlan}. 
However, no language has yet emerged as a de facto standard, and no consensus exists on how to properly design such languages, either.  
BIP~\cite{bip06,BliSif07-acp-emsoft} and Reo~\cite{Reo} each addresses this complexity and provides a formal semantic framework, which allows reasoning about and proving correctness of coordination as a first-class entity.  

BIP is a language for the construction of concurrent systems by superposing three layers: behaviour, interaction and priorities.
The layered approach of BIP separates concerns between interaction and computation.
This is essential for component-based design of concurrent systems, because it allows global analysis of the coordination layer and reusability of written code.

Reo is a language for compositional specification of coordination protocols, i.e., protocols modeling the synchronization and dataflow among multiple components.
These protocols consist of graph-like structures, called {\em connectors}.
Reo connectors may compose together to form more complex connectors, allowing reusability and compositional construction of coordination protocols.

We provide a more detailed introduction to BIP and Reo in \secn{overview}.

\paragraph{Motivation.} 
Both BIP and Reo advocate the necessity of separating coordination mechanisms from the coordinated components.
In BIP one refers to this separation as the {\em architecture-based} design approach \cite{BBJS14}. 
Reo literature uses the term {\em exogenous coordination} to describe the same fundamental principle \cite{PA01, Reo, Arbab11}. 
Despite this fundamental agreement, the design choices underlying BIP and Reo differ.
For example, BIP uses stateless interactions, while Reo allows stateful connectors.
Establishing a formal relation between BIP and Reo is necessary to discover fundamental principles that drive the design of coordination languages.

Translations exist between numerous other coordination models and BIP and Reo, individually \cite{CRB+08, BMM11, PC08, TSR11}. 
Hence, a formal relationship between BIP and Reo yields insight, albeit indirect, into the relation of each with a wider range of related work.

Furthermore, establishing a formal relationship between BIP and Reo enables encodings that allow each of the two frameworks to benefit from tools and theoretical results obtained for the other. 
These toolchains include tools for editing, code generation, and model checking.
We refer to \cite{biptools} and \cite{reotools,Arbab11} for details.

\paragraph{Contributions.} 
We relate the most important semantic models of BI(P)\footnote{\label{fn:prio}Although BIP's notion of priority is equally applicable to the constraint automata semantics of Reo, Reo provides no syntax to specify such global priority preferences. Reo does have a weaker priority mechanism to specify local preferences by means of context sensitive channel {\tt LossySync}, that prefers locally maximal dataflow.} (i.e., BIP without the priority layer) and Reo. 
For Reo we consider {\em port automata} and {\em constraint automata}, which model Reo connectors at different levels of abstraction \cite{JA12}. 
For BI(P) we consider {\em BIP architectures} \cite{ABBJS14} and {\em BIP interaction models}, i.e., sets of simple interaction expressions \cite{BBJS14}. 

First, we provide a short summary of BIP and Reo in \secn{overview}.
Then, in \secn{PA2Arch}, we define mappings between port automata and BIP architectures, and show that these distribute over composition modulo semantic equivalence.
Hence, it is possible to compute these translations incrementally, in order to speed them up. 
In \secn{CA2BIPconn}, we define mappings between stateless constraint automata and BIP interaction models.
We show that all transformations preserve all properties of observable dataflow, which, for example, enables one to transfer safety properties established for some generated code, or the results of model checking from one model to the other. 
These mappings in the data-sensitive domain do not distribute over composition, but in \secn{conclusion} we briefly discuss a different translation scheme that still allows incremental translation. There, we discuss also the differences and similarities between BI(P) and Reo and other coordination languages, and point out future work.


\paragraph{Related Work.}
Other authors have related and compared both BIP and Reo to other coordination languages. 
Bruni et al. encode BIP models into Petri nets \cite{BMM11}, and Chkouri et al. present a translation of AADL into BIP \cite{CRB+08}. 
Proen\c{c}a and Clarke provide a detailed comparison between Orc and Reo \cite{PC08}.
Arbab et al. provide a translation of Reo connectors into the Tile Model \cite{ABCLM09}.
Krause compared Reo to Petri nets \cite{Krause09}.
Talcott, Sirjani and Ren connect both ARC and PBRD to Reo by providing mappings between their semantic models \cite{TSR11}.

Although an indirect comparison of BIP and Reo through their respective comparisons with other models, e.g., Petri nets, is certainly possible, the direct and formal translations we present in this paper allows direct translation tools between BIP and Reo, that are otherwise difficult, if not impossible, to construct based on such indirect comparisons.



\section{Overview of BIP and Reo}
\label{sec:overview} 

\subsection{BIP}
\label{sec:bip}

A BIP system consist of a superposition of three layers: Behaviour, Interaction, and Priority.  
The behaviour layer encapsulates all computation, consisting of {\em atomic components} processing sequential code.
{\em Ports} form the interface of a component through which it interacts with other components.  
BIP represents these atomic components as \emph{Labeled Transition Systems} (LTS) having transitions labeled with ports and extended with data stored in local variables. 
The second layer defines component coordination by means of
\emph{BIP interaction models}~\cite{BBJS14}. 
For each \emph{interaction} among components in a BIP system, the interaction model of that system specifies the set of ports synchronized by that interaction and the way data is retrieved, filtered and updated in each of
the participating components.
In the third layer, priorities impose scheduling constraints to
resolve conflicts in case alternative interactions are possible. 
In the rest of this paper, we disregard priorities and focus mainly on
interaction models (cf., footnote \ref{fn:prio}).

\paragraph{Data-agnostic semantics.} 
We first introduce a data-agnostic semantics for BIP.

\begin{figure}[t]
\centering
\newcommand{\SCALE}{.75}
\subfigure[]{
\scalebox{\SCALE}{\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=1.5cm, semithick]
  \tikzstyle{every state}=[fill=red,draw=none,text=white]

  \node[elliptic state]         (A)              {};
  \node[elliptic state]         (B) [above of=A] {};

  \path (A) edge [bend left]  node {} (B);
  \path (B) edge [bend left]  node {} (A);
  \draw (-1,-0.8) rectangle (1,2.5);
  \draw (0.3,2) rectangle (0.8,2.5);
  \draw (-0.8,2) rectangle (-0.3,2.5);
  \node at (-0.55,2.25) {};
  \node at (0.55,2.25) {};
  \node at (-0.7,-0.6) {};
\end{tikzpicture}
\qquad
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=1.5cm, semithick]
  \tikzstyle{every state}=[fill=red,draw=none,text=white]

  \node[elliptic state] (A)              {};
  \node[elliptic state]         (B) [above of=A] {};

  \path (A) edge [bend left]  node {} (B);
  \path (B) edge [bend left]  node {} (A);
  \draw (-1,-0.8) rectangle (1,2.5);
  \draw (0.3,2) rectangle (0.8,2.5);
  \draw (-0.8,2) rectangle (-0.3,2.5);
  \node at (-0.55,2.25) {};
  \node at (0.55,2.25) {};
  \node at (-0.7,-0.6) {};
  \label{fig:mutexa}
\end{tikzpicture}}}
\qquad
\subfigure[]{
\scalebox{\SCALE}{\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=1.5cm, semithick]
  \tikzstyle{every state}=[fill=red,draw=none,text=white]

  \node[elliptic state] (A)              {};
  \node[elliptic state]         (B) [above of=A] {};

  \path (A) edge [bend left,left]  node {} (B);
  \path (B) edge [bend left,right]  node {} (A);
  \draw (-1,-0.8) rectangle (1,2.5);
  \draw (0.4,2) rectangle (0.9,2.5);
  \draw (-0.9,2) rectangle (-0.4,2.5);
  \node at (-0.65,2.25) {};
  \node at (0.65,2.25) {};
  \node at (-0.6,-0.6) {};
  \label{fig:mutexb}
\end{tikzpicture}}}

\caption{BIP components (a); coordinator (b).}
\label{fig:mutex}
\end{figure}

\begin{definition}[BIP component~\cite{ABBJS14}]
	\label{defn:bipcomp}
	A {\em BIP component}  over a set of ports  is a labeled transition system  over the alphabet . If  is a set of components, we say that  is \emph{disconnected} iff  for all distinct . Furthermore, we define .
\end{definition}

Then, BIP defines an \emph{interaction model} over a set of ports  to be a set of subsets of . 
Interaction models are used to define synchronisations among
components, which can be intuitively described as follows.  Given a
disconnected set of BIP components  and an interaction
model  over , the state space of the
corresponding {\em composite component}  is the
cross product of the state spaces of the components in ;
 can make a transition labelled by an interaction
 iff all the involved components (those that have ports
in ) can make the corresponding transitions.  A straightforward
formal presentation can be found in \cite{BliSif07-acp-emsoft} (cf., \defn{archapp} below).
Thus, BIP interaction models are \emph{stateless}: every interaction in  is always allowed; it is enabled if all ports in the interaction are ready.
However, \cite{ABBJS14} shows the need for statefull interaction, which motivates {\em BIP architectures}

\begin{definition}[BIP architecture~\cite{ABBJS14}]
\label{defn:archi}
A {\em BIP architecture} is a tuple , where  is a finite disconnected set of {\em coordinating} BIP components,  is a set of ports, such that , and  is a {\em data-agnostic interaction model}. We call ports in  {\em dangling ports} of .
\end{definition}

Essentially, a BIP architecture is a structured way of combining an interaction model  with a set of distinguished components, whose only purpose is to control which interactions in  are applicable at which point in time (which depends on the states of the coordinating components).

\begin{definition}[BIP architecture application~\cite{ABBJS14}]
   \label{defn:archapp}
   Let  be a BIP architecture, and  a set of components, such that  is finite and disconnected, and that . Write , with . Then, the {\em application  of  to } is the BIP component , where  is the smallest relation satisfying:  whenever
\begin{enumerate}
	\item , and there exists an  such that  and  for all ; or
	\item , and for all  we have  implies , and  implies .
\end{enumerate}
\end{definition}

The application , of a BIP architecture  to a set of BIP components , enforces coordination constraints specified by that architecture on those components~\cite{ABBJS14}.
The \emph{interface}  of 
contains all ports  of the coordinating components  and some
additional ports, which must belong to the components in .  In
the application , the ports belonging to  can
participate only in interactions defined by the interaction model
 of . 
Ports that do not belong to  are not restricted and can participate in any interaction.  

Intuitively, an architecture can also be viewed as an incomplete
system: the application of an architecture consists in ``attaching''
its dangling ports to the operand components.  The operational
semantics is that of composing all components (operands and
coordinators) with the interaction model as described in the previous
paragraph.  The intuition behind transitions labelled by 
is that they represent {\em observable idling} (as opposed to internal
transitions).  This allows us to ``desynchronise'' combined
architectures (see \defn{archcomp}) in a simple manner, since
coordinators of one architecture can idle, while those of another 
performs a transition.  Note that, if , in item 2
of \defn{archapp}, , hence also, , for all
.  Thus, intuitively, one can say that none of the components
moves.  Item 1, however, does allow one component to make a real move
labelled by , if such a move exists.  Thus, the transitions
labelled by  interleave, reflecting the idea that in BIP
synchronisation can happen only through ports.

\begin{example}[Mutual exclusion\cite{ABBJS14}]
  \label{ex:mutex:base}
  Consider the components  and  in \fig[(a)]{mutex}.  In order to
  ensure mutual exclusion of their \texttt{work} states, we apply the
  BIP architecture , where 
  is shown in \fig[(b)]{mutex},  and .  
  The interface  of  covers all ports of ,  and
  .  Hence, the only possible interactions are those that explicitly
  belong to .  
  Assuming that the initial states of  and  are \texttt{sleep},
  and that of  is \texttt{free}, neither
  of the two states  and
   is reachable, \ie the
  mutual exclusion property \mdash 
  where  and  are state variables of  and  respectively\mdash holds in  .
\tri\end{example}

\begin{definition}[Composition of BIP architectures~\cite{ABBJS14}]
\label{defn:archcomp}
Let  and  be two BIP architectures.
Recall that , for . 
If , then  is given by , where .
In other words,  is the interaction model defined by the conjunction of the characteristic predicates of  and .
\end{definition}

\paragraph{Data-aware semantics.} Recently, the data-agnostic formalization of BIP interaction models was extended with data transfer, using the notion of \emph{interaction expressions}~\cite{BBJS14}.
Let  be a global set of ports.
For each port , let  be a typed variable used for the data exchange at that port. 
For a set of ports , let .
An interaction expression models the effect of an interaction among ports in terms of the data exchanged through their corresponding variables.

\begin{definition}[Interaction expression~\cite{BBJS14}]
  \label{defn:expression}
  An {\em interaction expression} is an expression of the form
  {
    
  }
  where
   are {\em top} and {\em bottom} sets of ports;
   is a set of {\em local} variables;
   is the boolean {\em guard};
   and  are respectively the {\em up-} and {\em
    downward data transfer} expressions.

  For an interaction expression  as above, we define by
  ,  and
   the sets of top, bottom and all
  ports in , respectively.  We denote ,  and
   the guard, upward and downward transfer corresponding expressions in .
\end{definition}

The first part of an interaction expression, , describes
the control flow as a dependency relation between the bottom and
the top ports.  The expression in the brackets describes the data flow, first ``upward''---from bottom to top ports---and then ``downward''.
The guard  relates these two parts:
interaction is enabled only when the values of the local variables together
with those of variables associated to the bottom ports satisfy a boolean
condition. As a side effect, an interaction expression may also
modify local variables in .
Intuitively, such an interaction expression can \emph{fire} only if its guard is true.
When it fires, its upstream transfer is computed first using the values offered by its participating BIP components.  Then, the downstream
transfer modifies all the port variables with updated values.

\begin{definition}[BIP interaction models~\cite{BBJS14}]
	A {\em (data-aware) BIP interaction model} is a set  of {\em simple BIP connectors} , which are BIP interaction expressions of the form

where  is a single top port,  is a set of ports, such that , and neither  nor  involves local variables.
\end{definition}

\begin{example}[Maximum]
\label{ex:maximum}
	Let  be a set of ports of type integer, i.e., , for all , and consider the interaction expression (simple BIP connector)

where  is true. First, the connector takes the values presented at ports  and . Then, the simple BIP connector  computes atomically the maximum of  and  and assigns it to its local variable . Finally,  assigns atomically the value of  to both  and .  
\tri\end{example}

BIP interaction expressions capture complete information about all aspects
of component interaction---i.e. synchronisation and data transfer
possibilities---in a structured and concise manner.  Thus, by
examining interaction expressions, one can easily understand, on the one
hand, the interaction model used to compose components and, on the
other hand, how the valuations of data variables affect the
enabledness of the interactions and how these valuations are modified.
Furthermore, a formal definition of a composition operator on
interaction expressions is provided in \cite{BBJS14}, which allows combining
such expressions hierarchically to manage the complexity of systems
under design.  Since any BIP system can be flattened, this
hierarchical composition of interaction expressions is not relevant
for the semantic comparison of BIP and Reo in this paper.
Nevertheless, the possibility of concisely capturing all aspects of
component interaction in one place is rather convenient.





\subsection{Reo}
\label{sec:reo}

Reo is a coordination language wherein graph like structures express concurrency constraints (e.g., synchronization, exclusion, ordering, etc.) among multiple components. 
These structures consist of a composition of channels and nodes, collectively called \emph{connectors} or \emph{circuits}. 
A channel in Reo has exactly two \emph{ends}, and each end either accepts data items, if it is a \emph{source end}, or offers data items, if it is a \emph{sink end}. 
Moreover, a channel has a \emph{type} for its behaviour in terms of a formal constraint on the dataflow through its two ends. 
Its abstract definition of channels and its notion of channel types make Reo an extensible programming language.
Beside the established channel types (\tab{channels} contains some of them) Reo allows arbitrary user-defined channel types.

\begin{figure}[t]
\centering
\subfigure[BIP-like mutex]{\scalebox{.7}{\begin{tikzpicture}[baseline, node distance=1.3cm, every node/.style={transform shape}]
        \node[reobnode,label=above:]  (c1) [] {};
        \node[reonode]  (c2) [right of=c1] {};
        \node[reobnode,label=above:]  (c3) [right of=c2] {};
        \node[]  (c4) [below of=c1] {};
        \node[reonode]  (c5) [below of=c2] {};
        \node[]  (c6) [below of=c3] {};       
        \node[reobnode,label=below:]  (c7) [below of=c4] {};
        \node[reonode]  (c8) [below of=c5] {};
        \node[reobnode,label=below:]  (c9) [below of=c6] {};
        \node[]  (f1) [left of=c7] {};
        \node[]  (f2) [right of=c9] {};        
        \node[rectangle, draw, text centered, minimum height=2em] (B1) [below of=c1] {};
        \node[rectangle, draw, text centered, minimum height=2em] (B2) [below of=c3] {};
        \draw[sync,>->] (c1) to node {} (c2);
        \draw[sync,>->] (c3) to node {} (c2);
        \draw[sync,>->] (c7) to node {} (c8);
        \draw[sync,>->] (c9) to node {} (c8);
        \draw[syncdrain] (c2) to node {} (c5);
        \draw[fifo,>->] (c8) to node {} (c5);
        \draw[dotted, -] (B1) to node {} (c1);
        \draw[dotted, -] (B1) to node {} (c7);
        \draw[dotted, -] (B2) to node {} (c3);
        \draw[dotted, -] (B2) to node {} (c9);
        
        \node[] (above) [above of=c1] {};
        \node[] (below) [below of=c7] {};
\end{tikzpicture}
\label{fig:reomutexa}}}
\qquad
\subfigure[]{\scalebox{.7}{\begin{tikzpicture}[baseline, node distance=1.3cm, every node/.style={transform shape}]
        \node[reobnode,label=above:]  (c1) {};
        \node[reonode]  (c2) [below of=c1] {};
        \node[reobnode,label=below:]  (c3) [below of=c2] {};
        \draw[syncdrain] (c1) to node {} (c2);
        \draw[fifo,>->] (c3) to node {} (c2);
        
        \node[] (above) [above of=c1] {};
        \node[] (below) [below of=c3] {};
\end{tikzpicture}
\label{fig:reomutexb}}}
\qquad
\subfigure[Fool-proof mutex]{\scalebox{.7}{\begin{tikzpicture}[baseline, node distance=1.3cm, every node/.style={transform shape}]
        \node[]  (b1) [] {};
        \node[reobnode,label=above:]  (c1) [right of=b1] {};
        \node[reonode]  (c2) [right of=c1] {};
        \node[reobnode,label=above:]  (c3) [right of=c2] {};
        \node[]  (b2) [right of=c3] {};   
        \node[reonode]  (c4) [below of=c1] {};
        \node[reonode]  (c5) [below of=c2] {};
        \node[reonode]  (c6) [below of=c3] {};       
        \node[reobnode,label=below:]  (c7) [below of=c4] {};
        \node[reonode]  (c8) [below of=c5] {};
        \node[reobnode,label=below:]  (c9) [below of=c6] {};
        \node[]  (f1) [left of=c7] {};
        \node[]  (f2) [right of=c9] {};        
        \node[rectangle, draw, text centered, minimum height=2em] (B1) [below of=b1] {};
        \node[rectangle, draw, text centered, minimum height=2em] (B2) [below of=b2] {};
        \draw[sync,>->] (c1) to node {} (c2);
        \draw[sync,>->] (c3) to node {} (c2);
        \draw[sync,>->] (c7) to node {} (c8);
        \draw[sync,>->] (c9) to node {} (c8);
        \draw[dotted, -] (B1) to node {} (c1);
        \draw[dotted, -] (B1) to node {} (c7);
        \draw[dotted, -] (B2) to node {} (c3);
        \draw[dotted, -] (B2) to node {} (c9);
        \draw[syncdrain] (c1) to node {} (c4);
        \draw[syncdrain] (c2) to node {} (c5);
        \draw[syncdrain] (c3) to node {} (c6);
        \draw[fifo,>->] (c7) to node {} (c4);
        \draw[fifo,>->] (c8) to node {} (c5);
        \draw[fifo,>->] (c9) to node {} (c6);
        
        \node[] (above) [above of=c1] {};
        \node[] (below) [below of=c7] {};
\end{tikzpicture}
\label{fig:reomutexc}
}}
\qquad
\subfigure[Generated mutex]{\scalebox{.7}{\begin{tikzpicture}[baseline, node distance=1.3cm, every node/.style={transform shape}]
	\node[draw,thick,circle, label={[label distance=-0.46cm]0:X}] (a1) [] {};
	\node[reonode] (a2) [above right of=a1] {};
	\node[reonode] (a3) [right of=a2] {};
	\node[reonode] (a4) [right of=a3] {};
	\node[reonode] (a5) [below right of=a4] {};
	\node[reonode] (a6) [below right of=a1] {};
	\node[reonode] (a7) [right of=a6] {};
	\node[reonode] (a8) [right of=a7] {};
	\node[reonode] (a9) [below of=a5] {};
	\node[draw,thick,circle, label={[label distance=-0.46cm]0:X}] (a11) [below of=a9] {};
	\node[reonode] (a12) [above left of=a11] {};
	\node[reonode] (a13) [left of=a12] {};
	\node[reonode] (a14) [left of=a13] {};
	\node[reonode] (a15) [below left of=a14] {};
	\node[reonode] (a16) [below left of=a11] {};
	\node[reonode] (a17) [left of=a16] {};
	\node[reonode] (a18) [left of=a17] {};
	\node[reonode] (a19) [above of=a15] {};
	\node[reonode] (a20) [above left of=a1] {};
	\node[reonode] (a21) [below left of=a1] {};
	\node[reonode] (a22) [above right of=a11] {};
	\node[reonode] (a23) [below right of=a11] {};
	
	\node[reonode,label=left:] (b1) [below left of=a3] {};
	\node[reonode,label=right:] (b2) [above right of=a7] {};
	\node[reonode,label=left:] (f1) [below left of=a13] {};
	\node[reonode,label=right:] (f2) [above right of=a17] {};
	
	\draw[syncdrain] (a3) to node {} (b1);
	\draw[syncdrain] (a7) to node {} (b2);
	\draw[syncdrain] (a13) to node {} (f1);
	\draw[syncdrain] (a17) to node {} (f2);
	
	\draw[fifo,>->] (a2) to node {} (a3);
	\draw[fifo,>->] (a3) to node {} (a4);
	\draw[fifo,>->] (a6) to node {} (a7);
	\draw[fifo,>->] (a7) to node {} (a8);
	\draw[fifo,>->] (a12) to node {} (a13);
	\draw[fifo,>->] (a13) to node {} (a14);
	\draw[fifo,>->] (a16) to node {} (a17);
	\draw[fifo,>->] (a17) to node {} (a18);
	\draw[fifo,>->] (a5) to node {} (a9);
	\draw[fifo,>->] (a9) to node {} (a11);
	\draw[fifo,>->] (a15) to node {} (a19);
	\draw[fifofull,>->] (a19) to node {} (a1);
	\draw[fifo,>->] (a2) to node {} (a3);
	\draw[fifo,>->] (a2) to node {} (a3);
	\draw[fifo,>->] (a2) to node {} (a3);
	
	\draw[fifo,>->] (a1) to node {} (a20);
	\draw[fifo,>->] (a21) to node {} (a1);
	\draw[fifo,>->] (a11) to node {} (a22);
	\draw[fifo,>->] (a23) to node {} (a11);
	
	\draw[sync,>->] (a1) to node {} (a2);
	\draw[sync,>->] (a1) to node {} (a6);
	\draw[sync,>->] (a4) to node {} (a5);
	\draw[sync,>->] (a8) to node {} (a5);
	\draw[sync,>->] (a11) to node {} (a12);
	\draw[sync,>->] (a11) to node {} (a16);
	\draw[sync,>->] (a14) to node {} (a15);
	\draw[sync,>->] (a18) to node {} (a15);
	\draw[sync,>->] (a20) to node {} (a21);
	\draw[sync,>->] (a22) to node {} (a23);
        
    \node[] (below) [below of=a11] {};
	
\end{tikzpicture}
\label{fig:generatedmutex}}}
\caption{Fool-proof (c) mutual exclusion protocol in Reo, composed from a BIP-like (a) mutual exclusion connector and an altenator connector (b), and the generated Reo circuit (d) from \ex{mutextranslation}.}
\label{fig:reomutex}
\end{figure}

Multiple ends may glue together into \emph{nodes} with a fixed \emph{merge-replicate} behaviour: a data item out of a single sink end coincident on a node, atomically propagates to all source ends coincident on that node. This propagation happens only if all their respective channels allow the data exchange. 
A node is called a \emph{source node} if it consists of source ends, a \emph{sink node} if it consists of sink ends, and a \emph{mixed node} otherwise. 
Together, the source and sink nodes of a connector constitute its set of \emph{boundary nodes/ports}.


\begin{example}
\label{ex:reomutex}
\fig{reomutexa} shows a Reo connector that achieves mutual exclusion of components  and , exactly as the BIP system shown in \fig{mutex} does. This connector consists of a composition of channels and nodes in \tab{channels}. The Reo connector atomically accepts data from either  or  and puts it into the {\tt FIFO1} channel, a buffer of size one.
A full {\tt FIFO1} channel means that  or  holds the lock. 
If one of the components writes to  or , the {\tt SyncDrain} channel flushes the buffer, and the lock is released, returning the connector to its initial configuration, where  and  can again compete for exclusive access by attempting to write to  or .

Note that this connector is not fool-proof. Even if  takes the lock,  may release it, and vice versa. 
Hence, exactly as the BIP architecture in \fig{mutex}, the Reo connector in \fig{reomutexa} relies on the conformance of the coordinated components  and . 
The expected behaviour of , , is that it alternates writes on the  and , and that every write on  comes after a write on .
Depending on such assumptions may not be ideal.
The connector, shown in \fig{reomutexb}, makes this expected behaviour explicit. 
By composing two such connectors with the connector in \fig{reomutexa}, we obtain a fool-proof mutual exclusion protocol, as shown in \fig{reomutexc}. 
\fig{foolproofmutex} shows the constraint automaton semantics of the connector in \fig{reomutexc}.
Unlike the case of the connector in \fig{reomutexa} or the BIP architecture in \fig{mutex}, non-compliant writes to  or  ports of the connector in \fig{reomutexc} will {\em block} component , but cannot {\em break} the mutual exclusion protocol that this connector implements.
\tri
\end{example}

\paragraph{Formal semantics of Reo.} 
Reo has a variety of formal semantics \cite{Arbab11, JA12}. In this paper we use its operational \emph{constraint automaton} (CA) semantics \cite{BSAR06}.

\begin{definition}[Constraint automata \cite{BSAR06}] 
\label{defn:CA} 
Let  be a set of nodes and  a set of data items. A data constraint is a formula in the language of the grammar

where variable  represents the data assigned to (i.e., exchanged through) port .
Let  denote the obvious satisfaction relation between data constraints and data assignments , with , and write  for the set of all data constraints.
A constraint automaton (over data domain ) is a tuple

where  is a set of states,  is a finite set of nodes,  is a transition relation, and   is the initial state.
\end{definition}

In this paper, we consider only finite data domains, although most of our results generalize to infinite data domains. Over a finite data domain, the data constraint language  is expressive enough to define any data assignment. 
For notational convenience, we relax, in this paper, the definition of data constraints and allow the use of set-membership and functions in the data constraints. However, we preserve the intention that a data constraint describes a set of data assignments.

\tab{channels} shows the CA semantics for some typical Reo primitives.
The CA semantics of every Reo connector can be derived as a composition of the constraint automata of its primitives, using the CA product operation in \defn{ProductCA}.
On the other hand, every constraint automaton (over a finite data domain) translates back into a Reo connector~\cite{BKK14}.
Because of this correspondence, we may consider Reo and CA as equivalent, and focus on constraint automata only.
\begin{table}[t]
\begin{center}
\begin{tabular}{ccccc}
{\tt Sync} 
& 
{\tt LossySync} 
& 
{\tt SyncDrain} 
&
{\tt FIFO1} 
&
{\tt Node} 
\\
\hline
\adjustbox{valign=c}{\scalebox{.8}{\begin{tikzpicture}
  \node[label=above:] (in) at (0,0) {};
  \node[right of= in, xshift=1cm,label=above:] (out) {};
  \draw[sync,>->] (in) -- (out); 
\end{tikzpicture}}}
&
\adjustbox{valign=c}{\scalebox{.8}{\begin{tikzpicture}
  \node[label=above:] (in)                {};
  \node[right of=in, xshift=1cm,label=above:] (out)  {};
  \draw[lossysync,>->] (in) -- (out);
\end{tikzpicture}}}
& 
\adjustbox{valign=c}{\scalebox{.8}{\begin{tikzpicture}
  \node[label=above:] (in)                {};
  \node[right of=in, xshift=1cm,label=above:] (out)  {};
  \draw[syncdrain,>-<] (in) -- (out);
\end{tikzpicture}}}
& 
\adjustbox{valign=c}{\scalebox{.8}{\begin{tikzpicture}
  \node[label=above:] (in) at (0,0) {};
  \node[right of=in, xshift=1cm,label=above:] (out)  {};
  \draw[fifo,>->] (in) -- (out);
\end{tikzpicture}}}
&
\adjustbox{valign=c}{\scalebox{.8}{\begin{tikzpicture}
  \node[reobnode] (A) at (0,0) [] {};
  \node[above right of=A, node distance=.7cm, inner sep=1pt] (A1) {};
  \node[above left of=A, node distance=.7cm, inner sep=1pt] (A2) {};
  \node[below left of=A, node distance=.7cm, inner sep=1pt] (A3) {};
  \node[below right of=A, node distance=.7cm, inner sep=1pt] (A4) {};
\draw[sync,->] (A1) -- (A);
  \draw[sync,>-] (A) -- (A2);
  \draw[sync,->] (A3) -- (A);
  \draw[sync,>-] (A) -- (A4);
\end{tikzpicture}}} 
\\ 
\\
\adjustbox{valign=c}{\scalebox{.8}{\begin{tikzpicture}[->,initial text={},>=stealth',shorten >=1pt,auto,node distance=1.5cm, semithick,scale=0.8, every node/.style={transform shape}]
  \tikzstyle{every state}=[fill=red,draw=none,text=white]

  \node[state] (A)              {};

  \path (A) edge [in=110,out=70,loop above]  node {} (A);
\end{tikzpicture}}}
&
\adjustbox{valign=c}{\scalebox{.8}{\begin{tikzpicture}[->,initial text={},>=stealth',shorten >=1pt,auto,node distance=1.5cm, semithick,scale=0.8, every node/.style={transform shape}]
  \tikzstyle{every state}=[fill=red,draw=none,text=white]

  \node[state] (A)              {};

  \path (A) edge [in=110,out=70,loop above]  node {} (A);
  \path (A) edge [in=290,out=250,loop below]  node {} (A);
\end{tikzpicture}}}
&
\adjustbox{valign=c}{\scalebox{.8}{\begin{tikzpicture}[->,initial text={},>=stealth',shorten >=1pt,auto,node distance=1.5cm, semithick,scale=0.8, every node/.style={transform shape}]
  \tikzstyle{every state}=[fill=red,draw=none,text=white]

  \node[state] (A)              {};

  \path (A) edge [in=110,out=70,loop above]  node {} (A);
\end{tikzpicture}}}
&
\adjustbox{valign=c}{\scalebox{.8}{\begin{tikzpicture}[->,initial text={},>=stealth',shorten >=1pt,auto,node distance=1.5cm, semithick,scale=0.8, every node/.style={transform shape}]
  \tikzstyle{every state}=[fill=red,draw=none,text=white]

  \node[state,initial] (A)              {};
  \node[state] (B) [right of=A] {};

  \path (A) edge [bend left=70] node [above] {} (B);
  \path (B) edge [bend left=70] node [below] {} (A);
\end{tikzpicture}}}
&
\adjustbox{valign=c}{\scalebox{.8}{\begin{tikzpicture}[->,initial text={},>=stealth',shorten >=1pt,auto,node distance=1.5cm, semithick,scale=0.8, every node/.style={transform shape}]
  \tikzstyle{every state}=[fill=red,draw=none,text=white]

  \node[state] (A)              {};

  \path (A) edge [in=110,out=70,loop above] node {} (A);
  \path (A) edge [in=290,out=250,loop below]  node {} (A);
\end{tikzpicture}}}
\\
\hline
\end{tabular}
\end{center}
\caption{Some primitives in the Reo language with CA semantics over a singleton data domain .}
\label{tab:channels}
\end{table}

If a constraint automaton  has only one state,  is called \emph{stateless}. 
If the data domain  of  is a singleton,  is called a \emph{port automaton} \cite{KC09}. In that case, we omit data constraints, because all satisfiable constraints reduce to .

\begin{definition}[Product of CA \cite{BSAR06}]
\label{defn:ProductCA} 
Let  be a constraint automaton, for . Then the product  of these automata is the automaton , whose transition relation is the smallest relation obtained by the rule:  whenever
\begin{enumerate}
	\item , , and , or
	\item , , , , and  with .
\end{enumerate}
\end{definition}

It is not hard to see that constraint automata product operator is associative and commutative modulo equivalence of state names and data constraints.

\begin{definition}[Hiding in CA \cite{BSAR06}]
\label{defn:HidingCA} 
Let  be a constraint automaton, and  a set of nodes. Then hiding nodes  of  yields an automaton , where  is given by .
\end{definition}

The hiding operator affects only transition labels, and preserves the structure of the automaton. 
Hence the hiding operator offers a technique to alter the interface of a component or connector without modifying its behaviour. 
As hiding of non-shared nodes distributes over the product, hiding of non-shared nodes commutes with constraint automata product.

\begin{example}[Product and hide]
\label{ex:prodhide}
Consider the Reo connectors in \fig{reomutex}. Using \defn{ProductCA}, and the primitive constraint automata from \tab{channels}, we find their CA semantics as shown in Figures \ref{fig:biplikemutex}, \ref{fig:alternator}, and \ref{fig:foolproofmutex}, respectively. 
If we compute the product of the automaton  in \fig{biplikemutex} with the automata , , in \fig{alternator}, then we obtain an automaton , whose part reachable from the initial state  is shown in \fig{foolproofmutex}.
\tri\end{example}






\section{Port automata and BIP architectures}
\label{sec:PA2Arch}

To study the relation between BIP and Reo with respect to synchronization, we start by defining a correspondence between them in the data-agnostic domain. This correspondence consists of a pair of mappings between the sets containing semantic models of BIP and Reo connectors.
For the data independent semantic model of Reo connectors we choose port automata: a restriction of constraint automata over a singleton set as data domain. We model BIP connectors by BIP architectures introduced in \cite{ABBJS14}. 
In order to compare the behaviour of BIP and Reo connectors we interpret them as labeled transition systems. 
We define a mapping  that transforms BIP architectures into port automata, and a mapping  that transforms port automata into BIP architectures. 
We then show that these mappings preserve (1) properties closed under bisimulation, and (2) composition structure modulo semantic equivalence.

\subsection{Interpretation of BIP and Reo}
\label{sec:interpr_no_data}
To compare the behaviour of BIP and Reo connectors, we interpret all connectors as labeled transitions systems with one initial state and an alphabet , for a set of ports . 
We write  for the class of all such labeled transition systems. 

\begin{figure}[t]
\centering
\subfigure[data-agnostic domain]{\scalebox{1}{
\begin{tikzpicture}[baseline={([yshift=-.5ex]current bounding box.center)}]
  \matrix (m) [matrix of math nodes,row sep=1.5em,column sep=4em,minimum width=2em,ampersand replacement=\&]
  {
     \mathrm{Reo} \&  \& \mathrm{BIP} \\
     \PA \&  \& \Arch \\
     \& \LTS \& \\};
  \draw[-latex] (m-2-1) to node [below left] {} (m-3-2);
  \draw[-latex] (m-2-1.10) to node [above] {} (m-2-3.170);
  \draw[-latex] (m-2-3) edge node [below right] {} (m-3-2);
  \draw[-latex] (m-2-3.190) to node [below] {} (m-2-1.350);
  \draw[-latex] (m-1-1) to [bend left=10] node [right] {\cite{BSAR06}} (m-2-1);
  \draw[-latex] (m-2-1) to [bend left=10] node [left] {\cite{BKK14}} (m-1-1);
  \draw[-] (m-1-3.260) to node [right] {\cite{ABBJS14}} (m-2-3.100);
  \draw[-] (m-2-3.80) to node [] {} (m-1-3.280);
\end{tikzpicture}
\label{fig:intpr1}
}}
\qquad
\subfigure[data-sensitive domain]{\scalebox{1}{
\begin{tikzpicture}[baseline={([yshift=-.5ex]current bounding box.center)}]
  \matrix (m) [matrix of math nodes,row sep=1.5em,column sep=4em,minimum width=2em,ampersand replacement=\&]
  {
     \mathrm{Reo} \&  \& \mathrm{BIP} \\
     \CA \&  \& \BC \\
     \& \LTS \& \\};
  \draw[-latex] (m-2-1) to node [below left] {} (m-3-2);
  \draw[-latex] (m-2-1.10) to node [above] {} (m-2-3.170);
  \draw[-latex] (m-2-3) edge node [below right] {} (m-3-2);
  \draw[-latex] (m-2-3.190) to node [below] {} (m-2-1.350);
  \draw[-latex] (m-1-1) to [bend left=10] node [right] {\cite{BSAR06}} (m-2-1);
  \draw[-latex] (m-2-1) to [bend left=10] node [left] {\cite{BKK14}} (m-1-1);
  \draw[-] (m-1-3.260) to node [right] {\cite{BBJS14}} (m-2-3.100);
  \draw[-] (m-2-3.80) to node [] {} (m-1-3.280);
\end{tikzpicture}
\label{fig:intpr2}
}}
\caption{Translations and interpretations in data-agnostic and data-sensitive domain.}
\label{fig:intpr}
\end{figure}

\fig{intpr1} shows our translations and interpretations. The objects ,  and  are, respectively, the classes
of port automata, BIP architectures, and labeled transition systems. The mappings , ,  and , respectively, translate Reo to BIP, BIP to Reo, Reo to LTS, and BIP to LTS.

We first consider the semantics of connectors. Since BIP connectors differ internally from Reo connectors, we restrict our interpretation to their observable behaviour. This means that we hide the ports of the coordinating components in BIP architectures. For port automata this means that for our comparison, we implicitly assume that all names represent boundary nodes.

The interpretation of a port automaton in LTS is defined by

Hence  acts essentially as an identity function, justifying our choice of interpretation. 
Next, we define the interpretation of BIP architectures using their operational semantics obtained by applying them on dummy components and hiding all internal ports. 
Let  be a BIP architecture with coordinating components , , and . 
Recall that  is the set of internal ports in . Define 
 as a dummy component relative to the BIP architecture .
Using \defn{archapp}, we compute the BIP architecture application  of  to its dummy component . 
Then, 

In other words,  equals  after hiding all internal ports .
Note that we based our interpretation  on the operational semantics of BIP architectures, i.e., BIP architecture application. This justifies the definition of interpretation of architectures.

Because of hiding,  is not injective. Hence, our interpretation of BIP architectures induces a non-trivial equivalence given by equality of interpretations. In the sequel, we use a slightly stronger version of equivalence based on bisimulation \cite{Milner89}. 

\begin{definition}[Bisimulation~\cite{Milner89}]
\label{defn:bisim}
If , , then  and  are \emph{bisimilar} () iff  and there exists  such that , and  implies, for all ,  with , if , then, for some ,  and .
\end{definition}

\begin{definition}[Semantic equivalence]
	Let  be port automata and  be BIP architectures. Then,  and  are {\em semantically equivalent} () iff , and  and  are {\em semantically equivalent} () iff .
\end{definition}


With a common semantics for BIP and Reo, we can define the notion of preservation of properties expressible in this common semantics. Recall that a property of labeled transition systems corresponds to the subset of labeled transition systems satisfying that property. 

\begin{definition}
\label{defn:prop-data-agnostic}
Let  be a property. Then, \emph{ preserves } iff  for all . Similarly, \emph{ preserves } iff  for all .
\end{definition}



\subsection{BIP to Reo}
\label{sec:bip2reo_a}
To translate BIP connectors to Reo connectors, we first determine what elements of BIP architectures correspond to Reo connectors. Our interpretations of port automata and BIP architectures show that dangling ports in BIP architectures correspond to boundary port names in port automata. Furthermore, the mutual exclusion of the interactions in an interaction model in a BIP architecture simulates mutually exclusive firing of transitions in port automata. The definition of a coordinating component in a BIP architecture is almost identical to that of a port automaton, yielding an obvious translation.

\begin{figure}[t]
\centering
\subfigure[BIP-like mutex]{
\scalebox{.8}{
\begin{tikzpicture}[->, initial text={}, initial where=above,>=stealth',shorten >=1pt,auto,node distance=1.5cm, semithick]
  \tikzstyle{every state}=[fill=red,draw=none,text=white]

  \node[state, initial] (A)              {};
  \node[state] (B) [right of=A,xshift=0.8cm] {};

  \path (A) edge [bend left=10,above] node {} (B);
  \path (A) edge [bend left=70,above] node {} (B);
  \path (B) edge [bend left=10,below] node {} (A);
  \path (B) edge [bend left=70,below] node {} (A);
  \label{fig:biplikemutex}
\end{tikzpicture}}}
\subfigure[]{
\scalebox{.8}{
\begin{tikzpicture}[->, initial text={}, initial where=above,>=stealth',shorten >=1pt,auto,node distance=1.5cm, semithick]
  \tikzstyle{every state}=[fill=red,draw=none,text=white]

  \node[state,initial] (A)              {};
  \node[state] (B) [below of=A] {};

  \path (A) edge [bend left=10,right] node {} (B);
  \path (B) edge [bend left=10,left] node {} (A);
  \label{fig:alternator}
\end{tikzpicture}}}
\subfigure[Fool-proof mutex]{
\scalebox{.8}{
\begin{tikzpicture}[->, initial text={}, initial where=left,>=stealth',shorten >=1pt,auto,node distance=1.5cm, semithick]
  \tikzstyle{every state}=[fill=red,draw=none,text=white]

  \node[elliptic state,initial] (A)              {};
  \node[elliptic state] (B) [above of=A] {};
  \node[elliptic state] (C) [below of=A] {};

  \path (A) edge [bend left=50,left]  node {} (B);
  \path (A) edge [bend left=50,right]  node {} (C);
  \path (B) edge [bend left=50,right]  node {} (A);
  \path (C) edge [bend left=50,left]  node {} (A);
  \label{fig:foolproofmutex}
\end{tikzpicture}}}
\subfigure[]{
\scalebox{.8}{
 \begin{tikzpicture}[->, initial text={}, initial where=right,>=stealth',shorten >=1pt,auto,node distance=1.5cm, semithick]
  \tikzstyle{every state}=[fill=red,draw=none,text=white]
  \node[state]         (A)              {};
  \path (A) edge [in=8,out=64,loop,above right]  node {} (A);
  \path (A) edge [in=80,out=136,loop,above]  node {} (A);
  \path (A) edge [in=152,out=208,loop,above left]  node {} (A);
  \path (A) edge [in=224,out=280,loop,left]  node {} (A);
  \path (A) edge [in=296,out=352,loop,below]  node {} (A);
  \label{fig:mutexaReo}
\end{tikzpicture}}}
\subfigure[]{
\scalebox{.8}{
\begin{tikzpicture}[->, initial text={}, initial where=left,>=stealth',shorten >=1pt,auto,node distance=1.5cm, semithick]
  \tikzstyle{every state}=[fill=red,draw=none,text=white]

  \node[elliptic state,initial] (A)              {};
  \node[elliptic state] (B) [below of=A] {};

  \path (A) edge [loop above,left]  node {} (A);
  \path (B) edge [loop below,right]  node {} (B);
  \path (A) edge [bend left=10,right]  node {} (B);
  \path (A) edge [bend left=70,right]  node {} (B);
  \path (B) edge [bend left=10,left]  node {} (A);
  \path (B) edge [bend left=70,left]  node {} (A);
  \label{fig:mutexbReo}
\end{tikzpicture}}}
\caption{CA representations , , and  of Reo connectors Figures \ref{fig:reomutexa}, \ref{fig:reomutexb}, and \ref{fig:reomutexc}, respectively; translation of the interaction model  and BIP architecture  of Figure \ref{fig:mutex}.}
\label{fig:mutexReo}
\end{figure}

Let  be a BIP architecture, with . Each  corresponds trivially to a port automaton . Let  be the stateless port automaton over  with transition relation  defined by . Then  can be seen as the port automata encoding of the interaction model . Recall that . The corresponding port automaton of  is given by 


\begin{example}
\label{ex:mutextranslation}
We translate the BIP architecture in \ex{mutex:base} using \eq{ReoPA}. 
First, we transform  into a port automaton , shown in \fig{mutexaReo}. Then, we compute the product of  with the coordinating component  to obtain the port automaton corresponding to the BIP architecture , shown in \fig{mutexbReo}.
As mentioned in section \secn{reo}, we can transform the port automaton in \fig{mutexbReo} into a Reo connector, using the method described in \cite{BKK14}.
This mechanical translation yields the Reo connector in \fig{generatedmutex}. 
Here, the dot in the {\tt FIFO1} buffer indicates that its initial state is the full state.
The crossed node represents an {\em exclusive router}, which atomically takes data from a coincident sink end, and provides it to a single coincident source end.
Note that the port automaton semantics of the connector in \fig{reomutexa} (see \fig{biplikemutex}) is similar to the automaton in \fig{mutexbReo}, up to empty transitions.
\tri\end{example}


\subsection{Reo to BIP}

In BIP, interaction is memoryless. This means that a stateful channel in Reo must translate to a coordinating component. In fact, we may encode the whole Reo connector as one such component. 

Let , , be two port automata, and let  be a shared port of  and . Suppose that we know how to translate  into a BIP architecture . If  is not a dangling port of , then, by symmetry,  is not a dangling port of . But now,  and  are not composable, because there components are not disconnected. Hence, since we want the translation to preserve composition,  should be a dangling port.

Let  be a port automaton. We construct a corresponding BIP architecture. Duplicate all ports in  by defining  for all . We do not use a port , for , for composition. Their exact name is therefore not important, but merely their relation to its dangling brother . Trivially, , with , is a BIP component (cf., \defn{bipcomp}). Essentially,  and  are the same labeled transition system. Now we define:

Thus,  uses the port automaton as the coordinating component of the generated BIP architecture.

\begin{example}
Let  be the port automaton in \fig{alternator} over the name set . We determine . Obtain  by adding adding a prime to each port in . The interaction model of  consist of  Hence,  is given by th BIP architecture .
\end{example}


\subsection{Preservation of properties}

To confirm that translations  and  preserve properties, we first investigate whether \fig{intpr1} commutes, i.e.,  and , for  and .

First, note that the equations  and  cannot hold, because their state spaces differ. For example,  alters the state space by adding the state of a dummy component, and  adds the state of the port automaton encoding of the interaction model. Therefore we view these equations modulo bisimulation of labeled transition systems from \defn{bisim}.

Next, consider the equation , for some BIP architecture . Suppose that two distinct coordination components  and , , each contains an empty-labeled transition, i.e., there exist transistions  and . When we translate  to a port automaton using , the second rule in \defn{ProductCA} yields a \emph{single} transition in  from a global state where component  is in state  and  is in state , to a global state where  is in state  and  is in state . However, BIP semantics does not allow independent progress of state-changing empty-labeled transitions, which means that this single transition exists only when  and . Indeed, the first rule of \defn{archapp} allows either  or  to change state, and the second rule implies  and  for . Because of this, we need to exclude BIP architectures where two coordinating components can make a state-changing empty-labeled transition. Moreover, as we consider composition of BIP architectures in \secn{compatcomposition}, we exclude BIP architectures containing a single coordinating component that can make a state-changing empty-labeled transition, and restrict  to 
.
Finally, consider the equation , for some port automaton . Note that the interaction model of  contains the empty set. Hence, the second rule in \defn{archapp} yields empty-labeled self-transitions in . Since  acts like the identity, we conclude that  should have empty-labeled self-transitions, i.e.,  implies . On the other hand, suppose that . Then the coordinating component of  should not contain a state-changing empty-labeled transition, hence . Therefore, we restrict  to .

\begin{theorem}
\label{thm:commute_a} 
For all  and  we have  and .
\end{theorem}

\begin{proof}
Using \defn{archapp}, \defn{ProductCA}, , , and the fact that , it follows that (1)  given by  for all  is a bisimulation between  and , where  is the state space of , and (2)  given by  for all , is a bisimulation, where , , are the state spaces of the coordinating components of . 
See \cite{bip2reo} for a detailed proof.
\end{proof}

\begin{corollary}
\label{cor:props_pa2arch}
 and  preserve all properties closed under bisimulation, i.e., for all ,  and  we have  and .
\end{corollary}

\begin{example}
	Consider the following safety property  satisfied by the Reo connector in \fig{reomutexc}: ``if  fires, then  fires only after  fires''. Clearly, the automaton , obtained from \fig{foolproofmutex} by adding empty self-transitions, satisfies this property as well. Using \cor{props_pa2arch}, we conclude that the BIP architecture  satisfies . More generally, \cor{props_pa2arch} allows model checking of BIP architectures with Reo model checkers. 
\tri\end{example}


\subsection{Compatibility with composition} 
\label{sec:compatcomposition}

BIP architectures and port automata have their own notions of composition.
This raises the question of whether our translations preserve composition structures. 
We show that, under specific conditions, our translations preserve composition modulo semantic equivalence. Recall the port automaton representation of the interaction model (\secn{bip2reo_a}).

\begin{lemma}
\label{lem:interaction}
Let , , with  and .  
Then, we have that ,
where  be the interaction model of .
\end{lemma}

\begin{proof}
Follows easily from \defn{ProductCA} and \defn{archcomp}. See \cite{bip2reo} for a detailed proof.
\end{proof}

Suppose that , for any two BIP architectures . \defn{ProductCA} implies . In other words, the name set of port automaton  is the union of the name set of the port automata , . Hence, , for . This means that the dangling ports of  contain all dangling ports of . Therefore, we need to assume that .

Note that this is only a mild assumption. Indeed, if  is a dangling port of , connected directly to a component in . Then, we first add a (dangling) port  to  and synchronize  with  by considering the BIP interaction model . Finally, we rename  to  in . The resulting architectures satisfy the assumption.

\begin{theorem}
\label{thm:homreo} 
 for all , with  and .
\end{theorem}

\begin{proof}
Let , with  iff . By definition, we have . Next, we use the bisimulation of port automata (i.e., constraint automata with data contraint ) as defined in \cite{BSAR06}. Composition () of port automata is commutative and associative up to bisimulation \cite{BSAR06}. Using \lem{interaction}, it follows that .
Indeed, since  is like the identity, it follows that semantic equivalence  coincides with bisimulation  of port automata as defined in \cite{BSAR06}.
Now, we use our assumption that , and the fact that , and  do not use ports from . Then, .
We conclude that .
Since,  is like the identity, it is not hard to see that  takes bisimilar port automata to bisimilar labeled transition systems. Therefore,  is a homomorphism up to semantic equivalence, i.e., .
\end{proof}

\begin{theorem}
\label{thm:hombip}
 for all .
\end{theorem}

\begin{proof}
Note that, since  is like the identity, semantic equivalence  coincides with bisimulation  of port automata \cite{BSAR06}. As  is a congruence with respect to the composition  of port automata, we conclude that  is a congruence too (i.e., , for , implies ). 

Let , , be two port automata. From \thm{homreo}, we conclude that
, for any . Substitute , for . Then,
. Thus, , for , by \thm{commute_a}. Hence, using that  is a congruence, we obtain . Therefore, .
\end{proof}

\begin{example}
	For any two ports  and , let  be the port automaton of a synchronous channel (cf., \tab{channels}), and let  be its corresponding BIP component. Suppose we need to translate  to a BIP architecture. Then we first compute , with . Next, we compute , with . Note that we need to use a double prime now, because otherwise  would be a shared port of  and . Using \thm{hombip}, we find that , where  is the composition of  and .
\end{example}

\begin{example}
Consider the port automaton , obtained from \fig{foolproofmutex} by adding empty self-transitions. If we translate  to BIP, we obtain a BIP architecture , which has only a single coordinating component. From \ex{prodhide} we conclude , where  is the port automaton in \fig{biplikemutex}, , , is the port automaton in \fig{alternator}, and  is obtained from  by adding empty self-transitions. Now consider . Using \defn{archcomp}, we see that  has three coordinating components. Nevertheless, \thm{hombip} shows that  is semantically equivalent to . Therefore, \thm{hombip} allows to compute translations compositionally.
\tri\end{example}




\section{Stateless CA's and interaction models}
\label{sec:CA2BIPconn}

In \secn{PA2Arch} we established a correspondence between port automata and BIP architectures. Here, we offer translations between data-aware connector models in BIP and Reo.

First we determine the semantic model of the connectors. For BIP connectors we use BIP interaction models, i.e., sets of interaction expressions , with a single top port that is not a bottom port, and whose guard and up functions are independent of local variables (\defn{expression}). We assume that every top port occurs only in one interaction expression per BIP interaction model. We denote the class of BIP interaction models by .
For the semantics of Reo connectors we take a pair consisting of a constraint automaton together with a partition of its node set into source nodes , mixed nodes , and sink nodes . We call such pairs \emph{constraint automata with polarity}. 
Due to the absence of coordinating components in the data sensitive model for BIP, we restrict ourselves here to stateless constraint automata, since BIP interaction expressions are stateless \cite{ABBJS14, BBJS14}.
We write  for the class of all stateless constraint automata with polarity, with  and  for some set of ports . This assumption is necessary to enable simulation of bidirectional ports in BIP. The reason we explicitly distinguish node types in this semantics is to give direction to dataflow, similar to BIP connectors. Usually such node type distinctions are implicit, but for preciseness we encode them as a partition within the semantics of Reo connectors. 

As in \secn{PA2Arch}, we interpret all connectors as labeled transition systems. Then we define translations between Reo connectors () and BIP connectors (), and show that they preserve properties.


\subsection{Interpretation of BIP and Reo}
\label{sec:interpretation2}
An important difference between BIP and Reo involves how they handle data. 
BIP uses bidirectional ports, while Reo treats input and output ports separately.
Since the common semantics should support both approaches, we duplicate every bidirectional port of BIP to obtain two unidirectional ports, compatible with Reo.
The sense of every reference to a bidirectional port in a BIP interaction expression maps that bidirectional port to its intended corresponding unidirectional port.

Let  be the class of all labeled transition systems over an alphabet , where  is a set of data items;  contains \emph{void} or \emph{null}, modeling the absence of data; and  is the \emph{duplicated (unidirectional) port set} of a set of (bidirectional) ports , that is, . If data appears at  (i.e.,  for ), then we interpret this as input to the connector. If data appears at , then we interpret this at output from the connector. 

Consider \fig{intpr2}. Classes  and  consist of constraint automata with polarity and interaction models. Morphisms  and  are translations of those classes and  and  are interpretations in a common  semantics.
We do not intend to redefine the semantics of constraint automata with polarity and of interaction models in this section. Hence, we interpret them using their definitions from \cite{BSAR06, BBJS14}. 

We begin by defining the interpretation of stateless constraint automata with polarity. 
Given a stateless constraint automaton with polarity , we first determine the smallest set of bidirectional ports  such that  and , where  and  are all source and sink nodes that occur on a transition of . Then, we take  as the port names of . Finally, we obtain the transitions of  by replacing every transition labeled with  in  with a set of transitions labeled with , where  contains all data assignments  that satisfy the data constraint .
We formalize this as follows. Let  be a stateless constraint automaton with polarity over a data domain . 
Define , and .
Let  be the smallest set, with  and . Define 

where .
Note that ports in  and  are important only for composition, which we do not consider in this paper.

Next, we interpret interaction models  by a single-state labeled transition system with labels describing all possible dataflows allowed by the guard, and up and down functions of some interaction expression in .
Before we provide a formal definition, we first introduce some notation. 
For every BIP interaction expression , we write  for its bottom ports,  for its guard,  and  for the restriction of the up function to its top port and its local variables, respectively, and  for the restriction of the down function to its bottom ports.
For every BIP interaction model , we write , and , where  is the data type of port .
For every data assignment  we define  and , for all .
Then, we define

where .
Note that we use the value of  as a local variable, since we consider only non-hierarchical interaction models.

In \cite{BBJS14}, Bliudze et al. encode BIP interaction models in {\em Top/Bottom components}, i.e., an automaton over interaction expressions together with local variables. Furthermore, they define a semantics for T/B components, which indirectly defines an interpretation of interaction models. Equation (\ref{eqn:g_data}) imitates this interpretation without using Top/Bottom components explicitly.

Now that we defined the interpretation of our objects in , we explore how these translations preserve properties that are expressible in , as we did for their counterparts in \secn{interpr_no_data}.

\subsection{Reo to BIP}
\label{sec:reotobip_nodata}
Since BIP interaction models are stateless, we cannot translate an arbitrary constraint automaton (i.e., Reo connector) into BIP. Interaction models in BIP preclude keeping track of the state of a Reo connector. Hence, the translation of the interaction model of a BIP architecture into a port automaton in \secn{bip2reo_a} inspires us for our translation .

Let  be a stateless constraint automaton over a data domain . Since we care only about external behaviour, we first hide all mixed nodes. 
Then, we transform every transition in  with label  into a simple BIP connector with  as its bottom ports, together with a guard, an up and a down function that mimic the data constraint . We define the corresponding set  of simple BIP connectors by the set of all transformed transitions from .

We first define the transformation of transitions into interaction expressions. For every label  in automaton , we define the simple BIP connector
 
where  is the smallest set satisfying ,  is any quantifier free formula equivalent to , the variables  are some fresh local variables, and  and  model the input and output values assigned to the bottom ports, and  returns a vector  satisfying . All variables have data type  (the data domain of ), i.e.,  for all .
Note that the solve function in  is not deterministic. However, comparing the solve function to the random function in Figure 4 in \cite{BBJS14}, we see that this generality is justified.
Now, we define  as follows:


\subsection{BIP to Reo}
The correspondence between BIP interaction expressions and automata transitions from \secn{reotobip_nodata}, provides the main idea for the translation of interaction models into stateless constraint automata. If  is a set of simple BIP connectors, we assign to every  a transition  labeled with , and subsequently construct the stateless constraint automaton consisting of all such  transitions.

Let  be a simple BIP interaction expression. 
Recall our relaxation on the data constraint language in \secn{overview}, and our notations regarding  in \secn{interpretation2}.
Then, define 
where  iff  assignes data to  in the upward data transfer, and  iff  assigns data to  in the downward data transfer.
Furthermore, let , , and define
 
Note that  is independent of the top port , as we consider only non-hierarchical connectors.

Let  be a set of simple BIP connectors. Recall that  and . Then, define the constraint automaton  over  by 


\begin{example}
\label{ex:bip2reodata}
Consider the interaction expression  from \ex{maximum}, with the data domains restricted to . We translate the interaction model  using \eq{reo(gamma)}, i.e., we compute . Trivially,  is stateless. Its set of input ports equals , and its set of output ports equals . It has a unique transitions , with synchronization contraint  and guard
.
\tri\end{example}

\subsection{Preservation of properties}

To show the faithfulness of translations  and , we show that interpretations  and  commute with the translations  and  in \fig{intpr2}.

\begin{theorem} 
\label{thm:commute_b}
For all  and all  we have  and .
\end{theorem}

\begin{proof}[Proof. (Sketch)]
Let  and . Then, , and , for all , and all transition labels  in . From this and the definitions of  and , we see that , and , respectively.
\end{proof}

\begin{corollary}
\label{cor:props_ca2setssimplecon}
   The translations  and  preserve all properties expressible in , i.e.,  and  for all ,  and .
\end{corollary}

\begin{example}
Consider the following safety property  for the interaction expression  from \ex{maximum}: ``the value retrieved from port  equals zero''.  Clearly, this safety property does not hold, whenever  or  offers a non-zero integer. 
Note that  depends solely on the interpretation of the interaction model  in , and hence  is expressible in .
Using \cor{props_ca2setssimplecon} we conclude that  is false also for .
Thus, we know any executable code generated from the constraint automaton  does not satisfy . More generally, \cor{props_ca2setssimplecon} allows us to use the Reo compiler to generate correct code for a BIP interaction model.
\tri\end{example}



\section{Conclusions and Future Work}
\label{sec:conclusion}

BIP and Reo find common ground in their stimulation of exogenous system design. 
This means that they force the explicit modeling of coordination constraints. 
A clear and formal separation between coordination (connectors) and computation (components) allows the software architect to analyze the interaction of the components using automated tools. 
The exogenous approach of BIP and Reo contrasts with the endogenous approach supported in process algebra and other languages where coordination is woven into the code of the components. 
For example, process algebra does not supply constructs to enforce the separation of concerns necessary in exogenous coordination \cite{PA01}.

Multiparty synchronization constitutes a fundamental coordination concept in BIP (represented by interactions in a BIP interaction model) and Reo (represented by synchronization constraints in constraint automata). Our translations show that these representations of multiparty synchronization coincide.   

The BIP framework concretely \emph{defines} what separates computation (BIP behaviour) and coordination (BIP interaction), while Reo merely \emph{separates} computation (Reo components) and coordination (Reo connector) structurally. Indeed, Reo does not force a fixed universal definition for computation and coordination in all applications.  Without giving a fixed definition of separation criterion, Reo's structural separation of computation from coordination (i.e., component versus connector) simply means that, while this separation is always important, the distinction between the two is in the eye of the beholder: in different applications, different, or even the same people, may find it convenient to draw the line that separates computation and coordination at different places to suit their needs.  For example, the stateful behavior of a {\tt FIFO} with capacity of 1 strictly places what this entity does in the behaviour layer of BIP, as a (computation) component. In Reo, such stateful components can, of course, be regarded and used as computation as well. However, when deemed appropriate, one can use the same component (i.e., a {\tt FIFO1} channel) in the construction of a Reo connector as well, e.g., to express the stateful, turn-taking interaction between two components, as in \fig{reomutex}.

Our data-agnostic translations allow compositional translation, because their operators distribute over composition modulo semantic equivalence.
On the other hand, our data-sensitive translation scheme does not support incremental translation.
It seems intuitive to translate synchronous Reo channels into BIP interaction expressions. 
However, the directionality inherent in the dataflows of BIP interaction expressions implies that they can compose only hierarchically, whereas the \emph{relational} specification of dataflow constraints in Reo (which manifests itself as data constraints in constraint automata transition labels) allows more expressive composition of dataflows as relational composition of constraints.
This difference restricts the set of the Reo connectors that this scheme can incrementally translate into BIP, as well as the granularity of the sub-connectors that it can translate in one increment: the data constraints on the boundary nodes of every such sub-connector must be locally resolvable into a directional dataflow expression at the level of the sub-connector, in isolation.
In practice, synchronous cycles in a Reo connector must translate as a whole, which scuttles the computational benefit of translating incrementally.

In contrast with the BIP architecture model, the data-sensitive model for BIP does not include coordinating components within the connector \cite{ABBJS14, BBJS14}.
Nevertheless, it seems possible to use the formalization in \cite{BBJS14} to extend BIP architectures of \cite{ABBJS14} with data.
However, extending the current composition operator  to compose data-sensitive BIP architectures does not seem trivial, and we do not know what properties such an extended composition operator can preserve. 

Using the ideas from \secn{PA2Arch}, extending our  translation (\fig{intpr2}) to the domain of postulated data-sensitive BIP architectures seems straight-forward. 
Moreover, it may be possible to extend our translations to mappings that preserve internal ports.  
Such extensions, together with the results from \secn{CA2BIPconn}, effectively promise a property-preserving composition operator for data-sensitive BIP architectures that may also share internal ports.

\bibliography{references}
\bibliographystyle{eptcs}

\end{document}