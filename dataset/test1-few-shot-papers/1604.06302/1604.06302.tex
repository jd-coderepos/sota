\documentclass[a4paper,11pt]{article}
\pdfoutput=1
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{environ}
\usepackage{xcolor,graphicx}
\usepackage{verbatim}
\usepackage{a4wide}


\usepackage{subfig}




\usepackage{paralist}
\usepackage{xspace}
\usepackage{tabularx}
\usepackage{multirow}
\usepackage{graphicx}
\usepackage{enumerate}
\usepackage{mathtools}
\usepackage{dsfont}
\usepackage[numbers,sort]{natbib}
\setlength{\bibsep}{0.0pt}

\usepackage{booktabs}

\usepackage[vlined,linesnumbered,ruled]{algorithm2e}
\SetEndCharOfAlgoLine{}
\SetCommentSty{textrm}



\usepackage{authblk}
\renewcommand\Affilfont{\small}
\renewcommand\Authfont{\normalsize}
\usepackage{scrpage2}

\usepackage{tikz}
\tikzset{every neuron/.style={
    circle,
    draw,
    minimum size=0.8cm
  },
  neuron missing/.style={
    draw=none, 
    scale=3,
    text height=0.333cm,
    execute at begin node=\color{black}
  },
}
\usetikzlibrary{positioning}
\usetikzlibrary{fit}
\usetikzlibrary{shapes,arrows}
\usetikzlibrary{matrix}
\usetikzlibrary{decorations.pathreplacing, decorations.markings, arrows}


\usetikzlibrary{arrows,positioning} 

\tikzset{
>=stealth',
dot/.style={
		radius=0.05,
		fill=black,
	},
	gnode/.style={
          draw,
          shape=circle,
          inner sep=4pt
	},
	dummynode/.style={
		  gnode
		, fill=black
	},
	edgeto/.style={
		->,
shorten <=2pt,
		shorten >=2pt,
		bend right=15,},
	edgeboth/.style={
		<->,
shorten <=2pt,
		shorten >=2pt,
		},
	edgefrom/.style={
		<-,
shorten <=2pt,
		shorten >=2pt,
		bend left=15,}
}







\usepackage[pagebackref]{hyperref}



\usepackage{todonotes}


\theoremstyle{remark}
\newtheorem{reduction}{Reduction}

\theoremstyle{plain}
\newtheorem{theorem}{Theorem}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{observation}[theorem]{Observation}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{construction}[theorem]{Construction}
\newtheorem{rrule}{Reduction Rule}[section]

\theoremstyle{definition}
\newtheorem{definition}[theorem]{Definition}

\usepackage[sort&compress]{cleveref}
\crefname{ineq}{inequality}{inequalities}
\creflabelformat{ineq}{#2{\upshape(#1)}#3} 

\crefname{cond}{Condition}{Conditions}
\creflabelformat{cond}{#2(#1)#3}

\crefname{algorithm}{Algorithm}{Algorithms}
\crefname{line}{Line}{Lines}
\crefname{rrule}{Reduction Rule}{Reduction Rules}
\crefname{chapter}{Chapter}{Chapters}
\crefname{section}{Section}{Sections}
\crefname{subsection}{Section}{Sections}
\crefname{theorem}{Theorem}{Theorems}
\crefname{obs}{Observation}{Observations}
\crefname{proposition}{Proposition}{Propositions}
\crefname{corollary}{Corollary}{Corollaries}
\crefname{lemma}{Lemma}{Lemmas}
\crefname{figure}{Figure}{Figures}
\crefname{construction}{Construction}{Constructions}
\crefname{definition}{Definition}{Definitions}



\newcommand{\NCE}{\textsc{Number Constraint Editing}\xspace}
\newcommand{\NCEA}{\textsc{NCE}\xspace}


\newcommand{\numO}{\textsc{\#}}
\newcommand{\numOlong}{\textsc{Numbers Only}\xspace}

\newcommand{\DDCSClong}{\textsc{Digraph Degree Constraint Sequence Completion}\xspace}
\newcommand{\DDCSC}{\textsc{DDConSeqC}\xspace}
\newcommand{\nDDCSClong}{\numOlong \DDCSClong} 
\newcommand{\nDDCSC}{\numO\DDCSC}


\newcommand{\DDCClong}{\textsc{Digraph Degree Constraint Completion}\xspace}
\newcommand{\DDCC}{\textsc{DDConC}\xspace}
\newcommand{\nDDCClong}{\numOlong \DDCClong}
\newcommand{\nDDCC}{\numO\DDCC}

\newcommand{\DDSClong}{\textsc{Digraph Degree Sequence Completion}\xspace}
\newcommand{\DDSC}{\textsc{DDSeqC}\xspace}
\newcommand{\nDDSClong}{\numOlong \DDSClong} \newcommand{\nDDSC}{\numO\DDSC} 



\newcommand{\DAlong}{\textsc{Digraph Degree Anonymity}\xspace}
\newcommand{\DA}{\textsc{DDA}\xspace}
\newcommand{\nDAlong}{\numOlong \DAlong} \newcommand{\nDA}{\numO\DA} 




\DeclareMathOperator{\degr}{deg}
\DeclareMathOperator{\diff}{diff}

\newcommand{\N}{\ensuremath{\mathds{N}}}
\newcommand{\degpara}{\ensuremath{\Delta^*}\xspace}
\newcommand{\flushfill}[1]{\hspace{\fill}\mbox{}\linebreak[0]\hspace*{\fill}\mbox{#1}}

\makeatletter
\newcommand{\problemtitle}[1]{\gdef\@problemtitle{#1}}\newcommand{\probleminput}[1]{\gdef\@probleminput{#1}}\newcommand{\problemquestion}[1]{\gdef\@problemquestion{#1}}\NewEnviron{problemdef}{
  \problemtitle{}\probleminput{}\problemquestion{}\BODY \par\addvspace{.5\baselineskip}
  \noindent
  \begin{tabularx}{\textwidth}{@{\hspace{0ex}} l X c}
    \multicolumn{2}{@{\hspace{0ex}}l}{\normalsize\@problemtitle} \\\normalsize\textbf{Input:} & \normalsize\@probleminput \\\normalsize\textbf{Question:} & \normalsize\@problemquestion \end{tabularx}
  \par\addvspace{.5\baselineskip}
}

\usepackage{etoolbox}





\pagestyle{plain}

\begin{document}

\title{A Parameterized Algorithmics Framework for Degree Sequence Completion Problems in Directed Graphs}

\author[]{Robert Bredereck}
\author[]{Vincent Froese}
\author[]{Marcel Koseler}
\author[]{Marcelo Garlet Millani}
\author[]{AndrÃ©~Nichterlein}
\author[]{Rolf Niedermeier}

\affil[]{Institut f\"ur Softwaretechnik und Theoretische Informatik,  TU Berlin, Germany,
 \texttt{\{robert.bredereck, vincent.froese, m.garletmillani, andre.nichterlein, rolf.niedermeier\}@tu-berlin.de}}
\date{}

\maketitle

\thispagestyle{scrheadings}
\cfoot{}
\ohead{}
\ifoot{}

\begin{abstract}
There has been intensive work on the parameterized complexity of
the typically NP-hard task to 
edit undirected graphs into graphs fulfilling certain given vertex degree 
constraints. In this work, we lift the investigations to the case of directed graphs; herein, we focus on arc insertions.
To this end, we develop a general two-stage framework which consists of efficiently solving a problem-specific number problem and transferring its solution to a solution for the graph problem by applying flow computations. In this way, we obtain fixed-parameter tractability and polynomial kernelizability
results, with the central parameter being the maximum vertex in- or outdegree of the output digraph.
Although there are certain similarities with the much better studied undirected case,
the flow computation used in the directed case seems not to 
work for the undirected case while -factor computations as used 
in the undirected case seem not to work for the directed case.
\end{abstract}

\section{Introduction}
Modeling real-world networks (e.g., communication, ecological, social) 
often requests \emph{directed} graphs (digraphs for short). 
We study a class of specific ``network design'' (in the sense of constructing
a specific network topology) or ``graph realization''
problems. Here, our focus is on inserting arcs into a given digraph in order to fulfill certain vertex degree constraints. These problems are 
typically NP-hard, so we choose parameterized algorithm design 
for identifying relevant tractable special cases. The main parameter 
we work with is the maximum in- or outdegree of the newly constructed digraph.
We deal with the following three problems:
First, the problem \DDCClong (\DDCC), which asks to insert a minimum number of arcs
such that each vertex ends up with a degree as specified by an individual list of target degrees (see \Cref{fig:example DDCC}).
Second, the \DDSClong (\DDSC) problem, where the goal is to insert arcs in such a way that
the resulting digraph has a specific degree sequence (\Cref{fig:example DDSC}).
Third, \DAlong (\DA), which asks to ``-anonymize'' a given digraph, that is, after inserting a minimum number of arcs, each combination of in- and outdegree occurs either zero or at least ~times (\Cref{fig:example DA}).
\begin{figure}[t]
	\centering
	\begin{tikzpicture}
	\node[gnode, inner sep=2.0pt, radius=3pt, minimum size=16pt,  draw=black] (path4136-5) at (0.0, 0.0) [align=left]{\\};
\node[gnode, inner sep=2.0pt, radius=3pt, minimum size=16pt,  draw=black] (path4136-62) at (2.25, 0.0) [align=left]{\\};
\node[gnode, inner sep=2.0pt, radius=3pt, minimum size=16pt,  draw=black] (path4136-9) at (4.5, 0.0) [align=left]{\\};
\node[gnode, inner sep=2.0pt, radius=3pt, minimum size=16pt,  draw=black] (path4136-7) at (1.125, 1.25) [align=left]{\\};
\node[gnode, inner sep=2.0pt, radius=3pt, minimum size=16pt,  draw=black] (path4136-35) at (3.375, 1.25) [align=left]{\\};
\node[gnode, inner sep=2.0pt, radius=3pt, minimum size=16pt,  draw=black] (path4136) at (0.0, 2.5) [align=left]{\\};
\node[gnode, inner sep=2.0pt, radius=3pt, minimum size=16pt,  draw=black] (path4136-3) at (2.25, 2.5) [align=left]{\\};
\node[gnode, inner sep=2.0pt, radius=3pt, minimum size=16pt,  draw=black] (path4136-6) at (4.5, 2.5) [align=left]{\\};
\draw[draw=black, ->] (path4136-5) edge (path4136-7);
\draw[draw=black, ->] (path4136-3) edge (path4136-35);
\draw[draw=black, ->] (path4136-35) edge (path4136-6);
\draw[draw=black, ->] (path4136-9) edge (path4136-35);
\draw[draw=black, ->] (path4136-35) edge (path4136-62);
\draw[draw=black, ->] (path4136-7) edge (path4136-62);
\draw[draw=black, ->] (path4136-7) edge (path4136-9);
\draw[draw=black, ->] (path4136) edge (path4136-3);
\draw[draw=black, ->] (path4136-3) edge (path4136-7);

\draw[
        -triangle 90,
        line width=0.5mm,
        postaction={draw, line width=2mm, shorten >=2mm, -}
    ] (5.25,1.25) -- (5.75,1.25);

	\begin{scope}[shift={(6.25,0)}]
	\node[gnode, inner sep=2.0pt, radius=3pt, minimum size=16pt,  draw=black] (path4136-5) at (0.0, 0.0) [align=left]{\\};
\node[gnode, inner sep=2.0pt, radius=3pt, minimum size=16pt,  draw=black] (path4136-62) at (2.25, 0.0) [align=left]{\\};
\node[gnode, inner sep=2.0pt, radius=3pt, minimum size=16pt,  draw=black] (path4136-9) at (4.5, 0.0) [align=left]{\\};
\node[gnode, inner sep=2.0pt, radius=3pt, minimum size=16pt,  draw=black] (path4136-7) at (1.125, 1.25) [align=left]{\\};
\node[gnode, inner sep=2.0pt, radius=3pt, minimum size=16pt,  draw=black] (path4136-35) at (3.375, 1.25) [align=left]{\\};
\node[gnode, inner sep=2.0pt, radius=3pt, minimum size=16pt,  draw=black] (path4136) at (0.0, 2.5) [align=left]{\\};
\node[gnode, inner sep=2.0pt, radius=3pt, minimum size=16pt,  draw=black] (path4136-3) at (2.25, 2.5) [align=left]{\\};
\node[gnode, inner sep=2.0pt, radius=3pt, minimum size=16pt,  draw=black] (path4136-6) at (4.5, 2.5) [align=left]{\\};
\draw[draw=black, ->] (path4136-5) edge (path4136-7);
\draw[draw=black, dashed, ->] (path4136) edge (path4136-7);
\draw[draw=black, ->] (path4136-3) edge (path4136-35);
\draw[draw=black, ->] (path4136-35) edge (path4136-6);
\draw[draw=black, dashed, ->] (path4136-7) edge (path4136-35);
\draw[draw=black, dashed, ->] (path4136-62) edge (path4136-9);
\draw[draw=black, ->] (path4136-9) edge (path4136-35);
\draw[draw=black, ->] (path4136-35) edge (path4136-62);
\draw[draw=black, ->] (path4136-7) edge (path4136-62);
\draw[draw=black, dashed, ->] (path4136-7) edge (path4136-6);
\draw[draw=black, ->] (path4136-7) edge (path4136-9);
\draw[draw=black, ->] (path4136) edge (path4136-3);
\draw[draw=black, ->] (path4136-3) edge (path4136-7);
\draw[draw=black, dashed, ->] (path4136-62) edge (path4136-5);
\end{scope}
	\end{tikzpicture}
	\caption{Example instance of \DDCClong.
	The numbers inside the vertices represent the desired degrees (indegree on top, outdegree on bottom).
	We can satisfy all demands by adding the dashed arcs.
	Note that, in general, the desired degrees of a vertex do not have to be unique.}
	\label{fig:example DDCC}
\end{figure}

\begin{figure}[t]
	\centering
	\begin{tikzpicture}[xscale=1.5]
		
		\node[gnode, inner sep=2.0pt, radius=3pt, minimum size=16pt, fill=white, draw=black] (path4136-5) at (0.0, 0.0) [align=left]{};
		\node[gnode, inner sep=2.0pt, radius=3pt, minimum size=16pt, fill=white, draw=black] (path4136-62) at (1.5, 0.0) [align=left]{};
		\node[gnode, inner sep=2.0pt, radius=3pt, minimum size=16pt, fill=white, draw=black] (path4136-9) at (3.0, 0.0) [align=left]{};
		\node[gnode, inner sep=2.0pt, radius=3pt, minimum size=16pt, fill=white, draw=black] (path4136-7) at (0.75, 1.25) [align=left]{};
		\node[gnode, inner sep=2.0pt, radius=3pt, minimum size=16pt, fill=white, draw=black] (path4136-35) at (2.25, 1.25) [align=left]{};
		\node[gnode, inner sep=2.0pt, radius=3pt, minimum size=16pt, draw=black] (path4136) at (0.0, 2.5) [align=left]{};
		\node[gnode, inner sep=2.0pt, radius=3pt, minimum size=16pt, draw=black] (path4136-3) at (1.5, 2.5) [align=left]{};
		\node[gnode, inner sep=2.0pt, radius=3pt, minimum size=16pt, draw=black] (path4136-6) at (3.0, 2.5) [align=left]{};
		\node[rectangle, thick, dashed] (rect5360) at (1.5, -0.75) [align=left]{\normalsize, , , , , , , };
		\draw[draw=black, ->] (path4136-5) edge (path4136-7);
		\draw[draw=black, ->] (path4136-3) edge (path4136-35);
		\draw[draw=black, ->] (path4136-35) edge (path4136-6);
		\draw[draw=black, ->] (path4136-9) edge (path4136-35);
		\draw[draw=black, ->] (path4136-35) edge (path4136-62);
		\draw[draw=black, ->] (path4136-7) edge (path4136-62);
		\draw[draw=black, ->] (path4136-7) edge (path4136-9);
		\draw[draw=black, ->] (path4136) edge (path4136-3);
		\draw[draw=black, ->] (path4136-3) edge (path4136-7);
		
		\draw[
        -triangle 90,
        line width=0.5mm,
        postaction={draw, line width=2mm, shorten >=2mm, -}
    ] (3.5,1.25) -- (3.83333,1.25);
		
		\begin{scope}[shift={(4.16666,0)}]
			\node[gnode, inner sep=2.0pt, radius=3pt, minimum size=16pt, fill=white, draw=black] (path4136-5) at (0.0, 0.0) [align=left]{\\};
		\node[gnode, inner sep=2.0pt, radius=3pt, minimum size=16pt, fill=white, draw=black] (path4136-62) at (1.5, 0.0) [align=left]{\\};
		\node[gnode, inner sep=2.0pt, radius=3pt, minimum size=16pt, fill=white, draw=black] (path4136-9) at (3.0, 0.0) [align=left]{\\};
		\node[gnode, inner sep=2.0pt, radius=3pt, minimum size=16pt, fill=white, draw=black] (path4136-7) at (0.75, 1.25) [align=left]{\\};
		\node[gnode, inner sep=2.0pt, radius=3pt, minimum size=16pt, fill=white, draw=black] (path4136-35) at (2.25, 1.25) [align=left]{\\};
		\node[gnode, inner sep=2.0pt, radius=3pt, minimum size=16pt, draw=black] (path4136) at (0.0, 2.5) [align=left]{\\};
		\node[gnode, inner sep=2.0pt, radius=3pt, minimum size=16pt, draw=black] (path4136-3) at (1.5, 2.5) [align=left]{\\};
		\node[gnode, inner sep=2.0pt, radius=3pt, minimum size=16pt, draw=black] (path4136-6) at (3.0, 2.5) [align=left]{\\};
\draw[draw=black, ->] (path4136-5) edge (path4136-7);
		\draw[draw=black, ->] (path4136-3) edge (path4136-35);
		\draw[draw=black, ->] (path4136-35) edge (path4136-6);
		\draw[draw=black, ->] (path4136-9) edge (path4136-35);
		\draw[draw=black, ->] (path4136-35) edge (path4136-62);
		\draw[draw=black, ->] (path4136-7) edge (path4136-62);
		\draw[draw=black, ->] (path4136-7) edge (path4136-9);
		\draw[draw=black, ->] (path4136) edge (path4136-3);
		\draw[draw=black, ->] (path4136-3) edge (path4136-7);
		\draw[draw=black, dashed, ->] (path4136-5) edge (path4136-35);
		\draw[draw=black, dashed, ->] (path4136-9) edge (path4136-6);
		\draw[draw=black, dashed, ->] (path4136-35) edge (path4136-7);
		\draw[draw=black, dashed, ->] (path4136-62) edge (path4136-3);
		\draw[draw=black, dashed, ->] (path4136-35) edge (path4136);
		\end{scope}

	\end{tikzpicture}
	\caption{Example instance of \DDSClong.
	The target sequence is given below the digraph.
	Adding the dashed arcs produces a digraph with the desired degree sequence.
	}
	\label{fig:example DDSC}
\end{figure}

\begin{figure}[t]
	\centering
	\begin{tikzpicture}
	\begin{scope}
		\node (rect6685-1) at (2.25, -0.25) [align=center]{};
		\node[gnode, inner sep=2.0pt, radius=3pt, minimum size=16pt, fill=white, draw=black] (path4136-5) at (0.0, 0.0) [align=left]{};
		\node[gnode, inner sep=2.0pt, radius=3pt, minimum size=16pt, fill=white, draw=black] (path4136-62) at (2.25, 0.0) [align=left]{};
		\node[gnode, inner sep=2.0pt, radius=3pt, minimum size=16pt, fill=white, draw=black] (path4136-9) at (4.5, 0.0) [align=left]{};
		\node[gnode, inner sep=2.0pt, radius=3pt, minimum size=16pt, fill=white, draw=black] (path4136-7) at (1.125, 1.25) [align=left]{};
		\node[gnode, inner sep=2.0pt, radius=3pt, minimum size=16pt, fill=white, draw=black] (path4136-35) at (3.375, 1.25) [align=left]{};
		\node[gnode, inner sep=2.0pt, radius=3pt, minimum size=16pt, fill=white, draw=black] (path4136) at (0.0, 2.5) [align=left]{};
		\node[gnode, inner sep=2.0pt, radius=3pt, minimum size=16pt, fill=white, draw=black] (path4136-3) at (2.25, 2.5) [align=left]{};
		\node[gnode, inner sep=2.0pt, radius=3pt, minimum size=16pt, fill=white, draw=black] (path4136-6) at (4.5, 2.5) [align=left]{};
		\node (rect6685) at (2.25, 3.75) [align=center]{\normalsize 1-anonymous degree sequence:\\\normalsize , , , , , , , };
		\draw[draw=black, ->] (path4136-5) edge (path4136-7);
		\draw[draw=black, ->] (path4136-3) edge (path4136-35);
		\draw[draw=black, ->] (path4136-35) edge (path4136-6);
		\draw[draw=black, ->] (path4136-9) edge (path4136-35);
		\draw[draw=black, ->] (path4136-35) edge (path4136-62);
		\draw[draw=black, ->] (path4136-7) edge (path4136-62);
		\draw[draw=black, ->] (path4136-7) edge (path4136-9);
		\draw[draw=black, ->] (path4136) edge (path4136-3);
		\draw[draw=black, ->] (path4136-3) edge (path4136-7);
	\end{scope}	
	\draw[
        -triangle 90,
        line width=0.5mm,
        postaction={draw, line width=2mm, shorten >=2mm, -}
    ] (5.25,1.25) -- (5.75,1.25);


	\begin{scope}[shift={(6.5,0)}]
		\node (rect6685-1) at (2.25, -0.25) [align=center]{};
	\node[gnode, inner sep=2.0pt, radius=3pt, minimum size=16pt, fill=white, draw=black] (path4136-5) at (0.0, 0.0) [align=left]{\\};
	\node[gnode, inner sep=2.0pt, radius=3pt, minimum size=16pt, fill=white, draw=black] (path4136-62) at (2.25, 0.0) [align=left]{\\};
	\node[gnode, inner sep=2.0pt, radius=3pt, minimum size=16pt, fill=white, draw=black] (path4136-9) at (4.5, 0.0) [align=left]{\\};
	\node[gnode, inner sep=2.0pt, radius=3pt, minimum size=16pt, fill=white, draw=black] (path4136-7) at (1.125, 1.25) [align=left]{\\};
	\node[gnode, inner sep=2.0pt, radius=3pt, minimum size=16pt, fill=white, draw=black] (path4136-35) at (3.375, 1.25) [align=left]{\\};
	\node[gnode, inner sep=2.0pt, radius=3pt, minimum size=16pt, fill=white, draw=black] (path4136) at (0.0, 2.5) [align=left]{\\};
	\node[gnode, inner sep=2.0pt, radius=3pt, minimum size=16pt, fill=white, draw=black] (path4136-3) at (2.25, 2.5) [align=left]{\\};
	\node[gnode, inner sep=2.0pt, radius=3pt, minimum size=16pt, fill=white, draw=black] (path4136-6) at (4.5, 2.5) [align=left]{\\};
	\node (rect6685) at (2.25, 3.75) [align=center]{\normalsize 4-anonymous degree sequence:\\\normalsize , , , , , , , };
	\draw[draw=black, ->] (path4136-5) edge (path4136-7);
	\draw[draw=black, ->] (path4136-3) edge (path4136-35);
	\draw[draw=black, ->] (path4136-35) edge (path4136-6);
	\draw[draw=black, ->] (path4136-9) edge (path4136-35);
	\draw[draw=black, ->] (path4136-35) edge (path4136-62);
	\draw[draw=black, ->] (path4136-7) edge (path4136-62);
	\draw[draw=black, ->] (path4136-7) edge (path4136-9);
	\draw[draw=black, ->] (path4136) edge (path4136-3);
	\draw[draw=black, ->] (path4136-3) edge (path4136-7);
	\draw[draw=black, dashed, ->] (path4136-62) edge (path4136-3);
	\draw[draw=black, dashed, ->] (path4136-62) edge (path4136-5);
	\draw[draw=black, dashed, ->, bend right=20] (path4136-6) edge (path4136);
\end{scope}
	\end{tikzpicture}
	\caption{Example instance for \DAlong.
	The input digraph is -anonymous since there is only one vertex with indegree 2 and outdegree 0.
	By adding the dashed arcs we obtain a digraph which is -anonymous.}
	\label{fig:example DA}
\end{figure}




All three problems are NP-hard.
Based on a general framework presented in Section~\ref{sec:GeneralSetting},
we derive several fixed-parameter tractability results for them,
mainly exploiting the parameter ``maximum vertex degree'' in the output digraph.
Moreover, the three problems above are special cases of the \DDCSClong problem which we will define next. 
Before doing so, however, 
we go into a little more detail concerning the roots 
of the underlying graph-theoretic  problems studied here.
Since early computer science and algorithmic graph theory
days, studies on graph realizability of degree 
sequences (that is, multisets of positive integers or integer pairs) 
have played 
a prominent role, being performed both for undirected graphs~\cite{EG60,Hak62} 
as well as digraphs~\cite{Che66,Ful60,KW73,HN15}. 
Lately, the graph modification view gained more and more 
attention: 
given a graph, can it be changed by a minimum number of graph modifications such that the resulting graph adheres to 
specific constraints for its degree sequence?

In the most basic variant a degree sequence is a sequence of positive integers specifying (requested) vertex degrees for a fixed ordering of the vertices.
Typically, the corresponding computational problems are NP-hard.
In recent years, research in this direction focused on undirected graphs~\cite{FNN16,Gol15,GM17,HNNS15,MS12,MT09}.
In this work, we investigate parameterized algorithms on digraphs.
As \citet{GY08} observed, much less is known about the structure of digraphs than that of undirected graphs, making the design of parameterized algorithms for digraphs more challenging.
In particular, we present a general framework for a class of degree sequence modification problems, focusing on the case of arc insertions (that is, completion problems).

The most general degree completion problem for digraphs we consider in this work is as follows.

\begin{problemdef}
        \problemtitle{\DDCSClong(\DDCSC)}
        \probleminput{A digraph~, a non-negative integer~, a ``degree list function'' , and a ``sequence property''~.}
        \problemquestion{Is it possible to obtain a digraph  by inserting at most~ arcs into~ such that the degree sequence of~ fulfills~ and  for all~?}
\end{problemdef}

We emphasize that there are two types of constraints---one (specified by the function~, which gives us the in- and outdegrees) for the individual vertices and one (specified by~) for the whole list of degree tuples. For instance, 
a common~ as occurring in the context of data privacy applications 
is to request that the list is \emph{-anonymous}, that is, 
every combination of in- and outdegree that occurs in the list occurs at least ~times (see also \Cref{fig:example DA}).

Since \DDCSC{} and its special cases as studied here all turn out 
to be NP-hard~\cite{Mil15,Kos15}, a parameterized complexity analysis
seems the most natural fit for understanding the computational
complexity landscape of these kinds of problems---this has also 
been observed in the above mentioned studies for the undirected case.
Our main findings are mostly on the positive side. That is,
although seemingly more intricate to deal with due to the 
existence of in- and outdegrees, many positive algorithmic results 
which hold for undirected graphs can also be achieved for 
digraphs (albeit using different techniques).
In particular, we present a maximum-flow-based framework that,
together with the identification and solution of certain number problems,
helps to derive several fixed-parameter tractability results with 
respect to the parameter maximum possible in- or outdegree~\degpara in any solution digraph.
Notably, the corresponding result in the undirected case was 
based on -factor computations~\cite{FNN16} which do not transfer 
to the directed case, and, vice versa, the flow computation 
approach we present for the directed case seemingly does not transfer to the 
undirected case. 
For special cases of \DDCSC{}, we can move further and even derive 
some polynomial-size problem kernels, again for the parameter~\degpara.

We consider the parameter~\degpara for the following reasons.
First, it is always at most~, a natural parameter in the input.
Second, in combination with~, we might get an even smaller upper bound for~\degpara.
Third, bounded-degree graphs are well studied and our work extends this since we only require~\degpara to be small, not to be constant.
Fourth, in practice, the maximum degree is often significantly smaller than the number of vertices:
\citet{LH08} studied a huge instant-messaging network (180 million vertices) with maximum degree~600.
Furthermore, in the context of anonymization it can empirically be observed that the maximum degree will not increase during the anonymization process~\cite{HHN14}. 
Thus, the parameter~\degpara is interesting when studying kernelization as we do. 


\subsection{Related Work}

Most of the work on graph modification
problems for realizing degree constraints has focused on undirected 
graphs~\cite{FNN16,Gol15,GM17,HNNS15,MS12,MT09}. Closest to our work
is the framework for deriving polynomial-size problem kernels
for undirected degree sequence completion problems~\cite{FNN16},
which we complement by our results for digraphs. 
Generally speaking, we can derive similar results, but the technical
details differ and the landscape of problems is richer 
in the directed case.
As to digraph modification problems in general, we are aware of surprisingly 
little work. 
We mention work studying arc insertion for 
making a digraph transitive~\cite{WKNU12} or 
for making a graph 
Eulerian~\cite{DMNW13}, both employing the toolbox of parameterized
complexity analysis. 
Somewhat related is also work about the insertion of edges into a mixed graph to satisfy local edge-connectivity constraints~\cite{FJ95}
or about orienting edges in a partially oriented graph to make it an 
oriented graph~\cite{BHZ18}.

\subsection{Our Results}
In \cref{sec:GeneralSetting}, we present our general framework for \DDCSC{}, which is a two-stage approach based on flow computations.
To this end, we identify a specific pure number problem arising from the degree constraints.
We show that, if this number problem is fixed-parameter tractable with respect to the largest possible integer in the output, then \DDCSC{} is fixed-parameter tractable with respect to~\degpara.
Next, presenting applications of the framework, in \cref{sec:DDCC}, we show that if there is no constraint~ concerning the degree sequence (that is, we deal with the \DDCClong problem), then we not only obtain fixed-parameter 
tractability but also a polynomial-size problem kernel for parameter~\degpara.
Then, in \cref{sec:DDSC} we show an analogous result if there is exactly one specified degree sequence to be realized (\DDSClong).
Finally, in \cref{sec:DA}, we show that if we request the degree
sequence to be -anonymous (that is, \DAlong), then we can at least derive a polynomial-size
problem kernel for the combined parameter~, where~ denotes the maximum in- or outdegree of the input digraph~.
Also, we take a first step outlining the limitations of our framework for digraphs.
In contrast to the undirected case (which is polynomial-time solvable~\cite{LT08}), the corresponding number problem of \DAlong surprisingly is weakly NP-hard and, thus, presumably not polynomial-time solvable.
A summary of our results is provided in \cref{tab:summary}.

\begin{table}
  \centering
  \caption{Summary of our results for the three problems we studied (indicated by (digraph)) and the corresponding number problems (indicated by (number)). The parameters are defined as follows:
   is the number of vertices,  is the maximum number of added arcs,  is the maximum target in- or outdegree of a vertex, \degpara is the maximum in- or outdegree in any solution digraph,
   is the maximum in- or outdegree in the input digraph,  is the largest possible integer in the output sequence, and  is the level of anonymity.}
  \label{tab:summary}
  \begin{tabularx}{\textwidth}{lp{1.5cm}Xr}
	\toprule
	Problem & & Result & Reference\\
\midrule
	\multirow{3}{*}{\DDCC} & (number)  & -time solvable & \Cref{lem:nDDCC-poly}\\
                & (digraph) & -vertex kernel in  time & \Cref{thm:DDCCkrKernel}\\
                &  & -vertex kernel in  time & \Cref{cor:DDCCkernel}\\
	\midrule
	\multirow{3}{*}{\DDSC} & (number) & -time solvable & \Cref{lem:TSC-poly}\\
                & (digraph) & -vertex kernel in  time & \Cref{thm:DDSC_kDelta-kernel}\\
                & & -vertex kernel in  time & \Cref{cor:DDSCkernel}\\
	\midrule
	\multirow{5}{*}{\DA} & (number)  & weakly NP-hard & \Cref{thm:nDAhard}\\
				& &FPT w.r.t.\  & \Cref{thm:nDA-FPT}\\
                & (digraph) & FPT w.r.t.\ \degpara & \Cref{cor:DDAfpt}\\
                & & -vertex kernel in  time & \Cref{thm:DirDegAnon-kernel-sDelta}\\
                & & FPT w.r.t.\  & \Cref{cor:DA-FPT-deltastern}\\
	\bottomrule
\end{tabularx}
\end{table}

\section{Preliminaries} \label{notation}

\paragraph{Notation.}
We consider \emph{digraphs} (without multiarcs or loops)  with  and .
For a vertex~,  denotes the \emph{indegree} of~, that is, the number of incoming arcs of~. Correspondingly,  denotes the \emph{outdegree}, that is, the number of outgoing arcs of~.
We define the \emph{degree}~.
The set  contains all vertices incident to an arc in .
For a set of arcs ,  denotes the digraph~, while  denotes the  subdigraph~.
Analogously, for a set of vertices ,  denotes the induced subdigraph~ which only contains the vertices~ and the arcs between vertices from~.
The set  denotes the set of \emph{outneighbors} of~. Analogously,  denotes the set of \emph{inneighbors}.
Furthermore, we define the maximum indegree , the maximum outdegree , and~.

A \emph{digraph degree sequence}  is a multiset of nonnegative integer tuples, where  for all~. We define

For a digraph~ we denote by , , , the digraph degree sequence of~.
Let~ be a nonnegative integer tuple.
For a digraph~, the \emph{block}~ \emph{of degree~} is the set of all vertices having degree~, formally~.
We define~ as the number of vertices in~ with degree~, that is, .
Similarly, we define~ as the multiset of all tuples equal to~
and  as the number of occurrences of the tuple~ in the multiset~.
For two integer tuples~, , we define the sum~.

\paragraph{Parameterized Algorithmics. \cite{Cyg15,DF13,FG06,Nie06}} We assume the reader to be familiar with classical complexity theory concepts such as polynomial-time reductions and (weak) NP-hardness~\cite{GJ79, AB09}.
An instance~ of a parameterized problem~ consists
of the classical input~ and a \emph{parameter}~. A parameterized problem~ is called \emph{fixed-parameter tractable} (fpt) with respect to the parameter~ if it can be solved in~ time, where~ is a function only depending on~ and~ denotes the size of the input~.
Accordingly, for a \emph{combined parameter}~, a parameterized problem is fpt if it can be solved in~ time.

A \emph{kernelization} is a polynomial-time algorithm transforming a given instance~ into an equivalent instance~ with~ and~ for some functions~ and~, that is,  is a yes-instance if and only if~ is a yes-instance.
The instance~ is called the \emph{problem kernel} and~ denotes its size.
If~ is a polynomial, then we have a \emph{polynomial(-size)} problem kernel.
It can be shown that a parameterized problem is fpt if and only if it has a problem kernel.

\section{The Framework} \label{sec:GeneralSetting}

      Our goal is to develop a framework for deriving fixed-parameter tractability for a general
      class of completion problems in directed graphs.
      To this end, recall our general setting for \DDCSC{} which is as follows.
      We are given a digraph and want to insert at most~ arcs such that the vertices satisfy certain degree constraints~,
      and, additionally, the degree sequence of the digraph fulfills a certain property~.
Formally, the sequence property~ is given as a function that maps a digraph degree sequence to~ if the sequence fulfills the property and otherwise to~.
We restrict ourselves to properties where the corresponding function can be encoded with only polynomially many bits in the number of vertices of the input digraph
and can be decided efficiently.\footnote{All specific properties in this work can be easily decided in polynomial time.
Indeed, in many cases even fixed-parameter tractability with respect to the maximum integer in the sequence would suffice.}
We remark that it is not always the case that there are both vertex degree constraints (as defined by~) and degree sequence constraints~(as defined by~) requested.
This can be handled by either setting~ to the trivial degree list function with~ for all  or setting~ to allow all possible degree sequences.

In this section, we show how to derive (under certain conditions) fixed-parameter tractability with respect to the maximum possible in- or outdegree~\degpara of the \emph{output} digraph for \DDCSC.
Note that~\degpara in general is not known in advance. 
In practice, we might therefore instead consider upper bounds for~\degpara which depend on the given input. 
For example, we know that  for any yes-instance since we insert at most~ arcs into~.
Clearly, \degpara might also be upper-bounded depending on~ (or even depending on~, , , and~) in some cases.
Our generic framework consists of two main steps: First, we prove fixed-parameter tractability with respect to the combined parameter~ in \cref{sec:GeneralFPTsr}.
This step generalizes ideas for the undirected case~\cite{FNN16}.
Note that~ trivially holds for yes-instances.
Second, we show in \cref{sec:GeneralFPTr} how to upper-bound the number~ of arc insertions polynomially in~ by solving a certain problem specific numerical problem.
For this step, we develop a new key argument based on a maximum flow computation (the undirected case was based on -factor arguments).

\subsection{Fixed-parameter tractability with respect to~}
\label{sec:GeneralFPTsr}
We show that \DDCSC is fixed-parameter tractable with respect to the combination of
the maximum number~ of arcs to insert and the maximum in- or outdegree~ of the input digraph~.
The basic idea underlying this result is that two vertices~ and~ with~ and~ are interchangeable.
Accordingly, we will show that it suffices to consider only a bounded number of vertices with the same ``degree properties''.
In particular, if there is a solution, then there is also a solution that only inserts arcs between a properly chosen subset of vertices of bounded size.
To formalize this idea, we introduce the notion of an \emph{-block-type set} for some positive integer~.

To start with, we define the types of a vertex via the numbers of arcs that~ allows to add to this vertex.
Let~ be a \DDCSC instance.
A vertex  is of \emph{type}  if .
Observe that one vertex can be of several types.
The subset of~ containing all vertices of type~ is denoted by~.
A vertex~ of type~ (that is, ) is called \emph{satisfied}.
A vertex which is not satisfied is called \emph{unsatisfied}.
We next define our notion of -block-type sets and its variants.

\begin{definition} \label[definition]{def:alpha-block-type-set}
Let~ be a positive integer and let~ denote the set of all unsatisfied vertices in~. A vertex subset~ with~ is called
\begin{itemize}
	\item \emph{-type set} if, for each type~,  contains exactly  satisfied vertices of type~;
	\item \emph{-block set} if, for each degree~,  contains exactly  satisfied vertices with degree~;
	\item \emph{-block-type set} if, for each degree~ and each type~, ~contains exactly  satisfied vertices of degree~ and type~.
\end{itemize}
\end{definition}

As a first step, we prove that these sets defined above can be computed efficiently.

\begin{lemma} \label[lemma]{lem:alphaSetLinTime}
	An -type/-block/-block-type set~ as described in \cref{def:alpha-block-type-set} can be computed in~ /  /  time. 
\end{lemma}

\begin{proof}
  To compute an -block-type set, we start with an empty set~ and
  for each possible vertex degree~ and each possible vertex type~, we initialize a counter~.
  We then iterate over all vertices~.
  If~ is unsatisfied, that is~, then we add~ to~.
  If~ is satisfied, then for each type~ with~, we increase the counter~ by one and add~ to~ if .
	This can be done in~ time.
	The other two cases of computing an -block set or an -type set can be done in a similar fashion.\qed
\end{proof}

We move on to the crucial lemma stating that a solution (that is, a set of arcs), if existing, can always be found between vertices of an -block-type set~ given that~ contains ``enough'' vertices of each degree and type.
Here, enough means .
\begin{lemma} \label[lemma]{lem:AlphaSet}
	Let~ be a \DDCSC instance and let~ be a -block-type set.
	If~ is a yes-instance, then there exists a solution~ for~, that is, ,  fulfills~, and~ for all~.
\end{lemma}

\begin{proof}
	Let~ be a solution for  that minimizes the number of vertices not in~, that is,  is minimum. 
	The solution~ exists since~ is a yes-instance.
	If~, then we are done.
	Hence, we assume that there exists a vertex~ in~ which is incident to at least one arc in~.
	Let~ and let  be the set of in- respectively outneighbors of~ in~.
	Furthermore, let~ and~.
	Thus,  has degree~ and is of type~.
	By definition of~, it follows that~.

	Now, we claim that there is a vertex~ such that we can replace~ with~ in the solution.
	More precisely, in all arcs of~ we want to replace  by~, that is, we obtain a new arc set
	
	Since we cannot insert arcs that already exist in the input digraph~, we need that~ and~.
	Observe that such a vertex~ exists: 
	Since each of the at most~ vertices in~ has at most~ incoming and~ outgoing arcs, it follows that at most~ vertices in~ can have an arc from or to a vertex in~.
	Furthermore, since~, it follows that at most~ vertices in~ are incident to an arc in~ (the minus one comes from the fact that~ is incident to at least one arc in~). 
	By definition of~, it follows that~.
	Hence, there is at least one vertex~ that is not adjacent to any vertex in~ and not incident to any arc in~.
	Thus, we can replace~ by~.
	
	We now show that~ is still a solution:
	First, observe that  and, hence,  fulfills .
	Second, observe that~ since~, which implies that~ was satisfied.
	Further,  since~ is of type~.
	Hence,  is a solution and~, a contradiction to the assumption that~ was a solution minimizing this value.\qed
\end{proof}

If there are no restrictions on the resulting degree sequence (as it is the case for the \DDCClong problem (\DDCC) in \cref{sec:DDCC}), then we can replace the -block-type set in \cref{lem:AlphaSet} by a -type set:
\begin{lemma}\label[lemma]{lem:DDCC-type-set}
	Let~ be a \DDCC instance and let~ be a -type set.
	If~ is a yes-instance, then there exists a solution~ for~, that is,  and~ for all~.
\end{lemma}

Similarly, if there are no restrictions on the individual vertex degrees, that is,  is the degree list function~ for all~,
then we can replace the~-block-type set by a -block set.

\begin{lemma}\label[lemma]{lem:PiDDSC-block-set}
	Let~ be a \DDCSC instance with~ for all~ and let~ be a -block set.
	If~ is a yes-instance, then there exists a solution~ for~, that is,  and  fulfills~.
\end{lemma}

\cref{lem:AlphaSet} implies a fixed-parameter algorithm by providing a bounded search space for possible solutions, namely any -block-type set~.

\begin{theorem}\label{thm:PiEAfptDeltak}
  If deciding  is fixed-parameter tractable with respect to the maximum integer in the input sequence, then \DDCSC is fixed-parameter tractable with respect to~.
\end{theorem}

\begin{proof}
  Given a \DDCSC instance~, we first check in polynomial time whether there are more than~ unsatisfied vertices in~. If this is the case, then we have a no-instance, since we can change the degrees of at most~ vertices by inserting at most~ arcs.
  Otherwise, we compute a -block-type set~ in polynomial time (\cref{lem:alphaSetLinTime}).
  By~\cref{lem:AlphaSet}, we know that it is sufficient to search for a solution within the vertices of~. Hence, we simply try out all possible arc sets~ of size at most~ and check whether in one of the cases the vertex degrees and the degree sequence of~ satisfy the requirements~ and~.
  Since~ contains at most~ unsatisfied vertices and at most~ satisfied vertices, and since~, there are at most~ possible subsets of arcs to insert.
  Checking whether~ is satisfied can be done in polynomial time and deciding whether~ holds for  is by assumption fixed-parameter tractable with respect to the largest integer, which is at most~.
Thus, overall, we obtain fixed-parameter tractability with respect to~.\qed
\end{proof}

\subsection{Bounding the solution size~ polynomially in~\degpara}
\label{sec:GeneralFPTr}
This subsection constitutes the major part of our framework.
The rough overall scheme is analogous to the undirected case as described by \citet{FNN16}.
By dropping the graph structure and solving a simpler problem-specific number problem on the degree sequence of the input digraph, we show how to solve \DDCSC instances with ``large'' solutions provided that we can solve the associated number problem efficiently.
The number problem is defined so as to simulate the insertion of arcs to a digraph on an
integer tuple sequence.
Note that inserting an arc increases the indegree of a vertex by one and increases the outdegree of another vertex by one.
Inserting~ arcs can thus be represented by increasing the tuple entries in the degree sequence by an overall value of~ in each component.
Formally, the corresponding number problem (abbreviated as \nDDCSC) is defined as follows.

\begin{problemdef}
    \problemtitle{\nDDCSClong}
    \probleminput{A sequence  of~ nonnegative integer tuples,
                  a positive integer~,
                  a ``tuple list function'' ,
                  and a sequence property~.}
    \problemquestion{Is there a sequence 
                     such that ,
                     , , and  for all , and
                      fulfills~?}
\end{problemdef}

If we plug the degree sequence of a digraph into \nDDCSC, then an integer tuple~
of a solution tells us to add~ incoming arcs and~ outgoing arcs to the vertex~.
We call the tuples~ \emph{demands}.
Having computed the demands, we can then try to solve our original \DDCSC instance by searching for a set of arcs to insert that exactly fulfills the demands.
Such an arc set, however, might not always exist.
Hence, the remaining problem is to decide whether it is possible to realize the demands in the given digraph. The following lemma shows (using flow computations) that this is in fact always possible if the number~ of arcs to insert is large compared to~\degpara.

\begin{lemma}\label[lemma]{lem:factor}
  Let~ be a digraph and let~, , and~\degpara be nonnegative integers such that
  \begin{compactenum}[(I)]
    \item\label[cond]{cond:maxdegbound} , 
    \item\label[cond]{cond:indegbound}  for all~,
    \item\label[cond]{cond:outdegbound}  for all~,   
    \item\label[cond]{cond:balance} , and
    \item\label[cond]{cond:minsize} .
  \end{compactenum}

  Then, there exists an arc set~ of size~ such that for the digraph~ it holds  for all .
  Moreover, the set~ can be computed in~ time. \end{lemma}

\begin{proof}
The proof is based on a flow network which we construct such that the corresponding maximum flow (for details of network flow theory, refer to the book by~\citet{AMO93}) yields the set~ of arcs to be inserted in~ in order to obtain our target digraph~. 
\begin{construction}\label[construction]{flowConst}
  We build a flow network~ according to the following steps.
  \begin{itemize}
    \item Add a \emph{source} vertex~ and a \emph{sink} vertex~ to~;
    \item for each vertex , add two vertices~,  to~;
    \item for each , insert the arc  with capacity ;
    \item for each , insert the arc  with capacity ;
    \item for each  with~, insert the arc  with capacity one.
  \end{itemize}
\end{construction}

\begin{figure}[t!]
  \centering
  \begin{tikzpicture}[>=stealth,scale=1.0, transform shape]
\node[draw, shape=circle, inner sep=3pt] (t-1) at (7.5,2.8) {};

\node[draw, shape=circle, inner sep=3pt] (s-1) at (0,2.8) {};
    
    \node[draw, shape=circle, inner sep=1pt] (input-1) at (2.5,4) {};
    \node[draw, shape=circle, inner sep=1pt] (input-2) at (2.5,3) {};
    \node at (2.5,2.5) {};
    \node[draw, shape=circle, inner sep=1pt] (input-3) at (2.5,1.8) {};

    \node[draw, shape=circle, inner sep=1pt] (hidden-1) at (5,4) {};
    \node[draw, shape=circle, inner sep=1pt] (hidden-2) at (5,3) {};
    \node at (5.0,2.5) {};
    \node[draw, shape=circle, inner sep=1pt] (hidden-3) at (5,1.8) {};

\draw [->] (input-1) -- (hidden-3) node [pos=0.8, above] {};
    \draw [->] (input-1) -- (hidden-2) node [pos=0.8, above] {};
    \draw [->] (input-2) -- (hidden-1) node [pos=0.8, above] {};
    \draw [->] (input-3) -- (hidden-2) node [pos=0.8, above] {};
    
\foreach \l [count=\i] in {1,2,n}
        \draw [->] (s-1) -- (input-\i) node [pos=0.6, above] {}; 
    
\foreach \l [count=\i] in {1,2,n}
        \draw [->] (hidden-\i) -- (t-1) node [pos=0.4, above] {};
\end{tikzpicture} 
\caption{A flow network as described in \Cref{flowConst}. For each vertex  in the digraph~ there are two vertices  and~. We connect a vertex~ to a vertex  if the arc  is not in . Inserting the arc  is then represented by setting the flow on the arc  to one.
}
\label{fig:flownw}
\end{figure}
The network~ contains~ vertices and~ arcs (since , we also have~) and can be constructed in~ time.
See \Cref{fig:flownw} for an illustration.
Inserting an arc  in~ corresponds to sending flow from  to . Since, by definition,
each vertex~ will only receive at most~ flow from~ and each vertex  will send at most  flow to , we cannot insert more than~ arcs (\cref{cond:balance}).

We claim that for  (\cref{cond:minsize}), the maximum flow in the network is indeed .
To see this, let  and let .
	In the following, a vertex  () is called \emph{saturated} with respect to a flow~, if  ().
	Suppose that the maximum flow~ has a value less than .
	Then, there exist non-saturated vertices  and .
	Let   be the vertices to which  has an outgoing arc in the residual graph and let  be the vertices which have an outgoing arc to  in the residual graph.
	Observe that  and .
	Consequently,  holds due to \cref{cond:outdegbound}.
	Since  is not saturated, we know that  (due to \cref{cond:maxdegbound}).
	By the same reasoning (using \cref{cond:indegbound,cond:maxdegbound}) it follows that .

	Remember that  is a flow of maximum value. Hence, each vertex in~ and each vertex in~ is saturated. 
	Otherwise, there would be an augmenting path in the residual graph, contradicting our assumption of  being maximal. 
	If a vertex~ would receive flow from a vertex~, then this would imply a backward arc in the residual graph resulting in an augmenting path , again contradicting our maximality assumption for~. 
	Thus, we can conclude that all the flow that goes into  has to come from the remaining vertices in . This set has size at most .
	But since  for all  (by \cref{cond:outdegbound}), those~ vertices can cover at most a flow of value~ and, hence, 
	
	Since  is saturated, and since also  holds for all  (\cref{cond:indegbound}), we obtain from \cref{cond:balance}
	
	This contradicts  (\cref{cond:minsize}) and hence proves the claim.

	Now, let  be a maximum flow in~ (computable in  time~\cite{Orlin13}) and let . Note that  and~.
	Clearly, for the digraph  it holds~ for all~.\qed
\end{proof}

We remark that similar flow-constructions as given in the proof above have been used before~\cite{Gal57,CMPPS14}.
The difference here is that we actually argue about the size of the flow and not only about polynomial-time solvability. Consequently, our proof uses quite different arguments. 


With \Cref{lem:factor} we have the key which allows us to transfer solutions of \nDDCSC to solutions of \DDCSC. The following lemma is immediate.

\begin{lemma}\label[lemma]{cor:LargePiTupleSolution}
  Let  with  be an instance of \DDCSC with .
  If there exists an  with  such that
   with~ for all  is a yes-instance of \nDDCSC, then also~ is a yes-instance of \DDCSC.
\end{lemma}

We now have all ingredients for our first main result, namely transferring
fixed-parameter tractability with respect to the combined parameter~ to
fixed-parameter tractability with respect to the single parameter~, provided that \nDDCSC is fixed-parameter tractable with respect to the largest possible integer~ in the output sequence.
The idea is to search for large solutions based on \Cref{cor:LargePiTupleSolution} using \nDDCSC.
If there are no large solutions (that is, ), then we run an FPT-algorithm with respect to~.

\begin{theorem}\label{thm:FPT_transfer}
  If \nDDCSC is fixed-parameter tractable with respect to the largest possible integer~ in the output sequence and \DDCSC is fixed-parameter tractable with respect to , then \DDCSC is fixed-parameter tractable with respect to~.
\end{theorem}

\begin{proof}
  In the following, let  be the fixed-parameter algorithm solving \DDCSC in  time
  and let  be the fixed-parameter algorithm solving \nDDCSC in  time.
  Let  be a \DDCSC instance.

  If , then we can run algorithm~ on~
  in  time for some function~.

  Otherwise, we check for each~ whether the instance  with  for all~ is a yes-instance of \nDDCSC using algorithm~. Note that the running time is at most .
  If we find a yes-instance~ for some~, then we know by \cref{cor:LargePiTupleSolution} that  is also a yes-instance. If~ is a no-instance for all~, then we also know that there cannot exist a solution for~ of size larger than~ since the existence of a solution for a \DDCSC instance clearly implies a solution for the corresponding \nDDCSC instance.
  Therefore,  is a yes-instance if and only if  is a yes-instance.
  We can thus run algorithm~ on~ in~ time.\qed
\end{proof}

Our second main result allows us to transfer a polynomial-size problem kernel with respect to~
to a polynomial-size problem kernel with respect to~ if \nDDCSC is polynomial-time solvable.
The proof is analogous to the proof of \cref{thm:FPT_transfer}.

\begin{theorem}\label{thm:Kernel_transfer}
  If \DDCSC admits a problem kernel containing  vertices computable in  time and \nDDCSC is solvable in  time for polynomials~ and~, then \DDCSC admits a problem kernel with  vertices computable in~ time.
\end{theorem}

\begin{proof}
  Let  be a \DDCSC instance.
  If , then we simply run the kernelization algorithm on~
  obtaining an equivalent instance containing at most~ vertices in~ time.
  Otherwise, we check, in~ time for each~, whether the instance  with  for all~ is a yes-instance of \nDDCSC. Note that the running time is thus at most~.
  If we find a yes-instance~ for some~, then we know by \cref{cor:LargePiTupleSolution} that also~ is a yes-instance, and thus we return a trivial \DDCSC yes-instance. If~ is a no-instance for all~, then we also know that there cannot exist a solution for~ of size larger than~ since the existence of a solution for a \DDCSC instance clearly implies a solution for the corresponding \nDDCSC instance.
  Therefore,  is a yes-instance if and only if  is a yes-instance. Again, we run the kernelization algorithm on~ and return an equivalent instance with at most~ vertices in~ time.
  The overall running time is thus in~ and we obtain a problem kernel with respect to~.\qed
\end{proof}

\section{Applications}

In the following, we show how the framework described in \cref{sec:GeneralSetting} can be applied to three special cases of \DDCSC{}.
These special cases naturally extend known problems on undirected graphs to the digraph setting.

\subsection{Digraph Degree Constraint Completion} \label{sec:DDCC}

In this section, we investigate the NP-hard special case of \DDCSC\footnote{This special case was investigated more specifically
in the Bachelor thesis of \citeauthor{Kos15}~\cite{Kos15} (available online).} where the property~ allows any possible degree sequence, see \Cref{fig:flownw18} for two illustrating examples.

\begin{problemdef}
  \problemtitle{\DDCClong (\DDCC)}
    \probleminput{A digraph , a positive integer , and a ``degree list function'' .}
    \problemquestion{Is it possible to obtain a digraph  by inserting at most  arcs in~ such that  for all ?}
\end{problemdef}

\begin{figure}[t]
\centering
\begin{tikzpicture}[>=stealth, scale=0.9]

\node[gnode] (s-1) at (0,0) {};
\node[gnode] (s-2) at (2,0) {};
\node[gnode] (s-3) at (4,0) {};

\node at (0,0.5) {};
\node at (2,0.5) {};
\node at (4,0.5) {};

\node[gnode] (s-4) at (7,0) {};
\node[gnode] (s-5) at (9,0) {};
\node[gnode] (s-6) at (11,0) {};

\node at (7,0.5) {};
\node at (9,0.5) {};
\node at (11,0.5) {};

\draw[->] (s-1)  -- (s-2);
\draw[->, dashed] (s-3) -- (s-2);
\draw[->] (s-4) -- (s-5);
    
\end{tikzpicture}
\captionof{figure}{Two example instances of \DDCC with .
The left instance is solvable by inserting the (dashed) arc from the right vertex to the middle vertex.
The right instance is a no-instance since one cannot add an outgoing arc to the left vertex or to the middle vertex but one has to add an incoming arc to the right vertex (loops are not allowed).}
\label{fig:flownw18}
\end{figure}
\DDCC is the directed (completion) version of the well-studied undirected \textsc{Degree Constraint Editing} problem~\cite{MS12, Gol15} for which an~-vertex problem kernel is known~\cite{FNN16}.
We subsequently transfer the polynomial-size problem kernel for the undirected case to a polynomial-size problem kernel for \DDCC with respect to~\degpara.
Note that the parameter~\degpara is clearly at most~.
Since it is trivial to decide~ in this case, due to \cref{thm:PiEAfptDeltak} we obtain fixed-parameter tractability of \DDCC with respect to~.
The result is based on a bounded search space, namely a -type set (see \cref{def:alpha-block-type-set} and \cref{lem:DDCC-type-set}).
We further strengthen this result by removing all vertices that are not in the -type set and adjusting the degree list function~ appropriately.
\cref{lem:DDCC-type-set} then yields the correctness of this approach resulting in a polynomial-size problem kernel with respect to~.

We start with the following simple reduction rule.
Recall that a vertex~ is called unsatisfied if~.
  
\begin{rrule}\label{rr:DDCCtrivialNO}
  Let  be a \DDCC instance.
  If there are more than~ unsatisfied vertices, then return a trivial no-instance.
  Moreover, if there exists a vertex~ with  or , then also return a trivial no-instance.
\end{rrule}

\begin{lemma}\label[lemma]{lem:DDCCtrivialNO}
\cref{rr:DDCCtrivialNO} is correct and can be computed in  time.  
\end{lemma}

\begin{proof}
  If there are more than~ unsatisfied vertices, then we can return a trivial no-instance since
  inserting an arc can satisfy at most two vertices.
  Also, by inserting arcs we can only increase in- and outdegrees of vertices. Hence, we can return a no-instance if the in- or outdegree of a vertex is larger than .
  This proves the correctness.
  
  The reduction rule is applicable in  time by computing the degree of each vertex in  time and subsequently iterating through~.\qed
\end{proof}

Based on \cref{rr:DDCCtrivialNO}, we obtain a polynomial-size
problem kernel with respect to the combined parameter~ as follows.


\begin{theorem}\label[theorem]{thm:DDCCkrKernel}
\DDCC admits a problem kernel where the number of vertices is in . 
It is computable in  time.
\end{theorem}

\begin{proof}
  Let  be an instance of \DDCC.
  First, we apply \cref{rr:DDCCtrivialNO} in  time. If a no-instance is returned, then we are done. Otherwise, we know that there are at most~ unsatisfied vertices.
  Also, we know that  and  for all~.
  We compute an -type set~ (see \cref{def:alpha-block-type-set}) for  in  time (\cref{lem:alphaSetLinTime}) and return the instance , where the adjusted degree list~, for each~, is defined as follows:
	
    The instance~ can be computed in~ time.
    We now show that~ is an equivalent instance of \DDCC.

    Assume that~ is a yes-instance, that is, there exists a set~ of size at most~ such that  for each .
    Then, the set~ is also a solution for~ since, for each vertex~,  by definition of~.
    Moreover, for each vertex~, we know that  since  contains only satisfied vertices. Hence,  is a yes-instance.

    Conversely, let~ be a yes-instance. Then, by \cref{lem:DDCC-type-set}, we know that there exists an arc set~ of size at most~ such that  for all~.
    Then, for each vertex~,  by definition of~.
    Hence, also~ is a yes-instance.
    
    Concerning the size of~, observe that~ contains at most~ unsatisfied vertices and at most~ satisfied vertices for each of the~ possible types.
    Therefore,
    
Since , we obtain a problem kernel with~ vertices.
  The overall running time is in~.\qed
\end{proof}

The goal now is to use our framework (\cref{thm:Kernel_transfer}) to transfer the polyno\-mial-size problem kernel with respect to~ to a polynomial-size problem kernel with respect to~ alone.
To this end, we show that the corresponding number problem \nDDCC (which is the special case of \nDDCSC without the sequence property~) is polynomial-time solvable.

\begin{problemdef}
    \problemtitle{\textsc{\nDDCClong} (\nDDCC)}
    \probleminput{A sequence  of~ nonnegative integer tuples,
                  a positive integer~, and
                  a ``tuple list function'' .}
    \problemquestion{Is there a sequence 
                     such that , and
                     , , and  for all ?}
\end{problemdef}

\nDDCC can be solved in pseudo-polynomial time by a dynamic programming algorithm. 
Note that pseudo-polynomial time is sufficient for our purposes since all occurring numbers will be bounded by~ when creating the \nDDCC instance from the given \DDCC instance.
(In fact, we conjecture that \nDDCC is weakly NP-hard and a reduction from \textsc{Partition} should be possible as in the case for \nDA in \cref{sec:DA}, \cref{thm:nDAhard}.)

\begin{lemma}\label[lemma]{lem:nDDCC-poly}
\nDDCC is solvable in  time.
\end{lemma}

\begin{proof}
Let  be an instance of \nDDCC.
We solve~ using a modified version of the dynamic programming algorithm for \NCEA due to \citet[Lemma~2]{FNN16}.
To this end, we define the Boolean table~ for , ,
where~ if and only if there exist tuples~ with ,  and  for all  such that
 and .
Thus,  is a yes-instance if .
We compute~ based on the recurrence where we essentially consider all possibilities to fix the~-th tuple and recurse:

where we set

The size of  is in . A single entry can be computed in~ time.\qed
\end{proof}

Combining \cref{thm:DDCCkrKernel,lem:nDDCC-poly} yields the following corollary of \cref{thm:Kernel_transfer}.

\begin{corollary}\label[corollary]{cor:DDCCkernel}
	\DDCC admits a problem kernel containing  vertices.
	It is computable in~ time.
\end{corollary}

\subsection{Digraph Degree Sequence Completion}
\label{sec:DDSC}

\begin{figure}[t]
  \centering
  \begin{tikzpicture}
    \node[gnode] (v1) at (0,0) {};
    \node[gnode] (v2) at (2,0) {};
    \node[gnode] (v3) at (4,0) {};
    \node[gnode] (v4) at (2,0.7) {};
    \node[right] at (4.5,0.4) {};
    
    \draw[->] (v1) to (v2);
    \draw[->] (v2) to (v3);
    \draw[->] (v4) to (v2);
    \draw[->] (v4) to (v3);
    \draw[->, dashed] (v4) to (v1);
  \end{tikzpicture}
  \caption{Example instance of \DDSC.
           Inserting the dashed arc in the input digraph (solid arcs) with degree sequence~ yields a digraph with the given target sequence~.}
  \label{DDSCexample}
\end{figure}

In this section, we investigate the NP-hard special case of \DDCSC\footnote{Although not stated explicitly, the NP-hardness follows from the proof of Theorem 3.2 of the Bachelor thesis of \citet{Mil15} (available online) as the construction therein allows for only one feasible target degree sequence.}
 where~ does not restrict the allowed degree of any vertex and ~is fulfilled by exactly one specific degree sequence~ (see \cref{DDSCexample} for an example).
The undirected problem variant is studied by \citet{GM17}.
\begin{problemdef}
	\problemtitle{\DDSClong (\DDSC)}
	\probleminput{A digraph , a digraph degree sequence~ containing~ integer tuples.}
	\problemquestion{Is it possible to obtain a digraph~ by inserting arcs in~ such that~?}
\end{problemdef}

For \DDSC, the parameter~\degpara is by definition equal to~.
Moreover, note that the number~ of arcs to insert (if possible) is determined by the target sequence~ by~.
We henceforth assume that 
holds since otherwise we have a trivial no-instance.

Since deciding~ (that is, deciding whether ) can be done in polynomial time, we immediately obtain fixed-parameter tractability of \DDSC with respect to~ due to \cref{thm:PiEAfptDeltak}.
We further strengthen this result by developing a polynomial-size problem kernel for \DDSC with respect to~.
The kernelization is inspired by the~-vertex problem kernel for the undirected problem by~\citet{GM17}.
The main idea is to only keep the vertices of a -block set (see \cref{def:alpha-block-type-set}) together with some additional ``dummy'' vertices and to adjust the digraph degree sequence~ properly.










\begin{theorem}
  \label{thm:DDSC_kDelta-kernel}
  \DDSC admits a problem kernel containing~ vertices computable in~ time.
\end{theorem}

\begin{proof}
  Let~ be a \DDSC instance. Clearly, since we are only allowed to insert arcs in the digraph~, we can never decrease the in- or outdegree of any vertex. Hence, if~ or , then we return a trivial no-instance.
  Otherwise, we know that~.
  Moreover, since inserting one arc can change the degrees of at most two vertices, it also holds  for each~.

  We now compute a -block set~ (see \cref{def:alpha-block-type-set}) in~ time (\cref{lem:alphaSetLinTime}) and return the instance~ which is defined as follows.
  The digraph~ is constructed from~ by the following steps:
  \begin{itemize}
    \item Delete all vertices of~.
    \item Add  new vertices~ and insert all arcs~.
    \item For each~ such that the number~ of inneighbors in~ is at least one, insert the arcs~.
      \item For each~ such that the number~ of outneighbors in~ is at least one, insert the arcs~.
      \end{itemize}
      The digraph~ can be constructed in~ time.
  Observe that  and  hold for all~, and that~ holds for all~.
  The number of vertices in~ equals~. Note that~ contains at most~ vertices of each of the~ possible vertex degrees in~. Thus,  contains  vertices.
  
  The digraph degree sequence~ is constructed from~ as follows:
  \begin{itemize}
    \item For each vertex~ that was removed from~, remove a copy of the tuple~ from~
    \item For each , add the tuple .
    \end{itemize}
    Note that this construction is well-defined, that is, we can always apply the first step and remove a copy of~ from~ since we remove at most  copies.
    The construction of~ can be done in~ time. Hence, the overall running time of computing the problem kernel is in~.

    It remains to show that~ is a yes-instance if and only if~ is a yes-instance.
    Assume first that~ is a yes-instance. We know from \cref{lem:PiDDSC-block-set} that there exists a solution~ with~.
    Using
    
it is then easy to verify that~, and thus,  is a yes-instance.

Conversely, let~ be a solution for~
with~.
We claim that~, that is,~ does not contain an arc incident to a vertex in~. To see this, recall that by construction

hold for all~.
That is, , and thus a solution must not insert arcs incident to~. It follows that .
This recursively also holds for  and thus, we have  for all~.
Hence,  does not contain any arcs incident to vertices in~, that is, .
Thus, we can derive

It is now straightforward to check that .\qed
\end{proof}
To apply our framework and derive a polynomial-size problem kernel with respect to~ for \DDSC, we define a corresponding number problem and show its polynomial-time solvability.
The number problem \nDDSC is the special case of \nDDCSC asking for the specific target sequence~.

\begin{problemdef}
    \problemtitle{\textsc{\nDDSClong (\nDDSC)}}
    \probleminput{Two multisets  and~ containing~ nonnegative integer tuples.}
    \problemquestion{Is there a bijection~ such that
     , and , for all ?}
\end{problemdef}

\nDDSC can be solved in polynomial time by finding perfect matchings in an auxiliary graph.

\begin{lemma}
  \label[lemma]{lem:TSC-poly}
  \nDDSC is solvable in~ time.
\end{lemma}

  \begin{proof}
    We show how to solve the problem by computing a perfect matching in a bipartite graph.
    Let  be a \nDDSC instance. 
We construct an undirected bipartite graph~. For each~, there is a vertex~ corresponding to the tuple~, and a vertex~ corresponding to~.
    For each~, , the edge~ is in~ if and only if~ and~ hold.
    The graph~ can be computed in~ time. Note that a perfect matching in~
    defines a bijection that satisfies the condition in the problem definition. Hence, we can solve a \nDDSC instance by computing a perfect matching in a bipartite graph, which can be done in~ time~\cite{HK73}.\qed
  \end{proof}

Combining \cref{thm:DDSC_kDelta-kernel} and \cref{lem:TSC-poly} yields the following corollary of \cref{thm:Kernel_transfer}.

\begin{corollary}\label[corollary]{cor:DDSCkernel}
	\DDSC admits a problem kernel containing  vertices. 
	It is computable in  time.
\end{corollary}


\subsection{Degree Anonymity}
\label{sec:DA}

We extend the definition of \textsc{Degree Anonymity} in undirected graphs due to \citet{LT08} to digraphs and obtain the following NP-hard problem~\cite{Mil15} (\cref{example of DA} presents an example): 

\begin{problemdef}
	\problemtitle{\DAlong (\DA)}
	\probleminput{A digraph  and two positive integers  and .}
	\problemquestion{Is it possible to obtain a digraph   by inserting at most~ arcs in~ such that~ is -anonymous, that is, for every vertex  there are at least ~other vertices in  with degree~?}
\end{problemdef}

\begin{figure}[t]
	\centering
	\begin{tikzpicture}
			\node[gnode] (a1) at (0,0.25) {};
			\node[gnode] (a2) at (1.5,0.25) {};
			\node[gnode] (b1) at (4,0.25) {};
			\node[gnode] (b2) at (5.5,0.25) {};

                        \draw[->, bend angle=30, bend left] (a1) to (a2);
                        \draw[->, bend angle=30, bend left] (a2) to (a1);
                        \draw[->, bend angle=30, bend left] (b1) to (b2);
                        \draw[->, bend angle=30, bend left] (b2) to (b1);
                        
			\node[gnode] (c1) at (8,0) {};
			\node[gnode] (c2) at (9,0.5) {};
			\node[gnode] (c3) at (10,0) {};

                        \draw[->] (c2) to (c1);
                        \draw[->] (c3) to (c2);
                        \draw[->, dashed] (c1) to (c3);
	\end{tikzpicture}
      \caption{Example instance of \DA. The input digraph with three components (solid arcs) is -anonymous since there is only one vertex with degree . By inserting the dashed arc, the digraph becomes -anonymous since all vertices have degree~.}
	\label{example of DA}
\end{figure}

The (parameterized) complexity as well as the (in-)approx\-imability of the undirected version called \textsc{Degree Anonymity} are well-studied~\cite{CKSV13,HNNS15,BBHNW16}.
There also exist many heuristic approaches to solve the undirected version~\cite{CHT17,HHN14}. Notably, our generic approach shown in~\cref{sec:GeneralFPTr} originates from a heuristic of~\citet{LT08} for \textsc{Degree Anonymity}.
Later, \citet{HNNS15} used this heuristic to prove that ``large'' solutions of \textsc{Degree Anonymity} can be found in polynomial time and \citet{FNN16} extended this approach to a more general class of problems.
The property~ (that is, -anonymity) can clearly be checked for a given input digraph degree sequence in polynomial time. Hence, \cref{thm:PiEAfptDeltak} yields fixed-parameter tractability of~\DA with respect to~.
Again, we develop a polynomial-size problem kernel with respect to~.
Somewhat surprisingly, we cannot transfer this problem kernel to a problem kernel with respect to~ since we are not able to solve the corresponding number problem in polynomial time.
In fact, we will show that it is at least weakly NP-hard.


To start with, we give a problem kernel based on \Cref{lem:PiDDSC-block-set} in a similar fashion as in the proof of \Cref{thm:DDSC_kDelta-kernel}.
More precisely, by \Cref{lem:PiDDSC-block-set} we know that we only need to keep a -block set~, that is,  arbitrary vertices of each block.
Note that deleting all vertices that are not in~ changes the degrees of the vertices in~.
We repair this in a similar way as in the problem kernel stated in \Cref{thm:DDSC_kDelta-kernel}: 
After deleting the vertices that are not in~, we add vertices adjacent to the vertices in~ in such a way that the vertices in~ keep their original degrees. 
Denoting the set of newly added vertices by~, we also need to ``separate'' the vertices in~ from the vertices in~ so that their degrees do not interfere in the target degree sequence. 
We do this, similarly as in the proof of \Cref{thm:DDSC_kDelta-kernel}, by increasing the degrees of all vertices in~ to at least~. 
Furthermore, we need to ensure that a solution in the new instance does not insert arcs between vertices in~ and vertices in~ since we cannot map such solutions back to solutions for the original instance.
Solving this issue, however, is not as simple as for \DDSC
and requires some adjustment of the actual number of vertices we keep. 
As a result, we will prove that if there is a solution inserting arcs between~ and~, then there is also a solution not inserting such arcs (\Cref{lem:P-uneff}).

Another adjustment concerns the anonymity level~: 
If~ is large, then we need to shrink it since otherwise we would always create no-instances. 
The general idea is to keep the ``distance to size~'', meaning that if in the original instance some block contains~ vertices for some~, then in the new instance this block should contain~ vertices where~ is the new anonymity level.
The reason for the specific range of values for~ between~ and~ is that if some block has size larger than~ for example, then, after inserting~ arcs, this block will still be of size larger than~.
Similarly, if a block contains less than~ vertices, then after inserting~ arcs it will contain less than~ vertices and it will violate the -anonymity constraint unless it is empty. 
Hence, the interesting cases for~ are between~ and~.
In order to ensure that there is a solution not inserting arcs between~ and~, we need to increase this range from~ to~, see the proof of \Cref{lem:P-uneff} for further details.

In the following, we describe the details of our kernelization algorithm, see \cref{alg:polyKernelDirDegAnon} for the pseudocode. 
Observe that our general approach is a non-obvious adaption of the polynomial-size problem kernel for the undirected \textsc{Degree Anonymity} problem by \citet{HNNS15}. 
\begin{algorithm}[t!]\small
  \caption{The pseudocode of the algorithm computing a polynomial-size kernel with respect to  for \DA.}
 \label{alg:polyKernelDirDegAnon}
	\KwIn{A digraph~ and integers .}
	\KwOut{A digraph~ and integers .}
   \vspace{1em}
	\If(\tcp*[f]{ is defined as~} \label{line:iniBound}){}
	{
		\KwRet{}
	}
	\; \label{line:setNewK} 
        \;
	\ForEach(\label{line:keepVerticesStart}){distinct tuple  occurring in }
	{
		\If{}
		{
			\KwRet{trivial no-instance} \tcp*{insufficient budget for } \label{line:trivialNoInstance}
		}
		\uIf(\tcp*[f]{determine number of retained vertices}){}
		{
			 \tcp*{keep at most~ vertices} \label{line:NoOfVerticesCase1} 
		}
		\uElseIf(\tcp*[f]{``small'' block}){}
		{
			 \tcp*{keep all vertices (``distance to size zero'')} \label{line:NoOfVerticesCase2.1} 
		}
		\Else(\tcp*[f]{``large'' block and~})
		{
			 \tcp*{keep ``distance to size~''} \label{line:NoOfVerticesCase2.2} 
		}
		add~ arbitrary vertices from~ to~\; \label{line:keepVerticesEnd}
	}
	\; \label{line:keepGA} \ForEach(\tcp*[f]{insert new vertices to preserve degrees of vertices in~}){}
	{
	 add  many vertices with an incoming arc from~ to~\;\label{line:add-outdeg-fix-vertices}
	add  many vertices with an outgoing arc to~ to~\;\label{line:add-indeg-fix-vertices}
	}
	let  be the set of vertices added in \cref{line:add-outdeg-fix-vertices} \tcp*{}
	let  be the set of vertices added in \cref{line:add-indeg-fix-vertices} \tcp*{}
	\While{}
	{
		add a new vertex~ to~ \label{line:add-P-in-vertex}\;
		add a new vertex~ to~ \label{line:add-P-out-vertex}\;
		insert the arc~ in~ \;
	}
	insert all arcs~ and~ in~ \label{line:high-degree-in-P} \tcp*{ensure high degree difference from vertices in~}
	insert all arcs from~ in~  \label{line:separate-P-in-and-P-out} \tcp*{separate  from~}
	\KwRet{}
\end{algorithm}

\begin{lemma}\label[lemma]{lem:P-uneff}
	Let~ be an instance of \DA and let~ be the instance computed by \Cref{alg:polyKernelDirDegAnon}, where~ is the set of newly added vertices.
	If there is a solution~ with , then there is also a solution~ with  such that~.
\end{lemma}

\begin{proof}
	Let~ be a solution for~ such that~.
	We construct a new solution~ such that~ and~.
	The idea is to replace the endpoints of arcs that are in~ by new endpoints from one ``large'' block (of size at least~, where ) in~.
	To this end, observe that if~, then \Cref{alg:polyKernelDirDegAnon} returns the original instance (see \cref{line:iniBound}) and we are done. 
	Hence, there is at least one block~ for some~ of size at least~ since there are at most~ blocks.
	We will use vertices in~ as a replacement for the vertices in~ within the arcs of~.
	
	We now construct~.
	To this end, initialize~ and insert further arcs in the following way.
	First, consider those arcs in~ that have exactly one endpoint in~.
	For each arc~ with  and~, insert the arc~ in~ where~ such that~ is not incident to any arc in~ and is not an outneighbor of~.
	Since~ and~, it follows that~ contains such a vertex~. 
	Similarly, for each arc~ with  and~, insert the arc~ in~ where~ is a vertex not incident to any arc in~ and not an inneighbor of~.
	Again, due to the size of~, such a vertex exists.
	
	Second, consider those arcs in~ having both endpoints in~.
	For each arc~ with , insert the arc~ in~ where~ such that neither~ nor~ is incident to any arc in~ and~.
	Since~ and~, it follows that these vertices~ and~ exist.
	Observe that after all these modifications, there are still at least~ vertices left in~.
	
	Clearly, we have~.
	It remains to prove that~ is -anonymous.
	To this end, observe that, since the outdegree of each vertex in~ is at least  (see \cref{line:separate-P-in-and-P-out}) larger than the outdegree of any vertex in , it follows that the vertices in~ which are incident to an arc in~ end up in blocks of~ that are empty in~.
	Thus, at least~ vertices in~ are the head of an arc in~ and at least~ vertices in~ are the tail of an arc in~.
	Hence, we used at least~ vertices from~ as an replacement in~ and thus the blocks~ and~ contain at least~ vertices.
	Furthermore, all other vertices in~ have the same degree in~ and in~ and the vertices in~ are not incident to any arc in~.
	Since~ was a solution, it follows that also~ is -anonymous.\qed
\end{proof}

We remark that parts of the proof of \cref{lem:P-uneff} are an adaption of the proof of the corresponding lemma in the undirected case~\cite[Lemma 6]{HNNS15}.

\begin{theorem}
	\label{thm:DirDegAnon-kernel-sDelta}
	\DA admits a problem kernel containing~ vertices. 
	It is computable in~ time.
\end{theorem}

\begin{proof}
	We use \cref{alg:polyKernelDirDegAnon} to compute the problem kernel. 
	The correctness of the kernelization follows from the following two lemmas.
        Their proofs are, however, adaptions of the corresponding undirected counterparts~\cite[Lemmas~7 and~8]{HNNS15}

	Let~ be a digraph and~. 
	An arc set~ is called \emph{-insertion set} for~, if~ is~-anonymous.
        
	\begin{lemma}\label[lemma]{lem:polyKernelRueckrichtung-DirDegAnon}
		If the instance~ constructed by \Cref{alg:polyKernelDirDegAnon} is a yes-instance, then  is a yes-instance.
	\end{lemma}

	\begin{proof}[of \cref{lem:polyKernelRueckrichtung-DirDegAnon}]
		First, observe that if , then  and each -insertion set for~ is a -insertion set for~ as all blocks with less than~ vertices remain unchanged. 
		Hence, it remains to consider the case that~ and thus~.
		
		Let~ be an arc set such that~ and  is -anonymous.
		By~\cref{lem:P-uneff}, we can assume that each arc in~ has both endpoints in~.
		We show that~ is -anonymous, that is, for each block~ we have~ or .
		To this end, we distinguish two cases on whether the corresponding block in~ is empty or contains at least~ vertices.
		
		First, consider the case~. 
		Since it holds that , it follows that~. 
		By \cref{line:NoOfVerticesCase2.1,line:NoOfVerticesCase2.2}, it follows that~ and~ contain the same vertices of degree~, that is, .
		Hence, we have~.
		
		Second, consider the case~.
		If~, then it clearly holds that  and we are done.
		Otherwise, by \cref{line:NoOfVerticesCase2.2}, we have~.
		Since~ only contains arcs with both endpoints in~, it follows that by inserting~, the same vertices will be added and removed from~ and~, that is, .
		Since~ it follows that~. 
		Thus,  is -anonymous and  is a yes-instance.
		\hfill (Proof of \cref{lem:polyKernelRueckrichtung-DirDegAnon})
	\end{proof}

	\begin{lemma}\label[lemma]{lem:polyKernelHinrichtung-DirDegAnon}
		If  is a yes-instance, then the instance~ constructed by \Cref{alg:polyKernelDirDegAnon} is a yes-instance.
	\end{lemma}

	\begin{proof}
		Observe that, in the instance~ constructed by \Cref{alg:polyKernelDirDegAnon}, for each degree~ we have that either~ (in case that~ contains few vertices, see \cref{line:NoOfVerticesCase1,line:NoOfVerticesCase2.1}) or~ contains at least~ vertices (, see \cref{line:trivialNoInstance,line:NoOfVerticesCase1,line:NoOfVerticesCase2.2}).
		Thus,  contains a~-block set.
		Since  is a yes-instance, it follows from \cref{lem:PiDDSC-block-set} that there is a -insertion set~ of size at most~ for~ such that~.
		
		We next show that~ is -anonymous, and hence,  is a yes-instance.
		First, consider the case that~ and thus .
		Observe that every block~ containing at least~ vertices also contains at least~ vertices in~.
		For every block~ containing less than~ vertices it holds that~ (see \cref{line:NoOfVerticesCase1}).
		Thus,  and therefore~ fulfills the -anonymity requirement.
		
		Second, consider the case that~ and thus .
		Let~ be some block of~.
		We show that~ or~.
		If~, then~ (see \cref{line:NoOfVerticesCase2.1}).
		Hence,  since~.
		If~, then~ (see \cref{line:trivialNoInstance}) and thus~ (see \cref{line:NoOfVerticesCase2.2}).
		Observe that~, and thus,
		
		Since~, we have~. 
		We now distinguish the two cases~ and~.
		In the first case, it follows that~ and from \cref{eq:size1} it follows
		
		In the second case, it follows that~ (see \cref{line:NoOfVerticesCase2.2}).
		Observe that~ since~.
		From \cref{eq:size1} we conclude that
		
                \hfill (Proof of \cref{lem:polyKernelHinrichtung-DirDegAnon})
	\end{proof}	
	The size of the kernel can be seen as follows:
	For each of the at most~ different blocks in the input graph~, the algorithm keeps at most~ vertices in the set~ (see \cref{line:NoOfVerticesCase1,line:NoOfVerticesCase2.1,line:NoOfVerticesCase2.2}).
	Thus, .
	The number of newly added vertices in \crefrange{line:add-outdeg-fix-vertices}{line:add-P-out-vertex} is at most~.
	Hence,  and thus the instance produced by \cref{alg:polyKernelDirDegAnon} contains at most~ vertices.
	
	The running time can be seen as follows:
	Using bucket sort, one can lexicographically sort the~ vertices by degree in~ time.
	Furthermore, in the same time one can create~ lists---each list containing the vertices of some degree~.
	Then, the selection of the~ vertices of~ can be done in~ time.
	Clearly, inserting the vertices in~ can be done in~ time.
	Finally, inserting the arcs between the vertices in~ (\cref{line:high-degree-in-P,line:separate-P-in-and-P-out}) takes~ time.\qed
\end{proof}

In contrast to both number problems in \cref{sec:DDCC,sec:DDSC}, we were unable to find a polynomial-time algorithm for the number problem for \DA, which is the special case of \nDDCSC asking for a -anonymous target sequence.

\begin{problemdef}
    \problemtitle{\nDAlong (\nDA)}
    \probleminput{A sequence  of~ nonnegative integer tuples,
                  two positive integers~ and .}
    \problemquestion{Is there a sequence 
      such that
      \begin{compactenum}[(i)]
        \item ,
        \item , and  for all , and
        \item each tuple in~ appears at least~ times?
      \end{compactenum}}
\end{problemdef}

We can show that \nDA is weakly NP-hard by a polynomial-time many-one reduction from \textsc{Partition}.

\begin{problemdef}
	\problemtitle{\textsc{Partition}}
	\probleminput{A multiset~ of positive integers that sum up to~.}
	\problemquestion{Is there a subset~ whose elements sum up to~?}
\end{problemdef}

\begin{theorem}
	\label{thm:nDAhard}
	\nDA is (weakly) NP-hard even if~.
\end{theorem}

\begin{proof}
	Given a multiset , observe that we can assume without loss of generality that each integer in~ is smaller than~ (otherwise we could solve the instance in polynomial time).
 
	We create the following \nDA-instance with , , and the sequence  containing the following tuples.
	For each  create five tuples: one tuple  of type , one block~ that contains two tuples of type~, and one block~ that contains two tuples of type~.
	This completes the construction.
 
	We show that there is a subset  whose elements sum up to exactly~ if and only if there is a sequence  that fulfills Conditions (i)--(iii) of \nDA.
 
	First, assume that there is some  and .
	Then, we obtain the desired sequence~ by first copying~ and changing~ as follows:
	For each  change the tuple  from type~ to type~ and for each  change the tuple  from type~ to type~.
	It is not hard to verify that this~ is indeed a solution:
	For Condition~(i), observe that  since the elements in~ as well as the elements in~ sum up to~.
	Condition (ii)~is clearly ensured by construction of~.
	For Condition~(iii), note that in sequence~ block~ contains either ~tuples (if ) or ~tuples (if ) and, analogously, note that block~ contains either ~tuples (if ) or ~tuples (if );  contains no further tuples.
	
	Second, assume that there is a sequence  that is a solution for our constructed \nDA instance.
	First note that  does not differ from~ ``a lot'' in the following sense.
	Since  and , in sequence~ the first component and the second component of all tuples can in total be increased by at most~, respectively.
	Next, observe that each tuple~ must either be of type~ or of type~, since  every other tuple is too far away (recall that  for all~).
	This means that each tuple~ contributes with~ to the total sum over the differences in either the first component (), or the second component ().
	Since , it follows that the tuples~ require at least a budget of~ in either the the first or the second component. 
	Let x_i(2B(i+1),0)\sigma'.
	We show that .
	Assume towards a contradiction that .
	Since  and , either  or  would be greater than~---a contradiction to our budget.\qed
\end{proof}

Note that the hardness from \cref{thm:nDAhard} does not translate to instances of \nDA originating from digraph degree sequences because in such instances all numbers in the input sequence~ and also in the output sequence~ are bounded by~ where~ is the number of tuples in~.
Since there are pseudo-polynomial-time algorithms for \textsc{Partition}, \cref{thm:nDAhard} leaves open whether \nDA is  strongly NP-hard or can be solved in polynomial time for instances originating from digraphs.

To again apply our framework (\cref{thm:FPT_transfer}), we show that \nDA is at least fixed-parameter tractable with respect to the largest possible integer~ in the output sequence.
To this end, we develop an integer linear program that contains at most~~integer
variables and apply a famous result due to \citeauthor{Len83}~\cite{Len83}. 

\begin{theorem}\label{thm:nDA-FPT}
	\nDA is fixed-parameter tractable with respect to the largest possible integer~ in the output sequence.
\end{theorem}

\begin{proof}
 Let  be an instance of \nDA.
 The key idea is that knowing how many tuples of type~ in~ are
 transformed into a tuples of type~ in~ for each pair~ of tuples
 is sufficient to describe a solution of our \nDA instance.
 To this end, observe that there are at most  tuple blocks
 in~ and in~, respectively.
 
 We describe an integer linear problem and create one variable  for each
 pair  which denotes the number of tuples
 of type~ in sequence~ that become tuples of type~ in sequence~.
 We further use the binary variables~ for each  being~ if and only if some tuple of type~ is used in the solution, that is,
 there is at least one tuple of type~ in~.
 We add a set of constraints ensuring that all tuples from  appear in :
 
 Then, we ensure that (i) holds by:
  
 and by:
 
 We ensure that (ii) holds by:
 
 We ensure that (iii) holds by:
 
 Finally, we add the following constraint set to ensure consistency between the~ and ~variables:\
 

 Finally, fixed-parameter tractability follows by
 a result of \citet{Len83}
(later improved by \citet{Kan87,FT87b})
 that says that an ILP with  variables and  input bits can be solved
 in~ time.\qed
\end{proof}

Combining \cref{thm:PiEAfptDeltak,thm:FPT_transfer,thm:nDA-FPT} yields fixed-parameter tractability for \DA with respect to~.

\begin{corollary}\label[corollary]{cor:DDAfpt}
  \DA is fixed-parameter tractable with respect to~.
\end{corollary}

For undirected graphs, \citet{HNNS15} showed fixed-parameter tractability with respect to the maximum degree~ of the input graph.
This result was based on showing that~.
For directed graphs, however, we can only show that~ implying fixed-parameter tractability with respect to~.

\begin{lemma}\label[lemma]{lem:DA-kernel-k-delta-bound}
	Let~ be a digraph and let~ be a minimum size arc set such that~ is -anonymous.
	Then .
\end{lemma}

\begin{proof}
 Let~ be a digraph with maximum degree~ and let~ be a positive integer.
 An arc set~ is called \emph{-insertion set} for~ if~ is~-anonymous.
 Further, let~ be a minimum size -insertion set. We will show that if~, then the maximum degree in~ is at most~, and
 if~, then the degree in~ is clearly at most~.
	
Now suppose that~ and assume towards a contradiction that~ has a maximum degree~.
We next construct a smaller -insertion set~ in two steps.
In the first step, we define for each vertex~, a target degree~ such that the following (and further conditions that are discussed later) holds:
	\begin{enumerate}[(a)]
		\item\label[cond]{cond:i} ,
		\item\label[cond]{cond:ii} , and
		\item\label[cond]{cond:iii} the multiset~ is -anonymous, that is~ for each~.
	\end{enumerate}
	As a second step, we use \cref{lem:factor} to provide an arc set~ such that~.
	Since~ is -anonymous, it follows that~ is a -insertion set and we will show that~. 

	We now give a detailed description of the two steps and start with defining the target degree function~ as follows
	
	Observe that~ satisfies the above three \cref{cond:i,cond:ii,cond:iii}. 
	Furthermore, we have~ since the maximum degree in  is larger than .
	If we can realize the target degrees~ with a~-insertion set~, then it follows that~.
	
	To apply \cref{lem:factor} with~,  and , we need to satisfy \cref{cond:maxdegbound,cond:indegbound,cond:outdegbound,cond:balance} of \cref{lem:factor}.
	By assumption,  holds.
	Hence, \cref{cond:maxdegbound} is fulfilled.
	Moreover,  and~ holds for all .
	\cref{cond:indegbound,cond:outdegbound} are thus also satisfied.
	However, we also need to ensure~ (\cref{cond:balance}), that is, we need to ensure that~ changes the indegrees and outdegrees of the vertices in~ by the same overall amount.
	This might not be true as we changed the indegrees and outdegrees independently.
	To overcome this problem, we subsequently adjust~ again.
	
	Assume without loss of generality that compared to~ the target degree function~ reduced more indegrees than outdegrees, that is,
        
	Denote by  the difference between the two sums, that is,
	
	Further, denote by~ the \emph{block of~ in~}, that is the set vertices having the same target degree as~.
	In the final adjustment of~ we need~ to be at least~ and at most~.
	Hence, if~, then we adjust~ as follows:
	Pick an arbitrary vertex~ such that the outdegree of~ in~ is larger than~.
	Observe that such a vertex must exist: 
	We assumed to reduce the indegrees more than the outdegrees (thus ), hence we reduced the indegrees of the vertices of at least one block, that is, of at least~ vertices. 
	Since~ it follows that we also reduced the outdegrees of at least one block and thus, such a vertex~ exists.
	If the block of~ contains at least~ vertices, then increase the target outdegree of exactly~ of these vertices by one.
	Otherwise, if the block contains less than~ vertices, then increase the target outdegree of all these vertices by one.
	It follows that~.
	Furthermore, observe that~, that is, after realizing the target degrees~, the corresponding -insertion set~ is still smaller than~.

	In the following, we increase the indegrees in two rounds.
	Observe that if we do not increase outdegrees, then it still holds that~.
	In the first round, while~ do the following:
	\begin{enumerate}
		\item Pick an arbitrary vertex with~.
		\item\label{2nd} If~, then increase the target indegree~ by one for each~.
		\item\label{3rd} Else, it follows that~. 
				Let~ be an arbitrary subset of size exactly~ and increase the target indegree~ by one for each~.
	\end{enumerate}
	Observe that in Step~\ref{2nd} as well as in Step~\ref{3rd} we increase the target indegree of at least~ vertices that have the same target degree.
	Furthermore, in Step~\ref{3rd} we ensure that at least~ vertices with the original target degree remain.
	Hence, the (changed) multiset~ is still -anonymous.
	Furthermore, it is easy to verify that the maximum target indegree is at most~.
	Finally, observe that we decrease~ in each iteration by at most~ and, hence, we have .
	
	In the second round, we have that~.
	We simply pick a block~ with at least~ vertices and increase the target indegree of exactly~ vertices.
	Since~ and there are at most~ different degrees in~ (in- and outdegrees between~ and~), it follows that there exists such a block of size at least~.
	Furthermore, observe that, after this change in the second round,~ is still -anonymous and the maximum target indegree is at most~.
	Hence, the adjusted target degree function~ fulfills \cref{cond:maxdegbound,cond:indegbound,cond:outdegbound,cond:balance} of \cref{lem:factor}.
        
	It remains to show the last condition in \cref{lem:factor}, that is, \cref{cond:minsize} stating .
	Due to the definition of~ (see \cref{eq:def-tau}), it follows that we only decreased the degrees of vertices with in- or outdegree greater than~ in~.
	Since the target degrees of these vertices is at least~ (the later changes to~ only increased some degrees), it follows that~ is exactly the set of vertices whose target indegree (outdegree) is larger than their indegree (outdegree) in~. 
	Hence, 
	
	Since~ it follows that \cref{cond:minsize} is indeed fulfilled.
	Thus, the set~ realizing~ is a -insertion set of size less than~; a contradiction to the fact that~ is a minimum size -insertion set for~.\qed
\end{proof}

Combining \cref{thm:PiEAfptDeltak,thm:FPT_transfer,thm:nDA-FPT,lem:DA-kernel-k-delta-bound}, we obtain the following.

\begin{corollary}\label[corollary]{cor:DA-FPT-deltastern}
	\DA is fixed-parameter tractable with respect to~.
\end{corollary}

It remains open whether \DA is fixed-parameter tractable with respect to~.
We remark that the problems \DDCC and \DDSC are both NP-hard for~. 
This follows from an adaption of the construction given by \citet[Theorem 3.2]{Mil15}.


\section{Conclusion}
We proposed a general framework for digraph degree sequence completion
problems and demonstrated its wider applicability in case studies. 
Somewhat surprisingly, the presumably more technical case 
of digraphs allowed for some elegant tricks (based on
flow computations) that seem not to work for the 
presumably simpler undirected case. 
Once having established the framework (see Section~\ref{sec:GeneralSetting}), 
the challenges then
associated with deriving fixed-parameter tractability and kernelizability 
results usually boil down to the question for fixed-parameter tractability and (pseudo-)polynomial-time solvability of a simpler
problem-specific number problem. 
While in most cases we could develop polynomial-time algorithms solving these number problems, in the case of \DAlong the polynomial-time solvability of the associated number problem remains open.
Moreover, a widely open field is to attack weighted versions 
of our problems. 
Finally, we believe that due to the fact that many real-world networks 
are inherently directed 
(e.g., representing relations such as ``follower'', ``likes'', or ``cites'')
further studies (e.g., exploiting special digraph properties) 
of digraph degree sequence completion problems are desirable.

\bibliographystyle{abbrvnat}
\bibliography{bibfile}






\end{document}
