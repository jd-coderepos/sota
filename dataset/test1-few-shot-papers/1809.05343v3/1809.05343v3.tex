\documentclass{article}
\renewcommand{\baselinestretch}{0.97}
\usepackage[utf8]{inputenc} \usepackage[T1]{fontenc}    \usepackage{hyperref}       \usepackage{url}            \usepackage{booktabs}       \usepackage{amsfonts}       \usepackage{nicefrac}       \usepackage{microtype}      \usepackage{times}
\usepackage{graphicx,xspace} \usepackage[dvipsnames]{xcolor}
\usepackage{epstopdf}
\usepackage{subfigure}
\usepackage{amsmath,amssymb,amsthm,array,amsfonts,mathtools}



\usepackage{algorithm}
\usepackage{algorithmic}

\usepackage{booktabs,multirow,rotating}
\usepackage{hyperref}


\usepackage{wrapfig}

\DeclareGraphicsExtensions{.pdf,.jpeg,.png,.jpg}

\makeatletter
\DeclareRobustCommand\onedot{\futurelet\@let@token\@onedot}
\def\@onedot{\ifx\@let@token.\else.\null\fi\xspace}

\def\eg{\emph{e.g}\onedot} \def\Eg{\emph{E.g}\onedot}
\def\ie{\emph{i.e}\onedot} \def\Ie{\emph{I.e}\onedot}
\def\cf{\emph{c.f}\onedot} \def\Cf{\emph{C.f}\onedot}
\def\etc{\emph{etc}\onedot} \def\vs{\emph{vs}\onedot}
\def\wrt{w.r.t\onedot} \def\dof{d.o.f\onedot}
\def\etal{\emph{et al}\onedot}
\makeatother

\def\Vec#1{{\boldsymbol{#1}}}
\def\Mat#1{{\boldsymbol{#1}}}
\def\MH#1{{\color{red}{\bf [Mehrtash:} {\it{#1}}{\bf ]}}}
\def\TODO#1{{\color{red}{\bf [TODO:} {\it{#1}}{\bf ]}}}
\def\NOTE#1{{\bf [NOTE:} {\it\color{blue}{#1}}{\bf ]}.}
\def\CHK#1{{\bf [CHECK:} {\it\color{red} {#1}}{\bf ]}.}
\def\SPD#1{\mathcal{S}_{++}^{#1}}
\def\SYM#1{\mathcal{S}^{#1}}
\def\GRASS#1#2{\mathcal{G}({#1},{#2})}

\def\TZ#1{{\color{red}{\bf [TZ:} {\it{#1}}{\bf ]}}}

\newcommand{\tr}{\mathop{\rm  Tr}\nolimits}
\newcommand{\DIAG}{\mbox{Diag\@\xspace}}



\newtheorem{example}{Example}
\newtheorem{theorem}{Theorem}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{remark}[theorem]{Remark}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{conjecture}[theorem]{Conjecture}
\newtheorem{axiom}[theorem]{Axiom}

\usepackage[final]{nips_2018}


\title{Adaptive Sampling \\ Towards Fast Graph Representation Learning}



\author{
Wenbing Huang, Tong Zhang, Yu Rong, Junzhou Huang \\
 Tencent AI Lab. ;\\
 Australian National University;\\
{\tt\small hwenbing@126.com, tong.zhang@anu.edu.cn,}\\
{\tt\small royrong@tencent.com, jzhuang@uta.edu}\\
}

\begin{document}


\maketitle

\begin{abstract}
Graph Convolutional Networks (GCNs) have become a crucial tool on learning representations of graph vertices. The main challenge of adapting GCNs on large-scale graphs is the scalability issue that it incurs heavy cost both in computation and memory due to the uncontrollable neighborhood expansion across layers. In this paper, we accelerate the training of GCNs through developing an adaptive layer-wise sampling method. By constructing the network layer by layer in a top-down passway, we sample the lower layer conditioned on the top one, where the sampled neighborhoods are shared by different parent nodes and the over expansion is avoided owing to the fixed-size sampling. More importantly, the proposed sampler is adaptive and applicable for explicit variance reduction, which in turn enhances the training of our method. Furthermore, we propose a novel and economical approach to promote the message passing over distant nodes by applying skip connections.
Intensive experiments on several benchmarks verify the effectiveness of our method regarding the classification accuracy while enjoying faster convergence speed.


\end{abstract}

\section{Introduction}
Deep Learning, especially Convolutional Neural Networks (CNNs), has revolutionized various machine learning tasks with grid-like input data, such as image classification~\cite{he2016deep} and machine translation~\cite{vaswani2017attention}. By making use of local connection and weight sharing, CNNs are able to pursue translational invariance of the data. In many other contexts, however, the input data are lying on irregular or non-euclidean domains, such as graphs which encode the pairwise relationships. This includes examples of social networks~\cite{hamilton2017inductive}, protein interfaces~\cite{fout2017}, and 3D meshes~\cite{qi2017pointnet}. How to define convolutional operations on graphs is still an ongoing research topic.

There have been several attempts in the literature to develop neural networks to handle arbitrarily structured graphs.
Whereas learning the graph embedding is already an important topic~\cite{perozzi2014deepwalk,tang2015line,grover2016node2vec}, this paper mainly focus on learning the representations for graph vertices by aggregating their features/attributes.  The closest work to this vein is the Graph Convolution Network (GCN)~\cite{kipf2016semi} that applies connections between vertices as convolution filters to perform neighborhood aggregation. As demonstrated in~\cite{kipf2016semi}, GCNs have achieved the state-of-the-art performance on node classification.


An obvious challenge for applying current graph networks is the scalability. Calculating convolutions requires the recursive expansion of neighborhoods across layers, which however is computationally prohibitive and demands hefty memory footprints.
Even for a single node, it will quickly cover a large portion of the graph due to the neighborhood expansion layer by layer if particularly the graph is dense or powerlaw. Conventional mini-batch training is unable to  speed up the convolution computations, since every batch will involve a large amount of vertices, even the batch size is small.


\begin{figure}[!t]
\begin{center}
\subfigure{
\includegraphics[width=\columnwidth]{model.pdf}
}
\caption{Network construction by different methods: (a) the node-wise sampling approach; (b) the layer-wise sampling method; (c) the model considering the skip-connection. To illustrate the effectiveness of the layer-wise sampling, we assume that the nodes denoted by the red circle in (a) and (b) have at least two parents in the upper layer. In the node-wise sampling, the neighborhoods of each parent are not seen by other parents, hence the connections between the neighborhoods and other parents are unused. In contrast, for the layer-wise strategy, all neighborhoods are shared by nodes in the parent layer, thus all between-layer connections are utilized. }
\label{Fig:sampling}
\end{center}
\end{figure}

To avoid the over-expansion issue, we accelerate the training of GCNs by controlling the size of the sampled neighborhoods in each layer (see Figure~\ref{Fig:sampling}). Our method is to build up the network layer by layer in a top-down way, where the nodes in the lower layer\footnote{Here, lower layers denote the ones closer to the input.} are sampled conditionally based on the upper layer's. Such layer-wise sampling is efficient in two technical aspects. First, we can reuse the information of the sampled neighborhoods since the nodes in the lower layer are visible and shared by their different parents in the upper layer. Second, it is easy to fix the size of each layer to avoid over-expansion of the neighborhoods, as the nodes of the lower layer are sampled as a whole.

The core of our method is to define an appropriate sampler for the layer-wise sampling. A common objective to design the sampler is to minimize the resulting variance. Unfortunately, the optimal sampler to minimize the variance is uncomputable due to the inconsistency between the top-down sampling and the bottom-up propagation in our network (see \textsection~\ref{Sec:sampler} for details). To tackle this issue, we approximate the optimal sampler by replacing the uncomputable part with a self-dependent function, and then adding the variance to the loss function. As a result, the variance is explicitly reduced by training the network parameters and the sampler.

Moreover, we explore how to enable efficient message passing across distant nodes. Current methods~\cite{perozzi2014deepwalk,such2017robust} resort to random walks to generate neighborhoods of various steps, and then take integration of the multi-hop neighborhoods. Instead, this paper proposes a novel mechanism by further adding a skip connection between the -th and -th layers. This short-cut connection reuses the nodes in the -th layer as the 2-hop neighborhoods of the -th layer, thus it naturally maintains the second-order proximity without incurring extra computations.

To sum up, we make the following contributions in this paper: \textbf{I.}We develop a novel layer-wise sampling method to speed up the GCN model, where the between-layer information is shared and the size of the sampling nodes is controllable. \textbf{II.} The sampler for the layer-wise sampling is adaptive and determined by explicit variance reduction in the training phase. \textbf{III.} We propose a simple yet efficient approach to preserve the second-order proximity by formulating a skip connection across two layers.
We evaluate the performance of our method on four popular benchmarks for node classification, including Cora, Citeseer, Pubmed~\cite{sen2008collective} and Reddit~\cite{hamilton2017inductive}. Intensive experiments verify the effectiveness of our method regarding the classification accuracy and convergence speed.

\section{Related Work}

While graph structures are central tools for various learning tasks (\eg semi-supervised learning in~\cite{liu2012robust,kipf2016semi}), how to design efficient graph convolution networks has become a popular research topic.
Graph convolutional approaches are often categorized into spectral and non-spectral classes~\cite{velivckovic2017graph}.  The spectral approach first proposed by~\cite{bruna2013spectral} defines the convolution operation in Fourier domain. Later, \cite{henaff2015deep} enables localized filtering by applying efficient spectral filters, and \cite{defferrard2016convolutional} employs Chebyshev expansion of the graph Laplacian to avoid the eigendecomposition.
Recently, GCN is proposed in~\cite{kipf2016semi} to simplify previous methods with first-order expansion and re-parameterization trick.
Non-spectral approaches define convolution on graph by using the spatial connections directly.
For instance, \cite{duvenaud2015convolutional} learns a weight matrix for each node degree, the work by~\cite{atwood2016diffusion} defines multiple-hop neighborhoods by using the powers series of a transition matrix, and other authors~\cite{niepert2016learning} extracted normalized neighborhoods
that contain a fixed number of nodes.

A recent line of research is to generalize convolutions by making use of the patch operation~\cite{monti2017geometric} and self-attention~\cite{velivckovic2017graph}. As opposed to GCNs, these methods implicitly assign different importance weights to nodes of a same neighborhood, thus enabling a leap in model capacity. Particularly, Monti \etal~\cite{monti2017geometric} presents mixture model CNNs to build CNN architectures on graphs using the patch operation, while the graph attention networks~\cite{velivckovic2017graph} compute the hidden representations of each node on graph by attending over its neighbors following a self-attention strategy.

More recently, two kinds of sampling-based methods including GraphSAGE~\cite{hamilton2017inductive} and FastGCN~\cite{chen2018fastgcn} were developed for fast representation learning on graphs. To be specific, GraphSAGE computes node representations by sampling neighborhoods of each node and then performing a specific aggregator for information fusion. The FastGCN model interprets graph convolutions as integral transforms of embedding functions and samples the nodes in each layer independently.
While our method is closely related to these methods, we develop a different sampling strategy in this paper. Compared to GraphSAGE that is node-wise, our method is based on layer-wise sampling as all neighborhoods are sampled as altogether, and thus can allow neighborhood sharing as illustrated in Figure~\ref{Fig:sampling}. In contrast to FastGCN that constructs each layer independently, our model is capable of capturing the between-layer connections as the lower layer is sampled conditionally on the top one. We detail the comparisons in \textsection~\ref{Sec:comparison}. Another related work is the control-variate-based method by~\cite{jianfei2018stochastic}. However, the sampling process of this method is node-wise, and the historical activations of nodes are required.



\section{Notations and Preliminaries}
\textbf{Notations.} This paper mainly focuses on undirected graphs. Let  denote the undirected graph with nodes , edges , and  defines the number of the nodes. The adjacency matrix  represents the weight associated to edge  by each element . We also have a feature matrix  with  denoting the -dimensional feature for node .



\textbf{GCN.}
The GCN model developed by Kipf and Welling~\cite{kipf2016semi} is one of the most successful convolutional networks for graph representation learning.
If we define  as the hidden feature of the -th layer for node , the feed forward propagation becomes
\vskip -0.25in

\vskip -0.1in
where  is the re-normalization of the adjacency matrix;  is a nonlinear function;  is the filter matrix in the -th layer; and we denote the nodes in the -th layer as  to distinguish them from those in the -th layer.




\section{Adaptive Sampling}

Eq.~\eqref{Eq:gcn} indicates that, GCNs require the full expansion of neighborhoods for the feed forward computation of each node. This makes it computationally intensive and memory-consuming for learning on large-scale graphs containing more than hundreds of thousands of nodes. To circumvent this issue, this paper speeds up the feed forward propagation by adaptive sampling. The proposed sampler is adaptable and applicable for variance reduction.

We first re-formulate the GCN update to the expectation form and introduce the node-wise sampling accordingly. Then, we generalize the node-wise sampling to a more efficient framework that is termed as the layer-wise sampling. To minimize the resulting variance, we further propose to learn the layer-wise sampler by performing variance reduction explicitly. Lastly, we introduce the concept of skip-connection, and apply it to enable the second-order proximity for the feed-forward propagation.

\subsection{From Node-Wise Sampling to Layer-Wise Sampling}



\textbf{Node-Wise Sampling.} We first observe that Eq~\eqref{Eq:gcn} can be rewritten to the expectation form, namely,
\vskip -0.2in

\vskip -0.1in
where we have included the weight matrix  into the function  for concision;  defines the probability of sampling  given , with .

A natural idea to speed up Eq.~\eqref{Eq:GCN-exp} is to approximate the expectation by Monte-Carlo sampling. To be specific, we estimate the expectation  with  given by
\vskip -0.2in

\vskip -0.1in
By setting , the Monte-Carlo estimation can reduce the complexity of ~\eqref{Eq:gcn} from  ( denotes the number of edges)  to  if the numbers of the sampling points for the -th and -th layers are both .


By applying Eq.~\eqref{Eq:GCN-exp-sample} in a multi-layer network, we construct the network structure in a top-down manner: sampling the neighbours of each node in the current layer recursively (see Figure~\ref{Fig:sampling} (a)). However, such \emph{node-wise sampling} is still computationally expensive for deep networks, because the number of the nodes to be sampled grows exponentially with the number of layers. Taking a network with depth  for example, the number of sampling nodes in the input layer will increase to , leading to significant computational burden for large \footnote{One can reduce the complexity of the node-wise sampling by removing the repeated nodes. Even so, for dense graphs, the sampling nodes will still quickly fills up the whole graph as the depth grows. }.





\textbf{Layer-Wise Sampling.} We equivalently transform Eq.~\eqref{Eq:GCN-exp} to the following form by applying importance sampling, \ie,
\vskip -0.3in

\vskip -0.1in
where  is defined as the probability of sampling  given all the nodes of the current layer (\ie, ). Similarly, we can speed up Eq.~\eqref{Eq:GCN-exp-all} by approximating the expectation with the Monte-Carlo mean, namely, computing  with
\vskip -0.3in

\vskip -0.1in

We term the sampling in Eq.~\eqref{Eq:mc} as the \emph{layer-wise sampling} strategy. As opposed to the node-wise method in Eq.~\eqref{Eq:GCN-exp-sample} where the nodes  are generated for each parent  independently, the sampling in Eq.~\eqref{Eq:mc} is required to be performed only once. Besides, in the node-wise sampling, the neighborhoods of each node are not visible to other parents; while for the layer-wise sampling all sampling nodes  are shared by all nodes of the current layer. This sharing property is able to enhance the message passing at utmost. More importantly, the size of each layer is fixed to , and the total number of sampling nodes only grows linearly with the network depth.





\subsection{Explicit Variance Reduction}
\label{Sec:sampler}

The remaining question for the layer-wise sampling is \emph{how to define the exact form of the sampler }. Indeed, a good estimator should reduce the variance caused by the sampling process, since high variance probably impedes efficient training. For simplicity, we concisely denote the distribution  as  below.






According to the derivations of importance sampling in~\cite{mcbook}, we immediately conclude that
\begin{proposition}
\label{Pro:varaince}
The variance of the estimator  in Eq.~\eqref{Eq:mc} is given by
\vskip -0.2in

\vskip -0.1in
The optimal sampler to minimize the variance  in Eq.~\eqref{Eq:var} is given by
\vskip -0.2in

\vskip -0.4in
\end{proposition}


Unfortunately, it is infeasible to compute the optimal sampler in our case. By its definition, the sampler  is computed based on the hidden feature  that is aggregated by its neighborhoods in previous layers. However, under our top-down sampling framework, the neural units of lower layers are unknown unless the network is completely constructed by the sampling.

To alleviate this chicken-and-egg dilemma, we learn a self-dependent function of each node to determine its importance for the sampling. Let  be the self-dependent function computed based on the node feature . Replacing the hidden function in Eq.~\eqref{Eq:opt} with  arrives at
\vskip -0.2in

\vskip -0.1in

The sampler by Eq.~\eqref{Eq:app} is node-wise and varies for different . To make it applicable for the layer-wise sampling, we summarize the computations over all nodes , thus we attain
\vskip -0.2in

\vskip -0.1in
In this paper, we define  as a linear function \ie  parameterized by the matrix .
Computing the sampler in Eq.~\eqref{Eq:all-app} is efficient, since computing   (\ie the adjacent value) and the self-dependent function  is fast.


Note that applying the sampler given by Eq.~\eqref{Eq:all-app} not necessarily results in a minimal variance.
To fulfill variance reduction, we add the variance to the loss function and explicitly minimize the variance by model training.
Suppose we have a mini-batch of data pairs , where  is the target nodes and  is the corresponded ground-true label. By the layer-wise sampling (Eq.~\eqref{Eq:all-app}), the nodes of previous layer are sampled given , and this process is recursively called layer by layer until we reaching the input domain. Then we perform a bottom-up propagation to compute the hidden features and obtain the estimated activation for node , \ie . Certain nonlinear and soft-max functions are further added on  to produce the prediction .
By taking the classification loss and variance (Eq.~\eqref{Eq:var}) into account, we formulate a hybrid loss as
\vskip -0.2in

\vskip -0.1in
where  is the classification loss (\eg, the crossing entropy);
 is the trade-off parameter and fixed as 0.5 in our experiments. Note that the activations for other hidden layers are also stochastic, and the resulting variances should be reduced. In Eq.~\eqref{Eq:hybrid-loss} we only penalize the variance of the top layer for efficient computation and find it sufficient to deliver promising performance in our experiments.

To minimize the hybrid loss in Eq.~\eqref{Eq:hybrid-loss}, it requires to perform gradient calculations.
For the network parameters, \eg  in Eq.~\eqref{Eq:GCN-exp}, the gradient calculation is straightforward and can be easily derived by the automatically-differential platform, \eg, TensorFlow~\cite{abadi2016tensorflow}. For the parameters of the sampler, \eg  in Eq.~\eqref{Eq:all-app}, calculating the gradient is nontrivial as the sampling process (Eq.~\eqref{Eq:mc}) is non-differential.
Fortunately, we prove that the gradient of the classification loss with respect to the sampler is zero. We also derive the gradient of the variance term regarding the sampler, and detail the gradient calculation in the supplementary material























\section{Preserving Second-Order Proximities by Skip Connections}

The GCN update in Eq.~\eqref{Eq:gcn} only aggregates messages passed from 1-hop neighborhoods. To allow the network to better utilize information across distant nodes, we can sample the multi-hop neighborhoods for the GCN update in a similar way as the random walk~\cite{perozzi2014deepwalk,such2017robust}. However, the random walk requires extra sampling to obtain distant nodes which is computationally expensive for dense graphs. In this paper, we propose to propagate the information over distant nodes via skip connections.

The key idea of the skip connection is to reuse the nodes of the -th layer to preserve the second-order proximity (see the definition in~\cite{tang2015line}). For the -th layer, the nodes of the -th layer are actually the 2-hop neighborhoods. If we further add a skip connection from the -th to the -th layer, as illustrated in Figure~\ref{Fig:sampling} (c), the aggregation will involve both the 1-hop and 2-hop neighborhoods. The calculations along the skip connection are formulated as
\vskip -0.2in

\vskip -0.1in
where  denote the nodes in the -th layer. Due to the 2-hop distance between  and , the weight  is supposed to be the element of .
Here, to avoid the full computation of , we estimate the weight with the sampled nodes of the -th layer, \ie,
\vskip -0.2in

\vskip -0.1in
Instead of learning a free  in Eq.~\eqref{Eq:skip}, we decompose it to be
\vskip -0.2in

\vskip -0.1in
where  and  are the filters of the -th and -th layers in original network, respectively. The output of skip-connection will be added to the GCN layer (Eq.\eqref{Eq:gcn}) before nonlinearity.

By the skip connection, the second-order proximity is maintained without extra 2-hop sampling. Besides,
the skip connection allows the information to pass between two distant layers thus enabling more efficient back-propagation and model training.

While the designs are similar, our motivation of applying the skip connection is different to the residual function in ResNets~\cite{he2016deep}.
The purpose of employing the skip connection in~\cite{he2016deep} is to gain accuracy by increasing the network depth. Here, we apply it to preserve the second-order proximity. In contrast to the identity mappings used in ResNets, the calculation along the skip-connection in our model should be derived specifically (see Eq.~\eqref{Eq:skip-A} and Eq.~\eqref{Eq:skip-W}).






\section{Discussions and Extensions}
\label{Sec:comparison}


\textbf{Relation to other sampling methods.}
We contrast our approach with GraphSAGE~\cite{hamilton2017inductive} and FastGCN~\cite{chen2018fastgcn} regarding the following aspects:

1. The proposed layer-wise sampling method is novel. GraphSAGE randomly samples a fixed-size neighborhoods of each node, while FastGCN constructs each layer independently according to an identical distribution. As for our layer-wise approach, the nodes in lower layers are sampled conditioned on the upper ones, which is capable of capturing the between-layer correlations.

2. Our framework is general. Both GraphSAGE and FastGCN can be categorized as the specific variants of our framework.
Specifically, the GraphSAGE model is regarded as a node-wise sampler in Eq~\eqref{Eq:GCN-exp-sample} if  is defined as the uniform distribution; FastGCN can be considered as a special layer-wise method by applying the sampler  that is independent to the nodes  in Eq.~\eqref{Eq:mc}.

3. Our sampler is parameterized and trainable for explicit variance reduction. The sampler of GraphSAGE or FastGCN involves no parameter and is not adaptive for minimizing variance.
In contrast, our sampler modifies the optimal importance sampling distribution with a self-dependent function. The resulting variance is explicitly reduced by fine-tuning the network and sampler.


\textbf{Taking the attention into account.}
The GAT model~\cite{velivckovic2017graph} applies the idea of self-attention to graph representation learning.
Concisely, it replaces the re-normalization of the adjacency matrix in Eq.~\eqref{Eq:gcn} with specific attention values, \ie,

where  measures the attention value between the hidden features  and , which is derived as  by using the LeakyReLU nonlinearity  and SoftMax normalization with parameters  and .

It is impracticable to apply the GAT-like attention mechanism directly in our framework, as the probability  in Eq.~\eqref{Eq:all-app} will become related to the attention value  that is determined by the hidden features of the -th layer. As discussed in \textsection~\ref{Sec:sampler}, computing the hidden features of lower layers is impossible unless the network is already built after sampling. To solve this issue,
we develop a novel attention mechanism by applying the self-dependent function similar to Eq.~\eqref{Eq:all-app}.
The attention is computed as
\vskip -0.3in

\vskip -0.1in
where  and  are the learnable parameters.

\section{Experiments}

We evaluate the performance of our methods on the following benchmarks: (1) categorizing academic papers in the citation network datasets--Cora, Citeseer and Pubmed~\cite{sen2008collective}; (2) predicting which community different posts belong to in Reddit~\cite{hamilton2017inductive}. These graphs are varying in sizes from small to large. Particularly, the number of nodes in Cora and Citeseer are of scale , while Pubmed and Reddit contain more than  and   vertices, respectively.
Following the supervised learning scenario in FastGCN~\cite{chen2018fastgcn}, we use all labels of the training examples for training. More details of the benchmark datasets and more experimental evaluations are presented in the supplementary material.


Our sampling framework is \emph{inductive} in the sense that it clearly separates out test data from training. In contrast to the \emph{transductive} learning where all vertices should be provided, our approach aggregates the information from each node's neighborhoods to learn structural properties that can be generalized to unseen nodes.
For testing, the embedding of a new node may be either computed by using the full GCN architecture or approximated through sampling as is done in model training. Here we use the full architecture as it is more straightforward and easier to implement.
For all datasets, we employ the network with two hidden layers as usual. The hidden dimensions for the citation network datasets (\ie, Cora, Citeseer and Pubmed) are set to be 16. For the Reddit dataset, the hidden dimensions are selected to be 256 as suggested by~\cite{hamilton2017inductive}.
The numbers of the sampling nodes for all layers excluding the top one are set to  for Cora and Citeseer,  for Pubmed and  for Reddit. The sizes of the top layer (\ie the stochastic mini-batch size) are chosen to be 256 for all datasets.
We train all models using early stopping with a window size of 30, as suggested by~~\cite{kipf2016semi}.
Further details on the network architectures and training settings are contained in the supplementary material.


\begin{figure}[!t]
\begin{center}
\subfigure{
\includegraphics[width=4.4cm, height=3.5cm]{cora.pdf}
}
\subfigure{
\includegraphics[width=4.4cm, height=3.5cm]{citeseer.pdf}
}
\subfigure{
\includegraphics[width=4.4cm, height=3.5cm]{reddit.pdf}
}
\caption{The accuracy curves of test data on Cora, Citeseer and Reddit. Here, one training epoch means a complete pass of all training samples.}
\label{Fig:sampling}
\end{center}
\vskip -0.2in
\end{figure}



\subsection{Alation Studies on the Adaptive Sampling}
\textbf{Baselines.}
The codes of GraphSAGE~\cite{hamilton2017inductive} and FastGCNN~\cite{chen2018fastgcn} provided by the authors are implemented inconsistently; here we re-implement them based on our framework to make the comparisons more fair\footnote{We also perform experimental comparisons by using the public codes of FastGCN in the supplementary material.}. In details, we implement the GraphSAGE method by applying the node-wise strategy with a uniform sampler in Eq.~\eqref{Eq:GCN-exp-sample}, where the number of the sampling neighborhoods for each node are set to 5. For FastGCN, we adopt the Independent-Identical-Distribution (IID) sampler proposed by~\cite{chen2018fastgcn} in Eq.~\eqref{Eq:mc}, where the number of the sampling nodes for each layer is the same as our method. For consistence, the re-implementations of GraphSAGE and FastGCN are named as \emph{Node-Wise} and \emph{IID} in our experiments. We also implement the \emph{Full} GCN architecture as a strong baseline. All compared methods shared the same network structure and training settings for fair comparison. We have also conducted the attention mechanism introduced in \textsection~\ref{Sec:comparison} for all methods.


\textbf{Comparisons with other sampling methods.}
The random seeds are fixed and no early stopping is used for the experiments here.
Figure~\ref{Fig:sampling} reports the converging behaviors of all compared methods during training on Cora, Citeseer and Reddit\footnote{The results on Pubmed are provided in the supplementary material.}. It demonstrates that our method, denoted as \emph{Adapt}, converges faster than other sampling counterparts on all three datasets. Interestingly, our method even outperforms the \emph{Full} model on Cora and Reddit. Similar to our method, the \emph{IID} sampling is also layer-wise, but it constructs each layer independently.
Thanks to the conditional sampling, our method achieves more stable convergent curve than the \emph{IID} method as Figure~\ref{Fig:sampling} shown. It turns out that considering the between-layer information helps in stability and accuracy.

Moreover, we draw the training time in Figure~\ref{Fig:time} (a). Clearly, all sampling methods run faster than the \emph{Full} model.
Compared to the \emph{Node-Wise} method, our approach exhibits a higher training speed due to the more compact architecture. To show this, suppose the number of nodes in the top layer is , then for the \emph{Node-Wise} method the input, hidden and top layers are of sizes ,  and , respectively, while the numbers of the nodes in all layers are  for our model. Even with less sampling nodes, our model still surpasses the \emph{Node-Wise} method by the results in Figure~\ref{Fig:sampling}.

\textbf{How important is the variance reduction?}
To justify the importance of the variance reduction, we implement a variant of our model by setting the trade-off parameter as  in Eq.~\eqref{Eq:hybrid-loss}. By this, the parameters of the self-dependent function are randomly initialized and no training is performed. Figure~\ref{Fig:sampling} shows that, removing the variance loss does decrease the accuracies of our method on Cora and Reddit. For Citeseer, the effect of removing the variance reduction is not so significant. We conjecture that the average degree of Citeseer (\ie 1.4) is smaller than Cora (\ie 2.0) and Reddit (\ie 492), and penalizing the variance is not so impeding due to the limited diversity of neighborhoods.

\textbf{Comparisons with other state-of-the-art methods.}
We contrast the performance of our methods with the graph kernel method KLED~\cite{Fouss06anexperimental} and Diffusion Convolutional Network (DCN)~\cite{atwood2016diffusion}. We use the reported results of KLED and DCN on Cora and Pubmed in~\cite{atwood2016diffusion}.  We also summarize the results of GraphSAGE and FastGCN by their original implementations. For GraphSAGE, we report the results by the mean aggregator with the default parameters. For FastGCN, we directly make use of the provided results by~\cite{chen2018fastgcn}. For the baselines and our approach, we run the experiments with random seeds over 20 trials and record the mean accuracies and the standard variances. All results are organized in Table~\ref{Tab:all}. As expected, our method achieves the best performance among all datasets, which are consistent with the results in Figure~\ref{Fig:sampling}. It is also observed that removing the variance reduction will decrease the performance of our method especially on Cora and Reddit.



\begin{table}[t!]
\centering
\caption{Accuracy Comparisons with state-of-the-art methods.}
\label{Tab:all}
\tabcolsep 1.5pt \renewcommand{\arraystretch}{0.8}
\begin{tabular}{ccccc}
\toprule
Methods          & Cora           & Citeseer        & Pubmed           & Reddit         \\
\hline
KLED~\cite{Fouss06anexperimental}          & 0.8229         &  -              & 0.8228           & -              \\
2-hop DCNN~\cite{atwood2016diffusion}      & 0.8677         &  -              & 0.8976           & -              \\
FastGCN~\cite{chen2018fastgcn}      & 0.8500         &  0.7760         & 0.8800         & 0.9370          \\
GraphSAGE\cite{hamilton2017inductive}     & 0.8220         &  0.7140         & 0.8710         & 0.9432          \\
\hline
Full             &  &   &    &    \\
IID              &  &   &    &                \\
Node-Wise        &  &   &     &                \\
\hline
Adapt (no vr)    &         &         &   &  \\
Adapt   &   &   &   & \\
\bottomrule
\end{tabular}
\end{table}


\begin{figure}[!t]
\begin{center}
\subfigure[]{
\includegraphics[width=5.5cm]{time.pdf}
}
\qquad
\subfigure[]{
\includegraphics[width=5.5cm]{sc.pdf}
}
\caption{(a) Training time per epoch on Pubmed and Reddit. (b) Accuracy curves of testing data on Cora for our Adapt method and its variant by adding skip connections.}
\label{Fig:time}
\end{center}
\end{figure}

\subsection{Evaluations of the Skip Connection}



We evaluate the effectiveness of the skip connection on Cora. For the experiments on other datasets, we present the details in the supplementary material. The original network has two hidden layers. We further add a skip connection between the input and top layers, by using the computations in Eq.~\eqref{Eq:skip-A} and Eq.~\eqref{Eq:skip-W}. Figure~\ref{Fig:sampling} displays the convergent curves of the original \emph{Adapt} method and its variant with the skip connection, where the random seeds are shared and no early stopping is adapted. Although the improvement by our skip connection is not big regarding the final accuracy, it indeed speeds up the convergence significantly. This can be observed from Figure 3 (b) where adding the skip connection reduces the required epoches to converge from around 150 to 100.



\begin{table}[t!]
\centering
\caption{Testing Accuracies on Cora.}
\label{Tab:sc}
\begin{tabular}{ccc}
\toprule
Adapt                 & Adapt+sc           &   Adapt+2-hop          \\
\hline
     &   &          \\
\bottomrule
\end{tabular}
\end{table}



We run experiments with different random seeds over 20 trials and report the mean results obtained by early stopping in Table~\ref{Tab:sc}. It is observed that the skip connection slightly improves the performance. Besides, we explicitly involve the 2-hop neighborhood sampling in our method by replacing the re-normalization matrix  with its 2-order power expansion, \ie . As displayed in Table~\ref{Tab:sc}, the explicit 2-hop sampling further boosts the classification accuracy. Although the skip-connection method is slightly inferior to the explicit 2-hop sampling, it avoids the computation of (\ie ) and yields more computationally beneficial for large and dense graphs.




\section{Conclusion}
We present a framework to accelerate the training of GCNs through developing a sampling method by constructing the network layer by layer. The developed layer-wise sampler is adaptive for variance reduction. Our method outperforms the other sampling-based counterparts: GraphSAGE and FastGCN in effectiveness and accuracy on extensive experiments. We also explore how to preserve the second-order proximity by using the skip connection. The experimental evaluations demonstrate that the skip connection further enhances our method in terms of the convergence speed and eventual classification accuracy.









\bibliographystyle{unsrt}
\small
\bibliography{ref}

\section*{Appendix}

This supplementary material provides the gradient calculation of the loss function ( Eq.~(10)) with respect to the sampler. It also contains more setting details and more results for the experiments.


\section{Gradient Calculation}

We prove that the gradient of the expectation  in Eq.~(5) with respect to the sampler  is equal to zero. To demonstrate this, we decompose the gradient as


Hence, the gradient of the classification loss in Eq.~(10) regarding the sampler is equal to zero. To perform the gradient calculation for the variance term, we first estimate it with the sampled instances by

whose gradient is given by

where the samples  generated from  independently.

\section{More Experimental Evaluations}

\textbf{Datasets.} The Cora, Citeseer and Pubmed datasets are downloaded from \url{https://github.com/tkipf/gcn}. We follow the setting as~\cite{chen2018fastgcn} by keeping the validation and test indexes unchanged but using all remaining samples for training. The Reddit dataset is from \url{http:
//snap.stanford.edu/graphsage/}. The statistics of four datasets are summarized in Table~\ref{Tab:dataset}.


\begin{table}[h!]
\centering
\caption{Dataset Statistics.}
\label{Tab:dataset}
\tabcolsep 4pt \begin{tabular}{cccccc}
\toprule
Datasets          & Nodes           & Edges        & Classes           & Features   & Training/Validation/Testing       \\
\hline
Cora    & 2,708        & 5,429           & 7           & 1,433          &1, 208/500/1,000    \\
Citeseer    & 3,327        & 4,732           & 6           & 3,703          &1, 812/500/1,000    \\
Pubmed    & 19,717        & 44,338           & 3           & 500          &18, 217/500/1,000    \\
Reddit    & 232,965        & 11,606,919          & 41           & 602          &152,410/23,699/55,334    \\
\bottomrule
\end{tabular}
\end{table}


\textbf{Further implementation details.} The initial learning rates for the Adam optimizer are set to be 0.001 for Cora, Citeseer and Pubmed, and 0.01 for Reddit. The weight decays for all datasets are selected to be 0.0004. We apply ReLu function as the activation function and  no dropout in our experiments. As presented in the paper, all models are implemented with 2-hidden-layer networks. For the Reddit dataset, we follow the suggestion by~\cite{chen2018fastgcn} to fix the weight of the bottom layer and pre-compute the product  given the input features for  efficiency. All experiments are conducted on a single Tesla P40 GPU. We apply the early-stopping for the training with a window size of 30 and apply the model that achieves the best validation accuracy for testing.


\textbf{More results on the variance reduction.}
As shown in Table 1, it is sufficient to boost the performance by only reducing the variance of the top layer. Indeed, it is convenient to reduce the variances of all layers in our method, e.g., adding them all to the loss. To show this, we conduct an experiment on Cora by minimizing the variances of both the first and top hidden layers, where the experimental settings are the same as Table 1. The result is , which slightly outperforms the original accuracy in Table 1 (i.e. ).

\textbf{Comparisons with FastGCN by using the official codes.}
We use the public code to re-run the experiments of FastGCN in Figure 2 and Table 1. The average accuracies of FastGCN for four datasets are , ,  and . The running curves of Figure 2 in the paper are updated by Figure~\ref{Fig:sampling} here. Clearly, our method still outperforms FastGCN remarkably. We have observed the inconsistences between the official implementations of GraphSAGE and FastGraph including the adjacent matrix construction, hidden dimensions, mini-batch sizes, maximal training epoches and other engineering tricks not mentioned in their papers. For fair comparisons, we re-implements them and uses the same experimental settings as our method in the main text.

\begin{figure}[!h]
\begin{center}
\subfigure{
\includegraphics[width=4.4cm, height=3.5cm]{cora_sup.pdf}
}
\subfigure{
\includegraphics[width=4.4cm, height=3.5cm]{citeseer_sup.pdf}
}
\subfigure{
\includegraphics[width=4.4cm, height=3.5cm]{reddit_sup.pdf}
}
\vskip -0.15in
\caption{The accuracy curves of test data on Cora, Citeseer and Reddit. Here, one training epoch means a complete pass of all training samples. The sampling nodes of each hidden layer for FastGCN and our method on Cora, Citeseer, Pubmed and Reddit are selected as 128, 128, 256, and 512, respectively.}
\label{Fig:sampling}
\end{center}
\vskip -0.2in
\end{figure}


\textbf{More results on Pubmed.}  In the paper, Figure~2 displays the accuracy curves of test data on Cora, Citeseer and Reddit, where the random seeds are fixed. For those on Pubmed, we provide results in Figure~\ref{Fig:sampling}. Obviously, our method outperforms the IID and Node-Wise counterparts consistently. The Full model achieves the best accuracy around the 30-th epoch, but drops down after the 60-th epoch properly due to the overfitting. In contrast, our performance is more stable and it gives even better results in the end. Performing the variance reduction on this dataset is only helpful during the early stage, but contributes little when the model converges.

Table~3 (b) reports the accuracy curve of the model with the skip connection on Cora. Here, we evaluate the effectiveness of the skip connection on Citeseer and Pubmed in Figure~\ref{Fig:sc}.
It demonstrates that the skip connection is helpful to speed up the convergence on Citeseer. While on the Pubmed dataset, adding the skip connection boosts the performance only during early training epochs.
For the Reddit dataset, we can not apply the skip connection in the network since the bottom layer is fixed and the output features are pre-computed.



\begin{figure}[!h]
\begin{center}
\subfigure{
\includegraphics[width=6.5cm, height=4cm]{pubmed.pdf}
}
\caption{The accuracy curves of test data on Pubmed. Here, a training epoch means a complete pass of all training samples.}
\label{Fig:sampling}
\end{center}
\end{figure}


\begin{figure}[!h]
\begin{center}
\subfigure{
\includegraphics[width=6.5cm, height=4cm]{sc-citeseer.pdf}
}
\subfigure{
\includegraphics[width=6.5cm, height=4cm]{sc-pubmed.pdf}
}
\caption{Accuracy curves of testing data on Citeseer and Pubmed for our Adapt method and its variant by adding skip connections.}
\label{Fig:sc}
\end{center}
\end{figure}



\end{document}
