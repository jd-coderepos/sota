\subsection{A Data Structure for Representing Filtering Solutions}

\begin{definition}[LCP Tree]
Given a set of addresses , we define {\em the Longest Common Prefix tree} of , denoted by LCP-tree(),
as the binary tree with the following properties:
(i) each leaf represents a different address in  and there is a leaf for each address in ;
(ii) each intermediate (non-leaf) node represents the longest common prefix between the prefixes represented by its two children.
\end{definition}

The LCP-tree() can be constructed from the complete binary tree (with root  leaves at level 32 corresponding to all addresses , and intermediate nodes at level  corresponding to all prefixes of length ) by removing the branches that do not have addresses in , and then by removing nodes with a single child.
It is a variation of the binary (or unibit) trie~\cite{varghese}, but does not have nodes with a single child.
The LCP-tree() offers an intuitive way to represent sets of prefixes that can block the addresses in set : each node in the LCP tree represents a prefix that can be blocked, hence we can represent a filtering solution as the pruned version of the LCP tree, whose leaves are all and only the blocked prefixes.

\begin{example}
For instance, consider the LCP tree depicted in Figure~\ref{fig:P3-proof}, whose leaves correspond to bad addresses that we want to block. One (expensive) solution is to use one filter to block each bad address; thus the LCP tree is not pruned and its leaves correspond to the filters. Another feasible solution is to use three filters and block traffic from prefixes , , and ; this can be represented
by the pruned version of the LCP tree that includes the
aforementioned prefixes as leaves. Yet another (rather radical) solution is to filter a single prefix () to  block all traffic; this can be represented by the pruned version of the LCP tree that includes only its root.
\end{example}.



\begin{figure}
\centering
\includegraphics[width=3.5in, angle=0]{./figs/b-tree-temp.eps}
\caption{\label{fig:P3-proof} {\small {\bf Example of LCP-tree().}
Consider a blacklist consisting of the following 9 bad addresses:
, . All remaining addresses are considered good.
Each leaf represents one address in the .
Each intermediate node represents the longest common prefix  covering all bad addresses in that subtree.
At each intermediate node , we also show the collateral damage (\ie number of good addresses blocked) when we filter prefix  instead of filtering each of its children.
{\em E.g.,} if we use two filters to block bad addresses 10.0.0.5/32 and 10.0.0.7/32 the collateral damage is 0; if, instead, we use one filter to block prefix 10.0.0.4/30, we also block good address 10.0.0.6/4, \ie we cause collateral damage 1.}}
\end{figure}








\subsubsection*{Complexity}
Given a list of addresses , we can build  the LCP-tree() by performing  insertions in a Patricia trie~\cite{varghese}.
To insert a string of  bits, we need at most  comparisons. Thus, the worst-case complexity is , where  (bits) is the  length of a 32-bit IPv4 address.



\subsection{BLOCK-ALL}
\label{sec:block-all}

\subsubsection*{Problem Statement}
Given: a blacklist , a whitelist , and the number of available filters ;
select filters that block {\em all} bad traffic and minimize collateral damage.

\subsubsection*{Formulation}
We formulate this problem by making two adjustments to the general framework of Eq. (\ref{P-GENERAL})--(\ref{P-domain}).
First, Eq.~(\ref{P-GENERAL}) becomes Eq.~(\ref{P1-OF}) below, which expresses the goal to minimize the collateral damage. Second, Eq.~(\ref{P-coverage}) becomes Eq. (\ref{P1-coverage}) below,
which enforces the constraint that every bad address should be blocked by exactly one filter,
as opposed to at most one filter in Eq.(\ref{P-coverage}).



















\subsubsection*{Characterizing an Optimal Solution}
Our algorithm starts from LCP-tree() and outputs a pruned version of that LCP tree.
Hence, we start by proving that an optimal solution to BLOCK-ALL can indeed be represented as a pruned version of that LCP tree.

\begin{proposition}\label{prop:all}
An optimal solution to BLOCK-ALL can be represented as a pruned
subtree of LCP-tree() with the same root as LCP-tree(), up to  leaves,
and each non-leaf node having exactly two children.
\end{proposition}

\begin{proof}
We prove that, for each feasible solution to BLOCK-ALL , there exists another feasible solution 
that (i) can be represented as a pruned subtree of LCP-tree() as described
in the proposition and (ii) whose collateral damage is smaller or equal to 's.
This is sufficient to prove the proposition, since an optimal solution is also a feasible one.

Any filtering solution can be represented as a pruned subtree of
the full binary tree of all IP addresses (LCP-tree)
with the same root and leaves corresponding to the filtered prefixes.
 is a feasible solution to BLOCK-ALL, therefore 
 uses up to  filters, \ie its tree has up to  leaves. Indeed, if this was not the case,
Eq.~(\ref{P1-cardinality}) would be violated and  would not be a feasible solution.

Let us assume that the tree  representing  includes a prefix  that is {\em not} in LCP-tree(). There are three possible cases:
\begin{enumerate}
\item  includes no bad addresses.
In this case, we can simply remove  from 's tree (\ie, unblock ).
\item Only one of 's children includes bad addresses.
In this case, we can replace  with the child node.
\item Both of 's children contain bad addresses. In this case,  is already the longest common prefix of all bad addresses in , thus already on the LCP-tree().
\end{enumerate}
Clearly, each of these operations transforms feasible solution , which is assumed not to be on LCP-tree(), into another feasible solution  with smaller or equal collateral damage but on the LCP-Tree(). We can repeat this process for all prefixes that are in 's tree but not in LCP-tree(), until we create a feasible solution  that includes only prefixes from LCP-tree() and has smaller or equal collateral damage.


The only element missing to prove the proposition is to show that, in the pruned LCP subtree that represents ,
each non-leaf node has exactly two children.
We show this by contradiction:
Suppose there exists a non-leaf node in our pruned LCP subtree that has exactly one child.
This can only result from pruning out one child of a node in the LCP tree.
This means that all the bad addresses (leaves) in the subtree of this child node remain unfiltered, which violates Eq.~(\ref{P1-coverage}); but this is a contradiction because   is a feasible solution.
\end{proof}







\subsubsection*{Algorithm} Algorithm \ref{Alg:P1}, which solves BLOCK-ALL, consists of two steps. First, we build the LCP tree from the input
blacklist . Second, in a bottom-up fashion, we compute , \ie, the minimum collateral damage needed to block all
bad addresses in the subtree of prefix  using at most  filters.
Following a dynamic programming (DP) approach,  we can find the optimal allocation of filters in the subtree rooted at prefix ,
by finding a value  and assigning  filters to the left subtree and  to the right subtree, so as to minimize collateral damage.
The fact that BLOCK-ALL needs to filter all bad addresses (leaves in the LCP tree) implies that at least one filter must be assigned to the left
and right subtree, \ie .
In other words, for every pair of sibling nodes,  (left) and  (right), with common parent node ,  the following recursive equation holds:

with boundary conditions for leaf and intermediate nodes:

Once we compute  for all prefixes in the LCP tree, we simply read the value of the optimal solution, .
We also use auxiliary variables  to keep track of the set of prefixes used in the optimal solution.
In lines 4 and 10 of Algorithm 1,   is initialized to the single prefix used.
In line 12, after computing the new cost, the corresponding set of prefixes is updated: .


\begin{algorithm}[t!]
 \caption{\label{Alg:P1} Algorithm forsolving  BLOCK-ALL}
\begin{algorithmic}[1]
\begin{footnotesize}
\STATE build LCP-tree()
\FOR{ all leaf nodes }
	\STATE{  }
	\STATE{ }
\ENDFOR
\STATE level = level(leaf)-1
\WHILE{} \label{line:while}
    \FOR{all node   such that  }
	\STATE 
	\STATE 
	\STATE 
   	\STATE 
    \ENDFOR
    \STATE level = level - 1
\ENDWHILE
\RETURN , 
\end{footnotesize}
\end{algorithmic}
\end{algorithm}


\begin{theorem}
Algorithm~1 computes the optimal solution of problem BLOCK-ALL: the prefixes that are contained in set  are the optimal
 for Eq. (\ref{P1-OF})--(\ref{P1-coverage}).
\end{theorem}
\begin{proof}
Recall that,  denotes the value of the optimal solution of BLOCK-ALL with  filters
(\ie, the minimum collateral damage), while  denotes the  set of filters selected in the optimal solution.
Let  and  denote the two children nodes (prefixes) of  in the LCP-tree().
Finding the optimal allocation of  filters to block all addresses contained in  (possibly all IP space),
is equivalent to finding the optimal allocation of  filters to block all addresses in ,
and  prefixes for bad addresses in , such that .
This is because prefixes , and  jointly contain {\em all} bad addresses.
Moreover, each of  and  contains at least one bad address. Thus, at least one filter must be assigned to each of them.
If , \ie, there is only one filter available, the only feasible solution is to select  as the prefix to filter out.
The same argument recursively applies to descendant nodes, until either we reach a leaf node, or we have only one filter available.
In these cases, the problem is trivially solved by Eq. (\ref{conds:block-all}).
\end{proof}



\subsubsection*{Complexity} The LCP-tree is a binary tree with  leaves; therefore, it has  intermediate nodes (prefixes). Computing Eq. (\ref{eq:block-all}) for every node  and for every value  involves solving  sub-problems,
one for every pair (, ) with complexity .
 in Eq. (\ref{eq:block-all}) requires only the optimal solution at the
sibling nodes, . Thus, proceeding from the leaves to the root, we can compute the optimal solution in
. In practice, the complexity is even lower, since we do not need to compute  for all values
, but only for , where  is the number of the leaves in prefix  in the LCP tree.
Moreover, we only need to compute entries  for every prefix , s.t. we cover all addresses in , which may require  for long prefixes in the LCP-tree.




Finally, we observe that the asymptotic complexity is ,
since   and  does not depend on  but only on the TCAM size.
Thus, the time complexity increases linearly with the number of bad addresses .
This is within a constant factor of the lowest achievable complexity, since we need to read all  bad addresses at least once.



\subsection{\label{sec:block-some}BLOCK-SOME}


\subsubsection*{Problem Statement}
Given a blacklist , a whitelist , and the number of available filters ,
the goal is to select filters so as to minimize the total cost of the attack.

\subsubsection*{Formulation}
This is precisely the problem described by Eq. (\ref{P-GENERAL})--(\ref{P-domain}),
but put slightly rephrased to better compare it with BLOCK-ALL.
There are two differences from BLOCK-ALL. First, the goal is to minimize the total cost of the attack, which involves
both collateral damage  and the filtering benefit , which is expressed by Eq. (\ref{P2-OF}).
Second, Eq. (\ref{P2-coverage}) states that every bad address must be filtered by {\em at most} one prefix, which means that it may or may not be filtered.





\subsubsection*{Characterizing an Optimal Solution}
As with BLOCK-ALL, our algorithm starts from LCP-tree() and outputs a pruned version of that LCP tree.
The only difference is that some bad addresses may now remain unfiltered.
In the pruned LCP subtree that represents our solution, this means that
there may exist intermediate (non-leaf) nodes with a single child.

\begin{proposition}\label{prop:some}
An optimal solution to BLOCK-SOME can be represented as a pruned subtree of
LCP-tree() with: the same root as LCP-tree() and up to  leaves.
\end{proposition}

\begin{proof}  
In Proposition~\ref{prop:all}, we proved that any solution of Eq. (\ref{P1-OF})--(\ref{P1-cardinality}) can be reduced to a (pruned)
subtree of the LCP tree with at most  leaves. Moreover, the constraint expressed by Eq.~(\ref{P2-coverage}), 
which imposes the use of non-overlapping prefixes, is automatically imposed considering the {\em leaves} of the pruned subtree as the selected filter. 
This proves that any feasible solution of BLOCK-SOME can be represented as a pruned subtree of the LCP tree with at most  leaves. 
And thus, so can an optimal solution.
\end{proof}













\subsubsection*{Algorithm} The algorithm that solves BLOCK-SOME is similar to Algorithm \ref{Alg:P1} in that it
relies on the LCP tree and a dynamic programming (DP) approach. The main difference is that not all bad addresses need to be filtered, hence, at each step,
we can assign  filters to the left and/or right subtree.
More specifically, whereas in line (11) of Algorithm~\ref{Alg:P1} we had , now we have .
We can recursively compute the optimal solution as before:

with boundary  conditions

where   is an intermediate node (prefix) and  is a leaf node in the LCP-tree.

\subsubsection*{Complexity} The analysis of Algorithm~\ref{Alg:P1} applies to this algorithm as well.
The complexity is the same, \ie, linearly increasing with .

\subsubsection*{BLOCK-ALL vs. BLOCK-SOME}
There is an interesting connection between the two problems.
The latter can be regarded as an automatic way to select the best subset from 
and run BLOCK-ALL only on that subset.
If the absolute value of weights of bad addresses are significantly larger than the weights of the good addresses,
then BLOCK-SOME degenerates to BLOCK-ALL.


