\documentclass{LMCS}

\def\dOi{9(3:21)2013}
\lmcsheading {\dOi}
{1--17}
{}
{}
{Oct.~20, 2012}
{Sep.~17, 2013}
{}

\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{pgf}
\usepackage{pgfarrows}
\usepackage{pgfnodes}
\usepackage{tikz}

\usepackage{proof}
\usepackage{verbatim}
\usepackage{float}
\usepackage{macros}


\usepackage{enumerate,hyperref}

\begin{document}

\title[Reachability under Contextual Locking]{Reachability under Contextual Locking\rsuper*}

\author[R.~Bonnet]{R\'emi Bonnet\rsuper a}
\address{{\lsuper a}LSV, ENS Cachan \& CNRS, France}
\email{remi.bonnet@cs.ox.ac.uk}

\author[R.~Chadha]{Rohit Chadha\rsuper b}
\address{{\lsuper{b,c,d}}University of Missouri, U.S.A.}
\email{chadhar@missouri.edu, madhu@illiniois.edu, vmahesh@illinois.edu}

\author[P.~Madhusudan]{P.~Madhusudan\rsuper c}
\address{\vspace{-6 pt}}

\author[M.~Viswanathan]{Mahesh Viswanathan\rsuper d}
\address{\vspace{-6 pt}}

\ACMCCS{[{\bf Theory of computation}]: Semantics and
  reasoning---Program reasoning---Program verification; [{\bf Software
      and its engineering}]: Software organization and
  properties---Software functional properties---Formal
  methods---Software verification}

\subjclass{F.3.1, D.2.4}
\keywords{Static analysis, Pushdown reachability, Locks, Reentrant locks} 
\titlecomment{{\lsuper*}An extended abstract of the paper appeared in
\cite{rch:pm:mv:12}.}

\maketitle

\begin{abstract}
The pairwise reachability problem for a multi-threaded program asks,
given control locations in two threads, whether they can be simultaneously reached in
an execution of the program. The problem is important for static
analysis and is used to detect statements that are concurrently enabled. This
problem is in general undecidable even when data is abstracted and
when the threads (with recursion) synchronize only using a finite set of locks. 
Popular programming paradigms that limit the lock usage patterns have been identified
under which the pairwise reachability problem becomes decidable. In
this paper, we consider a new natural programming paradigm, called contextual locking,
which ties the lock usage to calling patterns in each thread: we assume that locks are released in the same context that they were acquired and that every lock acquired by a thread in
a procedure call is released before the procedure returns. Our
main result is that the pairwise reachability problem is polynomial-time 
decidable for this new programming paradigm as well. The problem becomes undecidable if the locks are
reentrant; reentrant locking is a \emph{recursive locking} mechanism which allows a thread in a multi-threaded program 
to acquire the reentrant lock multiple times.  \end{abstract}
 \section{Introduction}
In static analysis of sequential programs~\cite{muchnick}, such as
control-flow analysis, data-flow analysis, points-to analysis, etc., 
the semantics of the program and the data that it manipulates is \emph{abstracted}, and the
analysis concentrates on computing fixed-points over a lattice using
the control-flow in the program. For instance, in flow-sensitive
context-sensitive points-to analysis, a finite partition of the heap
locations is identified, and the analysis keeps track of the set of
possibilities of which variables point may point to each heap-location
partition, propagating this information using the control-flow graph
of the program. In fact, several static analysis questions can be
formulated as reachability in a pushdown system that captures the
control-flow of the program (where the stack is required to model
recursion)~\cite{HorowitzRepsSagiv}.

In concurrent programs, abstracting control-flow is less obvious, due to the
various synchronization mechanisms used by threads to communicate and orchestrate
their computations.
One of the most basic questions is \emph{pairwise reachability}: given
two control locations  and  in two threads of a concurrent
program, are these two locations simultaneously reachable? This
problem is very basic to static analysis, as many analysis techniques
would, when processing , take into account the \emph{interference} of
concurrent statements, and hence would like to know if a location like
 is concurrently reachable. Data-races can also be formulated
using pairwise reachability, as it amounts to asking whether a
read/write to a location (or an abstract heap region) is concurrently
reachable with a write to the same location (or region). More
sophisticated verification techniques like deductive verification can
also utilize such an analysis. For instance, in an Owicki-Gries style
proof~\cite{og76} of a concurrent program, the invariant at 
must be proved to be stable with respect to concurrent moves by the
environment, and hence knowing whether  is concurrently
reachable will help determine whether the statement at  need be
considered for stability.

Pairwise reachability of control locations is hence an important
problem. Given that individual threads may employ recursion, this
problem can be \emph{modeled} as reachability of \emph{multiple}
pushdown systems that synchronize using the synchronization constructs
in the concurrent program, such as locks, barriers, etc. However, it
turns out that even when synchronization is limited to using just
locks, pairwise reachability is
\emph{undecidable}~\cite{ram00}.   Consequently, recently, many natural
restrictions have been identified under which pairwise reachability is
decidable.

One restriction that yields a decidable pairwise reachability problem
is \emph{nested locking}~\cite{kig05,kg06}: if each thread performs
only nested locking (i.e. locks are released strictly in the reverse order
in which they are acquired), then pairwise reachability is known to be
decidable~\cite{kig05}.  The motivation for nested locking is that many
high-level locking constructs in programming languages naturally
impose nested locking. For instance the {\tt synchronize(o) \{\ldots
  \}} statement in Java acquires the lock associated with , executes the
body, and releases the lock, and hence nested synchronized blocks
naturally model nested locking behaviors. The usefulness of the pairwise 
reachability problem was demonstrated in~\cite{kig05} where the above  decision procedure for
nested locking was used to find bugs in the Daisy file system.
 Nested locking has been
generalized to the paradigm of \emph{bounded lock chaining} for which
pairwise reachability has also been proved to be
decidable~\cite{kah09,kah11}. 


In this paper, we study a different restriction on locking, called
\emph{contextual locking}. A program satisfies contextual locking if
each thread, in every context, acquires new locks and releases all
these locks before returning from the context. Within the context,
there is \emph{no requirement} of how locks are acquired and released;
in particular, the program can acquire and release locks in a
non-nested fashion or have unbounded lock chains.

The motivation for contextual locking comes from the fact that this is
a very natural restriction. First, note that it's very natural for
programmers to release locks in the same context they were acquired;
this makes the acquire and release occur in the same syntactic code block,
which is a very simple way of managing lock acquisitions.

Secondly, contextual locking is very much encouraged by higher-level
locking constructs in programming languages.  For example, consider
the code fragment of a method, in Java~\cite{lea} shown in Figure
\ref{fig:javaexxample}.
\begin{figure}
\begin{verbatim}
   public void m() {
     synchronized(done) {
       ...
       synchronized(r) {
         ...
         while (done=0)
         try {
            done.wait();
         }
     ...
   }
\end{verbatim}
\caption{Synchronized blocks in Java}
\label{fig:javaexxample}
\end{figure}
The above code takes the lock associated with  followed
later by a lock associated with object .  In order to proceed, it
wants  to be equal to  (a signal from a concurrent thread,
say, that it has finished some activity), and hence the thread waits
on , which releases the lock for ,
allowing other threads to proceed. When some other thread issues a
\emph{notify}, this thread wakes up, reacquires the lock for ,
and proceeds.

Notice that despite having synchronized blocks, the {\texttt wait()}
statement causes releases of locks in a non-nested fashion (as it
exhibits the sequence \emph{acq lock\_done; acq lock\_r; rel
  lock\_done; acq lock\_done; rel lock\_r; rel lock\_done}).
However, note that the code above does satisfy \emph{contextual
  locking}; the lock  acquires are all released before the exit,
because of the synchronized-statements. Thus, we believe that
contextual locking is a natural restriction that is adhered to
in many programs.

The first result of this paper is that pairwise reachability is
decidable under the restriction of contextual locking. It is worth
pointing out that this result does not follow from the decidability
results for nested locking or bounded lock
chains~\cite{kig05,kah09}. Unlike nested locking and bounded lock
chains, contextual locking imposes no restrictions on the locking
patterns in the absence of recursive function calls; thus, programs
with contextual locking may not adhere to the nested locking or
bounded lock chains restrictions.  Second, the decidability of nested
locking and bounded lock chains relies on a non-trivial observation
that the number of context switches needed to reach a pair of states
is bounded by a value that is \emph{independent} of the size of the
programs.\footnote{This observation is implicit in the proofs of decidability in~ \cite{kig05,kah09}.} However, such a result of a bounded number of context
switches does not seem to hold for programs with contextual locking. Thus, the
proof techniques used to establish decidability are different as well.

We give a brief outline of the proof ideas
behind our decidability result. We observe that if a pair of states is
simultaneously reachable by some execution, then they are also
simultaneously reachable by what we call a \emph{well-bracketed
  computation}. A concurrent computation of two threads is not well-bracketed, if in the computation one process, say , makes a
call which is followed by the other process () making a call,
but then  returns from its call before  does (but after
 makes the call). We then observe that every well-bracketed
computation of a pair of recursive programs can simulated by a single
recursive program. Thus, decidability in polynomial time follows from
observations about reachability in pushdown systems~\cite{bem97}.


The second result of the paper concerns  \emph{reentrant  locks}. The standard mutex locks are blocking, \emph{i.e.}, if a
lock is held by some thread, then any attempt to acquire it by any thread (including the \emph{owning} thread) fails and the requesting thread blocks. 
Some programming languages such as Java support  (non-blocking)  \emph{reentrant  locks}.
Reentrant locks are recursive locks;  if a thread attempts to acquire a reentrant lock it already holds 
then the thread succeeds.  The lock becomes free only when the owning thread releases the lock as many times as
it acquires the lock. 


We  consider the case of multi-threaded programs synchronizing through \emph{reentrant} locks and show
 that the pairwise reachability problem is undecidable for contextual reentrant locking (even for non-recursive programs). 
The undecidability result is obtained by a reduction from the emptiness problem of a -counter machine. 
As the locking mechanism is reentrant,  a counter can be simulated by a lock. Counter increment and counter decrement can be
simulated by lock acquisition and lock release respectively. The ``zero-test'' in the reduction is simulated by 
synchronization between the  threads.

The rest of the paper is organized as follows. Section~\ref{sec:model}
introduces the model of concurrent pushdown systems communicating
via locks and presents its semantics. Our main decidability result
is presented in Section~\ref{sec:main}. The undecidability result for contextual reentrant locking is presented in Section~\ref{sec:reentrant}. Conclusions are presented in
Section~\ref{sec:conclusions}.


{\bf Note:} An extended abstract of the paper  co-authored by Rohit Chadha, P. Madhusudan and Mahesh Viswanathan appeared in
\cite{rch:pm:mv:12} and contains the decidability
 result for pairwise reachability under contextual (non-reentrant) locking.
The undecidability result for contextual reentrant locking was obtained subsequently by R\'emi Bonnet and Rohit Chadha,
and has not been presented elsewhere. 





\begin{comment}
\section{Motivation of Reachability of Contextual Locking}
In static analysis of sequential programs, such as dataflow analysis, points-to analysis, etc., the semantics of
the program and the data that it manipulates is \emph{abstracted}, and the analysis concentrates on computing
fixed-points over a lattice using the control-flow in the program. For instance, in flow-sensitive context-sensitive
points-to analysis, a finite partition of the heap locations is identified, and the analysis keeps track of the
set of possibilities of which variables point may point to each heap-location partition, propagating this
information using the control-flow graph of the program. In fact, several static analysis questions can be formulated
as reachability in a pushdown system that captures the control-flow of the program (where the stack is required to model
recursion)~\cite{HorowitzRepsSagiv}.

In concurrent programs, the control-flow is less obvious, due to several mechanisms using which threads synchronize.
One of the most basic questions is \emph{pairwise reachability}: given two control locations  and  in two threads of
a concurrent program, are these two locations simultaneously reachable. This problem is very basic to static analysis,
as many analysis techniques would, when processing , take into account the interference of concurrent statements,
and hence would like to know if a location like  is concurrently reachable. Data-races can also be formulated using
pairwise reachability, as it amounts to asking whether a read/write to a location (or an abstract heap region) is concurrently
reachable with a write to the same location (or region). More sophisticated verification techniques like deductive verification
can also utilize such an analysis: for instance, in an Owicki-Gries style proof of a concurrent program, the invariant at 
must be proved to be stable with respect to concurrent moves by the environment, and hence knowing whether  is concurrently
reachable will help determine whether the statement at  need be considered for stability.

Pairwise reachability of control locations is hence an important problem. Given that individual threads may have recursion, this problem can be \emph{modeled} as reachability of \emph{multiple} pushdown systems that synchronize using the synchronization constructs in a concurrent program, such as locks, barriers, etc. However, it turns out that even with synchronization with locks,
pairwise reachability  is \emph{undecidable}~\cite{kig05}. Consequently, there have been many recent approaches that have identified
natural restrictions under which pairwise reachability is decidable.

One restriction that yields a decidable pairwise reachability problem is \emph{nested locking}:
if each thread performs only nested locking (i.e. locks are released in the same order they are acquired), then pairwise reachability is known to be decidable~\cite{kig05}. The motivation for nested locking is that many high-level locking constructs
in programming languages naturally impose nested locking. For instance the {\tt synchronize(o) \{ \ldots \}} statement
acquires the lock associated with , executes the body, and releases the lock, and hence nested synchronized blocks
naturally model nested locking behaviors.

\subsubsection*{Motivating contextual locking:}~\\
In this paper, we study a different restriction on locking, called \emph{contextual locking}, which also gives a decidable
pairwise reachability problem. A program satisfies contextual locking if each thread, in every context, acquires new locks and
releases all these locks before returning from the context. Within the context, there is \emph{no requirement} of how locks
are acquired and released; in particular, the program can acquire and release locks in a non-nested fashion.

The motivation for contextual locking comes from the fact that this is a very natural restriction. First, note that
it's very natural for programmers to release locks in the same context they were acquired; this makes the acquire and
release in the same syntactic code block, which is a very simple way of tracking lock acquisitions.

Secondly, contextual locking is very much encouraged by higher-level locking constructs in programming languages.
For example, consider the following code fragment of a method, in Java:
\begin{verbatim}
   public void m() {
     synchronized(done) {
       ...
       synchronized(r) {
         while (done=0)
         try {
            done.wait();
         }
     ...
   }
\end{verbatim}

The above code takes the lock associated with  followed later by a lock associated with object .
In order to proceed, it wants  to be equal to  (a signal from a concurrent thread, say, that it has finished
some activity), and hence the thread waits on , that releases the lock for ,
letting the other threads proceed.

Notice that despite having synchronized blocks, the {\texttt wait()} statement forces releases of locks in a non-nested
fashion (as it exhibits the sequence \emph{acq lock\_done; acq lock\_r; rel lock\_done; acq lock\_done; rel lock\_r; rel lock\_done;}).
However, note that the code above does satisfy \emph{contextual locking}; the locks  acquires are all released before the
exit, because of the synchronized-statements.

We believe that contextual locking is hence a natural restriction that is adhered to in many programs, and hence
establishing pairwise reachability to be decidable for such programs is interesting.
\end{comment}
\section{Model}
\label{sec:model}
The set of natural numbers shall be denoted by  The set of functions from a set  to  shall be denoted by  Given a function , the function  shall be the unique function  defined as follows:
 and for all ,  If  then  for each  



\subsection{Pushdown Systems.} For static analysis,  recursive programs are usually modeled as pushdown systems.
Since we are interested in modeling threads in concurrent programs we will also need to model locks for communication between threads.
Formally,

\begin{definition}
Given a finite set , a pushdown system (PDS)  using 
is a tuple  where

\begin{iteMize}{}
\item  is a  finite set of control states.
\item  is a finite stack alphabet.
\item  is the initial state.
\item  is a finite set of
   transitions where
   \begin{iteMize}{}
   \item .
   \item .
   \item .
   \item .
   \item .

   \end{iteMize}
 \end{iteMize}
 \end{definition}
For a PDS , the semantics is defined as a transition system.
The configuration of a PDS  is the product of the set of control states  and the stack which is modeled
as a word over the stack alphabet   For a thread  using  we have to keep track of the locks being held by 
 Thus
  the set of configurations  of   using  is  
 where   is the powerset of 

 Furthermore, the transition relation is no longer just
 a relation between configurations but  a binary relation on  since
 the thread now {\it executes} in an {\it environment}, namely, the free locks (i.e., locks not being held by any other thread).
 Formally,



 \begin{definition}
 A PDS  using  gives  a labeled
 transition relation  where  and
  is defined as follows.
 \begin{iteMize}{}
 \item  if 
 \item  if 
 \item  if 
 \item  if  and .
 \item  if   and
 .
 \end{iteMize}
 \end{definition}












\subsection{Multi-pushdown systems} Concurrent programs are modeled as multi-pushdown systems.
For our paper, we assume that  threads in a concurrent program communicate only through locks which leads
us to the following definition.
\begin{definition}
Given a finite set , a -pushdown system (-PDS)  communicating via 
is a tuple  where each  is a PDS using 
\end{definition}

Given a -PDS ,
we will assume that the set of control states and the stack symbols of the threads are mutually disjoint.
\begin{definition}
The semantics of a -PDS  communicating via  is given as a labeled transition system  where
\begin{iteMize}{}
\item  is said to be the set of configurations of  and  is the set  where  is the set of states of  and  is the stack alphabet of 
\item  is the initial configuration and is  where  is the initial state of 

\item The set of labels on the transitions  is  where 
The labeled transition relation  is defined as follows
  iff
      
      and for all ,
        and .
\end{iteMize}
\end{definition}

\begin{notation}

Given a configuration  of a -PDS ,
we say that 
and , the length of 
\end{notation}

\subsection{Computations.}
 A {\it computation} of  the -PDS , , is a sequence 
 such that  is the initial configuration of
 The {\it label of the computation} {\Comp}, denoted {}, is said to be the word 
The
transition  is said to be a {\it procedure call by thread }. Similarly, we can define {\it procedure return}, {\it internal action},
{\it acquisition of lock } and {\it release of lock } by thread 
A procedure return    is said to
{\it match} a procedure call  iff 
 and for all 










\begin{example}
\label{exam:example1} Consider the two-threaded program showed in
Figure \ref{fig:example1}. For sake of convenience, we only show the relevant actions of the programs.
Figure \ref{fig:compexam} shows  computations whose labels are as follows:


and

respectively.
\begin{figure}[ht]
\begin{minipage}[b]{0.5\textwidth}
\begin{verbatim}
   int a(){
      acq l1; 
      acq l2;
      if (..) then{
         ....
         rel l2;
         ....
         rel l1;
          };
      else{
          .....
          rel l1
          .....
          rel l2
          };
         return i;
   };

   public void P0() {
     n=a();
   }
   \end{verbatim}

\end{minipage}\begin{minipage}[b]{0.5\textwidth}
\begin{verbatim}
  int b(){
      acq l1;
      rel l1;
      return j;
   };

   public void P1() {
     m=b();
   }
   \end{verbatim}

\end{minipage}

\caption{A -threaded program with threads P0 and P1}
\label{fig:example1}
\end{figure}

\begin{figure}
\begin{center}
\begin{tikzpicture}
\foreach \name/\x in {0/0, 1/1.2, 2/2.4, 3/3.6, 4/4.8, 5/6, 
                      6/7.2, 7/8.4, 8/9.6, 9/10.8, 10/12}
   \node(s\name) at (\x,3) {};
\foreach \name/\x in {0/0, 1/1.2, 2/2.4, 3/3.6, 4/4.8, 5/6, 
                      6/7.2, 7/8.4, 8/9.6, 9/10.8, 10/12}
   \node(t\name) at (\x,0) {};
\node at (6,2.5) {};
\node at (6,-0.5) {};
\scriptsize
\draw[->] (s0) -- node[above](p0){} (s1);
\draw[->] (s1) -- node[above]{} (s2);
\draw[->,dashed] (s2) -- node[above](p1){} (s3);
\draw[->] (s3) -- node[above]{} (s4);
\draw[->] (s4) -- node[above]{} (s5);
\draw[->,dashed] (s5) -- node[above]{} (s6);
\draw[->] (s6) -- node[above]{} (s7);
\draw[->] (s7) -- node[above](r0){} (s8);
\draw[->,dashed] (s8) -- node[above]{} (s9);
\draw[->,dashed] (s9) -- node[above](r1){} (s10);
\draw[dotted] (p0) .. controls (1.6,4.5) and (8,4.5) .. (r0);
\draw[dotted] (p1) .. controls (4,4.5) and (10.4,4.5) .. (r1);

\draw[->] (t0) -- node[above](p2){} (t1);
\draw[->] (t1) -- node[above]{} (t2);
\draw[->,dashed] (t2) -- node[above](p3){} (t3);
\draw[->] (t3) -- node[above]{} (t4);
\draw[->] (t4) -- node[above]{} (t5);
\draw[->,dashed] (t5) -- node[above]{} (t6);
\draw[->,dashed] (t6) -- node[above]{} (t7);
\draw[->,dashed] (t7) -- node[above](r3){} (t8);
\draw[->] (t8) -- node[above]{} (t9);
\draw[->] (t9) -- node[above](r2){} (t10);
\draw[dotted] (p2) .. controls (1.6,1.5) and (10.4,1.5) .. (r2);
\draw[dotted] (p3) .. controls (3.8,1) and (8.2,1) .. (r3); \end{tikzpicture}
\end{center}
\caption{Computations  and . Transitions of  are
  shown as solid edges while transition of  are shown as dashed
  edges; hence the process ids are dropped from the label of
  transitions. Matching calls and returns are shown with dotted
  edges.}
\label{fig:compexam}
\end{figure}


\end{example}


\subsection{Contextual locking}
In this paper, we are considering the pairwise reachability problem when the threads follow  {\it contextual locking}. Informally, this means that--
\begin{iteMize}{}
\item every lock acquired by a thread in a
procedure call must be released before the corresponding return is executed, and
\item the locks held by a thread just before a procedure call is executed are not released during the
execution of the procedure.

\end{iteMize}
Formally,
 \begin{definition}
A thread  in a -PDS  is said to follow contextual locking if whenever 
and  are matching procedure call and return  along a computation

we have that


 \end{definition}

\begin{example}
\label{exam:example2}
Consider the -threaded program shown in Figure \ref{fig:example1}. Both the threads P0 and
P1 follow contextual locking. The program P2 in Figure \ref{fig:example2} does not follow contextual locking.
\begin{figure}[ht]
\begin{verbatim}

   int a(){
      acq l1;
      rel l2;
      return i;
   };
   public void P2(){
   acq l2;
   n=a();
   rel l1;
   }
\end{verbatim}

\caption{A program that does not follow contextual locking.}
\label{fig:example2}
\end{figure}

\end{example}
\begin{example}
\label{exam:example3}
Consider the -threaded program in Figure \ref{fig:example3}. The
two threads P3 and P4 follow contextual locking as there is no
recursion! However, the two threads do not follow either the
discipline of nested locking~\cite{kig05} or of bounded lock
chaining~\cite{kah09}. Hence, algorithms of \cite{kig05,kah09} cannot
be used to decide the pairwise reachability question for this
program. Notice that the computations of this pair of threads require
an unbounded number of context switches as the two threads proceed in
lock-step fashion. The locking pattern exhibited by these threads can
present in any program with contextual locking as long as this pattern
is within a single calling context (and not across calling
contexts). Such locking patterns when used in a non-contextual fashion
form the crux of undecidability proofs for multi-threaded programs
synchronizing via locks~\cite{kig05}.

\begin{figure}[ht]
\begin{minipage}{0.5\textwidth}
\begin{verbatim}

   public void P3(){
    acq l1;
    while (true){
       acq l2;
       rel l1;
       acq l3;
       rel l2;
       acq l1;
       rel l3;
    }
    }
   \end{verbatim}

\end{minipage}\begin{minipage}{0.5\textwidth}
\begin{verbatim}
  public void P4(){
    acq l3;
    while (true){
       acq l1;
       rel l3;
       acq l2;
       rel l1;
       acq l3;
       rel l2;
    }
    }
   \end{verbatim}

\end{minipage}

\caption{A -threaded program with unbounded lock chains}
\label{fig:example3}
\end{figure}



\end{example}






\section{Pairwise reachability}
\label{sec:main}
The pairwise reachability problem for a multi-threaded program
asks whether two given states in two threads can be simultaneously
reached in an execution of the program. Formally,

\begin{definition}
Given a -PDS  communicating via    indices  with , and control states  and
 of threads  and  respectively, let  denote the predicate that there is a computation  of  such that  and  The
pairwise control state reachability problem  asks if   is true.
\end{definition}

The pairwise reachability problem for multi-threaded programs
communicating via locks was first studied in~\cite{ram00}, where it
was shown to be undecidable. Later, Kahlon et. al.~\cite{kig05} showed
that when the locking pattern is restricted the pairwise reachability
problem is decidable.  In this paper, we will show that the problem is
decidable for multi-threaded programs in which each thread follows
contextual locking. Before we show this result, note that it suffices
to consider programs with only two threads \cite{kig05}.
\begin{proposition}
Given a -PDS  communicating via
 indices  with  and control states
 and  of  and  respectively, let 
be the -PDS  communicating via  Then  iff

\end{proposition}
Thus, for the rest of the section, we will only consider -PDS.

\subsection{Well-bracketed computations}
The key concept in the proof of decidability is
the concept of well-bracketed computations, defined below.

\begin{definition}
Let  be a -PDS via  and let  be a computation of .  is said to be  \emph{non-well-bracketed} if there exist  and  such that
\begin{iteMize}{}
\item   and  are matching call and returns of
, and
\item   is a procedure call of thread  whose matching return either occurs after  or does not occur at all.
\end{iteMize}
Furthermore,
the triple  is said to be a {\it witness} of non-well-bracketing of .

 is said to be \emph{well-bracketed} if it is not non-well-bracketed.
\end{definition}
\begin{example}
\label{exam:example4}
Recall the -threaded program from Example~\ref{exam:example1} shown in Figure~\ref{fig:example1}.
The computation  (see Figure~\ref{fig:compexam}) is non-well-bracketed, while the computation 
(see Figure~\ref{fig:compexam}) is well-bracketed. On the other hand, all the computations of the -threaded program
in  Example~\ref{exam:example3} (see Figure~\ref{fig:example3}) are well-bracketed as the two threads are
non-recursive.
\end{example}
 If there is a computation that simultaneously reaches
control states  and    then there is a well-bracketed computation that simultaneously reaches
 and :


\begin{lemma}
Let
  be a -PDS communicating via  such that each thread follows contextual locking. Given control states  and , we have that
 iff there is a  well-bracketed computation  of 
such that  and 

\end{lemma}
\begin{proof}
Let  be a non-well-bracketed computation that simultaneously reaches  and .
Let  be the smallest  such that there is a witness  of non-well-bracketing of . Observe now that it suffices to show that there is another computation  of the same length as
 that simultaneously reaches  and  and
\begin{iteMize}{}
\item either  is well-bracketed,
\item or if  is non-well-bracketed then for each witness  of
  non-well-bracketing of  it must be the case 
\end{iteMize}

\noindent We show how to construct  Observe first that any witness  of non-well-bracketing of  must necessarily agree in the third component  Let 
denote this component.  Let  be the smallest
 such that  is a witness of non-well-bracketing of 
Thus, the transition  and 
are matching procedure call and return of some thread  while the transition  is a procedure call of  by thread  whose return happens only after  Without loss of generality, we can assume that 

Let  and  be such that
 .  and
length of  is , of  is  and
of  is  Thus,  and
 are matching call and return of thread  and
 is a call of the thread  whose return does not
happen in .

We construct  as follows. Intuitively,  is
obtained by ``rearranging" the sequence
 as
follows. Let  and  denote all the ``actions" of thread
 and  respectively in  Then  is
obtained by rearranging  to
 This is shown in
Figure \ref{fig:proof}.
\begin{figure}
\begin{center}
\begin{tikzpicture}
\footnotesize
\node(s0) at (0,3) {};
\node at (1,3) {};
\node(slmn) at (2,3) {};
\node(slmn1) at (3.5,3) {};
\node at (4.5,3) {};
\node(slsm) at (5.5,3) {};
\node(slsm1) at (7,3) {};
\node(slrt) at (10.7,3) {};
\node(slrt1) at (12.2,3) {};
\node(u1) at (1,2.7) {};
\node(v11) at (4.5,2.7) {};
\node(v12) at (8.9,2.7) {};
\node at (6.1,2.2) {};
\node(t0) at (0,0) {};
\node at (1,0) {};
\node(tlmn) at (2,0) {};
\node(tlmn1) at (3.5,0) {};
\node at (4.5,0) {};
\node(tk) at (6.8,0) {};
\node(tk1) at (8.3,0) {};
\node(tk2) at (9.8,0) {};
\node(u2) at (1,-0.3) {};
\node(v21) at (4.5,-0.3) {};
\node(v22) at (6.1,-0.3) {};
\node(v23) at (10.9,-0.3) {};
\node at (6.1,-0.8) {};
\scriptsize
\draw[|<-] (0,2.7) -- (u1);
\draw[->|] (u1) -- (2,2.7);
\draw[|<-] (3.5,2.7) -- (v11);
\draw[->|] (v11) -- (5.5,2.7);
\draw[|<-] (7,2.7) -- (v12);
\draw[->|] (v12) -- (10.7,2.7);
\draw[->] (slmn) -- node[above](p0){} (slmn1);
\draw[->,dashed] (slsm) -- node[above](p1){} (slsm1);
\draw[->] (slrt) -- node[above](r0){} (slrt1);
\draw[->,dashed] (slsm1) -- (8,3);
\draw[->] (8.1,3) -- (8.6,3);
\draw[->,dashed] (8.7,3) -- (9.2,3);
\draw[->] (9.3,3) -- (9.8,3);
\draw[->,dashed] (9.9,3) -- (10.4,3);
\draw[dotted] (p0) .. controls (3.7,4.5) and (10.4,4.5) .. (r0);
\draw[dotted] (p1) .. controls (7.2,4) and (12.2,4) .. (12.4,4);
\draw[|<-] (0,-0.3) -- (u2);
\draw[->|] (u2) -- (2,-0.3);
\draw[|<-] (3.5,-0.3) -- (v21);
\draw[->|] (v21) -- (5.5,-0.3);
\draw[|<-] (5.5,-0.3) -- (v22);
\draw[->|] (v22) -- (6.8,-0.3);
\draw[|<-] (9.8,-0.3) -- (v23);
\draw[->|] (v23) -- (12,-0.3);
\draw[->] (tlmn) -- node[above](p2){} (tlmn1);
\draw[->] (tk) -- node[above](r2){} (tk1);
\draw[->,dashed] (tk1) -- node[above](p3){} (tk2);
\draw[->] (5.5,0) -- (6,0);
\draw[->] (6.1,0) -- (6.6,0);
\draw[->,dashed] (tk2) -- (10.8,0);
\draw[->,dashed] (10.9,0) -- (11.4,0);
\draw[->,dashed] (11.5,0) -- (12,0);
\draw[dotted] (p2) .. controls (3.7,1.5) and (6.5,1.5) .. (r2);
\draw[dotted] (p3) .. controls (10,1) and (12,1) .. (12.2,1); \end{tikzpicture}
\end{center}
\caption{Computations  and . Transitions of
   are shown as solid edges and transitions of  are
  shown as dashed edges; hence process ids are dropped from the label
  of transitions. Matching calls and returns are shown with dotted
  edges. Observe that all calls of  in  have matching
  returns within .}
\label{fig:proof}
\end{figure}


The fact that if  is non-well-bracketed then there is no
witness  of non-well-bracketing with
 will follow from the following observations on


\begin{iteMize}{}
\item[]  cannot contain any returns of  which
  have a matching call that occurs in  (by construction of
  ).
\item[] All calls of  in  must return
  either in  or after  is returned. But the latter is not
  possible (by construction of ). Thus, all calls of 
  in  must return in 
\end{iteMize}


Formally,  is constructed as follows. We fix some
notation.  For each  let  and
 Thus 
\begin{enumerate}[(1)]

\item The first  transitions of  are the
  same as , i.e., initially
  
  
\item Consider the sequence of transitions
   in . Let  be the number of transitions of 
  in this sequence and let  be the indices such that
  . Note that it must be the case that for each 
 

 For ,  let 
 Observe now that, thanks to contextual locking, the set of locks held by  in  is a subset of the locks held
 by  in  for each  Thus we can extend 
 by applying the   transitions of   used to obtain  in .
 In other words,  is now
 

     Note that 
     Thus the set of locks held by  in   is exactly the set of locks held by  at
        


     \item
     Consider the sequence of transitions  in . Let  be the number of transitions of
  in  this sequence and let
  be the indices such that
  . Note that it must be the case that for each 
 

 For   let  
 Observe now that, thanks to contextual locking, the set of locks held by  in  is
  exactly the set of locks held by  at
         and the latter is  a subset of the locks held
 by  in  for each 
 Thus we can extend 
 by applying the   transitions of   used to obtain  in .
 In other words,  is now
 



       Observe now that the extended  is a sequence of  transitions  and that the final configuration
       of , 
       is exactly the configuration 
      \item Thus, now we can extend  as
      
        Clearly,  has the same length as  and simultaneously reaches  and     There is also no  witness  of non-well-bracketing in  with
  The lemma follows. \qedhere  \end{enumerate} 
\end{proof}
\subsection{Deciding   pairwise reachability}
We are ready to show that the problem of checking pairwise reachability is decidable.

\begin{theorem} There is an algorithm that
given a -threaded program  communicating via  such that  and  follow contextual locking, and control states  and 
of  and  respectively decides if  is true or not. Furthermore, if  and  are the sizes of
the  programs  and  and  the number of elements of  then this algorithm has a running time of 

\end{theorem}
\begin{proof}
The main idea behind the algorithm is to construct a single PDS  which simulates all the well-bracketed
computations of     simulates a well-bracketed computation as follows.
The set of control states of  is the product of control states of  and 
The single stack of  keeps track of the stacks of  and : it
is the sequence of those calls of the well-bracketed computation which have not been returned.
 Furthermore, if the stack of 
is  then  the stack of  is the projection of  onto the stack symbols of  and the
stack of  is the projection  of  onto the stack symbols of  Thus, the top of the stack is the most recent unreturned call and if it belongs to  well-bracketing ensures
that no previous unreturned call is returned without returning this call.


Formally,  is defined as follows. Let  and
 Without loss of generality,  assume that 
and 

\begin{iteMize}{}
\item   The set of states  is 


\item  \item 
     \item  consists of three sets  and  which simulate the
             internal actions, procedure calls and returns, and lock acquisitions and releases of the threads
              as follows. We explain here only the simulation of actions of  (the simulation of actions of  is similar).
                 \begin{iteMize}{}
                 \item {\it Internal actions.} If  is an internal action of  then for each  and 
                  
                  \item {\it Lock acquisitions.} Lock acquisitions are also modeled by  If  is a lock
                    acquisition action of thread 
                   then for each   and 
                  
                   \item {\it Lock releases.} Lock releases are also modeled by  If  is a lock
                    release action of thread 
                   then for each   and 
                  
                    \item {\it Procedure Calls.}     Procedure calls are modeled  by  If 
                    is a procedure call of thread  then for each
                     and 
                    

                   \item {\it Procedure Returns.}     Procedure returns are modeled  by  If 
                    is a procedure return of thread  then for each
                     and 
                    



                                  \end{iteMize}

\end{iteMize}

\noindent It is easy to see that  is reachable in  by a
well-bracketed computation iff there is a computation of 
which reaches  for some  The complexity of the results follows from the observations
in~\cite{bem97} and the size of . \end{proof}

\section{Reentrant locking}
\label{sec:reentrant}
We now turn our attention to reentrant locking. Recall that a reentrant lock is a recursive lock which allows the thread owning a lock
to acquire the lock multiple times; the owning thread must release the lock an equal number of times before another thread can acquire
the lock.  Thus, the  set of configurations of a  thread   using \emph{reentrant locks} is the set 
(and not the set   as in non-reentrant locks).  Intuitively, the elements of a configuration  of  now have the following meaning:  is the control state of   the contents of the stack and  is a function that tells the number of times each lock has been acquired by  The
semantics of a PDS  using reentrant  is formally defined as:\footnote{The definition of PDS  using reentrant locks  is exactly the definition of PDS  using locks  (see Section \ref{sec:model}).} 
 \begin{definition}
 A PDS  using reentrant  gives  a labeled
 transition relation  where  and
  is defined as follows.
 \begin{iteMize}{}
 \item  if 
 \item  if 
 \item  if 
 \item  if  and either  or .
 \item  if   and
 .

 \item  if   and
 .
 \end{iteMize}
 \end{definition}
 
The semantics of -PDS  communicating via reentrant  is given as a
transition system on  
where  and  are the set of states and the stack alphabet  of process  respectively. Formally,
\begin{definition}
The semantics of a -PDS  communicating via reentrant   is given as a labeled transition system  where
\begin{iteMize}{}
\item  is said to be the set of configurations of  and  is the set  where  is the set of  states of  and  is the stack alphabet of 
\item The initial configuration  is   where  is the initial local state of  and  is the function which takes the value  for each 


\item The set of labels on the transitions  is  where 
The labeled transition relation  is defined as follows.

iff  for all ,
        and  and  
      
\end{iteMize}
\end{definition}

\begin{notation}
Given a configuration  of a -PDS  using reentrant ,
we say that 
\end{notation}


\subsection{Contextual locking}
We now adapt contextual locking to reentrant locks. Informally, contextual reentrant locking means that--
\begin{iteMize}{}
\item each instance of a lock acquired by a thread in a
procedure call must be released before the corresponding return is executed, and
\item the instances of locks held by a thread just before a procedure call is executed are not released during the
execution of the procedure.
\end{iteMize}
Formally,
 \begin{definition}
A thread  in a -PDS  is said to follow contextual locking if whenever 
and  are matching procedure call and return  along a computation

we have that

 \end{definition}



\subsection{Pairwise reachability problem}
We are ready to show that the pairwise reachability problem becomes undecidable if we have reentrant locks. 

\begin{lemma}
\label{thm:contextundecid}
The following problem is undecidable:
Given a -PDS  communicating only via reentrant locks   s.t.  and  follow contextual locking, and control states  and
 of  threads  and   check if  is  true. The problem continues to remain undecidable even when  and  are finite state systems, \emph{i.e.},  and   do not use their stack during any computation.
\end{lemma}
\begin{proof}
We shall show a reduction from the halting problem of a two-counter machine (on empty input)  to the pairwise control state reachability problem. 

A two-counter machine  is a tuple :   is a finite set of states,  is the initial state,  is the final state and  is a tuple  where
  is the set of state transitions of    for each ,   is the set  of increment transitions of
the  counter ,  is the set of decrement transitions of
the  counter , and  is the set of zero-tests of the  counter .
A configuration of  is a triple 
 where  is the ``current control state", and  and  are the values of the counters  and  respectively.  
 is said to \emph{halt}  if there is a computation starting from  and reaching a configuration  for some 
The halting problem asks if  halts.


Fix a two-counter machine  We will construct a  finite set , a -PDS  communicating via reentrant  and states  of  and  respectively such that  halts iff  is true. 

The set  will be the set  
The -PDS  will not have any recursion, \emph{i.e.}, its stack alphabet  will be empty.  will constructed in two steps. In the first step, we construct a -PDS  communicating via reentrant   , a configuration  of  and states  and  of  and  respectively such that there is a computation of  starting from  and ending in a state  for some  iff  halts. In the next step of the construction, we will show how to ``set up'' the appropriate values of  and  initially.


We construct  as follows. The locks  and  will not play a role in the construction of , but will
be used later to initialize  and .
 Intuitively,  the program   simulates a computation of .
The simulation is mostly carried out by the thread .   maintains the control state
 of  as well as the values of the two counters  using the locks  and : 
 the contents of the counter  are stored as number of times  the lock  is acquired by  
 An increment of the counter  is simulated by an acquisition of the lock  and a decrement of  is simulated by release of the lock  A state transition of  is modeled by an internal action of 
 
 
 
 
 A zero-test of  counter  is carried by synchronization of threads  and  and involves  the locks 
  and  The zero test on counter  is carried out as follows.  
 For the zero test to be carried out, , must be in a ``ready" state   
 Before a zero-test on counter  is carried out,  
  thread  holds one instance of lock  and thread  holds one instance of lock  To carry out the zero-test,  carries out the following sequence of lock acquisitions and releases:
   and
  carries out the following sequence:
  
 
 
 
 Intuitively, the zero-test ``commences" by  trying to acquire lock  If the lock acquisition succeeds then  ``learns" that counter  is indeed 
zero.  then releases the lock  in order to ``inform"  that the counter  is  and ``waits" for 
thread  to update its state. To test that counter  is indeed , thread  tries to acquire
lock  If it succeeds in acquiring the lock then thread  learns that counter  is indeed  It updates its state, releases lock  to  ``inform"  thread  that it has updated the state. Thread  learns that   has updated its state by acquiring lock  Now,   releases lock  so that it can ``tell"  to release the lock 
Thread  acquires lock  releases lock  and waits for lock  to be released.  can now acquire  the lock . After acquiring     releases lock  and transitions back to the state  Thread  acquires lock  and releases lock  
Now, we have that  holds lock  and  holds lock  as before and nobody holds . Now  can continue
simulating .

Let  and   Let
   
Let 
The construction of
 ensures that there is a computation of  starting from  and ending in a state  for some  iff  halts.

Now,  is constructed from  as follows. The thread  initially performs the following sequence of lock acquisitions and releases:
 
makes a transition to  and starts behaving like thread 
The thread  initially performs the following sequence of lock acquisitions and releases:

makes a transition to  and starts behaving like thread  

The construction ensures that  is true iff  halts. 
The formal construction of  has been carried out in the Appendix.
\end{proof}




\section{Conclusions}
\label{sec:conclusions}

The paper investigates the problem of pairwise reachability of
multi-threaded programs communicating using only locks. We identified
a new restriction on locking patterns, called contextual locking,
which requires threads to release locks in the same calling context in
which they were acquired. Contextual locking appears to be a natural
restriction adhered to by many programs in practice. The main result
of the paper is that the problem of pairwise reachability is decidable
in polynomial time for programs in which the locking scheme is
contextual. Therefore, in addition to being a natural restriction to
follow, contextual locking may also be more amenable to 
practical analysis.  We observe that these results do not follow from
results in~\cite{kig05,kg06,kah09,kah11} as there are programs
with contextual locking that do not adhere to the nested locking
principle or the bounded lock chaining principle. The proof principles
underlying the decidability results are also different. Our results can also be mildly extended to handling programs that release locks a bounded stack-depth away from when they were acquired
   (for example, to handle procedures that call a function that acquires a lock, and calls another to release it before it returns).



There are a few open problems immediately motivated by the results on contextual locking in
this paper. First, decidability of model checking with respect to
fragments of LTL under the contextual locking restriction remains
open. Next, while our paper establishes the decidability of pairwise
reachability, it is open if the problem of checking if 3 (or more) threads
simultaneously reach given local states is decidable for programs with
contextual locking. Finally, from a practical standpoint, one would
like to develop analysis algorithms that avoid to construct the
cross-product of the two programs to check pairwise reachability.


We also considered the case of reentrant locking mechanism and established that the pairwise reachability under
contextual reentrant locking is undecidable. The status of the pairwise reachability problem for the case when the
locks are nested (and not necessarily contextual) is open. This appears to be a very difficult problem. Our reasons for
believing this is that the problem of checking control state reachability in a PDS with \emph{one} counter and no zero tests
can be reduced to the problem of checking pairwise reachability problem  in a -threaded program communicating via a single (and hence nested) reentrant lock.   
The latter is a long standing open problem.  


For a more complete account for multi-threaded programs, other synchronization
primitives such as thread creation and barriers should be taken into account. Combining
lock-based approaches such as ours with techniques for other primitives is left to
future investigation.






\subsection{Acknowledgements.}
P. Madhusudan was supported in part by NSF Career Award 0747041. Mahesh Viswanathan was 
supported in part by NSF CNS 1016791 and NSF CCF 1016989. Rohit Chadha was at LSV, ENS Cachan \& INRIA
during the time research was carried out.



\bibliographystyle{plain}
\bibliography{refs}
\appendix
\section{Construction of  in the proof of Theorem~\ref{thm:contextundecid}}


We carry out the construction of   in the proof of Theorem~\ref{thm:contextundecid}. 

Recall that   is  a two  counter machine and  is the tuple    is a -PDS communicating via reenterant 
 Recall also that  is constructed in two steps. First a -PDS 
 is constructed and then extended to   

Formally,  the set of states of  is   Intuitively, the state
 means that the counter  is being tested for zero, the thread  has completed its  step in the test    and  will be the resulting state after the zero test is completed.   
The transitions 
of   
are defined as follows. The set of internal actions of ,  is the set  
The set of lock acquisitions  is the union of sets  and  where
 is the set
 The set of lock releases  is the union of sets  and  where
 is the set
 

   
The set of states of  is the set 
where  is a new state. Intuitively, the state  means that  is ready to test a counter.
The state  means that the counter  is being tested for zero and the thread  has completed its  step in the test.  The set of transitions 
of   consists of only lock acquisition transitions and lock release transitions.     The set of lock acquisitions  is the union of sets  and , where
 The set of lock releases  is the union of sets  and , where
 

Now the -PDS  is constructed as follows. For   the set of states is  where  are new states. In addition to  the set of
transitions of 
 contains the  lock acquisition transitions 
, , ,  and the lock release transition  The state  is the initial state of 

For  the set of states is  where  are new states. In addition to  the set of
transitions of 
contains the  lock acquisition transitions , , ,   and the lock release transition  The state  is the initial state of 

\end{document}
