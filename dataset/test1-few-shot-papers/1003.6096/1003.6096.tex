\documentclass{article}

\usepackage{float}          \usepackage{mathpartir}     \usepackage{pstricks}
\usepackage{pst-node}
\usepackage{wrapfig}

\usepackage{polys-metavars}
\usepackage{polys-syntax}
\usepackage{polys-functions}
\usepackage{comparison}

\renewcommand{\land}{\mathrel{\&}}

\floatstyle{boxed}
\restylefloat{figure}

\bibliographystyle{abbrv}
\setlength{\arraycolsep}{1.5pt}

\title{Expressiveness of Generic Process Shape Types}
\date{
    { \normalsize Heriot-Watt  University } \
\begin{array}{lll}
    \infAxiom{ \streq{\pPar{\xP}{\xQ}}
                     {\pPar{\xQ}{\xP}} \qquad }
&
    \infAxiom{ \streq{\pPar{\xP}{(\pPar{\xQ}{\xR})}}
                     {\pPar{(\pPar{\xP}{\xQ})}{\xR}} \qquad }
&
    \infAxiom{ \streq{\pPar{\xP}{\pNull}}{\xP} }
\\
    \infAxiom{ \streq{\pNull}{\pBang\pNull} }
&
    \infAxiom{ \streq{\pNu{\xx}{\pNu{\xy}{\xP}}}
                     {\pNu{\xy}{\pNu{\xx}{\xP}}} }
&
    \infAxiom { \streq{\oB\xP}{\xP\oI\oB\xP} }
\end{array}

    \infCondAxiom
          { \x\not\in\fn{\xA}\cup\bn{\xA} }
          { \streq{\xA.\pNu{\x}{\xP}}{\pNu{\x}{\xA.\xP}} }
\qquad
    \infCondAxiom
          { \x\not\in\fn{\xP} }
          { \streq{\pPar{\xP}{\pNu{\x}{\xQ}}}
                {\pNu{\x}{(\pPar{\xP}{\xQ})}} }
-7mm]
\begin{minipage}[t]{6.5cm}
\begin{pstgrammar}
    \grmclass{\xNVx,\xNVy}{NameVar}{ 
        \var{a} \grmOr 
        \var{b} \grmOr 
        \var{c} \grmOr 
        \cdots } 
\\
    \grmclass{\xMV}{MessageVar}{ 
        \var{M} \grmOr 
        \var{N} \grmOr 
        \cdots } 
\\
    \grmclass{\xETpl}{ElementTempl}{ 
        \x \grmOr 
        \xNV \grmOr 
        \sIn{\xNV_1,\ldots,\xNV_k} \grmOr 
        \sOut{\xMV_1,\ldots,\xMV_k} } 
\\
    \grmclass{\xATpl}{ActionTempl}{ 
        \xETpl_0\;\xETpl_1 
        \ldots \xETpl_k } 
\\
    \grmclass{\xPTplP,\xPTplQ}{ProcessTempl}{ 
        \xPV \grmOr 
        \xATpl.\xPTpl \grmOr 
        \pNull \grmOr 
        (\pPar{\xPTplP}{\xPTplQ}) \grmOr
        \sTemplSubst\,\xPV }
\\
    \grmclass{\xRule}{Rule}{ 
        \sReduce{\xPTplP}{\xPTplQ} \grmOr 
        \sActive{\xPV}{\xPTpl} 
    } 
\\
    \grmeqclass{\xRS}{RuleSet}{ \powerfin{\mathsf{Rule}} }
\end{pstgrammar}
\end{minipage}
\begin{minipage}[t]{5cm}
\begin{pstgrammar}
    \grmclass{\xPV}{ProcessVar}{ 
        \var{P} \grmOr 
        \var{Q} \grmOr 
        \var{R} \grmOr 
        \cdots }
\\
    \grmclass{\xSubstute}{Substitute}{ 
        \xNV \grmOr 
        \xMV } 
\end{pstgrammar}
\end{minipage}
\vspace{-3mm}
\labeledHline{Semantics of \metaS rewriting rules:}
\renewcommand{\arraystretch}{1.2}

\vspace{-1mm}
\normalsize
\caption{Syntax and semantics of \metaS reduction rule descriptions.}
\label{fig:meta/rwrules}
\end{figure}
}

\renewcommand{\infAxiom}[1]{\inferrule*{}{#1}}
\renewcommand{\infRule}[2]{#1 \,\Rightarrow\, #2}

\metaS provides syntax to describe rewriting rules that give meaning to
actions and also defines how these rules yield a rewriting relation on
processes.
The syntax is best explained by an example.
The following rule description
    (in which ``''
    describes substitution application)

directly corresponds to the standard -calculus communication
rule
``''.
The circle-topped letters stand at the place of name, message, and process
metavariables.
Given a set  of rule descriptions in the above syntax, \metaS
automatically infers the rewriting relation  which
incorporates structural equivalence and congruence rules (e.g.,
``'').
A rules description instantiates \metaS to a particular calculus, e.g.,
the set  containing only the above rule description
instantiates \metaS to the -calculus.

Further examples of \metaS instantiations are given in
Sec.~\ref{sec:pi/instatiate} and \ref{sec:ma/instatiate}.
A rule description can also contain a concrete \metaS name (e.g.
``'') when an exact match is required.
We require that these names are never bound in any process.
Complete definitions of the syntax of rewriting rules and of the
rewriting relation  is left to the TR
\cite[Sec.~2.2]{Jak+Wel:ShapeTypes-2009}.

\subsection{\polyS Shape Predicates and Types for \metaS}\label{sec:poly/types}

A \emph{shape predicate} describes possible structures of process
syntax trees.
When a rewriting rule from  is applied to a process, its syntax tree
changes, and sometimes the new syntax tree no longer satisfies the same
shape predicates.
All \polyS (-)types are shape predicates that describe process
sets closed under rewriting using .
For feasibility, types are defined via a syntactic test that enforces
rewriting-closedness.
Intuitively, the syntactic test tries to apply the rules from  to all
active positions in a shape graph and checks whether all the edges newly
generated by this application are already present in the graph.
Further restrictions are used to ensure the existence of principal
typings.

\newcommand{\FIGpolyshapesyntax}{
\begin{figure}[t]
\small
\labeledHeader{Syntax of \polyS shape predicates:}
\
\setlength{\arraycolsep}{2mm}
\begin{array}{lll}
    \infAxiom 
          { \shapes{\xa^\xn}{\xa} }
  &
    \infAxiom
          { \shapes{\sIn{\xa_1^{i_1},\ldots,\xa_k^{i_k}}}
                   {\sIn{\xa_1,\ldots,\xa_k}} }
  &
    \infRule
          { (\shapes{\xM_0}{\xFS}
             \land\, \shapes{\xM_1}{\xFS}) }
          { \shapes{\xM_0.\xM_1}{\xFS} }
\\
    \infAxiom
          { \shapes{\pNull}{\xFS} }
  &
    \infRule
          { (\shapes{\xF}{\xFT} \land \xFT\in\xFS) }
          { \shapes{\xF}{\xFS} }
  &
    \infRule
{ (\xM\not\in\grmset{Name} \land\, 
                 \shapes{\xM}{\xFS}) }
               { \shapes{\xM}{\sStar{\xFS}} }
\end{array}

\setlength{\arraycolsep}{2mm}
\begin{array}{ll}
     \infRule
           { (\forall i\le k\!:\ 
             \shapes{\xE_i}{\xET_i})
           }
           { \shapes{\xE_0 \ldots \xE_k}{\xET_0 \ldots \xET_k} }
  &
\\
    \infRule
          { (\forall i\!: 0<i\le k \land\, \shapes{\xM_i}{\xMT_i}) }
          { \shapes{\sOut{\xM_1,\ldots,M_k}}{\sOut{\xMT_1,\ldots,\xMT_k}} }
\end{array}

\setlength{\arraycolsep}{1mm}
\begin{array}{lr}
    \begin{array}{l}
        \infAxiom{ \shapes{\pNull}{\xS} }
    \\
        \infRule
              { \shapes{\xP}{\xS} }
              { \shapes{\pNu{\xx}{\xP}}{\xS} } 
    \\
        \infRule
              { \shapes{\xP}{\xS} }
              { \shapes{\oB\xP}{\xS} } 
    \end{array}
  &
    \begin{array}{l}
        \infRule
              { (\shapes{\xP}{\xS}
                 \land\, \shapes{\xQ}{\xS}) }
              { \shapes{\xP\oI\xQ}{\xS} }
    \\
        \infRule{ ((\xNode_0\oEdge{\xAT}\xNode_1) \in \xG \land\,
            \shapes{\xA}{\xAT}  \land\,
            \shapes{\xP}{\sShape{\xG}{\xNode_1}})}
        { \shapes{\xA.\xP}{\sShape{\xG}{\xNode_0}} }
    \end{array}
\end{array}

    \gStrEq{\gxPP}{\gxPP'} \land
    \reduce{\encode{\gxPP'}}{\encode{\gxPQ'}} \land
    \gStrEq{\gxPQ'}{\gxPQ}.

    \gRew{\gxPP}{\gxPQ} \land
    \gStrEq{\encode{\gxPQ}}{\xP_1}.

\begin{array}{l}
    \mathcal{P} = \bigcup_{k=0}^{\infty} \big\{ 
    \oReduce\oLeft\,
        \sChOut{\var{c}}{\var{M}_1,\ldots,\var{M}_k}.\var{P} \!\oI\!
        \sChIn{\var{c}}{\var{a}_1,\ldots,\var{a}_k}.\var{Q} 
    \ \oArr
        \var{P}\!\oI\!\oLeft
            \var{a}_1\!\oAssign\var{M}_1,\ldots,
            \var{a}_k\!\oAssign\var{M}_k
        \oRight\var{Q}
        \,\oRight
    \big\}
\end{array}

\begin{array}{ll}
    \multicolumn{2}{l}{
        \cIn{\cxc}{\cxx_1,\ldots,\cxx_k}.\cxPP    \oI
        \cOut{\cxc}{\cxy_1,\ldots,\cxy_k}.\cxPQ \SYMtRewrite 
        \tSub[\{\cxx_1\mapsto\cxy_1,\ldots,\cxx_k\mapsto\cxy_k\}]{\cxPP}
        \oI \cxPQ
    }
\
\vspace{-1mm}

\normalsize
\caption{The syntax and semantics of the -calculus.}
\label{fig:pi/syntax+semantics}
\end{figure}
}

\newcommand{\FIGtpitypesrules}{
\begin{figure}[t]
\small
\labeledHeader{Syntax of \TPi types:}
\begin{pstgrammar}
    \grmclass{\cxTV}{PiTypeVariable}{ 
        \textsf{\i} \grmOr \textsf{\i'} \grmOr \textsf{\i''} \grmOr \cdots } \\
    \grmclass{\cxT}{PiType}{ \cxTV \grmOr 
        \cChT{\cxT_1,\ldots,\cxT_k} } \\
    \grmeqclass{\gxE}{PiContext}{ 
        \mapfin{\grmset{BasicName}}{\grmset{PiType}} } \\
\end{pstgrammar}
\labeledHline{Typing rules of \TPi:}

\vspace{-2mm}

\vspace{-2mm}
\normalsize
\caption{Syntax of \TPi types and typing rules.}
\label{fig:pi/types+rules}
\end{figure}
}

The -calculus \cite{Mil+Par+Wal:IC-1992,Mil:CMS-1999} is a process
calculus involving process mobility developed by Milner, Parrow, and Walker.
Mobility is abstracted as channel-based communication whose objects are
atomic names.
Channel labels are not distinguished from names and can be passed by
communication.
This ability, referred as \emph{link passing}, is the -calculus
feature that most distinguishes it from its predecessors.
We use a polyadic version of the -calculus which supports
communication of tuples of names.

\renewcommand{\infAxiom}[1]{#1}
\renewcommand{\infCondAxiom}[2]{#2 \mbox{\ \ if } #1}
\renewcommand{\infRule}[2]{#1 \,\Rightarrow\, #2}
\FIGtpisyntaxsemantics

Fig.~\ref{fig:pi/types+rules} presents the syntax
and semantics of the -calculus.
Processes are built from \metaS names.
The process ``'', which
(input)-binds the names 's, waits to receive a -tuple of
names over channel  and then behaves like  with the received
values substituted for 's.
The process ``'' sends the -tuple
, ,  over channel  and then behaves like .
Other constructors have the meaning as in \metaS (Sec.~\ref{sec:star/calculus}).
The sets of names , , , 
are defined as in \metaS.

Processes are identified up to -conversion of bound names
which preserves basic names.
A substitution in the -calculus is a finite function from names to names,
and its application to  is written postfix, e.g.,
``''.
A process  is \defthis{well scoped} when \rulename{(S1)} 
, , and  do not overlap,
\rulename{(S2)} nested input binders do not bind the same basic name, and
\rulename{(S3)} no input action contains the same basic name more then once.
Henceforth, we require processes to be well scoped
(well-scopedness is preserved by rewriting).

\begin{example}\label{ex:pi/calculus}
Let 
     \\ 
    

\noindent
Using the rewriting relation  sequentially four times we can
obtain (among others) the process
``''.
\end{example}

\subsection{Types for the Polyadic -calculus (\TPi)}
\label{sec:pi/system}

\renewcommand{\infAxiom}[1]{#1}
\renewcommand{\infRule}[2]{#1\,\Rightarrow\,#2}
\FIGtpitypesrules

We compare \polyS with a simple type system \cite[Ch. 3]{Tur:PhD-1995}
for the polyadic -calculus presented by Turner which we name \TPi.
\TPi is essentially Milner's sort discipline \cite{Mil:CMS-1999}.
In the polyadic settings, an arity mismatch error on
channel  can occur when the lengths of the sent and received tuple do
not agree, like in
``''.
Processes which can never evolve to a state with a similar situation are
called \defthis{communication safe}.
\TPi verifies communication safety of -processes.

The syntax and typing rules of \TPi are presented in
Fig.~\ref{fig:pi/types+rules}.
Recall that  denotes the basic name of .
Types  are assigned to names.
Type variables  are types of names which are not used as channel
labels.
The type ``'' describes a channel which
can be used to communicate any -tuple whose -th name has type .
A context  assigns types to free names of a process (via their basic
names).
The relation , which is preserved under rewriting, expresses that
the actual usage of channels in  agrees with .
When  for some  then  is communication safe.
The opposite does not necessarily hold.

\begin{example}
\label{ex:pi/system}

Given  from Ex.~\ref{ex:pi/calculus} we can see that there is
no  such that . 
It is because the parts  and
 imply that types of  and  must be
equal while the parts  and 
force them to be different.
On the other hand  is communication safe.
We check this using \polyS in Sec~\ref{sec:pi/instatiate}.

\end{example}

\subsection{Instantiation of \metaS to the -calculus}
\label{sec:pi/instatiate}

\newcommand{\FIGpiencoding}{
\begin{figure}[t]
    \small
    \vspace{-1mm}
    \renewcommand{\arraystretch}{1.2}
    \setlength{\arraycolsep}{1mm}
    
    \vspace{-1mm}
    \renewcommand{\arraystretch}{1}
    \normalsize
    \caption{Encoding of -calculus processes in \metaS.}
    \label{fig:pi/process+encoding}
\end{figure}
}
    

\newcommand{\EXpiprincipaltype}{
    \newlength{\col}
    \newlength{\row}
    \setlength{\col}{5mm}
    \setlength{\row}{-4pt}
    \newcommand*{\armAa}{1.00}
    \newcommand*{\armAb}{1.45}
    \newcommand*{\armAc}{0.40}
    \newcommand*{\armAd}{0.92}
    \newcommand*{\armAe}{0.40}
    \newcommand*{\armAf}{0.90}
    \small
    
    \normalsize
}

The -calculus syntax from Sec.~\ref{sec:pi/calculus} already
matches the \metaS syntax and thus only the following  is needed
to instantiate \metaS to the calculus  and \polyS to its type
system .
Sec.~\ref{sec:pi/embedding} shows that  is essentially
identical to the above -calculus.
\PARinstpi
Each communication prefix length has its own rule; in our
implementation, a single rule can uniformly handle all lengths, but
the formal \metaS presentation is deliberately simpler.
The next example shows how to check communication safety in 
without using \TPi.

\begin{wraptable}{r}{5cm}
\vspace{-2mm}
\centering
\EXpiprincipaltype
\vspace{-13mm}
\end{wraptable}

\begin{fakedexample}
\label{ex:pi/instatiate}
    Let  be a \metaS equivalent of  from Ex.~\ref{ex:pi/calculus}.
    We can compute a principal -type  of  which is
    displayed on the right.
    Node  is its root. 
    The type  contains all computational futures of  in one
    place.
    Thus, because there are no two edges from  labeled by
    ``'' and
    ``'' with , we can conclude
    that  is communication safe which Ex.~\ref{ex:pi/system} shows \TPi
    can not do.
    Our implementation can be instructed (using an additional rule) to
    insert the error name  at the place of communication errors.
    Any type of  without  then implies 's communication
    safety.

\end{fakedexample}

\subsection{Embedding of \TPi in \polyS}
\label{sec:pi/embedding}

\newcommand{\FIGpitypeembed}{
\begin{figure}[t]
\small
\labeledHeader{The set of expected and actual channel types of :}
\vspace{1mm}

\vspace{-2mm}
\labeledHline{Context  and shape type  agreement relation
:}
\vspace{1mm}

Write  when there is some  with
the domain disjoint from  such that  is
defined and is an identity.

\normalsize
\caption{Property of shape types corresponding to  of \TPi.}
\label{fig:pi/type+embedding} 
\end{figure}
}

Using the terminology from Sec.~\ref{sec:general/terminology} we have
that  is the -calculus,  is \TPi,
predicates  of  are contexts , and 's
relation  is .
Moreover  is  which was introduced with 
 and  in Sec.~\ref{sec:pi/instatiate}.
This section provides a formal comparison which shows how to, for a
given  and , answer the question  using
.

As stated in Sec.~\ref{sec:general/calculus}, to relate \TPi and
 we need to provide an encoding  of
-processes in \metaS.
This , found in TR
    \cite[Fig.~10]{Jak+Wel:ShapeTypes-2009}
, is almost an identity because the
-calculus syntax (Fig.~\ref{fig:pi/syntax+semantics}) already agrees
with \metaS.
Thus  mainly changes the syntactic category.
Prop.~\ref{thm:general/encoding+correct} holds in the above context.

\FIGpitypeembed

Given , we define a shape type property which
holds for the principal type  of  iff
.
The property is given by the relation  from
Fig.~\ref{fig:pi/type+embedding}.
The set  contains pairs of \TPi types
extracted from .
Each pair corresponds to an edge of  labeled by an
action type ``'' or
``''.
The first member of the pair is 's type expected by ,
and the second member computes 's actual usage from the types of
's.
The set  is undefined when some required value of
 is not defined.
The context  from the definition of  provides types
of names originally bound in .
These are not mentioned by  but are in .
The following theorem shows how to answer  by
.

\begin{theorem}\label{thm:pi/embedding+correct}
    
Let no two different binders in  bind the same basic name, 
be a principal \mbox{(-)type} of , and
.  
Then  iff .

\end{theorem}

The requirement on different binders (which can be achieved by renaming) is
not preserved under rewriting because replication can introduce two
same-named binders.
However, when all binding basic names differ in , then the
theorem holds for any successor  of  even when the
requirement is not met for .
We want to ensure that the derivation of  does not assign
different types to different bound names.
A slightly stronger assumption of Thm.~\ref{thm:pi/embedding+correct}
simplifies its formulation.
The theorem uses principal types and does not necessarily hold for a
non-principal -type  of  because 's
additional edges not needed to match  can preclude
.

\subsection{Conclusions}
\label{sec:pi/conclusion}

We showed a process (Ex.~\ref{ex:pi/calculus}) that can not be proved
communication safe by \TPi (Ex.~\ref{ex:pi/system}) but can be proved so
by \polyS (Ex.~\ref{ex:pi/instatiate}).
Thm.~\ref{thm:pi/embedding+correct} implies that \polyS recognizes safety
of all \TPi-safe processes.
Thus we conclude that \polyS is better in recognition of communication
safety then \TPi.
Thm.~\ref{thm:pi/embedding+correct} allows to recognize typability in
\TPi:  is typable in \TPi iff .
This is computable because a \polyS principal type can always be found (for
 in
polynomial time), and checking  is easy.

Turner \cite[Ch.~5]{Tur:PhD-1995} presents also a polymorphic system for
the -calculus which recognizes  from Ex.~\ref{ex:pi/calculus}
as safe.
However, with respect to our best knowledge, it can not recognize safety
of the process ``'' which
\polyS can do.
We are not aware of any process that can be recognized safe by Turner's
polymorphic system but not by \polyS.
It must be noted, there are still processes which \polyS can not prove
safe, for example,
``''.

Other -calculus type systems are found in the literature.
Kobayashi and Igarashi \cite{Iga+Kob:POPL-2001} present types for the
-calculus looking like simplified processes which can verify
properties which are hard to express using shape types (race conditions,
deadlock detection) but do not support polymorphism.
One can expect applications where \polyS is more expressive as well as
contrariwise.
Shape types, however, work for many process calculi, not just
the -calculus.

\section{Shape Types for Mobile Ambients}
\label{sec:ma}

\subsection{Mobile Ambients (\MA)}
\label{sec:ma/calculus}

\newcommand{\FIGtmasyntaxsemantics}{
\begin{figure}[t]
\small
\labeledHeader{Syntax of \MA processes:}
\begin{pstgrammar}
    \grmeqclass{\txx}{AName}{\grmset{Name}\setminus
        \{ \sBullet \}} \\
    \grmclass{\txM}{ACapability}{
        \tNullMsg \grmOr
        \txx \grmOr
        \cab{in}{\txM} \grmOr
        \cab{out}{\txM} \grmOr
        \cab{open}{\txM} \grmOr
        \txM.\txM'
    } \\
    \grmclass{\txW}{AMessageType }{ 
        \mbox{definition postponed to Fig.~\ref{fig:ma/types+rules}}
    } \\
    \grmclass{\txP}{AProcess}{
        \pNull \grmOr
        (\txPP \oI \txPQ) \grmOr
        \amb{\txM}{\txP} \grmOr
        \txM.\txP \grmOr
        \oB \txP \grmOr
        \tNu{\txx}{\txW}{\txP} \grmOr
    } \\
    \grmcont{
        \tOut \grmOr
        \tIn{\txP}
    } 
\end{pstgrammar}
\setlength{\arraycolsep}{1mm}
\labeledHline{Rewriting relation of \MA
    ( is standard defined in TR
    \cite[Fig.~12]{Jak+Wel:ShapeTypes-2009}):}


\vspace{-2mm}

\normalsize
\caption{Syntax and semantics of \TMA.}
\label{fig:ma/syntax+semantics}
\end{figure}
}

\newcommand{\FIGtmatypesrules}{
\begin{figure}[t]
\small
\labeledHeader{Syntax of \TMA types:}
\begin{pstgrammar}
    \grmclass{\txW}{AMessageType }{ \tAmb{\txT} \grmOr \tCap{\txT} } \\
    \grmclass{\txT}{AExchangeType}{ \tShh \grmOr \tExch } \\
    \grmeqclass{\txE}{AEnvironment}{ 
        \mapfin{\grmset{AName}}{\grmset{AMessageType}} } \\
\end{pstgrammar}
\labeledHline{Typing rules of \TMA:}



\vspace{-2mm}
\normalsize
\caption{Syntax of \TMA types and typing rules.}
\label{fig:ma/types+rules}
\end{figure}
}

\newcommand{\DEFtmawellscoped}{
\begin{definition}
Call  or   \defthis{well formed} when all of the following hold:
\begin{description}
\item[\rulename{(S1)}] , , and  are
    pairwise disjoint
\item[\rulename{(S2)}] for 
    
    in ,
    's are distinct and 
\item[\rulename{(S3)}] different binding occurrences of ``'' assign the
    same type to ``''
\item[\rulename{(S4)}]  assigns the same type to names which share a
    basic name
\end{description}
\end{definition}
}

Mobile Ambients (\MA), introduced by Cardelli and Gordon
\cite{Car+Gor:FoSSaCS-1998}, is a process calculus for representing process
mobility.
Processes are placed inside named bounded locations called \emph{ambients}
which form a tree hierarchy.
Processes can change the hierarchy and send messages to nearby processes.
Messages contain either ambient names or hierarchy change instructions.

\renewcommand{\infAxiom}[1]{#1}
\renewcommand{\infCondAxiom}[2]{#2 & \mbox{if} & #1}
\renewcommand{\infRule}[2]{#1 \,\Rightarrow\, #2}
\FIGtmasyntaxsemantics

Fig.~\ref{fig:ma/syntax+semantics} describes \MA process syntax.
Executing a capability consumes it and instructs the surrounding ambient
to change the hierarchy.
The capability ``'' causes moving into a sibling ambient
named , the capability ``'' causes moving out of
the parent ambient  and becoming its sibling, and
``'' causes dissolving the boundary of a child ambient
.
In capability sequences, the left-most capability will be executed first.

The constructors ``'', ``'', ``'', ``'', and
``'' have standard meanings.
Binders contain explicit type annotations (Sec.~\ref{sec:ma/system} below).
The expression  describes the process  running
inside ambient .
Capabilities can be communicated in messages.
 is a process that sends a -tuple of
messages.
 is a process that receives a -tuple of messages, substitutes
them for appropriate 's in , and continues as this new process.
Free and bound (basic) names are defined like in \metaS.
Processes that are -convertible are identified.
A substitution  is a finite function from names to messages and
its application to  is written .
Fig.~\ref{fig:ma/syntax+semantics} also describes structural equivalence and
semantics of \MA processes.
The only thing the semantics does with type annotations is copy them around.
We require all processes to be well-scoped w.r.t.\ conditions
\rulename{S1-3} from Sec.~\ref{sec:pi/calculus}, and the additional
condition \rulename{(S4)} that the same message type is assigned to
bound names with the same basic name.
Ambients and capabilities where  is not a single name, which the
presentation allows for simplicity, are inert and meaningless.

\begin{example}
\label{ex:ma/calculus}
In this example, packet ambient  delivers a
synchronization message to destination ambient  by following
instructions . 
As we have not yet properly defined message types, we only suppose
 for some .


\vspace{-4mm}
\small

\normalsize
\end{example}


\subsection{Types for Mobile Ambients (\TMA)}
\label{sec:ma/system}

An arity mismatch error, like in
   ``'',
can occur in polyadic \MA.
Another communication error can be encountered when a sender sends
a capability while a receiver expects a single name.
For example
    ``''
can rewrite to a meaningless ``''.
Yet another error happens when a process is to
execute a single name capability, like in ``''.
Processes which can never evolve to a state with any of the above
errors are called \emph{communication safe}.
A typed \MA introduced by Cardelli and Gordon
\cite{Car+Gor:POPL-1999}, which we name \TMA, verifies communication safety.

\renewcommand{\infAxiom}[1]{#1}
\renewcommand{\infRule}[2]{#1\mathbin{\Rightarrow}#2}
\FIGtmatypesrules

\TMA assigns an allowed communication topic to each ambient location and
ensures that processes respect the topics.
Fig.~\ref{fig:ma/types+rules} describes \TMA type syntax.
Exchange types, which describe communication topics, are assigned to
processes and ambient locations.
The type  indicates silence (no communication).
 indicates communication of -tuples of
messages whose -th member has the message type .
For  we write  which allows only
synchronization actions  and .
 is the type of an ambient where communication
described by  is allowed.
 describes capabilities whose execution can unleash
exchange  (by opening some ambient).
Environments assign message types to free names (via basic names).
Fig.~\ref{fig:ma/types+rules} also describes the \TMA
typing rules.
Types from conclusions not mentioned in the assumption can be arbitrary.
For example, the type of  can be arbitrary provided
 is well-typed.
It reflects the fact that the communication inside  does not
directly interact with 's outside.
Existence of some  and  such that  does not assign a
-type to any free name and  holds implies
that  is communication safe.

\begin{example}
\label{ex:ma/system}
Take  from Ex.~\ref{ex:ma/calculus},
, and
    , and
    .
We can see that  but, for example,
.  
\end{example}

\subsection{Instantiation of \metaS to \MA}
\label{sec:ma/instatiate}

\newcommand{\FIGtmaencoding}{
\begin{figure}[t]
\small
\vspace{-3mm}

\vspace{-3mm}
\renewcommand{\arraystretch}{1.2}

\vspace{-2mm}
\renewcommand{\arraystretch}{1}
\normalsize
\caption{Encoding of \TMA processes in \metaS.}
\label{fig:ma/processencoding}
\end{figure}
}

\newcommand{\PARinstma}{
\small

\normalsize
}

\newcommand{\EXtmainstatiate}{
    \setlength{\col}{8mm}
    \setlength{\row}{8mm}
    \small
    
    \normalsize
}

When we omit type annotations, add ``'' after output actions, and write capability prefixes always in a right
associative manner (like
    ``''), 
we see that the \MA syntax is included in the \metaS syntax.
The following set  instantiates \metaS to \MA.
\PARinstma
The  rule lets rewriting be done inside ambients.
It corresponds to the rule
    ``''.
Each communication prefix length has its own rule as in the case of the
-calculus.
 defines the calculus  and the type system .

Communication safety of  can be checked on an -type as follows.
Two edges with the same source labeled by  and
 with 
indicates an arity mismatch error (but only at active positions).
Every label containing  (introduced by a
substitution) indicates that a capability was sent instead of a name.
Moreover, an edge labeled with a name  at active position
indicates an execution of a single name capability.
A type of  not indicating any error proves 's safety.
Checking safety this way is easy.

\begin{wraptable}{r}{4cm}
    \vspace{-5mm}
    \centering
    \EXtmainstatiate
    \vspace{-15mm}
\end{wraptable}

\begin{fakedexample}
\label{ex:ma/instatiate}
    's equivalent of  from Ex.~\ref{ex:ma/calculus} is
    .
    Its principal -type is displayed on the right.
    Its root is  and other node names are omitted. 
    Checking the edge labels as described above easily proves 's
    safety.
    The edge labeled by  is not a communication error because 
    is input-bound in .

\end{fakedexample}

\subsection{Embedding of \TMA in \polyS}
\label{sec:ma/embedding}

\newcommand{\FIGtmaembedding}{
\begin{figure}[t]
\small
\labeledHeader{Extraction of types of bound names:}
    \vspace{1mm}
    1mm]
            \tNuEnv(\xa)  =  \txW & \mbox{iff} & 
            \txW\!=\!\tAmb{\txT} \!\land\!
            \txP\mbox{ has a subprocess }\tNu{\xa^i}{\txW}{\txP_0} 
    \end{array}
    
        \extypes = \{ \tiType \} \cup
        \{ \txT \such \tAmb{\txT} \in \rng{\SYMtiAll} \}
    \qquad
        \SYMnodeof = \invert{\SYMtypeof}
    
\begin{array}{l}
    \namesof{\txW} = \{ \xa \such \tiAll{\xa}=\txW \}
\qquad
    \allowedin{\txT} = \moves \cup \opens{\txT} \cup \comm{\txT}
\
\labeledHline{Construction of shape predicates:}

\vspace{-1mm}
\normalsize
\caption{Construction of \polyS type embedding.}
\label{fig:ma/embedding}
\end{figure}
}

Using the notation from Sec.\ref{sec:general/terminology} we have that
 is \MA,  is \TMA, predicates  are pairs , and 
's relation  is .
Moreover  is  which was introduced with  and 
in Sec.~\ref{sec:ma/instatiate}.
This section provides an embedding which
shows how to, for a given , , and , answer the question
 using .
We stress that it is primarily a theoretical embedding for proving greater
expressiveness which is not intended for use in practice.





An encoding  of \MA processes in \metaS, found in TR
    \cite[Fig.~14]{Jak+Wel:ShapeTypes-2009}, is
again almost an identity except for the following.
(1) Meaningless expressions allowed by \MA's syntax are translated using 
the special name , e.g.,
    ``''.
(2) The encoding erases type annotations which is okay because \MA's
rewriting rules only copy them around.
The type embedding below recovers type information by different means.
Prop.~\ref{thm:general/encoding+correct} holds in the given context.

As discussed in Sec.~\ref{sec:general/system}, we can not translate
 to a shape type with an equivalent meaning because
 is preserved under renaming of bound basic names.
Nevertheless this becomes possible when we specify the sets of allowed
input- and -bound basic names and their types.
These can be easily extracted from a given process .
An environment  (resp. ) from the top part of
Fig.~\ref{fig:ma/embedding} describes -bound (resp. input-bound)
basic names of .
The definition reflects that -bound names in typable processes can
only have -types.
For a given , , and  we construct the shape type
 such that  
iff
.
The construction needs to know which names are input-bound and thus they
are separated from the other names.
The well-scopedness rules S1-4 ensure that there is no ambiguity in
using only basic names to refer to typed names in a process.
The type information  (Fig.~\ref{fig:ma/embedding}, 2nd part)
collects what is needed to construct a shape type.
For  we define , ,
and  such that 
 describes types of all names in  and , and
 describes types of 's input-bound names, and 
is simply .

\begin{example}
    , , and  from the previous examples (Ex.~\ref{ex:ma/calculus} and
    Ex.~\ref{ex:ma/system}) give us  
     and we have:
\vspace{-2mm}
    \small
    
    \normalsize
\end{example}

The main idea of the construction of the shape type  from
 is that  contains exactly one node for every
exchange type of some ambient location, that is, one node for the
top-level type , and one node for  whenever 
is in .
The top-level type corresponds to the shape type root.
Each node corresponding to some  has self-loops which describe
all capabilities and communication actions which a process of the type
 can execute.
When  then every node would have a self-loop
labeled by ``'' because -capabilities can be
executed by any process.
On the other hand only the node corresponding to  would allow
``'' because only processes of type  can legally
execute it.
Finally, following an edge labeled with ``'' means entering .
Thus the edge has led to the node  that corresponds to .
In the above example, the shape graph would contain edges labeled with 
``'' from any node to .

\FIGtmaembedding

The construction starts by building the node set of a shape predicate
(Fig.~\ref{fig:ma/embedding}, 3rd part).
All the exchange types of ambient locations are gathered in the set
.
These types are put in bijective correspondence with the set .

\begin{example}
Our example gives 
.
Let us take  and define the bijections
such that 
     and
    .
\end{example}

The 4th part of Fig.~\ref{fig:ma/embedding} defines some auxiliary
functions.
The set  contains all basic names declared with the type
 by .  
The set  contains all \polyS action types which
describe (translations of) all capabilities and action prefixes which
are allowed to be legally executed by a process of the type .
The set  consists of three parts: ,
, and .
The action types in  describe all  capabilities
constructible from ambient basic names in .
The set does not depend on  because  capabilities can
be executed by any process.
The set  describe -capabilities 
which can be executed by a process of the type .
The second part of  describes names of the type
 which might be instantiated to some executable capabilities.
The set  describes communication actions which can be executed
by a process of the type .
Its first part describes output- and the second input-actions.
The auxiliary set  describes all messages of the type 
constructible from names in .

\begin{example}Relevant sets for our example are:
\small

\normalsize
\end{example}

The bottom part of Fig.~\ref{fig:ma/embedding} constructs the shape
graph  and the shape predicate  from
.
The first part of  describes self-loops of  which
describe actions allowed to be executed by a process of
.
The second part of  describe transitions among nodes.
Any edge labeled by ``'' always leads to
the node which corresponds to the exchange type allowed inside .

\begin{example}
\newcommand*{\RNodeLabel}{
    \begin{array}{l}
        \scriptstyle
        \cab{in}{\n{d}}  \oI
        \cab{out}{\n{d}} \oI
        \cab{in}{\n{p}}  \oI
        \cab{out}{\n{p}} \oI
        \sOut{\n{x}}     \oI
        \sIn{\n{x}}      \oI
    \\
        \scriptstyle
        \sOut{\sStar{\{
            \n{x},
            \cab{in}{\n{d}}, 
            \cab{in}{\n{p}}, 
            \cab{out}{\n{p}}, 
    \\
        \scriptstyle\qquad
            \cab{out}{\n{d}}, 
            \cab{open}{\n{d}}, 
            \cab{open}{\n{p}}
        \}}}
    \end{array}
}
\newcommand*{\ONodeLabel}{
    \begin{array}{llllll}
        \scriptstyle \cab{in}{\n{d}}   & \scriptstyle \mathop{\oI} &
        \scriptstyle \cab{out}{\n{d}}  & \scriptstyle \mathop{\oI} &
        \scriptstyle \cab{open}{\n{d}} & \scriptstyle \mathop{\oI}
    \\
        \scriptstyle \cab{in}{\n{p}}   & \scriptstyle \mathop{\oI} &
        \scriptstyle \cab{out}{\n{p}}  & \scriptstyle \mathop{\oI} &
        \scriptstyle \cab{open}{\n{p}} & \scriptstyle \mathop{\oI}
    \\
        \multicolumn{5}{l}{
           \scriptstyle 
           \n{x}          \hfill\mathop{\oI}\hfill 
           \sOut{}        \hfill\mathop{\oI}\hfill 
           \sIn{}         \hfill\mathop{\oI}\hfill 
           \amb{\n{p}}{}  \hfill\mathop{\oI}\hfill 
           \amb{\n{d}}{}
        }
    \end{array}
}

The resulting shape predicate  in our
example is as follows.
We merge edges with the same source and destination using ``''.

\small
\renewcommand{\arraystretch}{0.6}

\normalsize
\renewcommand{\arraystretch}{1.0}

\end{example}

Correctness of the translation is expressed by
Thm.~\ref{thm:ma/embedding+correct}.
The assumptions ensure that no -bound name is mentioned by
 or has a -type assigned by an annotation.
Here we just claim that  is always an -type.

\begin{theorem}\label{thm:ma/embedding+correct}
    Let  and .
    Then it holds that
     if and only if 
    .
\end{theorem}

\subsection{Conclusions}
\label{sec:ma/conclusion}

We embedded \TMA's typing relation in 
(Sec.~\ref{sec:ma/embedding}) and showed how to recognize communication
safety in  directly (Sec.~\ref{sec:ma/instatiate}).
The type  constructed in Sec.~\ref{sec:ma/embedding} can
also be used to prove the safety of .
But then, it follows from the properties of principal types, that the safety
of  can be recognized directly from its principal -type. 
Thus any process proved safe by \TMA can be proved safe by  on
its own.
    
Some processes are recognized safe by  but not by \TMA.
For example, 
    ``'' 
is not typable in \TMA but it is trivially safe.
Another examples show polymorphic abilities of shape types,
for example, the  process
\vspace{-2mm}

can be proved safe by \polyS but it constitutes a challenge for \TMA-like
non-polymorphic type systems.
We are not aware of other type systems for \MA and its successors that can
handle this kind of polymorphism.

The expressiveness of shape types  from
Sec.~\ref{sec:ma/embedding} can be improved.
In subsequent work \cite{Car+Ghe+Gor:ICALP-1999}, Cardelli, Ghelli, and
Gordon define a type system which can ensure that some ambients stay
immobile or that their boundaries are never dissolved.
This can be achieved easily by removing appropriate self loops of nodes.
We can also assign nodes to (groups of) ambients instead of exchange
types. 
This gives us similar possibilities as another \TMA successor
\cite{Car+Ghe+Gor:ICTCS-2000}.
Moreover, we can use shape type polymorphism to express
location-dependent properties of ambients, like that ambient  can be
opened only inside ambient .

\section{Conclusions and Future Work}
\label{sec:conclusion}

We discussed already the contributions (Sec.~\ref{sec:contributions},
\ref{sec:star/discussion}).
Conclusions for the embeddings were given separately
(Sec.~\ref{sec:pi/conclusion}, \ref{sec:ma/conclusion}).
Future work is as follows.
For extensions, priorities are better handling of choice (e.g., because of
its use in biological system modeling), and handling of
\textbf{rec} which is in many calculi more expressive
than replication and better describes recursive behavior.
Moreover we would like to generalize actions so that calculi
with structured messages, like the Spi calculus
    \cite{Aba+Gor:IAC-1999}, can be handled.
For applications, we would like to (1) relate shape types with 
other systems which also use graphs to represent types
    \cite{Yoshida:FSTTCS-1996,Konig:CONCUR-1999},
and (2) to study the relationship between shape types and session types
\cite{Hon:CONCUR-1993}.

\bibliography{polystar-comparison}

\end{document}
