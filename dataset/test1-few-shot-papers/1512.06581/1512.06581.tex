\documentclass[10pt,twocolumn,twoside]{IEEEtran}
\usepackage{mathrsfs}
\usepackage{amsfonts}
\usepackage{bbm}
\usepackage{amsthm,amssymb}
\usepackage{multirow}
\usepackage{array}
\usepackage{graphicx}
\usepackage{caption}
\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage{amsmath}
\usepackage[english]{babel}
\usepackage{color}
\usepackage{subfigure}
\usepackage{boxedminipage}
\usepackage{multicol}

\newtheorem{definition}{Definition}
\newtheorem{theorem}{Theorem}

\begin{document}

\title{Generating Searchable Public-Key Ciphertexts with Hidden Structures for Fast Keyword Search}

\author{
Peng Xu, \IEEEmembership{Member, IEEE,}
Qianhong Wu,  \IEEEmembership{Member, IEEE,} 
Wei Wang, \IEEEmembership{Member, IEEE,} 
\\ Willy Susilo, \IEEEmembership{Senior Member, IEEE,}
Josep Domingo-Ferrer, \IEEEmembership{Fellow, IEEE,}
Hai Jin, \IEEEmembership{Senior Member, IEEE}
\IEEEcompsocitemizethanks{\IEEEcompsocthanksitem P. Xu and H. Jin are with Services Computing Technology and System Lab, Cluster and Grid Computing Lab, School of Computer Science and Technology, Huazhong University of Science and Technology, Wuhan, China. E-Mail: \{xupeng, hjin\}@mail.hust.edu.cn.}
\IEEEcompsocitemizethanks{\IEEEcompsocthanksitem Q. Wu is with the School of Electronics and Information Engineering, Beihang Univerisity, Beijing, China, and with the State Key Laboratory of Information Security, Institute of Information Engineering, Chinese Academy of Sciences, Beijing, China. E-mail: qhwu@xidian.edu.cn.}
\IEEEcompsocitemizethanks{\IEEEcompsocthanksitem W. Wang is with Cyber-Physical-Social Systems Lab, School of Computer Science and Technology, Huazhong University of Science and Technology, Wuhan, China. E-Mail: viviawangww@gmail.com.}
\IEEEcompsocitemizethanks{\IEEEcompsocthanksitem W. Susilo is with Centre for Computer and Information Security Research, School of Computer Science and Software Engineering, University of Wollongong, Australia. E-Mail: wsusilo@uow.edu.au.}
\IEEEcompsocitemizethanks{\IEEEcompsocthanksitem J. Domingo-Ferrer is with Universitat Rovira i Virgili, Department of Computer Engineering and Mathematics, UNESCO Chair in Data Privacy, 43007, Tarragona, Catalonia. E-Mail: josep.domingo@urv.cat.}
}

\IEEEcompsoctitleabstractindextext{
\begin{abstract}
Existing semantically secure public-key searchable encryption schemes take search time linear with the total number of the ciphertexts. This makes retrieval from large-scale databases prohibitive. To alleviate this problem, this paper proposes \emph{Searchable Public-Key Ciphertexts with Hidden Structures} (SPCHS) for keyword search as fast as possible without sacrificing semantic security of the encrypted keywords. In SPCHS, all keyword-searchable ciphertexts are structured by hidden relations, and with the search trapdoor corresponding to a keyword, the minimum information of the relations is disclosed to a search algorithm as the guidance to find all matching ciphertexts efficiently. We construct a simple SPCHS scheme from scratch in which the ciphertexts have a hidden star-like structure. We prove our scheme to be semantically secure based on 
the decisional bilinear 
Diffie-Hellman assumption in the Random Oracle (RO) model. The search 
complexity of our scheme is dependent on \emph{the actual number of the ciphertexts containing the queried keyword}, rather than the number of all ciphertexts. Finally, we present a generic SPCHS construction from anonymous identity-based encryption and \emph{collision-free full-identity malleable} Identity-Based Key Encapsulation Mechanism (IBKEM) with anonymity. We illustrate two collision-free full-identity malleable IBKEM instances, which are semantically secure and anonymous, respectively, in the RO and standard models. The latter instance enables us to construct an SPCHS scheme with semantic security in the standard model.
\end{abstract}

\begin{IEEEkeywords} 
Public-key searchable encryption, semantic security, identity-based key encapsulation mechanism,
identity based encryption
\end{IEEEkeywords}}

\maketitle \IEEEdisplaynotcompsoctitleabstractindextext
\IEEEpeerreviewmaketitle

\section{Introduction}

\IEEEPARstart{P}{ublic-key} encryption with keyword search (PEKS), introduced by Boneh \emph{et al.} in \cite{BCO04}, has the advantage that anyone who knows the receiver's public key can upload keyword-searchable ciphertexts to a server. The receiver can delegate the keyword search to the server. More
specifically, each sender separately encrypts a file and its extracted keywords and sends the resulting ciphertexts to a server; when the receiver wants to retrieve the files containing a specific keyword, he delegates a keyword search trapdoor to the server; the server finds the encrypted files containing the queried keyword without knowing the original files or the keyword itself, and returns the corresponding encrypted files to the receiver; finally, the receiver decrypts these encrypted files\footnote{Since the encryption of the original files can be separately processed with an independent public-key encryption scheme as in \cite{BCO04}, we only describe the encryption of the keywords (unless otherwise
clearly stated in the paper).}. The authors of PEKS \cite{BCO04} also presented semantic security against chosen keyword attacks (SS-CKA) in the sense that the server cannot distinguish the ciphertexts of the keywords of its choice before observing the corresponding keyword search trapdoors. It seems an appropriate security notion, especially if the keyword space has no high min-entropy. Existing semantically secure PEKS schemes take search time linear with the total number of all ciphertexts. This makes retrieval from large-scale databases prohibitive. Therefore, more efficient searchable public-key encryption is crucial for practically deploying PEKS schemes.

One of the prominent works to accelerate the search over encrypted keywords in the public-key setting is deterministic
encryption introduced by Bellare \emph{et al}. in \cite{BBN07}. An encryption scheme is deterministic if the encryption algorithm is deterministic. Bellare \emph{et al}. \cite{BBN07} focus on enabling search over encrypted keywords to be
as efficient as the search for unencrypted keywords, such that a ciphertext containing a given keyword can be retrieved
in time complexity logarithmic in the total number of all ciphertexts. This is reasonable because the encrypted keywords
can form a tree-like structure when stored according to their binary values. However, deterministic encryption has two inherent limitations. First, keyword privacy can be guaranteed only
for keywords that are \emph{a priori} hard-to-guess by the adversary (\emph{i.e.}, keywords with high
min-entropy to the adversary); second, certain information of a message leaks inevitably via the ciphertext of
the keywords since the encryption is deterministic. Hence, deterministic encryption is only applicable in special scenarios.

\subsection{Our Motivation and Basic Ideas}

We are interested in providing highly efficient search performance without
sacrificing semantic security in PEKS. Observe that a keyword space is usually of no high min-entropy in many
scenarios. Semantic security is crucial to guarantee keyword privacy in such
applications. Thus the linear search complexity of existing schemes is the major obstacle to their adoption.
Unfortunately, the linear complexity seems to be inevitable because the server has to scan and test each ciphertext, due to the fact that these ciphertexts (corresponding to the same keyword or not) are indistinguishable to the server.

\begin{figure}
\centering
\includegraphics [width=0.48\textwidth,height=0.25\textheight]{Mainidea}
\caption{Hidden star-like structure formed by keyword searchable ciphertexts. 
(The dashed arrows denote the hidden relations.  denotes the searchable ciphertext of keyword .)}\label{F.Mainidea}
\end{figure}

A closer look shows that there is still space to improve search performance in PEKS without sacrificing semantic security if one can organize the ciphertexts with elegantly designed but hidden relations. Intuitively, if the keyword-searchable ciphertexts have a hidden star-like structure, as shown in Figure \ref{F.Mainidea}, then search over ciphertexts containing a specific keywords may be accelerated. Specifically, suppose all ciphertexts of the same keyword form a chain by the correlated hidden relations, and also a hidden relation exists from a public \emph{Head} to the first ciphertext of each chain. With a keyword search trapdoor and the \emph{Head}, the server seeks out the first matching ciphertext via the corresponding relation from the \emph{Head}. Then another relation can be disclosed via the found ciphertext and guides the searcher to seek out the next matching ciphertext. By carrying on in this way, all matching ciphertexts can be found. Clearly, the search time depends on the actual number of the ciphertexts containing the queried keyword, rather than on the total number of all ciphertexts.

To guarantee appropriate security, the hidden star-like structure should 
preserve the semantic security of keywords, which indicates that partial relations are disclosed only when the corresponding keyword search trapdoor is known. Each sender should be able to generate the keyword-searchable ciphertexts with the hidden star-like structure by the receiver's public-key; the server having a keyword search trapdoor should be able to disclose partial relations, which is related to all matching ciphertexts. Semantic security is preserved 1) if no keyword search trapdoor is
known, all ciphertexts are indistinguishable, and no information is leaked about the structure, and 2) given a keyword search trapdoor, only the corresponding relations can be disclosed, and the matching ciphertexts leak no information about the rest of ciphertexts, except the fact that the rest do not contain the queried keyword.

\subsection{Our Work}

We start by formally defining the concept of Searchable Public-key Ciphertexts with Hidden Structures (SPCHS) and its semantic security. In this new concept, keyword-searchable ciphertexts with their hidden structures can be generated in the public key setting; with a keyword search trapdoor, partial relations can be disclosed to guide the discovery of all matching ciphertexts. Semantic security is defined for both the keywords and the hidden structures. It is worth noting 
that this new concept and its semantic security are suitable for keyword-searchable ciphertexts with any kind of hidden structures. In contrast, the concept of traditional PEKS does not contain any hidden structure among the PEKS ciphertexts; correspondingly, its semantic security is only defined for the keywords. 

Following the SPCHS definition, we construct a simple SPCHS from scratch in the random oracle (RO) model. The scheme generates keyword-searchable ciphertexts with a hidden star-like structure. The search performance mainly depends on the actual number of the ciphertexts containing the queried keyword. For security, the scheme is proven semantically secure based on the Decisional Bilinear Diffie-Hellman (DBDH) assumption \cite{BB04} in the RO model.

We are also interested in providing a generic SPCHS construction to generate keyword-searchable ciphertexts with a hidden star-like structure. Our generic SPCHS is inspired by several interesting observations on Identity-Based Key Encapsulation Mechanism (IBKEM). In IBKEM, a sender encapsulates a key  to an intended receiver . Of course, receiver  can decapsulate and obtain , and the sender knows that receiver  will obtain . However, a non-intended receiver  may also try to decapsulate and obtain . We observe that, (1) it is usually the case that  and  are independent of each other from the view of the receivers, and (2) in some IBKEM the sender may also know  obtained by receiver . We refer to the former property as \emph{collision freeness} and to the latter as \emph{full-identity malleability}. An IBKEM scheme is said to be \emph{collision-free full-identity malleable} if it possesses both properties. 

We build a generic SPCHS construction with Identity-Based Encryption (IBE) and collision-free full-identity malleable IBKEM. The resulting SPCHS can generate keyword-searchable ciphertexts with a hidden star-like structure. Moreover, if both the underlying IBKEM and IBE have semantic security and anonymity (\emph{i.e.} the privacy of receivers' identities), the resulting SPCHS is semantically secure. As there are known IBE schemes \cite{BW06,G06,AG09,D10} in both the RO model and the standard model, an SPCHS construction is reduced to collision-free full-identity malleable IBKEM with anonymity. In 2013, Abdalla \emph{et al.} proposed several IBKEM schemes to construct Verifiable Random Functions\footnote{VRF behaves like a pseudo-random function but one can verify that the output was
pseudo-random.} (VRF) \cite{ACF13}. We show that one of these IBKEM schemes is anonymous and collision-free full-identity malleable in the RO model. In \cite{FHPS13}, Freire \emph{et al.}  utilized the ``approximation'' of multilinear maps \cite{GGH13} to construct a standard-model version of Boneh-and-Franklin (BF) IBE scheme \cite{BF01}. We transform this IBE scheme into a collision-free full-identity malleable IBKEM scheme with semantic security and anonymity in the standard model. Hence, this new IBKEM scheme allows us to build SPCHS schemes secure in the standard model with the same search performance as the previous SPCHS construction 
from scratch 
in the RO model.

\subsection{Other Applications of Collision-Free Full-Identity Malleable IBKEM}

We note that collision-free full-identity malleable IBKEM is of independent interest. In addition to being a building block for the generic SPCHS construction, it may also find other applications, as outlined in the sequel.

\textbf{Batch identity-based key distribution.} A direct application of collision-free full-identity malleable IBKEM is to achieve batch identity-based key distribution. In such an application, a sender would like to distribute different secret session keys to multiple receivers so that each receiver can only know the session key to himself/herself. With collision-free full-identity malleable IBKEM, a sender just needs to broadcast an IBKEM encapsulation in the identity-based cryptography setting, e.g., encapsulating a session key  to a single user . According to the collision-freeness of IBKEM, each receiver  can decapsulate and obtain a different key  with his/her secret key in the identity based crypto-system. Due to the full-identity malleability, the sender knows the decapsulated keys of all the receivers. In this way, the sender efficiently shares different session keys with different receivers, at the cost of only a single encapsulation and one pass of communication.

\textbf{Anonymous identity-based broadcast encryption.}  A slightly more complicated application is anonymous identity-based broadcast encryption with efficient decryption. An analogous application was proposed respectively by Barth \emph{et al.} \cite{BBW06} and Libert \emph{et al.} \cite{LPQ12} in the traditional public-key setting. With collision-free full-identity malleable IBKEM, a sender generates an identity-based broadcast ciphertext , , , , ,  where  and  are two IBKEM encapsulations,  is the encapsulated key in  for receiver ,  is the encapsulated key in  for receiver , and  is the symmetric-key encryption of file  using the encapsulated key . In this ciphertext, the encapsulated key  is not used to encrypt anything. Indeed, it is an index to secretly inform receiver  on which part of this ciphertext belongs to him. To decrypt the encrypted file , receiver  decapsulates and obtains  from , finds out  by matching , and finally extracts  with the decapsulated key  from . It can be seen that the application will work if the IBKEM is collision-free full-identity malleable. It preserves the anonymity of receivers if the IBKEM is anonymous. Note that trivial anonymous broadcast encryption suffers decryption cost linear with the number of the receivers. In contrast, our anonymous identity-based broadcast encryption enjoys constant decryption cost, plus logarithmic complexity to search the matching index in a set  organized by a certain partial order, e.g., a dictionary order according to their binary representations.

\subsection{Related Work}

Search on encrypted data has been extensively investigated in recent years. From a cryptographic perspective, the
existing works fall into two categories, {\em i.e.}, symmetric searchable encryption \cite{CGK06} and public-key
searchable encryption.

Symmetric searchable encryption is occasionally referred to as symmetric-key encryption with keyword search (SEKS).
This primitive was introduced by Song \emph{et al.} in \cite{SWP00}. Their instantiated scheme takes search time linear with the size of the database. A number of efforts \cite{G03,BC04,AKSX04,CM05,BCLN09} follow this research line and
refine Song \emph{et al.}'s original work. The SEKS scheme due to Curtmola \emph{et al}. \cite{CGK06} has been proven to be semantically secure against an
adaptive adversary. It allows the search to be processed in logarithmic time, although the keyword search trapdoor has
length linear with the size of the database. In addition to the above efforts devoted to either provable security or
better search performance, attention has recently been paid to achieving versatile SEKS schemes as follows. The works
in \cite{CGK06,BDDY08} extend SEKS to a multi-sender scenario. The work in \cite{LWWCRL10} realizes fuzzy keyword
search in the SEKS setting. The work in \cite{WBDS04} shows practical applications of SEKS and employs it to realize
secure and searchable audit logs. Chase \emph{et al.} \cite{CK10} proposed to encrypt structured data and a secure method to search these data. To support the dynamic update of the encrypted data, Kamara \emph{et al.}  proposed the dynamic searchable symmetric encryption in \cite{KPR12} and further enhanced its security in \cite{KP13} at the cost of large index. The very recent work \cite{CJJJKRS14} due to Cash \emph{et al.} simultaneously achieves strong security and high efficiency.

Following the seminal work on PEKS, Abdalla\emph{ et al}. \cite{ABC05} fills some gaps w.r.t. consistency for PEKS
and deals with the transformations among primitives related to PEKS. Some efforts have also
been devoted to make PEKS versatile. The work of this kind includes conjunctive search
\cite{PKL04,GSW04,BKM05,HL07,RT07,BSS08}, range search \cite{BCP06,SBC07,BW07}, subset search \cite{BW07}, time-scope search \cite{ABC05,DMR04}, similarity search \cite{CMWYZ10}, authorized search \cite{TC11,INH11}, equality test between heterogeneous ciphertexts \cite{YTHW10}, and fuzzy keyword search \cite{XHW13}. In addition, Arriaga et al. \cite{ATR14} proposed a PEKS scheme to keep the privacy of keyword search trapdoors.

In the above PEKS schemes, the search complexity takes time linear with the number of all ciphertexts. In [24],  an oblivious generation of keyword search trapdoor is to  maintain the privacy of the keyword against a curious trapdoor generation. A chain-like structure is described to speed up the search on encrypted keywords. One may note that the chain in \cite{CKRS09} cannot be fully hidden to the server and leaks the frequency of the keywords (see Supplemental Materials A for details). To realize an efficient keyword search, Bellare \emph{et al.} \cite{BBN07} introduced
deterministic public-key encryption (PKE) and formalized a security notion ``as strong as possible'' (stronger than
onewayness but weaker than semantic security). A deterministic searchable encryption scheme allows efficient keyword search as if the keywords were not
encrypted. Bellare \emph{et al.} \cite{BBN07} also presented a deterministic PKE scheme (\emph{i.e.}, RSA-DOAEP) and a
generic transformation from a randomized PKE to a deterministic PKE in the random oracle model. Subsequently,
deterministic PKE schemes secure in the standard model were independently proposed by Bellare \emph{et al.}
\cite{BFNR08} and Boldyreva \emph{et al.} \cite{BFN08}. The former uses general complexity assumptions and the
construction is generic, while the latter exploits concrete complexity assumptions and has better efficiency. Brakerski \emph{et al.} \cite{BS11} proposed the deterministic PKE schemes with better security, although these schemes are still not semantically secure. So far, deterministic PEKS schemes can guarantee semantic security only if the keyword space has a high
min-entropy. Otherwise, an adversary can extract the encrypted keyword by a simple encrypt-and-test attack. Hence, deterministic PEKS schemes are applicable to applications where the keyword space is of a high min-entropy. 

\subsection{Organization of this article}
The remaining sections are as follows. Section \ref{S.SPCHS.Concept} defines SPCHS and its semantic security. A simple SPCHS scheme is constructed in Section \ref{S.SPCHS.Instance}. A general construction of SPCHS is given in Section \ref{S.SPCHS.Generic}. Two collision-free full-identity malleable IBKEM schemes, respectively in the RO and standard models, are introduced in Section \ref{S.IBKEM.Instances}. Section \ref{S.Conclusion} concludes this paper. 

\section{Modeling SPCHS}\label{S.SPCHS.Concept}

We first explain intuitions behind SPCHS. We describe a hidden structure formed by ciphertexts as , where  denotes the set of all ciphertexts,  denotes the hidden relations among , and  denotes the public parts. In case there is more than one hidden structure formed by ciphertexts, the description of multiple hidden structures formed by ciphertexts can be , where . Moreover, given  and  except  (where ), one can neither learn anything about  nor decide whether a ciphertext is associated with  or .

In SPCHS, the encryption algorithm has two functionalities. One is to encrypt a keyword, and the other is to generate a hidden relation, which can associate the generated ciphertext to the hidden structure. Let  be the hidden structure. The encryption algorithm must take  as input, otherwise the hidden relation cannot be generated since  does not contain anything about the hidden relations. At the end of the encryption procedure, the  should be updated since a hidden relation is newly generated (but the specific method to update  relies on the specific instance of SPCHS). In addition, SPCHS needs an algorithm to initialize  by taking the master public key as input, and this algorithm will be run before the first time to generate a ciphertext. With a keyword search trapdoor, the search algorithm of SPCHS can disclose partial relations
to guide the discovery of the ciphertexts containing the queried keyword with the hidden structure. 

\begin{definition}[SPCHS]\label{D.SPCHS.Concept}
SPCHS consists of five algorithms:
\begin{itemize}
\item : Take as input a security parameter  and a keyword space , and probabilistically output a pair of master public-and-secret keys , where  includes the keyword space  and the ciphertext space .

\item : Take as input , and probabilistically initialize a hidden structure by outputting its private and public parts .

\item : Take as inputs , a keyword  and a hidden structure's private part , and probabilistically output a keyword-searchable ciphertext  of keyword  with the hidden structure, and update .

\item : Take as inputs  and a keyword , and output a keyword search trapdoor  of .

\item : Take as inputs , a hidden structure's public part , all keyword-searchable ciphertexts  and a keyword search trapdoor  of keyword , disclose partial relations to guide finding out the ciphertexts containing keyword  with the hidden structure.
\end{itemize}
An SPCHS scheme must be consistent in the sense that given any keyword search trapdoor  and any hidden structure's public part , algorithm  finds out all ciphertexts of keyword  with the hidden structure .
\end{definition}

In the application of SPCHS, a receiver runs algorithm  to set up SPCHS. Each sender uploads the public part of his hidden structure and keyword-searchable ciphertexts to a server, respectively by algorithms  and . Algorithm  allows the receiver to delegate a keyword search trapdoor to the server. Then the server runs algorithm  for all senders' structures to find out the ciphertexts of the queried keyword.

The above SPCHS definition requires each sender to maintain the private part of his hidden structure for algorithm . A similar requirement appears in symmetric-key encryption with keyword search (SEKS) in which each sender is required to maintain a secret key shared with the receiver. This implies interactions via authenticated confidential channels before a sender encrypts the keywords to the receiver in SEKS. In contrast,  each sender in SPCHS just generates and maintains his/her private values locally, i.e., without requirement of extra secure interactions before encrypting keywords. 

In the general case of SPCHS, each sender keeps his/her private values . We could let each sender be stateless by storing his/her  in encrypted form at a server and having each sender download and re-encrypt his/her  for each update of . A similar method also has been suggested by \cite{CJJJKRS14}.

The semantic security of SPCHS is to resist adaptively chosen keyword and structure attacks (SS-CKSA). In this security notion, a probabilistic polynomial-time (PPT) adversary is allowed to know all structures' public parts, query the trapdoors for adaptively chosen keywords, query the private parts of adaptively chosen structures, and query the ciphertexts of adaptively chosen keywords and structures (including the keywords and structures which the adversary would like to be challenged). The adversary will choose two challenge keyword-structure pairs. The SS-CKSA security means that for a ciphertext of one of two challenge keyword-structure pairs, the adversary cannot determine which challenge keyword or which challenge structure the challenge ciphertext corresponds to, provided that the adversary does not know the two challenge keywords' search trapdoors and the two challenge structures' private parts.

\begin{definition}[SS-CKSA Security]\label{D.SPCHS.Security}
Suppose there are at most  hidden structures. An SPCHS scheme is SS-CKSA secure,
if any PPT adversary  has only a negligible advantage   to win in the following SS-CKSA game:

\begin{itemize}
\item \textbf{Setup Phase}: A challenger sets up the SPCHS scheme by running algorithm  to generate a pair of master public-and-secret keys , and initializes  hidden structures by running algorithm   times (let  be the set of all public parts of these  hidden structures.); finally the
challenger sends  and  to .
\item \textbf{Query Phase 1}:  adaptively issues the following queries multiple times.
	\begin{itemize}
	 \item Trapdoor Query : Taking as input a keyword , the challenger outputs the keyword search trapdoor of keyword ;
	\item Privacy Query : Taking as input a hidden structure's public part , the challenger outputs the corresponding private part of this structure;
	\item Encryption Query : Taking as inputs a keyword  and a hidden structure's public part , the challenger outputs an SPCHS ciphertext of keyword  with the hidden structure .
     \end{itemize}
\item \textbf{Challenge Phase}:  sends two challenge keyword-and-structure pairs  and  to the challenger; The challenger randomly chooses , and sends a challenge ciphertext  of keyword  with the hidden structure  to .
\item \textbf{Query Phase 2}: This phase is the same as \textbf{Query Phase 1}. Note that in \textbf{Query Phase 1} and \textbf{Query Phase 2},  cannot query the corresponding private parts both of  and  and the keyword search trapdoors both of  and .
\item \textbf{Guess Phase}:  sends a guess  to the challenger. We say that  wins if . And let  be the advantage of  to win in the above game.
\end{itemize}
\end{definition}

A weaker security definition of SPCHS is the selective-keyword security. We refer to this weaker security notion as SS-sK-CKSA security, and the corresponding attack game as SS-sK-CKSA game. In this attack game, the adversary  chooses two challenge keywords before the SPCHS scheme is set up, but the adversary still adaptively chooses two challenge hidden structures at . Let  denote the advantage of adversary  to win in this game.

\section{A Simple SPCHS Scheme from Scratch}\label{S.SPCHS.Instance}

Let }\leftarrow \Re\gamma\Re\mathbb{G}\mathbb{G}_1qg\mathbb{G}\hat{e}:\mathbb{G}\times\mathbb{G} \rightarrow
\mathbb{G}_1\hat{e}(g^a,g^b)=\hat{e}(g,g)^{ab}(a,b)\overset{\ and 
is a generator of . Let  be an efficient bilinear map generator that takes as input a security
parameter  and probabilistically outputs . Let keyword space . 

A simple SPCHS scheme secure in the random oracle model is constructed as follows.

\begin{itemize}
\item : Take as input  and the keyword space , compute , pick }\leftarrow \mathbb{Z}_q^*P=g^sH: \mathcal{W}\rightarrow \mathbb{G}\mathcal{C}\subseteq\mathbb{G}_1\times\mathbb{G}\times\mathbb{G}_1\mathbf{PK}=(q,\mathbb{G},\mathbb{G}_1,g,\hat{e},P,H,\mathcal{W},\mathcal{C})\mathbf{SK}=s\mathbf{StructureInitialization}(\mathbf{PK})\mathbf{PK}u\overset{\, and initialize a hidden structure by outputting a pair of private-and-public parts . Note that  here is a variable list formed as , which is initialized as .

\item : Take as inputs , a keyword , a hidden structure's private part , pick }{\leftarrow}\mathbb{Z}_q^*(W,Pt[u,W])W\mathbf{Pri}(W,Pt[u,W]\overset{\ to , and output the keyword-searchable ciphertext ;
\item Otherwise, pick }{\leftarrow}\mathbb{G}_1C=(Pt[u,W],g^r,\hat{e}(P,H(W))^r\cdot R)Pt[u,W]=RC\mathbf{Trapdoor}(\mathbf{SK},W)\mathbf{SK}W\in\mathcal{W}T_W=H(W)^sW\mathbf{StructuredSearch}(\mathbf{PK},\mathbf{Pub},\mathbb{C},T_W)\mathbf{PK}\mathbf{Pub}\mathbb{C}\mathbb{C}[i]\mathbb{C}(\mathbb{C}[i,1],\mathbb{C}[i,2],\mathbb{C}[i,3])\in\mathbb{G}_1\times\mathbb{G}\times\mathbb{G}_1T_WW\mathbb{C}^\prime=\phiPt^\prime=\hat{e}(\mathbf{Pub},T_W)\mathbb{C}[i]\mathbb{C}[i,1]=Pt^\prime\mathbb{C}[i]\mathbb{C}^\prime\mathbb{C}^\primePt^\prime=\hat{e}(\mathbb{C}[i,2],T_W)^{-1}\cdot\mathbb{C}[i,3]\mathbf{StructuredSearch}(\mathbf{PK},\mathbf{Pub},\mathbb{C},T_{W_i})\hat{e}(P,H(W_i))^u\hat{e}(\mathbf{Pub},T_{W_i})\hat{e}(P,H(W_i))^u(\hat{e}(P,H(W_i))^u,g^r,\hat{e}(P,H(W_i))^r\cdot Pt[u,W_i])Pt[u,W_i]\hat{e}(g^r,T_{W_i})^{-1}\cdot\hat{e}(P,H(W_i))^r\cdot Pt[u,W_i]Pt[u,W_i](Pt[u,W_i],g^r,\hat{e}(P,H(W_i))^r\cdot R)W_iRri\in[1,L]Pt[u,W_i]W_iRW_i\mathbf{StructuredSearch}Pt^\primePt^\primeH\mathbf{StructuredEncryption}\mathbf{StructuredSearch}Pt^\primeHkk\mathbf{BGen}(1^k)\mathbf{BGen}(1^k)=(q,\mathbb{G},\mathbb{G}_1,g,\hat{e})\mathcal{B}(g^a,g^b,g^c,\hat{e}(g,g)^{abc})(g^a,g^b,g^c,\hat{e}(g,g)^y)(a,b,c,y)\overset{\. Let   be the advantage of algorithm  to solve the DBDH problem. We say that the DBDH assumption holds in , if the advantage  is negligible in the parameter .
\end{definition}

In the security proof, we prove that if there is an adversary who can break the SS-CKSA security of the above SPCHS instance in the RO model, then there is an algorithm which can solve the DBDH problem in . Formally we have Theorem \ref{T.SPCHS.Instance.Security} whose proof can be found in Supplemental Materials C.

\begin{theorem}\label{T.SPCHS.Instance.Security}
Let the hash function  be modeled as the random oracle . Suppose there are at most  hidden structures, and a PPT adversary  wins in the SS-CKSA game of the above SPCHS instance with advantage , in which
 makes at most  queries to oracle  and at most  queries to oracle . Then there is a PPT algorithm  that solves the
DBDH problem in  with advantage
 where  is the base of natural logarithms.
\end{theorem}

\textbf{Forward and Backward Security.} Even in the case that a sender 
gets his local privacy  compromised, SPCHS still offers forward security. This means that the existing hidden structure of ciphertexts stays confidential, since the local privacy only contains the relationship of the new generated ciphertexts. To offer backward security with SPCHS, the sender can initialize a new structure by algorithm  for the new generated ciphertexts. Because the new structure is independent of the old one, the compromised local privacy will not leak the new generated structure.

\textbf{Search Complexity.} All keyword-searchable ciphertexts can be indexed by their first parts' binary bits. Assume that there are in total  ciphertexts from  hidden structures, and the -th hidden structure contains  ciphertexts of keyword . With the -th hidden structure, the search complexity is . For all hidden structures, the sum search complexity is , where . Since  and , we have that . Thus the above SPCHS instance allows a much more efficient search than existing PEKS schemes, which have  search complexity.

One may note that SPCHS loses its significant advantage in search performance compared with PEKS if  holds. However, this special case seldom happens. In practice, a sender will extract several keywords from 
each of his files. So we usually have   even if each sender only has one file. In addition, most related works on SEKS and PEKS assume that each file has several keywords.  

\textbf{Experiment.} We coded our SPCHS scheme, and tested the time cost of algorithm  to execute its cryptographic operations for different numbers of matching ciphertexts. We also coded the PEKS scheme \cite{BCO04}. Table \ref{T.Parameters} shows the system parameters including hardware, software and the chosen elliptic curve. Assume there are in total  searchable ciphertexts. PEKS takes about 53.8 seconds search time per keyword, since it must test all ciphertexts for each search. 
Figure \ref{F.Result} shows the experimental results of SPCHS. It is clear that the time cost of SPCHS is linear with the number of matching ciphertexts, whereas for PEKS it is linear with 
the number of total ciphertexts. Hence, SPCHS is much more efficient than PEKS. 

\begin{table}
\centering
\caption{System parameters}\label{T.Parameters}
\begin{tabular}{|c|c|c|}
\hline
Hardware & \multicolumn{2}{c|}{Intel CPU
	E5300 @ 2.60GHz}
\\ \hline OS and compiler & \multicolumn{2}{c|}{Win XP and
Microsoft VC++ 6.0}
\\ \hline Program library & \multicolumn{2}{c|}{MIRACL version 5.4.1}
\\ \hline \multicolumn{3}{|c|}{Parameters of bilinear map}
\\ \hline Elliptic curve & \multicolumn{2}{c|}{}
\\ \hline Pentanomial basis & \multicolumn{2}{c|}{}
\\ \hline Base field:  & \multicolumn{2}{c|}{}
\\ \hline A & \multicolumn{2}{c|}{1}
\\ \hline B & \multicolumn{2}{c|}{1}
\\ \hline Group order:  & \multicolumn{2}{c|}{}
\\ \hline a & \multicolumn{2}{c|}{315}
\\ \hline b & \multicolumn{2}{c|}{301}
\\ \hline c & \multicolumn{2}{c|}{287}
\\ \hline \multicolumn{3}{|l|}{The default unit is decimal.}
\\ \hline
\end{tabular}
\end{table}

\begin{figure}
\centering
\includegraphics[width=0.5\textwidth,height=0.195\textheight]{Decrypt.eps}
\caption{Time cost of SPCHS}\label{F.Result}
\end{figure}

\section{A Generic Construction of SPCHS \\ from IBKEM and IBE}\label{S.SPCHS.Generic}

In this section, we formalize collision-free full-identity malleable IBKEM and a generic SPCHS construction from IBKEM and IBE. 

\subsection{Reviewing IBE}
Before the generic SPCHS construction, let us review the concept of IBE and its Anonymity and Semantic Security both under adaptive-ID and Chosen Plaintext Attacks (Anon-SS-ID-CPA).

\begin{definition}[IBE \cite{BF01}]\label{D.IBE}
IBE consists of four algorithms:
\begin{itemize}
\item : Take as inputs a security parameter  and an identity space , and probabilistically output the master public-and-secret-key pair , where  includes the message space , the ciphertext space  and the identity space .

\item : Take as inputs  and an identity , and output a decryption key  of .

\item : Take as inputs , an identity  and a message , and probabilistically output a ciphertext .

\item : Take as inputs the decryption key  of identity  and a ciphertext , and output a message or , if the ciphertext is invalid.
\end{itemize}

An IBE scheme must be consistent in the sense that for any  and ,  holds if , except with a negligible probability in the security parameter .
\end{definition}

In the Anon-SS-ID-CPA security notion of IBE, a PPT adversary is allowed to query the decryption keys for adaptively chosen identities, and adaptively choose two challenge identity-and-message pairs. The Anon-SS-ID-CPA security of IBE means that for a challenge ciphertext, the adversary cannot determine which challenge identity and which challenge message it corresponds to, provided that the adversary does not know the two challenge identities' decryption keys. The Anon-SS-ID-CPA security of an IBE scheme is as follows. 

\begin{definition}[Anon-SS-ID-CPA security of IBE \cite{ABN10}] 
An IBE scheme is Anon-SS-ID-CPA secure if any PPT adversary  has only a negligible advantage  to win in the following Anon-SS-ID-CPA game:

\begin{itemize}
\item \textbf{Setup Phase}: A challenger sets up the IBE scheme by running algorithm  to generate the master public-and-secret-keys pair , and sends  to . 

\item \textbf{Query Phase 1}: Adversary  adaptively issues the following query multiple times.
\begin{itemize}
\item Decryption Key Query : Taking as input an identity , the challenger outputs the decryption key of identity . 
\end{itemize}

\item \textbf{Challenge Phase}: Adversary  sends two challenge identity-and-message pairs  and  to the challenger; the challenger picks }\leftarrow\{0,1\}\tilde{C}^*_{\tilde{d}}=\mathbf{Enc}_{\mbox{\tiny IBE}}(\mathbf{PK}_{\mbox{\tiny IBE}},ID^*_{\tilde{d}},M^*_{\tilde{d}})\mathcal{B}\mathcal{B}ID_0^*ID_1^*\mathcal{B}\tilde{d}^\prime\mathcal{B}\tilde{d}^\prime=\tilde{d}Adv^{\text{Anon-SS-ID-CPA}}_{IBE,\mathcal{B}}=Pr[\tilde{d}^\prime=\tilde{d}]-\frac{1}{2}\mathcal{B}\mathbf{Encaps}_{\mbox{\tiny IBKEM}}\mathbf{Encaps}_{\mbox{\tiny IBKEM}}\mathbf{Setup}_{\mbox{\tiny IBKEM}}(1^k,\mathcal{ID}_{\mbox{\tiny IBKEM}})1^k\mathcal{ID}_{\mbox{\tiny IBKEM}}(\mathbf{PK}_{\mbox{\tiny IBKEM}},\mathbf{SK}_{\mbox{\tiny IBKEM}})\mathbf{PK}_{\mbox{\tiny IBKEM}}\mathcal{ID}_{\mbox{\tiny IBKEM}}\mathcal{K}_{\mbox{\tiny IBKEM}}\mathcal{C}_{\mbox{\tiny IBKEM}}\mathbf{Extract}_{\mbox{\tiny IBKEM}}(\mathbf{SK}_{\mbox{\tiny IBKEM}},ID)\mathbf{SK}_{\mbox{\tiny IBKEM}}ID\in\mathcal{ID}_{\mbox{\tiny IBKEM}}\hat{S}_{ID}ID\mathbf{Encaps}_{\mbox{\tiny IBKEM}}(\mathbf{PK}_{\mbox{\tiny IBKEM}},ID,r)\mathbf{PK}_{\mbox{\tiny IBKEM}}ID\in\mathcal{ID}_{\mbox{\tiny IBKEM}}r(\hat{K},\hat{C})ID\mathbf{Decaps}_{\mbox{\tiny IBKEM}}(\hat{S}_{ID^\prime},\hat{C})\hat{S}_{ID^\prime}ID^\prime\hat{C}\bot(\hat{K},\hat{C})=\mathbf{Encaps}_{\mbox{\tiny
IBKEM}}(\mathbf{PK}_{\mbox{\tiny IBKEM}},ID,r)\mathbf{Decaps}_{\mbox{\tiny IBKEM}}(\hat{S}_{ID^\prime},\hat{C})=\hat{K}ID^\prime=IDk\mathbf{FIM}(\hat{K},\hat{C})=\mathbf{Encaps}_{\mbox{\tiny IBKEM}}(\mathbf{PK}_{\mbox{\tiny IBKEM}},ID,r)\mathbf{FIM}ID^\prime\in\mathcal{ID}_{\mbox{\tiny IBKEM}}\mathbf{FIM}(ID^\prime,r)=\mathbf{Decaps}_{\mbox{\tiny IBKEM}}(\hat{S}_{ID^\prime},\hat{C})\hat{S}_{ID^\prime}=\mathbf{Extract}_{\mbox{\tiny IBKEM}}(\mathbf{SK}_{\mbox{\tiny IBKEM}},ID^\prime)ID^\prime\in\mathcal{ID}_{\mbox{\tiny IBKEM}}r^\primeID\neq ID^\prime\bigvee r\neq r^\prime\mathbf{FIM}(ID,r)\neq \mathbf{FIM}(ID^\prime,r^\prime)k\mathcal{B}Adv^{\text{Anon-SS-ID-CPA}}_{IBKEM,\mathcal{B}}\mathbf{Setup}_{\mbox{\tiny IBKEM}}(\mathbf{PK}_{\mbox{\tiny IBKEM}},\mathbf{SK}_{\mbox{\tiny IBKEM}})\mathbf{PK}_{\mbox{\tiny IBKEM}}\mathcal{B}\mathcal{B}\mathcal{Q}_{DK}^{IBKEM}(ID)ID\in\mathcal{ID}_{\mbox{\tiny IBKEM}}ID\mathcal{B}ID^*_0ID_1^*\hat{d}\overset{\, computes 
and , and sends the challenge key-and-encapsulation pair  to , where  and  are randomly chosen.

\item \textbf{Query Phase 2}: This phase is the same as \textbf{Query Phase 1}. Note that in \textbf{Query Phase 1} and \textbf{Query Phase 2},  cannot query the decryption keys both of the challenge identities  and .

\item \textbf{Guess Phase}:  sends a guess  to the challenger. We say that  wins if . Let  be the advantage of  to win in the above game. 
\end{itemize}
\end{definition}

In the above definition, the anonymity of the encapsulated keys is defined by the indistinguishability of  and . But we do not define the anonymity of the IBKEM encapsulations (\emph{i.e.} the challenge key-and-encapsulation pair consists of  instead of ), since the full-identity malleability of IBKEM implies that any IBKEM encapsulation is valid for all identities.

A weaker security definition of IBKEM is the selective-identity security, referred to as the Anon-SS-sID-CPA security. The corresponding attack game is called the Anon-SS-sID-CPA game in which the adversary must commit to the two challenge identities before the system is set up.

\subsection{The Proposed Generic SPCHS Construction}

Let keyword space . Our generic SPCHS construction from the collision-free full-identity malleable IBKEM and IBE is as follows.

\begin{itemize}
\item : Take as inputs a security parameter  and the keyword space , run  and  , and output a pair of master public-and-secret keys . Let the SPCHS ciphertext space , and .

\item : Take as input , arbitrarily pick a keyword  and a random value , generate an IBKEM encapsulated key and its encapsulation , and initialize a hidden structure by outputting a pair of private-and-public parts . Note that  here is a variable list formed as , which is initialized as .

(In the above, an IBKEM encapsulation and its related random value are respectively taken as the public-and-private parts of a hidden structure. To generate these two parts , an arbitrary keyword have to be chosen to run algorithm .)

\item : Take as inputs , a keyword , a hidden structure's private part , and do the following steps: \begin{enumerate}
\item Search  for  in ;
\item If it is not found, insert }\leftarrow
\mathcal{M}_{\mbox{\tiny IBE}})\mathbf{Pri}C=(\mathbf{FIM}(W,u),\mathbf{Enc}_{\mbox{\tiny IBE}}(\mathbf{PK}_{\mbox{\tiny IBE}},W,Pt[u,W])R\overset{\, set , update , and output the keyword-searchable ciphertext ;
\end{enumerate}

\item : Take as inputs  and a keyword , run   and , and output a keyword search trapdoor  of keyword .

\item : Take as inputs , a hidden structure's public part , all keyword-searchable ciphertexts  (let  denote one ciphertext of , and this ciphertext can be parsed as ) and a keyword trapdoor  of keyword , set , and do the following steps:
\begin{enumerate}
\item Compute ;
\item Seek a ciphertext  having ; if 
it exists,  add  into ; 
\item If no matching ciphertext is found, output ;
\item Compute , go to step 2;
\end{enumerate}
\end{itemize}

Figure \ref{F.SPCHS.Generic} shows a hidden star-like structure generated by the generic SPCHS construction. When running algorithm , the full-identity malleability of IBKEM allows the algorithm to disclose the value  by computing  and find out the ciphertext  . Then the consistency of IBE allows the algorithm to disclose  by decrypting   and find out the ciphertext   . By carrying on in this way, 
the consistency of IBE allows the algorithm to find out the rest of ciphertexts of keyword  with the hidden star-like structure, and stop the search if no more ciphertexts are found. 

\begin{figure*}[!htp]
\centering
\begin{boxedminipage}{0.9\textwidth}
\includegraphics[scale=0.7]{GenericSPCHS}
\begin{quote}
Note that in each ciphertext, the value  is randomly chosen. For ,  is initialized with a random value when generating the first ciphertext of keyword , and it will be updated into  after generating each subsequent ciphertext of keyword . 
\end{quote} 
\end{boxedminipage}
\caption{Hidden star-like structure generated by the generic SPCHS construction}\label{F.SPCHS.Generic}
\end{figure*}

\textbf{Consistency.} When running the above algorithm , the consistency and full-identity malleability of IBKEM assures that  holds. The collision-freeness of IBKEM assures that only one ciphertext containing keyword  has the value  as its first part. Therefore the algorithm can find out the first ciphertext of keyword  with the hidden structure . Then the consistency of IBE allows the algorithm  to find out the rest of ciphertexts containing keyword  with the hidden structure . Formally we have Theorem \ref{T.SPCHS.Generic.Consistency}. The proof can be found in Supplemental Materials D.

\begin{theorem}\label{T.SPCHS.Generic.Consistency}
The above generic SPCHS scheme is consistent if its underlying collision-free full-identity malleable IBKEM and IBE schemes are both consistent.
\end{theorem}

\textbf{Semantic Security.} The SS-sK-CKSA security of the above generic SPCHS construction relies on the Anon-SS-sID-CPA security of the underlying IBKEM and the Anon-SS-ID-CPA security of the underlying IBE. In the security proof, we prove that if there is an adversary who can break the SS-sK-CKSA security of the above generic SPCHS construction, then there is another adversary who can break the Anon-SS-sID-CPA security of the underlying IBKEM or the Anon-SS-ID-CPA security of the underlying IBE. Theorem \ref{T.SPCHS.Generic.Security} formally states the semantic security of our generic SPCHS construction. The proof can be found in Supplemental Materials E.

\begin{theorem}\label{T.SPCHS.Generic.Security}
Suppose there are at most  hidden structures, and a PPT adversary  wins in the SS-sK-CKSA game with advantage . Then there is a PPT adversary , who utilizes the capability of  to win in the Anon-SS-sID-CPA game of the underlying IBKEM or the Anon-SS-ID-CPA game of the underlying IBE with advantage .
\end{theorem}

\section{Two Collision-Free Full-Identity Malleable IBKEM Instances}\label{S.IBKEM.Instances}

\textbf{The Instance in the RO Model.} Abdalla \emph{et al.} proposed several VRF-suitable IBKEM instances in \cite{ACF13}. An IBKEM instance is VRF-suitable if it provides \emph{unique decapsulation}. This means that given any encapsulation, all the decryption keys corresponding to the same identity decapsulate out the same encapsulated key, and the key is pseudo-random. Here, the decryption key extraction is probabilistic and for the same identity, different decryption key may be extracted in different runs of the key extraction algorithm. It is clear that our proposed collision-free full-identity malleability not only implies \emph{unique decapsulation}, but also implies that the generator of an encapsulation knows what keys will be decapsulated by the decryption keys of all identities. In Supplemental Materials  F, we prove that the VRF-suitable IBKEM instance proposed in Appendix A.2 of \cite{ACF13} is collision-free full-identity malleable. Even though this IBKEM scheme has the traditional Anon-SS-ID-CPA security, we further prove that this IBKEM scheme is Anon-SS-ID-CPA secure based on the DBDH assumption in the RO model according to Definition \ref{D.IBKEM.Security}. 

\textbf{The Instance in the Standard Model.}  In \cite{FHPS13}, Freire \emph{et al.} utilized the ``approximation'' of multilinear maps \cite{GGH13} to construct a programmable hash function in the multilinear setting (MPHF). Then Freire \emph{et al.} utilized this hash function to replace the traditional hash functions of the BF IBE scheme in \cite{BF01} and reconstructed this IBE scheme in the multilinear setting. They finally constructed a new IBE scheme with semantic security in the standard model. We find that this new IBE scheme can be easily transformed into a collision-free full-identity malleable IBKEM scheme with Anon-SS-ID-CPA security in the standard model. To simplify the description of this IBKEM scheme, we do not consider the ``approximation'' of multilinear maps. This means that we will leave out the functions that are the encoding of a group element,  the re-randomization of an encoding and the extraction of an encoding.  Some related definitions are reviewed as follows.

\begin{definition}[Multilinear Maps \cite{FHPS13}]\label{D.Multilinear} 
An -group system in the multilinear setting consists of  cyclic groups  of prime order , along with bilinear maps  for all  with . Let  be a generator of . The map  satisfies  (for all ). When  are clear, we will simply write  instead of . It will also be convenient to abbreviate  for  and . By induction, it is easy to see that this map is -linear. Additionally, We define . Finally, it can also be useful to define the group  of exponents to which this pairing family naturally extends. In the following, we will assume an -group system   generated by a \emph{multilinear maps parameter generator}  on input a security parameter .
\end{definition}

\begin{definition}[The -MDDH Assumption \cite{FHPS13}]\label{D.MDDH} 
Given   (for }{\leftarrow} \mathbb{G}_1x_i\ell\hat{e}(g^{x_1},\cdots ,g^{x_\ell})^{x_{\ell+1}} \in \mathbb{G}_\ell\mathbb{G}_\ell\mathbf{H}\mathbb{G}\mathbf{HGen}(1^k)hk\mathbf{HEval}(hk,X)hkX \in {\{0,1\}}^k\mathbf{H}_{hk}(X)\in\mathbb{G}\ell^\prime\mathbf{MPG}_{\ell^\prime}\mathbf{MG}_{\ell^\prime}(1^k)\mathbf{H}\mathbb{G}_{\ell}(\ell \leq \ell^\prime)m,n \in \mathbb{N}\mathbf{H}\mathbf{TGen}\mathbf{TEval}\mathbf{TGen}(1^k,c_1,\cdots,c_l,h)c_i,h \in \mathbb{G}_1h\neq 1hktdc_i,hhk\mathbf{HGen}\mathbf{TEval}(td,X)tdX \in {\{0,1\}}^ka_X \in \mathbb{Z}_p^*B_X \in \mathbb{G}_{\ell-1}\mathbf{H}_{hk}(X)= \hat{e}(c_1,\cdots,c_\ell)^{a_X} \cdot \hat{e}(B_X,h)p(k)hkX_1, \cdots, X_mZ_1, \cdots, Z_n \in {\{0,1\}}^k{\{X_i\}}_i \bigcap {\{Z_j\}}_j = \emptysetP_{hk,\{X_i\},\{Z_j\}} =Pr[(a_{X_1} = \cdots = a_{X_m} = 0) \land (a_{Z_1},\cdots,a_{X_n}\neq0)]\geq 1/p(k)td\mathbf{TGen}hkP_{hk,\{X_i\},\{Z_j\}}hk|P_{hk,\{X_i\},\{Z_j\}}-P_{hk^\prime,\{X_i\},\{Z_j\}}|\leq v(k)hkhk^\prime\mathbf{TGen}\{X_i\},\{Z_j\}v(k)\mathbf{H}(\mathsf{poly},n)(q(k),n)q(k)\mathbf{TEval}\mathbb{G}_1B_X \in \mathbb{G}_0B_X\mathcal{ID}_{\mbox{\tiny IBKEM}}=\{0,1\}^k\mathbf{Setup}_{\mbox{\tiny IBKEM}}(1^k,\mathcal{ID}_{\mbox{\tiny IBKEM}})1^k\mathcal{ID}_{\mbox{\tiny IBKEM}}(\ell+1)\mathbf{MPG}_{\ell+1}= \{\{\mathbb{G}_i\}_{i \in [1,\ell+1]}, p, \{\hat{e}_{i,j}\}_{i,j\geq1,i+j\leq\ell+1}\}\leftarrow\mathbf{MG}_{\ell+1}(1^k)(\mathsf{poly},2)\mathbf{H}\mathbb{G}_\ellhk\leftarrow \mathbf{HGen}(1^k)h\overset{\ and  }{\leftarrow}\mathbb{Z}_p\mathcal{K}_{\mbox{\tiny IBKEM}}=\mathbb{G}_{\ell+1}\mathcal{C}_{\mbox{\tiny IBKEM}}=\mathbb{G}_1\mathbf{PK}_{\mbox{\tiny IBKEM}}=(\mathbf{MPG}_{\ell+1},hk,\mathbf{H},h,h^x,\mathcal{ID}_{\mbox{\tiny IBKEM}},\mathcal{K}_{\mbox{\tiny IBKEM}},\mathcal{C}_{\mbox{\tiny IBKEM}})\mathbf{SK}_{\mbox{\tiny IBKEM}}=(hk,x)\mathbf{Extract}_{\mbox{\tiny IBKEM}}(\mathbf{SK}_{\mbox{\tiny IBKEM}},ID)\mathbf{SK}_{\mbox{\tiny IBKEM}}ID\in\mathcal{ID}_{\mbox{\tiny IBKEM}}\hat{S}_{ID}=\mathbf{H}_{hk}(ID)^xID\mathbf{Encaps}_{\mbox{\tiny IBKEM}}(\mathbf{PK}_{\mbox{\tiny IBKEM}},ID,r)\mathbf{PK}_{\mbox{\tiny IBKEM}}ID\in\mathcal{ID}_{\mbox{\tiny IBKEM}}r\in\mathbb{Z}_p^*(\hat{K},\hat{C})\hat{K}=\hat{e}(\mathbf{H}_{hk}(ID),h^x)^r\in\mathbb{G}_{\ell+1}\hat{C}=h^r\mathbf{Decaps}_{\mbox{\tiny IBKEM}}(\hat{S}_{ID^\prime},\hat{C})\hat{S}_{ID^\prime}ID^\prime\hat{C}\hat{K}=\hat{e}(\hat{C},\hat{S}_{ID^\prime})\in\mathbb{G}_{\ell+1}\hat{C}\in\mathbb{G}_1\bot\mathbf{FIM}(ID,r)=\hat{e}(h^x,\mathbf{H}_{hk}(ID))^r\in\mathbb{G}_{\ell+1}ID\in\mathcal{ID}_{\mbox{\tiny IBKEM}}r\in\mathbb{Z}_p^*(\hat{K},\hat{C})\leftarrow\mathbf{Encaps}_{\mbox{\tiny IBKEM}}(\mathbf{PK}_{\mbox{\tiny IBKEM}},ID,r)ID^\prime\mathbf{FIM}(ID^\prime,r)=\mathbf{Decaps}_{\mbox{\tiny IBKEM}}(\hat{S}_{ID^\prime},\hat{C})ID^\primer^\primeID^\prime\neq ID\bigvee r^\prime\neq r\mathbf{FIM}(ID,r)\neq \mathbf{FIM}(ID^\prime,r^\prime)(\mathsf{poly},1)(\mathsf{poly},2)(\ell+1)(\mathsf{poly},2)\mathbf{H}\mathbb{G}_\ell(\ell+1)\grave{e}W_i\in\mathcal{W}W_iE(K_i^1,P_i^2||K_i^2||\mathcal{P}_i^1)P_i^1P_i^2PEKS(Pub,W_i^1,K_i^1||P_i^1)=IBE(Pub,W_i^1,K_i^1||P_i^1||C_2)||C_2PubW_i^1K_i^1||P_i^1||C_2C_2K_i^1C_2E(K_i^1,P_i^2||K_i^2||\mathcal{P}_i^1)K_i^1P_i^2||K_i^2||\mathcal{P}_i^1K_i^2\mathcal{P}_i^1W_iW_iP_i^2||E(K_i^2,P_i^3||K_i^3||\mathcal{P}_i^2),P_i^3E(K_i^2,P_i^3||K_i^3||\mathcal{P}_i^2)P_i^2P_i^3W_iPEKS(Pub,W_i,K_i^1||P_i^1)E(K_i^1,P_i^2||K_i^2||\mathcal{P}_i^1)P_2E(K_i^1,P_i^2||K_i^2||\mathcal{P}_i^1)E(K_i^1,P_i^2||K_i^2||\mathcal{P}_i^1)E(K_i^2,P_i^3||K_i^3||\mathcal{P}_i^2)P_3E(K_i^2,P_i^3||K_i^3||\mathcal{P}_i^2)W_iW_iW_iW_i\in\mathcal{W}\{PEKS(Pub,W_i,K_i^1||P_i^1)|i\in[1,|\mathcal{W}|]\}|\mathcal{W}|\mathcal{W}W_iP_i^1||E(K_i^1,P_i^2||K_i^2||\mathcal{P}_i^1)E(K_i^1,P_i^2||K_i^2||\mathcal{P}_i^1)P_i^1W_iP_i^2||E(K_i^2,P_i^3||K_i^3||\mathcal{P}_i^2)E(K_i^2,P_i^3||K_i^3||\mathcal{P}_i^2)P_i^2W_iT_{W_i}=H(W_i)^sW_i\mathbf{Pub}=g^u\mathbf{StructuredSearch}(\mathbf{PK},\mathbf{Pub},\mathbb{C},T_{W_i})W_i\mathbf{Pub}P=g^s\mathbf{StructuredSearch}(\mathbf{PK},\mathbf{Pub},\mathbb{C},T_{W_i})Pt^\prime=\hat{e}(\mathbf{Pub},T_{W_i})\hat{e}(\mathbf{Pub},T_{W_i})=\hat{e}(P,H(W_i))^u\mathbf{StructuredSearch}(\mathbf{PK},\mathbf{Pub},\mathbb{C},T_{W_i})(\hat{e}(P,H(W_i))^u,g^r,\hat{e}(P,H(W_i))^r\cdot Pt[u,W_i])Pt^\primeHW_iPt^\prime=\hat{e}(P,H(W_i))^uk(\hat{e}(P,H(W_i))^u,g^r,\hat{e}(P,H(W_i))^r\cdot Pt[u,W_i])\mathbf{StructuredSearch}(\mathbf{PK},\mathbf{Pub},\mathbb{C},T_{W_i})Pt[u,W_i](\hat{e}(P,H(W_i))^u,g^r,\hat{e}(P,H(W_i))^r\cdot Pt[u,W_i])Pt^\prime=Pt[u,W_i]=\hat{e}(g^r,T_{W_i})^{-1}\cdot\hat{e}(P,H(W_i))^r\cdot Pt[u,W_i]\mathbf{StructuredEncryption}Pt[u,W_i]\mathbb{G}_1W_i\mathbf{Pub}\mathbf{StructuredSearch}(\mathbf{PK},\mathbf{Pub},\mathbb{C},T_{W_i})(Pt[u,W_i],g^r,\hat{e}(P,H(W_i))^r\cdot R)\mathbf{StructuredSearch}(\mathbf{PK},\mathbf{Pub},\mathbb{C},T_{W_i})W_i\mathbf{Pub}kR\mathcal{B}\mathcal{A}\mathcal{A}\mathbf{BGen}(1^k)\frac{27}{(e\cdot q_t\cdot q_p)^3}\cdot Adv^{\text{SS-CKSA}}_{SPCHS,\mathcal{A}}Coin\overset{\sigma}\leftarrow \{0,1\}Coin\in\{0,1\}Pr[Coin = 1] = \sigma\sigma\mathcal{B}\mathcal{B}(q,\mathbb{G},\mathbb{G}_1,g,\hat{e},g^a,g^b,g^c,Z)Z\hat{e}(g,g)^{abc}\hat{e}(g,g)^y\mathcal{W}\mathbf{Pt}=\emptyset\subseteq\mathcal{W}\times\mathbb{G}\times\mathbb{G}_1\mathbf{SList}=\emptyset\subseteq\mathbb{G}\times\mathbb{Z}_q^*\times\{0,1\}\mathbf{HList}=\emptyset\subseteq\mathcal{W}\times\mathbb{G}\times\mathbb{Z}_q^*\times \{0,1\}\mathcal{C}=\mathbb{G}_1\times\mathbb{G}\times\mathbb{G}_1\mathbf{PK}=(q,\mathbb{G},\mathbb{G}_1,g,\hat{e},P=g^a,\mathcal{W},\mathcal{C})Ni\in[1,N]u_i\overset{\ and ;
\item If , compute ; 
\item Otherwise, compute ;
\end{enumerate}
\item Set  and ;
\item Send  and  to adversary .
\end{enumerate}

\item \textbf{Query Phase 1}: Adversary  adaptively issues the following queries multiple times.
\begin{itemize}
\item Hash Query : Taking as input a keyword , algorithm  does the following steps:
	\begin{enumerate}
	\item Pick }\leftarrow\mathbb{Z}_q^*Coin\overset{\sigma}\leftarrow\{0,1\}Coin=0(W,g^x,x,Coin)\mathbf{HList}g^x(W,g^{c\cdot x},x,Coin)\mathbf{HList}g^{c\cdot x}\mathcal{Q}_{Trap}(W)W\in\mathcal{W}\mathcal{B}(W,*,*,*)\notin\mathbf{HList}\mathcal{Q}_H(W)W(W,X,x,Coin)\mathbf{HList}Coin=0g^{a\cdot x}\bot\mathcal{Q}_{Pri}(\mathbf{Pub})\mathbf{Pub}\in\mathbf{PSet}\mathcal{B}\mathbf{Pub}(\mathbf{Pub},u,Coin)\mathbf{SList}Coin=0u\bot\mathcal{Q}_{Enc}(W,\mathbf{Pub})W\in\mathcal{W}\mathbf{Pub}\mathcal{B}(W,*,*,*)\notin\mathbf{HList}\mathcal{Q}_H(W)W\mathbf{Pub}(W,X,x,Coin)(\mathbf{Pub},u,Coin^\prime)\mathbf{HList}\mathbf{SList}r\overset{\, and search  for  and  in ; 
	\item If  is not found, insert }\leftarrow\mathbb{G}_1)\mathbf{Pt}Coin=1\bigwedge Coin^\prime=1C=(Z^{x\cdot u},g^r,\hat{e}(g^a,X)^r\cdot Pt[u,W])Coin=0\bigwedge Coin^\prime=1C=(\hat{e}(g^a,g^{b\cdot u})^x,g^r,\hat{e}(g^a,X)^r\cdot Pt[u,W])Coin^\prime=0C=(\hat{e}(g^a,X)^u,g^r,\hat{e}(g^a,X)^r\cdot Pt[u,W])R\overset{\, 
set , update  and output ;
	\end{enumerate}
 \end{itemize}

\item \textbf{Challenge Phase}: Adversary  sends two challenge keyword-structure pairs  and  to algorithm ;  picks }\leftarrow\{0,1\}\mathbf{Pub}_0^*\mathbf{Pub}_1^*(\mathbf{Pub}_0^*,u_0^*,Coin_0^*)(\mathbf{Pub}_1^*,u_1^*,Coin_1^*)\mathbf{SList}Coin_0^*=0\bigvee Coin_1^*=0\bot(W_d^*,*,*,*)\notin\mathbf{HList}\mathcal{Q}_{H}(W_d^*)W_d^*(W_d^*,X_d^*,x_d^*,Coin)\mathbf{HList}Coin=0\bot(W_d^*,\mathbf{Pub}_d^*,Pt[u_d^*,W_d^*])W_d^*\mathbf{Pub}_d^*\mathbf{Pt}(W_d^*,\mathbf{Pub}_d^*,Pt[u_d^*,W_d^*]\overset{\ to , and send  to adversary ; 
\item Otherwise, pick }{\leftarrow}\mathbb{G}_1C_d^*=(Pt[u_d^*,W_d^*],g^b,Z^{x_d^*}\cdot R)Pt[u_d^*,W_d^*]=RC_d^*\mathcal{A}\mathcal{A}\mathbf{Pub}^*_0\mathbf{Pub}^*_1W^*_0W^*_1\mathcal{A}d^\prime\mathcal{B}d=d^\prime\mathcal{B}\overline{Abort}\mathcal{B}Pr[\overline{Abort}]Pr[\mathcal{B}=1|Z=\hat{e}(g,g)^{abc}]Pr[\mathcal{B}=1|Z=\hat{e}(g,g)^y]Adv_\mathcal {B}^{DBDH}(1^k)\overline{Abort}\sigma\mathcal{A}\mathcal{Q}_{Trap}(\cdot)\mathcal{Q}_{Pri}(\cdot)Pr[\overline{Abort}]=(1-\sigma)^{q_t\cdot q_p}\cdot \sigma^3\sigma=\frac{3}{3+q_t\cdot q_p}Pr[\overline{Abort}]\approx\frac{27}{(e\cdot q_t\cdot q_p)^3}eZ=\hat{e}(g,g)^{abc}\overline{Abort}\mathcal{B}\mathcal{A}Z=\hat{e}(g,g)^y\overline{Abort}\mathcal{B}W_0^*W_1^*Adv_\mathcal{B}^{DBDH}(1^k)\mathcal{B}\mathcal{A}\mathcal{A}Adv^{\text{SS-CKSA}}_{SPCHS,\mathcal{A}}\mathcal{A}q_t\mathcal{Q}_{Trap}(\cdot)q_p\mathcal{Q}_{Pri}(\cdot)\mathcal{B}\mathbf{BGen}(1^k)eT_{W_i}=(\hat{S}_{W_i},\tilde{S}_{W_i})W_i\mathbf{Pub}=\hat{C}\mathbf{StructuredSearch}(\mathbf{PK},\mathbf{Pub},\mathbb{C},T_{W_i})W_i\mathbf{Pub}\hat{S}_{W_i}=\mathbf{Extract}_{\mbox{\tiny IBKEM}}(\mathbf{SK}_{\mbox{\tiny IBKEM}},W_i)\tilde{S}_{W_i}=\mathbf{Extract}_{\mbox{\tiny IBE}}(\mathbf{SK}_{\mbox{\tiny IBE}},W_i)\hat{C}(\hat{K},\hat{C})=\mathbf{Encaps}_{\mbox{\tiny IBKEM}}(\mathbf{PK}_{\mbox{\tiny IBKEM}},W,u)W\mathcal{W}u\mathbf{StructuredSearch}(\mathbf{PK},\mathbf{Pub},\mathbb{C},T_{W_i})Pt^\prime=\mathbf{Decaps}_{\mbox{\tiny IBKEM}}(\hat{S}_{W_i},\mathbf{Pub})\mathbf{FIM}(W_i,u)=\mathbf{Decaps}_{\mbox{\tiny IBKEM}}(\hat{S}_{W_i},\mathbf{Pub})\mathbf{StructuredSearch}(\mathbf{PK},\mathbf{Pub},\mathbb{C},T_{W_i})(\mathbf{FIM}(W_i,u),\mathbf{Enc}_{\mbox{\tiny IBE}}(\mathbf{PK}_{\mbox{\tiny IBE}},W_i,Pt[u,W_i]))Pt^\primeW_j\neq W_i\mathbf{FIM}(W_i,u)=\mathbf{FIM}(W_j,u)\mathbf{Pub}^\prime\neq\mathbf{Pub}\mathbf{FIM}(W_i,u)=\mathbf{FIM}(W_i,u^\prime)\mathbf{Pub}^\prime\mathbf{StructureInitialization}(\mathbf{PK})u^\prime(\mathbf{FIM}(W_i,u),\mathbf{Enc}_{\mbox{\tiny IBE}}(\mathbf{PK}_{\mbox{\tiny IBE}},W_i,Pt[u,W_i]))k\mathbf{StructuredSearch}(\mathbf{PK},\mathbf{Pub},\mathbb{C},T_{W_i})Pt[u,W_i]\mathbf{Dec}_{\mbox{\tiny IBE}}(\tilde{S}_{W_i},\mathbf{Enc}_{\mbox{\tiny IBE}}(\mathbf{PK}_{\mbox{\tiny IBE}},W_i,Pt[u,W_i]))\mathbf{StructuredEncryption}Pt[u,W_i]\mathbb{G}_1W_i\mathbf{StructuredSearch}(\mathbf{PK},\mathbf{Pub},\mathbb{C},T_{W_i})(Pt[u,W_i],\mathbf{Enc}_{\mbox{\tiny IBE}}(\mathbf{PK}_{\mbox{\tiny IBE}},W_i,R))k\mathbf{StructuredSearch}(\mathbf{PK},\mathbf{Pub},\mathbb{C},T_{W_i})W_i\mathbf{Pub}kRW_i\mathcal{G}_1\mathcal{G}_2\mathcal{B}\mathcal{A}(W_0^*,W_1^*)\mathcal{B}\mathcal{B}I_1^*\leftarrow(\mathcal{ID}_{\mbox{\tiny IBKEM}}-\mathcal{W})(W_0^*,I_1^*)\mathcal{G}_1I_1^*\mathcal{W}\subset\mathcal{ID}_{\mbox{\tiny IBKEM}}\mathcal{G}_1(\mathbf{PK}_{\mbox{\tiny IBKEM}},\mathbf{SK}_{\mbox{\tiny IBKEM}})\mathbf{Setup}_{\mbox{\tiny IBKEM}}\mathbf{PK}_{\mbox{\tiny IBKEM}}\mathcal{B}\mathcal{B}\mathcal{G}_1\mathcal{G}_1\hat{d}\overset{\, generates  and , and sends  to , where  and  are randomly chosen.
\item  adds  into the set .
\item  generates  by algorithm , and sends  to .
\item  initializes the two lists  and , and initializes  hidden structures by repeating the following steps for :
\begin{enumerate}
\item Pick a random value  and an arbitrary keyword ;  
\item Generate , add  into the set , and add  into ;
\end{enumerate}
\item  finally sends  and  to .
\end{enumerate}

\item \textbf{Query Phase 1}: In this phase, adversary  adaptively issues the following queries multiple times.
\begin{itemize}
\item Trapdoor Query : Taking as input a keyword ,  forwards the query  both to the  decryption key oracles  and , and sends  to . 

(In this query,  cannot query the keyword search trapdoor corresponding to the challenge keyword  or . In addition, one may find that  cannot respond the query . However, 
this is not a problem, since we let . So  never issues that query.)

\item Privacy Query : Taking as input a structure's public part ,  aborts and outputs  if ; otherwise,  retrieves  from  according to  and outputs .
	
\item Encryption Query : Taking as inputs a keyword  and a structure's public part ,  does the following steps:
	\begin{enumerate}
	\item If , then 
	\begin{enumerate}
	\item Search  for  and  in ;
	
	 (Note that  is not a really known value. It is just a symbol to denote the random value used to generate .)
	\item If it is not found, query , insert }\leftarrow\mathcal{M}_{\mbox{\tiny IBE}})\mathbf{Pt}C=(\mathbf{Decaps}_{\mbox{\tiny IBKEM}}(\hat{S}_W,\mathbf{Pub}),\mathbf{Enc}_{\mbox{\tiny IBE}}(\mathbf{PK}_{\mbox{\tiny IBE}},W,Pt[u^*,W]))W=W_1^*\mathcal{B}\hat{S}_W=\mathcal{Q}_{DK}^{IBKEM}(W)W_1^*R\overset{\, set , update  and output ;
	\end{enumerate}
	\item If , then
	\begin{enumerate}
	\item Search  for  and  in ;
	\item If it is not found, insert }\leftarrow\mathcal{M}_{\mbox{\tiny IBE}})\mathbf{Pt}C=(\hat{K}_{\hat{d}}^*,\mathbf{Enc}_{\mbox{\tiny IBE}}(\mathbf{PK}_{\mbox{\tiny IBE}},W,Pt[u^*,W]))\hat{d}=0C\mathbf{FIM}(\hat{C}_0^*,W_0^*,u^*)=\hat{K}^*_{\hat{d}}C\mathcal{A}\hat{d}=1\mathcal{B}R\overset{\, set , update  and output ;
	\end{enumerate}
	\item If , then 
	\begin{enumerate}
	\item According to , retrieve  from ;
	\item Search  for  and  in ;
	\item If it is not found, insert }\leftarrow\mathcal{M}_{\mbox{\tiny IBE}})\mathbf{Pt}C=(\mathbf{FIM}(W,u),\mathbf{Enc}_{\mbox{\tiny IBE}}(\mathbf{Pk}_{\mbox{\tiny IBE}},W,Pt[u,W]))R\overset{\, set , update  and output ;
	\end{enumerate}
	\end{enumerate}
 \end{itemize}

\item \textbf{Challenge Phase}: In this phase, 
\begin{enumerate}
\item  sends two challenge structures  to ; 
\item  does the following steps:
\begin{enumerate}
\item If , then abort and output ;
\item Send two challenge IBE identity-and-message pairs  and  to , where }\leftarrow\mathcal{M}_{\mbox{\tiny IBE}}M_1^*\overset{\;
\end{enumerate}
\item  picks }\leftarrow\{0,1\}\tilde{C}^*_{\tilde{d}}=\mathbf{Enc}_{\mbox{\tiny IBE}}(\mathbf{PK}_{\mbox{\tiny IBE}},W^*_0,M^*_0)\mathcal{B}\tilde{d}=0\tilde{C}_{\tilde{d}}=\mathbf{Enc}_{\mbox{\tiny IBE}}(\mathbf{PK}_{\mbox{\tiny IBE}},I^*_1,M_1^*)\mathcal{B}\mathcal{B}(W_0^*,\mathbf{Pub}_0^*,Pt[u^*,W_0^*])W_0^*\mathbf{Pub}_0^*\mathbf{Pt}(W_0^*,\mathbf{Pub}_0^*,Pt[u^*,W_0^*]=M_0^*)\mathbf{Pt}C^*\mathcal{A}C^*=(\hat{K}_{\hat{d}}^*,\tilde{C}_{\tilde{d}})\hat{d}=0\tilde{d}=0C^*\mathcal{A}C^*\hat{d}=1\tilde{d}=1\mathcal{B}C^*=(Pt[u^*,W_0^*],\tilde{C}_{\tilde{d}})Pt[u^*,W_0^*]=M_0^*C^*\mathcal{A}\tilde{d}=0C^*\mathcal{A}C^*\tilde{d}=1\mathcal{B}\mathcal{A}\mathbf{Pub}^*_0\mathbf{Pub}^*_1W^*_0W^*_1\mathcal{A}d^\prime\mathcal{B}\mathcal{B}d^\prime\hat{d}\tilde{d}d^\prime\mathcal{G}_1\mathcal{G}_2\overline{Abort}\mathcal{B}\mathcal{A}\mathcal{Q}_{Pri}q_pPr[\overline{Abort}]=\frac{N-q_p}{N}\cdot \frac{1}{N-q_p}=\frac{1}{N}q_p\leq(N-2)\mathcal{A}\mathcal{Q}_{Pri}(\mathbf{Pub}^*_0,\mathbf{Pub}_1^*)Win_{IBKEM,\mathcal{B}}^{\text{Anon-SS-sID-CPA}}\mathcal{B}\mathcal{B}Win_{IBE,\mathcal{B}}^{\text{Anon-SS-ID-CPA}}\mathcal{B}\mathcal{B}Adv_{\mathcal{B}}\mathcal{B}Win_{IBKEM,\mathcal{B}}^{\text{Anon-SS-sID-CPA}}Win_{IBE,\mathcal{B}}^{\text{Anon-SS-ID-CPA}}\mathcal{B}\frac{3}{4}Win_{IBKEM,\mathcal{B}}^{\text{Anon-SS-sID-CPA}}Win_{IBE,\mathcal{B}}^{\text{Anon-SS-ID-CPA}}\mathcal{B}\overline{Belong}(W_0^*,\mathbf{Pub}_0^*,Pt[u^*,W_0^*])\notin\mathbf{Pt}Belong(W_0^*,\mathbf{Pub}_0^*,Pt[u^*,W_0^*])\in\mathbf{Pt}Pr[Win_{IBKEM,\mathcal{B}}^{\text{Anon-SS-sID-CPA}}|\overline{Abort}]+Pr[Win_{IBE,\mathcal{B}}^{\text{Anon-SS-ID-CPA}}|\overline{Abort}]Pr[Win_{IBKEM,\mathcal{B}}^{\text{Anon-SS-sID-CPA}}\bigwedge Win_{IBE,\mathcal{B}}^{\text{Anon-SS-ID-CPA}}|\overline{Abort}]\mathcal{B}\mathcal{A}\mathcal{A}Adv^{\text{SS-sK-CKSA}}_{SPCHS,\mathcal{A}}\mathcal{B}\mathcal{A}\frac{1}{4N}\cdot Adv^{\text{SS-sK-CKSA}}_{SPCHS,\mathcal{A}}\mathcal{ID}_{\mbox{\tiny IBKEM}}=\{0,1\}^*\mathbf{Setup}_{\mbox{\tiny IBKEM}}(1^k,\mathcal{ID}_{\mbox{\tiny IBKEM}})1^k\mathcal{ID}_{\mbox{\tiny IBKEM}}(q,\mathbb{G}, \mathbb{G}_1, g,\hat{e})\overset{\, pick }\leftarrow \mathbb{Z}_q^*P\leftarrow g^sH: \{0,1\}^*\rightarrow \mathbb{G}\mathcal{K}_{\mbox{\tiny IBKEM}}=\mathbb{G}_1\mathcal{C}_{\mbox{\tiny IBKEM}}=\mathbb{G}\mathbf{PK}_{\mbox{\tiny IBKEM}}=(q,\mathbb{G},\mathbb{G}_1,g,\hat{e},P,H,\mathcal{ID}_{\mbox{\tiny IBKEM}},\mathcal{K}_{\mbox{\tiny IBKEM}},\mathcal{C}_{\mbox{\tiny IBKEM}})\mathbf{SK}_{\mbox{\tiny IBKEM}}=s\mathbf{Extract}_{\mbox{\tiny IBKEM}}(\mathbf{SK}_{\mbox{\tiny IBKEM}},ID)\mathbf{SK}_{\mbox{\tiny IBKEM}}ID\in\mathcal{ID}_{\mbox{\tiny IBKEM}}\hat{S}_{ID}=H(ID)^sID\mathbf{Encaps}_{\mbox{\tiny IBKEM}}(\mathbf{PK}_{\mbox{\tiny IBKEM}},ID,r)\mathbf{PK}_{\mbox{\tiny IBKEM}}ID\in\mathcal{ID}_{\mbox{\tiny IBKEM}}r(\hat{K},\hat{C})\hat{K}=\hat{e}(P,H(ID))^r\hat{C}=g^r\mathbf{Decaps}_{\mbox{\tiny IBKEM}}(\hat{S}_{ID^\prime},\hat{C})\hat{S}_{ID^\prime}ID^\prime\hat{C}\hat{K}=\hat{e}(\hat{C},\hat{S}_{ID^\prime})\hat{C}\in\mathbb{G}\bot\mathbf{FIM}(ID,r)=\hat{e}(P,H(ID))^rID\in\mathcal{ID}_{\mbox{\tiny IBKEM}}r\in\mathbb{Z}_q^*\mathbf{FIM}\mathbf{FIM}(\hat{K},\hat{C})=\mathbf{Encaps}_{\mbox{\tiny IBKEM}}(\mathbf{PK}_{\mbox{\tiny IBKEM}},ID,r)ID^\prime\in\mathcal{ID}_{\mbox{\tiny IBKEM}}\mathbf{FIM}(ID^\prime,r)=\hat{e}(P,H(ID^\prime))^r=\mathbf{Decaps}_{\mbox{\tiny IBKEM}}(\hat{S}_{ID^\prime},\hat{C})\mathbf{FIM}ID^\prime\in\mathcal{ID}_{\mbox{\tiny IBKEM}}ID\neq ID^\prime\mathbf{FIM}(ID,r)\neq \mathbf{FIM}(ID^\prime,r)Hr^\prime\in\mathbb{Z}_q^*r\neq r^\prime\mathbf{FIM}(ID,r)\neq\mathbf{FIM}(ID,r^\prime)rr^\prime\mathbf{FIM}kH\mathcal{Q}_{H}(\cdot)\mathcal{A}Adv^{\text{Anon-SS-ID-CPA}}_{IBKEM,\mathcal{A}}\mathcal{A}q_p\mathcal{Q}_{DK}^{IBKEM}(\cdot)\mathcal{B}\mathbf{BGen}(1^k)e\mathcal{B}\mathcal{A}\mathcal{A}\mathbf{BGen}(1^k)\frac{4}{(e\cdot q_p)^2}\cdot Adv^{\text{Anon-SS-ID-CPA}}_{IBKEM,\mathcal{A}} Coin\overset{\sigma}\leftarrow \{0,1\}Coin\in\{0,1\}Pr[Coin = 1] = \sigma\sigma\mathcal{B}\mathcal{B}(q,\mathbb{G},\mathbb{G}_1,g,\hat{e},g^a,g^b,g^c,Z)Z\hat{e}(g,g)^{abc}\hat{e}(g,g)^y\mathcal{ID}_{\mbox{\tiny IBKEM}}\mathbf{HList}=\emptyset\subseteq\mathcal{ID}_{\mbox{\tiny IBKEM}}\times\mathbb{G}\times\mathbb{Z}_q^*\times \{0,1\}\mathcal{K}_{\mbox{\tiny IBKEM}}=\mathbb{G}_1\mathcal{C}_{\mbox{\tiny IBKEM}}=\mathbb{G}\mathbf{PK}_{\mbox{\tiny IBKEM}}=(q,\mathbb{G},\mathbb{G}_1,g,\hat{e},P=g^a,\mathcal{ID}_{\mbox{\tiny IBKEM}},\mathcal{K}_{\mbox{\tiny IBKEM}},\mathcal{C}_{\mbox{\tiny IBKEM}})\mathbf{PK}_{\mbox{\tiny IBKEM}}\mathcal{A}\mathcal{A}\mathcal{Q}_{H}(ID)ID\in\mathcal{ID}_{\mbox{\tiny IBKEM}}\mathcal{B}x\overset{\ and ;
	\item If , add  into  and output ;
	\item Otherwise, add  into  and output ;
	\end{enumerate}
\item Decryption Key Query : Taking as input an identity , algorithm  does the following steps:
	\begin{enumerate}
	\item If , query ;
	\item According to , retrieve  from ;
	\item If , output ; otherwise, abort and output ;
	\end{enumerate}
 \end{itemize}

\item \textbf{Challenge Phase}: Adversary  sends two challenge identities  and  to algorithm ;   picks }\leftarrow\{0,1\}(ID_0^*,*,*,*)\notin\mathbf{HList}\mathcal{Q}_H(ID_0^*)(ID_1^*,*,*,*)\notin\mathbf{HList}\mathcal{Q}_H(ID_1^*)ID_0^*ID_1^*(ID_0^*,X_0^*,x_0^*,Coin_0^*)(ID_1^*,X_1^*,x_1^*,Coin_1^*)\mathbf{HList}Coin_0^*=0\bigvee Coin_1^*=0\bot(Z^{x_{\hat{d}}^*},g^b)\mathcal{A}\mathcal{A}ID_0^*ID_1^*\mathcal{A}\hat{d}^\prime\mathcal{B}\hat{d}=\hat{d}^\prime\mathcal{B}\overline{Abort}\mathcal{B}Pr[\overline{Abort}]Pr[\mathcal{B}=1|Z=\hat{e}(g,g)^{abc}]Pr[\mathcal{B}=1|Z=\hat{e}(g,g)^y]Adv_\mathcal {B}^{DBDH}(1^k)\overline{Abort}\sigma\mathcal{A}\mathcal{Q}_{DK}^{IBKEM}(ID)Pr[\overline{Abort}]=(1-\sigma)^{q_p}\cdot \sigma^2\sigma=\frac{2}{2+q_p}Pr[\overline{Abort}]\approx\frac{4}{(e\cdot q_p)^2}eZ=\hat{e}(g,g)^{abc}\overline{Abort}\mathcal{B}\mathcal{A}Pr[\hat{d}=\hat{d}^\prime|\overline{Abort}\bigwedge Z=\hat{e}(g,g)^{abc}]=(Adv^{\text{Anon-SS-ID-CPA}}_{IBKEM,\mathcal{A}}+\frac{1}{2})Z=\hat{e}(g,g)^y\overline{Abort}\mathcal{B}ID_0^*ID_1^*Pr[\hat{d}=\hat{d}^\prime|\overline{Abort}\bigwedge Z=\hat{e}(g,g)^y]=\frac{1}{2}Adv_\mathcal{B}^{DBDH}(1^k)\mathcal{B}\mathcal{A}\mathcal{A}Adv^{\text{Anon-SS-ID-CPA}}_{IBKEM,\mathcal{A}}\mathcal{A}q_p\mathcal{Q}_{DK}^{IBKEM}(\cdot)\mathcal{B}\mathbf{BGen}(1^k)e\mathcal{A}Adv^{\text{Anon-SS-ID-CPA}}_{IBKEM,\mathcal{A}}\mathcal{A}q_p\mathcal{Q}_{DK}^{IBKEM}(\cdot)\mathcal{B}\mathcal{A}\mathcal{A}(\ell+1)\mathbf{MG}_{\ell+1}(1^k)\mathcal{B}\mathcal{B}(\ell+1)\mathbf{MPG}_{\ell+1}g,g^{x_1},\cdots,g^{x_{\ell+2}} \in \mathbb{G}_1 S \in \mathbb{G}_{\ell+1}S= \hat{e}(g^{x_1},\cdots,g^{x_{\ell+1}})^{x_{\ell+2}}SS\in\mathbb{G}_{\ell+1}S\mathcal{B}(q_p,2)\mathbf{H}\mathbb{G}_\ell\mathbf{PK}= (\mathbf{MPG}_{\ell+1},hk,\mathbf{H},h,h^\prime,\mathcal{ID},\mathcal{K},\mathcal{C})(h,h^\prime)= (g,g^{x_{\ell+1}})(hk,td)\leftarrow\mathbf{TGen}(1^k,g^{x_1},\cdots,g^{x_\ell},g)\mathbf{PK}_{\mbox{\tiny IBKEM}}\mathcal{A}(q_p,2)\mathsf{H}\mathcal{A}\mathcal{Q}_{DK}^{IBKEM}(ID)ID\in\mathcal{ID}_{\mbox{\tiny IBKEM}}\mathcal{B}\mathbf{TEval}(td,ID)=(a_{ID},B_{ID})a_{ID}=0\hat{S}_{ID}=\hat{e}(B_{ID},h^\prime)\bot\hat{S}_{ID}=\hat{e}(B_{ID},h^\prime)=\hat{e}(B_{ID},h)^{x_{\ell+1}}=\mathbf{H}_{hk}(ID)^{x_{\ell+1}}\mathcal{B}\mathcal{Q}_{DK}^{IBKEM}(ID)\mathcal{A}IDa_{ID}=0\mathcal{A}ID^*_0\in\mathcal{ID}_{\mbox{\tiny IBKEM}}ID_1^*\in\mathcal{ID}_{\mbox{\tiny IBKEM}}\mathcal{B}\mathcal{B}\hat{d}\overset{\, and does the following steps:
\begin{enumerate}
\item Compute  and ;
\item If , then abort and output ;
\item Send the challenge key-and-encapsulation pair  to adversary ; 
\end{enumerate}

Suppose algorithm  does not abort (i.e., both  and  hold), we have  and .  Furthermore, if , we have
. This implies that the challenge key-and-encapsulation pair  is a valid one in this case. Otherwise,  contains no information about .

\item \textbf{Query Phase 2}: This phase is the same as \textbf{Query Phase 2}. Note that in \textbf{Query Phase 1} and \textbf{Query Phase 2}, adversary  cannot query the decryption key corresponding to the challenge identity  or .

\item \textbf{Guess Phase}: Adversary  sends a guess  to algorithm . Let  denote the event that  does not abort in the previous phases. Let  be the set of the queried IDs by  and the challenge identities  and . Let , which will be decided later. As in \cite{FHPS13,W05},  ``artificially'' aborts with probability  for the polynomial  from Definition \ref{D.MPHF}  and outputs . If it does not abort,  uses the guess of . 
This means that if ,  outputs 1, otherwise it outputs 0.
\end{itemize}

In \textbf{Guess Phase},  did not directly use the guess of , since event  might not be independent of the identities in . So  ``artificially'' aborts to achieve the independence. Let  be the event that  does not abort in the above game. We have that . Hence, we have  and , where  is the probability that  succeeds in the Anon-SS-ID-CPA game of IBKEM. Further, we have  Hence,  breaks the -MDDH assumption if and only if  breaks the Anon-SS-ID-CPA security of the above IBKEM scheme.

Finally, to evaluate , we can only approximate it (up to an inversely polynomial error, by running \textbf{TEval} with freshly generated keys sufficiently often), which introduces an additional error term in the analysis. We refer to \cite{W05} for details on this evaluation.
\end{proof}
\thispagestyle{empty}
\end{onecolumn}

\end{document}
