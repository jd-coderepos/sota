\documentclass{article}

\PassOptionsToPackage{numbers}{natbib}





\usepackage[preprint]{neurips_2020}



\usepackage{neurips_2020}
\usepackage[T1]{fontenc}    \usepackage{hyperref}       \usepackage{url}            \usepackage{booktabs}       \usepackage{amsfonts}       \usepackage{nicefrac}       \usepackage{microtype}      

\usepackage{bbm}
\usepackage{color}
\usepackage{wrapfig}        \usepackage{graphicx}
\usepackage{subcaption}
\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage{amsmath,amsfonts,bm}
\usepackage{amssymb}
\usepackage{enumitem}
\usepackage{makecell}
\usepackage{multirow}
\def\LLB{\textcolor{red}}
\renewcommand{\algorithmicrequire}{\textbf{Input:}}
\renewcommand{\algorithmicensure}{\textbf{Output:}}


\usepackage{amsmath,amsfonts,bm}







\def\eps{{\epsilon}}


\def\reta{{\textnormal{}}}
\def\ra{{\textnormal{a}}}
\def\rT{{\textnormal{T}}}
\def\rL{{\textnormal{L}}}
\def\rb{{\textnormal{b}}}
\def\rc{{\textnormal{c}}}
\def\rd{{\textnormal{d}}}
\def\re{{\textnormal{e}}}
\def\rf{{\textnormal{f}}}
\def\rg{{\textnormal{g}}}
\def\rh{{\textnormal{h}}}
\def\ri{{\textnormal{i}}}
\def\rj{{\textnormal{j}}}
\def\rk{{\textnormal{k}}}
\def\rl{{\textnormal{l}}}
\def\rn{{\textnormal{n}}}
\def\ro{{\textnormal{o}}}
\def\rp{{\textnormal{p}}}
\def\rq{{\textnormal{q}}}
\def\rr{{\textnormal{r}}}
\def\rs{{\textnormal{s}}}
\def\rt{{\textnormal{t}}}
\def\ru{{\textnormal{u}}}
\def\rv{{\textnormal{v}}}
\def\rw{{\textnormal{w}}}
\def\rx{{\textnormal{x}}}
\def\ry{{\textnormal{y}}}
\def\rz{{\textnormal{z}}}

\def\rvepsilon{{\mathbf{\epsilon}}}
\def\rvtheta{{\mathbf{\theta}}}
\def\rva{{\mathbf{a}}}
\def\rvb{{\mathbf{b}}}
\def\rvc{{\mathbf{c}}}
\def\rvd{{\mathbf{d}}}
\def\rve{{\mathbf{e}}}
\def\rvf{{\mathbf{f}}}
\def\rvg{{\mathbf{g}}}
\def\rvh{{\mathbf{h}}}
\def\rvu{{\mathbf{i}}}
\def\rvj{{\mathbf{j}}}
\def\rvk{{\mathbf{k}}}
\def\rvl{{\mathbf{l}}}
\def\rvm{{\mathbf{m}}}
\def\rvn{{\mathbf{n}}}
\def\rvo{{\mathbf{o}}}
\def\rvp{{\mathbf{p}}}
\def\rvq{{\mathbf{q}}}
\def\rvr{{\mathbf{r}}}
\def\rvs{{\mathbf{s}}}
\def\rvt{{\mathbf{t}}}
\def\rvu{{\mathbf{u}}}
\def\rvv{{\mathbf{v}}}
\def\rvw{{\mathbf{w}}}
\def\rvx{{\mathbf{x}}}
\def\rvy{{\mathbf{y}}}
\def\rvz{{\mathbf{z}}}

\def\erva{{\textnormal{a}}}
\def\ervb{{\textnormal{b}}}
\def\ervc{{\textnormal{c}}}
\def\ervd{{\textnormal{d}}}
\def\erve{{\textnormal{e}}}
\def\ervf{{\textnormal{f}}}
\def\ervg{{\textnormal{g}}}
\def\ervh{{\textnormal{h}}}
\def\ervi{{\textnormal{i}}}
\def\ervj{{\textnormal{j}}}
\def\ervk{{\textnormal{k}}}
\def\ervl{{\textnormal{l}}}
\def\ervm{{\textnormal{m}}}
\def\ervn{{\textnormal{n}}}
\def\ervo{{\textnormal{o}}}
\def\ervp{{\textnormal{p}}}
\def\ervq{{\textnormal{q}}}
\def\ervr{{\textnormal{r}}}
\def\ervs{{\textnormal{s}}}
\def\ervt{{\textnormal{t}}}
\def\ervu{{\textnormal{u}}}
\def\ervv{{\textnormal{v}}}
\def\ervw{{\textnormal{w}}}
\def\ervx{{\textnormal{x}}}
\def\ervy{{\textnormal{y}}}
\def\ervz{{\textnormal{z}}}

\def\rmA{{\mathbf{A}}}
\def\rmB{{\mathbf{B}}}
\def\rmC{{\mathbf{C}}}
\def\rmD{{\mathbf{D}}}
\def\rmE{{\mathbf{E}}}
\def\rmF{{\mathbf{F}}}
\def\rmG{{\mathbf{G}}}
\def\rmH{{\mathbf{H}}}
\def\rmI{{\mathbf{I}}}
\def\rmJ{{\mathbf{J}}}
\def\rmK{{\mathbf{K}}}
\def\rmL{{\mathbf{L}}}
\def\rmM{{\mathbf{M}}}
\def\rmN{{\mathbf{N}}}
\def\rmO{{\mathbf{O}}}
\def\rmP{{\mathbf{P}}}
\def\rmQ{{\mathbf{Q}}}
\def\rmR{{\mathbf{R}}}
\def\rmS{{\mathbf{S}}}
\def\rmT{{\mathbf{T}}}
\def\rmU{{\mathbf{U}}}
\def\rmV{{\mathbf{V}}}
\def\rmW{{\mathbf{W}}}
\def\rmX{{\mathbf{X}}}
\def\rmY{{\mathbf{Y}}}
\def\rmZ{{\mathbf{Z}}}

\def\ermA{{\textnormal{A}}}
\def\ermB{{\textnormal{B}}}
\def\ermC{{\textnormal{C}}}
\def\ermD{{\textnormal{D}}}
\def\ermE{{\textnormal{E}}}
\def\ermF{{\textnormal{F}}}
\def\ermG{{\textnormal{G}}}
\def\ermH{{\textnormal{H}}}
\def\ermI{{\textnormal{I}}}
\def\ermJ{{\textnormal{J}}}
\def\ermK{{\textnormal{K}}}
\def\ermL{{\textnormal{L}}}
\def\ermM{{\textnormal{M}}}
\def\ermN{{\textnormal{N}}}
\def\ermO{{\textnormal{O}}}
\def\ermP{{\textnormal{P}}}
\def\ermQ{{\textnormal{Q}}}
\def\ermR{{\textnormal{R}}}
\def\ermS{{\textnormal{S}}}
\def\ermT{{\textnormal{T}}}
\def\ermU{{\textnormal{U}}}
\def\ermV{{\textnormal{V}}}
\def\ermW{{\textnormal{W}}}
\def\ermX{{\textnormal{X}}}
\def\ermY{{\textnormal{Y}}}
\def\ermZ{{\textnormal{Z}}}

\def\vzero{{\bm{0}}}
\def\vone{{\bm{1}}}
\def\vmu{{\bm{\mu}}}
\def\vtheta{{\bm{\theta}}}
\def\va{{\bm{a}}}
\def\vB{{\bm{B}}}
\def\vb{{\bm{b}}}
\def\vc{{\bm{c}}}
\def\vd{{\bm{d}}}
\def\ve{{\bm{e}}}
\def\vf{{\bm{f}}}
\def\vg{{\bm{g}}}
\def\vh{{\bm{h}}}
\def\vi{{\bm{i}}}
\def\vj{{\bm{j}}}
\def\vk{{\bm{k}}}
\def\vl{{\bm{l}}}
\def\vm{{\bm{m}}}
\def\vn{{\bm{n}}}
\def\vo{{\bm{o}}}
\def\vp{{\bm{p}}}
\def\vq{{\bm{q}}}
\def\vr{{\bm{r}}}
\def\vs{{\bm{s}}}
\def\vt{{\bm{t}}}
\def\vu{{\bm{u}}}
\def\vv{{\bm{v}}}
\def\vw{{\bm{w}}}
\def\vx{{\bm{x}}}
\def\vy{{\bm{y}}}
\def\vz{{\bm{z}}}


\def\evalpha{{\alpha}}
\def\evbeta{{\beta}}
\def\evepsilon{{\epsilon}}
\def\evlambda{{\lambda}}
\def\evomega{{\omega}}
\def\evmu{{\mu}}
\def\evpsi{{\psi}}
\def\evsigma{{\sigma}}
\def\evtheta{{\theta}}
\def\eva{{a}}
\def\evb{{b}}
\def\evc{{c}}
\def\evd{{d}}
\def\eve{{e}}
\def\evf{{f}}
\def\evg{{g}}
\def\evh{{h}}
\def\evi{{i}}
\def\evj{{j}}
\def\evk{{k}}
\def\evl{{l}}
\def\evm{{m}}
\def\evn{{n}}
\def\evo{{o}}
\def\evp{{p}}
\def\evq{{q}}
\def\evr{{r}}
\def\evs{{s}}
\def\evt{{t}}
\def\evu{{u}}
\def\evv{{v}}
\def\evw{{w}}
\def\evx{{x}}
\def\evy{{y}}
\def\evz{{z}}

\def\mA{{\bm{A}}}
\def\mB{{\bm{B}}}
\def\mC{{\bm{C}}}
\def\mD{{\bm{D}}}
\def\mE{{\bm{E}}}
\def\mF{{\bm{F}}}
\def\mG{{\bm{G}}}
\def\mH{{\bm{H}}}
\def\mI{{\bm{I}}}
\def\mJ{{\bm{J}}}
\def\mK{{\bm{K}}}
\def\mL{{\bm{L}}}
\def\mM{{\bm{M}}}
\def\mN{{\bm{N}}}
\def\mO{{\bm{O}}}
\def\mP{{\bm{P}}}
\def\mQ{{\bm{Q}}}
\def\mR{{\bm{R}}}
\def\mS{{\bm{S}}}
\def\mT{{\bm{T}}}
\def\mU{{\bm{U}}}
\def\mV{{\bm{V}}}
\def\mW{{\bm{W}}}
\def\mX{{\bm{X}}}
\def\mY{{\bm{Y}}}
\def\mZ{{\bm{Z}}}
\def\mBeta{{\bm{\beta}}}
\def\mPhi{{\bm{\Phi}}}
\def\mLambda{{\bm{\Lambda}}}
\def\mSigma{{\bm{\Sigma}}}

\DeclareMathAlphabet{\mathsfit}{\encodingdefault}{\sfdefault}{m}{sl}
\SetMathAlphabet{\mathsfit}{bold}{\encodingdefault}{\sfdefault}{bx}{n}
\newcommand{\tens}[1]{\bm{\mathsfit{#1}}}
\def\tA{{\tens{A}}}
\def\tB{{\tens{B}}}
\def\tC{{\tens{C}}}
\def\tD{{\tens{D}}}
\def\tE{{\tens{E}}}
\def\tF{{\tens{F}}}
\def\tG{{\tens{G}}}
\def\tH{{\tens{H}}}
\def\tI{{\tens{I}}}
\def\tJ{{\tens{J}}}
\def\tK{{\tens{K}}}
\def\tL{{\tens{L}}}
\def\tM{{\tens{M}}}
\def\tN{{\tens{N}}}
\def\tO{{\tens{O}}}
\def\tP{{\tens{P}}}
\def\tQ{{\tens{Q}}}
\def\tR{{\tens{R}}}
\def\tS{{\tens{S}}}
\def\tT{{\tens{T}}}
\def\tU{{\tens{U}}}
\def\tV{{\tens{V}}}
\def\tW{{\tens{W}}}
\def\tX{{\tens{X}}}
\def\tY{{\tens{Y}}}
\def\tZ{{\tens{Z}}}


\def\gA{{\mathcal{A}}}
\def\gB{{\mathcal{B}}}
\def\gC{{\mathcal{C}}}
\def\gD{{\mathcal{D}}}
\def\gE{{\mathcal{E}}}
\def\gF{{\mathcal{F}}}
\def\gG{{\mathcal{G}}}
\def\gH{{\mathcal{H}}}
\def\gI{{\mathcal{I}}}
\def\gJ{{\mathcal{J}}}
\def\gK{{\mathcal{K}}}
\def\gL{{\mathcal{L}}}
\def\gM{{\mathcal{M}}}
\def\gN{{\mathcal{N}}}
\def\gO{{\mathcal{O}}}
\def\gP{{\mathcal{P}}}
\def\gQ{{\mathcal{Q}}}
\def\gR{{\mathcal{R}}}
\def\gS{{\mathcal{S}}}
\def\gT{{\mathcal{T}}}
\def\gU{{\mathcal{U}}}
\def\gV{{\mathcal{V}}}
\def\gW{{\mathcal{W}}}
\def\gX{{\mathcal{X}}}
\def\gY{{\mathcal{Y}}}
\def\gZ{{\mathcal{Z}}}

\def\sA{{\mathbb{A}}}
\def\sB{{\mathbb{B}}}
\def\sC{{\mathbb{C}}}
\def\sD{{\mathbb{D}}}
\def\sF{{\mathbb{F}}}
\def\sG{{\mathbb{G}}}
\def\sH{{\mathbb{H}}}
\def\sI{{\mathbb{I}}}
\def\sJ{{\mathbb{J}}}
\def\sK{{\mathbb{K}}}
\def\sL{{\mathbb{L}}}
\def\sM{{\mathbb{M}}}
\def\sN{{\mathbb{N}}}
\def\sO{{\mathbb{O}}}
\def\sP{{\mathbb{P}}}
\def\sQ{{\mathbb{Q}}}
\def\sR{{\mathbb{R}}}
\def\sS{{\mathbb{S}}}
\def\sT{{\mathbb{T}}}
\def\sU{{\mathbb{U}}}
\def\sV{{\mathbb{V}}}
\def\sW{{\mathbb{W}}}
\def\sX{{\mathbb{X}}}
\def\sY{{\mathbb{Y}}}
\def\sZ{{\mathbb{Z}}}

\def\emLambda{{\Lambda}}
\def\emA{{A}}
\def\emB{{B}}
\def\emC{{C}}
\def\emD{{D}}
\def\emE{{E}}
\def\emF{{F}}
\def\emG{{G}}
\def\emH{{H}}
\def\emI{{I}}
\def\emJ{{J}}
\def\emK{{K}}
\def\emL{{L}}
\def\emM{{M}}
\def\emN{{N}}
\def\emO{{O}}
\def\emP{{P}}
\def\emQ{{Q}}
\def\emR{{R}}
\def\emS{{S}}
\def\emT{{T}}
\def\emU{{U}}
\def\emV{{V}}
\def\emW{{W}}
\def\emX{{X}}
\def\emY{{Y}}
\def\emZ{{Z}}
\def\emSigma{{\Sigma}}

\newcommand{\etens}[1]{\mathsfit{#1}}
\def\etLambda{{\etens{\Lambda}}}
\def\etA{{\etens{A}}}
\def\etB{{\etens{B}}}
\def\etC{{\etens{C}}}
\def\etD{{\etens{D}}}
\def\etE{{\etens{E}}}
\def\etF{{\etens{F}}}
\def\etG{{\etens{G}}}
\def\etH{{\etens{H}}}
\def\etI{{\etens{I}}}
\def\etJ{{\etens{J}}}
\def\etK{{\etens{K}}}
\def\etL{{\etens{L}}}
\def\etM{{\etens{M}}}
\def\etN{{\etens{N}}}
\def\etO{{\etens{O}}}
\def\etP{{\etens{P}}}
\def\etQ{{\etens{Q}}}
\def\etR{{\etens{R}}}
\def\etS{{\etens{S}}}
\def\etT{{\etens{T}}}
\def\etU{{\etens{U}}}
\def\etV{{\etens{V}}}
\def\etW{{\etens{W}}}
\def\etX{{\etens{X}}}
\def\etY{{\etens{Y}}}
\def\etZ{{\etens{Z}}}

\newcommand{\pdata}{p_{\rm{data}}}
\newcommand{\ptrain}{\hat{p}_{\rm{data}}}
\newcommand{\Ptrain}{\hat{P}_{\rm{data}}}
\newcommand{\pmodel}{p_{\rm{model}}}
\newcommand{\Pmodel}{P_{\rm{model}}}
\newcommand{\ptildemodel}{\tilde{p}_{\rm{model}}}
\newcommand{\pencode}{p_{\rm{encoder}}}
\newcommand{\pdecode}{p_{\rm{decoder}}}
\newcommand{\precons}{p_{\rm{reconstruct}}}
\newcommand{\laplace}{\mathrm{Laplace}} \newcommand{\E}{\mathbb{E}}
\newcommand{\Ls}{\mathcal{L}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\emp}{\tilde{p}}
\newcommand{\lr}{\alpha}
\newcommand{\reg}{\lambda}
\newcommand{\rect}{\mathrm{rectifier}}
\newcommand{\softmax}{\mathrm{softmax}}
\newcommand{\sigmoid}{\sigma}
\newcommand{\softplus}{\zeta}
\newcommand{\KL}{D_{\mathrm{KL}}}
\newcommand{\Var}{\mathrm{Var}}
\newcommand{\standarderror}{\mathrm{SE}}
\newcommand{\Cov}{\mathrm{Cov}}
\newcommand{\normlzero}{L^0}
\newcommand{\normlone}{L^1}
\newcommand{\normltwo}{L^2}
\newcommand{\normlp}{L^p}
\newcommand{\normmax}{L^\infty}

\newcommand{\parents}{Pa} 

\DeclareMathOperator*{\argmax}{arg\,max}
\DeclareMathOperator*{\argmin}{arg\,min}

\DeclareMathOperator{\sign}{sign}
\DeclareMathOperator{\Tr}{Tr}
\let\ab\allowbreak
 

\title{A Universal Representation Transformer Layer\\ for Few-Shot Image Classification}




\author{Lu Liu\thanks{This work was done while Lu Liu was a research intern with Mila.}, William Hamilton\thanks{Canada CIFAR AI Chair} , Guodong Long, Jing Jiang, Hugo Larochelle \\
 Mila,  Australian AI Institute, UTS,  McGill University,   Google Research, Brain Team\\
  Correspondence to \texttt{\href{mailto:lu.liu.cs@icloud.com}{lu.liu.cs@icloud.com}}
}

\newcommand*\rot{\rotatebox{0}}

\begin{document}

\maketitle

\begin{abstract}
Few-shot classification aims to recognize unseen classes when presented with only a small number of samples. 
We consider the problem of {\em multi-domain} few-shot image classification, where unseen classes and examples come from diverse data sources. This problem has seen growing interest and has inspired the development of benchmarks such as Meta-Dataset. A key challenge in this multi-domain setting is to effectively integrate the feature representations from the diverse set of training domains.
Here, we propose a Universal Representation Transformer (URT) layer, that meta-learns to leverage universal features for few-shot classification by dynamically re-weighting and composing the most appropriate domain-specific representations.
In experiments, we show that URT sets a new state-of-the-art result on Meta-Dataset. 
Specifically, it achieves top-performance on the highest number of data sources compared to competing methods.
We analyze variants of URT and present a visualization of the attention score heatmaps that sheds light on how the model performs cross-domain generalization. Our code is available at \texttt{\href{https://github.com/liulu112601/URT}{https://github.com/liulu112601/URT}}
\end{abstract}


\section{Introduction}


Learning tasks from small data remains a challenge for machine learning systems, which show a noticeable gap compared to the ability of humans to understand new concepts from few examples. A promising direction to address this challenge is developing methods that are capable of performing transfer learning across the collective data of many tasks. 
Since machine learning systems generally improve with the availability of more data, a natural assumption is that few-shot learning systems should benefit from leveraging data {\em across many different tasks and domains}---even if each individual task has limited training data available. 


This research direction is well captured by the problem of {\em multi-domain few-shot classification}. 
In this setting, training and test data spans a number of different domains, each represented by a different source dataset. 
A successful approach in this multi-domain setting must not only address the regular challenge of few-shot classification---i.e., the challenge of having only a handful of examples per class. 
It must also discover how to leverage (or ignore) what is learned from different domains, achieving generalization and avoiding cross-domain interference. 


Recently, \citet{triantafillou2019meta} proposed a benchmark for multi-domain few-shot classification, Meta-Dataset, and highlighted some of the challenges that current methods face when training data is heterogeneous. Crucially, they found that methods which trained on all available domains would normally obtain improved performance on some domains at the expense of others. Following on their work, progress has been made, which includes the design of adapted hyper-parameter optimization strategies~\cite{saikia2020optimized} and more flexible meta-learning algorithms~\cite{requeima2019fast}. Most notable is SUR (Selecting Universal Representation)~\cite{dvornik2020selecting}, a method that relies on a so-called universal representation, extracting from a collection of pre-trained and domain-specific neural network backbones. SUR prescribes a hand-crafted feature-selection procedure to infer how to weight each backbone for each task at hand, and produces an adapted representation for each task. This was shown to lead to some of the best performances on Meta-Dataset.


In SUR, the classification procedure for each task is fixed and not learned. Thus, except for the underlying universal representation, there is no transfer learning performed with regards to how classification rules are inferred across tasks and domains. Yet, cross-domain generalization might be beneficial in that area as well, in particular when tasks have only few examples per class. 

\textbf{Present work.}
To explore this question, we propose the Universal Representation Transformer (URT) layer, which can effectively learn to transform a universal representation into task-adapted representations. 
The URT layer is inspired from Transformer networks~\cite{vaswani2017attention} and uses an attention mechanism to learn to retrieve or blend the appropriate backbones to use for each task. By training this layer across few-shot tasks from many domains, it can support transfer across these tasks.


We show that our URT layer on top of a universal representation's pre-trained backbones sets a new state-of-the-art performance on Meta-Dataset.
It succeeds at outperforming SUR on 4 dataset sources without impairing accuracy on the others. This leads to top performance on 7 dataset sources when comparing to a set of competing methods.
To interpret the strategy that URT learns to weigh the backbones from different domains, we visualize the attention scores for both seen and unseen domains and find that our model generates meaningful weights for the pre-trained domains. A comprehensive analysis on variants and ablations of the URT layer is provided to show the importance of various components of URT, notably the number of attention heads.



\section{Few-Shot Classification}

\subsection{Problem Setting} 
In this section, we will introduce the problem setting for few-shot classification and the formulation of meta-learning for few-shot classification. Few-shot classification aims to classify samples where only few examples are available for each class. We describe a few-shot learning classification task
as the pair of examples, comprising of a support set  to define the classification task and the query set  of samples to be classified.



Meta-learning is a technique that aims to model the problem of few-shot classification as learning to learn from instances of few-shot classification tasks. The most popular way to train a meta-learning model is with episodic training. Here, tasks  are sampled from a larger dataset by taking subsets of the dataset to build a support set  and a query set  for the task. A common approach is to sample -way--shot tasks, each time selecting a random subset of  classes from the original dataset and choosing only  examples for each class to add to the support set .

The meta-learning problem can then be formulated by the following optimization:

where  is the distribution of tasks,  are the parameters of the model and  is the probability assigned by the model to label  of query example  (given the support set ), and  is an optional regularization term on the model parameters with factor .


Conventional few-shot classification targets the setting of -way--shot, where the number of classes and examples are fixed in each episode. Popular benchmarks that follow this approach include Omniglot~\cite{lake2015human}) or benchmarks made of subsets of ImageNet, such as \textit{mini}ImageNet~\cite{vinyals2016matching} and \textit{tiered}ImageNet~\cite{ren2018meta}. In such benchmarks, the tasks used for training cover a set of classes that is disjoint from the classes found in the test set of tasks. However, with the training and test sets tasks coming from a single dataset/domain, the distribution of tasks found in either sets is similar and lacks variability, which may be unrealistic in practice.

It is in this context that \citet{triantafillou2019meta} proposed Meta-Dataset, as a further step towards large-scale, multi-domain few shot classification. 
Meta-Dataset includes ten datasets (domains), with eight of them available for training. Additionally, each task sampled in the benchmark varies in the number of classes , with each class also varying in the number of shots . As in all few-shot learning benchmarks, the classes used for training and testing do not overlap.



\subsection{Background and Related Work} 

{\bf Transfer by fine-tuning} 
A simple and effective method for few-shot classification is to perform transfer learning by first learning a neural network classifier on all data available for training and using its representation to initialize and then fine-tune neural networks on the few-shot classification tasks found at test time~\cite{closerlook,triantafillou2019meta,DhillonG2020,saikia2020optimized}. Specifically, \citet{saikia2020optimized} have shown that competitive performance can be reached using a strong hyper-parameter optimization method applied on a carefully designed validation metric appropriate for few-shot learning.

{\bf Meta-Learning} Another approach is to use meta-learning to more directly train a model to learn to perform few-shot classification, in an end-to-end way.
A large variety of such models have been explored, inspired by
memory-augmented networks~\cite{santoro2016meta}, LSTMs~\cite{ravi2016optimization} and metric-based classifiers~\cite{vinyals2016matching}.
The two most popular methods are Prototypical Networks~\cite{snell2017prototypical} and Model Agnostic Meta-Learning (MAML)~\cite{finn2017model}. Prototypical Networks assume that every class can be represented as a prototype in a learned embedding space (represented by a neural network). Prototypes are calculated as the average of the representations of the support examples of each class. A 1-nearest centroid classifier is then adopted for classification and the neural network representation is trained to facilitate classification in few-shot tasks directly.
MAML models the procedure of learning to learn as a bilevel optimization, where an outer loop backpropagates loss gradients through an optimization-based inner loop to learn its initialization.
\citet{triantafillou2019meta} showed that prototypical networks and MAML could be combined by leveraging prototypes for the initialization of the output weights value in the inner loop. 
\citet{requeima2019fast} also proposed Conditional Neural Adaptive Processes (CNAPs) for few-shot classification, which can be seen as extending prototypical networks with a more sophisticated architecture that allows for improved task adaptation. This architecture was later improved further by \citet{bateni2020improved} with Simple~CNAPS, leading to one of the current best methods on Meta-Dataset.
\looseness-1


{\bf Universal Representatons} In contrast, our work instead builds on that of \citet{dvornik2020selecting} and their method SUR (Selecting from Universal Representations). \citet{BilenH2017} introduced the term {\it universal representation} to refer to a representation that supports good performance in multiple domains. One proposal towards such a representation is to train different neural networks backbones separately on the data of each available domain, then simply to concatenate the representation learned by each. Another is to introduce some parameter sharing between the backbones, by having a single network conditioned on the domain of the provenance of each batch of training data~\cite{RebuffiS2018}, e.g.\ using Feature-wise Linear Modulate (FiLM)~\cite{film2018}.
SUR proposes to leverage a universal representation in few-shot learning tasks with a feature selection procedure that assigns different weights to each of the domain-specific subvectors of the universal representation. The objective is to assign high weights only to the domain-specific representations that are specifically useful for each few-shot task at hand. The weights are inferred by optimizing a loss  on the support set that encourages high accuracy of a nearest-centroid classifier. As such, the method does not involve any meta-learning---a choice motivated by the concern that  meta-learning may struggle in generalizing to domains that are dissimilar to the training domains. 
SUR achieved some of the best performances on Meta-Dataset. However, a contribution of our work is to provide evidence that meta-learning can actually be used to replace SUR's hand-designed inference procedure and improve performance further.

{\bf Transformer Networks} Our meta-learning approach to leverage universal representations is inspired directly from Transformer networks~\cite{vaswani2017attention}. Transformer networks are neural network architectures characterized by the use self-attention mechanisms to solve tasks. Our model structure is inspired by the structure of the dot-product self-attention in the Transformer, which we adapted here to multi-domain few-shot learning by designing appropriate parametrizations for queries, keys and values. Self-attention was explored in the single-domain training regime by \citet{YeH2020}, however for a different purpose, where each representation of individual examples in a task support set is influenced by all other examples. Such a strategy is also employed by CNAPs, but with the latter using FiLM as the conditioning mechanism, instead of self-attention.
Regardless, the aim of this paper is to propose a different strategy.  
Rather than using self-attention between individual examples in the support set, our model uses self-attention to select between different domain-specific backbones.

\begin{figure}[t!]
\begin{center}
\includegraphics[width=\linewidth]{resources/urt-crop-v3.pdf}
\end{center}
\caption{Illustration of how a single-head URT layer uses a universal representation to produce a task-specific representation. This example assumes the use of four backbones, with each color illustrating their domain-specific sub-vector representation in the universal representation. 
}
\label{fig:urt}
\end{figure}





\section{Universal Representation Transformer Layer}
\label{sec:urt-layer}

In this section, we describe our proposed URT layer, which uses meta-learning episodic training to learn how to combine the domain-specific backbones of a universal representation for any given few-shot learning classification task.

Conceptually, the proposed model views the support set  of a task as providing information on how to query and retrieve from the set  of  pre-trained backbones the most appropriate backbone to build an adapted representation  for the task. 

We would like the model to support a variety of strategies on how to retrieve backbones. For example, it might be beneficial for the model to retrieve a single backbone from the set, especially if the domain of the given task matches perfectly that of a domain found in the training set. Alternatively, if some of the training domains benefit from much more training data than others, a better strategy might be to attempt some cross-domain generalization towards the few-shot learning task by blending many backbones together, even if none matches
the domain of the task perfectly.

This motivates us to use dot-product self-attention, inspired by layers of Transformer networks~\cite{vaswani2017attention}. For this reason, we refer to our model as a Universal Representation Transformer (URT) layer.
Additionally, since each class of the support set might require a different strategy, we perform attention separately for each class and their support set .




\subsection{Single-Head URT Layer}

We start by describing an URT layer consisting of a single attention head. An illustration of a single-head URT layer is shown in Figure~\ref{fig:urt}.
Let  be the output vector of the backbone for domain . We then write the universal representation as

This representation provides a natural starting point to obtain a representation of a support set class. Specifically, we will note

as the representation for the set .
From this, we can describe the URT layer by defining the queries\footnote{Unable to avoid the unfortunate double usage of the term "query" due to conflicting conventions, we highlight the difference between the {\it query} sets  of few-shot tasks and the {\it queries}  of an attention mechanism.}, keys, the attention mechanism and output of the layer:

{\bf Queries :} For each class , we obtain a query through , where we have a learnable query linear transformation represented by matrix  and bias .
    
{\bf Keys :} For each domain  and class , we define keys as , using a learnable linear transformation  and  and where , using a similar notation as for .


{\bf Attention scores :} as for regular Transformer layers, we use scaled dot-product attention

where  is the dimensionality of the keys and queries. Then, these per-class scores are aggregated to obtain scores for the full support set by averaging


Equipped with these attention scores, the URT layer can now produce an adapted representation for the task (for the support and query set examples) by computing

As we can see, this approach has the flexibility of either selecting a single domain-specific backbone (by assigning  for a single domain) or blending different domains together (by having  for multiple backbones).

\subsection{Multi-Head URT Layer}
The URT layer described so far can only learn to retrieve a single backbone (or blending of backbones). Yet, it might be beneficial to retrieve multiple different (blended) backbones, especially for a few-shot task that would include many classes of varying complexity.

Thus, to achieve such diversity in the adapted representation,  we also consider URT layers with multiple heads, i.e.\ where each head corresponds to the calculation of Equation~\ref{eq:urt-layer} and each head has its own set of parameters (). Denoting each head now as , a multi-head URT layer then produces as its output the concatenation of all of its heads:

Empirically we found that the randomness in the initialization of head weights alone did not lead to uniqueness and being complimentary between the heads, so inspired by~\citet{lin2017structured}, we add a regularizer to avoid duplication of the attention scores:

where  is the Frobenius norm of a matrix and  is the matrix for attention scores, with  being the vector of all scores  for head . The identity matrix  regularizes each set of attention scores to be more focused so that multiple heads can attend to different domain-specific backbones.




\begin{algorithm}[t]
\caption{Training of URT layer }
\label{alg:urt}
\begin{algorithmic}[1]
\REQUIRE  Number of tasks ,  pre-trained backbones ;
\FOR{}
\STATE Sample a few-shot task  with support set  and query set ;
\STATE {\bf \# Infer adapted representation for task from }
\STATE For each class, obtain representation using  pre-trained backbones as in Eq.~(\ref{eq:set-rep});
\STATE Obtain attention scores using Eq.~(\ref{eq:class-attention},\ref{eq:urt-attention}) for each head using support set ;
\STATE {\bf \# Use adapted representation to predict labels in  from support set }
\STATE Compute adapted representation of examples in  and  as in Eq.~(\ref{eq:urt-layer},\ref{eq:multi-head-urt});
\STATE Compute probabilities of label of examples in  using Prototypical Network as in Eq.~(\ref{equ:classification});
\STATE Compute loss as in Eq.~(\ref{equ:opt-obj},\ref{eq:regularizer}) and perform gradient descent step on URT parameters ;
\ENDFOR
\end{algorithmic}
\end{algorithm}


\subsection{Training Strategy}
We train representations produced by the URT layer by following the approach of Prototypical Networks~\cite{snell2017prototypical}, where the probability of a label  for a query example  given the support set of a task is modeled as:

where  is a distance metric and  corresponds to the centroid of class , referred to as its prototype. We use (negative) cosine similarity as the distance.
The full training algorithm is presented in Algorithm~\ref{alg:urt}.






\section{Experiments}

In this section, we seek to answer three key experimental questions:
\begin{enumerate}[label=\textbf{Q\arabic*}, itemsep=2pt, parsep=2pt, leftmargin=*, topsep=2pt]
    \item How does URT compare with previous state-of-the-art on Meta-Dataset for multi-domain few-shot classification?
    \item Do the URT attention heads generate interpretable and meaningful attention scores? 
     \item Does the URT layer provide consistent benefits, even when pre-trained backbones are trained in different ways? 
\end{enumerate}
In addition, we investigate architectural choices made, such as our models for keys/queries and their regularization, and study their contribution to achieving strong performance with URT. 






\iffalse
\begin{table}[t!]
\small
\centering
\setlength{\tabcolsep}{1.7pt}
\caption{
Test performance (mean+CI\%95) over 600 few-shot tasks. URT and the most recent methods, which are listed in the first row, are compared on 13 test datasets, which are listed in the first column. The numbers in \textbf{bold} have intersecting confidence intervals with the most accurate method. 
}
\vspace{0.5em}
\begin{tabular}{lcccccc|c}
\toprule
   & \textbf{ProtoNet}\cite{snell2017prototypical} & \textbf{MAML}\cite{finn2017model} & \textbf{ProtoMAML}\cite{triantafillou2019meta} & \textbf{CNAPs}\cite{requeima2019fast} & \textbf{BOHB-E}\cite{saikia2020optimized} & \textbf{SUR}\cite{dvornik2020selecting} & \textbf{URT}\\ \midrule
ILSVRC & 44.5  1.1 &  37.8  1.0 &  46.5  1.1 &       52.3  1.0 & \textbf{55.4  1.1} & \textbf{56.3  1.1} & \textbf{55.7  1.0}  \\ 
Omniglot & 79.6  1.1 &  83.9  1.0 &  82.7  1.0 &       88.4  0.7 & 77.5  1.1 & 93.1  0.5 & \textbf{94.4  0.4} \\ 
Aircraft & 71.1  0.9 &  76.4  0.7 &  75.2  0.8 &       80.5  0.6 &    60.9  0.9      &  \textbf{85.4  0.7}  &  \textbf{85.8  0.6}   \\
Birds & 67.0  1.0 &  62.4  1.1 &  69.9  1.0 &       72.2  0.9 &    73.6  0.8  &  71.4  1.0 & \textbf{76.3  0.8}  \\ 
Textures & 65.2  0.8 &  64.1  0.8 &  68.3  0.8 &       58.3  0.7 & \textbf{72.8  0.7} &  \textbf{71.5  0.8}  & \textbf{71.8  0.7} \\
QuickDraw & 64.9  0.9 &  59.7  1.1 &  66.8  0.9 &       72.5  0.8 &    61.2  0.9  &  81.3  0.6 & \textbf{82.5  0.6} \\
Fungi & 40.3  1.1 &  33.5  1.1 &  42.0  1.2 &       47.4  1.0 &    44.5  1.1  &  \textbf{63.1  1.0} & \textbf{63.5  1.0} \\
VGGFlower & 86.9  0.7 &  79.9  0.8 &  88.7  0.7 & 86.0  0.5 & \textbf{90.6  0.6} &  82.8  0.7 & 88.2  0.6 \\
\midrule
TrafficSigns & 46.5  1.0 &  42.9  1.3 &  52.4  1.1 & 60.2  0.9 &   57.5  1.0 & \textbf{70.4  0.8} & \textbf{69.4  0.8} \\
MSCOCO & 39.9  1.1 &  29.4  1.1 &  41.7  1.1 &       42.6  1.1 & \textbf{51.9  1.0} & \textbf{52.4  1.1} & \textbf{52.2  1.1}  \\
MNIST &   - &              - &              - & 92.7  0.4 &     - &  {\bf94.3  0.4}  & {\textbf{94.8  0.4}} \\
CIFAR10 &  - &              - &              - &       61.5  0.7 &                     - &  \textbf{66.8  0.9}  & \textbf{67.3  0.8}  \\
CIFAR100 &  - &              - &              - &       50.1  1.0 &                     - &  \textbf{56.6  1.0}  & \textbf{56.9  1.0}  \\
\bottomrule
\end{tabular}
\label{table:main-results}
\end{table}
\fi

\begin{table}[t!]
\scriptsize
\centering
\setlength{\tabcolsep}{2.0pt}
\caption{
Test performance (mean+CI\%95) over 600 few-shot tasks. URT and the most recent methods, which are listed in the first row, are compared on Meta-Dataset~\cite{triantafillou2019meta}, which are listed in the first row. The numbers in \textbf{bold} have intersecting confidence intervals with the most accurate method. 
}
\vspace{0.5em}
\begin{tabular}{lcccccccc|cc|c}
\toprule
& \textbf{\rotatebox{45}{ILSVRC}} & \textbf{\rotatebox{45}{Omniglot}} & \textbf{\rotatebox{45}{Aircraft}} & \textbf{\rotatebox{45}{Birds}} & \textbf{\rotatebox{45}{Textures}} & \textbf{\rotatebox{45}{QuickDraw}} & \textbf{\rotatebox{45}{Fungi}} & \textbf{\rotatebox{45}{VGGFlower}} & \textbf{\rotatebox{45}{TrafficSigns}} & \textbf{\rotatebox{45}{MSCOCO}} & \textbf{\rotatebox{45}{avg. rank}}  \\
\midrule
\textbf{MAML}\cite{finn2017model} & 37.81.0 &  83.91.0 &  76.40.7 &  62.41.1 &  64.10.8 &  59.71.1 &  33.51.1 &  79.90.8 &  42.91.3 &  29.41.1 & 8.0 \\
\textbf{ProtoNet}\cite{snell2017prototypical} & 44.51.1 & 79.61.1 & 71.10.9 & 67.01.0 & 65.20.8 & 64.90.9 & 40.31.1 & 86.90.7 & 46.51.0 & 39.91.1 & 7.3 \\
\textbf{ProtoMAML}\cite{triantafillou2019meta} & 46.51.1 &  82.71.0 &  75.20.8 &  69.91.0 &  68.30.8 &  66.80.9 &  42.01.2 &  88.70.7 &  52.41.1 &  41.71.1 & 5.4  \\
\textbf{CNAPs}\cite{requeima2019fast} & 52.31.0 &  88.40.7 &  80.50.6 & 72.20.9 & 58.30.7 & 72.50.8 & 47.41.0 & 86.00.5 & 60.20.9 & 42.61.1 & 5.1 \\
\textbf{BOHB-E}\cite{saikia2020optimized} & 55.41.1 & 77.51.1 & 60.90.9 &   73.60.8 & \textbf{72.80.7} &  61.20.9  &  44.51.1 & \textbf{90.60.6} & 57.51.0 & \textbf{51.91.0} & 4.4 \\
\textbf{TaskNorm}\cite{bronskill2020tasknorm} & 50.61.1 & 90.70.6 & 83.80.6 & 74.60.8 & 62.10.7 & 74.80.7 & 48.71.0 & 89.60.6 & 67.00.7 & 43.41.0 & 3.8 \\
\textbf{SUR}\cite{dvornik2020selecting} & 56.31.1 & 93.10.5  &  \textbf{85.40.7} &  71.41.0 &  \textbf{71.50.8} &  81.30.6 &  \textbf{63.11.0} &  82.80.7 & 70.40.8 & \textbf{52.41.1} & 2.5 \\
\textbf{SimpleCNAPS}\cite{bateni2020improved} & \textbf{58.61.1} & 91.70.6 & 82.40.7 & 74.90.8 & 67.80.8 & 77.70.7 & 46.91.0 & \textbf{90.70.5} & \textbf{73.50.7} & 46.21.1 & 2.4 \\
\textbf{URT} & 55.71.0 &  \textbf{94.40.4} &  \textbf{85.80.6} & \textbf{76.30.8} & \textbf{71.80.7} & \textbf{82.50.6} & \textbf{63.51.0} & 88.20.6 & 69.40.8 & \textbf{52.21.1} & 1.6 \\

\bottomrule
\end{tabular}
\label{table:main-results}
\end{table}



\subsection{Datasets and Setup}
We test our methods on the large-scale few-shot learning benchmark Meta-Dataset~\cite{triantafillou2019meta}. It consists of ten datasets with various data distributions across different domains, including natural images (Birds, Fungi, VGG Flower), hand-written characters (Omniglot, Quick Draw), and human created objects (Traffic Signs, Aircraft). Among the ten datasets, eight provide data that can be used during either training, validation and testing (with each class assigned to only one of those sets), while two datasets are solely used for testing. Following~\citet{bateni2020improved,requeima2019fast}, we also report results on MNIST~\cite{lecun1998gradient}, CIFAR10 and CIFAR100~\cite{krizhevsky2009learning} as additional unseen test datasets. Following \citet{triantafillou2019meta}, few-shot tasks are sampled with varying number of classes , varying number of shots  and class imbalance. 
The performance is reported as the average accuracy over 600 sampled tasks. More details of Meta-Dataset can be found in~\citet{triantafillou2019meta}.

The domain-specific backbones are pre-trained following the setup in~\cite{dvornik2020selecting}. Then, we freeze the backbone and train the URT layer for 10,000 episodes, with an initial learning rate of 0.01 and a cosine learning rate scheduler. 
Following~\citet{chen2020new}, the training episodes have 50\% probability coming from the ImageNet data source.
Since different pre-trained backbones may produce representations with different vector norms, we normalize the outputs of the backbones as in \citet{dvornik2020selecting}.
URT is trained with parameter weight decay of 1e-5 and with a regularization factor . The number of heads ( in Equation~\ref{eq:multi-head-urt}), is set to 2 and the dimension of the keys and queries ( in Equation~\ref{eq:class-attention}) is set to 1024.
We choose the hyper-parameters based on the performance of the validation set. Details of the hyper-parameter selection and how the performance is influenced by them are outlined in Section~\ref{sec:hyper-parameter-selection}.



\subsection{Comparison with Previous Approaches}
\label{ref:main-result}
Table~\ref{table:main-results} presents a comparison of URT with SUR, as well as other baselines based on transfer learning by fine-tuning~\cite{saikia2020optimized} or meta-learning (Prototypical Networks~\cite{snell2017prototypical}, first-order MAML~\cite{finn2017model}, ProtoMAML~\cite{triantafillou2019meta}, CNAPs~\cite{requeima2019fast}) and Simple~CNAPS\cite{bateni2020improved}.





\begin{wraptable}{r}{0.7\textwidth}
\centering
\setlength{\tabcolsep}{2.5pt}
\caption{
Test performance (mean+CI\%95) over 600 few-shot tasks on additional datasets.
}
\vspace{0.5em}
\begin{tabular}{lcccc}
\toprule
& \textbf{MNIST} & \textbf{CIFAR10} & \textbf{CIFAR100} & \textbf{avg. rank} \\
\midrule
\textbf{CNAPs}\cite{requeima2019fast} & 92.7  0.4 & 61.5  0.7 & 50.1  1.0 & 4.7 \\
\textbf{TaskNorm}\cite{bronskill2020tasknorm} & 92.3  0.4 & 69.3  0.8 & 54.6  1.1 & 3.3 \\
\textbf{SUR}\cite{dvornik2020selecting} & {\bf94.3  0.4} & 66.8  0.9 & 56.6  1.0 & 2.3  \\
\textbf{SimpleCNAPS}\cite{bateni2020improved} & 93.9  0.4 & \textbf{74.3  0.7} & \textbf{60.5  1.0} & 1.7 \\
\textbf{URT} & {\textbf{94.8  0.4}} & 67.3  0.8 & 56.9  1.0 & 2.0\\


   
   
\bottomrule
\end{tabular}
\label{table:additional-results}
\end{wraptable}

We observe in Table~\ref{table:main-results} that URT establishes a new state-of-the-art on Meta-Dataset, by achieving the top performance on 7 out of the 10 dataset sources. When comparing to its predecessor, URT outperforms SUR on 4 datasets without compromising performance on others, which is challenging to achieve in the multi-domain setting.
Of note, the average inference time for URT is 0.04 second per task, compared to 0.43 for SUR, on a single V100. Thus, getting rid of the optimization procedure for every episode with our meta-trained URT layer also significantly increases the latency, by more than 10.

We also report performances on the MNIST, CIFAR-10 and CIFAR-100 dataset sources in Table~\ref{table:additional-results}, and compare with the subset of methods that have reported on these datasets. There, URT neither improves nor gets worse performance than SUR, yeilding top performance on the MNIST domain but not on the CIFAR-10/CIFAR-100 domain, on which Simple~CNAPS has the best performance.



\begin{figure}[t!]
\begin{center}
\includegraphics[width=\linewidth]{resources/attention-score-v3.pdf}
\end{center}
\caption{
Average attention scores generated by URT with two heads. 
Rows correspond to the domain of the test tasks and the columns correspond to the pre-trained backbones  trained on the eight training domains.}
\label{fig:attention-score}
\end{figure}




\subsection{Interpreting and Visualizing Attention by URT}
To better understand how the URT model of Section~\ref{ref:main-result} uses its two heads to build adapted representations, we visualize the attention scores produced on the test tasks of Meta-Dataset in Figure~\ref{fig:attention-score}.



The blue (first head) and orange (second head) heatmaps summarize the values of the attention scores (Equation~\ref{eq:urt-attention}), averaged across several tasks for each test domain. Specifically, the element on row  and column  is the averaged attention scores  computed on test set domain  for the backbone from domain . Note that the last two rows are the two unseen domain datasets.
We found that for datasets from the seen domains, i.e.\ the first eight rows, one head (right, orange) consistently puts most of its weight on the backbone pre-trained on the same domain, while the other head (left, blue) learns relatively smoother weight distributions that blends other related domains. 
For unseen datasets, the right head puts half of its weight on ImageNet and the left head learned to blend the representations from four backbones.\looseness=-1






\subsection{URT using FiLM Modulated Backbones}

\begin{wraptable}{r}{0.46\textwidth}
\vspace{-5mm}
\centering
\setlength{\tabcolsep}{2.5pt}
\caption{
Performance comparison using parametric network family (pf) backbones.}\label{table:film-layer}
\begin{tabular}{lcccccc|c}
\toprule
   & \textbf{SUR-pf}~\cite{dvornik2020selecting} & \textbf{URT-pf} & \textbf{VS.} \\
\midrule
ILSVRC &  56.4  1.2 &  55.5  1.1 & =  \\ 
Omniglot &  88.5  0.8 & \textbf{90.2  0.6} & +\\ 
Aircraft &   79.5  0.8  & 79.8  0.7 & = \\
Birds & 76.4  0.9 & 77.5  0.8 & = \\ 
Textures & 73.1  0.7  & 73.5  0.7& = \\
Quick Draw &  75.7  0.7 & 75.8  0.7 & =\\
Fungi & 48.2  0.9 & 48.1  0.9 & = \\
VGG Flower &  90.6  0.5 & \textbf{91.9  0.5} & + \\
\midrule
Traffic Signs & 65.1  0.8 & \textbf{67.5  0.8} & + \\
MSCOCO &  52.1  1.0 & 52.1  1.0 & = \\
MNIST & 93.2  0.4  & 93.9  0.4 & = \\
CIFAR10   & 66.4  0.8 & 66.1  0.8 & = \\
CIFAR100 & 57.1  1.0  & 57.3  1.0 & = \\
\bottomrule
\end{tabular}
\vspace{-4mm}
\end{wraptable}
As additional evidence of the benefit of URT on universal representations, we also present experiments based on a different set of backbone architectures. 
Following SUR~\cite{dvornik2020selecting}, we consider the backbones from a parametric network family, obtained by training a base backbone on one dataset (ILSVRC) and then learning separate FiLM layers~\cite{film2018} for each other dataset, to modulate the backbone so it is adapted to the other domains. These backbones collectively have only 0.5\% more parameters than a single backbone.\looseness=-1



A comparison between SUR and URT using these backbones (referred to as SUR-pf and URT-pf) is presented in Table~\ref{table:film-layer}. Once again, URT improves the performance on three datasets without sacrificing performance on others. 
Additionally, URT-pf now achieves better performance than BOHB-E on VGGFlower.



\subsection{Hyper-Parameter and Ablation Studies}
\label{sec:hyper-parameter-selection}


We analyze the importance of the various components of URT's attention mechanism structure and training strategy in Table~\ref{table:ablation}.
First we analyze the importance of using the support set to model queries and/or keys. 
To this end, we consider setting the matrices  /  of the query / key linear transformation to 0, which only leaves the bias term.
We found that the support set representation is most crucial for building the keys (row  in the table) and has minor benefits for queries (row ) in the table.
This observation is possibly related to the success of attention-based models with learnable constant queries~\cite{liu2016learning,lin2017structured}.
We also found that adding a regularizer  as in Equation~\ref{eq:regularizer}  is important for some datasets, specifically VGG Flower and Birds.


\begin{table}[h!]
\centering
\setlength{\tabcolsep}{1.2pt}
\caption{
Meta-Dataset performance variation on ablations of elements of the URT layer.
}
\vspace{0.5em}
\begin{tabular}{lccccccccccccc}
\toprule
   & \textbf{\rot{ILSVRC}}  & \textbf{\rot{Omniglot}} & \textbf{\rot{Aircraft}} & \textbf{\rot{Birds}} & \textbf{\rot{Textures}} & \textbf{\rot{Draw}} & \textbf{\rot{Fungi}} & \textbf{\rot{Flower}} & \textbf{\rot{Signs}} &
   \textbf{\rot{MSCOCO}}  \\
\midrule
  &  +0.2 & -0.2 & -0.6 & -0.1 & -0.3 & -0.2 & 0.0 & -0.2 & -0.8 & -0.1  \\
  & -14.2 &  -2.8 & -10.7 & -18.1 & -7.6 & -9.3 & -22.4 & -3.6 & -0.26 & -10.9 \\
  & -14.2 & -2.8 & -10.7 & -18.1 & -7.6 & -9.2 & -22.4 & -3.6 & -0.26 & -10.9 \\
   &  0.0 & -0.9 & -0.4 & -3.3 & -1.2 & -0.2 & +0.3 & -9.0 & -2.0 & 0.0 \\  
\bottomrule
\end{tabular}
\label{table:ablation}
\end{table}


An important hyper-parameter in URT is the number of heads .
We chose this hyper-parameter based on the performance on validation set of tasks in Meta-Dataset. In Table~\ref{table:width-depth}, we show the validation performance of URT for varying number of heads. 
As suggested by \citet{triantafillou2019meta}, we considered looking at the rank of the performance achieved by each choice of  for each validation domains, and taking the average across domains as a validation metric. However, since the performances when using two to four heads are similar and yield the same average rank, we instead simply consider the average accuracy as the selection criteria. 

\begin{table}[h!]
\centering
\setlength{\tabcolsep}{4pt}
\caption{
Validation performance on Meta-Dataset using different number of heads
}
\vspace{0.5em}
\begin{tabular}{lccccccccc}
\toprule
    & \textbf{\rot{1}}  & \textbf{\rot{2}} & \textbf{\rot{3}} & \textbf{\rot{4}} & \textbf{\rot{5}} & \textbf{\rot{6}} & \textbf{\rot{7}} & \textbf{\rot{8}}
    \\
\midrule
Average Accuracy & 74.605 & 77.145 &  76.943 & 76.984 &  76.602 & 75.906 & 75.454  & 74.473 \\
Average Rank & 2.875 & 1.000 & 1.000 & 1.000 & 2.250 & 2.250 & 2.25 & 2.50 \\
\bottomrule
\end{tabular}
\label{table:width-depth}
\end{table}

In general, we observe a large jump in performance when using multiple heads instead of just one.
However, since the number of heads controls the capacity, predictably we also observe that having too many heads leads to overfitting. 


\section{Conclusion}
We proposed the URT layer to effectively integrate representations from multiple domains and demonstrated improved performance in multi-domain few-shot classification. 
Notably, our URT approach was able to set a new state-of-the-art on Meta-Dataset, and never performs worse than its predecessor (SUR) while also being  more efficient at inference.  
This work suggests that combining meta-learning with pre-trained universal representations is a promising direction for new few-shot learning methods. Specifically, we hope that future work can investigate the design of richer forms of universal representations that go beyond simply pre-training a single backbone for each domain, and developing meta-learners adapted to those settings.




\section*{Broader Impact}
Our URT model may present an interesting element of solution for applications that present difficulties in the collection and sharing of data. 
This could include settings where each user of an application has limited private data, and as such desires that a classification task be executed directly and solely on their devices.
Any deployment of the proposed model however should be preceded by an analysis of the potential biases captured by the dataset sources used for training and the correction of any such undesirable biases captured by the pre-trained backbones and model.



\section*{Acknowledgement}
We would like to thank Tianyi Zhou for paper review and suggestions. The computation support for this project is provided by Compute Canada and Google Cloud.
This project was supported by the Canada CIFAR AI Chairs program. 



\bibliographystyle{plainnat}{
\bibliography{abrv,neurips_2020}
}



\end{document}