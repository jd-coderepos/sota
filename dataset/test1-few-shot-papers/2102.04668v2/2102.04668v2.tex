
\documentclass{article} \usepackage{iclr2021_conference,times}



\usepackage{amsmath,amsfonts,bm}

\newcommand{\figleft}{{\em (Left)}}
\newcommand{\figcenter}{{\em (Center)}}
\newcommand{\figright}{{\em (Right)}}
\newcommand{\figtop}{{\em (Top)}}
\newcommand{\figbottom}{{\em (Bottom)}}
\newcommand{\captiona}{{\em (a)}}
\newcommand{\captionb}{{\em (b)}}
\newcommand{\captionc}{{\em (c)}}
\newcommand{\captiond}{{\em (d)}}

\newcommand{\newterm}[1]{{\bf #1}}


\def\figref#1{figure~\ref{#1}}
\def\Figref#1{Figure~\ref{#1}}
\def\twofigref#1#2{figures \ref{#1} and \ref{#2}}
\def\quadfigref#1#2#3#4{figures \ref{#1}, \ref{#2}, \ref{#3} and \ref{#4}}
\def\secref#1{section~\ref{#1}}
\def\Secref#1{Section~\ref{#1}}
\def\twosecrefs#1#2{sections \ref{#1} and \ref{#2}}
\def\secrefs#1#2#3{sections \ref{#1}, \ref{#2} and \ref{#3}}
\def\eqref#1{equation~\ref{#1}}
\def\Eqref#1{Equation~\ref{#1}}
\def\plaineqref#1{\ref{#1}}
\def\chapref#1{chapter~\ref{#1}}
\def\Chapref#1{Chapter~\ref{#1}}
\def\rangechapref#1#2{chapters\ref{#1}--\ref{#2}}
\def\algref#1{algorithm~\ref{#1}}
\def\Algref#1{Algorithm~\ref{#1}}
\def\twoalgref#1#2{algorithms \ref{#1} and \ref{#2}}
\def\Twoalgref#1#2{Algorithms \ref{#1} and \ref{#2}}
\def\partref#1{part~\ref{#1}}
\def\Partref#1{Part~\ref{#1}}
\def\twopartref#1#2{parts \ref{#1} and \ref{#2}}

\def\ceil#1{\lceil #1 \rceil}
\def\floor#1{\lfloor #1 \rfloor}
\def\1{\bm{1}}
\newcommand{\train}{\mathcal{D}}
\newcommand{\valid}{\mathcal{D_{\mathrm{valid}}}}
\newcommand{\test}{\mathcal{D_{\mathrm{test}}}}

\def\eps{{\epsilon}}


\def\reta{{\textnormal{}}}
\def\ra{{\textnormal{a}}}
\def\rb{{\textnormal{b}}}
\def\rc{{\textnormal{c}}}
\def\rd{{\textnormal{d}}}
\def\re{{\textnormal{e}}}
\def\rf{{\textnormal{f}}}
\def\rg{{\textnormal{g}}}
\def\rh{{\textnormal{h}}}
\def\ri{{\textnormal{i}}}
\def\rj{{\textnormal{j}}}
\def\rk{{\textnormal{k}}}
\def\rl{{\textnormal{l}}}
\def\rn{{\textnormal{n}}}
\def\ro{{\textnormal{o}}}
\def\rp{{\textnormal{p}}}
\def\rq{{\textnormal{q}}}
\def\rr{{\textnormal{r}}}
\def\rs{{\textnormal{s}}}
\def\rt{{\textnormal{t}}}
\def\ru{{\textnormal{u}}}
\def\rv{{\textnormal{v}}}
\def\rw{{\textnormal{w}}}
\def\rx{{\textnormal{x}}}
\def\ry{{\textnormal{y}}}
\def\rz{{\textnormal{z}}}

\def\rvepsilon{{\mathbf{\epsilon}}}
\def\rvtheta{{\mathbf{\theta}}}
\def\rva{{\mathbf{a}}}
\def\rvb{{\mathbf{b}}}
\def\rvc{{\mathbf{c}}}
\def\rvd{{\mathbf{d}}}
\def\rve{{\mathbf{e}}}
\def\rvf{{\mathbf{f}}}
\def\rvg{{\mathbf{g}}}
\def\rvh{{\mathbf{h}}}
\def\rvu{{\mathbf{i}}}
\def\rvj{{\mathbf{j}}}
\def\rvk{{\mathbf{k}}}
\def\rvl{{\mathbf{l}}}
\def\rvm{{\mathbf{m}}}
\def\rvn{{\mathbf{n}}}
\def\rvo{{\mathbf{o}}}
\def\rvp{{\mathbf{p}}}
\def\rvq{{\mathbf{q}}}
\def\rvr{{\mathbf{r}}}
\def\rvs{{\mathbf{s}}}
\def\rvt{{\mathbf{t}}}
\def\rvu{{\mathbf{u}}}
\def\rvv{{\mathbf{v}}}
\def\rvw{{\mathbf{w}}}
\def\rvx{{\mathbf{x}}}
\def\rvy{{\mathbf{y}}}
\def\rvz{{\mathbf{z}}}

\def\erva{{\textnormal{a}}}
\def\ervb{{\textnormal{b}}}
\def\ervc{{\textnormal{c}}}
\def\ervd{{\textnormal{d}}}
\def\erve{{\textnormal{e}}}
\def\ervf{{\textnormal{f}}}
\def\ervg{{\textnormal{g}}}
\def\ervh{{\textnormal{h}}}
\def\ervi{{\textnormal{i}}}
\def\ervj{{\textnormal{j}}}
\def\ervk{{\textnormal{k}}}
\def\ervl{{\textnormal{l}}}
\def\ervm{{\textnormal{m}}}
\def\ervn{{\textnormal{n}}}
\def\ervo{{\textnormal{o}}}
\def\ervp{{\textnormal{p}}}
\def\ervq{{\textnormal{q}}}
\def\ervr{{\textnormal{r}}}
\def\ervs{{\textnormal{s}}}
\def\ervt{{\textnormal{t}}}
\def\ervu{{\textnormal{u}}}
\def\ervv{{\textnormal{v}}}
\def\ervw{{\textnormal{w}}}
\def\ervx{{\textnormal{x}}}
\def\ervy{{\textnormal{y}}}
\def\ervz{{\textnormal{z}}}

\def\rmA{{\mathbf{A}}}
\def\rmB{{\mathbf{B}}}
\def\rmC{{\mathbf{C}}}
\def\rmD{{\mathbf{D}}}
\def\rmE{{\mathbf{E}}}
\def\rmF{{\mathbf{F}}}
\def\rmG{{\mathbf{G}}}
\def\rmH{{\mathbf{H}}}
\def\rmI{{\mathbf{I}}}
\def\rmJ{{\mathbf{J}}}
\def\rmK{{\mathbf{K}}}
\def\rmL{{\mathbf{L}}}
\def\rmM{{\mathbf{M}}}
\def\rmN{{\mathbf{N}}}
\def\rmO{{\mathbf{O}}}
\def\rmP{{\mathbf{P}}}
\def\rmQ{{\mathbf{Q}}}
\def\rmR{{\mathbf{R}}}
\def\rmS{{\mathbf{S}}}
\def\rmT{{\mathbf{T}}}
\def\rmU{{\mathbf{U}}}
\def\rmV{{\mathbf{V}}}
\def\rmW{{\mathbf{W}}}
\def\rmX{{\mathbf{X}}}
\def\rmY{{\mathbf{Y}}}
\def\rmZ{{\mathbf{Z}}}

\def\ermA{{\textnormal{A}}}
\def\ermB{{\textnormal{B}}}
\def\ermC{{\textnormal{C}}}
\def\ermD{{\textnormal{D}}}
\def\ermE{{\textnormal{E}}}
\def\ermF{{\textnormal{F}}}
\def\ermG{{\textnormal{G}}}
\def\ermH{{\textnormal{H}}}
\def\ermI{{\textnormal{I}}}
\def\ermJ{{\textnormal{J}}}
\def\ermK{{\textnormal{K}}}
\def\ermL{{\textnormal{L}}}
\def\ermM{{\textnormal{M}}}
\def\ermN{{\textnormal{N}}}
\def\ermO{{\textnormal{O}}}
\def\ermP{{\textnormal{P}}}
\def\ermQ{{\textnormal{Q}}}
\def\ermR{{\textnormal{R}}}
\def\ermS{{\textnormal{S}}}
\def\ermT{{\textnormal{T}}}
\def\ermU{{\textnormal{U}}}
\def\ermV{{\textnormal{V}}}
\def\ermW{{\textnormal{W}}}
\def\ermX{{\textnormal{X}}}
\def\ermY{{\textnormal{Y}}}
\def\ermZ{{\textnormal{Z}}}

\def\vzero{{\bm{0}}}
\def\vone{{\bm{1}}}
\def\vmu{{\bm{\mu}}}
\def\vtheta{{\bm{\theta}}}
\def\va{{\bm{a}}}
\def\vb{{\bm{b}}}
\def\vc{{\bm{c}}}
\def\vd{{\bm{d}}}
\def\ve{{\bm{e}}}
\def\vf{{\bm{f}}}
\def\vg{{\bm{g}}}
\def\vh{{\bm{h}}}
\def\vi{{\bm{i}}}
\def\vj{{\bm{j}}}
\def\vk{{\bm{k}}}
\def\vl{{\bm{l}}}
\def\vm{{\bm{m}}}
\def\vn{{\bm{n}}}
\def\vo{{\bm{o}}}
\def\vp{{\bm{p}}}
\def\vq{{\bm{q}}}
\def\vr{{\bm{r}}}
\def\vs{{\bm{s}}}
\def\vt{{\bm{t}}}
\def\vu{{\bm{u}}}
\def\vv{{\bm{v}}}
\def\vw{{\bm{w}}}
\def\vx{{\bm{x}}}
\def\vy{{\bm{y}}}
\def\vz{{\bm{z}}}

\def\evalpha{{\alpha}}
\def\evbeta{{\beta}}
\def\evepsilon{{\epsilon}}
\def\evlambda{{\lambda}}
\def\evomega{{\omega}}
\def\evmu{{\mu}}
\def\evpsi{{\psi}}
\def\evsigma{{\sigma}}
\def\evtheta{{\theta}}
\def\eva{{a}}
\def\evb{{b}}
\def\evc{{c}}
\def\evd{{d}}
\def\eve{{e}}
\def\evf{{f}}
\def\evg{{g}}
\def\evh{{h}}
\def\evi{{i}}
\def\evj{{j}}
\def\evk{{k}}
\def\evl{{l}}
\def\evm{{m}}
\def\evn{{n}}
\def\evo{{o}}
\def\evp{{p}}
\def\evq{{q}}
\def\evr{{r}}
\def\evs{{s}}
\def\evt{{t}}
\def\evu{{u}}
\def\evv{{v}}
\def\evw{{w}}
\def\evx{{x}}
\def\evy{{y}}
\def\evz{{z}}

\def\mA{{\bm{A}}}
\def\mB{{\bm{B}}}
\def\mC{{\bm{C}}}
\def\mD{{\bm{D}}}
\def\mE{{\bm{E}}}
\def\mF{{\bm{F}}}
\def\mG{{\bm{G}}}
\def\mH{{\bm{H}}}
\def\mI{{\bm{I}}}
\def\mJ{{\bm{J}}}
\def\mK{{\bm{K}}}
\def\mL{{\bm{L}}}
\def\mM{{\bm{M}}}
\def\mN{{\bm{N}}}
\def\mO{{\bm{O}}}
\def\mP{{\bm{P}}}
\def\mQ{{\bm{Q}}}
\def\mR{{\bm{R}}}
\def\mS{{\bm{S}}}
\def\mT{{\bm{T}}}
\def\mU{{\bm{U}}}
\def\mV{{\bm{V}}}
\def\mW{{\bm{W}}}
\def\mX{{\bm{X}}}
\def\mY{{\bm{Y}}}
\def\mZ{{\bm{Z}}}
\def\mBeta{{\bm{\beta}}}
\def\mPhi{{\bm{\Phi}}}
\def\mLambda{{\bm{\Lambda}}}
\def\mSigma{{\bm{\Sigma}}}

\DeclareMathAlphabet{\mathsfit}{\encodingdefault}{\sfdefault}{m}{sl}
\SetMathAlphabet{\mathsfit}{bold}{\encodingdefault}{\sfdefault}{bx}{n}
\newcommand{\tens}[1]{\bm{\mathsfit{#1}}}
\def\tA{{\tens{A}}}
\def\tB{{\tens{B}}}
\def\tC{{\tens{C}}}
\def\tD{{\tens{D}}}
\def\tE{{\tens{E}}}
\def\tF{{\tens{F}}}
\def\tG{{\tens{G}}}
\def\tH{{\tens{H}}}
\def\tI{{\tens{I}}}
\def\tJ{{\tens{J}}}
\def\tK{{\tens{K}}}
\def\tL{{\tens{L}}}
\def\tM{{\tens{M}}}
\def\tN{{\tens{N}}}
\def\tO{{\tens{O}}}
\def\tP{{\tens{P}}}
\def\tQ{{\tens{Q}}}
\def\tR{{\tens{R}}}
\def\tS{{\tens{S}}}
\def\tT{{\tens{T}}}
\def\tU{{\tens{U}}}
\def\tV{{\tens{V}}}
\def\tW{{\tens{W}}}
\def\tX{{\tens{X}}}
\def\tY{{\tens{Y}}}
\def\tZ{{\tens{Z}}}


\def\gA{{\mathcal{A}}}
\def\gB{{\mathcal{B}}}
\def\gC{{\mathcal{C}}}
\def\gD{{\mathcal{D}}}
\def\gE{{\mathcal{E}}}
\def\gF{{\mathcal{F}}}
\def\gG{{\mathcal{G}}}
\def\gH{{\mathcal{H}}}
\def\gI{{\mathcal{I}}}
\def\gJ{{\mathcal{J}}}
\def\gK{{\mathcal{K}}}
\def\gL{{\mathcal{L}}}
\def\gM{{\mathcal{M}}}
\def\gN{{\mathcal{N}}}
\def\gO{{\mathcal{O}}}
\def\gP{{\mathcal{P}}}
\def\gQ{{\mathcal{Q}}}
\def\gR{{\mathcal{R}}}
\def\gS{{\mathcal{S}}}
\def\gT{{\mathcal{T}}}
\def\gU{{\mathcal{U}}}
\def\gV{{\mathcal{V}}}
\def\gW{{\mathcal{W}}}
\def\gX{{\mathcal{X}}}
\def\gY{{\mathcal{Y}}}
\def\gZ{{\mathcal{Z}}}

\def\sA{{\mathbb{A}}}
\def\sB{{\mathbb{B}}}
\def\sC{{\mathbb{C}}}
\def\sD{{\mathbb{D}}}
\def\sF{{\mathbb{F}}}
\def\sG{{\mathbb{G}}}
\def\sH{{\mathbb{H}}}
\def\sI{{\mathbb{I}}}
\def\sJ{{\mathbb{J}}}
\def\sK{{\mathbb{K}}}
\def\sL{{\mathbb{L}}}
\def\sM{{\mathbb{M}}}
\def\sN{{\mathbb{N}}}
\def\sO{{\mathbb{O}}}
\def\sP{{\mathbb{P}}}
\def\sQ{{\mathbb{Q}}}
\def\sR{{\mathbb{R}}}
\def\sS{{\mathbb{S}}}
\def\sT{{\mathbb{T}}}
\def\sU{{\mathbb{U}}}
\def\sV{{\mathbb{V}}}
\def\sW{{\mathbb{W}}}
\def\sX{{\mathbb{X}}}
\def\sY{{\mathbb{Y}}}
\def\sZ{{\mathbb{Z}}}

\def\emLambda{{\Lambda}}
\def\emA{{A}}
\def\emB{{B}}
\def\emC{{C}}
\def\emD{{D}}
\def\emE{{E}}
\def\emF{{F}}
\def\emG{{G}}
\def\emH{{H}}
\def\emI{{I}}
\def\emJ{{J}}
\def\emK{{K}}
\def\emL{{L}}
\def\emM{{M}}
\def\emN{{N}}
\def\emO{{O}}
\def\emP{{P}}
\def\emQ{{Q}}
\def\emR{{R}}
\def\emS{{S}}
\def\emT{{T}}
\def\emU{{U}}
\def\emV{{V}}
\def\emW{{W}}
\def\emX{{X}}
\def\emY{{Y}}
\def\emZ{{Z}}
\def\emSigma{{\Sigma}}

\newcommand{\etens}[1]{\mathsfit{#1}}
\def\etLambda{{\etens{\Lambda}}}
\def\etA{{\etens{A}}}
\def\etB{{\etens{B}}}
\def\etC{{\etens{C}}}
\def\etD{{\etens{D}}}
\def\etE{{\etens{E}}}
\def\etF{{\etens{F}}}
\def\etG{{\etens{G}}}
\def\etH{{\etens{H}}}
\def\etI{{\etens{I}}}
\def\etJ{{\etens{J}}}
\def\etK{{\etens{K}}}
\def\etL{{\etens{L}}}
\def\etM{{\etens{M}}}
\def\etN{{\etens{N}}}
\def\etO{{\etens{O}}}
\def\etP{{\etens{P}}}
\def\etQ{{\etens{Q}}}
\def\etR{{\etens{R}}}
\def\etS{{\etens{S}}}
\def\etT{{\etens{T}}}
\def\etU{{\etens{U}}}
\def\etV{{\etens{V}}}
\def\etW{{\etens{W}}}
\def\etX{{\etens{X}}}
\def\etY{{\etens{Y}}}
\def\etZ{{\etens{Z}}}

\newcommand{\pdata}{p_{\rm{data}}}
\newcommand{\ptrain}{\hat{p}_{\rm{data}}}
\newcommand{\Ptrain}{\hat{P}_{\rm{data}}}
\newcommand{\pmodel}{p_{\rm{model}}}
\newcommand{\Pmodel}{P_{\rm{model}}}
\newcommand{\ptildemodel}{\tilde{p}_{\rm{model}}}
\newcommand{\pencode}{p_{\rm{encoder}}}
\newcommand{\pdecode}{p_{\rm{decoder}}}
\newcommand{\precons}{p_{\rm{reconstruct}}}

\newcommand{\laplace}{\mathrm{Laplace}} 

\newcommand{\E}{\mathbb{E}}
\newcommand{\Ls}{\mathcal{L}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\emp}{\tilde{p}}
\newcommand{\lr}{\alpha}
\newcommand{\reg}{\lambda}
\newcommand{\rect}{\mathrm{rectifier}}
\newcommand{\softmax}{\mathrm{softmax}}
\newcommand{\sigmoid}{\sigma}
\newcommand{\softplus}{\zeta}
\newcommand{\KL}{D_{\mathrm{KL}}}
\newcommand{\Var}{\mathrm{Var}}
\newcommand{\standarderror}{\mathrm{SE}}
\newcommand{\Cov}{\mathrm{Cov}}
\newcommand{\normlzero}{L^0}
\newcommand{\normlone}{L^1}
\newcommand{\normltwo}{L^2}
\newcommand{\normlp}{L^p}
\newcommand{\normmax}{L^\infty}

\newcommand{\parents}{Pa} 

\DeclareMathOperator*{\argmax}{arg\,max}
\DeclareMathOperator*{\argmin}{arg\,min}

\DeclareMathOperator{\sign}{sign}
\DeclareMathOperator{\Tr}{Tr}
\let\ab\allowbreak
 \usepackage{multicol}
\usepackage{multirow}
\usepackage{hyperref}
\usepackage{url}
\usepackage{enumitem}
\usepackage{svg}
\usepackage{caption}
\usepackage[ruled]{algorithm2e}
\usepackage{amsthm}
\usepackage{xcolor}
\definecolor{applegreen}{rgb}{0.3, 0.7, 0.3}

\usepackage{scrwfile}
\TOCclone[\contentsname~(\appendixname)]{toc}{atoc}
\newcommand\StartAppendixEntries{}
\AfterTOCHead[toc]{\renewcommand\StartAppendixEntries{\value{tocdepth}=-10000\relax}}
\AfterTOCHead[atoc]{\edef\maintocdepth{\the\value{tocdepth}}\value{tocdepth}=-10000\relax \renewcommand\StartAppendixEntries{\value{tocdepth}=\maintocdepth\relax}}
\newcommand*\appendixwithtoc{\cleardoublepage
  \appendix
  \addtocontents{toc}{\protect\StartAppendixEntries}
  \listofatoc
}

\renewcommand \thepart{}
\renewcommand \partname{}

\newtheorem{theorem}{Theorem}[section]
\newtheorem{corollary}{Corollary}[theorem]
\newtheorem{lemma}{Lemma}[theorem]
\usepackage{comment}
\usepackage{subcaption}
\usepackage{pifont}
\newcommand{\cmark}{\ding{51}}\newcommand{\xmark}{\ding{55}}\newenvironment{problem}[2][Problem]{\begin{trivlist}
\item[\hskip \labelsep {\bfseries #1}\hskip \labelsep {\bfseries #2.}]}{\end{trivlist}}
\usepackage{wrapfig}
\title{MALI: A memory efficient and reverse accurate integrator for Neural ODEs}



\author{Juntang Zhuang; Nicha C. Dvornek; Sekhar Tatikonda; James S. Duncan \\
\texttt{\{j.zhuang; nicha.dvornek; sekhar.tatikonda; james.duncan\} @yale.edu} \\
Yale University, New Haven, CT, USA
}



\newcommand{\fix}{\marginpar{FIX}}
\newcommand{\new}{\marginpar{NEW}}

\iclrfinalcopy \begin{document}


\maketitle

\begin{abstract}
Neural ordinary differential equations (Neural ODEs) are a new family of deep-learning models with continuous depth. 
However, the numerical estimation of the gradient in the continuous case is not well solved: existing implementations of the adjoint method suffer from inaccuracy in reverse-time trajectory, while the naive method and the adaptive checkpoint adjoint method (ACA) have a memory cost that grows with integration time. In this project, based on the asynchronous leapfrog (ALF) solver, we propose the Memory-efficient ALF Integrator (MALI), which has a constant memory cost \textit{w.r.t} number of solver steps in integration similar to the adjoint method, and guarantees accuracy in reverse-time trajectory (hence accuracy in gradient estimation). We validate MALI in various tasks: on image recognition tasks, to our knowledge, MALI is the first to enable feasible training of a Neural ODE on ImageNet and outperform a well-tuned ResNet, 
while existing methods fail due to either heavy memory burden or inaccuracy; for time series modeling, MALI significantly outperforms the adjoint method; and for continuous generative models, MALI achieves new state-of-the-art performance.Code is available at https://github.com/juntang-zhuang/TorchDiffEqPack
\end{abstract}

\section{Introduction}
Recent research builds the connection between continuous models and neural networks. The theory of dynamical systems has been applied to analyze the properties of neural networks or guide the design of networks \citep{weinan2017proposal, ruthotto2019deep, lu2018beyond}. In these works, a residual block \citep{he2016deep} is typically viewed as a one-step Euler discretization of an ODE; instead of directly analyzing the discretized neural network, it might be easier to analyze the ODE. 

Another direction is the neural ordinary differential equation (Neural ODE) \citep{chen2018neural}, which takes a continuous depth instead of discretized depth. The dynamics of a Neural ODE is typically approximated by numerical integration with adaptive ODE solvers. Neural ODEs have been applied in irregularly sampled time-series \citep{rubanova2019latent}, free-form continuous generative models \citep{grathwohl2018ffjord, finlay2020train}, mean-field games \citep{ruthotto2020machine}, stochastic differential equations \citep{li2020scalable} and physically informed modeling \citep{sanchez2019hamiltonian, zhong2019symplectic}.

Though the Neural ODE has been widely applied in practice, how to train it is not extensively studied. The \textit{naive method} directly backpropagates through an ODE solver, but tracking a continuous trajectory requires a huge memory. \citet{chen2018neural} proposed to use the \textit{adjoint method} to determine the gradient in continuous cases, which achieves constant memory cost \textit{w.r.t} integration time; however, as pointed out by \citet{zhuang2020adaptive}, the adjoint method suffers from numerical errors due to the inaccuracy in reverse-time trajectory. \citet{zhuang2020adaptive} proposed the \textit{adaptive checkpoint adjoint (ACA)} method to achieve accuracy in gradient estimation at a much smaller memory cost compared to the naive method, yet the memory consumption of ACA still grows linearly with integration time. Due to the non-constant memory cost, neither ACA nor naive method are suitable for large scale datasets (e.g. ImageNet) or high-dimensional Neural ODEs (e.g. FFJORD \citep{grathwohl2018ffjord}).

In this project, we propose the Memory-efficient Asynchronous Leapfrog Integrator (MALI) to achieve advantages of both the adjoint method and ACA: constant memory cost \textit{w.r.t} integration time and accuracy in reverse-time trajectory. MALI is based on the asynchronous leapfrog (ALF) integrator \citep{mutze2013asynchronous}. With the ALF integrator, each numerical step forward in time is reversible. Therefore, with MALI, we delete the trajectory and only keep the end-time states, hence achieve constant memory cost \textit{w.r.t} integration time; using the reversibility, we can accurately reconstruct the trajectory from the end-time value, hence achieve accuracy in gradient. Our contributions are:
\begin{enumerate}[leftmargin=*]
\item We propose a new method (MALI) to solve Neural ODEs, which achieves constant memory cost \textit{w.r.t} number of solver steps in integration and accuracy in gradient estimation. We provide theoretical analysis.\item We validate our method with extensive experiments: (a) for image classification tasks, MALI enables a Neural ODE to achieve better accuracy than a well-tuned ResNet with the same number of parameters; to our knowledge, MALI is the first method to enable training of Neural ODEs on a large-scale dataset such as ImageNet, while existing methods fail due to either heavy memory burden or inaccuracy. (b) In time-series modeling, MALI achieves comparable or better results than other methods. (c) For generative modeling, a FFJORD model trained with MALI achieves new state-of-the-art results on MNIST and Cifar10.
\end{enumerate}
\section{Preliminaries}
\subsection{Numerical Integration Methods}
An ordinary differential equation (ODE) typically takes the form

where  is the hidden state evolving with time,  is the end time,  is the start time (typically 0),  is the initial state. The derivative of  w.r.t  is defined by a function , and  is defined as a sequence of layers parameterized by . The loss function is , where  is the target variable. Eq.~\ref{eq:NODE} is called the initial value problem (IVP) because only  is specified.
\begin{wrapfigure}{r}{0.45\textwidth}
\begin{minipage}{\linewidth}
\scalebox{0.92}{
\begin{algorithm}[H]
\label{alg:int}
\SetAlgorithmName{Algorithm}{} \\
\textbf{Input} initial state , start time , end time , error tolerance , initial stepsize .\\
\textbf{Initialize} \\
\textbf{While}  \\
\hspace{8mm}  \\
\hspace{8mm} \textbf{While}  \\
\hspace{16mm}  \\
\hspace{16mm}  \\
\hspace{8mm} \textbf{If} \\ 
\hspace{16mm}  \\
\hspace{8mm} 
\caption{Numerical Integration}
\end{algorithm}
}
\end{minipage}
\vspace{-4mm}
\end{wrapfigure} \\
\textbf{Notations} \ \ We summarize the notations following \citet{zhuang2020adaptive}.
\begin{itemize}[topsep=0pt,parsep=0pt,partopsep=0pt,leftmargin=*]
\item : hidden state in forward/reverse time trajectory at time .
\item : the \textit{numerical} solution at time , starting from  with a stepsize .
\item :  is the number of layers in  in Eq.~\ref{eq:NODE},  is the dimension of .
\item : number of discretized points (outer iterations in Algo.~\ref{alg:int}) in forward / reverse integration. \item : average number of inner iterations in Algo.~\ref{alg:int} to find an acceptable stepsize.
\end{itemize} 
\textbf{Numerical Integration} \ \ The algorithm for general adaptive-stepsize numerical ODE solvers is summarized in Algo.~\ref{alg:int} \citep{wanner1996solving}. The solver repeatedly advances in time by a step, which is the outer loop in Algo.~\ref{alg:int} (blue curve in Fig.~\ref{fig:forward}). For each step, the solver decreases the stepsize until the estimate of error
is lower than the tolerance, which is the inner loop in Algo.~\ref{alg:int} (green curve in Fig.~\ref{fig:forward}). For fixed-stepsize solvers, the inner loop is replaced with a single evaluation of  using predefined stepsize . Different methods typically use different , for example different orders of the Runge-Kutta method \citep{runge1895numerische}. 
\subsection{Analytical form of gradient in continuous case}
We first briefly introduce the analytical form of the gradient in the continuous case, then we compare different numerical implementations in the literature to estimate the gradient. The analytical form of the gradient in the continuous case is


where  is the ``adjoint state''. Detailed proof is given in \citep{pontryagin2018mathematical}. In the next section we compare different numerical implementations of this analytical form.
\begin{table*}[t]
\centering
\caption{\small{Comparison between different methods for gradient estimation in continuous case. MALI achieves reverse accuracy, constant memory \textit{w.r.t} number of solver steps in integration, shallow computation graph and low computation cost.}}
\label{table:comparison}
\vspace{-2mm}
\scalebox{0.73}{
\begin{tabular}{c|ccc|c}
\hline
                  & Naive & Adjoint & ACA & MALI \\ \hline
Computation      &        &        &  &  \\
Memory           &       &   &   &      \\ Computation graph depth &  &  &  &  \\
Reverse accuracy &  {\color{applegreen}\cmark}     &      {\color{red}\xmark}     & {\color{applegreen}\cmark}  & {\color{applegreen}\cmark}   \\

\hline
\end{tabular}
}
\end{table*}
\begin{figure*}
\centering
    \begin{minipage}{0.45\textwidth}
    \centering
        \includegraphics[ width=\linewidth]{figures/windermere3.png}
        \captionof{figure}{\small{Illustration of numerical solver in forward-pass. For adaptive solvers, for each step forward-in-time, the stepsize is recursively adjusted until the estimated error is below predefined tolerance; the search process is represented by green curve, and the accepted step (ignore the search process) is represented by blue curve. 
}}
\label{fig:forward}
    \end{minipage}
    \hfill
    \begin{minipage}{0.45\textwidth}
    \centering
        \includegraphics[width=\linewidth]{figures/windermere_4.png} \captionof{figure}{\small{In backward-pass, the adjoint method reconstructs trajectory as a separate IVP. Naive, ACA and MALI track the forward-time trajectory, hence are accurate. ACA and MALI only backpropagate through the accepted step, while naive method backpropagates through the search process hence has deeper computation graphs.
}}
\label{fig:backward}
    \end{minipage}
    \vspace{-3mm}
\end{figure*}
\subsection{Numerical implementations in the literature for the analytical form}
We compare different numerical implementations of the analytical form in this section. The forward-pass and backward-pass of different methods are demonstrated in Fig.~\ref{fig:forward} and Fig.~\ref{fig:backward} respectively. Forward-pass is similar for different methods. 
The comparison of backward-pass among different methods are summarized in Table.~\ref{table:comparison}. We explain methods in the literature below.

\textbf{Naive method}\ \ The naive method saves all of the computation graph (including search for optimal stepsize, green curve in Fig.~\ref{fig:backward}) in memory, and backpropagates through it. Hence the memory cost is  and depth of computation graph are , and the computation is doubled considering both forward and backward passes. Besides the large memory and computation, the deep computation graph might cause vanishing or exploding gradient \citep{pascanu2013difficulty}.

\textbf{Adjoint method}\ \ Note that we use ``\textit{adjoint state equation}'' to refer to the \textit{analytical form} in Eq.~\ref{eq:analytic_grad} and \ref{eq:lambda_ode}, while we use ``\textit{adjoint method}'' to refer to the \textit{numerical implementation} by \citet{chen2018neural}. As in Fig.~\ref{fig:forward} and ~\ref{fig:backward}, the adjoint method forgets forward-time trajectory (blue curve) to achieve memory cost  which is constant to integration time; it takes the end-time state (derived from forward-time integration) as the initial state, and solves a separate IVP (red curve) in reverse-time.\begin{theorem}\citep{zhuang2020adaptive}
\label{thm:error_adj}
For an ODE solver of order , the error of the reconstructed initial value by the adjoint method is , where  is the ideal solution,  is the Jacobian of ,  and  are the local error in forward-time and reverse-time integration respectively.
\end{theorem}
Theorem~\ref{thm:error_adj} is stated as Theorem 3.2 in \citet{zhuang2020adaptive}; please see reference paper for detailed proof. To summarize, due to inevitable errors with numerical ODE solvers, the reverse-time trajectory (red curve, ) cannot match the forward-time trajectory (blue curve, ) accurately. The error in  propagates to  by Eq.~\ref{eq:analytic_grad}, hence affects the accuracy in gradient estimation.

\textbf{Adaptive checkpoint adjoint (ACA)}\ \ 
To solve the inaccuracy of adjoint method, \citet{zhuang2020adaptive} proposed ACA: ACA stores forward-time trajectory in memory for backward-pass, hence guarantees accuracy; ACA deletes the search process (green curve in Fig.~\ref{fig:backward}), and only back-propagates through the accepted step (blue curve in Fig.~\ref{fig:backward}), hence has a shallower computation graph ( for ACA vs  for naive method). ACA only stores , and deletes the computation graph for , hence the memory cost is . Though the memory cost is much smaller than the naive method, it grows linearly with , and can not handle very high dimensional models. In the following sections, we propose a method to overcome all these disadvantages of existing methods.
\section{Methods}
\subsection{Asynchronous Leapfrog Integrator}
\label{subsec:ALF}
In this section we give a brief introduction to the asynchronous leapfrog (ALF) method \citep{mutze2013asynchronous}, and we provide theoretical analysis which is missing in \citet{mutze2013asynchronous}. 
For general first-order ODEs in the form of Eq.~\ref{eq:NODE}, the tuple  is sufficient for most ODE solvers to take a step numerically. For ALF, the required tuple is , where  is the ``approximated derivative''. Most numerical ODE solvers such as the Runge-Kutta method \citep{runge1895numerische} track state  evolving with time, while ALF tracks the ``augmented state'' .
We explain the details of ALF as below. 
\begin{minipage}{0.48\textwidth}
\begin{algorithm}[H]
\label{alg:ALF_forward}
\SetAlgorithmName{Algorithm}{} \\
\textbf{Input}  where  is current time,  and  are correponding values at time ,  is stepsize.\\
\textbf{Forward} \hspace{3mm} \\
\hspace{16mm}  \\
\hspace{16mm}  \\
\hspace{16mm}  \\
\hspace{16mm}  \\
\hspace{16mm}  \\
\textbf{Output} \hspace{4mm}\scalebox{0.95}{}
\caption{Forward of  in ALF}
\end{algorithm}
\end{minipage}
\hfill
\begin{minipage}{0.48\textwidth}
\begin{algorithm}[H]
\label{alg:ALF_inverse}
\SetAlgorithmName{Algorithm}{} \\
\textbf{Input}  where  is current time,  and  are corresponding values at ,  is stepsize.\\
\textbf{Inverse} \hspace{5mm} \\
\hspace{16mm}  \\
\hspace{16mm}  \\
\hspace{16mm}  \\
\hspace{16mm}  \\
\hspace{16mm}  \\
\textbf{Output} \hspace{4mm} 
\caption{  (Inverse of ) in ALF}
\end{algorithm}
\end{minipage}

\begin{wrapfigure}{r}{0.43\textwidth}
\begin{minipage}{\linewidth}
\centering
\includegraphics[width=\linewidth]{figures/ALF_bidirection2.png}
\vspace{-6mm}
\captionof{figure}{\small{With ALF method, given any tuple  and discretized time points , we can reconstruct the entire trajectory accurately due to the reversibility of ALF.}}
\label{fig:recon}
\end{minipage}
\end{wrapfigure}

\textbf{Procedure of ALF}\ \ Different ODE solvers have different  in Algo.~\ref{alg:int}, hence we only summarize  for ALF in Algo.~\ref{alg:ALF_forward}. Note that for a complete algorithm of integration for ALF, we need to plug Algo.~\ref{alg:ALF_forward} into Algo.~\ref{alg:int}. The forward-pass is summarized in Algo.~\ref{alg:ALF_forward}. Given stepsize , with input , a single step of ALF outputs .

As in Fig.~\ref{fig:recon}, given , the numerical forward-time integration calls Algo.~\ref{alg:ALF_forward} iteratively:

\textbf{Invertibility of ALF}\ \ An interesting property of ALF is that  defines a bijective mapping; therefore, we can reconstruct  from , as demonstrated in Algo.~\ref{alg:ALF_inverse}. As in Fig.~\ref{fig:recon}, 
we can reconstruct the entire trajectory given the state  at time , and the discretized time points . For example, given  and , the trajectory for Eq.~\ref{eq:all_forward}
is reconstructed:

In the following sections, we will show the invertibility of ALF is the key to maintain accuracy at a constant memory cost to train Neural ODEs. 
Note that ``inverse'' refers to reconstructing the input from the output without computing the gradient, hence is different from ``back-propagation''. 

\textbf{Initial value}\ \  For an initial value problem (IVP) such as Eq.~\ref{eq:NODE}, typically  is given while  is undetermined. We can construct , so the initial augmented state is . 

\textbf{Difference from midpoint integrator} \ \ The midpoint integrator \citep{suli2003introduction} is similar to Algo.~\ref{alg:ALF_forward}, except that it recomputes  for every step, while ALF directly uses the input . Therefore, the midpoint method does not have an explicit form of inverse.

\textbf{Local truncation error} \ \  Theorem~\ref{theorem:truncation} indicates that the local truncation error of ALF is of order ; this implies the global error is . Detailed proof is in Appendix~\ref{sup:subsec:localerror}.
\begin{theorem}
\label{theorem:truncation}
For a single step in ALF with stepsize , the local truncation error of  is , and the local truncation error of  is .
\end{theorem}

\textbf{A-Stability}\ \ The ALF solver has a limited stability region, but this can be solved with damping. The damped ALF replaces the update of  in Algo.~\ref{alg:ALF_forward} with , where  is the ``damping coefficient'' between 0 and 1. We have the following theorem on its numerical stability.\begin{theorem}
\label{thm:stability}
For the damped ALF integrator with stepsize , where  is the -th eigenvalue of the Jacobian , then the solver is A-stable if 
\end{theorem}
Proof is in Appendix \ref{sup:subsec:stability} and \ref{sup:sec:damp}. Theorem~\ref{thm:stability} implies the following: when , the damped ALF reduces to ALF, and the stability region is empty; when , the stability region is non-empty. However, stability describes the behaviour when  goes to infinity; in practice we always use a bounded  and ALF performs well. Inverse of damped ALF is in Appendix A.5.

\vspace{-1mm}
\subsection{Memory-efficient ALF Integrator (MALI) for gradient estimation}
\label{subsec:ALF_all}
\vspace{-1mm}
An ideal solver for Neural ODEs should achieve two goals: accuracy in gradient estimation and constant memory cost \textit{w.r.t} integration time. Yet none of the existing methods can achieve both goals.
We propose a method based on the ALF solver, 
which to our knowledge is the first method to achieve the two goals simultaneously. 
\begin{algorithm}
\textbf{Input} Initial state , start time , end time \\
\textbf{Forward} \\
\hspace{4mm}Apply the numerical integration in Algo.~\ref{alg:int}, with the  function defined by Algo.~\ref{alg:ALF_forward}. \\
\hspace{4mm}Delete computation graph on the fly, only keep end-time state  \\ 
\hspace{4mm}Keep \textit{accepted} discretized time points  (ignore process to search for optimal stepsize) \\
\textbf{Backward}\\
\hspace{4mm} Initialize  by Eq.~\ref{eq:lambda_ode}, initialize \\
\hspace{4mm} \textbf{For}  in : \\
\hspace{10mm} Reconstruct  from  by Algo.~\ref{alg:ALF_inverse} \\
\hspace{10mm} Local forward  \\
\hspace{10mm} Local backward, get  and  
\\
\hspace{10mm} Update  and  by Eq.~\ref{eq:analytic_grad} and Eq.~\ref{eq:lambda_ode} discretized at time points  and  \\
\hspace{10mm} Delete local computation graph \\\hspace{4mm} \textbf{Output} the adjoint state  (gradient \textit{w.r.t} input ) and parameter gradient 
\caption{MALI to acheive accuracy at a constant memory cost \textit{w.r.t} integration time}
\label{alg:ALF_all} 
\end{algorithm}\\
\textbf{Procedure of MALI}\ \ Details of MALI are summarized in Algo.~\ref{alg:ALF_all}. For the forward-pass, we only keep the end-time state  and the \textit{accepted} discretized time points (blue curves in Fig.~\ref{fig:forward} and ~\ref{fig:backward}). We ignore the search process for optimal stepsize (green curve in Fig.~\ref{fig:forward} and \ref{fig:backward}), and delete other variables to save memory. During the backward pass, we can reconstruct the forward-time trajectory as in Eq.~\ref{eq:all_inverse}, then calculate the gradient by numerical discretization of Eq.~\ref{eq:analytic_grad} and Eq.~\ref{eq:lambda_ode}. 


\textbf{Constant memory cost \textit{w.r.t} number of solver steps in integration}\ \ We delete the computation graph and only keep the end-time state to save memory. The memory cost is , where  is due to evaluating  and is irreducible for all methods. Compared with the adjoint method, MALI only requires extra  memory to record , and also has a constant memory cost \textit{w.r.t} time step . The memory cost is . 

\textbf{Accuracy} \ \ Our method guarantees the accuracy of reverse-time trajectory (e.g. blue curve in Fig.~\ref{fig:backward} matches the blue curve in Fig.~\ref{fig:forward}), because ALF is explicitly invertible for free-form  (see Algo.~\ref{alg:ALF_inverse}). Therefore, the gradient estimation in MALI is more accurate compared to the adjoint method.

\textbf{Computation cost}\ \ Recall that on average it takes  steps to find an acceptable stepsize, whose error estimate is below tolerance. Therefore, the forward-pass with search process has computation burden . Note that we only reconstruct and backprop through the \textit{accepted} step and ignore the search process, hence it takes another  computation. The overall computation burden is  as in Table~\ref{table:comparison}.
\begin{figure*}
\centering
    \begin{minipage}{0.32\textwidth}
    \centering
        \includegraphics[width=\linewidth]{figures/error_grad_comparison_input.png}
\label{fig:grad_input}
    \end{minipage}
    \begin{minipage}{0.32\textwidth}
    \centering
        \includegraphics[width=\linewidth]{figures/error_grad_comparison_param.png}
\label{fig:grad_param}
    \end{minipage}
    \begin{minipage}{0.32\textwidth}
    \centering
        \includegraphics[width=\linewidth]{figures/mem_comparison.png}
\label{fig:memory}
    \end{minipage}
    \vspace{-7mm}
\captionof{figure}{\small { Comparison of error in gradient in Eq.~\ref{eq:toy}. (a) error in . (b) error in . (c) memory cost. } }
    \label{fig:toy}
    \vspace{-2mm}
\end{figure*}
\begin{figure*}
\centering
\begin{subfigure}{0.35\textwidth}
\centering
\includegraphics[width=\linewidth]{figures/test_acc_comparison_cifar10_2.png}
\end{subfigure}
\begin{subfigure}{0.31\textwidth}
\centering
\includegraphics[width=\linewidth]{figures/ACC_Epoch_confidence_2.png}
\end{subfigure}
\begin{subfigure}{0.31\textwidth}
\centering
\includegraphics[width=\linewidth]{figures/ACC_time_confidence_2.png}
\end{subfigure}
\vspace{-2mm}
\caption{\small {Results on Cifar10. From left to right: (1) box plot of test accuracy (first 4 columns are Neural ODEs, last is ResNet); (2) test accuracy  v.s. training epoch for Neural ODE; (3) test accuracy  v.s. training time of 90 epochs for Neural ODE.}}
\label{fig:cifar10}
\vspace{-3mm}
\end{figure*} 

\textbf{Shallow computation graph}\ \ Similar to ACA, MALI only backpropagates through the accepted step (blue curve in Fig.~\ref{fig:backward}) and ignores the search process (green curve in Fig.~\ref{fig:backward}), hence the depth of computation graph is . The computation graph of MALI is much shallower than the naive method, hence is more robust to  vanishing and exploding gradients \citep{pascanu2013difficulty}.

\textbf{Summary}\ \ The adjoint method suffers from inaccuracy in reverse-time trajectory, the naive method suffers from exploding or vanishing gradient caused by deep computation graph, and ACA finds a balance but the memory grows linearly with integration time. MALI achieves accuracy in reverse-time trajectory, constant memory \textit{w.r.t} integration time, and a shallow computation graph.
\section{Experiments}
\label{sec:experiments}
\vspace{-1mm}
\subsection{Validation on a toy example}
We compare the performance of different methods on a toy example, defined as

The analytical solution is

We plot the amplitude of error between numerical solution and analytical solution varying with  (integrated under the same error tolerance, ) in Fig~\ref{fig:toy}.
ACA and MALI have similar errors, both outperforming other methods. 
We also plot the memory consumption for different methods on a Neural ODE with the same input in Fig.~\ref{fig:toy}. As the error tolerance decreases, the solver evaluates more steps, hence the naive method and ACA increase memory consumption, while MALI and the adjoint method have a constant memory cost. These results validate our analysis in Sec.~\ref{subsec:ALF_all} and Table~\ref{table:comparison}, and shows MALI achieves accuracy at a constant memory cost.
\begin{table}[]
\captionof{table}{\small{Top-1 test accuracy of Neural ODE and ResNet on ImageNet. Neural ODE is trained with MALI, and ResNet is trained as the original model; Neural ODE is tested using different solvers \textit{without} retraining.}}
\label{table:imagenet}
\vspace{-2mm}
\centering
\scalebox{0.7}{
\begin{tabular}{c|c|ccccc|cccc}
\hline
\multirow{2}{*}{}                                                     & \multicolumn{6}{c|}{Fixed-stepsize solvers of various stepsizes}      & \multicolumn{4}{c}{Adaptive-stepsize solver of various tolerances}                    \\ \cline{2-11} 
                                                                      &  Stepsize & 1     & 0.5   & 0.25  & 0.15  & 0.1   & \multicolumn{1}{c|}{Tolerance} & 1.00E+00 & 1.00E-01 & 1.00E-02 \\ \hline
\multirow{4}{*}{\begin{tabular}[c]{@{}c@{}}Neural\\ ODE \end{tabular}} & MALI      & 42.33 & 66.4  & 69.59 & 70.17 & 69.94 & \multicolumn{1}{c|}{MALI}       & 62.56    & 69.89    & 69.87    \\
                                                                      & Euler    & 21.94 & 61.25 & 67.38 & 68.69 & 70.02 & \multicolumn{1}{c|}{Heun-Euler}     & 68.48    & 69.87    & 69.88    \\
                                                                      & RK2     & 42.33 & 69    & 69.72 & 70.14 & 69.92 & \multicolumn{1}{c|}{RK23}       & 50.77    & 69.89    & 69.93    \\
                                                                      & RK4      & 12.6  & 69.99 & 69.91 & \textbf{70.21} & 69.96 & \multicolumn{1}{c|}{Dopri5}       & 52.3     & 68.58    & 69.71    \\ \hline
\multicolumn{1}{c|}{ResNet} & \multicolumn{10}{c}{70.09} \\ \hline
\end{tabular}
}
\vspace{-3mm}
\end{table} 
\begin{table}
\centering
\captionof{table}{\small{Top-1 accuracy under FGSM attack.  is the perturbation amplitude. For Neural ODE models, row names represent the solvers to derive the gradient for attack, and column names represent solvers for inference on the perturbed image.}}
\label{table:adversarial}
\vspace{-2mm}
\scalebox{0.7}{
\begin{tabular}{c|c|cccc|cccc}
\hline
\multicolumn{2}{c|}{\multirow{2}{*}{}}                                         & \multicolumn{4}{c|}{} & \multicolumn{4}{c}{} \\ \cline{3-10} 
\multicolumn{2}{c|}{}                                                          & MALI      & Heun-Euler   & RK23    & Dopri5   & MALI     & Heun-Euler   & RK23    & Dopri5   \\ \hline
\multirow{4}{*}{\begin{tabular}[c]{@{}c@{}}Neural\\ ODE\end{tabular}} & MALI    & 14.69    & 14.72   & 14.77   & 15.71    & 10.38   & 10.46   & 10.62   & 10.62    \\
                                                                      & Heun-Euler  & 14.77    & 14.75   & 14.80    & \textbf{15.74}    & 10.63   & 10.47   & 10.44   & 10.49    \\
                                                                      & RK23   & 14.82    & 14.77   & 14.79   & 15.69    & \textbf{10.78}   & 10.53   & 10.48   & 10.56    \\
                                                                      & Dopri5 & 14.82    & 14.78   & 14.79   & 15.15    & 10.76   & 10.49   & 10.48   & 10.51    \\ \hline
\multicolumn{2}{c|}{ResNet}                                                    & \multicolumn{4}{c|}{13.02}              & \multicolumn{4}{c}{9.57}               \\ \hline
\end{tabular}
}
\vspace{-5mm}
\end{table}
\subsection{Image recognition with Neural ODE}
We validate MALI on image recognition tasks using Cifar10 and ImageNet datasets. Similar to \citet{zhuang2020adaptive}, we modify a ResNet18 into its corresponding Neural ODE: the forward function is  and  for the residual block and Neural ODE respectively, where the same  is shared. We compare MALI with the naive method, adjoint method and ACA.

\textbf{Results on Cifar10}\ \ 
Results of 5 independent runs on Cifar10 are summarized in Fig.~\ref{fig:cifar10}. MALI achieves comparable accuracy to ACA, and both significantly outperform the naive and the adjoint method. Furthermore, the training speed of MALI is similar to ACA, and both are almost two times faster than the adjoint memthod, and three times faster than the naive method. This validates our analysis on accuracy and computation burden in Table~\ref{table:comparison}. \\
\begin{wrapfigure}{r}{0.35\textwidth}
\begin{minipage}{\linewidth}
\centering
\includegraphics[width=\linewidth]{figures/imagenet_test.png}
\vspace{-7mm}
\captionof{figure}{\small{Top-1 accuracy on ImageNet validation dataset.}}
\label{fig:imagenet_test}
\end{minipage}
\vspace{-6mm}
\end{wrapfigure} 
\textbf{Accuracy on ImageNet}\ \ Due to the heavy memory burden caused by large images, the naive method and ACA are unable to train a Neural ODE on ImageNet with 4 GPUs; only MALI and the adjoint method are feasible due to the constant memory. We also compare the Neural ODE to a standard ResNet. As shown in Fig.~\ref{fig:imagenet_test}, the accuracy of the Neural ODE trained with MALI closely follows ResNet, and significantly outperforms the adjoint method (top-1 validation: 70\% v.s. 63\%).

\textbf{Invariance to discretization scheme}\ \
A continuous model should be invariant to discretization schemes (e.g. different types of ODE solvers) as long as the discretization is sufficiently accurate. We test the Neural ODE using different solvers \textit{without} re-training; since ResNet is often viewed as a one-step Euler discretization of an ODE \citep{haber2017stable}, we perform similar experiments.
As shown in Table~\ref{table:imagenet}, Neural ODE consistently achieves high accuracy (70\%), while ResNet drops to random guessing (0.1\%) because ResNet as a one-step Euler discretization fails to be a meaningful dynamical system \citep{queiruga2020continuous}.

\textbf{Robustness to adversarial attack}\ \ \citet{hanshu2019robustness} demonstrated that Neural ODE is more robust to adversarial attack than ResNet on small-scale datasets such as Cifar10. We validate this result on the large-scale ImageNet dataset. The top-1 accuracy of Neural ODE and ResNet under FGSM attack \citep{goodfellow2014explaining} are summarized in Table~\ref{table:adversarial}. For Neural ODE, due to its invariance to discretization scheme, we derive the gradient for attack using a certain solver (row in Table~\ref{table:adversarial}), and inference on the perturbed images using various solvers. For different combinations of solvers and perturbation amplitudes, Neural ODE consistently outperforms ResNet.

\textbf{Summary}\ \  In image recognition tasks, we demonstrate Neural ODE is accurate, invariant to discretization scheme, and more robust to adversarial attack than ResNet. Note that detailed explanation on the robustness of Neural ODE is out of the scope for this paper, but to our knowledge, MALI is the \textit{first} method to enable training of Neural ODE on large datasets due to constant memory cost.
\vspace{-1mm}
\subsection{Time-series modeling}
\vspace{-1mm}
We apply MALI to latent-ODE \citep{rubanova2019latent} and Neural Controlled Differential Equation (Neural CDE) \citep{kidger2020hey, kidger2020neural}. Our experiment is based on the official implementation from the literature. 
We report the mean squared error (MSE) on the \textit{Mujoco} test set in Table~\ref{table:mujoco}, which is generated from the ``Hopper'' model using DeepMind control suite \citep{tassa2018deepmind}; for all experiments with different ratios of training data, MALI achieves similar MSE to ACA, and both outperform the adjoint and naive method. We report the test accuracy on the \textit{Speech Command} dataset for Neural CDE in Table~\ref{table:ncde}; MALI achieves a higher accuracy than competing methods.
\vspace{-1mm}
\subsection{Continuous generative models} 
\vspace{-1mm}
We apply MALI on FFJORD \citep{grathwohl2018ffjord}, a free-from continuous generative model, and compare with several variants in the literature \citep{finlay2020train, kidger2020hey}. Our experiment is based on the official implementaion of \cite{finlay2020train}; for a fair comparison, we train with MALI, and test with the same solver as in the literature \citep{grathwohl2018ffjord, finlay2020train}, the \textit{Dopri5} solver with  from the \textit{torchdiffeq} package \citep{chen2018neural}. Bits per dim (BPD, lower is better) on validation set for various datasets are reported in Table~\ref{table:ffjord}. For continuous models, MALI consistently generates the lowest BPD, and outperforms the Vanilla FFJORD (trained with adjoint), RNODE (regularized FFJORD) and the SemiNorm Adjoint \citep{kidger2020hey}. Furthermore, FFJORD trained with MALI achieves comparable BPD to state-of-the-art discrete-layer flow models in the literature. Please see Sec.~\ref{sup:sec:ffjord} for generated samples.
\vspace{-4mm}
\section{Related works}
\vspace{-2mm}
Besides ALF, the symplectic integrator \citep{verlet1967computer, yoshida1990construction} is also able to reconstruct trajectory accurately, yet it's typically restricted to second order Hamiltonian systems \citep{de1990hamiltonian}, and are unsuitable for general ODEs. Besides aforementioned methods, there are other methods for gradient estimation such as interpolated adjoint \citep{daulbaev2020interpolated} and spectral method \citep{quaglino2019snode}, yet the implementations are involved and not publicly available. Other works focus on the theoretical properties of Neural ODEs \citep{dupont2019augmented, tabuada2020universal,massaroli2020dissecting}. Neural ODE is recently applied to stochastic differential equation \citep{li2020scalable}, jump differential equation \citep{jia2019neural} and auto-regressive models \citep{wehenkel2019unconstrained}.
\footnotetext{\footnotesize {1.  \citet{rubanova2019latent}; 2. \citet{zhuang2020adaptive}; 3.  \citet{kidger2020hey}; 4. \citet{chen2018neural}; 5. \citet{finlay2020train}; 6. \citet{dinh2016density}; 7.  \citet{behrmann2019invertible}; 8. \citet{kingma2018glow}; 9. \citet{ho2019flow++}; 10. \citet{chen2019residual}}}

\begin{table}
\begin{minipage}{0.67\textwidth}
\centering
\captionof{table}{\small{Test MSE () on Mujoco dataset (lower is better). Results marked with superscript numbers correspond to literature in the footnote.}}
\label{table:mujoco}
\scalebox{0.8}{
\begin{tabular}{c|cc|cccc}
\hline
\multirow{2}{*}{\begin{tabular}[c]{@{}c@{}}Percentage\\ of training data \\\end{tabular}} & \multirow{2}{*}{RNN} & \multirow{2}{*}{RNN-GRU} & \multicolumn{4}{c}{Latent-ODE} \\ \cline{4-7}                                                  &                      &                          & Adjoint  & Naive & ACA  & MALI  \\ \hline
10\%                                                                                     & 2.45                 & 1.97                     & 0.47     & 0.36  & \textbf{0.31} & 0.35 \\
20\%                                                                                     & 1.71                 & 1.42                     & 0.44     & 0.30  & \textbf{0.27} & \textbf{0.27} \\
50\%                                                                                     & 0.79                 & 0.75                     & 0.40     & 0.29  & \textbf{0.26} & \textbf{0.26} \\ \hline
\end{tabular}
}
\end{minipage}
\hfill
\begin{minipage}{0.3\textwidth}
\centering
\captionof{table}{\small{Test ACC on Speech Command Dataset}}
\label{table:ncde}
\vspace{-2mm}
\scalebox{0.8}{
\begin{tabular}{c|c}
\hline
Method   & Accuracy (\%) \\ \hline
Adjoint  &   \\
SemiNorm &   \\
Naive    &   \\
ACA      &   \\
MALI      &   \\ \hline
\end{tabular}
}
\end{minipage}
\vspace{-2mm}
\end{table}
\begin{table}[]
\caption{\small{Bits per dim (BPD) of generative models, \textit{lower} is better. Results marked with superscript numbers correspond to literature in the footnote.}}
\label{table:ffjord}
\vspace{-1mm}
\scalebox{0.77}{
\begin{tabular}{c|cccc|ccccc}
\hline
\multirow{2}{*}{Dataset} & \multicolumn{4}{c|}{Continuous Flow (FFJORD)} & \multicolumn{5}{c}{Discrete Flow}                 \\ \cline{2-10} 
                         & Vanilla  & RNODE  & SemiNorm & MALI      & RealNVP & i-ResNet & Glow & Flow++ & Residual Flow \\ \hline
MNIST                    & 0.99     & 0.97   & 0.96     & \textbf{0.87} & 1.06    & 1.05     & 1.05 & -      & 0.97          \\
CIFAR10                  & 3.40     & 3.38   & 3.35     & \textbf{3.27} & 3.49    & 3.45     & 3.35 & 3.28   & 3.28          \\
ImageNet64               & -        & 3.83   & -        & \textbf{3.71} & 3.98    & -        & 3.81 & -      & 3.76 \\ 
\hline
\end{tabular}
}
\vspace{-3mm}
\end{table}
\vspace{-2mm}
\section{Conclusion}
\vspace{-2mm}
Based on the asynchronous leapfrog integrator, we propose MALI to estimate the gradient for Neural ODEs. To our knowledge, our method is the first to achieve accuracy, fast speed and a constant memory cost. We provide comprehensive theoretical analysis on its properties. We validate MALI with extensive experiments, and achieved new state-of-the-art results in various tasks, including image recognition, continuous generative modeling, and time-series modeling.
\newpage

\bibliography{iclr2021_conference}
\bibliographystyle{iclr2021_conference}
\newpage
\appendixwithtoc
\newpage
\setcounter{equation}{0}
\setcounter{figure}{0}
\setcounter{theorem}{0}
\setcounter{corollary}{0}
\setcounter{lemma}{0}
\setcounter{algocf}{0}


\section{Theoretical properties of ALF integrator}
\label{sup:sec:theory}
\subsection{Algorithm of ALF}
\label{sub:sec:ALF}
For the ease of reading, we write the algorithm for  in ALF below, which is the same as Algo.~\ref{alg:ALF_forward} in the main paper, but uses slightly different notations for the ease of analysis.
\begin{algorithm}
\SetAlgorithmName{Algorithm}{} \\
\textbf{Input}  where  is current time,  and  are correponding values at time ; stepsize .\\
\textbf{Forward} 

\textbf{Output} \hspace{28mm} 
\caption{Forward of  in ALF}
\label{sup:alg:ALF_forward2}
\end{algorithm}

For simplicity, we can re-write the forward of ALF as

Similarly, the inverse of ALF can be written as

\subsection{Preliminaries}
For an ODE of the form

We have:

For the ease of notation, we re-write Eq.~\ref{sup:eq:2nd-grad} as

where  and  represents the partial derivative of  \textit{w.r.t}  and  respectively.
\subsection{Local truncation error of ALF}
\label{sup:subsec:localerror}
\begin{theorem}[Theorem~\ref{theorem:truncation} in the main paper]
\label{sup:theorem:truncation}
For a single step in ALF with stepsize , the local truncation error of  is , and the local truncation errof of  is .
\end{theorem}
\begin{proof}
Under the same notation as Algo.~\ref{sup:alg:ALF_forward2}, denote the ground-truth state of  and  starting from  as  and  respectively. Then the local truncation error is 
 
We estimate  and  in terms of polynomial of . 

Under mild assumptions that  is smooth up to 2nd order almost everywhere (this is typically satisfied with neural networks with bounded weights), hence Taylor expansion is meaningful for . By Eq.~\ref{sup:eq:2nd-grad-2}, the Taylor expansion of  around point  is

Next, we analyze accuracy of the numerical approximation. For simplicity, we directly analyze Eq.~\ref{sup:eq:sim_forward} by performing Taylor Expansion on .


Plug Eq.~\ref{sup:eq:taylor_z}, Eq.~\ref{sup:eq:taylor_f} and E.q.~\ref{sup:eq:z_2} into the definition of , we get

Therefore, if  is of order ,  is of order ; if  is of order  or smaller, then  is of order . Specifically, at the start time of integration, we have , by induction,  at end time is .

Next we analyze the local truncation error in , denoted as . Denote the ground truth as , we have 

Next we analyze the error in the numerical approximation. Plug Eq.~\ref{sup:eq:taylor_f} into Eq.~\ref{sup:eq:sim_forward}, 

From Eq.~\ref{sup:eq:taylor_z}, Eq.~\ref{sup:eq:ideal_v} and Eq.~\ref{sup:eq:hat_v2}, we have

The last equation is derived by plugging in Eq.~\ref{sup:eq:taylor_z}.
Note that Eq.~\ref{sup:eq:Lv} holds for every single step forward in time, and at the start time of integration, we have  due to our initialization as in Sec.~\ref{subsec:ALF} of the main paper. Therefore, by induction,  is of order  for consecutive steps.
\end{proof}
\subsection{Stability analysis}
\label{sup:subsec:stability}
\begin{lemma}
\label{sup:lem:det}
For a matrix of the form , if  are square matrices of the same shape, and , then we have\ \ 

\end{lemma}
\begin{proof}
See \citep{silvester2000determinants} for a detailed proof.
\end{proof}
\begin{theorem}
For ALF integrator with stepsize , if  is 0 or is imaginary with norm no larger than 1, where  is the -th eigenvalue of the Jacobian , then the solver is on the critical boundary of A-stability; otherwise, the solver is not A-stable.
\end{theorem}
\begin{proof}
A solver is A-stable is equivalent to the eigenvalue of the numerical forward has a norm below 1. We calculate the eigenvalue of  below.

For the function defined by Eq.~\ref{sup:eq:sim_forward}, the Jacobian is

We determine the eigenvalue of  by solving the equation

It's trivial to check  satisfies conditions for Lemma~\ref{sup:lem:det}.Therefore, we have

Suppose the eigen-decompostion of  can be written as

Note that , hence we have

Hence the eigenvalues are 

A-stability requires , and has no solution.

The critical boundary is , the solution is:  is 0 or on the imaginary line with norm no larger than 1.
\end{proof}
\newpage
\subsection{Damped ALF}
\label{sup:sec:damp}
\begin{algorithm}
\SetAlgorithmName{Algorithm}{} \\
\textbf{Input}  where  is current time,  and  are correponding values at time ; stepsize .\\
\textbf{Forward} 

\textbf{Output} \hspace{28mm} 
\caption{Forward of  in Damped ALF ({\color{blue}  })}
\label{sup:alg:damp_ALF_forward}
\end{algorithm}
\begin{algorithm}[H]
\label{alg:ALF_inverse}
\SetAlgorithmName{Algorithm}{} \\
\textbf{Input}  where  is current time,  and  are corresponding values at ,  is stepsize.\\
\textbf{Inverse} 

\textbf{Output} \hspace{28mm} 
\caption{  (Inverse of ) in Damped ALF ({\color{blue}  })}
\end{algorithm}
The main difference between ALF and Damped ALF is marked in blue in Algo.~\ref{sup:alg:damp_ALF_forward}. In ALF, the update of  is ; while in Damped ALF, the update is scaled by a factor  between 0 and 1, so the update is . When , Damped ALF reduces to ALF.

Similar to Sec.~\ref{sub:sec:ALF}, we can write the forward as
For simplicity, we can re-write the forward of ALF as

Similarly, the inverse of ALF can be written as


\begin{theorem}
\label{sup:theorem:truncation}
For a single step in Damped ALF with stepsize , the local truncation error of  is , and the local truncation errof of  is .
\begin{proof}
The proof is similar to Thm.~\ref{sup:theorem:truncation}. By similar calculations using the Taylor Expansion in Eq.~\ref{sup:eq:taylor_f} and Eq.~\ref{sup:eq:taylor_z}, we have

Using Eq.~\ref{sup:eq:ideal_v}, Eq.~\ref{sup:eq:taylor_f} and Eq.~\ref{sup:eq:taylor_z}, we have

Note that when , Eq.~\ref{sup:eq:z_err_damp} reduces to Eq.~\ref{sup:eq:Lz}, and Eq.~\ref{sup:eq:v_err_damp} reduces to Eq.~\ref{sup:eq:Lv}. By initialization, we have  at initial time, hence by induction, the local truncation error for  is ; the local truncation error for  is  when , and is  when .
\end{proof}
\end{theorem}

\begin{theorem}[Theorem~\ref{thm:stability} in the main paper]
For Dampled ALF integrator with stepsize , where  is the -th eigenvalue of the Jacobian , then the solver is A-stable if .
\end{theorem}
\begin{proof}
The Jacobian of the forward-pass of a single step damped ALF is

when ,  reduces to Eq.~\ref{sup:eq:jacobian}. We can determine the eigenvalue of  using similar techniques. Assume the eigenvalues for  are , then we have

when , it's easy to check that  has non-empty solutions for .
\end{proof}
For a quick validation, we plot the region of A-stability on the imaginary plane for a single eigenvalue in Fig.~\ref{sup:fig:stability}. As  increases, the area of stability decreases. When , the system is no-where A-stable, and the boundary for A-stability is on the imaginary axis  where  is the imaginary unit. 
\begin{figure}
\begin{minipage}{0.32\textwidth}
\includegraphics[width=\linewidth]{figures/0.25stability.pdf}
\end{minipage}
\begin{minipage}{0.32\textwidth}
\includegraphics[width=\linewidth]{figures/0.7stability.pdf}
\end{minipage}
\begin{minipage}{0.32\textwidth}
\includegraphics[width=\linewidth]{figures/0.8stability.pdf}
\end{minipage}
\caption{Region of A-stability for eigenvalue on the imaginary plane for damped ALF. From left to right, the region of stability for , , respectively. As  increases to 1, the area of stability region decreases.}
\label{sup:fig:stability}
\end{figure}
\newpage
\section{Experimental Details}
\subsection{Image Recognition}
\subsubsection{Experiment on Cifar10}
We directly modify a ResNet18 into a Neural ODE, where the forward of a residual block () and the forward of an ODE block ( where ) share the same parameterization , hence they have the same number of parameters. Our experiment is based on the official implementation by \citet{zhuang2020adaptive} and an open-source repository \citep{cifar10}.

All models are trained with SGD optimizer for 90 epochs, with an initial learning rate of 0.01, and decayed by a factor of 10 at 30th epoch and 60th epoch respectively. Training scheme is the same for all models (ResNet, Neural ODE trained with adjoint, naive, ACA and MALI). For ACA, we follow the settings in \citep{zhuang2020adaptive} and use the official implementation \textit{torch\_ACA} \footnote{\url{https://github.com/juntang-zhuang/torch_ACA}}, 
and use a Heun-Euler solver with  during training. For MALI, we use an adaptive version and set . For the naive and adjoint method, we use the default \textit{Dopri5} solver from the \textit{torchdiffeq}\footnote{\url{https://github.com/rtqichen/torchdiffeq}} package with . We train all models for 5 independent runs, and report the mean and standard deviation across runs. 

\subsubsection{Experiments on ImageNet}
\paragraph{Training scheme}
We conduct experiments on ImageNet with ResNet18 and Neural-ODE18. All models are trained on 4 GTX-1080Ti GPUs with a batchsize of 256. All models are trained for 80 epochs, with an initial learning rate of 0.1, and decayed by a factor of 10 at 30th and 60th epoch. Note that due to the large size input , the naive method and ACA requires a huge memory, and is infeasible to train. MALI and the adjoint method requires a constant memory hence is suitable for large-scale experiments. For both MALI and the adjoint menthod, we use a fixed stepsize of 0.25, and integrates from 0 to . As shown in Table.~\ref{table:imagenet} in the main paper, a stepsize of 0.25 is sufficiently small to train a meaningful continuous model that is robust to discretization scheme. 

\begin{figure}
\begin{subfigure}{0.5\textwidth}
\includegraphics[width=\linewidth]{figures/imagenet_train.png}
\caption{Training curve on ImageNet.}
\end{subfigure}
\begin{subfigure}{0.5\textwidth}
\includegraphics[width=\linewidth]{figures/imagenet_test.png}
\caption{Validation curve on ImageNet.}
\end{subfigure}
\caption{Results on ImageNet.}
\end{figure}

\paragraph{Invariance to discretization scheme}
To test the influence of discretization scheme, we test our Neural ODE with different solvers \textit{without} re-training. For fixed-stepsize solvers, we tested various step sizes including ; for adaptive solvers, we set  for MALI and Heun-Euler method, and set  for RK23 solver, and set  for Dopri5 solver. As shown in Table.~\ref{table:imagenet}, Neural ODE trained with MALI is robust to discretization scheme, and MALI significantly outperforms the adjoint method in terms of accuracy (70\% v.s. 63\% top-1 accuracy on the validation dataset). An interesting finding is that when trained with MALI which is a second-order solver, and tested with higher-order solver (e.g. RK4), our Neural ODE achieves 70.21\% top-1 accuracy, which is higher than both the same solver during training (MALI, 69.59\% accuracy) and the ResNet18 (70.09\% accuracy).

Furthermore, many papers claim ResNet to be an approximation for an ODE \citep{lu2018beyond}. However, \citet{queiruga2020continuous} argues that many numerical discretizations fail to be meaningful dynamical systems, while our experiments demonstrate that our model is continuous hence invariant to discretization schemes. 

\paragraph{Adversarial robustness}
Besides the high accuracy and robustness to discretization scheme, another advantage of Neural ODE is the robustness to adversarial attack. The adversary robustness of Neural ODE is extensively studied in \citep{hanshu2019robustness}, but not only validated on small-scale datasets such as Cifar10. To our knowledge, our method is the first to enable effectuve training of Neural ODE on large-scale datasets such as ImageNet and achieve a high accuracy, and we are the first to validate the robustness of Neural ODE on ImageNet. We use the \textit{advertorch} \footnote{\url{https://github.com/BorealisAI/advertorch}} toolbox to perform adversarial attack. We test the performance of ResNet and Neural ODE under FGSM attack. To be more convincing, we conduct experiment on the pretrained ResNet18 provided by the official PyTorch website \footnote{\url{https://pytorch.org/docs/stable/torchvision/models.html}}. Since Neural ODE is invariant to discretization scheme, it's possible to derive the gradient for attack using one ODE solver, and inference on the perturbed image using another solver. As summarized in Table.~\ref{table:adversarial}, Neural ODE consistently achieves a higher accuracy than ResNet under the same attack.

\subsection{Time series modeling}
We conduct experiments on Latent-ODE models \citep{rubanova2019latent} and Neural CDE (controlled differential equation) \citep{kidger2020hey}. For all experiments, we use the official implementation, and only replace the solver with MALI. The latent-ODE model is trained on the \textit{Mujoco} dataset processed with code provided by the official implementation, and we experiment with different ratios (10\%,20\%,50\%) of training data as described in \citep{rubanova2019latent}. All models are trained for 300 epochs with Adamax optimizer, with an initial learning rate of 0.01 and scaled by 0.999 for each epoch. For the Neural CDE model, for the naive method, ACA and MALI, we perform 5 independent runs and report the mean value and standard deviation; results for the adjoint and seminorm adjoint are from \citep{kidger2020hey}. For Neural CDE, we use MALI with ALF solver with a fixed stepsize of 0.25, and train the model for 100 epochs with an initial learning rate of 0.004.

\subsection{Continuous generative models}
\label{sup:sec:ffjord}
\subsubsection{Training details}
Our experiment is based on the official implementation of \citep{finlay2020train}, with the only difference in ODE solver. For a fair comparison, we only use MALI for training, and use \textit{Dopri5} solver from \textit{torchdiffeq} package \citep{chen2018neural} with . For MALI, we use adaptive ALF solver with , and use an initial stepsize of 0.25. Integration time is from 0 to 1. 

On MNIST and CIFAR dataset, we set the regularization coefficients for kinetic energy and Frobenius norm of the derivative function as 0.05. We train the model for 50 epochs with an initial learning rate of 0.001.



\subsubsection{Addtional results}
We show generated examples on MNIST dataset in Fig.~\ref{sup:fig:mnist}, results for Cifar10 dataset in Fig.~\ref{sup:fig:cifar}, and results for ImageNet64 in Fig.~\ref{sup:fig:imagenet}.
\begin{figure}
\begin{subfigure}{0.5\textwidth}
\centering
\includegraphics[width=\linewidth]{figures/real_mnist.jpg}
\caption{Real samples from MNIST dataset.}
\end{subfigure}
\begin{subfigure}{0.5\textwidth}
\centering
\includegraphics[width=\linewidth]{figures/mnist2.png}
\caption{Generated samples from FFJORD.}
\end{subfigure}
\caption{Results on MNIST dataset.}
\label{sup:fig:mnist}
\end{figure}

\begin{figure}
\begin{subfigure}{0.5\textwidth}
\centering
\includegraphics[width=\linewidth]{figures/real_cifar.jpg}
\caption{Real samples from CIFAR10 dataset.}
\end{subfigure}
\begin{subfigure}{0.5\textwidth}
\centering
\includegraphics[width=\linewidth]{figures/fake_cifar.jpg}
\caption{Generated samples from FFJORD.}
\end{subfigure}
\caption{Results on Cifar10 dataset.}
\label{sup:fig:cifar}
\end{figure}

\begin{figure}
\begin{subfigure}{0.5\textwidth}
\centering
\includegraphics[width=\linewidth]{figures/real_imagenet.jpg}
\caption{Real samples from ImageNet64 dataset.}
\end{subfigure}
\begin{subfigure}{0.5\textwidth}
\centering
\includegraphics[width=\linewidth]{figures/generated_imagenet.jpg}
\caption{Generated samples from FFJORD.}
\end{subfigure}
\caption{Results on ImageNet64 dataset.}
\label{sup:fig:imagenet}
\end{figure}

\subsection{Error in gradient estimation for toy examples when }
We plot the error in gradient estimation for the toy example defined by Eq.6 in the main paper in Fig.~\ref{sup:fig:toy}. Note that the integration time  is set as smaller than 1, while the main paper is larger than 20. We observe the same results, MALI and ACA generate smaller error than the adjoint and the naive method.
\begin{figure}
\begin{subfigure}{0.5\textwidth}
\centering
\includegraphics[width=\linewidth]{figures/error_grad_comparison_input2.png}
\caption{Error in the estimation of gradient \textit{w.r.t} initial condition.}
\end{subfigure}
\begin{subfigure}{0.5\textwidth}
\centering
\includegraphics[width=\linewidth]{figures/error_grad_comparison_param2.png}
\caption{Error in the estimation of gradient \textit{w.r.t} parameter .}
\end{subfigure}
\caption{Comparison of error in gradient estimation for the toy example by Eq.6 of the main paper, when .}
\label{sup:fig:toy}
\end{figure}

\subsection{Results of damped MALI }
For all experiments in the main paper, we set  and did not use damping. For completeness, we experimented with damped MALI using different values of . As shown in Table.~\ref{sup:table:eta}, MALI is robust to different  values.
\begin{table}[]
\caption{Results of damped MALI with different  values. We report the test accuracy of Neural CDE on Speech Command dataset, and the test MSE of latent-ODE on Mujoco data.}
\label{sup:table:eta}
\scalebox{0.9}{
\begin{tabular}{c|c|cccc}
\hline
\multicolumn{2}{c|}{}                                                                                            & 1.0                         & 0.95                        & 0.9                         & 0.85                         \\ \hline
\multicolumn{2}{c|}{\begin{tabular}[c]{@{}c@{}}Test Accuracy\\ on Speech Commands\\ (Higher is better)\end{tabular}}                &  &  &  &  \\ \hline
\multirow{2}{*}{\begin{tabular}[c]{@{}c@{}}Test MSE of latent ODE \\ on Mujoco (Lower is better)\end{tabular}} & 10\% training data & 0.35                        & 0.36                        & 0.33                        & 0.33                         \\ \cline{2-6} 
                                                                                                               & 20\% training data & 0.27                        & 0.25                        & 0.26                        & 0.27                         \\ \hline
\end{tabular}
}
\end{table}
\end{document}
