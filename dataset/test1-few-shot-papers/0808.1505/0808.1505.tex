\documentclass{sig-alternate}

\usepackage{amsfonts,amsmath,amssymb,latexsym,comment,enumerate}
\ifx\pdftexversion\undefined
\usepackage[a4paper,colorlinks,linkcolor=black,filecolor=black,citecolor=black,urlcolor=black,pdfstartview=FitH]{hyperref}
\else
\usepackage[a4paper,colorlinks,linkcolor=blue,filecolor=blue,citecolor=blue,urlcolor=blue,pdfstartview=FitH]{hyperref}
\fi
\usepackage{xspace}
\newcommand{\wbox}{\mbox{\llap{}}}
\newtheorem{theorem}{Theorem}
\newtheorem{conjecture}{Conjecture}
\newtheorem{lemma}{Lemma}
\newtheorem{proposition}[lemma]{Proposition}
\newtheorem{definition}{Definition}
\newtheorem{example}{Example}
\newtheorem{claim}{Claim}
\newtheorem{corollary}{Corollary}
\newtheorem{introtheorem}{Theorem}
\newtheorem{assumption}{Assumption}
\newcommand{\namedref}[2]{\hyperref[#2]{#1~\ref*{#2}}}
\newcommand{\sectionref}[1]{\namedref{Section}{#1}}
\newcommand{\appendixref}[1]{\namedref{Appendix}{#1}}
\newcommand{\subsectionref}[1]{\namedref{Subsection}{#1}}
\newcommand{\theoremref}[1]{\namedref{Theorem}{#1}}
\newcommand{\defref}[1]{\namedref{Definition}{#1}}
\newcommand{\figureref}[1]{\namedref{Figure}{#1}}
\newcommand{\claimref}[1]{\namedref{Claim}{#1}}
\newcommand{\lemmaref}[1]{\namedref{Lemma}{#1}}
\newcommand{\tableref}[1]{\namedref{Table}{#1}}
\newcommand{\corollaryref}[1]{\namedref{Corollary}{#1}}
\newcommand{\propertyref}[1]{\namedref{Property}{#1}}
\newcommand{\appref}[1]{\namedref{Appendix}{#1}}
\newcommand{\propref}[1]{\namedref{Proposition}{#1}}
\newcommand{\dagree}{{\em Detect/Agree\ }}
\newcommand{\etal}{et~al.\xspace}
\newcommand{\F}{\mathcal{F}}
\newcommand{\PR}{\cal{R}}
\newcommand{\PS}{\cal{S}}
\newcommand{\T}{{\mathcal T}}
\newcommand{\C}{\mathcal{C}}
\renewcommand{\P}{\mathcal{P}}
\newcommand{\false}{\mathit{false}}
\newcommand{\true}{\mathit{true}}
\newcommand{\ack}{\mathit{ack}}
\newcommand{\info}{{\mbox{\it correct}}}
\newcommand\all{N}
\newcommand{\none}{\tau'}
\newcommand{\best}{\mathrm{best}}
\newcommand{\majority}{\mathrm{majority}}
\newcommand\alone{\{i\}}
\newcommand{\secret}{\mathit{sec}}
\newcommand{\sigmact}{\sigma_{\mbox{\footnotesize\sc ct}}}
\newcommand{\Gammact}{\Gamma_{\!\mbox{\footnotesize\sc ct}}}
\newcommand{\vecsigmact}{\sigma_{\mbox{\footnotesize\sc ct}}}
\newcommand{\fsc}[1]{\mbox{\footnotesize\sc {#1}}}
\newcommand{\ie}{\emph{i.e.\xspace}}
\newcommand{\uT}{u^T}
\newcommand{\ceil}[1]{\left\lceil{#1}\right\rceil}
\newcommand{\pare}[1]{\left({#1}\right)}
\newcommand{\set}[1]{\left\{{#1}\right\}}
\newcommand{\ang}[1]{\left\langle {#1} \right\rangle}
\newcommand{\range}[2]{\set{{#1},\dots,{#2}}}
\def\beginsmall#1{\vspace{-\parskip}\begin{#1}\itemsep-\parskip}
\def\endsmall#1{\end{#1}\vspace{-\parskip}}
\newenvironment{RETHM}[2]{\trivlist \item[\hskip 10pt\hskip\labelsep{\bf
#1\hskip 5pt\relax\ref{#2}.}]\it}{\endtrivlist}
\newcommand{\rethm}[1]{\begin{RETHM}{Theorem}{#1}}
\newcommand{\repro}[1]{\begin{RETHM}{Proposition}{#1}}
\newcommand{\relem}[1]{\begin{RETHM}{Lemma}{#1}}
\newcommand{\recor}[1]{\begin{RETHM}{Corollary}{#1}}
\newcommand{\erethm}{\end{RETHM}}
\newcommand{\erepro}{\end{RETHM}}
\newcommand{\erelem}{\end{RETHM}}
\newcommand{\erecor}{\end{RETHM}}
\newcommand{\mes}[2]{\left\langle {\textrm{#1}},{#2} \right\rangle}
\newcommand{\alert}[1]{\textbf{\color{red}
[[[#1]]]}}
\newcommand{\dd}[1]{\textbf{\color{blue}
[[[#1]]]}}
\newcommand{\note}[1]{\textbf{\color{magenta}
[[[Note: #1]]]}}
\newcommand{\eps}{\mbox{--}}
\newcommand{\fullv}[1]{\commentout{#1}}
\newcommand{\shortv}[1]{#1}
\newcommand{\commentout}[1]{}
\newcommand{\mediator}{\mathit{mediator}}
\newcommand{\Dom}{{\it DOM}}
\newcommand{\cD}{\mathcal{D}}
\newcommand{\punish}{{\textsc{punish}}}
\newcommand{\pass}{{\textsc{pass}}}
\newcommand{\detect}{{\textsc{detect}}\xspace}
\newcommand{\mwdavss}{\text{MW-SVSS}\xspace}
\newcommand{\davss}{{\text{SVSS}}\xspace}
\newcommand{\IN}{\mbox{}}
\renewcommand{\ell}{l}
\newcommand{\idea}[1]{\textsf{#1}}
\newcommand{\OK}{\mathit{OK}}

\newcommand{\A}{\text{ACK}\xspace}
\newcommand{\D}{\text{DEAL}\xspace}
\newcommand{\DMM}{\text{DMM}\xspace}







\begin{document}


\conferenceinfo{PODC'08,} {August 18--21, 2008, Toronto, Ontario, Canada.}

\CopyrightYear{2008}

\crdata{978-1-59593-989-0/08/08}


\title{An Almost-Surely Terminating Polynomial Protocol for
Asynchronous Byzantine Agreement with Optimal Resilience}





\numberofauthors{3}
\author{
\alignauthor Ittai Abraham\\
\affaddr{Hebrew University} \\
\email{ittaia@cs.huji.ac.il}
\alignauthor Danny Dolev\thanks{Part of the work was done
while the author visited Cornell university. The work was
funded in part by ISF, NSF, CCR, and AFOSR.} \\
\affaddr{Hebrew University} \\
\email{dolev@cs.huji.ac.il}
\alignauthor Joseph Y. Halpern\thanks{
Supported in part by NSF under grants ITR-0325453 and
IIS-0534064,  and by AFOSR under grant FA9550-05-1-0055.
} \\
\affaddr{Cornell University} \\
\email{halpern@cs.cornell.edu} }

\maketitle
\begin{abstract}
Consider an asynchronous system with private channels and  processes,
up to  of which may be faulty.  We settle a longstanding open
question by providing a Byzantine agreement protocol that simultaneously
achieves three properties:
\begin{enumerate}
\item \emph{(optimal) resilience}: it works as long as ;
\item \emph{(almost-sure) termination}: with probability one, all
nonfaulty processes terminate;
\item \emph{(polynomial) efficiency}: the expected computation time,
  memory consumption, message size, and number of messages sent are all
  polynomial in .
\end{enumerate}
Earlier protocols have achieved only two of these three
properties.  In particular, the protocol of Bracha is not polynomially
efficient, the protocol of Feldman and Micali is not optimally
resilient, and the protocol of Canetti and Rabin does not have
almost-sure termination. Our protocol utilizes a new primitive called
\emph{shunning (asynchronous) verifiable secret sharing}
(SVSS), which ensures,
roughly speaking, that either a secret is successfully shared or a new
faulty process is ignored from this point onwards
by some nonfaulty process.
\end{abstract}

\category{C.2.4}{Computer-Communication Networks}{Distributed Systems}
F.0 {[Theory of Computation]}: {General}.

\terms{Security, Theory}
\keywords{Distributed computing, secret sharing, Byzantine agreement.}

\section{Introduction}
The \emph{Byzantine agreement problem}, introduced in 1980 by Pease,
Shostak, and Lamport \citeyear{PSL80}, has emerged as one of the most
fundamental problems in Distributed Computing. The problem is easy to
describe:
each process has an input value; the goal is for
all processes to agree on a
consensus value that is an input value of one of the processes. The
challenge lies in reaching agreement despite the presence of faulty
processes. Many variants of the problem have been studied.  After three
decades of
extensive research, tight bounds have been obtained for almost all of
the variants, with one significant exception:
\emph{asynchronous Byzantine agreement}, where communication channels
between processes have unbounded delay
(although messages are guaranteed to arrive eventually),
and the faulty processes are
malicious in an arbitrary way
(though nonfaulty processes have secure private channels).




An execution of a Byzantine agreement protocol is
\emph{nonterminating} if some nonfaulty process 
does not output a value.
The celebrated result of Fischer, Lynch, and Paterson \citeyear{FLP}
shows that any protocol that never reaches disagreement
(i.e., has no executions where two nonfaulty processes output different
values)
must have
some nonterminating executions.
For a protocol that never reaches disagreement, the best we can hope for
is that the set of 
nonterminating executions has probability 0.
We say such protocols are  \emph{almost-surely terminating}.
Ben-Or \citeyear{Ben83} showed that almost-surely terminating asynchronous
Byzantine agreement can be achieved
as long as ,
where  is the number of processes in the system and  is a bound on
the number of faulty processes.  However, his protocol required an
expected number of rounds that is exponential in .
This started a lengthy sequence of research on asynchronous Byzantine
agreement; see, for example,
\cite{Ben83,Bra84,CR93,FM88,KK06,RB89}.
It is well known that Byzantine agreement for  processes cannot be
reached if  \cite{PSL80}.
Therefore the best resilience one can hope for is . We
will call such protocols \emph{optimally resilient}.
Bracha \citeyear{Bra84}
provides an almost-surely terminating protocol that is optimally
resilient.
However his
protocol does not scale well with the size of the system, since,
like Ben-Or's, the
expected number of messages and rounds is exponential in .
Feldman and Micali \citeyear{FM88}
provide a Byzantine agreement protocol for the synchronous model with
optimal resilience and constant expected running time.
They extend their result to the asynchronous model,
where they provide a
polynomial-time algorithm that almost-surely terminates, but
does not have optimal resilience; their protocol requires that .
Canetti and Rabin \cite{CR93,CR93-long} provide a protocol that is
optimally resilient  and polynomially efficient.
Their result uses ideas from Rabin and Ben-Or \citeyear{RB89} on
verifiable secret sharing (VSS) in synchronous systems equipped with a
broadcast channel. The techniques of \cite{RB89} have an inherent
nonzero probability of failure; as a result, in the asynchronous
implementation of \cite{CR93},
the protocol is not  almost-surely terminating.
Indeed, in \cite{CR93-long}, the authors explicitly highlighted the problem
of finding a protocol that
simultaneously achieves optimal resilience, almost-sure termination, and
polynomial efficiency.
Up to now, despite repeated efforts, this has not been done.
The main result of this paper is to provide such a protocol.




Pretty much all protocols following Bracha's \citeyear{Bra84} used his
idea of reducing the problem of Byzantine agreement to that of
implementing a shared coin. We do that as well.
We obtain a shared coin using an approach that goes back to Feldman
and Micali \citeyear{FM88,FM97}, who essentially reduce
the problem of efficiently implementing a shared coin to that of
efficiently implementing VSS.
Roughly speaking, the secrets in VSS are used to generate a shared coin.
We refer
the reader to Canetti's thesis \cite{Can-thesis} (Chapters 4 and 5)
for a comprehensive account of the rather complex reduction from
VSS to Byzantine agreement in the asynchronous model.

The protocol of Canetti and Rabin~\cite{CR93}
also
uses the reduction from
verifiable secret sharing to Byzantine agreement.
The only reason that their protocol is not
almost-surely terminating is that they use a protocol that they call
Asynchronous Verifiable
Secret Sharing (AVSS), which has a small 
(but nonzero)
probability of not terminating.
Our protocol has essentially the same structure as the Canetti-Rabin
protocol.
Indeed, it
uses the same reduction from AVSS to Byzantine agreement as
in  \cite{CR93},
except that the use of AVSS is replaced by
a variant of AVSS that we call
\emph{shunning (asynchronous) verifiable secret sharing} (\davss).
which is guaranteed to terminate almost-surely.





To explain
the properties of \davss, we first review
the properties of standard
VSS
(verifiable secret sharing).
VSS involves a dealer who has a value to share, which we think of as the dealer's
secret.
It has two key
properties, known as \emph{validity} and \emph{binding}.
Informally, the validity property
guarantees that, if the dealer is nonfaulty, then all nonfaulty processes will
reconstruct
the
dealer's value; the binding property guarantees that a faulty
dealer must commit to a value during what is called the \emph{share
phase} of the protocol.
Our \davss scheme has weaker validity and binding properties.
Specifically, we require that in each invocation where the validity or binding
properties do not hold,
at least one nonfaulty process
ignores
at least one new faulty
process
from that invocation on.
The key observation is that this limits the
adversary to breaking the validity and binding properties at most a
polynomial number of times.



The \davss protocol uses a weaker protocol called \emph{moderated weak
shunning (asynchronous) VSS} (\mwdavss).
The
\mwdavss protocol is a variant of VSS
with a dealer and an additional entity called a
\emph{moderator}.
In \mwdavss the dealer has some input value  and the moderator has some input value .
The nonfaluty moderator's task is to enforce during the share phase that the value that the dealer shares is  (hence  if both are nonfaulty).
The initials MWS characterize how \mwdavss differs from standard VSS:
\beginsmall{itemize}
\item \textbf{Moderated}. A  faulty dealer must commit
to
the value of the nonfaulty moderator in order to complete the share
protocol.
(Katz and Koo \citeyear{KK06} use a moderator for VSS in a
somewhat similar way.)
\item \textbf{Weak}. As in \emph{weak VSS} \cite{CR93,RB89}, the binding
property of VSS is weakened so that each process
reconstructs either
the committed value or a default value (denoted ).
\item \textbf{Shunning}. Like \davss,
it is possible that neither
validity nor the weaker binding property hold, but in that case
at least one nonfaulty process
ignores
at least one new faulty process
from this stage on.
\endsmall{itemize}


As in the VSS scheme used in \cite{BGW88,FM88,FM97}, the \davss scheme
starts with a dealer who shares
a degree- bivariate polynomial
 such that  is the secret.
Each process  gets  values of each of the
polynomials  and ,
which is enough to reconstruct them, since they both have degree .
Then, roughly speaking,
each pair  of processes uses \mwdavss to commit to
 and .
This ensures that if either  or  is nonfaulty then the
reconstructed values of the \mwdavss protocol will be either  or
the required values (, ). We then use this fact to
prove the properties of the \davss protocol.


The key property of the \mwdavss protocol is its
use of a fault-detection mechanism. The mechanism has the property that
a nonfaulty process might not explicitly know it has detected a
faulty process.
The only guarantee is that it will act as if it has detected a faulty
process, by ignoring all messages from the detected process for the rest
of the protocol.
This behavior is somewhat reminiscent of the failure detector  \cite{CHT96} in the sense that a nonfaulty process might
reach a state
of permanently suspecting a faulty process without being explicitly
aware of this fact.
Since the details of the \mwdavss protocol are somewhat technical, we refer the reader to \sectionref{sec:high-level}
for a high-level description.


The rest of this paper is organized as follows.
In Section~\ref{sec:properties}, we state the properties of \davss
and \mwdavss.  In Section~\ref{sec:MWFD-AVSS}, we  provide an
implementation of \mwdavss and prove that it has the required
properties.  In Section~\ref{sec:FD-AVSS}, we do the same for \davss,
using \mwdavss as a subroutine.
A description of Bracha's
\emph{Reliable Broadcast} protocol, which we use as a subroutine, is
given in the appendix.


\section{Shunning VSS}\label{sec:properties}
As we mentioned above,
in \davss, if
either
the binding property or the validity property
does not hold, then a new faulty process is
ignored in all future invocations
by some nonfaulty
process.
To implement this, each process needs to keep track of the processes it
knows to be faulty.  Thus, the \davss scheme actually has two
components: a \emph{detection and message management protocol} (\DMM
protocol) and a \emph{VSS protocol}.  Each process uses its \DMM protocol
to decide which messages to discard, which to ignore for now, and which
to act on, and to keep track of the processes it knows to be faulty.
The \DMM protocol is invoked when the \davss scheme is initialized, and
then runs indefinitely and concurrently with all the invocations of the
VSS protocols.
The VSS protocol may be invoked a number of times while the \davss scheme runs, and several invocations may be running concurrently.
The VSS protocol is composed of a pair of protocols  (for
\emph{share}) and  (for \emph{reconstruct}).
These protocols are called separately;  is never called
unless  completes, but  may not be called at
all even if  completes.
We associate with each VSS invocation a unique session identifier
 that is composed of
a counter  and
the dealer's identifier .
We tag all events of that invocation with its session identifier,
so that it is always clear which invocation of the VSS protocol an event
belongs to.

We say that a VSS invocation has \emph{completed for process } if process
 completed the reconstruct associated with that
session. Given a process  and two VSS invocations with session
identifiers  and , we write  if process  completes the invocation of the VSS 
before process  begins the invocation of the VSS .

As we said in the introduction, our VSS scheme is \emph{shunning}.
Process  may start shunning  well before  is sure that
 is faulty;
indeed,  may shun  without ever knowing that  is faulty.
\begin{definition}
Process  is \emph{shunned} by process  starting in session

of \mwdavss (resp., \davss)
if
process  does not ignore some message from  during
session ,
but
ignores or discards
all messages from  associated with
every
session 
of  \mwdavss (resp., \davss)
such that .
\end{definition}


\subsection{Properties of \davss}
Each VSS invocation has one process  designated as the
\emph{dealer}; the
dealer has some input value .
For ease of exposition, we do not include the session identifier in our
description of the properties of the VSS protocol when they are clear
from the context, although we do include them in the description of the
protocols.
Each VSS invocation must satisfy the following properties (in runs with at
most  faulty processes); we call these the
\emph{\davss} properties.
\beginsmall{enumerate}
\item \textbf{Validity of Termination}. If a nonfaulty dealer initiates
    protocol , then each nonfaulty process will eventually
    complete protocol .

\item \textbf{Termination}. If a nonfaulty process completes protocol
    , then all nonfaulty processes will eventually complete
    protocol .
Moreover, if all nonfaulty processes begin protocol ,
    then all nonfaulty processes will eventually complete
    protocol 
(note, however, that if only some but not all nonfaulty processes begin
protocol , then there is no termination requirement).
\item \textbf{Binding}. Once the first nonfaulty process completes an invocation of
 with session id ,
there is a value  such that either
 \beginsmall{itemize}
 \item the output of each nonfaulty process that completes protocol
 is ; or
 \item  there exists a nonfaulty process  and a faulty process  such that  is shunned by  starting in session .
\endsmall{itemize}

\item  \textbf{Validity}. If the dealer is nonfaulty, then either
     \beginsmall{itemize}
         \item  the output of each nonfaulty process that completes protocol  is ; or
         \item  there exists a nonfaulty process  and a faulty process  such that  is shunned by  starting in session .
    \endsmall{itemize}

\item \textbf{Hiding}.  If the dealer is nonfaulty and no
    nonfaulty process invokes protocol , then the
    faulty processes learn nothing about the dealer's value\footnote{To make this precise, assume that the adversary
    determines the \emph{scheduling protocol}:
    how long each message will take to arrive as a function
    of the history.  Note that once we fix the inputs, the faulty processes,
    the protocols used by the faulty processes, and the scheduling
    protocol, the VSS protocol (which is used by the nonfaulty processes)
    determines a distribution on runs.  Formally, hiding requires that for
    all distributions
    determined this way, the dealer's value is independent of the
    histories of the faulty processes.}
\endsmall{enumerate}


\subsection{Properties of \mwdavss}
In order to implement the VSS protocol, we use a weaker protocol called
\emph{moderated weak shunning (asynchronous) VSS} (\mwdavss).
Just as VSS, the \mwdavss protocol is composed of a share protocol

and a reconstruction protocol .
As in weak VSS, we weaken the Binding property so that each
nonfaulty process reconstructs either  or .
But now, in addition to
having one process  designated as the dealer,
there is
an additional
process designated as the
\emph{moderator}.
Both the dealer and the moderator have (possibly different) input
values, denoted  and ,
respectively.
Each \mwdavss invocation must satisfy Termination and Validity,
just like VSS, and the following variants of the properties of VSS
(in runs with at most  faulty processes); we call these the
\emph{\mwdavss} properties.
\beginsmall{enumerate}
\item [1.] \textbf{Moderated Validity of Termination}. If a nonfaulty
    dealer initiates protocol , the moderator is nonfaulty, and ,
    then each nonfaulty process will eventually complete protocol .

\item [3.] \textbf{Weak and Moderated Binding}.
Once the first nonfaulty process completes
an invocation of protocol  with session id ,
there is a value  (possibly ) such that
\beginsmall{itemize}
 \item if the moderator is nonfaulty, then .
 \endsmall{itemize}
In addition, either
 \beginsmall{itemize}
 \item the output of each nonfaulty process that completes protocol
     is either  or ; or
 \item  there exists a nonfaulty process  and a faulty process 
    such that  is shunned by  starting in session .
 \endsmall{itemize}


\item [5.] \textbf{Moderated Hiding}.  If the dealer and moderator
are nonfaulty and no nonfaulty process invokes protocol
, then the faulty processes learn nothing about
the dealer's value.
\endsmall{enumerate}


It might seem surprising that in the second condition of Validity and
(Weak and Moderated) Binding, we talk about shunning rather than just
saying that a faulty process is detected.  The reason is that, as we
show in Example~\ref{xam:shunning} (after we give the implementation of
the \mwdavss protocol), it is possible that two nonfaulty processes
will complete an invocation of the \mwdavss protocol
with different values
without
(explicitly)
detecting
a new faulty process; however, in that case, at least one of them will
shun a faulty process that was not shunned before.

\section{Implementing \DMM and \mwdavss}\label{sec:MWFD-AVSS}


\subsection{A high-level description}\label{sec:high-level}
In this section, we provide an implementation of \DMM and \mwdavss.
We start with
a high-level description of both.
Both protocols use the Reliable Broadcast protocol (RB) of
Bracha \cite{Bra84}.
RB guarantees that messages are
indeed broadcast; if a nonfaulty sender sends a message , then all
nonfaulty processes eventually receive , and nothing else.
(The properties of RB are stated carefully in the appendix,
where, for completeness, an implementation is provided.)

We assume that the dealer
creates  degree- polynomials 
over some finite field  with 
such that 
is the secret
(i.e., )
and . Then the dealer shares the
polynomials   and also gives
each process  the polynomial .
We can think of process  as a
potential ``monitor'' for .
The dealer shares the polynomial  by sending each process  the
value .  This means that, if the dealer is correct, any 
nonfaulty processes can reconstruct .
In addition, the dealer sends  to the moderator.
Each process  that receives  sends this value to  and
broadcasts a confirmation.
In this case, we can think of process  as a ``confirmer'' for .
When
 receives confirmations and values that agree with the polynomial
 sent by the dealer from at least  processes,
 becomes a ``monitor'' for , sends
 to the moderator, and broadcasts the set  of
at least
 confirmers
whose value it
accepted. Intuitively, each monitor 
is responsible for validating
the value of one
point on the polynomial , namely,
.
When the moderator receives
at least
 values all of which agree with the polynomial  from different
monitors
and receives confirmations from their associated  sets, then the moderator
broadcasts the
set of  monitors' indexes it accepted. The dealer broadcasts a
confirmation when it learns that the moderator, its monitors, and their
confirmers have
acted in a nonfaulty manner.
This allows nonfaulty processes to know which confirmers they need to
wait for in order to complete their execution of the share protocol.



In the reconstruct phase, processes send their values using the RB
protocol. If the dealer is nonfaulty, then
it can check  the values sent by all processes and detect faulty processes.
If the dealer is faulty, then there are at least  nonfaulty monitors

that can monitor their polynomial
.
If they do not detect
problems
with their confirmers,
then the
Weak Binding property must hold.


We now explain how processes shun other processes if a problem is detected.
Before a process  ``sees'' a message in the \mwdavss protocol (or the
\davss protocol that we present later),
the message is filtered by the DMM protocol.
The  protocol
decides whether to discard the message, ignore it for now, or pass it on
for action.
In order to do this,  must maintain a number of data
structures.
First, it maintains the partial order  on
sessions described above,
where  if  started the
share protocol of VSS session  after completing the
reconstruct protocol of VSS session .
In addition,
the  protocol uses a variable  that
represents a set of processes.
Intuitively, the processes in  are ones known by  to be faulty.
Any message sent by a process  is discarded by .
To decide which messages to ignore for now and which to pass on for
action,  maintains two arrays.
The first array, denoted , consists of tuples in
.
Intuitively,  if  is expecting to receive a
broadcast sent by  using RB saying  as part of a
VSS session  (thus, this is a session for which  is the dealer).
The second array, denoted , consists of tuples in
.  Intuitively,
 if  is expecting to receive a
message broadcast by  (using RB) saying 
as part of VSS session .
Both  and  are initially empty.
We will explain how tuples are added to  and  when
we describe the \mwdavss protocol.


Process  ignores
(that is, saves but does not act on)
all messages from process  that are part of a
session   such that either  and  or
 and .  That is,
newer
messages from  are ignored by  if  is
expecting to receive something from  that it has not yet received.
When a message that  expects to hear from  that is associated with
either with   or with , then the
relevant tuple is removed from  or
.
Once there are no messages that  expects to hear from 
from a session that precedes , then the  protocol enables
the \mwdavss protocol to act on messages from session .

Finally, process  is added to  if a message is received from 
that is inconsistent with what is expected according to a tuple in
 or .  For example, if
 and  receives a message as part of session
 from  saying , with , then  is
added to ,
and messages sent by  in all sessions  such that  will be
discarded by .





\subsection{Implementing \mwdavss}
We now show how to implement \mwdavss.  We start with the
share protocol .  We assume that the field  being used is
common knowledge and .
In the  protocol (and a number of our later protocols), we
have variables that are tagged by the session id .  If the
session id is clear from context, we omit it.

\subsubsection*{Share protocol :}
\begin{enumerate}
\item If a dealer  wants to invoke  with a
secret  it first updates  to  and then
selects  random degree-
polynomials  over field  such
that  and  for all
.
It sends each process  a message
 .
In addition, it sends each process  a message
 (note that this allows  to
compute , so we sometimes say `` receives '' in
this message),
and sends the moderator yet another message,
 (so that the moderator can compute ).

\item If process  receives values 
and polynomial  from a dealer  in session ,
then, for each process ,  sends
 to .
(Note that  is supposed to be , but if the dealer
is faulty, it may not be.  We continue to use the notation  and
 to denote the polynomials and values actually received.)
It also broadcasts  to all processes using RB.

\item If process  receives   and
 from process , receives 
from the dealer , and , it
adds  to .
Intuitively, the message  provides
confirmation to  that
the dealer sent  to both  and .  The fact that
 adds  to  means that 
expects  to confirm publicly (using RB) that indeed it received
 from the dealer , which is what  told 
privately.

\item Let .
If ,
then   sends  to all processes using RB,
It also sends  to the moderator.  Intuitively, if , then  has gotten as much confirmation as it can expect
to get that the dealer  correctly shared the polynomial
.  By broadcasting , it is broadcasting the set of processes
from which it
expects to hear public  confirmation of this fact.  By sending
 to the moderator,  is giving the moderator a
share of the information that the moderator needs
for computing the secret.
\item If the moderator receives  from the dealer,
 and  from process , and
 message from all processes ,
, and , the moderator
adds  to the set ,
which is initialized to .
Intuitively, if the values that the
moderator receives from  are compatible with the values the
moderator received from the dealer, and the dealer's values are
compatible with the moderator's value ,
then the moderator adds  for the session  to .
\item
If
, the
moderator sends  to all processes using RB.

\item If the dealer  receives  from the moderator,
receives  from  each process ,
and receives  from each process  such
that , then
it adds   to 
for all  and , and sends 
using RB.
Note that if the moderator is nonfaulty and it sends these messages to
the dealer, then it really did receive
 from each process 
and  from each process  in , and these
messages were sent
using RB.  Thus, the dealer will eventually receive all these
messages too and, if nonfaulty, will broadcast the  message.


\item If process  receives  from the moderator and  then 
 removes from  all entries of the form  that
are associated with session . Intuitively, since 
 for session , we do not care about the values
of  for this session. 



\item If process  receives an  message from the dealer,
 from the moderator,  from each
process , and  from each  such that
, it completes
this invocation of the share protocol .



\end{enumerate}

\subsubsection*{Reconstruct protocol :}

\begin{enumerate}
\item
If process  for , then  broadcasts

using RB, where  is what  received from the dealer at
step 2 of .

\item
Process  initializes  to   for each process
 for which it has received a set .
If  receives a message  from
process  at step 1, and  , then  adds

to .
Intuitively,  should be the point
 on the polynomial .

\item
If , then 
finds the unique degree  polynomial
 that interpolates the points in .


\item After computing  for all , 
tries to interpolate a polynomial 
such that  for all .
If  exists,  outputs ;
otherwise,  outputs .
\end{enumerate}


\subsection{Implementing \DMM}
We now describe the implementation of .


\medskip
\textbf{Protocol }
\vspace{-2mm}
\beginsmall{enumerate}

\item Initialize an empty set of processes , an empty array 
consisting of tuples in , and an empty array  consisting of tuples in .
As we said earlier,
intuitively,  if  is expecting to receive a
    broadcast sent by  using RB saying  as part of VSS
session 
and
     if  is expecting to receive a
    message broadcast by  using RB saying 
    as part of VSS session .


\item If  and a broadcast message  is
received then
    \beginsmall{itemize}
    \item if , then remove  from ;

\item otherwise, add  to .

    \endsmall{itemize}

    (See line 7 of protocol  for the condition that causes
    a tuple  to be added to .)

\item   If  and a broadcast message 
is received, then
    \beginsmall{itemize}
    \item if  then remove  from ;

    \item otherwise, add  to .
    \endsmall{itemize}

    (See line 3 of protocol  for the condition that causes
    a tuple  to be added to .)

\item If a message sent from  is received and , then
discard the message.

\item If a message with session identifier  sent from  is received, then delay this message if there is a tuple
 such that  or a
tuple   such that .
If there is no such tuple in  or  (or after all such tuples
have been removed), then forward the message to the
   VSS invocation of session .

\endsmall{enumerate}



We now show that the \mwdavss protocol satisfies the \mwdavss
properties.  To do this, we first must establish two key properties of
the \DMM protocol.

\begin{lemma}\label{lem:DMM}
If  is nonfaulty, then  satisfies the following
two properties:
\beginsmall{itemize}
\item[(a)]  if , then  is a faulty process;
\item[(b)] if  is nonfaulty,
 (resp., ),
and all 
nonfaulty
processes complete session  (resp. ), then
eventually
 is removed from  (resp.,  is removed
from ).
\endsmall{itemize}
\end{lemma}


\begin{proof}
For part (a), note that
the only reason that  adds  to  is if 
(resp., ) and the \DMM protocol detects that
process  sent a message 
(resp., )
using RB
such that 
(resp., ). If  is nonfaulty then 
(resp., ),
hence  would not add  to  if  is nonfaulty.

Part (b) follows from the observation that if  or , then the tuple was added during
the share phase.
If  and session  completed, then it must
be the case that  and . Since  is nonfaulty, then the message required to
remove the tuple from  will be sent 
using RB by  during the reconstruct phase, and will eventually be
received by . 
If  then there are two cases. If this entry was
removed in line 8 of protocol , then we are
done. Otherwise, since session  completed, it must be the
case that  and . Hence the message
required to remove the tuple from  will be sent using RB by 
during the reconstruct phase, and will eventually be received by . 
\end{proof}



We now prove that all the \mwdavss properties hold.
\begin{lemma}\label{lem:mwdavss}
The \mwdavss protocol satisfies the\\ \mwdavss properties.
\end{lemma}
\begin{proof}
We consider the properties in turn.

\textbf{Moderated Validity of Termination}. If the dealer and the
moderator are nonfaulty and  then, for
all nonfaulty processes  and , eventually 
will be in .   Hence, eventually  will be at least
.  Thus, eventually  will complete step 4 of the share protocol.
(For future reference, note that although the first  elements of
 may not all be nonfaulty,
at least  of the elements of  will be nonfaulty.)
Moreover, since  only if  sent an  message
using RB, eventually the moderator will receive an
 message from all .  Thus, if  is
nonfaulty, a nonfaulty moderator will eventually add  to 
in step 5 of the share protocol.
Since there are  nonfaulty processes,
eventually we must have
, so the moderator completes step 6 of the share
protocol.  We already gave the intuition that a nonfaulty dealer will then
broadcast  at step 7.  Thus, all nonfaulty processes
will eventually complete protocol .

\textbf{Termination}. If a nonfaulty process  completes protocol
,
then, since all the messages that caused  to complete the protocol
are sent using RB, it follows that all nonfaulty processes
eventually complete .
The fact that
they all  complete  follows since, as observed above, the
set  for each
 contains at least  nonfaulty
processes, each of which eventually sends its value
in step 1 of .  Thus, each nonfaulty process
outputs either some value in  or  at step 3 of .

\textbf{Validity}.
Suppose that the dealer  is nonfaulty.  There are two cases.   If
some  faulty process  such that  sends
a message  at step 1 of  such that , then 
did not ignore some message from  during session ,  
will never be removed from , and eventually  will be added to

by line 2 in the  protocol.
Hence,  is shunned by  starting in session .
Thus, if no process is shunned by  for the first time in , it
must be the case that, for each process , all the values broadcast by processes in 
agree with .  Since
there will eventually be at least  values broadcast from
processes in , all
nonfaulty processes will interpolate  for all , and subsequently will interpolate  and the secret .

\textbf{Weak and Moderated Binding}.
If the dealer is nonfaulty, it follows from Validity that Weak Binding
holds, taking .
So suppose that the dealer  is faulty.
If there is
a faulty process  such that  for a nonfaulty process  and  sends a message

in step 1 of 
such that . In this case  did not ignore a message from  during session
,  will never be removed from , and
eventually  will be added to 
by line 3 in the  protocol.
Hence,  is shunned by  starting in session ,
so weak and moderated binding holds.
On the other hand,
if,
for each nonfaulty process , all the values broadcast by processes in 
are what they were expected to be
then, at the time that the first nonfaulty process
completes protocol ,
the set  is fixed.
Let  be the set of nonfaulty processes in
. For each , the value  is also
fixed. If there exists a degree- polynomial  that interpolates the
points in
, then let
; otherwise, let .
We claim that each nonfaulty process will output either  or  at
the reconstruct phase. This is true since all nonfaulty processes will
interpolate  for all  correctly. Since
, the values  determine a polynomial . If all remaining values
 obtained from the polynomials  for  agree with , then  is
output;  otherwise,   is output.

It easily follows from step 5 of
 that
if the moderator is nonfaulty, then
the values  can be interpolated only by a polynomial  such that  is the moderator's value ; that is, .


\textbf{Moderated Hiding}.   If the dealer and moderator are nonfaulty
then, as long as no nonfaulty process has invoked protocol ,
the combined view of any  faulty processes is distributed
independently of the value of the shared secret, .
This follows since the dealer uses random degree- polynomials,
so no set of size  learns any information.
\end{proof}




As promised, we now show that it is possible that two nonfaulty
processes will complete an invocation of \mwdavss with different values
without detecting a new faulty process.


\begin{example}\label{xam:shunning}
{\rm Let  and . Consider an invocation of the \mwdavss protocol with
processes , , , and , where  is the dealer and  is the
moderator. Suppose that, in the share protocol
, process  is delayed.
Hence, processes , , and  hear only from each other before
completing the  share protocol.
Thus, .
Now suppose that in
the reconstruct protocol , process  hears the values
sent by  according to line 1 of  before hearing from
 or .  Since it clearly hears from itself as well, ,
, and  will each have two points---one from  and
one from .  Since  in this case, it follows from step 3 that
 will then find the unique degree 1 polynomials
, , and  that
interpolate the points in , , and , respectively.
If , , and  are collinear, and
 is the polynomial that interpolates them, then  outputs
.  If  is faulty, then by choosing
the values it sends appropriately,  can make  an
arbitrary element of .  Now if  hears from  before
hearing from  or ,
 will also output a value, which may be different from 's.

Of course, to get  to output a value different from 's,
 must send a value  that is different from the one that
 expects to
hear.  Once  gets this value, it will realize that  is
faulty, and add  to its set .  However, this may happen after
both  and  have completed the invocation of \mwdavss.
Notice that this argument relies on the fact that processes use RB
to send their values.  } \qed
\end{example}












\section{Implementing \davss}\label{sec:FD-AVSS}
In this section, we show how to implement \davss, and then prove that our
implementation satisfies the \davss properties.
The difficulties of doing this are illustrated by Example~\ref{xam:shunning}:
it is possible that two nonfaulty processes output different values in
an invocation  of the
\mwdavss protocol. Of course, by the Weak Binding property, this can
happen only if a new faulty process is eventually detected (and is
shunned in all invocations that follow ).
Nevertheless, this detection can come after all processes have
completed .  Thus, we must show that the inconsistency cannot
cause problems.


\subsubsection*{Share protocol :}
\begin{enumerate}
\item If a dealer  wants to invoke  with a
secret , it first updates  to ,
initializes sets of processes  and , ,
to 
and
chooses
a random degree- bivariate polynomial
 over the field  such that \footnote{Specifically, since a bivariate polynomial of degree  has
the form , we simply set 
and choose the remaining coefficients at random from .  Of course,
the same ideas apply to choosing a  random univariate polynomial 
such that .}
Let  and let , for .
Dealer  sends each process 
the message 
(so  can reconstruct  and ).

\item If a process  receives  and  from dealer  for a
session , then for each process , process 
participates in four invocations of \mwdavss protocol :

    \beginsmall{enumerate}
\item as a dealer with secret  and moderator
    
(who should also have value   if  and  are
    nonfaulty);
\item as a dealer with secret  and moderator
     (who should also have value  if  and
     are nonfaulty);
\item as a moderator with secret  and dealer
     (who should also have value   if  and
     are nonfaulty); and
\item as a moderator with secret  and dealer
     (who should also have value   if  and
     are
    nonfaulty).
    \endsmall{enumerate}
\item The dealer  adds  to the set  and  to the
set  if
the dealer completes all four invocations of
the share part of
\mwdavss  with
 and  playing the roles of dealer and moderator.

\item The dealer  adds  to the set  if .

\item If , the dealer sends  using RB.

\item When process  receives  from the dealer and completes all four  protocols
for each pair  such that  and , then it completes this invocation of .
\end{enumerate}

\subsubsection*{Reconstruct protocol :}

\begin{enumerate}
\item Each process
 initializes the set  to 
and invokes the reconstruct protocol 
for
each of the four invocations of \mwdavss for each
pair  such that  and
.
After the four reconstruct protocols associated with  and  are
complete,
 sets  to
    the reconstructed
    output value for the entry  where  was the dealer in the
\mwdavss protocol (so that  is either  or ).

\item For each , process  adds  to  if
\begin{itemize}
    \item there exists  such that  or  are ; or

    \item there do not exist degree- polynomials that interpolate
     or
    .
\end{itemize}
Intuitively,  consists of those processes that 
ignores in invocation .

\item For each , process  computes the
degree- polynomials  and 
 that interpolate   and .
If there exist  such that ,
then
 outputs .
Otherwise,
if there is  a
unique degree- bivariate polynomial 
  such that for all ,
  ,
then  outputs ; otherwise,  outputs .
\end{enumerate}

This completes the description of the \davss protocol.

\begin{lemma}\label{lem:d-avss}
The \davss protocol satisfies the \davss properties.
\end{lemma}
\begin{proof}
For any \davss session , if  are nonfaulty processes, then
all messages sent from  to  will eventually not be ignored. This
is true since, if , then 
completed all  invocations associated with . From
the way we use \mwdavss in , all processes will also invoke
all 
sessions
 associated with . Hence from the Termination
property of \mwdavss and \lemmaref{lem:DMM}, it follows that all
messages that  expects  to send in session  will eventually be
received.
We now go through \davss properties in turn.

\textbf{Validity of Termination}. If the dealer is nonfaulty, then for
any two nonfaulty processes  and , eventually all four
invocations of
 will complete. So eventually the set 
will be of size at least  for each nonfaulty , the set 
will eventually contain at least  elements, and all four
 invocations for each  and  will
complete. By the properties of RB, all processes
will eventually receive the sets  and  and, by the
Termination property of \mwdavss, for each   and ,
all processes will eventually complete all four invocations of .
Hence, all nonfaulty processes will complete protocol
.

\textbf{Termination}. If a nonfaulty process completes protocol
,
then it
follows from the Termination property of the \mwdavss protocol and the
Reliable Broadcast properties
that all nonfaulty processes complete .
The fact that they all  complete
 follows from the Termination property of the \mwdavss protocol.

\textbf{Validity}. Suppose that the dealer  is nonfaulty in an
invocation of  with session id .  There are
two cases. If a faulty process  is first shunned by a nonfaulty
process  in some \mwdavss invocation with session  that is
part of the \davss invocation with session id , then,
because  started  before starting  and  completes
 before completing ,
 is
also
first shunned by  starting in session  of \davss.
On the other hand, if no faulty process is shunned starting in session
, then all invocations of \mwdavss
must satisfy the first clause of the Validity and Weak and Moderated
Binding properties.
It follows from (the first clause of) the Validity property that
if  is nonfaulty, then for all , it must be
the case that  and  (since  acts as the dealer in computing these values,  acts as the moderator and
the values themselves are correct, since they were received from ).
Thus, it follows that .
Similarly, it follows from (the first clause of) the Weak and Moderated
Binding property that, for all  and , if
either 
or  are nonfaulty, then it must be
the case that  and  are each either
 or , and that
 and  are each either  or
.  (Here we use the
fact that the nonfaulty process
---either  or ---is acting as
either dealer or moderator in the
invocations of \mwdavss during which these values are computed.)
Thus, even if  is faulty,  if , then we must have

for all nonfaulty .
It follows  that,
in step 3 of , 
correctly reconstructs
 and 
for all .
Thus, the polynomial  computed by  will be , and  will
output .

\textbf{Binding}.
If the dealer is nonfaulty, it follows from Validity that Binding
holds, taking .
If the dealer is faulty, there are again two cases.
If a faulty process  is shunned by a nonfaulty
process  in some \mwdavss invocation with session  that is
part of the \davss invocation session ,
then, as argued in the proof of Validity,  is also first shunned by
 in invocation .
On the other hand, if no
faulty process is shunned starting in session
, then all invocations of \mwdavss must satisfy the first clause
of the Validity and Moderated Weak Binding properties.
Consider the time that the first nonfaulty process
completes protocol . At this time, the set  is fixed.
Let  be the set of nonfaulty processes in .  Since ,
we must have that .
If there is a unique degree- bivariate polynomial 
induced by the entries  for all  and
, then set ;
otherwise, set .





We claim that each nonfaulty process will output  at the reconstruct
phase.  As in the proof of the Validity property for \davss,
it follows from (the first clause of) the Validity property for
\mwdavss that if  is nonfaulty, then
for all nonfaulty , we have
that   and , where  and  are the polynomials sent
by  to .
Thus, .
Hence, if , then all nonfaulty processes will output .
Moreover,
if , then,
as in the proof of Validity for \davss,  by the Weak and
Moderated Binding property,
and from the fact that ,
for all , it must be
the case that  and  agree with .
Therefore  will interpolate  and output .




\textbf{Hiding}.   If the dealer is nonfaulty and no
nonfaulty process has invoked protocol ,
then the combined
view of any  processes is distributed independently of the
dealer's value , because every polynomial  and  has degree
, and no process learns more than  values of these polynomials.
\end{proof}

This completes the construction of the \davss protocol.  We now briefly sketch how, using ideas from Canetti and Rabin
\citeyear{CR93}, we can use \davss to construct the required
asynchronous Byzantine agreement protocol.



\section{From \davss to Byzantine\\ Agreement}\label{sec:restofprotocol}


Once we have \davss, we can get an almost-surely terminating polynomial
protocol for Byzantine agreement with optimal resilience, following the
ideas outlined in Canetti's \citeyear{Can-thesis} thesis.  We proceed
in two steps.
The first step is to get a common coin.  Canetti and Rabin
showed that, given , an AVSS protocol that terminates with
probability  could be used to construct a protocol
CC that gives a common coin and terminates with probability .
We use \davss to get a
\emph{shunning Common Coin} (SCC) protocol.
\begin{definition}[SCC]
Let  be a protocol where each party has a random input and a
binary output. As in \davss, we tag each invocation of  with a
unique session identifier .
We say that  is a \emph{shunning, terminating, -resilient
Common Coin protocol}
(SCC protocol)
if the  following properties,
called the \emph{SCC properties},
hold
(in runs with at most  faulty processes
in some session tagged 
):
\begin{enumerate}
\item \textbf{Termination}. All nonfaulty processes terminate.

\item \textbf{Correctness}. For every invocation either
    \begin{itemize}
        \item for each , with probability at least , all nonfaulty processes output ; or

        \item there exists a nonfaulty process  and a faulty process  such that  is shunned by  starting in session .
    \end{itemize}
\end{enumerate}	
\end{definition}

\begin{lemma}
For  there exists a shunning, terminating, -resilient Common Coin protocol.
\end{lemma}

\begin{proof}
The protocol to implement SCC is exactly the protocol in Figure 5--9
in \cite{Can-thesis}, except that we replace the AVSS protocol
with our \davss. The proof
that this protocol satisfies the SCC properties
follows from
Lemmas 5.27--5.31 in \cite{Can-thesis}, together with the
observation that if a process is shunned starting at a \davss invocation
whose reconstruct protocol competes before the SCC protocol invocation
completes, then this process is shunned starting at this SCC protocol
invocation.
\begin{comment}
following observation.

If a \davss share invocation  is an attached secret of a
process  (see line 2 of figure 5--9 for the definition of attach) for
some invocation  of protocol SCC, and  belongs to some set
 (see figure 5--9 for the use of ) then the
invocation  of \davss must begin after the invocation 
of FD, and  must end before  does.
Hence, if some faulty process  is shunned by some nonfaulty process
 in , then  is also shunned by  in .
On the other hand,
if no such \davss invocation  is shunned during invocation ,
then the arguments of
Canetti apply.
\end{comment}
\end{proof}

The second step is to use the common coin protocol to get the Byzantine
agreement
protocol.  Canetti and Rabin use their
common coin protocol CC that terminates with probability  to
get a Byzantine agreement protocol that
terminates with probability .  We replace the use of
CC by SCC to get an almost-surely terminating protocol.
The key observation is that in the protocol of Figure 5-11 in
\cite{Can-thesis}, if a nonfaulty process 
participates in rounds  and  (and hence, in our setting, it
participles in the SCC protocol with session identifiers  and
),
and ,
then it must be the case that
.
Therefore, there can be at most  rounds  such that a
nonfaulty process   shuns a faulty process  starting in round .
Hence, there are
at most  rounds where the SCC protocol
does not succeed. In all the remaining rounds, the first clause of the SCC
Correctness property holds,
so we essentially have a common coin that is sufficiently strong for
Byzantine agreement.
It therefore follows from Lemma 5.38 and
5.29 of \cite{Can-thesis} that
the expected running time of the protocol is  .
Thus we have the following result.

\begin{theorem}[Byzantine Agreement]
There is an
almost-surly terminating, polynomial protocol for
asynchronous Byzantine agreement protocol with optimal resilience.
\end{theorem}





\section{Conclusions}


We have shown how to use \davss to give a protocol for asynchronous
Byzantine agreement that has optimal resilience, almost-surely
terminates, and is polynomially efficient.
Our \davss protocol has implications for asynchronous Secure Multiparty
Computation  (ASMPC) of certain functionalities. In the full paper we
define a family of functionalities for which the use of \davss gives a
protocol for
ASMPC that has optimal resilience, terminates almost surely, and has
perfect security (the ideal and real worlds are statistically
indistinguishable).
Perhaps the major open question remaining is whether there exists
an asynchronous Byzantine agreement protocol with optimal resilience and
constant expected running time.





\appendix



\section{Basic tools}


\subsection{Weak Reliable Broadcast}
A protocol  with a distinguished dealer holding input
 is a -tolerant \emph{Weak Reliable Broadcast
protocol} if the following holds for every execution with at most  faulty processes:
\begin{enumerate}
\item \textbf{Weak termination}. If the dealer is nonfaulty, then every
nonfaulty
process will eventually complete protocol .
\item \textbf{Correctness}.
\begin{enumerate}
\item
if a nonfaulty process completes protocol , then once the
first nonfaulty process completes the protocol
there is a value  such that
each nonfaulty process that completes protocol  accepts
;
\item if the dealer is nonfaulty, then
each nonfaulty process that completes protocol  accepts .\end{enumerate}
\end{enumerate}
\begin{lemma}
For  there exists a
-tolerant \emph{Weak Reliable Broadcast protocol}.
\end{lemma}
\begin{proof}
This protocol, which we call WRB, is essentially Dolev's \citeyear{D82}
\emph{crusader agreement}.
It uses two types of messages; \emph{type 1 messages} have
the form  and \emph{type 2 messages} have the form .
WRB proceeds as follows:
\begin{enumerate}
\item The dealer sends  to all processes.
\item  If process  receives a type 1 message  from the
dealer and it never sent a type 2 message, then process  sends
 to all processes.
\item If process  receives   distinct type 2 messages
, all with value ,
then it accepts the value .
\end{enumerate}

If the dealer is nonfaulty, then
it is immediate that every nonfaulty process will send , and thus
will accept  (since there are at most  faulty processes, by
assumption).
Moreover, if the dealer is nonfaulty,
the only type 2 message sent by a nonfaulty process is , so no
nonfaulty process will receive more than  type 2 messages  with .\footnote{We assume that,
as in VSS,
if there are multiple invocations of WRB,
messages are tagged with an invocation number,
so that messages from old invocations will not be confused with messages
from the current invocation.}


To see that WRB satisfies the correctness property,
suppose, by way of contradiction, that one nonfaulty process  accepts 
and another nonfaulty process  accepts , with .  Then
 must have received  type 2 messages with value  and 
must have received  type 2 messages with value .
Thus, at least  processes must have sent a type 2
message to both  and .
At least one of these processes must be
nonfaulty.  But the protocol ensures that a nonfaulty process will send only
one type 2 message.  This gives us the desired contradiction.
\end{proof}


\subsection{Reliable Broadcast}
A protocol  with a distinguished dealer holding input  is a -tolerant \emph{Reliable Broadcast
protocol} if the weak termination and correctness properties of the Weak
Reliable Broadcast holds, and in addition, the following property holds:
\begin{enumerate}
\item[3.]
\textbf{Termination}. For every execution with at most  faulty
processes,
if some nonfaulty process completes protocol
 then all nonfaulty processes will eventually
complete protocol .
\end{enumerate}
\begin{lemma}
For  there exists a -tolerant \emph{Reliable Broadcast (RB) protocol}.
\end{lemma}
\begin{proof}
This protocol, which we call RB, is essentially Bracha's \emph{echo
broadcast}.  It uses WRB as a subroutine.  In addition to type 1  and
type 2 messages, it uses \emph{type 3} messages, which have the
form .  RB proceeds as follows:
\begin{enumerate}
\item The dealer sends  to all processes using Weak Reliable
Broadcast (WRB).
\item  If process  accepts  message  from the dealer using WRB,
then process  sends
 to all processes.
\item if process  receives at least  distinct
type 3 messages with the same value ,
then process  sends  to all processes.
\item if process  receives at least   distinct
type 3 messages with the same value , then it accepts the value
.
\end{enumerate}

To see that RB is correct, first observe
that, from the correctness property of WRB, it follows that
it cannot be the case that two type 3 message with different values are
sent by nonfaulty processes at step 2.
Moreover, if a nonfaulty process
sends a type 3 message at step 3, it must be because it got a type 3
message from a nonfaulty process.  It easily follows that all the type 3
messages sent by nonfaulty processes at either step 2 or step 3 have the
same value.


If the dealer is nonfaulty, then it is easy to see that
all nonfaulty processes terminate and accept value , as in WRB.  To
see that
termination holds for RB,
suppose that a nonfaulty process completes the
protocol.
It thus must have received  type 3 messages with the same value
.  Each other nonfaulty process
will eventually have received at least  of these messages,
and so will send a type 3 message by step 3, if it has not already
done so by step 2.  As we argued above, all the type 3 messages sent
by nonfaulty processes must have the same value.  Thus,
each nonfaulty process will end up receiving
 type 3  messages with value .


Finally, part (b) of correctness follows easily from our observation
above that all the type 3 messages sent by nonfaulty processes have the
same value .
\end{proof}



\begin{thebibliography}{10}




\bibitem{Ben83}
M.~Ben{-}Or.
\newblock Another advantage of free choice (extended abstract): Completely
  asynchronous agreement protocols.
\newblock In {\em Proc.~2nd ACM Symposium on Principles of Distributed
Computing}, pages 27-30, 1983.

\bibitem{BGW88}
M.~Ben{-}Or, S.~Goldwasser, and A.~Wigderson.
\newblock Completeness theorems for non-cryptographic fault-tolerant
  distributed computation.
\newblock In {\em Proc.~20th ACM Symp.~Theory of Computing}, pages 1--10, 1988.

\bibitem{Bra84}
G.~Bracha.
\newblock An asynchronous [(n - 1)/3]-resilient consensus protocol.
\newblock In {\em Proc.~3rd ACM Symp.~Principles of Distributed Computing},
pages 154--162, 1984.

\bibitem{CR93}
R.~Canetti and T.~Rabin.
\newblock Fast asynchronous Byzantine agreement with optimal resilience.
\newblock In {\em Proc. 25th ACM
Symp. Theory of Computing}, pages 42--51, 1993.

\bibitem{CR93-long}
R.~Canetti and T.~Rabin.
\newblock Fast asynchronous Byzantine agreement with optimal resilience, 1993.
\newblock http://people.csail.mit.edu/canetti/materials/cr93.ps.

\bibitem{Can-thesis}
R.~Canetti.
\newblock Studies in secure multiparty computation and applications, 1996.
\newblock http://people.csail.mit.edu/canetti/materials/thesis.ps.

\bibitem{CHT96}
T.~D. Chandra, V. Hadzilacos, and S. Toueg.
\newblock The weakest failure detector for solving consensus.
\newblock {\em Journal of the ACM}, 43:685--722, 1996.

\bibitem{D82}
D.~Dolev.
\newblock The Byzantine generals strike again.
\newblock {\em {J}ournal of {A}lgorithms}, 3:14--30, 1982.

\bibitem{FM88}
P.~Feldman and S.~Micali.
\newblock Optimal algorithms for Byzantine agreement.
\newblock In {\em Proc.~20th ACM Symp.~Theory of Computing}, pages 148--161,
  1988.

\bibitem{FM97}
P.~Feldman and S.~Micali.
\newblock An optimal probabilistic protocol for synchronous Byzantine
  agreement.
\newblock {\em SIAM J. Comput.}, 26(4):873--933, 1997.

\bibitem{FLP}
M.~J. Fischer, N.~A. Lynch, and M.~S. Paterson.
\newblock Impossibility of distributed consensus with one faulty processor.
\newblock {\em Journal of the ACM}, 32(2):374--382, 1985.

\bibitem{KK06}
J.~Katz and C.-Y. Koo.
\newblock On expected constant-round protocols for Byzantine agreement.
\newblock In Cynthia Dwork, editor, {\em CRYPTO}, volume 4117 of {\em Lecture
  Notes in Computer Science}, pages 445--462. Springer, 2006.

\bibitem{PSL80}
M.~Pease, R.~Shostak, and L.~Lamport.
\newblock Reaching agreement in the presence of faults.
\newblock {\em J. of the ACM}, 27(2):228--234, 1980.

\bibitem{RB89}
T.~Rabin and M.~Ben{-}Or.
\newblock Verifiable secret sharing and multiparty protocols with honest
  majority.
\newblock In {\em Proc.~21st ACM Symp.~Theory of Computing}, pages 73--85,
  1989.

\end{thebibliography}



\end{document}
