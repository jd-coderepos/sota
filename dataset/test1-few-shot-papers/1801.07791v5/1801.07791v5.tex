\documentclass{article}
\pdfoutput=1



\usepackage[preprint]{nips_2018}
\newcommand{\githuburl}{https://github.com/yangyanli/PointCNN}







\usepackage[utf8]{inputenc} \usepackage[T1]{fontenc}    \usepackage{hyperref}       \usepackage{url}            \usepackage{booktabs}       \usepackage{amsfonts}       \usepackage{nicefrac}       \usepackage{microtype}      

\usepackage{caption}
\usepackage{amsmath}
\usepackage{mathtools}
\usepackage{textcomp}
\usepackage{wrapfig}
\usepackage{graphicx}

\usepackage[ruled]{algorithm2e} \renewcommand{\algorithmcfname}{ALGORITHM}
\SetAlFnt{\small}
\SetAlCapFnt{\small}
\SetAlCapNameFnt{\small}
\SetAlCapHSkip{0pt}
\IncMargin{-\parindent}

\usepackage{algpseudocode}
\usepackage{multirow}
\usepackage{enumitem}
\usepackage{color}
\definecolor{gray}{rgb}{0.35,0.35,0.35}
\definecolor{blue}{rgb}{0,0,1}
\definecolor{red}{rgb}{1,0,0}
\definecolor{orange}{rgb}{0.75, 0.4, 0}
\newcommand{\todo}[1]{{\color{red}\textbf{ }[Todo: #1]}\normalfont}
\newcommand{\yy}[1]{{\color{orange}\textbf{ }[Yangyan: #1]}\normalfont}
\newcommand{\bq}[1]{{\color{blue}\textbf{ }[Baoquan: #1]}\normalfont}
\newcommand{\nf}[1]{{\color{magenta}\textbf{ }#1}\normalfont}

\title{PointCNN: Convolution On -Transformed Points}



\author{
  Yangyan Li\textsuperscript{\textdagger}\thanks{Part of the work was done during Yangyan's Autodesk Research 2017 summer visit.} \quad Rui Bu\textsuperscript{\textdagger} \quad Mingchao Sun\textsuperscript{\textdagger} \quad Wei Wu\textsuperscript{\textdagger} \quad Xinhan Di\textsuperscript{\textdaggerdbl} \quad Baoquan Chen\textsuperscript{\textsection}\\
  \And
  \textsuperscript{\textdagger}Shandong University \hspace{0.6in} \textsuperscript{\textdaggerdbl}Huawei Inc. \hspace{0.6in}
  \textsuperscript{\textsection}Peking University \\
}

\begin{document}


\maketitle

\begin{abstract}
	We present a simple and general framework for feature learning from point clouds. The key to the success of CNNs is the convolution operator that is capable of leveraging spatially-local correlation in data represented densely in grids (e.g. images). However, point clouds are irregular and unordered, thus directly convolving kernels against features associated with the points will result in desertion of shape information and variance to point ordering. To address these problems, we propose to learn an -transformation from the input points to simultaneously promote two causes: the first is the weighting of the input features associated with the points, and the second is the permutation of the points into a latent and potentially canonical order. Element-wise product and sum operations of the typical convolution operator are subsequently applied on the -transformed features. The proposed method is a generalization of typical CNNs to feature learning from point clouds, thus we call it \emph{PointCNN}. Experiments show that PointCNN achieves on par or better performance than state-of-the-art methods on multiple challenging benchmark datasets and tasks.
\end{abstract}


 \section{Introduction}
\label{sec:introduction}

Spatially-local correlation is a ubiquitous property of various types of data that is independent of the data representation. For data that is represented in regular domains, such as images, the convolution operator has been shown to be effective in exploiting that correlation as the key contributor to the success of CNNs on a variety of tasks~\cite{lecun2015deep}. However, for data represented in point cloud form, which is irregular and unordered, the convoralution operator is ill-suited for leveraging spatially-local correlations in the data.

\begin{figure}[h!]
\begin{minipage}{.5\linewidth}
  \includegraphics[width=1.0\textwidth]{figures/motivation}
  \captionof{figure}{Convolution input from regular grids (i) and point clouds (ii-iv). In (i), each grid cell is associated with a feature. In (ii-iv), the points are sampled from local neighborhoods, in analogy to local patches in (i), and each point is associated with a feature, an order index, and coordinates.}
  \label{fig:motivation}
\end{minipage}
\begin{minipage}{.5\linewidth}
  
    \begin{split}
    f_{ii} & = Conv(\mathbf{K}, [f_a, f_b, f_c, f_d]^T), \\
    f_{iii} & = Conv(\mathbf{K}, [f_a, f_b, f_c, f_d]^T), \\
    f_{iv} & = Conv(\mathbf{K}, [f_c, f_a, f_b, f_d]^T).
    \end{split}
    \label{eq:no_X}
    
    \begin{split}
    f_{ii} & = Conv(\mathbf{K}, \mathcal{X}_{ii} \times [f_a, f_b, f_c, f_d]^T), \\
    f_{iii} & = Conv(\mathbf{K}, \mathcal{X}_{iii} \times [f_a, f_b, f_c, f_d]^T), \\
    f_{iv} & = Conv(\mathbf{K}, \mathcal{X}_{iv} \times [f_c, f_a, f_b, f_d]^T).
    \end{split}
    \label{eq:with_X}
    
\end{minipage}
\end{figure}

We illustrate the problems and challenges of applying convolutions on point clouds in Figure~\ref{fig:motivation}. Suppose the unordered set of the -dimensional input features is the same  in all the cases (), and we have one kernel  of shape . In (i), by following the canonical order given by the regular grid structure, the features in the local  patch can be cast into  of shape , for convolving with , yielding , where  is simply an element-wise product followed by a sum\footnote{Actually, this is a special instance of convolution --- a convolution that is applied in \textbf{one} spatial location. For simplicity, we call it convolution as well.}. In , , and , the points are sampled from local neighborhoods, and thus their ordering may be arbitrary. By following orders as illustrated in the figure, the input feature set  can be cast into  in  and , and  in (iv). Based on this, if the convolution operator is directly applied, the output features for the three cases could be computed as depicted in Eq.~\ref{eq:no_X}. Note that  holds for all cases, while  holds for most cases. This example illustrates that a direct convolution results in deserting shape information (i.e., ), while retaining variance to the ordering (i.e., ).


In this paper, we propose to learn a  -transformation for the coordinates of  input points , with a multilayer perceptron~\cite{Rumelhart_1986}, i.e., . Our aim is to use it to simultaneously weight and permute the input features, and subsequently apply a typical convolution on the transformed features. We refer to this process as -Conv, and it is the basic building block for our PointCNN. The -Conv for , , and  in Figure~\ref{fig:motivation} can be formulated as in Eq.~\ref{eq:with_X}, where the s are  matrices, as  in this figure. Note that since  and  are learned from points of different shapes, they can differ so as to weight the input features accordingly, and achieve . For  and , if they are learned to satisfy , where  is the permutation matrix for permuting  into , then  can be achieved.

From the analysis of the example in Figure~\ref{fig:motivation}, it is clear that, with ideal -transformations, -Conv is capable of taking the point shapes into consideration, while being invariant to ordering. In practice, we find that the learned -transformations are far from ideal, especially in terms of the permutation equivalence aspect. Nevertheless, PointCNN built with -Conv is still significantly better than a direct application of typical convolutions on point clouds, and on par or better than state-of-the-art neural networks designed for point cloud input data, such as PointNet++~\cite{Qi_NIPS17}.

Section~\ref{sec:pointcnn} contains the details of -Conv, as well as PointCNN architectures. We show our results on multiple challenging benchmark datasets and tasks in Section~\ref{sec:experiments}, together with ablation experiments and visualizations for a better understanding of PointCNN.


 \section{Related Work}
\label{sec:related_work}

\paragraph{Feature Learning from Regular Domains.} CNNs have been very successful for leveraging spatially-local correlation in images --- pixels in 2D regular grids~\cite{lecun1998gradient}. There has been work in extending CNNs to higher dimensional regular domains, such as 3D voxels~\cite{Wu_CVPR15}. However, as both the input and convolution kernels are of higher dimensions, the amount of both computation and memory inflates dramatically. Octree~\cite{Riegler_CVPR17,Wang_SIGGRAPH17}, Kd-Tree~\cite{Klokov_ICCV17} and Hash~\cite{Shao_arXiv18} based approaches have been proposed to save computation by skipping convolution in empty space. The activations are kept sparse in~\cite{SubmanifoldSparseConvNet} to retain sparsity in convolved layers. \cite{Hua_CVPR18} and \cite{BenShabat_arXiv18} partition point cloud into grids and  represent each grid with grid mean points and Fisher vectors respectively for convolving with 3D kernels. In these approaches, the kernels themselves are still dense and of high dimension. Sparse kernels are proposed in~\cite{Li_NIPS16}, but this approach cannot be applied recursively for learning hierarchical features. Compared with these methods, PointCNN is sparse in both input representation and convolution kernels.

\paragraph{Feature Learning from Irregular Domains.} Stimulated by the rapid advances and demands in 3D sensing, there has been quite a few recent developments in feature learning from 3D point clouds. PointNet~\cite{Qi_CVPR17} and Deep Sets~\cite{Zaheer_NIPS17} proposed to achieve input order invariance by the use of a symmetric function over inputs. PointNet++~\cite{Qi_NIPS17} and SO-Net~\cite{Li_CVPR18} apply PointNet hierarchically for better capturing of local structures. Kernel correlation and graph pooling are proposed for improving PointNet-like methods in~\cite{Shen_CVPR18}. RNN is used in~\cite{Huang_CVPR18} for processing features aggregated by pooling from ordered point cloud slices. \cite{Wang_arXiv18_mit} proposed to leverage neighborhood structures in both point and feature spaces. While these symmetric pooling based approaches, as well as those in \cite{Dieleman_ICML16,Zaheer_NIPS17,ravanbakhsh2016deep}, have guarantee in achieving order invariance, they come with a price of throwing away information.

\cite{Su_CVPR18,Atzmon_SIGGRAPH18,Tatarchenko_CVPR18} propose to first ``interpolate'' or ``project'' features into \emph{predefined} regular domains, where typical CNNs can be applied. In contrast, the regular domain is latent in our method. CNN kernels are represented as parametric functions of neighborhood point positions to generalize CNNs for point clouds in \cite{Wang_CVPR18_Deep,Groh_arXiv18,Xu_arXiv18}. The kernels associated with each point are parametrized individually in these methods, while the -transformations in our method are learned from each neighborhood, thus could potentially by more adaptive to local structures.

Besides as point clouds, sparse data in irregular domains can be represented as graphs, or meshes, and a few works have been proposed for feature learning from such representations~\cite{Monti_CVPR17,Yi_CVPR17,Maron_SIGGRAPH17}. We refer the interested reader to~\cite{Bronstein_17} for a comprehensive survey of work along these directions. Spectral graph convolution on a local graph is used for processing point clouds in~\cite{Wang_arXiv18_mg}.

\paragraph{Invariance vs. Equivariance.}
A line of pioneering work aiming at achieving equivariance has been proposed to address the information loss problem of pooling in achieving invariance~\cite{hinton2011transforming,sabour2017dynamic}. The -transformations in our formulation, ideally, are capable of realizing equivariance, and are demonstrated to be effective in practice. We also found similarity between PointCNN and Spatial Transformer Networks~\cite{Jaderberg_NIPS15}, in the sense that both of them provided a mechanism to ``transform'' input into latent canonical forms for being further processed, with no explicit loss or constraint in enforcing the canonicalization. In practice, it turns out that the networks find their ways to leverage the mechanism for learning better. In PointCNN, the -transformation is supposed to serve for both weighting and permutation, thus is modelled as a general matrix. This is different than that in~\cite{Cruz_CVPR17}, where a permutation matrix is the desired output, and is approximated by a doubly stochastic matrix. \section{P\lowercase{oint}CNN}
\label{sec:pointcnn}

The hierarchical application of convolutions is essential for learning hierarchical representations via CNNs. PointCNN shares the same design and generalizes it to point clouds. First, we introduce hierarchical convolutions in PointCNN, in analogy to that of image CNNs, then, we explain the core -Conv operator in detail, and finally, present PointCNN architectures geared toward various tasks.

\subsection{Hierarchical Convolution}

\begin{figure}[h!]
  \begin{minipage}[c]{0.5\textwidth}
  \includegraphics[width=\textwidth]{figures/hierarchical}
  \end{minipage}\hfill
  \begin{minipage}[c]{0.48\textwidth}
	\caption{Hierarchical convolution on regular grids (upper) and point clouds (lower). In regular grids, convolutions are recursively applied on local grid patches, which often reduces the grid resolution (), while increasing the channel number (visualized by dot thickness). Similarly, in point clouds, -Conv is recursively applied to ``project'', or ``aggregate'', information from neighborhoods into fewer representative points (), but each with richer information.}
	\label{fig:hierarchical}
  \end{minipage}
\end{figure}

Before we introduce the hierarchical convolution in PointCNN, we briefly go through
its well known version for regular grids, as illustrated in Figure~\ref{fig:hierarchical} upper. The input to grid-based CNNs is a feature map  of shape , where  is the spatial resolution, and  is the feature channel depth. The convolution of kernels  of shape  against local patches of shape  from , yields another feature map  of shape . Note that in Figure~\ref{fig:hierarchical} upper, , , and . Compared with ,  is often of lower resolution () and of deeper channels (), and encodes higher level information. This process is recursively applied, producing feature maps with decreasing spatial resolution ( in Figure~\ref{fig:hierarchical} upper), but deeper channels (visualized by increasingly thicker dots in Figure~\ref{fig:hierarchical} upper).

The input to PointCNN is , i.e., a set of points , each associated with a feature . Following the hierarchical construction of grid-based CNNs, we would like to apply -Conv on  to obtain a higher level representation , where  is a set of representative points of  and  is of a smaller spatial resolution and deeper feature channels than , i.e., , and . When the -Conv process of turning  into  is recursively applied, the input points with features are ``projected'', or ``aggregated'', into fewer points ( in Figure~\ref{fig:hierarchical} lower), but each with increasingly richer features (visualized by increasingly thicker dots in Figure~\ref{fig:hierarchical} lower).

The representative points  should be the points that are beneficial for the information ``projection'' or ``aggregation''. In our implementation, they are generated by random down-sampling of  in classification tasks, and farthest point sampling in segmentation tasks, since segmentation tasks are more demanding on a uniform point distribution. We suspect some more advanced point selections which have shown promising performance in geometry processing, such as Deep Points~\cite{Wu_SIGGRAPH15}, could fit in here as well. We leave the exploration of better representative point generation methods for future work.

\subsection{-Conv Operator}

-Conv is the core operator for turning  into . In this section, we first introduce the input, output and procedure of the operator, and then explain the rationale behind the procedure.

\begin{algorithm}[h!]
	\SetKwInOut{Input}{Input}
	\SetKwInOut{Output}{Output}
	\Input{, , , }
	\Output{ \Comment{Features ``projected'', or ``aggregated'', into representative point }}
	\begin{algorithmic}[1]
		\State  \Comment{Move  to local coordinate system of } 
		\State  \Comment{\textbf{Individually} lift each point into  dimensional space} 
		\State  \Comment{Concatenate } and ,  is a  matrix 
		\State  \Comment{Learn the  -transformation matrix} 
		\State  \Comment{Weight and permute  with the learnt } 
		\State  Conv \Comment{Finally, typical convolution between  and }	
	\end{algorithmic}
	\caption{-Conv Operator}
	\label{alg:xconv}
\end{algorithm}

To leverage spatially-local correlation, similar to convolution in grid-based CNNs, -Conv operates in local regions. Since the output features are supposed to be associated with the representative points , -Conv takes their neighborhood points in , as well as the associated features, as input to convolve with. For simplicity, we denote a representative point in  as , the features with  as  and its  neighbors in  as , thus the -Conv input for this specific  is . Note that  is an unordered set. Without loss of generality,  can be cast into a  matrix , and a  matrix , and  denotes the trainable convolution kernels. With these inputs, we would like to compute the features , which are the ``projection'', or ``aggregation'', of the input features into the representative point . We detail the -Conv operator in Algorithm~\ref{alg:xconv}, and summarize it concisely as:

where  is a multilayer perceptron applied individually on each point, as in PointNet~\cite{Qi_CVPR17}. Note that all the operations involved in building -Conv, i.e., Conv, , matrix multiplication , and , are differentiable. Accordingly. -Conv is differentiable, and can be plugged into a neural network for training by back propagation.

\begin{figure}[t!]
  \includegraphics[width=\textwidth]{figures/relative}
  \caption{The process for converting point coordinates to features. Neighboring points are transformed to the local coordinate systems of the representative points (a and b). The local coordinates of each point are then individually lifted and combined with the associated features (c).}
  \label{fig:relative}
\end{figure}

Lines 4-6 in Algorithm~\ref{alg:xconv} are the core -transformation as described in Eq.~\ref{eq:with_X} in Section~\ref{sec:introduction}. Here, we explain the rationale behind lines 1-3 of Algorithm~\ref{alg:xconv} in detail. -Conv is designed to work on local point regions, and the output should not be dependent on the absolute position of  and its neighboring points, but on their relative positions. To that end, we position local coordinate systems at the representative points (line 1 of Algorithm~\ref{alg:xconv}, Figure~\ref{fig:relative}b). It is the local coordinates of neighboring points, together with their associated features, that define the output features. However, the local coordinates are of a different dimensionality and representation than the associated features. To address this issue, we first lift the coordinates into a higher dimensional and more abstract representation (line 2 of Algorithm~\ref{alg:xconv}), and then combine it with the associated features (line 3 of Algorithm~\ref{alg:xconv}) for further processing (Figure~\ref{fig:relative}c).

Lifting coordinates into features is done through a point-wise , as in PointNet-based methods. Differently, however,the lifted features are not processed by a symmetric function. Instead, along with the associated features, they are weighted and permuted by the -transformation that is jointly learned across all neighborhoods. The resulting  \textbf{is} dependent on the order of the points, and this \textbf{is} desired, as  is supposed to permute  according to the input points, and therefore has to be aware of the specific input order. For an input point cloud without any additional features, i.e.,  is empty, the first -Conv layer uses only .
PointCNN can thus handle point clouds with or without additional features in a robust uniform fashion.

For more details about the -Conv operator, including the actual definition of ,  and Conv, please refer to Supplementary Material Section~\ref{sec:xconv_details}.



\subsection{PointCNN Architectures}

From Figure~\ref{fig:hierarchical}, we can see that the Conv layers in grid-based CNNs and -Conv layers in PointCNN only differ in two aspects: the way the local regions are extracted ( patches vs.  neighboring points around representative points) and the way the information from local regions is learned (Conv vs. -Conv). Otherwise, the process of assembling a deep network with -Conv layers highly resembles that of grid-based CNNs.

\begin{figure}[h!]
  \begin{minipage}[c]{0.65\textwidth}
  \includegraphics[width=\textwidth]{figures/pointcnn}
  \end{minipage}\hfill
  \begin{minipage}[c]{0.33\textwidth}
	\caption{PointCNN architecture for classification (a and b) and segmentation (c), where  and  denote the output representative point number and feature dimensionality,  is the neighboring point number for each representative point, and  is the -Conv dilation rate.}
	\label{fig:pointcnn}
  \end{minipage}
\end{figure}

Figure~\ref{fig:pointcnn}a depicts a simple PointCNN with two -Conv layers that gradually transform the input points (with or without features) into fewer representation points, but each with richer features. After the second -Conv layer, there is only one representative point left, and it aggregates information from all the points from the previous layer. In PointCNN, we can roughly define the receptive field of each representative point as the ratio , where  is the neighboring point number, and  is the point number in the previous layer. With this definition, the final point ``sees'' all the points from the previous layer, thus has a receptive field of  --- it has a global view of the entire shape, and its features are informative for semantic understanding of the shape. We can add fully connected layers on top of the last -Conv layer output, followed by a loss, for training the network.

Note that the number of training samples for the top -Conv layers drops rapidly (Figure~\ref{fig:pointcnn}a), making it inefficient to train them thoroughly. To address this problem, we propose PointCNN with denser connections (Figure~\ref{fig:pointcnn}b), where more representative points are kept in the -Conv layers. However, we aim to maintain the depth of the network, while keeping the receptive field growth rate, such that the deeper representative points ``see'' increasingly larger portions of the entire shape. We achieve this goal by employing the dilated convolution idea from grid-based CNNs in PointCNN. Instead of always taking the  neighboring points as input, we uniformly sample  input points from   neighboring points, where  is the dilation rate. In this case, the receptive field increases from  to , without increasing actual neighboring point count or kernel size.

In the second -Conv layer of PointCNN in Figure~\ref{fig:pointcnn}b, dilation rate  is used, thus all the four remaining representative points ``see'' the entire shape, and all of them are suitable for making predictions. Note that, in this way, we can train the top -Conv layers more thoroughly, as much more connections are involved in the network, compared to PointCNN in Figure~\ref{fig:pointcnn}a. In test time, the output from the multiple representative points is averaged right before the  to stabilize the prediction. This design is similar to that of Network in Network~\cite{Lin_ICLR14}. The denser version of PointCNN (Figure~\ref{fig:pointcnn}b) is the one we used for classification tasks.

For segmentation tasks, high resolution point-wise output is required, and this can be realized by building PointCNN following Conv-DeConv~\cite{Noh_ICCV15} architecture, where the DeConv part is responsible for propagating global information into high resolution predictions (see Figure~\ref{fig:pointcnn}c). Note that both the ``Conv'' and ``DecConv'' in the PointCNN segmentation network are the same -Conv operator. The only differences between the ``Conv'' and ``DeConv'' layers is that the latter has more points but less feature channels in its output vs. its input, and its higher resolution points are forwarded from earlier ``Conv'' layers, following the design of U-Net~\cite{Ronneberger_MICCAI15}.

Dropout is applied before the last fully connected layer to reduce over-fitting. We also employed the ``subvolume supervision'' idea from~\cite{Qi_CVPR16}, to further address the over-fitting problem. In the last -Conv layers, the receptive field is set to be less than , such that only partial information is ``seen'' by the representative points. The network is pushed to learn harder from the partial information during training, and performs better at test time. In this case, the global coordinates of the representative points matter, thus they are lifted into feature space  with  (detailed in Supp. Material Section~\ref{sec:xconv_details}) and concatenated into -Conv for further processing by follow-up layers.

\paragraph{Data augmentation.} 
To train the parameters in -Conv, it is evidently not beneficial to keep using the same set of neighboring points, in the same order, for a specific representative point.
To improve generalization, we propose to randomly sample and shuffle the input points, such that both the neighboring point sets and order may differ from batch to batch. To train a model that takes  points as input,  points are used for training, where  denotes a Gaussian distribution. We found that this strategy is crucial for successful training of PointCNN. \section{Experiments}
\label{sec:experiments}

We conducted an extensive evaluation of PointCNN for shape classification on six datasets (ModelNet40~\cite{Wu_CVPR15}, ScanNet~\cite{dai2017scannet}, TU-Berlin~\cite{Eitz_SIGGRAPH12}, Quick Draw~\cite{ha2017neural}, MNIST, CIFAR10), and segmentation task on three datasets (ShapeNet Parts~\cite{Yi_SIGGRAPHAsia16}, S3DIS~\cite{armeni20163d}, and ScanNet~\cite{dai2017scannet}).
The details of the datasets and how we convert and feed data into PointCNN, are described in Supp. Material Section~\ref{sec:dataset_details}, and the PointCNN architectures for the tasks on these datasets can be found in Supp. Material Section~\ref{sec:model_zoo}.

\subsection{Classification and Segmentation Results}

\begin{table}
  \begin{minipage}[c]{0.62\textwidth}
  	\scalebox{0.6}{
		\begin{tabular}{ l | c | c | c | c | c | c }
			\cline{2-7}
			& \multicolumn{4}{c|}{ModelNet40} & \multicolumn{2}{|c}{\multirow{2}{*}{ScanNet}}  \\
            \cline{2-5}
            & \multicolumn{2}{c|}{Pre-aligned} & \multicolumn{2}{|c|}{Unaligned} & \multicolumn{2}{|c}{} \\
            \cline{2-7}
            & mA & OA & mA & OA & mA & OA \\
            \hline
            Flex-Convolution~\cite{Groh_arXiv18} & - & 90.2 & - & - & - & - \\
            KCNet~\cite{Shen_CVPR18} & - & 91 & - & - & - & - \\
            Kd-Net~\cite{Klokov_ICCV17} & 88.5 & 90.6 (91.8 w/ P32768) & - & - & - & - \\
            SO-Net~\cite{Li_CVPR18} & - & 90.7 (93.4 w/ PN5000) & - & - & - & - \\
            3DmFV-Net~\cite{BenShabat_arXiv18} & - & 91.4 (91.6 w/ P2048) & - & - & - & - \\
            PCNN~\cite{Atzmon_SIGGRAPH18} & - & 92.3 & - & - & - & - \\
            PointNet~\cite{Qi_CVPR17} & - & - & 86.2 & 89.2 & - & - \\
            PointNet++~\cite{Qi_NIPS17} & - & - & - & 90.7 (91.9 w/ PN5000) & - & 76.1 \\
            SpecGCN~\cite{Wang_arXiv18_mg} & - & - & - & 91.5 (92.1 w/ PN2048) & - & - \\
            SpiderCNN~\cite{Xu_arXiv18} & - & - & - & - (92.4 w/ PN1024) & - & - \\
            DGCNN~\cite{Wang_arXiv18_mit} & - & - & \textbf{90.2} & \textbf{92.2} & - & - \\
            \hline
            PointCNN & \textbf{88.8} & \textbf{92.5} & 88.1 & \textbf{92.2} & 55.7 & \textbf{79.7}\\
			\hline
		\end{tabular}
	}
  \end{minipage}\hfill
  \begin{minipage}[c]{0.31\textwidth}
	\caption{Comparisons of mean per-class accuracy (mA) and overall accuracy (OA) (\%) on ModelNet40~\cite{Wu_CVPR15} and ScanNet~\cite{dai2017scannet}. The reported performances are based on  input points, unless otherwise noted by P\# (\# input points) or PN\# (\# input points with normals).}
	\label{tab:classification}
  \end{minipage}
\end{table}

We summarize our 3D point cloud classification results on ModelNet40 and ScanNet in Table~\ref{tab:classification}, and compare to several neural network methods designed for point clouds. Note that a large portion of the 3D models from ModelNet40 are pre-aligned to the common up direction and horizontal facing direction. If a random horizontal rotation is not applied on either the training or testing sets, then the relatively consistent horizontal facing direction is leveraged, and the metrics based on this setting is not directly comparable to those with the random horizontal rotation. For this reason, we ran PointCNN and reported its performance in both settings. Note that PointCNN achieved top performance on both ModelNet40 and ScanNet.



\begin{wraptable}{R}{0.5\linewidth}
	\scalebox{0.78}{
		\begin{tabular}{  l | c | c | c | c  }
			 \cline{2-5}
			 & \multicolumn{2}{|c|}{ShapeNet Parts} & S3DIS & ScanNet  \\
             \cline{2-5}
             & pIoU & mpIoU & mIoU & OA  \\
			\hline
			SyncSpecCNN~\cite{Yi_CVPR17} & 84.74 & 82.0 & - & -  \\
			Pd-Network~\cite{Klokov_ICCV17} & 85.49 & 82.7 & - & -   \\
			SSCN~\cite{graham20173d} & 85.98 & 83.3 & - & -   \\
            SPLATNet~\cite{Su_CVPR18} & 85.4 & 83.7 & - & -   \\
            SpiderCNN~\cite{Xu_arXiv18} & 85.3 & 81.7 & - & -   \\
            SO-Net~\cite{Li_CVPR18} & 84.9 & 81.0 & - & -   \\
            PCNN~\cite{Atzmon_SIGGRAPH18} & 85.1 & 81.8 & - & -   \\
            KCNet~\cite{Shen_CVPR18} & 83.7 & 82.2 & - & -   \\
            SpecGCN~\cite{Wang_arXiv18_mg} & 85.4 & - & - & -  \\
            Kd-Net~\cite{Klokov_ICCV17} & 82.3 & 77.4 & - & - \\
            3DmFV-Net~\cite{BenShabat_arXiv18} & 84.3 & 81.0 & - & -   \\
            RSNet~\cite{Huang_CVPR18} & 84.9 & 81.4 & 56.47  & -  \\
            DGCNN~\cite{Wang_arXiv18_mit} & 85.1 & 82.3 & 56.1 & -  \\
            PointNet~\cite{Qi_CVPR17} &  83.7 & 80.4 & 47.6 & 73.9 \\
			PointNet++~\cite{Qi_NIPS17} & 85.1 & 81.9 & -  &  84.5  \\
            SGPN~\cite{Wang_CVPR18} & 85.8 & 82.8 & 50.37 & -   \\
			SPGraph~\cite{Landrieu_arXiv17} & - & - & 62.1 & - \\
            TCDP~\cite{Tatarchenko_CVPR18} & - & - & - & 80.9 \\
			\hline
			PointCNN & \textbf{86.14} & \textbf{84.6} & \textbf{65.39} & \textbf{85.1} \\
			\hline
		\end{tabular}
	}
   	\caption{Segmentation comparisons on ShapeNet Parts in part-averaged IoU (pIoU, \%) and mean per-class pIoU (mpIoU, \%),  S3DIS in mean per-class IoU (mIoU, \%)  and ScanNet in per voxel overall accuracy (OA, \%).}
	\label{tab:segmentation}
\end{wraptable}

We evaluate PointCNN on the segmentation of ShapeNet Parts, S3DIS, and ScanNet
datasets, and summarize the results in Table~\ref{tab:segmentation}. More detailed segmentation result comparisons can be found in Supplementary Material Section~\ref{sec:detailed_segmentation_results}. We note that PointCNN outperforms all the compared methods, including SSCN~\cite{graham20173d}, SPGraph~\cite{Landrieu_arXiv17} and SGPN~\cite{Wang_CVPR18}, which are specialized segmentation networks with state-of-the-art performance. Note that the part averaged IoU metric for ShapeNet Parts is the one used in~\cite{ShapeNet17}. Compared with mean IoU, the part averaged IoU puts more emphasis on the correct prediction of small parts.

Sketches are 1D curves in 2D space, thus can be more effectively represented with point clouds, rather than with 2D images. We evaluate PointCNN on TU-Berlin and Quick Draw sketches, and present results in Table~\ref{tab:sketches}, where we compare its performance with the competitive PointNet++, as well as image CNN based methods. PointCNN outperforms PointNet++ on both datasets, with a more prominent advantage on Quick Draw (25M data samples), which is significantly larger than TU-Berlin (0.02M data samples). On the TU-Berlin dataset, while the performance of PointCNN is slightly better than the generic image CNN AlexNet~\cite{krizhevsky2012imagenet}, there is still a gap with the specialized Sketch-a-Net~\cite{Yu_IJCV17}. It is interesting to study whether architectural elements from Sketch-a-Net can be adopted and integrated into PointCNN to improve its performance on the sketch datasets.

Since -Conv is a generalization of Conv, ideally, PointCNN should perform on par with CNNs, if the underlying data is the same, but only represented differently. To verify this, we evaluate PointCNN on the point cloud representation of MNIST and CIFAR10, and show results in Table~\ref{tab:mnist_cifar}. For MNIST data, PointCNN achieved comparable performance with other methods, indicating its effective learning of the digits' shape information. For CIFAR10 data, where there is mostly no ``shape'' information, PointCNN has to learn mostly from the spatially-local correlation in the RGB features, and it performed reasonably well on this task, though there is a large gap between PointCNN and the mainstream image CNNs. From this experiment, we can conclude that CNNs are still the better choice for general images.

\begin{table}[h!]
\begin{minipage}{.5\linewidth}
      \centering
      \scalebox{0.9}{
          \begin{tabular}{  l | c | c }
              \hline
              Method & TU-Berlin  & Quick Draw \\
              \hline
              Sketch-a-Net~\cite{Yu_IJCV17} & \textbf{77.95} & - \\ 
              AlexNet~\cite{krizhevsky2012imagenet} & 68.60 & - \\
              \hline
              PointNet++~\cite{Qi_NIPS17} & 66.53 &  51.58 \\
              PointCNN & 70.57 &  \textbf{59.13}  \\
              \hline
          \end{tabular}
      }
      \caption{Sketch classification results.}
      \label{tab:sketches}
\end{minipage}
\begin{minipage}{.5\linewidth}
      \centering
      \scalebox{0.9}{
          \begin{tabular}{  l | c | c }
              \hline
              Method & MNIST  &  CIFAR10  \\
              \hline
              LeNet~\cite{lecun1998gradient} & 99.20  & 84.07 \\ 
              Network in Network~\cite{Lin_ICLR14} & 99.53 &  \textbf{91.20}  \\
              \hline
              PointNet++~\cite{Qi_CVPR17} & 99.49 & 10.0\footnotemark \\
              PointCNN & \textbf{99.54}  & 80.22 \\
              \hline
          \end{tabular}
      }
      \caption{Image classification results.}
      \label{tab:mnist_cifar}
\end{minipage}
\end{table}


\footnotetext{PointNet++ performs no better than random choice on CIFAR10. We suspect the reason is that, in PointNet++, the RGB features become in-discriminative after being processed by the max-pooling. Together with the lack of ``shape'' information, PointNet++ fails completely on this task.}

\subsection{Ablation Experiments and Visualizations}

\begin{wraptable}{R}{0.5\linewidth}
	\centering
	\scalebox{0.72}{
		\begin{tabular}{ l | c | c | c | c }
			\hline
			 & PointCNN & w/o  & w/o -W & w/o -D \\
			\hline
			Core Layers & -Conv & Conv & Conv & Conv \\
			\# Parameter & 0.6M & 0.54M & 0.63M & 0.61M \\
			\hline
			Accuracy (\%) & \textbf{92.2} & 90.7  & 90.8 & 90.7  \\
			\hline
		\end{tabular}
	}
	\caption{Ablation tests on ModelNet40.}
	\label{tab:w_X_wo_X}
\end{wraptable}
\paragraph{Ablation test of the core -Conv operator.} To verify the effectiveness of the -transformation, we propose PointCNN without it as a baseline, where lines 4-6 of Algorithm~\ref{alg:xconv} are replaced by  Conv. Compared with PointCNN, the baseline has less trainable parameters, and is more ``shallow'' due to the removal of  in line 4 of Algorithm~\ref{alg:xconv}. For a fair comparison, we further propose PointCNN w/o -W/D, which is wider/deeper, and has approximately the same amount of parameters as PointCNN. The model depth of PointCNN w/o  (deeper) also compensates for the decrease in depth caused by the removal of  from PointCNN. The comparison results are summarized in Table~\ref{tab:w_X_wo_X}. Clearly, PointCNN outperforms the proposed variants by a significant margin, and the gap between PointCNN and PointCNN w/o  is not due to model parameter number, or model depth. With these comparisons, we conclude that -Conv is the key to the performance of PointCNN.



\paragraph{Visualization of -Conv features.} Each representative point, with its neighboring points in a particular order, has a corresponding  and  in , where . For the same representative point, if its neighboring points in different orders are fed into the network, we get a set of  and , and we denote them as  and . Similarly, we define the set of  in PointCNN w/o  as . Clearly,  can be quite scattering in the  space, since differences in input point order will result in a different . On the other hand, if the learned  can perfectly canonize ,  is supposed to stay at a canonical point in the space.

\begin{figure}[t!]
	\begin{center}
		\includegraphics[width=1.0\linewidth]{figures/tsne}
	\end{center}
	\caption{T-SNE visualization of features without (a/), before (b/) and after (c/) -transformation.}
	\label{fig:tsne}
\end{figure}

To verify this, we show T-SNE visualization of ,  and  of  randomly picked representative points from the ModelNet40 dataset in Figure~\ref{fig:tsne}, each with one color, and consistent in the sub-figures. Note that  is quite ``blended'', which indicates that the features from different representative points are not discriminative against each other (Figure~\ref{fig:tsne}a). While  is better than , it is still ``fuzzy'' (Figure~\ref{fig:tsne}b). In Figure~\ref{fig:tsne}c,  are ``concentrated'' by , and the features of each representative point become highly discriminative. To give an quantitative reference of the ``concentration'' effect, we firstly compute the feature centers of different representative points, then classify all the feature points to the representative points they belong to, based on nearest search to the centers. The classification accuracies are 76.83\%, 89.29\% and 94.72\% for ,  and , respectively. With the qualitative visualization and quantitative investigation, we conclude that though the ``concentration'' is far from reaching a point, the improvement is significant, and it explains the performance of PointCNN in feature learning.

\begin{table}[h!]
  \centering
  \scalebox{0.7}{
    \begin{tabular}{c | c | c | c | c | c | c | c | c}
      \hline
      \multicolumn{2}{c|}{Methods} & PointNet~\cite{Qi_CVPR17} & PointNet++~\cite{Qi_NIPS17}  & 3DmFV-Net~\cite{BenShabat_arXiv18} & DGCNN~\cite{Wang_arXiv18_mit} & SpecGCN~\cite{Wang_arXiv18_mg} & PCNN~\cite{Atzmon_SIGGRAPH18} & PointCNN \\
      \hline
      \multicolumn{2}{c|}{Parameters} & 3.48M & 1.48M & 45.77M & 1.84M & 2.05M & 8.2M & \textbf{0.6M} \\
      \hline
      \multirow{2}{*}{FLOPs} & Training & 43.82B & 67.94B  & 48.57B & 131.37B & 49.97B & \textbf{6.49B} & 93.03B \\
      & Inference & 14.70B & 26.94B & 16.89B & 44.27B  & 17.79B & \textbf{4.70B} & 25.30B \\
      \hline
      \multirow{2}{*}{Time} & Training & 0.068s & 0.091s & 0.101s & 0.171s & 14.640s & 0.476s &\textbf{0.031s} \\
      & Inference & 0.015s & 0.027s  & 0.039s & 0.064s & 11.254s & 0.226s & \textbf{0.012s} \\
      \hline
    \end{tabular}
  }
  \caption{Parameter number, FLOPs and running time comparisons.}
  \label{tab:statistics}
\end{table}

\paragraph{Optimizer, model size, memory usage and timing.} We implemented PointCNN in tensorflow~\cite{tensorflow}, and use ADAM optimizer~\cite{Kingma_ICLR14} with an initial learning rate  for the training of our models. As shown in Table \ref{tab:statistics}, we summarize our running statistics based with the model for classification with batch size 16, 1024 input points on nVidia Tesla P100 GPU, in comparison with several other methods. PointCNN achieves 0.031/0.012 second per batch for training/inference on this setting. In addition, the model for segmentation with  input points has M parameters runs on nVidia Tesla P100 with batch size  at 0.61/0.25 second per batch for training/inference. \section{Conclusion}
\label{sec:conclusion}

We proposed PointCNN, which is a generalization of CNN into leveraging spatially-local correlation from data represented in point cloud. The core of PointCNN is the -Conv operator that weights and permutes input points and features before they are processed by a typical convolution. While -Conv is empirically demonstrated to be effective in practice, a rigorous understanding of it, especially when being composited into a deep neural network, is still an open problem for future work. It is also interesting to study how to combine PointCNN and image CNNs to jointly process paired point clouds and images, probably at the early stages. We open source our code at \href{\githuburl}{\githuburl} to encourage further development. 

\subsubsection*{Acknowledgments}
Yangyan would like to thank Leonidas Guibas from Stanford University and Mike Haley from Autodesk Research for insightful discussions, and Noa Fish from Tel Aviv University and Thomas Schattschneider from Technical University of Hamburg for proof reading. The work is supported in part by National Key Research and Development Program of China grant No. 2017YFB1002603, the National Basic Research grant (973)  No. 2015CB352501, National Science Foundation of China General Program grant No. 61772317, and ``Qilu'' Young Talent Program of Shandong University.

\small
\begingroup
	\setlength{\bibsep}{1pt}
	\bibliographystyle{plain}
	\bibliography{PointCNN}
\endgroup

\clearpage
\begin{center}
\textbf{\large PointCNN Supplementary Material}
\end{center}
\setcounter{section}{0}
\setcounter{equation}{0}
\setcounter{figure}{0}
\setcounter{table}{0}
\setcounter{page}{1}
\makeatletter

\section{-Conv Details}
\label{sec:xconv_details}

We implement  in Line 2 of Algorithm~\ref{alg:xconv} with two fully connected (FC) layers, each followed by ELU~\cite{Clevert_ICLR16} activation function and batch normalization (BN)~\cite{Ioffe_ICML15}, i.e., . We set  to .

 in Line 4 of Algorithm~\ref{alg:xconv} can be implemented in a similar way: , where  denotes a vector in , and  denotes a -by- square matrix. However, this implementation results in  parameters. To reduce the parameter number and computation, as well as the overfitting risk due to a large number of parameters, we propose to replace  with a depthwise convolution , which applies  different filters to each of the  column of the input  matrix, yielding a  vector, where  parameters are involved. More specifically,  is implemented with , which results in  parameters.

Conv in Line 6 of Algorithm~\ref{alg:xconv}, if implemented with typical convolution, has  trainable parameters. We implemented it with separable convolution~\cite{chollet2016xception}, which has  trainable parameters, where  is the depth multiplier, and we use  in our implementation. Separable convolution reduces both parameter number and computation compared with that of a typical convolution.

 is used to harvest the global position information of the representative points in the last -Conv layer. It is implemented similar to , i.e., . We set  to . The  dimensional output of  is concatenated with the  dimensional output of the last -Conv layer for further processing.

In our implementation, a  nearest neighbor search is applied for extracting the  neighboring points. This assumes a more or less uniform distribution of input points. For point clouds with non-uniform distribution, a radius search can be applied first, and then  points can be randomly picked out of the radius search results.

In theory, the -transformation can be applied on either the features or the kernels. We opt to apply it on the features, in which way the follow up operation is a standard convolution operation that is highly optimized by popular deep learning frameworks.

\section{Dataset Details}
\label{sec:dataset_details}

We conducted extensive evaluation of PointCNN on datasets of various types and scales. Here we introduce the details of the datasets, as well as how we pre-process and feed them into PointCNN:
\begin{itemize}[leftmargin=*]
	\item Object datasets: ModelNet40~\cite{Wu_CVPR15} and ShapeNet Parts~\cite{Yi_SIGGRAPHAsia16}.
	\begin{itemize}
		\item ModelNet40 is composed of  3D mesh models from  categories, with a  training/testing split. Both the gravity and ``facing'' directions of the models are mostly aligned in the dataset. In the ``Pre-aligned'' setting, the models are used for training and testing, without random horizontal rotations. In which way, the relative consistent ``facing'' direction is leveraged by the network. In the ``Unaligned'' setting, random horizontal rotations are explicitly applied on either the training or the testing models, \textbf{not} as a data augmentation, but to ``forget'' the relative consistent ``facing'' directions thus better approximate the scenarios in real world applications, where the ``facing'' direction of the objects are often unknown. We use the point cloud conversion of ModelNet40 provided by~\cite{Qi_CVPR17} as our input, where  points are sampled from each mesh, and we further sample  points to train a model for testing with  points on the classification task.
		\item ShapeNet Parts contains  models (/ training/testing split) from  shape categories, each annotated with 2 to 6 parts and there are 50 different parts in total. Each point sampled from the models is associated with a part label. The task is to predict the part label for each point, thus a segmentation task, and can be treated as a dense point-wise classification problem. The category label for each model is given, and can be used for trimming irrelevant predictions, same as that in~\cite{graham20173d}.  points are sampled from each point cloud to train a model for testing with  input points on the segmentation task. Each testing point cloud is sampled multiple times to make sure all the points are evaluated at least  ( in our experiments) times at testing time.
	\end{itemize}

	\item Indoor scene datasets: S3DIS~\cite{armeni20163d} and ScanNet~\cite{dai2017scannet}. While ModelNet40 and ShapeNet models are mostly made by 3D modeling tools, S3DIS and ScanNet are from real scans of indoor environments.
	\begin{itemize}
		\item S3DIS contains 3D scans from Matterport scanners in  areas including  rooms. Each point with RGB features in the scan is annotated with one of the semantic labels from 13 categories. The task is segmentation. The data is firstly split by room, and then the rooms are sliced into m by m blocks, with m padding on each side. The points in the padding areas serve as context of the internal points, and themselves are not linked to loss in the training phase, nor used for prediction in the testing phase. Each block is moved to a local coordinate system defined by its center. Random horizontal rotations are applied on the sliced blocks for data augmentation. The rotated blocks are handled in the same way as the object point clouds in ShapeNet Parts.
		\item ScanNet contains  scanned and reconstructed indoor scenes, with  scenes for training/testing in semantic voxel labeling of  categories. We firstly prepare data in the same way as that of S3DIS to train a segmentation model, and the segmentation results on testing data are then converted into semantic voxel labeling, as that in~\cite{Qi_NIPS17},  for a fair comparison with previous methods. The  training/testing object instances from the  categories in ScanNet are also used for evaluating classification task. Note that ScanNet comes with RGB information for each point. However, they are not used in previous methods. To make fair comparisons, we do not use them either.
	\end{itemize}
	


	\item 2D sketch datasets: TU-Berlin~\cite{Eitz_SIGGRAPH12} and Quick Draw~\cite{ha2017neural}. Similar to surfaces in 3D space, line sketches in 2D are inherently of less dimension than the ambient space, and can be represented as point cloud, thus we consider 2D sketches good arena for evaluating neural networks that are designed to consume point cloud data. TU-Berlin has sketches from  categories, with  sketches from each category, where  are used for training and the rest  for testing. Quick Draw is the largest available sketch dataset, with sketches from  categories, each with  training/testing samples. We sample  points from the sketch stokes to train a model for testing with  points on sketch classification task.
	
	\item Image datasets: MNIST and CIFAR10. MNIST and CIFAR10 are widely used for sanity check of image CNNs. Since PointCNN is a generalization of CNNs, we would like to evaluate PointCNN on the point cloud representation of MNIST and CIFAR10. For MNIST, we randomly sample  \textbf{foreground} pixels and convert them into point cloud representation, with the gray-scale pixel value as the input feature. For CIFAR10, we randomly sampled  pixels out of the  pixels for converting into point cloud with RGB features. Note that there is ``shape'' information in the MNIST point cloud, sine the point cloud follow the digits' structure, but this is not the case for the CIFAR10 point cloud, where the points are mostly the same blob for all the data samples.
\end{itemize}

\section{PointCNN Model Zoo}
\label{sec:model_zoo}

\begin{figure*}[t!]
	\begin{center}
\includegraphics[width=1.0\linewidth]{figures/model_zoo}
	\end{center}
	\caption{PointCNN model zoo, where (a) is used for ModelNet40 (channel number in bold) and ScanNet classification, (b) is used for TU-Berlin sketch classification, (c) is used for Quick Draw sketch classification, (d) is used for ScanNet and S3DIS segmentation, and (e) is used for ShapeNet Parts segmentation.}
	\label{fig:model_zoo}
\end{figure*}

In Figure~\ref{fig:model_zoo}, we list the PointCNNs used for classification and segmentation tasks on multiple benchmark datasets. PointCNNs are easy to implement, setup, and tune. Larger  are used for layers with more abstract/semantic information, such as the top layers in classification networks, and middle layers in ``Conv-DeConv'' segmentation networks. To relax the memory demand, smaller s are used at layers with large number of representative points, such as bottom layers of classification networks, and top and bottom layers of segmentation networks. Deeper PointCNN with larger receptive field in the last -Conv layer are used for larger or harder datasets. The skip-links, together with the dilation parameter , make it easy to fuse information from different scales (receptive fields), as illustrated in (d) and (e), which is essential for segmentation tasks.

\section{Detailed Segmentation Results}
\label{sec:detailed_segmentation_results}

\begin{table}[t!]
	\centering
	\scalebox{0.54}{
		\begin{tabular}{  l | c | c | c | c | c | c | c | c | c | c | c | c | c | c | c | c | c | c  }
             \cline{1-19}
             Method & pIoU & mpIoU & air & bag & cap & car & chair & ear & guitar & knife & lamp & laptop & motor & mug & pistol & rocket & skate & table\\
             &  &  & plane &  &  &  &  & phone &  &  &  &  & bike &  &  &  & board & \\
			\hline
			SyncSpecCNN~\cite{Yi_CVPR17} & 84.74 & 82.0 & 81.55 & 81.74 & 81.94 & 75.16 & 90.24 & 74.88 & \textbf{92.97} & 86.1 & 84.65 & 95.61 & 66.66 & 92.73 & 81.61 & 60.61 & 82.86 & 82.13\\
			Pd-Network~\cite{Klokov_ICCV17} & 85.49 & 82.7 & 83.31	& 82.42 & 87.04	& 77.92	& 90.85	& 76.31 & 91.29	& 87.25	& 84.0 & 95.44 & 68.71 & 94.0 & 82.9 & 62.97 & 76.44 & 83.18 \\
			SSCN~\cite{graham20173d} & 85.98 & 83.3 & 84.09	& 82.99 & 83.97 & 80.82 & \textbf{91.41} & 78.16 & 91.6 & \textbf{89.1} & 85.04 & 95.78 & 73.71 & 95.23 & 84.02 & 58.53 & 76.02 & 82.65 \\
            SpiderCNN~\cite{Xu_arXiv18} & 85.3 & 81.7 & 83.5 & 81 & 87.2 & 77.5 & 90.7 & 76.8 & 91.1 & 87.3 & 83.3 & 95.8 & 70.2 & 93.5 & 82.7 & 59.7 & 75.8 & 82.8 \\
            SO-Net~\cite{Li_CVPR18} & 84.9 & 81.0 & 82.8 & 77.8 & \textbf{88.0} & 77.3 & 90.6 & 73.5 & 90.7 & 83.9 & 82.8 & 94.8 & 69.1 & 94.2 & 80.9 & 53.1 & 72.9 & 83.0 \\
            PCNN~\cite{Atzmon_SIGGRAPH18} & 85.1 & 81.8 & 82.4 & 80.1 & 85.5 & 79.5 & 90.8 & 73.2 & 91.3 & 86.0 & 85.0 & 95.7 & 73.2 & 94.8 & 83.3 & 51.0 & 75.0 & 81.8 \\
            KCNet~\cite{Shen_CVPR18} & 83.7 & 82.2 & 82.8 & 81.5 & 86.4 & 77.6 & 90.3 & 76.8 & 91.0 & 87.2 & 84.5 & 95.5 & 69.2 & 94.4 & 81.6 & 60.1 & 75.2 & 81.3 \\
            Kd-Net~\cite{Klokov_ICCV17} & 82.3 & 77.4 & 80.1 & 74.6 & 74.3 & 70.3 & 88.6 & 73.5 & 90.2 & 87.2 & 81.0 & 94.9 & 57.4 & 86.7 & 78.1 & 51.8 & 69.9 & 80.3 \\
            3DmFV-Net~\cite{BenShabat_arXiv18} & 84.3 & 81.0 & 82.0 & 84.3 & 86.0 & 76.9 & 89.9 & 73.9 & 90.8 & 85.7 & 82.6 & 95.2 & 66.0 & 94.0 & 82.6 & 51.5 & 73.5 & 81.8 \\
            RSNet~\cite{Huang_CVPR18} & 84.9 & 81.4 & 82.7 & 86.4 & 84.1 & 78.2 & 90.4 & 69.3 & 91.4 & 87.0 & 83.5 & 95.4 & 66.0 & 92.6 & 81.8 & 56.1 & 75.8 & 82.2 \\
            DGCNN~\cite{Wang_arXiv18_mit} & 85.1 & 82.3 & \textbf{84.2} & 83.7 & 84.4 & 77.1 & 90.9 & 78.5 & 91.5 & 87.3 & 82.9 & 96.0 & 67.0 & 93.3 & 82.6 & 59.7 & 75.5 & 82.0 \\
            PointNet~\cite{Qi_CVPR17} &  83.7 & 80.4 & 83.4 & 78.7 & 82.5 & 74.9 & 89.6 & 73.0 & 91.5 & 85.9 & 80.8 & 95.3 & 65.2 & 93.0 & 81.2 & 57.9 & 72.8 & 80.6 \\
			PointNet++~\cite{Qi_NIPS17} & 85.1 & 81.9 & 82.4 & 79.0 & 87.7 & 77.3 & 90.8 & 71.8 & 91.0 & 85.9 & 83.7 & 95.3 & 71.6 & 94.1 & 81.3 & 58.7 & 76.4 & 82.6 \\
            SGPN~\cite{Wang_CVPR18} & 85.8 & 82.8 & 80.4 & 78.6 & 78.8 & 71.5 & 88.6 & 78 & 90.9 & 83 & 78.8 & 95.8 & \textbf{77.8} & 93.8 & \textbf{87.4} & 60.1 & \textbf{92.3} & \textbf{89.4} \\
			\hline
			PointCNN & \textbf{86.14} & \textbf{84.6} & 84.11 & \textbf{86.47} & 86.04 & \textbf{80.83} & 90.62 & \textbf{79.70} & 92.32 & 88.44 & \textbf{85.31} & \textbf{96.11} & 77.20 & \textbf{95.28} & 84.21 & \textbf{64.23} & 80.00 & 82.99\\
			\hline
		\end{tabular}
	}
	\caption{Segmentation result comparisons on ShapeNet Parts~\cite{Yi_SIGGRAPHAsia16} in part-averaged IoU (pIoU, \%) , mean per-class pIoU (mpIoU, \%) and per-class pIoU (\%).}
	\label{tab:shapenet_segmentation_details}
\end{table}

We show detailed segmentation result comparisons on ShapeNet Parts in Table~\ref{tab:shapenet_segmentation_details}, we can see our approach achieves the best overall performance and are best on 7 of the 16 categories.

\begin{table}[t!]
	\centering
	\scalebox{0.6}{
        \begin{tabular}{  l | c | c | c | c | c | c | c | c | c | c | c | c | c | c | c | c }
             \cline{1-17}
             Method & OA & mAcc & mIoU & ceiling & floor & wall & beam & column & window & door & table & chair & sofa & bookcase & board & clutter \\
			\hline
            PointNet~\cite{Qi_CVPR17} & 78.5 & 66.2 & 47.6 & 88.0 & 88.7 & 69.3 & 42.4 & 23.1 & 47.5 & 51.6 & 54.1 & 42.0 & 9.6 & 38.2 & 29.4 & 35.2 \\
            SPGraph~\cite{Landrieu_arXiv17} & 85.5 & 73.0 & 62.1 & 89.9 & 95.1 & 76.4 & 62.8 & 47.1 & 55.3 & \textbf{68.4} & \textbf{73.5} & \textbf{69.2} & \textbf{63.2} & 45.9 & 8.7 & 52.9 \\
            RSNet~\cite{Huang_CVPR18} & - & 66.45 & 56.47 & 92.48 & 92.83 & \textbf{78.56} & 32.75 & 34.37 & 51.62 & 68.11 & 60.13 & 59.72 & 50.22 & 16.42 & 44.85 & 52.03 \\
			\hline
			PointCNN & \textbf{88.14} & \textbf{75.61} & \textbf{65.39} & \textbf{94.78} & \textbf{97.3} & 75.82 & \textbf{63.25} & \textbf{51.71} & \textbf{58.38} & 57.18 & 71.63 & 69.12 & 39.08 & \textbf{61.15} & \textbf{52.19} & \textbf{58.59} \\
			\hline
		\end{tabular}
	}
	\caption{Segmentation result comparisons on the S3DIS~\cite{armeni20163d} dataset in overall accuracy (OA, \%), micro-averaged accuracy (mAcc, \%), micro-averaged IoU (mIoU, \%) and per-class IoU (\%).}
	\label{tab:s3dis_segmentation_details}
\end{table}


\begin{table}[t!]
	\centering
	\scalebox{0.6}{
		\begin{tabular}{  l | c | c | c | c | c | c | c | c | c | c | c | c | c | c | c | c  }
             \cline{1-17}
             Method & OA & mAcc & mIoU & ceiling & floor & wall & beam & column & window & door & table & chair & sofa & bookcase & board & clutter \\
			\hline
            PointNet~\cite{Qi_CVPR17} &  - & 48.98 & 41.09 & 88.80 & 97.33 & 69.80 & 0.05 & 3.92 & 46.26 & 10.76 & 58.93 & 52.61 & 5.85 & 40.28 & 26.38 & 33.22 \\
            SPGraph~\cite{Landrieu_arXiv17} &  \textbf{86.38} & 66.50 & 58.04 & 89.35 & 96.87 & 78.12 & 0.00 & \textbf{42.81} & 48.93 & 61.58 & \textbf{84.66} & 75.41 & \textbf{69.84} & 52.60 & 2.10 & 52.22 \\
            SegCloud~\cite{Tchapmi_3DV17} &  - & 57.35 & 48.92 & 90.06 & 96.05 & 69.86 & 0.00 & 18.37 & 38.35 & 23.12 & 70.40 & 75.89 & 40.88 & 58.42 & 12.96 & 41.60 \\
            PCCN~\cite{Wang_CVPR18_Deep} &  - & \textbf{67.01} & \textbf{58.27} & 92.26 & 96.20 & 75.89 & \textbf{0.27} & 5.98 & \textbf{69.49} & \textbf{63.45} & 66.87 & 65.63 & 47.28 & \textbf{68.91} & 59.10 & 46.22 \\
			\hline
			PointCNN & 85.91 & 63.86 & 57.26 & \textbf{92.31} & \textbf{98.24} & \textbf{79.41} & 0.00 & 17.60 & 22.77 & 62.09 & 74.39 & \textbf{80.59} & 31.67 & 66.67 & \textbf{62.05} & \textbf{56.74} \\
			\hline
		\end{tabular}
        }
        \caption{Segmentation result comparisons on the S3DIS~\cite{armeni20163d} Area 5 in overall accuracy (OA, \%), micro-averaged accuracy (mAcc, \%), micro-averaged IoU (mIoU, \%) and per-class IoU (\%).}
	\label{tab:s3dis_segmentation_details_a5}
\end{table}

We show detailed segmentation result comparisons on S3DIS in Table~\ref{tab:s3dis_segmentation_details}, we can see our approach achieves the best overall performance and are best on 6 of the 13 categories. The detailed segmentation result comparisons on S3DIS Area 5 are summarized in Table~\ref{tab:s3dis_segmentation_details_a5}, as some of the literatures only report the performance on this area. 
\end{document}
