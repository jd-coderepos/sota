\documentclass{article} \usepackage{iclr2021_conference,times}
\iclrfinalcopy


\usepackage{amsmath,amsfonts,bm}

\newcommand{\figleft}{{\em (Left)}}
\newcommand{\figcenter}{{\em (Center)}}
\newcommand{\figright}{{\em (Right)}}
\newcommand{\figtop}{{\em (Top)}}
\newcommand{\figbottom}{{\em (Bottom)}}
\newcommand{\captiona}{{\em (a)}}
\newcommand{\captionb}{{\em (b)}}
\newcommand{\captionc}{{\em (c)}}
\newcommand{\captiond}{{\em (d)}}

\newcommand{\newterm}[1]{{\bf #1}}


\def\figref#1{figure~\ref{#1}}
\def\Figref#1{Figure~\ref{#1}}
\def\twofigref#1#2{figures \ref{#1} and \ref{#2}}
\def\quadfigref#1#2#3#4{figures \ref{#1}, \ref{#2}, \ref{#3} and \ref{#4}}
\def\secref#1{section~\ref{#1}}
\def\Secref#1{Section~\ref{#1}}
\def\twosecrefs#1#2{sections \ref{#1} and \ref{#2}}
\def\secrefs#1#2#3{sections \ref{#1}, \ref{#2} and \ref{#3}}
\def\eqref#1{equation~\ref{#1}}
\def\Eqref#1{Equation~\ref{#1}}
\def\plaineqref#1{\ref{#1}}
\def\chapref#1{chapter~\ref{#1}}
\def\Chapref#1{Chapter~\ref{#1}}
\def\rangechapref#1#2{chapters\ref{#1}--\ref{#2}}
\def\algref#1{algorithm~\ref{#1}}
\def\Algref#1{Algorithm~\ref{#1}}
\def\twoalgref#1#2{algorithms \ref{#1} and \ref{#2}}
\def\Twoalgref#1#2{Algorithms \ref{#1} and \ref{#2}}
\def\partref#1{part~\ref{#1}}
\def\Partref#1{Part~\ref{#1}}
\def\twopartref#1#2{parts \ref{#1} and \ref{#2}}

\def\ceil#1{\lceil #1 \rceil}
\def\floor#1{\lfloor #1 \rfloor}
\def\1{\bm{1}}
\newcommand{\train}{\mathcal{D}}
\newcommand{\valid}{\mathcal{D_{\mathrm{valid}}}}
\newcommand{\test}{\mathcal{D_{\mathrm{test}}}}

\def\eps{{\epsilon}}


\def\reta{{\textnormal{}}}
\def\ra{{\textnormal{a}}}
\def\rb{{\textnormal{b}}}
\def\rc{{\textnormal{c}}}
\def\rd{{\textnormal{d}}}
\def\re{{\textnormal{e}}}
\def\rf{{\textnormal{f}}}
\def\rg{{\textnormal{g}}}
\def\rh{{\textnormal{h}}}
\def\ri{{\textnormal{i}}}
\def\rj{{\textnormal{j}}}
\def\rk{{\textnormal{k}}}
\def\rl{{\textnormal{l}}}
\def\rn{{\textnormal{n}}}
\def\ro{{\textnormal{o}}}
\def\rp{{\textnormal{p}}}
\def\rq{{\textnormal{q}}}
\def\rr{{\textnormal{r}}}
\def\rs{{\textnormal{s}}}
\def\rt{{\textnormal{t}}}
\def\ru{{\textnormal{u}}}
\def\rv{{\textnormal{v}}}
\def\rw{{\textnormal{w}}}
\def\rx{{\textnormal{x}}}
\def\ry{{\textnormal{y}}}
\def\rz{{\textnormal{z}}}

\def\rvepsilon{{\mathbf{\epsilon}}}
\def\rvtheta{{\mathbf{\theta}}}
\def\rva{{\mathbf{a}}}
\def\rvb{{\mathbf{b}}}
\def\rvc{{\mathbf{c}}}
\def\rvd{{\mathbf{d}}}
\def\rve{{\mathbf{e}}}
\def\rvf{{\mathbf{f}}}
\def\rvg{{\mathbf{g}}}
\def\rvh{{\mathbf{h}}}
\def\rvu{{\mathbf{i}}}
\def\rvj{{\mathbf{j}}}
\def\rvk{{\mathbf{k}}}
\def\rvl{{\mathbf{l}}}
\def\rvm{{\mathbf{m}}}
\def\rvn{{\mathbf{n}}}
\def\rvo{{\mathbf{o}}}
\def\rvp{{\mathbf{p}}}
\def\rvq{{\mathbf{q}}}
\def\rvr{{\mathbf{r}}}
\def\rvs{{\mathbf{s}}}
\def\rvt{{\mathbf{t}}}
\def\rvu{{\mathbf{u}}}
\def\rvv{{\mathbf{v}}}
\def\rvw{{\mathbf{w}}}
\def\rvx{{\mathbf{x}}}
\def\rvy{{\mathbf{y}}}
\def\rvz{{\mathbf{z}}}

\def\erva{{\textnormal{a}}}
\def\ervb{{\textnormal{b}}}
\def\ervc{{\textnormal{c}}}
\def\ervd{{\textnormal{d}}}
\def\erve{{\textnormal{e}}}
\def\ervf{{\textnormal{f}}}
\def\ervg{{\textnormal{g}}}
\def\ervh{{\textnormal{h}}}
\def\ervi{{\textnormal{i}}}
\def\ervj{{\textnormal{j}}}
\def\ervk{{\textnormal{k}}}
\def\ervl{{\textnormal{l}}}
\def\ervm{{\textnormal{m}}}
\def\ervn{{\textnormal{n}}}
\def\ervo{{\textnormal{o}}}
\def\ervp{{\textnormal{p}}}
\def\ervq{{\textnormal{q}}}
\def\ervr{{\textnormal{r}}}
\def\ervs{{\textnormal{s}}}
\def\ervt{{\textnormal{t}}}
\def\ervu{{\textnormal{u}}}
\def\ervv{{\textnormal{v}}}
\def\ervw{{\textnormal{w}}}
\def\ervx{{\textnormal{x}}}
\def\ervy{{\textnormal{y}}}
\def\ervz{{\textnormal{z}}}

\def\rmA{{\mathbf{A}}}
\def\rmB{{\mathbf{B}}}
\def\rmC{{\mathbf{C}}}
\def\rmD{{\mathbf{D}}}
\def\rmE{{\mathbf{E}}}
\def\rmF{{\mathbf{F}}}
\def\rmG{{\mathbf{G}}}
\def\rmH{{\mathbf{H}}}
\def\rmI{{\mathbf{I}}}
\def\rmJ{{\mathbf{J}}}
\def\rmK{{\mathbf{K}}}
\def\rmL{{\mathbf{L}}}
\def\rmM{{\mathbf{M}}}
\def\rmN{{\mathbf{N}}}
\def\rmO{{\mathbf{O}}}
\def\rmP{{\mathbf{P}}}
\def\rmQ{{\mathbf{Q}}}
\def\rmR{{\mathbf{R}}}
\def\rmS{{\mathbf{S}}}
\def\rmT{{\mathbf{T}}}
\def\rmU{{\mathbf{U}}}
\def\rmV{{\mathbf{V}}}
\def\rmW{{\mathbf{W}}}
\def\rmX{{\mathbf{X}}}
\def\rmY{{\mathbf{Y}}}
\def\rmZ{{\mathbf{Z}}}

\def\ermA{{\textnormal{A}}}
\def\ermB{{\textnormal{B}}}
\def\ermC{{\textnormal{C}}}
\def\ermD{{\textnormal{D}}}
\def\ermE{{\textnormal{E}}}
\def\ermF{{\textnormal{F}}}
\def\ermG{{\textnormal{G}}}
\def\ermH{{\textnormal{H}}}
\def\ermI{{\textnormal{I}}}
\def\ermJ{{\textnormal{J}}}
\def\ermK{{\textnormal{K}}}
\def\ermL{{\textnormal{L}}}
\def\ermM{{\textnormal{M}}}
\def\ermN{{\textnormal{N}}}
\def\ermO{{\textnormal{O}}}
\def\ermP{{\textnormal{P}}}
\def\ermQ{{\textnormal{Q}}}
\def\ermR{{\textnormal{R}}}
\def\ermS{{\textnormal{S}}}
\def\ermT{{\textnormal{T}}}
\def\ermU{{\textnormal{U}}}
\def\ermV{{\textnormal{V}}}
\def\ermW{{\textnormal{W}}}
\def\ermX{{\textnormal{X}}}
\def\ermY{{\textnormal{Y}}}
\def\ermZ{{\textnormal{Z}}}

\def\vzero{{\bm{0}}}
\def\vone{{\bm{1}}}
\def\vmu{{\bm{\mu}}}
\def\vtheta{{\bm{\theta}}}
\def\va{{\bm{a}}}
\def\vb{{\bm{b}}}
\def\vc{{\bm{c}}}
\def\vd{{\bm{d}}}
\def\ve{{\bm{e}}}
\def\vf{{\bm{f}}}
\def\vg{{\bm{g}}}
\def\vh{{\bm{h}}}
\def\vi{{\bm{i}}}
\def\vj{{\bm{j}}}
\def\vk{{\bm{k}}}
\def\vl{{\bm{l}}}
\def\vm{{\bm{m}}}
\def\vn{{\bm{n}}}
\def\vo{{\bm{o}}}
\def\vp{{\bm{p}}}
\def\vq{{\bm{q}}}
\def\vr{{\bm{r}}}
\def\vs{{\bm{s}}}
\def\vt{{\bm{t}}}
\def\vu{{\bm{u}}}
\def\vv{{\bm{v}}}
\def\vw{{\bm{w}}}
\def\vx{{\bm{x}}}
\def\vy{{\bm{y}}}
\def\vz{{\bm{z}}}

\def\evalpha{{\alpha}}
\def\evbeta{{\beta}}
\def\evepsilon{{\epsilon}}
\def\evlambda{{\lambda}}
\def\evomega{{\omega}}
\def\evmu{{\mu}}
\def\evpsi{{\psi}}
\def\evsigma{{\sigma}}
\def\evtheta{{\theta}}
\def\eva{{a}}
\def\evb{{b}}
\def\evc{{c}}
\def\evd{{d}}
\def\eve{{e}}
\def\evf{{f}}
\def\evg{{g}}
\def\evh{{h}}
\def\evi{{i}}
\def\evj{{j}}
\def\evk{{k}}
\def\evl{{l}}
\def\evm{{m}}
\def\evn{{n}}
\def\evo{{o}}
\def\evp{{p}}
\def\evq{{q}}
\def\evr{{r}}
\def\evs{{s}}
\def\evt{{t}}
\def\evu{{u}}
\def\evv{{v}}
\def\evw{{w}}
\def\evx{{x}}
\def\evy{{y}}
\def\evz{{z}}

\def\mA{{\bm{A}}}
\def\mB{{\bm{B}}}
\def\mC{{\bm{C}}}
\def\mD{{\bm{D}}}
\def\mE{{\bm{E}}}
\def\mF{{\bm{F}}}
\def\mG{{\bm{G}}}
\def\mH{{\bm{H}}}
\def\mI{{\bm{I}}}
\def\mJ{{\bm{J}}}
\def\mK{{\bm{K}}}
\def\mL{{\bm{L}}}
\def\mM{{\bm{M}}}
\def\mN{{\bm{N}}}
\def\mO{{\bm{O}}}
\def\mP{{\bm{P}}}
\def\mQ{{\bm{Q}}}
\def\mR{{\bm{R}}}
\def\mS{{\bm{S}}}
\def\mT{{\bm{T}}}
\def\mU{{\bm{U}}}
\def\mV{{\bm{V}}}
\def\mW{{\bm{W}}}
\def\mX{{\bm{X}}}
\def\mY{{\bm{Y}}}
\def\mZ{{\bm{Z}}}
\def\mBeta{{\bm{\beta}}}
\def\mPhi{{\bm{\Phi}}}
\def\mLambda{{\bm{\Lambda}}}
\def\mSigma{{\bm{\Sigma}}}

\DeclareMathAlphabet{\mathsfit}{\encodingdefault}{\sfdefault}{m}{sl}
\SetMathAlphabet{\mathsfit}{bold}{\encodingdefault}{\sfdefault}{bx}{n}
\newcommand{\tens}[1]{\bm{\mathsfit{#1}}}
\def\tA{{\tens{A}}}
\def\tB{{\tens{B}}}
\def\tC{{\tens{C}}}
\def\tD{{\tens{D}}}
\def\tE{{\tens{E}}}
\def\tF{{\tens{F}}}
\def\tG{{\tens{G}}}
\def\tH{{\tens{H}}}
\def\tI{{\tens{I}}}
\def\tJ{{\tens{J}}}
\def\tK{{\tens{K}}}
\def\tL{{\tens{L}}}
\def\tM{{\tens{M}}}
\def\tN{{\tens{N}}}
\def\tO{{\tens{O}}}
\def\tP{{\tens{P}}}
\def\tQ{{\tens{Q}}}
\def\tR{{\tens{R}}}
\def\tS{{\tens{S}}}
\def\tT{{\tens{T}}}
\def\tU{{\tens{U}}}
\def\tV{{\tens{V}}}
\def\tW{{\tens{W}}}
\def\tX{{\tens{X}}}
\def\tY{{\tens{Y}}}
\def\tZ{{\tens{Z}}}


\def\gA{{\mathcal{A}}}
\def\gB{{\mathcal{B}}}
\def\gC{{\mathcal{C}}}
\def\gD{{\mathcal{D}}}
\def\gE{{\mathcal{E}}}
\def\gF{{\mathcal{F}}}
\def\gG{{\mathcal{G}}}
\def\gH{{\mathcal{H}}}
\def\gI{{\mathcal{I}}}
\def\gJ{{\mathcal{J}}}
\def\gK{{\mathcal{K}}}
\def\gL{{\mathcal{L}}}
\def\gM{{\mathcal{M}}}
\def\gN{{\mathcal{N}}}
\def\gO{{\mathcal{O}}}
\def\gP{{\mathcal{P}}}
\def\gQ{{\mathcal{Q}}}
\def\gR{{\mathcal{R}}}
\def\gS{{\mathcal{S}}}
\def\gT{{\mathcal{T}}}
\def\gU{{\mathcal{U}}}
\def\gV{{\mathcal{V}}}
\def\gW{{\mathcal{W}}}
\def\gX{{\mathcal{X}}}
\def\gY{{\mathcal{Y}}}
\def\gZ{{\mathcal{Z}}}

\def\sA{{\mathbb{A}}}
\def\sB{{\mathbb{B}}}
\def\sC{{\mathbb{C}}}
\def\sD{{\mathbb{D}}}
\def\sF{{\mathbb{F}}}
\def\sG{{\mathbb{G}}}
\def\sH{{\mathbb{H}}}
\def\sI{{\mathbb{I}}}
\def\sJ{{\mathbb{J}}}
\def\sK{{\mathbb{K}}}
\def\sL{{\mathbb{L}}}
\def\sM{{\mathbb{M}}}
\def\sN{{\mathbb{N}}}
\def\sO{{\mathbb{O}}}
\def\sP{{\mathbb{P}}}
\def\sQ{{\mathbb{Q}}}
\def\sR{{\mathbb{R}}}
\def\sS{{\mathbb{S}}}
\def\sT{{\mathbb{T}}}
\def\sU{{\mathbb{U}}}
\def\sV{{\mathbb{V}}}
\def\sW{{\mathbb{W}}}
\def\sX{{\mathbb{X}}}
\def\sY{{\mathbb{Y}}}
\def\sZ{{\mathbb{Z}}}

\def\emLambda{{\Lambda}}
\def\emA{{A}}
\def\emB{{B}}
\def\emC{{C}}
\def\emD{{D}}
\def\emE{{E}}
\def\emF{{F}}
\def\emG{{G}}
\def\emH{{H}}
\def\emI{{I}}
\def\emJ{{J}}
\def\emK{{K}}
\def\emL{{L}}
\def\emM{{M}}
\def\emN{{N}}
\def\emO{{O}}
\def\emP{{P}}
\def\emQ{{Q}}
\def\emR{{R}}
\def\emS{{S}}
\def\emT{{T}}
\def\emU{{U}}
\def\emV{{V}}
\def\emW{{W}}
\def\emX{{X}}
\def\emY{{Y}}
\def\emZ{{Z}}
\def\emSigma{{\Sigma}}

\newcommand{\etens}[1]{\mathsfit{#1}}
\def\etLambda{{\etens{\Lambda}}}
\def\etA{{\etens{A}}}
\def\etB{{\etens{B}}}
\def\etC{{\etens{C}}}
\def\etD{{\etens{D}}}
\def\etE{{\etens{E}}}
\def\etF{{\etens{F}}}
\def\etG{{\etens{G}}}
\def\etH{{\etens{H}}}
\def\etI{{\etens{I}}}
\def\etJ{{\etens{J}}}
\def\etK{{\etens{K}}}
\def\etL{{\etens{L}}}
\def\etM{{\etens{M}}}
\def\etN{{\etens{N}}}
\def\etO{{\etens{O}}}
\def\etP{{\etens{P}}}
\def\etQ{{\etens{Q}}}
\def\etR{{\etens{R}}}
\def\etS{{\etens{S}}}
\def\etT{{\etens{T}}}
\def\etU{{\etens{U}}}
\def\etV{{\etens{V}}}
\def\etW{{\etens{W}}}
\def\etX{{\etens{X}}}
\def\etY{{\etens{Y}}}
\def\etZ{{\etens{Z}}}

\newcommand{\pdata}{p_{\rm{data}}}
\newcommand{\ptrain}{\hat{p}_{\rm{data}}}
\newcommand{\Ptrain}{\hat{P}_{\rm{data}}}
\newcommand{\pmodel}{p_{\rm{model}}}
\newcommand{\Pmodel}{P_{\rm{model}}}
\newcommand{\ptildemodel}{\tilde{p}_{\rm{model}}}
\newcommand{\pencode}{p_{\rm{encoder}}}
\newcommand{\pdecode}{p_{\rm{decoder}}}
\newcommand{\precons}{p_{\rm{reconstruct}}}

\newcommand{\laplace}{\mathrm{Laplace}} 

\newcommand{\E}{\mathbb{E}}
\newcommand{\Ls}{\mathcal{L}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\emp}{\tilde{p}}
\newcommand{\lr}{\alpha}
\newcommand{\reg}{\lambda}
\newcommand{\rect}{\mathrm{rectifier}}
\newcommand{\softmax}{\mathrm{softmax}}
\newcommand{\sigmoid}{\sigma}
\newcommand{\softplus}{\zeta}
\newcommand{\KL}{D_{\mathrm{KL}}}
\newcommand{\Var}{\mathrm{Var}}
\newcommand{\standarderror}{\mathrm{SE}}
\newcommand{\Cov}{\mathrm{Cov}}
\newcommand{\normlzero}{L^0}
\newcommand{\normlone}{L^1}
\newcommand{\normltwo}{L^2}
\newcommand{\normlp}{L^p}
\newcommand{\normmax}{L^\infty}

\newcommand{\parents}{Pa} 

\DeclareMathOperator*{\argmax}{arg\,max}
\DeclareMathOperator*{\argmin}{arg\,min}

\DeclareMathOperator{\sign}{sign}
\DeclareMathOperator{\Tr}{Tr}
\let\ab\allowbreak
 
\usepackage[hyphens]{url}
\usepackage{hyperref}
\usepackage[hyphenbreaks]{breakurl}
\usepackage{multirow}
\usepackage{natbib}
\usepackage{amssymb}
\usepackage{makecell}
\usepackage{array}
 \usepackage{graphicx}
\usepackage{subcaption}
\usepackage[flushleft]{threeparttable}
\usepackage{stackrel}
\usepackage{appendix}
\usepackage{hyperref}
\title{Masked Label Prediction: Unified Message Passing Model for Semi-Supervised Classification}



\author{Yunsheng Shi, Zhengjie Huang, Wenjin Wang, Hui Zhong, Shikun Feng, Yu Sun \\
Baidu Inc., China \\
{\tt \{shiyunsheng01,huangzhengjie,wangwenjin02,zhonghui03\}@baidu.com} \\
{\tt \{fengshikun01,sunyu02\}@baidu.com} \\}




\newcommand{\fix}{\marginpar{FIX}}
\newcommand{\new}{\marginpar{NEW}}

\begin{document}


\maketitle

\begin{abstract}
Graph neural network (GNN) and label propagation algorithm (LPA) are both message passing algorithms, which have achieved superior performance in semi-supervised classification. GNN performs \emph{feature propagation} by a neural network to make predictions, while LPA uses \emph{label propagation} across graph adjacency matrix to get results. However, there is still no good way to combine these two kinds of algorithms. In this paper, we proposed a new {\bf Uni}fied {\bf M}essage {\bf P}assaging Model (UniMP) that can incorporate \emph{feature propagation} and \emph{label propagation} with a shared message passing network, providing a better performance in semi-supervised classification. First, we adopt a Graph Transformer jointly label embedding to propagate both the feature and label information. Second, to train UniMP without overfitting in self-loop label information, we propose a masked label prediction strategy, in which some percentage of training labels are simply masked at random, and then predicted. UniMP conceptually unifies feature propagation and label propagation and be empirically powerful. It obtains new state-of-the-art semi-supervised classification results in Open Graph Benchmark (OGB). Our implementation is available online \url{https://github.com/PaddlePaddle/PGL/tree/main/ogb_examples/nodeproppred/unimp}.
\end{abstract}



\section{Introduction}
There are various scenarios in the world, e.g., recommending related news and products, discovering new drugs, or predicting social relations, 
which can be described as graph structures. Many methods have been proposed to optimize these graph-based problems and achieved significant success in many related domains such as predicting the properties of nodes \citep{yang2016revisiting, kipf2016semi}, links \citep{grover2016node2vec, battaglia2018relational}, and graphs \citep{duvenaud2015convolutional, niepert2016learning, bojchevski2018netgan}.

In the task of semi-supervised node classification, we are required to learn with labeled examples and then make predictions for those unlabeled ones. To better classify the nodes' labels in the graph, based on the Laplacian smoothing assumption~\citep{li2018deeper, xu2018representation}, the message passing models were proposed to aggregate the information from its connected neighbors in the graph, acquiring
enough facts to produce a more robust prediction for unlabeled nodes. Generally, there are two kinds of practical methods to implement message passing model, the Graph Neural Networks (GNNs)~\citep{kipf2016semi, hamilton2017inductive, xu2018representation, liao2019lanczosnet, xu2018powerful, qu2019gmnn} and the Label Propagation Algorithms (LPAs)~\citep{zhu2005semi, zhu2003semi, zhang2007hyperparameter, wang2007label, karasuyama2013manifold, gong2016label, liu2019learning}. GNNs combine graph structures by propagating and aggregating nodes features through several neural layers, which get predictions from \emph{feature propagation}. While LPAs make predictions for unlabeled instances by \emph{label propagation} iteratively.


Since GNN and LPA are based on the same assumption, making semi-supervised classifications by information propagation, there is an intuition that incorporating them together for boosting performance. Some superior studies have proposed their graph models based on it. For example, APPNP \citep{klicpera2019predict} and TPN \citep{liu2019learning} integrate GNN and LPA by concatenating them together, and GCN-LPA \citep{wang2019unifying} uses LPA to regularize their GCN model. However, as shown in Tabel \ref{table:comparision}, aforementioned methods 
still can not incorporate GNN and LPA within a message passing model, \emph{propagating} \emph{feature} and \emph{label} in both training and prediction procedure.




\begin{table}[htbp]
	\setlength{\abovecaptionskip}{0.cm}
	\setlength{\belowcaptionskip}{-.2cm}
	\caption{Comparision between message passing models}
	\begin{center}
\begin{tabular}{lccccc}
			\multicolumn{1}{c}{ }  &\multicolumn{2}{c}{ Training} &\multicolumn{2}{c}{ Prediction} \\
			\multicolumn{1}{c}{ }  &\multicolumn{1}{c}{\bf Feature} &\multicolumn{1}{c}{\bf Label} &\multicolumn{1}{c}{\bf Feature} &\multicolumn{1}{c}{\bf Label}	\\
			\hline 
			LPA         & &\makecell[c]{\checkmark} & &\makecell[c]{\checkmark}   \\
			GCN             &\makecell[c]{\checkmark}  &&\makecell[c]{\checkmark}  & \\
			APPNP     &\makecell[c]{\checkmark}    &   &\makecell[c]{\checkmark}    & \\
			GCN-LPA      &\makecell[c]{\checkmark}    & \makecell[c]{\checkmark}    &\makecell[c]{\checkmark}    & \\
			UniMP (Ours)     &\makecell[c]{\checkmark}    & \makecell[c]{\checkmark}    &\makecell[c]{\checkmark}    &\makecell[c]{\checkmark}  \\
		\end{tabular}
	\end{center}
	\label{table:comparision}
	\vspace{-4mm}
\end{table}

To unify the \emph{feature} and \emph{label propagation}, there are mainly two issues needed to be addressed:

{\bf Aggregating feature and label information.} Since node feature is represented by embeddings, while node label is a one-hot vector. They are not in the same vector space. In addition, there are different between their message passing ways, GNNs can propagate the information by diverse neural structures likes GraphSAGE \citep{hamilton2017inductive}, GCN \citep{kipf2016semi} and GAT \citep{velivckovic2017graph}.  But LPAs can only pass the label message by graph adjacency matrix.

{\bf Supervised training.} Supervised training a model with \emph{feature} and \emph{label propagation} will overfit in self-loop label information inevitably, which makes the label leakage in training time and causes poor performance in prediction.

In this work, inspired by several advantages developments \citep{vaswani2017attention, wang2018joint, devlin2018bert} in Natural Language Processing (NLP), we propose a new {\bf Uni}fied {\bf M}essage {\bf P}assing model (UniMP) with masked label prediction that can settle the aforementioned issues. UniMP is a multi-layer Graph Transformer, jointly using label embedding to transform nodes labels into the same vector space as nodes features. It propagates nodes features like the previous attention based GNNs \citep{velivckovic2017graph, zhang2018gaan}. Meanwhile, 
its multi-head attentions are used as the transition matrix for propagating labels vectors. Therefore, each node can aggregate both features and labels information from its neighbors. To supervised training UniMP without overfitting in self-loop label information, we draw lessons from masked word prediction in BERT \citep{devlin2018bert} and propose a masked label prediction strategy, which randomly masks some training instances' label embedding vectors and then predicts them. This training method perfectly simulates the procedure of transducing labels information from labeled to unlabeled examples in the graph.

We conduct experiments on three semi-supervised classification datasets in the Open Graph Benchmark (OGB), where our new methods achieve novel state-of-the-art results in all tasks, gaining  ACC in \emph{ogbn-products},  ROC-AUC in \emph{ogbn-proteins} and  ACC in \emph{ogbn-arxiv}. We also conduct the ablation studies for the models with different inputs to prove the effectiveness of our unified method. In addition, we make the most thorough analysis of how the label propagation boosts our model's performance.
\section{Method}
\begin{figure}[htbp]
	\centering
	\includegraphics[width=\linewidth]{unimp_architecture}
	\caption{
	 The architecture of our UniMP.
	}
	\label{figure:unimp_architecture}
\end{figure}
We first introduce our notation about graph. We denote a graph as , where  denotes the nodes in the graph with  and  denotes edges with . The nodes are described by the feature matrix , which usually are dense vectors with  dimension, and the target class matrix , with the number of classes . The adjacency matrix 
is used to describe graph , and the diagonal degree matrix is denoted by  diag , where  is the degree of node . A normalized adjacency matrix is defined as  or , and we adopt the first definition in this paper.

\subsection{Feature propagation and Label propagation}
In semi-supervised node classification, based on the Laplacian smoothing assumption, the GNN transforms and propagates nodes features  across the graph by several layers, including linear layers and nonlinear activation to build the approximation
of the mapping: . The feature propagation scheme of GNN in layer  is:

where the  is an activation function,  is the trainable weight in the -th layer, and the  is the -th layer representations of nodes.  is equal to node input features . Finally, a  output layer is applied on the final representation to make prediction for .

As for LPA, it also assumes the labels between connected nodes are smoothing and propagates the labels iteratively across the graph. Given an initial label matrix , which consists of one-hot label indicator vectors  for the labeled nodes or zeros vectors for the unlabeled. A simple iteration equation of LPA is formulated as following:

Labels are propagated from each other nodes through a normalized adjacency matrix . 


\subsection{Unified message passing model}

As shown in Figure \ref{figure:unimp_architecture}, we employ a Graph Transformer, jointly using label embedding to construct our unified message passing model for combining the aforementioned feature and label propagation together.

{\bf Graph Transformer}. Since Transformer \citep{vaswani2017attention} has been proved being powerful in NLP, we employ its vanilla multi-head attention into graph learning with taking into account the case of edge features. Specifically, given nodes features , we calculate multi-head attention for each edge from  to  as following:

where  is exponential scale dot-product function and  is the hidden size of each head.
 For the -th head attention, we firstly transform the source feature  and distant feature  into query vector and key vector  respectively using different trainable parameters , , , . The provided edge features  will be encoded and added into key vector as additional information for each layer.


After getting the graph multi-head attention, we make a message aggregation from the distant  to the source :

where the  is the concatenation operation for  head attention. Comparing with the Equation \ref{equ:1}, multi-head attention  matrix replaces the original normalized adjacency matrix as transition matrix for message passing. The distant feature  is transformed to  for weighted sum. In addition, inspired by \citep{li2019deepgcns,chen2020simple} to prevent oversmoothing, we propose a gated residual connections between layers by  and .

Specially, similar to GAT, if we apply the Graph Transformer on the output layer, we will employ averaging for multi-head output as following: 


{\bf Label Embedding and Propagation}. We propose to embed the partially observed labels information into the same space as nodes features: , which consist of the label embedding vector for labeled nodes and zeros vectors for the unlabeled. And then, we combine the label propagation into Graph Transformer by simply adding the nodes features and labels features together as propagation features . We can prove that by mapping partially-labeled  and nodes features  into the same space and adding them up, our model is unifying both label propagation and feature propagation within a shared message passing framework. Let's take  and  to be normalized adjacency matrix  or the attention matrix from our Graph Transformer like Equation \ref{eq:3}. Then we can find that:

where  can be the gated function like Equation \ref{eq:4} or a pre-defined hyper-parameters like APPNP \citep{klicpera2019predict}. For simplification, we let  function as identity function, then we can get:

where . Then we can find that our model can be approximately decomposed into feature propagation  and label propagation . 

\section{Masked label prediction}

Previous works on GNNs seldom consider using the partially observed labels  in both training and inference stages. They only take those labels information as ground truth target to supervised train their model's parameters  with given  and :

where  represents the partial nodes with labels. However, our UniMP model propagates nodes features and labels to make prediction: . Simply using above objective for our model will make the label leakage in the training stage, causing poor performance in inference. Learning from BERT, which masks input words and makes prediction for them to pretrain their model (masked word prediction), we propose a masked label prediction strategy to train our model. During training, at each step, we corrupt the  into  by randomly masking a portion of node labels to zeros and keep the others remain, which is controlled by a hyper-parameter called label\_rate. Let those masked labels be , our objective function is to predict  with given ,  and :

where  represents those nodes with masked labels. In this way, we can train our model without the leakage of self-loop labels information. And during inference, we will employ all  as input labels to predict the remaining unlabeled nodes.






\section{Experiments}

We propose a Unified Message Passing Model (UniMP) for semi-supervised node classification, which incorporates the feature and label propagation jointly by a Graph Transformer and employ a masked label prediction strategy to optimize it. We conduct the experiments on the Node Property Prediction of Open Graph Benchmark (OGBN), which includes several various challenging and large-scale datasets for semi-supervised classification, splitted in the procedure that closely matches the real-world application \cite{hu2020open}. To verified our models effectiveness, we compare our model with others State-Of-The-Art models (SOTAs) in \emph{ogbn-products}, \emph{ogbn-proteins} and \emph{ogbn-arxiv} three OGBN datasets. We also provide more experiments and comprehensive studies to show our motivation more intuitively, and how LPA improves our model to achieve better results.


\subsection{Datasets and Experimental Settings}

\begin{table}[htbp]
	\setlength{\abovecaptionskip}{0.cm}
	\setlength{\belowcaptionskip}{-.2cm}
	\caption{Dataset statistics of OGB node property prediction}
    \small
	\begin{center}
		\setlength{\tabcolsep}{1.2mm}{
			\begin{tabular}{l|cccccccc}
				{\bf Name}  & {\bf Node} &  {\bf Edges}  &  {\bf Tasks} &  {\bf Split Rate} &  {\bf Split Type}  &  {\bf Task Type} &  {\bf Metric}	\\
				\hline 
				ogbn-products  && &  & &Sales rank &Multi-class class &Accuracy \\
				 ogbn-proteins   &&&& &Species&Binary class  &ROC-AUC\\
				ogbn-arxiv     &&&& &Time &Multi-class class  &Accuracy \\
		\end{tabular}}
	\end{center}
	\label{table:ogb}
\end{table}

\textbf{Datasets.} Most of the frequently-used graph datasets are extremely small compared to graphs found in real applications. And the performance of GNNs on these datasets is often unstable due to several issues including
their small-scale nature, non-negligible duplication or leakage rates, unrealistic data splits \citep{dwivedi2020benchmarking,hu2020open}. Consequently, we conduct our experiments on the recently released datasets of Open Graph Benchmark (OGB) \citep{hu2020open}, which overcome the main drawbacks of commonly used datasets and thus
are much more realistic and challenging. OGB datasets cover a variety of real-world applications and span several important domains ranging from social and information networks to biological networks, molecular graphs, and knowledge graphs. They also span a variety of predictions tasks at the level of nodes, graphs, and links/edges. As shown in table \ref{table:ogb}, in this work, we performed our experiments on the three OGBN datasets with different sizes and tasks for getting credible result, including \emph{ogbn-products} about 47 products categories classification with given 100-dimensional nodes features , \emph{ogbn-proteins} about 112 kinds of proteins function prediction with given 8-dimensional edges features and \emph{ogbn-arxiv} about 40-class topics classification with given 128 dimension nodes features. More details about these datasets are provided in Appendix.


{\bf Implementation Details.} 
As mentioned above, these datasets are different from each other in sizes or tasks. So we evaluate our model on them with different sampling methods like previous studies  \citep{li2020deepergcn}, getting credible comparison results.
 In \emph{ogbn-products} dataset, we use NeighborSampling with  for each layer to sample the subgraph during training and use full-batch for inference. In \emph{ogbn-proteins} dataset, we use Random Partition to split the dense graph into subgraph to train and test our model. The number of partitions is  for training and  for test. As for small-size \emph{ogbn-arxiv} dataset, we just apply full batch for both training and test. We set the hyper-parameter of our model for each dataset in Table \ref{table:params}, and the label\_rate means the percentage of labels we preserve during applying masked label prediction strategy. We use Adam optimizer with  to train our model. Specially, we set weight decay to  for our model in small-size \emph{ogbn-arxiv} dataset to prevent overfitting. More details about the tuned hyper-parameters are provided in Appendix.
\begin{table}[htbp]
	\setlength{\abovecaptionskip}{0.cm}
	\setlength{\belowcaptionskip}{-.2cm}
	\caption{The hyper-paramerter setting of our model}
	\begin{center}
		\begin{tabular}{cccc}
			& {\bf ogbn-products} &  {\bf ogbn-proteins	}  &  {\bf ogbn-arxiv} \\
			\hline
			sampling\_method &NeighborSampling & Random Partition & Full-batch \\
			num\_layers &   &  & \\ 
			hidden\_size &  &  & \\ 
			num\_heads &  &  & \\ 
			dropout  &  &  & \\ 
			lr &  &  & \\ 
			weight\_decay&  &  & \\ 
			label\_rate&  &  & \\ 
		\end{tabular}
	\end{center}
	\label{table:params}
	\vspace{-4mm}
\end{table}

We implement all our models by PGL\footnote[1]{\url{https://github.com/PaddlePaddle/PGL}} and PaddlePaddle\footnote[2]{\url{https://github.com/PaddlePaddle/Paddle}} and run all experiments on a single NVIDIA V100 32GB.
\subsection{Comparison with SOTAs}


\begin{table}[htbp]
	\setlength{\abovecaptionskip}{0.cm}
	\setlength{\belowcaptionskip}{-.2cm}
	\caption{Results for ogbn-products}
    \small
	\begin{center}
		\begin{tabular}{l|cccc}
			{\bf Model}  & {\bf Test Accuracy	} &  {\bf Validation Accuracy	}  &  {\bf Params} \\
			\hline 
			GCN-Cluster \citep{chiang2019cluster} &  &  &  \\
			GAT-Cluster & & & \\ 
			GAT-NeighborSampling &  & - &\\
			GraphSAINT \citep{zeng2019graphsaint} &  & - & \\
			DeeperGCN  \citep{li2020deepergcn} &  &  &   \\
			\hline 
			{\bf UniMP} & & &\\
		\end{tabular}
	\end{center}
	\label{table:ret_products}
\end{table}

\begin{table}[h]
	\setlength{\abovecaptionskip}{0.cm}
	\setlength{\belowcaptionskip}{-.2cm}
	\caption{Results for ogbn-proteins}
	\small
	\begin{center}
		\begin{tabular}{l|cccc}
			{\bf Model}  & {\bf Test ROC-AUC	} &  {\bf Validation ROC-AUC	}  &  {\bf Params} \\
			\hline 
			GaAN \citep{zhang2018gaan} &  & - & - \\
			GeniePath-BS \citep{liu2020bandit} & & - & \\ 
			MWE-DGCN&  & &\\
			DeepGCN \citep{li2019deepgcns}&  &  & \\
			DeeperGCN \citep{li2020deepergcn}  &  &  &   \\
			\hline 
			{\bf UniMP} & & &\\
		\end{tabular}
	\end{center}
	\label{table:ret_proteins}
\end{table}

\begin{table}[htbp]
	\setlength{\abovecaptionskip}{0.cm}
	\setlength{\belowcaptionskip}{-.2cm}
	\caption{Results for ogbn-arxiv}
	\small
	\begin{center}
		\begin{tabular}{l|cccc}
			{\bf Model}  & {\bf Test Accuracy	} &  {\bf Validation Accuracy	}  &  {\bf Params} \\
			\hline 
			DeeperGCN \citep{li2020deepergcn} & && \\ 
			GaAN \citep{zhang2018gaan} & & - & \\ 
			DAGNN \citep{liu2020towards} &  & -  &\\
			JKNet \citep{xu2018representation} &  & & \\
			GCNII \citep{chen2020simple}  &  & - &   \\
\hline 
			{\bf UniMP} & & &\\
		\end{tabular}
	\end{center}
	\label{table:ret_arxiv}
	\vspace{-4mm}
\end{table}


Baseline and other comparative SOTAs are provided by OGB leaderboard. Some of the including results are conducted officially by authors from original papers, while the others are re-implemented by communities. And all these results are guaranteed to be reproducible with open source codes. Following the requirement of OGB, we run our experimental results for each dataset 10 times and report the mean and standard deviation. As shown in Tabel \ref{table:ret_products}, Tabel \ref{table:ret_proteins}, and Tabel \ref{table:ret_arxiv}, our unified model outperform all other comparative models in three OGBN datasets.
Since most of the compared models only consider optimizing their models for the features propagation, these results demonstrate that incorporating label propagation into GNN models can bring significant improvements.
Specifically, we gain 82.56\% ACC in \emph{ogbn-products}, 86.42\% ROC-AUC in \emph{ogbn-proteins}, which achieves about 0.6-1.6\%  absolute improvements compared to the newly SOTA methods like DeeperGCN \citep{li2020deepergcn}. In \emph{ogbn-arxiv}, our method gains 73.11\% ACC, achieve 0.37\% absolute improvements compared to GCNII \citep{chen2020simple}, whose parameters are four times larger than ours. 














 

\section{Conclusion}
We first propose a unified message passing model, UniMP, which jointly performs feature propagation and label propagation within a Graph Transformer to make the semi-supervised classification. Furthermore, we propose a masked label prediction method to supervised training our model, preventing it from overfitting in self-loop label information. Experimental results show that UniMP outperforms the previous state-of-the-art models on three main OGBN datasets: \emph{ogbn-products}, \emph{ogbn-proteins} and \emph{ogbn-arxiv} by a large margin, and ablation studies demonstrate the effectiveness of unifying feature propagation and label propagation. 




\newpage
\bibliography{iclr2021_conference}
\bibliographystyle{iclr2021_conference}





\end{document}
