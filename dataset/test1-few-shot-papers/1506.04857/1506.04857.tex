
\documentclass[12pt]{article}
\usepackage{graphicx}



\marginparwidth 0pt \oddsidemargin 0pt
\evensidemargin 0pt \marginparsep 0pt
\topmargin 0pt \textwidth 6.5in \textheight 8.5in
\pagestyle{plain}



\newcommand{\bc}{bchain}



\begin{document}

\newenvironment{describe}{\begin{list}{}{\setlength\leftmargin{80pt}}\setlength\labelsep{10pt}\setlength\labelwidth{70pt}}{\end{list}}

\newenvironment{flag}{\begin{list}{\makebox[20pt]{\hss\enspace}}
                                  {\labelwidth 20pt}}{\end{list}}





\newenvironment{numberedlist}
{\begin{list}{\makebox[20pt]{\hss(\arabic{itemno})\enspace}}
             {\usecounter{itemno}\labelwidth 20pt}}{\end{list}}

\newenvironment{alphabetlist}
{\begin{list}{\makebox[20pt]{\hss(\alph{itemno1})\enspace}}
             {\usecounter{itemno1}\labelwidth 20pt}}{\end{list}}

\newenvironment{romanlist}
{\begin{list}{\makebox[20pt]{\hss(\roman{itemno2})\enspace}}
             {\usecounter{itemno2}\labelwidth 20pt}}{\end{list}}

\newcounter{itemno}

\newcounter{itemno1}

\newcounter{itemno2}
\newcounter{lemma}
\newcounter{exno}

\newcounter{defno}













\newenvironment{defn}{\refstepcounter{defno}\medskip \noindent {\bf
Definition \thedefno.\ }}{\medskip}

\newenvironment{ex}{\refstepcounter{exno}\medskip \noindent {\bf
Example \theexno.\ }}{\medskip} 













\newenvironment{millerexample}{
 \begingroup \begin{tabbing} \hspace{2em}\= \hspace{5em}\= \hspace{5em}\=
\hspace{5em}\= \kill}{
 \end{tabbing}\endgroup}

\newenvironment{wideexample}{
 \begingroup \begin{tabbing} \hspace{2em}\= \hspace{10em}\= \hspace{10em}\=
\hspace{10em}\= \kill}{
 \end{tabbing}\endgroup}

\newcommand{\sep}{\;\vert\;}

\newcommand{\ra}{\rightarrow}
\newcommand{\app}{\ }
\newcommand{\appt}{\ }
\newcommand{\tup}[1]{\langle\nobreak#1\nobreak\rangle}

\newcommand{\hu}{{\cal H}^+}
\newcommand{\Free}{{\cal F}}
\newcommand{\oprove}{\vdash\kern-.6em\lower.7ex\hbox{}\,}
\newcommand{\true}{\top}

\newcommand{\Dscr}{{\cal D}}
\newcommand{\Pscr}{{\cal P}}
\newcommand{\Gscr}{{\cal G}}
\newcommand{\Fscr}{{\cal F}}
\newcommand{\Vscr}{{\cal V}}
\newcommand{\Uscr}{{\cal U}}
\newcommand{\pderivation}{{\cal P}\kern -.1em\hbox{\rm -derivation}}
\newcommand{\pderivationl}{{\cal P}\kern -.1em\hbox{\em -derivation}}
\newcommand{\pderivable}{{\cal P}\kern -.1em\hbox{\rm -derivable}}
\newcommand{\pderivablel}{{\cal P}\kern -.1em\hbox{\em -derivable}}
\newcommand{\pderivations}{{\cal P}\kern -.1em\hbox{\rm -derivations}}
\newcommand{\pderivability}{{\cal P}\kern -.1em\hbox{\rm -derivability}}
\newcommand{\eqm}[1]{=_{\scriptscriptstyle #1}}
\newcommand\subsl{\preceq}
\newcommand{\fnrestr}{\uparrow}

\newcommand{\match}{{\rm MATCH}}
\newcommand{\triv}{{\rm TRIV}}
\newcommand{\imit}{{\rm IMIT}}
\newcommand{\proj}{{\rm PROJ}}
\newcommand{\simpl}{{\rm SIMPL}}
\newcommand{\failed}{{\bf F}}

\newcommand{\Dsiginst}[1]{{[#1]_\Sigma}}
\newcommand{\Psiginst}[1]{{[#1]_\Sigma}}
\newcommand{\lnorm}{{\lambda}norm}
\newcommand{\seq}[2]{#1 \supset #2}
\newcommand{\dseq}[2]{#1_1,\ldots,#1_{#2}}

\newcommand{\all}{\forall}
\newcommand{\some}{\exists}
\newcommand{\lambdax}[1]{\lambda #1\,}
\newcommand{\somex}[1]{\some#1\,}
\newcommand\allx[1]{\all#1\,}

\newcommand{\subs}[3]{[#1/#2]#3}
\newcommand{\rep}[3]{S^{#2}_{#1}{#3}}
\newcommand{\ie}{{\em i.e.}}
\newcommand{\eg}{{\em e.g.}}

\newcommand{\lbotr}{-R}
\newcommand{\ldbotr}{\bot\mbox{\rm -R}}
\newcommand{\landl}{-L}
\newcommand{\ldandl}{\land\mbox{\rm -L}}
\newcommand{\landr}{-R}
\newcommand{\ldandr}{\land\mbox{\rm -R}}
\newcommand{\lorl}{-L}
\newcommand{\ldorl}{\lor\mbox{\rm -L}}
\newcommand{\lorr}{-R}
\newcommand{\ldorr}{\lor\mbox{\rm -R}}
\newcommand{\limpl}{-L}
\newcommand{\ldimpl}{\supset\mbox{\rm -L}}
\newcommand{\limpr}{-R}
\newcommand{\ldimpr}{\supset\mbox{\rm -R}}
\newcommand{\lnegl}{-L}
\newcommand{\ldnegl}{\neg\mbox{\rm -L}}
\newcommand{\ldnegr}{\neg\mbox{\rm -R}}
\newcommand{\lalll}{-L}
\newcommand{\ldalll}{\forall\mbox{\rm -L}}
\newcommand{\lallr}{-R}
\newcommand{\ldallr}{\forall\mbox{\rm -R}}
\newcommand{\lsomel}{-L}
\newcommand{\ldsomel}{\exists\mbox{\rm -L}}
\newcommand{\lsomer}{-R}
\newcommand{\ldsomer}{\exists\mbox{\rm -R}}
\newcommand{\ldlamlr}{\lambda}
\newcommand{\sequent}[2]{\hbox{{}}}
\newcommand{\prog}[2]{\hbox{{}}}
\newcommand{\run}{\Gamma}


\newcommand{\Ibf}{{\bf I}}
\newcommand{\Cbf}{{\bf C}} 
\newcommand{\Cbfpr}{{\bf C'}}

\newcommand{\cprove}{\vdash_C}
\newcommand{\iprove}{\vdash_I}

\newsavebox{\lpartfig}
\newsavebox{\rpartfig}




\newenvironment{exmple}{
 \begingroup \begin{tabbing} \hspace{2em}\= \hspace{3em}\= \hspace{3em}\=
\hspace{3em}\= \hspace{3em}\= \hspace{3em}\= \kill}{
 \end{tabbing}\endgroup}
\newenvironment{example2}{
 \begingroup \begin{tabbing} \hspace{8em}\= \hspace{2em}\= \hspace{2em}\=
\hspace{10em}\= \hspace{2em}\= \hspace{2em}\= \hspace{2em}\= \kill}{
 \end{tabbing}\endgroup}

\newenvironment{example}{
\begingroup  \begin{tabbing} \hspace{2em}\= \hspace{3em}\= \hspace{3em}\=
\hspace{3em}\= \hspace{3em}\= \hspace{3em}\= \hspace{3em}\= \hspace{3em}\= 
\hspace{3em}\= \hspace{3em}\= \hspace{3em}\= \hspace{3em}\= \kill}{
 \end{tabbing} \endgroup }


\newcommand{\sand}{sand} \newcommand{\pand}{pand} \newcommand{\cor}{cor} 

\newcommand{\lb}{\langle}
\newcommand{\rb}{\rangle}
\newcommand{\pr}{prov}
\newcommand{\prG}{intp}
\newcommand{\prSG}{intp_E}
\newcommand{\intp}{intp_o}
\newcommand{\prove}{exec} \newcommand{\np}{invalid} \newcommand{\Ra}{\supset}  
\newcommand{\add}{\oplus} \newcommand{\adc}{\&} \newcommand{\Cscr}{{\cal C}}
\newcommand{\seqweb}{SProlog}
\newcommand{\sprog}{{SProlog}}

\newtheorem{theorem}[lemma]{Theorem}

\newtheorem{proposition}[lemma]{Proposition}

\newtheorem{corollary}[lemma]{Corollary}
\newenvironment{proof}
     {\begin{trivlist}\item[]{\it Proof. }}{\\* \hspace*{\fill} \end{trivlist}}

\newcommand{\seqand}{\prec}
\newcommand{\seqor}{\cup}
\newcommand{\seqandq}[2]{\prec_{#1}^{#2}}
\newcommand{\parandq}[2]{\land_{#1}^{#2}}
\newcommand{\exq}[2]{\exists_{#1}^{#2}}
\newcommand{\ext}{intp_G} 
\title{\bf  Mutually Exclusive Modules  in  Logic Programming }
\author{
 Keehang Kwon\\
\sl \small Faculty of Computer Eng., DongA  University\\
\small khkwon@dau.ac.kr
}
\maketitle









\newcommand{\prov}{ex}


\noindent {\bf Abstract}: 
Logic programming has traditionally lacked devices for expressing 
 mutually exclusive modules. We address this limitation 
  by adopting 
   choice-conjunctive modules of the form 
   where   are a conjunction of Horn clauses and 
  is a linear logic connective.   Solving a  goal  using   --  -- has the 
 following operational semantics:  a successful one between  and
 . In other words, if  is chosen in the course of solving , then  will be
discarded and vice versa.  Hence, the class of  choice-conjunctive  modules can capture
the notion  of  mutually exclusive modules.

{\bf keywords:} mutual exclusion, cut, linear logic, choice-conjunction.


\maketitle


\newcommand{\muprolog}{LProlog}





\section{Introduction}\label{sec:intro}

Modern logic programming languages support a notion of modules, \ie,  a conjunction of clauses as a unit.
Despite their attractiveness, logic programming has 
traditionally lacked elegant devices for structuring mutually exclusion at the module level.
 Lacking such devices, structuring mutually exclusive modules in logic programming has  been impossible.


\newcommand{\hweb}{MutexWeb}

This paper proposes a logical, high-level solution to this problem. 
To be specific, we propose
\hweb, an extension to LogicWeb with a novel feature called choice-conjunctive modules.
 This logic extends  modules  by the choice construct 
 of the form  where  are modules and  is a choice-conjunctive connective of
linear logic.
Inspired by  \cite{Jap03}, this has the following intended semantics:  a successful one between  and  in the course of 
solving a goal. Of course, the unchosen module will be discarded.
This expression thus supports the idea of mutual exclusion. 

An illustration of this aspect is provided by the following modules  which define the 
usual
 relation:

\begin{exmple}
  \% quicksort \\ 
 \\
 \\ \\ \\
   \% heapsort  \\
 \\

\end{exmple}
\noindent 
Now we want to define a module  which contains different sorting algorithms.
This is show below:


\begin{exmple}
  \%  modue sort \\ 
 \\
\end{exmple}
\noindent In the above, these two sorting algorithms
 are defined as  mutually exclusive. Hence, only one of these two sorting algorithms
can be used. 

The remainder of this paper is structured as follows. We describe \hweb\
 in
the next section. In Section \ref{sec:modules}, we
present some examples of \hweb.
Section~\ref{sec:conc} concludes the paper.


\section{The Language}\label{sec:logic}

The language is an extended  version of Horn clauses
 with choice-conjunctive modules and implication goals. It is described
by - and -formulas given by the syntax rules below:
\begin{exmple}
\> \>    \\   \\
\> \>  \\
\end{exmple}
\noindent
In the rules above,   
  represents an atomic formula.
A -formula  is called a  
   module. 
 
In the transition system to be considered, -formulas will function as 
queries and a set of -formulas will constitute  a program. 

 We will  present an operational 
semantics for this language. The rules of \hweb\ are formalized by means of what it means to
execute a goal task  from a program .
These rules in fact depend on the top-level 
constructor in the expression,  a property known as
uniform provability\cite{Mil89jlp,MNPS91}. Below the notation  denotes
that the  formula is distinguished
(marked for backchaining). Note that execution  alternates between 
two phases: the goal-reduction phase (one  without a distinguished clause)
and the backchaining phase (one with a distinguished clause).

\begin{defn}\label{def:semantics}
Let  be a goal and let  be a program.
Then the notion of   executing  --  -- 
 is defined as follows:
\begin{numberedlist}

\item  . \% This is a success.

\item     if 
  and  .

\item     if   .

\item     if   .

\item     if   .

\item     if  choose a successful disjunct between   and
 . 

\item     if    and . \%  change to backchaining phase.

\item    if   and
  .

\item   if .

\item  if 


\end{numberedlist}
\end{defn}

\noindent  
In the rule (6), the symbol   allows for the mutually exclusive execution of modules. This rule
 can be implemented as follows:
  first attempts to solve the goal using .
 If it succeeds, then do nothing (and do not leave any choice point for 
). If it fails, then  is attempted. 

Our execution model based on uniform proof is not complete with respect to linear logic.
However, it is complete with respect to affine logic (linear logic + weakening).
The following theorem connects our language to affine logic.
Its proof can be obtained from the fact that the cut rule is admissible in affine logic.

\begin{theorem}
 Let  be a program and 
let  be a goal.  Then,  terminates with a success
 if and only if  follows from
 in intuitionistic affine logic. 
\end{theorem}
\noindent In the above,  represents that  is  a reusable clause.


\section{\hweb}\label{sec:modules}

In our context, a web page corresponds simply to a set of -formulas
 with a URL. 
The module construct  allows a URL to be associated to a set of -formulas.
An example of the use of this construct is provided by the 
following ``lists'' module which contains some basic list-handling rules.


\begin{exmple}
 .\\
\%  deterministic version of the member predicate \\
\\
 {\rm :-}  \\
\%  optimized version of the append predicate \\
 \\
 {\rm :-}   \\ 

\% the sorting of a list via two mutually exclusive sorting algorithms \\
\\
\end{exmple}
\noindent Our language  makes it possible to use quicksort and heapsort in a mutually exclusive way.

 These  pages can be made available in specific contexts by explicitly
mentioning the module implication. For example, consider a goal 
. 
Solving this goal  has the effect
 of adding the rules in 
to the program before evaluating , producing the result .





\section{Conclusion}\label{sec:conc}

In this paper, we have considered an extension to Prolog with  
mutually exclusive  modules. This extension allows modules of 
the form    where  are modules.
These modules are 
 particularly useful for structuring the program space.


  We are investigating the connection between \hweb\ and Japaridze's
computability logic \cite{Jap03,Jap08}.





\bibliographystyle{plain}\begin{thebibliography}{1}

\bibitem{LD96}
S.W. Lok and A.~Davison, ``Logic {P}rogramming with the {WWW},'' Proceedings of
  the 7th ACM conference on Hypertext, ACM Press, 1996.

\bibitem{Davies}
J.~Davies, D.~Fensel, and F.V. Harmelen, Towards the Semantic Web, John Wiley,
  2003.


\bibitem{Jap03}
G.~Japaridze, ``Introduction to computability logic'', Annals  of Pure and
 Applied  Logic, vol.123, pp.1--99, 2003.

\bibitem{Jap08}
G.~Japaridze,   ``Sequential operators in computability logic'',
 Information and Computation, vol.206, No.12, pp.1443-1475, 2008.  



\bibitem{Gir87}
J.Y.~Girard, ``Linear Logic'', Theoretical Computer Science, vol.50, pp.1--102, 
1987.

\bibitem{HM94}
J.~Hodas and D.~Miller, ``Logic Programming in a Fragment of Intuitionistic Linear Logic'', Information and Computation, vol.110, pp.327--365, 1994.



\bibitem{Mil89jlp}
D.~Miller, ``A logical analysis of modules in logic programming,'' Journal of
  Logic Programming, vol.6, pp.79--108, 1989.

\bibitem{MNPS91}
D.~Miller, G.~Nadathur, F.~Pfenning, and A.~Scedrov, ``Uniform proofs as a
  foundation for logic programming,'' Annals of Pure and Applied Logic, vol.51,
  pp.125--157, 1991.


\bibitem{Por}
A.~Porto,   ``A structured alternative to Prolog with simple compositional
               semantics'',
 Theory and Practice of Logic Programming, vol.11, No.4-5, pp.611-627, 2011.  


\end{thebibliography}



\end{document}
