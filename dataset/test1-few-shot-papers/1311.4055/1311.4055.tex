

The area of exact exponential algorithms is about   solving  intractable  problems  faster than the trivial exhaustive search, though still in exponential time  \cite{FominKratschbook10}.  
In this paper, we give  algorithms computing maximum induced chordal and interval subgraphs in a graph faster than the trivial brute-force search. These problems are interesting cases of a more general meta-problem \textsc{Maximum Induced -Subgraph}, where for a given graph  and hereditary\footnote{A class of graphs is {\em{hereditary}} if it is closed under taking induced subgraphs.} class of graphs  one asks for an induced subgraph belonging  with the maximum possible number of vertices.

By the result of Lewis  and Yannakakis \cite{LewisY80}, the \textsc{Maximum Induced -Subgraph} problem is NP-hard for every non-trivial class of graphs . 
Different classes  were studied in the literature; examples include classes of graphs that are edgeless, planar, outerplanar, bipartite, complete bipartite, acyclic, degree-constrained, chordal etc. From the point of view of exact algorithms, as far as membership in  can be tested in polynomial time, a trivial brute-force search trying all possible vertex subsets of  solves  
\textsc{Maximum Induced -Subgraph} in time  on an -vertex graph .\footnote{The  notation suppresses terms polynomial in the input size.}  
However, many algorithms for \textsc{Maximum Induced -Subgraph} which are faster than  can be found in the literature for explicit classes . 
Notable examples are  being the class of graphs that are edgeless~\cite{Robson86} (equivalent to \textsc{Maximum Independent Set}), acyclic~\cite{FominGPR08-On} (equivalent to \textsc{Maximum Induced Forest}), bipartite~\cite{RamanSS07}, planar~\cite{FominTV11}, degenerate~\cite{PilipczukP12}, regular \cite{GuptaRS12},  cluster graphs~\cite{FominGKLS10}, bounded treewidth \cite{Fomin:2010ys}, or bicliques~\cite{GaspersKL12}, see Table~\ref{table1}. Very recently, Fomin et al.~\cite{FominTV13} have shown that for every hereditary class of graphs  that have constant treewidth and are definable in counting monadic second-order logic (CMSO), the \textsc{Maximum Induced -Subgraph} problem can be solved in  time.

The listed examples suggest that existence of algorithms faster than  for \textsc{Maximum Induced -Subgraph} can be a phenomenon of a much more general nature. In fact, so far we do not know any efficiently recognizable class  for which a lower bound could be derived. Therefore,   the following   is a folklore open problem in the field; we could not find it  explicitly stated in the literature, so we state it below.

\begin{hypothesis}\label{conj:main}
For every hereditary graph class  that can be recognized in polynomial time, the \textsc{Maximum Induced -Subgraph} problem can be solved in time  for some .
\end{hypothesis}

We expect that some additional weak conditions on~ may be needed to provide a positive answer to hypothesis we discuss propositions of such relaxations in Section~\ref{sec:conlusion}. Thus, the aforementioned results~\cite{FominGKLS10,FominGPR08-On,FominTV11,FominTV13,GaspersKL12,PilipczukP12,RamanSS07,Robson86} can be viewed as partial progress on Hypothesis~\ref{conj:main}: the idea is to investigate how different features of the class  can be used to design an algorithm breaking the  barrier.



\begin{table}[h!]
\begin{center}
\begin{tabular}{|c|c|c|}
\hline
Property & Time complexity &  Reference\\
\hline
edgeless &   & Robson~\cite{Robson86}\\
acyclic &  & Fomin et al.~\cite{FominGPR08-On}\\
bipartite &  & Raman et al.~\cite{RamanSS07}\\
planar &  & Fomin et al.~\cite{FominTV11}\\
-degenerate &  & Pilipczuk~\cite{PilipczukP12}\\
cluster graph &  & Fomin et al.~\cite{FominGKLS10}\\
biclique &   & Gaspers et al.~\cite{GaspersKL12}\\
 treewidth &    & Fomin and Villanger~\cite{Fomin:2010ys}\\
-regular &  & Gupta et al. ~\cite{GuptaRS12}\\
matching &  & Gupta et al. ~\cite{GuptaRS12}\\
\hline
\end{tabular}
\end{center}
\caption{Known results for \textsc{Maximum Induced -Subgraph}}\label{table1}
\end{table}

Since every hereditary class of graphs  can be characterized by a (not necessarily finite) set of forbidden induced subgraphs, there is an equivalent formulation of the \textsc{Maximum Induced   -Subgraph} problem. For a set of graphs , a graph  is called -free if it contains no graph from  as an induced subgraph. The \textsc{Maximum -free Subgraph} problem is to find a maximum induced -free subgraph of . Clearly, if  is the set of forbidden induced subgraphs for , then the \textsc{Maximum Induced -Subgraph} problem and the \textsc{Maximum -free Subgraph} problem are equivalent.

It is well known that when the set  is \emph{finite}, then \textsc{Maximum -free Subgraph} can be solved in time , where . This can be seen by applying a simple branching arguments, see Proposition~\ref{lemma:finite_deletion}, or by reducing to the \textsc{-Hitting Set} problem, which is solvable faster than  for every fixed ~\cite{FominGKLS10,Gaspers:2008rf}. Examples of -free classes of graphs for some finite set  are split  graphs, cographs, line graphs or trivially perfect graphs; see the book \cite{brandstadt1999graph} for more information on these graph classes.

It is however completely unclear if anything faster than the trivial brute-force is possible in the case when  is an infinite set, even when  consists of very simple graphs. One of the most known  and well studied classes of -free graphs is the class of  \emph{chordal graphs}, where  is the set of all cycles of length more than three.  Chordal graphs form a fundamental class of graphs whose properties are well understood. Another fundamental class of graphs is the class of \emph{interval graphs}. We refer to the book  of Golumbic  for an overview of properties and applications of chordal and interval graphs \cite{Golumbic80}. In spite of nice structural properties of these graphs,  no exact algorithms for \textsc{Maximum Induced Chordal Subgraph} and \textsc{Maximum Induced Interval Subgraph} problems better than the trivial  were known prior to our work.
 
\smallskip\noindent\textbf{Our results.} 
We define four properties of a graph class and give an algorithm that, for every fixed graph class  (not part of the input) satisfying these properties, and for a given -vertex graph , finds a maximum induced subgraph of  belonging to  in time  for some , where  depends only on the class . Because classes of chordal and interval graphs satisfy the required properties, as an immediate corollary we obtain that \textsc{Maximum Induced Chordal Subgraph} and \textsc{Maximum Induced Interval Subgraph} can be solved in time  for some .

When pipelined with simple branching arguments, our algorithms can be used to obtain time   algorithms for some   for a variety of other \textsc{Maximum Induced -Subgraph} problems, where class  comprises chordal/interval graphs that moreover contain no induced subgraph from a \emph{finite} forbidden set of graphs. 
Examples of such classes are proper interval graphs, Ptolemaic graphs, block graphs, or proper circular-arc graphs; see \cite{brandstadt1999graph} for definitions and discussions of these graph classes.

The main intention of our work was to break the trivial  barrier, and thus to provide a new insight into Hypothesis~\ref{conj:main} by analyzing chordal and chordal-like graph classes. For this reason, we did not try to optimize the constant  in the exponent. There are several places where the running time of our algorithm can be improved at a cost of more involved arguments or intensive case analyses. However, we would like to stress again that the main motivation of our work is the theoretical study of Hypothesis~\ref{conj:main}, rather than pursuit of really efficient algorithms for the respective problems. Therefore, we refrain from giving these improvements and prefer keeping the arguments as simple as possible.

\smallskip\noindent\textbf{Organization.} In Section~\ref{sec:preliminaries} we give notation and recall known tools that will be used later. In Section~\ref{sec:properties} we discuss the four properties of a graph class that are needed for our algorithm to be applicable. Section~\ref{sec:algo} contains the description of the algorithm. For the convenience of the reader, in Section~\ref{app:choice} we summarize the order of choice of small constants used by the algorithm. Finally, in Section~\ref{sec:conlusion} we give some concluding remarks.
