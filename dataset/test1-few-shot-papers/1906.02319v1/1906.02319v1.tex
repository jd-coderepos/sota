

\documentclass[sigconf]{acmart}


\settopmatter{printacmref=true}


\fancyhead{}


\usepackage{balance}
\usepackage{multirow}
\usepackage{enumitem}
\newcommand{\demonet}{{\emph {DEMO-Net}}}


\def\BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08emT\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}
    


\copyrightyear{2019}
\acmYear{2019}
\setcopyright{acmcopyright}
\acmConference[KDD '19] {The 25th ACM SIGKDD Conference on Knowledge Discovery and Data Mining}{August 4--8, 2019}{Anchorage, AK, USA}
\acmBooktitle{The 25th ACM SIGKDD Conference on Knowledge Discovery and Data Mining (KDD'19), June 22--24, 2019, Anchorage, AK, USA}
\acmPrice{15.00}
\acmDOI{10.1145/3292500.3330950}
\acmISBN{978-1-4503-6201-6/19/08} 







\begin{document}


\title{\demonet: Degree-specific Graph Neural Networks for\\ Node and Graph Classification}


\author{Jun Wu}
\affiliation{\institution{Arizona State University}
}
\email{junwu6@asu.edu}

\author{Jingrui He}
\affiliation{\institution{Arizona State University}
}
\email{Jingrui.he@asu.edu}

\author{Jiejun Xu}
\affiliation{\institution{HRL Laboratories, LLC}
}
\email{jxu@hrl.com}

\renewcommand{\shortauthors}{Trovato and Tobin, et al.}

\begin{abstract}
Graph data widely exist in many high-impact applications. Inspired by the success of deep learning in grid-structured data, graph neural network models have been proposed to learn powerful node-level or graph-level representation. However, most of the existing graph neural networks suffer from the following limitations: (1) there is limited analysis regarding the graph convolution properties, such as {\em seed-oriented}, {\em degree-aware} and {\em order-free}; (2) the node's degree-specific graph structure is not explicitly expressed in graph convolution for distinguishing structure-aware node neighborhoods; (3) the theoretical explanation regarding the graph-level pooling schemes is unclear.

To address these problems, we propose a generic degree-specific graph neural network named \demonet\ motivated by Weisfeiler-Lehman graph isomorphism test that recursively identifies 1-hop neighborhood structures. In order to explicitly capture the graph topology integrated with node attributes, we argue that graph convolution should have three properties: {\em seed-oriented}, {\em degree-aware}, {\em order-free}. To this end, we propose multi-task graph convolution where each task represents node representation learning for nodes with a specific degree value, thus leading to preserving the degree-specific graph structure. In particular, we design two multi-task learning methods: degree-specific weight and hashing functions for graph convolution. In addition, we propose a novel graph-level pooling/readout scheme for learning graph representation provably lying in a degree-specific Hilbert kernel space. The experimental results on several node and graph classification benchmark data sets demonstrate the effectiveness and efficiency of our proposed \demonet\ over state-of-the-art graph neural network models.
\end{abstract}





\keywords{Graph Neural Network, Degree-specific Convolution, Multi-task Learning, Graph Isomorphism Test}



\maketitle

\section{Introduction}
Nowadays, graph data is being generated across multiple high-impact application domains, ranging from bioinformatics~\cite{gilmer2017neural} to financial fraud detection~\cite{zhou2018sparc, zhou2017local}, from genome-wide association study~\cite{wu2018leveraging} to social network analysis~\cite{hamilton2017inductive}. In order to leverage the rich information in graph-structured data, it is of great importance to learn effective node or graph representation from both node/edge attributes and the graph topological structure. To this end, numerous graph neural network models have been proposed recently inspired by the success of deep learning architectures on grid-structured data (e.g., images, videos, languages, etc.). One intuition behind this line of approaches is that the topological structure as well as node attributes could be integrated by recursively aggregating and compressing the continuous feature vectors from local neighborhoods in an end-to-end training architecture.

One key component of graph neural networks~\cite{hamilton2017representation, gilmer2017neural} is the graph convolution (or feature aggregation function) that aggregates and transforms the feature vectors from a node's local neighborhood. By integrating the node attributes with the graph structure information using Laplacian smoothing~\cite{li2018deeper, kipf2016semi} or advanced attention mechanism~\cite{velickovic2017graph}, graph neural networks learn the node representation in a low-dimensional feature space where nearby nodes in the graph would share a similar representation. Moreover, in order to learn the representation for the entire graph, researchers have proposed the graph-level pooling schemes~\cite{atwood2016diffusion} that compress the nodes' representation into a global feature vector. The node or graph representation learned by graph neural networks has achieved state-of-the-art performance in many downstream graph mining tasks, such as node classification~\cite{zhang2018graph}, graph classification~\cite{xu2018powerful}, etc.

However, most of the existing graph neural networks suffer from the following limitations.
\textbf{ (L1)} There is limited analysis on graph convolution properties that could guide the design of graph neural networks when learning node representation. \textbf{ (L2)} In order to preserve the node proximity, the graph convolution applies a special form of Laplacian smoothing~\cite{li2018deeper}, which simply mixes the attributes from node's neighborhood. This leads to the loss of degree-specific graph structure information for the learned representation. An illustrative example is shown in Figure \ref{degree_struc}: although nodes 4 and 5 are structurally different, they would be mapped to similar representation due to first-order node proximity using existing methods. Moreover, the neighborhood sub-sampling methods used to improve model efficiency~\cite{hamilton2017inductive} significantly degraded the discrimination of degree-specific graph structure. \textbf{ (L3)} The theoretical explanation regarding the graph-level pooling schemes is largely missing.

To address the above problems, in this paper, we propose a generic graph neural network model \demonet\ that considers the degree-specific graph structure in learning both node and graph representation. Inspired by Weisfeiler-Lehman graph isomorphism test \cite{weisfeiler1968reduction}, the graph convolution of graph neural networks should have three properties: {\em seed-oriented}, {\em degree-aware}, {\em order-free}, in order to map different neighborhoods to different feature representation. 
As shown in Figure \ref{degree_struc}, nodes with identical degree value typically share similar subtree (root node followed by its 1-hop neighbors) structures. As a result, the representation of nodes 2 and 8 should be close in the feature space due to the similar subtree structure. On the other hand, nodes 4 and 5 have different subtree structures (i.e., number of subtree leaves), and they indicate different roles in the network, e.g., leader vs. deputy in a covert group. Therefore, they should not be mapped closely in the feature space.

To the best of our knowledge, very little effort on graph neural networks is devoted to learning the degree-specific representation for each node or the entire graph. To bridge the gap, we present a degree-specific graph convolution by assuming that nodes with the same degree value would share the same graph convolution. It can be formulated as a multi-task feature learning problem where each task represents the node representation learning for nodes with specific degree values. 

In addition, we introduce a degree-specific graph-level pooling scheme to learn the graph representation. We theoretically show that the graph representation learned by our model lies in a Reproducing Kernel Hilbert space (RKHS) induced by a degree-specific Weisfeiler-Lehman graph kernel. The most similar work to us is Graph Isomorphism Network (GIN) \cite{xu2018powerful} which used the sum-aggregator associated with multi-layer perceptrons as the neighborhood-injective graph convolution that mapped different node neighborhood to different features. However, one issue of GIN is that 
the degree-aware structures are implicitly expressed in its graph convolution relying on the universal approximation capacity of multi-layer perceptrons.

The main contributions of this paper are summarized as follows:
\begin{enumerate}
    \item We provide theoretical analysis for graph neural networks from the perspective of Weisfeiler-Lehman graph isomorphism test, which motivates us to design the graph convolution based on the following properties: seed-oriented, degree-aware and order-free.
    
    \item we propose a generic graph neural network framework named \demonet\ by assuming that nodes with the same degree value would share the same graph convolution. A degree-specific multi-task graph convolution function is presented to learn the node representation. Furthermore, a novel graph-level pooling scheme is introduced for learning the graph representation provably lying in a degree-specific Hilbert kernel space. 
    
    \item The experimental results on several node and graph classification benchmark data sets demonstrate the effectiveness and efficiency of our proposed \demonet\ model.
\end{enumerate}

The rest of the paper is organized as follows. We review the related work in Section 2, followed by the problem definition and background introduction in Section 3. Section 4 presents our proposed \demonet\ framework for node and graph representation learning. The extensive experiments and discussion are provided in Section 5. Finally, we conclude the paper in Section 6.

\begin{figure}[t]
\includegraphics[width = 3.35in]{figures/degree_struc.pdf}
\caption{Nodes with the same degree value are structurally similar. For example, nodes 1, 3, 5, 7 and 9 in (b), nodes 2 and 8 in (c), nodes 4 and 6 in (d) share similar 1-hop neighborhood structure. Using the proposed model, the learned node representation integrates the degree-specific graph structure and node attributes such that the structurally similar nodes have similar representation.}
\label{degree_struc}
\vspace{-3mm}
\end{figure}

\section{Related Work}
In this section, we briefly review the related work on graph neural networks for node and graph classification.

\subsection{Node Classification}
Most of the existing graph neural networks \cite{hamilton2017representation} learn the node representation by recursively aggregating the continuous feature vectors from local neighborhoods in an end-to-end fashion. They could be fitted into the Message Passing Neural Networks (MPNNs) \cite{gilmer2017neural} which explained the feature aggregation of graph neural networks as message passing in local neighborhoods.
Generally, they focus on extracting the spatial topological information by operating the convolutions in the node domain \cite{zhang2018graph}, which differs from some spectral approaches \cite{defferrard2016convolutional, kipf2016semi} considering a node representation in the spectral domain. Graph Convolutional Network (GCN) \cite{kipf2016semi} defined the convolution operation via a neighborhood aggregation function. Following the same intuition, many graph neural network models have been proposed with different aggregation functions, e.g., attention mechanism \cite{velickovic2017graph}, mean and max functions \cite{hamilton2017inductive}, etc.

However, most of the graph neural network architectures are motivated by the success of deep learning on grid-like data, thus leading to little theoretical analysis for explaining the high performance and guiding the novel methodologies. Up till now, some work have been proposed to explain why graph neural networks work. The convolution of GCN was a special form of Laplacian smoothing on graph \cite{li2018deeper}, which explained the over-smoothing phenomena brought by many convolution layers. Lei et al. \cite{lei2017deriving} showed that the graph representation generated by graph neural networks lies in the Reproducing Kernel Hilbert Space (RKHS) of some popular graph kernels. Moreover, it shows that 1-dimensional aggregation-based graph neural networks are at most as powerful as the Weisfeiler-Lehman (WL) isomorphism test \cite{weisfeiler1968reduction} in distinguishing graphs \cite{xu2018powerful}. Compared with the existing work on graph neural networks, in this paper, we design a degree-specific graph convolution that captures the node neighborhood structures inspired by WL isomorphism test. This is in sharp contrast to the existing work which focused on preserving the node proximity in the feature space, thus leading to the loss of local graph structures.

\subsection{Graph Classification}
The graph-level pooling/readout schemes aim to learn a representation of the entire graph from its node representations for graph-level classification tasks. Mean/max/sum functions are commonly used due to its computational efficiency and effectiveness \cite{atwood2016diffusion, xu2018powerful}. One challenge for graph-level pooling is to maintain the invariance to node order. PATCHY-SAN \cite{niepert2016learning} first adopted the external software to obtain a global node order for the entire graph, which is very time-consuming. More recently, a number of graph neural network models have been proposed \cite{zhang2018end, xu2018powerful, ying2018hierarchical}, which formulated the node representation learning and graph-level pooling into a unified framework. Different from graph kernel approaches \cite{shervashidze2011weisfeiler, yanardag2015deep} that intuitively extract the graph feature or define the graph similarity using ad-hoc knowledge or random walk properties, graph neural networks would automatically learn the graph representation to integrate node attributes with its topological information via an end-to-end training architecture.

Nevertheless, very little effort has been devoted to explicitly considering the degree-specific graph structures for graph representation learning. Our proposed degree-specific graph-level pooling method is designed to address this issue by compressing the learned node representation according to degree values.

\section{Preliminaries}
In this section, we introduce the notation and problem definition, as well as some background information on graph neural networks.

\subsection{Notation}
Suppose that a graph is represented as , where  is the set of  nodes and  is the edge set. Let  denote the attribute matrix where each row  is the -dimensional attribute vector for node . The graph  can also be represented by an adjacency matrix , where  represents the similarity between  and  on the graph. For each node , its 1-hop neighborhood is denoted as .
Let  denote a set of graphs. In this paper, we focus on undirected attributed networks, although our model can be naturally generalized to other types of networks. The main notation used in this paper is summarized in Table \ref{tab: notations}.

\begin{table}[t]
\centering
\small
\caption{Notation} \label{tab: notations}
\begin{tabular}{|c|l|}
\hline
\multicolumn{1}{|c|}{Notation} & \multicolumn{1}{c|}{Definition}         \\ \hline
 &  A set of graphs \\ \hline
 & A graph  with node set  and edge set  \\ \hline
 & Attribute matrix \\ \hline
 & Adjacency matrix \\ \hline
 & Number of nodes in the graph \\ \hline
 & Dimensionality of the node or graph representation \\ \hline
 & 1-hop neighborhood of node  \\ \hline
 & Indices of labeled nodes' for node classification \\ \hline
 & Indices of labeled graphs' for graph classification \\ \hline
 & Label of node  \\ \hline
 & Label of graph  \\ \hline
 & Node 's representation at the  iteration\\ \hline
 & Feature set within node 's neighborhood \\  \hline
 & A set of subtrees\\ \hline
 &  A set of the degree values in graph  \\ \hline
\end{tabular}
\vspace{-3mm}
\end{table}

\subsection{Problem Definition}
In this paper, we focus on two problems: node-level and graph-level representation learning by formulating a novel degree-specific graph neural network model. Furthermore, we analyze the proposed model from various aspects, and empirically demonstrate its superior performance on both node and graph classification.

Formally, the node- and graph-level representation learning problems can be defined below.
\begin{definition}(\textit{\textbf{Node-level Representation Learning}}) \\
\indent \textbf{Input:} (i) An attributed graph  with adjacency matrix  and node attributes ; (ii) Labeled training nodes . \\
\indent \textbf{Output:} A vector representation  for each node  on the -dimensional embedding space where nodes would be well separated if their local neighborhoods are structurally different.
\end{definition}

\begin{definition}(\textit{\textbf{Graph-level Representation Learning}}) \\
\indent \textbf{Input:} (i) A set of attributed graphs  with adjacency matrix  and node attributes ; (ii) Labeled training graphs . \\
\indent \textbf{Output:} A vector representation  for each graph  on the -dimensional embedding space where graphs would be well separated if they have different graph topological structure.
\end{definition}

\subsection{Graph Neural Networks}
It has been observed that a broad class of graph neural network (GNN) architectures followed the 1-dimensional Weisfeiler-Lehman (WL) graph isomorphism test \cite{weisfeiler1968reduction}. From the perspective of WL isomorphism test, they mainly consist of the following crucial steps at each iteration of feature aggregation:
\begin{itemize}
\item Feature initialization (label\footnote{ Here, label is an identifier of nodes. In order not to be confused with a class label, we will use node attribute to represent it in this paper.} initialization): The node features are initialized by original attribute vectors.
\item Neighborhood detection (multiset-label determination): It decides the local neighborhood in which node gathers the information from neighbors. More specifically, a seed\footnote{The seed denotes the root node to be learned in the graph. For example, node  in Figure \ref{subtree} is a seed when updating its feature at each iteration.} followed by its neighbors generates a subtree pattern.
\item Neighbors sorting (multiset-label sorting): The neighbors are sorted in the ascending or descending order of degree values. The subtrees with permutation order of neighbors are recognized as the same one.
\item Feature aggregation (label compression): The node feature is updated by compressing the feature vectors of the aggregated neighbors including itself.
\item Graph-level pooling (graph representation): It summarizes all the node features to form a global graph representation.
\end{itemize}

Next, we briefly go over some existing graph neural network models, which follow the aforementioned steps of the 1-dimensional WL algorithms. We would like to point out that graph neural networks would learn the node or graph representation using continuous node attributes, whereas WL algorithms update the node attributes by directly compressing the augmented discrete attributes.

Taking 1-hop neighborhood  into consideration at each iteration, the following node-level graph neural network variants have the same feature initialization and neighborhood detection on learning node representation. And when element-wise average or max operations are used for feature aggregation, graph neural networks would be invariant to the order of neighbors. We summarize the feature aggregation functions (graph convolution) of those graph neural networks as follows.

\begin{itemize}
\item Graph Convolutional Network (GCN)~\cite{kipf2016semi}:

where  is the re-normalization of the adjacency matrix  with added self-loops, and  is the trainable matrix at  layer. It is essentially a weighted feature aggregation from node neighborhood.
\item Graph Attention Network (GAT)~\cite{velickovic2017graph}:

where  is a self-attention score indicating the importance of node  to node  on feature aggregation. It is obvious that GCN can be considered as a special case of GAT when the attention score  is defined as .
\item GraphSAGE~\cite{hamilton2017inductive}:

where mean-, max- and LSTM-aggregator are presented for feature aggregation. Though LSTM considers node neighbors as an ordered sequence, the LSTM aggregator is adapted on an unordered neighbors with random permutation.
\end{itemize}

There are some observations from these GNN variants: (i) Their feature aggregation schemes are invariant to the order of the neighbors except for GraphSAGE with LSTM-aggregator; (ii) The output feature at -layer neural network can be seen as the representation of a subtree around the seed; (iii) The node representation become closer and indistinguishable when the neural layers are going deeper, because the subtrees would share more common elements. However, little work theoretically discusses the reasons behind these observations to guide the design of graph neural networks: how is the node representation affected by node degree and order of neighbors? what kind of graph convolution is required to learn the subtree structures? Inspired by WL graph isomorphism test, we present a degree-specific graph neural network model named \demonet\ in Section 4 to discuss those problems.

Additionally, the neighborhood aggregation schemes of graph neural networks, such as mean-aggregator in GraphSAGE~\cite{hamilton2017inductive}, self-attention in GAT~\cite{velickovic2017graph}, can be regarded as the relabeling step in WL isomorphism test. Figure \ref{subtree} provides an example to illustrate the essence of feature aggregation on graph neural networks. The node feature is actually a special representation of subtree consisting of the seed followed by its neighbors. For example, node 1's feature  represents the subtree  collected from previous layer. As a result, graph neural networks with  layers learn the representation of subtree with depth  rooted at the seed. That provides us an intuition to design a graph convolution for explicitly preserving the degree-specific subtree structures.

\section{Proposed Model: \demonet}

\begin{figure}
\centering
\includegraphics[width = 3.35in]{figures/subtree}
\caption{Feature aggregation of the graph neural networks: For node 1, its feature is (a)  at  layer; (b)  at  layer compressed from a subtree ; (c)  at  layer learned from a subtree .}
\label{subtree}
\vspace{-3mm}
\end{figure}

In this section, we propose a generic degree-specific graph neural network named \demonet. Key to our algorithm is the degree-specific graph convolution for feature aggregation which can map different subtrees to different feature vectors. Figure \ref{framework} provides an overview of the proposed \demonet\ framework on learning node and graph representation, which will be described in detail below.

\subsection{Node Representation Learning}
Let  denote the feature set  within node 's neighborhood.
Let  be the set of subtrees consisting of the features of seed  and its 1-hop neighbors . To formalize our analysis, we first give the definition of structurally identical subtree below.
\begin{definition}(Structurally Identical Subtree)
Any two subtrees in  are structurally identical if the only possible difference between them is the order of neighbors.
\end{definition}

The following lemma shows that graph neural networks could distinguish the local graph structures as well as the WL graph isomorphism test when \textbf{graph convolution is an injective function} that maps two subtrees in  to different features if they are not structurally identical.


\begin{lemma}
Let  be a graph and  be two nodes in the graph. When the mapping function  in graph neural networks is injective, the learned features of  and  will be different if and only if the WL graph isomorphism test determines that they are not structurally identical.
\end{lemma}




The feature aggregation of graph neural networks can be simply summarized as follows.

Obviously, most of the existing graph neural networks \cite{kipf2016semi, velickovic2017graph} did not consider the injective aggregation function when learning node representation. From the perspective of WL isomorphism test, an injective graph convolution has the following properties.

\begin{lemma} (Properties)
Let  be the aggregation function. If it is an injective function that maps any different subtrees in  to different feature vectors, then it has the following properties:
\begin{enumerate}[label=(\roman*)]
\item Seed-oriented:  if the seeds' attributes are different, i.e., .
\item Degree-aware:  if the seeds' degree values are different, i.e., .
\item Order-free:  if  and the only possible difference between  and  is the order of neighbors.
\end{enumerate}
\end{lemma}


\begin{figure}
\includegraphics[width = 1.5in]{figures/mapping.pdf}
\caption{Examples of subtree in  with: (a) different seeds' attributes; (b) different seeds' degree values; (c) different neighbors' order. In such cases, two subtrees in (a) and (b) are mapped to different feature vectors, respectively. Two subtrees in (c) will be mapped to the same feature vector. (Best seen in color. Colors denote the node attributes.)}
\label{mapping}
\vspace{-3mm}
\end{figure}

Figure \ref{mapping} lists some examples to illustrate those properties. The injective function  maps the subtrees in Figure \ref{mapping}(a) to different features due to the distinctive seeds' attributes. Here, we hold that the subtree's structure properties are guided by seed node. Thus they are not structurally identical though both subtrees share the same leaf elements. Seeds' degree values also decide the subtree structure (shown in Figure \ref{mapping}(b)) because it is obvious that nodes with identical degree value share the similar structure. Figure \ref{mapping}(c) shows that neighbors' order will not change the subtree structure. 

These properties will guide us to build a structure-specific graph neural network model.
Based on properties (i) and (ii), the feature aggregation function in Eq. (\ref{G1}) can be expressed as follow.

where  and  are seed-related and degree-specific mapping functions, respectively, and  denotes the degree value of node . All the nodes share one seed-oriented mapping function , but have a degree-specific function for compressing node neighborhoods. Here,  denotes the vector concatenation which combines the mapped features to form a single vector. If  and  are injective, it will have the first two properties in Lemma 4.2 that subtrees with different seeds' features or degree values would be mapped differently. Additionally, the degree-specific mapping function  should be symmetric\footnote{A symmetric function of  variables is one whose value given  arguments is the same no matter the order of the arguments. For example,  for any pair .} that is invariant to the order of neighbors. And we have the following theorem (proven in Appendix) to show the existence of mapping functions  and .
\begin{theorem}(Existence Theorem)
\label{T: existence}
Assume  is countable, there exist mapping functions  and  such that for any two subtrees in , the function  defined in Eq. (5) maps them to different features if they are not structurally identical.
\end{theorem}






Next, we present our graph neural network model where the injective aggregation function could be approximated by multi-layer neural network due to its exceptional expression power. For seed-related mapping function  in Eq. (5), we use a simple one-layer fully-connected neural network as follows.

where the trainable matrix  is shared by all the seeds at  hidden layer. Here  is a nonlinear activation function. 

For degree-specific neighborhood aggregation on , it can be formulated as a multi-task feature learning problem (shown in Figure \ref{framework}(b)(c)) in which each task represents node representation learning for nodes with a specific degree value, thus leading to preserving the degree-specific graph structure. Here, we present two schemes for this multi-task learning problem.

\noindent\textbf{Degree-specific weight function: } The degree-specific aggregation function can be expressed as follow.

where  is a degree-specific trainable matrix at  layer and  is a global trainable matrix shared by all the seeds.

\noindent\textbf{Hashing function:} Since the number of degree values on graphs could be very large, a critical challenge is how to perform multi-task learning efficiently. To address this challenge, hash kernel~\cite{weinberger2009feature} (also called feature hashing or hash trick) is applied for our multi-task neighborhood learning problem. Given two vectors  and , the hash map  and the corresponding kernel  are defined:


where  and  denote two hash functions such that  and . Notice that hash kernel is unbiased, i.e.,  for any pair of input feature vectors. Let  denote one of the row vectors in , then we have . In this way, the multi-task feature aggregation function  can be expressed as:

where  is the trainable matrix shared by all the nodes, and  and  are global and degree-specific hash maps, respectively. 

One common assumption in multi-task learning is that all the tasks are related with some shared knowledge, and meanwhile have their own task-specific knowledge. As shown in Figure \ref{mapping}(b), two subtrees are structurally different, but they share some common leaves for neighborhood aggregation. By adopting both common (global) and task-specific (local) weight/hash functions, it allows learning the shared sub-structures and degree-specific neighborhood structures simultaneously.

There might be many different node degrees in real networks. One intuitive idea is that we could partition the degree values into several buckets to reduce the number of tasks. This heuristic solution might improve our model robustness to noisy graph structure or labeled nodes on source networks brought by human annotations \cite{zhou2016crowdsourcing, zhou2017multic2}.
We leave this as our future work because hashing kernel \cite{weinberger2009feature} used in \demonet\ is efficient to tackle large-scale multi-task learning problem.

\begin{figure*}
\centering
\includegraphics[width = 5in]{figures/framework}
\caption{Overview of our proposed \demonet\ framework (best seen in color). (b) and (c) represent the multi-task feature aggregation. The node representation in (d) can be used for node-level classification. For learning graph embedding, (e)-(g) provide the graph-level pooling method based on node degree distribution for learning graph representation.}
\label{framework}
\vspace{-3mm}
\end{figure*}

\subsection{Graph Representation Learning}
The goal of graph representation learning is to use a compact feature vector to represent the entire graph. To this end, we provide a degree-specific graph-level pooling scheme.

When graph neural networks are going deeper, node representation actually captures the higher-order topological information within its local neighborhood. By mapping the original graph to a sequence of graphs  where  denotes the original graph and  represents the graph after the  layer of feature aggregation (as shown in Figure \ref{framework}(e)-(g)), the  graph representation can be expressed as follow.

where  denotes the set of degree values in graph , and  is 1 when its two arguments are equal and 0 otherwise.

As discussed before, the node representation in  captures the topological information within -hop neighborhood. In order to consider all the subtrees' information, we concatenate the representation  from all graphs :




Next, we compare the degree-specific pooling scheme with existing graph-level pooling methods~\cite{atwood2016diffusion, xu2018powerful} and Weisfeiler-Lehman (WL) subtree kernel~\cite{shervashidze2011weisfeiler}.
We define a degree-specific WL kernel:

The corresponding mapping function is defined as:

where  is the degree of , and


As shown in \cite{lei2017deriving}, the non-linear activation function  has a mapping function  such that  for some mapping  constructed from .
By the following theorem (proven in Appendix), we show that our graph representation lies in a degree-specific Hilbert kernel space. 
\begin{theorem}
\label{T: kernel}
For a degree-specific Weisfeiler-Lehman kernel, the graph representation  in Eq. (12) belongs to the Reproducing Kernel Hilbert Space (RKHS) of kernel  where

\end{theorem}

The sum/mean based graph-level pooling approaches make the learned graph representation lie in the kernel as follow.

And WL subtree Kernel \cite{shervashidze2011weisfeiler} can be expressed as:

It is easy to see that: (1) WL subtree kernel cannot be applied to measure the graph similarity when nodes have the continuous attribute vectors. (2) Our graph-level representation lies in a degree-specific kernel space comparing Eq. (13) with (17), thus leading to explicitly preserving the degree-specific graph structure.

\subsection{Discussion}
We compare the proposed \demonet\ with some existing graph neural networks regarding the properties of graph convolution.

Lemma 4.3 shows that an injective aggregation function has three properties: {\em seed-oriented}, {\em degree-aware}, {\em order-free}. We summarize the properties of graph convolution of GCN \cite{kipf2016semi}, GAT \cite{velickovic2017graph}, GraphSAGE \cite{hamilton2017inductive}, and DCNN \cite{atwood2016diffusion} in Table \ref{propeties_comparison}. It can be seen that: (1) The existing graph neural networks do not have all the three properties. More importantly, none of them capture the degree-specific graph structures. (2) For graphSAGE, it is {\em order-free} when using mean or max aggregator. But graphSAGE with LTSM-aggregator is not {\em order-free} because it considers the node neighborhood as an ordered sequence. (3) Our proposed \demonet\ considers all the properties, and the {\em degree-aware} property in particular allows our model to explicitly preserve the neighborhood structures for node and graph representation learning. In addition, the time complexity of graph convolution of \demonet\ is linear with respect to the number of nodes and edges.

\begin{table}
\centering
\caption{Comparison of graph neural networks}\label{propeties_comparison}
\begin{tabular}{|l|c|c|c|}
\hline
Properties & {\em seed-oriented} & {\em degree-aware}  & {\em order-free} \\ \hline
GCN \cite{kipf2016semi} &  &  & \checkmark \\ \hline
GAT \cite{velickovic2017graph} & \checkmark &  & \checkmark \\ \hline
GraphSAGE \cite{hamilton2017inductive} & \checkmark &  & --- \\ \hline
DCNN \cite{atwood2016diffusion} &  &  & \checkmark \\ \hline
\demonet & \checkmark & \checkmark & \checkmark \\ \hline
\end{tabular}
\vspace{-3mm}
\end{table}




\section{Experimental Results}
In this section, we present the experimental results on real networks. In particular, we  focus on answering the following questions: \\
\textbf{Q1:} Is the proposed \demonet\ algorithm effective on node classification compared to the state-of-the-art graph neural networks? \\
\textbf{Q2:} How does the proposed \demonet\ perform on identifying graph structure compared to structure-aware embedding approaches?\\
\textbf{Q3:} How does the proposed \demonet\ with degree-specific graph-level pooling perform on graph classification task? \\
\textbf{Q4:} Is the proposed degree-specific graph convolution of \demonet\ efficient on learning node representation?

\subsection{Experiment Setup}
\textbf{Data Sets:} We use seven node classification data sets, including four social networks and three air-traffic networks. Facebook, Wiki-Vote \cite{snapnets},
BlogCatalog and Flickr\footnote{\url{http://people.tamu.edu/~xhuang/Code.html}} are social networks.
The posted keywords or tags in BlogCatalog and Flickr networks are used as node attribute information. There are three air-traffic networks \cite{ribeiro2017struc2vec}: Brazil, Europe and USA, where each node corresponds to an airport and edge indicates the existence of commercial flights between the airports. Their class labels are assigned based on the level of activity measured by flights or people that passed the airports. Data statistics are summarized in Table \ref{node_datasets}.
For those networks without node attributes, we use the one-hot encoding of node degrees. In BlogCatalog, Flickr and other air-traffic networks, node class labels are available. In Facebook and Wiki-Vote, we use the degree-induced class labels by labeling the node according to its degree value.

In addition, we use four bioinformatics networks to evaluate the model performance on graph classification, including MUTAG, PTC, PROTEINS and ENZYMES\footnote{\url{https://ls11-www.cs.tu-dortmund.de/staff/morris/graphkerneldatasets}} where the nodes are associated with categorical input features. The detailed statistics for these bioinformatics networks are summarized in Table \ref{graph_datasets}.

\noindent\textbf{Model Configuration: } We adopt two hidden layers followed by the softmax activation layer in \demonet, where the proposed multi-task feature learning schemes in Eq. (7) and (10) are applied to each hidden layer for neighborhood aggregation (termed as {\demonet (weight)} and {\demonet (hash)}, respectively). In addition, we apply Adam optimizer \cite{kingma2014adam} with the learning rate 0.005 on the cross-entropy loss to train our models. To prevent our models from over-fitting, we adopt the dropout \cite{srivastava2014dropout} with  and  regularization with . The hidden layer size of neural units is set as 64. An early stopping strategy with a patience of 100 epochs on validation set is applied in our experiments.

\noindent\textbf{Baseline Methods: } The baseline methods used in our experiments are given below: (1) node-level graph neural networks: GCN \cite{kipf2016semi}, GCN\_cheby \cite{kipf2016semi}, GraphSAGE (mean aggregator) \cite{hamilton2017inductive}, Union \cite{li2018deeper}, Intersection \cite{li2018deeper} and GAT \cite{velickovic2017graph}; (2) node-level structure-aware embedding approaches: RolX \cite{henderson2012rolx}, struc2vec \cite{ribeiro2017struc2vec} and GraphWAVE \cite{donnat2018learning}; (3) graph-level graph neural networks: DCNN \cite{atwood2016diffusion}, PATCHY-SAN \cite{niepert2016learning} and DIFFPOOL \cite{ying2018hierarchical}; (4) deep graph kernel: DeepWL \cite{yanardag2015deep}. In our experiments, all the baseline models used the default hyperparameters suggested in the original papers.

All our experiments are performed on a Windows machine with four 3.60GHz Intel Cores and 32GB RAM. The source code will be available at \url{https://github.com/jwu4sml/DEMO-Net}.

\begin{table}
\caption{Data sets for node classification}
\label{node_datasets}
\small
\begin{tabular}{|l|c|c|c|c|}
\hline
\multicolumn{1}{|c|}{Data sets} & \# nodes & \# edges & \# classes & \# attributes \\\hline
Facebook & 4039 & 88234 & 4 & - \\ \hline
Wiki-Vote & 7115 & 103689 & 4 & - \\ \hline
BlogCatalog                   & 5196    & 171743  & 6         & 8189         \\\hline
Flickr                        & 7575    & 239738  & 9         & 12047        \\\hline
Brazil                        & 131     & 1038    & 4         & -            \\\hline
Europe                        & 399     & 5995   & 4         & -            \\\hline
USA                           & 1190    & 13599   & 4         & -           \\ \hline
\end{tabular}
\vspace{-3mm}
\end{table}

\begin{table}
\caption{Data sets for graph classification}
\label{graph_datasets}
\small
\begin{tabular}{|l|c|c|c|c|}
\hline
\multicolumn{1}{|c|}{Data sets} & \# graphs & \# classes & Avg \# nodes & \# attributes \\ \hline
MUTAG                           & 188      & 2         & 17.9        & 7            \\ \hline
PTC                             & 344      & 2         & 25.5        & 19           \\ \hline
PROTEINS                        & 1113     & 2         & 39.1        & 3            \\ \hline
ENZYMES                         & 600      & 6         & 32.6        & 3            \\ \hline
\end{tabular}
\vspace{-3mm}

\end{table}

\subsection{Node Classification}
For a fair comparison of different architectures \cite{shchur2018pitfalls}, we use different train/validation/test splits of the networks on node classification.
For social networks, we randomly choose 10\% and 20\% of the graph nodes as the training and validation set, respectively, and the rest as the test set. For air-traffic networks, the training, validation and test sets are randomly assigned with equal number of nodes. We run 10 times and report the mean accuracy with the standard variance for performance comparison. As shown in Table \ref{tab:node_classification}, we report the classification results on the real networks where the best results are indicated in bold. It can be observed that the proposed \demonet models significantly outperform other graph neural networks (answering \textbf{Q1}). In particular, our \demonet\ models are at least 10\% higher on mean accuracy over baseline methods. One explanation is that baseline methods focus on preserving the node proximity by roughly mixing a node with its neighbors, whereas our proposed \demonet\ models capture the degree-specific structure to distinguish the structural roles of nodes in the networks.

We also evaluate the performance of our models against three structure-aware embedding approaches: RolX, struc2vec and GraphWAVE. All of them are unsupervised embedding approaches identifying the structural roles of nodes in the networks. Following \cite{ribeiro2017struc2vec}, we use the one-vs-rest logistic regression with L2 regularization to train a classifier for node representations learned by baseline methods. Here we consider using different train-test splits where the percentage of training nodes ranges from 10\% to 90\% and the rest is used for testing. The experimental results on the Brazil and USA air-traffic networks are provided in Figure \ref{struc_indentity}. We observe that our proposed \demonet\ models outperform the comparison methods across all the data sets (answering \textbf{Q2}). Besides, the structure roles identified by those baselines only represent the local graph structure without considering node attributes. Instead, both topological information and node attributes are captured in our \demonet\ models when learning node representation.

\begin{table*}
\centering
\caption{Node-level classification accuracy (mean  standard variance) on the social and air-traffic networks}
\begin{tabular}{|l|c|c|c|c|c|c|c|}
\hline
\multirow{2}{*}{}     & \multicolumn{4}{c|}{Social networks} & \multicolumn{3}{c|}{Air-traffic networks}   \\ \cline{2-8} 
                    & Facebook     &  Wiki-Vote & BlogCatalog       & Flickr           & Brazil          & Europe          & USA \\ \hline
GraphSAGE \cite{hamilton2017inductive} & 0.389 \textpm 0.019 & 0.245 \textpm 0.000 & 0.828 \textpm 0.007& 0.641 \textpm 0.006& 0.404 \textpm 0.035 & 0.272 \textpm 0.022& 0.316 \textpm 0.022\\ \hline
GCN~\cite{kipf2016semi}       & 0.575 \textpm 0.013 & 0.329 \textpm 0.029 & 0.720 \textpm 0.013   & 0.546 \textpm 0.019  & 0.432 \textpm 0.064 & 0.371 \textpm 0.046 &  0.432 \textpm 0.022   \\ \hline
GCN\_cheby~\cite{kipf2016semi}    &     0.646 \textpm 0.012        & 0.495 \textpm 0.016      & 0.686 \textpm 0.037   &   0.479 \textpm 0.023               & 0.516 \textpm 0.070 & 0.460 \textpm 0.038 &  0.526 \textpm 0.045   \\ \hline
{Union}~\cite{li2018deeper}    & 0.600 \textpm 0.000       &  0.463 \textpm 0.000   & 0.730 \textpm 0.000   & 0.566 \textpm 0.000  & 0.466 \textpm 0.006 & 0.418 \textpm 0.002 & 0.582 \textpm 0.000    \\ \hline
{Intersection}~\cite{li2018deeper}  & 0.598 \textpm 0.000 & 0.462 \textpm 0.000     & 0.725 \textpm 0.000   & 0.557 \textpm 0.000  & 0.459 \textpm 0.003 & 0.443 \textpm 0.002 & 0.573 \textpm 0.000    \\ \hline
GAT~\cite{velickovic2017graph}      &   0.570 \textpm 0.036      &     0.594 \textpm 0.070              &   0.663 \textpm 0.000                &   0.359 \textpm 0.000               & 0.382 \textpm 0.126 & 0.424 \textpm 0.073 &  0.585 \textpm 0.021   \\ \hline
\hline
\demonet (hash)                 &  0.887 \textpm 0.020    &  0.997 \textpm 0.000     & 0.849 \textpm 0.006                  &    \textbf{0.678 \textpm 0.010}              & \textbf{0.614 \textpm 0.069} & \textbf{0.479 \textpm 0.064} &  \textbf{0.659 \textpm 0.020}   \\ \hline
\demonet (weight)   & \textbf{0.919 \textpm 0.003} & \textbf{0.998 \textpm 0.000} &    \textbf{0.849 \textpm 0.000}   & 0.656 \textpm 0.000  & 0.543 \textpm 0.034 & 0.459 \textpm 0.025 & 0.647 \textpm 0.021    \\ \hline
\end{tabular}
\label{tab:node_classification}
\end{table*}

\begin{figure}[t]
\includegraphics[width = 3.35in]{figures/struc_indentity.pdf}
\caption{Node-level classification accuracy on the Brazil and USA air-traffic networks using different train/test splits}
\label{struc_indentity}
\vspace{-4mm}
\end{figure}

\subsection{Graph Classification}
We use four public graph classification benchmarks to evaluate the proposed \demonet\ models with the degree-specific graph-level pooling scheme. DCNN \cite{atwood2016diffusion}, PATCHY-SAN \cite{niepert2016learning} and DIFFPOOL \cite{ying2018hierarchical} adopted the end-to-end training architectures for supervised graph classification. For unsupervised graph kernel method DeepWL \cite{yanardag2015deep}, we use the one-vs-rest logistic regression with L2 regularization to train a supervised classifier for graph classification. We also consider our model variants (denoted as \demonet\_m(hash) and \demonet\_m(weight) respectively) which replace the proposed degree-specific graph-level pooling with mean-pooling scheme \cite{atwood2016diffusion}. The input graphs are randomly assigned to the training, validation, or test set where each set has the same number of nodes.

The graph classification results are shown in Table \ref{tab:graph_classification} where the best results are indicated in bold. It is observed that (1) compared to the existing mean-pooling method, the proposed degree-specific pooling method improves the model performance in most cases, which is consistent with our analysis in Section 4.2; (2) the classification results of our \demonet\ models are comparable to other graph neural networks and graph kernel method (answering \textbf{Q3}). Moreover, on MUTAG and ENZYMES data sets, our proposed \demonet (weight) outperforms the baseline methods. One explanation might be that the graph representation generated by \demonet\ explicitly preserves the degree-specific graph structure information.

\begin{table}
    \centering
    \caption{Graph-level classification on the real networks}
    \small
    \begin{tabular}{|l|c|c|c|c|}
    \hline
         &  MUTAG & PTC  & PROTEINS & ENZYMES   \\ \hline
         DeepWL~\cite{yanardag2015deep} & 0.733 & 0.537  & 0.680  & 0.210   \\ \hline
         DCNN~\cite{atwood2016diffusion}   & 0.670  & 0.572 & 0.579   & 0.160  \\ \hline
         PATCHY-SAN~\cite{niepert2016learning} & 0.795  & 0.568  & 0.714  & 0.170   \\ \hline
         DIFFPOOL~\cite{ying2018hierarchical} & 0.663  & 0.251 & \textbf{0.733 } & 0.184  \\ \hline
         \hline
         \demonet\_m(hash)   & 0.760  & \textbf{0.586}  & 0.617  & 0.236  \\ \hline
         \demonet\_m(weight)   & 0.798  & 0.550  & 0.616 &  0.251 \\ \hline
         \demonet (hash)   & 0.771  & 0.563  & 0.705 & 0.251  \\ \hline
         \demonet (weight) & \textbf{0.814} & 0.572 & 0.708  & \textbf{0.272} \\ \hline
    \end{tabular}
    \label{tab:graph_classification}
    \vspace{-3mm}
\end{table}





\subsection{Efficiency Analysis}
It is easy to show that the time complexity of each layer in our proposed \demonet (hash) model is  where  and  are the number of nodes and edges in the graph, respectively,  and  are the dimensionalities of input and output features at each layer, respectively,  is the number of tasks (degree values) in the graph, and  is the hashing dimension. By observing that  in the networks, its time complexity would be , which is on par with GCN and GAT models. Similarly, we can show that the time complexity of each layer in \demonet(weight) is . When  and , it also scales linearly with respect to the number of nodes and edges.

Following \cite{kipf2016semi}, we report the running time (measured in seconds wall-clock time) per epoch (including forward pass, cross-entropy calculation, backward pass) on a synthetic network assigning  edges uniformly at random. As shown in Figure \ref{running_time}, we observe that (answering \textbf{Q4}) (1) the wall-clock time of our proposed \demonet\ model is linear with respect to the number of nodes; (2) our models are much more efficient than GAT on node classification task.

\begin{figure}
\includegraphics[width = 3.35in]{figures/running_time.pdf}
\caption{Running time per epoch (best seen in color)}
\label{running_time}
\vspace{-3mm}
\end{figure}

\section{Conclusions}
In this paper, we focus on building a degree-specific graph neural network for both node and graph classification. We start by analyzing the limitations of the existing graph neural networks from the perspective of Weisfeiler-Lehman graph isomorphism test. Furthermore, it is observed that the graph convolution should have the following properties: {\em seed-oriented}, {\em degree-aware}, {\em order-free}. To this end, we propose a generic graph neural network model named \demonet\, which formulates the feature aggregation into a multi-task learning problem according to nodes' degree values. In addition, we also present a novel graph-level pooling method for learning graph representations provably lying in a degree-specific Hilbert kernel space. The extensive experiments on real networks demonstrate the effectiveness of our \demonet\ algorithm.















\begin{acks}
This work is supported by the United States Air Force and DARPA under contract number FA8750-17-C-0153, National Science Foundation under Grant No. IIS-1552654, Grant No.
IIS-1813464 and Grant No. CNS-1629888, the U.S. Department of Homeland Security
under Grant Award Number 17STQAC00001-02-00, and an IBM Faculty Award. The views and conclusions are those of the authors and should not be interpreted as representing
the official policies of the funding agencies or the government.
\end{acks} 
\bibliographystyle{ACM-Reference-Format}
\bibliography{sample-bibliography}
\clearpage
\appendix
\section{Appendix for Reproducibility}
To better reproduce the experimental results, we provide additional details about the algorithms.

{\bf Proof of Theorem~\ref{T: existence}}.
Theorem~\ref{T: existence} says that there exist mapping functions  and  such that for any two subtrees in , the function  defined in Eq. (5) maps them to different feature vectors if they are not structurally identical.
\begin{proof}
Let  denote the seed set in  and  the maximum degree values plus one. Becuase  is countable, there exists an injective function  that maps each subtree from  to an unique natural number. It can be observed that  can be divided into  disjoint sets: , , , .

There exists an injective function  that maps each seed from  to an unique natural number in . Let  denote the neighbor set consisting of the seeds' neighbors when their degree values are equal to . Because  is countable, all the subsets  are countable. There exists the injective, symmetric function  that maps each element from  to an unique real number in . Moreover, there is a function  that maps each subtree from  to an unique feature vector in  when . Please note that the structurally identical subtrees would be considered the same one when the degree-specific function  is symmetric.

It is easy to construct an injective function . Based on the properties of injective function,  will be injective function that maps any two subtrees in  to different feature vectors in  if they are not structurally identical, which completes the proof.
\end{proof}

\noindent{\bf Proof of Theorem~\ref{T: kernel}}.
Theorem~\ref{T: kernel} says that the graph representation  learned in Eq. (12) belongs to the Reproducing Kernel Hilbert Space (RKHS) of kernel .
\begin{proof}
Let  denote the feature vector of graph  for nodes with degree value . Let  denote the  element of . Our graph convolution (feature aggregation) function can be written as:

where  represents the degree-specific parameters, and more specifically,  for degree-specific weight matrix in Eq. (7) and . Because we use the concatenation operator  to combine the learned features of seed and its neighborhood, it holds that  lies in \textbf{either} seed's feature  \textbf{or} , but not both.

Let  denote the  row from . To show our results, we construct a -regular "reference graph"  which has the same nodes as the input graph  (i.e., ). Its degree value  is  and each node in "reference graph" is associated with the same feature vector . Then when  lies in the seed's feature , we have:


The lemma 1 in \cite{lei2017deriving} holds that for activation functions , there exists kernel functions  and the underlying mapping  such that  for some mapping function  constructed from . Therefore, we have:

where  is the composition of  and , and . And  is the "reference graph" constructed from model parameters and activation function.

Let  denote the  row from  with . Similarly, we construct a -regular "reference graph"  which has the same nodes as the input graph  with degree value . Each node in this "reference graph" is associated with the same feature vector .
when when  lies in the neighborhood's feature , we have:

Please notice that in this case, node features are assumed to be the sum of neighborhood features. And moreover, it can be written as:

where  is the "reference graph" constructed from model parameters and activation function.
Therefore, the graph representation  belongs to the RKHS of kernel , which completes the proof.
\end{proof}

















 
\end{document}
