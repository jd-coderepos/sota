\documentclass{article}





\usepackage[final,nonatbib]{neurips_2019}



\usepackage{amssymb}
\usepackage[utf8]{inputenc} \usepackage[T1]{fontenc}    \usepackage{hyperref}       \usepackage{url}            \usepackage{booktabs}       \usepackage{amsfonts}       \usepackage{nicefrac}       \usepackage{microtype}      \usepackage{mathrsfs}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage[tbtags]{amsmath}
\usepackage{mathrsfs}
\usepackage{graphicx}
\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage{subfigure}
\usepackage{listings}
\usepackage{booktabs}
\usepackage{appendix}
\usepackage{multirow}
\usepackage{color}
\newtheorem{theorem}{Theorem}
\newtheorem{lemma}{Lemma}
\newtheorem{proposition}{Proposition}

\usepackage{titlesec}
\usepackage{titletoc}
\usepackage{xcolor}
\usepackage{pythonhighlight}

\titlecontents{section}
[1.5cm]
{\bf }{\contentslabel{2.5em}}{}{\titlerule*[0.5pc]{}\contentspage\hspace*{2cm}}



\title{Meta-Weight-Net: Learning an Explicit Mapping \\For Sample Weighting}











\author{Jun Shu\\
	Xi'an Jiaotong University\\
	\texttt{xjtushujun@gmail.com} \\
\And
	Qi Xie \\
	Xi'an Jiaotong University\\
	\texttt{xq.liwu@stu.xjtu.edu.cn} \\
	\And
	Lixuan Yi \\
	Xi'an Jiaotong University\\
	\texttt{yilixuan@stu.xjtu.edu.cn} \\
	\And
	Qian Zhao \\
	Xi'an Jiaotong University\\
	\texttt{timmy.zhaoqian@mail.xjtu.edu.cn} \\
	\And
	Sanping Zhou \\
	Xi'an Jiaotong University\\
	\texttt{sanpingzhou@stu.xjtu.edu.cn} \\
	\And
	Zongben Xu \\
	Xi'an Jiaotong University\\
	\texttt{zbxu@mail.xjtu.edu.cn} \\
	\And
	Deyu Meng\thanks{Corresponding author.}\\
	Xi'an Jiaotong University\\
	\texttt{dymeng@mail.xjtu.edu.cn} \\
}





\begin{document}
	\maketitle
	\vspace{0mm}
	\begin{abstract}
		Current deep neural networks (DNNs) can easily overfit to biased training data with corrupted labels or class imbalance. Sample re-weighting strategy is commonly used to alleviate this issue by designing a weighting function mapping from training loss to sample weight, and then iterating between weight recalculating and classifier updating. Current approaches, however, need manually pre-specify the weighting function as well as its additional hyper-parameters. It makes them fairly hard to be generally applied in practice due to the significant variation of proper weighting schemes relying on the investigated problem and training data. To address this issue, we propose a method capable of adaptively learning an explicit weighting function directly from data. The weighting function is an MLP with one hidden layer, constituting a universal approximator to almost any continuous functions, making the method able to fit a wide range of weighting functions including those assumed in conventional research. Guided by a small amount of unbiased meta-data, the parameters of the weighting function can be finely updated simultaneously with the learning process of the classifiers. Synthetic and real experiments substantiate the capability of our method for achieving proper weighting functions in class imbalance and noisy label cases, fully complying with the common settings in traditional methods, and more complicated scenarios beyond conventional cases. This naturally leads to its better accuracy than other state-of-the-art methods. Source code is available at \url{https://github.com/xjtushujun/meta-weight-net}.
	\end{abstract}\vspace{0mm}
	\setcounter{footnote}{0}
	\section{Introduction}
	\label{introduction}
	DNNs have recently obtained impressive good performance on various applications due to their powerful capacity for modeling complex input patterns. However, DNNs can easily overfit to biased training data\footnote{We call the training data biased when they are generated from a joint sample-label distribution deviating from the distribution of evaluation/test set\cite{ren2018learning}.}, like those containing corrupted labels \cite{zhang2016understanding} or with class imbalance\cite{he2008learning}, leading to their poor performance in generalization in such cases. This robust deep learning issue has been theoretically illustrated in multiple literatures~\cite{neyshabur2017exploring,arpit2017closer,kawaguchi2017generalization,novak2018sensitivity,galar2012review,buda2018systematic}.
	


	In practice, however, such biased training data are commonly encountered. For instance, practically collected training samples always contain corrupted labels~\cite{sukhbaatar2014learning,azadi2015auxiliary,goldberger2016training,li2017learning,vahdat2017toward,hendrycks2018using,han2018co,zhang2018generalized}. A typical example is a dataset roughly collected from a crowdsourcing system \cite{bi2014learning} or search engines \cite{liang2016learning,zhuang2017attend}, which would possibly yield a large amount of noisy labels.
	Another popular type of biased training data is those with class imbalance. Real-world datasets are usually depicted as skewed distributions, with a long-tailed configuration. A few classes account for most of the data, while most classes are under-represented. Effective learning with these biased training data, which is regarded to be biased from evaluation/test ones, is thus an important while challenging issue in machine learning~\cite{ren2018learning,jiang2018mentornet}.
	
	Sample reweighting approach is a commonly used strategy against this robust learning issue. The main methodology is to design a weighting function mapping from training loss to sample weight (with hyper-parameters), and then iterates between calculating weights from current training loss values and minimizing weighted training loss for classifier updating. There exist two entirely contradictive ideas for constructing such a loss-weight mapping. One makes the function monotonically increasing as depicted in Fig. \ref{fig1a}, i.e., enforce the learning to more emphasize samples with larger loss values since they are more like to be uncertain hard samples located on the classification boundary. Typical methods of this category include AdaBoost \cite{freund1997decision,sun2007cost}, hard negative mining \cite{malisiewicz2011ensemble} and focal loss \cite{lin2018focal}. This sample weighting manner is known to be necessary for class imbalance problems, since it can prioritize the minority class with relatively higher training losses.
	
	On the contrary, the other methodology sets the weighting function as monotonically decreasing, as shown in Fig. \ref{fig1b}, to take samples with smaller loss values as more important ones. The rationality lies on that these samples are more likely to be high-confident ones with clean labels. Typical methods include self-paced learning(SPL) \cite{kumar2010self}, iterative reweighting \cite{fernando2003reweight,zhang2018generalized} and multiple variants~\cite{jiang2014easy,jiang2014self,wang2017robust}. This weighting strategy has been especially used in noisy label cases, since it inclines to suppress the effects of samples with extremely large loss values, possibly with corrupted incorrect labels.
	
	\begin{figure}[t]
		\centering
\subfigcapskip=-2mm
		\subfigure[Weight function in focal loss]{
			\label{fig1a} \includegraphics[width=0.30\textwidth]{focal.pdf}} \ \ \
		\subfigure[Weight function in SPL]{
			\label{fig1b} \includegraphics[width=0.30\textwidth]{self.pdf}} \ \ \
		\subfigure[Meta-Weight-Net architecture]{
			\label{fig1c} \includegraphics[width=0.30\textwidth]{weightnet.pdf}} \ \ \
		\\ \vspace{-0.2cm}
		\subfigure[MW-Net function learned in class imbalance case]{
			\label{fig1d} \includegraphics[width=0.30\textwidth]{classimbalance.pdf}}\ \ \
		\centering
		\subfigure[MW-Net function learned in corrupter labels case]{
			\label{fig1e} \includegraphics[width=0.30\textwidth]{corrupted.pdf}}\ \ \
		\centering
		\subfigure[MW-Net function learned in \ real Clothing1M dataset]{
			\label{fig1f} \includegraphics[width=0.30\textwidth]{clothing1M.pdf}} \vspace{-0.3cm}
		\caption{(a)-(b) weight functions set in focal loss and self-paced learning (SPL). (c) Meta-Weighting-Net architecture. (d)-(f) Meta-Weighting-Net functions learned in class imbalance (imbalanced factor 100), noisy label (40\% uniform noise), and real dataset, respectively, by our method.}\label{ss} 
		\vspace{0cm}
	\end{figure}
	
	Although these sample reweighting methods help improve the robustness of a learning algorithm on biased training samples, they still have evident deficiencies in practice. On the one hand, current methods need to manually set a specific form of weighting function based on certain assumptions on training data. This, however, tends to be infeasible when we know little knowledge underlying data or the label conditions are too complicated, like the case that the training set is both imbalanced and noisy. On the other hand, even when we specify certain weighting schemes, like focal loss~\cite{lin2018focal} or SPL~\cite{kumar2010self}, they inevitably involve hyper-parameters, like focusing parameter in the former and age parameter in the latter, to be manually preset or tuned by cross-validation. This tends to further raise their application difficulty and reduce their performance stability in real problems.
	
	To alleviate the aforementioned issue, this paper presents an adaptive sample weighting strategy to automatically learn an explicit weighting function from data. The main idea is to parameterize the weighting function as an MLP (multilayer perceptron) network with only one hidden layer (as shown in Fig. \ref{fig1c}), called \textbf{\emph{Meta-Weight-Net}}, which is theoretically a universal approximator for almost any continuous function~\cite{csaji2001approximation}, and then use a small unbiased validation set (meta-data) to guide the training of all its parameters. The explicit form of the weighting function can be finally attained specifically suitable to the learning task.
	
	In summary, this paper makes the following three-fold contributions:\vspace{0mm}
	
	1) We propose to automatically learn an explicit loss-weight function, parameterized by an MLP from data in a meta-learning manner. Due to the universal approximation capability of this weight net, it can finely fit a wide range of weighting functions including those used in conventional research.\vspace{0mm}
	
	2) Experiments verify that the weighting functions learned by our method highly comply with manually preset weighting manners used in tradition in different training data biases, like class imbalance and noisy label cases as shown in Fig. \ref{fig1d} and \ref{fig1e}), respectively. This shows that the weighting scheme learned by the proposed method inclines to help reveal deeper understanding for data bias insights, especially in complicated bias cases where the extracted weighting function is with complex tendencies (as shown in Fig. \ref{fig1f}).\vspace{0mm}
	
	3) The insights of why the proposed method works can be well interpreted. Particularly, the updating equation for Meta-Weight-Net parameters can be explained by that the sample weights of those samples better complying with the meta-data knowledge will be improved, while those violating such meta-knowledge will be suppressed. This tallies with our common sense on the problem: we should reduce the influence of those highly biased ones, while emphasize those unbiased ones.
	
	The paper is organized as follows. Section \ref{section2} presents the proposed meta-learning method as well as the detailed algorithm and analysis of its convergence property. Section \ref{section3} discusses related work. Section \ref{section4} demonstrates experimental results and the conclusion is finally made.\vspace{0mm}
	
	
	
	\section{The Proposed Meta-Weight-Net Learning Method}\label{section2}


\subsection{The Meta-learning Objective}\vspace{-1mm}
	
	Consider a classification problem with the training set ,  where  denotes the -th sample,  is the label vector over  classes, and  is the number of the entire training data.  denotes the classifier, and  denotes its parameters. In current applications,  is always set as a DNN. We thus also adopt DNN, and call it the classifier network for convenience in the following.
	
	Generally, the optimal classifier parameter  can be extracted by minimizing the loss  \  calculated on the training set. For notation convenience, we denote that .
	In the presence of biased training data, sample re-weighting methods enhance the robustness of training by imposing weight  on the -th sample loss, where  denotes the weight net, and  represents the parameters contained in it. The optimal parameter  is calculated by minimizing the following weighted loss: \vspace{-1.5mm}
	
	\textbf{Meta-Weight-Net:} Our method aims to automatically learn the hyper-parameters  in a meta-learning manner. To this aim, we formulate  as a MLP network with only one hidden layer containing 100 nodes, as shown in Fig. \ref{fig1c}. We call this weight net as \textbf{\emph{Meta-Weight-Net}} or \textbf{\emph{MW-Net}} for easy reference. Each hidden node is with ReLU activation function, and the output is with the Sigmoid activation function, to guarantee the output located in the interval of . Albeit simple, this net is known as a universal approximator for almost any continuous function~\cite{csaji2001approximation}, and thus can fit a wide range of weighting functions including those used in conventional research.
	
	\textbf{Meta learning process.}
	The parameters contained in MW-Net can be optimized by using the meta learning idea \cite{wu2018learning,andrychowicz2016learning,dehghani2017learning,franceschi2018bilevel}.
	Specifically, assume that we have a small amount unbiased meta-data set (i.e., with clean labels and balanced data distribution) , representing the meta-knowledge of ground-truth sample-label distribution, where  is the number of meta-samples and . The optimal parameter  can be obtained by minimizing the following meta-loss: \vspace{-2mm}
	  
	where  is calculated on meta-data. \vspace{-2mm}
	
	\subsection{The Meta-Weight-Net Learning Method}  
	Calculating the optimal  and  require two nested loops of optimization. Here we adopt an online strategy to update  and  through a single optimization loop, respectively, to guarantee the efficiency of the algorithm.
	
	
	\textbf{Formulating learning manner of classifier network.}
	As general network training tricks, we employ SGD to optimize the training loss (\ref{eq3}).
	Specifically, in each iteration of training, a mini-batch of training samples  is sampled, where  is the mini-batch size. Then the updating equation of the classifier network parameter can be formulated by moving the current  along the descent direction of the objective loss in Eq. (\ref{eq3}) on a mini-batch training data:   \vspace{-4mm}
	
	where  is the step size. 
	
	
	\begin{figure*}[t]
\includegraphics[width=\textwidth]{flowchart.pdf}\\ \vspace{-4mm}
		\caption{Main flowchart of the proposed MW-Net Learning algorithm (steps 5-7 in Algorithm \ref{alg:example}).}\label{fig1}  \vspace{0mm}
	\end{figure*}
	
	\begin{algorithm}[h]
		\vspace{0mm}
		\renewcommand{\algorithmicrequire}{\textbf{Input:}}
		\renewcommand{\algorithmicensure}{\textbf{Output:}}
		\caption{The MW-Net Learning Algorithm}
		\label{alg:example}
		\begin{algorithmic}[1]  \small
\REQUIRE  Training data , meta-data set , batch size , max iterations .
			\ENSURE  Classifier network parameter 
\STATE Initialize classifier network parameter  and Meta-Weight-Net parameter .
			\FOR{ {\bfseries to} }
			\STATE  SampleMiniBatch().
			\STATE  SampleMiniBatch().
			\STATE Formulate the classifier learning function  by Eq. (\ref{eq6}).
			\STATE Update  by Eq. (\ref{eq7}).
			\STATE Update  by Eq. (\ref{eq8}).
			\ENDFOR
\end{algorithmic}
	\end{algorithm}
	\vspace{2mm}
	
	\textbf{Updating parameters of Meta-Weight-Net:} After receiving the feedback of the classifier network parameter updating formulation  \footnote{Notice that  here is a variable instead of a quantity, which makes  a function of  and the gradient in Eq. (\ref{eq7}) be able to be computed.}from the Eq .(\ref{eq6}), the parameter  of the Meta-Weight-Net can then be readily updated guided by Eq. (\ref{eq4}), i.e., moving the current parameter  along the objective gradient of Eq. (\ref{eq4}) calculated on the meta-data:

	\vspace{-2mm}
	where  is the step size.\vspace{2mm}
	
	
	
	
	\textbf{Updating parameters of classifier network:} Then, the updated  is employed to ameliorate the parameter  of the classifier network, i.e., \vspace{-6mm}
	
	
	
	
	The MW-Net Learning algorithm can then be summarized in Algorithm \ref{alg:example}, and Fig. \ref{fig1} illustrates its main implementation process (steps 5-7).
	All computations of gradients can be efficiently implemented by automatic differentiation techniques and generalized to any deep learning architectures of classifier network. The algorithm can be easily implemented using popular deep learning frameworks like PyTorch \cite{paszke2017automatic}. It is easy to see that both the classifier network and the MW-Net gradually ameliorate their parameters during the learning process based on their values calculated in the last step, and the weights can thus be updated in a stable manner, as clearly shown in Fig. \ref{curve}.
	
	
	
	
	\subsection{Analysis on the Weighting Scheme of Meta-Weight-Net}
	
	The computation of Eq. (\ref{eq7}) by backpropagation can be rewritten as\footnote{Derivation can be found in supplementary materials.}:
	
	where .
	Neglecting the coefficient , it is easy to see that each term in the sum orients to the ascend gradient of the weight function . , the coefficient imposed on the -th gradient term, represents the similarity between the gradient of the -th training sample computed on training loss and the average gradient of the mini-batch meta data calculated on meta loss. That means if the learning gradient of a training sample is similar to that of the meta samples, then it will be considered as beneficial for getting right results and its weight tends to be more possibly increased. Conversely, the weight of the sample inclines to be suppressed. This understanding is consistent with why well-known MAML works \cite{finn2017model,nichol2018reptile,eshratifar2018gradient}.
	
	
	\subsection{Convergence of the MW-Net Learning algorithm}
	Our algorithm involves optimization of two-level objectives, and therefore we show theoretically that our method converges to the critical points of both the meta and training loss function under some mild conditions in Theorem \ref{th1} and \ref{th2}, respectively. The proof is listed in the supplementary material.
	\begin{theorem} \label{th1}
		Suppose the loss function  is Lipschitz smooth with constant , and  is differential with a -bounded gradient and twice differential with its Hessian bounded by , and the loss function  have -bounded gradients with respect to training/meta data. Let the learning rate  satisfies , for some , such that , and  is a monotone descent sequence,  for some , such that  and . Then the proposed algorithm can achieve  in  steps. More specifically,
		
		where  is some constant independent of the convergence process, and  is the variance of drawing uniformly mini-batch sample at random.
	\end{theorem}
	
	\begin{theorem}\label{th2}
		The condions in Theorem \ref{th1} hold, then we have:
		
	\end{theorem}
	\vspace{0mm}
	\section{Related Work} \label{section3}\vspace{0mm}


	\textbf{Sample Weighting Methods.}
	The idea of reweighting examples can be dated back to dataset resampling \cite{chawla2002smote,dong2017class} or instance re-weight \cite{zadrozny2004learning}, which pre-evaluates the sample weights as a pre-processing step by using certain prior knowledge on the task or data. To make the sample weights fit data more flexibly, more recent researchers focused on pre-designing a weighting function mapping from training loss to sample weight, and dynamically ameliorate weights during training process \cite{elkan2001foundations,khan2018cost}. There are mainly two manners to design the weighting function. One is to make it monotonically increasing, specifically effective in class imbalance case. Typical methods include the boosting algorithm (like AdaBoost \cite{freund1997decision}) and multiple of its variations \cite{johnson2019survey},
hard example mining \cite{malisiewicz2011ensemble} and focal loss \cite{lin2018focal}, which impose larger weights to ones with larger loss values.
On the contrary, another series of methods specify the weighting function as monotonically decreasing, especially used in noisy label cases. For example, SPL \cite{kumar2010self} and its extensions \cite{jiang2014easy,jiang2014self}, iterative reweighting ~\cite{fernando2003reweight,zhang2018generalized} and other recent work \cite{chang2017active,wang2017robust}, pay more focus on easy samples with smaller losses.
The limitation of these methods are that they all need to manually pre-specify the form of weighting function as well as their hyper-parameters, raising their difficulty to be readily used in real applications.
	
	\textbf{Meta Learning Methods.} Inspired by meta-learning developments \cite{lake2015human,shu2018small,ravi2016optimization,finn2017model,snell2017prototypical}, recently some methods were proposed to learn an adaptive weighting scheme from data to make the learning more automatic and reliable.
	Typical methods along this line include FWL \cite{dehghani2017fidelity}, learning to teach \cite{fan2018learning,wu2018learning} and MentorNet \cite{jiang2018mentornet} methods, whose weight functions are designed as a Bayesian function approximator, a DNN with attention mechanism, a bidirectional LSTM network, respectively. Instead of only taking loss values as inputs as classical methods, the weighting functions they used (i.e., the meta-learner), however, are with much more complex forms and required to input complicated information (like sample features). This makes them not only hard to succeed good properties possessed by traditional methods, but also to be easily reproduced by general users. \vspace{0mm}
	
	A closely related method, called L2RW \cite{ren2018learning}, adopts a similar meta-learning mechanism compared with ours. The major difference is that the weights are implicitly learned there, without an explicit weighting function. This, however, might lead to unstable weighting behavior during training and unavailability for generalization. In contrast, with the explicit yet simple Meta-Weight-Net, our method can learn the weight in a more stable way, as shown in Fig. \ref{curve}, and can be easily generalized from a certain task to related other ones (see in the supplementary material).


	\textbf{Other Methods for Class Imbalance.} Other methods for handling data imbalance include: \cite{wang2017learning,cui2018large} tries to transfer the knowledge learned from major classes to minor classes. The metric learning based methods have also been developed to effectively exploit the tailed data to improve the generalization ability, e.g., triple-header loss \cite{huang2016learning} and range loss \cite{zhang2017range}.
	
	\textbf{Other Methods for Corrupted Labels.} For handling noisy label issue, multiple methods have been designed by correcting noisy labels to their true ones via a supplemental clean label inference step \cite{azadi2015auxiliary,vahdat2017toward,veit2017learning,li2017learning,jiang2018mentornet,ren2018learning,hendrycks2018using}.
	For example,
GLC \cite{hendrycks2018using} proposed a loss correction approach to mitigate the effects of label noise on DNN classifiers. Other methods along this line include the Reed \cite{reed2014training}, Co-training \cite{han2018co}, D2L \cite{ma2018dimensionality} and S-Model \cite{goldberger2016training}.
	\vspace{0mm}
	\section{Experimental Results}  \label{section4}\vspace{0mm}
	To evaluate the capability of the proposed algorithm, we implement experiments on data sets with class imbalance and noisy label issues, and real-world dataset with more complicated data bias.
	\vspace{0mm}
	\subsection{Class Imbalance Experiments}\label{imbalance}\vspace{0mm}
	We use Long-Tailed CIFAR dataset \cite{cui2019class}, that reduces the number of training samples per class according to an exponential function , where  is the class index,  is the original number of training images and . The imbalance factor of a dataset is defined as the number of training samples in the largest class divided by the smallest.  We trained ResNet-32 \cite{he2016deep} with softmax cross-entropy loss by SGD with a momentum 0.9, a weight decay , an initial learning rate 0.1. The learning rate of ResNet-32 is divided by 10 after 80 and 90 epoch (for a total 100 epochs), and the learning rate of WN-Net is fixed as . We randomly selected 10 images per class in validation set as the meta-data set. The compared methods include: 1) \textbf{BaseModel}, which uses a softmax cross-entropy loss to train ResNet-32 on the training set; 2) \textbf{Focal loss} \cite{lin2018focal} and \textbf{Class-Balanced} \cite{cui2019class} represent the state-of-the-arts of the predefined sample reweighting techniques; 3) \textbf{Fine-tuning}, fine-tune the result of BaseModel on the meta-data set;
	4) \textbf{L2RW} \cite{ren2018learning}, which leverages an additional meta-dataset to adaptively assign weights on training samples.\vspace{0mm}
	
	Table \ref{classim} shows the classification accuracy of ResNet-32 on the test set and confusion matrices are displayed in Fig. \ref{conmatrix} (more details are listed in the supplementary material). It can be observed that: 1) Our algorithm evidently outperforms other competing methods on datasets with class imbalance, showing its robustness in such data bias case; 2) When imbalance factor is 1, i.e., all classes are with same numbers of samples, fine-tuning runs best, and our method still attains a comparable performance; 3) When imbalance factor is 200 on long-tailed CIFAR-100, the smallest class has only two samples. An extra fine-tuning achieves performance gain, while our method still perform well in such extreme data bias.\vspace{0mm}
	
	To understand the weighing scheme of MW-Net, we depict the tendency curve of weight with respect to loss by the learned MW-Net in Fig. \ref{fig1d}, which complies with the classical optimal weighting manner to such data bias. i.e., larger weights should be imposed on samples with relatively large losses, which are more likely to be minority class sample.


	
	
	\begin{table}
		\caption{Test accuracy (\%) of ResNet-32 on long-tailed CIFAR-10 and CIFAR-100, and the best and the second best results are highlighted in \textbf{bold} and \textbf{\underline{\emph{ italic bold}}}, respectively.}\label{classim} \vspace{0mm}
		\centering
		\begin{scriptsize}
			\begin{tabular}{c|c|c|c|c|c|c|c|c|c|c|c|c}
				\toprule
				Dataset Name & \multicolumn{6}{c|}{Long-Tailed CIFAR-10} & \multicolumn{6}{c}{Long-Tailed CIFAR-100}\\
				\hline
				Imbalance & 200 & 100 & 50 & 20 & 10 &1& 200 & 100 & 50 & 20 & 10 &1 \\
				\hline
				BaseModel & 65.68& 70.36& 74.81& 82.23& 86.39& 92.89&34.84& 38.32&43.85&51.14& 55.71& 70.50\\
				Focal Loss& 65.29& 70.38& 76.71& 82.76& 86.66& \textbf{\underline{\emph{93.03}}} & 35.62& 38.41& 44.32&51.95& 55.78& \textbf{\underline{\emph{70.52}}}\\
				Class-Balanced &\textbf{\underline{\emph{68.89}}}& \textbf{\underline{\emph{74.57}}}& \textbf{\underline{\emph{79.27}}}& \textbf{\underline{\emph{84.36}}}& \textbf{\underline{\emph{87.49}}}& 92.89& 36.23& 39.60 & 45.32&     \textbf{\emph{\underline{ 52.59}}}& \textbf{\underline{\emph{57.99}}}& 70.50\\
				\hline
				\hline
				Fine-tuning&66.08&71.33&77.42&83.37&86.42&\textbf{93.23}&\textbf{38.22}&\textbf{\emph{\underline{41.83}}}&\emph{\textbf{\underline{46.40}}}&52.11&57.44&\textbf{70.72}\\
				L2RW&66.51 & 74.16&78.93 &82.12 &85.19 & 89.25& 33.38&40.23 &44.44 &51.64 & 53.73 & 64.11\\
				Ours&\textbf{68.91} &\textbf{75.21} &\textbf{80.06} & \textbf{84.94}&\textbf{87.84 }&92.66 &\emph{\textbf{\underline{37.91}}} & \textbf{42.09}&\textbf{46.74} &\textbf{54.37 }& \textbf{58.46} &70.37\\
				\bottomrule
			\end{tabular}
		\end{scriptsize} \vspace{0mm}
	\end{table}
	


	
	
	\vspace{0mm}
	\subsection{Corrupted Label Experiment}\label{noise}\vspace{0mm}
	We study two settings of corrupted labels on the training set: 1) \textbf{Uniform noise.} The label of each sample is independently changed to a random class with probability  following the same setting in \cite{zhang2016understanding}.
	2) \textbf{Flip noise.} The label of each sample is independently flipped to similar classes with total probability . In our experiments, we randomly select two classes as similar classes with equal probability.
	Two benchmark datasets are employed: CIFAR-10 and CIFAR-100 \cite{krizhevsky2009learning}. Both are popularly used for evaluation of noisy labels \cite{ma2018dimensionality,han2018co}. images with clean labels in validation set are randomly selected as the meta-data set.
We adopt a Wide ResNet-28-10 (WRN-28-10) \cite{zagoruyko2016wide} for uniform noise and ResNet-32 \cite{he2016deep} for flip noise as our classifier network models\footnote{We have tried different classifier network architectures as classifier networks under each noise setting to show our
		algorithm is suitable to different deep learning architectures. We show this effect in Fig.\ref{fignet:a}, verifying the consistently good performance of our method in two classifier network settings.}.
	
	
	The comparison methods include: \textbf{BaseModel}, referring to the similar classifier network utilized in our method, while directly trained on the biased training data; the robust learning methods \textbf{Reed} \cite{reed2014training}, \textbf{S-Model} \cite{goldberger2016training} , \textbf{SPL} \cite{kumar2010self}, \textbf{Focal Loss} \cite{lin2018focal}, \textbf{Co-teaching} \cite{han2018co}, \textbf{D2L} \cite{ma2018dimensionality}; \textbf{Fine-tuning}, fine-tuning the result of \textbf{BaseModel} on the meta-data with clean labels to further enhance its performance; typical meta-learning methods \textbf{MentorNet} \cite{jiang2018mentornet}, \textbf{L2RW} \cite{ren2018learning}, \textbf{GLC} \cite{hendrycks2018using}.
	We also trained the baseline network only on 1000 meta-images. The performance are evidently worse than the proposed method due to the neglecting of the knowledge underlying large amount of training samples. We thus have not involved its results in comparison.
	
	\begin{table*}[t]
		\caption{Test accuracy comparison on CIFAR-10 and CIFAR-100 of WRN-28-10 with varying noise rates under uniform noise. Mean accuracy (std) over 5 repetitions are reported (`---' means the method fails).}
		\label{result-table}
		\vspace{2mm}
		\vskip 0in
		\centering
		\begin{tiny}
\resizebox{\textwidth}{8mm}{
				\begin{tabular}{lr|ccccccc|ccccc}
\toprule
					\multicolumn{2}{c|}{Datasets / Noise Rate } &  BaseModel & Reed-Hard &S-Model&Self-paced &Focal Loss &Co-teaching &D2L & Fine-tining&MentorNet &  L2RW &GLC&Ours\\
					\hline
					\multirow{3}{*}{CIFAR-10} &0\% &95.600.22 &94.380.14&83.790.11 & 90.810.34& \textbf{95.700.15}& 88.670.25& 94.640.33&\textbf{\underline{\emph{95.650.15}}}&94.350.42& 92.380.10
					&94.300.19 &94.520.25\\
					&40\% &68.071.23&81.260.51&79.580.33&86.410.29 &75.961.31&  74.810.34&85.600.13&80.470.25&87.330.22& 86.920.19 & \textbf{\underline{\emph{88.280.03}}}&\textbf{89.270.28}\\
					& 60\%&53.123.03&73.531.54&--- &53.101.78&51.871.19  & 73.060.25&68.020.41& 78.752.40&82.801.35& 82.240.36&  \textbf{\underline{\emph{83.490.24}}}  & \textbf{84.070.33}\\
\hline
					\multirow{3}{*}{CIFAR-100}&0\% &79.951.26
					& 64.451.02&52.860.99 &59.790.46 & \textbf{81.040.24}& 61.800.25& 66.171.42&\textbf{\underline{\emph{80.880.21}}}&73.261.23 &72.990.58&73.750.51&78.760.24\\
					&40\% &51.110.42
					& 51.271.18&42.120.99 &46.312.45 & 51.190.46 &46.200.15& 52.10 0.97&52.490.74  &\textbf{\underline{\emph{61.393.99}}} &60.790.91&61.310.22 &\textbf{67.730.26}\\
					& 60\%& 30.920.33&   26.950.98& ---&19.080.57 &27.703.77  & 35.671.25
					& 41.110.30& 38.160.38  & 36.871.47&48.150.34&\textbf{\underline{\emph{50.811.00}}}
					& \textbf{58.750.11}\\
\bottomrule
			\end{tabular}}
\end{tiny} \vspace{0mm}
	\end{table*}
	
	\begin{figure}[pt] \vspace{2mm}
		\begin{minipage}{0.48\textwidth}
\includegraphics[width=0.45\textwidth]{Baseline_cifar10_200.pdf} \ \ \ \ \
\includegraphics[width=0.45\textwidth]{ours_cifar10_200.pdf}\vspace{0mm}
			\caption{Confusion matrices for the Basemodel and ours on long-tailed CIFAR-10 with imbalance factors 200.}
			\label{conmatrix}
		\end{minipage} \ \ \ \ \ \ \ \ \
		\begin{minipage}{0.48\textwidth}
			\centering
\includegraphics[width=\textwidth]{type_net_10.pdf} \vspace{-5mm}
			\caption{Performance comparison for different classifier networks (WRN-28-10 and ResNet32) under CIFAR flip noise.} \label{fignet:a}
		\end{minipage}\vspace{0mm}
	\end{figure}
	
	\begin{table*}[t]\vspace{0mm}
		\caption{Test accuracy comparison on CIFAR-10 and CIFAR-100 of ResNet-32 with varying noise rates under flip noise.}\label{result2-table}\vspace{-1mm}
		\vskip -0.2in
		\begin{center}
			\begin{tiny}
\resizebox{\textwidth}{8mm}{
					\begin{tabular}{lr|ccccccc|ccccc}
\toprule
						\multicolumn{2}{c|}{Datasets / Noise Rate } &  BaseModel & Reed-Hard &S-Model&Self-paced &Focal Loss &Co-teaching &D2L & Fine-tining& MentorNet & L2RW &GLC&Ours\\
						\hline
						\multirow{3}{*}{CIFAR-10}
						&0\% &\textbf{\underline{\emph{92.890.32}}} &92.310.25 & 83.610.13& 88.520.21&93.030.16  &  89.870.10   & 92.020.14&  \textbf{93.230.23 } &92.130.30
						&  89.250.37   &   91.020.20  &  92.040.15 \\
						&20\% & 76.832.30&88.280.36&79.250.30& 87.030.34& 86.450.19 &   82.830.85  & 87.660.40
						&  82.473.64 &86.360.31 &   87.860.36  & \textbf{\underline{\emph{89.680.33  }}}  & \textbf{ 90.330.61 }\\
						&40\% & 70.772.31&81.060.76
						&75.730.32
						&81.630.52  &80.450.97 &  75.410.21   & 83.890.46
						& 74.071.56  &81.760.28 &   85.660.51   &  \textbf{88.920.24 }  &  \textbf{\underline{\emph{87.540.23}}} \\
						\hline
						\multirow{3}{*}{CIFAR-100}
						&0\% &\textbf{\underline{\emph{70.500.12}}} &69.020.32
						& 51.460.20&67.550.27 &  70.020.53 &    63.310.05 &   68.110.26
						& \textbf{70.720.22}  &70.240.21
						&  64.111.09   &  65.420.23   &  70.110.33 \\
						&20\% &  50.860.27& 60.270.76& 45.450.25& 63.630.30& 61.870.30 &   54.130.55  &  63.480.53
						&  56.980.50 & 61.970.47
						& 57.471.16    & \textbf{\underline{\emph{ 63.070.53 }}}   & \textbf{64.220.28}  \\
						&40\% & 43.011.16 & 50.401.01&43.810.15& 53.510.53& 54.130.40 &   44.850.81  &  51.830.33
						& 46.370.25  &52.660.56
						
						&   50.981.55   & \textbf{62.220.62 }  &  \textbf{\underline{\emph{58.640.47}}} \\
						\bottomrule
				\end{tabular}}
\end{tiny}
		\end{center}\vspace{0mm}
	\end{table*}
	
	
	All the baseline networks were trained using SGD with a momentum 0.9, a weight decay  and an initial learning rate 0.1. The learning rate of classifier network is divided by 10 after 36 epoch and 38 epoch (for a total of 40 epoches) in uniform noise, and after 40 epoch and 50 epoch (for a total of 60 epoches) in flip noise. The learning rate of WN-Net is fixed as . We repeated the experiments 5 times with different random seeds for network initialization and label noise generation.
	
	\begin{figure}[t] \vspace{0mm}
		\begin{minipage}{0.48\textwidth}
\includegraphics[width=0.9\textwidth]{W_N.pdf} \vspace{-3mm}
\caption{Sample weight distribution on training data under 40\% uniform noise experiments.}
			\label{weightsdis}
		\end{minipage} \ \ \ \ \ \ \ \ \
		\begin{minipage}{0.48\textwidth}
			\centering
\includegraphics[width=0.9\textwidth]{weight.pdf} \vspace{-2.4mm}
			\caption{Weight variation curves under 40\% uniform noise experiment on CIFAR10 dataset. } \label{curve}
		\end{minipage}\vspace{0mm}
	\end{figure}
	
	


	We report the accuracy averaged over 5 repetitions for each series of experiments and each competing method in Tables \ref{result-table} and \ref{result2-table}. It can be observed that our method gets the best performance across almost all datasets and all noise rates, except the second for 40\% Flip noise. At 0\% noise cases (unbiased ones), our method performs only slightly worse than the BaseModel. For other corrupted label cases, the superiority of our method is evident.
	Besides, it can be seen that the performance gaps between ours and all other competing methods increase as the noise rate is increased from 40\% to 60\% under uniform noise. Even with 60\% label noise, our method can still obtain a relatively high classification accuracy, and attains more than 15\% accuracy gain compared with the second best result for CIFAR100 dataset, which indicates the robustness of our methods in such cases.
	
	
	
	
	
	


	Fig. \ref{fignet:a} shows the performance comparison between WRN-28-10 and ResNet32 under fixed flip noise setting. We can observe that the performance gains for our method and BaseModel between two networks takes the almost same value. It implies that the performance improvement of our method is not dependent on the selection of the classifier network architectures.
	
	As shown in Fig. \ref{fig1e}, the shape of the learned weight function depicts as monotonic decreasing, complying with the traditional optimal setting to this bias condition, i.e., imposing smaller weights on samples with relatively large losses to suppress the effect of corrupted labels. Furthermore, we plot the weight distribution of clean and noisy training samples in Fig. \ref{weightsdis}. It can be seen that almost all large weights belongs to clean samples, and the noisy samples's weights are smaller than that of clean samples, which implies that the trained Meta-Weight-Net can distinguish clean and noisy images.
	
	Fig. \ref{curve} plots the weight variation along with training epoches under 40\% noise on CIFAR10 dataset of our method and L2RW. -axis denotes the differences of weights calculated between adjacent epoches, and -axis denotes the number of epoches. Ten noisy samples are randomly chosen to compute their mean curve, surrounded by the region illustrating the standard deviations calculated on these samples in the corresponding epoch. It is seen that the weight by our method is continuously changed, gradually stable along iterations, and finally converges. As a comparison, the weight during the learning process of L2RW fluctuates relatively more wildly. This could explain the consistently better performance of our method as compared with this competing method.
	
	
	\subsection{Experiments on Clothing1M}\label{real}
	To verify the effectiveness of the proposed method on real-world data, we conduct experiments on the Clothing1M dataset \cite{xiao2015learning}, containing 1 million images of clothing obtained from online shopping websites that are with 14 categories, e.g.,
	T-shirt, Shirt, Knitwear. The labels are generated by using surrounding texts of the images provided by the sellers, and therefore contain many errors. We use the 7k clean data as the meta dataset. Following the previous works \cite{patrini2017making,tanaka2018joint}, we used ResNet-50 pre-trained on ImageNet. 
	For preprocessing, we resize the image to , crop the middle  as input, and perform normalization.  We used SGD with a momentum 0.9, a weight decay , and an initial learning rate 0.01, and batch size 32. The learning rate of ResNet-50 is divided by 10 after 5 epoch (for a total 10 epoch), and the learning rate of WN-Net is fixed as .
	
	\begin{table}
		\caption{ Classification accuracy (\%) of all competing methods on the Clothing1M test set.}\label{clothing}
		\centering\tiny\vspace{0mm}
		\resizebox{0.8\textwidth}{12mm}{\begin{tabular}{c|c|c|c|c|c}
				\toprule
				\#  & Method &Accuracy & \#  & Method &Accuracy\\
				\hline
				\hline
				1 & Cross Entropy & 68.94 &5 & Joint Optimization \cite{tanaka2018joint}& 72.23\\
				2 & Bootstrapping \cite{reed2014training}& 69.12 & 6 & LCCN \cite{yao2019safeguarded}& 73.07\\
				3 & Forward  \cite{patrini2017making} & 69.84 & 7 & MLNT \cite{Li2019Learningto}& 73.47\\
				4 & S-adaptation \cite{goldberger2016training} & 70.36 & 8 & Ours & 73.72  \\
				\bottomrule
		\end{tabular}}
		\vspace{0mm}
	\end{table}
	
	The results are summarized in Table. \ref{clothing}. which shows that the proposed method achieves the best performance. Fig. \ref{fig1f} plots the tendency curve of the learned MW-Net function, which reveals abundant data insights. Specifically, when the loss is with relatively small values, the weighting function inclines to increase with loss, meaning that it tends to more emphasize hard margin samples with informative knowledge for classification; while when the loss gradually changes large, the weighting function begins to monotonically decrease, implying that it tends to suppress noise labels samples with relatively large loss values. Such complicated essence cannot be finely delivered by conventional weight functions.
	
	\vspace{-2mm}
	\section{Conclusion}\vspace{-2mm}
	We have proposed a novel meta-learning method for adaptively extracting sample weights to guarantee robust deep learning in the presence of training data bias. Compared with current reweighting methods that require to manually set the form of weight functions, the new method is able to yield a rational one directly from data. The working principle of our algorithm can be well explained and the procedure of our method can be easily reproduced ( Appendix A provide the Pytorch implement of our algorithm (less than 30 lines of codes)), and the completed training code is avriable at \url{https://github.com/xjtushujun/meta-weight-net}.). Our empirical results show that the propose method can perform superior in general data bias cases, like class imbalance, corrupted labels, and more complicated real cases.  Besides, such an adaptive weight learning approach is hopeful to be employed to other weight setting problems in machine learning, like ensemble methods and multi-view learning.
	
	
	\subsubsection*{Acknowledgments}
	This research was supported by the China NSFC projects under contracts 61661166011, 11690011, 61603292, 61721002,U1811461.
	The authors would also like to thank anonymous reviewers for their constructive suggestions on improving the paper, especially on the proofs and theoretical analysis of our paper.
	
	\bibliographystyle{unsrt}
	
	\bibliography{bayes_ref}
	\newpage
	
	\appendix
	
	\begin{Large}
		\textbf{Appendix}
	\end{Large}


	\setcounter{theorem}{0}
	\setcounter{footnote}{0}
	
	\section{Pytorch codes of our algorithm}
	The following is the Pytorch codes of our algorithm (core code is less than 30 lines), and the completed training code is avriable at \url{https://github.com/xjtushujun/meta-weight-net}.
	\begin{python}	
		def norm_func(v_lambda):
		norm_c = torch.sum(v_lambda)
		if norm_c != 0:
		v_lambda_norm = v_lambda / norm_c
		else:
		v_lambda_norm = v_lambda
		return 	v_lambda_norm
		
		optimizer_a = torch.optim.SGD(model.params(), args.lr, momentum=args.momentum, nesterov=args.nesterov, weight_decay=args.weight_decay)
		optimizer_c = torch.optim.SGD(vnet.params(), 1e-3, momentum=args.momentum, nesterov=args.nesterov,weight_decay=args.weight_decay)
		
		for iters in range(num_iters):
		adjust_learning_rate(optimizer_a, iters + 1)
		model.train()
		data, target = next(iter(train_loader))
		data, target = data.to(device), target.to(device)
		meta_model.load_state_dict(model.state_dict())
		y_f_hat = meta_model(data)
		cost = F.cross_entropy(y_f_hat, target_var, reduce=False)
		cost_v = torch.reshape(cost, (len(cost), 1))
		v_lambda = vnet(cost_v.data)
		v_lambda_norm = norm_func(v_lambda)
		l_f_meta = torch.sum(cost_v * v_lambda_norm)
		meta_model.zero_grad()
		grads = torch.autograd.grad(l_f_meta,(meta_model.params()),create_graph=True)
		meta_model.update_params(lr_inner=meta_lr,source_params=grads)
		
		data_meta,target_meta = next(iter(train_meta_loader))
		data_meta,target_meta = data_meta.to(device),target_meta.to(device)
		y_g_hat = meta_model(data_meta)
		l_g_meta = F.cross_entropy(y_g_hat, target_meta)
		optimizer_c.zero_grad()
		l_g_meta.backward()
		optimizer_c.step()
		
		y_f = model(data)
		cost_w = F.cross_entropy(y_f, target, reduce=False)
		cost_v = torch.reshape(cost_w, (len(cost_w), 1))
		with torch.no_grad():
		w_new = vnet(cost_v)
		w_v = norm_func(w_new)
		l_f = torch.sum(cost_v * w_v)
		optimizer_a.zero_grad()
		l_f.backward()
		optimizer_a.step()
	\end{python}
	
	
	
	\section{Derivation of the Weighting Scheme in Meta-Weight-Net}
	Recall the update equation of the parameters of Meta-Weight-Net as follows:
	
	The computation of Eq. (\ref{eq7}) in the paper by backpropagation can be understood by the following derivation:
	
	Let 
	 
	by substituting Eq. (\ref{eq9}) into Eq. (\ref{eq7}), we can get:
	
	
	
	
	
	\section{Convergence Proof of Our Method}
	This section provides the proofs for Theorems 1 and 2 in the paper.
	


	Suppose that we have a small amount of meta (validation) dataset with  samples  with clean labels, and the overall meta loss is,
	
	where  is the parameter of the classifier network, and  is the parameter of the Meta-Weight-Net. Let's suppose we have another  training data, , where , and the overall training loss is,
	
	
	
	\begin{lemma}\label{lemma1}
		Suppose the meta loss function is Lipschitz smooth with constant , and  is differential with a -bounded gradient and twice differential with its Hessian bounded by , and the loss function  have -bounded gradients with respect to training/meta data. Then the gradient of  with respect to meta loss is Lipschitz continuous.
	\end{lemma}
	\begin{proof}
		The gradient of  with respect to meta loss can be written as:
		
		
		Let   \footnotesize and  being defined in Eq.(\ref{eqg}). Taking gradient of  in both sides of Eq.(\ref{eq20}), we have
		
		For the first term in the right hand side, we have that
		
		since . And for the second term we have
		
		since . Combining the above two inequalities Eq.(\ref{eq21}) (\ref{eq22}), we have
		 
		Define , based on Lagrange mean value theorem, we have:
		
		where .
	\end{proof}
	
	
	
	
	\begin{theorem} \label{th1}
		Suppose the loss function  is Lipschitz smooth with constant , and  is differential with a -bounded gradient and twice differential with its Hessian bounded by , and the loss function  have -bounded gradients with respect to training/meta data. Let the learning rate  satisfies , for some , such that , and  is a monotone descent sequence,  for some , such that  and . Then Meta-Weight-Net can achieve  in  steps. More specifically,
		
		where  is some constant independent of the convergence process,  is the variance of drawing uniformly mini-batch sample at random.
	\end{theorem}
	\begin{proof}
		The update of  in each iteration is as follows:
		
		
		This can be written as:
		
		Since the mini-batch  is drawn uniformly from the entire data set, we can rewrite the update equationp as:
		
		where . Note that  are i.i.d random variable with finite variance, since  are drawn i.i.d with a finite number of samples. Furthermore, , since samples are drawn uniformly at random.
		Observe that
		\begin{tiny}
			
		\end{tiny}
		By Lipschitz smoothness of meta loss function,  we have
		\begin{tiny}
			
		\end{tiny}
		Since \begin{tiny}  \end{tiny} according to Eq.(\ref{eq6}),(\ref{eq8}), we have
		
		Since , .
		
		By Lipschitz continuity of  according to Lemma \ref{lemma1}, we can obtain the following:
		\begin{tiny}
			
		\end{tiny}
		Thus Eq.(\ref{eq23}) satifies
		\begin{tiny}
			
		\end{tiny}
		Rearranging the terms, we can obtain
		\begin{tiny}
			
		\end{tiny}
		Summing up the above inequalities and rearranging the terms, we can obtain
		\begin{tiny}
			
		\end{tiny}
Taking expectations with respect to  on both sides of Eq. \ref{eqrand}, we can then obtain:
		\begin{tiny}
			
		\end{tiny}
		since  and , where
		 is the variance of .
		Furthermore, we can deduce that
		
		The third inequlity holds for .
		Therefore, we can conclude that our algorithm can always achieve  in  steps, and this finishes our proof of Theorem \ref{th1}.
	\end{proof}
	
	\begin{lemma}\label{lemma2}
		(Lemma A.5 in \cite{mairal2013stochastic}) Let  be two non-negative real sequences such that the series  diverges, the series  converges, and there exists  such that . Then the sequences  converges to 0.\\
	\end{lemma}
	\begin{theorem}\label{th2}
		Suppose the loss function  is Lipschitz smooth with constant , and  is differential with a -bounded gradient and twice differential with its Hessian bounded by , and the loss function  have -bounded gradients with respect to training/meta data. Let the learning rate  satisfies , for some , such that , and  is a monotone descent sequence,  for some , such that  and .Then
		
	\end{theorem}
	
	
	
	\begin{proof}
		It is easy to conclude that 
		 satisfy .
		Recall the update of  in each iteration as follows:\vspace{-4mm}
		
		It can be written as:
		
		where . Since the mini-batch  is drawn uniformly at random, we can rewrite the update equation as:
		
		where .
		Note that  is i.i.d. random variable with finite variance, since  are drawn i.i.d. with a finite number of samples. Furthermore, , since samples are drawn uniformly at random, and .
		
		The objective function  defined in Eq. \ref{eqob} can be easily checked to be Lipschitz-smooth with constant , and have -bounded gradients with respect to training data.
		Observe that
		\begin{tiny}
			
		\end{tiny}


		For the first term,
		\begin{scriptsize}
			
		\end{scriptsize}
		For the second term,
		\begin{scriptsize}
			
		\end{scriptsize}
		Therefore, we have:
		\begin{scriptsize}
			
		\end{scriptsize}
		Taking expectation of both sides of (\ref{eq25}) and since , we have
		\begin{tiny}
			
		\end{tiny}
		Summing up the above inequalities over  in both sides, we obtain 
		\begin{tiny}
			 
		\end{tiny}
		The last inequality holds since , and  for limited number of samples' loss is bounded. Thus we have 
		\begin{tiny}
			
		\end{tiny}
		Since 
		
		which implies that .
		By Lemma \ref{lemma2}, to substantiate , since , it only needs to prove:
		
		for some constant . Based on the inequality:
		
		we then have:
		\begin{tiny}
			
		\end{tiny}
		According to the above inequality, we can conclude that our algorithm can achieve
		
		The proof is completed.
	\end{proof}
	
	
	\section{Experimentalp Details on Meta-Weight-Net}
	To match the original training step size, in our experiment, we can consider normalizing the weights of all examples in a training batch so that they sum up to one. In other words, we choose to have a hard constraint within the set , and the normalized weight
	
	where the function of  is to prevent the degeneration case when all  in a mini-batch are zeros, i.e. .  denotes a constant grater than 0, if ; and equal to 0 otherwise. With batch normalization,
	we effectively cancel the learning rate of Meta-Weight-Net, and it works well with a fixed learning rate.
	
	\section{MLP architecture of Meta-Weight-Net}
	We actually have tried different MLP architecture settings in experiments. The right table depicts some representative results under 6 different structures, with different depths and widths. It can be seen that varying MLP settings have unsubstantial effects to the final result. We thus prefer to use the simple and shallow one.
	\begin{table}[htp]	\vspace{-4mm}
\caption{Test accuracy on CIFAR-10 and CIFAR-100 of different MW-Nets.}
\begin{tabular}{c|c|c|c|c|c|c}
			\toprule
			\multirow{2}{*}{architcture}  & \multicolumn{2}{c|}{Imbalance (factor 100)} & \multicolumn{2}{c|}{ Uniform noise (40\%)} & \multicolumn{2}{c}{ Flip noise (40\%)}\\
&  CIFAR10 &\multicolumn{1}{c|}{CIFAR100}& CIFAR10 &\multicolumn{1}{c|}{CIFAR100}& CIFAR10 &CIFAR100\\
\hline
			1-50-1 & 73.50 & 41.87 & 89.01  & 67.63  & 87.38  &57.83 \\
			\hline
			1-100-1 & 75.21 & 42.09 & 89.27  & 67.73  & 87.54  &58.64 \\
			\hline
			1-200-1 & 74.70 &41.72  &89.58   & 67.84  & 87.74  & 58.41\\
			\hline
			1-100-100-1 & 75.01 & 41.97 & 89.09  & 66.48  & 87.28  & 57.39\\
			\hline
			1-10-10-1 & 74.71 & 41.94 & 89.10  & 66.53  & 87.58  &57.11 \\
			\hline
			1-10-10-10-1 & 74.96 &42.31 &  88.82 & 66.67  & 87.36  &57.29 \\
			\bottomrule
		\end{tabular}
\end{table}
	
	
	\section{Complexity Analysis of The Proposed Algorithm}
	Our Meta-PGC algorithm can be roughly regarded as that requires an extra full forward and backward passes of the network on training data (step 5 in algorithm) and an extra full forward and backward passes of the network of meta data (step 6 in algorithm) in the presence of the normal classifier network' parameters update (step 7 in algorithm). Therefore compared to regular training, our method needs approximately 3  training time in each iteration. It is suggest to let batch size of meta data less than or equal to batch size of training data, which avoids GPU memory increase and speeds up the learning process.
	
	\begin{figure}[t]
		\centering
		\subfigure[CIFAR-10 40\% noise]{
			\label{Robustnessa} \includegraphics[width=0.48\textwidth]{acc10_4.pdf}}
		\subfigure[CIFAR-10 60\% noise]{
			\label{Robustnessb} \includegraphics[width=0.48\textwidth]{acc10_6.pdf}}
		\vspace{0mm} \\
		\subfigure[CIFAR-100 40\% noise]{
			\label{Robustnessc} \includegraphics[width=0.48\textwidth]{acc100_4.pdf}}
		\subfigure[CIFAR-100 60\% noise]{
			\label{Robustnessd} \includegraphics[width=0.48\textwidth]{acc100_6.pdf}}\vspace{0mm}
		\caption{Training and test accuracy changing curves in \textbf{uniform noise} cases of CIFAR-10 and CIFAR-100 datasets. Solid and dotted curves denote the test and training accuracies, respectively. Our method and L2RW are less prone to overfit label noises, while our method can converge faster at around 40 epoch as shown in Fig. \ref{Robustnessa}. We thus terminate our method in 40 epoch in other experiments.} \vspace{-4mm}
		\label{Robustness} \end{figure}
	
	\section{Robustness Towards Label Noise Overfitting Issue}
Fig. \ref{Robustness} plots the tendency curves of the mini-batch training accuracy calculated on noisy training set in experiments, as well as those calculated simultaneously on clean test data during learning iterations. From the figure, we can easily find that the BaseModel can easily overfit to the noisy labels contained in the training set, whose test accuracy quickly degrades after the first learning rate decays. While our method and L2RW are less prone to such overfitting issue, and they retain the similar test accuracy until termination. Especially, throughout all our experiments, we find that our method can converge significantly faster than the BaseModel and L2RW methods\footnote{Since our method is inspired by L2RW \cite{ren2018learning}, we compare this method, as well as the BaseModel, for better illustration. The uniform noise experiment setting is the same as L2RW \cite{ren2018learning}, and thus the iteration steps of BaseModel and L2RW follows the original setting.}, as clearly shown in Fig.\ref{Robustness}, and get the peak performance at around 40 epochs, as compared with 120 epochs required for the other two methods, as shown in Fig. \ref{Robustnessa}. We thus only report our results at 40 epochs in the figure for other experiments.
	
	
	
	
	
	
	
	
	
	
	
	
	\newpage
	
	
	
	\section{Confusion Matrices for Class Imbalance and Corrupted Labels}
	We demonstrate confusion matrices of Baseline and our algorithm on long-tailed CIFAR-10 dataset for class imbalance and corrupted labels experiments, as shown in Fig. 2-4.
	
	\begin{figure}[h]
		\setlength{\abovecaptionskip}{0.cm}
		\setlength{\belowcaptionskip}{-1.cm}
		\vspace{-0.5cm}
		\centering
		\subfigure[1 for Baseline]{
\includegraphics[width=0.23\textwidth]{Baseline_cifar10_1.pdf}}
		\subfigure[1 for Ours]{
\includegraphics[width=0.23\textwidth]{ours_cifar10_1.pdf}}
		\subfigure[10 for Baseline]{
\includegraphics[width=0.23\textwidth]{Baseline_cifar10_10.pdf}}
		\subfigure[10 for Ours]{
\includegraphics[width=0.23\textwidth]{ours_cifar10_10.pdf}}\\\vspace{-0.4cm}
		\subfigure[20 for Baseline]{
\includegraphics[width=0.23\textwidth]{Baseline_cifar10_20.pdf}}
		\subfigure[20 for Ours]{
\includegraphics[width=0.23\textwidth]{ours_cifar10_20.pdf}}
		\subfigure[50 for Baseline]{
\includegraphics[width=0.23\textwidth]{Baseline_cifar10_50.pdf}}
		\subfigure[50 for Ours]{
\includegraphics[width=0.23\textwidth]{ours_cifar10_50.pdf}}\\\vspace{-0.4cm}
		\subfigure[100 for Baseline]{
\includegraphics[width=0.23\textwidth]{Baseline_cifar10_100.pdf}}
		\subfigure[100 for Ours]{
\includegraphics[width=0.23\textwidth]{ours_cifar10_100.pdf}}
		\subfigure[200 for Baseline]{
\includegraphics[width=0.23\textwidth]{Baseline_cifar10_200.pdf}}
		\subfigure[200 for Ours]{
\includegraphics[width=0.23\textwidth]{ours_cifar10_200.pdf}}
		\vspace{0mm} \vspace{0mm}
		\caption{Confusion matrices on long-tailed CIFAR-10 with imbalance factors ranging from 1 to 200.} \vspace{7mm}\label{ff1}
		\label{f1} \end{figure}
	\begin{figure}[h]
		\setlength{\abovecaptionskip}{0.cm}
		\setlength{\belowcaptionskip}{-1.cm}
		\centering
		\subfigure[40\% for Baseline]{
\includegraphics[width=0.23\textwidth]{1.pdf}}
		\subfigure[40\% for Ours]{
\includegraphics[width=0.23\textwidth]{uniform_ours_cifar10_4.pdf}}
		\subfigure[60\% for Baseline]{
\includegraphics[width=0.23\textwidth]{2.pdf}}
		\subfigure[60\% for Ours]{
\includegraphics[width=0.23\textwidth]{uniform_ours_cifar10_6.pdf}}
		\vspace{0mm} \vspace{0mm}
		\caption{Confusion matrices on CIFAR-10 dataset with varying noise rates under \textbf{uniform noise}.} \vspace{7mm}
		\label{f1} \end{figure}
	
	\begin{figure}[htb]
		\setlength{\abovecaptionskip}{0.cm}
		\setlength{\belowcaptionskip}{-1.cm}
		\centering
		\subfigure[20\% for Baseline]{
\includegraphics[width=0.23\textwidth]{flip_baseline_cifar10_2.pdf}}
		\subfigure[20\% for Ours]{
\includegraphics[width=0.23\textwidth]{flip_ours_cifar10_2.pdf}}
		\subfigure[40\% for Baseline]{
\includegraphics[width=0.23\textwidth]{flip_baseline_cifar10_4.pdf}}
		\subfigure[40\% for Ours]{
\includegraphics[width=0.23\textwidth]{flip_ours_cifar10_4.pdf}}
		\caption{Confusion matrices on CIFAR-10 dataset with varying noise rates under \textbf{flip noise}.}
		\label{f1} \end{figure}
	
	
	
	
	
	
	
	


	\newpage
	\section{Convergence Verification for The Training loss and Meta Loss}
	To validate the convergence results obtained in Theorem 1 and 2 in the paper, we plot the changing tendency curves of training and meta losses with the number of epochs in our experiments, as shown in Fig. \ref{supp4}\ - \ref{supp6}. The convergence tendency can be easily observed in the figures, substantiating the properness of the theoretical results in two theorems.
	
	\begin{figure}[htb]
		\setlength{\abovecaptionskip}{0.cm}
		\setlength{\belowcaptionskip}{-1.cm}
		\centering
		\subfigure[1 for CIFAR-10]{
\includegraphics[width=0.23\textwidth]{cifar10-1-ClassImbalance.pdf}}
		\subfigure[10 for CIFAR-10]{
\includegraphics[width=0.23\textwidth]{cifar10-10-ClassImbalance.pdf}}
		\subfigure[20 for CIFAR-10]{
\includegraphics[width=0.23\textwidth]{cifar10-20-ClassImbalance.pdf}}
		\subfigure[50 for CIFAR-10]{
\includegraphics[width=0.23\textwidth]{cifar10-50-ClassImbalance.pdf}}\\
		\subfigure[100 for CIFAR-10]{
\includegraphics[width=0.23\textwidth]{cifar10-100-ClassImbalance.pdf}}
		\subfigure[200 for CIFAR-10]{
\includegraphics[width=0.23\textwidth]{cifar10-200-ClassImbalance.pdf}}
		\subfigure[1 for CIFAR-100]{
\includegraphics[width=0.23\textwidth]{cifar100-1-ClassImbalance.pdf}}
		\subfigure[10 for CIFAR-100]{
\includegraphics[width=0.23\textwidth]{cifar100-10-ClassImbalance.pdf}}\\
		\subfigure[20 for CIFAR-100]{
\includegraphics[width=0.23\textwidth]{cifar100-20-ClassImbalance.pdf}}
		\subfigure[50 for CIFAR-100]{
\includegraphics[width=0.23\textwidth]{cifar100-50-ClassImbalance.pdf}}
		\subfigure[100 for CIFAR-100]{
\includegraphics[width=0.23\textwidth]{cifar100-100-ClassImbalance.pdf}}
		\subfigure[200 for CIFAR-100]{
\includegraphics[width=0.23\textwidth]{cifar100-200-ClassImbalance.pdf}}
		\caption{Training and meta loss tendency curves on long-tailed CIFAR with imbalance factors ranging from 1 to 200.}\vspace{8mm}
		\label{supp4} \end{figure}
	
	
	
	
	\begin{figure}[htb]
		\setlength{\abovecaptionskip}{0.cm}
		\setlength{\belowcaptionskip}{-1.cm}
		\centering
		\subfigure[CIFAR-10 40\% ]{
			\label{fig:subfig:a} \includegraphics[width=0.23\textwidth]{cifar10-40-Uniform-Noise.pdf}}
		\subfigure[CIFAR-10 60\% ]{
			\label{fig:subfig:b} \includegraphics[width=0.23\textwidth]{cifar10-60-Uniform-Noise.pdf}}
		\subfigure[CIFAR-100 40\% ]{
			\label{fig:subfig:a} \includegraphics[width=0.23\textwidth]{cifar100-40-Uniform-Noise.pdf}}
		\subfigure[CIFAR-100 60\%]{
			\label{fig:subfig:b} \includegraphics[width=0.23\textwidth]{cifar100-60-Uniform-Noise.pdf}}
		\caption{Training and meta loss tendency curves on CIFAR dataset with varying noise rates under \textbf{uniform noise}.}\vspace{8mm}
		\label{supp5} \end{figure}
	
	
	
	\begin{figure}[htb]
		\setlength{\abovecaptionskip}{0.cm}
		\setlength{\belowcaptionskip}{-1.cm}
		\centering
		\subfigure[CIFAR-10 20\% ]{
			\label{fig:subfig:a} \includegraphics[width=0.23\textwidth]{cifar10-20-Flip.pdf}}
		\subfigure[CIFAR-10 40\% ]{
			\label{fig:subfig:b} \includegraphics[width=0.23\textwidth]{cifar10-40-Flip.pdf}}
		\subfigure[CIFAR-100 20\% ]{
			\label{fig:subfig:a} \includegraphics[width=0.23\textwidth]{cifar100-20-Flip.pdf}}
		\subfigure[CIFAR-100 40\%]{
			\label{fig:subfig:b} \includegraphics[width=0.23\textwidth]{cifar100-40-Flip.pdf}}
		\caption{Training and meta loss tendency curves on CIFAR dataset with varying noise rates under \textbf{flip noise}.}
		\label{supp6} \end{figure}
	
	
	
	
	
	
	
	
\end{document}
