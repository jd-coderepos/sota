


\documentclass[preprint,12pt]{elsarticle}




\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{wrapfig}
\usepackage{latexsym}
\usepackage{amsmath}
\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage{multicol}
\usepackage{amsthm}
\usepackage{subfigure}

\newtheorem{theorem}{Theorem}
\newtheorem{lemma}{Lemma}
\newtheorem{definition}{Definition}




\journal{Theoretical Computer Science}

\begin{document}

\begin{frontmatter}



\title{Partial Gathering of Mobile Agents \\in Asynchronous Unidirectional Rings\tnoteref{t1,t2}}
\tnotetext[t1]{The conference version of this paper is published in the proceedings of 16th International
Conference on Principles of Distributed Systems (OPODIS 2012).}
\tnotetext[t2]{This work was supported by JSPS KAKENHI Grant Numbers 24500039,
24650012, 25104516, 26280022, and 26330084.
}






\author{Masahiro~Shibata\corref{cor1}}
\ead{m-sibata@ist.osaka-u.ac.jp}
\author{Shinji~Kawai\corref{cor1}}

\author{Fukuhito~Ooshita\corref{cor1}}
\ead{f-oosita@ist.osaka-u.ac.jp}
\author{Hirotsugu~Kakugawa\corref{cor1}}
\ead{kakugawa@ist.osaka-u.ac.jp}
\author{Toshimitsu~Masuzawa\corref{cor1}}
\ead{masuzawa@ist.osaka-u.ac.jp}

\cortext[cor1]{Corresponding author. Tel.:+81 6 6879 4117. Fax: +81 6 6879 4119.}




\address{Graduate School of Information Science and Technology, Osaka University, 1-5
Yamadaoka, Suita, Osaka 565-0871, Japan}

\begin{abstract}
In this paper, we consider the partial gathering problem of mobile agents in
asynchronous unidirectional rings equipped with whiteboards on nodes.
The partial gathering problem is a new generalization of the total gathering problem.
The partial gathering problem requires, for a given integer  , that each agent
should move to a node and terminate so that at least  agents
should meet at the same node. 
The requirement for the partial gathering problem is weaker than that for
the (well-investigated) total gathering problem, and thus, we have interests in
clarifying the difference on the move complexity between them.
We propose three  algorithms to solve the partial gathering problem. 
The first algorithm is deterministic but requires unique ID of each agent. 
This algorithm achieves the partial gathering in  total moves, 
where  is the number of nodes. 
The second algorithm is randomized and requires no unique ID of each agent (i.e., anonymous).
This algorithm achieves the partial gathering in expected   total moves. 
The third  algorithm is deterministic and requires no unique ID of each agent.
For this case, we show that there exist initial configurations in which no algorithm can solve the problem 
and  agents can achieve the partial gathering in  total moves for solvable initial configurations,
where  is the number of agents.
Note that the total gathering problem requires  total moves, while the partial gathering problem requires  total moves in each model.
Hence, we show that the move complexity
of the first and second  algorithms is asymptotically optimal.


\end{abstract}

\begin{keyword}
distributed system, mobile agent, gathering problem, partial gathering


\end{keyword}

\end{frontmatter}



\section{Introduction}
\label{intro}

\subsection{Background and our contribution}
\label{background}

A {\em distributed system} is a system that consists of a set of computers ({\em nodes})  and communication links.
In recent years, distributed systems have become large and design of distributed systems has become complicated.
As an effective way to design distributed systems, (mobile) agents have attracted a lot of attention \cite{gathering}.
Design of distributed systems can be simplified using agents because they can traverse the system with carrying information and process tasks on each node.

The total gathering problem is a fundamental problem for cooperation of agents \cite{gathering,token1,token2}. 
The total gathering problem requires all agents to meet at a single node in finite time. 
The total gathering problem is useful because, by meeting at a single node, all agents can share information or synchronize behaviors among them.

In this paper, we consider a new generalization of the total gathering problem, called the {\em partial gathering problem}. The partial gathering problem does not always require all agents to gather at a single node, but requires agents to gather partially at several nodes. More precisely, we consider the problem which requires, for a given integer  , that each agent should move to a node and terminate at a node so that at least  agents should meet at the node.
We define this problem as the {\em -partial gathering problem}. 
We assume that  is the number of agents. 
Clearly if  holds, the -partial gathering problem is equivalent to the total gathering problem. If  holds, the requirement for the -partial gathering problem is weaker than that for the total gathering problem, and thus it seems possible to solve the -partial gathering problem with fewer total moves. From a practical point of view, the -partial gathering problem is still useful because agents can share information and process tasks cooperatively among at least  agents.

The contribution of this paper is to clarify the difference on the move complexity between the total gathering problem and the -partial gathering problem.
We investigate the difference in asynchronous unidirectional rings equipped with whiteboards on nodes.
The contribution of this paper is summarized in Table \ref{table:result}, where  is  the number of nodes.
\begin{table*}[t]
\begin{center}
\small
\caption[smallcaption]{Proposed algorithms for the -partial gathering problem in asynchronous unidirectional rings.}
\label{table:result}
\newlength{\myheight}
\setlength{\myheight}{10.5mm}
\begin{tabular}{|c|c|c|c|}
\hline \parbox[c][\myheight][c]{0cm}{} & \parbox[c]{18mm}{\shortstack {Model 1\\ (Section 3)}}  & 
\parbox[c]{18mm}{\shortstack{Model 2\\ (Section 4)}} & \parbox[c]{18mm}{\shortstack{Model 3\
T_j &\ge& \sum_{i=1}^{|A_i|}(i-1)\cdot \frac{n}{k}\\
&\ge& \sum_{i=1}^g (i-1)\cdot \frac{n}{k} + (|A_j|-g)\cdot \frac{gn}{k}\\
    &=& \frac{n}{k}\cdot \frac{g(g-1)}{2} + (|A_j|-g)\cdot \frac{gn}{k}.

T &=&   \sum_{v_j\in V'}T_j \\
  &\ge& x\cdot \frac{n}{k}\cdot \frac{g(g-1)}{2} + (k-gx)\cdot \frac{gn}{k}\\
  &=& gn-\frac{gnx}{2k}(g+1).

T\ge \frac{n}{2} (g-1).
=\textit{false}v_j.inactivev_ja_ha_hv_{j'}v_{j'}.phase=a_h.phasea_hv_ja_ha_ha_h.phasea_h.id_1a_h.id_2a_h.id_3v_jv_j.phasev_j.idv_j.inactive=a_ha_h.phase=1a_h.id_1=a_h.idv_j.phase=a_h.phasev_j.id=a_h.id(v_j.phase=a_h.phase)\land (v_j.id=a_h.id_1)a_h.id_2=v_j.ida_h.id_3=v_j.ida_h.id_2\geq \min (a_h.id_1,a_h.id_3)v_j.inactive=truea_h.phase=\lceil \log g \rceil a_h.phase = a_h.phase+1a_h.id_1=a_h.id_2a_hv_{j'}v_{j'}.phase=a_h.phasea_hv_j.initial=a_hv_j.inactive=truea_h.phase \neq v_j.phasea_ha_ha_ha_ha_ha_bx=a_h.phasey=a_b.phasey<xa_hv_ca_h.phase>v_c.phasea_ha_bv_ca_bv_c.phasev_ca_hv_cv_c.phase=xv_c.inactive=truea_bv_c.phasev_c.inactivea_ha_ha_ba_h(v_j.initial=\textit{false})\vee (v_j.inactive=true \land a_h.phase\neq v_j.phase)a_h.phase > v_j.phasev_j.phase=a_h.phasev_j.inactive=truea_ha_ba_ha_ba_hx=a_h.phase=a_b.phasea_ha_ba_ca_dxv_hv_bv_cv_da_ha_ba_ca_dxa_ha_bv_cv_da_hv_ca_hv_ca_hv_c.ida_ba_c.idv_cv_dv_da_hv_ca_ha_h.phase=x+1v_c.phasev_c.ida_ha_h.id_2=a_b.idv_c.ida_b.ida_ha_hv_da_hv_da_bv_dv_d.phase<a_h.phasev_d.inactive=v_da_ha_bv_da_bv_ca_b.phase<v_c.phasea_bv_c.phasea_hv_c.ida_hv_c.id=a_b.ida_b.id_1=a_b.id_2a_bv_da_ha_ha_ba_ha_bg-1\lceil \log g \rceila_ha_{h'}a_ha_{h'}v_jv_j.phasev_j.inactivea_{h'}v_jv_j.phase v_j.inactivea_hv_j\lceil \log g\rceila_h.id_2a_ha_hiig-1j2^j -1a_hj = 11 = 2^1 - 1j = l2^l -1l+1(2^l -1) +1 + (2^l - 1)2^{l+1} - 1j2^j - 1\lceil \log g\rceilg-1a_ha_bO(n\log g)O(n)\lceil \log g \rceil gleaderinactivemovingga_ha_ha_hv_ja_hga_ha_hga_ha_1a_2a_1a_2g=3)a_ha_hgv_j.initialv_j.inactivev_j.initial=truev_jv_j.inactive=truev_jv_{j'}v_{j'}.initial=\textit{false}ga_hv_ja_h.counta_ha_hga_h.countv_j.\textit{isGather}v_ja_hv_ja_hv_j.\textit{isGather}v_ja_h.count=0a_hv_j.\textit{isGather}v_j.\textit{isGather}\perpv_ja_ha_ha_h.count=0v_jv_j.\textit{isGather}=\perpa_ha_ia_ha_ia_ha_ia_hv_jv_j.initial=truev_j.inactive=v_j.\textit{isGather}  = \perpa_iv_j.inactive=truev_jv_j.\textit{isGather}\neq \perpv_ja_hv_j.inactive=truev_j.\textit{isGather}\neq \perpv_j.\textit{isGather}v_ja_hv_ja_hv_j.\textit{isGather}=0a_h.count=a_h.count+1v_j.\textit{isGather}=\perpv_j.initial=v_j.inactive=\textit{false})\wedge( v_j.\textit{isGather}=\perp)v_j.inactive=truev_j.\textit{isGather}\neq \perpv_j.inactive=truea_h.count=0v_j.\textit{isGather}=1v_j.\textit{isGather}=0v_ja_h.count=(a_h.count+1)\bmod ga_hv_ja_hv_j.\textit{isGather}\neq\perpa_hv_jv_j.\textit{isGather}=1ga_hv_jv_j.initial=truev_j.\textit{isGather}  = \perpa_ha_hv_j.\textit{isGather}a_hv_ja_hv_j.\textit{isGather}\neq 1(v_j.initial=\textit{true})\wedge (v_j.\textit{isGather} = \perp)v_j.\textit{isGather}\neq \perpgO(gn)v^g_0,v^g_1,\ldots ,v^g_lv^g_j.\textit{isGather} = 10\le j\leq lv^g_jg-1v^g_jv^g_{j+1}gnv^g_jg-1a_hv_j.\textit{isGather}g-12g-1v^g_jv^g_{j+1}O(gn)2ggO(gn)gkgO(gn)g-13\log kv_j\textit{leader}\textit{flag}v_jO(n\log g)a_h.id_1,a_h.id_2a_h.id_3a_ha_h.id_1=a_h.id_3\neq a_h.id_2a_ha_h.id_2<a_h.id_1=a_h.id_3a_ha_ha_1a_1.id_2<a_1.id_1=a_1.id_3a_2a_2.id_2>a_2.id_1=a_2.id_3a_h.id_2=a_h.id_1a_h.id_2=a_h.id_3a_hO(n\log g)a_ha_ha_hv_jv_jv_j.initial=truea_hv_ja_ha_ha_ha_ha_ha_ha_ha_h.ida_hA_{min}a_h\in A_{min}id_{min}a_h\notin A_{min}a_h|A_{min}|=1a_ha_ha_ha_h|A_{min}| = 1a_1a_1a_1,a_2a_4a_3,a_5a_6a_1,a_2a_4a_1a_2a_4a_hv_ja_h.id_1,a_h.id_2,a_h.id_3a_ha_ha_h.id_1a_h.phasea_hv_j.phasev_j.idv_jv_j.\textit{tour}\textit{flag}v_j.leader\textit{flag}falsea_h.\textit{semiObserve}a_ha_h.\textit{semiObserve}falsea_hlla_hv_ja_ha_ha_h.phasea_h.id_1a_h.id_2a_h.id_3a_h.\textit{semiObserve}=v_jv_j.phasev_j.idv_j.inactive=v_j.\textit{tour}\textit{flag}=v_j.leader\textit{flag}=a_hv_ja_ha_h.phase=1a_h.id_1=(3\log k)v_j.phase=a_h.phasev_j.id=a_h.id_1v_j.\textit{tour}=\textit{true}a_h.\textit{\textit{semiObserve}}=\textit{true}a_h.id_2=v_j.idv_j.\textit{tour}=\textit{true}a_h.\textit{semiObserve}=\textit{true}a_h.id_3=v_j.ida_h.\textit{semiObserve}=\textit{true}v_j.inactive = \textit{true}a_h.phase=v_j.phase)\land (a_h.id_1=a_h.id_2 \lor a_h.id_2=a_h.id_3)a_h.id_2\geq \min (a_h.id_1,a_h.id_3)v_j.inactive=\textit{true}a_h.phase=\lceil \log g \rceil v_j.\textit{leader}\textit{flag}=\textit{true}a_h.phase = a_h.phase+13\log k3\log ka_h(a_h.phase=v_j.phase )\land (a_h.id_2=a_h.id_1 \lor a_h.id_2=a_h.id_3)v_ja_ha_hv_j.inactivea_h(a_h.phase=v_j.phase )\land (a_h.id_2=a_h.id_1 \lor a_h.id_2=a_h.id_3)a_ha_hv_ja_ha_ha_h.\textit{semiPhase}a_h.\textit{semiID}a_h.\textit{agentCount}a_h.\textit{isMin}=a_h.\textit{isUnique}=a_h.\textit{leaderObserve}=v_jv_j,\textit{semiPhase}v_j.idv_j.\textit{leader}\textit{flag}v_j.\textit{semi}\textit{leader}\textit{flag}v_j.\textit{tour}\textit{flag}a_hv_ja_hv_j.tour\textit{flag}=\textit{true}v_j.inactive =\textit{true}v_j.semileader\textit{flag}=\textit{true}a_h.\textit{semiPhase}=1v_j.\textit{semiPhase}=a_h.\textit{semiPhase}v_j.id = random(3\log k)a_h.\textit{semiID}= v_j.ida_h.\textit{agentCount}\neq kv_j.initial=a_h.\textit{agentCount}=a_h.\textit{agentCount}+1v_j.leader\textit{flag}=\textit{true}a_h.\textit{leaderObserve}=\textit{true}v_j.semileader\textit{flag}=\textit{true}a_h.\textit{semiPhase}\neq v_j.\textit{semiPhase}a_h.\textit{semiPhase}=v_j.\textit{semiPhase}{v_j.id}<a_h.\textit{semiID}a_h.\textit{isMin}=\textit{false}{v_j.id}=a_h.\textit{semiID}a_h.\textit{isUnique}=\textit{false}v_j.\textit{tour}\textit{flag}=\textit{true}a_hv_ja_ha_h.\textit{leaderObserve}=\textit{true}v_j.inactive =\textit{true}a_h.\textit{isMin}= \textit{false}v_j.\textit{semi}leader\textit{flag}=v_j.inactive = \textit{true}a_h.\textit{isUnique}=\textit{true}a_h.\textit{semiPhase}=a_h.\textit{semiPhase}+1a_h.\textit{agentCount}=0a_hv_ja_h.\textit{semiID}a_ha_h.\textit{agentCount}a_ha_h.\textit{isMin}a_ha_h.\textit{isMin}truea_h\textit{isUnique}a_ha_h\textit{isUnique}truea_h.\textit{leaderObserve}a_ha_h.\textit{leaderObserve}a_h.\textit{semiPhase}a_hv_j.\textit{semiPhase}a_h.\textit{semiPhase}v_j.\textit{semiPhase}v_jv_j.idv_j.\textit{leader}\textit{flag}v_j.\textit{semi}\textit{leader}\textit{flag}v_j.tour\textit{flag}a_hv_jv_ja_{h'}v_ja_ha_ha_ha_hg-1O(n\log g)O(n\log g)l(\frac{1}{2})^lk_iik_i\times (\frac{1}{2})^l\lceil \log g\rceilk\times (\frac{1}{2})^l+\frac{k}{2} \times (\frac{1}{2})^l+\cdots +\frac{k}{2^{\lceil \log g\rceil -1}} \times (\frac{1}{2})^l<2k\times (\frac{1}{2})^ll=3\log k\frac{2}{k^2}<\frac{1}{k}ka_hA_{min}|A_{min}|=1O(kn)k\times (\frac{1}{2})^la_ha_h|A_{min}|=1t=k\times (\frac{1}{2})^l ss-1|A_{min}|\neq 1s|A_{min}|=1|A_{min}|=1st^{s-1}\times 1=t^{s-1}skn\frac{1}{k}O(n\log g)+\frac{1}{k}\times \sum^\infty_{s=1}t^{s-1} \times skn = n \sum^\infty_{s=1}st^{s-1}S_n1\times 1 + 2\times t +\cdots +nt^{n-1}S_n= (nt^{n+1}-(n-1)t^n+1)/(1-t)^2n=\inftyS_n=1/(1-t)^2t=k\times (\frac{1}{2})^ll=3\log kt<\frac{1}{2}S_n<4O(n)O(n\log g)O(n\log g)g-1ggO(gn)ggO(kn)ca_hD_h(c)=(d^h_0(c),\ldots,d^h_{k-1}(c))d^h_i(c)ia_h(i+1)a_hcc\{D_h(c)|a_h\in A\}D(c)D=(d_0,d_1,\ldots,d_{k-1})\textit{shift}(D,x)=(d_{x},d_{x+1},\ldots,d_{k-1},d_0,d_1,\ldots,d_{x-1})D=\textit{shift}(D,x)x0<x<kDperiodD\textit{shift}(\textit{D},period)=\textit{D}c_0D(c_0)periodggm=k/periodA_j0\le j\le period-1a_hD_h(c_0)=\textit{shift}(D(c_0),j)A_jA_jmA_jmk/m=period<ggmggO(kn)D=D(c_0)c_0gperiod<ggperiod\geq gka_hD_h(c_0)a_hDperiodperiod<ga_hga_h\{a_\ell|D=D_\ell(c_0)\}a_hperiod\,(\ge g)ga_hv_ja_ha_ha_h.\textit{total};a_h.dis;a_h.x;a_h.DD_{min}a_ha_h.\textit{total}=0a_h.dis=0a_h.\textit{total}\neq kv_j.initial = false a_h.dis=a_h.dis+1a_h.D[a_h.\textit{total}]=a_h.disa_h.\textit{total}=a_h.\textit{total}+1a_h.dis=0D_{min}\{\textit{shift}(a_h.D,x)|0\le x\le k-1\}period=\min \{x>0|shift(D_{min},x)=D_{min}\}  (g>period)ga_h.x= \min \{x\le 0| \textit{shift}(a_h.D,x) = D_{min}\}\sum^{a_h.x-1}_{i=0}{a_h.D[i]}gO(kn)a_hD_{min}periodperiod<gga_hperiod\geq g\sum^{a_h.x-1}_{i=0}{a_h.D[i]}a_ha_\ella_\ell.D=D(c_0)period \,(\ge g)ggO(kn)nO(kn)gO(kn)ggO(gn)\Omega (kn)$, and if the conjecture is correct, we can show that the third algorithm is asymptotically optimal in terms of total moves. 

\bibliographystyle{unsrt} 
\bibliography{ref}










\end{document}
