\noindent
    {\bf \large Appendix.}
\bigskip
    
\noindent
This appendix contains several examples on how to use \tool{T2}.
For the ease of this demonstration, we include easy to follow programs alongside
corresponding simple properties. Additional examples of \tool{T2} operating on realistic programs 
with expressive properties are available in the papers relating to the respective technical
results~\cite{Cook13a,Cook14,coo:khl:pit:15}.
Installation instructions for \tool{T2}, additional runtime options, and an overview of the program source
code can be found alongside its source in
\url{https://github.com/mmjb/T2/blob/master/README.txt}.


\section{Front-end Pre-processing via LLVM}
\label{llvm}

\begin{figure*}
\vspace{-3ex}
\begin{tabular}{cc}
{\begin{minipage}{0.35\textwidth}
  \small
\begin{alltt}
define i32 @main() #0 \{
main_bb0:
  \%"0" = call i32 (...)* @nondet()
  \%"1" = call i32 (...)* @nondet()
  \%"2" = icmp sgt i32 \%"0", 0
  br i1 \%"2", label \%main_bb1, 
      label \%main_bb3

main_bb1:
  \%x = phi i32 [ \%"4", \%main_bb2],
      [ \%"1", \%main_bb0 ]
  \%"3" = icmp sgt i32 \%x, 0
  br i1 \%"3", label \%main_bb2,
      label \%main_bb3

main_bb2:
  \%"4" = sub nsw i32 \%x, \%"0"
  br label \%main_bb1

main_bb3:
  ret i32 0
\}
\end{alltt}
\end{minipage}
}
&
\begin{tabular}{cc}
 \null\hspace{0.5in}
  \begin{minipage}{.26\textwidth}
  \small
  \begin{alltt}
START: main_bb0;

FROM: main_bb0;
  v0 := nondet();
  v1 := nondet();
  x := v1;
TO: main_bb0_end;

FROM: main_bb0_end;
  assume(v0 > 0);
TO: main_bb1;

FROM: main_bb0_end;
  assume(v0 <= 0);
TO: main_bb3;
\end{alltt}
\end{minipage}
&
\begin{minipage}{.3\textwidth}
\begin{alltt}


FROM: main_bb1;
  assume(x > 0);
TO: main_bb2;

FROM: main_bb1;
  assume(x <= 0);
TO: main_bb3;

FROM: main_bb2;
  v4 := x - v0;
  x := v4;
TO: main_bb1;

FROM: main_bb3;
TO: main_bb3;
  \end{alltt}
 \end{minipage}
 \end{tabular}
 \end{tabular}
\\
\centerline
{\begin{minipage}{0.5\textwidth}
\vspace{-1ex}
(a)\hspace{2in}(b)
\end{minipage}}
\\
\vspace{-3ex}
\caption{\label{ex:T2} {\bf (a)} Compiled LLMV-IR post \tool{llvm2kittel} optimizations 
corresponding to \rF{ex:T2-Input}(a).  
{\bf (b)} \tool{T2} input file corresponding to \rF{ex:T2-Input}(b), generated from(a).}
\vspace{-3ex}
\end{figure*}

 Our LLVM front-end builds upon and extends
\tool{llvm2kittel}~\cite{Falke11}. Our version of
  \textsf{llvm2kittel} tailored for \textsf{T2} can be found at
  \url{https://github.com/hkhlaaf/llvm2kittel}.
\tool{llvm2kittel} provides multiple optimizations that are helpful for our
transformation into the native \ttwo file format, as it performs function
inlining, dead code elimination, constant propagation, and control-flow
simplification. 
Below we provide a very basic notion of how the \tool{LLVM} intermediate
representation (\tool{LLVM-IR}) corresponds to the \tool{T2} format.

The \tool{LLVM-IR} generated by \code{clang} for our example \tool{C} program
from \rF{ex:T2-Input}(a) is shown in \rF{ex:T2}(a).
The \tool{T2} input file generated from this by our \tool{llvm2kittel} front-end
is displayed in \rF{ex:T2}(b).
In our translation, basic blocks in the \tool{LLVM-IR} (\texttt{main\_bb0},
\texttt{main\_bb1}, \ldots) are translated as transition rules labeled with
corresponding arithmetic instructions.
These instructions are trivially obtained from the \tool{LLVM-IR}, but
all heap memory reads are implemented as \code{\bf nondet()}, and heap writes
are dropped.

A basic block's entry point is represented by a location of the same name, i.e.,
a transition to the location \code{main\_bb2} corresponds to entering the basic
block \code{main\_bb2}.
The targets of the generated transitions are extracted from the \texttt{br}
(``branch'') instructions.
Sequences of \texttt{phi} instructions at the beginning of a basic block ,
which are needed for \tool{LLVM-IR}'s single static assignment syntax, are
encoded on the transitions leading to .
For example, in \rF{ex:T2}(a), the basic block \texttt{main\_bb0} contains a
sequence of instructions before a \texttt{br} instruction determines
whether to branch to \texttt{main\_bb1} or \texttt{main\_bb3}, depending on the
value of \texttt{\%0}. 
This is reflected in \rF{ex:T2}(b) in the first column, where the comparison of
the value \texttt{\%0} (\texttt{v0} in the \ttwo file), is done from the 
\texttt{main\_bb0\_end} node.
If \texttt{v0 > 0} we transition to the \texttt{main\_bb1} node, otherwise we
transition  to the \texttt{main\_bb3} node.


Using our version of \tool{llvm2kittel} as a front-end, we now show how it can be used to
generate native \ttwo files from \tool{C} programs. Assume that the \tool{C}
program from \rF{ex:T2-Input}(a) is stored as \code{ex0.c}. We generate a \ttwo 
native input file as follows:
\begin{quote}
  \vspace{-1ex}
  \begin{alltt}
    \small
\ ./llvm2kittel --eager-inline --t2 ex0.bc > ex0.t2
  \end{alltt}
  \vspace{-1ex}
\end{quote}

\section{\tool{T2} as Termination Prover}
\subsection{Native Input}
We first demonstrate using \tool{T2} to prove termination of the example from
\rF{ex:T2-Input}, whose textual representation is displayed in \rF{ex:T2}
Assume that the example is saved as file \code{ex0.t2}. Then, 
the most simple \tool{T2} call looks like this:
\begin{quote}
  \vspace{-2ex}
\begin{alltt}
\small
\ ./T2 -termination -input\_t2 ex0.t2 -print\_proof
Termination proof succeeded
Used the following cutpoint-specific lexicographic rank functions:
 * For cutpoint 7, used the following rank functions/bounds (in descending priority order):
    - RF x, bound 1
\end{alltt}
  \vspace{-1ex}
\end{quote}
We see that the proof was done using a (one-element) lexicographic rank function.
However, this output is hard to connect to the input program, which had no
location \code{7}.\footnote{The reason for the location number is that \tool{T2}
  stores 
  locations as integers, but also allows strings to identify locations in the
  input (e.g. ``\code{START: start;}''), and thus renumbers all locations on
  parsing the input file.}
To understand the connection better, \tool{T2} allows to output all intermediate
program representations as \tool{DOT} graphs:
\begin{quote}
  \vspace{-1ex}
\begin{alltt}
\small
\ii java -cp aprove.jar aprove.CommandLineInterface.JBCFrontendMain --t2 yes Ex1.jar
Dumped to ./Ex1.jar-obl-8.t2
\\code{n} < \code{m} java -cp aprove.jar aprove.CommandLineInterface.JBCFrontendMain --t2 yes Ex2.jar
Dumped to ./Ex2.jar-obl-9.t2
\$ ./T2 -termination -input_t2 Ex2.jar-obl-9.t2
Termination proof succeeded
  \end{alltt}
  \vspace{-2ex}
\end{quote}

