\documentclass[10pt,conference]{IEEEtran}


\renewcommand\thesection{\arabic{section}}
\renewcommand\thesubsection{\thesection.\arabic{subsection}}
\renewcommand\thesubsubsection{\thesubsection.\arabic{subsubsection}}

\renewcommand\thesectiondis{\arabic{section}}
\renewcommand\thesubsectiondis{\thesectiondis.\arabic{subsection}}
\renewcommand\thesubsubsectiondis{\thesubsectiondis.\arabic{subsubsection}}


\usepackage{verbatim} 
\usepackage[pdftex]{graphicx}
\usepackage{setspace}
\usepackage[cmex10]{amsmath}
\usepackage{amsmath, amsthm, amssymb}
\usepackage{algorithmic}
\usepackage{algorithm}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{paralist}
\usepackage{cases}
\usepackage{cite}

\usepackage{tikz}

\usepackage{color}

\newcommand{\ceiling}[1]{\left\lceil{#1}\right\rceil}
\newcommand{\floor}[1]{\left\lfloor{#1}\right\rfloor}
\newcommand{\setof}[1]{\left\{{#1}\right\}}
\newcommand{\set}[2]{\{{#1}\mid{#2}\}}

\newcommand{\jj}[1]{\textcolor{blue}{jj: #1 : endjj}}
\newcommand{\kh}[1]{\textcolor{magenta}{kevin: #1 : endkevin}}
\newcommand{\toolbox}[1]{{\bf CHL}}
\newcommand{\frameworkkq}[1]{}
\newcommand{\frameworkku}[1]{}
\newcommand{\Cong}[1]{\textcolor{red}{cong: #1 : endcong}}


\def\myendproof{{\ \vbox{\hrule\hbox{\vrule height1.3ex\hskip0.8ex\vrule}\hrule }}\par}
 \renewenvironment{proof}{\noindent{\bf Proof. }}{\myendproof}
\newenvironment{appProof}[1]{\noindent{\bf Proof of
     #1. }}{\myendproof\vskip 0.1in}


 \setboolean{ALC@noend}{true}

\newtheorem{theorem}{Theorem}
\newtheorem{lemma}{Lemma}
\newtheorem{corollary}{Corollary}
\newtheorem{example}{Example}
\newtheorem{claim}{Claim}
\newtheorem{definition}{Definition}
\newtheorem{rrule}{Rule}
\newtheorem{remark}{Remark}
\newtheorem{observation}{Observation}

\graphicspath{{fig/multiframe/}{fig/arbitrary/}{fig/dag/}} 







\usetikzlibrary{arrows,shapes.misc,shapes.arrows,chains,matrix,positioning,scopes,decorations.pathmorphing,shadows}

\pgfdeclarelayer{background}
\pgfdeclarelayer{foreground}
\pgfsetlayers{background,main,foreground}
\tikzstyle{materia}=[draw, fill=white, text width=1.0em, text centered,
  minimum height=4em,drop shadow]
\tikzstyle{practica} = [materia, text width=18em, minimum width=8em,
align =left,
  minimum height=3em, rounded corners, drop shadow]
\tikzstyle{texto} = [above, text width=6em, text centered]
\tikzstyle{linepart} = [draw, thick, color=blue!50, -latex', dashed]
\tikzstyle{line} = [draw, line width = 2pt, color=blue!50, -latex']
\tikzstyle{ur}=[draw, text centered, minimum height=0.01em]
\newcommand{\blockdist}{1.3}
\newcommand{\edgedist}{1.5}

\newcommand{\practica}[2]{node (p#1) [practica]
  {\\{\footnotesize{#2}}}}

\newcommand{\background}[5]{\begin{pgfonlayer}{background}
\path (#1.west |- #2.north)+(-0.5,0.5) node (a1) {};
\path (#3.east |- #4.south)+(+0.5,-0.25) node (a2) {};
\path[fill=yellow!20,rounded corners, draw=black!50, dashed]
      (a1) rectangle (a2);
    \path (a1.east |- a1.south)+(0.8,-0.3) node (u1)[texto]
{#5};
  \end{pgfonlayer}}

\newcommand{\backgroundB}[5]{\begin{pgfonlayer}{background}
\path (#1.west |- #2.north)+(-0.5,0.5) node (a1) {};
\path (#3.east |- #4.south)+(+0.5,-0.25) node (a2) {};
\path[fill=red!20,rounded corners, draw=black!50, dashed]
      (a1) rectangle (a2);
    \path (a1.east |- a1.south)+(0.5,-0.3) node (u1)[texto]
{#5};
  \end{pgfonlayer}}

\newcommand{\transreceptor}[3]{\path [linepart] (#1.east) -- node [above]
    {\scriptsize Transreceptor #2} (#3);}


\pagestyle{plain}

\title{\huge Evaluate and Compare Two Utilization-Based
  Schedulability-Test Frameworks for Real-Time Systems}

\author{
    Jian-Jia Chen and Wen-Hung Huang\\
    Department of Informatics\\
    TU Dortmund University, Germany
    \and
    Cong Liu\\
    Department of Computer Science\\
    The University of Texas at Dallas
}
\vspace{3mm}



\begin{document}

\maketitle
\thispagestyle{plain}

\begin{abstract}
  This report summarizes two general frameworks, namely \frameworkkq{}
  and \frameworkku{}, that have been recently developed by us. The
  purpose of this report is to provide detailed evaluations and
  comparisons of these two frameworks. These two frameworks share some
  similar characteristics, but they are useful for different
  application cases.  These two frameworks together provide
  comprehensive means for the users to automatically convert the
  pseudo polynomial-time tests (or even exponential-time tests) into
  polynomial-time tests with closed mathematical forms.  With the
  quadratic and hyperbolic forms, \frameworkkq{} and \frameworkku{}
  frameworks can be used to provide many quantitive features to be
  measured and evaluated, like the total utilization bounds, speed-up factors, etc.,
  not only for uniprocessor scheduling but also for multiprocessor
  scheduling.  These frameworks can be viewed as ``blackbox''
  interfaces for providing polynomial-time schedulability tests and response time
  analysis for real-time applications.  We have already presented
  their advantages for being applied in some models in the previous
  papers.  However, it was not possible to present a more
  comprehensive comparison between these two frameworks. We hope this
  report can help the readers and users clearly understand the
  difference of these two frameworks, their unique characteristics,
  and their advantages. We demonstrate their differences and
  properties by using the traditional sporadic real-time task models
  in uniprocessor scheduling and multiprocessor global scheduling.
\end{abstract} 

\section{Introduction}
\label{sec:intro}

To analyze the worst-case response time or to ensure the timeliness of
the system, for each of individual task models, researchers tend to develop
dedicated techniques that result in schedulability tests with
different computation complexity and accuracy of the
analysis. Although many successful results have been developed, after
many real-time systems researchers devoted themselves for many years,
there does not exist a general framework that can provide  efficient and
effective analysis for different task models.

A very widely adopted case is the schedulability test of a
(constrained-deadline) sporadic real-time task  under
fixed-priority scheduling in uniprocessor systems, in which the
time-demand analysis (TDA) developed in
\cite{DBLP:conf/rtss/LehoczkySD89} can be adopted. That is, if

then task  is schedulable under the fixed-priority scheduling algorithm, where  is the set of tasks with higher priority than , , , and  represent 's relative deadline, worst-case execution time, and period, respectively. TDA requires pseudo-polynomial-time complexity to check the time points that lie in  for Eq.~\eqref{eq:exact-test-constrained-deadline}. 

However, it is not always necessary to test all possible time points
to derive a safe worst-case response time or to provide sufficient
schedulability tests.
The general and key concept to obtain sufficient schedulability tests in
\frameworkku{} in \cite{DBLP:journals/corr/abs-1501.07084,DBLP:conf/rtss/ChenHL15} and
\frameworkkq{} in \cite{DBLP:journals/corr/abs-kRTA,DBLP:conf/rtss/ChenHL16} is to test only a
subset of such points for verifying the schedulability. 
Traditional fixed-priority schedulability tests often have
pseudo-polynomial-time (or even higher) complexity. 
The idea
implemented in the \frameworkku{} and \frameworkkq{} frameworks  is to 
provide a general -point schedulability test, which
only needs to test  points under \textit{any} fixed-priority
scheduling when checking schedulability of the task with the 
highest priority in the system.  Moreover, this concept is further
extended in \frameworkkq{} to provide a safe upper bound of the
worst-case response time. The response time analysis and the
schedulability analysis provided by the frameworks can be viewed as
``\emph{blackbox}" interfaces that can result in sufficient utilization-based
analysis, in which the utilization of a task is its execution time
divided by its period.

The \frameworkku{} and \frameworkkq{}
frameworks are in fact two different important components for building
efficient and effective schedulability tests and response time
analysis. Even though they come from the same observations by testing
only  effective points, they are in fact fundamentally different
from mathematical formulations and have different properties.  In
\frameworkku{}, all the testings and formulations are based on the
task utilizations.  In \frameworkkq{}, the testings are based not only
on the task utilizations, but also on the task execution times.  The
different formulations of testings result in different types of
solutions.  The natural form of \frameworkku{} is a hyperbolic form
for testing the schedulability of a task, whereas the natural form of
\frameworkkq{} is a quadratic form for testing the schedulability or the
response time. In general, if the  points can be effectively
defined, \frameworkku{} has more precise results. However, if these
 points cannot be easily defined or there is some ambiguity to fine
the effective points, then \frameworkkq{} may be more suitable for such
models.

There have been several results in the literature with respect to
utilization-based, e.g.,
\cite{liu1973scheduling,HanTyan-RTSS97,journals/tc/LeeSP04,DBLP:conf/rtas/WuLZ05,kuo2003efficient}
for the sporadic real-time task model and its generalizations in uniprocessor systems.
The novelty of \frameworkku{} and \frameworkkq{} comes from a different
perspective from these approaches
\cite{liu1973scheduling,HanTyan-RTSS97,journals/tc/LeeSP04,DBLP:conf/rtas/WuLZ05,kuo2003efficient}. We
do not specifically seek for the total utilization bound. Instead, we
look for the critical value in the specified sufficient schedulability
test while verifying the schedulability of task . 
The natural condition to test
the schedulability of task  is a hyperbolic bound when
\frameworkku{} is adopted, whereas the nature condition to
test task  is a quadratic bound when \frameworkkq{} is adopted
(to be shown in Section~\ref{sec:framework}). The corresponding total
utilization bound can be obtained.

The generality of the \frameworkkq{} and \frameworkku{} frameworks has
been demonstrated in
\cite{DBLP:journals/corr/abs-1501.07084,DBLP:conf/rtss/ChenHL15,DBLP:journals/corr/abs-kRTA,DBLP:conf/rtss/ChenHL16}.
We believe that these two frameworks, to be used for different cases,
have great potential in analyzing many other complex real-time task
models, where the existing analysis approaches are insufficient or
cumbersome.  We have already presented their advantages for being
applied in some models in
\cite{DBLP:journals/corr/abs-1501.07084,DBLP:conf/rtss/ChenHL15,DBLP:journals/corr/abs-kRTA,DBLP:conf/rtss/ChenHL16}.
However, it was not possible to present a more comprehensive
comparison between these two frameworks in \cite{DBLP:journals/corr/abs-1501.07084,DBLP:conf/rtss/ChenHL15,DBLP:journals/corr/abs-kRTA,DBLP:conf/rtss/ChenHL16}. We hope this report can help
the readers and users clearly understand the difference of these
two frameworks, their unique characteristics, and their advantages.
Since our focus in this report is only to demonstrate the similarity,
the difference
and the characteristics of these two frameworks, we will use 
the simplest setting, i.e., the traditional sporadic real-time task
models in uniprocessor scheduling and multiprocessor global
scheduling.

For the \frameworkkq{} and \frameworkku{} frameworks, their
characteristics and advantages over other approaches have been already
discussed in
\cite{DBLP:journals/corr/abs-1501.07084,DBLP:conf/rtss/ChenHL15,DBLP:journals/corr/abs-kRTA,DBLP:conf/rtss/ChenHL16}. However,
between these two frameworks, we only gave short sketches and high-level descriptions of their
differences and importance. These explanations may seem
incomplete in \cite{DBLP:journals/corr/abs-1501.07084,DBLP:conf/rtss/ChenHL15,DBLP:journals/corr/abs-kRTA,DBLP:conf/rtss/ChenHL16} to explain whether both are needed or only one of them is important.  Therefore,
we would like to present in this report to explain why both frameworks
are needed and have to be applied for different cases.  Moreover, we
would like to emphasize that both frameworks are
important. In general, the \frameworkku{}
framework is more precise by using only the utilization values of the
higher-priority tasks. If we can formulate the schedulability tests
into the \frameworkku{} framework, it is also usually possible to
model it into the \frameworkkq{} framework. In such cases, the same
pseudo-polynomial-time test is used. When we consider the worst-case
quantitive metrics like utilization bounds, resource augmentation
bounds, or speedup factors, the result derived from the \frameworkku{}
framework is better for such cases. However, there are also cases, in
which formulating the test by using the \frameworkku{} framework is
not possible. These cases may even start from schedulability tests
with exponential-time complexity. We have successfully demonstrated
three examples in \cite{DBLP:journals/corr/abs-kRTA} by using the
\frameworkkq{} framework to derive polynomial-time tests. In those demonstrated cases, either
the \frameworkku{} framework cannot be applied or with worse results
(since different exponential-time or pseudo-polynomial-time schedulability tests are applied).

\noindent\textbf{Organizations.} The rest of this report is organized
as follows:
\begin{compactitem}
\item The basic terminologies and models are presented in
  Section~\ref{sec:model}. 
\item The two frameworks
  from\cite{DBLP:journals/corr/abs-1501.07084,DBLP:conf/rtss/ChenHL15,DBLP:journals/corr/abs-kRTA,DBLP:conf/rtss/ChenHL16}
  are summarized and presented in Section~\ref{sec:framework}.
\item We demonstrate two different comparisons between the frameworks
  by using sporadic task systems in uniprocessor systems and
  multiprocessor systems. 
\end{compactitem}
Note that this report does not intend to provide new theoretical
results. All the omitted proofs are already provided in
\cite{DBLP:journals/corr/abs-1501.07084,DBLP:conf/rtss/ChenHL15,DBLP:journals/corr/abs-kRTA,DBLP:conf/rtss/ChenHL16}. For
some simple properties derived from the results in
\cite{DBLP:journals/corr/abs-1501.07084,DBLP:conf/rtss/ChenHL15,DBLP:journals/corr/abs-kRTA,DBLP:conf/rtss/ChenHL16},
we will explain how such results are derived.




\section{Basic Task and Scheduling Models}
\label{sec:model}

This report will demonstrate the effectiveness and differences of the
two frameworks by using the sporadic real-time task model, even though
the frameworks target at more general task models. We define the
terminologies in this section for completeness.  A sporadic task
 is released repeatedly, with each such invocation called a
job. The  job of , denoted , is released
at time  and has an absolute deadline at time . Each
job of any task  is assumed to have execution time . Here
in this report, whenever we refer to the execution time of a job, we
mean for the worst-case execution time of the job, since all the analyses we use are safe by only considering 
the worst-case execution time.  The response time
of a job is defined as its finishing time minus its release
time. Successive jobs of the same task are required to execute in
sequence. Associated with each task  are a period , which
specifies the minimum time between two consecutive job releases of
, and a deadline , which specifies the relative deadline
of each such job, i.e., . The worst-case response
time of a task  is the maximum response time among all its
jobs.  The utilization of a task  is defined as .



A sporadic task system  is said to be an implicit-deadline
system if  holds for each . A sporadic task system
 is said to be a constrained-deadline system if 
holds for each .  Otherwise, such a sporadic task system
 is an arbitrary-deadline system.

A task is said \emph{schedulable} by a scheduling policy if all of its
jobs can finish before their absolute deadlines, i.e., the worst-case
response time of the task is no more than its relative deadline.  A
task system is said \emph{schedulable} by a scheduling policy if all
the tasks in the task system are schedulable. A \emph{schedulability
  test} is to provide sufficient conditions to ensure the feasibility
of the resulting schedule by a scheduling policy. 



Throughout the report, we will focus on fixed-priority preemptive
scheduling. That is, each task is associated with a priority
level. More specifically, we will only use rate monotonic (RM, i.e., 
tasks with smaller periods are with higher priority levels) and 
deadline monotonic (DM, i.e., 
tasks with smaller relative deadlines are with higher priority levels)
in this report.
For a uniprocessor system, the scheduler always dispatches the job
with the highest priority in the ready queue to be executed.  For a
multiprocessor system, we consider multiprocessor global scheduling on
 identical processors, in which each of them has the same
computation power. For global multiprocessor scheduling, there is a
global queue and a global scheduler to dispatch the jobs. We consider
only global fixed-priority scheduling. At any time, the
-highest-priority jobs in the ready queue are dispatched and
executed on these  processors.

Note that the above definitions are just for simplifying the
presentation flow in this report. The frameworks can still work for
non-preemptive scheduling and different types of fixed-priority
scheduling. 

We will only present the schedulability test of a certain task
, that is being analyzed, under the above assumption. For
notational brevity, in the framework presentation, we will implicitly
assume that there are  tasks, says  with higher-priority than task . \emph{These 
higher-priority tasks are assumed to schedulable before we move on
to test task .} We will use
 to denote the set of these  higher priority tasks,
when their orderings do not matter. Moreover, we only
consider the cases when , since  is pretty trivial.


\section{\frameworkku{} and \frameworkkq{} Frameworks}
\label{sec:framework}

This section presents the definitions and properties of the \frameworkku{} and \frameworkkq{} frameworks
for testing the schedulability of task  in a given set of
real-time task. The construction of the frameworks requires the
following definitions:


\begin{definition}
  \label{def:kpoints-k2u}
  A -point effective schedulability test is a sufficient schedulability test of a fixed-priority scheduling policy, that verifies the existence of  with  such that 
  where , , , and  are dependent upon the setting
  of the task models and task . \myendproof
\end{definition}



\begin{definition}[Last Release Time Ordering]
Let  be the last release time ordering assignment as a bijective
function  to define the last release time ordering
of task  in the window of interest. Last release time orderings are
numbered from  to , i.e., , where 1 is the earliest and  the
latest. \myendproof
\end{definition}

\begin{definition}
  \label{def:kpoints}
  A -point last-release schedulability test under a given ordering
   of the  higher priority tasks is a sufficient schedulability test of a fixed-priority scheduling policy, that verifies the existence of   such that 
  where , for , , , , and  are dependent upon the setting
  of the task models and task . \myendproof
\end{definition}
 
\begin{definition}
  \label{def:kpoints-response}
  A -point last-release response time analysis is a safe response time
  analysis of a fixed-priority scheduling policy under a given
  ordering  of the  higher-priority tasks by finding the
  maximum
  
with  and
  
  where , , , , and  are dependent upon the setting
  of the task models and task . \myendproof
\end{definition}

Throughout the report, we implicitly assume that  when
Definition~\ref{def:kpoints-k2u} and Definition~\ref{def:kpoints} are
used, as  is usually related to the given relative deadline
requirement. Note that  may still become  when
Definition~\ref{def:kpoints-response} for response time analysis is
used. Moreover, we only consider non-trivial cases, in which , and
, , ,
and  for .




\subsection{Comparison of Definition~\ref{def:kpoints-k2u} and Definition~\ref{def:kpoints}}
 

The definition of the -point last-release schedulability test  in Definition \ref{def:kpoints} only slightly differs from
the -point effective schedulability test  in
Definition~\ref{def:kpoints-k2u}.  However, since the tests are
different, they are used for different situations and the resulting
bounds and properties are also different.



In Definition~\ref{def:kpoints-k2u}, the -point effective
schedulability test is a sufficient schedulability test by testing
only  time points, defined by the  higher-priority tasks and
task .  These  points defined by the 
higher-priority tasks can be arbitrary as long as the corresponding
 and  can be defined. In
Definition~\ref{def:kpoints}, the  points defined by the 
higher-priority tasks have to be the last release times of the
highest-priority tasks, and the  higher-priority tasks have to be
indexed according to their last release time before .  In
Definition~\ref{def:kpoints}, the last release time ordering  is
assumed to be given. In some cases, this ordering can be easily
obtained. However, in some of the cases in our demonstrated task
models in \cite{DBLP:journals/corr/abs-kRTA}, the last release ordering cannot be 
defined. It may seem that 
we have to test all possible last release time orderings and
take the worst case. Fortunately, finding the
worst-case ordering is not a difficult problem, which requires to sort
the  higher-priority tasks under a simple criteria. Therefore,
before adopting the \frameworkkq{} framework, we have to know whether we
can obtain the last release time ordering or we have to consider a
pessimistic ordering for the higher priority tasks.


The frameworks assume that the corresponding coefficients 
and  in Definitions~\ref{def:kpoints-k2u},~\ref{def:kpoints},
and~\ref{def:kpoints-response} are given. How to derive them depends
on the task models and the scheduling policies.  Provided that these
coefficients , , ,  for every higher
priority task  are given, we can
find the worst-case assignments of the values  for
the higher-priority tasks . Therefore, in case
Definition~\ref{def:kpoints-k2u} is adopted, changing  affects the
values  and ; in case
Definitions~\ref{def:kpoints} and~\ref{def:kpoints-response} are
adopted, changing  only affects the value . 
By using the above approach, we can analyze (1)
the response time by finding the extreme case for a given  (under
Definition~\ref{def:kpoints-response}), or (2) the schedulability by
finding the extreme case for a given  and   (under
Definitions~\ref{def:kpoints-k2u} and Definition~\ref{def:kpoints}). 

In Section~\ref{sec:use-framework}, we will give a comparison about
the difference of Definition~\ref{def:kpoints-k2u} and Definition~\ref{def:kpoints} based on uniprocessor schedulability tests
for sporadic tasks.

\subsection{Properties of \frameworkku{}}

By using the property defined in Definition~\ref{def:kpoints-k2u}, we
can have the following lemmas in the \frameworkku{} framework
\cite{DBLP:journals/corr/abs-1501.07084,DBLP:conf/rtss/ChenHL15}. All the proofs of the
following lemmas are in
\cite{DBLP:journals/corr/abs-1501.07084,DBLP:conf/rtss/ChenHL15}.

  
\begin{lemma}
\label{lemma:framework-constrained-k2u}
For a given -point effective schedulability test of a scheduling 
algorithm, defined in
Definition~\ref{def:kpoints-k2u},
in which  and , and  for any
, task  is schedulable by the scheduling
algorithm if the following condition holds 

\end{lemma}


\begin{lemma}
\label{lemma:framework-totalU-constrained-k2u}
For a given -point effective schedulability test of a scheduling
algorithm, defined in
Definition~\ref{def:kpoints-k2u},
in which  and  and  for any
, task  is schedulable by the scheduling
algorithm if 

\end{lemma}


\begin{lemma}
\label{lemma:framework-totalU-exclusive-k2u}
For a given -point effective schedulability test of a scheduling
algorithm, defined in
Definition~\ref{def:kpoints-k2u},
in which  and  and  for any
, task  is schedulable by the scheduling
algorithm if 

\end{lemma}



\begin{lemma}
\label{lemma:framework-general-k2u}
For a given -point effective schedulability test of a fixed-priority scheduling
algorithm, defined in
Definition~\ref{def:kpoints-k2u}, task  is schedulable by the scheduling algorithm,
in which  and  and  for any
, 
 if
the following condition holds 

\end{lemma}

\subsection{Properties of \frameworkkq{}}
By using the property defined in Definition~\ref{def:kpoints}, we
can have the following lemmas in the \frameworkkq{} framework
\cite{DBLP:journals/corr/abs-kRTA,DBLP:conf/rtss/ChenHL16}.
All the proofs of the
following lemmas are in
\cite{DBLP:journals/corr/abs-kRTA,DBLP:conf/rtss/ChenHL16}.

  
\begin{lemma}
\label{lemma:framework-general-schedulability}
For a given -point last-release schedulability test, defined in
Definition~\ref{def:kpoints}, of a scheduling 
algorithm,
in which , and  for any
, , , and , task  is schedulable by the
fixed-priority scheduling
algorithm if the following condition holds

\end{lemma}

It may seem at first glance that we need to test all the possible
orderings. Fortunately, with the following lemma, we can safely
consider only one specific ordering of the  higher priority
tasks.
\begin{lemma}
  \label{lemma:general-sorting}
  The worst-case ordering  of the  higher-priority tasks under the schedulability condition in Eq.~\eqref{eq:schedulability-general} in Lemma~\ref{lemma:framework-general-schedulability} is to order the tasks in a non-increasing order of ,
 in which  and  for any , and .
\end{lemma}


The analysis in Lemma~\ref{lemma:framework-general-schedulability} uses the execution time and the utilization of the tasks in  to build an upper bound of  for  schedulability tests. It is also very convenient in real-time systems to build schedulability tests only based on utilization of the tasks. We explain how to achieve that in the following lemmas under the assumptions that , and  for any . 
These lemmas are useful when we are interested to derive utilization bounds, speed-up factors, resource augmentation factors, etc., for a given scheduling policy by defining the coefficients  and  according to the scheduling policies independently from the detailed parameters of the tasks. 
 Since the property repeats in all the statements, we make a formal definition before presenting the lemmas.
\begin{definition}
  \label{def:alpha-upper-bound}
  Lemmas~\ref{lemma:framework-constrained-schedulability} to
  \ref{lemma:framework-totalU-constrained} are based on the
  following -point last-release schedulability test of a scheduling
  algorithm, defined in Definition~\ref{def:kpoints}, in which , and  for
  any , , , and .
\end{definition}

\begin{lemma}
\label{lemma:framework-constrained-schedulability}
For a given -point last-release schedulability test of a scheduling 
algorithm, with the properties in Definition~\ref{def:alpha-upper-bound}, 
task  is schedulable by the scheduling
algorithm if the following condition holds
{\small }
\end{lemma}


\begin{figure*}[t]
	\begin{center}
      \begin{tikzpicture}[scale=0.9,transform shape]
\path \practica {1}{\underline{\bf Demonstrated Applications:}
          \begin{tabular}{ll}
          Sec. 5:& Uniprocessor sporadic tasks\\
          Sec. 6:& Multiprocessor global RM\\
          \multicolumn{2}{l}{and several others in \cite{DBLP:journals/corr/abs-1501.07084,DBLP:conf/rtss/ChenHL15,DBLP:journals/corr/abs-kRTA,DBLP:conf/rtss/ChenHL16}. }
          \end{tabular}
        };
\path (p1.west)+(2.2,-7.8) node(p2)[materia, rounded
        rectangle,text width=7.2em]{{\bf \\ \\\\\\\\  {\scriptsize(for Lemmas \ref{lemma:framework-general-schedulability}-\ref{lemma:framework-totalU-constrained})}}}; 
        \path (p2.north)+(1.5,0.45) node[text width=16em]{Derive
          parameters\\by \underline{Definitions 3 or 4}};
        \path (p2.east)+(3,0) node(p3)[practica,fill=blue!40,text width=5em,text centered]{\large{\bf \\ framework}}; 


        \path (p3.east)+(4.5,+3) node(p4)[practica,fill=green!45,minimum width=6em,text width=5em,text centered]{Quadratic bound}; 
        \path (p4.south)+(0,-1) node(p5)[practica,fill=green!45,minimum width=6em,text width=5em,text centered]{Other utilization bounds}; 
        \path (p5.south)+(0,-1)
        node(p6)[practica,fill=green!45,minimum width=6em,text
        width=5em,text centered]{Response-time test}; 
        
        \path [line, ->] (p1.west)+(0,0.8) -- +(-1,0.8) node[black, rotate=90,
        yshift=0.3cm, xshift=-4cm]{\footnotesize{define the
            last release time ordering  or use Lemma~\ref{lemma:general-sorting} or \ref{lemma:general-response-sorting}}} -- + (-1, -7.8) -- (p2.west);
        \path [line, ->] (p2.east) -- (p3.west);
        \path [line, ->] (p3.east)+(0,0.3) -- node[rotate=45,yshift=0.3cm,black]{Lemma \ref{lemma:framework-general-schedulability}} (p4.west);
        \path [line, ->] (p3.east)+(0,0) -- node[rotate=25,yshift=0.3cm,black]{Lemmas \ref{lemma:framework-constrained-schedulability}-~\ref{lemma:framework-totalU-constrained}} (p5.west);
        \path [line, ->] (p3.east)+(0,-0.3) --
        node[rotate=3,yshift=0.3cm,black]{Lemma \ref{lemma:framework-general-response}} (p6.west);
\path (p1.west)+(2.8,-3) node(p12)[materia, rounded rectangle,text width=6em]{{\bf \\\\\\}}; 
        \path (p12.north)+(1.5,0.45) node[text width=16em]{Derive parameters\\by \underline{Definition 1}};
        \path (p12.east)+(3,0) node(p13)[practica,fill=blue!10,text width=5em,text centered]{\large{\bf \frameworkku{}\\ framework}}; 


        \path (p13.east)+(4.5,+3) node(p14)[practica,fill=green!15,minimum width=6em,text width=5em,text centered]{Hyperbolic bound}; 
        \path (p14.south)+(0,-1) node(p15)[practica,fill=green!15,minimum width=6em,text width=5em,text centered]{Other utilization bounds}; 
        \path (p15.south)+(0,-1) node(p16)[practica,fill=green!15,minimum width=6em,text width=5em,text centered]{Extreme points test}; 
        
        \path [line, ->] (p1.west) -- +(-0.3,0) node[black, rotate=90, yshift=0.3cm, xshift=-1.6cm]{\footnotesize{define  and order  tasks}} -- + (-0.3, -3) -- (p12.west);
        \path [line, ->] (p12.east) -- (p13.west);
        \path [line, ->] (p13.east)+(0,0.3) -- node[rotate=40,yshift=0.3cm,black]{Lemma \ref{lemma:framework-constrained-k2u}} (p14.west);
        \path [line, ->] (p13.east)+(0,0) -- node[rotate=25,yshift=0.3cm,black]{Lemmas \ref{lemma:framework-totalU-constrained-k2u}\&~\ref{lemma:framework-totalU-exclusive-k2u}} (p15.west);
        \path [line, ->] (p13.east)+(0,-0.3) -- node[rotate=5,yshift=0.3cm,black]{Lemma \ref{lemma:framework-general-k2u}} (p16.west);
      \end{tikzpicture}    
	\end{center}
\vspace{-2mm}
\caption{The \frameworkku{} and \frameworkkq{} frameworks. }
\label{fig:framework}
\end{figure*}


\begin{lemma}
\label{lemma:framework-totalU-exclusive}
For a given -point last-release schedulability test of a scheduling 
algorithm, with the properties in Definition~\ref{def:alpha-upper-bound}, 
task  is schedulable by the scheduling
algorithm if 

\end{lemma}

\begin{lemma}
\label{lemma:framework-totalU-constrained}
For a given -point last-release schedulability test of a scheduling 
algorithm, with the properties in Definition~\ref{def:alpha-upper-bound}, 
provided that , 
then task  is schedulable by the scheduling
algorithm if  
{\small
 
}
\end{lemma}

The right-hand side of
Eq.~\eqref{eq:schedulability-totalU-constrained} (when
) decreases with
respect to . Similarly, the right-hand side of
Eq.~\eqref{eq:schedulability-totalU-exclusive} also decreases with
respect to . Therefore, for evaluating the utilization bounds, it
is alway safe to take  as a safe upper bound. The
right-hand side of Eq.~\eqref{eq:schedulability-totalU-exclusive}
converges to  when .  The right-hand side of
Eq.~\eqref{eq:schedulability-totalU-constrained}  (when
) converges to
 when
.



The following two lemmas are from the -point last-release response time analysis, defined in
Definition~\ref{def:kpoints-response}.
\begin{lemma}
\label{lemma:framework-general-response}
For a given -point last-release response time analysis of a scheduling 
algorithm, defined in
Definition~\ref{def:kpoints-response},
in which ,  for any
,  and , the response time to execute  for task
 is at most

\end{lemma}



\begin{lemma}
  \label{lemma:general-response-sorting}
  The worst-case ordering  of the  higher-priority tasks
  under the response bound in
  Eq.~\eqref{eq:schedulability-general-response} in Lemma~\ref{lemma:framework-general-response} is to order the tasks in a non-increasing order of ,
 in which  and  for any , .
\end{lemma}

\section{How to Use the Frameworks}
\label{sec:use-framework}

The \frameworkku{} and \frameworkkq{} frameworks can be used by a wide range of applications, as
long as the users can properly specify the corresponding task
properties  (in case of \frameworkkq{}) and  and the constant
coefficients  and  of every higher priority task
. The choice of the parameters  and 
affects the quality of the resulting schedulability bounds.  However,
deriving the \emph{good} settings of  and  is
not the focus of the frameworks. The frameworks do not care how
the parameters  and  are obtained. It simply
derives the bounds according to the given parameters  and
, regardless of the settings of  and . The
correctness of the settings of  and  is not
verified by the frameworks. Figure \ref{fig:framework} provides an overview of the procedures.

The ignorance of the settings of  and  actually
leads to the elegance and the generality of the frameworks, which work
as long as Definitions~\ref{def:kpoints-k2u}, \ref{def:kpoints}, or
\ref{def:kpoints-response} can be successfully constructed for the
sufficient schedulability test or the response time analysis.  The
other approaches in
\cite{journals/tc/LeeSP04,DBLP:dblp_journals/tc/BurchardLOS95,HanTyan-RTSS97}
also have similar observations by testing only several time points in
the TDA schedulability analysis based on
Eq.~\eqref{eq:exact-test-constrained-deadline} in their problem
formulations. However, as these approaches in
\cite{journals/tc/LeeSP04,DBLP:dblp_journals/tc/BurchardLOS95,HanTyan-RTSS97}
seek for the total utilization bounds, they have limited applications
and are less flexible. For example, they are typically not applicable
directly when considering sporadic real-time tasks with arbitrary
deadlines or multiprocessor systems.

The \frameworkku{} and \frameworkkq{} frameworks provide comprehensive means for the users to
almost automatically convert the pseudo polynomial-time tests (or even
exponential-time tests) into polynomial-time tests with closed
mathematical forms.  With the availability of the \frameworkku{} and \frameworkkq{} frameworks,
the hyperbolic bounds, quadratic bounds, or speedup factors can be
almost automatically derived by adopting the provided lemmas in Section~\ref{sec:framework}
as long as the safe upper bounds  and  to cover all the
possible settings of  and  for the schedulability
test or the response-time analysis can be derived, regardless of the
task model or the platforms.

The above characteristics and advantages over other approaches have
been already discussed in
\cite{DBLP:journals/corr/abs-1501.07084,DBLP:conf/rtss/ChenHL15,DBLP:journals/corr/abs-kRTA,DBLP:conf/rtss/ChenHL16}. However,
between these two frameworks, it is unclear
whether both are needed or only one of them is important.

As the simplest example, consider the test of task  with
 in an implicit-deadline sporadic task set in uniprocessor RM scheduling. Suppose that task
 has utilization . If we only use the utilization of
the higher-priority tasks as the means of testing, modeling the
schedulability test in Definition~\ref{def:kpoints} is less precise
since we may have to inflate and set  properly according to the
given priority assignment. Using Definition~\ref{def:kpoints-k2u} with
 leads to , but using Definition~\ref{def:kpoints}
with any  can only be feasible if we set  to
. Therefore, for such cases, we can only be safe by putting , and, therefore, using \frameworkkq{} is more pessimistic
than using \frameworkku{}.

In the above example, it may seem at first glance that the test in the
\frameworkku{} framework is better than the test in the \frameworkkq{}
framework. However, this observation can only hold if a
schedulability test can be applicable to satisfy
Definition~\ref{def:kpoints-k2u} and Definition~\ref{def:kpoints}.

We test the above case with different settings of 
with  when  is
. Figure~\ref{fig:2tasks-example-rm} illustrates the maximum
utilization of task  by using different tests from the two
frameworks. In such a case, we can clearly define  as
. Therefore,  is 
and  is set to  when
adopting Lemma \ref{lemma:framework-constrained-k2u} from
\frameworkku{}. Moreover,  is  and  is set to
 when adopting Lemma
\ref{lemma:framework-constrained-schedulability} from \frameworkkq{}.

As shown in Figure~\ref{fig:2tasks-example-rm}, when we adopt only
utilizations of the higher-priority task, i.e., Lemma
\ref{lemma:framework-constrained-k2u} from \frameworkku{} and Lemma
\ref{lemma:framework-constrained-schedulability} from \frameworkkq{},
the results from \frameworkku{} are always better. However, the results
of Lemma \ref{lemma:framework-constrained-k2u} from \frameworkku{} and
Lemma \ref{lemma:framework-general-schedulability} from \frameworkkq{}
are not comparable. 

Therefore, there is no clear dominator between these two frameworks.
Moreover, there are also cases, in which formulating the test by using
the \frameworkku{} framework is not possible (c.f. the results in
Theorems~\ref{theorem:response-time-sporadic} and
\ref{thm:multiprocessor-grm-sporadic-tight}). These cases may even
start from schedulability tests with exponential-time complexity. We
have successfully demonstrated three examples in
\cite{DBLP:journals/corr/abs-kRTA} by using the \frameworkkq{} framework
to derive polynomial-time tests with approximation guarantees. In
those demonstrated cases, either the \frameworkku{} framework cannot
be applied or with worse results (since different exponential-time or
pseudo-polynomial-time schedulability tests are applied).



\begin{figure}[t]
   \centering
  \includegraphics[width=\columnwidth]{2tasks-comparison.pdf}
  \caption{Adopting different tests from \frameworkku{} and \frameworkkq{} for RM uniprocessor scheduling with .}
    \label{fig:2tasks-example-rm}
\end{figure}



\section{Analysis for Sporadic Task Models}
\label{sec:sporadic}

This section examines the applicability of the \frameworkku{} and
\frameworkkq{} frameworks to derive utilization-based schedulability
analysis and response-time analysis for sporadic task systems in
uniprocessor systems. We will consider constrained-deadline systems in
Section~\ref{sec:constrained-deadline} and arbitrary-deadline systems
in Section~\ref{sec:arbitrary-deadline}.  For a specified
fixed-priority scheduling algorithm, let  be the set of
tasks with higher priority than . We now classify the task set
 into two subsets:
\begin{itemize}
\item  consists of the higher-priority tasks with periods
  smaller than .
\item  consists of the higher-priority tasks with periods
  larger than or equal to .
\end{itemize}
For the rest of this section, we will implicitly assume .


\subsection{Constrained-Deadline}
\label{sec:constrained-deadline}

For a constrained-deadline task , the schedulability test in
Eq.~\eqref{eq:exact-test-constrained-deadline}  is equivalent to the
verification of the existence of  such that

We can then create a virtual sporadic task  with execution
time , relative
deadline , and period . It is
clear that the schedulability test to verify the schedulability of
task  under the interference of the higher-priority tasks
 is the same as that of task  under the
interference of the higher-priority tasks .
For notational brevity, suppose that there are  tasks, indexed
as , in
. 



\noindent\textbf{Adopting \frameworkku{}}: \hspace{1cm}
Setting  for every
task  in , and indexing the
tasks in a non-decreasing order of  lead to the satisfaction of
Definition~\ref{def:kpoints-k2u} with  and .
Therefore, we can apply Lemmas~\ref{lemma:framework-constrained-k2u}
and~\ref{lemma:framework-totalU-constrained-k2u} to obtain the
following theorem. 
 
\begin{theorem}
\label{theorem:sporadic-general-k2u}
Task  in a sporadic task system with constrained deadlines is
schedulable by the fixed-priority scheduling algorithm if

or

\end{theorem}

\begin{corollary}
\label{corollary-rm-k2u}
Task  in a sporadic task system with implicit deadlines is
schedulable by the RM scheduling algorithm if
Lemmas \ref{lemma:framework-totalU-constrained-k2u}
and \ref{lemma:framework-totalU-exclusive-k2u}
holds by setting
 as , , and .
\end{corollary}

The above result in Corollary~\ref{corollary-rm-k2u} leads to the
utilization bound  (by using
Lemma~\ref{lemma:framework-totalU-constrained-k2u} with  and
) for RM scheduling, which is the same as the Liu and Layland
bound  \cite{liu1973scheduling}. It also leads to the
hyperbolic bound for RM scheduling by Bini and Buttazzo
\cite{bini2003rate} when adopting
Theorem~\ref{theorem:sporadic-general-k2u} directly.

\noindent\textbf{Adopting \frameworkkq{}}: \hspace{1cm} 
Setting  for every
task  in , and indexing the
tasks in a non-decreasing order of  leads to the satisfaction of
Definition~\ref{def:kpoints} with  and
.  For such a case, the last release ordering is well-defined by the sorting of the tasks above.
Therefore, we can use
Lemma~\ref{lemma:framework-general-schedulability} to derive the
following theorem.

\begin{theorem}
\label{theorem:sporadic-general}
Task  in a sporadic task system with constrained deadlines is
schedulable by the fixed-priority scheduling algorithm if
 and

in which the  higher priority tasks in  are indexed
in a non-decreasing order of .
\end{theorem}

\begin{corollary}
\label{corollary-rm}
Task  in a sporadic task system with implicit deadlines is
schedulable by the RM scheduling algorithm if
Lemmas~\ref{lemma:framework-general-schedulability},~\ref{lemma:framework-constrained-schedulability},
\ref{lemma:framework-totalU-exclusive},
or~\ref{lemma:framework-totalU-constrained} holds by setting
 as , , and .
\end{corollary}

The above result in Corollary~\ref{corollary-rm} leads to the
utilization bound  (by using
Lemma~\ref{lemma:framework-totalU-constrained} with  and
) for RM scheduling, which is worse than the existing
Liu and Layland bound  \cite{liu1973scheduling}. 

Moreover, the above utilization bound  has been also
provided by Abdelzaher et al. \cite{DBLP:journals/tc/AbdelzaherSL04}
for uniprocessor deadline-monotonic scheduling when an aperiodic task
may generate different task instances (jobs) with different
combinations of execution times and minimum inter-arrival times. Such
a model is a more general model than the sporadic task model. Under
such a setting, the \frameworkku{} framework cannot be used, whereas
the \frameworkkq{} framework is very suitable.

\subsection{Arbitrary-Deadline}
\label{sec:arbitrary-deadline}

The schedulability analysis for arbitrary-deadline sporadic task sets
is to use a \emph{busy-window} concept to evaluate the worst-case
response time \cite{DBLP:conf/rtss/Lehoczky90}. That is, we release
all the higher-priority tasks together with task  at time 
and all the subsequent jobs are released as early as possible by
respecting to the minimum inter-arrival time. The busy window finishes
when a job of task  finishes before the next release of a job
of task . It has been shown in
\cite{DBLP:conf/rtss/Lehoczky90} that the worst-case response time of
task  can be found in one of the jobs of task  in the
busy window.
For the -th job of task  in the busy window, let  the finishing
time  is the minimum  such that
 
and, hence, its response time is . The busy window
of task  finishes on the -th job if . 

A simpler sufficient schedulability test for a task  is to
test whether the length of the busy window is within .  If so,
all invocations of task  released in the busy window can
finish before their relative deadline. Such an observation has also
been adopted in \cite{conf:/rtns09/Davis}. Therefore, a sufficient
test is to verify whether

If the condition in Eq.~\eqref{eq:sufficient-test-arbitrary-deadline} holds,
it implies that the busy window (when considering task ) is no
more than , and, hence, task  has worst-case response
time no more than .

Similarly, we can use  and , as in
Section~\ref{sec:constrained-deadline}, and, then create a virtual
sporadic task  with execution time ,
relative deadline , and period . 
For notational brevity, suppose that there are  tasks, indexed
as , in
. 


\noindent\textbf{Adopting \frameworkku{}}: \hspace{1cm}
Setting , and indexing the
tasks in a non-decreasing order of  leads to the satisfaction of
Definition~\ref{def:kpoints-k2u} with  and . Therefore, we can apply Lemmas~\ref{lemma:framework-constrained-k2u}
and~\ref{lemma:framework-totalU-constrained-k2u} to obtain the
following theorem. 

\begin{theorem}
\label{theorem:sporadic-arbitrary-k2u}
Task  in a sporadic task system with arbitrary deadlines is
schedulable by the fixed-priority scheduling algorithm if

or

\end{theorem}


\noindent\textbf{Adopting \frameworkkq{}}: \hspace{1cm}  If we use the
busy-window concept to analyze the schedulability of task  by
using Eq.~\eqref{eq:sufficient-test-arbitrary-deadline}, we can reach
the following theorem directly by
Lemma~\ref{lemma:framework-general-schedulability}.
\begin{theorem}
\label{theorem:schedulability-sporadic-arbitrary}
Task  in a sporadic task system is
schedulable by the fixed-priority scheduling algorithm if
 and

in which , and the  higher priority tasks in  are indexed
in a non-decreasing order of .
\end{theorem}


Analyzing the schedulability by using
Theorem~\ref{theorem:schedulability-sporadic-arbitrary} can be good if
 is small. However, as the busy window may be
stretched when  is large, it may be too pessimistic.  
Suppose that 
for a higher priority task . We index the tasks such that the
last release ordering  of the  higher priority tasks is with
 for . Therefore, we know that
 is upper bounded by finding the maximum
  
with  and
  
Therefore, the above derivation of  satisfies
Definition~\ref{def:kpoints-response} with , and
 for any higher priority task . However, it should
be noted that the last release time ordering  is actually unknown
since  is unknown. Therefore, we have to apply
Lemma~\ref{lemma:general-response-sorting} for such cases to obtain
the worst-case ordering.

\begin{lemma}
  \label{lemma:finishing-time-sporadic-h}
  Suppose that . Then, for any
   and , we have
  
  where the  higher-priority tasks are ordered
  in a non-increasing order of their periods.
\end{lemma}

The worst-case response time for such cases can be set to , in
which the detailed proof is in \cite{DBLP:journals/corr/abs-kRTA,DBLP:conf/rtss/ChenHL16}.
\begin{theorem}
  \label{theorem:response-time-sporadic}
  Suppose that . The worst-case
  response time of task  is at most
  
  where the  higher-priority tasks are ordered
  in a non-increasing order of their periods.
\end{theorem}

\begin{corollary}
  \label{corollary:arbitrary-response-schedulability}
  Task  in a sporadic task system is schedulable by the
  fixed-priority scheduling algorithm if 
  and 
  
  where the  higher-priority tasks are ordered
  in a non-increasing order of their periods.
\end{corollary}

\subsection{Analytical Comparison of \frameworkkq{} and \frameworkku{}}

The utilization-based worst-case response-time analysis in  
Theorem~\ref{theorem:response-time-sporadic} is analytically tighter  
than the best known result, , by Bini et  
al. \cite{bini2009response}. 
 Lehoczky \cite{DBLP:conf/rtss/Lehoczky90} also provides the total
utilization bound of RM scheduling for arbitrary-deadline systems. The
analysis in \cite{DBLP:conf/rtss/Lehoczky90} is based on the Liu and
Layland analysis \cite{liu1973scheduling}. The resulting utilization
bound is a function of . When
 is , it is an implicit-deadline system. The utilization
bound in \cite{DBLP:conf/rtss/Lehoczky90} has a closed-form when
 is an integer. However, calculating the utilization bound for
non-integer  is done asymptotically for  with
complicated analysis.  Bini \cite{DBLP:journals/tc/Bini15} provides a total utilization bound
of RM scheduling, based on the quadratic response time analysis in
\cite{bini2009response}, that works for any arbitrary ratio of
. 

For constrained-deadline sporadic task sets, since the same test in
Eq.~\eqref{eq:exact-test-constrained-deadline-2} is used for
constructing Definition~\ref{def:kpoints-k2u} and
Definition~\ref{def:kpoints}, the result (with respect to the
conditions in Theorem~\ref{theorem:sporadic-general-k2u},
Corollary~\ref{corollary-rm-k2u},
Theorem~\ref{theorem:response-time-sporadic}, and
Corollary~\ref{corollary-rm}) by using \frameworkku{} is superior to
that by using \frameworkkq{}. The speedup factor of the test in
Eq.~\eqref{eq:schedulability-sporadic-k2u-any-a} in
Theorem~\ref{theorem:sporadic-arbitrary-k2u} has been proved to be
, which is also better than that in
Eq.~\eqref{eq:schedulability-sporadic-any-a} in
Theorem~\ref{theorem:schedulability-sporadic-arbitrary}.\footnote{The
 speedup factor for the schedulability test by using Eq.~\eqref{eq:schedulability-sporadic-any-a} is . This
  is obtained by ignoring the last term in the right-hand-side of
  Eq.~\eqref{eq:schedulability-sporadic-any-a}. Since this is not
  analytically superior, the analysis was not shown in \cite{DBLP:journals/corr/abs-kRTA}.} 
However, the quadratic bound in
Eq.~\eqref{eq:schedulability-sporadic-any-a} can be better than the
hyperbolic bound in Eq.~\eqref{eq:schedulability-sporadic-k2u-any-a}, as demonstrated
in the evaluations. 


For arbitrary-deadline sporadic task sets, two different
tests are applied: one comes from
Eq.~\eqref{eq:sufficient-test-arbitrary-deadline} for constructing
Theorem~\ref{theorem:sporadic-arbitrary-k2u} and
Theorem~\ref{theorem:schedulability-sporadic-arbitrary} and another
comes from Eqs.~\eqref{eq:sporadic-arbitrary-objective-k} and
\eqref{eq:sporadic-arbitrary-objective-k2} for construction
Theorem~\ref{theorem:response-time-sporadic} and
Corollary~\ref{corollary:arbitrary-response-schedulability}. It should
be clear that the test from
Eqs.~\eqref{eq:sporadic-arbitrary-objective-k} and
\eqref{eq:sporadic-arbitrary-objective-k2} is tighter than that from
Eq.~\eqref{eq:sufficient-test-arbitrary-deadline}. Therefore, these
results are not analytically comparable. 




Note that we can also use Lemma~\ref{lemma:framework-general-k2u} by
defining the values of  and  for each task 
in  precisely to make the hyperbolic bound in
Eq.~\eqref{eq:schedulability-sporadic-k2u-any-a} and
Eq.~\eqref{eq:schedulability-sporadic-arbitrary-k2u-any-a} more
precisely. Their performance will be provided in the evaluation results.


\subsection{Simulation Environment}
\label{subsec:simulation-env}
The rest of this section presents our evaluation results for the above tests. 
We generated a set of sporadic tasks. The cardinality of the task set was .
The UUniFast-Discard method~\cite{davis2011improved} was adopted to generate a set of utilization values with the given goal.
We  used the approach suggested by Davis et
al.~\cite{davis2008efficient}
to generate the task periods according
to a uniform distribution in the range of the logarithm of the task periods (i.e.,
log-uniform distribution).  
The order of magnitude  to control the period values between the largest and smallest periods is parameterized in evaluations, (e.g.,  for ,  for , etc.). 
We evaluate these tests in uniprocessor systems with .
The priority ordering of the tasks is assigned according to deadline-monotonic (DM) scheduling. The execution time was set accordingly, i.e., .



\begin{figure*}[t]
   \centering
  \includegraphics[width=\textwidth]{figures/up/uni-constrained.pdf}
  \caption{Performance evaluation on uniprocessor systems in terms of acceptance ratio for constrained-deadline uniprocessor systems where .}
    \label{fig:uni-1}
\end{figure*}

The metric to compare results is to measure the \emph{acceptance ratio} of the above tests with respect to a given task set utilization. 
We generate 100 task sets for each utilization level.
The acceptance ratio of a level is said to be the number of task sets that are schedulable under the schedulability test divided by the number of task sets for this level, i.e., 100. 


\subsection{Evaluation for Constrained Deadline Systems} 
Task relative deadlines were uniformly drawn from the interval .  
The evaluated  tests are as follows:
\begin{itemize}
\item \emph{RTA}: the exact response time test by Lehoczky et al. \cite{DBLP:conf/rtss/LehoczkySD89}.
\item \emph{Bini}: the linear-time response time bound by Bini et al.~\cite{bini2009response}.
\item \emph{HP} (from \frameworkku{}): Eq.~\eqref{eq:schedulability-sporadic-k2u-any-a} in Theorem~\ref{theorem:sporadic-general-k2u} in this report.
\item \emph{HP-EP} (from \frameworkku{}): using Lemma~\ref{lemma:framework-general-k2u}
  (with a more precise extreme point) by defining the values of
   and  for each task  in 
  precisely in this report. This improves HP.
\item \emph{QB} (from \frameworkkq{}): Eq.~\eqref{eq:schedulability-sporadic-any-a} in Theorem~\ref{theorem:sporadic-general} in this report.
\end{itemize}


\vspace{0.1in}
{\noindent \bf Results.}
Figure~\ref{fig:uni-1} shows that the performance of the above tests in terms of acceptance ratios, for three different settings of .
The tests by HP-EP, Bini, QB, and RTA are sensitive to : the larger the value of  is, the more the test sets they admit. In the case of , the test by Bini (the QB test, respectively) can admit all task sets with their total utilizations of up to  (, respectively), and its performance starts to decline at utilization  (, respectively). On the other hand, the tests by HP and HP-EP can fully accept a task set with around  more utilizations, but acceptance ratio of HP drops sharply and becomes completely ineffective at utilization . 

In the case of , we can also see that test HP derived from
\frameworkku{} and test QB derived from \frameworkkq{} are
incomparable. HP itself becomes pessimistic since we do not take the
different values of  to have more precise tests, whereas
HP-EP is more precise. In general, for
uniprocessor constrained-deadline task systems, we can observe that
HP-EP outperforms the other polynomial-time tests.  Due to the
analytical dominance, we also see that the QB test dominates the test
by Bini.



\subsection{Evaluation for Arbitrary-Deadline Systems}

Task relative deadlines were uniformly drawn from the interval .  
The tests evaluated are shown as follows:
\begin{itemize}
\item \emph{RTA}: the exact response time test by Lehoczky\cite{DBLP:conf/rtss/Lehoczky90}.
\item \emph{Bini}: the linear-time response time bound by Bini et al.~\cite{bini2009response}.
\item \emph{HP-Busy} (from \frameworkku{}): Eq.~\eqref{eq:schedulability-sporadic-arbitrary-k2u-any-a} from Theorem~\ref{theorem:sporadic-arbitrary-k2u}  in this report
\item \emph{HP-EP} (from \frameworkku{}): using Lemma~\ref{lemma:framework-general-k2u}
  (with a more precise extreme point) by defining the values of
   and  for each task  in 
  precisely in this report. This improves HP-Busy. 
\item \emph{QB-Busy} (from \frameworkkq{}): Eq.~\eqref{eq:schedulability-sporadic-any-arbitrary-a} in Theorem~\ref{theorem:schedulability-sporadic-arbitrary} in this report.
\item \emph{QB-Response} (from \frameworkkq{}): Eq.~\eqref{eq:R-D-k} in Corollary~\ref{corollary:arbitrary-response-schedulability} in this report.
\end{itemize}

{\noindent \bf Results.}  Figure~\ref{fig:uni-2} compares the
performance on arbitrary-deadline uniprocessor system where
.  
Analytically, we know that test by QB is superior to that by Bini,
which is the best-known test for arbitrary-deadline uniprocessor
systems.  The results shown in Figure~~\ref{fig:uni-2} also support
such dominance.

In the case of , the acceptance ratio by Bini decreases steadily from utilization  to .
On the other hand, the number of task sets accepted by QB-Response starts to decrease at utilization . Test QB-Response is able to admit more task tests from utilization  to , compared to test Bini. With utilization more , Bini performs better than QB-Busy. In the other cases, Bini outperforms QB-Busy.

For arbitrary-deadline systems, since the test in
Eq.~\eqref{eq:sufficient-test-arbitrary-deadline} is too pessimistic
by checking whether the busy-window length is no more than ,
HP-Busy, HP-EP, and QB-Busy do not perform very well. In the above
experimental results, the quadratic forms by using \frameworkkq{} are
better than the hyperbolic forms by using \frameworkku{} in such
cases. This is due to the fact that these two tests start from
different pseudo-polynomial time tests.





\begin{figure*}[t]
  \centering
   \includegraphics[width=\textwidth]{figures/up/uni-arbitrary.pdf}
  \caption{Performance evaluation on uniprocessor systems in terms of acceptance ratio for arbitrary-deadline uniprocessor systems where }
    \label{fig:uni-2}
\end{figure*}

\section{Global RM Scheduling}
\label{sec:global-sporadic}

This section demonstrates the two frameworks 
for multiprocessor global fixed-priority scheduling. We consider that
the system has  identical processors. For global fixed-priority
scheduling, there is a global queue and a global scheduler to dispatch
the jobs. We demonstrate the applicability for implicit-deadline
sporadic systems under global RM.

Unfortunately, unlike uniprocessor systems, up to now, there is no
exact schedulability test to verify whether task  is schedulable
by global RM.  Therefore, existing schedulability
tests (in pseudo-polynomial time or exponential time) are only
sufficient tests. We will use three different tests for demonstrating
the use of the \frameworkku{} and \frameworkkq{} frameworks and compare their results.

One way to quantify the quality of the resulting schedulability test
is to use the \emph{capacity augmentation factor} \cite{Li:ECRTS14}.
Suppose that the test is to verify whether the total utilization

and the maximum utilization . Such a factor  has
been recently named as a \emph{capacity augmentation factor}
\cite{Li:ECRTS14}. 


We only consider testing the schedulability of task  under
global RM, where . For , the global RM scheduling
guarantees the schedulability of task  if . Without loss of generality, we limit our presentation to the
case that  for
, for the simplicity of presentation.

\subsection{Adopted Pseudo-Polynomial-Time and Exponential-Time Tests}

We now present three different tests that require
pseudo-polynomial-time or exponential-time complexity.

\noindent{\bf Greedy-Carry-In}:  The first one is based on a simple observation to carry-in a job for
each of the higher-priority tasks in the window of interest \cite{DBLP:conf/rtss/GuanSYY09}. The
following time-demand function  can be used for a simple
sufficient schedulability test:

That is, we allow the first release of task  to be inflated by
a factor , whereas the other jobs of task  have the same
execution time .  
Therefore, task  is schedulable under global RM on 
identical processors, if
{\small  
}
 
\noindent{\bf Bounded-Carry-In}:  
The second test is based on the observation by Guan et
al. \cite{DBLP:conf/rtss/GuanSYY09} that we only have to consider
 tasks with carry-in jobs, for constrained-deadline task sets.
 For implicit-deadline
task sets, this means that we only need to set  of some
tasks to , rather than all the  tasks in
Eq.~\eqref{eq:W_i-multiprocessor}. More precisely, we can define two
different time-demand functions, depending on whether task  is
with a carry-in job or not:\footnote{This is an over-approximation of the linear function used by Guan et al. \cite{DBLP:conf/rtss/GuanSYY09}.}

and

Moreover, we can further over-approximate , since  . Therefore, a sufficient schedulability test for testing task  with  for global RM is to verify whether 

for all  with . It is
not necessary to enumerate all  with  if
 we can construct the task set 
with the maximum .


\noindent{\bf Forced-Forward}: The third one is based on a
reformulation of the forced-forward approach by Baruah et
al. \cite{DBLP:journals/rts/BaruahBMS10}. This is the reformulation in
\cite{DBLP:journals/corr/abs-kRTA} based on a simple revision of the
forced-forward algorithm in \cite{DBLP:journals/rts/BaruahBMS10}.  Let  be
.  As shown and proved in
\cite{DBLP:journals/corr/abs-kRTA}, task  in a
sporadic task system with implicit deadlines is schedulable by a
global RM on
 processors if



The schedulability condition in
Eq.~\eqref{eq:test-forced-forward} requires to test all possible  and all possible settings of  for
the higher priority tasks  with .
Therefore, it needs exponential time (for all the possible
combinations of ).

\subsection{Polynomial-Time Tests by \frameworkku{}}

We now demonstrate how the \frameworkku{} framework can be adopted.

\noindent\underline{\bf Based on Greedy-Carry-In}: 
Such a case is pretty clear by setting 
and  in Definition~\ref{def:kpoints-k2u}
for task . Therefore, by using
Lemma~\ref{lemma:framework-constrained-k2u} and
Lemma~\ref{lemma:framework-totalU-exclusive-k2u}, we have the
following theorem.

\begin{theorem}
\label{thm:multiprocessor-GRM}
Task  in a sporadic implicit-deadline task system is
schedulable by global RM on  processors if

or

\end{theorem}

\noindent\underline{\bf Based on Bounded-Carry-In}: There are two ways
to use \frameworkku{}. In the first case, we consider that  for
task  in  is known. For such a case, we simply
have to put the  higher-priority tasks with the largest execution
times into . This can be imagined as if we increase the
execution time of task  from  to . Therefore, we still have  and  for
. Therefore, by using
Lemma~\ref{lemma:framework-constrained-k2u} and
Lemma~\ref{lemma:framework-totalU-exclusive-k2u}, we have the
following theorem:


\begin{theorem}
\label{thm:multiprocessor-GRM-M-1-V0}
Task  in a sporadic implicit-deadline task system is
schedulable by global RM on  processors if

or

where .
\end{theorem}

In the second case, if only the task utilizations are given, we are not sure which tasks
should be put into the carry-in task set . That is, if we
are testing the worst-case period assignments of the higher-priority
tasks in , we need to enumerate .  Nevertheless,
if  with  is specified, the translation to
the \frameworkku{} framework is as follows: (1) the parameters are  and  by
using Eq.~\eqref{eq:grm-multiprocessor-M-1-carryin} if  is in
, and (2) the parameters are  and  by using
Eq.~\eqref{eq:grm-multiprocessor-M-1-carryin} if  is not in
. It may seem at first glance that we have to check all
possible permutations of . Fortunately, with the analysis in
\cite{DBLP:journals/corr/abs-1501.07084,DBLP:conf/rtss/ChenHL15}, the worst permutation of
 is to the  higher-priority tasks with the largest
utilization into . This leads to the following theorem by
extending Lemma~\ref{lemma:framework-general-k2u}.

\begin{theorem}
\label{thm:multiprocessor-GRM-M-1-carry}
Task  in a sporadic implicit-deadline task system is
schedulable by global RM on  processors if

by indexing the  higher-priority tasks in a non-decreasing order of  and assigning  to  and  to .
\end{theorem}

\noindent\underline{\bf Based on Forced-Forward}:
Formulating the test in Eq.~\eqref{eq:test-forced-forward} into the
\frameworkku{} framework is problematic. Suppose that  is
. Assume that  is set to ,  is set to ,
and  is set to . Under the above setting,  is ,
and  is ,  is . In fact, we even cannot
safely set  to any possible value except  if  is
small enough. Therefore, constructing parameters based on Definition
\ref{def:kpoints-k2u} is not possible (or non-trivial).


\subsection{Polynomial-Time Tests by \frameworkkq{}}

\noindent\underline{\bf Based on Greedy-Carry-In}: This is
possible by setting  and 
and applying
Lemma~\ref{lemma:framework-general-schedulability}. However, since the
results are not superior to the one with bounded-carry-in, we omit it.

\noindent\underline{\bf Based on Bounded-Carry-In}:
To use \frameworkkq{}, we are certain about which tasks should be put
into the carry-in task set  by assuming that  and 
are both given. That is, we simply have to put the 
higher-priority tasks with the largest execution times into . This can be imagined as if we increase the execution time of
task  from  to .

This leads to the following theorem by using
Lemma~\ref{lemma:framework-general-schedulability}. 

\begin{theorem}
\label{thm:multiprocessor-GRM-M-1-carry-k2q}
Task  in a sporadic implicit-deadline task system is
schedulable by global RM on  processors if  and

by indexing the  higher-priority tasks in a non-decreasing order
of  and by putting the 
higher-priority tasks with the largest execution times into .
\end{theorem}

We can of course revise the statement in
Theorem~\ref{thm:multiprocessor-GRM-M-1-carry-k2q} by adopting
Lemma~\ref{lemma:framework-constrained-schedulability} and
Lemma~\ref{lemma:framework-totalU-exclusive} to construct
schedulability tests by using only task utilizations.

\noindent\underline{\bf Based on Forced-Forward}: 
We present the corresponding polynomial-time schedulability tests for
global fixed-priority scheduling. By using the forced-forward test,
we can adopt the \frameworkkq{} framework by setting
 and . Due to the fact
that  for any task , i.e., , under global RM, we can reach the following theorems and
corollary, where the proofs are in \cite{DBLP:journals/corr/abs-kRTA}.

 \begin{theorem}
  \label{thm:multiprocessor-grm-sporadic-k2q-tight}
Let  be .  
Task  in a sporadic task system with implicit deadlines  is schedulable by global RM on
 processors if

by ordering the  higher-priority tasks in a non-increasing order of .
\end{theorem}

\begin{theorem}
  \label{thm:multiprocessor-grm-sporadic-tight}
Let  be .  
Task  in a sporadic task system with implicit deadlines  is schedulable by global RM on
 processors if

or

\end{theorem}


\begin{corollary}
  \label{col:grm-tight}
  The capacity augmentation factor of global RM for a sporadic system
  with implicit deadlines is .
\end{corollary}


\subsection{Analytical Comparison of \frameworkkq{} and \frameworkku{}}

\begin{figure*}[t]
  \centering
  \includegraphics[width=\textwidth]{figures/mp/multi.pdf}
  \caption{Acceptance ratio comparison on implicit-deadline 8 multiprocessor systems.}
  \label{fig:mul-2}
\end{figure*}

The utilization-based worst-case response-time analysis in
Theorem~\ref{thm:multiprocessor-grm-sporadic-tight} and
Corollary~\ref{col:grm-tight} is analytically tighter than the best
known result by Bertogna et
al. \cite{bertogna2006new} with linear-time tests. Moreover, our
polynomial-time schedulability test extended to handle
deadline-monotonic scheduling for constrained-deadline task sets based
on the forced-forward analysis in
\cite{DBLP:journals/corr/abs-kRTA} has the same speedup factor as the
best known result in pseudo-polynomial time by Baruah et
al. \cite{DBLP:journals/rts/BaruahBMS10}.

With respect to the capacity augmentation factors, the test derived
from \frameworkkq{} by using the forced-forward approach obtains the
best one, whereas the tests from bounded carry-in are worse.\footnote{They can be easily obtained by setting  and .}
As shown in the above examples, different schedulability tests may
lead to different quality of the schedulability tests. Therefore,
these results are not analytically comparable. We will have to compare
these results in the evaluations.

\subsection{Evaluation Results}
In this section, we conduct experiments using synthesized task sets for evaluating the proposed tests on multiprocessor systems.
We first generated a set of sporadic tasks. The cardinality of the task set was  times the number of processors, e.g., 40 tasks on 8 multiprocessor systems.
The task sets were generated in a similar manner in Section~\ref{subsec:simulation-env}. Tasks' relative deadlines were equal to their periods.

The evaluated tests are as follows:
\begin{itemize}
\item \emph{BCL}: the linear-time test in Theorem 4 in~\cite{bertogna2006new}.
\item \emph{FF}: the pseudo-polynomial-time force-forward (FF) analysis in Eq. (5) in \cite{DBLP:journals/rts/BaruahBMS10}.
\item \emph{BAK}: the  test in Theorem 11 in~\cite{baker2006analysis}.
\item \emph{Guan}: the pseudo-polynomial-time response time analysis\cite{DBLP:conf/rtss/GuanSYY09}.
\item \emph{HP-GC} (from \frameworkku{}): Eq.~\eqref{eq:schedulability-GRM} from Theorem~\ref{thm:multiprocessor-GRM} based on greedy carry-in (GC) in this report.
\item \emph{HP-BC} (from \frameworkku{}): Eq.~\eqref{eq:schedulability-GRM-M-1-V0} from Theorem~\ref{thm:multiprocessor-GRM-M-1-V0} based on bounded carry-in (BC) in this report. 
\item \emph{HP-BC-EP} (from \frameworkku{}):  using Lemma~\ref{lemma:framework-general-k2u}
  (with a more precise extreme point) by defining the values of
   and  for each task  in 
  precisely in this report. This improves HP-BC from Theorem~\ref{thm:multiprocessor-GRM-M-1-V0} based on bounded carry-in (BC) in this report. 
\item \emph{HP-BC2} (from \frameworkku{}): Eq.~\eqref{eq:schedulability-GRM-M-1-carry} from Theorem~\ref{thm:multiprocessor-GRM-M-1-carry} based on bounded carry-in (BC) in this report.
\item \emph{QB-BC} (from \frameworkkq{}): Eq.~\eqref{eq:schedulability-GRM-M-1-carry-k2q} in Theorem~\ref{thm:multiprocessor-GRM-M-1-carry-k2q} based on bounded carryin (BC) in this report.
\item \emph{QB-FF} (from \frameworkkq{}): Eq.~\eqref{eq:schedulability-GRM-k2q-tight} from Theorem~\ref{thm:multiprocessor-grm-sporadic-k2q-tight} based on force-forward (FF) in this report.
\item \emph{QB-FF2} (from \frameworkkq{}): Eq.~\eqref{eq:schedulability-GRM-tight} from Theorem~\ref{thm:multiprocessor-grm-sporadic-tight} based on force-forward (FF) in this report.
\end{itemize}

Among the above tests,  BCL, HP-GC, HP-BC2, QB-FF\footnote{We assume that the priority ordering is given. We just have to use the reversed order in Theorem~\ref{thm:multiprocessor-grm-sporadic-k2q-tight}.} and QB-FF2 can be implemented in linear time. Our other tests (HB-BC, HP-BC-EP, QB-BC) require to sort the higher-priority tasks to define the proper last release ordering; therefore, their time complexity is  for a task set with  tasks.


{\noindent \bf Results.}
Figure~\ref{fig:mul-2} depicts the result of the performance comparison. In all the cases, we can see that QB-BC and HP-BC-EP are superior to almost all the other polynomial-time tests.  It may seem that QB-FF is superior to QB-BC when we inspect their schedulability tests. However, the way how we formulated the force-forward algorithm in Eq.~\eqref{eq:test-forced-forward} is also pessimistic by introducing  instead of just . Such inflation from  to  makes the analysis for the worst-case capacity-augmentation factor tighter, but also makes QB-FF with less acceptance ratio when testing tasks with utilization larger than the threshold . Therefore, if , then QB-FF is worse than QB-BC.

The greedy carry-in in HP-GC makes it too pessimistic. However, HP-BC is comparable with BAK. Among the linear-time tests, QB-FF outperforms the others in all the cases. Among the above tests, it is difficult to compare QB-BC and HP-BC-EP, since they perform very closely.  Overall, most of the tests derived by using the two frameworks perform very well with low time complexity.


\section{Conclusion}

This report presents the similarly, difference, and the
characteristics of the \frameworkku{} and \frameworkkq{}
frameworks. These two frameworks have great potential to be used for
deriving polynomial-time schedulability tests \emph{almost automatically}, as soon as
the corresponding parameters in Definitions~\ref{def:kpoints-k2u},
\ref{def:kpoints}, and \ref{def:kpoints-response} can be constructed.
In the past, exponential-time schedulability tests were typically not
recommended and most of time ignored, as this requires very high
complexity. However, by adopting these two frameworks, we have
successfully shown that exponential-time schedulability tests may lead
to good polynomial-time tests by using the \frameworkku{} and
\frameworkkq{} frameworks. Both frameworks are needed and have to be
applied for different cases. With these two frameworks, some difficult
schedulability test and response time analysis problems may be solved
by building a good (or exact) exponential-time test and applying these
two frameworks.

These two frameworks are both useful and needed for different cases
and applications. We have demonstrated their differences in details
and present evaluation results for the schedulability tests derived
from these two frameworks. For some cases, \frameworkku{} is better,
and for some cases, \frameworkkq{} is better.

\begin{spacing}{0.9}
   \noindent{\small {\bf Acknowledgement}: This paper has been
     supported by DFG, as part of the Collaborative Research Center
     SFB876 (http://sfb876.tu-dortmund.de/), and the priority program
     "Dependable Embedded Systems" (SPP 1500 -
     http://spp1500.itec.kit.edu).  }
 \end{spacing}


\footnotesize
\vspace{-0.1in}
\def\IEEEbibitemsep{-0.2pt}
\bibliographystyle{abbrv}
\bibliography{ref,real-time}
\normalsize

\end{document}
