\documentclass[letterpaper, 11pt]{article}
\pagestyle{plain}                                                      \setlength{\textwidth}{6.5in}     \setlength{\oddsidemargin}{0in}   \setlength{\evensidemargin}{0in}  \setlength{\textheight}{8.95in}    \setlength{\topmargin}{0in}       \setlength{\headheight}{0in}      \setlength{\headsep}{0in}         \setlength{\footskip}{.5in}       \setlength {\parskip}{3pt}                                             \bibliographystyle{abbrv}                                           

 
 
\usepackage{appendix}
 




 
\newcommand{\Aightarrow}{\stackrel{a}{\Rightarrow}}
 
\newcommand{\comment}[1]{}
 
\usepackage{graphicx}

\usepackage{subfigure}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{mdwlist}


\usepackage{algorithm}

\usepackage{hyperref}
 
 
\usepackage{xspace}
\usepackage{setspace}

\newcommand{\BSB}{{\tt Broadcast\_Binary}\xspace}
\newcommand{\DG}{{\tt Diag\_Graph}\xspace}
\newcommand{\TRUE}{{\tt TRUE}\xspace}
\newcommand{\FALSE}{{\tt FALSE}\xspace}
 
\newcommand{\teq}[1]{\stackrel{#1}{\equiv}}
\newcommand{\nteq}[1]{\stackrel{#1}{\nequiv}}
 
 
\newcommand{\sg}{{\mathcal G}}
\newcommand{\sv}{{\mathcal V}}
\newcommand{\se}{{\mathcal E}}
\newcommand{\sw}{{\mathcal W}}
\newcommand{\ms}{{\mathcal S}}
\newcommand{\sn}{{\mathcal N}}
 


\newcommand{\nchoosek}[2]{{#1 \choose #2}}
 
\newcommand{\mybox}[1]{\vspace{5pt}\centerline{\framebox{\parbox[c]{\textwidth}{#1}}}\vspace{5pt}}
 
\newcommand{\BlackBox}{\rule{2.6mm}{2.6mm}}
\newenvironment{proof}{\noindent {\bf Proof:}~}{\hspace*{\fill}}
\newenvironment{proofSketch}{\noindent{\bf Proof Sketch:}}{\hspace*{\fill}}
\newtheorem{theorem}{Theorem}
\newtheorem{conjecture}{Conjecture}
\newtheorem{claim}{Claim}
\newtheorem{corollary}{Corollary}
\newtheorem{definition}{Definition}
\newtheorem{condition}{Condition}
\newtheorem{lemma}{Lemma}
\newtheorem{example}{Example}
\newcommand{\fillblackbox}{\hspace*{\fill}}
\newcommand{\fillbox}{\hspace*{\fill}}
\newcommand{\fig}[1]{Figure~\ref{#1}}
\newcommand{\eqn}[1]{Equation~\ref{#1}}
\newcommand{\refsec}[1]{Section~\ref{#1}}
\newcommand{\num}[1]{(\romannumeral#1)}
\def\noflash#1{\setbox0=\hbox{#1}\hbox to 1\wd0{\hfill}}




\newcommand{\scriptf}{\mathcal{F}}
\newcommand{\scripte}{\mathcal{E}}
\newcommand{\scriptv}{\mathcal{V}}
\newcommand{\scriptl}{\mathcal{L}}
\newcommand{\scripts}{\mathcal{S}}
\newcommand{\matrixm}{\textbf{M}}
\newcommand{\matrixh}{\textbf{H}}
\newcommand{\graphh}{\textit{H}}
\newcommand{\bfF}{\textbf{F}}
\newcommand{\bfC}{\textbf{C}}
\newcommand{\bfR}{\textbf{R}}
\newcommand{\bfL}{\textbf{L}}

\newcommand{\shortdividerline}{\begin{center} \line(1,0){150} \end{center}}
\newcommand{\dividerline}{\begin{center}\hrule\end{center}}



\newcommand{\Zightarrow}{\rightarrow}


\newcommand{\propagate}[3]{#1\stackrel{#3}{\rightsquigarrow}{#2}}
\newcommand{\notpropagate}[3]{#1\stackrel{#3}{\not\rightsquigarrow}{#2}}




\newcommand{\Propagate}{{\tt Propagate}}
\newcommand{\Equality}{{\tt Equality}}
\newcommand{\ssss}{{\mbox{\it start}}}
\newcommand{\eeee}{{\mbox{\it end}}}

 
\begin{document}
\title{Byzantine Consensus in Directed Graphs\footnote{\normalsize This research is supported in part by Army Research Office grant W-911-NF-0710287. Any opinions, findings, and conclusions or recommendations expressed here are those of the authors and do not necessarily reflect the views of the funding agencies or the U.S. government.}}



\author{Lewis Tseng, and Nitin Vaidya\\~\\
 \normalsize  Department of Computer Science,\\
 \normalsize  Department of Electrical and Computer Engineering, 
 and\\ \normalsize  Coordinated Science Laboratory\\ \normalsize University of Illinois at Urbana-Champaign\\ \normalsize Email: \{ltseng3, nhv\}@illinois.edu \\ \normalsize Phone: +1 217-244-6024, +1 217-265-5414}


\date{August 24, 2012\footnote{Revised on February 18, 2014 to make major improvements to the presentation and related work.}}
\maketitle



\begin{abstract}
\normalsize

Consider a synchronous point-to-point network of  nodes connected by {\em directed} links, wherein each node has a binary input. 
This paper proves a {\em tight} necessary and sufficient condition on the underlying communication topology for
achieving Byzantine consensus among these nodes in the presence of
up to  Byzantine faults. We derive a necessary condition, and then we provide a constructive proof of
sufficiency by presenting a Byzantine consensus algorithm for directed graphs
that satisfy the necessary condition. 

~

Prior work has developed analogous necessary and sufficient conditions
for {\em undirected} graphs. It is known that, for undirected graphs,
the following two conditions are
together necessary and sufficient \cite{impossible_proof_lynch, welch_book,dolev_82_BG}:
(i) , and (ii) network connectivity greater than .
However, these conditions are not adequate to completely characterize Byzantine consensus
in {\em directed} graphs.


\end{abstract}


~

~




~




\thispagestyle{empty}
\newpage
\setcounter{page}{1}

\section{Introduction}
\label{s_intro}


In this work, we explore algorithms for achieving Byzantine consensus \cite{psl_BG_1982} in a synchronous point-to-point network in the presence of Byzantine faulty nodes. The network is modeled as a {\em directed} graph, i.e., the communication links between neighboring nodes are not necessarily bi-directional. Our work is 
motivated by the presence of directed links in wireless networks.
However, we believe that the results here are of independent interest as well.
 

The Byzantine consensus problem \cite{psl_BG_1982} considers  nodes, of which at most  nodes may be faulty. The faulty nodes may deviate from the algorithm in arbitrary fashion. Each node has an {\em input} in . A Byzantine consensus algorithm is {\em correct} if it satisfies the following three properties:

\begin{itemize}
\item \textbf{Agreement}: the output (i.e., decision) at all the fault-free nodes is identical.

\item \textbf{Validity}: the output of every fault-free node equals the input of a fault-free node.

\item \textbf{Termination}: every fault-free node eventually decides on an output.

\end{itemize}



In networks with undirected links (i.e., in undirected graphs), it is well-known that the following two conditions together are both necessary and sufficient for the existence of Byzantine consensus algorithms \cite{impossible_proof_lynch, welch_book, dolev_82_BG}: (i) , and (ii) node connectivity
greater than . The first condition, that is, , is necessary for directed graphs as well. Under the second condition, each pair of nodes in the undirected graph can
communicate {\em reliably} with each other. In particular, either a given pair of nodes is connected
directly by an edge, or there are  node-disjoint paths between the pair of nodes. However, reliable communication between every pair of node is {\em not} necessary for achieving consensus in directed graphs. In Section \ref{s_discussion}, we address this statement in more details.


This paper presents {\em tight} necessary and sufficient conditions for Byzantine consensus in {\em directed} graphs. We provide a constructive proof of sufficiency by presenting a Byzantine consensus algorithm for directed graphs satisfying the necessary condition. The rest of the paper is organized as follows. Section \ref{s_related} discusses the related work. Section \ref{s_term} introduces our system model and some terminology used frequently in our presentation. The main result and the implications are presented in Section \ref{nec_2}. The Byzantine consensus algorithm for directed graphs is described, and its correctness is also proved in Section \ref{s_sufficiency}. The paper summarizes in Section \ref{s_conclusion}.



\section{Related Work}
\label{s_related}

Lamport, Shostak, and Pease addressed the Byzantine agreement problem in \cite{psl_BG_1982}. Subsequent work \cite{impossible_proof_lynch, dolev_82_BG} characterized the necessary and sufficient conditions under which the problem is solvable in {\em undirected} graphs. However, as noted above, these conditions are not adequate to fully characterize the {\em directed} graphs in which Byzantine consensus is feasible. In this work, we identify {\em tight} necessary and sufficient conditions for Byzantine consensus in {\em directed} graphs. The necessity proof presented in this paper is based on the state-machine approach, which was originally developed for conditions in undirected graphs \cite{impossible_proof_lynch,dolev_82_BG,welch_book}; however, due to the nature of directed links, our necessity proof is a non-trivial extension. The technique is also similar to the {\em withholding} mechanism, which was developed by Schmid, Weiss, and Keidar \cite{impossible_link} to prove impossibility results and lower bounds for the number of nodes for synchronous consensus under {\em transient link} failures in {\em fully-connected} graphs; however, we do not assume the transient fault model as in \cite{impossible_link}, and thus, our argument is more straightforward.

In related work, Bansal et al. \cite{Bansal_disc11} identified tight conditions for achieving Byzantine consensus in {\em undirected} graphs using {\em authentication}. Bansal et al. discovered that all-pair reliable communication is not necessary to achieve consensus when using authentication. Our work differs from Bansal et al. in that our results apply in the absence of authentication or any other security primitives; also our results apply to {\em directed} graphs. We show that even in the absence of authentication all-pair reliable communication is not necessary for Byzantine consensus.

Several papers have also addressed communication between a single source-receiver pair.
Dolev et al. \cite{Dolev90perfectlysecure} studied the problem of secure communication, which achieves both fault-tolerance and perfect secrecy between a single source-receiver pair in undirected graphs, in the presence of node and link failures. Desmedt and Wang considered the same problem in directed graphs \cite{yvo_eurocrypt02}. In our work, we do not consider secrecy, and address the consensus problem rather than the single source-receiver pair problem. Shankar et al. \cite{Shankar_SODA08} investigated reliable communication between a source-receiver pair in directed graphs allowing for an arbitrarily small error probability in the presence of a Byzantine failures. Our work addresses deterministically correct algorithms for consensus.

Our recent work \cite{vaidya_PODC12,Tseng_general,vaidya_incomplete} has considered a restricted class of iterative algorithms for achieving {\em approximate} Byzantine consensus in directed graphs, where fault-free nodes must agree on values that are approximately equal to each other using iterative algorithms with limited memory. The conditions developed in such prior work are {\em not} necessary when no such restrictions are imposed. Independently, LeBlanc et al. \cite{leblanc_HiCoNs,Sundaram_journal}, and Zhang and Sundaram \cite{Sundaram,Sundaram_ACC} have developed results for iterative
algorithms for {\em approximate} consensus under a {\em weaker} fault model, where a faulty node must send
identical messages to all the neighbors. In this work, we consider the problem of {\em exact} consensus (i.e., the outputs at fault-free nodes must be exactly identical), and we do not impose any restriction on the algorithms or faulty nodes.

Alchieri et al. \cite{BFT-CUP_OPODIS} explored the problem of achieving exact consensus in {\em unknown} networks with Byzantine nodes, but the underlying communication graph is assumed to be fully-connected. In this work, the network is assumed to be known to all nodes, and may not be fully-connected.


















\section{System Model and Terminology}
\label{s_term}

\subsection{System Model}
The system is assumed to be {\em synchronous}.
The synchronous communication network consisting
of  nodes is modeled as a simple {\em directed} graph , where  is the set of  nodes, and  is the set of directed edges between the nodes in .  We assume that , since the consensus problem for  is trivial.  Node  can transmit messages to another node  if and only if the directed edge  is in . Each node can send messages to itself as well; however, for convenience, we {exclude self-loops} from set . That is,  for . With a slight abuse of terminology, we will use the terms {\em edge} and {\em link}, and similarly the terms
{\em node} and {\em vertex},
 interchangeably.




All the communication links are reliable,
FIFO (first-in first-out) and deliver each transmitted message exactly once.
When node  wants to send message M on link  to node , it
puts the message M in a send buffer for link . No further operations
are needed at node ; the mechanisms for implementing reliable,
FIFO and exactly-once semantics 
are transparent to the nodes. When a message is delivered on link (),
it becomes available to node  in a receive buffer for link .
As stated earlier, the communication network is synchronous, and thus,
each message sent on link () is delivered to node  within a 
bounded interval of time.


\paragraph{Failure Model:}
We consider the Byzantine failure model, with up to  nodes becoming faulty. A faulty node may {\em misbehave} arbitrarily. Possible misbehavior includes sending incorrect and mismatching (or inconsistent) messages to different neighbors. The faulty nodes may potentially collaborate with each other. Moreover, the faulty nodes are assumed to have a complete knowledge of the execution of the algorithm, including the states of all the nodes, contents of messages the other nodes send to each other, the algorithm specification, and the network topology.



\subsection{Terminology}

We now describe terminology that is used frequently in our presentation. Upper case italic letters are used below to name subsets of ,
and lower case italic letters are used to name nodes in .

\paragraph{Incoming neighbors:}

\begin{itemize}
\item Node  is said to be an incoming neighbor of node  if .
\item
For set , node  is said to be an incoming
neighbor of set  if , and there exists 
such that . Set  is said to have  incoming neighbors in set  if set  contains  distinct incoming neighbors of .

\end{itemize}

\paragraph{Directed paths:}
All paths used in our discussion are directed paths.

\begin{itemize}
\item Paths from a node  to another node :
\begin{itemize}
\item For a directed path from node  to node , node  is said to be the ``source node'' for the path.
\item An ``-path'' is a directed path from node  to node . An ``-path excluding '' is a directed path from node  to node  that does not contain any node from set . 


\item Two paths from node  to node  are said to be ``disjoint'' 
	if the two paths only have nodes  and 
	in common, with all remaining
	nodes being distinct.
	
\item The phrase `` disjoint -paths'' refers to
	 pairwise disjoint paths from node  to node . The phrase `` disjoint -paths excluding '' refers to  pairwise disjoint -paths that do not contain any node from set .

\end{itemize}
\item Every node  trivially has a path to itself. That is,
	for all , an -path
	excluding  exists.
\item Paths from a set  to node :

\begin{itemize}
\item A path is said to be an ``-path'' if it is an
	-path for some . An ``-path excluding '' is a -path that does not contain any node from set .


\item Two -paths are said to be ``disjoint'' 
	if the two paths only have node 
	in common, with all remaining
	nodes being distinct (including the source nodes on the paths).
	
\item The phrase `` disjoint -paths'' refers to
	 pairwise disjoint -paths. The phrase `` disjoint -paths excluding '' refers to  pairwise disjoint -paths that do not contain any node from set .

\end{itemize}
\end{itemize}

\paragraph{Graph Properties:}

\begin{definition}
\label{def:propagate}
Given disjoint subsets  of  such that ,
set  is said to
\underline{propagate in } to set 
if either (i) , or (ii) for each node , there exist at least
 disjoint -paths excluding .
\end{definition}
We will denote the fact that set  propagates in  to set 
by the notation 
When it is not true that , we will denote that fact by 

~

For example, consider Figure \ref{f:2-core} below when  and  and , then  and .

\begin{figure}[hbtp!]
\centering
\includegraphics[scale=0.65, bb=-100 -30 749 240]{2-core.jpg}
\vspace*{-30pt}
\caption{A network tolerating  faults. Edges inside cliques  and  are not shown.}
\label{f:2-core}


\end{figure}

\begin{definition}
\label{def:G-F}
For , graph  is obtained by removing from 
all the nodes in , and all the links incident on nodes in .
\end{definition}

\begin{definition}
\label{def:strong}
A subgraph  of  is said to be {\em strongly connected}, if for all nodes  in , there exists an -path in . \end{definition}


\section{Main Result}
\label{nec_2}








We now present the main result of this paper.

\begin{theorem}
\label{t_nec_2}
Byzantine consensus is possible
in 
{\bf if and only if} for any node partition  of , where  and  are both non-empty, and , either  or .
\end{theorem}

\begin{proof}
Appendix \ref{a_1and2} presents the proof of necessity of the condition in the theorem. In Appendix \ref{a_1and2}, we first prove the necessity of an alternate form of the condition using the state-machine approach developed in prior work \cite{impossible_proof_lynch,dolev_82_BG,welch_book}. We then prove that the alternate necessary condition is equivalent to the condition stated in Theorem \ref{t_nec_2}.

In Section \ref{s_sufficiency}, we present a constructive proof of sufficiency of the condition in the theorem. In particular, we present a Byzantine consensus algorithm and prove its correctness in all directed graphs that satisfy the condition stated in Theorem \ref{t_nec_2}. 
\end{proof}

\subsection{Implications of the necessary and sufficient condition}
\label{s_discussion}

Here, we discuss some interesting implications of Theorem \ref{t_nec_2}.

\begin{itemize}
\item Lower bounds on number of nodes and incoming neighbors are identical to the case in undirected networks \cite{impossible_proof_lynch,dolev_82_BG,welch_book}:

This observation is not surprising, since undirected graphs are a special case of directed graphs.

\begin{corollary}
\label{cor:2f+1}
Suppose that a correct Byzantine consensus algorithm exists for
.
Then,
 (i) , and
 (ii) if , then each node must have at least  incoming neighbors.
\end{corollary}
\begin{proof}
The proof is in Appendix \ref{a_cor:2f+1}.
\end{proof}





\item Reliable communication between {\bf all} node pairs is {\bf not} necessarily required:

This observation is also not surprising, but nevertheless
interesting (because, in undirected graphs, Byzantine consensus
is feasible if and only if all node pairs can communicate with each
other reliably). To illustrate the above observation, consider the simple
example in Figure \ref{f:core}, with . In Figure \ref{f:core},
nodes  have directed links to each other, forming a 4-node
clique -- the links inside the clique are not shown in the figure. Node  does not have a directed link to any other node, but has links from the
other 4 nodes.
Yet, Byzantine consensus can be achieved easily by first reaching consensus within the
4-node clique, and then propagating the consensus value (for the 4-node consensus) to node .  
Node  can choose majority of the values received from the nodes in the
4-node clique as its own output.
It should be easy to see that this algorithm works correctly for inputs in  as
required in the Byzantine consensus formulation considered in this work.

\vspace*{-40pt}
\begin{figure}[hbtp!]
\centering



\includegraphics[scale=0.6, bb=-250 -30 749 240]{core.jpg}
\vspace*{-30pt}
\caption{A network tolerating  fault. Edges inside clique  are not shown.}
\label{f:core}
\end{figure}

\item For a cut  of the communication graph, there may not necessarily be  disjoint links 
in any one direction (i.e., from nodes in  to nodes in , or vice-versa):

The above observation is surprising, since it suggests that reliable communication may not be
feasible in either direction across a given cut in the communication graph.
We illustrate this using the system in
Figure \ref{f:2-core} in Section \ref{s_term}, which contains 
two cliques  and , each containing 7 nodes.
Within each clique, each node has a directed link to the other 6 nodes
in that clique -- these links
are not shown in the figure.
There are 8 directed links with one endpoint in clique  and the other endpoint in clique .
We prove in Appendix \ref{a_l_2clique} that Byzantine consensus can be
achieved in this system with .
However, there are only 4 directed links from  to ,
and 4 directed links from  to . Thus, reliable communication is
{\em not} guaranteed across the cut  in either direction.
Yet, Byzantine consensus is achievable using Algorithm BC.  
In Appendix \ref{a_l_2clique}, we present a family of graphs, named 2-clique network, which satisfies the
condition in Theorem \ref{t_nec_2}. Figure \ref{f:2-core} shown in Section \ref{s_term} is the 2-clique network for .
Section \ref{s_sufficiency} proves that Byzantine consensus is possible in all graphs
that satisfy the necessary condition. Therefore, consensus is possible in the 2-clique
network as well. 
\end{itemize}










\section{Sufficiency: Algorithm BC and Correctness Proof}
\label{s_sufficiency}

In this section, we assume that graph  satisfies the condition stated in Theorem \ref{t_nec_2}, even if this is not stated explicitly again. We present Algorithm BC (Byzantine Consensus) and prove its correctness in all graphs that satisfy the condition in Theorem \ref{t_nec_2}. This proves that the necessary condition is also sufficient. 
When , all the nodes are fault-free,
and as shown in Appendix \ref{a_f_0}, 
the proof of sufficiency is trivial.
In the rest of our discussion below, we will assume that . 






The proposed Algorithm BC is presented below.
Each node  maintains two state variables that are
explicitly used in our algorithm:  and .
Each node maintains other state as well (such as
the routes to other nodes); however, we do not introduce
additional notation for that for simplicity.

\begin{itemize}

\item
{Variable :}
Initially,  at any node  is equal to the binary input at node .
During the execution of the algorithm,  at node  may be updated
several times. Value  at the end of the algorithm
represents node 's decision (or output)
for Algorithm BC. The output at each node is
either 0 or 1. At any time during the execution of the algorithm,
the value  at node  is said to be {\em valid}, if it equals some fault-free node's input. Initial value  at a fault-free node  is valid, because it equals its own input.
Lemma \ref{l_valid_1} proved later in Section \ref{s:correct} implies that  at a fault-free node  always remains valid
throughout the execution of Algorithm BC.

\item
{Variable :} Variable  at any node  
may take a value in , where  is distinguished
from 0 and 1.
Algorithm BC makes use of procedures \Propagate~and \Equality~that are described soon below. These procedures take  as input, and possibly also modify .
Under some circumstances, as discussed later, state variable  at node  is set equal to ,
in order to update .
\end{itemize}


Algorithm BC consists of two loops, an OUTER loop, and an INNER loop. The OUTER loop is performed for
each subset of nodes , . 
For each iteration of the OUTER loop, many iterations of the INNER loop are performed.
The nodes in  do not participate in any of these INNER loop iterations.
For a chosen ,
each iteration of the INNER loop is performed for a different partition of .

Since there are at most  faults, one iteration of the OUTER loop has  exactly equal
to the set of faulty nodes. Denote the actual set of faulty nodes as . 
Algorithm BC has two properties, as proved later:
\begin{itemize}
\item State  of each fault-free node  at the end of any particular INNER loop iteration equals the state of some
fault-free node at the start of that INNER loop iteration. 
Thus, Algorithm BC ensures that the state  of each fault-free node  remains valid at all times.
\item
By the end of the OUTER loop iteration for , all the fault-free nodes reach agreement.
\end{itemize}
The above two properties ensure that, when Algorithm BC terminates, the validity and agreement properties are both satisfied. 

Each iteration of the INNER loop, for a given set , considers a partition  of the nodes in 
such that .
Having chosen a partition , intuitively speaking, the goal of the INNER loop iteration is for the nodes in set  to attempt to influence the state of the nodes in the other partition.
A suitable set  is identified and agreed a priori using the known topology information. There are two possible cases. In Case 1 in Algorithm BC, , and nodes in  use procedure \Equality~(step (b) in the pseudo-code) to decide the value to propagate to nodes in  (step (c)). In Case 2, , and nodes in  first learn the states at nodes in  using procedure \Propagate~(step (f)), and then use procedure \Equality~(step (g)) to decide the value to propagate to nodes in  (step (h)). These steps ensure that if , and nodes in  have the same  value, then  will propagate that value, and all nodes in  (Case 1: step (d)) or in  (Case 2: step (i)) will set  value equal to the value propagated by , and thus, the agreement is achieved. As proved later, in at least one INNER loop iteration with , nodes in  have the same  value.






\comment{+++++++++++++++++++++++++++++++++old text++++++++++++++++++

Algorithm BC consists of two loops. The OUTER loop tries to isolate  faults by excluding a set of chosen nodes  from the propagation of the proposed values for that iteration, i.e., nodes in  do not send or forward any messages, and can only accept values from their incoming neighbors in the end of that iteration. Since the OUTER loop enumerates over all possible sets of nodes, in some iteration,  must equal the \underline{actual set of faulty nodes} in the network . 

The INNER loop has two goals: (i) preserves validity, i.e., the state at each fault-free node in the end of the iteration is some fault-free node's state in the beginning of that iteration; and (ii) achieves agreement when OUTER loop chooses . The INNER loop relies on procedures  and , which  make use of state variables  and  maintained by the nodes. We discuss the node state in Section \ref{ss_node}, and each procedure in Sections \ref{ss_propagate} and \ref{ss_equality}, respectively. 

Each iteration of the INNER loop divides nodes in  into different partition , and chooses a set of nodes  according to the property of  and . Then nodes in  propose a value to be adopted (variable ) for that iteration, and other nodes will decide whether to accept the value using procedure  (steps (c) and (h)). Variable  is determined differently in each case. In Case 1,  can be determined by communication among nodes in  (steps (a) and (b)); while in Case 2, nodes in  need to help nodes in  to determine  (steps (e), (f), and (g)). If the graph satisfies the condition in Theorem \ref{t_nec_2}, then both goals will be achieved. Later in Section \ref{s:correct}, we prove goal (i) in Lemma \ref{l_valid_1}, and goal (ii) in Lemma \ref{l_agreement}.



++++++++++++++++++++++++++}





~

\hrule

\vspace*{2pt}

\noindent {\bf Algorithm BC}

\vspace*{4pt}

\hrule

\vspace*{4pt}

~

\indent {\em Comment}: Note that Algorithm BC can be implemented distributedly if every node has prior knowledge of the topology. For the convenience of reader, the pseudo-code below is presented in a centralized fashion. \\


\noindent
(OUTER LOOP)\\ For each , where :

  \begin{list}{}{}
  \item (INNER LOOP)\\For each partition  of  such
	 that  are non-empty, and :

	STEP 1 of INNER loop:

	\begin{itemize}
	\item {\bf Case 1:}
            {\bf if}  and :

	Choose a non-empty set  such that ,	and  is strongly connected in  ( is defined in Definition \ref{def:G-F}).

        \begin{list}{}{}
        \item[(a)] At each node   
	\item[(b)] \Equality()               
	\item[(c)] \Propagate()
	\item[(d)] At each node  if , then 
        \end{list}

	\item {\bf Case 2:}
            {\bf if}  and :

	Choose a non-empty set  such that	,	 is strongly connected in , and .


        \begin{list}{}{}
        \item[(e)] At each node  
        \item[(f)] \Propagate()
	\item[(g)] \Equality()
	\item[(h)] \Propagate()
	\item[(i)] At each node  if ,
			 then 
	\end{list}
	\end{itemize}  

	STEP 2 of INNER loop:
        \begin{list}{}{}
	\item[(j)] Each node  receives  from
		each , where  is a set consisting of
		 of 's incoming neighbors in .
		If all the received values are identical, then  is
		set equal to this identical value; else  is unchanged.
	\end{list}
   \end{list}

\hrule





\comment{+++++++++++++++
\subsection{Node State}
\label{ss_node}

Each node  maintains two state variables that are
explicitly used in our algorithm:  and .
Each node will have to maintain other state as well (such as
the routes to other nodes); however, we do not introduce
additional notation for that for simplicity.
\begin{itemize}


\item
{Variable :}
Initially,  at any node  is equal to the binary input at node .
During the course of the algorithm,  at node  may be updated
several times. Value  at the end of the algorithm
represents node 's decision (or output)
for Algorithm BC. The output at each node is
either 0 or 1. At any time during the execution of the algorithm,
the value  at node  is said to be {\em valid}, if it equals some fault-free node's input. Initial value  at a fault-free node  is valid because it equals its
own input.
Lemma \ref{l_valid_1} proved later in Section \ref{s:correct} implies that  at a fault-free node  always remains valid
throughout the execution of Algorithm BC.


\item
{Variable :} Variable  at any node  
may take a value in , where  is distinguished
from 0 and 1.
The \Propagate~ and \Equality~ procedures take  at participating
nodes  as input, and may also modify .
Under some circumstances,  at node  is set equal to 
in order to update , in steps (d) and (i) of Algorithm BC.
\end{itemize}
++++++++++++++++++++++}



\subsection{Procedure \Propagate()}
\label{ss_propagate}

\Propagate() assumes that , ,
 and . Recall that set  is the set chosen in each OUTER loop as specified by Algorithm BC.

\vspace*{2pt}
\hrule
\vspace*{2pt}
\noindent \Propagate()
\vspace*{4pt}
\hrule
\vspace*{-2pt}
\begin{list}{}{}
\item[(1)]
Since , for each , there
exist at least  disjoint (-paths that exclude .
The source node of each of these paths is in .
On each of  such disjoint paths, the source node for that path, say , sends  to node . Intermediate nodes on these paths forward
received messages as necessary. 

When a node does not receive an expected message,
the message content is assumed to be .

\item[(2)] When any node  receives  values along the 
disjoint paths above:\\
 if the  values are all equal to 0, then
; else if the  values are all equal to 1, then
; else . \hfill (Note that  denotes the assignment operator.)
\end{list}
For any node ,  is not modified during \Propagate().
Also, for any node ,  is not modified during \Propagate().

\vspace*{4pt}
\hrule



\subsection{Procedure \Equality()}
\label{ss_equality}

\Equality() assumes that , ,
and for each pair of nodes ,
an -path excluding  exists, i.e.,  is strongly connected
in  ( is defined in Definition \ref{def:G-F}).




\vspace*{2pt}
\hrule
\vspace*{2pt}
\noindent \Equality()
\vspace*{4pt}
\hrule
\begin{list}{}{}
\item[(1)] Each node  sends  to all other nodes
in  along paths excluding .
\item[(2)] Each node  thus receives messages from all nodes in .
Node  checks whether values received from all the nodes in  and
its own  are all equal, and also belong to .
If these conditions are {\em not} satisfied, then ; otherwise  is not modified.



\end{list}
For any node ,  is not modified in \Equality().
Also, for any node ,  is not modified in \Equality().

\vspace*{4pt}

\hrule


\subsection{INNER Loop of Algorithm BC for }
\label{subsec:inner}
Assume that .
For each  chosen in the OUTER loop, the INNER loop of Algorithm BC examines
each partition  of  such that  are both non-empty.
From the condition in Theorem \ref{t_nec_2}, we know that either
 or .
Therefore, with renaming of the sets we can ensure that 
. Then, depending on the choice of , two cases may occur:
 (Case 1)  and , and (Case 2)  and . 

In Case 1 in the INNER loop of Algorithm BC, we need to find
	a non-empty set  such that ,
	and  is strongly connected in  ( is defined in Definition \ref{def:G-F}).
In Case 2, we need to find
	a non-empty set  such that
	,
	 is strongly connected in , and . 
The following claim ensures that Algorithm BC can be executed correctly in .

\begin{claim}
\label{claim:inner_loop}
Suppose that  satisfies the condition stated in Theorem \ref{t_nec_2}. Then,

\begin{itemize}
\item The required set  exists in both Case 1 and 2 of each INNER loop.

\item Each node in set  has enough incoming neighbors in  to perform step (j) of Algorithm BC with .
\end{itemize}

\end{claim}

\begin{proof}
The proof of the first claim is proved in Appendix \ref{a_claim:S}.

Now, we prove the second claim.
Consider nodes in set . As shown in Corollary \ref{cor:2f+1} in Section \ref{nec_2},
when , each node in  has at least  incoming neighbors.
Since ,
for each  there must exist at least
 incoming neighbors in . 
Thus, the desired set  exists, satisfying
the requirement in step (j) of Algorithm BC.
\end{proof}

\comment{++++++++++
Appendix \ref{a_claim:S} shows that the required set  exists in both the cases. 

Now, we show the following claim:

\begin{claim}
Each node in set  has enough incoming neighbors in  to perform step (j) of Algorithm BC with .
\end{claim}

\begin{proof}
Consider nodes in set . As shown in Corollary \ref{cor:2f+1} in Section \ref{nec_2},
when , each node in  has at least  incoming neighbors.
Since ,
for each  there must exist at least
 incoming neighbors in . 
Thus, the desired set  exists, satisfying
the requirement in step (j) of Algorithm BC.
\end{proof}

+++++++++++++++}








\subsection{Correctness of Algorithm BC for }
\label{s:correct}

Recall that by assumption,  is the \underline{actual set of faulty nodes} in
the network ().
Thus, the set of fault-free nodes is . When discussing a certain INNER loop iteration, we sometimes add
\underline{superscripts \, and }\, to  for node  to indicate whether we are referring to  at the start, or at the end, of that
INNER loop iteration, respectively. We first show that INNER loop preserves validity.



\begin{lemma}
\label{l_valid_1}
For any given INNER loop iteration, for each fault-free node , there exists a fault-free node  such that . 
\end{lemma}


\begin{proof}
To avoid cluttering the notation, for a set of nodes , we use the phrase

\hspace{1in}a fault-free node 

\noindent
as being equivalent to

 \hspace{1in}a fault-free node 

\noindent
because all the fault-free nodes in any set  must also be in .

Define \underline{set } as the set of values of 
at all fault-free  at the start of the
INNER loop iteration under consideration, i.e., .

We first prove the claim in the lemma for the fault-free nodes in ,
and then for the fault-free nodes in .
Consider the following two cases in the INNER loop iteration.
\begin{itemize}
\item {\bf Case 1:}  and :

Observe that, in Case 1,  remains unchanged for all
fault-free . Thus,  for
, and hence, the claim of the lemma is trivially
true for these nodes. We will now prove the claim for fault-free .

\begin{itemize}
\item step (a):
Consider a fault-free node .
At the end of step (a),  is equal to . Thus,
.

\item step (b):
In step (b), step 2 of \Equality() either keeps  unchanged at
fault-free node 
or modifies it to be . Thus, now .

\item step (c):
Consider a fault-free node . During \Propagate(),
 receives  values along  disjoint paths originating
at nodes in . Therefore, at least one of the  values
is received along a path that contains only fault-free nodes;
suppose that the value received by node  along this fault-free path
is equal to . As observed above in step (b),
 at all fault-free nodes  is in . Thus,
.
Therefore, at fault-free node , step 2 of \Propagate() will result
in .

\item step (d):
Then it follows that, in step (d), at fault-free , if  is updated, then 
. On the other hand, if  is not updated, then .
\end{itemize}

\item {\bf Case 2:}  and :

Observe that, in Case 2,  remains unchanged for all
fault-free ; thus 
for these nodes. Now, we prove the claim in the lemma for 
fault-free .

\begin{itemize}

\item step (e):
For any fault-free node ,
at the end of step (e), .

\item
step (f):
Consider a fault-free node . During \Propagate(),
 receives  values along  disjoint paths originating
at nodes in . Therefore, at least one of the  values
is received along a path that contains only fault-free nodes;
suppose that the value received by node  along this fault-free path
is equal to .
Therefore, at node , \Propagate() will result in
 being set to a value in . Now, for ,  is not modified in step (f), and therefore,
for fault-free , . Thus, we can conclude that, at the end of step (f), for all
fault-free nodes
, .

\item
step (g):
In step (g), at each , \Equality() either keeps  unchanged,
or modifies it to be . Thus, at the end of step (g), for
all fault-free ,  remains in .

\item
step (h):
Consider a fault-free node . During \Propagate(),
 receives  values along  disjoint paths originating
at nodes in . Therefore, at least one of the  values
is received along a path that contains only fault-free nodes;
suppose that the value received by node  along this fault-free path
is equal to . As observed above, after step (g),
for each fault-free node , .
Therefore, , and at node ,
\Propagate() will result in
 being set to a value in .

\item step (i):
From the discussion of steps (g) and (h) above,
it follows that, in step (i), if  is updated
at a fault-free , then ;
on the other hand, if  is not modified,
then .
\end{itemize}
\end{itemize}
Now, consider a fault-free node . Step (j) uses set
 such that . As shown above, at the start of step (j),  at all fault-free . Since , at least one of the nodes in  is fault-free. Thus, of the  values received by node , at least one value must be in . It follows that if node  changes  in step (j), then the new value will also in ; on the other hand, if node  does not change , then it remains equal to .
\end{proof}




\begin{lemma}
\label{l_validity}
Algorithm BC satisfies the validity property for Byzantine consensus.
\end{lemma}
\begin{proof}
Recall that the state  of a fault-free node  is {\em valid} if it equals the input
at a fault-free node.
For each fault-free , initially,  is valid. 
Lemma \ref{l_valid_1} implies that after each INNER loop iteration,  remains valid
at each fault-free node .
Thus, when Algorithm BC terminates,  at each
fault-free node  will satisfy the {\em validity} property
for Byzantine consensus, as stated in Section \ref{s_intro}.
\end{proof}

\begin{lemma}
\label{l_termination}
Algorithm BC satisfies the termination property for Byzantine consensus.
\end{lemma}
\begin{proof}
Recall that we are assuming a synchronous system, and the graph 
is finite. Thus, Algorithm BC performs a finite number of OUTER loop iterations,
and a finite number of INNER loop iterations for each
choice of  in the OUTER loop,
the number of iterations being a function of graph .
Hence, the termination property is satisfied.
\end{proof}



\begin{lemma}
\label{l_agreement}
Algorithm BC satisfies the agreement property for Byzantine consensus.
\end{lemma}


\begin{proofSketch}
The complete proof is in Appendix \ref{a_l_agreement}. Recall that  denotes the actual set of faulty nodes in the network (). Since the OUTER loop considers all possible  such that , eventually, the OUTER loop will be performed with .
 We will show that when OUTER loop is performed with , {\em agreement} is achieved.
After agreement
is reached when , Algorithm BC may perform the OUTER loop with other choices of set . However, due to Lemma \ref{l_valid_1}, the {\em agreement} among fault-free nodes is still preserved.
(Also, due to Lemma \ref{l_valid_1}, before the OUTER loop with  is performed,  at each fault-free node remains valid.)

Now, consider the OUTER loop with .
We will say that an INNER loop iteration with  is ``deciding'' if one of the following
conditions is true: (i) in Case 1 of the INNER loop iteration, after step (b) is performed,
all the nodes in set  have an identical value for variable ,
or (ii) in Case 2 of the INNER loop iteration, after step (g) is performed,
all the nodes in set  have an identical value for variable .
As elaborated in Appendix \ref{a_l_agreement},
when , at least one of the INNER loop
iterations must be a {\em deciding} iteration. 
Let us partition the INNER loop iterations when  into three phases:
\begin{itemize}
\item Phase 1: INNER loop iterations before the first deciding iteration with .
\item Phase 2: The first deciding iteration with .
\item Phase 3: Remaining INNER loop iterations with .
\end{itemize}

From the pseudo-code for~\Propagate~and~\Equality, observe that when , all paths
used in the INNER loop iterations {\bf exclude} . That is, all these paths contain only
fault-free nodes, since  is the actual set of faulty nodes.
In each INNER loop iteration in Phase 1, we can show that value  for each fault-free node  remains unchanged from previous INNER loop iteration. 
As elaborated in Appendix \ref{a_l_agreement},
this together with fact that the value  for each fault-free node , ensures that a {\em deciding} INNER loop iteration is eventually performed when
 (e.g., when set  contains the fault-free nodes with  value equal to , and set  contains the remaining fault-free nodes, or vice-versa).
 In Phase 2, Algorithm BC achieves agreement among fault-free nodes due to the fact that nodes in set  reliably propagate an identical value to all the other nodes. Finally, in Phase 3,
 due to Lemma \ref{l_valid_1},
 agreement achieved in the previous phase is preserved.
 Therefore, at the end of the OUTER loop with , agreement is achieved.
\end{proofSketch}

\begin{theorem}
\label{t_correct}
Algorithm BC satisfies the agreement, validity, and termination conditions.
\end{theorem}

\begin{proof}
The theorem follows from Lemmas \ref{l_validity}, \ref{l_termination} and \ref{l_agreement}.
\end{proof}

\subsection{Application to Multi-Valued Consensus}

Algorithm BC can be used to solve a particular version of {\em multi-valued} consensus with the following properties: 

\begin{itemize}
\item \textbf{Agreement}: the output (i.e., decision) at all the fault-free nodes must be identical.

\item \textbf{Validity}: If all fault-free nodes have the same input, then the output of every fault-free node equals its input.

\item \textbf{Termination}: every fault-free node eventually decides on an output.

\end{itemize}
Under these conditions, if all the fault-free nodes do not have the same multi-valued input,
then it is possible for
the fault-free nodes to agree on a value that is not an input at any fault-free node.
This multi-valued consensus problem for -bit input values can be solved by executing
 instance of Algorithm BC, one instance for each bit of the input, on graphs
that satisfy the condition stated in Theorem \ref{t_nec_2}.
The 1-bit output of each of the  instances put together form the -bit output
of the multi-valued consensus problem. Correctness of this procedure follows from
Theorem \ref{t_correct}.

If the above validity condition for multi-valued consensus is made stronger, to require that the
output value must be the multi-valued input of a fault-free node, then the condition
in Theorem \ref{t_nec_2} is not sufficient for inputs that can take 3 or more distinct values.  













\section{Conclusion}
\label{s_conclusion}

For nodes with binary inputs, we present a {\em tight} necessary and sufficient condition for achieving Byzantine consensus in synchronous {\em directed} graphs. The condition is shown to be necessary using traditional state-machine approach \cite{impossible_proof_lynch,dolev_82_BG, welch_book}. Then, we provide a constructive proof of sufficiency by presenting a new Byzantine consensus algorithm for graphs satisfying the necessary condition. The algorithm can also be used to solve multi-valued consensus.

Two open problems are of further interest: 

\begin{itemize}
\item  Algorithm BC presented in Section \ref{s_sufficiency} has exponential round complexity. The optimal round complexity for directed graphs is presently unknown.

\item It is not known whether one can efficiently determine that a given graph satisfies the condition in Theorem \ref{t_nec_2} or not. 


\end{itemize}







\begin{thebibliography}{10}

\bibitem{BFT-CUP_OPODIS}
E.~Alchieri, A.~Bessani, J.~Silva~Fraga, and F.~Greve.
\newblock Byzantine consensus with unknown participants.
\newblock In T.~Baker, A.~Bui, and S.~Tixeuil, editors, {\em Principles of
  Distributed Systems}, volume 5401 of {\em Lecture Notes in Computer Science},
  pages 22--40. Springer Berlin Heidelberg, 2008.

\bibitem{welch_book}
H.~Attiya and J.~Welch.
\newblock {\em Distributed Computing: Fundamentals, Simulations, and Advanced
  Topics}.
\newblock Wiley Series on Parallel and Distributed Computing, 2004.

\bibitem{Bansal_disc11}
P.~Bansal, P.~Gopal, A.~Gupta, K.~Srinathan, and P.~K. Vasishta.
\newblock Byzantine agreement using partial authentication.
\newblock In {\em Proceedings of the 25th international conference on
  Distributed computing}, DISC'11, pages 389--403, Berlin, Heidelberg, 2011.
  Springer-Verlag.

\bibitem{dag_decomposition}
S.~Dasgupta, C.~Papadimitriou, and U.~Vazirani.
\newblock {\em Algorithms}.
\newblock McGraw-Hill Higher Education, 2006.

\bibitem{yvo_eurocrypt02}
Y.~Desmedt and Y.~Wang.
\newblock Perfectly secure message transmission revisited.
\newblock In L.~Knudsen, editor, {\em Advances in Cryptology -- EUROCRYPT
  2002}, volume 2332 of {\em Lecture Notes in Computer Science}, pages
  502--517. Springer Berlin Heidelberg, 2002.

\bibitem{dolev_82_BG}
D.~Dolev.
\newblock The byzantine generals strike again.
\newblock {\em Journal of Algorithms}, 3(1):1430, March 1982.

\bibitem{Dolev90perfectlysecure}
D.~Dolev, C.~Dwork, O.~Waarts, and M.~Yung.
\newblock Perfectly secure message transmission.
\newblock {\em Journal of the Association for Computing Machinery (JACM)},
  40(1):17--14, 1993.

\bibitem{impossible_proof_lynch}
M.~J. Fischer, N.~A. Lynch, and M.~Merritt.
\newblock Easy impossibility proofs for distributed consensus problems.
\newblock In {\em Proceedings of the fourth annual ACM symposium on Principles
  of distributed computing}, PODC '85, pages 59--70, New York, NY, USA, 1985.
  ACM.

\bibitem{psl_BG_1982}
L.~Lamport, R.~Shostak, and M.~Pease.
\newblock The byzantine generals problem.
\newblock {\em ACM Trans. on Programming Languages and Systems}, 1982.

\bibitem{Sundaram_journal}
H.~LeBlanc, H.~Zhang, X.~Koutsoukos, and S.~Sundaram.
\newblock Resilient asymptotic consensus in robust networks.
\newblock {\em IEEE Journal on Selected Areas in Communications: Special Issue
  on In-Network Computation}, 31:766--781, April 2013.

\bibitem{leblanc_HiCoNs}
H.~LeBlanc, H.~Zhang, S.~Sundaram, and X.~Koutsoukos.
\newblock Consensus of multi-agent networks in the presence of adversaries
  using only local information.
\newblock {\em HiCoNs}, 2012.

\bibitem{impossible_link}
U.~Schmid, B.~Weiss, and I.~Keidar.
\newblock Impossibility results and lower bounds for consensus under link
  failures.
\newblock {\em SIAM J. Comput.}, 38(5):1912--1951, Jan. 2009.

\bibitem{Shankar_SODA08}
B.~Shankar, P.~Gopal, K.~Srinathan, and C.~P. Rangan.
\newblock Unconditionally reliable message transmission in directed networks.
\newblock In {\em Proceedings of the nineteenth annual ACM-SIAM symposium on
  Discrete algorithms}, SODA '08, pages 1048--1055, Philadelphia, PA, USA,
  2008. Society for Industrial and Applied Mathematics.

\bibitem{Tseng_general}
L.~Tseng and N.~H. Vaidya.
\newblock Iterative approximate byzantine consensus under a generalized fault
  model.
\newblock In {\em In International Conference on Distributed Computing and
  Networking (ICDCN)}, January 2013.

\bibitem{vaidya_incomplete}
N.~H. Vaidya.
\newblock Iterative byzantine vector consensus in incomplete graphs.
\newblock In {\em In International Conference on Distributed Computing and
  Networking (ICDCN)}, January 2014.

\bibitem{vaidya_PODC12}
N.~H. Vaidya, L.~Tseng, and G.~Liang.
\newblock Iterative approximate byzantine consensus in arbitrary directed
  graphs.
\newblock In {\em Proceedings of the thirty-first annual ACM symposium on
  Principles of distributed computing}, PODC '12. ACM, 2012.

\bibitem{Graph_theory_west}
D.~B. West.
\newblock {\em Introduction To Graph Theory}.
\newblock Prentice Hall, 2001.

\bibitem{Sundaram_ACC}
H.~Zhang and S.~Sundaram.
\newblock Robustness of complex networks with implications for consensus and
  contagion.
\newblock In {\em Proceedings of CDC 2012, the 51st IEEE Conference on Decision
  and Control}, 2012.

\bibitem{Sundaram}
H.~Zhang and S.~Sundaram.
\newblock Robustness of distributed algorithms to locally bounded adversaries.
\newblock In {\em Proceedings of ACC 2012, the 31st American Control
  Conference}, 2012.

\end{thebibliography}




\appendix





\newpage

\centerline{\Large\bf Appendices}














\section{Necessity Proof of Theorem \ref{t_nec_2}}
\label{a_1and2}

This appendix presents the proof of necessity of the condition stated in Theorem \ref{t_nec_2}.
We first present an alternative form of the necessary condition, named {\em Condition 1} below. We use the
well-known state-machine approach \cite{impossible_proof_lynch,dolev_82_BG, welch_book} to show the necessity
of {\em Condition 1}. Then, we prove that the condition stated in Theorem \ref{t_nec_2} is
equivalent to {\em Condition 1}.

\subsection{Necessary Condition 1}

Necessary condition 1 is stated in Theorem \ref{t_nec_1} below.
Its proof uses the familiar proof technique based on state machine approach.
Although the proof of Theorem \ref{t_nec_1} is straightforward, we include it here
for completeness.
Readers may omit the proof of Theorem \ref{t_nec_1} in this section without lack of continuity.

We first define relations  and  that are used subsequently.
These relations are defined for disjoint sets. 
Two sets are disjoint if their intersection is empty.
For convenience of presentation, we adopt the convention that
sets  and  are disjoint if either one of them is empty.
More than two sets are disjoint if they are pairwise disjoint.


\begin{definition}
\label{def:absorb}
For disjoint sets of nodes  and , where  is non-empty:
\begin{itemize}
\item  iff set  contains at least
  distinct incoming neighbors of .

 That is, .
\item  iff  is {\em not} true.
\end{itemize}
\end{definition}


The theorem below states {\em Condition 1}, and proves its necessity. 

\begin{theorem}
\label{t_nec_1}
Suppose that a correct Byzantine consensus algorithm exists for .
For any partition
\footnote{Sets  are said to form a partition of set  provided that (i) , and (ii)  if .}
  of , such that
both  and  are non-empty, and , either , 
or .
\end{theorem}

We first describe the intuition behind the proof, followed by a formal proof. The proof is by contradiction.

Suppose that there exists a partition  where  are non-empty and  such that
, and . Assume that the nodes in  are faulty, and the nodes in sets  are fault-free. Note that fault-free nodes are not aware of the identity of the faulty nodes.


Consider the case when all the nodes in  have input , and all the nodes in  have input , where . Suppose that the nodes in  (if non-empty) behave to nodes in  as if nodes in  have input , while behaving to nodes in  as if nodes in  have input . This behavior by nodes in  is possible, since the nodes in  are all assumed to be faulty here. 

Consider nodes in .
Let  denote the set of incoming neighbors of  in .
Since , .
Therefore, nodes in  cannot distinguish between the following two scenarios:
 (i) all the nodes in  (if non-empty) are faulty, rest of the nodes are fault-free,  and all the fault-free nodes have input , and (ii) all the nodes in  (if non-empty) are faulty, rest of the nodes are fault-free, and fault-free nodes have input either  or . In the first scenario, for validity, the output at nodes in  must be . Therefore, in the second scenario as well, the output at the nodes in  must be . We can similarly show that the output at the nodes in  must be . Thus, if the condition in Theorem \ref{t_nec_1} is not satisfied, nodes in  and  can be forced to decide on distinct values, violating the agreement property. Now, we present the formal proof. Note that the formal proof relies on traditional state-machine approach \cite{impossible_proof_lynch, welch_book}. We include it here for completeness.


\paragraph{Proof of Theorem \ref{t_nec_1}:}
~\\

\begin{proof}
The proof is by contradiction.
Suppose that a correct Byzantine consensus algorithm, say ALGO, exists in , and there exists a partition  of  such that  and . Thus,  has at most  incoming neighbors in ,
and  has at most  incoming neighbors in .
Let us define:

Then,



The behavior of each node  when
using ALGO can be modeled by a state machine
that characterizes the behavior of each node . \\

We construct a new network called , as illustrated in Figure \ref{sm_1-1}.
In , there are three copies of each node in ,
and two copies of each node in .
In particular, C0 represents one copy of the nodes in ,
C1 represents the second copy of the nodes in ,
and 
C2 represents the third copy of the nodes in .
Similarly, R0 and R2 represent the two copies of the nodes in ,
L0 and L1 represent the two copies of the nodes in , and
F1 and F2 represent the two copies of the nodes in .
Even though the figure shows just one vertex for C1, it represents
all the nodes in  (each node in  has a counterpart in the nodes
represented by C1). Same correspondence holds for other vertices
in Figure \ref{sm_1-1}.





\begin{figure}[p]
\centering
\includegraphics[width=220mm,bb=0 0 960 720]{1_1-new.jpg}
\caption{Network }
\label{sm_1-1}
\end{figure}

~



The communication links in  are derived using the communication
graph . The figure shows solid edges and dotted edges,
and also edges that do not terminate on one end.
We describe all three types of edges below.
\begin{itemize}
\item {\em Solid edges:}
If a node  has a link to node 
in , i.e., ,
then each copy of node  in  will have a link from
{\bf one of the copies} of node  in .
Exactly which copy of node  has link to a copy of
node  is represented with the edges shown in 
Figure \ref{sm_1-1}.
For instance,
the directed edge from vertex R0 to vertex F1 in Figure \ref{sm_1-1} indicates
that, {\bf if} for  and , link ,
then there is a link in  from the copy of  in R0 to
the copy of  in F1.
Similarly,
the directed edge from vertex F2 to vertex L0 in Figure \ref{sm_1-1} indicates
that, {\bf if} for  and , link ,
then there is a link from the copy of  in F2 to the copy of  in L0.
Other solid edges in Figure \ref{sm_1-1} represent other communication
links in  similarly.

\item {\em Dotted edges:}
Dotted edges are defined similar to the solid edges, with the difference being that
the dotted edges emulate a broadcast operation. 
Specifically, in certain cases, if link , then one copy of node 
in  may have links to {\bf two} copies of node  in , with both copies
of node  receiving identical messages from the same copy of node . 
This should be viewed as a ``broadcast'' operation that is being
emulated {\em unbeknownst} to the
nodes in .
There are four such ``broadcast edges'' in the figure, shown as
dotted edges.
The broadcast edge from L0 to R0 and R2 indicates that
{\bf if} for  and , link ,
then messages from the copy of node  in L0 are broadcast to the
copies of node  in R0 and R2 both.
Similarly, the broadcast edge from R0 to C0 and C1 indicates that
{\bf if} for  and , link ,
then messages from the copy of node  in R0 are broadcast to the
copies of node  in C0 and C1 both.
There is also a broadcast edge from L0 to C0 and C2,
and another broadcast edge from R0 to L0 and L1. 

\item {\em ``Hanging'' edges:}
Five of the edges in Figure \ref{sm_1-1} do not terminate at any vertex.
One such edge originates at each of the vertices C1, L1, R2, C2, and C0,
and each such edge is labeled as R, L or F, as explained next.
A {\em hanging} edge signifies that the corresponding transmissions are discarded
silently without the knowledge of the sender.
In particular, the {\em hanging} edge originating at L1 with label R indicates the following:
if for  and , , then transmissions by
the copy of node  in L1 to node  are silently discarded {\em without the knowledge} of
the copy of node  in L1.
Similarly, the {\em hanging} edge originating at C0 with label F indicates the following:
if for  and , , then transmissions by
the copy of node  in C0 to node  are silently discarded {\em without the knowledge} of
the copy of node  in C0.

It is possible to avoid using such ``hanging'' edges by introducing additional vertices
in . We choose the above approach to make the representation more compact.

\end{itemize}
Whenever , in network , each copy of node  has
an incoming edge from {\bf one copy of} node , as discussed above.
The broadcast and hanging edges defined above are consistent with our
{\em communication model} in Section \ref{s_intro}. As noted there,
each node, when sending a message, simply puts the message in the send
buffer. Thus, it is possible for us to emulate hanging edges by
discarding messages from the buffer, or broadcast edges by replicating
the messages into two send buffers. (Nodes do not read messages in
send buffers.) 

Now, let us assign input of  or , where ,
to each of the nodes in . The inputs are shown next to the
vertices in small rectangles Figure \ref{sm_1-1}.
For instance,  next to vertex C1 means that each node
represented by C1 has input  (recall that C1 represents
one copy of each node in ). 
Similarly,  next to vertex L0 means that each node
represented by L0 has input .



Let  denote a particular execution of ALGO in  given the input specified above. Now, we identify three executions of ALGO in  with a different set of nodes of size  behaving faulty. The behavior of the nodes is modeled by the corresponding nodes in .

\begin{itemize}
\item {\bf Execution :}

Consider an execution  of ALGO in , where the incoming neighbors of nodes in  that are in  or , i.e., nodes in , are faulty, with the rest of the nodes being fault-free. In addition, all the fault-free nodes
have inputs . Now, we describe the behavior of each node.

\begin{itemize}
\item The behavior of fault-free nodes in , ,  and  is modeled by the corresponding nodes in R0, F1, C1, and L1 in . For example, nodes in  send to their outgoing neighbors in  the messages sent in  by corresponding nodes in F1 to their outgoing neighbors in L1.

\item The behavior of the faulty nodes (i.e., nodes in ) is modeled by the behavior of the senders for the incoming links at the nodes in R0. In other words, faulty nodes are sending to their outgoing neighbors in  the messages sent in  by corresponding nodes in C0 or L0 to their outgoing neighbors in R0.
\end{itemize}
Recall from (\ref{e_nr}) that . Since ALGO is correct in , the nodes in  must agree on , because all the fault-free nodes in network I have input .




\item {\bf Execution :}

Consider an execution  of ALGO in , where the incoming neighbors of nodes in  that are in  or , i.e., nodes in , are faulty, with the rest of the nodes being fault-free. In addition, all the fault-free
nodes have inputs . Now, we describe the behavior of each node.

\begin{itemize}
\item The behavior of fault-free nodes in , , , and  is modeled by the corresponding nodes in R2, F2, C2, and L0 in . For example, nodes in  send to their outgoing neighbors in  the messages sent in  by corresponding nodes in F2 to their outgoing neighbors in R2.

\item The behavior of the faulty nodes (i.e., nodes in ) is modeled by the behavior of the senders for the incoming links at the nodes in L0. In other words, faulty nodes are sending to their outgoing neighbors in  the messages sent in  by corresponding nodes in C0 or R0 to their outgoing neighbors in L0.
\end{itemize}
Recall from (\ref{e_nl}) that . Since ALGO is correct in , the nodes in  must agree on , because all the fault-free nodes in network II have input .

\item {\bf Execution :}

Consider an execution  of ALGO in , where the nodes in F are faulty, with the rest of the nodes being fault-free. In addition, nodes in  have inputs , and the nodes in  have inputs . Now, we describe the behavior of each node.


\begin{itemize}
\item The behavior of fault-free nodes in ,  and  is modeled by the corresponding nodes in R0, C0, and L0 in . For example, nodes in  are sending to their outgoing neighbors in  the messages sent in  by corresponding nodes in R0 to their outgoing neighbors in L0.

\item The behavior of the faulty nodes (i.e., nodes in ) is modeled by the nodes in F1 and F2. In particular, faulty nodes in  send to their outgoing neighbors in  the messages sent in  by corresponding nodes in F1 to their outgoing neighbors in R0. Similarly the faulty nodes in  send to their outgoing neighbors in  the messages sent in  by corresponding nodes in F2 to their outgoing neighbors in L0.  
\end{itemize}

Then we make the following two observations regarding :

\begin{itemize}
\item Nodes in  must decide  in 
because, by construction, nodes in  cannot distinguish between  and . 
Recall that nodes in  decide on  in .



\item Nodes in  must decide .
because by construction, nodes in  cannot distinguish between  and .
Recall that nodes in  decide on  in .

\end{itemize}
Thus, in , the fault-free nodes in  and  decide on different
values, even though . This violates the agreement condition,
contradicting the assumption that ALGO
is correct in .

\end{itemize}

\comment{+++++++++++ old podc submission++++++++++++++

Consider three sub-networks of . In each case, we will identify a set of
 nodes in  as being fault-free. The behavior of the faulty nodes is modeled
by the rest of .

\begin{itemize}

\item {\bf Sub-network I} consists of nodes in R0, C1, L1 and F1.
Let the incoming neighbors of nodes in R0 that are {\underline not} in R0 or F1 be faulty,
with the rest of the nodes being fault-free.
The behavior of the faulty nodes (i.e., incoming neighbors of R0 that are not in R0 or F1)
is modeled by the behavior of the senders for the incoming links at the nodes in R0.
Recall from (\ref{e_nr}) that .
Since ALGO is correct in , it must be correct
in sub-network I. Therefore, the nodes in R0 must agree on ,
because all the fault-free nodes in sub-network I have input .

\item {\bf Sub-network II} consists of nodes in L0, C2, R2 and F2.
Let the incoming neighbors of nodes in L0 that are {\underline not} in L0 or F2 be faulty,
with the rest of the nodes being fault-free.
The behavior of the faulty nodes (i.e., incoming neighbors of L0 that are not in L0 or F2)
is modeled by the behavior of the senders for the incoming links at the nodes in L0.
Recall from (\ref{e_nl}) that .
Since ALGO is correct in , it must be correct
in sub-network II. Therefore, the nodes in L0 must agree on ,
because all the fault-free nodes in sub-network II have input .

\item {\bf Sub-network III} consists of nodes in C0, L0, R0 and F1. In this case, the fault-free nodes are the nodes in C0, L0, and R0, with the nodes in F1 being faulty. The behavior of the faulty nodes (i.e., nodes in F1) is modeled by the nodes in F1 and F2. In particular, faulty nodes are sending to their outgoing neighbors in R0 the messages sent by F1 to R0 in , and to their outgoing neighbors in L0 the messages sent by F2 to L0 in .  Note that .
Therefore, since ALGO is correct in , it must be correct
in sub-network III. Therefore, the nodes in L0 and R0 must agree on
an identical value.
However, this requirement contradicts with sub-networks I and II,
where nodes in R0 agree on , and nodes in L0 agree on , respectively.
\end{itemize}
The contradiction identified above proves that the condition in Theorem \ref{t_nec_1} is necessary.

++++++++++++++}
\end{proof}








\subsection{Equivalence of the Conditions Stated in Theorem \ref{t_nec_2} and Condition 1}

In this section, we first prove that Condition 1 (the condition in Theorem \ref{t_nec_1}) implies the condition in Theorem \ref{t_nec_2},
and then prove that the condition in Theorem \ref{t_nec_2} implies Condition 1 (the condition in Theorem \ref{t_nec_1}). Thus, the two conditions are proved to be equivalent.
We first prove the two lemmas below. The proofs use the following version of Menger's theorem \cite{Graph_theory_west}.

\begin{theorem}[Menger's Theorem]
Given a graph  and two nodes , then a set  is an -cut if there is no -path excluding , i.e., every path from  to  must contain some nodes in .
\end{theorem}

\begin{lemma}
\label{lemma:prop}
Assume that Condition 1 (the condition in Theorem \ref{t_nec_1}) holds for .
For any partition
 of , where 
is non-empty, and , if ,
then .
\end{lemma}

\begin{proof}
Suppose that  is a partition of , where
 is non-empty, , and .
If , then by Definition \ref{def:propagate},
the lemma is trivially true.
In the rest of this proof, assume that .



Add a new (virtual) node  to graph , such that, (i)  has no
incoming edges, (ii)  has an outgoing edge to each node
in , and (iii)  has no outgoing edges to any node that is not in .
Let  denote the graph resulting after the addition of  to 
as described above. 

We want to prove that .
Equivalently,\footnote{\label{f_prop} {\tt Footnote:} {\em Justification}:
Suppose that . By the definition of ,
for each ,
there exist at least  disjoint -paths excluding ;  these
paths only share
node . Since  has outgoing links to all the nodes in , this implies
that there exist  disjoint -paths excluding  in ;
these paths only share
nodes  and .
Now, let us prove the converse. Suppose that there exist
 disjoint -paths excluding  in . Node  has
outgoing links
only to the nodes in , therefore, from the  disjoint -paths
excluding , if we
delete node  and its outgoing links, then the shortened paths
are disjoint ()-paths excluding .}
we want to prove that, in graph , for each , there exist
 disjoint ()-paths excluding .
We will prove this claim by contradiction.

Suppose that , and
therefore, there exists a node  such that there are at most 
disjoint  paths excluding  in . By construction, there is no direct edge from  to . Then Menger's theorem \cite{Graph_theory_west} implies that
there exists a set  with
, such that, in graph , there is no -path
excluding . In other words, all -paths
excluding  contain at least one node in .

Let us define the following sets .
Some of the sets defined in this proof are illustrated in Figure \ref{fig:lemma6}.
\begin{itemize}
\item .
	
	 is non-empty, because  is non-empty.
\item i,bF\cup F_1.

Thus, .\\
Note that . Thus,  is non-empty.

\item . 

Thus, . Since , it follows
	that .
 
\end{itemize}

\begin{figure}[tbhp]
\centering
\includegraphics[scale=0.6, bb=-30 -30 928 316]{lemma6.jpg}
\caption{Illustration for the proof of Lemma \ref{lemma:prop}}
\label{fig:lemma6}
\end{figure}

~


Observe that  are disjoint sets, because  and  are disjoint, and
.
Since set , , and ,
we have
, and .
Thus, set  can be partitioned into disjoint sets  and 
such that
\begin{itemize}
\item , and
\item . Note that .
\end{itemize}
We make the following observations:
\begin{itemize}
\item For any  and , .

	{\em Justification}:
	Recall that virtual node  has a directed edge to .
	If edge  were to exist then there would be a )-path
	via nodes  and  excluding 
	(recall from definition of  that  has
	a path to  excluding ).
	This contradicts the definition of set .
\item For any , and , .
	
	{\em Justification}:
	If edge  were to exist, then there would be a -path
	via node  excluding ,
        since  has a -path excluding .
	Then node  should have been in  by the definition of .
	This is a contradiction to the assumption that , since
	.
\end{itemize}
Thus, all the incoming neighbors of set  are contained in  (note that
).
Recall that .
Since , it follows that


Recall that .
By definitions of  above, we have  and .
Thus,

(\ref{e1}) and (\ref{e2}) contradict the condition in Theorem \ref{t_nec_1}.
Thus, we have proved that
.
\end{proof}

\begin{lemma}
\label{lemma:prop2}
Assume that Condition 1 (the condition in Theorem \ref{t_nec_1}) holds for .
Consider a partition
 of , where 
are both non-empty, and .
If  then there exist  and  such
\begin{itemize}
\item  and  are both non-empty,
\item  and  form a partition of ,
\item  and , and
\item .
\end{itemize}
\end{lemma}
\begin{proof}
Suppose that 
.

Add a new (virtual) node  to graph , such that, (i)  has no
incoming edges, (ii)  has an outgoing edge to each node
in , and (iii)  has no outgoing edges to any node that is not in .
Let  denote the graph resulting after addition of  to 
as described above.

Since , for some node 
there exist at most  disjoint -paths excluding .
Therefore, there exist at most  disjoint -paths excluding
 in .\footnote{See footnote \ref{f_prop}.}
Also by construction, . Then, by Menger's theorem \cite{Graph_theory_west}, there must exist
, ,
such that, in graph , all ()-paths excluding  
contain at least one node in .

Define the following sets (also recall that ):
\begin{itemize}
\item
(i,a)F\cup F_1

\item
G_{+w}(w,j)F\cup F_1

Set  contains  since all nodes in  have edges from .

\item .\\ Observe that  (because
	nodes of  are not in ). Also, by definition of
	, sets  and  are disjoint.
\end{itemize}
Observe the following:
\begin{itemize}
\item
Sets  and  are disjoint, and set .
Also, .

{\em Justification}: . By definition of ,
	all -paths excluding  contain at least one node in .
If  were to be non-empty, we can find a -path excluding
, which is a contradiction.

Note that ; therefore, .
, since all nodes in  have links from .
Since  and  are disjoint, it follows that ,
and therefore, ; that is, .



\item For any  and , .

{\em Justification}: If such a link were to exist, then
	 should be in , which is a contradiction
	(since  and  are disjoint).

\item There are no links from nodes in  to nodes in .

{\em Justification}: If such a link were to exist,
	it would contradict the definition of , since we
	can now find a -path excluding .
\end{itemize}
Thus, all the incoming neighbors of set  must be contained in
. Recall that  and . Thus, 

Now define, ,  .
Observe the following:
\begin{itemize}
\item  and  form a partition of .

{\em Justification}:
 are disjoint sets, therefore  and
 are disjoint. By the definition of
sets  it follows that
.

\item  is non-empty and .

{\em Justification}:
By definition of set , set  contains node .
Thus,  is non-empty. We have already argued that .
Thus, .



\item  is non-empty and .

{\em Justification}:
Recall that  are disjoint,
and . Thus, by definition of ,
. Since , it follows that
.
Also, since  is non-empty,  is also non-empty.

\item 

{\em Justification}: Follows directly from (\ref{e3}),
and the definition of  and . 
\end{itemize}
This concludes the proof.
\end{proof}

~



\paragraph{Necessity Proof of Theorem \ref{t_nec_2}}

We now prove that Condition 1 (the condition in Theorem \ref{t_nec_1}) implies the condition in Theorem \ref{t_nec_2}.

\begin{proof}

Assume that Condition 1 (the condition in Theorem \ref{t_nec_1}) is satisfied by graph
. Consider a partition of  of  such that
 are non-empty and .
Then, we must show that either 
or .

\noindent
Consider two possibilities:
\begin{itemize}
\item : In this case, the proof is complete.
\item :
Then by Lemma \ref{lemma:prop2} in Appendix \ref{a_1and2}, there exist non-empty sets 
that form a partition of  such that
, , and .
Lemma \ref{lemma:prop} in Appendix \ref{a_1and2} then implies that .



Because ,
for each , there exist  disjoint -paths excluding .
Since , it then follows that,
for each , there exist  disjoint -paths excluding .
Since , and , each -path excluding  is also a
-path excluding . Thus, 
for each , there exist  disjoint -paths excluding .
Therefore, .

\end{itemize}
\end{proof}



The proof above shows that
the {\em Condition 1} implies the condition
in Theorem \ref{t_nec_2}. That fact, and Lemma \ref{lemma:nec2-to-1} below,
together prove that the two forms of the condition are equivalent. Therefore, by Theorem \ref{t_nec_1}, the condition in Theorem \ref{t_nec_2} is necessary.

\begin{lemma}
\label{lemma:nec2-to-1}
The condition stated in Theorem \ref{t_nec_2} implies the condition stated in Theorem \ref{t_nec_1} (i.e., {\em Condition 1}).
\end{lemma}
\begin{proof}
We will prove the lemma by showing that, if {\em Condition 1} is violated, then the condition stated in Theorem \ref{t_nec_2}
is violated as well. 

Suppose that the {\em Condition 1} is violated. Then there exists a partition  of  such that  are both non-empty, ,  and .

Since , for any node , there exists a set , , such that all the -paths excluding  contain at least one node in . Since , Menger's theorem \cite{Graph_theory_west} implies that there are at most  disjoint  -paths excluding .  Thus, because , . 

Similarly, since , for any node , there exists a set , , such that all the -paths excluding   contain at least one node in . Menger's theorem \cite{Graph_theory_west} then implies that there are at most  disjoint -paths excluding .  Thus, .

Define , and . Thus,  is a partition of  such that  and  are non-empty. The two conditions derived above imply that
 and ,  violating the condition stated in Theorem \ref{t_nec_2}.
\end{proof}





\comment{+++++++++++++

\section{Proof of Claim (i) in Corollary \ref{cor:2f+1} in Section \ref{nec_2}}
\label{a_cor:2f+1}

\begin{proof}
Claim (ii) in the corollary is proved in the main body of the paper already. Now, we present the proof of Claim (i).

Since  is a necessary condition for Byzantine consensus in
undirected graphs \cite{impossible_proof_lynch, welch_book}, it follows that  is also necessary for directed graphs.  As presented below, this necessary condition can also be derived from Theorem \ref{t_nec_2}.

For , the corollary is trivially true.
Now consider .
 The proof is by contradiction. Suppose that .
As stated in Section \ref{s_intro}, we assume , since consensus for  is trivial.
Partition  into three subsets  such that ,
, and . Such a partition can be found because
. 
Since  are both non-empty, and contain at most  nodes each, we have 
 and , violating the condition in Theorem \ref{t_nec_2}.


\comment{++++++++++++++ old+++++
Claim (ii) in the corollary is proved in the main body of the paper already. Now, we present the proof of Claim (i).

Since  is a necessary condition for Byzantine consensus in
undirected graphs \cite{impossible_proof_lynch, welch_book}, it follows that  is also necessary for directed graphs.  As presented below, this necessary condition can also be derived from Theorem \ref{t_nec_1}.

For , the corollary is trivially true.
Now consider .
 The proof is by contradiction. Suppose that .
As stated in Section \ref{s_intro}, we assume , since consensus for  is
trivial.
Partition  into three subsets  such that ,
, and . Such a partition can be found because
. 
Define .
Since  are both non-empty, and contain at most  nodes each, we have 
and , violating the condition in Theorem \ref{t_nec_1}.
++++++++++++}
\end{proof}
++++++++++}







\section{2-clique Network}
\label{a_l_2clique}

In this section, we present a family of graphs, namely 2-clique network. We will prove that the graph satisfies the necessary condition in Theorem \ref{t_nec_2}, but each pair of nodes may not be able to communicate reliably with each other. 

\begin{definition}
\label{def:dual}
A graph  consisting of  nodes, where  is a positive even integer, is said to be a {\em 2-clique network} if all the following properties are satisfied: 

\begin{itemize}
\item It includes two disjoint cliques, each consisting of  nodes.
Suppose that the nodes in the two cliques are specified by sets  and ,
respectively, where ,
and .
Thus,  and , for  and ,
\item , for  
		and , and
\item , for  
		and .
\end{itemize}
\end{definition}
Figure \ref{f:2-core} is the 2-clique network for . Note that Section \ref{s_sufficiency} proves that Byzantine consensus is possible in all graphs that satisfy the necessary condition. Therefore, consensus is possible in the 2-clique network as well. 

~

We first prove the following lemma for any graph  that satisfies the necessary
condition.

\begin{lemma}
\label{lemma:AtoBC}
Let  be disjoint subsets of  such that  and  are non-empty. Suppose that  and . Then, .
\end{lemma}

\begin{proof}
The proof is by contradiction. Suppose that 

\begin{itemize}
\item , 
\item , and
\item .

\end{itemize}
The first condition above implies that .
By Definition \ref{def:propagate} and Menger's Theorem \cite{Graph_theory_west}, the third condition implies that there exists a node  and a set of nodes  such that , and all -paths excluding  contain at least one node in .
In other words, there is no -path excluding .
Observe that, because
,  cannot be in ; therefore
 must belong to set .

Let us define the sets  and  as follows:
\begin{itemize}
\item Node  if and only if 
	and there exists an -path
	excluding .
	It is possible that ; thus, the -path
	cannot contain any nodes in . 
\item Node  if and only if   and there exists an -path
	excluding .
\end{itemize}

By the definition of  and , it follows that
for any , there cannot be any
-path excluding .
Also, since , for each ,
there must exist an -path excluding ; thus,
, and .
Similarly, , and therefore, .

By definition of , there are no -paths excluding
. Therefore, because , there are
no -paths excluding . Therefore,
since , . This is a contradiction to the second condition above.
\end{proof}

~

Now, we use Lemma \ref{lemma:AtoBC} to prove the following Lemma.

\begin{lemma}
\label{l_2clique}
Suppose that  is a 2-clique network.
Then graph  satisfies the condition in Theorem \ref{t_nec_2}.
\end{lemma}

\begin{proof}





Consider a partition  of , where  and  are both non-empty, and . Recall from Definition \ref{def:dual} that  also
form a partition of .

Define  and .

Define  to be the set of directed links from the nodes
in  to the nodes in , or vice-versa.
Thus, there are
 directed links in 
from the nodes in  to the nodes in ,
and the same number of links from the nodes in  to the nodes
in . 
Each pair of links in , with the exception of
the link pair between  and , is node disjoint.
Since , it should be easy to see that, at least
one of the two conditions below is true:
\begin{list}{}{}
\item{(a)} There are at least  directed links from the nodes in  to the nodes in . 
\item{(b)} There are at least  directed links from the nodes in  to nodes the in . 
\end{list}
Without loss of generality, suppose that condition (a) is true.
Therefore, since 
and the nodes in  form a clique, it follows that .
Then, because  and , 
we have


 also implies that
either  or .
Without loss of generality, suppose that .
Then, since the nodes in  form a clique, it follows that

(recall that ). Since , we have 


(\ref{e_topo_1}) and (\ref{e_topo_2}), along with 
Lemma \ref{lemma:AtoBC} above imply that
. Therefore,
, and . 
Since  and , .
\end{proof}




\section{Proof of Corollary \ref{cor:2f+1}}
\label{a_cor:2f+1}

\begin{proof}
Since  is a necessary condition for Byzantine consensus in
undirected graphs \cite{impossible_proof_lynch, welch_book}, it follows that  is also necessary for directed graphs.  As presented below, this necessary condition can also be derived from Theorem \ref{t_nec_2}.

For , condition (i) in the corollary is trivially true.
Now consider .
 The proof is by contradiction. Suppose that .
As stated in Section \ref{s_intro}, we assume , since consensus for  is trivial.
Partition  into three subsets  such that ,
, and . Such a partition can be found because
. 
Since  are both non-empty, and contain at most  nodes each, we have 
 and , violating the condition in Theorem \ref{t_nec_2}.
Thus,  is a necessary condition.

Now, for , we show that it is necessary for each node to have at least  incoming neighbors. The proof is by contradiction.
Suppose that for some node , the number of incoming neighbors
is at most . Partition  into two sets  and 
such that  is non-empty and contains at most  incoming neighbors of ,
and . It should be easy to see that such  can be found, since node  has at most  incoming neighbors.

Define  and .
Thus,  form a partition of .
Then, since  and , it follows that .
Also, since  contains at most  incoming neighbors of node , and
set  contains only node , there are at most  node-disjoint -paths. Thus, . The above two conditions violate the necessary condition stated in Theorem \ref{t_nec_2}. 
\end{proof}





\section{Source Component}
\label{a_SC}


We introduce some definitions and results that are useful in the other appendices.


\begin{definition}
\label{def:decompose}
{\bf Graph decomposition:}
Let  be a subgraph of . Partition graph  into non-empty strongly connected components,
 , where  is a non-zero integer dependent on graph ,
 such that nodes  if and only if
there exist - and -paths both excluding nodes outside .

Construct a graph  wherein each strongly connected component  above is represented by vertex , and there is an edge from vertex  to vertex  if and only if the nodes in  have directed paths in  to the nodes in .
\end{definition}
It is known that the decomposition graph  is a directed {\em acyclic} graph \cite{dag_decomposition}.

\begin{definition}
\label{def:source_comp}
{\bf Source component}:
Let  be a directed graph, and let  be its decomposition as per Definition~\ref{def:decompose}. Strongly connected component  of  is said to be a {\em source component} if the corresponding vertex  in  is \underline{not} reachable from any other vertex in . 
\end{definition}



\begin{definition}
\label{def:reduced} {\bf Reduced Graph:}
For a given graph , and sets ,
, such that  and , reduced
graph  is defined as
follows: (i)
, and (ii)  is obtained by removing from 
all the links incident on the nodes in , and all the outgoing links from nodes
in . 
That is, .
\end{definition}


\begin{corollary}
\label{cor:1:prop}
Suppose that graph  satisfies the condition stated in
Theorem \ref{t_nec_1}. For any 
and , such that  and
, let  denote the set of nodes in the source component of
.
Then, .\end{corollary}


\begin{proof}
Since  contains non-zero number of nodes, its source component  must be non-empty.
If  is empty, then the corollary follows trivially by Definition \ref{def:propagate}.
Suppose that  is non-empty.
Since  is a source component in , it has
no incoming neighbors in ; therefore, all of the incoming neighbors
of  in  in graph  must belong to . Since , we have,

Lemma \ref{lemma:prop} in Appendix \ref{a_1and2} then implies that

\end{proof}


~

\begin{lemma}
\label{l_connected}
For any , , such that , : \begin{itemize}
\item The source component of  is strongly connected in . ( is defined in Definition \ref{def:G-F} in Section \ref{s_sufficiency}.)
\item The source component of  does not contain any nodes in .
\end{itemize}
\end{lemma}

\begin{proof}
By Definition \ref{def:decompose}, each pair of nodes  in the source
component of graph  has at least one -path 
and at least one -path consisting of nodes only in ,
i.e., excluding nodes in .

Since ,  contains other nodes besides .
Although nodes of  belong to graph , the
nodes in  do not have any outgoing links in .
Thus, a node in  cannot have paths to any other node in .
Then, due to the connetedness requirement of a source component,
it follows that no nodes of  can be in the source component.
\end{proof}



\section{Sufficiency for }
\label{a_f_0}

The proof below uses the terminologies and results presented in Appendix \ref{a_SC}.
We now prove that, when , the necessary condition in Theorem \ref{t_nec_2} is
sufficient to achieve consensus.

\begin{proof}

When ,
suppose that the graph  satisfies the necessary condition in Theorem \ref{t_nec_2}.
Consider the source component  in reduced graph , i.e., in the reduced graph where , as per Definition \ref{def:reduced} in Appendix \ref{a_SC}. Note that by definition,  is non-empty. Pick a node  in the source component. By Lemma \ref{l_connected} in Appendix \ref{a_SC},  is strongly connected in , and thus  has a directed path to each of the nodes in . By Corollary \ref{cor:1:prop} in Appendix \ref{a_SC}, because , , i.e., for each node , an -path exists. Since  is strongly connected, an -path also exists.  Then consensus can be achieved simply by node  routing its input to all the other nodes, and requiring all the nodes to adopt node 's input as the output (or decision) for the consensus.  It should be easy to see that termination, validity and agreement properties are all satisfied.

\end{proof}

























\section{Proof of Claim \ref{claim:inner_loop} in Section \ref{subsec:inner}}
\label{a_claim:S}

The proof below uses the terminologies and results presented in Appendix \ref{a_SC}. We first prove a simple lemma.


\begin{lemma}
\label{l_propagate_f+1}
Given a partition  of  such that  is non-empty,
and ,
if , then
size of  must be at least .
\end{lemma}
\begin{proof}
By definition, there must be at least  disjoint -paths
excluding  for each . Each of these  disjoint paths
will have a distinct {\em source} node in . Therefore, such  disjoint paths
can only exist if  contains at least  distinct nodes.
\end{proof}

~

~

\noindent


We now prove the claim (i) in Section \ref{subsec:inner}. \\







\noindent{\bf Proof of Claim \ref{claim:inner_loop} in Section \ref{subsec:inner}:}

The second claim of Claim \ref{claim:inner_loop} is proved in the main body already. Now, we present the proof of the first claim:

\noindent
{\em The required set  exists in both Case 1 and 2 of each INNER loop.}

~

Consider the two cases in the INNER loop.
\begin{itemize}
\item{Case 1:~}
  and :

Since , by Lemma \ref{lemma:prop2} in Appendix \ref{a_1and2},
there exist non-empty sets  that form a partition of
  such that  and

Let  be the set of incoming neighbors of  in .
Since , . Then
 has no incoming neighbors in . Therefore, the
source component of  
must be contained within . (The definition of source component is in Appendix \ref{a_SC}.)
Let  denote the set of nodes in this source component.
Since  is the source component, 
by Corollary \ref{cor:1:prop} in Appendix \ref{a_SC},

Since  and , .
Then, ; therefore,  is non-empty.
Also, since , set  must be non-empty
(by Lemma \ref{l_propagate_f+1} above).
By Lemma \ref{l_connected} in Appendix \ref{a_SC},  is strongly connected in . (The definition of  is in Section \ref{s_sufficiency}.)
Thus, set  as required in Case 1 exists.

\item{Case 2:~}
  and :

Recall that we consider  in Section \ref{subsec:inner}. 



By Corollary \ref{cor:2f+1} in Section \ref{nec_2}, since , . 
In this case, we pick an arbitrary non-empty set  such that , and find the source component of . 
Let the set of nodes in the source component be denoted as .
Since  is the source component, 
by Corollary \ref{cor:1:prop} in Appendix \ref{a_SC},

Also, since , and ,
we have .
Also, since  contains , and  is non-empty,
 is non-empty; also, since ,
set  must be non-empty (by Lemma \ref{l_propagate_f+1} above).
By Lemma \ref{l_connected} in Appendix \ref{a_SC},  is strongly connected in .
Thus, set  as required in Case 2 exists.
\end{itemize}



\fillbox


~

\comment{++++++
Consider nodes in set . As shown in Corollary \ref{cor:2f+1} in Section \ref{nec_2},
when , each node in  has at least  incoming neighbors.
Since ,
for each  there must exist at least
 incoming neighbors in . 
Thus, the desired set  exists, satisfying
the requirement in step (j) of Algorithm BC.

+++++++++++++ f+1??? ++++++++++++}

\fillbox





\section{Proof of Lemma \ref{l_agreement}}
\label{a_l_agreement}

The proof below uses the terminologies and results presented in Appendix \ref{a_SC}. Now, we present the proof of Lemma \ref{l_agreement}.

\begin{proof}
Recall that  denotes the \underline{actual set of faulty nodes} in
the network ().

Since the OUTER loop of Algorithm BC considers all possible 
such that , eventually, the OUTER loop will be
performed with .

In the INNER loop for , different partitions 
of  will be considered.
We will say that such a partition  is a ``conformant'' partition
if  for all , 
and  for all .
A partition  that is not conformant is said to be ``non-conformant''. Further, we will say that an INNER loop iteration is a ``deciding'' iteration if one of the following condition is true. 

\begin{itemize}
\item[C1]: The  partition of  considered in the iteration is conformant.

In Case 1 with conformant partition, every node in  has the same value   after step (a). Hence, in the end of step (b), every node in  has the same value . Now, consider Case 2 with conformant partition. Denote the value of all the nodes in  by  (). Then, in step (e), each node
  in  (including ) sets  equal to . In step (f), all the nodes in  receive identical values  from nodes in , and hence, they set value   equal to . Therefore, every node in  has the same value  at the end of step (g).

\item[C2]: The  partition of  considered in the iteration is non-conformant; however,
the values at the nodes are such that, at the end of step (b) of Case 1, or at the end of step (g) of Case 2 (depending on which case applies), every node in the corresponding set  has the same value . (The definition of source component is in Appendix \ref{a_SC}.) That is, for all .
\end{itemize}
In both C1 and C2, all the nodes in the corresponding source component  have the identical value  in the deciding iteration (in the end of step (b) of Case 1, and in the end of step (g) of Case 2). The iteration that is not deciding is said to be ``non-deciding''. 

\begin{claim}
\label{claim:deciding}
In the INNER loop with , value  for each fault-free node  will stay unchanged in every non-deciding iteration.
\end{claim}

\begin{proof}
Suppose that , and the INNER loop iteration under consideration is a non-deciding iteration. Observe that since the paths used in procedures {\tt Equality} and {\tt Propagate} exclude , none of the faulty nodes can affect the outcome of any INNER loop iteration when . Thus, during \Equality() (step (b) of Case 1, and step (g) of Case 2), each node in  can receive the value from other nodes in  correctly. Then, every node in  will set value  to be  in the end of \Equality(), since by the definition of non-deciding iteration, there is a pair of nodes  such that . Hence, every node in  will receive  copies of  after \Propagate() (step (c) of Case 1, and step (h) of Case 2), and will set value  to . Finally, at the end of the INNER loop iteration, the value  at each node stays unchanged based on the following two observations:

\begin{itemize}
\item nodes in  in Case 1, and in  in Case 2, will not change value  as specified by Algorithm BC, and

\item  for each node  in Case 1, and for each node 
in Case 2.
\end{itemize}
Thus, no node in  will change their  value (where ).

Note that by assumption, there is no fault-free node in , and hence, we do not need to consider STEP 2 of the INNER loop. Therefore, Claim \ref{claim:deciding} is proved.
\end{proof}

~

Let us divide the INNER loop iterations for  into three phases:
\begin{itemize}
\item Phase 1: INNER loop iterations before the first deciding iteration with .

\item Phase 2: The first deciding iteration with .

\item Phase 3: Remaining INNER loop iterations with .

\end{itemize}

\begin{claim}
\label{claim:phase2}
At least one INNER loop iteration with  is a deciding iteration.
\end{claim}

\begin{proof}
The input at each process is in . Therefore,
by repeated application of Lemma \ref{l_valid_1} in Section \ref{s:correct}, it is always true that  for each fault-free node . Thus, when the OUTER iteration for  begins, a conformant partition exists (in particular, set  containing all fault-free nodes with  value , and set  containing the remaining fault-free nodes, or vice-versa.) By Claim \ref{claim:deciding}, nodes in  will not change values during non-deciding iterations.
Then, since the INNER loop considers all partitions of , the INNER loop will eventually consider
either the above conformant partition, or sometime prior to considering the above conformant
partition, it will consider a non-conformant partition with properties in (C2) above.
\end{proof}

~

Thus, Phase 2 will be eventually performed when . Now, let us consider each phase separately:
\begin{itemize}

\item Phase 1: Recall that all the nodes in  are fault-free. By Claim \ref{claim:deciding}, the  at each fault-free node  stays unchanged.

\item Phase 2: Now, consider the first deciding iteration of the INNER loop. 

Recall from Algorithm BC that a suitable set  is identified in each INNER loop iteration.
 We will show that in the deciding iteration, every node in  will have the same  value. Consider two scenarios:

\begin{itemize}
\item The partition is non-conformant: Then by definition of deciding iteration, we can find an  such that  for all  after step (b) of Case 1, or after step (g) of Case 2.

\item The partition is conformant: Let  for all  for . Such an  exists because the partition is conformant.

\begin{itemize}
\item Case 1: In this case, recall that . Therefore, after steps (a) and (b) both,  at all  will be identical, and equal to .

\item Case 2: This is similar to Case 1. At the end of step (e), for all nodes
, .
After step (f), for all nodes , .
Therefore, after step (g),  for all nodes ,  will remain equal to .
\end{itemize}

\end{itemize}

Thus, in both scenarios above, we found a set  and  such that for all ,  after step (b) in Case 1, and after step (g) in Case 2.

Then, consider the remaining steps in the deciding iteration.

\begin{itemize}
\item Case 1: During \Propagate(), each node  will receive  copies of  along  disjoint paths, and set  in step (c). Therefore, each node  will update its  to be  in step (d).
(Each node  does not modify its , which is
already equal to .)

\item Case 2: After step (h),  for all . Thus, each node   will update  to be .
(Each node  does not modify its , which is
already equal to .)

\end{itemize}



Thus, in both cases, at the end of STEP 1 of the INNER loop, for
all , . 

Since all nodes in  are faulty, agreement has been reached at this
point.
The goal now is to show that the agreement
property is not violated by
actions taken in any future INNER loop iterations.

\item Phase 3: At the start of Phase 3, for each fault-free 
	node , we have .
	Then by Lemma \ref{l_valid_1}, all future INNER loop iterations cannot assign any value other than  to any node . 

\end{itemize}
After Phase 3 with , Algorithm BC may perform OUTER loop iterations for
other choices of set . However, due to Lemma \ref{l_valid_1},
the value  at each  (i.e., all fault-free nodes)
continues being equal to . 

Thus, Algorithm BC satisfies the {\em agreement} property, as stated
in Section \ref{s_intro}.
\end{proof}



 
 
 
\end{document}
