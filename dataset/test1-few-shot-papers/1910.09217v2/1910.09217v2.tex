\documentclass[dvipsnames]{article} \usepackage{iclr2020_conference, times}
\usepackage{xcolor}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{pifont}\newcommand{\cmark}{\ding{51}}\newcommand{\xmark}{\ding{55}}\usepackage{booktabs}
\usepackage{multirow}
\usepackage{xspace}
\usepackage{amsthm}
\usepackage{soul}
\usepackage{wrapfig}
\usepackage{inconsolata}
\newtheorem{theorem}{Theorem}


\usepackage{amsmath,amsfonts,bm}


\makeatletter
\DeclareRobustCommand\onedot{\futurelet\@let@token\@onedot}
\def\@onedot{\ifx\@let@token.\else.\null\fi\xspace}

\def\eg{\emph{e.g}\onedot} \def\Eg{\emph{E.g}\onedot}
\def\ie{\emph{i.e}\onedot} \def\Ie{\emph{I.e}\onedot}
\def\cf{\emph{cf}\onedot} \def\Cf{\emph{Cf}\onedot}
\def\etc{\emph{etc}\onedot} \def\vs{\emph{vs}\onedot}
\def\wrt{w.r.t\onedot} \def\dof{d.o.f\onedot}
\def\etal{\emph{et al}\onedot}
\makeatother

\newcommand{\figleft}{{\em (Left)}}
\newcommand{\figcenter}{{\em (Center)}}
\newcommand{\figright}{{\em (Right)}}
\newcommand{\figtop}{{\em (Top)}}
\newcommand{\figbottom}{{\em (Bottom)}}
\newcommand{\captiona}{{\em (a)}}
\newcommand{\captionb}{{\em (b)}}
\newcommand{\captionc}{{\em (c)}}
\newcommand{\captiond}{{\em (d)}}

\newcommand{\newterm}[1]{{\bf #1}}


\def\figref#1{figure~\ref{#1}}
\def\Figref#1{Figure~\ref{#1}}
\def\twofigref#1#2{figures \ref{#1} and \ref{#2}}
\def\quadfigref#1#2#3#4{figures \ref{#1}, \ref{#2}, \ref{#3} and \ref{#4}}
\def\secref#1{section~\ref{#1}}
\def\Secref#1{Section~\ref{#1}}
\def\twosecrefs#1#2{sections \ref{#1} and \ref{#2}}
\def\secrefs#1#2#3{sections \ref{#1}, \ref{#2} and \ref{#3}}
\def\eqref#1{equation~\ref{#1}}
\def\Eqref#1{Equation~\ref{#1}}
\def\plaineqref#1{\ref{#1}}
\def\chapref#1{chapter~\ref{#1}}
\def\Chapref#1{Chapter~\ref{#1}}
\def\rangechapref#1#2{chapters\ref{#1}--\ref{#2}}
\def\algref#1{algorithm~\ref{#1}}
\def\Algref#1{Algorithm~\ref{#1}}
\def\twoalgref#1#2{algorithms \ref{#1} and \ref{#2}}
\def\Twoalgref#1#2{Algorithms \ref{#1} and \ref{#2}}
\def\partref#1{part~\ref{#1}}
\def\Partref#1{Part~\ref{#1}}
\def\twopartref#1#2{parts \ref{#1} and \ref{#2}}

\def\ceil#1{\lceil #1 \rceil}
\def\floor#1{\lfloor #1 \rfloor}
\def\1{\bm{1}}
\newcommand{\train}{\mathcal{D}}
\newcommand{\valid}{\mathcal{D_{\mathrm{valid}}}}
\newcommand{\test}{\mathcal{D_{\mathrm{test}}}}

\def\eps{{\epsilon}}


\def\reta{{\textnormal{}}}
\def\ra{{\textnormal{a}}}
\def\rb{{\textnormal{b}}}
\def\rc{{\textnormal{c}}}
\def\rd{{\textnormal{d}}}
\def\re{{\textnormal{e}}}
\def\rf{{\textnormal{f}}}
\def\rg{{\textnormal{g}}}
\def\rh{{\textnormal{h}}}
\def\ri{{\textnormal{i}}}
\def\rj{{\textnormal{j}}}
\def\rk{{\textnormal{k}}}
\def\rl{{\textnormal{l}}}
\def\rn{{\textnormal{n}}}
\def\ro{{\textnormal{o}}}
\def\rp{{\textnormal{p}}}
\def\rq{{\textnormal{q}}}
\def\rr{{\textnormal{r}}}
\def\rs{{\textnormal{s}}}
\def\rt{{\textnormal{t}}}
\def\ru{{\textnormal{u}}}
\def\rv{{\textnormal{v}}}
\def\rw{{\textnormal{w}}}
\def\rx{{\textnormal{x}}}
\def\ry{{\textnormal{y}}}
\def\rz{{\textnormal{z}}}

\def\rvepsilon{{\mathbf{\epsilon}}}
\def\rvtheta{{\mathbf{\theta}}}
\def\rva{{\mathbf{a}}}
\def\rvb{{\mathbf{b}}}
\def\rvc{{\mathbf{c}}}
\def\rvd{{\mathbf{d}}}
\def\rve{{\mathbf{e}}}
\def\rvf{{\mathbf{f}}}
\def\rvg{{\mathbf{g}}}
\def\rvh{{\mathbf{h}}}
\def\rvu{{\mathbf{i}}}
\def\rvj{{\mathbf{j}}}
\def\rvk{{\mathbf{k}}}
\def\rvl{{\mathbf{l}}}
\def\rvm{{\mathbf{m}}}
\def\rvn{{\mathbf{n}}}
\def\rvo{{\mathbf{o}}}
\def\rvp{{\mathbf{p}}}
\def\rvq{{\mathbf{q}}}
\def\rvr{{\mathbf{r}}}
\def\rvs{{\mathbf{s}}}
\def\rvt{{\mathbf{t}}}
\def\rvu{{\mathbf{u}}}
\def\rvv{{\mathbf{v}}}
\def\rvw{{\mathbf{w}}}
\def\rvx{{\mathbf{x}}}
\def\rvy{{\mathbf{y}}}
\def\rvz{{\mathbf{z}}}

\def\erva{{\textnormal{a}}}
\def\ervb{{\textnormal{b}}}
\def\ervc{{\textnormal{c}}}
\def\ervd{{\textnormal{d}}}
\def\erve{{\textnormal{e}}}
\def\ervf{{\textnormal{f}}}
\def\ervg{{\textnormal{g}}}
\def\ervh{{\textnormal{h}}}
\def\ervi{{\textnormal{i}}}
\def\ervj{{\textnormal{j}}}
\def\ervk{{\textnormal{k}}}
\def\ervl{{\textnormal{l}}}
\def\ervm{{\textnormal{m}}}
\def\ervn{{\textnormal{n}}}
\def\ervo{{\textnormal{o}}}
\def\ervp{{\textnormal{p}}}
\def\ervq{{\textnormal{q}}}
\def\ervr{{\textnormal{r}}}
\def\ervs{{\textnormal{s}}}
\def\ervt{{\textnormal{t}}}
\def\ervu{{\textnormal{u}}}
\def\ervv{{\textnormal{v}}}
\def\ervw{{\textnormal{w}}}
\def\ervx{{\textnormal{x}}}
\def\ervy{{\textnormal{y}}}
\def\ervz{{\textnormal{z}}}

\def\rmA{{\mathbf{A}}}
\def\rmB{{\mathbf{B}}}
\def\rmC{{\mathbf{C}}}
\def\rmD{{\mathbf{D}}}
\def\rmE{{\mathbf{E}}}
\def\rmF{{\mathbf{F}}}
\def\rmG{{\mathbf{G}}}
\def\rmH{{\mathbf{H}}}
\def\rmI{{\mathbf{I}}}
\def\rmJ{{\mathbf{J}}}
\def\rmK{{\mathbf{K}}}
\def\rmL{{\mathbf{L}}}
\def\rmM{{\mathbf{M}}}
\def\rmN{{\mathbf{N}}}
\def\rmO{{\mathbf{O}}}
\def\rmP{{\mathbf{P}}}
\def\rmQ{{\mathbf{Q}}}
\def\rmR{{\mathbf{R}}}
\def\rmS{{\mathbf{S}}}
\def\rmT{{\mathbf{T}}}
\def\rmU{{\mathbf{U}}}
\def\rmV{{\mathbf{V}}}
\def\rmW{{\mathbf{W}}}
\def\rmX{{\mathbf{X}}}
\def\rmY{{\mathbf{Y}}}
\def\rmZ{{\mathbf{Z}}}

\def\ermA{{\textnormal{A}}}
\def\ermB{{\textnormal{B}}}
\def\ermC{{\textnormal{C}}}
\def\ermD{{\textnormal{D}}}
\def\ermE{{\textnormal{E}}}
\def\ermF{{\textnormal{F}}}
\def\ermG{{\textnormal{G}}}
\def\ermH{{\textnormal{H}}}
\def\ermI{{\textnormal{I}}}
\def\ermJ{{\textnormal{J}}}
\def\ermK{{\textnormal{K}}}
\def\ermL{{\textnormal{L}}}
\def\ermM{{\textnormal{M}}}
\def\ermN{{\textnormal{N}}}
\def\ermO{{\textnormal{O}}}
\def\ermP{{\textnormal{P}}}
\def\ermQ{{\textnormal{Q}}}
\def\ermR{{\textnormal{R}}}
\def\ermS{{\textnormal{S}}}
\def\ermT{{\textnormal{T}}}
\def\ermU{{\textnormal{U}}}
\def\ermV{{\textnormal{V}}}
\def\ermW{{\textnormal{W}}}
\def\ermX{{\textnormal{X}}}
\def\ermY{{\textnormal{Y}}}
\def\ermZ{{\textnormal{Z}}}

\def\vzero{{\bm{0}}}
\def\vone{{\bm{1}}}
\def\vmu{{\bm{\mu}}}
\def\vtheta{{\bm{\theta}}}
\def\va{{\bm{a}}}
\def\vb{{\bm{b}}}
\def\vc{{\bm{c}}}
\def\vd{{\bm{d}}}
\def\ve{{\bm{e}}}
\def\vf{{\bm{f}}}
\def\vg{{\bm{g}}}
\def\vh{{\bm{h}}}
\def\vi{{\bm{i}}}
\def\vj{{\bm{j}}}
\def\vk{{\bm{k}}}
\def\vl{{\bm{l}}}
\def\vm{{\bm{m}}}
\def\vn{{\bm{n}}}
\def\vo{{\bm{o}}}
\def\vp{{\bm{p}}}
\def\vq{{\bm{q}}}
\def\vr{{\bm{r}}}
\def\vs{{\bm{s}}}
\def\vt{{\bm{t}}}
\def\vu{{\bm{u}}}
\def\vv{{\bm{v}}}
\def\vw{{\bm{w}}}
\def\vx{{\bm{x}}}
\def\vy{{\bm{y}}}
\def\vz{{\bm{z}}}

\def\evalpha{{\alpha}}
\def\evbeta{{\beta}}
\def\evepsilon{{\epsilon}}
\def\evlambda{{\lambda}}
\def\evomega{{\omega}}
\def\evmu{{\mu}}
\def\evpsi{{\psi}}
\def\evsigma{{\sigma}}
\def\evtheta{{\theta}}
\def\eva{{a}}
\def\evb{{b}}
\def\evc{{c}}
\def\evd{{d}}
\def\eve{{e}}
\def\evf{{f}}
\def\evg{{g}}
\def\evh{{h}}
\def\evi{{i}}
\def\evj{{j}}
\def\evk{{k}}
\def\evl{{l}}
\def\evm{{m}}
\def\evn{{n}}
\def\evo{{o}}
\def\evp{{p}}
\def\evq{{q}}
\def\evr{{r}}
\def\evs{{s}}
\def\evt{{t}}
\def\evu{{u}}
\def\evv{{v}}
\def\evw{{w}}
\def\evx{{x}}
\def\evy{{y}}
\def\evz{{z}}

\def\mA{{\bm{A}}}
\def\mB{{\bm{B}}}
\def\mC{{\bm{C}}}
\def\mD{{\bm{D}}}
\def\mE{{\bm{E}}}
\def\mF{{\bm{F}}}
\def\mG{{\bm{G}}}
\def\mH{{\bm{H}}}
\def\mI{{\bm{I}}}
\def\mJ{{\bm{J}}}
\def\mK{{\bm{K}}}
\def\mL{{\bm{L}}}
\def\mM{{\bm{M}}}
\def\mN{{\bm{N}}}
\def\mO{{\bm{O}}}
\def\mP{{\bm{P}}}
\def\mQ{{\bm{Q}}}
\def\mR{{\bm{R}}}
\def\mS{{\bm{S}}}
\def\mT{{\bm{T}}}
\def\mU{{\bm{U}}}
\def\mV{{\bm{V}}}
\def\mW{{\bm{W}}}
\def\mX{{\bm{X}}}
\def\mY{{\bm{Y}}}
\def\mZ{{\bm{Z}}}
\def\mBeta{{\bm{\beta}}}
\def\mPhi{{\bm{\Phi}}}
\def\mLambda{{\bm{\Lambda}}}
\def\mSigma{{\bm{\Sigma}}}

\DeclareMathAlphabet{\mathsfit}{\encodingdefault}{\sfdefault}{m}{sl}
\SetMathAlphabet{\mathsfit}{bold}{\encodingdefault}{\sfdefault}{bx}{n}
\newcommand{\tens}[1]{\bm{\mathsfit{#1}}}
\def\tA{{\tens{A}}}
\def\tB{{\tens{B}}}
\def\tC{{\tens{C}}}
\def\tD{{\tens{D}}}
\def\tE{{\tens{E}}}
\def\tF{{\tens{F}}}
\def\tG{{\tens{G}}}
\def\tH{{\tens{H}}}
\def\tI{{\tens{I}}}
\def\tJ{{\tens{J}}}
\def\tK{{\tens{K}}}
\def\tL{{\tens{L}}}
\def\tM{{\tens{M}}}
\def\tN{{\tens{N}}}
\def\tO{{\tens{O}}}
\def\tP{{\tens{P}}}
\def\tQ{{\tens{Q}}}
\def\tR{{\tens{R}}}
\def\tS{{\tens{S}}}
\def\tT{{\tens{T}}}
\def\tU{{\tens{U}}}
\def\tV{{\tens{V}}}
\def\tW{{\tens{W}}}
\def\tX{{\tens{X}}}
\def\tY{{\tens{Y}}}
\def\tZ{{\tens{Z}}}


\def\gA{{\mathcal{A}}}
\def\gB{{\mathcal{B}}}
\def\gC{{\mathcal{C}}}
\def\gD{{\mathcal{D}}}
\def\gE{{\mathcal{E}}}
\def\gF{{\mathcal{F}}}
\def\gG{{\mathcal{G}}}
\def\gH{{\mathcal{H}}}
\def\gI{{\mathcal{I}}}
\def\gJ{{\mathcal{J}}}
\def\gK{{\mathcal{K}}}
\def\gL{{\mathcal{L}}}
\def\gM{{\mathcal{M}}}
\def\gN{{\mathcal{N}}}
\def\gO{{\mathcal{O}}}
\def\gP{{\mathcal{P}}}
\def\gQ{{\mathcal{Q}}}
\def\gR{{\mathcal{R}}}
\def\gS{{\mathcal{S}}}
\def\gT{{\mathcal{T}}}
\def\gU{{\mathcal{U}}}
\def\gV{{\mathcal{V}}}
\def\gW{{\mathcal{W}}}
\def\gX{{\mathcal{X}}}
\def\gY{{\mathcal{Y}}}
\def\gZ{{\mathcal{Z}}}

\def\sA{{\mathbb{A}}}
\def\sB{{\mathbb{B}}}
\def\sC{{\mathbb{C}}}
\def\sD{{\mathbb{D}}}
\def\sF{{\mathbb{F}}}
\def\sG{{\mathbb{G}}}
\def\sH{{\mathbb{H}}}
\def\sI{{\mathbb{I}}}
\def\sJ{{\mathbb{J}}}
\def\sK{{\mathbb{K}}}
\def\sL{{\mathbb{L}}}
\def\sM{{\mathbb{M}}}
\def\sN{{\mathbb{N}}}
\def\sO{{\mathbb{O}}}
\def\sP{{\mathbb{P}}}
\def\sQ{{\mathbb{Q}}}
\def\sR{{\mathbb{R}}}
\def\sS{{\mathbb{S}}}
\def\sT{{\mathbb{T}}}
\def\sU{{\mathbb{U}}}
\def\sV{{\mathbb{V}}}
\def\sW{{\mathbb{W}}}
\def\sX{{\mathbb{X}}}
\def\sY{{\mathbb{Y}}}
\def\sZ{{\mathbb{Z}}}

\def\emLambda{{\Lambda}}
\def\emA{{A}}
\def\emB{{B}}
\def\emC{{C}}
\def\emD{{D}}
\def\emE{{E}}
\def\emF{{F}}
\def\emG{{G}}
\def\emH{{H}}
\def\emI{{I}}
\def\emJ{{J}}
\def\emK{{K}}
\def\emL{{L}}
\def\emM{{M}}
\def\emN{{N}}
\def\emO{{O}}
\def\emP{{P}}
\def\emQ{{Q}}
\def\emR{{R}}
\def\emS{{S}}
\def\emT{{T}}
\def\emU{{U}}
\def\emV{{V}}
\def\emW{{W}}
\def\emX{{X}}
\def\emY{{Y}}
\def\emZ{{Z}}
\def\emSigma{{\Sigma}}

\newcommand{\etens}[1]{\mathsfit{#1}}
\def\etLambda{{\etens{\Lambda}}}
\def\etA{{\etens{A}}}
\def\etB{{\etens{B}}}
\def\etC{{\etens{C}}}
\def\etD{{\etens{D}}}
\def\etE{{\etens{E}}}
\def\etF{{\etens{F}}}
\def\etG{{\etens{G}}}
\def\etH{{\etens{H}}}
\def\etI{{\etens{I}}}
\def\etJ{{\etens{J}}}
\def\etK{{\etens{K}}}
\def\etL{{\etens{L}}}
\def\etM{{\etens{M}}}
\def\etN{{\etens{N}}}
\def\etO{{\etens{O}}}
\def\etP{{\etens{P}}}
\def\etQ{{\etens{Q}}}
\def\etR{{\etens{R}}}
\def\etS{{\etens{S}}}
\def\etT{{\etens{T}}}
\def\etU{{\etens{U}}}
\def\etV{{\etens{V}}}
\def\etW{{\etens{W}}}
\def\etX{{\etens{X}}}
\def\etY{{\etens{Y}}}
\def\etZ{{\etens{Z}}}

\newcommand{\pdata}{p_{\rm{data}}}
\newcommand{\ptrain}{\hat{p}_{\rm{data}}}
\newcommand{\Ptrain}{\hat{P}_{\rm{data}}}
\newcommand{\pmodel}{p_{\rm{model}}}
\newcommand{\Pmodel}{P_{\rm{model}}}
\newcommand{\ptildemodel}{\tilde{p}_{\rm{model}}}
\newcommand{\pencode}{p_{\rm{encoder}}}
\newcommand{\pdecode}{p_{\rm{decoder}}}
\newcommand{\precons}{p_{\rm{reconstruct}}}

\newcommand{\laplace}{\mathrm{Laplace}} 

\newcommand{\E}{\mathbb{E}}
\newcommand{\Ls}{\mathcal{L}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\emp}{\tilde{p}}
\newcommand{\lr}{\alpha}
\newcommand{\reg}{\lambda}
\newcommand{\rect}{\mathrm{rectifier}}
\newcommand{\softmax}{\mathrm{softmax}}
\newcommand{\sigmoid}{\sigma}
\newcommand{\softplus}{\zeta}
\newcommand{\KL}{D_{\mathrm{KL}}}
\newcommand{\Var}{\mathrm{Var}}
\newcommand{\standarderror}{\mathrm{SE}}
\newcommand{\Cov}{\mathrm{Cov}}
\newcommand{\normlzero}{L^0}
\newcommand{\normlone}{L^1}
\newcommand{\normltwo}{L^2}
\newcommand{\normlp}{L^p}
\newcommand{\normmax}{L^\infty}

\newcommand{\parents}{Pa} 

\DeclareMathOperator*{\argmax}{arg\,max}
\DeclareMathOperator*{\argmin}{arg\,min}

\DeclareMathOperator{\sign}{sign}
\DeclareMathOperator{\Tr}{Tr}
\let\ab\allowbreak
 

\newcommand{\header}[1]{\noindent\textbf{#1.}~}
\newcommand{\headerit}[1]{\noindent\textit{#1.}~}

\newcommand{\uniform}{instance-balanced\xspace}
\newcommand{\Uniform}{Instance-balanced\xspace}

\newcommand{\balanced}{class-balanced\xspace}
\newcommand{\Balanced}{Class-balanced\xspace}

\newcommand{\squareroot}{square-root\xspace}
\newcommand{\Squareroot}{Square-root\xspace}

\newcommand{\shift}{progressively-balanced\xspace}
\newcommand{\Shift}{Progressively-balanced\xspace}



\newcommand{\joint}{Joint\xspace}
\newcommand{\ncm}{NCM\xspace}
\newcommand{\retrain}{cRT\xspace}
\newcommand{\wnorm}{-normalized\xspace}



\newcommand{\LWS}{LWS}
\newcommand{\wscale}{\LWS}
 




\definecolor{citecolor}{RGB}{34, 139, 34}
\usepackage[colorlinks, citecolor=citecolor]{hyperref} \usepackage{url}


\title{Decoupling Representation and Classifier \\ for Long-Tailed Recognition}

\author{Bingyi Kang\textsuperscript{1,2},
Saining Xie\textsuperscript{1},
Marcus Rohrbach\textsuperscript{1},
Zhicheng Yan\textsuperscript{1},
Albert Gordo\textsuperscript{1}, \\ 
\textbf{Jiashi Feng\textsuperscript{2}},
\textbf{Yannis Kalantidis\textsuperscript{1}} \\
\textsuperscript{1}Facebook AI, \textsuperscript{2}National University of Singapore  \\
\texttt{kang@u.nus.edu,\{s9xie,mrf,zyan3,agordo,yannisk\}@fb.com,elefjia@nus.edu.sg}
}



\newcommand{\fix}{\marginpar{FIX}}
\newcommand{\new}{\marginpar{NEW}}


\iclrfinalcopy 

\begin{document}
\maketitle
\begin{abstract}

The long-tail distribution of the visual world poses great challenges for deep learning based classification models on how to handle the class imbalance problem. Existing solutions usually involve class-balancing strategies, \eg by loss re-weighting, data re-sampling, or transfer learning from head- to tail-classes, but most of them adhere to the scheme of jointly learning representations and classifiers. In this work, we decouple the learning procedure into \emph{representation learning} and \emph{classification}, and systematically explore how different balancing strategies affect them for long-tailed recognition. The findings are surprising: (1) data imbalance might not be an issue in learning high-quality representations; (2) with representations learned with the simplest instance-balanced (natural) sampling, it is also possible to achieve strong long-tailed recognition ability by adjusting only the classifier. We conduct extensive experiments and set new state-of-the-art performance on common long-tailed benchmarks like ImageNet-LT, Places-LT and iNaturalist, showing that it is possible to outperform carefully designed losses, sampling strategies, even complex modules with memory, by using a straightforward approach that decouples representation and classification. Our code is available at \url{https://github.com/facebookresearch/classifier-balancing}.

\end{abstract} 

\section{Introduction}
\label{sec:introduction}
Visual recognition research has made rapid advances during the past years, driven primarily by the use of deep convolutional neural networks (CNNs) and large image datasets, most importantly the  ImageNet Challenge~\citep{ILSVRC15}. Such datasets are usually artificially balanced with respect to the number of instances for each object/class in the training set.
Visual phenomena, however, follow a long-tailed distribution that many standard approaches fail to properly model, leading to a significant drop in accuracy. Motivated by this, a number of works have recently emerged that try to study \emph{long-tailed recognition}, \ie, recognition in a setting where the number of instances in each  class highly varies and follows a long-tailed distribution.

When learning with long-tailed data, a common challenge is that instance-rich (or head) classes dominate the training procedure. The learned classification model tends to perform better on these classes, while  {performance}  {is significantly worse} for instance-scarce (or tail) classes. To address this issue {and} to improve performance across all classes, one can re-sample the data or design specific loss functions that better facilitate learning with imbalanced data~\citep{chawla2002smote, cui2019class, cao2019learning}. Another direction is to enhance recognition performance of the tail classes  by transferring knowledge from the head classes~\citep{wang2017learning, Wang_2018_CVPR,Zhong_2019_CVPR,liu2019large}.  Nevertheless, the common belief behind existing approaches is that designing proper sampling strategies, losses, or even more complex models, is useful for learning high-quality representations for long-tailed recognition. 

Most aforementioned approaches thus learn the classifiers used for recognition jointly with the data representations. However, such a joint learning scheme makes it unclear how the long-tailed recognition ability is  {achieved}\textemdash is it from learning a better representation  {or by}  handling the data imbalance  better {via shifting classifier decision boundaries}? To answer this question,  we take one step back and  decouple long-tail recognition into \emph{representation learning} and \emph{classification}. For learning representations, the model is exposed to the training instances and trained through different sampling strategies or losses. For classification, upon the learned representations, the model recognizes  the long-tailed  classes through various classifiers. {We evaluate the performance of various sampling and classifier training strategies for long-tailed recognition under both joint and decoupled learning schemes.}

Specifically, we first train models to learn representations with different sampling strategies, including the standard instance-based sampling, class-balanced sampling and a mixture of them.  Next, we study three different  {basic} approaches to obtain a classifier with balanced decision boundaries, on top of the learned representations. They are  1) re-training the parametric linear classifier in a class-balancing manner (\ie, re-sampling); 2) non-parametric nearest class mean classifier, which classifies the data based on their closest  class-specific  mean representations from the training set; and 3) normalizing the classifier weights, which adjusts the weight magnitude directly to be more balanced,  adding a temperature to modulate the normalization procedure.


We conduct extensive experiments to compare the aforementioned instantiations of the decoupled learning scheme with the conventional scheme that jointly trains the classifier and the representations. We also compare to recent, carefully designed and more complex models, including approaches using memory (\eg, OLTR \citep{liu2019large}) as well as more sophisticated losses~\citep{cui2019class}. From our extensive study across three long-tail datasets, ImageNet-LT, Places-LT and iNaturalist, we make the following intriguing observations:

\begin{itemize}
    \item We find that decoupling representation learning and classification has surprising results that challenge common beliefs for long-tailed recognition:  \uniform sampling learns the best and most generalizable representations.
    \item It is advantageous in long-tailed recognition to re-adjust the decision boundaries specified by the jointly learned classifier during representation learning: 
    {Our experiments show that this can either be achieved by retraining the classifier with class-balanced sampling or by a simple, yet effective, classifier weight normalization which has only a single hyper-parameter controlling the ``temperature'' and which does not require additional training.} 
    \item By applying the decoupled learning scheme to standard networks (\eg, ResNeXt), we achieve significantly higher accuracy than well established state-of-the-art  methods (different sampling strategies, new loss designs and other complex modules) on  multiple long-tailed recognition benchmark datasets, including ImageNet-LT, Places-LT, and iNaturalist. 
\end{itemize}


 

\section{Related Work}
\label{sec:related}

Long-tailed recognition has attracted increasing attention due to the prevalence of imbalanced data in real-world applications~\citep{wang2017learning, zhou2017places, mahajan2018exploring, Zhong_2019_CVPR, gupta2019lvis}. Recent studies have mainly pursued the following three directions:

\header{Data distribution re-balancing} Along this direction, researchers have proposed to re-sample the dataset to achieve a more balanced data distribution. These methods include over-sampling~\citep{chawla2002smote, han2005borderline} for the minority classes (by adding copies of data), under-sampling~\citep{undersampling} for the majority classes (by removing data), and class-balanced sampling~\citep{shen2016relay, mahajan2018exploring} based on the number of samples for each class. 

\header{Class-balanced Losses} Various methods are proposed to assign different losses to different training samples for each class. The loss can vary at class-level for matching a given data distribution and improving the generalization of tail classes~\citep{cui2019class, khan2017cost, cao2019learning, Khan_2019_CVPR, huang2019deep}. A more fine-grained control of the loss can also be achieved at sample level, \eg with Focal loss~\citep{lin2017focal}, Meta-Weight-Net~\citep{shu2019meta}, re-weighted training~\citep{ren18l2rw}, or based on Bayesian uncertainty \citep{Khan_2019_CVPR}. Recently, \citet{hayat2019max} proposed to balance the classification regions of head and tail classes using an affinity measure to enforce cluster centers of classes to be uniformly spaced and equidistant. 

\header{Transfer learning from head- to tail classes} Transfer-learning based methods address the issue of imbalanced training data by transferring features learned from head classes with abundant training instances to under-represented tail classes. Recent work includes transferring the intra-class variance~\citep{yin2019feature} and transferring semantic deep features~\citep{liu2019large}. However it is usually a non-trivial task to design specific modules (\eg external memory) for feature transfer.

A benchmark for low-shot recognition was proposed by \citet{hariharan2017low} and consists of a representation learning phase without access to the low-shot classes and a subsequent low-shot learning phase. In contrast, the setup for long-tail recognition assumes access to both head and tail classes and a more continuous decrease in in class labels. Recently,~\citet{liu2019large} and~\citet{cao2019learning} adopt re-balancing schedules that learn representation and classifier jointly within a two-stage training scheme. OLTR~\citep{liu2019large} uses \uniform sampling to first learn representations that are fine-tuned in a second stage with \balanced sampling together with a memory module. LDAM \citep{cao2019learning} introduces a label-distribution-aware margin loss that expands the decision boundaries of few-shot classes. In Section~\ref{sec:experiments} we exhaustively compare to OLTR and LDAM, since they report state-of-the-art results for the ImageNet-LT, Places-LT and iNaturalist datasets. In our work, we argue for \emph{decoupling} representation and classification. We demonstrate that in a long-tailed scenario, this separation allows straightforward approaches to achieve high recognition performance, without the need for designing sampling strategies, balance-aware losses or adding memory modules.


 

\section{Learning representations for long-tailed recognition}
\label{sec:representation}


For long-tailed recognition, the training set  follows a long-tailed distribution over the classes. As we have less data about infrequent classes during training, the models trained using imbalanced datasets tend to exhibit under-fitting on the few-shot classes. {But in practice  we are interested in obtaining the model capable of  recognizing all classes well. } Various re-sampling strategies~\citep{chawla2002smote, shen2016relay, cao2019learning}, loss reweighting and margin  regularization over few-shot classes are  thus  proposed.  However, it remains unclear how they achieve     performance  improvement, if any, for long-tailed recognition.  Here we  systematically investigate their effectiveness  by disentangling representation learning from classifier learning, in order  to   identify what indeed matters for long-tailed recognition.


\header{Notation} We define the notation used through the paper. Let  be a training set, where  is the label for data point . Let  denote the number of training sample for class , and let  be the total number of training samples. Without loss of generality, we assume that the classes are sorted by cardinality in decreasing order, \ie, if , then . Additionally, since we are in a long-tail setting, . Finally, we denote with  the representation for , where  is implemented by a deep CNN model with parameter  . The final class prediction  is given by a classifier function , such that . For the common case,  is a linear classifier, \ie, , where  denotes the classifier weight matrix, and  is the bias. We present other instantiations of  in Section~\ref{sec:classifiers}.

\header{Sampling strategies}
In this section we present a number of sampling strategies that aim at re-balancing the data distribution for representation and classifier learning. 
For most sampling strategies presented below, the probability  of sampling a data point from class  is given by:


where  and  is the number of training classes. Different sampling strategies arise for different values of  and below we present strategies that correspond to , , and . 

\headerit{\Uniform sampling}
This is the most common way of sampling data, where each training example has equal probability of being selected. For \uniform sampling, the probability  is given by ~\Eqref{eq:sampling} with , \ie, a data point from class  will be sampled proportionally to the cardinality  of the class in the training set. 

\headerit{\Balanced sampling}
For imbalanced datasets, \uniform sampling   has been shown to be sub-optimal~\citep{huang2016learning,wang2017learning} as the model under-fits for few-shot classes leading to lower accuracy, especially for balanced test sets. \Balanced sampling has been used to alleviate this discrepancy, as, in this case, each \emph{class} has an equal probability of being selected. The probability  is given by Eq. (\ref{eq:sampling}) with , \ie, . One can see this as a two-stage sampling strategy, where first a class is selected uniformly from the set of classes, and then an instance from that class is subsequently uniformly sampled. 

\headerit{\Squareroot sampling}
A number of variants of the previous sampling strategies have been explored. A commonly used variant is \squareroot sampling~\citep{mikolov2013distributed, mahajan2018exploring}, where  is set to  in Eq. (\ref{eq:sampling}) above.


\headerit{\Shift sampling}
Recent approaches~\citep{cui2018large,cao2019learning} utilized mixed ways of sampling, \ie, combinations of the sampling strategies presented above. In practice this involves first using \uniform sampling for a number of epochs, and then \balanced sampling for the last epochs. These mixed sampling approaches require setting the number of epochs before switching the sampling strategy as an explicit hyper-parameter. Here, we experiment with a softer version,  \shift sampling,  that   progressively ``interpolates'' between \uniform  and \balanced sampling as learning progresses. Its sampling probability/weight  for class  is now a function of the epoch ,

where   is the total number of epochs. Figure~\ref{fig:shifting} in appendix depicts the sampling probabilities. 

\header{Loss re-weighting strategies}
Loss re-weighting functions for imbalanced data have been extensively studied, and it is beyond the scope of this paper to examine all related approaches. What is more, we found that some of the most recent approaches reporting high performance were hard to train and reproduce and in many cases require extensive, dataset-specific hyper-parameter tuning. In Section~\ref{sec:reweighting} of the Appendix we summarize the latest, best performing methods from this area. {In Section~\ref{sec:experiments} we show that, without bells and whistles, baseline methods equipped with a properly balanced classifier can perform equally well, if not better, than the latest loss re-weighting approaches.}
 


\section{classification for long-tailed recognition}
\label{sec:classifiers}


When learning  a classification model on balanced datasets, the classifier weights  and   are usually trained jointly with   the model parameters  for extracting the representation  by minimizing the cross-entropy loss between the ground truth  and prediction . This is also a typical baseline for long-tailed recognition. Though various approaches of  re-sampling, re-weighting and transferring representations from head to tail classes  have been proposed, the general scheme remains the same: classifiers are either learned jointly with the representations either end-to-end, or via a two-stage approach where the classifier and the representation are jointly fine-tuned with variants of \balanced sampling as a second stage~\citep{cui2018large,cao2019learning}. 

In this section, we consider decoupling the representation from the classification in long-tailed recognition. We present ways of learning classifiers aiming at rectifying the decision boundaries on head- and tail-classes  via fine-tuning with different sampling strategies or other non-parametric ways such as nearest class mean classifiers. We also consider an approach to rebalance the classifier weights that exhibits a high long-tailed recognition accuracy without any additional retraining.

\header{Classifier Re-training (\retrain)}
A straightforward approach is to re-train the classifier with \balanced sampling. That is, keeping the representations fixed, we randomly re-initialize and optimize the classifier weights  and  for a small number of epochs using \balanced sampling. A similar methodology was also recently used in~\citep{zhang2019study} for action recognition on a long-tail video dataset.

\header{Nearest Class Mean classifier (\ncm)}
Another commonly used approach is to first compute the mean feature representation for each class on the training set and then perform nearest neighbor search either using cosine similarity or the Euclidean distance computed on  normalized mean features ~\citep{snell2017prototypical, guerriero2018deep, rebuffi2017icarl}. Despite its simplicity, this is a strong baseline (\cf the experimental evaluation in Section \ref{sec:experiments}); the cosine similarity alleviates the weight imbalance problem via its inherent normalization (see also Figure~\ref{fig:decisionboundaries}).


\header{-normalized classifier (\wnorm)}
We investigate an efficient approach to re-balance the decision boundaries of classifiers, inspired by an empirical observation: after joint training with \uniform sampling, the norms of the weights  are correlated with the cardinality of the classes , while, after fine-tuning the classifiers using \balanced sampling, the norms of the classifier weights tend to be more similar (\cf Figure~\ref{fig:wnorm}-left). 


Inspired by the above observations, we consider   rectifying imbalance of decision boundaries by adjusting the classifier weight norms directly through the following -normalization procedure. Formally, let , where  are the classifier weights corresponding to class . We scale the weights of  to get  by:

where  is a hyper-parameter controlling the ``temperature'' of the normalization, and  denotes the  norm. When , it reduces to standard -normalization. When , no scaling is imposed. We empirically choose  such that the weights can be rectified smoothly. After -normalization, the classification logits are given by . Note that we discard the bias term  here due to its negligible effect on the logits and final predictions. 


\header{Learnable weight scaling (\LWS)}
Another way of interpreting -normalization would be to think of it as a re-scaling of the magnitude for each classifier  keeping the direction unchanged. This could be written as

Although for \wnorm in general  is chosen through cross-validation, we further investigate learning  on the training set, using \balanced sampling (like \retrain). In this case, we keep both the representations and classifier weights fixed and only learn the scaling factors . We denote this variant as \emph{Learnable Weight Scaling} (LWS) in our experiments. 

\section{Experiments}
\label{sec:experiments}


\subsection{Experimental setup}


\header{Datasets} We perform extensive experiments on three large-scale long-tailed datasets, including Places-LT~\citep{liu2019large}, ImageNet-LT~\citep{liu2019large}, and iNaturalist 2018 ~\citep{inat18}. Places-LT and ImageNet-LT are artificially truncated from their balanced versions (Places-2~\citep{zhou2017places} and ImageNet-2012~\citep{deng2009imagenet}) so that the labels of the training set follow a long-tailed distribution. Places-LT contains images from 365 categories and the number of images per class ranges from 4980 to 5. ImageNet-LT has 1000 classes and the number of images per class ranges from  1280 to 5 images. iNaturalist 2018 is a real-world, naturally long-tailed dataset, consisting of samples from 8,142 species. 

\header{Evaluation Protocol} After training on the long-tailed datasets, we evaluate the models on the corresponding balanced test/validation datasets and report the commonly used top-1 accuracy over all classes, denoted  as \emph{All}. 
To better examine performance variations across classes with different number of examples seen during training, we follow~\citet{liu2019large} and further report accuracy on three splits of the set of classes: \emph{Many-shot} (more than 100 images), \emph{Medium-shot} (20100 images) and \emph{Few-shot} (less than 20 images). Accuracy is reported as a percentage.


\header{Implementation} We use the PyTorch~\citep{paszke2017automatic} framework for all experiments\footnote{We will open-source our codebase and models.}. For Places-LT, we choose ResNet-152 as the backbone network and pretrain it on the full ImageNet-2012 dataset, following~\citet{liu2019large}. On ImageNet-LT, we report results with ResNet-\{10,50,101,152\}~\citep{he2016deep} and ResNeXt-\{50,101,152\}(32x4d)~\citep{xie2017aggregated} but mainly use ResNeXt-50 for analysis. Similarly, ResNet-\{50,101,152\} is also used for iNaturalist 2018. For all experiements, if not specified, we use SGD optimizer with momentum 0.9, batch size 512, cosine learning rate schedule~\citep{loshchilov2016sgdr} gradually decaying from 0.2 to 0 
and image resolution . 
In the first representation learning stage, the backbone network is usually trained for 90 epochs. In the second stage, \ie, for retraining a classifier (\retrain), we restart the learning rate and train it for 10 epochs while keeping the backbone network fixed.  

\subsection{Sampling strategies and decoupled learning}



\begin{figure}[t]
    \centering
    \includegraphics[width=\linewidth]{figs/plot_sampling.pdf}
    \caption{The performance of different classifiers for each split on ImageNet-LT with ResNeXt-50. Colored markers denote the sampling strategies used to learn the representations.}
    \label{fig:classifiers_vs_samplings}
\end{figure}



In Figure~\ref{fig:classifiers_vs_samplings}, we compare different sampling strategies for the conventional joint training scheme to a number of variations of the decoupled learning scheme on the ImageNet-LT dataset. For the joint training scheme (Joint), the linear classifier and backbone for representation learning are jointly trained for 90 epochs using a standard cross-entropy loss and different sampling strategies, \ie, \Uniform, \Balanced, \Squareroot, and \Shift. For the decoupled learning schemes, we present results when learning the classifier in all the ways presented in Section~\ref{sec:classifiers}, \ie, re-initialize and re-train (cRT), Nearest Class Mean (NCM) as well as -normalized classifier. 
Below, we discuss a number of key observations.


\emph{Sampling matters when training jointly.} From the Joint results in Figure~\ref{fig:classifiers_vs_samplings} across sampling methods and splits, we see consistent gains in performance when using better sampling strategies (see also Table~\ref{tab:sampling}). The trends are consistent for the overall performance as well as the medium- and few-shot classes, with \shift sampling giving the best results. As expected, \uniform sampling gives the highest performance for the many-shot classes. This is well expected since the resulted model is highly skewed to the  many-shot classes. Our results for different sampling strategies on joint training validate related works that try to design better data sampling methods.


\begin{wraptable}{r}{0.5\linewidth}
\small
\caption{Retraining/finetuning different parts of a ResNeXt-50 model on ImageNet-LT. B: backbone; C: classifier; LB: last block.}
\label{tab:retraining}
\begin{center}
\begin{tabular}{lcccc}
\toprule
Re-train & Many & Medium & Few & All \\
\midrule
B+C & 55.4 & 45.3 & 24.5 & 46.3 \\
B+C(0.1) & \textbf{61.9} & 45.6 & 22.8 & 48.8 \\
LB+C & 61.4 & 45.8 & 24.5 & 48.9 \\
C & 61.5 & \textbf{46.2} &	\textbf{27.0} &	\textbf{49.5} \\
\bottomrule
\end{tabular}
\end{center}
\end{wraptable}


\emph{Joint or decoupled learning?} For most cases presented in Figure~\ref{fig:classifiers_vs_samplings}, performance using decoupled methods is significantly better in terms of overall performance, as well as all splits apart from the many-shot case. Even the non-parametric \ncm approach is highly competitive in most cases, while \retrain and \wnorm outperform the jointly trained baseline by a large margin (\ie 5\% higher than the jointly learned classifier), and even achieving 2\% higher overall accuracy than the best jointly trained setup with \shift sampling. The gains are even higher for medium- and few-shot classes at 5\% and 11\%, respectively.

To further justify our claim that it is beneficial to decouple representation and classifier, we experiment with fine-tuning the backbone network (ResNeXt-50) jointly with the linear classifier. In Table~\ref{tab:retraining}, we present results when fine-tuning the whole network with standard or smaller (0.1) learning rate, fine-tuning only the last block in the backbone, or only retraining the linear classifier and fixing the representation. Fine-tuning the whole network yields the worst performance (46.3\% and 48.8\%), while keeping the representation frozen performs best (49.5\%). The trend is even more evident for the medium/few-shot classes. This result suggests that decoupling representation and classifier is desirable for long-tailed recognition.
 

\emph{\Uniform sampling gives the most generalizable representations.} Among all decoupled methods, when it comes to overall performance  and all splits apart from the many-shot classes, we see that \Uniform sampling gives the best results. This is particularly interesting, as it implies that \emph{data imbalance might not be an issue learning high-quality representations}. 


\subsection{How to balance your classifier?} 


Among the   ways of balancing the classifier explored in Figure~\ref{fig:classifiers_vs_samplings}, the non-parametric \ncm seems to perform slightly worse than \retrain and -normalization. Those two methods are consistently better in most cases apart from the few-shot case, where \ncm performs comparably. The biggest drop for the \ncm approach comes from the many-shot case. It is yet still somehow surprising that both the \ncm and \wnorm cases give competitive performance even though they are free of additional training and involve no additional sampling procedure. 
As discussed in Section~\ref{sec:classifiers}, their strong performance may stem from their ability to adaptively adjust the decision boundaries for many-, medium- and few-shot classes (see also Figure~\ref{fig:decisionboundaries}). 

In Figure~\ref{fig:wnorm}~(left) we empirically show the  norms of the weight vectors for all classifiers, as well as  the training data distribution sorted in a descending manner with respect to the number of instances in the training set. We can observe that the weight norm of the joint classifier (blue line) is positively correlated with the number of training instances of the corresponding class. More-shot classes tend to learn a classifier with larger magnitudes. As illustrated in Figure~\ref{fig:decisionboundaries}, this yields a wider classification boundary in feature space, allowing the classifier to have much higher accuracy on data-rich classes, but hurting data-scarce classes. -normalized classifiers (gold line) alleviate this issue to some extent by providing more balanced classifier weight magnitudes. For retraining (green line), the weights are almost balanced except that few-shot classes have slightly larger classifier weight norms. Note that the \ncm approach would give a horizontal line in the figure as the mean vectors are -normalized before nearest neighbor search. 

In Figure~\ref{fig:wnorm}~(right), we further investigate how the performance changes as the temperature parameter  for the \wnorm classifier varies. The figure shows that as  increases from 0, many-shot accuracy decays dramatically while few-shot accuracy increases dramatically.

\begin{figure}[t]
    \centering
    \includegraphics[height=0.35\linewidth]{figs/wnorm.pdf}
    \caption{Left: Classifier weight norms for ImageNet-LT validation set when classes are sorted by descending values of . Blue line: classifier weights learned with \uniform sampling. Green line: weights after fine-tuning with \balanced sampling. Gold line: after  normalization. Brown line: weights by learnable weight scaling. Right: Accuracy with different values of the   normalization parameter . }
    \label{fig:wnorm}
\end{figure}



\subsection{Comparison with the state-of-the-art on long-tailed datasets}


\begin{table}[ht]
\small
\caption{Long-tail recognition accuracy on ImageNet-LT for different backbone architectures.  \dag~denotes results directly copied from~\citet{liu2019large}. * denotes results reproduced with the authors' code. ** denotes OLTR with our representation learning stage. }
\label{tab:imagenet_main}
\begin{center}
\begin{tabular}{lc@{\ \ }c@{\ \ }c}
\toprule
 Method & ResNet-10 & ResNeXt-50 & ResNeXt-152 \\\midrule
 FSLwF\dag~\citep{gidaris2018dynamic} & 28.4 & - & - \\
 Focal Loss\dag~\citep{lin2017focal} & 30.5 & - & - \\
 Range Loss\dag~\citep{zhang2017range} & 30.7 & - & - \\
 Lifted Loss\dag ~\citep{oh2016deep} & 30.8 & - & - \\
 OLTR\dag~\citep{liu2019large} & 35.6 & - & - \\
 OLTR* & 34.1 & 37.7 & 24.8\\
 OLTR** & 37.3 & 46.3 & 50.3\\
\midrule
 \joint & 34.8 & 44.4 & 47.8 \\
 \ncm & 35.5 & 47.3 & 51.3\\
 \retrain & \textbf{41.8} & \textbf{49.5} & 52.4\\
 \wnorm & 40.6 & \textbf{49.4} & \textbf{52.8}\\
 \wscale & \textbf{41.4} & \textbf{49.9} & \textbf{53.3} \\
\bottomrule
\end{tabular}
\end{center}
\end{table}

In this section, we compare the performance of the decoupled schemes to other recent works that report state-of-the-art results on on three common long-tailed benchmarks: ImageNet-LT, iNaturalist and Places-LT. Results are presented in Tables~\ref{tab:imagenet_main},~\ref{tab:inat_main} and~\ref{tab:place_main}, respectively. 

\header{ImageNet-LT} Table~\ref{tab:imagenet_main} presents results for ImageNet-LT. Although related works present results with ResNet-10~\citep{liu2019large}, we found that using bigger backbone architectures increases performance significantly on this dataset. We therefore present results for three backbones: ResNet-10, ResNeXt-50 and the larger ResNeXt-152. For the state-of-the-art OLTR method of~\citet{liu2019large} we adopt results  reported in the paper, as well as results we reproduced using the authors' open-sourced codebase\footnote{\url{https://github.com/zhmiao/OpenLongTailRecognition-OLTR}} with two training settings: the one suggested in the codebase and the one using our training setting for the   representation learning. From the table we see that the non-parametric decoupled \ncm method performs on par with the state-of-the-art for most architectures. We also see that when re-balancing the classifier properly, either by re-training or -normalizing, we get results that, without bells and whistles outperform the current state-of-the-art for all backbone architectures. We further experimented with adding the memory mechanism of~\citet{liu2019large} on top of our decoupled \retrain setup, but the memory mechanism didn't seem to further boost performance (see Appendix~\ref{sec:modelsize}).


\header{iNaturalist 2018} We further evaluate our decoupled methods on the iNaturalist 2018 dataset. We present results after 90 and 200 epochs, as we found that 90 epochs were not enough for the representation learning stage to converge; this is different from~\citet{cao2019learning} where they train for 90 epochs. From Table~\ref{tab:inat_main} we see that results are consistent with the ImageNet-LT case: re-balancing the classifier gives results that outperform CB-Focal~\citep{cui2019class}. Our performance, when training only for 90 epochs,  is slightly lower than the very recently proposed LDAM+DRW~\citep{cao2019learning}. However, with 200 training epochs and  classifier normalization, we achieve   a new state-of-the-art of 69.3 with ResNet-50 that can be further improved to 72.5 for ResNet-152. It is further worth noting that we cannot     reproduce the numbers reported in~\citet{cao2019learning}. We find that the -normalized classifier performs best and gives a new state-of-the-art for the dataset, while surprisingly achieving similar accuracy (69\%/72\% for ResNet-50/ResNet-152) \emph{across all many-, medium- and few-shot class splits}, a highly desired result for long-tailed recognition. Complete results, \ie, for all splits and more backbone architectures can be found in Table~\ref{tab:inat_extra} of the Appendix.

\header{Places-LT} For Places-LT we follow the protocol of~\citet{liu2019large} and start from a ResNet-152 backbone pre-trained on the \emph{full} ImageNet dataset. Similar to~\citet{liu2019large}, we then fine-tune the backbone with \Uniform sampling for representation learning. Classification follows with fixed representations for our decoupled methods. As we see in Table~\ref{tab:place_main}, all three decoupled methods outperform the state-of-the-art approaches, including Lifted Loss~\citep{oh2016deep}, Focal Loss~\citep{lin2017focal}, Range Loss~\citep{zhang2017range}, FSLwF~\citep{gidaris2018dynamic} and OLTR~\citep{liu2019large}. Once again, the -normalized classifier give the top performance, with impressive gains for the medium- and few-shot classes.


\begin{table}

\footnotesize
\begin{minipage}[t]{0.47\textwidth}
\centering
\caption{Overall accuracy on iNaturalist 2018. Rows with \dag~denote results directly copied from~\citet{cao2019learning}. We present results when training for 90/200 epochs.}
\label{tab:inat_main}
\vspace{6pt}
\begin{tabular}{lcc}
\toprule
Method & ResNet-50 & ResNet-152 \\
\midrule
CB-Focal\dag  & 61.1 & -\\
LDAM\dag  & 64.6 & -\\
LDAM+DRW\dag & 68.0 & -\\
\midrule \joint &  61.7/65.8 & 65.0/69.0\\
\ncm &  58.2/63.1 & 61.9/67.3\\
\retrain &  65.2/67.6 & 68.5/71.2\\
\wnorm &  65.6/\textbf{69.3} & 68.8/\textbf{72.5}  \\
\wscale & 65.9/\textbf{69.5} & 69.1/{72.1} \\
\bottomrule
\end{tabular}
\end{minipage}
\hfill
\begin{minipage}[t]{0.47\textwidth}
\centering
\caption{Results on Places-LT, starting from an ImageNet pre-trained ResNet152. \dag~denotes results directly copied from~\citet{liu2019large}.}
\vspace{3pt}
\label{tab:place_main}
\begin{tabular}{lcccc}
\toprule
Method & Many & Medium & Few & All \\
\midrule
Lifted Loss\dag & 41.1 & 35.4 & 24.0 & 35.2 \\
Focal Loss\dag & 41.1 & 34.8 & 22.4 & 34.6 \\
Range Loss\dag & 41.1 & 35.4 & 23.2 & 35.1 \\
FSLwF\dag & 43.9 & 29.9 & 29.5 & 34.9 \\
OLTR\dag & 44.7 & 37.0 & 25.3 & 35.9 \\
\midrule
\joint & \textbf{45.7} & 27.3 & 8.2 & 30.2 \\
\ncm & 40.4 & 37.1 & 27.3 & 36.4 \\
\retrain & 42.0 & 37.6 & 24.9 & 36.7 \\
\wnorm & 37.8 & \textbf{40.7} & \textbf{31.8} & \textbf{37.9} \\
\wscale & 40.6 &	39.1 &	28.6 & 37.6 \\
\bottomrule
\end{tabular}
\end{minipage}
\end{table}

 

\section{Conclusions}
\label{sec:conclusions}


In this work, we explore a number of learning schemes for long-tailed recognition and compare jointly learning the representation and classifier to a number of straightforward decoupled methods. Through an extensive study we find that although sampling strategies matter when jointly learning representation and classifiers, \uniform sampling gives more generalizable representations that can achieve state-of-the-art performance after properly re-balancing the classifiers and without need of carefully designed losses or memory units. We set new state-of-the-art performance for three long-tailed benchmarks and believe that our findings not only contribute to a deeper understanding of the long-tailed recognition task, but can offer inspiration for future work.  





\bibliography{iclr2020_conference}
\bibliographystyle{iclr2020_conference}

\newpage
\appendix



\section{Loss Re-weighting strategies}
\label{sec:reweighting}


Here, we summarize some of the best performing loss re-weighting methods that we compare against in Section~\ref{sec:experiments}. Introduced in the context of object detection where imbalance exists in most common benchmarks, the Focal loss~\citep{lin2017focal} aims to balance the sample-wise classification loss for model training by down-weighing easy samples. To this end, given a probability prediction  for the sample  over its true category , it adds a re-weighting factor   with  into the standard cross-entropy loss : 

For easy samples (which may dominate the training samples) with large predicted probability  for their true categories, their corresponding cross entropy loss will be down weighted. Recently, ~\citet{cui2019class} presented a class balanced variant of the focal loss and applied it to long-tailed recognition. They modulated the Focal loss for a sample from class  with a balance-aware coefficient equal to . Very recently, \citet{cao2019learning} proposed a label-distribution-aware margin (LDAM) loss that encourages few-shot classes to have larger margins, and their final loss is formulated as a cross-entropy loss with enforced margins:

where  are the logits and  is a class-aware margin, inversely proportional to .


\section{Further Analysis and Results}



\subsection{Sampling Strategies}


In Figure~\ref{fig:shifting} we visualize the sampling weights for the four sampling strategies we explore. In Table~\ref{tab:sampling} we present accuracy on ImageNet-LT for ``all'' classes when training the representation and classifier jointly. It is clear that better sampling strategies help when jointly training the classifier with the representations/backbone architecture. 


\begin{figure}[h]
    \centering
    \includegraphics[width=\linewidth]{figs/sampling_distribution_max.pdf}
    \caption{Sampling weights  for ImageNet-LT. Classes are ordered with decreasing  on the x-axis. Left: \uniform, \balanced and \squareroot sampling. Right: \Shift sampling; as epochs progress, sampling goes from \uniform to \balanced sampling.}
    \label{fig:shifting}
\end{figure}



\begin{table}[h]
\small
\caption{Accuracy on ImageNet-LT when jointly learning the representation and classifier using different sampling strategies. Results in this Table are a subset of the results presented in Figure~\ref{fig:classifiers_vs_samplings}.}
\label{tab:sampling}
\begin{center}
\begin{tabular}{lcccc}
\toprule
Sampling & Many & Medium & Few & All \\
\midrule
\Uniform & \textbf{65.9} & 37.5 & 7.7 & 44.4 \\
 \Balanced &  61.8 & 40.1 & 15.5 & 45.1 \\
 \Squareroot & 64.3 & 41.2 & 17.0 & 46.8 \\
 \Shift & 61.9 & \textbf{43.2} & \textbf{19.4} & \textbf{47.2} \\
\bottomrule
\end{tabular}
\end{center}
\end{table}





\subsection{Classifier decision boundaries for \texorpdfstring{\wnorm}{tau-normalized} and \ncm}
In Figure~\ref{fig:decisionboundaries} we illustrate the classifier decision boundaries before/after normalization with Eq.(\ref{eq:wnorm}), as well as when using cosine distance. Balancing the norms also leads to more balanced decision boundaries, allowing the classifiers for few-shot classes to occupy more space. 

\begin{figure}[h]
    \centering
    \includegraphics[width=1\linewidth,height = 0.2\linewidth]{figs/cones.pdf}
    \caption{ Illustrations on different classifiers and their corresponding decision boundaries, where  and  denote the classification weight for class  and  respectively,  is the classification cone belongs to class  in the feature space,  is the feature mean for class . From left to right: \wnorm classifiers  with : the classifier with larger weights have wider decision boundaries; \wnorm classifiers  with :  the decision boundaries are more balanced for different classes; NCM with cosine-similarity whose decision boundary is independent of the classifier weights; NCM with Euclidean-similarity whose decision boundaries partition the feature space into Voronoi cells.}
    \label{fig:decisionboundaries}
    \vspace{-4mm}
\end{figure}



\subsection{Classifier learning comparison table} 


Table~\ref{tab:proscons} presents some comparative analysis for the four different ways of learning the classifier that are presented in Section~\ref{sec:classifiers}.

\begin{table}
    \centering
    {\resizebox{0.6\textwidth}{!}{\begin{tabular}{l|ccccc}
    \toprule
         & \joint & \ncm & \retrain & \wnorm & \wscale \\ 
         \midrule
        Decoupled from repr.& \xmark & \cmark & \cmark & \cmark  & \cmark \\
        No extra training & \cmark & \cmark & \xmark & \cmark & \xmark \\
        No extra hyper-parameters & \cmark & \cmark & \cmark & \xmark & \cmark\ \\
        Performance &  &  &  &  &  \\
        \bottomrule
    \end{tabular}
    }}
    \caption{Comparative analysis for different ways of learning the classifier for long-tail recognition.}
    \label{tab:proscons}
\end{table}

\subsection{Varying the backbone architecture size}
\label{sec:modelsize}


\header{ImageNet-LT} In Figure~\ref{fig:modelsize} we compare the performance of different backbone architecture sizes (model capacity) under different methods, including of different methods 1) OLTR~\citep{liu2019large} using the authors' codebase settings (OLTR*); 2) OLTR using the representation learning stage detailed in Section~\ref{sec:experiments} (OLTR**); 3) \retrain with the memory module from~\citet{liu2019large} while training the classifier; 4) \retrain; and 5) \wnorm. we see that a) the authors' implementation of OLTR over-fits for larger models, b) overfitting can be alleviated with our training setup (different training and LR schedules) c) adding the memory unit when re-training the classifier doesn't increase performance. Additional results of Table~\ref{tab:imagenet_main} are given in Table~\ref{tab:imnet_extra}. 

\begin{figure}[h]
    \vspace{-1cm}
    \centering
    \includegraphics[width=0.8\textwidth]{figs/models_chart+.pdf}
    \caption{Accuracy on ImageNet-LT for different backbones}
    \label{fig:modelsize}
    \vspace{-0.5cm}
\end{figure}

\begin{table}[h]
\small
\caption{Comprehensive results on ImageNet-LT with different backbone networks  \{ResNet, ResNeXt\}-\{50, 101,152\}}
\label{tab:imnet_extra}
\begin{center}
\begin{tabular}{ll|cccc|cccc}
\toprule
\multirow{2}{*}{Backbone} & \multirow{2}{*}{Method} & \multicolumn{4}{c}{ResNet} & \multicolumn{4}{|c}{ResNeXt} \\
 &  & Many & Medium & Few & All & Many & Medium & Few & All\\
\midrule
\multirow{4}{*}{*-50}
&\joint & 64.0 & 33.8 & 5.8 & 41.6 & 65.9 & 37.5 & 7.7 & 44.4 \\
& \ncm & 53.1 & 42.3 & 26.5 & 44.3 & 56.6 & 45.3 & 28.1 & 47.3\\
& \retrain & 58.8 & 44.0 & 26.1 & 47.3 & 61.8 & 46.2 & 27.4 & 49.6\\
& \wnorm & 56.6 & 44.2 & 27.4 & 46.7 & 59.1 & 46.9 & 30.7 & 49.4\\
& \wscale & 57.1 & 45.2 & 29.3 & 47.7 & 60.2 & 47.2 & 30.3 & 49.9 \\
\midrule
\multirow{4}{*}{*-101}
& \joint & 66.6 & 36.8 & 7.1 & 44.2 & 66.2 & 37.8 & 8.6 & 44.8 \\
& \ncm & 56.8 & 45.1 & 28.8 & 47.4 & 57.2 & 45.5 & 29.5 & 47.8 \\
& \retrain & 61.6 & 46.5 & 28.0 & 49.8 & 61.7 & 46.0 & 27.0 & 49.4 \\
& \wnorm & 59.4 & 47.0 & 30.6 & 49.6 & 59.1 & 47.0 & 31.7 & 49.6  \\
& \wscale & 60.1 & 47.6 & 31.2 & 50.2 & 60.5 & 47.2 & 31.2 & 50.1 \\
\midrule
\multirow{4}{*}{*-152}
& \joint & 66.9 & 27.7 & 7.7 & 44.9 & 69.1 & 41.4 & 10.4 & 47.8 \\
& \ncm & 56.9 & 45.6 & 29.9 & 47.8 & 60.3 & 49.0 & 33.6 & 51.3 \\
& \retrain & 61.8 & 46.8 & 28.4 & 50.1 & 64.7 & 49.1 & 29.4 & 52.4 \\
& \wnorm & 59.6 & 47.5 & 32.2 & 50.1 & 62.2 & 50.1 & 35.8 & 52.8 \\
& \wscale & 60.6 & 47.8 & 31.4 & 50.5 & 63.5 & 50.4 & 34.2 & 53.3 \\
\bottomrule
\end{tabular}
\end{center}
\vspace{-0.5cm}
\end{table}


\begin{table}[h]
\small
\caption{Comprehensive results on iNaturalist 2018 with different backbone networks (ResNet-50, ResNet-101 \& ResNet-152) and different training epochs (90 \& 200)}
\label{tab:inat_extra}
\begin{center}
\begin{tabular}{ll|cccc|cccc}
\toprule
\multirow{2}{*}{Backbone} & \multirow{2}{*}{Method} & \multicolumn{4}{c}{90 Epochs} & \multicolumn{4}{|c}{200 Epochs} \\
 &  & Many & Medium & Few & All & Many & Medium & Few & All\\
\midrule
\multirow{4}{*}{ResNet-50}
&\joint & 72.2 & 63.0 & 57.2 & 61.7 & 75.7 & 66.9 & 61.7 & 65.8 \\
& \ncm & 55.5 & 57.9 & 59.3 & 58.2 & 61.0 & 63.5 & 63.3 & 63.1\\
& \retrain & 69.0 & 66.0 & 63.2 & 65.2 & 73.2 & 68.8 & 66.1 & 68.2\\
& \wnorm & 65.6 & 65.3 & 65.9 & 65.6 & 71.1 & 68.9 & 69.3 & 69.3\\
& \wscale & 65.0 & 66.3 & 65.5 & 65.9 & 71.0 & 69.8 & 68.8 & 69.5 \\
\midrule
\multirow{4}{*}{ResNet-101}
& \joint & 75.9 & 66.0 & 59.9 & 64.6 & 75.5 & 68.9 & 63.2 & 67.3 \\
& \ncm & 58.6 & 61.9 & 61.8 & 61.5 & 63.7 & 65.7 & 65.3 & 65.3\\
& \retrain & 73.0 & 68.9 & 65.7 & 68.1 & 73.9 & 70.4 & 67.8 & 69.7 \\
& \wnorm & 69.7 & 68.3 & 68.3 & 68.5 & 68.6 & 70.6 & 72.2 & 71.0  \\
& \wscale & 69.6 & 69.1 & 67.9 & 68.7 & 71.5 & 71.3 & 69.7 & 70.7 \\
\midrule
\multirow{4}{*}{ResNet-152}
& \joint & 75.2 & 66.3 & 60.7 & 65.0 & 78.2 & 70.6 & 64.7 & 69.0\\
& \ncm & 59.3 & 61.9 & 62.6 & 61.9 & 66.3 & 67.5 & 67.2 & 67.3 \\
& \retrain & 73.6 & 69.3 & 66.3 & 68.5 & 75.9 & 71.9 & 69.1 & 71.2\\
& \wnorm & 69.8 & 68.5 & 68.9 & 68.8 & 74.3 & 72.3 & 72.2 & 72.5 \\
& \wscale & 69.4 & 69.5 & 68.6 & 69.1 & 74.3 & 72.4 & 71.2 & 72.1 \\
\bottomrule
\end{tabular}
\end{center}

\end{table}

\header{iNaturalist 2018} In Table~\ref{tab:inat_extra} we present an extended version of the results of Table~\ref{tab:inat_main}. We show results per split as well as results with a ResNet-101 backbone. As we see from the table and mentioned in Section~\ref{sec:experiments}, training only for 90 epochs gives sub-optimal representations, while both large models and longer training result in much higher accuracy on this challenging, large-scale task. What is even more interesting, we see performance across the many-, medium- and few-shot splits being approximately equal after re-balancing the classifier, with only a small advantage for the many-shot classes. 


\subsection{On the exploration of determining }
\label{sec:tau_selection}


The current tau-normalization strategy does require a validation set to choose tau, which could be a disadvantage depending on the practical scenario. Can we do better?

\header{Finding  value on training set}
We also attempted to select  directly on the \emph{training} dataset. Surprisingly, final performance on testing set is very similar, with  selected using training set only. 

We achieve this goal by simulating a balanced testing distribution from the training set. We first feed the whole training set through the network to get the top-1 accuracy for each of the classes. Then, we average the class-specific accuracies and use the averaged accuracy as the metric to determine the tau value. As shown in Table~\ref{tab:tau_expore}, we compare the  found on training set and validation set for all three datasets. We can see that both the vale of  and the overall performances are very close to each other, which demonstrates the effectiveness of searching for  on training set. This strategy offers a practical way to find  even when validation set is not available.

\header{Learning  value on training set}
We further investigate if we can automatically learn the  value instead of grid search. To this end, following cRT, we set  as a learnable parameter and learn it on the training set with balanced sampling, while keeping all the other parameters fixed (including both the backbone network and classifier). Also, we compare the learned  value and the corresponding results in the Table~\ref{tab:tau_expore} (denoted by ``learn'' = \cmark). This further reduces the manual effort of searching best  values and make the strategy more accessible for practical usage.

\begin{table}[h]
\small
\caption{Determining  on the training set}
\label{tab:tau_expore}
\begin{center}
\begin{tabular}{llcl|cccc}
\toprule
Dataset & split & learn &  &  Many & Medium & Few & All \\
\midrule
\multirow{3}{*}{ImageNet-LT}
& val & \xmark & 0.7 & 59.1 & 46.9 & 30.7 & 49.4 \\
& train & \xmark & 0.7 & 59.1 & 46.9 & 30.7 & 49.4 \\
& train & \cmark & 0.6968 & 59.2 & 46.9 & 30.6 & 49.4 \\
\midrule
\multirow{3}{*}{iNaturalist}
& val & \xmark & 0.3 & 65.6 & 65.3 & 65.9 & 65.6 \\
& train & \xmark & 0.2 & 69.0 & 65.2 & 63.6 & 65.0 \\
& train & \cmark & 0.3146 & 65.1 & 65.2 & 66.1 & 65.6 \\
\midrule
\multirow{3}{*}{Places-LT}
& val & \xmark & 0.8 & 37.8 & 40.7 & 31.8 & 37.9 \\
& train & \xmark & 0.6 & 41.4 & 39.3 & 25.3 & 37.4 \\
& train & \cmark & 0.5246 & 42.6 & 38.3 & 22.7 & 36.8 \\
\bottomrule
\end{tabular}
\end{center}
\end{table}

\subsection{Comparing MLP Classfiier with Linear Classifier}
\label{sec:mlp}
We experimented with MLPs with different layers (2 or 3) and different number of hidden neurons (2048 or 512). We use ReLU as activation function, set the batch size to be 512, and train the MLP using balanced sampling on fixed representation for 10 epochs with a cosine learning rate schedule, which gradually decrease the learning rate to zero. We conducted experiments on two datasets. 

On ImageNet-LT, we use ResNeXt50 as the backbone network. The results are summarized in Table~\ref{tab:mlp_imnet}. We can see that when the MLP going deeper, the performance are getting worse. It probably means the backbone network is enough to learn discriminative representation. 

\begin{table}[h]
\small
\caption{MLP classifier on ImageNet-LT}
\label{tab:mlp_imnet}
\begin{center}
\begin{tabular}{c|cccc|cccc}
\toprule
\multirow{2}{*}{Layers} & \multicolumn{4}{c}{hid-dim : 2048} & \multicolumn{4}{|c}{hid-dim : 512} \\
 & Many & Medium & Few & All & Many & Medium & Few & All\\
\midrule
1 & 61.7 & 45.9 & 26.8 & 49.4 \\
2 & 60.8 & 44.4 & 24.5 & 48.0 & 59.9 & 44.3 & 25.1 & 47.7 \\
3 & 60.3 & 44.3 & 23.7 & 47.7 & 59.3 & 43.7 & 23.9 & 47.0 \\
\bottomrule
\end{tabular}
\end{center}
\end{table}

For iNaturalist, we use the representation from a ResNet50 model trained for 200 epochs. We only consider a hidden dimension of 2048, as this dataset contains much more classes. The results are shown in Table~\ref{tab:mlp_inat}, and show that performance drop is even more severe when a deeper classifier is used. 

\begin{table}[h]
\small
\caption{MLP classifier on iNaturalst}
\label{tab:mlp_inat}
\begin{center}
\begin{tabular}{c|cccc}
\toprule
Layers & Many & Medium & Few & All \\
\midrule
1 & 73.2 & 68.8 & 66.1 & 68.2 \\
2 & 60.4 & 61.8 & 60.6 & 61.2 \\
3 & 68.5 & 63.6 & 60.1 & 62.8 \\
\bottomrule
\end{tabular}
\end{center}
\end{table}

\subsection{Cosine Similarity for Classification}
\label{sec:mlp}

We tried to replace the linear classifier with a cosine similarity classifier with (denoted by ``cos'') and without (denoted by ''cos(noRelu)'') the last ReLU activation function, following \cite{gidaris2018dynamic}. We summarize the results in Table~\ref{tab:cos}, which show that they are comparable to each other.

\begin{table}[h]
\small
\caption{Cosine similarity Classifier}
\label{tab:cos}
\begin{center}
\begin{tabular}{l|cccc}
\toprule
Classifier & Many & Medium & Few & All \\
\midrule
\ncm & 56.6 & 45.3 & 28.1 & 47.3 \\
\retrain & 61.7 & 45.9 & 26.8 & 49.4 \\
\wnorm & 59.1 & 46.9 & 30.7 & 49.4 \\
\midrule
cos & 60.4 & 46.8 & 29.3 & 49.7 \\
cos(noRelu) & 60.7 & 46.9 & 28.0 & 49.6 \\
\bottomrule
\end{tabular}
\end{center}
\end{table}




 

\end{document}
