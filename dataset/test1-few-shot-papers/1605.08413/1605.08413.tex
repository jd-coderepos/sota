








\documentclass[10pt,journal,compsoc]{IEEEtran}
\pdfoutput=1









\usepackage{ifpdf}







\ifCLASSOPTIONcompsoc
\usepackage[nocompress]{cite}
\else
\usepackage{cite}
\fi






\ifCLASSINFOpdf
  \usepackage[pdftex]{graphicx}
\graphicspath{{./figs/}}
\DeclareGraphicsExtensions{.pdf,.jpeg,.jpg,.png}
\else
\fi







\usepackage{amsmath}






\usepackage{algorithm}
\usepackage{algpseudocode}


\usepackage{array}








\ifCLASSOPTIONcompsoc
  \usepackage[caption=false,font=footnotesize,labelfont=sf,textfont=sf]{subfig}
\else
  \usepackage[caption=false,font=footnotesize]{subfig}
\fi


























\usepackage[colorinlistoftodos]{todonotes}

\usepackage{enumerate}

\usepackage{rotating}
\usepackage{multirow}



\hyphenation{op-tical net-works semi-conduc-tor}


\begin{document}
\title{Advancing the State-of-the-Art in \\ Hardware Trojans Design}


\author{
Syed~Kamran~Haider,
~Chenglu~Jin,
and~Marten~van~Dijk\IEEEcompsocitemizethanks{\IEEEcompsocthanksitem S. K. Haider, C. Jin, and M. van Dijk are with the Department
of Electrical and Computer Engineering, University of Connecticut, Storrs,
CT, 06279.\protect\\
E-mail: \{syed.haider, chenglu.jin, vandijk\}@engr.uconn.edu}}

















\IEEEtitleabstractindextext{\begin{abstract}
Electronic Design Automation (EDA) industry heavily reuses third party IP cores.
These IP cores are vulnerable to insertion of Hardware Trojans (HTs) at design time by third party IP core providers or by malicious insiders in the design team.
State of the art research has shown that existing HT detection techniques, which claim to detect all publicly available HT benchmarks, can still be defeated by carefully designing new sophisticated HTs.
The reason being that these techniques consider the HT landscape to be limited only to the publicly known HT benchmarks, or other similar (simple) HTs.
However the adversary is not limited to these HTs and may devise new HT design principles to bypass these countermeasures.

In this paper, we discover certain crucial properties of HTs which lead to the definition of an exponentially large class of Deterministic Hardware Trojans  that an adversary can (but is not limited to) design.
The discovered properties serve as HT design principles, based on which we design a new HT called \textit{XOR-LFSR} and present it as a `proof-of-concept' example from the class .
These design principles help us understand the tremendous ways an adversary has to design a HT, and show that the existing publicly known HT benchmarks are just the tip of the iceberg on this huge landscape.
This work, therefore, stresses that instead of guaranteeing a certain (low) false negative rate for a small \textit{constant} set of publicly known HTs, a rigorous HT detection tool should take into account these newly discovered HT design principles and hence guarantee the detection of an \textit{exponentially large} class (exponential in number of wires in IP core) of HTs with negligible false negative rate.










 \end{abstract}

\begin{IEEEkeywords}
Hardware Trojans, Security, Taxonomy, Classification, IP Cores.
\end{IEEEkeywords}}


\maketitle


\IEEEdisplaynontitleabstractindextext




\IEEEpeerreviewmaketitle


\newtheorem{theorem}{Theorem}
\newtheorem{lemma}{Lemma}
\newtheorem{definition}{Definition}

\section{Introduction} \label{sec:intro}

Modern electronic systems heavily use third party IP (intellectual property) cores as their basic building blocks.
An IP core is a reusable block of logic, tailored to perform a particular operation in an efficient manner, that is an intellectual property of one party.
Optimized for area and performance, the IP cores are essential elements of design reuse in electronic design automation (EDA) industry and save a lot of resources to redesign the components from scratch. 
UARTs, DSP units, Ethernet controllers and PCI interfaces etc. are some examples of the IP cores~\cite{ipcore2}.

The IP cores are typically offered either in a hardware description language (e.g., Verilog or VHDL) as synthesizable RTL (also called `open source' IPs) or as generic gate-level netlists (also called `closed source' IPs).
These IP cores give rise to a critical security problem: how to make sure that the IP core does not contain a \textit{Hardware Trojan} (HT)?
A (compromised) IP core vendor acting as an adversary could implant a malicious circuitry in the IP core for privacy leakage or denial of service attacks.

A significant amount of research has been done during the past decade to design efficient tools for HT detection.
Hicks \textit{et al.}~\cite{sp2010} proposed \textit{Unused Circuit Identification} (UCI) which centers on the fact that the HT circuitry mostly remains inactive within a design, and hence such minimally used logic can be distinguished from the other parts of the circuit.
However later works~\cite{uci_1},~\cite{UCI_sp11} showed how to design HTs which can defeat the UCI detection scheme.
Zhang \textit{et al.}~\cite{veritrust} and Waksman \textit{et al.}~\cite{fanci} proposed detection schemes called VeriTrust and FANCI respectively and showed that they can detect all HTs from the TrustHub~\cite{trust_hub} benchmark suite.
Yet again, the most recent technique called DeTrust~\cite{detrust} introduces new Trojan designs which can evade both VeriTrust and FANCI.

The reason behind this cat-and-mouse game between attackers and defenders is that the current HT detection tools offer critically low HT coverage and typically only cover a small \textit{constant} set of \textit{publicly known} HT benchmarks such as TrustHub.
Whereas an adversary may design new HTs which are different from the publicly known HTs in that they can bypass the detection tool, as demonstrated by DeTrust~\cite{detrust}.
It is unclear to what extent the existing HT detection tools are effective for \textit{publicly unknown} HTs.



The first and foremost challenge in designing an effective HT detection technique is to define the scope of the countermeasure on the landscape of HTs.
The HT taxonomies can be used for this purpose.
Bhunia {\em et al.} \cite{ieeesurvey} presents a taxonomy of HTs
based on an extensive survey of the existing literature.
The trigger based HTs are subdivided into digital and analog categories where digital HTs have two general models, combinational and sequential HTs.
Combinational HTs are those whose trigger circuitry is simply a comparator whereas sequential HTs have memory elements as well in their trigger circuitry.
Trojans are also classified based on payloads, i.e. digital, analog and others such as denial of service.


Since we are talking about digital IP cores, in this paper we limit ourselves to trigger activated digital HTs which have digital payloads. 
The Trojans that are always active and/or exploit side channels for their payloads are out of scope of this paper.


Even though existing HT taxonomies, such as the one mentioned above, provide significant knowledge about the HT properties, yet this information is quite fundamental and does not provide detailed characteristics vital for the HT countermeasures to provide strong security guarantees.
This limitation may lead to uncertainties and potentially misleading information about the detection coverage that a HT countermeasure can provide.



This paper introduces four crucial properties (, , , ) of a large and complex class  of trigger activated and deterministic digital HTs.
These properties, determining the stealthiness of HTs, lead to a much more detailed classification of such HTs and hence assign well defined boundaries to the scope of the existing and new countermeasures on the huge landscape of HTs.
In our model,  represents the HTs which are embedded in a digital IP core whose output is a function of only its input, and the algorithmic specification of the IP core can exactly predict the IP core behavior.
A brief highlight of the properties of  is as follows:

{
\vspace{6pt}
\renewcommand{\arraystretch}{1.3}
\centering
\begin{tabular}{c p{0.85\columnwidth}} : &  \textbf{Trigger Signal Dimension} represents the number of wires used by HT trigger circuitry to activate the payload circuitry in order to exhibit malicious behavior. Large  shows a complicated trigger signal, hence harder to detect. \\ : & \textbf{Payload Propagation Delay} is the number of cycles required to propagate malicious behavior to the output port \textit{after} the HT is triggered. Large  means it takes a long time after triggering until the malicious behavior is seen, hence less likely to be detected during testing. \\ : & \textbf{Implicit Behavior Factor} represents the probability that given a HT gets triggered, it will not (explicitly) manifest malicious behavior; this behavior is termed as implicit malicious behavior. Higher probability of implicit malicious behavior means higher stealthiness. \\ :  & \textbf{Trigger Signal Locality} shows the spread of trigger signal wires of the HT across the IP core. Small  shows that these wires are in the close vicinity of each other. Large  means that these wires are spread out in the circuit, hence the HT is harder to detect. \\ \end{tabular}
\vspace{3pt}
}






Based on the above mentioned parameters, we introduce a new stealthy HT, coined the \textit{XOR-LFSR}, which cannot be efficiently detected by ordinary means (design knowledge of the HT itself needs to be incorporated in the detection tool).
We also show that the current publicly known HTs have small  (mostly  for TrustHub) and hence they are the simplest ones.
\figurename~\ref{fig-coverage} depicts a pictorial representation of the HT class  that includes TrustHub\footnote{In this paper, we are only considering HTs from TrustHub that are trigger activated and have digital payloads.}.
Although VeriTrust and FANCI can detect TrustHub HTs, it is unclear what security guarantees they offer outside TrustHub.

\begin{figure}[!t]
\centering
\includegraphics[width=0.7\columnwidth]{coverage}
\caption{Class of Deterministic Hardware Trojans , and detection coverages of existing Hardware Trojan countermeasures.}
\label{fig-coverage}
\end{figure}































The rest of this paper is organized as follows.
Section \ref{sec:background-org} provides some basic background of HTs and introduces our threat model.
Section \ref{sec:classification} defines the HT class  and introduces several advanced properties of this class which lead to new HT design methodologies.



 
\section{Background \& Definitions}\label{sec:background-org}

\begin{figure}[!t]
\centering
\includegraphics[width=2.6in]{classification_a}
\caption{IP Core Design Space: An IP core can either have a Hardware Trojan or an Exploit, or it behaves `normally'.}
\label{fig:classification_a}
\end{figure}

A digital IP core can fall under one of the following three categories, as shown in \figurename~\ref{fig:classification_a}, based on its level of conformity to the design specifications; (1) containing \textit{A Hardware Trojan}, or (2) containing \textit{An Exploit}, or (3) exhibiting \textit{Normal Behavior}. 

\subsection{Hardware Trojan}
A Hardware Trojan (HT) is malicious \textit{extra} circuitry embedded inside a larger circuit, which results in data leakage or harm to the normal functionality of the circuit once activated.
We define \textit{extra} circuitry as redundant logic added to the IP core without which the core can still meet its design specifications\footnote{Design specifications can also cover the performance requirements of the core, and hence pipeline registers etc. added to the core only for performance reasons can also be considered as `necessary' to meet the design specifications and will not be counted towards `extra' circuitry.}.
A \textit{trigger activated} HT activates upon some special event, whereas an \textit{always active} HT remains active all the time to deliver the intended payload.


Trigger activated HTs typically consist of two parts: a \textit{trigger circuitry} and a \textit{payload circuitry}.
The trigger circuitry is implemented semantically as a comparator which compares the value(s) of certain wires(s) of the circuit with a specified boolean value called \textit{trigger condition}.
The HT trigger circuitry sends its comparator's output to the payload circuitry over certain other wire(s) called the \textit{trigger signal}.
Once the trigger signal is asserted, the payload circuitry performs the malicious operation called `payload' as intended by the adversary.

\begin{definition}
\textbf{Trigger condition} refers to an event, manifested in the form of a particular boolean value of certain internal/external wires of the circuit, which activates the HT trigger circuitry.
\end{definition}
\begin{definition}
\textbf{Trigger signal or Trigger State} refers to a collection of physical wire(s) which the HT trigger circuitry asserts in order to activate the payload circuitry once a trigger condition occurs.
\end{definition}

The trigger signal must not be confused with trigger condition; trigger condition is an event which causes the HT activation, whereas trigger signal is the output of trigger circuitry which tells the payload circuitry to show malicious behavior.

\begin{figure}[!t]
\centering
\subfloat[Half Adder]{\includegraphics[width=1.4in]{simple_ht_exp_1}
\label{fig:simple_ht_exp_1}}
\hfil
\subfloat[Half Adder with HT]{\includegraphics[width=1.9in]{simple_ht_exp_2}
\label{fig:simple_ht_exp_2}}
\caption{A simple HT: Trigger condition ; Normal output ; Malicious output (under trigger condition) .}
\label{fig:simple_ht_example}
\end{figure}

\figurename~\ref{fig:simple_ht_example} shows an example of a simple HT embedded in a half adder circuit.
The HT-free circuit in \figurename~\ref{fig:simple_ht_exp_1} generates a sum  and a carry . 
The HT, highlighted in red in \figurename~\ref{fig:simple_ht_exp_2}, triggers when  and produces incorrect results i.e.  for  and  for .
Notice the difference between the trigger condition , and the trigger signal  which only becomes  when the trigger condition is satisfied.

The Trojan affected circuit in \figurename~\ref{fig:simple_ht_example} produces a \textit{malicious} output  for trigger condition  which is distinguishable from otherwise normal output (). 
However, the same circuit produces a (so called) malicious output  for trigger condition  which is the same as otherwise normal output and cannot be distinguished from the `normal' behavior of the circuit.
This observation leads us to the definition of \textit{explicit} vs. \textit{implicit} malicious behaviors:

\begin{definition}
\textbf{Explicit malicious behavior} refers to a behavior of a HT where the HT generated output is \textit{distinguishable} from a normal output.
\end{definition}
\begin{definition}
\textbf{Implicit malicious behavior} refers to a behavior of a HT where the HT generated output is \textit{indistinguishable} from a normal output. 
\end{definition}

Notice that an adversary may exploit the implicit malicious behavior to bypass functional testing based detection tools during the testing phase.
Once the infected circuit has passed the testing and is deployed, it can then manifest explicit malicious behavior to actually deliver the payload.
In other words, implicit malicious behavior can lead to a false negative.

\begin{definition}
\textbf{False Negative} refers to a scenario when a HT detection tool identifies a circuit containing a HT as a Trojan-free circuit or transforms a circuit containing a HT into a circuit which still allows the HT to express implicit or explicit malicious behavior.
\end{definition}

Clearly, all existing dynamic analysis (i.e. functional testing) based approaches which assume that a HT is never triggered during the functional testing phase can suffer from false negatives because of the implicit malicious behavior.
Neglecting the implicit malicious behavior could lead to devastating consequences in a security critical application, e.g. if an adversary designs a HT to significantly increase the probability of implicit malicious behavior and thus alleviates the existing HT detection techniques.

\subsection{An Exploit}
An exploit refers to a loophole in the specifications or implementation of an IP core which allows an adversary to manipulate it beyond its intended specifications.
Notice that an exploitable IP core does not have `extra' circuitry like a Hardware Trojan.
Depending upon the nature of the exploits, they can also deliver the payloads like Hardware Trojans such as privacy leakage or denial of service etc.
Some examples of exploits are as follows: a wireless connection that can be overloaded may lead to a denial of service, a broken AES module due to a predictable key, recent OpenSSL Heartbleed bug etc. 
This paper only focuses on rigorous reasoning about Hardware Trojans (not exploits).







 \section{Characterization of Hardware Trojans}\label{sec:classification}

\begin{figure}[!t]
\centering
\includegraphics[width=0.9\columnwidth]{taxonomy} 
\caption{Classification of Hardware Trojans}
\label{fig:taxonomy}
\end{figure}

In this section, we characterize the trigger activated HTs based on their following fundamental characteristics that lead to a clear distinction between the deterministic  and non-deterministic  types.


\subsection{ vs.  Hardware Trojans} 
Hardware Trojans are first grouped based on the payload channels they use once activated as shown in  \figurename~\ref{fig:taxonomy}.
\textit{St} refers to the Trojans using only standard I/O channels (this includes LED outputs etc.) whereas \textit{Si} represents the Trojans which also use side channels to deliver the payload.
I/O channels are generally used to communicate binary payloads  at certain times  for the duration of the execution of the IP core. 
In this sense the view of an I/O channel can be represented as a sequence . 
Its information is decomposed in three channels: the binary channel corresponding to , the timing channel corresponding to , and the termination channel  which reveals information about the duration of the execution of the IP core. 
If a Trojan delivers some of its payload over the timing channel (or other side channels), then we define it to be in \textit{Si}. 
If a Trojan delivers {\em all} of its payload using the standard usage of  I/O channels (the binary and termination channels), then we define it to be in \textit{St}.  
E.g., a HT causing performance degradation in terms of slower response/termination times due to slower computation (denial of service in the most extreme case) is in \textit{St}.



\subsection{ vs.  Hardware Trojans} 
We further refine our description of \textit{St} Trojans by subdividing them in  and  groups based on the IP core behavior in which they are embedded and their algorithmic specifications.

\begin{definition}
\boldmath{} Trojans are the ones which are:
\begin{enumerate} 
\item Embedded in an IP core whose output is a function of only its input -- i.e. the logical functionality of the IP core is deterministic, and 
\item The algorithmic specification of the IP core can exactly predict the IP core behavior.
\end{enumerate}
\end{definition}

If any of the two above mentioned conditions is not satisfied for a \textit{St} type HT then we consider the HT to be in .
A true random number generator (TRNG), for example, is a non-deterministic IP core since its output cannot be predicted and verified by logic testing against an expected output.\footnote{Any IP core which contains a TRNG as a module, yet the I/O behavior of the core can still be predicted is considered .}
Any \textit{St} Trojan in such a core is considered .
A pseudo random number generator (PRNG), on the other hand, is considered a deterministic IP core as its output depends upon the initial seed and is therefore predictable by a logic based testing tool (hence ).
Similarly, if the algorithmic specification allows coin flips generated by a TRNG then we consider the Trojan to be .
On the other hand, if the coin flips are generated by a PRNG then we regard the Trojan as .

The non-deterministic behavior of IP cores and/or their functional specification which accepts small probabilistic fluctuations within some acceptable range allows a covert channel for  Trojans to embed some minimal malicious payload in the standard output without being detected by an external observer~\cite{bellare2014security}.
The external observer considers these small fluctuations as part of the functional specification.
Hence, the non-deterministic nature of  Trojans prohibits the development of a logic testing based tool to detect these Trojans with overwhelming probability.













\section{Advanced Properties of Class } \label{sec:HD}

In the following discussion, we introduce some crucial properties of  Trojans that characterize their complexity and stealthiness.

\subsection{Trigger Signal Dimension }
When a trigger condition of a hardware Trojan occurs, {\em regardless of the other subsequent user interactions}, its trigger circuitry gets activated and outputs a certain binary value on a certain trigger signal  to activate the payload circuitry which manifests malicious behavior.
A trigger signal  is represented as a labeled binary vector of one or more wires/registers/flip-flops (each carrying a  or ), e.g. in the example circuit of \figurename~\ref{fig:simple_ht_example},  is a trigger signal.
In other words,  represents a trigger state of the circuit through which the circuit must have passed before manifesting malicious behavior.
Notice that the trigger state(s) can be associated back to the occurrence of the respective trigger condition(s).
Hence a HT can be represented by a set of trigger states ; i.e. the states which always lead to malicious behavior (implicit or explicit).
\begin{definition} 
\textbf{A set \boldmath{} of trigger states} \textit{represents} a HT if the HT always passes through one of the states in  in order to express implicit of explicit malicious behavior.
\end{definition}

\vspace{3pt}
Notice that {} is not unique. 
For example, {} could be {}, or if  is somehow independent of  and , then it could also be {} etc.

We define the \textit{trigger signal dimension}  of a HT represented by a set of trigger states  as follows:
\begin{definition} 
\textbf{Trigger Signal Dimension \boldmath{}} of a HT is defined as .
\end{definition}

\vspace{3pt}
In other words, the trigger signal dimension shows the width of the widest trigger signal bit-vector of a HT.
E.g. for the HT from \figurename~\ref{fig:simple_ht_exp_2},  since the set of trigger states {} only has the signal  that activates the payload circuitry is only 1-bit wide (and hence easy to detect).
In the next section, we show that one can design HTs with high dimensional trigger signals.
Obviously, it becomes difficult to detect HTs which only have high dimensional sets of trigger states, i.e. large trigger signals.
The set of possible values of a given trigger signal  grows exponentially in  and only one value out of this set can be related to the occurrence of the corresponding trigger condition. 
Clearly, since in theory  can be as large as the number of wires  in the IP core,  represents an exponentially (in ) large class of possible HTs.

\subsection{Payload Propagation Delay }
For a set  which represents a HT, we know that if the HT manifests malicious behavior, then it must have transitioned through a trigger state  at some previous clock cycle. 
Therefore, we define the \textit{payload propagation delay}  as follows:
\begin{definition}
\textbf{Payload Propagation Delay \boldmath{}} of a hardware Trojan represented by a set of trigger states  is defined as the {\em maximum} number of clock cycles taken to propagate the malicious behavior to the output \textit{after} entering a trigger state in . 
\end{definition}


I.e., the number of clock cycles from the moment when a trigger signal is asserted till its resulting malicious behavior shows up at the output port.
E.g., consider a counter-based HT where malicious behavior immediately (during the same clock cycle) appears at the output as soon as a counter reaches a specific value. 
Then,  for the trigger signal  which represents the occurrence of the specific counter value (i.e. trigger condition).
However, notice that any counter value  clock cycles before reaching the `specific value' can also be considered as a trigger signal  with , because eventually after  cycles this  manifests the malicious behavior.


To detect a HT with a large value of , the memory requirement and complexity of logic testing based detection tool is increased.
However, for any HT, typically there exists a set of trigger signals which represents the HT and which has a small  because of a small number of register(s) between the trigger signal and the output port.



\subsection{Implicit Behavior Factor }
In addition to previously discussed properties of Trojans, the IP core in which the Trojan is embedded plays a critical role in its stealthiness.
According to the definition of implicit malicious behavior, it may not always be possible to distinguish a malicious output from a normal output just by monitoring the output ports.
Consequently, the implicit malicious behavior adds to the stealthiness of the HT since it creates a possibility of having a false negative under logic testing based techniques.
We quantify this possibility by defining the \textit{implicit behavior factor}  as follows:
\begin{definition}
\label{def:aplha}
\textbf{Implicit Behavior Factor \boldmath{}} of a HT is the probability that given the HT is triggered, it will manifest {\em implicit} malicious behavior.
\end{definition}


In other words, the higher the value of , the lower the chance of detection by logic testing even if the HT gets triggered and hence the higher the overall stealthiness of the HT.
E.g. for the HT from \figurename~\ref{fig:simple_ht_exp_2} with the trigger condition , if  then the malicious output  is distinguishable from the normal output (i.e. ).
However for , the malicious\footnote{The output is considered malicious because it is generated by an activated hardware Trojan.} output  is indistinguishable from the normal output (i.e. ), i.e. the implicit malicious behavior comes into the picture.
Hence, given that this particular HT activates, the probability that the HT-generated (malicious) output is indistinguishable from the normal output is  which represents the implicit behavior factor of this HT.





\subsection{Trigger Signal Locality }

\begin{figure}[!t]
\centering
\subfloat[A simple circuit]{\includegraphics[width=2in]{locality_circuit}
\label{fig:locality_circuit}}
\hfil
\subfloat[Locality Graph of the circuit]{\includegraphics[width=2in]{locality_graph}
\label{fig:locality_graph}}
\caption{Example of Locality Graph}
\label{fig:locality_graph_example}
\end{figure}

We notice that the individual wires of a HT trigger signal of dimension  are logically/physically located in the close vicinity of each other in the circuit netlist/layout.
This is because eventually these wires need to coordinate (through some combinational logic) with each other to perform the malicious operation.
Based on this observation, we introduce the idea of \textit{locality} in gate level circuits, similar to the region based approach in \cite{trustedRTL}.

Consider the simple combinational circuit from \figurename~\ref{fig:locality_circuit}.
Based on this circuit, we draw a \textit{locality graph} shown in \figurename~\ref{fig:locality_graph} whose nodes represent the wires of the circuit and each edge between any two nodes represents connectivity of the corresponding two wires through a combinational logic level. 
In other words, each logic gate of the circuit is replaced by multiple edges (three in this case) in the graph which connect together the nodes corresponding to its inputs and the output.
For any two nodes (i.e. wires)  and  in a locality graph, we define  as the shortest distance between  and .
In other words,  represents the minimum number of basic combinational or sequential logic levels (e.g. logic gates and/or flip flops) between wires  and .
E.g. , whereas .

\begin{definition} \label{def:locality}
\textbf{Trigger Signal Locality \boldmath{}} of a HT represented by the set of trigger states  is defined as: 

where  represents the label of the  wire in .
\end{definition}

A low value of  shows that the trigger signal wires of the HT are in the close vicinity of each other and vice versa.
Having a notion of locality can significantly reduce the computational complexity of logic testing based HT detection tools. 

\subsection{Achievable Quadruples }
A Hardware Trojan can be represented by multiple sets of trigger states , each having their own , , , and  values.  
The collection of corresponding quadruples  is defined as the achievable region of the Hardware Trojan.




The choice of parameters  and  significantly affects  of the HT.  as a function of  and  is decreasing in both  and .
Reducing  means that explicit malicious behavior may not have had the chance to occur, hence, the probability   that no explicit malicious behavior is seen increases. 
Similarly, reducing  can increase  since as a result of smaller , there may not exist a set of trigger signals  that represents the HT and satisfies .
Increasing  or  only decreases  down to a certain level; the remaining component of  represents the inherent implicit malicious behavior of the HT.






\section{Examples of  Trojans}
In this section, we present some examples of new HTs from the class .
These HTs demonstrate how the properties of  Trojans defined in the previous section play a significant role in determining the stealthiness of these HTs.

\subsection{A Counter-Based  Trojan}\label{htd-h2}
\begin{figure}[!t]
\centering
\subfloat[A counter based  Trojan. Trigger Condition: ; Trigger Signal: ; Payload: Leak ]{\includegraphics[width=2.4in]{h2_lfsr_exp_updated}
\label{fig:h2_lfsr_fig}}
\hfill
\subfloat[Truth Table of the Trojan affected circuit. Trigger Condition: ]{
\renewcommand{\arraystretch}{1.1}
\begin{tabular}[b]{|c||c|c|c|c||c|c|c|}
\hline
 &  &  &  &  &  &  &  \\
\hline
0 & 1 & 0 & 1 & 0 & 1 & 1 & 0\\
1 & 0 & 1 & 0 & 1 & 0 & 0 & 0\\
2 & 1 & 0 & 1 & 1 & 1 & 1 & 0\\
3 & 0 & 1 & 1 & 1 & 1 & 1 & 0\\
4 & 1 & 1 & 1 & 1 & 1 & 1 & 1\\
5 & 1 & 1 & 1 & 0 & 1 & 1 & 0\\
6 & 1 & 1 & 0 & 0 & 0 & 0 & 0\\
7 & 1 & 0 & 0 & 0 & 0 & 0 & 0\\
8 & 0 & 0 & 0 & 1 & 0 & 0 & 0\\
9 & 0 & 0 & 1 & 0 & 1 & 1 & 0\\
10 & 0 & 1 & 0 & 0 & 0 & 0 & 0\\
11 & 1 & 0 & 0 & 1 & 0 & 0 & 0\\
12 & 0 & 0 & 1 & 1 & 1 & 1 & 0\\
13 & 0 & 1 & 1 & 0 & 1 & 1 & 0\\
\bfseries 14 & \bfseries 1 & \bfseries 1 & \bfseries 0 & \bfseries 1 & \bfseries 0 & \bfseries 1 &\bfseries 1 \\
\hline
\end{tabular}
\label{fig:h2_lfsr_table}
}
\caption{A Counter-Based  Trojan having Trigger Signal Dimension .}
\label{fig:h2_lfsr_ex}
\end{figure}

The example Trojan shown in \figurename~\ref{fig:h2_lfsr_fig} can leak  via  port instead of  once it is activated.
The trigger condition of this Trojan is generated by a counter, when reached to (), which is implemented as a 4-bit maximal LFSR in order to have maximum possible time before the Trojan gets triggered.
The LFSR is initialized to .
At  clock cycle, the trigger condition (i.e. ) occurs, the HT gets triggered and produces  on the trigger signal ().
This results in the activation of payload circuitry (the group of three MUXes) which leaks the secret.


It can be seen in \figurename~\ref{fig:h2_lfsr_table} that all individual wires related to the HT circuitry are continuously showing transitions \textit{without} activating the HT during several clock cycles before reaching to the trigger condition (i.e. cycle ).
Therefore, clearly those existing logic testing based HT detection techniques which only look for simplistic one-dimensional HT (i.e. ) trigger signals do not see any `suspicious' wire which is stuck at  or , and hence this HT is not detected unless it gets activated in a long testing phase. 
This shows that this HT has a trigger signal dimension  since two wires  and  together constitute the trigger signal.
Since counter based HTs can have large counters, it may not always be feasible to activate them during testing.
Consequently, in order to efficiently detect such HTs, the knowledge of such design parameters must be incorporated while designing the HT countermeasures.




\subsection{An Advanced  Trojan: -\textit{XOR-LFSR}}
\figurename~\ref{fig-htd} depicts -\textit{XOR-LFSR}, a counter based Trojan with the counter implemented as an LFSR 
of size . The Trojan is merged with the circuitry of an IP core which outputs the XOR of  inputs .

Let   denote the LFSR register content at clock cycle  represented as a binary vector of length . 
Suppose that  is the maximum index for which the linear space  generated by vectors  (modulo 2) has dimension . 
Since  , there exists a vector  such that, (1) the inner products  (modulo 2) for all , and (2)  (modulo 2). 
{\em Only} the register cells corresponding to  are being XORed with inputs . 


Since the  are all XORed together in the specified  logical functionality to produce the sum , the Trojan changes this sum to

I.e., the sum remains unchanged until the -th clock cycle when it is maliciously inverted.

\begin{figure}[!t]
\centering
\includegraphics[width=2.6in]{general_ht}
\caption{-\textit{XOR-LFSR}: A general  Trojan.}
\label{fig-htd}
\end{figure}


The trojan uses an LFSR to generate register values  for each clock cycle  and we assume in our analysis  that all vectors  behave like random vectors from a uniform distribution. 
Then, it is unlikely that  is more than a small constant larger than  (since every new vector  has at least probability  to increase the dimension by one). 
Therefore, , hence, the register size of the trojan is comparable to the number of clock cycles before the trojan is triggered to deliver its malicious payload. 
This makes the trojan somewhat contrived (since it can possibly be detected by its suspiciously large area overhead). 

Since inputs  can take on any values, any trigger signal  must represent a subset of the LFSR register content. Suppose . Then  must represent a subset of .
We will proceed with showing a lower bound on .
Consider a projection  to a subset of  register cells; by  we denote the projection of  under , and we call  -dimensional. If , then the wire combination of the   wires corresponding to  {\em cannot} represent  (otherwise ): if this is the case for all  dimensional , then  cannot represent a subset of . The probability that   is at least equal to the probability that , which is (by the union bound) 

\vspace{-6pt}

Since there are  projections,  cannot represent a subset of  with probability 

For ,  this lower bound is about .
Since  and after neglecting the term , this shows an approximate lower bound on , i.e.,


This characterizes the stealthiness of the -\textit{XOR-LFSR}.
In other words, the stealthiness of -\textit{XOR-LFSR} can be increased with  within the acceptable area overhead limits.
\figurename~\ref{fig:d_bound_XORLFSR} shows the lower bounds on  for this HT for fixed values of  and ; if , then .
The HT can be designed for any point in the region above the lower bound.
For the HT shown in \figurename~\ref{fig-htd}, clearly  since it \textit{always} produces incorrect output immediately once the HT gets triggered.

\begin{figure}[!t]
\centering
\subfloat[]{\includegraphics[width=1.7in]{d_bound_t}
\label{fig:d_bound_t}}
\hfil
\subfloat[]{\includegraphics[width=1.7in]{d_bound_k}
\label{fig:d_bound_k}}
\caption{Lower bounds on  for -\textit{XOR-LFSR}.}
\label{fig:d_bound_XORLFSR}
\end{figure}




































 \section{Characterizing TrustHub Benchmarks}\label{sec:evaluation}

Trusthub~\cite{trust_hub} benchmark suite includes a wide variety of Hardware Trojans including trigger-activated and always-active Trojans; Trojans that use standard IO channels as well as side channels.
In this section, we analyze the TrustHub benchmarks with respect to our definitional framework.
As mentioned earlier, our  class of HTs covers majority of the relevant benchmarks from TrushHub. 
Here we present the values of design parameters (, , ) for these benchmarks which provide a deeper insight about the stealthiness of these well known HTs.



\begin{table}[t]
\renewcommand{\arraystretch}{1.2}
\setlength\tabcolsep{2pt}
\centering
\caption{Classification of Trusthub Benchmarks w.r.t. our definitional framework}
\label{table:trusthub_table}
\begin{tabular}{|c|c|c|c|c||m{0.7\columnwidth}|}\hline

\multicolumn{2}{|c|}{\multirow{1}{*}{\textit{\textbf{Type}}}}			&
\multicolumn{1}{c|}{\multirow{1}{*}{}}							&
\multicolumn{1}{c|}{\multirow{1}{*}{}}							&
\multicolumn{1}{c|}{\multirow{1}{*}{}}						&
\multicolumn{1}{c|}{\multirow{1}{*}{\textit{\textbf{Benchmarks}}}}	\\  \hline 

\multicolumn{1}{|c|}{\multirow{15}{*}{\textit{\textbf{St}}}}	&
\multicolumn{1}{c|}{\multirow{14}{*}{\textit{\textbf{D}}}}		&
\multicolumn{1}{c|}{\multirow{14}{*}{1}}		&
\multicolumn{1}{c|}{\multirow{4}{*}{0}}						&
       		& BasicRSA-T\{100, 300\} \\ \cline{5-6}
       
&&&& 0.5 	& 	s15850-T100, s38584-T\{200, 300\} \\ \cline{5-6}
&&&& 0-0.25	&	wb\_conmax-T\{100, 200, 300\} \\ \cline{5-6}
&&&& 0-0.87	&	RS232-T\{100, 800, 1000, 1100, 1200, 1300, 1400, 1500, 1600, 1700, 1900, 2000\} \\ \cline{4-6}

&&& \multicolumn{1}{c|}{\multirow{3}{*}{1}}		&
	0.5	&	b15-T\{300,400\}								\\ \cline{5-6}
&&&& 0.5-0.75  &	s35932-T\{100, 200\}						\\ \cline{5-6}
&&&& 0-0.06	  &	RS232-T\{400, 500, 600, 700, 900, 901\} \\ \cline{4-6}

&&& \multicolumn{1}{c|}{\multirow{2}{*}{2}}		&
	0.5		&	vga-lcd-T100, b15-T\{100, 200\}				\\ \cline{5-6}
&&&& 0.87	&	 s38584-T100 							\\ \cline{4-6}

&&& \multicolumn{1}{c|}{\multirow{2}{*}{3}}		&
		&	BasicRSA-T\{200, 400\}				\\ \cline{5-6}
&&&& 0.5			&	s38417-T100 						\\ \cline{4-6}

&&& 5	&	0.99&	 s38417-T200  \\ \cline{4-6}
&&& 7	&	0.5	&	RS232-T300 \\ \cline{4-6}
&&& 8 	&	0.5	&	s35932-T300 \\ \cline{2-6}


&
\multicolumn{1}{c|}{\textit{\textbf{ND}}}		&
\multicolumn{3}{c||}{ N/A }						&
MC8051-T\{200, 300, 400, 500, 600, 700, 800\}, PIC16F84-T\{100, 200, 300, 400\} \\ \hline

\multicolumn{2}{|c|}{\textit{\textbf{Si}}} 		& 
\multicolumn{3}{c||}{ N/A }						&
AES-T400, 600, 700, 800, 900, 1000, 1100, 1200, 1300, 1400, 1500, 1600, 1700, 2000, 2100, s38417-T300, AES-T100, 200, 300 \\ \hline 

\end{tabular}
\end{table}




\tablename~\ref{table:trusthub_table} shows the relevant\footnote{Not all of the benchmarks from TrustHub are listed in \tablename~\ref{table:trusthub_table}, because some of them have no payload, such as RS232-T200. Similarly the payloads of some other benchmarks are harmless which would be removed by synthesis tools. E.g. RS232-T1800, which just adds three inverters to waste energy.} benchmarks from Trusthub categorized according to our framework.
\textit{St-D} group (i.e.  Trojans) is further subdivided based on the properties (, , ).
All these Trojans happen to be represented by a single trigger of dimension  (i.e., the trigger is a single wire); whereas their corresponding  and  values\footnote{ values show estimated upper bounds on probabilities.} are listed in \tablename~\ref{table:trusthub_table}.

To determine  values of these trojans, we simply count the minimum number of registers between the trigger signal wires(s) and the output port of the IP core.
Since precisely calculating  can be almost impossible for large circuits, we estimate  values through experiments.
We argue that these estimated values closely represent the corresponding actual values of , hence \tablename~\ref{table:trusthub_table} fits the definition of .
In order to estimate  values, we first find the smallest chain of logic gates starting from the trigger signal wire(s) till the output port of the IP core (ignoring any registers in the path).
Then for each individual logic gate, we compute the probability of propagating a logic 1 (considering that the trigger wire(s) get a logic 1 upon a trigger event), e.g. an AND gate has the probability  of propagating a logic 1, whereas an XOR gate has the probability .
Finally we compute an aggregate probability of propagation by multiplying all the probabilities of each logic gate in the chain, which gives the value .


Notice that all these \textit{St-D} Trojans have a very low value of  (particularly ) which reflects their low stealthiness, and hence the fact that these publicly available benchmarks represent only a small subset consisting of simple Trojans.
Even though some of these benchmarks have high values of  (e.g. s38584-T100 and s38417-T200), however in practice, having a very high value of  may not always be useful for the adversary.
Ideally, on one hand, the adversary wants the Trojan to be triggered in the logic testing phase only once, and remain undetected (i.e. by having high ) so that the Trojan trigger is whitelisted.
On the other hand, after the testing phase, he wants the Trojan to deliver the payload by disrupting the normal output (i.e. by having low ), otherwise the Trojan is not useful for him.
Therefore, the adversary would like to have a sweet spot between the high and low ends of  values.




\textit{St-ND}  (i.e.  group) and \textit{Si} Trojans are out of scope of this paper.
In our model, some TrustHub benchmarks, e.g. MC8051 series, are considered to be in  group because of their flexible design specifications.
The specification of a processor is relatively flexible about the timing/ordering of outputs (e.g. instructions execution) due to some unpredictable factors like interrupt requests etc. 
This flexibility, however, makes it harder for logic testing based tools to verify the functional correctness of the design. 
However, if there exists a precise and strict model for these cores, such HTs can still be analyzed in our model.





 \vspace{6pt}
\section{Related Work}\label{sec:related_work}

Hardware trojans have recently gained significant interest in the security community~\cite{taxonomy},~\cite{usenix08},~\cite{huntforkill}. 
The works~\cite{usenix08} and~\cite{huntforkill} showed how malicious entities can exist in hardware, while Skorobogatov \emph{et al.}~\cite{military} showed evidence of such backdoors in military grade devices.
Nefarious designs have also been deployed and detected in wireless communications devices~\cite{wireless}.
Recent works have mostly focused on detection~\cite{iccd_12} and identification schemes~\cite{iccad_12}, which assess to what extent the pieces of hardware may be vulnerable, and how related trojans can be classified.
State of the art HT detection schemes include UCI~\cite{sp2010}, VeriTrust~\cite{veritrust}, FANCI~\cite{fanci} and DeTrust~\cite{detrust}.
Typically, HT detection techniques only show their detection capabilities for HTs from the TrustHub benchmarks suite, in which all trojans are explicitly triggered.
This explicitness forgoes the lack of implicitness, due to which all the above schemes are able to detect the benchmarked trojans.
These schemes, however, do not cater for higher dimensional () trojans or the added stealthiness because of the implicit malicious behaviors (i.e. ).
DeTrust presents a trojan example which bypasses other existing countermeasures, and interestingly it happens to have the dimension .
However, this property has not been noticed or analyzed in that paper.
We fill these gaps by providing a detailed and rigorous framework to reason about HT characteristics and their impact on the detection schemes.



Further works construct and detect HTs that use side channels~\cite{sidechannel1, sidechannel2, sidechannel3}.
Such HTs remain implicitly on, and have usually no effect on the normal functionality of the circuit.
Side channels include power based channels~\cite{power2}, as well as heat based channels~\cite{power4}.
Power based HTs force the circuit to dissipate more and more power to either damage the circuit, or simply waste energy.
Heat based HTs leak important information via heat maps~\cite{heat}, where highs and lows in heat dissipation can be interpreted as logic 1's and 0's.
Our work only focuses on HTs that perturb standard I/O channels; analyzing side channel models/frameworks is out of scope of this paper.
 \section{Conclusion}\label{sec:conclusion}
We provide the first rigorous framework of Hardware Trojans within which ``Deterministic Trojans'', the class  is introduced.
We discover several stealthiness parameters of the Hardware Trojans from  which lead us to design a much more stealthy \textit{XOR-LFSR} Hardware Trojan.
This shows that the current publicly known Hardware Trojans are the simplest ones in terms of stealthiness, and hence they represent just the tip of the iceberg at the huge landscape of Hardware Trojans.

We conclude that our framework allows the Hardware Trojan research community to rigorously reason about the stealthiness of different Hardware Trojans and the effectiveness of existing countermeasures.
The Hardware Trojan design principles introduced in this paper encourage and assist in designing new and even stronger countermeasures for highly stealthy and sophisticated Hardware Trojans. 


\ifCLASSOPTIONcaptionsoff
  \newpage
\fi

\bibliographystyle{IEEEtran}
\bibliography{sections/refs} 















































































\end{document}
