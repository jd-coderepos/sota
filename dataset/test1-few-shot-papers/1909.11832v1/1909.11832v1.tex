\documentclass{article}


\usepackage{arxiv}

\usepackage[utf8]{inputenc} \usepackage[T1]{fontenc}    \usepackage{hyperref}       \usepackage{url}            \usepackage{booktabs}       \usepackage{amsfonts}       \usepackage{nicefrac}       \usepackage{microtype}      \usepackage{lipsum}
\usepackage{times}
\usepackage{soul}
\usepackage{url}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{booktabs}
\usepackage{soul}
\usepackage{array}
\usepackage{microtype}
\usepackage{subfigure}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{xcolor}
\usepackage{enumitem}
\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage{amsthm}
\usepackage[symbol]{footmisc}
\usepackage[normalem]{ulem}
\newcommand{\cmark}{\ding{51}}\newcommand{\xmark}{\ding{55}}\newtheorem{theorem}{Theorem}


\title{Adversarial Deep Embedded Clustering:\\on a better trade-off between\\Feature Randomness and Feature Drift}

\author{
  Nairouz Mrabah\\
  Department of Computer Science\\
  University of Quebec at Montreal\\
  Montreal, QC, Canada\\
  \texttt{mrabah.nairouz@courrier.uqam.ca} \\
\And
  Mohamed Bouguessa\\
  Department of Computer Science\\
  University of Quebec at Montreal\\
  Montreal, QC, Canada\\
  \texttt{bouguessa.mohamed@uqam.ca} \\
   \And
  Riadh Ksantini\\
  Department of Computer Science\\
  University of Windsor\\
  Windsor, ON, Canada\\
  \texttt{ksantini@uwindsor.ca} \\
}

\begin{document}
\maketitle

\begin{abstract}
Clustering using deep autoencoders has been thoroughly investigated in recent years. Current approaches rely on simultaneously learning embedded features and clustering the data points in the latent space. Although numerous deep clustering approaches outperform the shallow models in achieving favorable results on several high-semantic datasets, a critical weakness of such models has been overlooked. In the absence of concrete supervisory signals, the embedded clustering objective function may distort the latent space by learning from unreliable pseudo-labels. Thus, the network can learn non-representative features, which in turn undermines the discriminative ability, yielding worse pseudo-labels. In order to alleviate the effect of random discriminative features, modern autoencoder-based clustering papers propose to use the reconstruction loss for pretraining and as a regularizer during the clustering phase. Nevertheless, a clustering-reconstruction trade-off can cause the \textit{Feature Drift} phenomena. In this paper, we propose ADEC (Adversarial Deep Embedded Clustering) a novel autoencoder-based clustering model, which addresses a dual problem, namely, \textit{Feature Randomness} and \textit{Feature Drift}, using adversarial training. We empirically demonstrate the suitability of our model on handling these problems using benchmark real datasets. Experimental results validate that our model outperforms state-of-the-art autoencoder-based clustering methods.
\end{abstract}


\keywords{Unsupervised Learning, Deep Learning, Clustering, Autoencoders.}


\section{Introduction} \label{S:1}

The main focus of clustering is to partition the original data into clusters without using any supervisory signal. During the last decades, a plethora of clustering algorithms has been proposed to overcome three main challenges. The first challenge is the \textit{high-dimentionality} of the exiting real-world information. For example, a typical image has thousands of pixels. This characteristic makes the clustering task more difficult due to the well-known curse of dimensionality \cite{paper56}. The \textit{large amount} of data or big data, as popularized by the public community \cite{paper57}, constitutes the second challenge. Computationally, processing large-scale datasets is generally associated with time and memory overheads. Last but not least, the \textit{high-semantic} aspect of natural data makes clustering a more challenging task. For example, two images of cats may look nothing like each other from pixel-level although they belong to the same class. The high-semantic aspect of natural data can be explained by the compositional hierarchy of features \cite{paper20}. In that respect, it is well-know that high-level features are nothing than a combination of lower-level ones. To give an example in the case of visual data, edges are combined to construct motifs, which are the keystone for building objects. The same applies to speech and text datasets.

Classical clustering methods, such as, k-means \cite{paper14}, Gaussian Mixture Model \cite{paper47}, DBSCAN \cite{paper48} and Mean Shift \cite{paper15} are shallow models. They rely on computing distance-based similarities in the raw data-space or in the space where the handcrafted features live. However, features engineering is task-specific. Therefore, it is inappropriate to integrate such pre-processing task in the pipeline of a general-purpose clustering framework. Moreover, natural data (e.g., images and videos) have high-dimensional and high-semantic aspects. So, when dealing with such datasets, the conventional clustering approaches have limited performance as the computational time increases considerably. In addition, distance-based metrics computed in the raw data-space are unreliable for discovering semantic similarities. 



To address the curse of dimensionality, the original high-dimensional data should be projected in a low-dimensional feature space. While abundant literature revolves around unsupervised dimensionality reduction, there are two main families. The first one consists of the linear dimensionality reduction methods, such as, Principal Component Analysis \cite{paper49} and Factor Analysis \cite{paper50}. The second family is based on the assumption that the most pertinent information lies on a low dimensional manifold (not a linear subspace) \cite{paper52}. Multi-dimensional scaling \cite{paper51}, Isometric Feature Mapping \cite{paper52} and Hessian Eigen mapping \cite{paper53} are among the popular manifold dimensionality reduction techniques. Although the linear and non-linear methods aim to preserve substantial information, they are prone to discriminative information loss, which in turn decimates the clustering performance. 

Projected clustering \cite{paper82} and subspace clustering \cite{paper83} have gained popularity thanks to their ability to address the problem of high-dimensional data clustering, as they identify relevant dimensions that exhibit the cluster structure. Unlike pure dimensionality reduction techniques, these methods do not ignore the discriminative aspect. Yet, they are only effective when the data meets the linear subspace hypothesis, which is rarely the case for natural data. 

Differently, kernel k-means \cite{paper54} and spectral clustering \cite{paper12} map the data to non-linear manifolds. Nevertheless, the transformation capacity of these approaches is limited. They generally underfit the complexity and semanticity of real-world information. Added to that, their computational time usually grows considerably when processing large databases. 

The recent advancement in unsupervised representation learning \cite{paper17,paper5} based on deep neural networks gave birth to a new family of clustering strategies, known as deep clustering. The multi-layers architecture has become the natural choice when it comes to processing large, high-semantic and high-dimensional datasets for several reasons. First, backpropagation and Stochastic Gradient Descent (SGD) allow to update the network weights in a cheap way without the need to loop around the whole dataset, in every single iteration. That's why a neural network is well-adopted for analyzing large data. Second, the compositional nature of the data \cite{paper20} justifies the need to gradually extract higher semantic representations from one layer to another using non-linear projection. Finally, the number of neurons in the hidden layers defines the dimensionality of the embedded spaces. Hence, a deep architecture allows to reduce dimensionality if it is designed to have a low-dimensional latent space. In spite of the deep learning success in many supervised applications, leveraging the power of neural networks in performing data clustering is still an open problem.  



The most prominent deep clustering approaches rely on autoencoders \cite{paper27,paper28,paper29,paper30,paper31}. Some other deep clustering strategies harness an encoding architecture \cite{paper21,paper22,paper23,paper24,paper25,paper26} without a decoding network. However, dispensing with the decoder and clustering the data in a latent space just using pseudo-labels can mislead the training process. This is because pseudo-labels are primarily generated based on \textit{hypothetical} similarities, which generally underfit the semanticity of natural datasets. We call this problem \textit{Feature Randomness}. The rational of choosing auto-encoding as the standard deep clustering architecture can be imputed to the limited reliability of pseudo-supervision when used alone. The reconstruction allows to rebuild the input samples after encoding them in a low dimensional latent space. The ability to reconstruct a point from a low-dimensional representation suggests that the latent space captures the key factors of variations and similarities. Otherwise, it would be impossible to regenerate the data samples.

Autoencoder-based clustering approaches generally consists of a joint optimization process. The reconstruction cost is combined with a clustering-specific objective function.
Referring to the previous point, retaining the reconstruction cost during the clustering phase helps in reducing \textit{Feature Randomness} by blocking the encoder from generating random discriminative features. However, regularizing with the reconstruction end-to-end can lead to \textit{Feature Drift}. This problem emerges due to the natural trade-off between clustering and reconstruction. Put it differently, while latent clustering allows to group and separate the embedded samples by emphasizing within-cluster similarities and destroying between-cluster similarities, the reconstruction is associated with preserving all factors of similarities.

Meanwhile, Generative Adversarial Network (GAN) \cite{paper1} has shown great promise in learning complex natural data distributions. It allows to synthesize out-of-sample data points. Besides, it has been shown that GAN can obtain images with impressive visual quality \cite{paper18,paper32}. Apart from being a successful generative model, the adversarial training strategy has inspired several modern achievements on unsupervised representation learning \cite{paper5,paper6,paper7,paper9}. Although GAN does not come with an encoder out-of-the-box, some recent papers have suggested to extend the classical GAN framework to permit data encoding in a latent space, where the semantic factors of variations and similarities are better-emphasized \cite{paper6,paper7,paper10,paper8}. Nevertheless, it is still unclear to what extent the features learned, based on a deep generative model, can be useful for downstream discriminative tasks (e.g., classification and clustering). 

To address the aforementioned problems, we propose Adversarial Deep Embedded Clustering (ADEC). Our framework consists of eliminating the strong competition between embedded clustering and reconstruction without incurring a \textit{Feature Randomness} cost. This is done by getting the strong competition outside of a single network, while relying on a discriminator, in order to make sure that the embedded representations preserve the intrinsic data characteristics. Optimizing every objective function in a separate network , based on adversarial training, allows to reach a better trade-off between \textit{Feature Randomness} and \textit{Feature Drift}. Experimentation on real benchmark datasets shows the superiority of our framework, in terms of accuracy (ACC) and normalized mutual information (NMI). In a nutshell, the key contributions of this paper are:

\begin{itemize}
  \item Devising a new pretraing framework based on adversarially constrained interpolation and data transformation.
  \item Overcoming the clustering-reconstruction compromise based on an adversarial training strategy.
  \item Enhancing state-of-the-art autoencoder-based clustering by alleviating \textit{Feature Randomness} and \textit{Feature Drift}.
   \item Outperforming modern clustering models in terms of ACC and NMI on real benchmark datasets.
\end{itemize}

The rest of this paper has the following organization: Section 2 is devoted to related work. Section 3 presents an analysis of the trade-off between \textit{Feature Randomness} and \textit{Feature Drift}. In section 4, we present our methodology for tackling the \textit{Feature Randomness} and \textit{Feature Drift} problems. In Section 5, we show our experimental results. Finally, section 6 concludes the paper. 

\section{Related work}
To demonstrate the merit of our proposed framework, we provide a critical review of mainstream approaches related to our work. ADEC comes under the realm of deep clustering strategies. Furthermore, it is deemed to be part of the concerted effort to combine GANs and autoencoders. To this end, we shall review the existing deep clustering approaches and the unifying techniques of GANs and autoencoders. We should also review DEC \cite{paper27} and IDEC \cite{paper28} since they constitute our principal baselines. 



\begin{figure*}[ht]
\vskip 0.2in
\begin{center}
\centerline{\includegraphics[width=400pt, height=60pt]{images/deep_clustering_categories.png}}
\caption{The different deep clustering categories. The self-supervised loss  enforces reasonable general-purpose features and the pseudo-supervised loss  is used for clustering the embedded data.}
\label{fig:deep_clustering_categories}
\end{center}
\end{figure*}

\subsection{Deep Clustering}
In deep unsupervised learning, typically, there are two conceivable options to make up for the absence of supervisory signals. The first option consists of contriving a pretext task that encourages to learn general-purpose features. It is better known as self-supervision. For this case, labels are extracted from the input data. The intuition behind self-supervision is that the pretext task can not be solved efficiently without gaining a semantically high-level grasp of the input data. The obtained features can be used to outsource downstream tasks, such as, classification. There exists a wide variety of pretext tasks. Among them, the vanilla reconstruction, the denoising loss \cite{paper58}, the variational loss \cite{paper64}, the adversarial loss \cite{paper1}, predicting the location of image patches \cite{paper59}, predicting the permutations of a "jigsaw puzzle"\cite{paper61}, predicting unpainted image patches\cite{paper62}, and predicting image colorization \cite{paper63}. The second option consists of contriving a pseudo supervisory signal. Similar to self-supervision, the labeling is available within the data. However, for pseudo-supervision, labels are predicted. Therefore, they are not 100\% correct. In this paper,  denotes a self-supervised loss and  denotes a pseudo-supervised loss. 

A possible categorization of deep clustering methods can be imputed to the used loss functions and the way they are combined. Based on that, the existing models fall into three main categories. In Figure \ref{fig:deep_clustering_categories}, the framework of each category is illustrated. Within the actual context, the pseudo-supervised loss stands for the embedded clustering objective function, which can be any one of the typical clustering objective functions, such as, Gaussian Mixture Model (GMM) or k-means. As regards the self-supervised cost, reconstruction is commonly selected.

For the first category, the clustering is directly performed using a pseudo-supervised loss. However, the self-acquired labels are unreliable due to their hypothetical aspect. This can mislead the data grouping by learning non-representative features, which in turn deteriorates the discriminative ability of the model. Concisely, the main weakness of the methods affiliated with this category is \textit{Feature Randomness}. As part of this category, \textit{Yang et al.} proposed JULE \cite{paper22}, a deep recurrent framework that allows to perform agglomerative clustering and feature learning alongside with a unified triplet loss. The whole process is optimized end-to-end. However, one among the prominent downsides of JULE is the run-time overhead due to the recurrent framework. \textit{Chang et al.} proposed DAC \cite{paper23}, a framework that enables to cluster the data based on pairwise constraints. DAC has curriculum learning strategy, where only high-confidence training samples are selected. In another line of research, \textit{Hu et al.} proposed IMSAT \cite{paper26}, which consists of maximizing the mutual information between discrete predictions and their associated data points. The loss function of IMSAT is regularized by a self-augmented training term that allows to penalize the discrepancy between initial data and their geometrically transformed ones. DeepCluster \cite{paper24} is another framework intimately tied to this category. It alternates between two basic steps. First, the latent representations are clustered by k-means. Then, the obtained clustering assignments are fed to a convolutional neural network as supervisory signals to learn better features. It was mainly applied to large-scale datasets.

As for the second category, the network is pretrained using a self-supervised cost function. Then, the obtained latent features are finetuned by retraining using pseudo labels. Compared with the random initialization, pretraining with a self-supervised loss leads to improved initial features. Nevertheless, there is no correction mechanism to attenuate the noisy labels harm. Hence, \textit{Feature Randomness} is a strongly remaining concern for this category. As part of this category, DEC \cite{paper27} is the first deep clustering framework to follow a pretraining-finetuning strategy.

The third category consists of pretraining using a self-supervised cost function similar to the second category. However, their finetuning phases are different. In fact, the third category regularizes the pseudo-supervised objective function with a self-supervised one. The advantage of such a strategy is that it offers a mechanism to reduce \textit{Feature Randomness}. However, combining pseudo-supervision and self-supervision can lead to a strong competition between them. In order to balance the two cost functions, a hyperparameter is required. To give an example, \textit{Guo et al.} proposed IDEC \cite{paper28} and  \textit{Dizaji et al.} proposed DEPICT \cite{paper36}. Both models can be considered as extensions to DEC. They regularize the clustering loss with reconstruction during the finetuning phase. Therefore, the decoder is maintained throughout the whole training process. The main difference between them is that DEPICT utilizes a convolutional architecture, whereas IDEC leverages a fully-connected autoencoder. Apart from that, \textit{Yang et al.} proposed DCN \cite{paper29}. Compared with IDEC and DEPICT, DCN optimizes a latent k-means objective function. VaDE \cite{paper35} is another model from this category. Its variational auto-encoding architecture allows to impose a GMM latent distribution. Thanks to the reparameterization trick, VaDE can be optimized using backpropagation. In addition to clustering, VaDE can generate data samples. Even so, it is subjected to elevated computational complexity similar to all the other variational frameworks.





\subsection{Deep Embedding Clustering (DEC)}
DEC \cite{paper27} has two phases. The pretraining phase allows to learn low-dimensional embedded representations by training the autoencoder with vanilla reconstruction. Then, comes the clustering phase. First, the decoder is discarded. After that, the encoder is trained to jointly optimize the embedded representations and the clustering centers. For every training iteration, a soft clustering assignment  (\ref{eq:q_ij}) is computed based on the Student’s t-distribution.  represents an assessment of the  between the embedded data point  and the center .



The DEC loss function (\ref{eq:L_DEC}) is the Kullback Leibler divergence between the soft clustering assignment  and an auxiliary target distribution  (\ref{eq:p_ij}).





\subsection{Improved Deep Embedded Clustering (IDEC)}
IDEC \cite{paper28} has the same pretraining phase as DEC. The main difference between them is that IDEC is finetuned to minimize joint embedded clustering and reconstruction as described by (\ref{eq:L_IDEC}).



 stands for the reconstruction and  is in charge of balancing the two costs. The key idea of IDEC is to block the clustering loss from corrupting the feature space. However, we argue that combining embedded clustering and vanilla reconstruction gives birth to a strong competition between them (i.e., \textit{Feature Drift}). 

\subsection{Combining Autoencoders with GANs}
Interpolating data samples from the prior distribution, in the latent space of the generator, leads to realistic and semantically explainable variations \cite{paper18,paper32}. As a consequence of GAN effectiveness in capturing the semantic factors of variations, many researchers have studied the inverse mapping problem (i.e., projecting the data back in the embedded space) \cite{paper7,paper10,paper6,paper8}. As coupled with the generator, an encoder can potentially learn to produce latent high-semantic features from the initial data distribution. This can bring an important advancement in solving inverse problems (e.g., image inpainting and noise removal) and downstream discrimination tasks. Two of the most seminal contributions on combining the power of GANs with Autoencoders, are BiGAN \cite{paper7} and AAE \cite{paper10}. 

Although we use the same architectural components (i.e., Encoder, Decoder and Discriminator), our framework differs from the previous mentioned ones in several glaring aspects. First, our discriminator operates in the data space. In contrast, the critic of AAE processes samples from the latent space, while BiGAN framework concatenates a sample from the data space with its projection in the embedded space, before feeding it to the discriminator. Second, in BiGAN, the encoder and decoder can not directly communicate with each other. Therefore, the objective function of this approach does not have an explicit reconstruction cost. However, AAE and our model explicitly minimize the cycle cost. Unlike AAE, where both the encoder and decoder are trained to perform reconstruction, our encoder weights are frozen, while optimizing with respect to the cycle loss, in order to avoid drifting the features learned using the clustering loss. Moreover, in BiGAN and AAE, the encoder and decoder are trained jointly in competition with the discriminator network. However, in our framework, each network is trained separately. Furthermore, AAE and BiGAN are standard generative models. So, in order to allow sampling, they enforce the aggregated posterior to match an arbitrary prior. However, in our case, we do not impose any hypothetical prior distribution and the adversarial training strategy is introduced to tackle problems related to embedded clustering, that is, Features Randomness and \textit{Feature Drift}.

\section{Trade-Off Between Feature Randomness and Feature Drift}
In this section, we propose a mathematical formalism to characterize \textit{Feature Randomness} and \textit{Feature Drift}. We explain the identified problems and we shed light on the trade-off between them.

\subsection{Feature Randomness}
For a pseudo-supervised loss, the used labels are predicted based on a presumptive similarity metric. It then follows that part of the pseudo-labels mismatch the real ones. Zhang et al. \cite{paper66} showed empirically that standard deep neural networks can easily and perfectly fit completely random labels without any considerable time overhead, using the same hyperparameters and architecture as used for training with correct labels. This result suggests that a neural network has sufficient capacity to memorize the whole dataset even when there is little or no correlation between the training samples and their corresponding labels.

We call \textit{Feature Randomness} the training of a neural network using pseudo-labels. Put it differently, \textit{Feature Randomness} takes place when a significant portion of the true labels are substituted by random ones. At every iteration of a neural network optimization process, \textit{Feature Randomness} can be characterized by  (\ref{eq:delta_FR}).  is the cosine of the angle between the gradient of the unsupervised loss and the gradient of the real supervised loss w.r.t the network parameters .  denotes the true labels (100\% correct) and  denotes the pseudo-labels (partially correct).








Training with pseudo-labels deteriorates the generalization capacity of a neural network. In fact, it enforces learning features that emphasize similarities between uncorrelated data points. In order to reduce the harm of \textit{Feature Randomness}, a possible solution consists of adjusting the gradient of the pseudo-supervised loss  by another vector. The gradient of  is a candidate to be that vector for several reasons. First, it is well known that minimizing  generates reasonable general-purpose features. Second, the self-acquired labels for  are 100\% correct. Hence, minimizing  does not contribute to \textit{Feature Randomness}. Besides, self-supervision can be used to integrate relevant prior-knowledge. In Figure \ref{fig:fr_Ls}, we illustrate the role of the self-supervised objective function in adjusting the gradient of the pseudo-supervised one.  denotes the pretext-labels.
 


\begin{figure}[ht]
\vskip 0.2in
\begin{center}
\centerline{\includegraphics[width=300pt, height=80pt]{images/FR.png}}
\caption{Adjusting the gradient of the pseudo-supervised loss by the gradient of a self-supervised loss to better approximate the gradient of the true supervised loss.}
\label{fig:fr_Ls}
\end{center}
\end{figure}


\subsection{Feature Drift}
In the context of multi-objective optimization, two objective functions are said to be conflicting, if optimizing one of them in value degrade the other one. In such a case, the optimum should be computed, while taking into consideration the trade-offs between the competing objective functions. A solution is called non-dominated when there are multiple optima that jointly optimize the objective functions. These optima are considered equally valid in the absence of extra subjective information.

In the case of deep learning, we call \textit{Feature Drift} the optimization of a neural network's loss function whose secondary component (regularizer) \textit{strongly} competes with the main one.
This phenomenon can lead to a failure of the global learning process. The features learned based on the main cost function can be easily drifted by updating with respect to the secondary loss. To better understand this problem, Figure \ref{fig:competition} shows a simplistic illustration of \textit{Feature Drift}. In Figure \ref{fig:competition}.a, a linear combination of two strongly competing vectors  and  is pulling the ball. In Figure \ref{fig:competition}.b, the ball is pulled by another couple of forces  and , which are less conflicting. In both cases, the pulling forces are adjusted using a balancing positive coefficient . So, the resultant vector is equal to  for the first case and   for the second case. In this example, we consider that the pulling forces , , , and  are constants and the  coefficient is variable. After applying the resultant vector, the object is supposed to reach a position . In both figures, the colored area (delimited by the competing vectors) represents the field of possible positions after applying the resultant vector. The target solution lies within the green field. It is reasonable to predict that the smaller the area of the field, the easier to reach the target solution.
For two strongly competing vectors, we observe that the variation of  dramatically affects the reached position. Therefore,  the choice of  is quite critical for this case. Whereas, for the second case, where the competition is less ardent, the variation of  has a less important impact on the reached position. Hence, the choice of  is less crucial than in the first case. We conclude that the importance of a balancing coefficient depends on the level of competition. Most importantly, we observe that the level of competition can be assessed by the cosine of the angle between the two competing vectors. Hence, at every training iteration, we can characterize \textit{Feature Drift} as following:



Where  and  are the gradient of the pseudo-supervised loss and the gradient of the self-supervised loss, respectively. When the strongly contending vectors are not balanced meticulously, the desired solution would not be reached even after multiple iterations. Besides, it is of great importance to make unsupervised learning methods less reliant on unpredictable and dataset-specific parameters. The example presented by Figure \ref{fig:competition} was selected for its simplicity, since it is difficult to visualize the gradient vectors in a high-dimensional space.

\begin{figure}[ht]
\vskip 0.2in 
\centering
    \subfigure[Strong competition between  and .]{\includegraphics[width=200pt, height=120pt]{images/ft1.png}}
    \subfigure[Weak competition between  and .]{\includegraphics[width=180pt, height=120pt]{images/ft2.png}}
    \caption{Comparing the impact of strong and weak competition in reaching a target position.}
    \label{fig:competition}
\end{figure}

Several modern deep clustering models \cite{paper28, paper29, paper36, paper35} jointly perform reconstruction and embedded clustering. In this work, we show empirically that combining them leads to a very strong competition between their gradients. Under specific conditions, we provide a mathematical proof of this hypothesis. For this reason, we consider the problem of clustering a dataset  and X the matrix whose raw vectors are . We presume that the number of clusters . Our operators include a linear encoder , which maps samples from the data space to the latent space and a linear decoder  performing an inverse mapping. The matrices  and  hold the learnable parameters of the encoder and decoder, respectively. We define the vector   as the projection of the data point  in the latent space and  is the reconstructed representation of . We denote . Furthermore, we constrain  to the set of semi-orthogonal matrices. Thus, , where  is the identity matrix. Each cluster is associated with a centroid  in the embedded space , where ,   represents the cluster j and  is the number of points in . The center of the embedded points is denoted by . We define, , as the reconstruction loss, and , as the k-means loss in the latent space.





Let , be the average distance between two clusters  and . If  is equal to , this distance is called within-cluster distance, and defined by  and . Otherwise, it is called between-cluster distance, and defined by  and .



\begin{theorem}
Under the specific conditions described above, the loss function  can be expressed as following:



where 



\end{theorem}

The proof of Theorem 1 is provided in Appendix A. This theorem shows the implicit competition between a typical clustering loss (k-means) and the reconstruction one. Intuitively, minimizing the clustering loss has two objectives. First, it allows to emphasize the similarities between data points within the same cluster. Second, it enables to stress the variations between data points from different clusters. However, minimizing the reconstruction loss aims to preserve all the similarities and variances between every couple of data points, whether or not they belong to the same cluster. Using Theorem 1, we can notice that minimizing the first term of  leads to the maximization of between-cluster distances, which force the clusters to be separable. Added to that, minimizing the second and third terms of   minimizes within-cluster variances, which pushes the clusters to be as compact as possible. However, minimizing  implies minimizing both between-cluster distances and within-cluster variances.

In a general case, increasing  significantly causes the self-supervised loss to easily win the competition. Thus, any discriminative feature learned in the direction of the pseudo-supervised loss's gradient can be easily drifted by the gradient of the self-supervised loss. On the other side, decreasing  significantly leads to \textit{Feature Randomness}.

\section{Adversarial Deep Embedded Clustering}
In this section, we describe our proposed framework ADEC. Our model is designed to address \textit{Feature Randomness} and \textit{Feature Drift}. To this end, we consider the problem of clustering a dataset  into  clusters. Each cluster is associated with a centroid  in the embedded space , where . Our operators include a deep non-linear encoder , which maps samples from the data space to the latent space and a deep non-linear decoder  performing an inverse mapping.  and  represent the learnable parameters of the encoder and decoder, respectively. We define the vector  to be the projection of a data point  into the latent space and  is the reconstructed representation of . 

\subsection{Pretraining phase}
Following state-of-the-art autoencoder-based clustering approaches, we pretrain the encoder and decoder. In the context of deep clustering, pseudo-labels are the cluster representatives (i.e., embedded centers). It is important to start the clustering phase with latent features that reflect the data distribution. Otherwise, it would be impossible to extract meaningful pseudo-labels. Training a neural network using embedded centers extracted from completely random latent representations, leads to excessive \textit{Feature Randomness} (due to the large number of unreliable pseudo-labels). It is well-known that self-supervision allows to learn reliable general-purpose features by solving a pretext task. Therefore, the pretraining phase should consist of minimizing a self-supervised loss.

Previously proposed algorithms, such as, DEC and IDEC rely on a stacked denoising self-encoding strategy \cite{paper33} for initializing the training weights  and . In our case, we opted for pretraining the autoencoder using vanilla reconstruction loss regularized by an adversarially constrained interpolation \cite{paper5} and data augmentation (e.g., slight random rotation and translation of the input samples) \cite{paper34}. These techniques are backed up by results showing an important enhancement in learning unsupervised representations for downstream tasks \cite{paper5, paper34}. When pretraining the model, a real number  is randomly sampled to compute , such that,  is the reconstruction of a data point interpolated from the latent representations of  and . The framework of ACAI \cite{paper5} simulates a game competition between two adversarial networks. The autoencoder is trained to generate interpolated points. While the critic , which is a neural network parameterized by , enables to regress the interpolation parameter  in (\ref{eq:L_C}), the autoencoder aims to fool the critic into considering the generated interpolants as real samples (i.e., outputting ) in (\ref{eq:L_E_G}). The second term in (\ref{eq:L_C}) allows the critic to identify non-interpolated inputs. The coefficient , in (\ref{eq:L_C}), is randomly selected from  at every iteration and , in (\ref{eq:L_E_G}), is responsible for balancing the reconstruction and the regularization. For the sake of simplification, we assume that  stands for the data samples after carrying out the random transformations (rotation and translation). The full framework of our pretraining phase is illustrated in Figure \ref{fig:pretraining}. To the best of our knowledge, we are the first to propose such a pretraining strategy in the context of deep clustering.





\begin{figure}[ht]
\vskip 0.2in
\begin{center}
\centerline{\includegraphics[width=400pt, height=180pt]{images/acai_diagram.png}}
\caption{The pretraining phase of ADEC.}
\label{fig:pretraining}
\end{center}
\end{figure}

\subsection{Clustering phase}
For this phase, on top of the pretrained encoder and decoder, we need one additional network. More precisely, we introduce a Discriminator . Similar to the standard GAN framework, the Discriminator allows to identify real data samples from the fake ones. This network is parameterized with . Based on our experimental results, the feature learned by minimizing the embedded clustering objective function can be easily drifted, while minimizing the reconstruction loss. To inhibit this implicit strong competition from taking place, our strategy aims at transforming within-network competition to a different between-networks one. Therefore, each network is trained independently from the other ones to avoid the drifting effect. 

Training the encoder is the main step in our framework. The clustering loss in (\ref{eq:L_E}) is inspired by DEC
\cite{paper27}. It refines the clusters by gradually stressing high confidence assignments. It is worth to note that our methodology can be applied using a different embedded clustering loss. The choice of the DEC cost can be explained by its simplicity and popularity in the deep clustering community. Unlike DEC, we add a regularization term (second part of (\ref{eq:L_E})). Our regularization allows to penalize generating embedded features, which could not be decoded into realistic data points. This constraint is verified by the discriminator, leading to rejecting discriminative features, which corrupt the clustering space. Hence, we argue that minimizing (\ref{eq:L_E}) enables to reduce \textit{Feature Randomness}.



As shown by equation (\ref{eq:L_E}), our model does not require a balancing hyperparameter. Unlike IDEC, where the balancing hyperparameter is critical and hard-to-tune due to the strong trade-off, in our case, the clustering and regularization terms do not reflect any explicit competition. We would provide an experimental study on hyperparameter tuning to validate the aforesaid hypothesis. 

Unlike DEC, where the decoder is discarded straight away, this network plays a pivotal role in our case. It can be seen as a monitor. It allows to investigate the variations of the embedded representations induced by training the encoder. Hence, we argue that the decoder should be trained as well to catch-up with the encoder updates. However, training the decoder similar to IDEC would drift the discriminative features learned by the encoder. We propose to restrain the backpropagation of the reconstruction loss to the decoder layers as shown by equation (\ref{eq:L_G}). We argue that such a strategy helps in reducing \textit{Feature Drift}.



Unlike DEC and IDEC, we introduce a discriminator as an additional architectural component. As exhibited by equation (\ref{eq:V_D}), the discriminator is supposed to differentiate real data points from those generated randomly. Similar to the decoder, the discriminator should be sufficiently trained before updating the encoder weights at every clustering iteration. An illustration of the clustering phase is given by Figure \ref{fig:clustering_arc}.




\begin{figure}[ht]
\vskip 0.2in
\begin{center}
\centerline{\includegraphics[width=300pt, height=180pt]{images/adec_diagram.png}}
\caption{The clustering phase of ADEC.}
\label{fig:clustering_arc}
\end{center}
\end{figure}

At the end of the training process, we observe that the output images are smoother. Added to that, they do not represent a pure reconstruction anymore even if the decoder is trained for a huge number of iterations. This suggests that the encoder learned to destroy non-discriminative information. Another interesting observation is that the decoder maps images from the same class to the same blurry output image. This observation suggests that the encoder has learned to collapse within-class variances. Such characteristics of our model are inconsistent with IDEC pure reconstruction as illustrated by Figure \ref{fig:recons_ADEC_IDEC}. 

\begin{figure}[ht]
\vskip 0.2in
\begin{center}
\centerline{\includegraphics[width=\columnwidth, height=48pt]{images/output_images.png}}
\caption{First row: MNIST input images; Second row: Output images from IDEC; Third row: Output images from ADEC.}
\label{fig:recons_ADEC_IDEC}
\end{center}
\end{figure}

\subsection{Optimization}

ADEC has five kind of learnable parameters , , ,  and . All of them are updated using mini-batch SGD and backpropagation. ,  and  are, respectively, the stochastic mini-batch approximation of ,  and . The gradients are computed following Theorem \ref{theorem:gradient_z} and Theorem \ref{theorem:gradient_mu}. Refer to Appendix B and C for the proofs.

\begin{theorem} \label{theorem:gradient_z}
The gradient of the loss function  w.r.t the encoded data points  is calculated by (\ref{eq:gradient_z}), where  denotes the transpose Jacobian matrix of  and  is the gradient of . 
    
\end{theorem}

\begin{theorem} \label{theorem:gradient_mu}
The gradient of  w.r.t. to the cluster center  is computed following (\ref{eq:gradient_mu}).
    
\end{theorem}


For the clustering phase, we run the optimization for  batch iterations or until the clustering assignment variation between two consecutive clustering iterations is lower than . We found empirically that the decoder needs to be trained for a greater number of iterations compared to the other networks, otherwise it would cause instability. Thus, we alternate between training the \{Decoder , Encoder , Discriminator \} for  number of iterations and training the \{Decoder \} alone also for  auxiliary iterations. The target distribution , which is computed based on the predicted clustering assignment distribution , constitutes the support for computing the pseudo-labels.  is updated every  iterations based on equations (\ref{eq:q_ij}) and (\ref{eq:p_ij}). In practice, we refrain from bringing modifications on  at every single step to avoid instability. The predicted label  for a data point  is calculated based on the following equation: 



Our proposed algorithm is summarized in Algorithm \ref{alg:algorithm1}. 


\begin{algorithm}
\caption{Minibatch stochastic gradient descent training of Adversarial Deep Embedded Clustering.}
\label{alg:algorithm1}
\textbf{Input}: Input data: , Number of clusters: , Learning rate: , Convergence threshold: , Maximum iterations: , Auxiliary iterations: , Distribution update interval: .  \\
\textbf{Output}: Encoder weights: , Decoder weights: , Discriminator weights: , Embedded centroids: .
\begin{algorithmic}\STATE Pretrain the autoencoder by minimizing (\ref{eq:L_E_G}) and (\ref{eq:L_C}).
\STATE Pretrain the discriminator by maximizing (\ref{eq:V_D}).
\STATE Initialize the embedded centroids  using k-means.
\STATE  .
\FOR{i0 {\bfseries to} }
    \IF {()}
        \STATE Update  and  using (\ref{eq:q_ij}) and (\ref{eq:p_ij}).
        \STATE Save last predicted labels: .
        \STATE Compute the new predicted labels  using (\ref{eq:_ypred}).
        \IF {()}
            \STATE End training.
        \ENDIF
    \ENDIF
    \IF {()}
        \STATE .
        \STATE .
        \IF {()}
            \STATE .
        \ENDIF
    \ELSE
        \STATE  ( is computed using (\ref{eq:L_E})).
        \STATE  ( is computed using (\ref{eq:L_G})).
        \STATE  ( is computed using (\ref{eq:V_D})).
        \STATE .
        \STATE .
        \IF {()}
            \STATE .
        \ENDIF
    \ENDIF
\ENDFOR
\end{algorithmic}
\end{algorithm}

\section{Experiments}
An extensive experimental protocol is conducted to validate the suitability of ADEC in tackling \textit{Feature Randomness} and \textit{Feature Drift}. In order to perform this, we need to specify the scope of our experiments and the required experimental configurations. 

\subsection{Scope of experiments}
Deep Clustering models differ from each other in five substantial aspects. Each one of these aspects has been proved to have a significant impact on the clustering quality.
The first factor is the used \textit{architecture}. Some studies \cite{paper24, paper71} rely on sophisticated architectures (e.g., ResNet32, AlexNet and VGG) to cluster very large datasets. Other studies \cite{paper27, paper28} leverage fairly sized architectures to cluster sizeable datasets. Likewise, in this paper, we opted for the same architecture used by \cite{paper27, paper28, paper35, paper29}. The second factor is the integrated \textit{prior knowledge} (e.g. invariance of images' labels to small linear transformations and symmetries). For instance, previous works \cite{paper26, paper34} have proved that data augmentation based on prior knowledge leads to better clustering results. Inspired by these studies, we apply a similar data augmentation technique for image datasets.
The third factor of quality is the \textit{learning dynamics}. This was the focus of the following studies: (1) deep over-clustering \cite{paper71}, which offers two sub-heads, one for grouping the data in more clusters than required, and the second for clustering according to the ground truth number of clusters; (2) deep adaptive clustering \cite{paper23}, which clusters the easy samples first and then gradually supply the learning model with more difficult ones; and (3) clustering with a dynamic loss function \cite{paper72}, which gradually change the cost function according to the clustered samples. Unlike these papers, ADEC does not rely on any specific learning dynamics. Finally, the fourth and fifth factors consist in choosing the \textit{self-supervised} and \textit{pseudo-supervised} losses, respectively. \textit{Jabi et al.} \cite{paper73} proved that, under mild conditions, several pseudo-supervised objective functions are equivalent to each other.

All the previous deep clustering studies revolve around the five mentioned axes. The modification of any one of these factors is deemed to improve or worsen the effectiveness and efficiency of the studied deep clustering model. The following experimental protocol aims to show that the trade-off between \textit{Feature Randomness} and \textit{Feature Drift}, which was neglected by previous studies, is influential in designing deep clustering models. For this reason, our experiments should include a comparison, where all the other factors of quality are kept identical between ADEC and its baselines. 

\subsection{Experimental Settings}
All experiments are conducted on a server with 4 Intel(R) Xeon(R) CPU E5-2660 0 @ 2.20GHz, 32 GO RAM and a NVIDIA TESLA K80 GPU.

\subsubsection{Datasets}
We evaluate our approach on six benchmark datasets:

\begin{itemize}
    \item MNIST-full \cite{paper38}: a 10 classes database of  grayscale handwritten digit images of size  each. 
    \item MNIST-test: a subset of  images of the MNIST-full dataset. 
    \item USPS \cite{paper39}: a 10 classes  database of  grayscale digit images of size  each. 
    \item Fashion-MNIST \cite{paper40}: a 10 classes database of  grayscale images of size  each.
    \item REUTERS-10K \cite{paper69}: a 4 classes database (corporate/industrial, government/social, markets and economics) of  articles. The  most frequent words in all articles are selected. Then, for each article, we compute the TF-IDF features using the selected dictionary.
    \item Mice Protein \cite{paper70}: an 8 classes database of  mice samples. The features of this database consists of the expression levels of 77 proteins. 
\end{itemize}

All datasets are normalized before being fed to the clustering models, thereby the norm of each data point  is approximately equal to 1. For fully-connected models, we flatten the input data if its dimension is greater than one.

\subsubsection{Baselines}
In order to show the effectiveness of the proposed model, ADEC is compared against classical clustering algorithms, subspace clustering algorithms, manifold clustering algorithms, and state-of-the-art deep clustering algorithms. The classical clustering baselines include k-means \cite{paper14}, Gaussian mixture models (GMM) \cite{paper47}, Least Squares Non-negative Matrix Factorization (LSNMF) \cite{paper75} and agglomerative clustering (AC) \cite{paper74}. The subspace clustering methods include Scalable Sparse Subspace Clustering by Orthogonal Matching Pursuit (SSC-OMP) \cite{paper78} and Scalable Elastic Net Subspace Clustering (EnSC) \cite{paper79}. The other subspace clustering baselines are not efficient enough to deal with 70,000 samples and therefore they are left out. The manifold clustering approaches include normalized-cut spectral clustering (SC) \cite{paper76} and Kernel (RBF) k-means \cite{paper77}. Finally, the deep clustering algorithms include DeepCluster \cite{paper24}, JULE \cite{paper22}, SR-k-means\cite{paper73}, DEC \cite{paper27}, IDEC \cite{paper28}, DCN \cite{paper29}, VaDE \cite{paper35} and DEPICT \cite{paper36}. Our baselines also cover clustering the embedded data of an autoencoder using k-means and FINCH \cite{paper80} denoted, respectively, by (AE+k-means) and (AE+FINCH). As a side note, all the fully-connected baselines share the same architecture with ADEC. 

\subsubsection{Evaluation Metrics}
We adopt the metrics ACC \cite{paper41}, NMI \cite{paper42},  and  for assessing the clustering quality. The first two metrics are widely used to compare deep clustering methods. The third and fourth metrics are among the contributions of this work. ACC and NMI lie within the range  and  and  lie within the range . Higher values are better. As shown by (\ref{eq:acc}) and (\ref{eq:nmi}), ACC and NMI depend on  and , where  is a vector representing the predicted labels and  is the ground-truth labels vector.



 is selected from the set of all possible permutations mapping the predicted clusters to the ground-truth categories. The best matching can be found using the Hungarian Algorithm \cite{paper43}.



 denotes the entropy and  is the mutual information.

\subsubsection{Implementation}
The encoder has eight layers of dimensions  - 500 - 500 - 2000 - 10. Apart from the bottleneck layer, all the other ones are activated by ReLu \cite{paper44}. The decoder is an inverse mapping of the encoding layers 10 - 2000 - 500 - 500 -  with ReLu activations except for the last layer. We pretrain the autoencoder in competition with a critic for  iterations to perform data reconstruction constrained by an adversarially constrained interpolation. The learning weights are optimized using Adam \cite{paper45} with a learning rate equal to . , , and  (i.e., hyperparameters specific to Adam) have the respective values , , and . According to ACAI \cite{paper5} paper,  and  are set equal to  and , respectively. For the clustering stage, the encoder, decoder, and discriminator are trained alternatively for . The training is stopped before reaching the final iteration if the convergence criterion is met. This criterion is parameterized by a threshold .  We update the encoder, decoder and discriminator weights using SGD with a learning rate  and momentum . All backpropagation updates are performed on random batches of size 256 for both stages (i.e., pretraining and clustering). ADEC is implemented using Python and Tensorflow \cite{paper46}.
 
\subsection{Results}
Our experimental protocol has  three parts. In the first part, our model is compared with state-of-the-art clustering algorithms. In the second part, we analyse the ability of our model to tackle \textit{Feature Randomness} and \textit{Feature Drift}. In the last part, some qualitative results are exhibited. Before showing our results, we establish some useful notations. In all the following experiments: {-} indicates OUT\_OF\_MEMORY,  denotes the unsuitability of the algorithm to process one-dimensional data,  indicates that the pretraining phase does not support Data Transform and Adversarially Constrained Interpolation,  indicates that the pretraining phase does not support Data Transform, * indicates that the evaluated methods share the same pretraining weights, the same architecture, the same learning dynamics and the same clustering loss with ADEC.

\subsubsection{Comparing state-of-the art approaches}

Table \ref{table:ACC_NMI_comparison} illustrates the evaluation of several clustering approaches, including our proposed method, in terms of ACC and NMI. All baselines methods are tuned according to their default settings. First of all, we observe that state-of-the art subspace clustering algorithms, such as, SSC-OMP and EnSC are generally not suitable for clustering datasets with semantic similarities (e.g., images, text, sounds). In fact, subspace clustering presumes the data to lie in a union of low-dimensional linear subspaces. However, this assumption does not hold for datasets with clusters lieing near non-linearly shaped manifolds \cite{paper81}. Secondly, we observe that the manifold clustering approaches have better ACC and NMI values than the classical approaches on some datasets. In fact, for the manifold category, the selection of the non-linear transform is largely empirical. Particularly, no kernel space is sufficiently well-suited to effectively cluster any dataset. Thirdly, in most cases, we can see that deep clustering  models outperform all the other approaches by a huge margin. This observation confirms the suitability of deep clustering when it comes to clustering high-dimensional datasets. Finally, comparing among the deep clustering approaches, we can observe that our method provides the best results on every dataset. In terms of ACC and NMI, ADEC outperforms its state-of-the-art counterpart DEPICT by 2\% and 5\%, respectively. Worthy of note that DEPICT is the convolutional version of DEC with some minor modifications. In order to understand the outperformance of our approach, we need to conduct further experiments.

\begin{table}
  \caption{Comparison of the clustering performances in terms of ACC and NMI. The different clustering categories are separated by double horizontal lines. Best method in bold, second best emphasized.}
  \vskip 0.15in
  \begin{center}
  \begin{small}
  \begin{tabular}{|p{2.45cm}|c|c|c|c|c|c|c|c|c|c|c|c|}
    \hline
    {\textbf{Method}} & \multicolumn{2}{c|}{\textbf{MNIST-full}} & \multicolumn{2}{c|}{\textbf{MNIST-test}} & \multicolumn{2}{c|}{\textbf{USPS}} & \multicolumn{2}{c|}{\textbf{Fashion-MNIST}} & \multicolumn{2}{c|}{\textbf{REUTERS-10K}}& \multicolumn{2}{c|}{\textbf{Mice Protein}}\\
\cline{2-13}
    & \textbf{ACC} & \textbf{NMI} & \textbf{ACC} & \textbf{NMI} & \textbf{ACC} & \textbf{NMI} & \textbf{ACC} & \textbf{NMI} & \textbf{ACC} & \textbf{NMI} & \textbf{ACC} & \textbf{NMI} \\ \hline
    \textbf{k-means} & 0.532 & 0.500 & 0.546 & 0.501 & 0.668 & 0.627 & 0.474 & 0.512 & 0.522 & 0.313 & 0.342 & 0.252 \\ \hline
    \textbf{GMM} & 0.433 & 0.366 & 0.540 & 0.493 & 0.551 & 0.530 & 0.556 & 0.557 & 0.402 & 0.375 &  0.139 & 1.00 \\ \hline
    \textbf{LSNMF} & 0.540 & 0.455 & 0.550 & 0.463  & 0.575 & 0.551 & 0.549 & 0.523 & 0.596 & 0.361 &  \textit{0.497} & \textit{0.506} \\ \hline 
    \textbf{AC} & 0.621 & 0.682 & 0.695 & 0.711 & 0.683 & 0.725 & 0.500 & 0.564 & 0.526 & 0.365 &  0.294 & 0.211 \\ \hline \hline
    \textbf{SSC-OMP} & 0.309 & 0.315 & 0.413 & 0.450 & 0.477 & 0.503 & 0.100 & 0.007 & 0.402 & 0.008 & 0.152 & 0.078 \\ \hline
    \textbf{EnSC} & 0.111 & 0.014 & 0.603 & 0.591 & 0.610 & 0.684 & \textbf{0.629} & \textit{0.636} & 0.401 & 0.014 & 0.434 & 0.347 \\ \hline \hline
    \textbf{SC} & 0.656 & 0.731 & 0.660 & 0.704 & 0.649 & 0.794 & 0.508 & 0.575 & 0.402 & 0.375 &  0.298 & 0.268 \\ \hline
    \textbf{RBF k-means} & {-} & {-} & 0.560 & 0.523 & 0.629 & 0.631 & {-} & {-} & 0.499 & 0.288 &  0.363 & 0.269 \\ \hline \hline
    \textbf{AE + k-means} & 0.807 & 0.730 & 0.702 & 0.617 & 0.720 & 0.698 & 0.585 & 0.614 & 0.695 & 0.475 & 0.238  & 0.131\\ \hline
    \textbf{AE + FINCH} & {-} & {-} & 0.709 & 0.754 & 0.704 & 0.788 & {-} & {-} & 0.241 & 0.414 & 0.157 & 0.083 \\ \hline 
    \textbf{DeepCluster} & 0.797 & 0.661 & 0.854 & 0.713 & 0.562 & 0.540 & 0.542  & 0.510 &  &  &  &  \\ \hline
    \textbf{DCN} & 0.830 & 0.810 & 0.802 & 0.786 & 0.688 & 0.683  & 0.501 & 0.558 & 0.422 & 0.109 & 0.197 & 0.051 \\ \hline 
    \textbf{DEC} & 0.863 & 0.834 & 0.856 & 0.830 & 0.762 & 0.767 & 0.518 & 0.546 &  \textit{0.814} & \textit{0.598} & 0.184 & 0.026 \\ \hline
    \textbf{IDEC} & 0.881 & 0.867 & 0.846 & 0.802 & 0.761 & 0.785 & 0.529 & 0.557 & 0.790 & 0.550 & 0.196 & 0.037 \\ \hline
    \textbf{SR-k-means} & 0.939 & 0.866 & 0.863 & 0.873 & 0.901 & 0.912 & 0.507 & 0.548 &  &  &  &  \\ \hline
    \textbf{VaDE} & 0.945 & 0.876 & 0.287 & 0.287 & 0.566 & 0.512 & 0.578 & 0.630 & 0.793 & 0.521 & 0.139 & 1.00 \\ \hline
    \textbf{JULE} & 0.964 & 0.913 & 0.961 & \textit{0.915} & \textit{0.950} & \textit{0.913} & 0.563 & 0.608 &  &  &  &   \\ \hline
    \textbf{DEPICT} & \textit{0.965} & \textit{0.917} & \textit{0.963} & \textit{0.915} & 0.899 & 0.906 &  0.392 & 0.392 &  &  &  &  \\ \hline
    \textbf{ADEC} & \textbf{0.986} & \textbf{0.961} & \textbf{0.985} & \textbf{0.957} & \textbf{0.981} & \textbf{0.948} & \textit{0.586} & \textbf{0.662} & \textbf{0.821 } & \textbf{0.605 } &  \textbf{0.500 } & \textbf{0.604 } \\ \hline 
  \end{tabular}
  \label{table:ACC_NMI_comparison}
  \end{small}
  \end{center}
  \vskip -0.1in
\end{table}

\begin{table}
  \caption{Comparison of the clustering performances of DEC*, IDEC*, and ADEC in terms of ACC and NMI. Best method in bold, second best emphasized.}
  \vskip 0.15in
  \begin{center}
  \begin{small}
  \begin{tabular}{|p{2.45cm}|c|c|c|c|c|c|c|c|c|c|c|c|}
    \hline
    {\textbf{Method}} & \multicolumn{2}{c|}{\textbf{MNIST-full}} & \multicolumn{2}{c|}{\textbf{MNIST-test}} & \multicolumn{2}{c|}{\textbf{USPS}} & \multicolumn{2}{c|}{\textbf{Fashion-MNIST}} & \multicolumn{2}{c|}{\textbf{REUTERS-10K}}& \multicolumn{2}{c|}{\textbf{Mice Protein}}\\
\cline{2-13}
    & \textbf{ACC} & \textbf{NMI} & \textbf{ACC} & \textbf{NMI} & \textbf{ACC} & \textbf{NMI} & \textbf{ACC} & \textbf{NMI} & \textbf{ACC} & \textbf{NMI} & \textbf{ACC} & \textbf{NMI} \\ \hline
    \textbf{DEC*} & 0.971 & 0.929 & 0.968 & 0.920 & 0.963 & 0.910 & \textit{0.575} & 0.589 & \textit{0.814}  &\textit{0.598}  &  \textit{0.267}  & \textit{0.158} \\ \hline
    \textbf{IDEC*} & \textit{0.982} & \textit{0.952} & \textit{0.978} & \textit{0.944} & \textit{0.980} & \textit{0.946} & \textit{0.575} & \textit{0.631} & 0.790  & 0.550  & 0.188  & 0.033  \\ \hline
    \textbf{ADEC} & \textbf{0.986} & \textbf{0.961} & \textbf{0.985} & \textbf{0.957} & \textbf{0.981} & \textbf{0.948} & \textbf{0.586} & \textbf{0.662} & \textbf{0.821 } & \textbf{0.605 } &  \textbf{0.500 } & \textbf{0.604 } \\ \hline 
  \end{tabular}
  \label{table:fair_comparison}
  \end{small}
  \end{center}
  \vskip -0.1in
\end{table}

For a fair comparison with state-of-the-art deep clustering approaches, the baselines need to be reimplemented in a way to neutralize factors, which are out of this article scope. The new reimplemented models share the same deep clustering factors (i.e., architecture, learning dynamics, integrated prior knowledge and clustering loss) with ADEC. From Table \ref{table:ACC_NMI_comparison} and Table \ref{table:fair_comparison}, we can notice a considerable improvement in terms of ACC and NMI for the modified version of DEC and IDEC, comparatively to the original ones. More specifically, DEC* outperforms vanilla DEC by a huge margin. Similarly, IDEC* surpasses its standard counterpart significantly. The huge gap between the ordinary pretrained models (i.e., based on a simple reconstruction) and the modified ones, demonstrates the effectiveness of combining Adversarially Constrained Interpolation and Data Transformation, as a pretraining strategy. Furthermore, as we can see from Table \ref{table:fair_comparison}, ADEC* outperforms DEC* and IDEC*. This result suggests that ADEC offers a better trade-off between \textit{Feature Randomness} and \textit{Feature Drift}. This hypothesis will be further supported in the subsequent experiments.

In Table \ref{table:exec_time}, we report the execution time of different deep clustering methods. The comparison is limited to deep clustering models. Henceforth, we exclude all the other clustering categories due to their less competitive results as just demonstrated by the previous comparison in Table \ref{table:ACC_NMI_comparison}. As we can see in Table \ref{table:exec_time}, the run-time of ADEC is significantly higher than the execution times of DEC, IDEC, DCN and DeepCluster on all datasets. As it stands, these methods are more efficient than ADEC. However, we can also observe that the execution time of our method is on par with the execution times of DEPICT, SR-k-means and JULE. Interestingly, our algorithm is way faster than VaDE on all datasets. 

\begin{table}
  \caption{Comparison of the execution times (in seconds) of different deep clustering approaches.}
  \vskip 0.15in
  \begin{center}
  \begin{small}
  \begin{tabular}{|p{2.2cm}|c|c|c|c|c|c|}
    \hline
    {\textbf{Method}} & {\textbf{MNIST-full}} & {\textbf{MNIST-test}} & {\textbf{USPS}} &{\textbf{Fashion-MNIST}} & {\textbf{REUTERS-10K}}& {\textbf{Mice Protein}} \\ \hline
    \textbf{DeepCluster} & 1,375 & 74 & 64 & 1,250 & {-} & {-}\\ \hline
    \textbf{DCN} & 640 & 55 & 49 & 732 & 279 & 40 \\ \hline
    \textbf{DEC} & 693 & 58 & 53 & 2,384 & 105 & 22\\ \hline
    \textbf{IDEC} & 890 & 349 & 110 & 857 & 97 & 150\\ \hline
    \textbf{SR-k-means} & 14,872 & 1,657 & 1,655 & 4,551 & {-} & {-}\\ \hline
    \textbf{VaDE} & 123,000 & 15,000 & 13,000 & 120,000 & 105 & 15\\ \hline
    \textbf{JULE} & 12,500 & 3,247 & 2,540 & 13,100 & {-} & {-}\\ \hline
    \textbf{DEPICT} & 9,561 & 2,320 & 1,778 & 8,581 & {-} & {-} \\ \hline
    \textbf{ADEC} & 10,735 & 10,013 & 8,445 & 10,502 & 669  & 1,047 \\ \hline 
  \end{tabular}
  \label{table:exec_time}
  \end{small}
  \end{center}
  \vskip -0.1in
\end{table}

For fairness of comparison and in order to better assess the efficiency of our method, we run our algorithm against the modified versions of DEC and IDEC (same as the previous experiment). Based on Table \ref{table:exec_time} and Table \ref{table:fair_exec_time}, we can see that the run-time of DEC* and IDEC* are significantly higher than the execution times of vanilla DEC and vanilla IDEC, respectively. Therefore, we can conclude that DEC* and IDEC* are less efficient than DEC and IDEC, respectively. This conclusion can be explained by the long pretraining phase. Hence, the gain achieved by pretraining with an Adversarially Constrained Interpolation comes at the cost of a higher execution time. Another observation, DEC* and IDEC* are slightly faster than ADEC*. This is expected and it can be imputed to the adversarial training of our algorithm.

\begin{table}
  \caption{Comparison of the execution times (in seconds) of DEC*, IDEC* and ADEC.}
  \vskip 0.15in
  \begin{center}
  \begin{small}
  \begin{tabular}{|p{2.2cm}|c|c|c|c|c|c|}
    \hline
    {\textbf{Method}} & {\textbf{MNIST-full}} & {\textbf{MNIST-test}} & {\textbf{USPS}} &{\textbf{Fashion-MNIST}} & {\textbf{REUTERS-10K}}& {\textbf{Mice Protein}} \\ \hline
    \textbf{DEC*} & 9,667 & 9,092 & 7,692 & 10,840 & 53  & 639 \\ \hline
    \textbf{IDEC*} & 9,556 & 9,160 & 7,693 & 9,623 & 55  & 646 \\ \hline
    \textbf{ADEC} & 10,735 & 10,013 & 8,445 & 10,502 & 669  & 1,047 \\ \hline 
  \end{tabular}
  \label{table:fair_exec_time}
  \end{small}
  \end{center}
  \vskip -0.1in
\end{table}

\subsubsection{Feature Randomness and Feature Drift}
\label{Sec:Feature Randomness and Feature Drift}

In this section, our conducted experiments aim to show the ability of ADEC to reach a better trade-off between \textit{Feature Randomness} and \textit{Feature Drift}. Therefore, we perform an ablation of our adversarial mechanism. Instead of this mechanism, we regularize the clustering loss with vanilla reconstruction. The obtained model is IDEC*. Then, we compare ADEC with IDEC* in terms of  and . As mentioned earlier, both models share the same optimizer, the same pretraining phase and the same embedded clustering loss. The only difference between them is the regularization technique. 



The first experiment examines the impact of our adversarial mechanism in reducing \textit{Feature Randomness}. In this section, we show results for the MNIST dataset. Such results are representative of the general behavior of our approach and the same conclusion can be drawn on the other datasets. In Figure \ref{fig:Delta_FR_MNIST}, we draw the evolution of  for ADEC and IDEC* during training on MNIST. Based on this figure, we observe that the average values of  for ADEC is considerably higher than the one for IDEC*. A higher  value means that the gradient of ADEC is a better approximation to the supervised gradient. Hence, this experiment confirms that our adversarial regularization is more suitable for alleviating \textit{Feature Randomness} than vanilla reconstruction. 

\begin{figure*}[ht]
\vskip 0.2in
\centering
    \subfigure[ADEC.]{\includegraphics[width=0.45\linewidth]{images/FR_ADEC_mnist.png}}
    \subfigure[IDEC*.]{\includegraphics[width=0.45\linewidth]{images/FR_idec_mnist.png}} 
    \caption{ during training on MNIST.}
\label{fig:Delta_FR_MNIST}
\end{figure*}









The second experiment examined the impact of our adversarial mechanism in reducing \textit{Feature Drift}. In Figure \ref{fig:Delta_FD_MNIST}, we draw the evolution of  for ADEC and IDEC* during training on MNIST. Based on this figure, we observe that the values of  for IDEC* are always negative. This result confirms the strong competition between the gradient of the embedded clustering loss and the gradient of the reconstruction loss. Added to that, we observe that the average values of  for ADEC is considerably higher than the one for IDEC*. A higher  value indicates that the competition between the embedded clustering gradient and the reconstruction gradient is stronger than the competition between the embedded clustering gradient and the adversarial gradient. Hence, this experiment confirms that our adversarial regularization is more suitable for alleviating \textit{Feature Drift} than vanilla reconstruction. 

\begin{figure*}[ht]
\vskip 0.2in
\centering
    \subfigure[ADEC.]{\includegraphics[width=0.45\linewidth]{images/FD_ADEC_mnist.png}}
    \subfigure[IDEC*.]{\includegraphics[width=0.45\linewidth]{images/FD_idec_mnist.png}} 
    \caption{ during training on MNIST.}
\label{fig:Delta_FD_MNIST}
\end{figure*}



The third experiment examined the impact of \textit{Feature Drift} on the learning curves. In Figure \ref{fig:ACC_NMI_mnist}, we draw the learning curves of ADEC and IDEC*, in terms of ACC and NMI, during training on MNIST. Based on this figure, we observe that the learning curves of ADEC are not only above the learning curves of IDEC*, but also smoother. A zoom in to the learning curves of IDEC*, as illustrated by Figures \ref{fig:ACC_MNIST} and \ref{fig:NMI_MNIST}, shows noticeable fluctuations. However, zooming in to the learning curves of ADEC shows a smooth increase in both metrics. The observed fluctuations for IDEC* can be explained by the competition between the reconstruction and the embedded clustering.  



\begin{figure}
\centering
\begin{minipage}{.5\textwidth}
  \centering
  \includegraphics[width=200pt, height=150pt]{images/ACC_NMI_ADEC_IDEC_mnist.png}
  \caption{ACC and NMI during training on MNIST.}
  \label{fig:ACC_NMI_mnist}
\end{minipage}\begin{minipage}{.5\textwidth}
  \centering
  \includegraphics[width=200pt, height=150pt]{images/hyperparameter_idec.png}
  \caption{Sensitivity analysis for  during training on MNIST.}
  \label{fig:sensitivity_MNIST}
\end{minipage}
\end{figure}


\begin{figure}
\vskip 0.2in
\centering
    \subfigure[ADEC.]{\includegraphics[width=200pt, height=150pt]{images/ACC_ADEC_mnist.png}}
    \subfigure[IDEC*.]{\includegraphics[width=200pt, height=150pt]{images/ACC_IDEC_mnist.png}} 
    \caption{ACC during training on MNIST.}
\label{fig:ACC_MNIST}
\end{figure}

\begin{figure}
\vskip 0.2in
\centering
    \subfigure[ADEC.]{\includegraphics[width=200pt, height=150pt]{images/NMI_ADEC_mnist.png}}
    \subfigure[IDEC*.]{\includegraphics[width=200pt, height=150pt]{images/NMI_IDEC_mnist.png}} 
    \caption{NMI during training on MNIST-test.}
\label{fig:NMI_MNIST}
\end{figure}

The fourth experiment examined the impact of \textit{Feature Drift} on the sensitivity of the balancing hyperparameter . In Figure \ref{fig:sensitivity_MNIST}, we draw the learning curves of IDEC*, for different values of , during training on MNIST. In our experiments,  is selected from the following set . Based on the obtained results, we observe that only one value of the set ( = 0.01) yields an acceptable learning curve. All the other values make the learning curve drop significantly. Hence, we can conclude that IDEC* is very sensitive to the choice of . This result can be explained by \textit{Feature Drift} (the strong competition between the gradient of the self-supervised loss and the gradient of the pseudo-supervised loss). However, in our case, ADEC does not require any balancing hyperparameter.


\subsubsection{Qualitative results}

\begin{figure*}[ht]
\vskip 0.2in

\centering
    \subfigure[MNIST-full.]{\includegraphics[width=0.32\linewidth]{images/mnist_embedding.png}} 
    \subfigure[MNIST-test.]{\includegraphics[width=0.32\linewidth]{images/mnist-test_embedding.png}}
    \subfigure[USPS.]{\includegraphics[width=0.32\linewidth]{images/usps_embedding.png}} 
    \subfigure[Fashion-MNIST.]{\includegraphics[width=0.32\linewidth]{images/fmnist_embedding.png}}
    \subfigure[REUTERS.]{\includegraphics[width=0.32\linewidth]{images/reuters_embedding.png}}
    \caption{2D embedding subspace visualization to show the discriminative ability of ADEC.}
\label{fig:clusetrs_embedding}
\end{figure*}

In Figure \ref{fig:clusetrs_embedding}, the discriminative ability of ADEC is illustrated by projecting the data in a 2D latent subspace for different datasets. From this figure, we can see that the projected embedded data points are grouped in well-separated clusters.

\begin{figure*}[ht]
\vskip 0.2in
\centering
    \subfigure[MNIST.]{\includegraphics[width=0.45\linewidth]{images/mnist_hCImages.png}} 
    \subfigure[Fashion MNIST.]{\includegraphics[width=0.45\linewidth]{images/fmnist_hCImages.png}}
    \caption{Each row shows the top 10 high-confidence images from each cluster.}
\label{fig:top_cluster_images}
\end{figure*}

Figure \ref{fig:top_cluster_images} illustrates the top 10 high-confidence images from each cluster for two datasets, namely, MNIST and Fashion MNIST. In this figure, images are inserted in decreasing order from left to right according to their distance to their associated clustering centers. Every single row represents a different cluster.

\section{Conclusion}
In this article, we have proposed an Adversarial Deep Embedded Clustering algorithm. Our method enables to regularize the clustering loss in a way to alleviate \textit{Feature Randomness}. To overcome \textit{Feature Drift}, the strong clustering-reconstruction trade-off have been Eliminated. Empirical results have showed that ADEC outperforms state-of-the-art clustering methods in terms of ACC and NMI. Furthermore, our experimental studies have validated that ADEC offers a better trade-off between \textit{Feature Drift} and \textit{Feature Randomness}. For ADEC, similar to the most relevant deep clustering models, self-supervision and pseudo-supervision are combined linearly. It is very interesting to study other possible combinations and to find theoretical justifications. Besides, it is worthy to extend the scope of this work by using a more sophisticated architecture (e.g., ResNet32, AlexNet and VGG) to process higher semantic datasets.

\bibliographystyle{unsrt}
\begin{thebibliography}{10}

\bibitem{paper46}
Mart{\'\i}n Abadi, Paul Barham, Jianmin Chen, Zhifeng Chen, Andy Davis, Jeffrey
  Dean, Matthieu Devin, Sanjay Ghemawat, Geoffrey Irving, Michael Isard, et~al.
\newblock Tensorflow: a system for large-scale machine learning.
\newblock In {\em OSDI}, volume~16, pages 265--283, 2016.

\bibitem{paper50}
David~J Bartholomew, Fiona Steele, Jane Galbraith, and Irini Moustaki.
\newblock {\em Analysis of multivariate social science data}.
\newblock Chapman and Hall/CRC, 2008.

\bibitem{paper5}
David Berthelot, Colin Raffel, Aurko Roy, and Ian Goodfellow.
\newblock Understanding and improving interpolation in autoencoders via an
  adversarial regularizer.
\newblock {\em In International Conference on Learning Representations (ICLR)},
  2019.

\bibitem{paper47}
Christopher~M Bishop.
\newblock {\em Pattern recognition and machine learning}.
\newblock springer, 2006.

\bibitem{paper82}
Mohamed Bouguessa and Shengrui Wang.
\newblock Mining projected clusters in high-dimensional spaces.
\newblock {\em IEEE Transactions on Knowledge and Data Engineering},
  21(4):507--522, 2008.

\bibitem{paper32}
Andrew Brock, Jeff Donahue, and Karen Simonyan.
\newblock Large scale gan training for high fidelity natural image synthesis.
\newblock {\em In International Conference on Learning Representations (ICLR)},
  2019.

\bibitem{paper41}
Deng Cai, Xiaofei He, and Jiawei Han.
\newblock Locally consistent concept factorization for document clustering.
\newblock {\em IEEE Transactions on Knowledge and Data Engineering},
  23(6):902--913, 2011.

\bibitem{paper24}
Mathilde Caron, Piotr Bojanowski, Armand Joulin, and Matthijs Douze.
\newblock Deep clustering for unsupervised learning of visual features.
\newblock In {\em Proceedings of the European Conference on Computer Vision
  (ECCV)}, pages 132--149, 2018.

\bibitem{paper23}
Jianlong Chang, Lingfeng Wang, Gaofeng Meng, Shiming Xiang, and Chunhong Pan.
\newblock Deep adaptive image clustering.
\newblock In {\em Proceedings of the IEEE International Conference on Computer
  Vision}, pages 5879--5887, 2017.

\bibitem{paper9}
Xi~Chen, Yan Duan, Rein Houthooft, John Schulman, Ilya Sutskever, and Pieter
  Abbeel.
\newblock Infogan: Interpretable representation learning by information
  maximizing generative adversarial nets.
\newblock In {\em Advances in neural information processing systems}, pages
  2172--2180, 2016.

\bibitem{paper15}
Yizong Cheng.
\newblock Mean shift, mode seeking, and clustering.
\newblock {\em IEEE transactions on pattern analysis and machine intelligence},
  17(8):790--799, 1995.

\bibitem{paper51}
Trevor~F Cox and Michael~AA Cox.
\newblock {\em Multidimensional scaling}.
\newblock Chapman and hall/CRC, 2000.

\bibitem{paper54}
Inderjit~S Dhillon, Yuqiang Guan, and Brian Kulis.
\newblock Kernel k-means: spectral clustering and normalized cuts.
\newblock In {\em Proceedings of the tenth ACM SIGKDD international conference
  on Knowledge discovery and data mining}, pages 551--556. ACM, 2004.

\bibitem{paper65}
Chris Ding and Xiaofeng He.
\newblock K-means clustering via principal component analysis.
\newblock In {\em Proceedings of the twenty-first international conference on
  Machine learning}, page~29. ACM, 2004.

\bibitem{paper36}
Kamran~Ghasedi Dizaji, Amirhossein Herandi, Cheng Deng, Weidong Cai, and Heng
  Huang.
\newblock Deep clustering via joint convolutional autoencoder embedding and
  relative entropy minimization.
\newblock In {\em Computer Vision (ICCV), 2017 IEEE International Conference
  on}, pages 5747--5756. IEEE, 2017.

\bibitem{paper59}
Carl Doersch, Abhinav Gupta, and Alexei~A Efros.
\newblock Unsupervised visual representation learning by context prediction.
\newblock In {\em Proceedings of the IEEE International Conference on Computer
  Vision}, pages 1422--1430, 2015.

\bibitem{paper7}
Jeff Donahue, Philipp Kr{\"a}henb{\"u}hl, and Trevor Darrell.
\newblock Adversarial feature learning.
\newblock {\em In International Conference on Learning Representations (ICLR)},
  2017.

\bibitem{paper53}
David~L Donoho and Carrie Grimes.
\newblock Hessian eigenmaps: Locally linear embedding techniques for
  high-dimensional data.
\newblock {\em Proceedings of the National Academy of Sciences},
  100(10):5591--5596, 2003.

\bibitem{paper6}
Vincent Dumoulin, Ishmael Belghazi, Ben Poole, Olivier Mastropietro, Alex Lamb,
  Martin Arjovsky, and Aaron Courville.
\newblock Adversarially learned inference.
\newblock {\em In International Conference on Learning Representations (ICLR)},
  2017.

\bibitem{paper48}
Martin Ester, Hans-Peter Kriegel, J{\"o}rg Sander, Xiaowei Xu, et~al.
\newblock A density-based algorithm for discovering clusters in large spatial
  databases with noise.
\newblock In {\em Kdd}, volume~96, pages 226--231, 1996.

\bibitem{paper1}
Ian Goodfellow, Jean Pouget-Abadie, Mehdi Mirza, Bing Xu, David Warde-Farley,
  Sherjil Ozair, Aaron Courville, and Yoshua Bengio.
\newblock Generative adversarial nets.
\newblock In {\em Advances in neural information processing systems}, pages
  2672--2680, 2014.

\bibitem{paper28}
Xifeng Guo, Long Gao, Xinwang Liu, and Jianping Yin.
\newblock Improved deep embedded clustering with local structure preservation.
\newblock In {\em International Joint Conference on Artificial Intelligence
  (IJCAI-17)}, pages 1753--1759, 2017.

\bibitem{paper34}
Xifeng Guo, En~Zhu, Xinwang Liu, and Jianping Yin.
\newblock Deep embedded clustering with data augmentation.
\newblock In {\em Asian Conference on Machine Learning}, pages 550--565, 2018.

\bibitem{paper21}
Philip Haeusser, Johannes Plapp, Vladimir Golkov, Elie Aljalbout, and Daniel
  Cremers.
\newblock Associative deep clustering: Training a classification network with
  no labels.
\newblock In {\em Proceedings of the German Conference on Pattern Recognition
  (GCPR)}, 2018.

\bibitem{paper70}
Clara Higuera, Katheleen~J Gardiner, and Krzysztof~J Cios.
\newblock Self-organizing feature maps identify proteins critical to learning
  in a mouse model of down syndrome.
\newblock {\em PloS one}, 10(6):e0129126, 2015.

\bibitem{paper25}
Chih-Chung Hsu and Chia-Wen Lin.
\newblock Cnn-based joint clustering and representation learning with feature
  drift compensation for large-scale image data.
\newblock {\em IEEE Transactions on Multimedia}, 20(2):421--429, 2018.

\bibitem{paper26}
Weihua Hu, Takeru Miyato, Seiya Tokui, Eiichi Matsumoto, and Masashi Sugiyama.
\newblock Learning discrete representations via information maximizing
  self-augmented training.
\newblock In {\em Proceedings of the 34th International Conference on Machine
  Learning-Volume 70}, pages 1558--1567. JMLR. org, 2017.

\bibitem{paper39}
Jonathan~J. Hull.
\newblock A database for handwritten text recognition research.
\newblock {\em IEEE Transactions on pattern analysis and machine intelligence},
  16(5):550--554, 1994.

\bibitem{paper73}
Mohammed Jabi, Marco Pedersoli, Amar Mitiche, and Ismail~Ben Ayed.
\newblock Deep clustering: On the link between discriminative models and
  k-means.
\newblock {\em arXiv preprint arXiv:1810.04246}, 2018.

\bibitem{paper74}
Anil~K Jain.
\newblock Data clustering: 50 years beyond k-means.
\newblock {\em Pattern recognition letters}, 31(8):651--666, 2010.

\bibitem{paper71}
Xu~Ji, Joao~F Henriques, and Andrea Vedaldi.
\newblock Invariant information distillation for unsupervised image
  segmentation and clustering.
\newblock {\em arXiv preprint arXiv:1807.06653}, 2018.

\bibitem{paper35}
Zhuxi Jiang, Yin Zheng, Huachun Tan, Bangsheng Tang, and Hanning Zhou.
\newblock Variational deep embedding: An unsupervised and generative approach
  to clustering.
\newblock In {\em International Joint Conference on Artificial Intelligence
  (IJCAI-17)}, pages 1965--1972, 2017.

\bibitem{paper45}
Diederik~P Kingma and Jimmy Ba.
\newblock Adam: A method for stochastic optimization.
\newblock {\em arXiv preprint arXiv:1412.6980}, 2014.

\bibitem{paper64}
Diederik~P Kingma and Max Welling.
\newblock Auto-encoding variational bayes.
\newblock {\em arXiv preprint arXiv:1312.6114}, 2013.

\bibitem{paper43}
Harold~W Kuhn.
\newblock The hungarian method for the assignment problem.
\newblock {\em Naval research logistics quarterly}, 2(1-2):83--97, 1955.

\bibitem{paper57}
Doug Laney.
\newblock 3d data management: Controlling data volume, velocity and variety.
\newblock {\em META group research note}, 6(70):1, 2001.

\bibitem{paper20}
Yann LeCun, Yoshua Bengio, and Geoffrey Hinton.
\newblock Deep learning.
\newblock {\em nature}, 521(7553):436, 2015.

\bibitem{paper38}
Yann LeCun, Corinna Cortes, and CJ~Burges.
\newblock Mnist handwritten digit database.
\newblock {\em AT\&T Labs [Online]. Available: http://yann. lecun.
  com/exdb/mnist}, 2, 2010.

\bibitem{paper69}
David~D Lewis, Yiming Yang, Tony~G Rose, and Fan Li.
\newblock Rcv1: A new benchmark collection for text categorization research.
\newblock {\em Journal of machine learning research}, 5(Apr):361--397, 2004.

\bibitem{paper75}
Chih-Jen Lin.
\newblock Projected gradient methods for nonnegative matrix factorization.
\newblock {\em Neural computation}, 19(10):2756--2779, 2007.

\bibitem{paper44}
Andrew~L Maas, Awni~Y Hannun, and Andrew~Y Ng.
\newblock Rectifier nonlinearities improve neural network acoustic models.
\newblock In {\em Proc. icml}, volume~30, page~3, 2013.

\bibitem{paper14}
James MacQueen et~al.
\newblock Some methods for classification and analysis of multivariate
  observations.
\newblock In {\em Proceedings of the fifth Berkeley symposium on mathematical
  statistics and probability}, volume~1, pages 281--297. Oakland, CA, USA,
  1967.

\bibitem{paper10}
Alireza Makhzani, Jonathon Shlens, Navdeep Jaitly, Ian Goodfellow, and Brendan
  Frey.
\newblock Adversarial autoencoders.
\newblock {\em In International Conference on Learning Representations (ICLR)},
  2016.

\bibitem{paper72}
Nairouz Mrabah, Naimul~Mefraz Khan, and Riadh Ksantini.
\newblock Deep clustering with a dynamic autoencoder.
\newblock {\em arXiv preprint arXiv:1901.07752}, 2019.

\bibitem{paper12}
Andrew~Y Ng, Michael~I Jordan, and Yair Weiss.
\newblock On spectral clustering: Analysis and an algorithm.
\newblock In {\em Advances in neural information processing systems}, pages
  849--856, 2002.

\bibitem{paper61}
Mehdi Noroozi and Paolo Favaro.
\newblock Unsupervised learning of visual representations by solving jigsaw
  puzzles.
\newblock In {\em European Conference on Computer Vision}, pages 69--84.
  Springer, 2016.

\bibitem{paper62}
Deepak Pathak, Philipp Krahenbuhl, Jeff Donahue, Trevor Darrell, and Alexei~A
  Efros.
\newblock Context encoders: Feature learning by inpainting.
\newblock In {\em Proceedings of the IEEE conference on computer vision and
  pattern recognition}, pages 2536--2544, 2016.

\bibitem{paper49}
Karl Pearson.
\newblock Liii. on lines and planes of closest fit to systems of points in
  space.
\newblock {\em The London, Edinburgh, and Dublin Philosophical Magazine and
  Journal of Science}, 2(11):559--572, 1901.

\bibitem{paper18}
Alec Radford, Luke Metz, and Soumith Chintala.
\newblock Unsupervised representation learning with deep convolutional
  generative adversarial networks.
\newblock {\em In International Conference on Learning Representations (ICLR)},
  2016.

\bibitem{paper81}
Sam~T Roweis and Lawrence~K Saul.
\newblock Nonlinear dimensionality reduction by locally linear embedding.
\newblock {\em science}, 290(5500):2323--2326, 2000.

\bibitem{paper80}
Saquib Sarfraz, Vivek Sharma, and Rainer Stiefelhagen.
\newblock Efficient parameter-free clustering using first neighbor relations.
\newblock In {\em Proceedings of the IEEE Conference on Computer Vision and
  Pattern Recognition}, pages 8934--8943, 2019.

\bibitem{paper77}
Bernhard Sch{\"o}lkopf, Alexander Smola, and Klaus-Robert M{\"u}ller.
\newblock Nonlinear component analysis as a kernel eigenvalue problem.
\newblock {\em Neural computation}, 10(5):1299--1319, 1998.

\bibitem{paper31}
Sohil~Atul Shah and Vladlen Koltun.
\newblock Deep continuous clustering.
\newblock {\em arXiv preprint arXiv:1803.01449}, 2018.

\bibitem{paper76}
Jianbo Shi and Jitendra Malik.
\newblock Normalized cuts and image segmentation.
\newblock {\em Departmental Papers (CIS)}, page 107, 2000.

\bibitem{paper42}
Alexander Strehl and Joydeep Ghosh.
\newblock Cluster ensembles---a knowledge reuse framework for combining
  multiple partitions.
\newblock {\em Journal of machine learning research}, 3(Dec):583--617, 2002.

\bibitem{paper52}
Joshua~B Tenenbaum, Vin De~Silva, and John~C Langford.
\newblock A global geometric framework for nonlinear dimensionality reduction.
\newblock {\em science}, 290(5500):2319--2323, 2000.

\bibitem{paper8}
Ilya Tolstikhin, Olivier Bousquet, Sylvain Gelly, and Bernhard Schoelkopf.
\newblock Wasserstein auto-encoders.
\newblock {\em In International Conference on Learning Representations (ICLR)},
  2018.

\bibitem{paper56}
Kenneth~E Train.
\newblock {\em Discrete choice methods with simulation}.
\newblock Cambridge university press, 2009.

\bibitem{paper30}
Elad Tzoreff, Olga Kogan, and Yoni Choukroun.
\newblock Deep discriminative latent space for clustering.
\newblock {\em arXiv preprint arXiv:1805.10795}, 2018.

\bibitem{paper58}
Pascal Vincent, Hugo Larochelle, Yoshua Bengio, and Pierre-Antoine Manzagol.
\newblock Extracting and composing robust features with denoising autoencoders.
\newblock In {\em Proceedings of the 25th international conference on Machine
  learning}, pages 1096--1103. ACM, 2008.

\bibitem{paper17}
Pascal Vincent, Hugo Larochelle, Isabelle Lajoie, Yoshua Bengio, and
  Pierre-Antoine Manzagol.
\newblock Stacked denoising autoencoders: Learning useful representations in a
  deep network with a local denoising criterion.
\newblock {\em Journal of machine learning research}, 11(Dec):3371--3408, 2010.

\bibitem{paper33}
Pascal Vincent, Hugo Larochelle, Isabelle Lajoie, Yoshua Bengio, and
  Pierre-Antoine Manzagol.
\newblock Stacked denoising autoencoders: Learning useful representations in a
  deep network with a local denoising criterion.
\newblock {\em Journal of machine learning research}, 11(Dec):3371--3408, 2010.

\bibitem{paper40}
Han Xiao, Kashif Rasul, and Roland Vollgraf.
\newblock Fashion-mnist: a novel image dataset for benchmarking machine
  learning algorithms.
\newblock {\em arXiv preprint arXiv:1708.07747}, 2017.

\bibitem{paper27}
Junyuan Xie, Ross Girshick, and Ali Farhadi.
\newblock Unsupervised deep embedding for clustering analysis.
\newblock In {\em International conference on machine learning}, pages
  478--487, 2016.

\bibitem{paper29}
Bo~Yang, Xiao Fu, Nicholas~D Sidiropoulos, and Mingyi Hong.
\newblock Towards k-means-friendly spaces: Simultaneous deep learning and
  clustering.
\newblock In {\em Proceedings of the 34th International Conference on Machine
  Learning-Volume 70}, pages 3861--3870. JMLR. org, 2017.

\bibitem{paper22}
Jianwei Yang, Devi Parikh, and Dhruv Batra.
\newblock Joint unsupervised learning of deep representations and image
  clusters.
\newblock In {\em Proceedings of the IEEE Conference on Computer Vision and
  Pattern Recognition}, pages 5147--5156, 2016.

\bibitem{paper79}
Chong You, Chun-Guang Li, Daniel~P Robinson, and Ren{\'e} Vidal.
\newblock Oracle based active set algorithm for scalable elastic net subspace
  clustering.
\newblock In {\em Proceedings of the IEEE conference on computer vision and
  pattern recognition}, pages 3928--3937, 2016.

\bibitem{paper78}
Chong You, Daniel Robinson, and Ren{\'e} Vidal.
\newblock Scalable sparse subspace clustering by orthogonal matching pursuit.
\newblock In {\em Proceedings of the IEEE conference on computer vision and
  pattern recognition}, pages 3918--3927, 2016.

\bibitem{paper66}
Chiyuan Zhang, Samy Bengio, Moritz Hardt, Benjamin Recht, and Oriol Vinyals.
\newblock Understanding deep learning requires rethinking generalization.
\newblock {\em In International Conference on Learning Representations (ICLR)},
  2017.

\bibitem{paper63}
Richard Zhang, Phillip Isola, and Alexei~A Efros.
\newblock Colorful image colorization.
\newblock In {\em European conference on computer vision}, pages 649--666.
  Springer, 2016.

\bibitem{paper83}
Xiaofeng Zhu, Shichao Zhang, Yonggang Li, Jilian Zhang, Lifeng Yang, and Yue
  Fang.
\newblock Low-rank sparse subspace for spectral clustering.
\newblock {\em IEEE Transactions on Knowledge and Data Engineering}, 2018.

\end{thebibliography}
 


\newpage
\appendix

\section{Proof of theorem 1}

We start by computing: \\

And since \\

Therefore \\

The  function can be written as: \\

According to \cite{paper65}, the  function can be written as : \\

So we obtain \\


\section{Proof of theorem 2}

The loss function  can be written as: \\


Then, we compute  and  separately.


After substitutions, we have:



\section{Proof of theorem 3}

 and  play symmetric roles in the first part of , and the regularization part does not depend on . Therefore,


\end{document}
