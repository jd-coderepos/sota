\documentclass{llncs}
\pdfoutput=1
\setcounter{tocdepth}{3}
\usepackage{amssymb, amsmath, amsfonts}
\usepackage[T1]{fontenc}
\usepackage{lmodern} 

\DeclareMathOperator{\Receive}{receive}
\newcommand\Rec[3]{\Receive_{#1,#2} \left( #3 \right)}

\DeclareMathOperator{\EvReceive}{Receive}
\newcommand\EvRec[3]{\EvReceive_{#1,#2} \left[ #3 \right]}

\DeclareMathOperator{\Trust}{trust}
\newcommand\Tru[2]{\Trust_{#1,#2}}

\DeclareMathOperator{\Compute}{compute}
\newcommand\Comp[3]{\Compute_{#1} \left( #2 = #3 \right)}

\DeclareMathOperator{\EvCompute}{Compute}
\newcommand\EvComp[3]{\EvCompute_{#1} \left[ #2 = #3 \right]}

\DeclareMathOperator{\Checkk}{check}
\newcommand\Che[2]{\Checkk_{#1} \left( #2 \right)}

\DeclareMathOperator{\EvCheckk}{Check}
\newcommand\EvChe[2]{\EvCheckk_{#1} \left[ #2 \right]}

\DeclareMathOperator{\Verif}{verif}
\newcommand\Ver[2]{\Verif_{#1} \left( #2 \right)}

\DeclareMathOperator{\EvVerif}{Verif}
\newcommand\EvVer[2]{\EvVerif_{#1} \left[ #2 \right]}

\DeclareMathOperator{\Hass}{has}
\newcommand\Has[2]{\Hass_{#1} \left( #2 \right)}

\DeclareMathOperator{\EvHass}{Has}
\newcommand\EvHas[2]{\EvHass_{#1} \left[ #2 \right]}

\DeclareMathOperator{\Attest}{attest}
\newcommand\Att[2]{\Attest_{#1} \left( #2 \right)} 

\DeclareMathOperator{\EvAttest}{Attest}
\newcommand\EvAtt[2]{\Attest_{#1} \left[ #2 \right]}

\DeclareMathOperator{\Know}{K}
\newcommand\Kno[2]{\Know_{#1} \left( #2 \right)}

\DeclareMathOperator{\Xnow}{X}
\newcommand\Xno[2]{\Xnow_{#1} \left( #2 \right)}

\DeclareMathOperator{\Hashh}{hash}
\newcommand\Hash[1]{\Hashh \left( #1 \right)}

\DeclareMathOperator{\HHashh}{hhash}
\newcommand\HHash[1]{\HHashh \left( #1 \right)}

\DeclareMathOperator{\FF}{F}
\newcommand\F[1]{\FF \left( #1 \right)}


\begin{document}

\newtheorem{ttd}{Definition}
\newtheorem{ttt}{Theorem}
\newtheorem{ttl}{Lemma}
\newtheorem{tta}{Algorithm}
\newtheorem{ttc}{Corollary}
\newtheorem{ttp}{Property}


\mainmatter  

\title{Privacy by Design: On the Conformance Between Protocols and Architectures\protect\footnote{The final publication is available at link.springer.com (URL not yet available).}}

\titlerunning{Privacy by Design}
\author{Vinh-Thong Ta \and Thibaud Antignac}
\authorrunning{V.-T. Ta, T. Antignac}


\institute{\small INRIA, University of Lyon, France\\
\{vinh-thong.ta, thibaud.antignac\}@inria.fr}


\maketitle

\begin{abstract}
In systems design, we generally distinguish the architecture and 
the protocol levels. In the context of privacy by design, in the first case, 
we talk about privacy architectures, which define the privacy goals and 
the main features of the system at high level. In the latter case, we consider 
the underlying concrete protocols and privacy enhancing technologies  
that implement the architectures. In this paper, we address the question that 
whether a given protocol conforms to a privacy architecture and provide the 
answer based on formal methods. We propose a process algebra variant to define 
protocols and reason about privacy properties, as well as a mapping procedure 
from protocols to architectures that  are defined in a high-level architecture 
language. 
\end{abstract}

\section{Introduction} 
According to the definition provided in~\cite{bass:2012}, ``the architecture of a system is the set of [elements 
and their relations] needed to reason about the system''. In the context of privacy, the elements are typically 
the privacy enhancing technologies (PETs) themselves and the purpose of the architecture is to combine them to 
achieve the privacy requirements. Generally speaking, an architecture can be seen as the abstraction of a system 
since an architecture abstracts away the details provided by PETs (such as message ordering, timing, complex 
cryptographic algorithms, etc.). Architectures only capture the main functionalities that a system should 
provide, for instance, which computations and communications are to be performed by the components.

Works in privacy by design mainly focus on PETs rather than architectures.  
In the position paper \cite{Antignac:2014}, the authors addressed the problem of privacy by design at 
the architecture level and proposed the application of formal methods that facilitate a systematic architecture design. 
In particular, they provided the idea of \textit{the architecture language and logic}, a dedicated variant of epistemic logics~\cite{fagin:2004}, to deal with different aspects of privacy. Basically, an architecture is defined as a set of \textit{architecture relations}, which capture the computations and communications 
abilities of each component. For instance, a relation \textit{compute}(  ) specifies that 
a component  can compute a value  for . 
Nevertheless, since \cite{Antignac:2014} is a position paper, the language envisioned in the paper is 
mainly based on an introductory description. An extended version of this language is detailed in 
\cite{TM-STM2014}. 

In this paper, we address the major question that whether the integration or combination of several 
different PETs conforms to a particular architecture. One challenge we have to face is that due 
to the diversity of technologies and protocols, their combination can raise a huge number of 
scenarios. Moreover, architectures are defined in an abstract way, while concrete 
implementations are more detailed, and it is challenging to define a proper abstraction 
from a lower to a higher level. The goal of this paper is to provide answers to this question.  

Specifically, our main contributions are two-fold: first, we propose a modified variant of 
the applied -calculus \cite{fournet01mobile} for specifying the protocols related to PETs, 
and reasoning about the knowledge of components during the protocol run. Second, we propose a 
mapping procedure which defines the connection between the protocol specified in the calculus and 
the architecture defined in the architecture language. This mapping allows us to show whether a 
protocol (or a combination of protocols) conforms to a given architecture. To the best of our 
knowledge, this work is the first attempt that examines the connection between the two levels based 
on formal methods in the context of privacy protection. 

The paper is organized as follows: in Section \ref{sec:architectures}, we review the 
privacy architectures language (PAL) proposed in \cite{TM-STM2014}, which is a high-level language 
for specifying architectures and reasoning about privacy requirements in them. Sections \ref{sec:calc} 
and \ref{sec:extrarch} contain our contributions. The modified 
applied -calculus is given in Section \ref{sec:calc}. Section \ref{sec:extrarch} 
discusses the connection  between each calculus process and relation in PAL, as well as the definitions 
and properties of the conformance between the two levels. In Section~\ref{related} we review the most 
relevant related works.  Finally, we conclude the paper and discuss about the future works in 
Section \ref{sec:conclusion}. 


\section{Architecture Level}
\label{sec:architectures}

The language we review here is a simplified version of the one in \cite{TM-STM2014}.  
The functionality of a service is defined by , where  is a term 
and  represents a variable that can 
be either indexed () or unindexed (). Each  can be a single variable or an array of 
variables.  denotes a function, and 
 defines the iterative application of  to the variables in 
the array  (e.g.:  defines the summation of the variables in a given array). 

\small
\begin{tabbing}
    12345678901\= \kill
    \>  ::=   (, \dots, )   ();\ \ \ \ \ \ \ \ \ \ \ \  ::=   
\end{tabbing}
\normalsize

\small
\begin{tabbing}
    1234567890\=123\=1234\=12456789012345678901234567890123456789012345678901234567890123\= \kill
    \>  \> ::= \> \{\}\\
    \>  \> ::= \>     \\
    \>\>\>      \textit{Trust}\\ 
    \> \textit{Att} \> ::= \> 
\end{tabbing}
\normalsize

An architecture  is 
defined by a set of components , ,  
associated with the set of \textit{relations} . Each 
\textit{relation}  specifies a capability of the components. 
Subscripts  and  denote component IDs.   expresses the 
fact that  is a variable that component  initially has (i.e., an input variable of ). 
 expresses the possibility for  
to receive the variable  directly from , and optionally an attestation 
related to this variable. An attestation, defined by , 
captures a statement made by  on the set of equations. Each    in the 
set \{\} expresses the integrity of , stating that it equals to . 
 says that  can compute a variable defined by an 
equation   .  states 
that  can check the satisfaction of property . The property 
   in  is related to the same property in 
, namely when  computes    it can send an 
attestation on this.  says 
that  is able to successfully verify the origin of an attestation. Finally, 
 is used to express the fact that component  trusts , and 
this trust relation does not change during operations. Trust relations are pre-defined, 
and an attestation sent by  will be accepted by  after a successful verification  
only if  trusts . 
 
The semantics of an architecture is defined as its sets of compatible traces. A trace is a 
sequence of possible high-level events occurring in the system. Events can be seen as 
\textit{instantiated relations} of the architecture. 

\small
\begin{tabbing}
    12345678\=123\=1234\=12456789012345678901234567890123456789012345678901234567890123\= \kill
    \>  \> ::= \> \\
    \>  \> ::= \>     \\
    \>\>\>    
\end{tabbing}
\normalsize

To distinguish events from relations, we let events start with lowercase. For instance, 
event  captures the fact that  has the value  
for , and  expresses the fact that 
 performes the computation . The other events are interpreted based on their 
corresponding relations (see \cite{TM-STM2014} for details). 
An event trace  is  \textit{compatible} with an architecture , 
if in this trace, only events which are instantiations of components of the architecture can 
appear in  -- except for the \textit{compute} events. For the case of \textit{compute} events, besides the computation specified explicitly in the architecture, we also take into account the ``background'' computations (deduction) that can be performed by each component, based on the data it has. 
This deduction ability of each  is captured by its deduction system  \cite{TM-STM2014}. 
The semantics of events is based on the \textit{component states} and the \textit{global state} of 
the architecture, given as follows: 
\small
\begin{tabbing}
    1234567\=12345\=\kill
    \> \textit{State} \>  \textit{State}  \textit{State};\\
    123456\=123456\=\kill
    \> \textit{State} \>  (\textit{Var}  \textit{Val});\ \ \ \ \ \ \ \textit{State}   
\end{tabbing}
\normalsize

The state of a component (\textit{State}) is composed of a variable state (\textit{State}) and a property state (\textit{State}). \textit{State} assigns a value (which can be
undefined, ) to each variable. \textit{State} defines the set of properties 
 and  known by a component. 

In the sequel,  is used to denote the global state of the architecture 
 (state of the components ) 
defined on .  (  (, ))  
denotes the state of the component , where  and  
represent the variable state and property state of , respectively.  
The initial state of , denoted by , contains 
only the trust properties specified by the architecture. 
The semantics of an event trace is defined by the function , which 
specifies the impact of a trace of events on the states of the 
components, through the impact of each event on the states (defined by the function ). 

\small
\begin{tabbing}
    123456\=12345678901\=123\= \kill
     \>   \textit{Trace}  \textit{State}  \textit{State};\ \ \ \ \ \ \ \ \   \textit{Event}  \textit{State}  \textit{State};\\
    \>  (, )   (, (, ));\ \ \ \ \ \ \ \ \ \    
     (, )   ;\\ 
    \>  (   [([],
      \{  \})   ].
\end{tabbing}
\normalsize 
 
Due to lack of space we only present  for the compute event here, 
the full list can be found in \cite{TM-STM2014}. The notation  is used to 
denote a trace whose first element is  and the rest of the trace is , while 
 denotes the empty trace. Each 
event modifies only the state  of the component . A modification is expressed by 
 that replaces  and  of  by  
and , respectively. 
The effect of  is to set  to the evaluation of 
 based on the current variable state , which is denoted by 
. Event \textit{compute} also results in adding the knowledge 
about  to the property state . 
 
The semantics of an architecture  is defined as  
, where  is the set of compatible traces of .   
To reason about the privacy requirements of architectures, the \textit{architecture logic} is proposed in \cite{TM-STM2014}, which is based on the architecture language PAL.

\small
\begin{tabbing}
    1234567890\=12\=1234\=12456789012345678901234567890123456789012345678901234567890123\= \kill
    \>  \> ::= \>        
\end{tabbing}
\normalsize


This logic involves modality  that represents the epistemic knowledge~\cite{fagin:2004} 
of  about \textit{T}  \textit{T}. In the rest of the paper, we 
refer to  as an architecture property. 
The semantics  of a property  is defined as follows: 
\small
\begin{tabbing}
    123\=\kill
    \>1.        ,  \\
    \>2.          \\ 
    \>3.         ,    ,  : (  )  (  \\ 
    \>\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \  (  ), 
\end{tabbing}
\normalsize

\noindent where \textit{Eq} (\textit{Eq}) represents an equation    (  ). 
An architecture satisfies the  property if and only if  may 
obtain the value of all  in \textit{Range}() in at least one compatible execution trace. 
 holds if and only if no execution trace can lead to a 
state in which  gets any value of any . We note that  properties 
only inform on the fact that  can get or derive some values for the variables but they 
do not bring any guarantee about the correctness of  these values. Integrity requirements 
can be expressed using the property , which states that 
the component  knows the truth of the integrity property 
. 
In , compared to ,  represents the 
state at the end of a longer trace.
Finally,    and  
  capture that  can be 
deduced from   and , respectively.  

\textbf{Example Architecture}: Let us consider a very simple smart 
metering architecture which consists in the communication between two components: the meter () 
and the operator (). The goal of this architecture is to ensure that the operator will get the consumption 
fee for a given period and to be convinced that the fee is correct. The privacy requirement 
says that  must not obtain the consumption data. One possible design solution is that the meter passes directly the consumption data to the operator who will compute the fee:  

\small
\begin{center}
  \{for   [, \dots, ]: \textit{Has}(); \textit{Compute}(  ); 
\textit{Receive}(\textit{Attest}(  ), ); 
\textit{Verif}(\textit{Attest}(  )); 
\textit{Compute}(  ); \textit{Compute}(  
), \textit{Trust}\}. 
\end{center}
\normalsize

In the architecture , the meter initially has the (input) variable  that 
represents the array of  consumption data ,   [, \dots, ]. 
The meter is capable to compute each metered data () based on each consumption data (). Intuitively, 
in   ,   will get the value 
of  . Then, the operator will receive the metered data (), 
along with the attestation made by  on the integrity property   
. After verifying the received attestation with success, due to \textit{Trust} 
the operator knows that    . Then for each 
,  computes the tariff based on the function . Finally,  computes 
the summation of the  tariffs (i.e., array ) to get the fee for the period. 
The requirements of the architecture are modeled with the properties of the architecture logic. Namely, 
 specifies that  has (all) the fee, while 
 says that  must not have any consumption data. 
 fulfills the first requirement, but it does not satisfy the privacy requirement because  
based on \textit{Receive}(\textit{Attest}(   ), 
)  can obtain  from . 

\section{Protocol Level} 
\label{sec:calc}

To reason about the concrete implementations of an architecture, we propose a modified variant of the applied -calculus. 
We decided to modify the basic applied -calculus  \cite{fournet01mobile} because thanks to its expressive syntax 
and semantics, it is broadly used for security verification of systems and protocols (e.g., 
\cite{Fournet:2002}, \cite{Delaune:2008}, \cite{DongJP:2010}, \cite{Li:2009}, \cite{Delaune:2009}, \cite{BackesZero:2008}, 
\cite{Kremer:2005}).  
Our main goal is to modify some syntax and semantics elements of the applied -calculus, 
making it more convenient to find the connection between the calculus semantics and the interpretation of 
architecture relations. One of such modifications is the notion of component, which is characterized 
by three elements: (i) the internal behavior of the component; (ii) the unique ID assigned to the component; and (iii) 
the set of IDs of the components who are trusted by this component. Another reason why we cannot use 
the basic applied -calculus is that it focuses on reasoning about the information a 
Dolev-Yao attacker (who can eavesdrop on all communications) obtains. However, in our case we reason about 
the information that components can have, which are only 
aware of the communications they can take part in.

\subsection{Syntax of the Modified Applied -Calculus}
\label{sec:calcsyntax}
We assume an infinite set of \textit{names}  and  
\textit{variables} , and a finite set of  \textit{component identifiers} 
, where   . 
Terms are defined as follows:
\begin{tabbing}
    123456789012\=12\=1234\=\kill
    \>  \> ::= \> \ \ \ \  \ \   \ \  \ \ \ \  \ \  \ \  . 
\end{tabbing}
  
\noindent  The meaning of each term is given as follows:   
 models a communication channel.   
 represents a component ID (   if   ) that uniquely identifies a component. 
,  and  denote names, which model some kind of data (e.g., a random nonce, a secret key, etc.).  
Terms , ,  denote variables that represent any term, namely, 
any term can be bounded to variables. 
 is a function, which models 
cryptographic primitives, e.g., digital signature 
can be modeled by , where  
and  specify the message and the private key, respectively. Moreover,  
can also be used to specify verification functions (e.g., the signature 
check is modeled by function 
\textit{checksign}(\textit{sign}(, ), ), where 
 represents the public key corresponding to the private key ).  
  
We rely on the same type system for terms as in the applied -calculus \cite{fournet01mobile}. 
Due to lack of space, we omit the unimportant details of this type system, and 
leave it implicit in the rest of the paper. We assume that terms 
are well-typed and that substitutions preserve types (see \cite{ryan:2011} 
for details).

The internal operation of components is modeled by \textit{processes}. Processes 
are specified with the following syntax:

\small
\begin{tabbing}
    \=\kill
    \> , ,  ::=\ \ \ \ \ \ \ \ \ \ \ \ \ \ .\ \ \ \ \ \ .\ \ \ \ \ \ \\
    \>\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \  \textit{let}    \textit{in} \ \ \ \ \ \textit{if}  \textit{then} \ \ \ \ \ \textbf{0}.   
\end{tabbing}
\normalsize

Note that for simplicity we left out the infinite replication of processes, . As a result 
a protocol/system run consists of a finite number of traces. 

Process  sends the term  (where 
  (, )) on channel 
, and continues with the execution of .  
Process  models the attestation sending, where  
and the signature  are sent on . 

Process . waits for a term on channel  and then binds the 
received term to  in .   
Process . waits for a term  and its signature 
 on channel , which models the attestation reception. 

 behaves as processes  and  running (independently) in
parallel.     
A restriction  is a process that creates a new, bound name
, and then behaves as . The name  is called bound because it is available 
only to .    
Process  \textit{let}    \textit{in}  proceeds to  and binds
every (free occurrence of)  in  to . 
 
Process \textit{if}  \textit{then}  says that if 
   (with respect to the equational theory , discussed later) 
then process  is executed, else it stops.  
Its special case is \textit{if}   \textit{checksign}(, ) \textit{then} , which  
captures the verification of an attestation (i.e., signature  with key ). For message authentication and integrity protection purposes digital 
signature and message authentication code (MAC) are used. In this paper we 
only consider signature. 

Finally, the \textit{nil} process \textbf{0} does nothing and specifies process 
termination. 

\textbf{Components:} To make the connection between calculus processes and architecture 
relations more straightforward, we introduce the notion of components.  defines a component with the unique identifier 
, who trusts the components whose IDs are in the set , and whose behavior is 
defined by process . The trust relation can be either one-way or symmetric, for instance, 
 and  
represent components  and  who trust each other. The rationale behind this way of 
component specification is that the component IDs and the trust relation between them are 
pre-defined, and do not change during the protocol run (this is what we assumed at 
the architecture level). In addition, we assume that a trusted component will not become untrusted. 

\textbf{Systems:}
A \textit{system}, denoted by , can be an empty system with no component: ; 
a singleton system with one component: ; the parallel 
composition of components:   
, where  and  
may include  and , respectively; or a system with name restriction. To capture 
more complex systems, we also allow systems to be the parallel composition of sub-systems, 
  .
\begin{center}    
 ::=  \  \  \    . \end{center}

\noindent 
The name restriction  represents the creation of new name , such as secret keys, or a random 
nonce which are only available to the components in . 

\subsection{Semantics of the Modified Applied -Calculus}
\label{sec:calcsemantics}

In order to check the conformance between protocols and architectures, it suffices to consider  
the internal reduction rules of the calculus, which model the behavior of the protocol 
(without contact with its environment). Reduction rules capture the internal operations 
(e.g., \textit{let} or \textit{if} processes) and communications performed by components. We define 
and distinguish the following reduction rules:  
\small 
\begin{tabbing}
    \=123456789012345\=12345\=123\= \kill
    \> \textbf{(Reduction rules)}\\ 
    \=123456789\=1234567891234567890123\=12345678901\= \kill
    \> (Rcv) \> \small    \>  \>   ,   (, );\\\\
    \=123456789\= \kill
    \> (Rcv) \>   \ \ \  \\ 
    \>\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \   ;\\\\
    \=123456789\=12345678901234567890\=12345678901\= \kill
    \> (Verif) \> \ \ \  ,\\ 
    \>\ \ \ \ \ \ \ \ \ \ \ \ \ where \{, \}. Note:  accepts the attestation if   .\\\\
    \=123456789\=123456789012345678901\=123456789012\= \kill 
    \>(Check) \>  \>  \>  (  ,   \textit{checksign});\\\\  
    \=123456789\=1234567891234678901\=123456\= \kill
    \>(Comp) \> \>  \> , (   or , such that\\ 
    \>\ \ \ \ \ \ \ \ \ \ \ \ \ \    \textit{comp}(,\   ) when   \{\textit{sign}, \textit{checksign}\}, else   );\\\\  
    \=123456789\=1234567891234678901234\=1234567890\= \kill
    \> (Has) \> (.) \>  \> (.) ,\\\\
    \=123456789\=1234567890123456701234\=123456\= \kill
    \>(Error) \>  \>  \> \ \ \ \ (\textit{if}   );\\\\
   \=123456789\=123456789012345670123\=123456\= \kill
    \>(Par-C) \> \ \ \ \  then  \ \ \ \ ;\\\\ 
    \>(Res-C) \> \ \ \ \  then  \ \ \ \  , where\\
    \>\ \ \ \ \ \ \ \ \ \ \ \  \ \   \{\textit{comp}(, ), \textit{has}(, ), \textit{check}(, ), \textit{error}, \textit{ver}(, )\};\\\\ 
    \>(Par-S) \> \ \ \ \  then    \ \ \ \   ;\\\\ 
    \>(Res-S) \> \ \ \ \  then  \ \ \ \ , where\\
    \>\ \ \ \ \ \ \ \ \ \ \ \ \ \  can be , and \textit{rcv}(, , ), \textit{rcv}(, , ).
\end{tabbing}
\normalsize

\noindent Before defining the system states, we label each reduction relation 
(arrow) based on the name of the rule and the terms used in them. 
We adopt the notion of equational theory  from \cite{fournet01mobile}, \cite{ryan:2011}, 
which contains rules of form     , that define when two terms are equal. For instance,  the 
equational theory  may include rules for signature verification, decryption, MAC verification, etc. The 
meaning of each reduction rule is as follows: 

\begin{itemize}
\item 
Rule (Rcv) captures the communication between components  and . 
Namely,  sends value  for  on channel , which is received by . As a result, 
we get  that binds  to every free occurrence of  in . It is 
assumed that   (, ), which is treated as a special case. 
\item 
Rule (Rcv) deals with exchanging the message  and the signature 
 on channel , which models the reception of the 
attestation \textit{Attest}(\{  \}). As a result, we get  in which 
 and the signature are bound to  and , respectively. The reason that 
we distiguish (Rcv) from (Rcv) is because we want to make a clear distinction 
between the cases of receiving a message with and without an attestation. 

\item 
Rule (Verif) captures the case when after binding  and  to 
 and the signature , respectively, component  successfully verified 
the signature using the corresponding public key of , . 
We implicitly assume that  and  contain enough information for the 
receiver to identify the ``type'' of the received message (e.g., the consumption fee in smart metering systems). 
Rules (Rcv) and (Verif) together specify the scenario when 
 sends to  the value  for , with the signature that proves the integrity 
and the authenticity of  this message. Then, in case  trusts , it knows 
the truth about the integrity property   . 


\item 
Rule (Check) considers the case when two terms are equal in the check 
(with respect to the equational theory ), which leads to  as result. We assume that 
 is not the \textit{checksign} function, which is used for the attest verification.   

\item 
Rule (Comp) models the computation    performed by .
As a result, every free occurrence of  in  is given the value . 
In this rule we assume that  can be either a variable or a function (except for 
\textit{sign} and \textit{checksign}, because they are considered as parts of the attestation), 
but not a name. 

\item 
Rule (Has) deals with the case when  is a name. 
The name , either bound (with ) or free (without ), represents the value of . Here 
 is used to model the variable that  initially has to capture the input data 
coming from the environment (e.g., the consumption data in the smart metering).    

\item 
Rule (Error) specifies the case when two terms are not equal with respect to . As a result, 
the process will continue with the \textit{nil} process. 

\item 
Rules (Par-C) and (Res-C) say that the \textit{if} and \textit{let} reductions are 
closed under parallel composition and restriction within a component, respectively.   
Rules (Par-S) and (Res-S) capture that all the reductions are 
closed under parallel composition and restriction on systems, respectively.

\end{itemize}

Instead of referring to the trace of reductions  \dots 
 we will refer to the trace of the corresponding labels 
, \dots,  for the sake of clarity.         
 
\textbf{States of components and systems}: Let us consider a system  with  components. 
Let \textit{Label} be the set of all labels (   \textit{Label}) of the reduction 
relations defined above, and let \textit{LTrace} be the set of all possible label traces of . 
We define the functions ,  and  
that update the states of the components and the entire system.  and 
 are similar to  and  in PAL, but they are based 
on label traces and labels instead of traces of events and events.  takes 
as input the set of all the possible label traces of  and handle each trace with .
Let \textit{State} denote the 
set of global state of  and  an empty set of traces. Finally, in 
.\textit{tr} the label  is the prefix of the trace \textit{tr}.

\small
\begin{tabbing}
    \=12345678901\=123\= \kill
    \>   \{\textit{LTrace}\}  \textit{State}  \textit{State};\\
    \>   \textit{LTrace}  \textit{State}  \textit{State}; \ \ \ \ \ \ \    \ \ \ \ \ \ \  \ \ \ \ \ \ \  \ \ \ \ \ \   \textit{Label}  \textit{State}  \textit{State};\\ 
    \> (\textit{LTrace}, )    (\textit{LTrace}\{\textit{tr}\}, 
    (\textit{tr}, )); \ \ \ \  
    (, )   ;\\  
    \> (.\textit{tr}, )   (\textit{tr}, (, )); \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \  (, )  ;\\
    \> (, )  [(\{/\}, )  ];\\
    \> (  [(\{/\}, )  ]\\
    \> (, )  [(\{/\}, )  ]\\
    \> (,    [(\{\},   \{  \})  ]\\ 
    \> (, )  [(,   \{  \})  ] 
     if     \\
\> (, )  [(,   \{\{  \} if  \textit{Trust}   \})  ].
\end{tabbing}
\normalsize

We let  and  denote the state of component  and   
the global state that consists in the state of all components in the system, respectively.  
Each  is defined by the pair (, ), which is the 
variable state and the property state for component , respectively. In our calculus 
the variable state  is defined by the set of substitutions \{, 
\dots, \}, which captures the terms available to , as well as the values of each 
variable from the perspective of . \{/\} is a shorthand for 
(  \{/\})  \{/\}, if \{/\}  
 for some .  is the set of integrity properties (e.g.,   ) 
that captures the knowledge gained by  about these properties.  
 represents the evaluation of  based on , and 
     says that the evaluation of 
 and  in  are equal up to the equational theory .  
We also consider the state update that results after a failed check 
(namely, [/], where  denotes the error state), 
though we omit the formal details here to save space.  

\section{From Protocols to Architectures}
\label{sec:extrarch}   
In the sequel, we discuss how the corresponding architecture can be extracted based on a given protocol or system. 
Namely, given a protocol specified in our process calculus we define an extraction procedure that extracts 
the corresponding architecture relations. The extraction procedure is based on the application of a set of 
extraction rules that we define below. Each extraction rule specifies the connection between the traces of labels    
of a system and the corresponding architecture relation. We assume a (initial) system  which consists 
in the parallel composition of  components (for a finite ), namely,   . 
The corresponding architecture relations will be extracted based on the possible traces (i.e., the trace semantics) 
of . We emphasize that during the extraction of architectural properties we only consider the reduction traces to 
capture the communication between components, without considering the activity of the environment (i.e., the Dolev-Yao 
attacker). Formally, we do not take into account the labelled transitions known in the applied -calculus \cite{fournet01mobile}. The 
reason is that the architecture relations focus only on the abilities of the components and the communication 
between them.

An architecture does not not contain the \textit{Compute} relations for background computations. 
The situation is similar at the protocol level, where the protocol description specifies 
the basic computations and communications of the components, without involving the background computations. 
Hence, when extracting the architecture relations, it is sufficient to consider only the protocol description and its
corresponding reduction traces. The background computations will be taken into account when we discuss the 
mapping to the \textit{Has} architecture logic property for reasoning about the data that 
can be deduced by a component. 

Given a system  and the set \textit{LTrace} of (all) its possible label traces, we define the 
extraction function  that extracts the corresponding architecture based on 
\textit{LTrace}.  is interpreted similarly as . 
\textit{Rel} denotes the set of architectural relations of . Function  extracts 
a relation based on a label  and put it into . We use  to denote the set 
of the extracted relations so far. We have the following 
extraction rules:  
\small
\begin{tabbing}
    \=12345678901\=123\= \kill
    \>   \{\textit{LTrace}\}  \textit{Rel}  \textit{Rel};\\
    \>   \textit{LTrace}  \textit{Rel}  \textit{Rel}; \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \   \textit{Label}  \textit{Rel}  \textit{Rel};\\ 
    \> (\textit{LTrace}, )   (\textit{LTrace}\{\textit{tr}\}, (\textit{tr}, ));\ \ \ \ \ \  
    (, )   ;\\  
    \> (.\textit{tr}, )   (\textit{tr}, (, ));\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \  (, )  ;\\
    \>:\ \ \ (, )    \{\textit{Has}()\};\\
    \>:\ \ \ (, )    \{\textit{Receive}()\};\\
    \>:\ \ \ (, \textit{Compute}(  )  ) \\
    \>\ \ \ \ \ \ \ \ \ \   \{\}, where \textit{Att}  \textit{Attest}(\{  \});\\ 
    \>:\ \ (,     (  )\}, where   \{\textit{sign}, \textit{checksign}\};\\  
    \> :\ \ (, )      
     if     ;\\
    \> :\ \ (, \{\textit{Trust}, \textit{Receive}(\{\textit{Att}\}, )\}  ) \\ 
    \>\ \ \ \ \ \ \ \ \ \ \   \{\textit{Verif}(\textit{Att})\}, where \textit{Att}  \textit{Attest}(\{ = \});
\end{tabbing}
\normalsize

All the rules above capture the communication and computation abilities of each component during the protocol run and 
are defined based on the trace semantics. In contrast, the \textit{Trust} relations are extracted 
based on the syntax. The initial set of relations is   \{ if        ,   \}. The meaning of each rule is defined as follows:

\begin{itemize}
\item 
Rule  corresponds to the relation \textit{Has}(), which 
says that  initially has a value for . The name  represents an input data for  of .

\item 
 extracts the relation \textit{Receive}, and describes the case when   
receives a value  for  during the protocol run.  and  represent the systems before and after 
the communication between  and .  involves the possibility for  to receive 
the variable . 
 
\item 
 extracts the relation \textit{Receive}(\textit{Attest}(\{  \}), ), where \{  \} contains   , along with all the equations 
   computed by  in order to constitute . Intuitively, besides attesting   ,  attests the integrity of all the computations it performed in order to get .  includes the possibility for  to receive , and its signature . Assumption (  )   captures the fact that  is able to compute 
  , hence, it can make an attestation on this equation. 
   
\item 
Rule  corresponds to the relation \textit{Compute}, 
for the equations  =  or   . We do not extract the 
computations for signature and its verification since these computations are integrated within 
the \textit{Attest} relation. 

\item 
Rule  extracts the relation \textit{Check}. To be able to check an equation, a component 
must have the ability to perform the function required in the check and it should possess the 
required data during the protocol run. This is determined by the equational theory , which defines 
the checking abilities of a component. We do not extract \textit{Check} for signature 
check because it is considered as an attestation verification.

\item 
Rule  deals with the case when component  successfully verified the 
attestation sent by component . However, we get the corresponding relation 
\textit{Verif}(\textit{Att}) only in case    
(i.e.,  trusts ). The assumption \textit{Receive}(\textit{Att}, )  
 captures the fact that  has received (\textit{Att}, ).    
\end{itemize}

The extraction procedure starts with the initial system , then we follow the possible reduction traces from  and apply the extraction rules where possible. 
Although during the extraction
every possible label trace of the system is examined, due to the simplifications we made on the 
processes (e.g., infinite process replication is leftout), the number of traces is finite, 
hence, the extraction procedure will terminate. In the sequel, we let  denote 
the extracted architecture of  (i.e., the set of relations  when we have examined all the 
possible traces).  

\begin{ttd}  The state based semantics of a given system is  
defined as ()    \textit{State}   
\textit{tr}  , \textit{tr}, \textit{Init}  .     
\end{ttd}  

 is the initial state of the system  which contains only the 
\textit{Trust} relations in . We adopt the \textit{Has} properties used 
in PAL (Section \ref{sec:architectures}), and define their semantics based on the semantics 
of the calculus.    

\begin{tabbing}
    1234567890\=12\=1234\=\kill
    \>  \> ::= \>        
\end{tabbing}

\begin{ttd}\textbf{Semantics of property  for systems} 
\small
\begin{tabbing}
    123456789\=\kill
    \>1.        :   and  such that\\ 
    \> \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \     , where \textit{BoundTo}()  \\
    \>2.          and    \textit{terms}():\\ 
    \> \ \ \ \   such that 
        , where \textit{BoundTo}()  \\
    \>3.            ,  \\ 
    \>\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (  )  (  )  (  ).
\end{tabbing}
\end{ttd}
\normalsize

 satisfies the property  when  
during the system run,  can deduce or obtain a value  for .  
    means that  can deduce  based on  and the equational 
theory . \textit{BoundTo}()   captures the fact that this  has been bounded to  during the 
reduction trace (i.e.,  is the value of ).  satisfies  when  
cannot deduce or obtain any value  for . Finally, the deduction    and    are defined on the deduction system based on the equational theory .  

To compare  and , we define , the set of \textit{type-preserved} 
mappings from terms in the calculus to the terms in PAL:   
  
\{  ;   ; (, \dots, )   (, \dots, ); (, \dots, )  (),  = [, \dots, ]\}. 
It is important to emphasize  
that in each mapping, the result and its preimage must have the same type. Defining an explicit type 
system for terms is not in the scope of this paper. Here, we only provide general type matching 
requirements for the mapping rules, giving the reader an intuition about the mapping 
to understand the definitions given below. In , each ID  can be mapped to an ID 
; each  can be mapped to a  of the same type.   
(, \dots, ) can be mapped to (, \dots, ) if each (, ) pair 
has the same type, and the two functions return the same type, too. Similarly, (, \dots, ) can be mapped 
to () if they return the same type, and the array  contains  variables, such that each corresponding 
variable pair has the same type. In the sequel, 
we let  denote the application of the mapping  to 
the architecture . 

The property \ref{prop:deduction} discusses the connection between a system  and 
its extracted architecture  with respect to the \textit{Has} 
and \textit{K} logical properties ( and ). 

\begin{ttp}
\label{prop:deduction} 
Given a system  and its extracted architecture , 
for some ,  
we have that  , , ,  in  and  , , 
,   in , where   ,   , 
  ,        
\textbf{1.} \mbox{  } iff\ \  
  ; \textbf{2.} 
   iff \mbox{  \textit{Has}}; and  
\textbf{3.}    iff\ \  
  . 
\end{ttp} 

The first point of Property~\ref{prop:deduction} says that if the system  satisfies 
, then the extracted architecture  
of  satisfies , and vice versa. The second point is related 
to the privacy requirement capturing that when  satisfies 
\textit{Has}, the system  satisfies \textit{Has}, and 
vice versa. The third point is related to the integrity property stating that if in the system  component 
 knows   , then in the extracted architecture this component knows the corresponding 
  , and vice versa.  The proof is based on the semantics of the architecture and the state based 
semantics of the systems, as well as the correspondence between the deduction rules 
of the privacy logic and the equational theory  of the calculus.  
 
We give two conformance definitions 
between protocol and architecture, a \textit{strong} one and a \textit{weak} one.     
                          
\begin{ttd}
\label{def:satstr}
\textbf{Strong Conformance} Let us consider a system  and an architecture . 
We say that  strongly conforms to  up to     if\ \mbox{  such} that 
  .   
\end{ttd} 

In the strong case, we require that there exists a mapping  such that  
contains exactly the same relations as . 

\begin{ttd}
\label{def:satweak}
\textbf{Weak Conformance} Let us consider a system  and an architecture . 
We say that  weakly conforms to  up to  denoted   
 if    such that \mbox{  }, and   ,  such that  
    If   
\textit{Has} then   
.   
\end{ttd} 

Point (i.) of the weak case requires the more relaxed   . 
Point (ii.) says that for every  in the privacy requirement  
of the architecture,  cannot have any value  for  in the system  (where \{  \}  
).  

Next, we provide the state simulation and bisimulation definitions in order to formulate 
Properties \ref{prop:2} and \ref{prop:3} about the relationship between the states of a system and 
states of an architecture in case of weak and strong conformance.
 
\begin{ttd}
\label{def:stsim}
\textbf{State simulation}: Let us consider a system  and an architecture .  We say that    simulates    up to  (denoted by    ), if  , , ,  in , and  , , ,  in , such that   ,   ,   ,   ,     
\begin{itemize}
\item if  ,     , then    ,    \mbox{ } 

\item if  ,
        , then    ,         , and

\item if  ,         , then  ,          .    
      
\end{itemize}

\noindent Also, we write    if  simulates  up to , but with respect to only the pair , , where   .
\end{ttd}

Each point of Definition~\ref{def:stsim} captures the state simulation that  
results from the corresponding architecture relations. 
For example, the second point says that if  \textit{Compute}(  )   then 
 \textit{Compute}(  )  .         

\begin{ttd}
\label{def:stbisim}
\textbf{State bisimulation}: Given a system  and an architecture : 

1. We say that    and    simulate each other up to  \mbox{  }, 

\ \ \ \ if    and  
 . 

2. We say that    and    simulate each other up to  and the 

\ \ \ \ variable pair , ,   , if    and  
 .   
\end{ttd}

\begin{ttp} 
\label{prop:2}
Given a system  and an architecture , where    and \mbox{  }. We have that    iff   .
\end{ttp}

Property \ref{prop:2} says that when  strongly conforms to , then the states of  in  simulates 
the states of the corresponding component  in , and vice versa. 

\begin{ttp}
\label{prop:3} 
Given a system  and an architecture , where    and 
\mbox{  }. We have that    iff 
   and    , 
for all  in . 
\end{ttp}

Property \ref{prop:3} says that in case  weakly conforms to , then the states of  simulates 
the states of the corresponding component , and these states are bisimilar for all the variable pair 
(, ), such that  holds.
A consequence of Properties~\ref{prop:2} and \ref{prop:3} is that it is sufficient to show the state simulation and bisimulation to prove the weak and strong conformance properties. These two properties also 
capture the correctness of the mapping with respect to the weak and strong conformance definitions. 
The proof of Properties~\ref{prop:2} and \ref{prop:3} is based on the defined extraction rules and 
the correspondence between functions  of the architecture and  of the 
system.

\textbf{Example Conformance Check:} We check the conformance between an example protocol and the architecture 
 at the end of Section~\ref{sec:architectures}, with   . Let us consider the protocol  
description in which there are components  and  that refer to the meter and 
operator, respectively. The behavior of the meter is specified by the process . 
The operator is defined by the process  . 

\begin{tabbing}
    1\=\kill
       \textit{let}   \ \ \textit{in} ;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \   \textit{let}     \textit{in} ;\\
    \>    
    \textit{let}     \textit{in} ;\ \ \ \ \ \ \ \ \ \ \ \ \  
      . \textbf{0}.\\ 
    12\=\kill
      .\ .\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \     .  
\end{tabbing}

Due to lack of space, we use this very simple example to demonstrate the mapping procedure and the conformance 
check between  and . The initial relations set  is \{\textit{Trust}\}. 
The architecture relations corresponding to  can be extracted in the following steps: From the two reductions 

  
  
 
  
  
and rules ,  we have     \{\textit{Has}()\}  \{\textit{Compute}(  )\}. The \textit{let}-process in  has no effect on the extraction, while the channel synchronization will result in adding \textit{Receive}(\{  \}, ) to . Since  terminates right after receiving the attestation, the two \textit{Compute}  relations and \textit{Verif}(\textit{Attest}(\{  \})) cannot be extracted. 
This means that the system  does not conform to the architecture .    
  
\section{Related Works}
\label{related}
Dedicated languages have been proposed to specify privacy properties 
(e.g., \cite{barth:2006}, \cite{becker:2011}, \cite{jafari:2011}) but they are complex and not intended to be used at the architectural level. 
In \cite{TM-STM2014,Antignac:2014} the authors addressed the idea of applying formal 
methods to architecture design and proposed a simple privacy architecture   
language (PAL). 

On the other hand, there are also many works focusing mainly on the protocol level,  
providing formal methods for specifying and verifying protocols, as well as reasoning 
about the security and privacy properties (e.g., \cite{meadows:2003}, \cite{paulson:1998}, \cite{burrows:1990}). 
For this purpose, process algebra languages are the most favoured means in the literature, 
because they are general frameworks to model concurrent systems. 

In addition, among the process algebras, the applied -calculus (\cite{ryan:2011}, 
\cite{fournet01mobile}) is one of the most promising language in the sense that its syntax and semantics are more 
expressive than the others (e.g., \cite{pi}, \cite{spi}, \cite{csp}). It  
also have been used to analyse security and privacy protocols (e.g., in \cite{Fournet:2002}, \cite{Delaune:2008}, 
\cite{DongJP:2010}, \cite{Li:2009}, \cite{Delaune:2009}, \cite{BackesZero:2008}, \cite{Kremer:2005}).  However, we cannot use it directly for our purpose because for instance, it lacks syntax and semantics for 
modelling component IDs and trust relations. Some modifications and extensions of the 
applied -calculus are required, which we proposed in Section~\ref{sec:calc}.  

Finally, the definition of the architecture comes before the definition of the protocol 
in software development cycles. Therefore, we 
chose to make it possible to verify the conformance of a protocol described in our 
language to an architecture. We used the architecture language in \cite{TM-STM2014} 
for this purpose. Its main advantage is that (i) compared to informal 
pictorial methods, or semi-formal representations such as UML diagrams, it is more formal 
and precise, while (ii) compared to process calculi, it is more abstracted.  The 
architecture language PAL enables designers to reason at the level of architectures, 
providing ways to express properties without entering into the details of specific protocols.   

 
\section{Conclusions and Future Works}
\label{sec:conclusion} 
In this paper, we proposed the application of formal methods to privacy by design. 
We provided the mapping from the protocol level to the architecture level for checking 
if a given implementation conforms to an architecture and showed its correctness. 
For this purpose, we modified the applied -calculus and 
defined the connection between the semantics of the calculus and PAL. To the best of our 
knowledge, this is the first attempt at examining the connection between the protocol 
and the architecture levels in the privacy protection context. 
   
The calculus version and the mapping procedure we proposed in this paper are based on a simplified 
version of the architecture language. Indeed, we only consider the attestation on equation 
  . Moreover, our proposed calculus (and mapping) does not support the modelling of 
zero-knowledge proofs, as well as the posibility of spot-checks used in toll pricing systems.  
Hence, our method can only handle simple architectures and protocols at this stage. 
One future direction of our work is to extend the calculus to support 
these such extensions. 

\subsubsection{Acknowledgements.}
The authors would like to thank Daniel Le M\'etayer for his initial idea and valuable comments during this work. 
This work is partially funded by the European project PARIS/FP7-SEC-2012-1, the ANR project BIOPRIV, and 
the Inria Project Lab CAPPRIS. 

\bibliographystyle{splncs03}
\bibliography{references}


\end{document}