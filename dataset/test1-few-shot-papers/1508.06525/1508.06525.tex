
\documentclass[12pt]{article}
\usepackage[english]{babel}
\usepackage[utf8x]{inputenc}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage[x11names]{xcolor}
\usepackage[colorinlistoftodos]{todonotes}
\usepackage{comment}

\usepackage{amsmath,amsthm}  \usepackage{pst-node}        \usepackage[crop=off]{auto-pst-pdf} \def\Property{\ensuremath{\hat{P}}}  \usepackage[x11names]{xcolor}
\usepackage{todonotes}
\newcommand{\todosylvain}[1]{\todo[inline,color=LightBlue2]{\sf\small @Sylvain: #1}}
\newcommand{\todoraphael}[1]{\todo[inline,color=LavenderBlush2]{\sf\small @Raphaël: #1}}
\newcommand{\todosebastien}[1]{\todo[inline,color=Khaki1]{\sf\small @Sébastien: #1}}
\newcommand{\todotous}[1]{\todo[inline,color=yellow]{\sf\small #1}}

\newcommand{\imagevide}{\framebox(200,200){IMAGE}}

\newcommand{\AG}{\mbox{\bf AG\,}}
\newcommand{\EG}{\mbox{\bf EG\,}}
\newcommand{\AF}{\mbox{\bf AF\,}}
\newcommand{\EF}{\mbox{\bf EF\,}}
\newcommand{\AX}{\mbox{\bf AX\,}}
\newcommand{\EX}{\mbox{\bf EX\,}}
\newcommand{\EU}{\mbox{\bf EU\,}}
\newcommand{\E}{\mbox{\bf E\,}}
\newcommand{\G}{\mbox{\bf G\,}}
\newcommand{\X}{\mbox{\bf X\,}}
\newcommand{\F}{\mbox{\bf F\,}}
\newcommand{\A}{\mbox{\bf A\,}}
\newcommand{\U}{\mbox{\bf \,U\,}}
\newcommand{\W}{\mbox{\bf \,W\,}}
\newcommand{\V}{\mbox{\bf \,V\,}}
\newcommand{\CTL}{\mbox{CTL}}
\newcommand{\LTL}{\mbox{LTL}}

\newtheorem{thm}{Theorem}
\newtheorem{dfn}{Definition}
\newtheorem{cor}{Corollary}

 
\begin{document}

\begin{titlepage}

\newcommand{\HRule}{\rule{\linewidth}{0.5mm}} 
\center 

\textsc{\LARGE Universit\'{e} du Qu\'{e}bec \`{a} Chicoutimi}\0.5cm] \textsc{\large Laboratoire D'informatique Formelle}\0.4cm]
{ \huge \bfseries Runtime Enforcement With Partial Control}\1.5cm]


\begin{minipage}{0.4\textwidth}
\begin{flushleft} \large
Rapha\"{e}l \textsc{Khoury} \end{flushleft}
\end{minipage}
~
\begin{minipage}{0.4\textwidth}
\begin{flushright} \large
Sylvain \textsc{Hall\'{e}} \end{flushright}
\end{minipage}\2cm] 



\vfill 
\end{titlepage}


\begin{abstract}
This study carries forward the line of enquiry that seeks to characterize precisely which security policies are enforceable by runtime monitors. In this regard, Basin et al.\ recently refined the structure that helps distinguish between those actions that the monitor can potentially suppress or insert in the execution, from those that the monitor can only observe. In this paper, we generalize this model by organizing the universe of possible actions in a lattice that naturally corresponds to the levels of monitor control. We then delineate the set of properties that are enforceable under this paradigm and relate our results to previous work in the field. Finally, we explore the set of security policies that are enforceable if the monitor is given greater latitude to alter the execution of its target, which allows us to reflect on the capabilities of different types of monitors.
\end{abstract}

\section{Introduction}\label{sec:introduction}

Runtime monitoring is an approach to enforcing security policies that seeks to allow untrusted code to run safely by observing its execution and reacting as needed to prevent a violation of a user-supplied security policy.  This method of ensuring the security of code is rapidly gaining acceptance in practice and several implementations exist \cite{COSREVIEW12}.  One question seems to recur frequently in multiple studies: exactly which set of properties are \textit{monitorable}, in the sense that they are enforceable by monitors. Previous research has identified several factors that can affect the set of security policies enforceable by monitors. These include the means at the disposal of monitors to react to a potential violation of the security policy \cite{MoreEnforce}, the availability of statically gathered data about the target program's possible executions \cite{ChabotJournal,MoreEnforce}, memory and computability constraints \cite{fong,Computability2} etc.

One specific aspect that can have a considerable impact on the monitor's expressiveness is its ability to either suppress certain actions performed by the target program from occurring during the execution (while allowing the remainder of the execution to continue unaffected) or to insert additional events in an ongoing execution. These abilities, when available, extend the monitor's enforcement power considerably. Indeed, a lower bound on the enforcement power of monitors is given by Schneider \cite{enforceable} who shows that the set of properties enforceable by a monitor whose only possible reaction to a potential violation of the desired security policy is to abort the execution coincides with the set of safety properties. Conversely, Ligatti et al.\ \cite{nonsafetyJournal} consider the case of a monitor with an unlimited ability to delay  any event performed by the target program until it has ascertained that its occurrence in the execution would not violate the security policy.  In effect, the monitor is simulating the execution of the program until it is certain that the behaviour it has so far witnessed is correct.  When behaving in this manner, the monitor can enforce a vast range of security properties, termed the set of infinite renewal properties, which   includes all safety policies, some liveness policies and some policies that are neither safety nor liveness.

Yet, it may not be realistic to assume that the monitor has an unlimited ability to simulate the execution of the target program.
Indeed,  as Ligatti et al.\  \cite{nonsafetyJournal} point out: ``\textit{[O]ur model assumes that security automata have the same computational capabilities as the system that observes the monitor's output. If an action violates this assumption by requiring an outside system in order to be executed, it cannot be feigned (i.e., suppressed) by the monitor. For example, it would be impossible for a monitor to feign sending email, wait for the target to receive a response to the email, test whether the target does something invalid with the response, and then decide to undo sending email in the first place. Here, the action for sending email has to be made observable to systems outside of the monitor's control in order to be executed, so this is an unsuppressible action. [...] Similarly, a system may contain actions uninsertable by monitors because, for example, the monitors [...] lack access to secret keys that must be passed as parameters to the actions. In general, environmental factors beyond the control of the monitor may give rise to actions that are unsuppressible or uninsertable.}''
The set of infinite renewal should thus be seen as an upper bound to the enforcement power of monitors.

To this end, Basin et al.\ propose a middle ground \cite{enforceableRevisited}. They partition the set of possible program actions in two disjoint subsets: a set of controllable actions, which the monitor may freely suppress from the execution, and a set of observable actions, whose occurrence the monitor can only observe. This allows for a more precise characterization to the set of monitorable properties. Section \ref{sec:preliminaries} will discuss these concepts in more detail.

In Section \ref{sec:partial}, we further generalize this analysis by organizing the set of possible actions along a lattice that distinguishes between four types of atomic actions, namely \emph{controllable} actions (which a monitor can insert or block from an execution), \emph{insertable} actions (which a monitor can add to the execution but not suppress), \emph{suppressible} actions (the converse) and \emph{observable} actions (which the monitor can only observe). We then delineate the set of properties that are enforceable under this paradigm and relate our results to previous work in the field.

Finally, we explore in Section \ref{sec:equivalence} the set of security policies that are enforceable if the monitor is given greater latitude to alter the execution of its target, rather than be bounded to return a syntactically identical execution sequence if the original execution is valid. In particular, we consider a monitor which can \textit{add} any action into the execution, but cannot prevent any action from occurring if the target program requests it. We also consider a monitor can \textit{remove} potentially malicious actions  performed by the target program but cannot add any action to the execution. We show how both can be handled by our model by simply considering a different equivalence relation between traces.

\section{Preliminaries}\label{sec:preliminaries}

\subsection{Executions}
Executions are modelled as sequences of atomic actions taken from a finite or countably infinite set of actions .  The empty sequence is noted , the set of all finite length sequences is noted , that of all infinite length sequences is noted , and the set of all possible sequences is noted . Let  and  be two sequences of actions.
We write  for the concatenation of  and . We say that  is a prefix of  noted , or equivalently    there exists a sequence  such that . Let  be a sequence, we write acts  for the set of actions  present in . We write  for the residual of  with regard to , i.e. the set of sequence  s.t. . Finally, let ,  is  said to be a suffix of  iff there exists a  such that .

Following \cite{nonsafetyJournal}, if  has already been quantified, we freely write  (resp. ) as an abbreviation to  (resp. ).  Likewise, if  has already been quantified,   (resp. ) can be abbreviated as  (resp. ).

Let  be a sequence and  be an action, we write  for the left cancellation of  from , which is defined as the removal from  of the first occurrence of .  Formally:




Observe that .  Abusing the notation, we write  to denote the sequence obtained by left cancellation of each action of  from . Formally, . For example, .

A finite word  is said to be a subword of a word , noted , iff  and  with  and .  Let  be sequences form . We write  to denote the longest subword of  which is also a subword of . For any ,  denotes the last action of sequence .



\subsection{Security Policies and Security Properties}

A security policy  is a property iff it can be characterized as a set of sequences for which there exists a decidable predicate  over the executions of  iff  is in the policy \cite{enforceable}. In other words, a property is a policy for which the membership of any sequence can be determined by examining only the sequence itself \footnote{Security policies whose enforcement necessitates the examination of multiples execution sequences, such as noninterference policies, are not generally enforceable by monitors.}. Such a sequence is said to be \textit{valid} or to \textit{respect} the property. Since, by definition, all policies enforceable by monitors are properties, P and \Property\ are used interchangeably in our context. Additionally, since the properties of interest represent subsets of , we follow the common usage in the literature and freely use \Property\ to refer to these sets.

A number of classes of properties have been defined in the literature and are of special interest in the study of monitoring. First are {\it safety} properties \cite{safety}, which proscribe the occurrence of a certain ``bad thing'' during the execution. Formally, let  be a set of actions and  \Property\ be a property. \Property\ is a {\it safety} property iff


Informally, this states that any sequence does not respect the security property if there exists a prefix of that sequence from which any possible extension does not respect the security policy.   This implies that a violation of a safety property is irremediable: once a violation occurs, nothing can be done to correct the situation.

Alternatively, a {\it liveness} property \cite{defliv} is a property prescribing that a certain ``good thing'' must occur in any valid execution. Formally, for an action set  and a property \Property, \Property\ is a liveness property iff


Informally, the definition states that a property is a liveness property if any finite sequence can be extended into a valid sequence.

Another class of security properties that are of interest is that of {\it renewal} properties\cite{nonsafetyJournal}. A property is in renewal if every infinite valid sequence has infinitely many valid prefixes, while every infinite invalid sequence has only finitely many such prefixes. Observe that every property over finite sequences is in infinite renewal.  The set of renewal properties is equivalent to the set of response properties in the safety-progress classification \cite{safPro}.


It is often useful to restrict our analysis to properties for which the empty sequence  is valid. Such properties are said to be \textit{reasonable} \cite{nonsafetyJournal}.  Formally,


In the remainder of this paper, we will only consider reasonable properties.  Furthermore, in order to avoid having the main topic of this paper be sidestepped by decidability issues, will consider that  is decidable for all properties and all execution sequences. Likewise, we also consider that other predicates or functions over sequences are decidable.

\subsection{Security Property Enforcement}

Finally, we need to provide a definition of what it means to ``enforce'' a security property \Property.  A number of possible definitions have been suggested. The most widely used is effective enforcement \cite{MoreEnforce}. Under this definition, a property is effectively enforced iff the following two criterion are respected.
\begin{enumerate}
  \item Soundness: All observable behaviours of the target program respect the desired property, i.e.\ every output sequence is present in the set of executions defined by \Property.
  \item Transparency: The semantics of valid executions is preserved, i.e.\ if the execution of the unmonitored program already respects the security property, the monitor must output  an equivalent sequence, with respect to an equivalence relation .
\end{enumerate}

Syntactic equality is the most straightforward equivalence relation, and the one that has been the most studied in the literature.  It models the behaviour of a monitor that enforces the desired property by suppressing (or simulating) part of the execution, only allowing it to be output  when it has ascertained that the execution up to that point is valid. In section \ref{sec:equivalence}, we consider two alternative notions of equivalences, which can be used to characterize alternative behaviours on the part of the enforcement mechanism.
\subsection{Related Work}\label{sec:related}

Initial work on the question of delineating which security policies are or are not enforceable by monitor was performed by Schneider \cite{enforceable}. He considered the capabilities of a monitor that observes the execution of its target, with no knowledge of its possible future behaviour and no means to affect the target except by aborting the execution. Each time the target program attempts to perform an action, the monitor has to either accept it immediately, or abort the execution. Under these constraints, the set of properties enforceable by monitors coincides with the set of \textit{safety} properties.

Ligatti et al.\ \cite{editauto} extend Schneider's modelling of monitors along three axes:
\begin{enumerate}
\item According to the means at the disposal of the monitor to react to a potential violation of the security policy. These include truncating the execution, inserting new actions into the execution, suppressing some part of the executions or both inserting and suppressing actions
\item According to the availability of statically gathered data describing the target program possible execution paths
\item According to how much latitude the monitor is given to alter executions that already respect the security policy.
\end{enumerate}
By combining these three criteria, they build a rich taxonomy of enforceable properties, and contrast the enforcement power of different types of monitors.

Basin et al.\ \cite{enforceableRevisited} generalize Schneider's model by distinguishing between observable actions, whose occurrence the monitor cannot prevent, and controllable actions, which the monitor can prevent from occurring by aborting the execution.

The enforcement power of monitor operating with memory constraints is studied in \cite{fong}, \cite{TTD06-a,TTD06-b,TTD08} and \cite{beauquier}.

The computability constraints that can further restrict a monitor's enforcement power are discussed in \cite{Computability2,CompuARM}; that of monitors relying upon an \textit{a priori} model of the program's possible behaviour is discussed in \cite{ChabotJournal} and \cite{editauto}.

Falcone et al.\ \cite{safProEnf1,safProEnf3} show that the set of infinite renewal properties coincides  with the union of four of the 6 classes of the safety-progress classification of security properties \cite{safPro}. Khoury and Tawbi \cite{KhouryEquiv,KT2012} and Bielova et al.\ \cite{BielovaNordsec,WhatMeanArt,DBLP:conf/essos/BielovaM11} further refine the notion of enforcement by suggesting alternative definitions of enforcement. In \cite{runtimeResults} Ligatti and Reddy introduced an alternative model, the mandatory-result automaton.  This model distinguishes between the action set of the target and that of the system with which it interacts. This distinction makes it easier to study the interaction between the target program, the monitor and the system. A thorough survey of the question of enforceable properties by monitors is provided in \cite{COSREVIEW12}.

\section{Monitoring With Partial Control}\label{sec:partial}

The previous works each consider monitors where actions belong to particular sets. For example, Schneider's model assumes that all actions can be suppressed by the monitor; conversely, Ligatti et al.\ assume that all actions can be indefinitely delayed. Basin et al.\ propose a middle ground where every action can either be freely suppressed, or can only be observed. In this section, we define a generalized model of actions where each of these works becomes a particular case. We then study what properties are enforceable in this generalized model.

\subsection{A Lattice of Actions}

We organize the set of possible actions along a lattice that distinguishes between four types of atomic actions :  namely controllable actions (), insertable actions (), suppressible actions ( ---for delete) and observable actions (), as is shown in Figure \ref{fig:lattice}.
\begin{itemize}
  \item Controllable actions () are the basic actions such as opening a file or sending data on the network, which the monitor can either insert into the execution or prevent from occurring if they violate the security policy. In Ligatti's model, all actions are controllable.
  \item Insertable actions () can be added into the execution but not suppressed if they are present. An example of an insertable action is an additional delay before processing a request to bring it unto compliance with a resource usage policy. The monitor may add such actions to the execution sequence but cannot remove them if the target program executes them.
  \item Suppressible actions ( ---for delete) are those actions that the monitor can prevent from occurring, but cannot insert in the execution if the target program  does not request them. Sending an email, decrypting a file or receiving a user input are all examples of suppressible actions. In Schneider's model, all actions are suppressible.
  \item Observable actions  can only be observed by the monitor, which can neither insert them in the execution when they are not present  nor suppress them if they occur. In Basin et al.'s model, all actions are either suppressible or observable.
\end{itemize}

As the examples above illustrate, we believe that the lattice model we propose is a more realistic description of the reality encountered by the monitor, and will thus allow a more precise characterization of the set of enforceable properties.  Observe than the monitor may only abort the execution if the next action is in . Moreover, the sets  are disjoint and that the universe of possible program actions is .

\begin{figure}
\centering
\psset{nodesep=3pt}
\newpsstyle{DblDash}{linestyle=dashed, dash=1pt 1.5pt, doubleline}
\begin{psmatrix}[mnode=r,colsep=0.6,rowsep=0.5]
&[name=12] &\\
[name=21] &&[name=23] \\
&[name=32] &
\ncline{12}{21}
\ncline{12}{23}
\ncline{21}{32}
\ncline{23}{32}
\end{psmatrix}
\caption{The lattice of possible actions}
\label{fig:lattice}
\end{figure}


The following notation is useful for comparing different enforcement mechanisms. Let   be a universe of actions and let  be a lattice over the set  as described in section 2. Let   stand for a subset of possible execution sequences and let  be an equivalence relation. We write   -enforceable to denote the set of proprieties that are enforceable by a monitor when the set of possible sequences is  and the set of possible actions is organized alongside lattice .

Let  be a lattice as described above. We write  (resp. , , ) for the set   (resp. , , ) in .
We write  for the lattice where , ,  and  .
Let  and let ,
we write   to indicate the lattice  defined such that  and . In other words,  is the lattice built by moving only element   from set  to another , leaving all other sets unchanged.


\subsection{Enforceable Properties}

We begin by reflecting on the set of properties that are -enforceable, i.e.\ properties that are enforceable if the monitor is bounded to output any valid sequence exactly as it occurs (with syntactic equality as the equivalence relation between valid inputs and the monitor's output).  This is the enforcement paradigm that has been the most studied in the literature.  A monitor that seeks to enforce a property in this manner may take any one of three strategies, depending on the desired property and the ongoing execution, and the set of  -enforceable properties can be derived by combining the three.

First, using a model in which every action is controllable, Ligatti et al.\ argued that a monitor can enforce any reasonable renewal property by suppressing the execution until a valid prefix is reached at which point the monitor can output the suffix of the execution it has previously suppressed.  We generalized the definition of renewal as follows:


Observe that the definition now applies to all sequences in , rather than just to infinite sequences. The second half of the equation always evaluates to true if all the actions are controllable (Ligatti's model) and always evaluates to false if all the actions are suppressible or observable (Schneider or Basin's models).

Second, Ligatti et al.\ observe that a property is enforceable if there exists a prefix beyond which there is only one valid extension. In that case, the monitor can abort the execution and output that sequence. This allows some nonsafety properties to be monitored. Ligatti et al.\ refer to this case as the ``corner case'' of effective enforcement.  We generalize this case as follows:


Once again, observe that the equation restricts all sequences, rather than only infinite ones. This equation always evaluates to false in the Schneider-Basin model and the second conjunct always evaluates to true in Ligatti's model.

Finally, the monitor can simply abort the execution if it is irremediably invalid. This is a generalization of the set of safety properties to our framework.


The set of -enforceable properties  can now be stated. The definition is not simply the conjunction of the tree preceding set as it must take into account the possibility that enforcement might begin by suppressing and reinserting part of the execution, and then abort the execution using of one of the other methods.
\begin{thm}\label{thm:Master}

\end{thm}
\begin{proof}
See Appendix A for all proofs to theorems and corollaries.
\end{proof}

This definition narrows the set of monitorable properties somewhat, compared with previous work. For example, bounded availability is given in \cite{nonsafetyJournal} as an example of a monitorable policy. In fact, it is monitorable only if every action  that occurs between the acquisition and release of a protected resource is controllable. Likewise, the ``\textit{no send after read}'' property described in \cite{enforceable} is only enforceable if every action which might violate the property is deletable or controllable.

While the set-theoretic characterization of enforceable property is somewhat involved, an LTL property can characterize such properties.

\begin{thm}
Let \textit{valid} be a predicate identifying a valid sequence:

Let \textit{cc} be a predicate that identifies a sequence in the -corner case:

Let  be a predicate identifying a sequence ending on a controllable action, and \textit{D} a predicate that identifies a sequence ending on a deletable action:

Then we have:

\end{thm}



In this theorem, we assume that any execution sequence from  is possible. In other words, at each step of the execution, the monitor must assume that any action from  is a possible next action, or that the execution of the target program could stop. This is called the uniform enforcement context. The monitor often operates in a context where it knows that certain executions are impossible (the nonuniform context).
This situation occurs when the monitor benefits from a static analysis of its target, that provides it with a model of the target's possible behaviour.  We can adapt the above theorem to take into account the fact that the monitor could operate in a nonuniform context.

\begin{thm}

\end{thm}


We can now restate the results of previous research in our new formalism.
\begin{thm}
(from \cite{enforceable}) If  then enforceable is  Safety.
\end{thm}



\begin{thm}
(from \cite{nonsafetyJournal}) If  then enforceable is the union of Infinite Renewal  and the corner case.
\end{thm}


\subsection{Additional Results}
\begin{cor}\label{corr:1}
Let  be a lattice over a set of actions  as described above and let  and .
-enforceable    -enforceable.
\end{cor}




Corollary \ref{corr:1} indicates that the set of enforceable properties increases monotonically with the capabilities of the monitor. Thus, any effort made to improve the capabilities of the monitor to control its target is rewarded by a augmented set of enforceable security properties. Conversely, if every action from the set  is in , only the inviolable property is enforceable.

\begin{cor}
\label{cor:2} Let -enforceable .
\end{cor}


\section{Alternative Equivalence Relations}\label{sec:equivalence}

The above results apply only to the case of effective enforcement. This corresponds to the enforcement power of a monitor that  sometimes delays the occurrence of actions in its target, or abort its execution, but does not add additional actions or permanently suppress part of the execution sequence, allowing the remainder of the execution to continue.  Syntactic equality (and subclasses of that relation) is the only equivalence relation that has been extensively studied in the literature. This naturally does not exhaust the enforcement capabilities of monitors.  In this section, we explore alternative equivalence relations (that characterize alternative enforcement mechanisms) and  determine the set of enforceable properties for each.

\subsection{Subword Equivalence and Insertion enforcement}
\label{sect:subword}
The first alternative equivalence relation that we examine is subword equivalence, noted . This corresponds to the enforcement power of a monitor which can \textit{add} any action into the execution, but cannot prevent any action from occurring if the target program requests it. For example, the monitor can enforce a property stating that any opened file is eventually closed by adding the missing close file action before the end of the program's execution.  This model is interesting to understand the capabilities of certain types of inline monitors, that are injected into the program in the form of guards or run in parallel with their target, such as those based upon the aspect-oriented programming paradigm \cite{aop,DBLP:journals/toplas/BoddenLH12,DBLP:conf/rv/MeredithR10}.

Let , we write  , and designate by enforceable the set of properties that are enforceable when   is the equivalence relation and  is the original input. This is a very permissive equivalence relation, which in effect allows the monitor to insert any action or actions into the execution, and consider the transformed execution equivalent to the original  execution  () if all actions performed by the target program are still present.  While this equivalence relation may be too permissive to be realistic, it does allow us to deduce an upper bound to the set of policies enforceable under this paradigm.

We begin by considering the cases that occur when the monitor has only limited control over the action set. When the monitor can only suppress actions or abort the execution, the set of enforceable properties coincides with that of safety properties, since the the monitor is unable to take advantage of the permissiveness of the equivalence relation.
\begin{thm}
Let  .   -enforceable is the set of safety properties.
\end{thm}

Another interesting case occurs when the monitor cannot delay the occurrence of the actions present in the execution sequence, but can only react to them by inserting additional actions afterwards. In other words, any action output by the target program must be immediately accepted, but can be followed by other actions inserted by the monitor. An intuitive lower bound to the set of enforceable properties in this context is the intersection of renewal properties and liveness properties. That is, properties for which any invalid sequence can be corrected into a valid sequence with a finite number of corrective steps.  Additionally, some safety properties and some persistence properties are also enforceable. For example, the property   imposing that no two `a' actions occur consecutively is a safety property since an invalid sequence cannot be corrected by the insertion of any subsequent actions. However, the policy is -enforceable since the monitor can insert any action other than 'a' after the occurrence of each `a'  action to ensure the respect of the security property. What characterizes properties outside the intersection of renewal and liveness that are nonetheless -enforceable  is that there exists a property  in renewal  liveness such that the property of interest includes . In the case of the example above, the property  ``any  a action is immediately followed by some action different from a (or the end of sequence token)'' is a renewal property included in . The monitor can enforce the property  by enforcing .

\begin{thm}\label{thm:strictInsert}
Let  and let . If the monitor cannot delay the occurrence of actions performed by the target program, then  -enforceable   and  is infinite renewal  liveness.
\end{thm}


Allowing the monitor to insert a finite number of actions  before or after an action taken by the target program increases the set of enforceable  properties further. Consider for example the property \Property  stating that a \textit{write} action only be performed on a previously opened file. The property is a safety property, and falls outside the set of -enforceable properties defined in theorem \ref{thm:strictInsert} if the number of files is infinite. The property can be  -enforced  by a monitor that inserts the corresponding \textit{open} file action anytime the target program attempts to write to a file that has not yet been opened. More generally, if all actions are in the set , then a property  is enforceable iff there exists a property , s.t.  is in renewal and Liveness and for any action , and for any sequence  in , there is a sequence  in the residual of  with regard to  s.t. . In other words, if for any sequence in the subproperty  and for any possible action , there is a continuation  s.t.  contains . The monitor can -enforces such a property by appending a sequence from the residual containing any action requested by the target program.

\begin{thm}
Let  .   -enforceable iff there exists a property .
\end{thm}

The upper bound naturally occurs when all actions are controllable. We found it harder to give a specific upper bound to the set of enforceable properties.  Indeed, this set seems to include almost every properties, with the exception of a number of hard to define special cases. Observe that because the subword relation is reflexive, a monitor that enforces the property also enforces it. This equivalence relation is so permissive that only a few very particular cases seem unenforceable.

Observe that while this result indicates that the  security properties that are -enforceable are largely the same as those that are -enforceable, the manner of enforcement is quite different. -enforcement guarantees that  any valid sequence is output \textit{as is}, without any modification by the monitor. For invalid sequences, -enforceable ensures that the longest valid prefix is always output \cite{WhatMeanArt}.   -enforcement does not provide these guarantees. Instead, as seen above, for non-safety properties -enforcement can ensure that any action present in the original program is eventually output, whether the execution sequence is valid or not. -enforcement also evidently has a much reduced memory overhead, since this enforcement paradigm does not impose on the monitor that it keep in memory an indefinitely long segment of the execution trace, as -enforcement does. Since  memory constraints were showed in \cite{fong} to significantly affect the set of enforceable properties it is certain that once such constraints are taken into account, some properties will be found to be -enforceable but not -enforceable.

\subsection{Suppression Enforcement}

Another interesting enforcement paradigm is suppression enforcement \cite{MoreEnforce}, which occurs when the monitor can remove potentially malicious actions  performed by the target program but cannot add any action to the execution. In that case, the monitor's enforcement is bounded by the reverse subword equivalence, meaning that the monitor's output is a subword of the original sequence.  This enforcement paradigm is similar to the one described in \cite{runtimeResults}, where the monitor is interposed between the target program and the system. Any action requested by the target program is intercepted by the monitor which must accept or reject it, and allows us to pose an upper bound to this enforcement paradigm.

Let ,we write  . As was the case in section \ref{sect:subword}, this is a very permissive equivalence relation, which characterizes the behaviour of a monitor that can potentially \textit{suppress} any action or actions from the execution.  We write  for this equivalence relation where  is the original input.

We begin by determining an upper bound to the set, which occurs when every action is suppressible. In that case, every reasonable property is enforceable, simply by always outputting the empty sequence (or possibly the longest valid prefix). While this may not be a particularly useful enforcement, it does however serve as a useful upper bound to begin reflecting about the capabilities of different types of monitors. It also argues for a stronger notion of transparency, as discussed in\cite{KT2012}, which allows us to reason about the capabilities of monitor in a context that is more similar to that of a real-life monitor. Such monitors would normally be bounded with respect to the alterations that they are allowed to performed on valid and invalid executions alike.

\begin{thm}\label{thm:total}
If  then -enforceable = .
\end{thm}


\begin{cor}
Let  . -enforceable = -enforceable.
\end{cor}

\begin{cor}
Let  . -enforceable =
-en\-for\-ceable.
\end{cor}

A more interesting characterization occurs when we consider that some subset of  is unsuppressible. These may be actions that the monitor lacks the ability to suppress (such as internal system computations) or actions that cannot be deleted without affecting the functionality of the target program. When that is the case, a property is enforceable iff every invalid sequence has a valid prefix ending on an action in .  In that case, the property of interest includes a safety property that can be enforced by truncation.
\begin{thm}
If  then -enforceable -safety.
\end{thm}



\section{Conclusion}\label{sec:conclusion}

In this paper, we reexamined the delimitation of enforceable properties by monitors, and proposed a finer characterization that distinguishes between actions that are only observable, actions which the monitor can delete but not insert into the execution, actions which the monitor can insert in the execution but not suppress if they are already present and completely controllable actions. Our study is a generalization of previous work on the same topic, and provides a finer characterization of the set of security properties that are enforceable by monitors in different contexts.

Additionally, we explored the set of properties that are enforceable by the monitor is given broader latitude to transform valid sequences, rather than be bounded to return a syntactically identical execution sequence  if the original execution is valid. We argue that our results point to the need for an alternative definition of enforcement.

Part of the reason the sets of enforceable and enforceable properties are so large is that, in the definition of effective enforcement, the transparency requirement is so weak. This leads to monitors with unusually broad licence to alter invalid sequences in order to correct them.  For monitors with broad capabilities to add and remove actions from the execution sequence, the desired behaviour of real-life security policy enforcement mechanism would be more accurately characterized by a more constraining definition of \textit{enforcement}.  For example, a practical suppression monitor should be bounded to remove from an invalid execution sequence only those actions that violate the security policy. Any valid behaviour present in an otherwise invalid sequence should be preserved.

In the future, we would like to consider that the cost of inserting or deleting an action may not be the same for all actions.  This would allow us to contrast different enforcement strategies for the same security property. A lattice-based framework is well-suited to model such a restriction.


\bibliographystyle{abbrv}
\bibliography{report}
\newpage
\appendix
\section{Proofs} \label{App:AppendixA}
\setcounter{thm}{0}
\setcounter{cor}{0}
\begin{thm}

\end{thm}
\begin{proof}
(if direction) We construct an edit-automaton  that effectively enforces the property \Property. This automata is defined as follows:
\begin{itemize}
  \item , i.e., each state consists in a pair of finite sequences, the sequence output so far and the suffix of the input currently suppressed.
  \item ,
  \item the transition function  is defined as \\
  
    \\where  is a function defined as follows \\
    
    Informally, this transition function states that the monitor suppresses the execution until a valid prefix is encountered, at which point it outputs the suffix of the execution it has suppressed so far. Function  detects the occurrence of the corner case described above.


\end{itemize}
Let  be the input sequence and let  be the prefix of the input sequence processed at step , and let  be the state of   reached after processing .  The automaton maintains the following invariants.
At step , (1)  has been output and this output is valid, (2) the output is transparent, i.e.  (3) and (4) the automaton  never manipulates and action in a disallowed manner.
The third invariant ensures that the automata does not, for instance, suppress an unsuppressible action, or abort the execution on an observable action.

The invariants hold initially since  and the automaton is in state .  Let us assume that INV(i) holds and let  be the next input action. We show that INV(i+1) holds where .

There are three cases to consider.\\
\begin{enumerate}
  \item  is invalid, and there are multiple valid extensions.   In this case the automaton suppresses the input sequence. The automaton enters state  where  and . That   holds from the induction hypothesis. Likewise, the transparency requirement holds trivially since .  The first conjunct of theorem \ref{thm:Master} ensures that  is controllable.

  \item . In this case the automaton outputs . By induction we have that  and thus . , which means the third part of the invariant holds trivially. Finally, since for in previous states, an action could only have been suppressed if it was controllable, we have that every action in  is controllable.

  \item  has a single valid extension. This includes the case where the only valid extension is  and the execution is aborted. In this case the automaton enters a loop in which it outputs the actions of the only valid extension one  by one. By the theorem \ref{thm:Master} we have that the output of the monitor is valid and insertable or controlable. Such an action in known to exist by the final conjunct of the theorem \ref{thm:Master}. INV(i+1)(3) holds trivially since .
\end{enumerate}

Since the invariant INV holds at each step, the output is valid, transparent and the monitor does not behave in a manner inconsistent with the limitations on its capabilities. \\
(else-if direction)\\
By negation of theorem \ref{thm:Master}, we have that a property is unenforceable iff it contains at least one valid sequence  meeting the following two properties \\

\begin{enumerate}
 \item  

 \item 

\end{enumerate}
Informally, the property is unenforceable iff there exists a valid sequence with an invalid prefix that is not in the controllable set, that that valid sequence either is not in the corner case described in section 3 or is not comprised of insertable of controllable actions. When the monitor encounters such a prefix, it cannot accept it since it may be the end of an invalid sequence, but it cannot suppress it since,  the input may have a valid continuation, which the monitor would be unable to re-insert.
\end{proof}

\setcounter{thm}{3}



\begin{thm}
(from \cite{enforceable}) If  then enforceable is  Safety.
\end{thm}
\begin{proof}
-enforceable \\

\hspace*{\fill}\\

-enforceable\\

\hspace*{\fill}\\

-enforceable\\


-enforceable\\

\hspace*{\fill} definition of Safety \\

-enforceable safety \\
\end{proof}


\begin{comment}
\begin{proof}
All actions are O or D, nonuniform context. monitor cannot suppress an action and continue the execution. Similar to theorem 5.
-enforceable \\


\hspace*{\fill}\\

-enforceable \\

\hspace*{\fill}\\

-enforceable \\
\end{proof}
\end{comment}


\begin{thm}
(from \cite{nonsafetyJournal}) If  then enforceable is Infinite Renewal or the corner case.
\end{thm}
\begin{proof}-enforceable  \\

\hspace*{\fill}\\

-enforceable  \\

\hspace*{\fill}\\

-enforceable  \\

\hspace*{\fill}\\

-enforceable  \\

\hspace*{\fill} definition of renewal and of the corner case \\

-enforceable renewal or the corner case  \\
\end{proof}


\begin{cor}\label{corr:1}
Let  be a lattice over a set of actions  as described above and let  and .
-enforceable    -enforceable.
\end{cor}
\begin{proof}
Any property that is -enforceable is trivially -enforceable.\\

Let  and  .
The property , which states that any valid execution must begin with a distinguished action  is not -enforceable since the monitor cannot correct an invalid sequence by adding the missing initial action. It is -enforceable.

Let   and  .
The property  is not -enforceable since when faced with a single , the monitor can neither suppress it (which would make it impossible to return a valid syntactically equal sequence if the next action is also ), nor output it, since the execution would be then be irremediably invalid in all other cases. The property is  -enforceable.

Let   and    or  and  .
The property  is not -enforceable since the monitor lacks the ability to suppress invalid  actions.  It is -enforceable by simple suppression of these actions.
\end{proof}

\begin{cor}
\label{cor:2} Let -enforceable .
\end{cor}
\begin{proof}
Corollary \ref{cor:2} follows immediately from Theorem \ref{thm:Master}.
\end{proof}




\begin{thm}
Let  .   -enforceable is the set of safety properties.
\end{thm}
\begin{proof}
Trivial. Since the monitor lacks the ability to insert any action into the execution, it behaves like a suppression automaton \cite{MoreEnforce}. The equivalence relation imposes that any action present in the input must also be present in the output. Since the monitor can only allow an action or terminate the execution, any enforceable property is necessarily prefix closed.
\end{proof}



\begin{thm}
Let  and let . If the monitor cannot delay the occurrence of actions performed by the target program, then  -enforceable   and  is infinite renewal  liveness.
\end{thm}
\begin{proof}
(if direction)
Let \Property' be property in Renewal  Liveness s.t. \Property'  \Property\ and let . A monitor can -enforce \Property' as follows: let  be the current output so far and let   be the next program action in the execution. Since \Property' is in Renewal  Liveness there necessarily exists a finite sequence  s.t. , and the monitor can -enforce \Property' by outputting this sequence. Since \Property'  \Property, the  monitor's output is correct w.r.t. \Property\ and since  the output is transparent. \\
(else-if direction)
A \Property\  not in the intersection of Renewal  Liveness can be safety properties or persistence properties.  Safety properties are properties for which a violation of the security policy is irremediable. As such, no suffix can be added by the monitor to the invalid sequence to correct it, thus -enforcing the property. Likewise, persistence properties include infinite invalid sequence with infinitely many valid prefixes, and infinite valid prefixes with only finitely many valid prefixes. In the former case, the monitor cannot enforce the property because even though its output will continuously be valid, the overall execution will violate the property. In the latter case, the monitor will eventually reach a finite execution  which has no finite valid extension.  If the monitor outputs a valid infinite extension, subsequent action output by the program will not be present in the monitor's output, violating the transparency requirement.  Since there does not exists a property \Property'  \Property\ s.t. \Property' is in Renewal  Liveness, the monitor cannot avoid reaching one of the three cases described above.
\end{proof}


\begin{thm}
Let  .   -enforceable iff there exists a property .
\end{thm}
\begin{proof}
(if direction) Let \Property\ and \Property'\ be a properties as described above. Let  be the input sequence so far and let  be the next program action in the execution.  By definition, there exists a sequence  s.t.   (satisfying correctness since \Property'  \Property) and  (satisfying transparency).\\
(else-if direction) If the condition above does no hold, then by definition there exists a sequence  such that  and an action  such that  has no valid finite extension containing .  This makes it impossible to enforce for a monitor to enforce the property in a correct and transparent manner if  is the input sequence.
\end{proof}

\begin{thm}
If  then -enforceable = .
\end{thm}
\begin{proof}
Since the empty sequence  is always valid, and equivalent to every possible sequence, the monitor can -enforce any property by always outputting that sequence.
\end{proof}

\begin{cor}
Let  . -enforceable = -enforceable.
\end{cor}
\begin{proof}
Immediate from theorem \ref{thm:total}.
\end{proof}


\begin{cor}
Let  . -enforceable =
-en\-for\-ceable.
\end{cor}
\begin{proof}
Immediate from theorem \ref{thm:total}.
\end{proof}




\setcounter{thm}{9}
\begin{thm}
If  then -enforceable -safety.
\end{thm}
\begin{proof}
(if direction)The property \Property\ can be enforced by enforcing the property . Since \Property' is a safety property, it can be enforced by truncation. Since \Property' is a subset of \Property, enforcing \Property' satisfy the correctness requirement for \Property. Enforcing the property by truncation guarantees that the transparency requirement is respected.

(else-if direction)Let \Property\ be a property for which there does not exist a property \Property' such that    and \Property'  -safety. There must exist a sequence  such that  . If  this is the input sequence, the monitor cannot enforce the property since there is no valid prefix upon which it can abort the execution.
\end{proof}

\end{document} 