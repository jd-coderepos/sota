\documentclass[letter]{ieice}

\usepackage[dvips]{graphicx}


\setcounter{page}{1}


\field{}
\title{Choice Disjunctive Queries in Logic Programming}

\authorlist{\authorentry{Keehang KWON}{m}{labelA}
\authorentry{Daeseong KANG}{n}{labelB}
}
\affiliate[labelA]{The author is a professor of Computer Eng., DongA University. khkwon@dau.ac.kr}
\affiliate[labelB]{The author is a professor of Electronics Eng., 
DongA University.}


\received{2003}{1}{1}
\revised{2003}{1}{1}
\finalreceived{2003}{1}{1}









\newenvironment{describe}{\begin{list}{}{\setlength\leftmargin{80pt}}\setlength\labelsep{10pt}\setlength\labelwidth{70pt}}{\end{list}}

\newenvironment{flag}{\begin{list}{\makebox[20pt]{\hss\enspace}}
                                  {\labelwidth 20pt}}{\end{list}}





\newenvironment{numberedlist}
{\begin{list}{\makebox[20pt]{\hss(\arabic{itemno})\enspace}}
             {\usecounter{itemno}\labelwidth 20pt}}{\end{list}}

\newenvironment{alphabetlist}
{\begin{list}{\makebox[20pt]{\hss(\alph{itemno1})\enspace}}
             {\usecounter{itemno1}\labelwidth 20pt}}{\end{list}}

\newenvironment{romanlist}
{\begin{list}{\makebox[20pt]{\hss(\roman{itemno2})\enspace}}
             {\usecounter{itemno2}\labelwidth 20pt}}{\end{list}}

\newcounter{itemno}

\newcounter{itemno1}

\newcounter{itemno2}
\newcounter{lemma}
\newcounter{exno}

\newcounter{defno}













\newenvironment{defn}{\refstepcounter{defno}\medskip \noindent {\bf
Definition \thedefno.\ }}{\medskip}

\newenvironment{ex}{\refstepcounter{exno}\medskip \noindent {\bf
Example \theexno.\ }}{\medskip} 













\newenvironment{millerexample}{
 \begingroup \begin{tabbing} \hspace{2em}\= \hspace{5em}\= \hspace{5em}\=
\hspace{5em}\= \kill}{
 \end{tabbing}\endgroup}

\newenvironment{wideexample}{
 \begingroup \begin{tabbing} \hspace{2em}\= \hspace{10em}\= \hspace{10em}\=
\hspace{10em}\= \kill}{
 \end{tabbing}\endgroup}

\newcommand{\sep}{\;\vert\;}

\newcommand{\ra}{\rightarrow}
\newcommand{\app}{\ }
\newcommand{\appt}{\ }
\newcommand{\tup}[1]{\langle\nobreak#1\nobreak\rangle}

\newcommand{\hu}{{\cal H}^+}
\newcommand{\Free}{{\cal F}}
\newcommand{\oprove}{\vdash\kern-.6em\lower.7ex\hbox{}\,}
\newcommand{\true}{\top}

\newcommand{\Dscr}{{\cal D}}
\newcommand{\Pscr}{{\cal P}}
\newcommand{\Gscr}{{\cal G}}
\newcommand{\Fscr}{{\cal F}}
\newcommand{\Vscr}{{\cal V}}
\newcommand{\Uscr}{{\cal U}}
\newcommand{\pderivation}{{\cal P}\kern -.1em\hbox{\rm -derivation}}
\newcommand{\pderivationl}{{\cal P}\kern -.1em\hbox{\em -derivation}}
\newcommand{\pderivable}{{\cal P}\kern -.1em\hbox{\rm -derivable}}
\newcommand{\pderivablel}{{\cal P}\kern -.1em\hbox{\em -derivable}}
\newcommand{\pderivations}{{\cal P}\kern -.1em\hbox{\rm -derivations}}
\newcommand{\pderivability}{{\cal P}\kern -.1em\hbox{\rm -derivability}}
\newcommand{\eqm}[1]{=_{\scriptscriptstyle #1}}
\newcommand\subsl{\preceq}
\newcommand{\fnrestr}{\uparrow}

\newcommand{\match}{{\rm MATCH}}
\newcommand{\triv}{{\rm TRIV}}
\newcommand{\imit}{{\rm IMIT}}
\newcommand{\proj}{{\rm PROJ}}
\newcommand{\simpl}{{\rm SIMPL}}
\newcommand{\failed}{{\bf F}}

\newcommand{\Dsiginst}[1]{{[#1]_\Sigma}}
\newcommand{\Psiginst}[1]{{[#1]_\Sigma}}
\newcommand{\lnorm}{{\lambda}norm}
\newcommand{\seq}[2]{#1 \supset #2}
\newcommand{\dseq}[2]{#1_1,\ldots,#1_{#2}}

\newcommand{\all}{\forall}
\newcommand{\some}{\exists}
\newcommand{\lambdax}[1]{\lambda #1\,}
\newcommand{\somex}[1]{\some#1\,}
\newcommand\allx[1]{\all#1\,}

\newcommand{\subs}[3]{[#1/#2]#3}
\newcommand{\rep}[3]{S^{#2}_{#1}{#3}}
\newcommand{\ie}{{\em i.e.}}
\newcommand{\eg}{{\em e.g.}}

\newcommand{\lbotr}{-R}
\newcommand{\ldbotr}{\bot\mbox{\rm -R}}
\newcommand{\landl}{-L}
\newcommand{\ldandl}{\land\mbox{\rm -L}}
\newcommand{\landr}{-R}
\newcommand{\ldandr}{\land\mbox{\rm -R}}
\newcommand{\lorl}{-L}
\newcommand{\ldorl}{\lor\mbox{\rm -L}}
\newcommand{\lorr}{-R}
\newcommand{\ldorr}{\lor\mbox{\rm -R}}
\newcommand{\limpl}{-L}
\newcommand{\ldimpl}{\supset\mbox{\rm -L}}
\newcommand{\limpr}{-R}
\newcommand{\ldimpr}{\supset\mbox{\rm -R}}
\newcommand{\lnegl}{-L}
\newcommand{\ldnegl}{\neg\mbox{\rm -L}}
\newcommand{\ldnegr}{\neg\mbox{\rm -R}}
\newcommand{\lalll}{-L}
\newcommand{\ldalll}{\forall\mbox{\rm -L}}
\newcommand{\lallr}{-R}
\newcommand{\ldallr}{\forall\mbox{\rm -R}}
\newcommand{\lsomel}{-L}
\newcommand{\ldsomel}{\exists\mbox{\rm -L}}
\newcommand{\lsomer}{-R}
\newcommand{\ldsomer}{\exists\mbox{\rm -R}}
\newcommand{\ldlamlr}{\lambda}
\newcommand{\sequent}[2]{\hbox{{}}}
\newcommand{\prog}[2]{\hbox{{}}}
\newcommand{\run}{\Gamma}


\newcommand{\Ibf}{{\bf I}}
\newcommand{\Cbf}{{\bf C}} 
\newcommand{\Cbfpr}{{\bf C'}}

\newcommand{\cprove}{\vdash_C}
\newcommand{\iprove}{\vdash_I}

\newsavebox{\lpartfig}
\newsavebox{\rpartfig}




\newenvironment{exmple}{
 \begingroup \begin{tabbing} \hspace{2em}\= \hspace{3em}\= \hspace{3em}\=
\hspace{3em}\= \hspace{3em}\= \hspace{3em}\= \kill}{
 \end{tabbing}\endgroup}
\newenvironment{example2}{
 \begingroup \begin{tabbing} \hspace{8em}\= \hspace{2em}\= \hspace{2em}\=
\hspace{10em}\= \hspace{2em}\= \hspace{2em}\= \hspace{2em}\= \kill}{
 \end{tabbing}\endgroup}

\newenvironment{example}{
\begingroup  \begin{tabbing} \hspace{2em}\= \hspace{3em}\= \hspace{3em}\=
\hspace{3em}\= \hspace{3em}\= \hspace{3em}\= \hspace{3em}\= \hspace{3em}\= 
\hspace{3em}\= \hspace{3em}\= \hspace{3em}\= \hspace{3em}\= \kill}{
 \end{tabbing} \endgroup }


\newcommand{\sand}{sand} \newcommand{\pand}{pand} \newcommand{\cor}{cor} 

\newcommand{\lb}{\langle}
\newcommand{\rb}{\rangle}
\newcommand{\pr}{prov}
\newcommand{\prG}{intp}
\newcommand{\prSG}{intp_E}
\newcommand{\intp}{intp_o}
\newcommand{\prove}{exec} \newcommand{\np}{invalid} \newcommand{\Ra}{\supset}  
\newcommand{\add}{\oplus} \newcommand{\adc}{\&} \newcommand{\Cscr}{{\cal C}}
\newcommand{\seqweb}{SProlog}
\newcommand{\sprog}{{SProlog}}

\newtheorem{theorem}[lemma]{Theorem}

\newtheorem{proposition}[lemma]{Proposition}

\newtheorem{corollary}[lemma]{Corollary}
\newenvironment{proof}
     {\begin{trivlist}\item[]{\it Proof. }}{\\* \hspace*{\fill} \end{trivlist}}

\newcommand{\seqand}{\prec}
\newcommand{\seqor}{\cup}
\newcommand{\seqandq}[2]{\prec_{#1}^{#2}}
\newcommand{\parandq}[2]{\land_{#1}^{#2}}
\newcommand{\exq}[2]{\exists_{#1}^{#2}}
\newcommand{\ext}{intp_G} \newcommand{\muprolog}{{Prolog}}
\renewcommand{\pr}{pv}
\renewcommand{\prove}{ex} \newcommand{\bli}{\all^{b}} \newcommand{\defeq}{:-}
\renewcommand{\Pscr}{{\cal P}}
\newcommand{\false}{\hbox{\sl false}}

\begin{document}
\maketitle
\begin{summary}
One of the long-standing research problems on logic programming is to treat the cut predicate
 in a logical, high-level way.
 We argue that this problem can be solved by adopting linear logic and 
   choice-disjunctive goal formulas of the form 
   where   are
goals.   These goals have the following intended semantics:
  the true disjunct  and execute  where , while 
 the unchosen disjunct.  
Note that only one goal can remain alive during execution. These goals thus allow us to specify
mutually exclusive tasks in a high-level way.   Note that there is another use of cut which is for breaking out of failure-driven loops and efficient heap management.
Unfortunately, it is not possible to replace cut of this kind with use of choice-disjunctive goals.
 

\end{summary}
\begin{keywords}
Game semantics; cut; mutual exclusion
\end{keywords}









\section{Introduction}

One of the long-standing research problems on logic programming is to treat the extra-logical 
primitive in a  {\it high-level, logical} way.
The advances of logic programming -- especially structured proof theory --  have enriched Horn clauses with
 additional programming primitives  in a  high-level way
 (higher-order programming, modules, local constants, etc) \cite{MNPS91,Kwon,Loke}.
 Nevertheless some key constructs could not be dealt with in a high-level way, in particular when we are
 concerned with  mutual exclusion (and  the 
cut
predicate). 

Consequently, much attention \cite{Por,Sau08,Kri11} has been given to finding a 
semantics that captures the cut predicate.
These proposals  - based on such  notions of -- and  -- are quite interesting but somewhat complicated
than necessary.
                                         

    In this paper, inspired by the work in \cite{Jap03,Jap08,JapCL1,JapCL2,JapCL12}, we propose a purely logical solution to this problem. It involves the direct employment of linear logic
\cite{Gir87}
 to allow for choice-disjunctive   goals.
 A  choice-disjunctive  goal  is of the form 
 
 where  are goals. (A more intuitive name would be .)
Executing this goal with respect to a program  --  --
 has the following intended semantics: 



\noindent For example, given a program , execution will succeed on
the goal  by choosing . Similarly,  execution will succeed on
the goal  by choosing . On the other hand,
consider a goal . In this case, both disjuncts can lead to a success, and,
in our semantics, it does not matter which disjunct to use. For simplicity, we assume from now on 
that execution always chooses the first
successful disjunct if there are many. Thus, back to the above, execution will succeed on
the goal  by choosing .
Note that the class of choice disjunctive goals is a superset of 
 the class of mutually exclusive goals.

    Another
illustration of this construct is provided by the following definition of the
relation  which holds if  is a son of .:

\begin{exmple}
  \> \hspace{6em}      \\ 
 \> \hspace{6em} 
\end{exmple}
\noindent
The body of the definition above contains a mutually exclusive goal, denoted by .
 As a particular example, solving the query  would result in selecting and 
executing the first goal , while discarding the second one.  The given goal will
succeed, producing solutions for . Of course, we can specify mutually exclusive goals using cut
in Prolog, but it is well-known that cuts
complicates the declarative meaning of the program. Our language makes it possible to formulate mutually exclusive goals in a high-level way.
The class of choice disjunctive goals is, in a sense, a high-level abstraction for the cut
predicate.


     As seen from the example above, choice-disjunctive  goals can be used to perform mutually exclusive
 tasks.
There are several well-designed linear logic languages \cite{HM94,Wini} 
 in which
goals of the form  are present. A common 
problem of these works  is their treatment of the 
-goals: these goals are treated as inclusive-OR (or classical disjunctive) goals rather than  
exclusive-OR ones:


\noindent where  represents classical disjunction. 
Hence, it is rather unfortunate that the declarative reading of  -- 
known as {\it the machine's choice} --
 is missing in these languages.

A  satisfactory solution can be obtained by adopting game semantics of \cite{Jap03}, \ie, by
adding an extra layer of the choice action, as discussed above,
 to their execution model of . In this way, 
 the execution respects the declarative
reading of , while maintaining provability.
Hence, the main difference is that, once a goal is chosen,
the unchosen goal will be discarded in our language, while it will remain alive (typically through a
creation of a choicepoint) in those languages.

\section{Reconsidering the Foundation in Logic Programming}\label{sec:intro}

 The computation-as-deduction approach\cite{MNPS91,Miller21} has provided a basis for logic programming.
It views the state of a computation as a sequent  and  computing as the  proof search. 
This approach has proven useful, leading to several extensions.
The first such extensions to the Horn clause include
 hypothetical and universally quantified goal formulas, pioneered in \cite{MNPS91}.
 Additional extensions were made using higher-order quantification and linear
logic\cite{HM94}.

Unfortunately,  this approach is appropriate only for  computation with boolean
semantics, i.e., deciding where some formula is true/false. However, this view is too limiting. 
Instead, we believe that computation should be based on a bigger paradigm, \ie, task/game semantics\cite{Jap03,Japtow}.
That is, computation should be interested in deciding whether some formula can be {\it made} true or not.
From this viewpoint, the major criterion for judging the adequacy of a 
logic programming can be explained as follows: 

\begin{itemize}

\item The first phase -- the proof phase -- should be sound and complete with respect to the given semantics such as intuitionstic, classical logic
 or linear logic.

\item The second phase -- the execution phase -- should respect the declarative readings of 
logical connectives.  

\end{itemize}
\noindent  
 Consider, for instance,   in a query. It reads as follows: solve  and  concurrently.
 Declarative readings of other connectives are given in the next section.
 

The sequent
calculus for Prolog  does not violate a correspondence between the declarative
meaning of  logical connectives and proof search operations. Unfortunately, there is no such
guarantee for new connectives.  
  is such an example where the logical connective  and the proof search operations do not  correspond.
 
\section{Declarative reading of logical connectives}\label{s2}

In this section, based on \cite{HM94,Jap03},  an   overview of declarative reading of linear logical connectives is given
in the sense of  intuitionistic linear logic.

\begin{description}


\item[Additive operations]

The choice group of operations:   ,  (and negative occurrences of ) are defined below.

 is the problem where, in the initial position, only the machine has a legal move which consists in 
choosing a value 0 or 1. After the machine makes a move , 
the problem becomes  . 

 (and negative occurrences of ) is the following: the machine must choose a value  for  and the problem becomes . 

\item[Muliplicative operations]

Playing  means solving the two problems concurrently.  In order to succeed,  
the machine needs to solve each of two problems. 

\item[Reduction]

  is the problem of reducing  ({\em consequent}) to  ({\em antecedent}).  

\end{description}

\section{\muprolog\ with the Old Semantics}

The language is a version of Horn clauses
 with choice-disjunctive goals. It is also a subset of Lolli\cite{HM94}.
 Note that  we disallow linear clauses here, thus allowing only
reusable clauses. 
It is described
by - and -formulas given by the syntax rules below:
\begin{exmple}
\> \>    \\   \\
\> \>  \\
\end{exmple}
\noindent
\newcommand{\sync}{up}
\newcommand{\async}{down}

In the rules above,    represent  terms, and  
  represents an atomic formula.
A -formula  is called a  Horn
 clause with choice-disjunctive goals. A set of -formulas is called a program.

 We will  present a machine's strategy for this language given in \cite{HM94}.
These rules in fact depend on the top-level 
constructor in the expression,  a property known as
uniform provability\cite{MNPS91,KK07}. 
 Note that execution  alternates between 
two phases: the goal-reduction phase 
and the backchaining phase. 
In  the goal-reduction phase, the machine tries to decompose a goal .
If  becomes an atom, the machine switches to the backchaining mode. 
This is encoded in the rule (2). 



\begin{defn}\label{def:semantics}
Let  be an answer substitution and let  be a goal and let  be a set of
-formulas.
Then the task of proving  with respect to  -- 
 -- 
is defined as 
follows:

\begin{numberedlist}





\item    . \% success

\item     if  and  are unifiable. 

\item  if  and   and
. \% DefR (backchaining)

\item   if  and 
. 

\item   if .

\item   if .



\item   if  
where  is a new free variable,  and  is a term.



\end{numberedlist}
\end{defn}
\noindent 
Initially,  is an empty substitution.  in Rule 3 represents the composition of  two substitutions  and . In the above, most rules are straightforward to read.

As an   
illustration of this approach, let us consider the following program . \\



 \\


Now, consider a goal task 
 .
 
The following is a proof tree of this example.  \\


,  \% success

,  \% defR

,  \% -R

,  \% success

,   \% defR

,  \% -R

,  \% -R \\

The following theorem connects our language to linear logic.
Its proof is easily obtained from \cite{HM94}.


\begin{theorem}
 Let  be a program and 
let  be a goal. Then,  terminates with a success
 if and only if  follows from
 in intuitionistic linear logic. Furthermore, the interpreter respects the declarative
reading of all the logical connectives except .
\end{theorem}
 

\section{The Execution Phase}\label{sec:0627}

Adding game semantics  requires another execution phase beside the proof phase.
To be precise, our new execution model -- adapted from \cite{Jap03} -- 
 actually solves the goal relative to the program using the proof tree built in the proof
phase.

 In the execution phase, it just follows the path in the proof tree, printing the output values
occasionally.

\begin{numberedlist}





\item    . \% success

\item     if . \% invoke unification.

\item  if 
, provided that the former is derived from the latter via . 

\item   if  and 
, provided that the former is derived from the latter via -R.

\item   if  where  is 0 or 1, provided that the former
is derived from the latter via -R. 




\item   if , 
provided that the former
is derived from the latter via -R.




\end{numberedlist}
\noindent 
Note that only the -R rule has changed.

The following theorem  justifies our machine with respect to linear logic.
Its proof is easily obtained from the analysis of the above algorithm.


\begin{theorem}
 Let  be a program and 
let  be a goal. Then,  terminates with a success
 if and only if  follows from
 in intuitionistic linear logic. Further, it respects the declarative
reading of all the logical connectives including .
\end{theorem}

\section{Some Examples }\label{sec:modules}

Let us first consider the relation  specified by two rules:

\begin{numberedlist}

\item if , then .

\item if , then .

\end{numberedlist}

The two  conditions are mutually exclusive which is expressed by using the cut in traditional logic
programming as shown below:




\noindent Using cut, we can specify mutually exclusive goals, but  cuts
affect the declarative meaning of the program. Our language makes it possible to formulate mutually exclusive goals
 through the choice-disjunctive goals as shown below:

\begin{exmple}
  \> \hspace{8em} \\
 \> \hspace{8em} \\
\end{exmple}
\noindent The new program, equipped with -goals, is more readable
than the original version with cuts, while preserving the same efficiency.
A similar example is provided by the 
following ``max'' program that finds the larger of two numbers.  

\begin{exmple}
  \> \hspace{9em} \\
 \> \hspace{9em} \\
\end{exmple}
\noindent These two goals in the body of the above clause are mutually exclusive. Hence, only one of these two goals
can  succeed.  For example, consider a goal .
Solving this goal  has the effect of choosing and executing the second goal , producing
the result .
 

As another example, we consider  the relation  for establishing whether  is in the list .
A typical Prolog  definition of  is shown below:

\begin{exmple}
  \> \hspace{9em} \\
\end{exmple}
\noindent This definition is nondeterministic in the sense that it can find any occurrence of .
Our language in Section 2 makes it possible to change  to be deterministic and more efficient: 
only one occurrence can be
found. An example of  this is provided by the following
 program.

\begin{exmple}
  \> \hspace{9em} \\
\end{exmple}



\section{Conclusion}\label{sec:conc}

In this paper, we have considered an extension to Prolog with  
choice-disjunctive  goals. This extension allows goals of 
the form    where  are goals.
These goals are 
 particularly useful for replacing the cut in Prolog, making Prolog
more concise and more readable.

In the near future, we plan 
to  investigate the connection between 
\muprolog and Japaridze's Computability Logic(CL)\cite{Jap03,Jap08}.
CL is a new semantic platform for reinterpreting logic
as a theory of tasks. Formulas in CL stand for instructions
that can carry out some  tasks. We plan to investigate whether  our operational semantics is sound and complete
with respect to  the semantics of CL. 

\section{Acknowledgements}

This research was supported by Dong-A University Research Fund.




\begin{thebibliography}{999}
\bibitem{Khan87}
G.~Kahn,  ``Natural Semantics'', In the 4th Annual Symposium on Theoretical Aspects of Computer Science, 
LNCS vol. 247,  1987.


\bibitem{Jap03}
G.~Japaridze, ``Introduction to computability logic'', Annals  of Pure and
 Applied  Logic, vol.123, pp.1--99, 2003.

\bibitem{Jap08}
G.~Japaridze,   ``Sequential operators in computability logic'',
 Information and Computation, vol.206, No.12, pp.1443-1475, 2008.  


\bibitem{JapCL1} G. Japaridze . Propositional computability logic I. {\it ACM Transactions on Computational Logic}, 2006, 7(2): 302-330.
  
\bibitem{JapCL2} G. Japaridze. Propositional computability logic II. {\it ACM Transactions on Computational Logic}, 2006, 7(2): 331-362.

\bibitem{Japtow} G. Japaridze. Towards applied theories based on computability logic. {\it Journal of Symbolic Logic}, 2010, 75(2): 565-601.



\bibitem{JapCL12} G. Japaridze. On the system CL12 of computability logic. http://arxiv.org/abs/1203.0103, June 2013.






\bibitem{Gir87}
J.Y.~Girard, ``Linear Logic'', Theoretical Computer Science, vol.50, pp.1--102, 
1987.

\bibitem{HM94}
J.~Hodas and D.~Miller, ``Logic Programming in a Fragment of Intuitionistic Linear Logic'', Information and Computation, vol.110, pp.327--365, 1994.

\bibitem{Kri11}
J.~Kriener and A.~King, ``RedAlert: Determinacy Inference for Prolog'', Theory and Practice of Logic Programming, vol.11, no.4-5. pp.182--196.


\bibitem{KK07}
E.~Komendantskaya and V.~Komendantsky, ``On uniform proof-theoretical operational semantics for logic programming'',  In J.-Y. Beziau and A.Costa-Leite, editors, Perspectives on Universal Logic, pages 379--394. Polimetrica Publisher, 2007.



\bibitem{Kwon} Kwon K, Hur S. Adding Sequential Conjunctions to Prolog. {\it International Journal of Computer Technology and Applications}, 2010, 1(1): 1-3.



 
\bibitem{Loke}
S.W. Loke and A. Davison:
LogicWeb: Enhancing the Web with Logic Programming. {\it Journal of Logic Programming},
1998, 36(3): 195-240.

\bibitem{Miller21}
 D.~Miller, ``A Survey of the Proof-Theoretic Foundations of Logic Programming",  
  20th Anniversary Issue of the Theory and Practice of Logic Programming, November 2021. 

\bibitem{MNPS91}
D.~Miller, G.~Nadathur, F.~Pfenning, and A.~Scedrov, ``Uniform proofs as a
  foundation for logic programming'', Annals of Pure and Applied Logic, vol.51,
  pp.125--157, 1991.

\bibitem{Por}
A.~Porto,   ``A structured alternative to Prolog with simple compositional
               semantics'',
 Theory and Practice of Logic Programming, vol.11, No.4-5, pp.611-627, 2011.  


\bibitem{Sau08}
A.~Saurin, ``Towards {L}udics Programming: Interactive Proof Search'',  International Conference on
Logic Programming, pages 253--268.  2008.


\bibitem{Wini}
M. D.~Winikoff, ``Logic Programming with Linear Logic'',  PhD. Thesis, 
Univ. Melbourne,
   1997.

\end{thebibliography}


\end{document}
