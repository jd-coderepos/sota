\documentclass[copyright]{eptcs}

\providecommand{\event}{ICE 2010} \providecommand{\volume}{??}
\providecommand{\anno}{2010}
\providecommand{\firstpage}{1}
\providecommand{\eid}{??}

\def\titlerunning{A theory of desynchronisable closed loop systems}
\def\authorrunning{H.Beohar \& P.J.L.Cuijpers}

\usepackage{amsmath,amscd,amsbsy}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{procalg}
\usepackage{stackrel}
\usepackage{subfigure}
\usepackage[numbers]{natbib}
\usepackage{graphicx}
\usepackage{graphics}

\tolerance20000
\hbadness19000
\usepackage{tikz}
\usetikzlibrary{shapes,arrows,automata}
\usetikzlibrary{shapes.symbols}
\usetikzlibrary{shapes.misc}
\usetikzlibrary{calc}

\theoremstyle{plain}
\newtheorem{theorem}{Theorem}[section]
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{lemma}[theorem]{Lemma}

\theoremstyle{definition}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{example}[theorem]{Example}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem*{lemm}{Open question}

\newcommand{\act}{\ensuremath{A}}
\newcommand{\actlabel}{\ensuremath{\mathit{Act}}}
\newcommand{\mact}{\ensuremath{\tilde{A}}}
\newcommand{\ebag}{\ensuremath{\varepsilon}}
\newcommand{\block}{\ensuremath{H}}
\newcommand{\hide}{\ensuremath{I}}
\newcommand{\prc}{\ensuremath{\mathbb{P}}}
\renewcommand{\comm}{\ensuremath{?\mkern-7mu!}}
\newcommand*\com{\mathop{\raisebox{-1pt}{\normalfont\Large\comm}}}

\newcommand{\Longtwoheadrightarrow}{\Longrightarrow\hspace{-1.4em}\Longrightarrow\hspace{.2em}}
\newcommand{\longtwoheadleftarrow}{\longleftarrow\hspace{-1.4em}\leftarrow\hspace{.2em}}
\newcommand{\lla}[2]{\ensuremath{\stackrel[]{\mkern+5mu#1}{\longtwoheadleftarrow_{#2}}}}
\newcommand{\la}[2]{\ensuremath{\stackrel[]{\mkern+5mu#1}{\longleftarrow_{#2}}}}
\newcommand{\stran}[2]{\ensuremath{\stackrel[]{\mkern-7mu#1}{\longrightarrow_{#2}}}}
\newcommand{\longtwoheadrightarrow}{\longrightarrow\hspace{-1.2em}\rightarrow\hspace{.2em}}
\newcommand{\strans}[2]{\ensuremath{\stackrel[]{\mkern-19mu#1}{\longtwoheadrightarrow_{#2}}}}
\newcommand{\bag}{\ensuremath{B}}
\newcommand{\nat}{\ensuremath{\mathbb{N}}}
\newcommand{\well}{\ensuremath{W}}
\newcommand{\hidepi}{{\hide_{P}^{?}}}
\newcommand{\hidepo}{{\hide_{P}^{!}}}
\newcommand{\reach}{\ensuremath{\mathit{Reach}}}
\newcommand{\mset}[1]{\ensuremath{\left[#1\right]}}
\newcommand{\vecm}{\ensuremath{\vec{\mu}}}
\newcommand{\vecn}{\ensuremath{\vec{\nu}}}
\newcommand{\encapp}[1]{\ensuremath{\nabla(#1)}}
\renewcommand{\nabla}[1]{\abstr{\hat{\hide}}{\encap{\block\cup\hat{\block}}{#1}}}

\newcommand{\wtran}[1]{\ensuremath{\stackrel[]{#1}{\Longrightarrow}}}
\newcommand{\wtrans}[2]{\ensuremath{\stackrel[]{\mkern-15mu#1}{\Longtwoheadrightarrow_{#2}}}}

\newcounter{xcount}
\setcounter{xcount}{1}
\newcommand{\inct}{T\arabic{xcount}\addtocounter{xcount}{1}}


\title{A theory of desynchronisable closed loop systems}
\author{Harsh Beohar
\institute{Formal methods group\\
Department of Mathematics and Computer Science\\
Eindhoven university of technology, The Netherlands}
\email{H.Beohar@tue.nl}
\and
Pieter Cuijpers
\institute{Formal methods group\\
Department of Mathematics and Computer Science\\
Eindhoven university of technology, The Netherlands}
\email{P.J.L.Cuijpers@tue.nl}
}

\begin{document}
\maketitle

\begin{abstract}
The task of implementing a supervisory controller is non-trivial, even though different theories exist that allow automatic synthesis of these controllers in the form of automata. One of the reasons for this discord is due to the asynchronous interaction between a plant and its controller in implementations, whereas the existing supervisory control theories assume synchronous interaction. As a consequence the implementation suffer from the so-called inexact synchronisation problem. In this paper we address the issue of inexact synchronisation in a process algebraic setting, by solving a more general problem of refinement. We construct an asynchronous closed loop system by introducing a communication medium in a given synchronous closed loop system. Our goal is to find sufficient conditions under which a synchronous closed loop system is branching bisimilar to its corresponding asynchronous closed loop system.
\end{abstract}

\section{Introduction}\label{sec:introduction}

The task of implementing a supervisory controller is non-trivial, even though different theories exist that allow automatic synthesis of these controllers in the form of automata. One of the reasons for this discord is due to the asynchronous interaction between a plant and its controller in implementations, whereas the existing supervisory control theories assume synchronous interaction. We elaborate on this mismatch by first introducing some terminology that is often used in supervisory control theory \citep{RW:1987}.

Supervisory control theory provides an automatic synthesis of a supervisor that controls a plant in such a way that a corresponding requirement (legal behaviour) is achieved. In supervisory control theory terminology,
\begin{itemize}
\item the model that is to be controlled is known as \textit{plant},
\item the model that specifies the requirement is known as \textit{specification},
\item the model that forces the plant to meet the specification by interacting with it is known as \textit{supervisor} or \textit{controller}.
\item the interaction between a plant and its supervisor is known as \textit{closed-loop behavior}.
\end{itemize}
The closed loop behaviour in supervisory control theory is realized by synchronous parallel composition. Informally, it allows a plant and a supervisor to synchronise on common events while other events can happen independently.

One of the main drawbacks while implementing the interaction between a plant and its supervisor, synthesised by supervisory control theory, is inexact synchronization \citep{fabian}. In practical industrial applications, the interaction between a plant and its supervisor is not synchronous but rather asynchronous. Due to the synchronous parallel composition used in supervisory control theory, the interaction between a plant and its supervisor is strict. By strict, we mean that either plant or supervisor has to wait for the other party while synchronising. To overcome this problem it is important to study asynchronous communication between a plant and its supervisor where communications are delayed in buffers.

\citeauthor{balemiphdt} was the first to consider the inexact synchronisation problem, and the solutions given in his PhD thesis \citep{balemiphdt} were in the domain of automata theory. In \citep{balemiphdt}, an \textit{input-output} interpretation was given between a plant and its supervisor and a special delay operator was introduced to model the delay in communication between the plant and the supervisor. Moreover, for this setup the existence of a supervisor in the presence of delays was also shown in \citep{balemiphdt}. It was required that the output actions from a plant can occur asynchronously, while the output actions from a supervisor must occur synchronously \citep{async-imp}. In \citep{async-imp} this requirement was relaxed. Furthermore, necessary and sufficient conditions were also provided for the existence of a controller under bounded delay between a plant and its supervisor.

The solutions provided in \citep{balemiphdt,async-imp} construct a new supervisor under the presence of bounded delay, which is a computationally expensive procedure. To circumvent this, we present sufficient conditions on a synchronous closed loop system under which the asynchronous closed loop system constructed from it, is a refinement of the given synchronous closed loop system. Moreover, the technique developed in this paper is independent of the size of buffers used. However, we do not analyse the computational complexities associated with the sufficient conditions presented in this paper.

In this paper, we reformulate the inexact synchronisation problem as a problem of refinement in the process algebra TCP \citep{acpbook}. The synchronous closed loop system can be considered as a specification with the asynchronous closed loop system as its implementation. If the given synchronous closed loop system and its corresponding asynchronous closed loop system are branching bisimilar \citep{Glabeek90}, then the asynchronous closed loop system is said to be a refinement of its corresponding synchronous closed loop system. Note that we do not compute an additional supervisor under the presence of delays, instead we assume a given plant and its supervisor. Thus, we solve a refinement problem instead of solving a control synthesis problem.

In the past, the idea of solving a refinement problem was studied \citep{Fischer96,HHJ90,diccs}, but different setups (in comparison with the current paper) were used in these studies. These studies were motivated by the so-called ``Foam-rubber wrapper'' principle \citep{udding}, borrowed from the field of delay insensitive circuits. Mathematically, it states that ``a process and the same process connected with buffers are equivalent''. In \citep{Fischer96}, the foam-rubber wrapper principle was also studied in the context of the parallel composition and it was shown that an extra condition is required to preserve this principle. In brief, we have a different architecture for the asynchronous closed loop system in this paper and we study the components in the asynchronous closed loop system conjointly, in order to capture desynchronisability.


\subsection{Architecture}\label{subsec-arch}

This paper is a result of the pre-study carried out in \citep{prDCL}, where four construction methods are proposed to construct an asynchronous closed loop system from its corresponding synchronous one. In this subsection, we introduce the architecture of an asynchronous closed loop system, discuss the reasonability of using a bag as a buffer and describe one of the abstraction schemes that will be used throughout this paper. We elucidate on these points in the upcoming paragraphs.

\begin{figure}
\centering
\includegraphics[width=5cm]{figures/layer}\\
  \caption{Asynchronous closed loop system in practice.}\label{fig:layer}
\end{figure}

An asynchronous closed loop system can be constructed by introducing a buffer between a plant and its supervisor in order to decouple the synchronisation of events between the two. In practice, the buffering mechanism is realised by the interactions of different layers (also known as protocol stack) as shown in Figure~\ref{fig:layer}. In theory, various authors \citep{Fischer96,HHJ90,MousaviDate04} have abstracted from the interaction of different layers by using data structures based on a particular level of abstraction. For example, to model delay insensitive (DI) circuits, which are at a lower level of abstraction (physical layer), wires are used as a buffering mechanism \citep{diccs}. On the other hand to model data flow networks, which are at a higher level of abstraction (in comparison to DI circuits), queues are used as a buffering mechanism \citep{HHJ90}. In this paper, we are interested in studying the asynchronous interaction in a closed loop system at an even higher level of abstraction by having a unique queue for every message. Thus, a queue stores only one type of unique message and all queues are allowed to run concurrently without interacting with one another. Such interleaving queues are equivalent to a bag modulo strong bisimulation. Hence, we use a bag as the buffering mechanism in this paper.

It is obvious that upon introduction of the bag as a buffer, the asynchronous closed loop system contains interactions that are not present in the synchronous closed loop system. However, to relate these two closed loop systems by a branching bisimulation relation \citep{Glabeek90}, it is necessary to hide some interactions or define a suitable abstraction scheme. In principle, a synchronous closed loop system can be converted into an asynchronous closed loop system by introducing bags with the following abstraction schemes:
\begin{itemize}
\item[M1.] by introducing bags between a plant and its supervisor such that \textit{the interaction between plant and bag is hidden} (see Figure~\ref{cm-m1}).
\item[M2.] by introducing bags between a plant and its supervisor such that \textit{the interaction between supervisor and bag is hidden} (see Figure~\ref{cm-m2}).
\item[M3.] by introducing bags between a plant and its supervisor such that \textit{the communication among the input actions of both plant and supervisor with bags are hidden} (see Figure~\ref{cm-m3}).
\item[M4.] by introducing bags between a plant and its supervisor such that \textit{the communication among the output actions of both plant and supervisor with bags are hidden} (see Figure~\ref{cm-m4}).
\end{itemize}
In Figure~\ref{cm}, thick lines are used to show the visible interaction and thin lines are used to show the invisible interaction. The notation  means `send action ' and  means `receive action '. In this paper, we develop the theory for the construction method M1 (see Section~\ref{sec:synctoasync} for the rationale behind this choice) and leave other construction methods as open for future study. Moreover, the techniques presented in this paper are restricted to reactive systems (so, no termination).

\begin{figure}\centering
\subfigure[Construction method M1.]{\label{cm-m1}
\includegraphics[width=0.35\textwidth]{figures/abs_sol1}}
\hspace{1cm}  \subfigure[Construction method M2.]{\label{cm-m2}
\includegraphics[width=0.35\textwidth]{figures/abs_sol2}
  }
\hspace{1cm} \subfigure[Construction method M3.]{\label{cm-m3}
\includegraphics[width=0.35\textwidth]{figures/abs_sol3}
  }
\hspace{1cm} \subfigure[Construction method M4.]{\label{cm-m4}
\includegraphics[width=0.35\textwidth]{figures/abs_sol4}
  }
\caption{Different ways to construct an asynchronous closed loop system.}\label{cm}
\end{figure}


\subsection{Outline}
The remainder of this paper is organized as follows. In Section~\ref{sec:background}, we start our exposition by defining the overall background required for this paper. Section~\ref{sec:introtorw} provides a brief introduction to supervisory control theory with respect to our setup. In Section~\ref{sec:synctoasync}, the construction method M1 is defined formally with its abstraction scheme. In Section~\ref{sec:DCL}, we give the formal definition of a desynchronisable closed loop system with the conditions that are sufficient for desynchronisability. Finally, in Section~\ref{sec:discussion} we present the conclusions and propose some directions for future research.

\section{Background}\label{sec:background}

In this section, we define the basic notations and definitions that will be used throughout this article. Let  be a set of action names. We use symbols  to range over the set . Then we define the following actions for an action label ,
\begin{itemize}
\item : send action label .
\item : receive action label .
\item : communicated action label .
\end{itemize}
Let  denote the set of all possible actions that are defined as,  The variables  are used to denote elements from set  when the information about the type of action is irrelevant. The set of all process terms (denoted by ) is then defined by the following grammar. The constant  is a process term that cannot perform any action, i.e. it can only \emph{deadlock}. A unary operator  for each action  is introduced in the TCP syntax, denoting an \emph{action prefix}. Intuitively, the process term  performs the action  and then behaves as the process . The binary operator  denotes the \emph{alternative composition or choice} between any two processes. The encapsulation operator , \emph{blocks execution of actions} from  while enduring the execution of other actions from . The abstraction operator  \emph{renames} the actions from  to , and leaves other actions unchanged.

\begin{center}

\end{center}

In the remainder of this paper, we assume that the symbols  range over the set . We fix the capital letters  for processes associated with supervisory control theory. Note that we also use the alphabet operator  and renaming operator  from TCP algebra for technical reasons, but not for modeling purposes. The empty process  is not defined because we are interested in modeling only reactive systems. The notation  denotes a recursion definition by a set of pairs  where  denotes a recursion variable and  the process term defining it. The parallel composition operator is parameterized with a communication function  such that 

The semantic domain of the process terms is a transition system (See \citep{acpbook} for details), which is achieved by the so-called SOS rules \citep{SOS}. For the sake of completeness, we give the SOS rules of the operators used here in the Appendix~\ref{osrules}.

\begin{definition}
A \emph{transition system} over a set of actions  is a set  of states, equipped with a transition relation . The action  denotes the invisible action. In the semantics of TCP,  is usually taken to be the set of process terms, i.e., , and the initial state of a process is defined as the process term itself. \qed
\end{definition}


As mentioned in the introduction, we use branching bisimulation to relate a synchronous closed loop system and its corresponding asynchronous closed loop system in which  actions are present. The presence of  actions in an asynchronous closed loop system will become evident in Section~\ref{sec:synctoasync}. We write the transitive closure of the transition relation  as . The symbol  is used to denote syntactical equivalence between process terms. The shorthand notation  is defined as  for all  with .

\begin{definition}\label{def-bb}
A binary relation  is called a \emph{branching bisimulation relation} \citep{acpbook,Glabeek90} iff:
\begin{itemize}
\item .
\item .
\item .
\item .
\end{itemize}
Let  be the initial states of processes , respectively. Two processes  and  are said to be branching bisimilar (denoted as ) iff there exists a branching bisimulation relation  such that there initial states  are related, i.e. . \qed
\end{definition}

Note that in the absence of  actions, branching bisimulation coincides with strong bisimulation. The phenomena of the occurrences of redundant silent steps can be formulated by the following notion of -inertness \citep{confluence}.

\begin{definition}
Let  be an arbitrary process. A process  is said to be \emph{-inert} with respect to  iff for all states  of the transition system (generated by operational rules) of  it holds that  where, . \qed
\end{definition}

The essence of the above definition is that an inert  action does not affect the future choices of a process modulo branching bisimulation. In Section~\ref{sec:DCL}, we also show that an asynchronous closed loop system constructed from a synchronous closed loop system satisfying Definitions~\ref{def-wellposed}, \ref{def-diamond} and \ref{def-reordering} is always -inert with respect to .

\section{Supervisory control theory}\label{sec:introtorw}

In this section, we give a brief introduction to supervisory control theory and define its fundamental entities in our setup. The basic entity (a plant, or a supervisor, or a requirement) in the supervisory control theory is deterministic. Furthermore, the proof of main Theorem~\ref{thm:char} requires the fact that a given synchronous closed loop system is also deterministic. Therefore, we now introduce the term deterministic process.

\begin{definition}\label{def:determinism}
A process  is called a \emph{deterministic process} iff
for all states  of the transition system (generated by the operational rules) of  and for all  it holds that  where, .\qed
\end{definition}

In supervisory control theory, plants and supervisors are allowed to perform events that are divided into two disjoint subsets: \emph{controllable} and \emph{uncontrollable} events. The idea behind this partition is that the supervisor can enable or disable controllable events so that the closed loop behavior is equivalent to the requirement. The supervisor can observe but cannot influence uncontrollable events. In this paper, we follow the input-output interpretation \cite{balemiphdt} between a plant and its supervisor; wherein the uncontrollable events are outputs from a plant to a supervisor and the controllable events are outputs from a supervisor to a plant. Thus, processes that model plants or supervisors must have distinct (because of the above partition) input and output actions in its alphabet. Such processes are called input-output processes.

\begin{definition}
The set of input actions for an arbitrary process  is denoted by  and is defined as . Similarly, the set of output actions (denoted by ) is defined as . A process  is called an \emph{input-output process} iff 
where, \qed
\end{definition}

The condition  ensures that an input-output process does not contain communicated actions in its alphabet. This is because bags are introduced to buffer both input and output events of an input-output process . So if communicated actions are allowed in the specification of the process  then, the information whether the action  is an input or an output action of the process  is unknown.

We now define the three basic entities in the supervisory control theory in our setup. A plant  is a deterministic and an input-output process. Similarly, a supervisor is a deterministic and an input-output process. A requirement is a process specifying the legal interaction that should occur while the plant and its supervisor are interacting such that a required task (for which the supervisor is synthesised) is completed. Thus, a requirement is a deterministic process  such that, 
where . This condition ensures that a requirement process only contains communicated actions in its alphabet.

Now, we can state the control problem as follows: given a plant  and a requirement , find a supervisor  such that, 
In this paper, we are not interested in how this supervisor is computed and rather assume that we are provided with a solution to the above equation. The goal of this paper is then to find certain conditions on the given synchronous closed loop system such that it is desynchronisable. Note that in supervisory control theory the control problem is based on language equivalence, but branching bisimilarity coincides with language equivalence in the presence of determinism and in the absence of  actions. However, we use branching bisimulation because the asynchronous closed loop systems as constructed in the next section are always nondeterministic. In brief, this cause of nondeterminism is due to the abstraction of interactions between a plant and the buffer.

\section{From synchrony to asynchrony}\label{sec:synctoasync}

In the previous section, we formally defined a plant , a supervisor  and a requirement  in our setup. Now, we extend our setup in accordance with the architecture of Subsection~\ref{subsec-arch}, to model asynchronous communication by introducing two bags between a given plant and its supervisor; one bag that contains input actions of  and another one that contains output actions of . Next we define a multiset and some operations over multisets that are necessary for the definition of a bag.

A multiset  over the set of communicated actions  is a tuple  where  is the corresponding multiplicity function. We write the empty multiset as , which is defined as , where  is the \emph{zero function}.

\begin{definition}
Let  be a multiset over the set .
\begin{itemize}
\item The predicate  is used to denote an element that \emph{belongs} to a multiset. It is defined as .
\item The operator  is used to denote an \emph{addition} of an element to a multiset. It is defined as  where,\newline \com a\in I\com a\not\in I and
x=\com a\wedge\com a\in Ix=\com a\wedge\com a\not\in Ix\neq\com a\wedge x\in I.
\item The operator  is used to denote a \emph{removal} of an element from a multiset. It is defined as  where,\newline
    \kappa(\com a)>1\kappa(\com a)=1 and
    x=\com a\wedge\kappa(\com a)>0x\neq\com a\wedge x\in I.\qed
\end{itemize}
\end{definition}

For each  we define a new element . Let  denote the set of new elements of the form .
Similarly we assume that there exists auxiliary hidden and blocking sets  and , respectively.

\begin{definition}{(\textbf{Bag}).}\label{bagdef}
Let  be a natural number representing the size of a bag process. Let  denote the empty multiset and  denote a multiset of communicated actions (i.e. the actions that are decorated with the symbol ). Then a \emph{bag process} over a set of actions  of size  is defined in the following way.
\qed
\end{definition}
The above definition is bounded with variable  that not only helps in modeling a realistic asynchronous implementation (as they contain buffers with finite memory). In contrast, it also aids in modeling an asynchronous implementation having buffers of infinite size, i.e., when . Notation, we denote the two interleaving bags as, 
where, ,  and  () denotes the size of bag associated with input (output) actions of the plant . Furthermore, the sets  and  denote the set of input and output actions of the plant , respectively.

Next we formally define an abstraction scheme that implements the construction method M1. Informally, it decorates the interaction between a plant and the two interleaving bags with the symbol , indicating such interactions are to be made hidden. We write the asynchronous closed loop system as  (for some ) constructed from its corresponding synchronous closed loop system  where,
\begin{itemize}
\item  is the modified communication function (or the abstraction scheme for method M1) defined in following way,\newline
!a\in\alpha^!(P)!a\in\alpha^!(S)
?a\in\alpha^?(P)?a\in\alpha^?(S)

Intuitively, the communication function  with the operators  ensures the interactions between the plant and the bag are invisible while the interactions between the supervisor and the bag are visible.
\end{itemize}

The rationale behind the choice of M1 is based on the observation that a transition system generated by a supervisor  is isomorphic to the corresponding synchronous closed loop system , modulo the difference in the type of action labels \citep{prDCL}. This is because in the synthesis of supervisors no transitions are introduced that a plant cannot execute. Moreover, the action labels in  will be decorated as either an input action (?) or an output action (!) while in  the same label will be decorated as a communicated action (). Formally, this fact is equivalent to

where,  is the renaming operator from TCP \cite{acpbook} and  is a function that renames an input/output action to a communicated action, i.e., .
As a consequence, when one introduces bags and abstracts the interaction between plant and bags, the supervisor model remains unaffected. While in other abstraction schemes this is not the case. Thus, it is easier to study abstraction scheme M1 than other schemes. 
\section{Desynchronisable closed loop system}\label{sec:DCL}

In the previous section, we have shown how to construct an asynchronous closed loop system from a given synchronous closed loop system. In general, the newly constructed asynchronous closed loop system will not be branching bisimilar to the given synchronous closed loop system. To this end, we introduce a special class of the synchronous closed loop system called desynchronisable closed loop system that are always branching bisimilar to their corresponding asynchronous closed loop systems. We then present sufficient conditions for desynchronisability.

\newcommand{\bagmn}{\ensuremath{\bag^{m,n}}}

\begin{definition}\label{def-desyncl}
Let  be a synchronous closed loop system and let  be any two nonzero natural numbers. Then,  is said to be \textit{desynchronisable} with input and output buffers of size  and  (or in short desynchronisable closed loop system), respectively, if 
\qed
\end{definition}

We now present three sufficient conditions for desynchronisability with buffers of arbitrary size. The objective of these conditions is the following. The conditions given in Definition~\ref{def-wellposed} and Definition~\ref{def-reordering} prevent an asynchronous closed loop system from getting deadlocked. The condition in Definition~\ref{def-diamond} ensures that the silent steps introduced by the abstraction scheme are inert.

\begin{definition}\label{def-wellposed}
Let  be a synchronous closed loop system. Then,  is called \textit{well posed} if there exists a binary relation  such that  and the following conditions are satisfied:
\begin{itemize}
\item  and
\item 
\end{itemize}
\qed
\end{definition}

\begin{figure}\centering
\includegraphics[width=0.4\textwidth,bb=14 14 347 153]{figures/diamond}
\caption{Diamond property.}\label{diamond-fig}
\end{figure}

We now partition \label{partition} the set  into two disjoint non-empty subsets  with respect to a plant process  as:
\begin{itemize}
\item .
\item .
\end{itemize}

\begin{definition}\label{def-reordering}
Let  and  be sequences in  and , respectively. Let  be an arbitrary process and let  be its initial state. We define the set of reachable states of  in the following way,
    
    By the semantics of TCP we know that if the initial state of a process is of the structure  then, all the reachable states will also be of the same structure. A synchronous closed loop system  is said to satisfy the \textit{reordering} property iff both the following conditions are satisfied,
    
\qed
\end{definition}

\begin{definition}\label{def-diamond}
Let  be an arbitrary state. Then,  is said to satisfy the \textit{diamond} property iff the following condition (see Figure~\ref{diamond-fig}) holds
\begin{itemize}
\item 
\end{itemize}
A process  is said to satisfy the diamond property iff for all reachable states  from  satisfy the diamond property, where  is the \emph{initial state} of the process . \qed
\end{definition}




For a reader familiar with the concepts of \emph{true concurrency} \cite{Winskel95}, the conditions given in Definition~\ref{def:determinism}, \ref{def-reordering} and \ref{def-diamond} are similar to the axioms of asynchronous transition system. The formulation of these axioms is based on the definition of an independence relation, which is an irreflexive, symmetric relation on the set of actions . However, the techniques for desynchronisability for such models are not investigated here, although it will be worthwhile to examine this research direction in the future. Note that in our approach we do not need an additional notion of the independence relation.

Next, we present the following main results of this paper.
\begin{itemize}
\item If an arbitrary synchronous closed loop system satisfy the conditions in Definitions~\ref{def-wellposed}, \ref{def-reordering} and \ref{def-diamond} then, it is a desynchronisable  with buffers of arbitrary size.
\item The transition system generated by an asynchronous closed loop system constructed from a synchronous closed loop system satisfying the conditions in Definitions~\ref{def-wellposed}, \ref{def-reordering} and \ref{def-diamond} is always -inert with respect to .
\end{itemize}
To prove the above statements, we first fix some notations and then prove some lemmas, which are necessary for the proof of main theorem.

We denote the contents of an arbitrary bag by the symbols , i.e.,  are of the form  and () respectively, where . The contents of the bag attached to input actions of  is denoted by , i.e.,  is of the form  where . Similarly the contents of the bag attached to output actions of  is denoted by , i.e.,  is of the form  where . For an arbitrary multiset , we define a sequence (denoted as ) over  as,
 such that , where  is a function that returns the maximum number of occurrences of  in  for some . For example consider a multiset . Then a possible sequence  over the given  can be of the form . Let  be the function defined as . Similarly, let  be the function defined as .

\begin{proposition}\label{prop:mu'}
Given a trace , we find using the above function  and semantics of  that .
\end{proposition}
\begin{proposition}\label{prop:mu}
Similarly, given a trace , we conclude that .
\end{proposition}

The following lemma is a generalisation of Definition~\ref{def-diamond}. It states that if two different states  are reachable from a state , then there exists a state  reachable from  and  such that, the trace between  and the trace between  commute.

\begin{lemma}[\textbf{Generalised diamond property}]\label{gdp}
Let  be an arbitrary synchronous closed loop system satisfying the conditions in Definitions~\ref{def-wellposed}, \ref{def-reordering} and \ref{def-diamond}. If  then,
    
\end{lemma}

The following Lemmas~\ref{dppi}, \ref{dppo} are the results (See \citep{desync} for the proofs) obtained by direct instantiation of reordering property (Definition~\ref{def-reordering}) and generalised diamond property (Lemma~\ref{gdp}).

\begin{lemma}\label{dppi}
Let  be a synchronous closed loop system satisfying the conditions in Definitions~\ref{def-wellposed}, \ref{def-reordering} and \ref{def-diamond}. Suppose  then, 
\end{lemma}

\begin{lemma}\label{dppo}
Let  be a synchronous closed loop system satisfying the conditions in Definitions~\ref{def-wellposed}, \ref{def-reordering} and \ref{def-diamond}. Suppose  then, 
\end{lemma}

We now pose the main theorem of this paper which proves the following statement. If the given synchronous closed system satisfies the conditions in Definition~\ref{def-wellposed}, \ref{def-reordering} and \ref{def-diamond}, then it is desynchronisable independent of the size of the buffers introduced between the given plant and its supervisor. 
\begin{theorem}\label{thm:char}
Let  be an arbitrary synchronous closed loop system satisfying the conditions in Definitions~\ref{def-wellposed}, \ref{def-reordering} and \ref{def-diamond}. Then for any  we have, 
\begin{proof}
Let  be free process variables. Let  be two free variables representing the contents of an input and an output bag of , respectively. Then, define a relation  as follows.

Note that the above conditions C1, C2, C3, C4 and C5 are independent of . The proof of the theorem is based on showing that  is a witnessing branching bisimulation relation. The intuition behind the definition of  is the following. A state  in a synchronous closed loop system is related to those states in an asynchronous closed loop system that contain the same supervisor state . The  relation between two states is indicated by dotted lines in Figure~\ref{fig:phi}.
\begin{figure}
        \centering
        \scalebox{0.96}{
        \begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto, semithick,]

  \tikzset{
    state/.style={
      circle,
      draw=black,
    }
  }

  \tikzset{
    super/.style={
      rectangle,
      rounded corners,
      draw=black,
    }
  }

\node[super] (qc) {};
\node[super] (qac) at () {};
\node[super] (qacf) at ()
{};
\node[super] (qact) at ()
{};
\node[super] (qacd) at ()
{};
\node (eqct) at () {};
\node (eqacft) at () {};

\path[-,dotted,blue] (qc) edge node {C1} (qac);
\path[-,dotted,blue] (qc) edge node {C2} (qact);
\path[-,dotted,blue] (qc) edge node {C3} (qacd);
\draw[-,dotted,blue] (qc) -- ();
\draw[-,dotted,blue] (qacf) -- ();
\path[-,dotted,blue] () edge node {C4 and C5} ();

\path[->>] (qact) edge node {} (qac);
\path[->>] (qact) edge node {} (qacf);
\path[->>] (qacf) edge node {} (qacd);
\path[->>] (qac) edge node {} (qacd);

\end{tikzpicture}          }
\caption{Illustration of relation .}\label{fig:phi}
\end{figure}
The complete proof requires a lot of case distinction and can be found in \citep{desync}. Here we discuss the different cases that are present in the proof and give the list of lemmas that are applied in each case. Let  be the initial states of the processes  and , respectively. From the definition of branching bisimilarity we need to show the following four transfer conditions:
\begin{enumerate}
\item 
\item\label{cond2} 
\item .
\item .
\end{enumerate}

Since the synchronous closed loop system does not contain  actions in its alphabet, there are following three effects on the above transfer conditions.
\begin{itemize}
\item The above condition 2 will be vacuously satisfied.
\item The condition 3 will be reduced to the simpler form,

\item And similarly condition 4 will be reduced to:

\end{itemize}
But to show that these conditions hold, we need to know whether an action label  occurring in each condition is either an input or output action with respect to , i.e.  or . Thus, we get six transfer conditions in total that are shown in Table~\ref{table1}. Furthermore, for each case we apply case distinction based on the structure of  and . In each subcase we use C1, C2, C3, C4, and C5 (the conditions from the definition of ) to determine the relation between free process variables  and then prove the conclusion as shown in Table~\ref{table1}. The notation  is used to denote that the  action is a result of abstraction of the communicated action .
\begin{table}[ht]
\caption{Proof structure of Theorem~\ref{thm:char}.}
\centering \begin{tabular}{|c|l|l|}
  \hline
  Case No. & Hypothesis & Conclusion\\
  \hline
\inct & . & \\
  \inct & .& \\
  \inct & &  \\
  & . & \\
  \inct & &  \\
  & . &\\
  \inct & .&  \\
  \inct & .& \\
  \hline
\end{tabular}
\label{table1}
\end{table}

In Table~\ref{lemma-applicable} we present the list of lemmas required to prove each case.

\begin{table}
  \centering
  \begin{tabular}{|l|l|}
    \hline
    Case No. & List of lemmas\\
    \hline
T1 & Lemma~\ref{gdp} \\
    T2 & Lemma~\ref{gdp} and Proposition~\ref{prop:mu'} \\
    T3 & Lemma~\ref{gdp} and Lemma~\ref{dppi}\\
    T4 & Lemma~\ref{gdp} \\
    T5 & Lemma~\ref{gdp} and Lemma~\ref{dppo} \\
    \hline
  \end{tabular}
  \caption{List of lemmas applied in each case.}\label{lemma-applicable}
\end{table}

\end{proof}
\end{theorem}

In hindsight, what we have actually proven is that all  actions generated by the abstraction scheme are -inert with respect to  The following corollary states this fact.

\begin{corollary}\label{thm:tauinert}
Let  be a process of the form . And let  be an asynchronous closed loop system of the form  such that . Then,

\end{corollary}

\section{Conclusions and future work}\label{sec:discussion}

In this paper, we presented sufficient conditions for desynchronisability in a process algebraic setting and showed that an asynchronous implementation using bags (of arbitrary size) is a refinement of the synchronous closed loop system satisfying these conditions.
The prominent features of our work can be summarised in the following main points:
\begin{itemize}
\item We solve a refinement problem instead of a supervisory control problem, and do not compute a new supervisor in the presence of buffers, as done in \citep{balemiphdt,async-imp}. Our approach is \textit{intended} to be computationally cheaper than the one developed in \citep{balemiphdt,async-imp}, however this conjecture needs to be verified by analysing the complexities associated with the conditions presented here. In particular, we conjecture that supervisory control theory always results in synchronous closed loop systems, which are well-posed (Definition~\ref{def-wellposed}), but the other conditions, (Definition~\ref{def-reordering} and Definition~\ref{def-diamond}), are not likely to be attained so easily.
\item We present our conditions for desynchronisability over the components of a synchronous closed loop system conjointly, in contrast with \citep{Fischer96}, where the check for the foam rubber wrapper principle on the two components was applied separately. Note the sender domination property from \citep{Fischer96} is equivalent to the well posed condition (Definition~\ref{def-wellposed}). However, the two approaches are incomparable because in \citep{Fischer96} the construction method M3 was studied while in this paper the construction method M1 is studied.
\item We use branching bisimulation equivalence instead of failure equivalence that was adopted in \citep{Fischer96}. As a consequence our techniques are applicable to all the weak equivalences in `van Glabbeek spectrum' \citep{Glabeek90} (including failure equivalence). The branching bisimulation is the preferred equivalence in TCP process algebra under the presence of  action \citep{acpbook}. Furthermore, the conditions (well posedness and diamond property) given here are similar to the ones mentioned in \citep{Fischer96}, where desynchronisability was characterised modulo failure equivalence. Thus, we conjecture that achieving desynchronisability for weaker equivalences will not lead to weaker sufficient conditions.
\end{itemize}


A question that was not treated in this paper, is whether the conditions we posed are in fact reasonable for industrial applications. This may become clear in the near future, when we
study the case studies involved with supervisory control theory in the context of MULTIFORM project \citep{multiform} with the language CIF \citep{cif}. The authors of CIF are currently developing techniques that will incorporate supervisory control theory and model based engineering into a single framework, thus making it suitable for the design of industrial applications. In particular, the elevator case study and the toy example, which were desynchronisable in \citep{prDCL} using the construction method M1, satisfy our conditions.

Another question is whether the conditions given are actually necessary for desynchronisability modulo branching bisimilarity. Formally speaking, they are not, and counter-examples have been found although we do not give them here. We anticipate that the diamond property (Definition~\ref{def-diamond}) can be further weakened. In particular, if the actions  are enabled at a state  then it may not be necessary for the traces  and  to commute.

Lastly, the research performed in this paper can of course be repeated for different architectures. One might study whether wires or queues can be used instead of bags, or study different abstraction schemes, or try to study the conditions for desynchronisability by focusing on other notions of weak equivalences.

\section{Acknowledgements}\label{sec:ack}
The authors would like to thank the reviewers for their valuable critical remarks on the earlier draft of this paper and pointing out that the sender domination property and the well posed property are equivalent. The authors would also like to thank Jos Baeten, Koos Rooda, Bert van Beek,
Rong Su, Jasen Markowski, Damian Nadales, and Mihaly Petreczky for various discussions and clarification about this work.

This work has been performed as part of the ``Integrated Multi-formalism Tool Support for the Design of Networked Embedded Control Systems'' (MULTIFORM) project, supported by the Seventh Research Framework Programme of the European Commission (Grant agreement number: INFSO-ICT-224249).

\bibliographystyle{plainnat}
\bibliography{paper}
\appendix
\section{Operational semantics of TCP}\label{osrules}

In this section, we give the SOS rules for the operators used in this paper. Note that the rules for symmetric case (in the context of binary operators) are not given.



\begin{definition}
The alphabet of a process , written as , is the set of atomic actions that it can perform. It is defined for the following closed terms.

Note that  is not defined explicitly for the operators  because these operators can be eliminated (See the corresponding elimination theorems in \citep{acpbook}).\qed
\end{definition}


\end{document} 
