\documentclass{LMCS}

\def\dOi{11(3:6)2015}
\lmcsheading {\dOi}
{1--72}
{}
{}
{Dec.~17, 2014}
{Sep.~\phantom03, 2015}
{}

\ACMCCS{[{\bf Theory of computation}]: Logic---Linear logic\,/\,Proof
  theory; Semantics and reasoning---Program semantics---Categorical semantics}



\usepackage{hyperref}
\renewcommand{\subsectionautorefname}{\S{}}


\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{txfonts} \usepackage{pxfonts}
\usepackage{diagrams}
\usepackage{exscale} \usepackage{tensor}
\usepackage{framed}
\usepackage{bussproofs}

\usepackage{graphics} \usepackage{color} \usepackage{subfigure} 

\usepackage{changepage} \newenvironment{clmenv}[1][10mm]{\begin{adjustwidth}{#1}{}}{\end{adjustwidth}} 

\usepackage{amsmath, amssymb, latexsym, amsthm,url}
\usepackage{nccmath}
\usepackage{xxcolor}
\usepackage{tikz}
\usetikzlibrary{positioning}
\usepackage{mathtools}
\usepackage{pxfonts}
\scrollmode 
\newcommand{\tens}{\mathbin{\otimes}}
\newcommand{\opcat}[1]{{#1}^{\sf op}}

\usetikzlibrary{shapes}
\usetikzlibrary{positioning,arrows}

\theoremstyle{plain}\newtheorem*{cLm}{Claim}
\def\eg{{\em e.g.}}
\def\cf{{\em cf.}}

\newcommand{\mll}{MLL} \newcommand{\mall}{MALL}
\newcommand{\lin}{\ttfamily LL\rmfamily}
\newcommand{\addll}{\ttfamily ALL\rmfamily}
\newcommand{\mllmix}{MLL+Mix} \newcommand{\GRel}{\mathbf{GRel}}
\newcommand{\mllmixmaybe}{MLL(+Mix)}
\newcommand{\otensor}{\otimes}

\newcommand{\Wedge}{\bigwedge}
\newcommand{\Vee}{\bigvee}
\newcommand{\C}{\mathbb{C}}
\newcommand{\D}{\mathbb{D}}
\newcommand{\GC}{\mathbf{G}\mathbb{C}}
\newcommand{\G}[1]{\mathbf{G}#1}
\newcommand{\gc}[1]{\mathbf{G}_{#1}\mathbb{C}}
\newcommand{\F}{\mathbb{F}}
\newcommand{\FDVec}{\mathbf{FDVec}_{\mathbb{F}}}
\newcommand{\GFDVec}{\mathbf{GFDVec}_{\mathbb{F}}}
\newcommand{\after}{\circ}
\newcommand{\bdl}{bounded distributive lattice}
\newcommand{\Pl}{P}
\newcommand{\finary}{\mathbf{FinAry}_{L}}
\newcommand{\ary}{\mathbf{Ary}_{L}}
\newcommand{\fary}{\mathbf{(Fin)Ary}_{L}}
\newcommand{\Rel}{\mathbf{Rel}}
\newcommand{\I}{\mathbf{I}}
\newcommand{\E}{\mathbb{E}}
\newcommand{\hary}{\mathbf{HAry}_{L}}
\newcommand{\p}{} \newcommand{\N}{\mathbb{N}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\K}{\mathcal{K}_{\mathbf{I}}}
\newcommand{\Mix}{\mathbf{Mix}}
\newcommand{\mix}{\mathbf{mix}}
\newcommand{\MIX}{\mathbf{MIX}}
\newcommand{\bbrk}[1]{[\![#1]\!]}
\newcommand{\GiC}{\mathbf{G}_{1}\mathbb{C}}
\newcommand{\GsC}{\mathbf{G}_{E}\mathbb{C}}
\newcommand{\Parf}{\mathbf{Par}}
\newcommand{\HypCoh}{\mathbf{HypCoh}}
\newcommand{\huh}{U} 

\newcommand{\Perm}{\mathop{\mathsf{Perm}}\nolimits}
\newcommand{\PPerm}{\mathop{\mathsf{PPerm}}\nolimits}
\newcommand{\cycle}{\mathbf{cycle}}

\newcommand{\dbigotimes}{\textstyle{\bigotimes}}
\newcommand{\tbigotimes}{\textstyle{\bigotimes}}
\newcommand{\dbigoplus}{\textstyle{\bigoplus}}
\newcommand{\tbiginvamp}{\displaystyle{\invamp}}


\newcommand{\binvamp}{\displaystyle{\invamp}}
\newcommand{\bforall}{\displaystyle{\forall}}
\newcommand{\botimes}{\textstyle{\bigotimes}}
\newcommand{\boplus}{\textstyle{\bigoplus}}
\newcommand{\fct}[3]{\mbox{\/}}
\newcommand{\fctl}[3]{\mbox{}\/}
\newcommand{\fromto}[2]{\mbox{\/}}
\newcommand{\goesto}[2]{\mbox{\/}}
\newcommand{\fctmapsto}[3]{\mbox{\/}}
\newcommand{\cfct}[5]{\mbox{\/}}

\newcommand{\inj}{\mathop{\mathsf{in}}\nolimits}

\newcommand{\sek}{ยง}

\newcommand{\hugha}[1]{} \newcommand{\hughb}[1]{} 

\newcommand{\hugh}[1]{#1}
\newcommand{\hughc}[1]{#1}
\newcommand{\hughd}[1]{#1}
\newcommand{\hughe}[1]{#1}
\newcommand{\hughf}[1]{#1}
\newcommand{\hughg}[1]{#1}
\newcommand{\hughh}[1]{#1}

\begin{document}
\title[Constructing Fully Complete Models of Multiplicative Linear Logic]{Constructing Fully Complete Models of \\ Multiplicative Linear Logic\rsuper*}

\author[A.~Schalk]{Andrea Schalk\rsuper a}	\address{{\lsuper a}School of Computer Science, University of Manchester, Oxford Road, Manchester M13 9PL, UK}	\email{andrea.schalk@manchester.ac.uk}  

\author[H.~P.~Steele]{Hugh P. Steele\rsuper b}	\address{{\lsuper b}Universit\'e Paris 13, Sorbonne Paris Cit\'e, LIPN, CNRS, F-93430, Villetaneuse, France}	\email{hugh.steele@lipn.univ-paris13.fr}  







\keywords{Linear Logic, -Autonomous Categories, Compact Closed Categories, Full Completeness, Tensor Calculus}
\titlecomment{{\lsuper*}A preliminary version of this article appeared in the proceedings of LICS 2012~\cite{SS12}.}




\begin{abstract}
The multiplicative fragment of Linear Logic is the formal system in this family with the best understood proof theory, and the categorical models which best capture this theory are the fully complete ones. We demonstrate how the Hyland-Tan double glueing construction produces such categories, either with or without units, when applied to any of a large family of degenerate models. This process explains as special cases a number of such models from the literature. In order to achieve this result, we develop a tensor calculus for compact closed categories with finite biproducts. We show how the combinatorial properties required for a fully complete model are obtained by this glueing construction adding to the structure already available from the original category.
\end{abstract}

\maketitle

\section{Introduction}

Linear Logic~\cite{Gir87} is a well-known formal system that has
attracted interest from computer science as well as logicians. It has
a very well behaved proof theory, and categorical models for linear
logic also contain a model of the \hugh{(linear)} simply-typed -calculus. {\em
  Fully complete}~\cite{AJ94} models are those that equate precisely
those proofs considered equivalent by the proof theory, and which
exclusively contain morphisms that are the interpretation of some
proof.

\p The best understood fragment of linear logic is that of {\em
  unit-free Multiplicative Linear Logic},~\mll. To model that one
requires a -autonomous category~\cite{Bar79}, but not all such
categories satisfy the desired full completeness property. \hugh{For example, compact closed categories~\cite{KL80}, which are thought of as \emph{degenerate} models of \mll, do not satisfy full completeness for the logic. The Chu construction~\cite{Chu79} creates -autonomous categories which generally are not fully complete. Pre-existing studies of
`good' models in this stronger sense are~\cite{HO93, Loa94a, DHPP99}.}

\p In~\cite{Tan97} the {\em double glueing}\/ construction is
introduced (see also~\cite{HS03} for a general account), and it is
suggested that fully complete models may be obtained when this is
applied to three particular compact closed categories. The three
categories in question are the category  of sets and
relations, the category  of finite
dimensional vector spaces over an arbitrary field  of
characteristic 0, and the category of Conway games and history-free
strategies. However, the proof of the second---arguably the most
interesting case---is not completed in the cited work; and the
restriction regarding the characteristic of the field turns out to be
unnecessary. Furthermore no two of the three proofs lend themselves
to a common unification.

\p In this paper, a greatly expanded version of the extended abstract~\cite{SS12}, we provide an entirely new approach to proving \hughh{full completeness which can be applied to a large variety of models provided by {\em tensor-generated compact closed categories with finite biproducts} to which the double glueing construction has been applied.} 
In the process we develop a `tensor calculus' for such categories,
and discuss its combinatorial consequences. The full completeness
proofs consist of algorithms which calculate the required
proof-theoretic structure for a given natural transformation. As a
consequence using the tensor calculus has a very algorithmic flavour, and there is certainly interesting future work to be done to connect this with other such work, for example in game semantics. \hughh{Both  and  belong to this collection of compact closed categories, and so the result is indeed a generalisation of Tan's work.}

\p For the sake of self-containment, we start in Section~\ref{BackgroundSection} by offering some background information relevant to the theorem being proved. This includes a short introduction to unit-free multiplicative linear logic and its proof theory, as well as its categorical models and the double glueing construction which can be placed over them. We then provide a formal description of the `tensor calculus' and its validity for the resulting categories within Section~\ref{ArrowDecomp}. It is within Section~\ref{SectionGCFC} that we provide the proof of our main result, Theorem~\ref{fcomp}, which
says that all \hughg{compact closed categories with finite
biproducts satisfying an extremely weak version of full completeness give rise to fully complete \mll\ models via double
glueing}. Using a mixture of results from earlier sections and
from~\cite{Tan97}, we finish by demonstrating in Section~\ref{SectionMLLMixFC} that the same double glueing construction under a \emph{slack focused orthogonality}~\cite{HS03} can produce fully complete models of \mllmix, the multiplicative fragment of linear logic with the `Mix' rule (Theorem~\ref{mixfcomp}).

\p The results in this paper are taken from the thesis of the second
author~\cite{Ste13}. The thesis, to which we occasionally refer, offers further background and discusses
some issues in more detail than is possible here.

\section{Background} \label{BackgroundSection}

In this section we give a short account of the well-known proof theory of \mll\ \cite{DR89} and how this system can be modelled categorically~\cite{BFSS90,Blu93}. We repeat the
formal notion of full completeness for such models, and indicate what can be said about the models provided by compact closed categories. An introduction to double glueing and orthogonalities is also contained within this background survey.

\subsection{Cut-Free \mll~Proof Nets}

The linear logic fragment \mll\ possesses a beautiful proof theory
revolving around the notion of proof nets~\hughd{\cite{Mel06,Str06}}. Proof nets provide a
method of equating two distinct derivations which differ only due to
`bureaucracy'~\cite{Gir87}. Since derivations in \mll\ can be
normalised confluently, we are interested primarily in cut-free
\mll~proof nets. It is sufficient to consider right-sided sequents of
formulae built from literals (which in a derivation are created as
pairs, one positive, one negative) using the multiplicative
conjunction  and disjunction~. Given a deduction
in the system we can construct a graph by using the parse trees of
the final sequent, connecting those literals that are created
together in said proof via edges known as \emph{(axiom) links}. This
is the {\em proof net}\/ that corresponds to the derivation, and we
wish to equate those deductions that have the same proof net.

\subsubsection{Correctness Criteria}

While every proof net represents a derivation, it is possible to
create graphs which resemble proof nets but do not correspond to
correct derivations. Given a parse tree for a sequent constructed
from literals and the \mll\ connectives  and  we
use the term {\em proof structure} for a graph resulting from
connecting matching literals.

\hughh{In this paper, proof structures are written only as the sequent together with its set of axiom links connecting appropriate literals above it. An example is given below.}
\begin{center} \vspace{5mm}
\begin{tikzpicture}
  [auto, node
  distance=6mm, skip loop/.style={to path={-- ++(0,#1) -| (\tikztotarget)}}] \tikzstyle{every node} = [text depth=-5pt,text height=0.5ex]
   \node (1) {}; \node (a) [right of=1] {} ;
  \node (2) [right of=a] {}; \node (b) [right of=2] {} ;
  \node (3)  [right of=b, xshift=-1mm] {}; \node (c)  [right of=3] {};
  \node (4)  [right of=c] {}; \node(d) [right of=4] {} ;
  \node (5) [right of=d, xshift=-1mm] {}; \node (e) [right of=5] {} ;
  \node (6) [right of=e] {}; \node (f) [right of=6] {} ;
  \node (7)  [right of=f,xshift=-1mm] {}; \node (g)  [right of=7] {};
  \node (8)  [right of=g] {};
\begin{scope}\path   (1)  edge [black, skip loop =6mm, shorten >=3mm, shorten <=3mm]  (2);
\path (3)  edge  [black, skip loop =6mm, shorten >=3mm, shorten <=3mm] (4);
\path   (5)  edge [black, skip loop =6mm, shorten >=3mm, shorten <=3mm]  (6);
\path (7)  edge  [black, skip loop =6mm, shorten >=3mm, shorten <=3mm] (8);
\end{scope}
\end{tikzpicture} \vspace{5mm}
\end{center}

\p It is possible to check whether a given proof structure is, in fact,
a proof net~\cite{DR89} using certain \emph{correctness criteria}. A
\emph{switching} of a proof structure is a subgraph created by
removing exactly one of the two argument edges of each
-vertex. A proof structure is a proof net if and only if every one of its
switchings is both {\em acyclic}\/ and {\em connected}.

\subsubsection{MDNF~Proof Structures} \label{MDNFProofStructures}

Multiplicative linear logic does not possess all the distributivity laws associated with Boolean logic. However, there are \hugh{\emph{weak distributivity} laws}\footnote{\hugh{These are sometimes known as linear distributivity laws.}} which have the effect of ``weakening'' formulae into a state closer to (and to closure into) a disjunctive form.

\begin{prooftree}
\AxiomC{}
\LeftLabel{\scriptsize()}
\UnaryInfC{}
\end{prooftree}
\begin{prooftree}
\AxiomC{}
\LeftLabel{\scriptsize()}
\UnaryInfC{}
\end{prooftree}
\begin{prooftree}
\AxiomC{}
\LeftLabel{\scriptsize()}
\UnaryInfC{}
\end{prooftree}
\begin{prooftree}
\AxiomC{}
\LeftLabel{\scriptsize()}
\UnaryInfC{}
\end{prooftree}

\hugh{From now on, in the appropriate contexts, we use the following notation: , and .}


\begin{defi}
An \mll~formula  is in \emph{multiplicative disjunctive normal form} (or~\emph{MDNF}) if \hughd{ for literals  for some , , and functions  and  indicating the literal and polarity of said literal respectively, \hughf{where  denotes an empty superscript, and therefore positivity}}. Each subformula \hugh{} of  for a given  is called a \emph{block} of the formula. An \mll~sequent is considered to be in \emph{MDNF} if all its constituent formulae are in MDNF; and its blocks are the blocks of its formulae.
\end{defi}

The correctness criteria for proof structures over \mll~sequents which are in MDNF are even further simplified. 





\begin{fact} \label{FactMDNFCorrectness} \hugh{\cite{Ste13}}
  An MDNF proof structure is a proof net for \mll\ if and only if its maximal
  -free subgraph is a tree.
\end{fact}

\hughh{The simplicity of these MDNF proof structures and their correctness criteria is very useful to us when proving full completeness in a category. As is seen in Sections~\ref{SectionGCFC} and~\ref{SectionMLLMixFC}, seemingly weaker full completeness theorems concerning only sequents of this form can be shown to be equivalent to theorems dealing with all sequents.}

\p \hughh{Each block of literals in a MDNF~structure written as a sequent with axiom links can be seen as one large vertex without affecting the acyclicity and connectedness of graph (the switchings of their parse trees are indeed still trees), and the instances of `' can be ignored by Fact~\ref{FactMDNFCorrectness}. From this perspective, we can check this graph for acyclicity and connectedness very swiftly. For example, the MDNF proof structure below is clearly incorrect due to the cycle between the two blocks.}

\begin{center} \vspace{5mm}
\begin{tikzpicture}
  [auto, node
  distance=5mm, skip loop/.style={to path={-- ++(0,#1) -| (\tikztotarget)}}] \tikzstyle{every node} = [text depth=-5pt,text height=0.5ex]
   \node (1) {}; \node (a) [right of=1] {} ;
  \node (2) [right of=a] {}; \node (b) [right of=2] {} ;
  \node (3)  [right of=b] {}; \node (c)  [right of=3] {};
 \node (4)  [right of=c] {};
\begin{scope}\path   (2)  edge [black, skip loop =6mm, shorten >=3mm, shorten <=3mm]  (3);
\path (1)  edge  [black, skip loop =7mm, shorten >=3mm, shorten <=3mm] (4);
\end{scope}
\end{tikzpicture} \vspace{2mm}
\end{center}

\subsubsection{The `Mix' Rule}

Although not a formal part of linear logic, the `Mix' rule is routinely seen as a part of the multiplicative structure. This is partly due to its insistence to being represented in many standard models, not least the category of coherence spaces~\cite{Gir87}. The proof theory of \mll\ is however not unduly made too difficult by the addition of this derivation rule. Thanks to \cite{FR94} we know that the only true difference which can occur between correct proof structures for \mll\ and \mllmix\ regards the disconnectedness of switchings.



\begin{fact} \hugh{\cite{FR94}}
An \mll~proof structure describes a proof net for \mllmix\ if and only if all its switchings are acyclic.
\end{fact}

\p It is also possible to create a `Mix' version of the MDNF criterion of the previous section:
\begin{fact} \hugh{\cite{FR94,Ste13}}
An MDNF proof structure is a proof net for \mllmix\ if and only if its maximal
  -free subgraph is a forest.
\end{fact}

\subsection{Sound Categorical Models} \label{CatModels}

Sound categorical models of \mll\ are found in the form of
-autonomous categories~\cite{Bar79,See89}---these are symmetric monoidal
categories with a well-behaved self-duality. The underlying idea is
quite simple: Each symbol in the logic is interpreted by a functor
(of the appropriate arity) on the category; the monoidal structure
 gives conjunction, the duality  allows negation,
and to model disjunction these can be combined to define a De Morgan
dual . We use the
latter functor also to interpret the commas separating formulae in a
sequent.

\p Hence every sequent in \mll\ determines a functor
 where . \hugh{That is to say, each sequent is described by a multivariant endofunctor with  co- and contravariant arguments respectively.} If
we look at these functors then we see that they are built by
\begin{itemize} \item applying the duality functor  to each
  copy of~,
\item creating as many copies of the arguments as
  required, then reordering them appropriately,
\item applying the functors  and  to
  get a result in~.
\end{itemize}
We refer to the functors that can be built in this way as {\em \mll~functors}. Similarly, functors that correspond to MDNF~sequents are
referred to as {\em MDNF~functors}.
  
\p Assume we have a right-sided sequent interpreted by the \mll\
functor~. The formula representing truth is interpreted by the functor whose
value is the constant , the unit for the monoidal structure. We
refer to this functor as , and allow ourselves to adjust its
source as needed. Every proof of the given sequent is interpreted by
a {\em dinatural transformation} from  (with the same source
as~) to~, which is a family of arrows  for which
the diagram below commutes for every , where
.


\begin{defi}
An {\em \mll} (respectively {\em MDNF}) {\em transformation}\/ is a dinatural transformation to an \mll\ (respectively MDNF)
functor from a constant functor  of appropriate source.
\end{defi}

It is possible to build \mllmixmaybe\ transformations corresponding to correct one-sided sequent derivations of the logic in an\label{SoundnessTechnique} inductive manner~\cite{Ste13} in any -autonomous category. Furthermore, it can be shown that any two derivations which reduce to the same cut-free proof net are represented by the same \mll\ transformation in the category~\cite{LS06}. This suggests that -autonomous categories are a sensible collection of models through which one can investigate \mll.

\p Dinatural transformations do not naturally compose with one another. However, they are capable of being composed with transformations natural in all components. The diagram below demonstrates the dinatural behaviour a composition of natural~ and dinatural~.

\label{DiNatsComposeStatement}

The equivalent result for precompositions is demonstrated in a dual manner.

\p One can now show that two proofs of the same sequent are interpreted
by the same dinatural transformation if and only if they have the
same proof net~\cite{LS06}. In other words, this categorical interpretation of
proofs fits very well with the existing proof theory for~\mll.

\p With -autonomous categories being sound categorical models of \mll, it is expected that they should all contain natural transformations which model the \hugh{weak distributivity} laws discussed in Section~\ref{MDNFProofStructures}.


It is shown how one can construct each of them in~\cite{Ste13}.

\p The `Mix' Rule is modelled in a -autonomous category if and only if there is a natural transformation . This is equivalent to there existing a `Mix' morphism ~\cite{Tan97}.

\subsection{Full Completeness}

Full Completeness was first defined in~\cite{AJ94}, and it is meant
to describe the tightest possible connection between the logic and
its model. Not only are the interpretations of two proofs the same if
and only if they are equivalent in the proof theory, but the model
does not contain any representations of `non-proofs'.\footnote{The name `full completeness' is derived from its original non-dinatural interpretation sense, in that the property establishes the existence of a full functor between the model category and a free -autonomous category. With this analogy in mind, due to every pair of derivations sharing the same cut-free proof net corresponding to the same \mllmixmaybe\ transformation, the satisfaction of the above definition may be more accurately described as full \emph{and faithful} completeness. However, for the sake of convenience and easy comprehension, we keep to the originally given name.}

\p In the case of the work in this paper, we are considering what this means from a dinatural interpretation of proofs. This provides us with the following definition, which originates from the notion as it is set out in~\cite{BS96}, and is further used in such works as~\cite{Loa94b,Tan97,Hag00}:

\begin{defi}
  A -autonomous category  satisfies \emph{\mllmixmaybe\ full
    completeness} if every \mllmixmaybe\ transformation in the
  category is the interpretation of a cut-free proof net.
\end{defi}



\subsection{Compact Closed Categories with Finite Biproducts} \label{SectionCompCCs}
 
Compact closed categories~\cite{KL80} are particular degenerate -autonomous
categories which possess a parameterised adjunction  (we denote the negation function  for historical reasons in these categories). The existence of this \hugh{adjunction} induces an invertible `Mix' natural transformation  between the two functors modelling the binary connectives. Nonetheless it turns out that they can form the basis for constructing fully complete models, as is seen in Sections~\ref{SectionGCFC} and~\ref{SectionMLLMixFC}.

\p \hughc{The adjunction associated with compact closed categories creates a bijective correspondence . This, along with the coherence properties of symmetric monoidal categories and the functoriality of tensor, ensure that the \mll~transformations can be reproduced in the following manner:}
\begin{enumerate} \label{CompCCDinatModelling}
\item Take the \hughc{right natural isomorphism} on each of the basis \mll~functors,

with  the projection of the  component of the product category  for each .
\item Use the parameterised adjunction associated with these categories with the \hughc{right isomorphism} to produce dinatural transformations \hughc{ for each argument}\footnote{\hughc{This dinatural transformation is indeed the collection of arrows  first discussed in~\cite{KL80}}}.
\item If the sequent whose derivation is being modelled contains  positive/negative occurrences of the literal being modelled with the  entries of the functors for each , then create the \mll~transformation

\item Use the associativity and symmetry isomorphisms  and  to rearrange brackets and the ordering of the literals so that those literals are found in the same order and the brackets in the same place as the functor requires. If the  and  literals are supposed to be connected by an axiom link, then it must be ensured that the two literals found in those positions are two that were created simultaneously by the exact same `axiom link' dinatural transformation. \hughd{The resulting dinatural transformation can be thought of as a \emph{fixed-point-free involution}, relating literals to their negations.}
\item Use the natural transformation  liberally to change all  functors into  functors where necessary to shape the target functor to create the \mll~functor in the category.
\end{enumerate}

\p\noindent Unfortunately, this advantage comes with a natural drawback: the unrestricted freedom to generate representations of axiom links within the \mll\ transformations means that unsequentialisable proof structures can be modelled just as easily as genuine proof nets. As such, \mll~full completeness cannot be satisfied by any of these categories.

\p In this paper we are more interested in the case where there is even more structure than that given above,
namely where the compact closed category  has finite biproducts.
Recall~\cite{Hou08} that  has finite products if and only if it
has finite sums if and only if it has finite biproducts. In this case
the scalars (that is the homset of endomorphisms on the tensor unit ) form a commutative unital semiring, and due to the
biproducts distributing over the tensor product  is enriched over
---the category of commutative
semimodules over the semiring of scalars~\cite{Heu08}.

\p \hugh{Given a set of dinatural transformations of the same type  for some index set , we define a linear combination  of them as the collection of arrows .} It is easy to show that in such a category every linear combination
of dinatural transformations is another such, giving \hugh{a second} obstacle
to full completeness. Nonetheless, from the above limitations, there is a clear concept of
a compact closed category with finite biproducts being `as fully complete as it can hope to be'.

\begin{defi} \label{FeebleFCDefn}
  A compact closed category  with finite biproducts satisfies
  \emph{feeble full completeness} if every \mll\ transformation
  for the category is a linear combination of interpretations of
  proof structures over the same sequent.
\end{defi}

\p It is known from~\cite{CHS01} (proof reproduced in~\cite{Ste13}) that finite biproductal compact
closed categories whose tensor unit acts as a separator satisfy
feeble full completeness. These models are called
\emph{tensor-generated}, and there are many of them. Examples include
both  and  for any field
, and extend beyond these to include categories such as
that of finite-dimensional Hilbert spaces. Every compact closed
category with finite biproducts clearly has a non-trivial full
subcategory which is tensor-generated, namely the category generated
by the object  and the tensor, biproduct and duality functors.

\subsection{The Double Glueing Construction} \label{SectionDGlueing}

Double Glueing constructions~\cite{HS03} operate upon categories. They can be thought of as adding structure to objects in the form of two arrows, which then has to be preserved by the morphisms of the newly created category. This leaves a trivial forgetful functor~ from the double-glued category to the original. When the added structure arrows are monomorphisms, this has the effect of generating homsets between two objects in the new category which are fundamentally subsets of the homsets of their underlying objects.~\cite{Ste13} That is,


\p The most commonly seen double glueing construction used on top of models of linear logic is the so-called Hyland-Tan construction~\cite{Tan97}, inspired by Loader's linear logic predicates~\cite{Loa94b}. This double glueing is based upon structure arrows which take the form of injections into homsets in~, and so are clear monomorphisms, allowing us to use the above fact. We define this construction formally below.

\begin{defi} \label{GCDefn}
Given a -autonomous category  \hugh{with tensor unit , and letting }, the category  is the category described with the following object set and homsets:
\begin{itemize}
\item Objects --- 
\item Arrows --- Arrows in  are described by single morphisms  such that:
	
\end{itemize}
\end{defi}

In general, when discussing a -object , we refer to  and  as the object's sets of \emph{values} and \emph{covalues} respectively. We write


As with any double glueing, the Hyland-Tan construction preserves -autonomy, and it also removes the degeneracy of compact closed categories. Tensor products and negations of arrows are immediately inherited from the underlying category --- indeed, the functor  is -autonomous. The object assignments are as follows:

where .

\subsubsection{Focused Orthogonalities} \label{SectionFocusedOrth}

Many examples of double-glued structures which have been investigated, particularly ones in which their glued nature is hidden, have restrictions on the objects which they are allowed to contain. For example, the category of Chu Spaces~\cite{Chu79} can be thought of as a full subcategory of a generalised version of the category  under the influence of a double-glueing \cite{Hug04}. Of course, the constraints must be defined sensibly in order to preserve the closure of the operations defined on such categories. These constraints are called \emph{orthogonalities}, and they can come in a variety of forms. In this paper, we wish to look at \emph{focused}, \emph{slack} orthogonalities.

\p Given any subset , we can construct an orthogonality in which two morphisms  and  are considered orthogonal if and only if they compose to form an arrow in the chosen set. This is called the orthogonality \emph{focused on} , and spawns a \emph{focused glueing}  whose values and covalues must be mutually orthogonal.

\begin{defi}
Given a -autonomous category  and a set , the category  is defined as the smallest full subcategory of  containing every object  such that

\end{defi}

\p Of course, the tensor unit  of  is not contained in any of the orthogonally glued categories for which the focus is a proper subset of \footnote{The categories  and  are clearly the same when }, meaning that the -autonomous structure of  is not preserved \textit{per se}. However, each one of these subcategories has another object within it which acts as legitimate unit for the tensor functor: the unit for  is .

\p With this fact taken into account, and the fact that the categories are closed under the tensor product and negation functors, we know that all of these constructions preserve {-autonomy} (with respect to the new unit definitions). Thus, just like the original -glueing, the glueings generate models of \mll.

\subsubsection{Properties}

The Hyland-Tan double glueing construction and its focused orthogonalities are particularly well-behaved, and in fact possess some properties which are immediately relevant to the coming results.

\pagebreak Given an arbitrary focused glueing , the value and covalue sets of an object are in fact precisely the homsets from  and to .

\begin{fact}{\cite{Ste13}} \label{CoValueArrowProp}
For every object ,  and , where .
\end{fact}






We can also claim a large understanding of the ~transformations for these double-glued categories. Since homsets in these categories are in some way `stripped' versions of those from their underlying categories, it would be reasonable to assume that an analogous statement could be made about dinatural transformations. This is indeed correct, as can be deduced from the below proposition.

\begin{prop}{\cite{Tan97,Ste13}} \label{PropGPreservesDNTs}
Let  be a dinatural transformation in . Then there is a dinatural transformation  in  which defines ; that is,  for every . \end{prop}
\proof
\hughc{Theorem~1.3.2 of~\cite{Tan97} provides the result for . As remarked on page~119 in~\cite{Ste13}, this proof only requires intermediary objects which are found in all categories of the given form, thus it extends to all subsets .} \qed









The consequences of this proposition are marked. The transformations of feebly fully complete compact closed categories with biproducts take the form of linear combinations of fixed-point-free involutions~\cite{CHS01}. Therefore the same morphisms are used to described the transformations in the categories created by applying the glueing construction to them.

\p Finally, given a compact closed category  with finite biproducts, which is assured a morphism  and a separate zero morphism  in the homset , we note that every focused glueing  where  stops this morphism being found in , but  preserves this modelling of the mix rule.
\begin{fact}
For every compact closed category  with finite biproducts and a set  containing , the category  models the mix rule if and only if . (See~\cite{Tan97})
\end{fact}

For shorthand, we say . The category is the subject of Section~\ref{SectionMLLMixFC}.

\section{Arrow Decomposition} \label{ArrowDecomp}

Every finite-dimensional vector space over a field  can be given a finite basis, meaning that all arrows in their category  can take the shape of a matrix, or in fact a tensor if desired, over the underlying field. Although it is not possible to say that all arrows in a given compact closed category with finite biproducts can be reduced to an array-based form over a single input type, the multilinear representations still appear and can certainly be of use. \hughd{We introduce this generalisation of matrix representations of arrows\footnote{\hughf{A concept found in folklore, and briefly explained in~\cite{Hou08}.}} in the coming section, and show that \hughh{\mll~transformations and the calculations required in deducing sets of values and covalues in double-glued objects can take a simplified form when using this notation.}}

\begin{defi}
An \emph{array} with \emph{index set}  over a set  is a function . An array can be considered to be \emph{-dimensional} if its index set takes the form  for some .
\end{defi}

\begin{defi}
Letting , an \emph{-tensor}  over a semiring  is an -dimensional array, each of whose components contain a value from . The  entry is written .
\end{defi}

Indices of tensors are allowed to be separated by commas and semicolons to demarcate relevant groups of indices. Superscripts may also be used to facilitate writing, though once a notation style is chosen for a specific tensor it must be adhered to. The number of indices a tensor requires to be expressed (in this case ) is called its \emph{order}. Often tensors are written with general index variables to emphasise that they are indeed multidimensional arrays. Furthermore, long sets of indices can be replaced by bold `superindices'. For example,  can be rewritten  for shorthand, where  and . \hughf{\label{OverloadRef} Sometimes we overload the notation of the tensor so as to show the reader information concerning relative positions of indices with respect to other tensors or a set position.}

\p Calculations involving tensors over semirings are unsurprisingly done in an identical manner to those involving tensors over fields in standard multilinear algebra. All the differences which may occur concern how its entries sum and multiply together. The standard algebraic manipulations are found below.

\begin{itemize}
\item (Addition) --- Given two tensors  and  over the same index sets, their sum is clearly found in the same semimodule.

\item (Composition) --- \hughf{Let  and  be - and -order tensors respectively with  index positions ranging over the same index sets in both arrays.} The composition of the two is given by an -order tensor for which each component is found to be as follows:

\item (Product) --- The outer product of two tensors  and  is given by an -tensor for which each entry is merely a product of entries from its factors.

\end{itemize}

\noindent Examples of the first three manipulation techniques from above are seen ubiquitously in the forms of addition, multiplication and the trace operation of matrices. It should be noted that, if desired, one can consider tensor composition as the equivalent of finding the outer product of two tensors sharing indices and contracting the result.

\p There are \hugh{five types of tensor} which are seen continuously in various guises within this \hughf{paper}. Their definitions are given below.
\begin{defi}\label{TensorExamDefns}  \\
\begin{enumerate}
\item A \emph{zero tensor}, written  for some indices , is a tensor, all of whose entries contain the scalar .
\item Similarly, a \emph{one tensor}, written , is a tensor whose entries all contain the scalar .
\item A \emph{Kronecker delta}, written , is an -tensor for any  such that

It is the tensor representation of the identity matrix. \\ \hugh{We also write  as shorthand}\footnote{\hughf{Note that these tensors are an example of where it is of use to overload the index notation as discussed on page~\pageref{OverloadRef}. It facilitates the understanding of which indices are connected by such a relation without having to resort to a yet more cumbersome notation.}}.
\item \hugh{A \emph{(full)} \emph{-permutation over } is an
  -tensor  such that for all , and  for each , there exists an
   so that . We use the notation  to
  denote the set of all {-permutations} over . Note that a -permutation over  is simply a tensor of the form  for some .}
  
  \p \hugh{Of particular use are \emph{cycle permutation tensors}. We define , with , to be the -tensor with entries defined as follows:
  }
\item \hugh{Generalising the above, a \emph{partial} \emph{-permutation over } is an
  -tensor  such that for all , and  for each , there exists an
   so that  is equal to  or . We use the notation  to
  denote the set of all -permutations over .}
\end{enumerate}
\end{defi}

\noindent Because of the number of indices which may be given to each tensor, the calculus of tensors can become very cluttered. The use of summation symbols adds to the excessive number of symbols in many expressions, and they can be thought of in many cases as unnecessary. As such, at some points it is useful to use the Einstein summation convention: whenever an expression containing tensors has two index positions involved within it which are summed together over the same index  say, the summation symbol may be omitted without worry. This means that a simple composition rule, for example, can be rewritten .

\subsection{Tensor Representation} \label{SectionTensorRep}

Decomposition of arrows between objects in the form of tensor products of direct sums is possible in a symmetric monoidal category with finite biproducts, and can be a very useful tool. Suppose that  is such a category, and consider the arbitrary arrow

Due to the preservation of products by the tensor product\footnote{\hughd{Since there is a natural isomorphism  in any compact closed category, the functor  in a compact closed category for any object  can be seen as both a left and right adjoint, and as such preserves both products and coproducts~\cite{Mac97}.}}, we know that the following set of  arrows describe .

We can follow the same procedure of decomposing  using the projections \linebreak  for all  of the object. Furthermore, due to the bifunctoriality of the tensor product, each of the projections is independent of the others. The injections operate similarly; and as such, it is possible to separate  yet further and describe it using a set of  arrows , where


This decomposition of  is known as a \emph{tensor representation}. It is generally inconvenient to write down the resultant tensor as a single entity due to the number of dimensions required. This is, however, of little concern to us, because we are able to view the entries of the tensor on a case-by-case basis.

\p The greatest implication this has is to the freedom of expression one has when decomposing arrows concerning the tensor product: given two arrows in the prescribed form above, it is possible to gain a tensor representation of their tensor product. This comes about almost trivially, with each entry in the new tensor being created by producing the tensor product of one entry from each of the representations of the more primitive morphisms. Given arbitrary arrows  and , with , ,  and , we find that


\noindent Rather unsurprisingly, addition and composition operate in an almost identical manner as they do in the matrix algebra. Identity and zero morphisms between objects of the form given above are represented by Kronecker deltas and zero tensors respectively. Letting , , and ,







\noindent Then taking arbitrary  and ,
\smallskip

There is a specific type of interaction composition and tensor multiplicaton which ought to be noted, namely when a composition passing through an object  contains an arrow of the form  or  for some arrows  or . Consider the composition ; the tensor representations of the composite morphisms are written, naturally, as  and . However, , and the only effect the Kronecker delta on the end representation of the composition is the change of index, which is superficial. In these types of situation, we consider ourselves at liberty to think instead of the composition of the two tensors  and , summing over the indices of  only.

\p The monoidality of the category  allows for scalar multiplication of arrows to be modelled by the synonymous operation on tensors.
\smallskip

When the source and target objects of an arrow are tensor products of direct sums of the tensor unit , the arrow's tensor representation acts as a standard tensor over \linebreak . These homsets are trivially in bijective correspondence with the set of scalars , and so we can work purely with tensors over this semiring.

\p Of course, in a compact closed category with finite biproducts, we are not restricted to building objects over the two functors  and : the contravariant endofunctor  is also available. We now show how tensor representations can be given to morphisms between objects built with this functor.

\p Consider a morphism , where , , and \linebreak . The extent to which this arrow can be decomposed using the tensor representation system given above is less than one would hope. The negation of  means that it is not possible to break it down without extending the representation. The parameterised adjunction  described in Section~\ref{SectionCompCCs} makes this extension possible.

\p The isomorphism  associated with the adjunction relates  to an arrow \linebreak . This new arrow is certainly in exactly the shape seen of morphisms at the beginning of this section;  is no longer shackled by the negation functor and its projections may be used in a decomposition in the same way as  and . The set of arrows , where

determines  uniquely; and since  is an isomorphism the arrows provide a unique description of  as well.

\p Using the isomorphism once more, this time on every arrow in the above set, we are able to understand  by viewing a set of morphisms that have a superficially identical form to it: . The parameterised adjunction offers a simplification of the descriptions of each of these arrows.


The principle above, where the duals of injection arrows into  are used in place of projections, is entirely generalisable to multiple instances of dual objects in a tensor product. Furthermore, the inherent duality of compact closed categories allows morphisms from tensor products with dualised elements to be decomposed by substituting injection arrows for duals of projection arrows. Suppose that we have an arrow

where the functions \hughf{ and  depict the polarity of a direct sum in the tensor product with respect to the negation functor,  denoting an empty superscript once more.} We define the \emph{tensor representation} of such an arrow to be the set of morphisms \hughf{}, where


We can extend this using a simple induction so that the functions  and  \hughg{may adopt the new range of the set of strings using only the letter ,  as we shall name it at this point\footnote{\hughf{It is more traditionally written with a Kleene star, but the authors believe the resulting expression  leads to confusing overloading.}}, so that we can apply the duality functor as many times as wished to a direct sum.} The tensor representation of the arrow  remains the same, but the definitions of  and  are generalised accordingly.


Of course, the negation of a number of positive and negative direct sums of objects together in a tensor product is also possible, and is in fact necessary if the  functor is to be defined. It would therefore be useful to produce tensor representations for arrows between objects containing such components. The principle being used in the earlier instances of negation may be translated directly to produce such entities. Given an arrow

where , ,  and  are direct sums of objects acted on by the negation functor , ,  and  times respectively. There is a bijective correspondence  to  to , and every morphism in this target set can be decomposed and be represented by a tensor containing arrows in the form shown below.

Using the correspondence  once again, we see that each morphism in the aforementioned tensor is related to an arrow which may be placed into a new representation: the relative of the above arrow is


The arrows of this form bundled into an appropriate set are defined to be the tensor representation of the arrow, and it is once again clear that the concept is generalisable to morphisms whose sources and targets may contain any number of tensor products affected by the functor . The self-duality of compact closed categories once more means that a similar line of reasoning can be afforded to dealing with negation in the source of an arrow by swapping the roles of injection and projection arrows. A logical extension to the argument can be constructed to deal with tensor products with the duality functor applied numerous times. Using the symmetry natural isomorphism  sensibly it is possible to express tensor representations for arrows between objects which are tensor products of tensor products of direct sums of primitive objects under any number of instances of the duality functor. Furthermore, due to induction, this style of reasoning is extendable to any arrow between objects built using indecomposable objects and the duality and tensor functors. We give new, recursive definitions for the arrow sets  and . These are, however, reliant on the concept of index sets in a category theoretical sense.

\begin{defi} \label{CatTensorIndexSetDefn}
An \emph{index set} of an instance of an object  in , written , is defined inductively as follows:
\begin{itemize}
\item If  for some instances of objects  we wish to be considered indecomposable, then .
\item If  for some object , then .
\item If  for some objects , then .
\end{itemize}\medskip
\end{defi}

Equivalently, the index set of an object  for which we consider its instances of  indecomposable for each  and  is the set of -tuples where for every , the  component ranges over the number of objects in the  direct sum.

\p We are now in a position to define  and .
\begin{defi}
The \emph{injection} and \emph{projection arrow functions} of an object  built using the tensor product and negation functors over direct sums of indecomposable objects in a compact closed category  with finite biproducts, written  and  respectively, have domain  and are defined recursively as follows:
\begin{itemize}
\item If  for indecomposable ,  and .
\item If  for some , then  and .
\item If  for some , then  and \\  , where each .
\end{itemize}\medskip
\end{defi}

\noindent The definition above facilitates the description of the tensor representation of every arrow built in the manner that has been discussed earlier.

\begin{defi} \label{TensorRepDefn}
A \emph{tensor representation} of an arrow , where  and  are objects built using tensor products and the negation functor over direct sums of instances of objects considered indecomposable, is defined as the set of morphisms  where
\vspace{-1 mm}
\end{defi}
Note how this definition of tensor representation is consistent with the earlier, more rudimentary forms which do not consider the possibility of negation existing beyond the direct sums. The entries in these tensors are still merely composites containing arrows; and addition of morphisms is a consequence of enrichment over , so the connection between tensor and arrow addition is maintained, including the zero morphisms. Similarly, scalar multiplication is unaffected. The extended definition of the identity arrow of any object  is created recursively from prior knowledge of the standard diagonal matrix representation of the identity arrow for direct sums of objects and the preservation of identity morphisms by functors, and takes the form .

\begin{itemize}
\item If  for indecomposable objects , then the representation of the identity morphism  is

\item If  for some object , then 

\item If  for some objects , then
\medskip
\end{itemize}
Because of the lack of change required in the shape of this arrow from earlier versions, the manner in which composition operates is also preserved.

\p Unlike when we consider only the simpler form of arrow being placed into a multilinear representation, which lacks any use of the duality functor, it cannot be taken for granted that the tensor describing an arrow between two objects built over direct sums of , and tensor and negation functors can be viewed as being a standard tensor over . This is because the entries take the form of arrows between tensor products over tensor products of both  and . \hughg{Fortunately,  is an isomorphism}; and we can compose suitable tensor products built from it, its inverse, dualities of both these arrows and the identity morphism  to ``remove'' the dual instantiations of the unit, and so therefore allow us to view the tensors as being over \hugh{.}

\subsection{Describing Transformations with Tensors} \label{SectionTransExtensors}

The representations described in this \hugh{section} offer a simplification to the form of morphisms between objects built from the three functors expected to exist in a compact closed category with finite biproducts. It therefore follows naturally that certain arrows that are part of an \mll~transformation can be viewed as tensors. In this section we consider an object  in a compact closed category  satisfying feeble full completeness for an arbitrary \mll~functor  where , \hugh{where ,} and give the arrows into the object which are constituents of \mll~transformations.

\p It is known that every \mll~transformation in a compact closed category with finite biproducts satisfying feeble full completeness is a linear combination of fixed-point-free involutions~\cite{CHS01}, with an involution being the equivalent of an appropriate number of instances of the unit dinatural transformation  joined by a tensor product being postcomposed with a series of symmetry natural isomorphisms.\footnote{Associativity natural isomorphisms are suppressed in this explanation, but this can be perceived as self-evident.} Each pair of objects created together by an instance of  models a pair of literals joined by an axiom link in a cut-free proof net. As such, it makes sense to initially provide the tensor representation of  for arbitrary . The unit transformation is derived from the bijective correspondence connected to  being applied to the identity arrows in : for every , ; and because of this the arrow  is easily shown to have an  identity matrix as its tensor representation.

We therefore are at liberty to express an axiom link as a Kronecker delta tensor, with one index referring to the object modelling the positive literal and the other the negative literal. This concept may be extended now by tensor multiplication to \mll~functors with more than one pair of literals to being joined. Letting  be modelled by , the arrow modelling the proof structure
\begin{center} \vspace{5mm}
\begin{tikzpicture}
  [auto, node
  distance=6mm, skip loop/.style={to path={-- ++(0,#1) -| (\tikztotarget)}}] \tikzstyle{every node} = [text depth=-5pt,text height=0.5ex]
   \node (1) {}; \node (a) [right of=1] {} ;
  \node (2) [right of=a] {}; \node (b) [right of=2] {} ;
  \node (3)  [right of=b, xshift=-1mm] {}; \node (c)  [right of=3] {};
  \node (4)  [right of=c] {}; \node(d) [right of=4] {} ;
  \node (5) [right of=d, xshift=-1mm] {}; \node (e) [right of=5] {} ;
  \node (6) [right of=e] {}; \node (f) [right of=6] {} ;
  \node (7)  [right of=f,xshift=-1mm] {}; \node (g)  [right of=7] {};
  \node (8)  [right of=g] {};
\begin{scope}\path   (1)  edge [red, skip loop =6mm, shorten >=3mm, shorten <=3mm]  (2);
\path (3)  edge  [red, skip loop =6mm, shorten >=3mm, shorten <=3mm] (4);
\path   (5)  edge [red, skip loop =6mm, shorten >=3mm, shorten <=3mm]  (6);
\path (7)  edge  [red, skip loop =6mm, shorten >=3mm, shorten <=3mm] (8);
\end{scope}
\end{tikzpicture} \vspace{5mm}
\end{center}

\noindent is represented by the tensor , where the indices  and  are connected to the objects representing the  positive and negative literals respectively. In a more general form, if the literals which are connected via axiom links are less well-ordered so that the  positive literal is connected to the  negative literal for some permutation , then the modelling tensor is .
\newpage

\begin{exa}
The tensor  represents the proof structure below.
\end{exa} 
\begin{center} \vspace{5mm}
\begin{tikzpicture}
  [auto, node
  distance=6mm, skip loop/.style={to path={-- ++(0,#1) -| (\tikztotarget)}}] \tikzstyle{every node} = [text depth=-5pt,text height=0.5ex]
   \node (1) {}; \node (a) [right of=1] {} ;
  \node (2) [right of=a] {}; \node (b) [right of=2] {} ;
  \node (3)  [right of=b, xshift=-1mm] {}; \node (c)  [right of=3] {};
  \node (4)  [right of=c] {}; \node(d) [right of=4] {} ;
  \node (5) [right of=d, xshift=-1mm] {}; \node (e) [right of=5] {} ;
  \node (6) [right of=e] {}; \node (f) [right of=6] {} ;
  \node (7)  [right of=f,xshift=-1mm] {}; \node (g)  [right of=7] {};
  \node (8)  [right of=g] {};
\begin{scope}\path   (1)  edge [blue, skip loop =7mm, shorten >=3mm, shorten <=3mm]  (8);
\path (2)  edge  [blue, skip loop =6mm, shorten >=3mm, shorten <=3mm] (5);
\path   (3)  edge [blue, skip loop =5mm, shorten >=3mm, shorten <=3mm]  (4);
\path (6)  edge  [blue, skip loop =6mm, shorten >=3mm, shorten <=3mm] (7);
\end{scope}
\end{tikzpicture} \vspace{5mm}
\end{center}

As discussed in Section~\ref{SectionCompCCs}, \mll~functors may model sequents which contain more than one instance of a single literal; and such entities can have more than one set of axiom links attached to them. Furthermore, regardless of the number of repeated literals, scalar multiplications on arrows, and so natural and dinatural transformations, are always possible. This gives rise to the possibility of transformations describing linear combinations of sets of axiom links on a single sequent. Such linear combinations are modelled by \mll~transformations which are linear combinations of transformations representing single sets of axiom links, whose constituent arrows are linear combinations as well. It follows, therefore, that the tensor representation of an arrow  for some \mll~transformation  where  is in the following form:

where  for every .

\begin{exa}
The tensor  represents the linear combination of axiom links on the \mll~formula given below.
\end{exa}
\begin{center} \vspace{5mm}
\begin{tikzpicture}
  [auto, node
  distance=6mm, skip loop/.style={to path={-- ++(0,#1) -| (\tikztotarget)}}] \tikzstyle{every node} = [text depth=-5pt,text height=0.5ex]
   \node (1) {}; \node (a) [right of=1] {} ;
  \node (2) [right of=a] {}; \node (b) [right of=2] {} ;
  \node (3)  [right of=b, xshift=-1mm] {}; \node (c)  [right of=3] {};
  \node (4)  [right of=c] {}; \node(d) [right of=4] {} ;
  \node (5) [right of=d, xshift=-1mm] {}; \node (e) [right of=5] {} ;
  \node (6) [right of=e] {}; \node (f) [right of=6] {} ;
  \node (7)  [right of=f,xshift=-1mm] {}; \node (g)  [right of=7] {};
  \node (8)  [right of=g] {};
  \node (z1) [left of=1] {};
  \node (t1) [above of= z1] {};
  \node (t2) [above of= t1] {};
  \node (s1) [left of= t1] {};
  \node (s2) [left of= t2] {};
\begin{scope}\path   (1)  edge [red, skip loop =11mm,shorten >=8mm, shorten <=8mm]  (2);
\path (3)  edge  [red, skip loop =11mm,shorten >=8mm, shorten <=8mm] (4);
\path   (5)  edge [red, skip loop =11mm,shorten >=8mm, shorten <=8mm]  (6);
\path (7)  edge  [red, skip loop =11mm,shorten >=8mm, shorten <=8mm] (8);
\path   (1)  edge [blue, skip loop =7mm, shorten >=3mm, shorten <=3mm]  (8);
\path (2)  edge  [blue, skip loop =6mm, shorten >=3mm, shorten <=3mm] (5);
\path   (3)  edge [blue, skip loop =5mm, shorten >=3mm, shorten <=3mm]  (4);
\path (6)  edge  [blue, skip loop =6mm, shorten >=3mm, shorten <=3mm] (7);
\end{scope}
\end{tikzpicture} \vspace{5mm}
\end{center}

\p Of course, not every proof structure (and none which satisfies the correctness criteria) is built over exactly one formula only containing tensors. It is therefore important to understand the effects of replacing some instances of the functor  with those of . Tensor representations of arrows between arbitrary objects are shown to exist in Section~\ref{SectionTensorRep}; this immediately implies that they exist for ones containing the par functor as well. After all, it is the de Morgan dual of the tensor product using  as negation.

\p We can see how involutions are viewed tensorially when certain tensor products are changed by considering  described in Section~\ref{CatModels} and its representation. In compact closed categories, the `Mix' transformation is not just natural but isomorphic, and is in fact built from the same correspondence :

where  is the composition of  natural isomorphisms such that

Via an inductive argument on the size of  and , we find that the  representation of  reduces to an identity , as long as both  and  are unit-generated. The natural consequence of this is that one need not even think of the multiplicative functor being used once the tensor calculus is employed: we differentiate between arrows with the same tensors purely by looking at their signatures.

\p We can take this knowledge and provide an tensorial method to look at the the weakening natural transformations. Consider . If the three inputs to the natural transformation are unit-generated, then we know from above that the instantiations of the  functor may be viewed in exactly the same manner as the usages of the  functor. It becomes obvious that, just like the \mll\ transformations above,  is perceived as a tensor in the same way as the associativity isomorphism. That is, letting  and  be the superindices denoting the  entries of the source and target functors respectively, we find that . The other weakening transformations are defined similarly.

\subsection{Describing Double-Glued Objects with Tensors} \label{SectionDGTensor}

\hughg{The sets of values and covalues of an object  in  contain morphisms from~ and to~ respectively. As such, if  is built solely from ,  and  in the underlying category, then the elements of  and  can be represented by tensors over the semiring of scalars of .}

\p Given , , we provide the shape of the values and covalues created from the -autonomous structure. One can see particularly how the formulation of these sets is greatly simplified for the negation and tensor product.

\begin{itemize}
\item 
\item ; .
\item 
\item 


\end{itemize}


\section{\mll~Full Completeness for } \label{SectionGCFC}

For the purposes of this section, we let  be an arbitrary compact closed category with biproducts satisfying feeble full completeness (Definition~\ref{FeebleFCDefn}). Feeble full completeness allows us to assume that every \mll~transformation (Section~\ref{CatModels}) in this category is described by a linear combination of fixed-point-free involutions, each involution representing an axiom link connecting the two literals being modelled. It is shown in \cite{Tan97,HS03} that  must be -autonomous, and so it is already known that all dinatural transformations modelling correct \mll~proof structures are found in the glued category. Fact~\ref{PropGPreservesDNTs} tells us that the dinatural transformations in the glued category are also described by linear combinations of fixed-point-free involutions. What still remains to be shown, however, is that the double glueing construction not only preserves the feeble full completeness of , but removes enough arrows to ensure that the only linear combinations of proof structures which are still modelled are not linear combinations at all, but denotations of single proof nets.

\p With such strong constraints on the arrows within transformations already placed, the strategy to do this becomes in essence remarkably simple. For an \mll~transformation  in  to be found in , it must be the case that  is found as an arrow from  to  for every , i.e. the set of values for the -object . Alternatively, it may be said that  does \emph{not} translate into  if there is a tuple of -objects  where  does not belong to . We provide tuples which expose how some arrows describing incorrect proof structures and impure linear combinations do not find themselves in all the sets of values needed to ensure they remain transformations in .

Every compact closed category with finite biproducts has a full subcategory closed under all three of the characteristic functors which is generated solely by its tensor unit . By choosing `test objects' for the tuples from this subcategory, we ensure the proof is as general as possible. Furthermore, if the tuple  consists of test objects whose underlying -objects are of the form  for some , the shape of the object  must be akin to those discussed in Section~\ref{SectionTensorRep}, and tensor representations of arrows may be considered instead, simplifying the process noticeably.

\hughh{The structure of the coming proof can be viewed as follows:}
\begin{description}
\item[\rm(\S 4.1-4.5)] We first prove that the only MDNF~transformations in~ model correct proof nets, a property which we call \emph{MDNF Full Completeness}. 
	\begin{enumerate}[label=(\autoref{SectionZeroTransProof})]
	\item[(\autoref{SectionMDNFObjects})] We introduce the families of test objects  and , and calculate the sets of values for the objects given by MDNF functors when instantiated using a chosen object from either one of these categories. These value sets are dependent on the families of full and partial permutations given in Definition~\ref{TensorExamDefns}.
	\item[(\autoref{SectionZeroTransProof})] It is shown that  only contains MDNF~transformations modelling linear combinations of proof structures whose scalar multiples sum to  (Proposition~\ref{OnlyOneLemma}). In particular, MDNF~transformations containing only zero morphisms (\emph{zero transformations}) are not found in the glued category.
	\item[(\autoref{SubsectionAcyclic})] A proof that every MDNF~transformation in~ models linear combinations of acyclic proof structures is given.
		\begin{itemize}
		\item Consider a transformation  in  modelling a linear combination containing a cyclic proof structure.
		\item Use Algorithm~\ref{AcyclicAlg} to produce partial permutations for all the blocks of a given cyclic structure.
		\item Proposition~\ref{AcyclicLemma}, together with technical lemmas~\ref{AcyclicClaim1} and~\ref{AcyclicClaim2}, are used to show that the generated partial permutations can be used to prove that  he tensor representation (Section~\ref{SectionTransExtensors}) of the transformation instantiated with a single object  for large enough  cannot be found in the instantiation of  where all arguments are . This disproves the possible existence of the equivalent transformation in~.
		\end{itemize}
	\item[(\autoref{SubsectionConnectedness})] Following a similar strategy to the above, we deduce that every MDNF~transformation in~ models linear combinations of correct proof structures (i.e. connectedness is proved).
		\begin{itemize}
		\item We consider a transformation  in  modelling a linear combination of acyclic, disconnected proof structures, noting all the structures must be disconnected (Lemma~\ref{OneDiscThenAllClaim}).
		\item We create appropriate full permutations for all blocks except one using Algorithm~\ref{DisconnectTupleAlg} and Lemma~\ref{ConAlgCompleteLemma}.
		\item Proposition~\ref{ConnectedLemma} explains how these permutations when composed with a tensor representation of appropriate dimensions of the linear combination of disconnected proof structures produces a zero tensor. This proves that the representation could not exist in the instantiation of  where all arguments are , meaning that the transformation cannot exist in the double-glued category.
		\end{itemize}
	\item[(\autoref{SubsectionUniqueness})] It is found that only singular, unique MDNF~proof nets can be modelled in~.
		\begin{itemize}
		\item The method is nearly identical to those seen above, considering a transformation in  to  modelling a true linear combination of proof nets (that is, one containing at least two different proof nets whose scalars are non-zero).
		\item Algorithm~\ref{UniqueTupleAlg} generates partial permutations for all except one block containing exactly one literal (which is a \emph{leaf} in each MDNF~proof net).
		\item Proposition~\ref{UniqueLemma}, which lightly makes use of the full form of Proposition~\ref{OnlyOneLemma}, shows that the tensor representation of this linear combination cannot be found in the set of values of the functor when instantiated using an appropriate  once again, and so MDNF~full completeness holds.
		\end{itemize}
	\end{enumerate}
\item[(\autoref{SectionMLLExtend})] Finally, we show that the full completeness of MDNF transformations extends to that for all \mll~transformations.
		\begin{itemize}
		\item Algorithms~\ref{MLLtoMDNFCycleAlg} and~\ref{MDNFAlg} take advantage of the natural isomorphisms and weak distributivity natural transformations in -autonomous categories to create natural transformations which compose with general \mll~transformations to give ones for MDNF~functors. These transformations are used in Theorem~\ref{fcomp} that MDNF~full completeness implies \mll~full completeness, thus giving the desired result.
		\end{itemize}\medskip
\end{description}

\p\noindent  It should be noted that the lemmata used in this full completeness proof find themselves in an unusual order. In previous \mll~full completeness results, particularly those requiring glueing constructions \cite{Loa94b,Tan97,Hag00}, it is generally proved first that only \mll~proof structures are modelled in the category, and their correctness is shown afterwards. In the coming proof we do the exact reverse. The existence of cyclic proof structures in modelled linear combinations is disproved, and disconnectedness of modelled proof structures in the glued category is shown to be unallowed. Only then do we prove that `impure' linear combinations and scalar multiples of proof nets are not represented by transformations in . Without assuming acyclicity the most natural approach to show the `purity' (or `uniqueness' as we refer to it from now on) of the allowed linear combinations required; the results of following this train of thought is seen in Section~\ref{SectionMLLMixFC}.

\p Most parts of the coming proof method require the use of an algorithm to produce a number of permutation tensors, and these are given in each of the corresponding subsections. The intuition behind how and why the permutations are of use are given alongside these algorithms before providing each formal, generalised proof.

\subsection{Test Objects and Permutations in MDNF Functors} \label{SectionMDNFObjects}

It turns out that only two fundamental types of test object are required for full completeness to be proved. We define them both for each  as follows:
\begin{itemize}
\item 
\item 
\end{itemize}

\hughh{As discussed in Section~\ref{SectionDGTensor}, we can represent these objects using sets of tensors instead of collections of arrows. Their new form is given below.}
\begin{itemize}
\item 
\item 
\end{itemize}

It is clear, particularly from the tensor representations, that  and  are self-dual --- that is,  and  --- for all positive natural numbers . As a consequence the sets of tensor representations of values and covalues of the objects  and  are the same if  is the \mll~functor representing the same sequent as , only with all instances of negative literals converted to positive instances, and  is filled only with objects such as  and . Because of this, in these situations we are at liberty to pretend that all instances of literals are positive in the formulae when viewing arrows solely through their multilinear arrays.

\p Tensor powers of these objects (and therefore tensor products only containing positive and negative instances of them) reproduce the sets of higher-order permutations, both full and partial as defined in Definition~\ref{TensorExamDefns}. This can be demonstrated using a standard inductive argument. We use the notation  for the  tensor power of an object .

\begin{lem} \label{ClaimTensorPowers}
For each , . Similarly, .
\end{lem}
\proof
The claim is trivially true for  in both cases, and it is also clear that


\noindent To prove that the values and covalues are as desired for any positive , we assume it is true for a natural number  and show that it remains true for . \hughg{Section~\ref{SectionDGTensor} contains the standard calculation rules that are used in this proof.} Starting with the values of the tensor power, we find


\noindent Finally, the covalues are evaluated to be as required.


The inductive evaluations of the values and covalues for  are simpler but essentially identical. \qed

If a functor  is in multiplicative disjunctive normal form, then the object  takes the form
\vspace{1mm}

\smallskip

\noindent for some  and , where  for some object , and  indicates the number of times the negation functor is applied to one of the instances of the object . If  is self-dual like each all objects of the form  and , and we continue to use tensor representations, then the function  becomes irrelevant and may be ignored to all intents and purposes. The sets of values and covalues in tensor representation form of the object  are then the same as those of the object . Knowing the values and covalues of the tensor powers of the objects  and  for each  allows us to calculate  and  concretely for  or . As in the previous chapter, to aid clarity of arguments, the names of the indices used in these sets are based upon the polarity of the literal to which they are tied: `'-indices represent positive literals, and `'-indices negative ones. In a block , we say that there are  positive and  negative literals; and in total there are  literals.



\hughg{}

\noindent The derivation of these sets follows from a simple induction on the number of blocks of tensor powers which exist in an MDNF~formula, using the same principles as demonstrated in Lemma~\ref{ClaimTensorPowers} and Section~\ref{SectionDGTensor}.

\p If an MDNF~transformation  in  representing a linear combination of sets of axiom links over an MDNF~sequent modelled by a functor  is to exist in the glued category, then  must belong to both  and  when . The rest of this section is dedicated to showing how we can always find permutations (either full or partial) that expose the inability of the aforementioned arrow to belong to at least one of these sets if the transformation models an unwanted axiom link combination.

\subsection{Zero Transformations} \label{SectionZeroTransProof}

A zero transformation is an \mll~transformation found in every compact closed category with finite biproducts whose constituent arrows are all zero morphisms. They could be viewed from a certain perspective as the representation of the statement of a sequent being provable with no evidence, even if the sequent is in fact unprovable by standard linear logic reasoning. There is no place for such transformations in fully complete models of \mll, and so it is fortunate that their absence from the category  can be deduced with minimal effort.

\p It is actually worthwhile proving a stronger result than merely the zero transformations being excluded from the glued category. We show that a linear combination of proof structures cannot possibly be modelled by an \mll~transformation in  unless the sum of the scalars given to each of the proof structures totals exactly . Although this is not a particularly strong result---in particular in categories such as , where the result is in fact equivalent to stating that zero transformations are forbidden---it is necessary for the final full completeness proof to be finished. The test object which provides the clearest proof of the desired result is . The object is in fact the tensor unit  of the sub--autonomous category  defined in Section~\ref{SectionFocusedOrth}, and the properties its position as a unit of a model of \mllmix\ bestows upon it are pivotal in the lemma below.

\begin{prop} \label{OnlyOneLemma} Every \mll~transformation in 
  models a linear combination of proof structures where the scalars applied to the constituent linkings sum to .
\end{prop}
\proof
Using induction, we observe that, for every \mll~functor , the arrows in the values and covalues of  have the tensor representation . 
\begin{itemize}
\item The base case is trivially true: , and .
\item .
\item .
\item , and so this step may be deduced from the previous two.
\end{itemize}

A linear combination of proof structures is modelled by a tensor , summing over bijections  from the set of indices for positive indices to the set of indices for negative ones, with  for all , when the underlying -objects of the inputs to  are of the form  for some . When , as is the case when  is the only -object being used in , the deltas become trivial (all the indices must be given the value ), meaning that the tensor becomes ; that is, the proof structures are modelled by the sum of the scalars associated with the proof structures.

 \p The only scalar found in  is  regardless of the form of , meaning morphisms for any sum of scalars not equalling  do not lift to the homset . As such, because not all the arrows required to form them in the glued category can be seen, transformations describing linear combinations of proof structures whose scalars do not add up to  in their semiring cannot translate into  either. \qed

\begin{cor}
No zero transformation  in  exists in the category .
\end{cor}

\subsection{Acyclicity} \label{SubsectionAcyclic}

It is first shown that each proof structure that is part of a linear combination being modelled in  satisfies the acyclicity criterion of Danos and Regnier \cite{DR89}. The concept behind how this is done can be understood by considering a few simple examples. The most basic example of a cyclic proof structure involves a single axiom link:
\begin{center} \vspace{5mm}
\begin{tikzpicture}
  [auto, node
  distance=5mm, skip loop/.style={to path={-- ++(0,#1) -| (\tikztotarget)}}] \tikzstyle{every node} = [text depth=-5pt,text height=0.5ex]
   \node (1) {}; \node (a) [right of=1] {} ;
  \node (2) [right of=a] {};
\begin{scope}\path   (1)  edge [black, skip loop =6mm, shorten >=3mm, shorten <=3mm]  (2);
\end{scope}
\end{tikzpicture} \vspace{5mm}
\end{center}

\p Modelling  with  for some , the values of the resultant object are square -matrices with at most one entry being non-zero, and if such an entry exists it must be the number . However, the tensor representation of the proof structure desired is , which for this representation of  has  non-zero entries. There are too many entries containing non-zero positions. This fault still remains if we consider scalar multiples of the proof structure.\footnote{Multiplying the structure by zero naturally removes the problem. However, this produces the zero morphism; the existence of a zero transformation has already been contradicted in Proposition~\ref{OnlyOneLemma}.}

The same problem occurs with larger cycles containing more than one axiom link and more than one block.
\begin{center} \vspace{5mm}
\begin{tikzpicture}
  [auto, node
  distance=5mm, skip loop/.style={to path={-- ++(0,#1) -| (\tikztotarget)}}] \tikzstyle{every node} = [text depth=-5pt,text height=0.5ex]
   \node (1) {}; \node (a) [right of=1] {} ;
  \node (2) [right of=a] {}; \node (b) [right of=2] {} ;
  \node (3)  [right of=b] {}; \node (c)  [right of=3] {};
  \node (4)  [right of=c] {}; \node(d) [right of=4] {} ;
  \node (5) [right of=d] {}; \node (e) [right of=5] {} ;
  \node (6) [right of=e] {};
\begin{scope}\path (1)  edge  [black, skip loop =7mm, shorten >=3mm, shorten <=3mm] (6);
\path   (3)  edge [black, skip loop =6mm, shorten >=3mm, shorten <=3mm]  (2);
\path (5)  edge  [black, skip loop =6mm, shorten >=3mm, shorten <=3mm] (4);
\end{scope}
\end{tikzpicture} \vspace{5mm}
\end{center}

The proof structure above is described by  ( and  relating to the positive and negative literals in the  block as is the norm). One of the criteria a tensor  must satisfy if  for large enough  in order for it to belong to the values of the corresponding object is for every pair of partial (-)permutations over ,  and  say, to create an -matrix with at most one non-zero entry when composed with it. If we say that  and  --- which are indeed partial permutations --- we find

The resulting matrix clearly has two non-zero entries: when  and ; and when  and . As such, this particular cyclic structure is shown to be represented neither in the set of values of , nor the \mll~transformations of .

\p The reason why this argument is possible is based on the fact that every block involved in a cycle has two literals incident to axiom links in the cycle. The two literals in the first block may be given tensors containing two non-zero positions which compose with the proof structure tensor because they are in the same block, and  contains all partial permutations; the same is true of those in the second block. If they were not, as would be the situation in the proof structure below, only one non-zero entry would be able to be found: tensors in  only have at most one value of , with the rest being zeroes.

\begin{center} \vspace{5mm}
\begin{tikzpicture}
  [auto, node
  distance=5mm, skip loop/.style={to path={-- ++(0,#1) -| (\tikztotarget)}}] \tikzstyle{every node} = [text depth=-5pt,text height=0.5ex]
   \node (1) {}; \node (a) [right of=1] {} ;
  \node (2) [right of=a] {}; \node (b) [right of=2] {} ;
  \node (3)  [right of=b] {}; \node (c)  [right of=3] {};
  \node (4)  [right of=c] {}; \node(d) [right of=4] {} ;
  \node (5) [right of=d] {}; \node (e) [right of=5] {} ;
  \node (6) [right of=e] {};
\begin{scope}\path (1)  edge  [black, skip loop =7mm, shorten >=3mm, shorten <=3mm] (6);
\path   (3)  edge [black, skip loop =6mm, shorten >=3mm, shorten <=3mm]  (2);
\path (5)  edge  [black, skip loop =6mm, shorten >=3mm, shorten <=3mm] (4);
\end{scope}
\end{tikzpicture} \vspace{2mm}
\end{center}

The objective of the coming proof is to generate partial permutations with two non-zero positions as above for all bar one of the blocks connected to the axiom links in a chosen cycle; and these tensors should compose with the Kronecker delta tensor representing an incorrect proof structure in a linear combination being considered to create a tensor with more than one entry not equalling zero. Of course, the scenarios offered so far have been curtailed in two ways: all of their axiom links are involved in the cycle (and there is only one cycle), and linear combinations of two or more distinct proof structures are absent. The algorithm below deals with both of these problems, and this is discussed in more detail after its description.

\begin{algo} \label{AcyclicAlg} Input: A cyclic MDNF~proof structure with linking  containing  blocks, the  of which containing  literals, and one of its minimal cycles . \\ Output: A number ;
  tensors  such that  for each .
\end{algo}
\begin{enumerate}
\item Let , and note that, at this point, none of the links in  has been dealt
  with.

\item Find a link  which has
  not been dealt with yet.
  \begin{enumerate}
  \item If one should exist, then assign the number  to both
    literals incident to~. Increment , and go to Step~2.
  \item If one does not exist, then move to Step~3.
  \end{enumerate}

\item Find a link  which has not been dealt with
  yet.
  \begin{enumerate}
  \item If one should exist, then assign both the numbers  and
     to both literals incident to . Increase the value of 
    by , and restart Step~3.
  \item If one does not exist, then move to Step~4.
  \end{enumerate}
	
\item For each tensor product of literals which does not contain a
  literal incident to a link within , place the values
  assigned to each literal into a tuple in the same order as their
  literals appear in the subformula. This tuple `belongs' to that
  subformula.

\item For each tensor product of literals which does contain a
  literal incident to at least one link within ,
  create two tuples as follows:
  \begin{enumerate}
  \item Place the lowest values assigned to each literal into a tuple
    in the same order as their literals appear in the subformula.
  \item Place the highest values assigned to each literal into a
    tuple in the same order as their literals appear in the
    subformula.\footnote{If a literal has been assigned only one
      number, then this number is indeed considered both the highest
      and lowest value.}
  \end{enumerate}
	
\item Set ; and for each , define an element
   of  as follows:
  \smallskip
\end{enumerate}

\noindent The tensors created in this algorithm are indeed always partial permutations. The tensors associated with blocks which are not connected to the cycle  only ever contain one non-zero entry, and that entry is . In this type of situation it is abundantly clear that there are only s and s as entries, and there cannot be two s in the same column. For those blocks connected to the cycle, there are two s in their tensors, but since the two tuples which define their positions in the tensor differ in more than one component, they cannot exist in the same column, and so they can exist together in a partial permutation. An example of how the algorithm functions with a typical input is given below.

\begin{exa} \label{AcyclicExam1}
Consider the sum of the two linkings  and  seen in the following diagram:
\end{exa}
\begin{center} \vspace{5mm}
\begin{tikzpicture}
  [auto, node
  distance=5mm, skip loop/.style={to path={-- ++(0,#1) -| (\tikztotarget)}}] \tikzstyle{every node} = [text depth=-5pt,text height=0.5ex]
  \node (z1) { }; 
   \node (1) [right of=z1] {}; \node (a) [right of=1] {} ;
  \node (2) [right of=a] {}; \node (b) [right of=2] {} ;
  \node (3)  [right of=b] {}; \node (c)  [right of=3] {};
  \node (4)  [right of=c] {}; \node(d) [right of=4] {} ;
  \node (5) [right of=d] {}; \node (e) [right of=5] {} ;
  \node (6) [right of=e] {}; \node (f) [right of=6] {} ;
  \node (7)  [right of=f] {}; \node (g)  [right of=7] {};
  \node (8)  [right of=g] {};
  \node (t1) [above of= z1] {};
  \node (t2) [above of= t1] {};
\begin{scope}\path   (1)  edge [red, skip loop =11mm,shorten >=8mm, shorten <=8mm]  (2);
\path (3)  edge  [red, skip loop =12mm,shorten >=8mm, shorten <=8mm] (6);
\path   (5)  edge [red, skip loop =11mm,shorten >=8mm, shorten <=8mm]  (4);
\path (7)  edge  [red, skip loop =11mm,shorten >=8mm, shorten <=8mm] (8);
\path   (1)  edge [blue, skip loop =7mm, shorten >=3mm, shorten <=3mm]  (6);
\path (2)  edge  [blue, skip loop =6mm, shorten >=3mm, shorten <=3mm] (3);
\path   (5)  edge [blue, skip loop =6mm, shorten >=3mm, shorten <=3mm]  (4);
\path (8)  edge  [blue, skip loop =6mm, shorten >=3mm, shorten <=3mm] (7);
\end{scope}
\end{tikzpicture} \vspace{5mm}
\end{center}

{\noindent\textit{The tensor representation of this linear combination of axiom links is  . We apply Algorithm \ref{AcyclicAlg}, choosing  to be , and the subset of axiom links drawn below to be  (with representation )}} 
\begin{center} \vspace{2mm}
\begin{tikzpicture}
  [auto, node
  distance=5mm, skip loop/.style={to path={-- ++(0,#1) -| (\tikztotarget)}}] \tikzstyle{every node} = [text depth=-5pt,text height=0.5ex]
 \node (z1) { }; 
    \node (1) [right of=z1] {}; \node (a) [right of=1] {} ;
   \node (2) [right of=a] {}; \node (b) [right of=2] {} ;
   \node (3)  [right of=b] {}; \node (c)  [right of=3] {};
   \node (4)  [right of=c] {}; \node(d) [right of=4] {} ;
   \node (5) [right of=d] {}; \node (e) [right of=5] {} ;
   \node (6) [right of=e] {}; \node (f) [right of=6] {} ;
   \node (7)  [right of=f] {}; \node (g)  [right of=7] {};
   \node (8)  [right of=g] {};
  \node (t1) [above of= z1] { };
  \node (t2) [above of= t1] { };
\begin{scope}\path (3)  edge  [magenta, skip loop =7mm, shorten >=3mm, shorten <=3mm] (6);
\path   (5)  edge [magenta, skip loop =6mm, shorten >=3mm, shorten <=3mm]  (4);
\end{scope}
\end{tikzpicture} \vspace{5mm}
\end{center}
	
	\begin{enumerate}[label={\cW4 \& }\arabic*.]
\item[2.] Step 2 from the algorithm is iterated twice. Starting with the left most axiom link from , the literals, along with the numbers to them are as follows:
\begin{center} \vspace{0mm}
\begin{tikzpicture}
  [auto, node
  distance=5mm, skip loop/.style={to path={-- ++(0,#1) -| (\tikztotarget)}}] \tikzstyle{every node} = [text depth=-5pt,text height=0.5ex]
  \node (z1) { }; 
     \node (1) [right of=z1] {}; \node (a) [right of=1] {} ;
    \node (2) [right of=a] {}; \node (b) [right of=2] {} ;
    \node (3)  [right of=b] {}; \node (c)  [right of=3] {};
    \node (4)  [right of=c] {}; \node(d) [right of=4] {} ;
    \node (5) [right of=d] {}; \node (e) [right of=5] {} ;
    \node (6) [right of=e] {}; \node (f) [right of=6] {} ;
    \node (7)  [right of=f] {}; \node (g)  [right of=7] {};
    \node (8)  [right of=g] {};
  \node (t1) [above of= z1] { };
  \node (t2) [above of= t1] { };
  \node (11) [below of=1] {};
  \node (12) [below of=2] {};
  \node (17) [below of=7] {};
  \node (18) [below of=8] {};
\begin{scope}\path   (1)  edge [red, skip loop =6mm, shorten >=3mm, shorten <=3mm]  (2);
\path (7)  edge  [red, skip loop =6mm, shorten >=3mm, shorten <=3mm] (8);
\end{scope}
\end{tikzpicture} \vspace{5mm}
\end{center}
	
\item[3.] Like Step 2, Step 3 must also be repeated. Starting once again from the left, the following number assignments are given:
\begin{center} \vspace{2mm}
\begin{tikzpicture}
  [auto, node
  distance=5mm, skip loop/.style={to path={-- ++(0,#1) -| (\tikztotarget)}}] \tikzstyle{every node} = [text depth=-5pt,text height=0.5ex]
  \node (z1) { }; 
     \node (1) [right of=z1] {}; \node (a) [right of=1] {} ;
    \node (2) [right of=a] {}; \node (b) [right of=2] {} ;
    \node (3)  [right of=b] {}; \node (c)  [right of=3] {};
    \node (4)  [right of=c] {}; \node(d) [right of=4] {} ;
    \node (5) [right of=d] {}; \node (e) [right of=5] {} ;
    \node (6) [right of=e] {}; \node (f) [right of=6] {} ;
    \node (7)  [right of=f] {}; \node (g)  [right of=7] {};
    \node (8)  [right of=g] {};
  \node (t1) [above of= z1] { };
  \node (t2) [above of= t1] { };
  \node (13) [below of=3] {3};
  \node (14) [below of=4] {5};
  \node (15) [below of=5] {5};
  \node (16) [below of=6] {3};
  \node (23) [below of=13] {4};
  \node (24) [below of=14] {6};
  \node (25) [below of=15] {6};
  \node (26) [below of=16] {4};
\begin{scope}\path (3)  edge  [magenta, skip loop =7mm, shorten >=3mm, shorten <=3mm] (6);
\path   (5)  edge [magenta, skip loop =6mm, shorten >=3mm, shorten <=3mm]  (4);
\end{scope}
\end{tikzpicture} \vspace{5mm}
\end{center}
	
\item[4 \& 5.] Tuples for the blocks are now created by merging the numbers for each of their literals.

\begin{center} \vspace{5mm}
\begin{tikzpicture}
  [auto, node
  distance=5mm, skip loop/.style={to path={-- ++(0,#1) -| (\tikztotarget)}}] \tikzstyle{every node} = [text depth=-5pt,text height=0.5ex]
 \node (z1) { }; 
    \node (1) [right of=z1] {}; \node (a) [right of=1] {} ;
   \node (2) [right of=a] {}; \node (b) [right of=2] {} ;
   \node (3)  [right of=b] {}; \node (c)  [right of=3] {};
   \node (4)  [right of=c] {}; \node(d) [right of=4] {} ;
   \node (5) [right of=d] {}; \node (e) [right of=5] {} ;
   \node (6) [right of=e] {}; \node (f) [right of=6] {} ;
   \node (7)  [right of=f] {}; \node (g)  [right of=7] {};
   \node (8)  [right of=g] {};
  \node (t1) [above of= z1] {};
  \node (t2) [above of= t1] {};
  \node (11) [below of=1] {[1]};
  \node (12) [below of=2] {[1]};
  \node (13) [below of=3] {[3}; \node (1c) [below of=c] {,};
  \node (14) [below of=4] {5]};
  \node (15) [below of=5] {[5}; \node (1e) [below of=e] {,};
  \node (16) [below of=6] {3}; \node (1f) [below of=f] {,};
  \node (17) [below of=7] {2]};
  \node (18) [below of=8] {[2]};
  \node (23) [below of=13] {[4}; \node (2c) [below of=1c] {,};
  \node (24) [below of=14] {6]};
  \node (25) [below of=15] {[6}; \node (2e) [below of=1e] {,};
  \node (26) [below of=16] {4}; \node (2f) [below of=1f] {,};
  \node (27) [below of=17] {2]};
\begin{scope}\path   (1)  edge [red, skip loop =11mm,shorten >=8mm, shorten <=8mm]  (2);
\path (3)  edge  [red, skip loop =12mm,shorten >=8mm, shorten <=8mm] (6);
\path   (5)  edge [red, skip loop =11mm,shorten >=8mm, shorten <=8mm]  (4);
\path (7)  edge  [red, skip loop =11mm,shorten >=8mm, shorten <=8mm] (8);
\path   (1)  edge [blue, skip loop =7mm, shorten >=3mm, shorten <=3mm]  (6);
\path (2)  edge  [blue, skip loop =6mm, shorten >=3mm, shorten <=3mm] (3);
\path   (5)  edge [blue, skip loop =6mm, shorten >=3mm, shorten <=3mm]  (4);
\path (8)  edge  [blue, skip loop =6mm, shorten >=3mm, shorten <=3mm] (7);
\end{scope}
\end{tikzpicture} \vspace{5mm}
\end{center}	

\item[6.] The tensors  are then created from the tuples above. 
\medskip
\end{enumerate}

\noindent In the tuples underneath each of the blocks in the MDNF~formula given in Part 4/5 of the above example, it can be seen that each of the numbers being assigned to the literals occur exactly twice. It can be easily verified that this occurs with any valid choice of input to the algorithm: before a number is assigned to a pair of literals in either of Steps 2 or 3, the counter used to provide that number is incremented so previously assigned numbers are never reused; and numbers are assigned to two literals at a time. Furthermore, two literals are given the same number (or numbers) of another literal if and only if they share an axiom link in the chosen linking . This can be realised by noting that Steps 2 and 3 are actually, in principle, numbering the axiom links of , and the literals, and only the literals, incident to an axiom link take the numbers associated with that link. This principle allows us to differentiate the chosen  from all other linkings, as can be seen in the coming claims. 

\begin{lem} \label{AcyclicClaim1}
Suppose that we have a linear combination of proof structures including a non-zero instance of a linking  which contains a minimal cycle , and choose a block  through which  passes. Then a tensor modelling a linking  when composed with all the tensors except  created by Algorithm \ref{AcyclicAlg} (when using  and  as inputs) will result in a zero tensor if  and  do not have an identical set of axiom links not connected to block .
\end{lem}
\proof
Suppose there is a link  not connected to block . Then the tensor modelling  must take the form  for some tensor , with  and  being indices associated with the literals connected via . For the blocks  and  containing the literals allocated the index  and , the algorithm creates partial permutations built from summations of one or two tensors of the form  and , with  and  and  products of Kronecker deltas whose details are of little relevance.

\p Since the two literals connected to  are not linked in , the numbers given to those literals in the tuples created by the algorithm are different, and therefore we know  for each of the parts of the partial permutations  and  of the form  and . We therefore find that , meaning  in all entries, and therefore  and  for the appropriate indices. \qed

The claim above can be seen clearly in action in Example \ref{AcyclicExam1}. If we assume that block , which is certainly in the cycle  in , then we see that the link in  from the left-most negative literal to the positive literal directly to its right, represented by the tensor , is neither in  nor incident to block~. The algorithm provides two partial permutations  and  which are intended to be composed directly with , and they produce a zero tensor as desired.

The effects of the tensor relating to  are therefore eradicated when composed with all of , ,  and .

\p There are examples of linear combinations of proof structures and choice of block , unlike the one given above, where there is a linking  which shares all of its axiom links not incident with block  with . Lemma~\ref{AcyclicClaim1} is rendered useless in these situations when attempting to differentiate all other sets of axiom links from . The example below typifies such a dilemma.

\begin{exa} \label{AcyclicExam2}
Consider the sum of the three linkings , and  seen in the diagram below.
\end{exa}
\begin{center} \vspace{5mm}
\begin{tikzpicture}
  [auto, node
  distance=5mm, skip loop/.style={to path={-- ++(0,#1) -| (\tikztotarget)}}] \tikzstyle{every node} = [text depth=-5pt,text height=0.5ex]
 \node (z1) { }; 
    \node (1) [right of=z1] {}; \node (a) [right of=1] {} ;
   \node (2) [right of=a] {}; \node (b) [right of=2] {} ;
   \node (3)  [right of=b] {}; \node (c)  [right of=3] {};
   \node (4)  [right of=c] {}; \node(d) [right of=4] {} ;
   \node (5) [right of=d] {}; \node (e) [right of=5] {} ;
   \node (6) [right of=e] {};
  \node (t1) [above of= z1] {};
  \node (t2) [above of= t1] {};
  \node (t3) [above of= t2] {};
\begin{scope}\path   (1)  edge [red, skip loop =16mm,shorten >=13mm, shorten <=13mm]  (2);
\path (3)  edge  [red, skip loop =16mm,shorten >=13mm, shorten <=13mm] (4);
\path   (5)  edge [red, skip loop =16mm,shorten >=13mm, shorten <=13mm]  (6);
\path   (1)  edge [blue, skip loop =12mm,shorten >=8mm, shorten <=8mm]  (6);
\path (2)  edge  [blue, skip loop =11mm,shorten >=8mm, shorten <=8mm] (4);
\path   (5)  edge [blue, skip loop =10mm,shorten >=8mm, shorten <=8mm]  (3);
\path (1)  edge  [green, skip loop =7mm, shorten >=3mm, shorten <=3mm] (6);
\path (2)  edge  [green, skip loop =6mm, shorten >=3mm, shorten <=3mm] (5);
\path (3)  edge  [green, skip loop =5mm, shorten >=3mm, shorten <=3mm] (4);
\end{scope}
\end{tikzpicture} \vspace{5mm}
\end{center}
\textit{Their corresponding tensor representation is . Choosing  to be , and taking the subset of links given in the figure below to be  (with representation )}
\begin{center} \vspace{5mm}
\begin{tikzpicture}
  [auto, node
  distance=5mm, skip loop/.style={to path={-- ++(0,#1) -| (\tikztotarget)}}] \tikzstyle{every node} = [text depth=-5pt,text height=0.5ex]
 \node (z1) { }; 
    \node (1) [right of=z1] {}; \node (a) [right of=1] {} ;
   \node (2) [right of=a] {}; \node (b) [right of=2] {} ;
   \node (3)  [right of=b] {}; \node (c)  [right of=3] {};
   \node (4)  [right of=c] {}; \node(d) [right of=4] {} ;
   \node (5) [right of=d] {}; \node (e) [right of=5] {} ;
   \node (6) [right of=e] {};
  \node (t1) [above of= z1] {};
\begin{scope}\path (2)  edge  [magenta, skip loop =7mm, shorten >=3mm, shorten <=3mm] (5);
\path (3)  edge  [magenta, skip loop =6mm, shorten >=3mm, shorten <=3mm] (4);
\end{scope}
\end{tikzpicture} \vspace{5mm}
\end{center}

\begin{enumerate}[label={\cW4 \& }\arabic*.]
\item[2.] Step 2 from the algorithm is only used once. We provide the single pair of literals connected to the sole link in  with the number .
\begin{center} \vspace{5mm}
\begin{tikzpicture}
  [auto, node
  distance=5mm, skip loop/.style={to path={-- ++(0,#1) -| (\tikztotarget)}}] \tikzstyle{every node} = [text depth=-5pt,text height=0.5ex]
 \node (z1) { }; 
    \node (1) [right of=z1] {}; \node (a) [right of=1] {} ;
   \node (2) [right of=a] {}; \node (b) [right of=2] {} ;
   \node (3)  [right of=b] {}; \node (c)  [right of=3] {};
   \node (4)  [right of=c] {}; \node(d) [right of=4] {} ;
   \node (5) [right of=d] {}; \node (e) [right of=5] {} ;
   \node (6) [right of=e] {};
  \node (11) [below of=1] {1};
  \node (16) [below of=6] {1};
\begin{scope}\path (1)  edge  [green, skip loop =6mm, shorten >=3mm, shorten <=3mm] (6);
\end{scope}
\end{tikzpicture} \vspace{5mm}
\end{center}

\item[3.] Step 3 is repeated twice. Starting from the left, the assign numbers as follows:

\begin{center} \vspace{5mm}
\begin{tikzpicture}
  [auto, node
  distance=5mm, skip loop/.style={to path={-- ++(0,#1) -| (\tikztotarget)}}] \tikzstyle{every node} = [text depth=-5pt,text height=0.5ex]
 \node (z1) { }; 
    \node (1) [right of=z1] {}; \node (a) [right of=1] {} ;
   \node (2) [right of=a] {}; \node (b) [right of=2] {} ;
   \node (3)  [right of=b] {}; \node (c)  [right of=3] {};
   \node (4)  [right of=c] {}; \node(d) [right of=4] {} ;
   \node (5) [right of=d] {}; \node (e) [right of=5] {} ;
   \node (6) [right of=e] {};
  \node (t1) [above of= z1] { };
  \node (12) [below of=2] {2};
  \node (13) [below of=3] {4}; \node (14) [below of=4] {4};
  \node (15) [below of=5] {2};
  \node (22) [below of=12] {3};
  \node (23) [below of=13] {5}; \node (24) [below of=14] {5};
  \node (25) [below of=15] {3}; 
\begin{scope}\path (2)  edge  [magenta, skip loop =7mm, shorten >=3mm, shorten <=3mm] (5);
\path (3)  edge  [magenta, skip loop =6mm, shorten >=3mm, shorten <=3mm] (4);
\end{scope}
\end{tikzpicture} \vspace{5mm}
\end{center}
\pagebreak
\item[4 \& 5.] The numbers created in the previous steps are now used to make tuples.


\begin{center} \vspace{5mm}
\begin{tikzpicture}
  [auto, node
  distance=5mm, skip loop/.style={to path={-- ++(0,#1) -| (\tikztotarget)}}] \tikzstyle{every node} = [text depth=-5pt,text height=0.5ex]
 \node (z1) { }; 
    \node (1) [right of=z1] {}; \node (a) [right of=1] {} ;
   \node (2) [right of=a] {}; \node (b) [right of=2] {} ;
   \node (3)  [right of=b] {}; \node (c)  [right of=3] {};
   \node (4)  [right of=c] {}; \node(d) [right of=4] {} ;
   \node (5) [right of=d] {}; \node (e) [right of=5] {} ;
   \node (6) [right of=e] {};
  \node (t1) [above of= z1] {};
  \node (t2) [above of= t1] {};
  \node (t3) [above of= t2] {};
  \node (11) [below of=1] {[1]};
  \node (12) [below of=2] {[2}; \node (1b) [below of=b] {,};
  \node (13) [below of=3] {4]}; \node (14) [below of=4] {[4}; \node (1d) [below of=d] {,};
  \node (15) [below of=5] {2}; \node (16) [below of=6] {1]};
  \node (11) [below of=11] {[1]};
  \node (12) [below of=12] {[3}; \node (2b) [below of=1b] {,};
  \node (23) [below of=13] {5]}; \node (24) [below of=14] {[5}; \node (2d) [below of=1d] {,};
  \node (25) [below of=15] {3};  \node (2e) [below of=1e] {,};
  \node (26) [below of=16] {1]};
\begin{scope}\path   (1)  edge [red, skip loop =16mm,shorten >=13mm, shorten <=13mm]  (2);
\path (3)  edge  [red, skip loop =16mm,shorten >=13mm, shorten <=13mm] (4);
\path   (5)  edge [red, skip loop =16mm,shorten >=13mm, shorten <=13mm]  (6);
\path   (1)  edge [blue, skip loop =12mm,shorten >=8mm, shorten <=8mm]  (6);
\path (2)  edge  [blue, skip loop =11mm,shorten >=8mm, shorten <=8mm] (4);
\path   (5)  edge [blue, skip loop =10mm,shorten >=8mm, shorten <=8mm]  (3);
\path (1)  edge  [green, skip loop =7mm, shorten >=3mm, shorten <=3mm] (6);
\path (2)  edge  [green, skip loop =6mm, shorten >=3mm, shorten <=3mm] (5);
\path (3)  edge  [green, skip loop =5mm, shorten >=3mm, shorten <=3mm] (4);
\end{scope}
\end{tikzpicture} \vspace{5mm}
\end{center}

\item[6.] The tensors  are then created from the tuples above.

Then .\medskip
\end{enumerate}

\noindent Fortunately, we are able to find another claim which provides enough information to differentiate any such rogue sets of axiom links from the chosen linking  sufficiently.

\begin{lem} \label{AcyclicClaim2}
Suppose that we have a linear combination of proof structures including a non-zero instance of a linking  which contains a minimal cycle , and choose a block  through which  passes. Let  and  be the two tuples created for block  by Algorithm \ref{AcyclicAlg} with  and  over their associated \mll~formula as its inputs, reordered so the  positions of  and  relate to the  positive literal (given index ), and  and  to the  negative literal with . If a set of axiom links  in the linear combination is similar enough to  that their axiom links not connected to block  are the same, then the tensor  when composed with all the tensors created by Algorithm \ref{AcyclicAlg} except , and either one of the tensors  and , the result is the scalar  if , and  otherwise.
\end{lem}
\proof
We start by showing that zero is created in the case that . In this situation, there is an axiom link in  incident to block  which is not found in . Without loss of generality, we assume that this link is connected to block  by a positive literal given index  in the tensor representation; it is adjacent to a negative literal with index  for some  and . The tensor representation of the axiom link is therefore , and the representation of  has this as a factor.

\p The value (or values) found in the  position of the tuple (or tuples) associated with block  in this case are not the same as  for , since the link is not found in : the tensor  has form  or , and we find that

for appropriate superindices  and , from which this part of the claim is a trivial consequence. This is because, for both  and ,


Now we consider the case when . Suppose that two literals, one of each polarity, given indices  and  are connected by an axiom link in . Then  has  as a factor.

\p If blocks  and  are not connected to , then it must be the case that  and  are factors of  and  respectively for the  and  defined in the algorithm for these index position. We know that  for some  for both constant tensors due to the axiom link being in .

As such,  produces Kronecker deltas representing an MDNF~proof structure identical to that of , but with the literals incident to the chosen axiom link removed (together with said axiom link). Following this line of argument to its logical conclusion, we find, when  means all blocks not adjacent to , that

reduces to the tensor representation of the axiom links solely in the neighbouring blocks of , with the  in the product being indices for each literal found in the blocks connected to the links in  which are adjacent via axiom links to blocks not connected to the cycle.

We now consider tuples  for the remaining indices in the blocks connected to . That is, for each of these ,

for appropriate superindices.

\p Suppose that there is an axiom link connected to blocks connected to the cycle  but not connected to block . Then its representation takes the form  for some , , , . It cannot be the case that , since we have chosen for  to be a minimal cycle in  (as prescribed by Algorithm~\ref{AcyclicAlg}). If it were, it would actually be the entire cycle. We are therefore left with the only possibility that .




If , then there will be a factor of the original composition which is equivalent to the following:

The tensor  is acting as the representation of an axiom link between the two literals represented by the indices  and .

\p The two tuples  and  are partial permutations containing exactly two non-zero positions. This is seen by how they are found by the blocks  and : the `' blocks are partial permutations with exactly two non-zero positions, and since they can be formed from the two `' tuples by use of a single Kronecker delta the same must be true of their factors. By assumption, and without loss of generality regarding which tuple contains the positive literal of the axiom link and which contains the negative, we know that the tuples  and  are tuples which take the forms below.

for some appropriately sized constant superindices  and constants , whilst letting  and  be the free superindices which are  and  with  and  removed respectively. We know this because Algorithm~\ref{AcyclicAlg} ensures that the tuples created for two blocks of tensors will have entries which match each other if and only if there is an axiom link in  connecting the literals whose positions they are representing. Since the axiom links of  and  which are not connected to block  are the, this crosses over to this linking.

\p Once these representations have been created, it becomes clear that the tensor composition from before reduces to nothing more than another partial permutation with two non-zero entries.

The representation could be said to be equivalent to the block of literals which would be created by merging to two blocks to which  and  are connected and removing the linked literals. The same idea applies to the two tuples that are created.

\p This is certainly a repeatable process for all axiom links not connected to block . Following this procedure as far as possible, we find that the answer to the original composition becomes the same as

The tensor  is the partial permutation described by two tuples providing the locations of the non-zero entries of block : the concatenation of all the first tuples of blocks which are not , with tuple positions relating to indices describing literals not connected to block  by an axiom link deleted; and the same with the second tuples. In Example~\ref{AcyclicExam2}, taking that , it happens that .

\p Due to the algorithm ensuring that certain tuple positions are kept
equal to one another, 
 It then follows trivially that 
 \medskip

\noindent Example \ref{AcyclicExam2} fits the scenario where Lemma~\ref{AcyclicClaim2} is used neatly. Assuming block  is the chosen block , it is clear that every axiom link in  not incident to that block is found in  and vice versa. However, multiplying  with  and  gives the following tensor:
 

\p\noindent Multiplying the resulting tensor with either  or  will immediately result in producing a  as an output.


Note in particular how composing with  produces two tensors being summed together which either have the right numbers to use in the entry positions but in the wrong order as in the first (due to the axiom links connecting with the block in a different manner), or the wrong numbers altogether like in the second (due to using the tensor created from the information from the upper tuple rather than the lower). The dual of this remark can be found by considering composition with .

\p Armed with the two claims created from the earlier simple principle, we are in a position to express why MDNF~transformations from  only translate to  if the linear combination of proof structures they model do not contain a cyclic proof structure.

\begin{prop} \label{AcyclicLemma} Every MDNF transformation in 
  models a linear combination of acyclic proof structures.
\end{prop}
\proof
  Suppose that the functor  is in MDNF, and therefore for
  any 
  
  The tensor representations of the values of the above object are
  given in Section~\ref{SectionMDNFObjects}

  Let 
  be an MDNF transformation in , modelling a linear combination
  of proof structures, one of which is cyclic. For the object
  , the component 
  is represented by the tensor
  
  One of the bijections,  say, is such that , and there is a cycle between the blocks.

  We show that  for some choice of
  . We choose  and define a set of partial
  permutations , one for each block of tensor
  products of literals, using Algorithm~\ref{AcyclicAlg}; and we
  nominate any one of the blocks that is part of the chosen cycle,
  calling it . We know from Lemmas~\ref{AcyclicClaim1} and~\ref{AcyclicClaim2} that there are two distinct entry tuples
   and  for  where
   that, for , 
  
  The tensor , when multiplied with
    these partial permutations, produces a tensor with at least two
    non-zero entries, meaning it fails the criterion desired of it to
    belong to . As such
     is not an arrow in
    , and consequently
     cannot be seen as an \mll\ transformation in . \qed
  
  \subsection{Connectedness} \label{SubsectionConnectedness}
  
  The previous subsection holds the proof that MDNF~transformations in  only describe linear combinations of acyclic proof structures. This section is devoted to proving the proof structures are connected as well. Once again we can see the intuition behind the coming proof using a couple of small examples.
  
  \p Consider the simplest \hughf{disconnected} proof structure.
  \begin{center} \vspace{5mm}
  \begin{tikzpicture}
    [auto, node
    distance=5mm, skip loop/.style={to path={-- ++(0,#1) -| (\tikztotarget)}}] \tikzstyle{every node} = [text depth=-5pt,text height=0.5ex]
     \node (1) {}; \node (a) [right of=1] {} ;
    \node (2) [right of=a] {}; \node (b) [right of=2] {} ;
    \node (3)  [right of=b] {}; \node (c)  [right of=3] {};
   \node (4)  [right of=c] {};
  \begin{scope}\path   (1)  edge [black, skip loop =6mm, shorten >=3mm, shorten <=3mm]  (2);
  \path (3)  edge  [black, skip loop =6mm, shorten >=3mm, shorten <=3mm] (4);
  \end{scope}
  \end{tikzpicture} \vspace{5mm}
  \end{center}
If we say  for some , it is quickly observed that the values of \linebreak  are described by the -permutations over . These are all tensors of the form  ( and  being linked to the  positive and negative literals respectively) which, when composed with any three constant tensors, produce another constant tensor.
  
  \p The proof structure is described by . It is already known that this is not a full -permutation, and therefore does not belong to the set of values. However, we require a more generalisable perspective in order to the learn from the example. If we compose  with  and , which are both -permutations over , we see that , meaning . Remembering the description of values of MDNF~objects built solely from  in Section~\ref{SectionMDNFObjects}, it becomes clear that  cannot belong in : the zero tensor does not belong to , and composing any tensor from the non-empty  with  produces .
  
  \p In the above example it was possible to find (-)permutations for both blocks in the left-hand component which, when composed with the Kronecker delta modelling the axiom link incident to their associated literals, produce the scalar . The generalisability of this idea becomes further evident when a more complicated proof structure is considered. 
  
  \begin{center} \vspace{5mm}
\begin{tikzpicture}
  [auto, node
  distance=5mm, skip loop/.style={to path={-- ++(0,#1) -| (\tikztotarget)}}] \tikzstyle{every node} = [text depth=-5pt,text height=0.5ex]
 \node (z1) { }; 
    \node (1) [right of=z1] {}; \node (a) [right of=1] {} ;
   \node (2) [right of=a] {}; \node (b) [right of=2] {} ;
   \node (3)  [right of=b] {}; \node (c)  [right of=3] {};
   \node (4)  [right of=c] {}; \node(d) [right of=4] {} ;
   \node (5) [right of=d] {}; \node (e) [right of=5] {} ;
   \node (6) [right of=e] {};  \node (f) [right of=6] {} ;
   \node (7)  [right of=f] {}; \node (g)  [right of=7] {};
   \node (8) [right of=g] {};  \node (h) [right of=8] {} ;
   \node (9)  [right of=h] {}; \node (i)  [right of=9] {};
   \node (10)  [right of=i] {};
\begin{scope}\path (1)  edge  [black, skip loop =6mm, shorten >=3mm, shorten <=3mm] (2);
\path (3)  edge  [black, skip loop =6mm, shorten >=3mm, shorten <=3mm] (4);
\path (5)  edge  [black, skip loop =7mm, shorten >=3mm, shorten <=3mm] (8);
\path (6)  edge  [black, skip loop =6mm, shorten >=3mm, shorten <=3mm] (7);
\path (9)  edge  [black, skip loop =6mm, shorten >=3mm, shorten <=3mm] (10);
\end{scope}
\end{tikzpicture} \vspace{5mm}
\end{center}  
  The above structure contains far more axiom links, and some blocks have more than one literal within them. Its links are described by , with the left-most component's links given by .
  
  \p The first five blocks constitute the left-most component, and five permutations which can annihilate the above tensors are found below.
  \vspace{3mm}
  
  \vspace{3mm}
  
  It is therefore true that  
for all , and so  is not a value, meaning that  is not modelled in  by an \mll~transformation.
  
  \p The lesson to be learned from the arithmetic above is that although cycle permutations are being used for the permutations  above\footnote{It should be remembered that .}, this is only due to their ease in comprehension. What is most important is that certain positions in the permutations have value . The proof structure figure below shows a choice of positions in the permutations corresponding to each block in the proof structure from above which ensure that their composition with the tensor  yields a zero tensor.
  \begin{center} \vspace{5mm}
\begin{tikzpicture}
  [auto, node
  distance=5mm, skip loop/.style={to path={-- ++(0,#1) -| (\tikztotarget)}}] \tikzstyle{every node} = [text depth=-5pt,text height=0.5ex]
 \node (z1) { }; 
    \node (1) [right of=z1] {}; \node (a) [right of=1] {} ;
   \node (2) [right of=a] {}; \node (b) [right of=2] {} ;
   \node (3)  [right of=b] {}; \node (c)  [right of=3] {};
   \node (4)  [right of=c] {}; \node(d) [right of=4] {} ;
   \node (5) [right of=d] {}; \node (e) [right of=5] {} ;
   \node (6) [right of=e] {};  \node (f) [right of=6] {} ;
   \node (7)  [right of=f] {}; \node (g)  [right of=7] {};
   \node (8) [right of=g] {};  \node (h) [right of=8] {} ;
   \node (9)  [right of=h] {}; \node (i)  [right of=9] {};
   \node (10)  [right of=i] {};
  \node (11) [below of=1] {[1]};
  \node (12) [below of=2] {[1}; \node (1b) [below of=b] {,};
  \node (13) [below of=3] {4]}; \node (14) [below of=4] {[4}; \node (1d) [below of=d] {,};
  \node (15) [below of=5] {5};  \node (1e) [below of=e] {,};
  \node (16) [below of=6] {2]}; \node (17) [below of=7] {[2]};
  \node (18) [below of=8] {[3]};
\begin{scope}\path (1)  edge  [black, skip loop =6mm, shorten >=3mm, shorten <=3mm] (2);
\path (3)  edge  [black, skip loop =6mm, shorten >=3mm, shorten <=3mm] (4);
\path (5)  edge  [black, skip loop =7mm, shorten >=3mm, shorten <=3mm] (8);
\path (6)  edge  [black, skip loop =6mm, shorten >=3mm, shorten <=3mm] (7);
\path (9)  edge  [black, skip loop =6mm, shorten >=3mm, shorten <=3mm] (10);
\end{scope}
\end{tikzpicture} \vspace{5mm}
  \end{center}
  Notice that each pair of literals in the proof structure are only given the same number for their entry positions if they are connected by an axiom link, and that all bar one of the linked pairs share a number, one of the rogue pair being the leaf which is the  block. Because of this, it is possible to follow a chain of compositions of permutations with  in an order such that the permutation of a block  is not considered until those of all the blocks whose unique path to the  block in the block graph passes through  have been (leaving  to last). This ensures that the product of all the permutations corresponding to blocks greater than or equal to  in the block graph of the structure with respect to the partial tree ordering induced by the vertex representing the  block with the primitive Kronecker deltas of  having at least one index in common with one of the permutations reduces to a Kronecker delta , where  is the sole remaining index relating to the literal connected via an axiom link to a literal not in the set of blocks greater than or equal to , and  is the number in the tuple placed underneath the same literal. The inevitable consequence is that the final Kronecker delta associated with the axiom link connected to the right-most leaf of the component having its indices substituted for two distinct numbers, which is equal to zero.
  
  \p Of course, we are not in a position to assume we are only dealing with singular proof structures and their scalar multiples --- linear combinations of proof structures have not yet been discounted. Lemma \ref{AcyclicLemma} allows us to assume that all proof structures in a linear combination being considered are acyclic. This has a rather useful consequence, namely that if any one proof structure in a linear combination of them is disconnected, then all the others are as well.
  
  \begin{lem} \label{OneDiscThenAllClaim}
  If a sequent  can be bestowed with a valid set of axiom links which induce an acyclic yet disconnected proof structure, then all possible valid linkings are also disconnected.
  \end{lem}
  \proof
  Given a set of
  proof structures over , we know that all the structures have the same number
  of edges. The number of axiom links in a single structure is equal to the number of pairs of literals which exist in , and so independent of the position of the links; and since the proof structures are built over the same parse forest (namely the one described by ), the number of edges which are not axiom links are equal as well. The number of  connectives is trivially only dependent on , and so the number of -vertices in each structure does not vary. The number of edges in a switching of a proof structure is equal to the number in the entire proof structure minus the number of -vertices in it, meaning that every switching of every proof structure over  has the same number of edges.
  
  \p The number of vertices in a proof structure over  (and therefore in each of its switchings),  say, is equal to the total number of literals and connectives in the sequent; for a graph over this number of vertices to be connected the number of edges must be greater than . If there is an acyclic and disconnected proof structure, its switchings must have strictly fewer than  edges: acyclicity provides an upper bound of , and the disconnectedness discounts the possibility of the number being exactly . Therefore \emph{all} switchings of all other proof structures have strictly fewer than  edges, which implies that the structures are all disconnected. \qed
  
  This fact leaves us with a slightly less daunting task. We merely need to place more restrictions on where entries must contain the value  for each of the permutations being composed with the tensor describing the incorrect \mll~proof structure. Different proof structures clearly lead to different components, and this could be viewed as creating a moving target. However, the claim above ensures that no problems are caused. We choose one leaf in the example to be the block not to be given a permutation to compose with the MDNF~tensor, and let ourselves be prepared to add restrictions to permutations for any of the other blocks if they are in a different component from that leaf for any one of the proof structures being modelled in the linear combination.
  
  \p The first task is to create a set of permutations over some  for an unacceptable linear combination of proof structures over a sequent  which makes it possible to derive a disproof of its associated tensor's existence in the set of values .
  
  \begin{algo} \label{DisconnectTupleAlg} Input: A linear combination of
    \hughf{acyclic, disconnected} MDNF proof structures of the same sequent
    containing  blocks. \\ Output: A number ; tensors
     such that  for each .
  \end{algo}
  \begin{enumerate}
  \item Let  be the set of axiom
    links in a linear combination of acyclic yet disconnected MDNF
    proof structures which are multiplied by a non-zero scalar. For
    each of the blocks containing exactly one literal (\emph{leaves})
    assign distinct values . We assign variables
     to each of the  blocks, with  as the initial setting. We call these variables
    \emph{valencies}. Let  and .
  
  \item Take  and the -free subgraph of the parse
    tree, and consider the component of the graph containing the lowest
    numbered component which does not contain block . Choose the
    leaf with the highest number in that component and change its
    valency to .
  
  \item Choose the first block  in the component such that .
    \begin{enumerate}
    \item If one does exist and it is a leaf, let . If it is
      not adjacent to another leaf in the graph, then assign the number
      given to that leaf to the literal to which it is connected and decrement the valency of the block of the connected literal.
      Restart Step~3.
    \item If one does exist but it is not a leaf, then mark the sole
      literal not yet allocated a number as an `exit' literal and go to
      Step~4.
    \item If there are no more blocks of valency  and , create
      a new \\ -tuple  for each block  in the
      component, and for every  let  be the label given to the  literal of the
      block. If the  literal is the exit of the block, then
      mark  as an exit entry. Delete duplicate tuples associated
      with each block, and remove all the labels and marks from all the
      literals except the leaves. Increment  and return to Step~2.
    \item Otherwise, terminate the algorithm after declaring that  and stating that for each ,
      
    \end{enumerate}
  \item Check to see whether the numbers given to each of the non-exit
    literals correspond exactly to those of a tuple  already associated with the block
    (meaning that if  is the number given to the 
    literal in the block, that  for every  for which
     is defined).
    \begin{enumerate}
    \item If so, then assign the final unused number in  to
      the exit literal.
    \item If not, assign  to the exit literal and increment~.
    \end{enumerate}
    Assign the number to the literal with which the exit literal shares
    an axiom link, unless that literal is a leaf and already has been
    assigned a number. Decrement the valencies of both block  and
    the block with which the exit literal of block  is linked by an
    axiom link in . Go to Step~3.
  \end{enumerate}
  
  \begin{exa} \label{DisconnectExam1}
  Consider the sum of the three linkings ,  and  provided below in red, blue and green respectively.
  \begin{center} \vspace{5mm}
  \begin{tikzpicture}
    [auto, node
    distance=5mm, skip loop/.style={to path={-- ++(0,#1) -| (\tikztotarget)}}] \tikzstyle{every node} = [text depth=-5pt,text height=0.5ex]
   \node (z1) { }; 
      \node (1) [right of=z1] {}; \node (a) [right of=1] {} ;
     \node (2) [right of=a] {}; \node (b) [right of=2] {} ;
     \node (3)  [right of=b] {}; \node (c)  [right of=3] {};
     \node (4)  [right of=c] {}; \node(d) [right of=4] {} ;
     \node (5) [right of=d] {}; \node (e) [right of=5] {} ;
     \node (6) [right of=e] {};  \node (f) [right of=6] {} ;
     \node (7)  [right of=f] {}; \node (g)  [right of=7] {};
     \node (8) [right of=g] {};  \node (h) [right of=8] {} ;
     \node (9)  [right of=h] {}; \node (i)  [right of=9] {};
     \node (10)  [right of=i] {};
  \begin{scope}\path (1)  edge  [red, skip loop =16mm,shorten >=13mm, shorten <=13mm] (2);
  \path (3)  edge  [red, skip loop =16mm,shorten >=13mm, shorten <=13mm] (4);
  \path (5)  edge  [red, skip loop =16mm,shorten >=13mm, shorten <=13mm] (6);
  \path (7)  edge  [red, skip loop =17mm,shorten >=13mm, shorten <=13mm] (10);
  \path (8)  edge  [red, skip loop =16mm,shorten >=13mm, shorten <=13mm] (9);
  \path (1)  edge  [blue, skip loop =11mm,shorten >=8mm, shorten <=8mm] (3);
  \path (2)  edge  [blue, skip loop =12mm,shorten >=8mm, shorten <=8mm] (4);
  \path (5)  edge  [blue, skip loop =11mm,shorten >=8mm, shorten <=8mm] (6);
  \path (7)  edge  [blue, skip loop =12mm,shorten >=8mm, shorten <=8mm] (10);
  \path (8)  edge  [blue, skip loop =11mm,shorten >=8mm, shorten <=8mm] (9);
  \path (1)  edge  [green, skip loop =6mm, shorten >=3mm, shorten <=3mm] (2);
  \path (3)  edge  [green, skip loop =6mm, shorten >=3mm, shorten <=3mm] (4);
  \path (5)  edge  [green, skip loop =6mm, shorten >=3mm, shorten <=3mm] (7);
  \path (6)  edge  [green, skip loop =7mm, shorten >=3mm, shorten <=3mm] (10);
  \path (8)  edge  [green, skip loop =6mm, shorten >=3mm, shorten <=3mm] (9);
  \end{scope}
  \end{tikzpicture} \vspace{5mm}
  \end{center}
  The linear combination's tensor representation is 

 We apply Algorithm~\ref{DisconnectTupleAlg}.
  \end{exa}
  \begin{enumerate}[label={\cW4 \& }\arabic*.]
  \item[1.] We first attach values to the leaves in each of the proof structures described. The value  reaches .
  \begin{center} \vspace{5mm}
  \begin{tikzpicture}
    [auto, node
    distance=5mm, skip loop/.style={to path={-- ++(0,#1) -| (\tikztotarget)}}] \tikzstyle{every node} = [text depth=-5pt,text height=0.5ex]
   \node (z1) { }; 
      \node (1) [right of=z1] {}; \node (a) [right of=1] {} ;
     \node (2) [right of=a] {}; \node (b) [right of=2] {} ;
     \node (3)  [right of=b] {}; \node (c)  [right of=3] {};
     \node (4)  [right of=c] {}; \node(d) [right of=4] {} ;
     \node (5) [right of=d] {}; \node (e) [right of=5] {} ;
     \node (6) [right of=e] {};  \node (f) [right of=6] {} ;
     \node (7)  [right of=f] {}; \node (g)  [right of=7] {};
     \node (8) [right of=g] {};  \node (h) [right of=8] {} ;
     \node (9)  [right of=h] {}; \node (i)  [right of=9] {};
     \node (10)  [right of=i] {};
    \node (t1) [above of= z1] {};
    \node (t2) [above of= t1] {};
    \node (t3) [above of= t2] {};
    \node (11) [below of=1] {[1]};
    \node (12) [below of=2] {[2]}; \node (13) [below of=3] {[3]}; \node (14) [below of=4] { }; \node (15) [below of=5] { }; \node (16) [below of=6] { };
    \node (17) [below of=7] { };
    \node (18) [below of=8] { };
    \node (19) [below of=9] {[4]};
    \node (20) [below of=10] {[5]};
  \begin{scope}\path (1)  edge  [red, skip loop =16mm,shorten >=13mm, shorten <=13mm] (2);
  \path (3)  edge  [red, skip loop =16mm,shorten >=13mm, shorten <=13mm] (4);
  \path (5)  edge  [red, skip loop =16mm,shorten >=13mm, shorten <=13mm] (6);
  \path (7)  edge  [red, skip loop =17mm,shorten >=13mm, shorten <=13mm] (10);
  \path (8)  edge  [red, skip loop =16mm,shorten >=13mm, shorten <=13mm] (9);
  \path (1)  edge  [blue, skip loop =11mm,shorten >=8mm, shorten <=8mm] (3);
  \path (2)  edge  [blue, skip loop =12mm,shorten >=8mm, shorten <=8mm] (4);
  \path (5)  edge  [blue, skip loop =11mm,shorten >=8mm, shorten <=8mm] (6);
  \path (7)  edge  [blue, skip loop =12mm,shorten >=8mm, shorten <=8mm] (10);
  \path (8)  edge  [blue, skip loop =11mm,shorten >=8mm, shorten <=8mm] (9);
  \path (1)  edge  [green, skip loop =6mm, shorten >=3mm, shorten <=3mm] (2);
  \path (3)  edge  [green, skip loop =6mm, shorten >=3mm, shorten <=3mm] (4);
  \path (5)  edge  [green, skip loop =6mm, shorten >=3mm, shorten <=3mm] (7);
  \path (6)  edge  [green, skip loop =7mm, shorten >=3mm, shorten <=3mm] (10);
  \path (8)  edge  [green, skip loop =6mm, shorten >=3mm, shorten <=3mm] (9);
  \end{scope}
  \end{tikzpicture} \vspace{5mm}
  \end{center}
  We make sure all the other components have valency the same as the number of literals within them: , , ,  and .
  
  \item[2.] We proceed with . With this set of axiom links the first block not in the same component as the first is the third. The component containing block  contains the , ,  and  blocks as well. We change the valency of block  to .
  
  \item[3 \& 4.] We must repeat the processes contained in Steps~3 and~4 four times (once for each axiom link in  connected to the component containing block ).
  	\begin{itemize}
  	\item Block  is a leaf and connects to the first literal of block . That literal is therefore given the same number allocated to block  (), and the second literal is marked as an exit. Block  now has valency , and block  has valency .
  	\item Block  is now the first block to have valency . Its second literal, is given  as its tuple entry, as is the first literal of the fifth block, which is adjacent. The valencies of blocks  and  become  and . The counter  is incremented to .
  	\item Block , a leaf, is now the first block with valency . It has already been given value , so we give this to its adjacent literal --- the third literal in the fifth block. We decrement the block valencies.
  	\item Block  is now the only one with valency~ in the component. Its only empty position --- the second --- is allocated the value . However, it is connected to the last leaf, and so we do not give its adjacent literal the same number (it already has been given the entry ).
  	\end{itemize}
  	We are left with the following tuples, with the numbers in squares emphasising exit literals for that particular linking:
  \begin{center} \vspace{5mm}
  \begin{tikzpicture}
    [auto, node
    distance=5mm, skip loop/.style={to path={-- ++(0,#1) -| (\tikztotarget)}}] \tikzstyle{every node} = [text depth=-5pt,text height=0.5ex]
   \node (z1) { }; 
      \node (1) [right of=z1] {}; \node (a) [right of=1] {} ;
     \node (2) [right of=a] {}; \node (b) [right of=2] {} ;
     \node (3)  [right of=b] {}; \node (c)  [right of=3] {};
     \node (4)  [right of=c] {}; \node(d) [right of=4] {} ;
     \node (5) [right of=d] {}; \node (e) [right of=5] {} ;
     \node (6) [right of=e] {};  \node (f) [right of=6] {} ;
     \node (7)  [right of=f] {}; \node (g)  [right of=7] {};
     \node (8) [right of=g] {};  \node (h) [right of=8] {} ;
     \node (9)  [right of=h] {}; \node (i)  [right of=9] {};
     \node (10)  [right of=i] {};
    \node (t1) [above of= z1] {};
    \node (t2) [above of= t1] {};
    \node (t3) [above of= t2] {};
    \node (11) [below of=1] {[1]}; \node (12) [below of=2] {[2]}; \node (13) [below of=3] {[3]}; \node (14) [below of=4] {[3};  \node (1d) [below of=d] {,};
    \node (15) [below of=5] {\fbox{6}]}; \node (16) [below of=6] {[6}; \node (1f) [below of=f] {,};
    \node (17) [below of=7] {\fbox{7}}; \node (1g) [below of=g] {,};
    \node (18) [below of=8] {4]}; \node (19) [below of=9] {[4]}; \node (20) [below of=10] {[5]};
  \begin{scope}\path (1)  edge  [red, skip loop =16mm,shorten >=13mm, shorten <=13mm] (2);
  \path (3)  edge  [red, skip loop =16mm,shorten >=13mm, shorten <=13mm] (4);
  \path (5)  edge  [red, skip loop =16mm,shorten >=13mm, shorten <=13mm] (6);
  \path (7)  edge  [red, skip loop =17mm,shorten >=13mm, shorten <=13mm] (10);
  \path (8)  edge  [red, skip loop =16mm,shorten >=13mm, shorten <=13mm] (9);
  \path (1)  edge  [blue, skip loop =11mm,shorten >=8mm, shorten <=8mm] (3);
  \path (2)  edge  [blue, skip loop =12mm,shorten >=8mm, shorten <=8mm] (4);
  \path (5)  edge  [blue, skip loop =11mm,shorten >=8mm, shorten <=8mm] (6);
  \path (7)  edge  [blue, skip loop =12mm,shorten >=8mm, shorten <=8mm] (10);
  \path (8)  edge  [blue, skip loop =11mm,shorten >=8mm, shorten <=8mm] (9);
  \path (1)  edge  [green, skip loop =6mm, shorten >=3mm, shorten <=3mm] (2);
  \path (3)  edge  [green, skip loop =6mm, shorten >=3mm, shorten <=3mm] (4);
  \path (5)  edge  [green, skip loop =6mm, shorten >=3mm, shorten <=3mm] (7);
  \path (6)  edge  [green, skip loop =7mm, shorten >=3mm, shorten <=3mm] (10);
  \path (8)  edge  [green, skip loop =6mm, shorten >=3mm, shorten <=3mm] (9);
  \end{scope}
  \end{tikzpicture} \vspace{5mm}
  \end{center}
  
  \item[2.] The process is then repeated with  and . Particular points to note are the following:
  	\begin{itemize}
  	\item The component containing block  can change (note that blocks  and  are not respected with respect to , but the two are adjacent with when the linkings  and  are used).
  	\item In the third iteration for , block  is reached at the same time in the same way as in . As such, the number  is reused for the tuple entry for its second literal.
  	\end{itemize}
  We now have three sets of tuples for each block (possibly repeated):
  \begin{center} \vspace{5mm}
  \begin{tikzpicture}
    [auto, node
    distance=5mm, skip loop/.style={to path={-- ++(0,#1) -| (\tikztotarget)}}] \tikzstyle{every node} = [text depth=-5pt,text height=0.5ex]
   \node (z1) { }; 
      \node (1) [right of=z1] {}; \node (a) [right of=1] {} ;
     \node (2) [right of=a] {}; \node (b) [right of=2] {} ;
     \node (3)  [right of=b] {}; \node (c)  [right of=3] {};
     \node (4)  [right of=c] {}; \node(d) [right of=4] {} ;
     \node (5) [right of=d] {}; \node (e) [right of=5] {} ;
     \node (6) [right of=e] {};  \node (f) [right of=6] {} ;
     \node (7)  [right of=f] {}; \node (g)  [right of=7] {};
     \node (8) [right of=g] {};  \node (h) [right of=8] {} ;
     \node (9)  [right of=h] {}; \node (i)  [right of=9] {};
     \node (10)  [right of=i] {};
    \node (t1) [above of= z1] {};
    \node (t2) [above of= t1] {};
    \node (t3) [above of= t2] {};
    \node (11) [below of=1] {[1]}; \node (12) [below of=2] {[2]}; \node (13) [below of=3] {[3]}; \node (14) [below of=4] {[3};  \node (1d) [below of=d] {,};
    \node (15) [below of=5] {\fbox{6}]}; \node (16) [below of=6] {[6}; \node (1f) [below of=f] {,};
    \node (17) [below of=7] {\fbox{7}}; \node (1g) [below of=g] {,};
    \node (18) [below of=8] {4]}; \node (19) [below of=9] {[4]}; \node (20) [below of=10] {[5]};
    \node (21) [below of=11] {[1]}; \node (22) [below of=12] {[2]}; \node (23) [below of=13] {[3]}; \node (24) [below of=14] {[2};  \node (2d) [below of=1d] {,};
    \node (25) [below of=15] {\fbox{8}]}; \node (26) [below of=16] {[8}; \node (2f) [below of=1f] {,};
    \node (27) [below of=17] {\fbox{9}}; \node (2g) [below of=1g] {,};
    \node (28) [below of=18] {4]}; \node (29) [below of=19] {[4]}; \node (30) [below of=20] {[5]};  
    \node (31) [below of=21] {[1]}; \node (32) [below of=22] {[2]}; \node (33) [below of=23] {[3]}; \node (34) [below of=24] {[3};  \node (3d) [below of=2d] {,};
    \node (35) [below of=25] {\fbox{6}]}; \node (36) [below of=26] {[\fbox{10}}; \node (3f) [below of=2f] {,};
    \node (37) [below of=27] {6}; \node (3g) [below of=2g] {,};
    \node (38) [below of=28] {4]}; \node (39) [below of=29] {[4]}; \node (40) [below of=30] {[5]};
  \begin{scope}\path (1)  edge  [red, skip loop =16mm,shorten >=13mm, shorten <=13mm] (2);
  \path (3)  edge  [red, skip loop =16mm,shorten >=13mm, shorten <=13mm] (4);
  \path (5)  edge  [red, skip loop =16mm,shorten >=13mm, shorten <=13mm] (6);
  \path (7)  edge  [red, skip loop =17mm,shorten >=13mm, shorten <=13mm] (10);
  \path (8)  edge  [red, skip loop =16mm,shorten >=13mm, shorten <=13mm] (9);
  \path (1)  edge  [blue, skip loop =11mm,shorten >=8mm, shorten <=8mm] (3);
  \path (2)  edge  [blue, skip loop =12mm,shorten >=8mm, shorten <=8mm] (4);
  \path (5)  edge  [blue, skip loop =11mm,shorten >=8mm, shorten <=8mm] (6);
  \path (7)  edge  [blue, skip loop =12mm,shorten >=8mm, shorten <=8mm] (10);
  \path (8)  edge  [blue, skip loop =11mm,shorten >=8mm, shorten <=8mm] (9);
  \path (1)  edge  [green, skip loop =6mm, shorten >=3mm, shorten <=3mm] (2);
  \path (3)  edge  [green, skip loop =6mm, shorten >=3mm, shorten <=3mm] (4);
  \path (5)  edge  [green, skip loop =6mm, shorten >=3mm, shorten <=3mm] (7);
  \path (6)  edge  [green, skip loop =7mm, shorten >=3mm, shorten <=3mm] (10);
  \path (8)  edge  [green, skip loop =6mm, shorten >=3mm, shorten <=3mm] (9);
  \end{scope}
  \end{tikzpicture} \vspace{5mm}
  \end{center}
  	
  \item[3.] The algorithm finished, leaving the following set of tensors:
  
  \end{enumerate}
  
\noindent  The above algorithm provides a set of partial permutations with entries containing the value  at positions which are of use in the final proof of the necessity of connectedness having to be satisfied. However, they are still \emph{partial} permutations, and in order to discuss objects of the form  full permutations must be used. It is therefore necessary to complete the permutations. Completing permutations is non-trivial, but by virtue of a number of properties bestowed on each of the partial permutations described in Algorithm \ref{DisconnectTupleAlg}, we are indeed capable of performing such a task.
  
  \begin{lem} \label{ConAlgCompleteLemma} Every partial higher-order
    permutation  where  which is an
    output tensor of Algorithm~\ref{DisconnectTupleAlg} can be
    completed to form a full higher-order permutation~.
  \end{lem}
  \proof
    It is known from Definition~\ref{TensorExamDefns} that for any  and  it is always possible to
    find the tensor  in . It is also well established that using a permutation over  on the numbering
    used on a single index of a permutation in  for any  always produces another equally valid permutation in the same set.
    
  Suppose that  is one of the partial permutations generated by Algorithm \ref{DisconnectTupleAlg} after being given appropriate inputs. Then we can refer back to the tuples  created in the middle of the algorithm which describe the positions where its entries are equal to , and also the positions in each of the tuples with an `exit marker'. From the definition of the procedure, we can be assured that if the  position of the  tuple is marked, then  for all . In other words, the number found in the position of a tuple's exit marker is not used again in the same position of another tuple. With
    this information, we define a set of partial functions in 
     in the following manner:
    \begin{enumerate}
    \item Let ,  and .
    \item If  has not yet been assigned a value
      and the tuple position in question was not marked an exit entry in Algorithm~\ref{DisconnectTupleAlg}, then we say that
       and then increment . Go to
      Step~3.
    \item If , increment  and go to Step~2; otherwise
      increment , set  back to  and go to Step~4.
    \item If , then go to Step~2; otherwise, go to Step~5.
    \item Reset  and .
    \item If  has not yet been assigned a value,
      then set  and go to Step~7. Otherwise increment 
      and repeat Step~6.
    \item If , increment  and let , and return to Step
      6. Otherwise, terminate the algorithm.
    \end{enumerate}
  
\noindent     This algorithm is well defined, and each partial function
     is injective with all defined source and target values
    in . As such, it is possible to restrict each of the partial
    functions to act upon , and then to extend them to full
    -permutations over (i.e. bijective endomorphisms on) . One way in which such an extension of a partial function  could be formed is inductively: by assigning the lowest value in  not already in the image of  to be the image of the lowest number in  not in domain of definition, and continuing similarly with the new definition of the partial function until it becomes total.
    
    \p We now define the tensor  for  in the following manner:
       
    The tensor is created by using -permutations on each of the entry positions of , and so belongs to the set . Furthermore, since  for each tuple  where  by design, it is a completion of , and as such we have satisfied the original statement as desired. \qed
  


  Much in the same manner as with Lemma~\ref{AcyclicLemma}, we are finally in a position to prove that the proof structures being modelled in linear combinations in the double-glued category are always proof nets.
  
  \begin{prop} \label{ConnectedLemma} Every MDNF transformation in 
    modelling a linear combination of acyclic proof structures is
    modelling a linear combination of cut-free proof nets.
  \end{prop}
  \proof
    Let  be an MDNF formula as in Lemma~\ref{AcyclicLemma}, and let \\  be an MDNF transformation in  modelling a linear
    combination of acyclic yet disconnected proof structures. We consider 
    where  is the output integer given by
    Algorithm~\ref{DisconnectTupleAlg} if the linear combination described by  is used as an input. From
    Section~\ref{SectionMDNFObjects} we know the criteria the tensor
    representations of the values of this object must satisfy.
  
  \p As seen in earlier deductions, for the integer  acquired from the algorithm, we have the tensor representation
    
    Algorithm~\ref{DisconnectTupleAlg} and Lemma~\ref{ConAlgCompleteLemma} makes it possible to obtain a
    set of (full) permutations  for the coming argument.
  
    \p Take any set of axiom links described by a bijection,  say,
    such that , and consider the tensor
    . It is possible to factorise this tensor into a
    product of Kronecker deltas, one for each component in the
    switching of . Multiplying the first of these smaller
    component tensors not containing the indices concerning the first
    block,  say, with
    each of the permutations 
    corresponding to the blocks within the component in question, the zero scalar is produced.
    
    \begin{clmenv}
    \begin{cLm}
    Using the definitions of  and  given above, 
    
    \end{cLm}
    \proof
    It is easy to show that there is a partial ordering induced by every tree and every choice of node within it. Given a tree  and vertex , we can create an ordering  defined as follows: if the unique path starting from a vertex  and finishing at  passes through the vertex , then we say that . The point  is therefore maximal in this ordering. This is a partial order if we close this under reflexivity.
    
    \p We consider the blocks with numbers in the image of  (that is, the blocks of the second component) observing the tree partial ordering induced by the leaf with the highest block number . With block  being a leaf, the tensor  for some constant , where the -index replaces either an - or -index depending on the polarity of the literal in the block. It should also be noted that, by design of the algorithm,  is a smaller number than any of the numbers given exit markers within the component which are not in a leaf block, and greater than all other numbers given to leaves in the component. We use an inductive argument on the blocks in this order to demonstrate that, for any block  except the reference leaf, a composition of the tensors in  with all the Kronecker deltas pairs whose indices are shared with two permutations in that set reduces to a constant tensor on the index with the exit marker created at this point in Algorithm \ref{DisconnectTupleAlg} and the number with said marker. That is,
    
    where  is the sole index not to be composed, and  is the number connected to the exit marker in the tuple generated by the algorithm the appropriate linking.
    \begin{itemize}
    \item The base case occurs when block  is a leaf. The first product of Kronecker deltas is then empty, and the second only contains the permutation . Since block  is a leaf, it must be the case that there is only one literal in the block, and therefore the permutation is a -permutation, i.e. a constant tensor of dimension . The algorithm defines the non-zero entry to occur at the  position, where  is the single value given to the block in Algorithm~\ref{DisconnectTupleAlg}, as desired.
    \item If not, then the composition can be split further. Let  denote the neighbourhood of block~ in the graph and . We can rewrite the composition above as follows:
    
    
    
    By the induction hypothesis, the inside of the bracket can be simplified, leaving
    
    
    Since  is a full -permutation, it must be the case that our final tensor, with constants taking the places of all bar one of the entry positions, is a -permutation as desired. Furthermore, the Kronecker deltas which have been fed into the equation are in agreement with exactly one set of tuples that is provided by the algorithm for . We therefore know that the number that the remaining free variable for the tensor must equal the final unused number from the tuple, which is the value at the exit marker. Our equation reduces to the form  with free index  and constant  as desired.
    
    
\end{itemize}
    Now we refer back to the original claim. The composition
      
           
    reduces to the very simple , where the -index is a substitute for an - or -index, depending on whether the literal for the component  is positive or negative as before. By the design of the algorithm, this final value  is assured of being not equal to ; and therefore it must be the case that  as desired. \qed
    \end{clmenv}
      
    \noindent Multiplying a zero tensor with any other tensor results in another
    zero tensor, and as such we know that
    
    Since
     is merely a linear combination of
    tensors like , and  was arbitrary, we know that
    
    This means that
    , and so
     does not meet the criteria to be found in .
    The \mll\ transformation  in  is therefore unable to be
    translated into  either. \qed
  
  \subsection{Uniqueness} \label{SubsectionUniqueness}
  
  Non-simple linear combinations of two or more proof structures can never be proof nets themselves. Because of this, their representations must be demonstrated to have been eradicated from the categorical model by the double glueing construction before we can declare MDNF~full completeness proved.
  
  \p The sections above allow us to take as fact that every \mll~transformation in the glued category  is not only the representation of a linear combination of proof structures, but a linear combination of proof \emph{nets}. Furthermore, it is also known that the scalars that each of the proof nets being modelled is multiplied by must sum to the semiring multiplicative unit . Interestingly, the information here is sufficient to provide MDNF~full completeness results for a number of categories of the form  for some category : namely those whose semiring of scalars have the property that if a sum  happens to equal , then there is exactly one  such that , and every other . An example of this type of category is the category of semimodules over .
  
  \p However, such grandiose claims cannot be written about the majority of compact closed categories with finite biproducts. In particular, the categories  and , which are the examples investigated in \cite{Tan97} in detail, do not benefit from having this property. A more comprehensive proof for uniqueness is required, and this unsurprisingly takes the same combinatorial form as seen throughout this chapter. We show the intuition to the proof below.
  
  \p For the sake of the coming argument, we assume that we do not have the result from Lemma \ref{OnlyOneLemma} (we use it in a more restricted form later). Suppose we have an \mll~transformation  which can be thought of as representing the sum of the two sets of axiom links over the formula below, itself being described by a functor .
  
  \begin{center} \vspace{5mm}
  \begin{tikzpicture}
    [auto, node
    distance=5mm, skip loop/.style={to path={-- ++(0,#1) -| (\tikztotarget)}}] \tikzstyle{every node} = [text depth=-5pt,text height=0.5ex]
    \node (z1) { };
     \node (1) {} [right of= z1]; \node (a) [right of=1] {} ;
    \node (2) [right of= a] {}; \node (b) [right of=2] {} ;
    \node (3)  [right of= b] {}; \node (c)  [right of=3] {};
    \node (4)  [right of= c] {};
    \node (t1) [above of= z1, xshift=-5mm] {};
    \node (t2) [above of= t1] {};
  \begin{scope}\path   (1)  edge [blue, skip loop =6mm, shorten >=3mm, shorten <=3mm]  (3);
  \path (2)  edge  [blue, skip loop =7mm, shorten >=3mm, shorten <=3mm] (4);
  \path (1) edge [red, skip loop = 11mm, shorten >=8mm, shorten <=8mm]  (2);
  \path (3) edge  [red, skip loop = 11mm, shorten >=8mm, shorten <=8mm] (4);
  \end{scope}
  \end{tikzpicture} \vspace{5mm}
  \end{center}
 
 \noindent Both linkings successfully describe proof nets for the formula, and so we are looking at a scenario concerning a linear combination of proof nets. The tensor representations of the two linkings  and , given by the red and blue linkings respectively, using the standard indices for each literal, are  and  respectively. The description of the linear combination of proof nets being discussed is .
  
  \p It is simple enough to find partial permutations for both of the first two blocks in the formula of some order which produces a constant tensor when composed with  yet creates a zero tensor when composed with . If we let  and , then
  

\noindent  By symmetry, it must also be possible to reverse this effect by letting  and .
  
  
  There are two significant points in the development of these partial permutations. Firstly, letting  (not using Einstein notation), the unions  and  are both partial permutations, where  if  and  otherwise. Secondly, the constant tensors created by the compositions  and  are not identical. The effect that these properties together have is that we can find a pair of partial permutations which act on the tensor sum , and the resulting tensor is the sum of two constant tensors where the constants are different (meaning they cannot interfere with one another and cancel each other out).
  
  There are clearly two non-zero entries in the resultant tensor, which means we can infer that the tensor  cannot belong to the set of values  for any number .
  
  \p The idea behind the coming proof can be extrapolated from this very simple example with relative ease. Given an \mll~transformation  in  modelling a non-simple linear combination of proof nets, we can show it does not manifest itself in any form in . An algorithm is given which takes linkings being described by  and creates partial permutations for all bar one of the blocks in the formula such that composing them with the tensor representation of two axiom links leaves a constant tensor, minimising interference between tensor representations of each linking involved. Composing these permutations with the a tensor representation of the linear combination of all the axiom links gives a tensor containing more than one non-zero entry, and therefore the tensor  is not in  for some , thus  cannot be found in . We start by giving the algorithm which begins this process.
  
  \begin{algo} \label{UniqueTupleAlg} Input: A non-trivial linear
    combination of MDNF proof nets for a sequent containing  blocks, the  of which having size  for each .
    \\ Output: A number ; tensors 
    such that  for
    each  except for one leaf.
  \end{algo}
  \begin{enumerate}
  \item Let  and  be two distinct sets of
    axiom links in the given linear combination of MDNF proof
    structures. We set the valencies  such that
     for all , except for the last leaf,
    block  say, for which . We let  and .
  \item Choose the first block  with .
    \begin{enumerate}
    \item If one does exist, then mark the sole literal not yet
      allocated a number as an `exit' and go to Step 3.
    \item If there are no more blocks of valency , create a new
       tuple  for each block  in the component,
      and let  for every , where 
      is the label given to the  literal of the block. Remove
      all the labels. If , increment , reset the valencies and
      restart Step~2; otherwise go to Step~4.
    \end{enumerate}
  
  \item Check to see whether the numbers given to each of the non-exit
    literals in the block correspond exactly to those of a tuple
     already associated with the
    block.
    \begin{enumerate}
    \item If so, then assign the final unused number in  to
      the exit literal.
    \item If not, increment  and then assign the new value of  to
      the exit literal.
    \end{enumerate}
    Assign the number to the literal with which the exit literal shares
    an axiom link in . Decrement the valencies of both
    block  and the the block with which the exit literal of block
     is linked by an axiom link in . Restart Step~2.
  
  \item Declare that , and we state that for each ,
     
  \end{enumerate}
  
\noindent  The algorithm above certainly terminates and produces partial permutations. By virtue of the proof structures being described by  and  being acyclic, there is always a block with valency  at every stage of the algorithm for a single value of  when one is needed until all the blocks bar leaf  have been visited. This assures that each block is considered in Step~2 exactly twice, and therefore at most two entries are found in each tensor of a block . On top of that, at the point where all bar one of the positions in a new tuple have been decided when  it is checked whether they all correspond exactly to the first tuple created when . If they do then the second tuple is completed to be a clone of the first; if not then a completely new number is used in the unfilled position. This ensures that there is never a situation where the two tuples differ in exactly one coordinate, and as such the tuples  (excluding ) have to be partial permutations.
  
  \p The partial permutations created need to have the effect of annihilating tensor representations of all possible axiom links on a sequent other than the two that have been selected for use in Algorithm \ref{UniqueTupleAlg}. Fortunately, the algorithm does do this naturally, and in fact makes sure that the representations of  and  only make use of one non-zero entry in each of the permutations.
  
  \begin{exa} \label{UniqueExam}
  Consider the sum of the three linkings ,  and  (given in red, blue and green respectively) in the diagram below.
  \end{exa}
  \begin{center} \vspace{2mm}
  \begin{tikzpicture}
    [auto, node
    distance=5mm, skip loop/.style={to path={-- ++(0,#1) -| (\tikztotarget)}}] \tikzstyle{every node} = [text depth=-5pt,text height=0.5ex]
   \node (z1) { }; 
      \node (1) [right of=z1] {}; \node (a) [right of=1] {} ;
     \node (2) [right of=a] {}; \node (b) [right of=2] {} ;
     \node (3)  [right of=b] {}; \node (c)  [right of=3] {};
     \node (4)  [right of=c] {}; \node(d) [right of=4] {} ;
     \node (5) [right of=d] {}; \node (e) [right of=5] {} ;
     \node (6) [right of=e] {};  \node (f) [right of=6] {} ;
     \node (7)  [right of=f] {}; \node (g)  [right of=7] {};
     \node (8) [right of=g] {};  \node (h) [right of=8] {} ;
     \node (9)  [right of=h] {}; \node (i)  [right of=9] {};
     \node (10)  [right of=i] {};
    \node (t1) [above of= z1] {};
    \node (t2) [above of= t1] {};
    \node (t3) [above of= t2] {};
  \begin{scope}\path (1)  edge  [red, skip loop =16mm,shorten >=13mm, shorten <=13mm] (2);
  \path (3)  edge  [red, skip loop =16mm,shorten >=13mm, shorten <=13mm] (4);
  \path (5)  edge  [red, skip loop =17mm,shorten >=13mm, shorten <=13mm] (8);
  \path (6)  edge  [red, skip loop =16mm,shorten >=13mm, shorten <=13mm] (7);
  \path (9)  edge  [red, skip loop =16mm,shorten >=13mm, shorten <=13mm] (10);
  \path (1)  edge  [blue, skip loop =11mm,shorten >=8mm, shorten <=8mm] (3);
  \path (2)  edge  [blue, skip loop =12mm,shorten >=8mm, shorten <=8mm] (4);
  \path (5)  edge  [blue, skip loop =12mm,shorten >=8mm, shorten <=8mm] (8);
  \path (6)  edge  [blue, skip loop =11mm,shorten >=8mm, shorten <=8mm] (7);
  \path (9)  edge  [blue, skip loop =11mm,shorten >=8mm, shorten <=8mm] (10);
  \path (1)  edge  [green, skip loop =6mm, shorten >=3mm, shorten <=3mm] (2);
  \path (3)  edge  [green, skip loop =6mm, shorten >=3mm, shorten <=3mm] (4);
  \path (5)  edge  [green, skip loop =7mm, shorten >=3mm, shorten <=3mm] (9);
  \path (6)  edge  [green, skip loop =6mm, shorten >=3mm, shorten <=3mm] (7);
  \path (8)  edge  [green, skip loop =6mm, shorten >=3mm, shorten <=3mm] (10);
  \end{scope}
  \end{tikzpicture} \vspace{2mm}
  \end{center}
  \textit{The tensor representation of this linear combination is}
  
  \textit{We apply Algorithm~\ref{UniqueTupleAlg}, choosing  and  as the two (synonymous) input linkings.}
  \vspace{5mm}
  \begin{enumerate}[label={\cW4 \& }\arabic*.]
  \item[1.] Block  is the right-most block containing only one literal, so the valencies of each block are given as follows:
   \item[2 \& 3.] We deal first with  (). Block  has valency , and no tuples have been given to it already (as is always the case when ), so the number  is allocated to it.
  
  Continuing along the same lines, looking for blocks of valency  from left to right at each iteration of Step~2, we obtain the following tuples.
  \begin{center} \vspace{-5mm}
  \begin{tikzpicture}
    [auto, node
    distance=5mm, skip loop/.style={to path={-- ++(0,#1) -| (\tikztotarget)}}] \tikzstyle{every node} = [text depth=-5pt,text height=0.5ex]
   \node (z1) { }; 
      \node (1) [right of=z1] {}; \node (a) [right of=1] {} ;
     \node (2) [right of=a] {}; \node (b) [right of=2] {} ;
     \node (3)  [right of=b] {}; \node (c)  [right of=3] {};
     \node (4)  [right of=c] {}; \node(d) [right of=4] {} ;
     \node (5) [right of=d] {}; \node (e) [right of=5] {} ;
     \node (6) [right of=e] {};  \node (f) [right of=6] {} ;
     \node (7)  [right of=f] {}; \node (g)  [right of=7] {};
     \node (8) [right of=g] {};  \node (h) [right of=8] {} ;
     \node (9)  [right of=h] {}; \node (i)  [right of=9] {};
     \node (10)  [right of=i] {};
    \node (t1) [above of= z1] {};
    \node (t2) [above of= t1] { };
    \node (t3) [above of= t2] { };
    \node (11) [below of=1] {[1]}; \node (12) [below of=2] {[1};  \node (1b) [below of=b] {,};
    \node (13) [below of=3] {2]}; \node (14) [below of=4] {[2};  \node (1d) [below of=d] {,};
    \node (15) [below of=5] {4};  \node (1e) [below of=e] {,};
    \node (16) [below of=6] {3]}; \node (17) [below of=7] {[3]}; \node (18) [below of=8] {[4};  \node (1h) [below of=h] {,};
    \node (19) [below of=9] {5]}; \node (20) [below of=10] {[5]};
  \begin{scope}\path (1)  edge  [red, skip loop =6mm, shorten >=3mm, shorten <=3mm] (2);
  \path (3)  edge  [red, skip loop =6mm, shorten >=3mm, shorten <=3mm] (4);
  \path (5)  edge  [red, skip loop =7mm, shorten >=3mm, shorten <=3mm] (8);
  \path (6)  edge  [red, skip loop =6mm, shorten >=3mm, shorten <=3mm] (7);
  \path (9)  edge  [red, skip loop =6mm, shorten >=3mm, shorten <=3mm] (10);
  \end{scope}
  \end{tikzpicture} \vspace{2mm}
  \end{center}
  
  \item[2 \& 3.] The same is done for , i.e. for the linking , only making sure tuples differing in exactly one position from the ones created when considering  do not occur (which in this case only occurs at leaf blocks  and ). We obtain the following:
  
  \begin{center} \vspace{-5mm}
  \begin{tikzpicture}
    [auto, node
    distance=5mm, skip loop/.style={to path={-- ++(0,#1) -| (\tikztotarget)}}] \tikzstyle{every node} = [text depth=-5pt,text height=0.5ex]
   \node (z1) { }; 
      \node (1) [right of=z1] {}; \node (a) [right of=1] {} ;
     \node (2) [right of=a] {}; \node (b) [right of=2] {} ;
     \node (3)  [right of=b] {}; \node (c)  [right of=3] {};
     \node (4)  [right of=c] {}; \node(d) [right of=4] {} ;
     \node (5) [right of=d] {}; \node (e) [right of=5] {} ;
     \node (6) [right of=e] {};  \node (f) [right of=6] {} ;
     \node (7)  [right of=f] {}; \node (g)  [right of=7] {};
     \node (8) [right of=g] {};  \node (h) [right of=8] {} ;
     \node (9)  [right of=h] {}; \node (i)  [right of=9] {};
     \node (10)  [right of=i] {};
    \node (t1) [above of= z1] {};
    \node (t2) [above of= t1] { };
    \node (t3) [above of= t2] { };
    \node (11) [below of=1] {[1]}; \node (12) [below of=2] {[6};  \node (1b) [below of=b] {,};
    \node (13) [below of=3] {1]}; \node (14) [below of=4] {[6};  \node (1d) [below of=d] {,};
    \node (15) [below of=5] {7};  \node (1e) [below of=e] {,};
    \node (16) [below of=6] {3]}; \node (17) [below of=7] {[3]}; \node (18) [below of=8] {[7};  \node (1h) [below of=h] {,};
    \node (19) [below of=9] {8]}; \node (20) [below of=10] {[8]};
  \begin{scope}\path (1)  edge  [blue, skip loop =6mm, shorten >=3mm, shorten <=3mm] (3);
  \path (2)  edge  [blue, skip loop =7mm, shorten >=3mm, shorten <=3mm] (4);
  \path (5)  edge  [blue, skip loop =7mm, shorten >=3mm, shorten <=3mm] (8);
  \path (6)  edge  [blue, skip loop =6mm, shorten >=3mm, shorten <=3mm] (7);
  \path (9)  edge  [blue, skip loop =6mm, shorten >=3mm, shorten <=3mm] (10);
  \end{scope}
  \end{tikzpicture} \vspace{5mm}
  \end{center}
\item[4.] Joining the two sets of tuples together, we get
  
  \begin{center} \vspace{5mm}
  \begin{tikzpicture}
    [auto, node
    distance=5mm, skip loop/.style={to path={-- ++(0,#1) -| (\tikztotarget)}}] \tikzstyle{every node} = [text depth=-5pt,text height=0.5ex]
   \node (z1) { }; 
      \node (1) [right of=z1] {}; \node (a) [right of=1] {} ;
     \node (2) [right of=a] {}; \node (b) [right of=2] {} ;
     \node (3)  [right of=b] {}; \node (c)  [right of=3] {};
     \node (4)  [right of=c] {}; \node(d) [right of=4] {} ;
     \node (5) [right of=d] {}; \node (e) [right of=5] {} ;
     \node (6) [right of=e] {};  \node (f) [right of=6] {} ;
     \node (7)  [right of=f] {}; \node (g)  [right of=7] {};
     \node (8) [right of=g] {};  \node (h) [right of=8] {} ;
     \node (9)  [right of=h] {}; \node (i)  [right of=9] {};
     \node (10)  [right of=i] {};
    \node (t1) [above of= z1] {};
    \node (t2) [above of= t1] {};
    \node (t3) [above of= t2] {};
    \node (11) [below of=1] {[1]}; \node (12) [below of=2] {[1};  \node (1b) [below of=b] {,};
    \node (13) [below of=3] {2]}; \node (14) [below of=4] {[2};  \node (1d) [below of=d] {,};
    \node (15) [below of=5] {4};  \node (1e) [below of=e] {,};
    \node (16) [below of=6] {3]}; \node (17) [below of=7] {[3]}; \node (18) [below of=8] {[4};  \node (1h) [below of=h] {,};
    \node (19) [below of=9] {5]}; \node (20) [below of=10] {[5]};
    \node (21) [below of=11] {[1]}; \node (22) [below of=12] {[6};  \node (2b) [below of=1b] {,};
    \node (23) [below of=13] {1]}; \node (24) [below of=14] {[6};  \node (2d) [below of=1d] {,};
    \node (25) [below of=15] {7};  \node (2e) [below of=1e] {,};
    \node (26) [below of=16] {3]}; \node (27) [below of=17] {[3]}; \node (28) [below of=18] {[7};  \node (2h) [below of=1h] {,};
    \node (29) [below of=19] {8]}; \node (30) [below of=20] {[8]};
  \begin{scope}\path (1)  edge  [red, skip loop =16mm,shorten >=13mm, shorten <=13mm] (2);
  \path (3)  edge  [red, skip loop =16mm,shorten >=13mm, shorten <=13mm] (4);
  \path (5)  edge  [red, skip loop =17mm,shorten >=13mm, shorten <=13mm] (8);
  \path (6)  edge  [red, skip loop =16mm,shorten >=13mm, shorten <=13mm] (7);
  \path (9)  edge  [red, skip loop =16mm,shorten >=13mm, shorten <=13mm] (10);
  \path (1)  edge  [blue, skip loop =11mm,shorten >=8mm, shorten <=8mm] (3);
  \path (2)  edge  [blue, skip loop =12mm,shorten >=8mm, shorten <=8mm] (4);
  \path (5)  edge  [blue, skip loop =12mm,shorten >=8mm, shorten <=8mm] (8);
  \path (6)  edge  [blue, skip loop =11mm,shorten >=8mm, shorten <=8mm] (7);
  \path (9)  edge  [blue, skip loop =11mm,shorten >=8mm, shorten <=8mm] (10);
  \path (1)  edge  [green, skip loop =6mm, shorten >=3mm, shorten <=3mm] (2);
  \path (3)  edge  [green, skip loop =6mm, shorten >=3mm, shorten <=3mm] (4);
  \path (5)  edge  [green, skip loop =7mm, shorten >=3mm, shorten <=3mm] (9);
  \path (6)  edge  [green, skip loop =6mm, shorten >=3mm, shorten <=3mm] (7);
  \path (8)  edge  [green, skip loop =6mm, shorten >=3mm, shorten <=3mm] (10);
  \end{scope}
  \end{tikzpicture} \vspace{5mm}
  \end{center}
  Therefore the tensors  can now be formed
  
  \end{enumerate}
  
\noindent  Composing the five partial permutations with the representation of  ends with a constant tensor.
  
  With similar equations it is easily shown that , and that . The components affected by the tensor representations of  and  are different from one another, meaning they do not interfere with one another. Similarly, the tensor representation for  and partial permutations reduce to the zero morphism, and therefore has no effect on any component. The permutations composed with the tensor representation for the sum of all the linkings is therefore found to be , which has two non-zero entries. This proves that the linking combination cannot be modelled in .
  
  \p It can also be seen that this lack of interference between different proof nets in the final result means that scalar multiples of the three linkings in question in the example can be summed together in a linear combination and the same concept of proof still holds. If we consider an \mll~transformation  in the underlying category of such a form, then composing  with the same five partial permutations for suitable  results in a tensor with two non-zero entries, with the fifth and eighth positions filled by the scalars multipled to  and  repectively. The exact values within the entries are irrelevant---it only matters that two are non-zero.
  
  \begin{lem} \label{UniqueAlgSepsAndAnnisClaim}
  Let  be an MDNF~transformation in a compact closed category  with finite biproducts modelling a linear combination of at least two distinct proof nets,  say, over the MDNF~formula modelled by  containing  blocks, the  of which is the last leaf. Letting  and  be the two primary inputs to Algorithm \ref{UniqueTupleAlg}, producing  partial permutations , we find that
  
  where  and  are the first and second values offered to leaf  in the algorithm, and  is the index  or , depending on the polarity of the literal denoted by leaf . Furthermore, for every ,
  
  \end{lem}
  \proof
  The tensor representation of a linking of a proof net is represented by a product of Kronecker deltas, where two indices are in the same delta if the literals to which they are associated are linked by an axiom link. As such, if two indices  and  associated with literals connected by an axiom link in  are forced to be given different values  and  say, then we know that  for appropriate index sets  and .
  
  \p The partial permutations, containing either one or two non-zero entries, can be multiplied together and the distribution law can be used to give a sum of  products of constant tensors ( being the number of blocks given partial permutations with two non-zero entries), with each index being given a number except . These  assignments of numbers are determined by the combinations of first and second tuples associated with the sets of indices for each block---Example \ref{UniqueExam} provides a good example of this.
  
  \p Of these combinations, only two are capable of being composed with a tensor representation of a set of axiom links to create a non-zero tensor: the one where all the constants are chosen to be from the top tuples of each block in the algorithm; and the one from all the bottom tuples. This is because the algorithm continuously uses new numbers when an arbitrary number must be selected (Step~3(b)), and so mixing up the top and bottom tuples leaves more than one number given to only one index, thus ensuring it cannot be part of an axiom link pairing without creating a zero tensor. An example of this argument in action can be seen in Example~\ref{UniqueExam} at the start of Step~4: we see that  of block~2 and  of block  only have one value  within the two of them together.
  
  \p For the tensor representation of , only the combination developed from the top tuples gives a non-zero tensor. The second tuples are defined so that two literals are only given the same number in their tuples if they share an axiom link in ; and since  and  are distinct, there must be at least one pair of literals joined by an axiom link in  which does not exist in , thus leading to a zero tensor. The one index from  which does not have a number assigned to it by a partial permutation is clearly , which is connected to the sole literal in a block other than  assigned the number  in the top tuple. The composition of  with the contsant tensors for relating to the top tuples from the  blocks which are not block  therefore reduces to a product of Kronecker deltas of the form  for various  and . Since  for all , this becomes simply ; and so it follows that  as desired.
  
  \p The argument for the representation of  is fundamentally identical, replacing the bottom tuples for the top tuples throughout the above paragraph. For every other  in the linear combination when composed any one of the  combinations mixing top and bottom tuples equates to zero for the same reasons as for  and  before. Each of them is also distinct from both  and  by definition, meaning that neither the combination of all the top tuples nor that of the bottom tuples induce constant tensors which compose with  to give a non-zero tensor due to the same principle as why the bottom tuples do not for . \qed
  
  We are now able to give the proof for a lemma proving the simplicity of the linear combinations of proof nets capable of being modelled in .
  
  \begin{prop} \label{UniqueLemma} Every MDNF transformation in 
    modelling a linear combination of proof nets is modelling a unique
    proof net with scalar~.
  \end{prop}
  \proof
    Let  be an MDNF formula, and consider
     for arbitrary , where
     is defined as in Section~\ref{SectionMDNFObjects}. Again,
    we use the criteria also given in Section~\ref{SectionMDNFObjects} that the
    tensor representation of an arrow  must satisfy in
    order to be found in~. Suppose that  is an MDNF
    transformation in  which models a linear combination of two or
    more proof nets. Then, for ,
     once again takes the tensorial form
    
    and we know that there are two bijections,  and
     say, corresponding to axiom link sets  and
     respectively, where . We use these two sets of axiom links in
    Algorithm~\ref{UniqueTupleAlg} to produce partial permutations
     for all of the blocks, and to fix the
    required size of the number  to prove the lemma.
  
    Let  and 
be the first and second tuple values associated with the last leaf
    (block ) from the algorithm. Then we find that for 
    
    where the index  equals  or 
    depending on whether the literal of leaf  is positive or
    negative.
    
    \p We have shown that there are at least two non-zero entries in \\
    , and so . The arrow
     does not
    therefore exist in
    , and so  is
    not an \mll\ transformation.
  
    \p From the above, we know that every \mll\ transformation in 
    models a scalar multiple of a cut-free proof net. Lemma~\ref{OnlyOneLemma} ensures that those scalar multiples with scalar not equal to  are not possible, and so we have proved the result. \qed
    
    \begin{thm} \label{MDNFFC} If\/  is a compact closed category
      with biproducts satisfying feeble full completeness, then 
      satisfies MDNF~full completeness.
    \end{thm}
    
    \subsection{Extending to \mll~Full Completeness} \label{SectionMLLExtend}
    
    The previous subsections contain results which combine to produce a full completeness result for \mll~transformations to target functors describing sequents in the multiplicative disjunctive normal form. Although a strong connection between any family of \mll~transformations and proof nets in \mll\ is advantageous, it is certainly no substitute for a `complete' \mll~full completeness theorem. One of the remarkable properties of the categories in which we are interested is that the earlier MDNF~full completeness proof can be extended using one lemma and a couple of supplementary algorithms so that it works for \emph{all} \mll~functors, giving the full completeness theorem originally proposed.
    
    \p As stated in Chapter~\ref{CatModels}, in every -autonomous category  there are natural
    transformations
    
    and these are canonically isomorphic to appropriate compositions of the associativity and symmetry isomorphisms  and  if  happens to be compact closed, making them bijections (no two distinct \mll~transformations compose with the same weak distributivity transformation to give the same result). The tensor representations of these natural isomorphisms are both described solely by Kronecker deltas as demonstrated in Section~\ref{SectionTransExtensors}. Due to the small diagrammatic argument on page~\pageref{DiNatsComposeStatement}, an \mll~transformation  in  may be composed with a sequence of natural transformations built from the weak distributivity transformations and the associativity and symmetry isomorphisms of  to
    produce an MDNF~transformation . Furthermore,  describes an \mll~transformation in  only if  does.
    
    \begin{prop} \label{MDNFtoMLLProp}
    Let  be an \mll~transformation in , and let  be a natural transformation built from the weak distributivity, associativity and symmetry natural transformations of . Then  does not exist \hugh{in}  if  does not.
    \end{prop}
    \proof
    The transformation  is in , and so we know that if  is dinatural in the glued category then so does , since both are well-defined in . The statement of the proposition is the contrapositive of this fact. \qed
    
    It is always possible to find a natural
    transformations which preserves the cyclicity of at least one
    modelled cyclic proof structure between \mll~transformations. As such it is also possible to find a composition of natural transformations which not only preserves the existence of a cyclic proof structure modelled but ensures at least one of these cycles never passes through a -vertex in its switching\footnote{In fact, if the cycle does not pass through a -vertex the cycle exists in all switchings of the proof structure}.
    
    \begin{algo} \label{MLLtoMDNFCycleAlg}
    Input: An \mll~transformation  describing a linear combination of proof structures over a common sequent with at least one structure breaking the acyclicity criterion. \\
    Output: An \mll~transformation  describing a linear combination of proof structures over a common sequent with at least one structure containing a switching cycle passing through no -vertices.
    \end{algo}
    \begin{enumerate}
    \item Select one of the proof structures associated with  which fails the acyclicity criterion. Choose a cycle of minimum length from one of its switchings. We let  and , and we name the cycle . Let , and whenever we refer to subformulae called ,  and , we name their lowest vertices as in a parse tree ,  and  respectively.
    
    \item Search for a position in  of the form  for some subformulae ,  and , the corresponding edge  of which is in the cycle .
    	\begin{enumerate}
    	\item If one should exist, and  passes through , then let
    	
    The functor  is defined to be the target functor of , which is the same as  except that the subformula  is replaced by . The cycle  passes through the same vertices as those in  in the identical sections of  and . If  contains the path , then the cycle  is completed by adding ; otherwise,  is used to connect the ends together. Increment  and restart Step 2.
    	\item If one should exist, but  passes through  instead, let
    	
    	 The functor  is defined similarly to before:  is replaced by . The cycle  passes through the same vertices as those in  in the identical sections of  and . If  contains , then the cycle  is completed by adding the path ; otherwise, . Increment  and restart Step 2.
    	\item If one does not exist, then move to Step 3.
    	\end{enumerate}
    	
    \item Search for a position in  of the form  for some subformulae ,  and , the corresponding edge  of which is in the cycle .
    	\begin{enumerate}
    	\item If one should exist, and  passes through , then let
    	
    The functor  is defined to be the target functor of , which is the same as  except that the subformula  is replaced by . The cycle  passes through the same vertices as those in  in the identical sections of  and . If  contains the path , then the cycle  is completed by adding ; otherwise,  is used to connect the ends together. Increment  and restart Step 2.
    	\item If one should exist, but  passes through  instead, let 
    	
    	The functor  is defined similarly to before:  is replaced by . The cycle  passes through the same vertices as those in  in the identical sections of  and . If  contains , then the cycle  is completed by adding the path ; otherwise, . Increment  and go back to Step 2.
    	\item If one does not exist, then define ,  and 
    	\end{enumerate}
    \end{enumerate}
    
\noindent     Intuitively it is simple to see why this algorithm works. Suppose, without loss of generality, that one of the scenarios expected for Step~2(a) unfolds (dual arguments can be given for each of the other four situations). We can think of the proof structure with the cycle  for some  taking the form of one of the left-hand diagrams in Figures~7.1 and~7.2 below.
    
    \begin{figure}[htbp] \label{DissociateFigure}
    \caption{The effect of Algorithm~\ref{MLLtoMDNFCycleAlg}}
    \label{setfig}
    \begin{center}
    \begin{tikzpicture}
          [node distance=.3cm and .5cm, box/.style={
    rectangle,minimum size=6mm, very thick, draw=#1!50!black!50,
    top color=#1!50!black!20, bottom color=#1!50!black!20}, 
    skip loop/.style={to path={-- ++(0,#1) -| (\tikztotarget)}}]
    \tikzstyle{myarrows}=[line width=3mm,draw=black,-triangle 45,postaction={draw, line width=5mm, shorten >=7mm, -}]
    \node (X1) [box=red,] {};
    \node (Y1) [box=blue, right=of X1] {};
    \node (Z1) [box=green, right=of Y1] {};
    \node (x1) [below=of X1] {};
    \node (y1) [below=of Y1] {};
    \node (z1) [below=of Z1] {};
    \node (p1) [below left=of z1, xshift=5mm] {};
    \node (t1) [below left=of p1, xshift=5mm] {};
    \node (W1) [right=of Z1] {};
    \node (W2) at (t1 -| W1) {};
    \node (W0) [above= 2mm of W1] {};
    \node (W3) [below= 2mm of W2] {};
    \node (tail) [below right=of z1, xshift=5mm, yshift=2mm] {};
    \node (head) [right= 20mm of tail] {};
    \node (X2) [box=red, right= 4cm of Z1] {};
    \node (Y2) [box=blue, right=of X2] {};
    \node (Z2) [box=green, right=of Y2] {};
    \node (x2) [below=of X2] {};
    \node (y2) [below=of Y2] {};
    \node (z2) [below=of Z2] {};
    \node (t2) [below right=of x2, xshift=-5mm] {};
    \node (p2) [below right=of t2, xshift=-5mm] {};
    \node (V1) [right=of Z2] {};
    \node (V2) at (p2 -| V1) {};
    \node (V0) [above= 2mm of V1] {};
    \node (V3) [below= 2mm of V2] {};
    \path (X1) edge [orange, very thick, skip loop=6mm] (Y1);
    \path (X1) edge [orange ](x1);
    \path (Y1) edge [orange] (y1);
    \path (Z1) edge  (z1);
    \path (x1) edge [orange] (t1);
    \path (y1) edge [orange] (p1);
    \path (z1) edge (p1);
    \path (p1) edge [orange] (t1);
    \path (X2) edge [orange, very thick, skip loop=6mm] (Y2);
    \path (X2) edge [orange] (x2);
    \path (Y2) edge [orange] (y2);
    \path (Z2) edge  (z2);
    \path (x2) edge [orange] (t2);
    \path (y2) edge [orange] (t2);
    \path (z2) edge  (p2);
    \path (p2) edge (t2);
    \draw [myarrows](tail)--(head);
    \end{tikzpicture}
    \end{center}
    \end{figure}
    
        \begin{figure}[htbp] \label{DissociateFigure2}
        \caption{The effect of Algorithm~\ref{MLLtoMDNFCycleAlg}}
        \label{setfig}
        \begin{center}
        \begin{tikzpicture}
              [node distance=.3cm and .5cm, box/.style={
        rectangle,minimum size=6mm, very thick, draw=#1!50!black!50,
        top color=#1!50!black!20, bottom color=#1!50!black!20}, 
        skip loop/.style={to path={-- ++(0,#1) -| (\tikztotarget)}}]
        \tikzstyle{myarrows}=[line width=3mm,draw=black,-triangle 45,postaction={draw, line width=5mm, shorten >=7mm, -}]
        \node (X1) [box=red,] {};
        \node (Y1) [box=blue, right=of X1] {};
        \node (Z1) [box=green, right=of Y1] {};
        \node (x1) [below=of X1] {};
        \node (y1) [below=of Y1] {};
        \node (z1) [below=of Z1] {};
        \node (p1) [below left=of z1, xshift=5mm] {};
        \node (t1) [below left=of p1, xshift=5mm] {};
        \node (W1) [right=of Z1] {};
        \node (W2) at (t1 -| W1) {};
        \node (W0) [above= 2mm of W1] {};
        \node (W3) [below= 2mm of W2] {};
        \node (tail) [below right=of z1, xshift=5mm, yshift=2mm] {};
        \node (head) [right= 20mm of tail] {};
        \node (X2) [box=red, right= 4cm of Z1] {};
        \node (Y2) [box=blue, right=of X2] {};
        \node (Z2) [box=green, right=of Y2] {};
        \node (x2) [below=of X2] {};
        \node (y2) [below=of Y2] {};
        \node (z2) [below=of Z2] {};
        \node (t2) [below right=of x2, xshift=-5mm] {};
        \node (p2) [below right=of t2, xshift=-5mm] {};
        \node (V1) [right=of Z2] {};
        \node (V2) at (p2 -| V1) {};
        \node (V0) [above= 2mm of V1] {};
        \node (V3) [below= 2mm of V2] {};
        \path (Y1) edge [orange, very thick, skip loop=6mm] (W1);
        \path (W0) edge [orange,very thick] (W3);
        \path (t1) edge [orange, very thick, skip loop=-6mm] (W2);
        \path (X1) edge (x1);
        \path (Y1) edge [orange] (y1);
        \path (Z1) edge  (z1);
        \path (x1) edge (t1);
        \path (y1) edge [orange] (p1);
        \path (z1) edge (p1);
        \path (p1) edge [orange] (t1);
        \path (Y2) edge [orange, very thick, skip loop=6mm] (V1);
        \path (V0) edge [orange,very thick] (V3);
        \path (p2) edge [orange, very thick, skip loop=-6mm] (V2);
        \path (X2) edge (x2);
        \path (Y2) edge [orange] (y2);
        \path (Z2) edge  (z2);
        \path (x2) edge (t2);
        \path (y2) edge [orange] (t2);
        \path (z2) edge  (p2);
        \path (p2) edge [orange] (t2);
        \draw [myarrows](tail)--(head);
        \end{tikzpicture}
        \end{center}
        \end{figure}
    
    \p The diagrams highlight the two possible key paths from  in  (which also happen to the the edges which still exist in one of the switchings causing the cycle).
    
    \begin{itemize}
    
    \item In the first situation the path is composed of the following: the switching path linking the subformulae  and , which may pass through any number of other subgraphs of a switching; the edge from  to the -vertex; the switch edge from the -vertex to ; and the edge between the - and -vertices denoting the synonymous connectives written explicitly in . It is trivially true that there must be a path from the literals connected to the highlighted axiom link through their respective subformulae  and  to  and .
    
    \p The natural transformation  converts that proof structure from Figure~7.1 and the cycle described within it to the one to its right. The weak distributivity transformation does not affect which literals are connected to one another via an axiom link, and also does not affect any subformulae of  except . The only change is a `shuffling' of the - and -vertices in the primary subformula being considered. The cycle itself can be thought of as having been reduced by the algorithm so it contains all the same vertices except possibly for the -vertex, which may have been removed.
    
    \item In the second scenario we have a slightly longer path: the switching path linking the lowest -vertex in the subgraph back to  at the top, which may pass through any number of axiom links; the switch edge from the -vertex to ; and the edge between the - and -vertices denoting the synonymous connectives written explicitly in .
    
    \p The natural transformation  converts the left proof structure of Figure~7.2 to the one on its right, with the cycle highlighted in the second diagram still existing. In this situation the length of the cycle has not been reduced, but a -vertex has effectively been moved further up the proof structure, which creates new possibilities for scenarios such as that seen in the previous point to be found. 
    
    \end{itemize}
    
\noindent    The lowest vertices in a cycle in the switching of a proof structure must be -vertices, with the cycle flowing through both of its argument edges. Whenever we meet such a situation as seen in the first case, the length of the cycle is reduced by one: a -vertex is removed. In the second case the length of the cycle is not changed, but the alteration in the form of the cycle in effect pushes the -vertex further down the structure until it inevitably meets a -vertex of maximal depth, at which point the vertex is removed.
    
    \p Since the other four steps 2(b), 3(a) and 3(b) of Algorithm~\ref{MLLtoMDNFCycleAlg} are identical in concept to Step~2(a) they also steadily remove these vertices. Since the algorithm stops once there are no -vertices in the cycle, and eventually in the worst case all -vertices will find themselves under the -vertices, this principle assures termination.
    
    \p It is also always possible to produce an MDNF~transformation from an \mll\ transformation using an algorithm such as the one below.
    
    \begin{algo} \label{MDNFAlg}
    Input: An \mll~transformation  describing a linear combination of proof structures over a common sequent. \\
    Output: An MDNF~transformation  describing a linear combination of proof structures over a common sequent.
    
    \p An algorithm which takes an MLL transformation describing a linear combination of proof structures over a common sequent, and produces another MLL transformation representing a linear combination of proof structures, only over an MDNF~sequent. The new sequent will preserve the number of tensor and par operators within the formulae.
    \end{algo}
    \begin{enumerate}
    \item Let  and . Let , and whenever we refer to subformulae called ,  and , we name their lowest vertices as in a parse tree ,  and  respectively.
    
    \item Search for any position in  of the form  for some subformulae ,  and .
    	\begin{enumerate}
    	\item If one should exist, then let . The functor  is defined to be the target functor of . Increment  and go back to Step 2.
    	\item If one does not exist, then move to Step 3.
    	\end{enumerate}
    	
    \item Search for any position in  of the form  for some subformulae ,  and .
    	\begin{enumerate}
    	\item If one should exist, then let . The functor  is defined to be the target functor of . Increment  and go back to Step 2.
    	\item If one does not exist, then let ,  and .
    	\end{enumerate}
    \end{enumerate}
    
\noindent    Algorithm \ref{MDNFAlg} is far simpler than Algorithm~\ref{MLLtoMDNFCycleAlg}, because there is no need to consider the preservation of anything: we are merely composing an \mll~transformation with a number of natural transformations which lead to the creation of an MDNF~transformation. However, it is useful to make the following observation.
    
    \begin{obs}
    Let  be an \mll~transformation modelling a linear combination of proof structures over a sequent, at least one of which fails the acyclicity criterion. Then applying Algorithms~\ref{MLLtoMDNFCycleAlg} and~\ref{MDNFAlg} in that order produces an MDNF~transformation  modelling a linear combination of proof structures, with at least one being cyclic.
    \end{obs}
    
    It is now possible to prove \mll~full completeness for .
    
    \begin{thm}\label{fcomp}
      If\/  is a compact closed category with finite biproducts
      satisfying feeble full completeness then\/  satisfies \mll~full completeness.
    \end{thm}
    \proof
      Let  be an \mll~transformation in  modelling a linear
      combination of proof structures, at least one of which is cyclic.
      Using Algorithms \ref{MLLtoMDNFCycleAlg} and \ref{MDNFAlg}, we obtain a family of arrows  modelling a linear combination of MDNF~proof
      structures, with at least one of these containing a switching
      cycle. By Proposition~\ref{MDNFFC},  is not an
      MDNF~transformation in ; and therefore it immediately follows
     from Proposition~\ref{MDNFtoMLLProp} that  is not either.
    
      \p If we instead assume that  models a linear combination of acyclic yet disconnected \mll~proof structures, Algorithm \ref{MDNFAlg} produces an MDNF~transformation  when introduced to , and this new transformation is also a linear combination of \hughf{acyclic, disconnected} proof structures. Proposition~\ref{MDNFFC} once again allows us to say that ---and consequently ---does not exist in . The same principle can be used for the case where  is a non-simple linear combination of proof nets, and so no \mll~transformations not representing a unique proof net is found in . \qed
    
    We can in fact improve on the theorem above greatly with near enough no effort by making a simple observation. For any choice of category , the only objects used in the lemmata in this section are in the sets  and ; and all of these are found in the collection of objects for any orthagonality category  with focus . The values and covalues of a -object  also describe the set of morphisms between the category's tensor unit  and  and between  and  respectively (Fact~\ref{CoValueArrowProp}). Because of this, the arguments from previous chapters and earlier in this chapter using the properties of the values and covalues may be replicated verbatim to give an \mll~full completeness theorem for all categories of this more restricted form.
    
    \begin{thm}
      If\/  is a compact closed category with finite biproducts
      satisfying feeble full completeness then\/  satisfies
      \mll~full completeness for any .
    \end{thm}
    
    \begin{cor}
      For a tensor-generated compact closed category with
      biproducts\/  the category\/  satisfies\/ \mll\ full completeness.
    \end{cor}
    
    Note that biproducts are necessary for this result despite the
      fact that we are not addressing the additive connectives here.
      Indeed, it is very easy to produce a (tensor-generated) compact
      closed category without biproducts which does not create a fully
      complete model under the double glueing construction (the full
      subcategory of~ containing only the tensor unit  for
      example).
    
    \section{\mllmix~Full Completeness for } \label{SectionMLLMixFC}
    
    The theorem given in the previous section has the effect of generalising the primary results found in first four chapters of \cite{Tan97}, which concern the categories  and  for arbitrary field  of characteristic . However, the manner in which Tan proves her theorem for  actually has a positive side effect that the proof above is unable to replicate. The lemmata proving acyclicity and uniqueness are not stated with an assumption of an already derived connectedness lemma; and the objects used in the proofs of the acyclicity and uniqueness are found in the collection of objects in the orthogonality subcategory  with focus the singleton  for , which is defined earlier in Section~\ref{SectionTransExtensors}. The category  is known to be a categorical model of \mllmix, and every dinatural transformation in  is inherited from . All these facts together allow us to conclude the following:
    
    \begin{fact}\hugh{\cite{Tan97}}
    The category  satisfies \mllmix~full completeness\footnote{The category in question was actually named  in \cite{Tan97}.}.
    \end{fact}
    
    This result can in fact also be generalised, though not the same extent as that seen in Section~\ref{SectionGCFC}. In this section we demonstrate that the category  satisfies \mllmix~full completeness if  is, like , a \emph{zero-sum-free} compact closed category with biproducts.
    \hugh{\begin{defi}
    A semiring  is \emph{zero-sum-free} if its additive unit  is its sole element with an additive inverse. A compact closed category with finite biproducts is \emph{zero-sum-free} if it is enriched over a category  for which the  is zero-sum-free.
    \end{defi}}
    
     Though the use of counterexample test objects to show certain \mll~transformations found in  cannot be seen in the glued category is still abundantly present, the flavour of the coming proof resembles the deduction of Tan more closely than the earlier proofs:
     \begin{enumerate}[label=(\autoref{SubsectionMixUnique})]
     \item[(\autoref{SubsectionMixUnique})] We start by showing that the \mll~transformations which are found in both  and  must model simple linear combinations of proof structures. This is done by using reducing the problem to one for \mll~functors built using no tensor functors (Proposition~\ref{MDNFMixToMLLProp}). By necessity the proof of uniqueness (Proposition~\ref{MixUniqueLemma}) takes a slightly less combinatorial shape than before and has a more algebraic feel, with its basis being simultaneous equations.
     \item[(\autoref{SubsectionMixAcyclic})] This is followed by the proof that the proof structures being modelled must also be acyclic and therefore correct with respect to the Danos-Regnier \mllmix~proof net criterion. Algorithm~\ref{MixCycleAlg} reduces the target to the most simple standard form, leaving a comparartively simple argument for Proposition~\ref{MixAcyclicLemma}. The theorem immediately follows.
     \end{enumerate}
     In spite of the small change in proof style, the index notation for values and covalues of the objects of the form  that has been employed greatly in this chapter continues to be utilised ubiquitously.
    
    \subsection{Uniqueness} \label{SubsectionMixUnique}
    
    In this full subcategory of  in which we now reside, we have restrictions on the sets of values and covalues which we may choose for our test objects to prove certain transformations from the underlying category do not become transformations in our new location. Every value must compose with every covalue to produce the morphism  and vice versa. This is remarkably restrictive, primarily because it becomes harder to find valid test objects which are self-dual and still useful, such as the objects  and  described in Section \ref{SectionMDNFObjects} in . However, this is counterbalanced by the fact that categorical models of \mllmix\ are equipped with the `Mix' natural transformation , which permits great simplifications to the set of \mll~formulae which must be considered to produce the desired results. The proof of the simplicity of all linear combinations of proof structures modelled in  demonstrates both these changes to the playing field in the clearest manner.
    
    \p Proposition~\ref{MDNFtoMLLProp} in the previous section allowed us to simplify the entire of the \mll~full completeness proof of  to one for MDNF~full completeness. Now using the mix natural transformation, we can produce a more extreme version of this proposition whose proof follows from an identical concept, which is possible due to  being an isomorphism in compact closed categories.
    \begin{prop} \label{MDNFMixToMLLProp}
    Let  be an \mll~transformation in , and let  be a natural transformation built from the `Mix', weak distributivity, associativity and symmetry natural transformations of . Then  does not translate into  if  does not.
    \end{prop}
    
    For the uniqueness proof the actual connectives that are in each formula being modelled become irrelevant---only the number of linkings is important. Because of this, a natural transformation eradicating all uses of the tensor product `', leaving a formula of the form , is a reasonable suggestion for  in the above proposition.
    
    \begin{cor} \label{AllParToMLLProp}
    Every \mllmix~transformation in  models a single proof structure if and only if every \mllmix~transformation to a functor leading to objects of the form  for some  does.
    \end{cor}
    
    We now follow the same procedure of choosing a single family of objects in , , where  for each , so that the set of values of the object  does not contain the tensor representation of an \mll~transformation modelling a non-simple linear combination of axiom links. We define each of the  as follows:
    
    where  is the tensor with entries equalling  for all . The values and covalues of  can be found from this definition for any  easily.
    
    \begin{lem} \label{ClaimMixObjectProperties}
    For each ,
    \begin{itemize}
    \item  \\ 
    \item 
    \end{itemize}
    \end{lem}
    \proof
    We follow a similar argument to that seen in Lemma~\ref{ClaimTensorPowers}, which is based around induction. We start by considering the covalues. The proof that the covalues of  is near enough trivial.
    
    It now takes minimal effort to show that the result desired is true for
    
    whilst assuming the claim is true for  for all .
    
    
    Now we deal with the values of these object amalgamations. The base case shows us that the values of  are the permutations over .
    
    The inductive case follows.
    \smallskip
    
\noindent    Having access to the form of the values of  for each value of  and  makes it simple enough to prove uniqueness for  as wished.
    
    \begin{prop} \label{MixUniqueLemma}
    Every \mll~transformation in  for zero-sum-free  models a unique proof structure.
    \end{prop}
    \proof
    We show that transformations are as desired for the \mll~functor ; Corollary \ref{AllParToMLLProp} forces the result to work for all \mll~functors.  At this point we notice that  utilised primarily in Section \ref{SectionZeroTransProof} is actually , and so is an object in . We can therefore use Lemma~\ref{OnlyOneLemma} to say that the sum of every scalar involved in a linear combination of proof structures modelled in the category totals .
    
    \p The formula  is equal to , meaning only one valid set of axiom links can be placed on its formula, namely the linking containing only one axiom link connecting the only two literals. Since every \mll~transformation in the category must model a linear combination of proof structures, this means that a transformation to  has to model a scalar multiple of this one axiom link, and therefore have a tensor representation  for some . Lemma~\ref{ClaimMixObjectProperties} tells us that  for all , which only contains  if . The conclusion of this is that non-identity scalar multiples of the axiom link are not modelled by a transformation in the glued category.
    
    \p Now we consider the more general case of when . It is possible to follow the argument through for any , so for the sake of simplicity we take . Lemma~\ref{ClaimMixObjectProperties} states that the tensors in  are those which create full permutations when any  of the  --index pairs are composed with matrices of the form  for each . This leads to many tensor equations, but due to the symmetry and addition properties noted in Section~\ref{SectionTransExtensors} we may choose to restrict the equations somewhat without loss of generality. We only consider equations for which each  composing with the value tensors are such that . This leaves  simultaneous equations to be solved over the semiring : for each  there must be a vector of values  such that
    
    Again simplifying using the ideas from Section~\ref{SectionTransExtensors}, we can look solely at the entries where the one remaining -indexed position, the  position, also considered at~. This means that the only entries of  which are now of interest are of the form , where each  is a permutation and  a corresponding scalar. Entries where the -indices do not form a permutation of  are therefore always zero.
    
    \p For some set of ,
    
    This leads to  linear equations of consequence, all bar  of which being sums which have to equal . In the context of a zero-sum-free semiring, as  is from our original assumption, each of the values in the sums of these  equations must equal .
    
    Let  be the function which describes the vector , i.e. for every , . Focusing on an arbitrary , we find that
    
    Therefore, by zero-sum-freeness, for every permutation  whenever ,
    
    
    By symmetry, we find that for all ,  unless  for all , which forces us to conclude that
    
    for some .
    
    \p By the form of , we already know then that  must form a permutation, and that
    
    The sum of the scalars must be unity, so ; and so the arrow which  describes is an instantiation of an \mll~transformation which represents a unique proof structure. \qed
    












    The proof above can be elucidated somewhat through the use of an example.
    
    \begin{exa} \label{MixUniqueExam}
    We view the proof of Lemma~\ref{MixUniqueLemma} for the \mll~formula  in more detail.
    \end{exa}
    We assume that  is the tensor representation of a linear combination of linkings on the formula modelled by . Lemma~\ref{ClaimMixObjectProperties} is provides us with the three tensor equations which must be satisfied for some numbers ,  and  found in .
    
    
\noindent     Suppose that  for each , making each constant distinct from one another and the function  proposed in the proof of the earlier lemma a permutation. This creates  equations:
    
    Since we are in a zero-sum-free compact closed category, we know that all the values in the sums equalling  must come to zero themselves. That means we can conclude from looking at equations (2), (3), (4), (6), (7) and (8) that
    
    Substituting these assignments into the  equations leaves the six sums totalling zero as trivial, and equations (1), (5) and (9) simplify to become
    
    Note that the choices of ,  and  coincide with the order of the three superscript index numbers of . This is to be expected, since the  makes it necessary for the  superscript index position to be  in order to for it to be in the equation for which the other  -indices are changed in are added together and equate to~. As such, the given position is the only one which fits this criteria for all .
    
    Due to  being a linear combination of Kronecker deltas representing axiom links between positive and negative literals, the only \mll~transformation which can be said to satisfy the criteria given here is the one modelling the unique proof structure given below.
    
    \begin{center} \vspace{5mm}
        \begin{tikzpicture}
          [auto, node
          distance=5mm, skip loop/.style={to path={-- ++(0,#1) -| (\tikztotarget)}}] \tikzstyle{every node} = [text depth=-5pt,text height=0.5ex]
           \node (1) {}; \node (a) [right of=1] {} ;
          \node (2) [right of=a] {}; \node (b) [right of=2] {} ;
          \node (3)  [right of=b] {}; \node (c)  [right of=3] {};
          \node (4)  [right of=c] {}; \node (d) [right of=4] {} ;
          \node (5) [right of=d] {}; \node (e) [right of=5] {} ;
          \node (6) [right of=e] {};
        \begin{scope}\path   (1)  edge [skip loop =6mm, shorten >=3mm, shorten <=3mm]  (2);
        \path   (3)  edge [skip loop =6mm, shorten >=3mm, shorten <=3mm]  (4);
        \path   (5)  edge [skip loop =6mm, shorten >=3mm, shorten <=3mm]  (6);
        \end{scope}
        \end{tikzpicture} \vspace{5mm}
    \end{center}
    Symmetry in permutations allows us to ascertain that all the possible linkings are possible by changing the permutation that  describes to each of the other , but no non-simple linear combinations have been shown to be possible.
    
    \p Now, we choose values of  so that the induced function  is not a permutation. Let us first consider  for all ; these induce the following linear equations:
    
    Earlier it is explained why the only position of  that can be non-zero is the one where . Bearing this in mind, we can expect no valuations of the entries of interest satisfy the above equations. Hypothetically, only  would be allowed to be non-zero; but by the constraints set upon it it is  by definition. By similar arguments, no tensor representation of an \mll~transformation  satisfies the equations when two or more of  are equal.
    
    \p For a tensor representation of an \mll~transformation to be in the values, it must satisfy the  equations for at least one of the combinations of values ,  and  can take. From the evidence above we know that such an  can only do that if only one tuple  provides a non-zero value for , and that position must equal zero. The only conclusion is, therefore, that  for some permutation  over . That is, no non-simple linear combinations of proof structures are modelled by a tensor in .
    
    \subsection{Acyclicity} \label{SubsectionMixAcyclic}
    
    Now that is has been established that  only contains \mll~transformations modelling unique proof structures, we can now attempt to show that those proof structures modelled are also acyclic. Once this has been shown, we will have proved \mllmix~full completeness: the connectedness condition of the Danos-Regnier criteria is rendered redundant once the `Mix' rule has been installed in the logic.
    
    \p Simplifying the problem down to dealing solely with the \mll~transformations  for different values of  is not an option here. If we wish to prove that a cyclic structure cannot be modelled in the glued category, we need to make sure that any natural transformations do not create a transformation modelling an acyclic structure. As such, at least one of the -vertices must be preserved. However, ignoring the existence of  would be a waste of the available attributes of the category.
    
    \p The methods utilised in Section \ref{SectionGCFC} to allow us to only consider the easier-to-handle MDNF~transformations are once again of use here. There is an algorithm given below which takes MDNF~transformations modelling unique cyclic proof structures and produces other MDNF~transformations modelling a formula containing the minimum number of \linebreak -vertices possible whilst preserving exactly one cycle.
    
    \begin{algo} \label{MixCycleAlg}
    Input: An MDNF~transformation  describing a unique proof structure, with  blocks say, breaking the acyclicity criterion. \\
    Output: An MDNF~transformation  built by composing  with natural transformations which describes a unique proof structure still breaking the acyclicity criterion with the minimum number of -vertices within it.
    \end{algo}
    \begin{enumerate}
    \item Choose a cycle from the proof structure described by  passing through the minimum number of axiom links. We let , ,  , and we name the cycle  (referring only to the literals). For every ,  is the target functor of 
    \item Search for the block furthest to the left in the formula modelled with literals within , calling it block . Let  be a composition of the associativity and symmetry isomorphisms for the monoidal bifunctor  which modifies the block so it takes the form , where  and  are the positions signifying the literals in  and  is a tensor product containing the rest of the literals. Define , where  is the  block. If  and  are connected via an axiom link go to Step~4; otherwise go to Step~3.
    \item Increment . Search for the block (which we name block ) which contains the literal, , connected to literal  via an axiom link. Let  be a composition of associativity and symmetry isomorphisms which modifies the block so it takes the form , where  is the other literal position in the block which is in . Define . If  is connected via an axiom link to  then go to Step~4; otherwise repeat Step~3.
    \item Consider block ,  where  and  are the functors representing the first and second literal positions. We set the natural transformation  the maximal composition of `mix' transformations on an \mll~functor  which eradicates all instances of  and replaces them with  whilst maintaining the order and bracketing of the inputs of the functor.
    	\begin{enumerate}
    	\item If it does not contain a literal in , then let .
    	\item If it does, then let 
    	\end{enumerate}
    If , then increment the number, and repeat Step~4. Otherwise let \linebreak , increment  and go to Step~5.
    \item Let  be a natural isomorphism built using the associativity and symmetry isomorphisms corresponding to the bifunctor  so that all the blocks in the proof structure described by  containing only one literal are to the left of all those containing two literals, and the two-literal blocks maintain the same order with respect to each other as found in . We let , and terminate the algorithm.
    \end{enumerate}
    
\noindent    The algorithm above certainly terminates---after all, each step changing an \mll~transformation can only deal with a finite set of finite blocks. Equally, the output dinatural transformation does indeed describe a cyclic proof structure: in every switching there is a cycle , and the -vertices in the cycle are the only ones which appear in the structure. Together with Algorithms \ref{MLLtoMDNFCycleAlg} and \ref{MDNFAlg}, we can find natural transformations from  which continue to exist in  which take any \mll~transformation describing a unique cyclic proof structure in  and create another one which models a proof structure with shape much like the proof structure given below.
    
    \begin{center} \label{MixCycleFigure} \vspace{5mm}
    \begin{tikzpicture}
      [auto, node
      distance=5mm, skip loop/.style={to path={-- ++(0,#1) -| (\tikztotarget)}}] \tikzstyle{every node} = [text depth=-5pt,text height=0.5ex]
       \node (1) {}; \node (a) [right of=1] {} ;
      \node (2) [right of=a] {}; \node (b) [right of=2] {} ;
      \node (3)  [right of=b] {}; \node (c)  [right of=3] {};
      \node (4)  [right of=c] {}; \node (d) [right of=4] {} ;
      \node (5) [right of=d] {}; \node (e) [right of=5] {} ;
      \node (6) [right of=e] {}; \node (f) [right of=6] {} ;
      \node (7) [right of=f] {}; \node (g) [right of=7] {} ;
      \node (8)  [right of=g] {}; \node (h)  [right of=8] {};
      \node (9)  [right of=h] {}; \node (i) [right of=9] {} ;
      \node (10) [right of=i] {};
    \begin{scope}\path   (1)  edge [skip loop =6mm, shorten >=3mm, shorten <=3mm]  (2);
    \path   (4)  edge [skip loop =6mm, shorten >=3mm, shorten <=3mm]  (5);
    \path   (6)  edge [skip loop =7mm, shorten >=3mm, shorten <=3mm]  (10);
    \path   (7)  edge [dashed, skip loop =5mm, shorten >=3mm, shorten <=3mm]  (9);
    \end{scope}
    \end{tikzpicture} \vspace{5mm}
    \end{center}
    
\noindent    This is a very regular form of \mll~formula being modelled. The formulae can be separated into two distinct parts. If we instantiate the functor with tuples containing the same self-dual object built over a -object  for some  in every entry,  say, we can say the tensor representations of the values and covalues in the resulting object take the form  for the MDNF~functors  and  for some , , where
    
    
    As has been the standard throughout this chapter, a single test object is required for all inputs of the total resulting \mll~transformation to show that acyclic proof structures are not modelled in . An object which is sufficient for the task whilst remaining in the confines of  is
    
    
    The values and covalues of objects , where the -dimensional tuple is  and  is the target functor of an MDNF~transformation which is an output of Algorithm~\ref{MixCycleAlg} can be found easily by using inductive methods, as seen in the claim below.
    
    \begin{lem} \label{GammaDeltaClaim}
    For every , , where
    
    Similarly, .
    \end{lem}
    \proof
    The object , and so we show that  has the form of  is as seen above, only with  replaced by , starting with .
    
    The inductive case is proved as follows:
    
    
\enlargethispage{\baselineskip}
\noindent    The result is exactly as desired, and so the claim concerning  is solved by corollary. We now move to demonstrate  takes the form wanted. We can conclude the following due to the functor  being the de Morgan dual of the functor :
    
    The final result immediately follows. \qed
    
    Proposition~\ref{MDNFMixToMLLProp}, in collaboration with Algorithms~\ref{MLLtoMDNFCycleAlg} and \ref{MixCycleAlg}, means the following statement is true: if we can show that \mll~transformations in the form seen in the above figure are not capable of existing in , then no cyclic proof structures may be modelled in the category  under the orthogonalised glueing.
    
    \begin{prop} \label{MixAcyclicLemma}
    Every \mll~transformation in  modelling a unique proof structure models an acyclic proof structure.
    \end{prop}
    \proof
    Due to the earlier discussion it is only necessary to consider \mll~transformations of the shape seen in Figure~\ref{MixCycleFigure} due to Algorithms~\ref{MLLtoMDNFCycleAlg} and \ref{MixCycleAlg} and Proposition~\ref{MDNFMixToMLLProp}. Suppose that  be such a functor, with  containing all the one-literal blocks and  all the two-literal blocks. We use the test object , meaning that we are able to use the calculations given in Lemma~\ref{GammaDeltaClaim} to find the values of  for some , .
    
    \p Suppose that  is a functor describing a subformula containing no literals, making  for a positive integer . The values of this object are therefore exactly as seen in Lemma~\ref{GammaDeltaClaim}. To simplify matters, instead of making - and -indices correspond to positive and negative literal positions respectively as earlier, the indices  and  now relate to the first and second literals in the  block in  for all . We can therefore assume that the proof structure being discussed, which we say has linking , has tensor representation .
    
    \p For , the situation is clear: , which clearly does not contain  as required for the cyclic proof structure to be modelled. For larger , we need to use covalues from .
    
    For every block , we use , which indeed does belong to the set of covalues. We find that
    
    The tensor  does not equal , and so it does not belong to the set of values for . As such,  does not satisfy the criteria expected of all elements of the set of values for the object . Because of this, the MDNF~transformation to  does not lift to .
    
    \p We extend this result so that it works for an non-empty . In this scenario we expect  for positive  and , and by standard tensor calculations we note that, when  and  act as superindices for the positive and negative literals respectively,
    
    
    Lemma~\ref{GammaDeltaClaim} tells us that there is only covalue for , namely . The tensor representation of the transformation is
    
    Composing the two tensors presented above together, we find
    
    
    We know from the base case when  that the tensor to which the composition reduces is not found in the set of values for , irrespective of the size of . We therefore conclude that  is not found in the values of ; and so its corresponding MDNF~transformation from  does not lift into . \qed
    
    \begin{thm}\label{mixfcomp}
    Let  be a zero-sum-free compact closed category with finite biproducts satisfying feeble full completeness. Then the category  satisfies \mllmix~full completeness.
    \end{thm}
    
    \subsection{The Necessity of Zero-Sum-Freeness}
    
    The satisfaction of full completeness for the logic \mllmix\ by degenerate categorical models under the orthogonalised glueing construction with focus  is quite a strong result, but the form of the scalars required for the proof to operate is an unfortunate stumbling block. The proof given earlier in this section is designed to show that a compact closed category with finite biproducts satisfying feeble full completeness creates a full complete model of \mllmix\ when the `'-glueing is used if the homset  acts as a zero-sum-free semiring.
    
    \p We now make clear the insurmountable hurdle which stops Tan's method from being further generalised. Lemma~\ref{MixUniqueLemma} is insufficient for compact closed categories enriched over semimodules over semirings containing even a single additive inverse. This is confirmed by the algorithm below.

    \begin{exa}
    We view the limitations of the proof of Lemma~\ref{MixUniqueLemma} by viewing the \mll~formula  in more detail.
    \end{exa}
    
    Suppose that , and let  be the linear combination of the following sets of axiom links.
    \begin{center} \vspace{1mm}
    \begin{tikzpicture}
      [auto, node
      distance=5mm, skip loop/.style={to path={-- ++(0,#1) -| (\tikztotarget)}}] \tikzstyle{every node} = [text depth=-5pt,text height=0.5ex]
     \node (z1) { }; \node (z2) [right of=z1] {}; 
        \node (1) [right of=z2] {}; \node (a) [right of=1] {} ;
       \node (2) [right of=a] {}; \node (b) [right of=2] {} ;
       \node (3)  [right of=b] {}; \node (c)  [right of=3] {};
       \node (4)  [right of=c] {}; \node(d) [right of=4] {} ;
       \node (5) [right of=d] {}; \node (e) [right of=5] {} ;
       \node (6) [right of=e] {}; 
      \node (t1) [above of= z1] {};
      \node (t2) [above of= t1] {};
      \node (t3) [above of= t2] {};
      \node (s1) [below of= z1] {};
      \node (s2) [below of= s1] {};
      \node (s3) [below of= s2] {};
      \node (T1) [above of= z2] {};
      \node (T2) [above of= T1] {};
      \node (T3) [above of= T2] {};
      \node (S1) [below of= z2] {};
      \node (S2) [below of= S1] {};
      \node (S3) [below of= S2] {};
    \begin{scope}\path (1)  edge  [red, skip loop =16mm,shorten >=13mm, shorten <=13mm] (2);
    \path (3)  edge  [red, skip loop =16mm,shorten >=13mm, shorten <=13mm] (4);
    \path (5)  edge  [red, skip loop =16mm,shorten >=13mm, shorten <=13mm] (6);
    \path (1)  edge  [blue, skip loop =11mm,shorten >=8mm, shorten <=8mm] (2);
    \path (3)  edge  [blue, skip loop =12mm,shorten >=8mm, shorten <=8mm] (6);
    \path (4)  edge  [blue, skip loop =11mm,shorten >=8mm, shorten <=8mm] (5);
    \path (1)  edge  [green, skip loop =7mm, shorten >=3mm, shorten <=3mm] (6);
    \path (2)  edge  [green, skip loop =6mm, shorten >=3mm, shorten <=3mm] (5);
    \path (3)  edge  [green, skip loop =6mm, shorten >=3mm, shorten <=3mm] (4);
    \path (1)  edge  [magenta, skip loop =-7mm, shorten >=3mm, shorten <=3mm] (4);
    \path (2)  edge  [magenta, skip loop =-6mm, shorten >=3mm, shorten <=3mm] (3);
    \path (5)  edge  [magenta, skip loop =-5mm, shorten >=3mm, shorten <=3mm] (6);
    \path (1)  edge  [orange, skip loop =-12mm,shorten >=8mm, shorten <=8mm] (4);
    \path (3)  edge  [orange, skip loop =-10mm,shorten >=8mm, shorten <=8mm] (6);
    \path (5)  edge  [orange, skip loop =-11mm,shorten >=8mm, shorten <=8mm] (2);
    \path (1)  edge  [gray, skip loop =-16mm,shorten >=13mm, shorten <=13mm] (6);
    \path (3)  edge  [gray, skip loop =-15mm,shorten >=13mm, shorten <=13mm] (2);
    \path (5)  edge  [gray, skip loop =-15mm,shorten >=13mm, shorten <=13mm] (4);
    \end{scope}
    \end{tikzpicture} \vspace{1mm}
    \end{center}
    
    Letting  and  denoting the symmetric and alternating groups of  elements respectively, the tensor representation of the \mll~transformation is written \vspace{2mm}
    
   where the scalars in the set  are as follows: \vspace{2mm}
     \vspace{2mm}
    Note that this means the following essential entries have the following values within them:
    \begin{itemize}
    \item ;
    \item ;
    \item .
    \end{itemize}
    \vspace{2mm}
    
    We remind ourselves that there are three tensor equations which must be satisfied for some ,  and  found in :
    \vspace{1mm}
    
  Taking the non-trivial situation from Example~\ref{MixUniqueExam}, where  for each , the significant equations may be found.
    
    It is now seen that these equations are consistent with the entries of  from earlier, and so it is deduced that . As stated in Lemma~\ref{MixUniqueLemma}, other simultaneous equations using other entry positions in the tensor  reduce to linear combinations of those found above using the rules from Section~\ref{SectionTransExtensors}. Furthermore, other choices of  for the test object  do not provide any more information when it comes to producing equations which contradict the existence of a tensor representation of  in the set of values of . It follows that the proof, or any obvious minor alterations to it, is unable to be used to disprove that  describes a transformation in the double-glued category.
    
    \p It comes as no surprise that there is more than one solution once negatives are added, especially when the values in the entries are in the genuine ring, once it is realised that there are  variables and the maximal linearly independent set of equations has  elements. Having fewer linear independent equations than variables within them means that the kernel of the equations has positive dimension, and so a myriad of solutions may be found.
    
    The problem becomes more apparent for formulae  the larger  becomes. As stated in the proof of Lemma~\ref{MixUniqueLemma}, the number of variable positions uniquely describing an \mll~transformation's tensor representation is , whilst the number of equations which may be considered linearly independent from one another even in the absence of negative elements is ; and clearly  for every .
    
    \p Of course this does not prove that non-zero-sum-free compact closed categories are incapable of being the basis of fully complete \mllmix\ models. After all, only one test object has been considered; \emph{all} objects in the focused glued category must be shown to still contain the morphisms associated to a rogue \mll~transformation from  to show that it remains a one in the glued category. Fortunately, it is possible to extend the principle from the above example to a result on the level of \mll~transformations for all the non-zero-sum-free categories.
    
    \begin{prop} \label{NoMLLMixFCforBadGiCLemma}
    Let  be a compact closed category with finite biproducts satisfying feeble full completeness. Then  does not satisfy \mllmix~full completeness if  is not zero-sum-free.
    \end{prop}
    \proof
    Suppose  is such a compact closed category, meaning that there exists at least one arrow  with an additive inverse . We assume without loss of generality that we are in a strict compact closed category, suppressing the usage of the isomorphism . However, at times when associativity and unit isomorphisms are silently being used are noted for the sake of clarity, either in the equation or as a side comment. Consider the \mll~transformation  found in  modelling the following linear combination of proof structures:
    
    \begin{center} \vspace{5mm}
    \begin{tikzpicture}
      [auto, node
      distance=5mm, skip loop/.style={to path={-- ++(0,#1) -| (\tikztotarget)}}] \tikzstyle{every node} = [text depth=-5pt,text height=0.5ex] \tikzstyle{every node} = [text depth=-5pt,text height=0.5ex]
     \node (z1) { }; \node (z2) [right of=z1] {}; 
        \node (1) [right of=z2] {}; \node (a) [right of=1] {} ;
       \node (2) [right of=a] {}; \node (b) [right of=2] {} ;
       \node (3)  [right of=b] {}; \node (c)  [right of=3] {};
       \node (4)  [right of=c] {}; \node(d) [right of=4] {} ;
       \node (5) [right of=d] {}; \node (e) [right of=5] {} ;
       \node (6) [right of=e] {}; 
      \node (t1) [above of= z1] {};
      \node (t2) [above of= t1] {};
      \node (t3) [above of= t2, xshift=-3mm] {};
      \node (s1) [below of= z1] {};
      \node (s2) [below of= s1] {};
      \node (s3) [below of= s2] {};
      \node (T1) [above of= z2] {};
      \node (T2) [above of= T1] {};
      \node (T3) [above of= T2] {};
      \node (S1) [below of= z2] {};
      \node (S2) [below of= S1] {};
      \node (S3) [below of= S2] {};
    \begin{scope}\path (1)  edge  [red, skip loop =16mm,shorten >=13mm, shorten <=13mm] (2);
    \path (3)  edge  [red, skip loop =16mm,shorten >=13mm, shorten <=13mm] (4);
    \path (5)  edge  [red, skip loop =16mm,shorten >=13mm, shorten <=13mm] (6);
    \path (1)  edge  [blue, skip loop =11mm,shorten >=8mm, shorten <=8mm] (2);
    \path (3)  edge  [blue, skip loop =12mm,shorten >=8mm, shorten <=8mm] (6);
    \path (4)  edge  [blue, skip loop =11mm,shorten >=8mm, shorten <=8mm] (5);
    \path (1)  edge  [green, skip loop =7mm, shorten >=3mm, shorten <=3mm] (6);
    \path (2)  edge  [green, skip loop =6mm, shorten >=3mm, shorten <=3mm] (5);
    \path (3)  edge  [green, skip loop =5mm, shorten >=3mm, shorten <=3mm] (4);
    \path (1)  edge  [magenta, skip loop =-7mm, shorten >=3mm, shorten <=3mm] (4);
    \path (2)  edge  [magenta, skip loop =-6mm, shorten >=3mm, shorten <=3mm] (3);
    \path (5)  edge  [magenta, skip loop =-5mm, shorten >=3mm, shorten <=3mm] (6);
    \path (1)  edge  [orange, skip loop =-12mm,shorten >=8mm, shorten <=8mm] (4);
    \path (3)  edge  [orange, skip loop =-10mm,shorten >=8mm, shorten <=8mm] (6);
    \path (5)  edge  [orange, skip loop =-11mm,shorten >=8mm, shorten <=8mm] (2);
    \path (1)  edge  [gray, skip loop =-17mm,shorten >=13mm, shorten <=13mm] (6);
    \path (3)  edge  [gray, skip loop =-16mm,shorten >=13mm, shorten <=13mm] (2);
    \path (5)  edge  [gray, skip loop =-16mm,shorten >=13mm, shorten <=13mm] (4);
    \end{scope}
    \end{tikzpicture} \vspace{5mm}
    \end{center}
    Up to isomorphism the transformation can be written
    
    where the natural transformation  for given permutation  is the composition of associativity and symmetry natural transformations expected of symmetric monoidal categories containing arrows with source and target in the form below.
    
    For short, we can write , where
    
    
    Let  be an arbitrary object in , meaning that  for every  and . We define the following notation:
    \begin{itemize}
    \item  is the tuple  missing the  entry;
    \item , where  is the natural composition of the unit isomorphism.
    \end{itemize}
    
\noindent    We see that,
    
    
    \p\noindent If either  or  then it is trivially true that  is in the set of values. If both sets are non-empty, let  and  be arbitrary, not necessarily distinct morphisms. Noting (and suppressing usage of the isomorphism ) that  and  for all suitable arrows  and  in  due to dinaturality, and that  for any choice of , the composition  can be found for each permutation . 
    By symmetry and a similar argument we also find
    
    
    
    




\noindent    Finding the compositions  and \\  now becomes a simple case of taking the correct linear combination of answers from the above calculations.

    This final sum is a linear combination of the arrows . One finds by inspection that the scalars added together in this sum for  for some  are  and , the two scalars for which . Since  and  are distinct but they share a value in exactly one position in this situation, it must be the case that one is an even permutation (that is, it belongs to ), and one is odd (and therefore is not a member of ). For the sake of convenience, let the former be the even permutation. If , then we know that neither of the two permutations are , and so we deduce that \linebreak . If however, , then one of them does equal , meaning . We therefore conclude that
    
    By a dual argument, we can find that 
    
    
\noindent    The arrows  and  are arbitrary throughout the above argument, meaning that any triple of values and covalues of  could be chosen. Thus . Furthermore, we may say that this for any choice of , since  is considered arbitrary in this proof as well. Naturally this means that the -arrows in the collection  are found in all the required homsets in , and therefore the \mll~transformation  is also in . The linear combination of proof structures modelled by this transformation is non-simple, and so the category does not satisfy \mllmix~full completeness. \qed
    
   
    \begin{cor}
    Let  be a compact closed category with finite biproducts satisfying feeble full completeness. The category  satisfies \mllmix~full completeness if and only if  is zero-sum-free.
    \end{cor}
    
\section{Conclusions}

In this paper we show that there are two simple, elegant methods
of producing categorical models for both \mll\ or~\mllmix. The
Hyland-Tan double glueing construction is seemingly the perfect
semantic description of the deductive system when applied to
tensor-generated compact closed categories with finite biproducts. 
Certainly the Danos-Regnier description of proof nets has a strongly
combinatorial flavour, and this paper shows that the same
combinatorial restrictions are imposed on the
categorical model by the double glueing construction.

\p It is notable that the tensor representations of \mll\
transformations are precisely the \emph{isotropic tensors of even
power} over the semiring of scalars. Viewed as vectors in Euclidean space, this means that such representations are exactly those which are invariant under basis change. It is therefore reasonable to suggest that the more combinatorial proofs given in this paper may be replaceable by geometric arguments. Such a methodology could unveil a different perspective on the categorical models and \mll\ itself.

\p An obvious possibility for future work is applying these techniques
to the (unitless) multiplicative additive fragment of linear logic,
\mall. Since we start from compact closed categories with finite
biproducts we know that our models, after double glueing, have both
finite sums and products~\cite{HS03} and so are models of \mall.

\p However, it is known that the Hyland-Tan construction alone cannot
produce fully complete models of \mall~\cite{Ste13}: none of the
resulting categories satisfy Joyal's softness property on the
dinatural level as is required. Categories which accurately model
\mall~proof nets are in short supply: the only example whose full proof has been published is  --- the category of hypercoherence spaces under the `'-construction --- found in~\cite{BHS05}.

\p We note that  is another example of a double-glued
category, but with a tight orthogonality upon it. \hughf{We are writing an article giving the appropriate generalisation of the definition of orthogonality found in~\cite{HS03} in order to allow the essence of this construction to be extracted. It is hoped that this will provide a starting point for finding a full completeness result for \mall\ which is as general as ours for~\mll.} One might note in
passing that the result of Blute, Hamano and Scott is based upon the
\mall~proof net criteria of Girard~\cite{Gir96} based around monomial weights, whereas there is currently no comparable result for the Hughes-van Glabbeek proof net criteria~\cite{HvG05}. We hope that our methods are suitable to address that situation.

\section*{Acknowledgements}
  \hughe{The authors would like to thank the anonymous reviewers of this paper for their constructive criticism of our originally submitted draft. Thanks also to Luke Ong and Harold Simmons, examiners of the thesis from which this article was originally drawn, for their suggestions. The commutative diagrams were drawn using the diagrams package of Paul Taylor.
  
  \noindent The second author was partially supported by the ANR projects LOGOI (10-BLAN-0213-02) and COQUAS (12-JS02-006-01), and an EPSRC studentship.}



\bibliographystyle{alpha}
\begin{thebibliography}{DHPP99}

\bibitem[AJ94]{AJ94}
S.~Abramsky and R.~Jagadeesan.
\newblock Games and full completeness for multiplicative linear logic.
\newblock {\em J.\ Symbolic Logic}, 59:543--574, 1994.

\bibitem[Bar79]{Bar79}
M.~Barr.
\newblock {\em {}-Autonomous categories}, volume 752 of {\em Lecture Notes
  in Mathematics}.
\newblock Springer-Verlag, 1979.

\bibitem[BFSS90]{BFSS90}
E.S. Bainbridge, P.J. Freyd, A.~Scedrov, and P.J. Scott.
\newblock Functorial polymorphism.
\newblock {\em Theoretical Computer Science}, 70:35--64, 1990.

\bibitem[BHS05]{BHS05}
R.~Blute, M.~Hamano, and P.~Scott.
\newblock Softness of hypercoherences and mall full completeness.
\newblock {\em Annals of Pure and Applied Logic}, 131:1--63, 2005.

\bibitem[Blu93]{Blu93}
R.~Blute.
\newblock Linear logic, coherence and dinaturality.
\newblock {\em Theoretical Computer Science}, 115:3--41, 1993.

\bibitem[BS96]{BS96}
R.~Blute and P.~Scott.
\newblock Linear {L}\"auchli semantics.
\newblock {\em Annals of Pure and Applied Logic}, 77:101--142, 1996.

\bibitem[CHS01]{CHS01}
R.~Cockett, M.~Hyland, and S.~Soloviev.
\newblock {Natural transformation between tensor powers in the presence of
  direct sums}.
\newblock Technical Report 01-12-R, IRIT, Universitรฉ Paul Sabatier, Toulouse,
  July 2001.

\bibitem[Chu79]{Chu79}
P.-H. Chu.
\newblock {\em Constructing {}-autonomous categories}.
\newblock Volume 752 of {\em Lecture Notes in Mathematics\/} \cite{Bar79},
  1979.
\newblock Appendix.

\bibitem[DHPP99]{DHPP99}
H.~Devarajan, D.~Hughes, G.~Plotkin, and V.~Pratt.
\newblock Full completeness of the multiplicative linear logic of chu spaces.
\newblock In {\em {Proc.\ Logic in Computer Science 1999}}. IEEE Computer
  Society Press, 1999.

\bibitem[DR89]{DR89}
V.~Danos and L.~Regnier.
\newblock The structure of the multiplicatives.
\newblock {\em Arch.\ Math.\ Logic}, 28:181--203, 1989.

\bibitem[FR94]{FR94}
A.~Fleury and C.~Retour\'e.
\newblock The mix rule.
\newblock {\em Mathematical Structures in Computer Science}, 4:273--285, 1994.

\bibitem[Gir87]{Gir87}
J.-Y. Girard.
\newblock Linear logic.
\newblock {\em Theoretical Computer Science}, 50:1--102, 1987.

\bibitem[Gir96]{Gir96}
J.-Y. Girard.
\newblock Proof-nets: the parallel syntax for proof theory.
\newblock In {\em Logic and Algebra}. Marcel Dekker, 1996.

\bibitem[Hag00]{Hag00}
E.~Haghverdi.
\newblock {\em A Categorical Approach to Linear Logic, Geometry of Proofs and
  Full Completeness}.
\newblock PhD thesis, University of Ottawa, 2000.

\bibitem[Heu08]{Heu08}
C.~Heunen.
\newblock Semimodule enrichment.
\newblock In {\em Proceedings of the Twenty-Fourth Conference on the
  Mathematical Foundations of Programming Semantics}, pages 193--208, 2008.

\bibitem[HO93]{HO93}
J.M.E. Hyland and C.-H.L. Ong.
\newblock Fair games and full completeness for multiplicative linear logic
  without the mix-rule.
\newblock ftp from ftp.comlab.ox.ac.uk as fcomplete.ps.gz in
  /pub/Documents/techpapers/Luke.Ong, 1993.

\bibitem[Hou06]{Hou08}
R.~Houston.
\newblock Finite products are biproducts in a compact closed category, 2006.

\bibitem[HS03]{HS03}
M.\ Hyland and A.\ Schalk.
\newblock Glueing and orthogonality for models of linear logic.
\newblock {\em Theoretical Computer Science}, 294:183--231, 2003.

\bibitem[Hug04]{Hug04}
D.~Hughes.
\newblock Intensional double glueing, biextensional collapse, and the chu
  construction.
\newblock In {\em Proceedings of {MFPS} {XIX}}, Electronic Notes in Theoretical
  Computer Science, 2004.

\bibitem[HvG05]{HvG05}
D.~Hughes and R.~van Glabbeek.
\newblock Proof nets for unit-free multiplicative-additive linear logic.
\newblock {\em ACM Transactions on Computational Logic}, 2005.
\newblock Invited submission November 2003. Revised January 2005.

\bibitem[KL80]{KL80}
G.M.\ Kelly and M.L.\ Laplaza.
\newblock Coherence for compact closed categories.
\newblock {\em Journal of Pure and Applied Algebra}, 19:193--213, 1980.

\bibitem[Loa94a]{Loa94a}
R.~Loader.
\newblock Linear logic, totality, and full completeness.
\newblock In {\em Proc.\ Logic in Computer Science 1994}. IEEE Computer Science
  Press, 1994.

\bibitem[Loa94b]{Loa94b}
R.~Loader.
\newblock {\em Models of lambda calculi and linear logic: Structural,
  equational and proof-theoretic characterisations}.
\newblock PhD thesis, St.~Hugh's College, Oxford, Michaelmas 1994.

\bibitem[LS06]{LS06}
F.~Lamarche and L.~Stra{\ss}burger.
\newblock From proof nets to the free *-autonomous category.
\newblock In {\em Logical Methods in Computer Science}, pages 1--44, 2006.

\bibitem[Mac97]{Mac97}
S.\ MacLane.
\newblock {\em Categories for the Working Mathematician Second Edition}.
\newblock Springer-Verlag, 1997.

\bibitem[Mel06]{Mel06}
P.~A. Melli\`{e}s.
\newblock Categorical semantics of linear logic: A survey, 2006.

\bibitem[See89]{See89}
R.~Seely.
\newblock Linear logic, *-autonomous categories and cofree coalgebras.
\newblock {\em AMS Contemporary Mathematics}, 92:371--382, 1989.

\bibitem[SS12]{SS12}
A.~Schalk and H.~Steele.
\newblock Constructing fully complete models for multiplicative linear logic
  (extended abstract).
\newblock In {\em {Proc.\ Logic in Computer Science 2012}}. IEEE Computer
  Society Press, 2012.

\bibitem[Ste13]{Ste13}
H.P. Steele.
\newblock {\em Combinatorial Arguments for Linear Logic Full Completeness}.
\newblock PhD thesis, University of Manchester, 2013.

\bibitem[Str06]{Str06}
L.~Strassburger.
\newblock Proof nets and the identity of proofs, 2006.

\bibitem[Tan97]{Tan97}
A.M. Tan.
\newblock {\em Full completeness for models of linear logic}.
\newblock PhD thesis, University of Cambridge, 1997.

\end{thebibliography}

\end{document}
