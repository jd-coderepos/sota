\def\year{2019}\relax
\documentclass[letterpaper]{article} \usepackage{aaai20}  \usepackage{times}  \usepackage{helvet} \usepackage{courier}  \usepackage[hyphens]{url}  \usepackage{graphicx} \urlstyle{rm} \def\UrlFont{\rm}  \usepackage{graphicx}  \frenchspacing  \setlength{\pdfpagewidth}{8.5in}  \setlength{\pdfpageheight}{11in}  \usepackage{booktabs}
\usepackage{arydshln}

\usepackage{amsthm} \usepackage{amsmath} \usepackage{amsfonts} \usepackage[mathscr]{eucal} 

\usepackage{subcaption}

\usepackage{algorithm}
\usepackage{algorithmic}

\pdfinfo{
/Title (Count-Based Exploration with the Successor Representation)
/Author (Marlos C. Machado, Marc G. Bellemare, Michael Bowling)
}

\setcounter{secnumdepth}{1} 

\def \inv {^{-1}}
\def \pHat {\hat{P_\pi}}
\def \pTilde {\tilde{P_\pi}}
\def \DeltaHat {\hat{\Delta}}
\def \DeltaTilde {\tilde{\Delta}}
\def \PsiHat {\hat{\Psi}_\pi}
\def \PsiTilde {\tilde{\Psi}_\pi}
\def \e {{\bf e}}
\def \ones {{\bf 1}}

\newtheorem{lemma}{Lemma}[section]
\newtheorem{lemma*}{Lemma}
\newtheorem{theorem}{Theorem}
\newtheorem{theorem*}{Theorem}
\newtheorem{definition}{Definition}[section]


\setlength\titlebox{2.5in} 
\title{Count-Based Exploration with the Successor Representation}
\author{Marlos C. Machado,\textsuperscript{\rm 1} \Large \textbf{Marc G. Bellemare,\textsuperscript{\rm 1}} \Large \textbf{Michael Bowling \textsuperscript{\rm 2}\textsuperscript{\rm 3}}\\ \textsuperscript{\rm 1} Google AI, Brain Team, \textsuperscript{\rm 2}University of Alberta,
\textsuperscript{\rm 3}DeepMind Alberta\\
\{marlosm, bellemare, bowlingm\}@google.com }
 \begin{document}

\maketitle

\begin{abstract}
In this paper we introduce a simple approach for exploration in reinforcement learning (RL) that allows us to develop theoretically justified algorithms in the tabular case but that is also extendable to settings where function approximation is required. Our approach is based on the successor representation (SR), which was originally introduced as a representation defining state generalization by the similarity of successor states. Here we show that the norm of the SR, while it is being learned, can be used as a reward bonus to incentivize exploration. In order to better understand this transient behavior of the norm of the SR we introduce the substochastic successor representation (SSR) and we show that it implicitly counts the number of times each state (or feature) has been observed. We use this result to introduce an algorithm that performs as well as some theoretically sample-efficient approaches. Finally, we extend these ideas to a deep RL algorithm and show that it achieves state-of-the-art performance in Atari 2600 games when in a low sample-complexity regime.
\end{abstract}

\section{Introduction}
Reinforcement learning (RL) tackles sequential decision making problems by formulating them as tasks where an agent must learn how to act optimally through trial and error interactions with the environment. The goal in these problems is to maximize the (discounted) sum of the numerical reward signal observed at each time step. Because the actions taken by the agent influence not just the immediate reward but also the states and associated rewards in the future, sequential decision making problems require agents to deal with the trade-off between immediate and delayed rewards. Here we focus on the problem of exploration in RL, which aims to reduce the number of samples (i.e., interactions) an agent needs in order to learn to perform well in these tasks when the environment is initially unknown.

Surprisingly, the most common approach in the field is to select exploratory actions uniformly at random, with even high-profile success stories being obtained with this strategy (e.g., \citeauthor{Tesauro95} \citeyear{Tesauro95}; \citeauthor{Mnih15} \citeyear{Mnih15}). However, random exploration often fails in environments with sparse rewards, that is, environments where the agent observes a reward signal of value zero for the majority of states. In this paper we introduce an approach for exploration in RL based on the successor representation (SR; \citeauthor{Dayan93} \citeyear{Dayan93}). The SR is a representation that generalizes between states using the similarity between their successors, that is, the states that follow the current state given the agent's policy. The SR is defined for any problem, it can be learned with temporal-difference learning and, as we discuss below, it can be seen as implicitly estimating the transition dynamics of the environment.

The main contribution of this paper is to show that \emph{the norm of the SR can be used as an exploration bonus}. We perform an extensive empirical evaluation to demonstrate this and we introduce the substochastic successor representation~(SSR) to also understand, theoretically, the behavior of such a bonus. The SSR behaves similarly to the SR but it is more amenable to theoretical analyses. We show that the SSR implicitly counts state visitation, suggesting that the exploration bonus obtained from the SR, while it is being learned, might also be incorporating some notion of state visitation counts. We demonstrate this intuition empirically and we use this result to introduce algorithms that, in the tabular case, perform as well as traditional approaches with PAC-MDP guarantees. Finally, we extend the idea of using the norm of the SR as an exploration bonus to the function approximation case, designing a deep RL algorithm that achieves state-of-the-art performance in hard exploration Atari 2600 games when in a low sample-complexity regime. The proposed algorithm is also simpler than traditional baselines such as pseudo-count-based methods because it does not require domain-specific density models \cite{Bellemare16,Ostrovski17}.

\section{Preliminaries}
\label{sec:background}

We consider an agent interacting with its environment in a sequential manner. Starting from a state , at each step the agent takes an action , to which the environment responds with a state  according to a transition function , and with a reward signal , where  indicates the expected reward for a transition from state  under action , that is, .

The value of a state  when following a policy , , is defined to be the expected sum of discounted rewards from that state: , where  is the discount factor. When the transition probability function  and the reward function  are known, we can compute  recursively by solving the system of equations below \cite{Bellman57}:

These \ equations \ can \ also \ be \ written \ in \ matrix \ form \ with ,  and : 

where  is the state to state transition probability function induced by , that is, .

Traditional model-based algorithms learn estimates of the matrix  and~of~the~vector  and use them to estimate , for example by solving Equation~\ref{eq:value_function}. We use  and  to denote empirical estimates of  and .~Formally,

where  denotes the -th entry in the vector ,  is the number of times the transition  was observed, , and  is the sum of the rewards associated with the  transitions (we drop the action to simplify notation). However, model-based approaches are rarely successful in problems with large state spaces due to the difficulty in learning accurate models.

Because of the challenges in model learning, model-free solutions largely dominate the literature. In model-free RL, instead of estimating  and , we estimate  directly from samples. We often use TD learning \cite{Sutton88} to update our estimates of , , online:

where  is the step-size parameter. Generalization is required in problems with large state spaces, where it is unfeasible to learn an individual value for each state. We do so by parametrizing~~with a set of weights . We write, given the weights ,  and , where . Model-free methods have performed well in problems with large state spaces, mainly due to the use of neural networks as function approximators (e.g., \citeauthor{Mnih15}~\citeyear{Mnih15}).

The ideas presented here are based on the successor representation (SR; \citeauthor{Dayan93} \citeyear{Dayan93}). The successor representation with respect to a policy , , is defined as

where we assume the sum is convergent with  denoting the indicator function. This expectation can actually be estimated from samples with TD learning:

for all  and  denoting the step-size. The SR also corresponds to the Neumann series of :

Notice that the SR is part of the solution when computing a value function:  (Equation~\ref{eq:value_function}). We use  to denote the SR computed through , the approximation of~.

Successor features \cite{Barreto17} generalize the successor representation to the function approximation setting. We use the definition for the uncontrolled case.

\begin{definition}[Successor Features] For a given , policy , and for a feature representation , the successor features for a state  are:

\label{def:sf}
\end{definition}

Alternatively, in matrix form, we can write the successor features as , where  is a matrix encoding the feature representation of each state such that . This definition reduces to the SR in the tabular case, where .

\section{ as an Exploration Bonus}
\label{sec:theory}

Recent results have shown that the SR naturally captures the diffusion properties of the environment (e.g., \citeauthor{Machado18b} \citeyear{Machado18b}; \citeauthor{Wu19} \citeyear{Wu19}). Inspired by these results, in this section we argue that the SR can be explicitly used to promote exploration. We show that the norm of the SR, while it is being learned, behaves as an exploration bonus that rewards agents for visiting states it has visited less often. We first demonstrate this behavior empirically, in the tabular case. We then introduce the substochastic successor representation to provide some theoretical intuition that justifies this idea. In subsequent sections we show how these ideas carry over to the function approximation~setting.

\subsection{First Empirical Demonstration}\label{sec:model_free_tabular}

To demonstrate the usefulness of the norm of the SR as an exploration bonus, we first compare the performance of traditional Sarsa~\cite{Rummery94,Sutton98} to Sarsa+SR, which incorporates the norm of the SR as an exploration bonus in the Sarsa update. The update equation for Sarsa+SR is

where  is a scaling factor and, at each time step ,  is updated before  as per Equation~4.

We evaluated this algorithm in \textsc{RiverSwim} and \textsc{SixArms}~\cite{Strehl08}, traditional domains in the PAC-MDP literature. In these domains, it is very likely that an agent will first observe a small reward generated in a state that is easy to get to. If the agent does not have a good exploration policy, it is likely to converge to a suboptimal behavior, never observing larger rewards available in states that are difficult to get to. See Figure~\ref{fig:tabular_domains} for more details. 

\begin{figure}[t]
    \centering
    \begin{subfigure}[b]{0.45\textwidth}
        \includegraphics[width=\textwidth]{riverswim}
        \caption{RiverSwim \linebreak}
    \end{subfigure}
    ~ 

    \begin{subfigure}[b]{0.42\textwidth}
        \includegraphics[width=\textwidth]{sixarms}
        \caption{SixArms}
    \end{subfigure}
    \caption{Domains used in the tabular case. The tuples in each transition denote action id, probability, reward. In \textsc{SixArms}, the agent starts in state~. In \textsc{RiverSwim}, the agent starts in either state~ or~ with equal probability.} \label{fig:tabular_domains} 
\end{figure}


We compared the performance of Sarsa and Sarsa+SR for  time steps when acting -greedily to maximize the discounted return (). For Sarsa+SR, we swept over different values of , , ,  and , with , , ,  and . For Sarsa, we swept over the parameters  and . For fairness, we looked at a finer granularity for these parameters, with  for  ranging from  to , and with  for  ranging from  to . Table~\ref{tab:parameters_tabular}, at the end of the paper, summarizes the parameter settings that led to the best results for each algorithm in \textsc{RiverSwim} and \textsc{SixArms}. The performance of each algorithm, averaged over  runs, is available in Table~\ref{tab:results_tabular_sarsa}.

Our results show that the proposed exploration bonus has a profound impact in the algorithm's performance. Sarsa obtains an average return of approximately  while Sarsa+SR obtains an approximate average return of  million. Notice that, in \textsc{RiverSwim}, the reward that is ``easy to get'' has value~, implying that, different from Sarsa+SR, Sarsa almost never explores the state space well enough. We observe the same trend in \textsc{SixArms}.

    

\subsection{Theoretical Justification}

It is difficult to characterize the behavior of our proposed exploration bonus because it is updated at each time step with TD learning. It is hard to analyze the behavior of estimates obtained with TD learning in the interim. Also, at its fixed point, for a fixed policy, the -norm of the SR is  for all states, preventing us from using the fixed point of the SR to theoretically analyze the behavior of this exploration bonus. In this section we introduce the substochastic successor representation (SSR) to provide some theoretical intuition, in the prediction case, of why the norm of the SR is a good exploration bonus. The SSR behaves similarly to the SR but it is simpler to analyze.

\begin{table}[t]
\centering
\caption{Comparison between Sarsa and Sarsa+SR. A 95\% confidence interval is reported between parentheses.}  \label{tab:results_tabular_sarsa}
\footnotesize
  \begin{tabular}{ l | r l | r l }
  & \multicolumn{2}{| c }{Sarsa} & \multicolumn{2}{| c }{Sarsa + SR} \\ \hline
  \textsc{RiverSwim}    &   &\!\!\!()   &\!\!\!   &()     \\ \hdashline[0.5pt/2pt]
  \textsc{SixArms}      &  &\!\!\!()  &\!\!\!   &() \\
  \end{tabular}
\end{table}

\begin{definition}[Substochastic Successor Representation] Let  denote the substochastic matrix induced by the environment's dynamics and by the policy  such that  For a given , the substochastic successor representation, , is defined as:
 \label{def:ssr}
\end{definition}

The SSR only differs from the empirical SR in its incorporation of an additional ``phantom'' transition from each state, making it underestimate the real SR. Through algebraic manipulation we show that the SSR allows us to recover an estimate of the visit counts, . This result provides some intuition of why the exploration bonus we propose performs so well, as exploration bonuses based on state visitation counts are known to generate proper exploration.

As aforementioned, the SSR behaves similarly to the SR. When computing the norm of the SR, while it is being learned with TD learning, it is as if a reward of 1 was observed at each time step.\footnote{In vector form, when estimating the SR with TD learning, the clause , from Equation 4, is always true for one of the states, that is, an entry in the vector representing the SR. Thus, it is as if a reward of 1 was observed at each time step.} Thus, there is little variance in the target, with the predictions slowly approaching the true value of the SR. If pessimistically initialized, as traditionally done (i.e., initialized to zero when expecting positive rewards), the estimates of the SR approach the target from below. In this sense, the number of times a prediction has been updated in a given state is a good proxy to estimate how far this prediction is from its final target. From Definition 3.1 we can see that the SSR have similar properties. It underestimates the true target but slowly approaches it, converging to the true SR in the limit. The SSR simplifies the analysis by not taking bootstrapping into consideration.

The theorem below formalizes the idea that the norm of the SSR implicitly counts state visitation, shedding some light on the efficacy of the exploration bonus we propose.

\begin{theorem}~\label{theorem}
Let  denote the number of times state  has been visited and let  denote the substochastic successor representation as in Definition~\ref{def:ssr}. For a given ,

\end{theorem}

\begin{proof}[Proof of Theorem~\ref{theorem}] \let\qed\relax

Let  be the empirical transition matrix. We first rewrite  in terms of :

This expression can also be written in matrix form: , where  denotes the diagonal matrix of augmented inverse counts. Expanding  we have:


The top eigenvector of a stochastic matrix is the all-ones vector,  \cite{meyn12markov}. Using this fact and the definition of  with respect to  we have:

We can now bound the term  using the fact that  is also the top eigenvector of the successor representation and has eigenvalue ~\cite{Machado18b}:

Plugging (\ref{eq:sr1}) into the definition of the SR we have (notice that ):

When we also use the other bound on the quadratic term we conclude that, for any state ,
 
\end{proof}


\subsubsection{The relationship between the SSR and the SR.}
Theorem~1 shows that the SSR, obtained after a slight change to the SR, can be used to recover state visitation counts. The intuition behind this result is that the phantom transition, represented by the  in the denominator of the SSR, serves as a proxy for the uncertainty about that state by underestimating the SR. This is due to the fact that  gets closer to  each time state  is visited.

\begin{figure}[t]
    \centering
    \includegraphics[width=0.8\columnwidth]{norm1}
    \caption{Empirical evaluation of the the norm of the SR as a function of state visitation count. Each curve denotes the evolution in one of the six states of \textsc{RiverSwim}. The colors match the colors of the states in Figure~\ref{fig:tabular_domains}a. Reference functions  and  are depicted for comparison (; ). See text for details.}\label{fig:empirical_count}
\end{figure}

This result also suggests that the exploration bonus we propose, , behaves as a proper exploration bonus. It rewards the agent for visiting a state for the first times and it becomes less effective as the agent continues to visit that state. Hence, our approach does not change the optimal~policy because, in the limit, the norm of the SR (and the exploration bonus) converges to a constant value (see footnote~1):


To validate the intuition that the SSR behaves similarly to the SR, we empirically evaluated the norm of the SR in the six states of RiverSwim as a function of the number of times those states were visited. Figure~\ref{fig:empirical_count} depicts the average result over the 100 runs used to generate the results in Table~\ref{tab:results_tabular_sarsa}. The plot shows that the norm of the SR does indeed grow as a function of state visitation counts. In this particular case, the norm of the SR grows at a rate between , as suggested by the SSR, and , which is the rate at which TD often converges (Theorem 3.6; \citeauthor{Dalal18}~\citeyear{Dalal18}).

\subsubsection{Empirical validation of  as an exploration bonus.}

As a sanity check, we used the result in Theorem~1 to implement a simple model-based algorithm that penalizes the agent for visiting commonly visited states with the exploration bonus . Our agent maximizes , where  is a scaling parameter. The shift  in the theorem has no effect in the agent's policy because it is the same across all states. In this algorithm the agent updates its transition model and reward model with Equation~\ref{eq:model_estimation} and its SSR estimate as in Definition~\ref{def:ssr}.

Table~\ref{tab:results_tabular} depicts the performance of this algorithm, dubbed ESSR, as well as the performance of some algorithms with polynomial sample-complexity bounds. The goal with this evaluation is not to outperform these algorithms, but to evaluate how well ESSR performs when compared to algorithms that explicitly keep visitation counts to promote exploration. ESSR performs as well as \textsc{R-Max}~\cite{Brafman02} and E~\cite{Kearns02} on \textsc{RiverSwim} and it outperforms these algorithms on \textsc{SixArms}; while MBIE~\cite{Strehl08}, which explicitly estimates confidence intervals over the expected return in each state, outperforms ESSR in these domains. These results clearly show that ESSR performs, on average, similarly to other algorithms with PAC-MDP guarantees, suggesting that the norm of the SSR is a promising exploration bonus.\footnote{The code used to generate all results in this section is available at:
\url{https://github.com/mcmachado/count_based_exploration_sr/tree/master/tabular}.}

\begin{table}[t]
\centering
\caption{Comparison between ESSR, \textsc{R-Max}, \textsc{E}, and \textsc{MBIE}. The numbers reported for \textsc{R-Max}, \textsc{E}, and \textsc{MBIE} were extracted from the histograms presented by \citeauthor{Strehl08}~(\citeyear{Strehl08}). ESSR's performance is the average over  runs. A  confidence interval is reported between parentheses. All numbers are reported in millions (i.e., ).}  \label{tab:results_tabular}
\small
  \begin{tabular}{ l | c | c | c| r l }
  & \textsc{E} &\textsc{R-Max} &\textsc{MBIE} &\multicolumn{2}{| c }{\textsc{ESSR}}\\ \hline
  \textsc{RiverSwim}    &  &    &    & &()  \\ \hdashline[0.5pt/2pt]
  \textsc{SixArms}      &   &    &    & &()  \\
  \end{tabular}
\end{table}



\section{Counting Feature Activations with the SR}
\label{sec:deep_sr}

In large environments, where enumerating all states is not an option, directly using Sarsa+SR as described in the previous section is not viable. However, one of the reasons the results in the previous section are interesting is the fact that there is a natural extension of the SR to non-tabular settings, the successor features (Definition~2.1), and the fact that we can immediately use norms in the function approximation setting. In this section we show how one can extend the idea of using the norm of the SR as an exploration bonus to the function approximation setting, something one cannot easily do if relying on explicit state visitation counts. Because deep RL approaches often lead to state-of-the-art performance while also learning a representation from high-dimensional sensory inputs, in this section we introduce a deep RL algorithm that incorporates the ideas introduced. Our algorithm was also inspired by recent work that has shown that successor features can be learned jointly with the feature representation itself \cite{Kulkarni16,Machado18b}.

An overview of the neural network we used to learn the agent's value function while also learning the feature representation and the SR is depicted in Figure~\ref{fig:network}. The layers used to compute the state-action value function, , are structured as in DQN~\cite{Mnih15}, with the number of parameters (i.e., filter sizes, stride, and number of nodes) matching \citeauthor{Oh15}'s~(\citeyear{Oh15}) architecture, which is known to succeed in the auxiliary task detailed below of predicting the agent's next observation. We call the part of our architecture that predicts  DQN. It is trained to minimize

with  and  being defined as 


This loss is known as the mixed Monte-Carlo return (MMC) and it has been used in the past by the algorithms that achieved succesful exploration in deep reinforcement learning~\cite{Bellemare16,Ostrovski17}. The distinction between  and  is standard in the field, with  denoting the parameters of the target network, which is updated less often for stability purposes~\cite{Mnih15}. As before, we use  to denote the exploration bonus obtained from the successor features of the internal representation, , which will be defined below. Moreover, to ensure all features are in the same range, we normalize the feature vector so that . In Figure~\ref{fig:network} we highlight with  the layer in which we normalize its output. Notice that the features are always non-negative due to the~use~of~ReLU~gates.

\begin{figure}[t]
    \centering
    \includegraphics[width=0.92\columnwidth]{abstract_diagram}
    \caption{Neural network architecture used by our algorithm when learning to play Atari 2600 games.}\label{fig:network}
\end{figure}

\begin{table*}[t]
\centering
\caption{Performance of the proposed algorithm, DQN+SR, compared to various agents on the ``hard exploration'' subset of Atari 2600 games. The DQN results reported are from \citeauthor{Machado18a}~(\citeyear{Machado18a}) while the \textsc{DQN}, \textsc{DQN} and RND results were obtained through personal communication with the authors of the corresponding papers. \citeauthor{Burda19} did not evaluate RND in \textsc{Freeway}. When available, standard deviation is reported between parentheses. See text for details.}  \label{tab:results_ale}
\footnotesize
  \begin{tabular}{ l | r l | r l | l | l | r l |  r l}
  &\multicolumn{2}{| c |}{DQN} &\multicolumn{2}{| c | }{DQN} &\textsc{DQN} &\textsc{DQN} &\multicolumn{2}{| c}{RND} &\multicolumn{2}{| c }{DQN+SR}\\ \hline
  \textsc{Freeway}                &32.4   &(0.3)     & 29.5   &(0.1)   & \ \ \ \ 29.2   & \ \ \ \ \ \ \ 29.4    &-       &-               &29.4   &(0.1)   \\ \hdashline[0.5pt/2pt]
  \textsc{Gravitar}               &118.5  &(22.0)    & 1078.3 &(254.1) & \ \ \ \ 199.8  & \ \ \ \ \ \ \ 275.4   &790.0   &(122.9)         &457.4  &(120.3) \\ \hdashline[0.5pt/2pt]
  \textsc{Mont. Rev.}             &0.0    &(0.0)     & 0.0    &(0.0)   & \ \ \ \ 2941.9 & \ \ \ \ \ \ \ 1671.7  &524.8   &(314.0)         &1395.4 &(1121.8) \\ \hdashline[0.5pt/2pt]
  \textsc{Private Eye}            &1447.4 &(2,567.9) & 113.4  &(42.3)  & \ \ \ \ 32.8   & \ \ \ \ \ \ \ 14386.0 &61.3    &(53.7)          &104.4  &(50.4)   \\ \hdashline[0.5pt/2pt]
  \textsc{Solaris}                &783.4  &(55.3)    & 2244.6 &(378.8) & \ \ \ \ 1147.1 & \ \ \ \ \ \ \ 2279.4  &1270.3  &(291.0)         &1890.1 &(163.1) \\ \hdashline[0.5pt/2pt]
  \textsc{Venture}                &4.4    &(5.4)     & 1220.1 &(51.0)  & \ \ \ \ 0.0    & \ \ \ \ \ \ \ 856.2   &953.7   &(167.3)         &1348.5 &(56.5) \\
  \end{tabular} 
\end{table*}


The successor features, , at the bottom of the diagram, are obtained by minimizing~the~loss

Zero is a fixed point for the SR, which is particularly concerning in settings with sparse rewards. The agent might end up learning to set  to achieve zero loss. We address this problem by not propagating  to  (this is depicted in Figure~\ref{fig:network} as an open circle stopping the gradient); and by creating an auxiliary task~\cite{Jaderberg17} to encourage a representation to be learned before a non-zero reward is observed. As \citeauthor{Machado18b}~(\citeyear{Machado18b}), we use the auxiliary task of predicting the next observation, learned with the architecture proposed by \citeauthor{Oh15}~(\citeyear{Oh15}), which is depicted as the top layers in Figure~\ref{fig:network}. The loss we minimize for this last part of the network is 

The overall loss minimized by the network is 

The last step in describing our algorithm is to define , the intrinsic reward we use to encourage exploration. As in Sarsa+SR, we choose the exploration bonus to be the inverse of the -norm of the vector of successor features of the current state. That is,

where  denotes the successor features of state  parametrized by . The exploration bonus comes from the same intuition presented in the previous section (we observed in preliminary experiments not discussed here that DQN performs better when dealing with positive rewards). 

A complete description of the network architecture is available in Figure~\ref{fig:detailed_network}, which is at the end of the paper to allow the reader to first focus on the main concepts of the proposed idea. We initialize our network the same way \citeauthor{Oh15}~(\citeyear{Oh15}) does. We use Xavier initialization~\cite{Glorot10} in all layers except the fully connected layers around the element-wise multiplication denoted by , which are initialized uniformly with values between  and . 

\section{Evaluation of Exploration in Deep RL}
\label{sec:evaluation}

We evaluated our algorithm on the Arcade Learning Environment~\cite{Bellemare13}. Following \citeauthor{Bellemare16}'s~(\citeyear{Bellemare16}) taxonomy, we focused on the Atari 2600 games with sparse rewards that pose hard exploration problems. They are: \textsc{Freeway, Gravitar, Montezuma's Revenge, Private Eye, Solaris}, and \textsc{Venture}.\footnote{The code used to generate the reported results is available at:\\
\url{https://github.com/mcmachado/count_based_exploration_sr/tree/master/function_approximation}.}


We used the evaluation protocol proposed by~\citeauthor{Machado18a}~(\citeyear{Machado18a}). The reported results are the average over 10 seeds after 100 million frames. We evaluated our agents in the stochastic setting (sticky actions, ) using a frame skip of  with the full action set (). The agent learns from raw pixels i.e., it~uses~the~game~screen~as~input.

Our results were obtained with the algorithm described in Section~\ref{sec:deep_sr}. We set  after a rough sweep over values in the game \textsc{Montezuma's Revenge}. We annealed  in DQN's -greedy exploration over the first million steps, starting at  and stopping at  as done by \citeauthor{Bellemare16}~(\citeyear{Bellemare16}). We trained the network with RMSprop with a step-size of , an  value of , and a decay~ of~, which are the standard parameters for training DQN~\cite{Mnih15}. The discount factor, , is set to , and , , . The weights  , , and  were set so that the loss functions would be roughly at the same scale. All other parameters are the same as those used by \citeauthor{Mnih15}~(\citeyear{Mnih15}) and \citeauthor{Oh15}~(\citeyear{Oh15}).

\subsection{Overall Performance and Baselines}

Table~\ref{tab:results_ale} summarizes the results after 100 million frames. The performance of other algorithms is also provided for reference. Notice we are reporting learning performance for all algorithms instead of the maximum scores achieved by the algorithm. We use the superscript  to distinguish between the algorithms that use MMC from those that do not. When comparing our algorithm, DQN+SR, to DQN we can see how much our approach improves over the most traditional baseline. By comparing our algorithm's performance to \textsc{DQN}~\cite{Bellemare16} and \textsc{DQN}~\cite{Ostrovski17} we compare our algorithm to established baselines for exploration that are closer to our method. By comparing our algorithm's performance to Random Network Distillation~(RND; \citeauthor{Burda19} \citeyear{Burda19}) we compare our algorithm to the most recent paper in the field with state-of-the-art performance. Finally, we also evaluate the impact of the proposed exploration bonus by comparing our algorithm to DQN, which uses the same number of parameters our network uses (i.e., filter sizes, stride, and number of nodes), but without the additional modules (next state prediction and successor representation) and without the intrinsic reward bonus. We do this by setting .


We can clearly see that our algorithm achieves scores much higher than those achieved by DQN, which struggles in games that pose hard exploration problems.  When comparing our algorithm to \textsc{DQN} and \textsc{DQN} we observe that, on average, DQN+SR at least matches the performance of these algorithms while being simpler by not requiring a density model. Instead, our algorithm requires the SR, which is domain-independent as it is already defined for every problem since it is a component of the value function estimates, as discussed in Section~\ref{sec:background}. Finally, DQN+SR also outperforms RND~\cite{Burda19} when it is trained for 100 million frames.\footnote{DQN+SR outperforms \textsc{DQN} in five out of six games, it outperforms RND in four out of five games, and its performance is comparable to \textsc{DQN}'s performance.} Importantly, RND, when trained for 2 billion frames, is currently considered to be the state-of-the-art approach for exploration in Atari 2600 games. Recently \citeauthor{Taiga19} (\citeyear{Taiga19}) evaluated several exploration algorithms, including~those~we~use as baselines, and they have shown that, in these games, their performance at 100 million frames is predictive of their performance at one billion frames.

Finally, the comparison between DQN+SR and DQN shows that the provided exploration bonus has a big impact in the game \textsc{Montezuma's Revenge}, which is probably known as the hardest game among those we used in our evaluation, and the only game where agents do not learn how to achieve scores greater than zero with random exploration. Interestingly, the change in architecture and the use of MMC leads to a big improvement in games such as \textsc{Gravitar} and \textsc{Venture}, which we cannot fully explain. However, because the change in architecture does not have any effect in \textsc{Montezuma's Revenge}, it seems that the proposed exploration bonus is essential in games with very sparse rewards.

\subsection{Evaluating the Impact of the Auxiliary Task}

While the results depicted in Table~3 allow us to see the benefit of using an exploration bonus derived from the SR, they do not inform us about the impact of the auxiliary task in the results. The experiments in this section aim at addressing this issue. We focus on \textsc{Montezuma's Revenge} because it is the game where the problem of exploration is maximized, with most algorithms not being able to do anything without an exploration bonus.

The first question we asked was whether the \emph{auxiliary task was necessary} in our algorithm. We evaluated this by dropping the reconstruction module from the network to test whether the initial random noise generated by the SR is enough to drive representation learning. It is not. When dropping the auxiliary task, the average performance of this baseline over 4 seeds in \textsc{Mont. Revenge} after  million frames was  points ( = ; min:~, max:~). As comparison, our algorithm obtains  points ( = , min: , max: ). These results suggest that auxiliary tasks are necessary for our method to perform well.

We also evaluated whether the \emph{auxiliary task was sufficient} to generate the results we observed. To do so we dropped the SR module and set  to evaluate whether our exploration bonus was actually improving the agent's performance or whether the auxiliary task was doing it. The exploration bonus seems to be essential. When dropping the exploration bonus and the SR module, the average performance of this baseline over 4 seeds in \textsc{Montezuma's Revenge} after  million frames was  points ( = ; min:~, max:~). Again, clearly, the auxiliary task is not a sufficient condition for the performance we report. The reported results use the same parameters as before. 

Thus, while it is hard to completely disentangle the impact of the different components of DQN+SR (e.g., the exploration bonus, learning the SR, the auxiliary task), the comparisons in Table~\ref{tab:results_ale} and the results in this section suggest that the exploration bonus we introduced is essential for our approach to achieve state-of-the-art performance.

\subsection{Evaluating the Impact of Using Different P-Norms}

To further understand the different nuances behind the idea that the norm of the successor representation can be used to generate an exploration bonus, we also asked the question of whether this is true only for the -norm of the SR. It is often said, for example, that the -norm is smoother, and thus might be more amenable to the training of neural networks.

For the function approximation case, DQN+SR when using the -norm has a performance comparable to DQN+SR when using the -norm of the SR to generate its exploration bonus ( is normalized with the respective norm). The actual performance of both approaches in the Atari 2600 games we used in the previous experiment is available in  Table~\ref{tab:mismatch_atari}. We followed the same evaluation protocol described before, averaging the performance of DQN+SR with the -norm over 10 runs. The parameter  is the only parameter not shared by both algorithms. While  when using the -norm of the SR,  when using the -norm of the SR. 

We also revisited the results presented in Section~\ref{sec:model_free_tabular} to evaluate, in the tabular case, the impact of the different norms in Sarsa+SR. We swept over all the parameters, as previously described. The results reported for Sarsa+SR when using the -norm of the SR are the average over 100 runs. The actual numbers are available in Table~\ref{tab:mismatch_tabular}. As before, it seems that it does not make much difference which norm of the SR we use (-norm or the -norm). The fact that these results are so close might suggest that the idea of using the norm of the SR for exploration is quite general, with the -norm of the SR being effective for more than one value of . Recall that  for any finite vector .

\begin{table}[t]
\centering
\caption{Performance of the proposed algorithm, DQN+SR, when using the -norm and -norm of the SR to generate the exploration bonus. Standard~deviation is reported between parentheses. See text for~details.}  \label{tab:mismatch_atari}
\footnotesize
  \begin{tabular}{ l | r l | r l}
  &\multicolumn{2}{| c }{-norm} &\multicolumn{2}{| c }{-norm}\\ \hline
  \textsc{Freeway}                & 29.4    &(0.1)      &29.5   &(0.1)   \\ \hdashline[0.5pt/2pt]
  \textsc{Gravitar}               & 457.4   &(120.3)    &430.3  &(109.4) \\ \hdashline[0.5pt/2pt]
  \textsc{Mont. Rev.}             & 1395.4  &(1121.8)   &1778.6 &(903.6) \\ \hdashline[0.5pt/2pt]
  \textsc{Private Eye}            & 104.4   &(50.4)     &99.1   &(1.8)   \\ \hdashline[0.5pt/2pt]
  \textsc{Solaris}                & 1890.1  &(163.1)    &2155.7 &(398.3) \\ \hdashline[0.5pt/2pt]
  \textsc{Venture}                & 1348.5  &(56.5)     &1241.8 &(236.0) \\
  \end{tabular} 
\end{table}

\begin{table}[t]
\centering
\caption{Performance of Sarsa+SR when using the -norm and -norm of the SR to generate the exploration bonus. A 95\% confidence interval is reported between parentheses.}  \label{tab:mismatch_tabular}
\footnotesize
  \begin{tabular}{ l | r l | r l}
  &\multicolumn{2}{| c }{-norm} &\multicolumn{2}{| c }{-norm}\\ \hline
  \!\!\! \textsc{RiverSwim}\!\!  & \!\!\!      &\!\!\!\!\!\!()\!\!      & \!\!\!    &\!\!\!\!\!\!()   \\ \hdashline[0.5pt/2pt]
	  \!\!\! \textsc{SixArms}  \!\!  & \!\!\!      &\!\!\!\!\!\!()\!\!   & \!\!\!        &\!\!\!\!\!\!() \\
  \end{tabular} 
\end{table}

\section{Related Work}

\begin{table*}[t]
\centering
\caption{Parameter settings that led to the reported performance in \textsc{RiverSwim} and \textsc{SixArms}.}\label{tab:parameters_tabular}
\small{
  \begin{tabular}{ l | c | c | c | c | c | c | c | c | c | c }
                                                        &\multicolumn{5}{| c }{\textsc{RiverSwim}} &\multicolumn{5}{| c }{\textsc{SixArms}} \\
    Algorithm                                           &  &  &  &      &   &  &  &  &      &  \\ \hline
    Sarsa                                               &   & -      & -                    & -           &  &    & -      & -                    & -           &       \\ \hdashline[0.5pt/2pt]
    Sarsa+SR (w/ -norm)      &     &   &              &        &   &     &  &                 &   &       \\ \hdashline[0.5pt/2pt]
    Sarsa+SR (w/ -norm)      &     &   &              &        &   &     &  &                 &    &
  \end{tabular}
}
\end{table*}

\begin{figure*}[t]
    \centering
    \includegraphics[width=0.7\textwidth]{architecture}
    \caption{Neural network architecture used by our algorithm when learning to play Atari 2600 games.}\label{fig:detailed_network}
\end{figure*}

There are multiple algorithms in the tabular, model-based case, with guarantees about their performance in terms of regret bounds (e.g., \citeauthor{Osband16b} \citeyear{Osband16b}) or sample-complexity (e.g., \citeauthor{Brafman02} \citeyear{Brafman02}; \citeauthor{Kearns02} \citeyear{Kearns02}; \citeauthor{Strehl08} \citeyear{Strehl08}). \textsc{RiverSwim} and \textsc{SixArms} are domains traditionally used when evaluating these algorithms. In this paper we introduced a model-free algorithm that performs particularly well in these domains. We also introduced a model-based algorithm that performs as well as some of these algorithms with theoretical guarantees. Among these algorithms, \textsc{R-Max} is the closest approach to ours. As \textsc{R-Max}, the algorithm presented in Section~\ref{sec:theory} augments the state-space with an imaginary state and encourages the agent to visit that state, implicitly reducing the algorithm's uncertainty. However, \textsc{R-Max} deletes the transition to this imaginary state once a state has been visited a given number of times. Ours, on the other hand, lets the probability of visiting this imaginary state vanish with additional~visitations. Importantly, notice that it is not clear how to apply traditional algorithms such as \textsc{R-Max} and E to large domains where function approximation~is~required.

Conversely, there are not many model-free approaches with proven sample-complexity bounds (e.g., \citeauthor{Strehl06} \citeyear{Strehl06}), but there are multiple model-free algorithms for exploration that actually work in large domains~(e.g., \citeauthor{Bellemare16} \citeyear{Bellemare16}; \citeauthor{Ostrovski17} \citeyear{Ostrovski17}; \citeauthor{Plappert18} \citeyear{Plappert18}; \citeauthor{Burda19} \citeyear{Burda19}). Among these algorithms, the use of pseudo-counts through density models is the closest to ours~\cite{Bellemare16,Ostrovski17}. Inspired by those papers we used the mixed Monte-Carlo return as a target in the update rule. In Section~\ref{sec:evaluation} we showed that our algorithm at least matches these approaches while being simpler by not requiring a density model. Importantly, \citeauthor{Martin17}~(\citeyear{Martin17}) had already shown that counting activations of fixed, handcrafted features in Atari 2600 games leads to good exploration behavior. Nevertheless, by using the SR we are not only counting \emph{learned} features but we are also implicitly capturing the induced transition dynamics.

\section{Conclusion}

RL algorithms tend to have high sample complexity, which often prevents them from being used in the real-world. Poor exploration strategies is one of the reasons for this high sample-complexity. Despite all of its shortcomings, uniform random exploration is, to date, the most commonly used approach for exploration. This is mainly due to the fact that most approaches for tackling the exploration problem still rely on domain-specific knowledge (e.g., density models, handcrafted features), or on having an agent learn a perfect model of the environment. In this paper we introduced a general method for exploration in RL that implicitly counts state (or feature) visitation in order to guide the exploration process. It is compatible with representation learning and the idea can also be adapted to be applied to large domains.

This result opens up multiple possibilities for future work. Based on the results presented in Section~\ref{sec:theory}, for example, we conjecture that the substochastic successor representation can be actually used to generate algorithms with PAC-MDP bounds (e.g., one could replace explicit state visitation counts by the norm of the SSR in traditional algorithms). Investigating to what extent different auxiliary tasks impact the algorithm's performance, and whether simpler tasks such as predicting feature activations or parts of the input~\cite{Jaderberg17} are effective is also worth studying. Finally, it might be interesting to further investigate the connection between representation learning and exploration, since it is also known that better representations can lead to faster exploration~\cite{Jiang17}.

\section*{Acknowledgements}

The authors would like to thank Jesse Farebrother for the initial implementation of DQN used in this paper, Georg Ostrovski for the discussions and for providing us the exact results we report for \textsc{DQN} and \textsc{DQN}, and Yuri Burda for providing us the data we used to compute the performance we report for RND in Atari 2600 games. We would also like to thank Carles Gelada, George Tucker and Or Sheffet for useful discussions, as well as the anonymous reviewers for their feedback. This work was supported by grants from Alberta Innovates Technology Futures and the Alberta Machine Intelligence Institute (Amii). Computing resources were provided by Compute Canada through CalculQu\'ebec. Marlos C. Machado performed this work while at the University of Alberta.

\bibliographystyle{aaai}
\bibliography{refs}

\end{document}
