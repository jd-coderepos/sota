\documentclass[12pt]{article} 
\DeclareMathAlphabet{\mathbbmsl}{U}{bbm}{m}{sl}
\usepackage{graphicx}
\usepackage{enumerate} 
\usepackage{algorithm}
\usepackage{fullpage} 
\usepackage{color}
\usepackage{palatino} 
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amssymb}
\newcommand{\genus}{\gamma}
\newcommand{\T}{\mathbbmsl{T}}
\newcommand{\F}{\mathbbmsl{F}}
\newcommand{\G}{\mathbbmsl{G}}
\newcommand{\II}{\mathbbmsl{I}}
\newcommand{\SSS}{\mathbbmsl{S}}
\newcommand{\U}{\mathbbmsl{U}}
\newcommand{\C}{\mathbbmsl{C}}
\newcommand{\V}{\textit{Node}}
\newcommand{\vv}{\textit{node}}
\newcommand{\N}{\textit{Nbr}}
\newcommand{\nn}{\textit{nbr}}
\newcommand{\D}{\textit{Offspring}}
\newcommand{\dd}{\textit{offspring}}
\newcommand{\xx}{\textit{hook}}

\newcommand{\picount}[1]{\#({#1},\pi)}
\newcommand{\func}[1]{{\mbox{\sc{#1}}}}
\newcommand{\ceiling}[1]{\left\lceil{#1}\right\rceil}
\newcommand{\floor}[1]{\left\lfloor{#1}\right\rfloor}
\newcommand{\code}[1]{\mbox{\rm code}_\pi({#1})}
\newcommand{\algo}[1]{\mbox{\rm encode}_\pi({#1})}
\newcommand{\bracket}[1]{\langle{#1}\rangle}
\newcommand{\setof}[1]{\left\{{#1}\right\}} 
\newcommand{\set}[2]{\left\{{#1}\mid{#2}\right\}} 
\newtheorem{fact}{Fact}
\newtheorem{claim}{Claim}
\newcounter{pcounter}
\newtheorem{lemma}{Lemma}[section]
\newtheorem{theorem}{Theorem}[section]
\newtheorem{corollary}{Corollary}[section]
\title{Linear-Time Compression of Bounded-Genus Graphs into
Information-Theoretically Optimal Number of Bits\thanks{Accepted to {\em SIAM Journal on Computing}. A 
preliminary version appeared in SODA~\cite{Lu02}.}}

\author{Hsueh-I Lu\thanks{Department of Computer Science and
    Information Engineering, National Taiwan University.  Address: 1
    Roosevelt Road, Section 4, Taipei 106, Taiwan, ROC.  Web:
    www.csie.ntu.edu.tw/hil/.  Email: hil@csie.ntu.edu.tw.
    Research supported in part by NSC grant 101--2221--E--002--062--MY3.
The author also holds joint appointments from the Graduate
    Institute of Networking and Multimedia and the Graduate Institute
    of Biomedical Electronics and Bioinformatics, National Taiwan
    University.}
}

\date{January 11, 2014}

\begin{document}
\maketitle 
\begin{abstract}
A {\em compression scheme}  for a class  of graphs consists of
an encoding algorithm  that computes a binary
string  for any given graph  in  and a
decoding algorithm  that recovers  from
.  A compression scheme  for  is {\em
  optimal} if both  and  run in
linear time and the number of bits of  for any
-node graph  in  is information-theoretically optimal to
within lower-order terms.  Trees and plane triangulations were the
only known nontrivial graph classes that admit optimal compression
schemes.  Based upon Goodrich's separator decomposition for planar
graphs and Djidjev and Venkatesan's planarizers for bounded-genus
graphs, we give an optimal compression scheme for any hereditary
(i.e., closed under taking subgraphs) class  under the premise
that any -node graph of  to be encoded comes with a
genus- embedding.  By Mohar's linear-time
algorithm that embeds a bounded-genus graph on a genus- surface,
our result implies that any hereditary class of genus- graphs
admits an optimal compression scheme.
For instance, our result yields the first-known optimal compression
schemes for planar graphs, plane graphs, graphs embedded on genus-
surfaces, graphs with genus  or less, -colorable directed plane
graphs, -outerplanar graphs, and forests with degree at most .
For non-hereditary graph classes, we also give a methodology for
obtaining optimal compression schemes. From this methodology, we give
the first known optimal compression schemes for triangulations of
genus- surfaces and floorplans.
\end{abstract}

\section{Introduction}
Compact representation of graphs are fundamentally important and
useful in many applications, including representing the meshes in
finite-element analysis, terrain models of GIS, and 3D models of
graphics~\cite{Rossignac99,Rossignac-edgebreaker,RossignacSS01,TaubinR98,SnoeyinkVK97,LopesTRSS02,SzymczakKR01,IsenburgS01}, VLSI
design~\cite{SahaS09,KrivogradTZ08}, designing compact routing tables
of computer
networks~\cite{Thorup04,GavoilleH99,Lu10,Peleg00,Gavoille00,ThorupZ01,AbrahamMR09,Chechik11,AgarwalGH11,GavoilleS11},
and compressing the link structure of the
Internet~\cite{BroderKMPRSTW00,AdlerM01,SuelY01,AsanoMN09,AnhM10,ClaudeN10}.
Let  be a class of graphs.  Let  denote the
number of distinct -node graphs in .  The
information-theoretically optimal number of bits to encode an -node
graph in  is .\footnote{All
  logarithms throughout the paper are to the base of two.}  For
instance, if  is the class of rooted trees, then
 and
; if  is the class of plane
triangulations, then ~\cite{Tutte62}.
A {\em compression scheme}  for  consists of an encoding
algorithm  that computes a binary string
 for any given graph  in  and a decoding
algorithm  that recovers graph  from
.  A compression scheme  for a graph class 
with  is {\em optimal} if the following
three conditions hold.
\begin{enumerate}[\em {Condition}~C1:]
\addtolength{\itemsep}{-0.5\baselineskip}
\item 
\label{condition:c1}
The running time of algorithm  is linear in the size of
.

\item 
\label{condition:c2}
The running time of algorithm  is linear
in the bit count of .

\item 
\label{condition:c3}
For all positive constants  with , the bit count of  for an -node
graph  in  is no more than .
\end{enumerate}
Condition~C\ref{condition:c3} basically says that the bit count of
 is information-theoretically optimal to within
lower-order terms.  Although there has been considerable work on
compression schemes, trees (see
e.g.,~\cite{MunroR01,Jacobson89,LuY08,BenoitDMRRR05}) and plane
triangulations~\cite{PoulalhonS06} were the only known nontrivial
graph classes that admit optimal compression schemes.
A graph class is {\em hereditary} if it is closed under taking
subgraphs.  Below is the main result of the paper.
\begin{theorem}
\label{theorem:theorem1}
Any hereditary class  of graphs with 
 admits an optimal compression scheme, as long
as each input -node graph in  to be encoded comes with a
genus- embedding.
\end{theorem}
\noindent
By Theorem~\ref{theorem:theorem1} and Mohar's linear-time genus-
embedding algorithm for genus- graphs~\cite{Mohar99,KawarabayashiMR08}
(see Lemma~\ref{lemma:mohar}), any hereditary class of genus-
graphs admits an optimal compression scheme.
For instance, our result yields the first-known optimal compression
schemes for planar graphs, plane graphs, graphs embedded on genus-
surfaces, graphs with genus  or less, -colorable directed plane
graphs, -outerplanar graphs, and forests with degree at most .
For non-hereditary graph classes, we also give an extension (see
Corollary~\ref{corollary:corollary1}) of
Theorem~\ref{theorem:theorem1}.  As summarized in the following
theorem, we show 
two classes of genus- graphs whose optimal
compression schemes are obtainable via this extension, where the class
of floorplans is defined in related work below.
\begin{theorem}
\label{theorem:theorem2}
The following
classes of graphs admit optimal compression schemes:
\begin{enumerate}
\addtolength{\itemsep}{-0.5\baselineskip}
\item
\label{thm2:triangulation}
Triangulations of a genus- surface for any integral constant .
\item 
\label{thm2:floorplan}
Floorplans.
\end{enumerate}
\end{theorem}

\paragraph{Technical overview}
The kernel of the proof of Theorem~\ref{theorem:theorem1} is a
linear-time disjoint partition  of an -node graph
 embedded on a genus-
surface.\footnote{Precisely, the disjoint partition 
  of the edges of the embedded graph  in the proof of
  Theorem~\ref{theorem:theorem1} is ,
  where  is both (i) a -separation  of an
  arbitrary triangulation  of  and (ii) a refinement of the
  -separation  of .}  Let
 denote .  Based upon Goodrich's
separator decomposition of planar graphs~\cite{Goodrich95} and Djidjev
and Venkatesan's planarizer~\cite{DjidjevV95}, partition
 satisfies the following conditions, where  is
the number of nodes of  and  is the number of times that the
nodes of  are duplicated in some  with :\footnote{As
  a matter of fact, in our construction, all duplicated nodes of 
  with  belong to .}  (a)~,
(b)~ holds for each ,
(c)~, and~(d)~.  By Condition~(a),  can be encoded in
 bits. By Conditions~(b) and (c), the information required to
recover  from  can be encoded into  bits
(see Lemma~\ref{lemma:recovery}).  By Condition~(d), we have
.  Therefore, the disjoint partition reduces
the problem of encoding an -node graph in  to the problem of
encoding a -node graph in .  Applying such a
reduction for one more level, it remains to encode a
-node graph in  into an
information-theoretically optimal number of bits, which can be
resolved by the standard technique~(see,
e.g.,~\cite{HeKL00,MunroR01,PettieR02}) of precomputation tables (see
Lemma~\ref{lemma:basis}).

\paragraph{Related work}
The compression scheme of Tur\'{a}n~\cite{turan84} encodes an -node
plane graph that may have self-loops into  bits.\footnote{For
  brevity, we omit all lower-order terms of bit counts in our
  discussion of related work.}  Keeler and Westbrook~\cite{KeelerW95}
improved this bit count to .  They also gave compression
schemes for several families of plane graphs. In particular, they used
 bits for plane triangulation, and  bits for connected
plane graphs free of self-loops and degree-one nodes.  For plane
triangulations, He et~al.~\cite{HeKL99} improved the bit count to
.  For triconnected plane graphs, He et~al.~\cite{HeKL99} also
improved the bit count to at most  bits.  This bit count was
later reduced to at most  by
Chuang et~al.~\cite{ChuangGHKL98}.  For any given -node graph 
embedded on a genus- surface, Deo and Litow~\cite{DeoL98} showed an
an -bit
encoding for . These compression schemes all take linear time for
encoding and decoding, but Condition~C\ref{condition:c3} does not hold
for them.  The compression schemes of He et~al.~\cite{HeKL00}
(respectively, Blelloch et~al.~\cite{BlellochF10}) for planar graphs,
plane graphs, and plane triangulations (respectively, separable
graphs) satisfies Condition~C\ref{condition:c3}, but their encoding
algorithms require  time on -node graphs.


\begin{figure}[t]
\centerline{\begin{picture}(0,0)\includegraphics{soda-fig1.eps}\end{picture}\setlength{\unitlength}{3947sp}\begingroup\makeatletter\ifx\SetFigFont\undefined \gdef\SetFigFont#1#2#3#4#5{\reset@font\fontsize{#1}{#2pt}\fontfamily{#3}\fontseries{#4}\fontshape{#5}\selectfont}\fi\endgroup \begin{picture}(5944,1743)(937,-1991)
\put(6076,-1936){\makebox(0,0)[lb]{\smash{{\SetFigFont{10}{12.0}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}(c)}}}}}
\put(1726,-1936){\makebox(0,0)[lb]{\smash{{\SetFigFont{10}{12.0}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}(a)}}}}}
\put(3976,-1936){\makebox(0,0)[lb]{\smash{{\SetFigFont{10}{12.0}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}(b)}}}}}
\end{picture} }
\caption{Three floorplans with  nodes,  internal faces, and
   edges. Floorplans~(a) and~(b) are equivalent, floorplans~(b)
  and~(c) are not equivalent.}
\label{figure:floorplan}
\end{figure}

Floorplanning is a fundamental issue in circuit
layout~\cite{YaoCCG03,GuoTCY01,MoffittRMP08,LinC05,Kajitani08,Young08,FengM06,BanerjeeSB09,ChenC06,LiSC10,DasguptaS01,LaiL88,TTSS91,MMH82,SahaS09,AgnihotriOM10}.
Motivated by VLSI physical design, various representations of
floorplans were proposed~\cite{ZhuangSJK03,ZhaoLKS04,FujimakiT07}.
Designing a floorplan to meet a certain criterion is NP-complete in
general~\cite{L83,H88,WKC88}, so heuristic techniques such as
simulated annealing~\cite{WL89,WLL88,ChenC06} are practically
useful. The length of the encoding affects the size of the search
space.  A {\em floorplan}, which is also known as {\em rectangular
  drawing}, is a division of a rectangle into rectangular faces using
horizontal and vertical line segments.  Two floorplans are {\em
  equivalent} if they have the same adjacency relations and relative
positions among the nodes.  For instance,
Figure~\ref{figure:floorplan} shows three floorplans: Floorplans (a)
and (b) are equivalent. Floorplans (b) and (c) are not equivalent.
Let  be the input -node floorplan.  Under the conventional
assumption that each node of , other than the four corner nodes,
has exactly three neighbors (see, e.g.,~\cite{He99,YS93}), one can
verify that  has  faces and  edges.  Yamanaka and
Nakano~\cite{YN06} showed how to encode  into  bits.
Chuang~\cite{Chuang08} reduced the bit count to .  Takahashi
et~al.~\cite{TakahashiFI09} further reduced bit count to .  All
these compression schemes for floorplans satisfy
Conditions~C\ref{condition:c1} and~C\ref{condition:c2}, but not
Condition~C\ref{condition:c3}.  Takahashi et~al.~\cite{TakahashiFI09}
also showed that the number of distinct -node floorplans is no more
than . Therefore, our
Theorem~\ref{theorem:theorem2}(\ref{thm2:floorplan}) encodes an -node
floorplan into at most  bits.

For applications that require query support,
Jacobson~\cite{Jacobson89} gave a -bit encoding for a
connected and simple planar graph  that supports traversal in
 time per node visited. Munro and
Raman~\cite{MunroR97} improved this result and gave schemes to encode
binary trees, rooted ordered trees, and planar graphs. For a general
-node -edge planar graph , they used  bits while
supporting adjacency and degree queries in  time. Chuang
et~al.~\cite{ChuangGHKL98} reduced this bit count to
 for any constant  with the same query
support. The bit count can be further reduced if only -time
adjacency queries are supported, or if  is simple, triconnected or
triangulated~\cite{ChuangGHKL98}.  Chiang et~al.~\cite{ChiangLL05}
reduced the number of bits to .  Yamanaka and
Nakano~\cite{YamanakaN10} showed a -bit encoding for plane
triangulations with query support.  The succinct encodings of Blandford
et~al.~\cite{BlandfordBK03} and Blelloch et~al.~\cite{BlellochF10} for
separable graphs support queries.  Yamanaka et~al.~\cite{YamanakaN08}
also gave a compression scheme for floorplans with query support.
For labeled planar graphs, Itai and Rodeh~\cite{ItaiR82} gave an
encoding of  bits.  For unlabeled general
graphs, Naor~\cite{Naor90} gave an encoding of 
bits.
For certain graph families, Kannan et~al.~\cite{KNR92} gave schemes
that encode each node with  bits and support -time testing of adjacency between two nodes. 
Galperin and Wigderson~\cite{GW83}
and Papadimitriou and Yannakakis~\cite{PH86.encode} investigated
complexity issues arising from encoding a graph by a small circuit
that computes its adjacency matrix.
Related work on various versions of succinct graph representations can
be found
in~\cite{MunroRS01,ArikatiMZ97,FederM95,GrossiL98,GavoilleH:k-page,Patrascu08,SadakaneN10,FarzanRR09,FarzanM08a,FarzanM08b,BarbayAHM07,kaot93.joa}
and the references therein.

\paragraph{Outline}
The rest of the paper is organized as follows.
Section~\ref{section:prelim} gives the preliminaries.
Section~\ref{section:separation} shows our algorithm for computing
graph separations.  Section~\ref{section:compression} gives our
optimal compression scheme for hereditary graph classes.
Section~\ref{section:extend} shows a methodology for obtaining optimal
compression schemes for non-hereditary graph classes and applies this
methodology on triangulations of genus- graphs
and floorplans.  Section~\ref{section:conclude} concludes the paper
with a couple of open questions.

\section{Preliminaries}
\label{section:prelim}

\subsection{Segmentation prefix}
Let  denote the number of bits of binary string .  A binary
string  is a {\em segmentation prefix} of binary strings
 if (a) it takes  time to
compute  from  and (b) given the concatenation of
, it takes  time to
recover all  with .

\begin{lemma}[See, e.g.,~\cite{BellCW90,Elias75}]
\label{lemma:concat}
Any binary strings  with  have a segmentation
prefix with  bits.
\end{lemma}

\begin{lemma}
\label{lemma:unary-concat}
Any binary strings  have an -bit segmentation prefix, where .
\end{lemma}

\begin{proof}
Let  be the concatenation of .  If ,
let  be the -bit binary string with exactly  copies of
-bits such that the -th bit of  is  if and only if
 holds for some .  Otherwise,
let  store the -bit numbers 
for all .  Let  be the segmentation prefix of 
and  as ensured by Lemma~\ref{lemma:concat}.  The concatenation of
 and  is a segmentation prefix  of 
with  bits.  The lemma is proved.
\end{proof}

\noindent
For the rest of the paper, let  denote the
concatenation of , where  is the segmentation
prefix of  as ensured by
Lemma~\ref{lemma:unary-concat}.

\subsection{Precomputation table}

Unless clearly stated otherwise, all graphs throughout the paper are
simple, i.e., having no multiple edges or self-loops.  
Let  denote the cardinality of set .  Let  consist of
the nodes in graph  and let .  For any subset 
of , let  denote the subgraph of  induced by~ and
let  denote the subgraph of  obtained by deleting 
and their incident edges.  Two disjoint subsets  and  of
 are {\em adjacent} in  if there is an edge  of 
with  and .  For any subset  of , let
 consist of the nodes in  that are adjacent
to  in  and let .  A {\em connected
  component} of graph  is a maximal subset  of  such that
 is connected.

\begin{lemma}
\label{lemma:basis}
Let  be a graph class satisfying .
Given positive integers  and~ with , it takes overall  time to compute (i) a labeling
 and a -bit binary string 
for each distinct graph  with at most  nodes and (ii) an
-bit string  such that the following
statements hold.
\begin{enumerate}
\addtolength{\itemsep}{-0.5\baselineskip}
\item 
\label{basis:1}
Given any graph  with , it takes 
time to obtain  and  from
.

\item  
\label{basis:2}
Given  for any graph  with , it takes  time to obtain  and 
from .
\end{enumerate}
\end{lemma}

\begin{proof}
Straightforward by .
\end{proof}



\subsection{Separator decomposition of planar graphs}

\begin{figure}[t]
\centerline{\begin{picture}(0,0)\includegraphics{soda-fig2.eps}\end{picture}\setlength{\unitlength}{3947sp}\begingroup\makeatletter\ifx\SetFigFont\undefined \gdef\SetFigFont#1#2#3#4#5{\reset@font\fontsize{#1}{#2pt}\fontfamily{#3}\fontseries{#4}\fontshape{#5}\selectfont}\fi\endgroup \begin{picture}(4390,1931)(412,-2591)
\put(1763,-1096){\makebox(0,0)[lb]{\smash{{\SetFigFont{9}{10.8}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}1}}}}}
\put(488,-1996){\makebox(0,0)[lb]{\smash{{\SetFigFont{9}{10.8}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}4}}}}}
\put(788,-1996){\makebox(0,0)[lb]{\smash{{\SetFigFont{9}{10.8}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}5}}}}}
\put(1688,-1996){\makebox(0,0)[lb]{\smash{{\SetFigFont{9}{10.8}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}7}}}}}
\put(2288,-1996){\makebox(0,0)[lb]{\smash{{\SetFigFont{9}{10.8}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}8}}}}}
\put(638,-1546){\makebox(0,0)[lb]{\smash{{\SetFigFont{9}{10.8}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}3}}}}}
\put(2138,-1546){\makebox(0,0)[lb]{\smash{{\SetFigFont{9}{10.8}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}6}}}}}
\put(1351,-2536){\makebox(0,0)[lb]{\smash{{\SetFigFont{9}{10.8}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}(a)}}}}}
\put(3676,-2536){\makebox(0,0)[lb]{\smash{{\SetFigFont{9}{10.8}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}(b)}}}}}
\put(4388,-1546){\makebox(0,0)[lb]{\smash{{\SetFigFont{9}{10.8}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}6}}}}}
\put(3038,-1546){\makebox(0,0)[lb]{\smash{{\SetFigFont{9}{10.8}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}5}}}}}
\put(3938,-946){\makebox(0,0)[lb]{\smash{{\SetFigFont{9}{10.8}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}3}}}}}
\put(3338,-946){\makebox(0,0)[lb]{\smash{{\SetFigFont{9}{10.8}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}1}}}}}
\put(3638,-946){\makebox(0,0)[lb]{\smash{{\SetFigFont{9}{10.8}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}2}}}}}
\put(4088,-1546){\makebox(0,0)[lb]{\smash{{\SetFigFont{9}{10.8}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}0}}}}}
\put(4538,-2146){\makebox(0,0)[lb]{\smash{{\SetFigFont{9}{10.8}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}8}}}}}
\put(3938,-2146){\makebox(0,0)[lb]{\smash{{\SetFigFont{9}{10.8}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}7}}}}}
\put(3338,-2146){\makebox(0,0)[lb]{\smash{{\SetFigFont{9}{10.8}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}4}}}}}
\put(1388,-1096){\makebox(0,0)[lb]{\smash{{\SetFigFont{9}{10.8}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}0}}}}}
\put(1013,-1096){\makebox(0,0)[lb]{\smash{{\SetFigFont{9}{10.8}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}2}}}}}
\end{picture} }
\caption{(a) A -node plane graph .
 (b) A separator decomposition  of .}
\label{figure:goodrich}
\end{figure}

Sets  form a {\em disjoint partition} of set  if
 are pairwise disjoint and .
A subset  of  is a {\em separator} of graph  with respect
to  and  if (1) , , and  form a disjoint
partition of , (2)  and  are not adjacent in , (3)
, and (4)
.  A {\em separator
  decomposition}~\cite{BhattL84} of  is a rooted binary tree 
on a disjoint partition of  such that the following two
statements hold, where ``nodes'' specify elements of  and
``vertices'' specify elements of . Statement~1: Each leaf
vertex of  consists of a single node of . Statement~2: Each
internal vertex  of  is a separator of  with respect
to  and , where  and  are the child
vertices of  in  and  (respectively,  and
) is the union of all the vertices in the subtree of 
rooted at  (respectively,  and ).  See
Figure~\ref{figure:goodrich} for an illustration.

\begin{lemma}[Goodrich~\cite{Goodrich95}]
\label{lemma:goodrich}
It takes  time to compute a separator decomposition for any given -node planar graph.
\end{lemma}

\subsection{Planarizers for non-planar graphs}
The {\em genus} of a graph  is the smallest integer 
such that  can be embedded on an orientable surface with 
handles without edge crossings~\cite{Gross87}. For example, the genus
of a planar graph is zero.
By Euler's formula (see, e.g.,~\cite{GilbertHT84}), an -node
genus- graph has  edges.  Determining the genus of a
general graph is NP-complete~\cite{Thomassen89}, but
Mohar~\cite{Mohar99} showed that it takes linear time to determine
whether a graph is of genus  for any . Mohar's algorithm is
simplified by Kawarabayashi et~al.~\cite{KawarabayashiMR08}.

\begin{lemma}[Mohar et al.~\cite{Mohar99,KawarabayashiMR08}]
\label{lemma:mohar}
It takes  time to compute a genus- embedding for any given
-node genus- graph.
\end{lemma}

Gilbert et~al.~\cite{GilbertHT84} gave an -time algorithm to
compute an -node separator of an -node genus-
graph, generalizing Lipton and Tarjan's classic separator theorem for
planar graphs~\cite{LiptonT79}. Our result relies on the following
planarization algorithm.

\begin{lemma}[Djidjev and Venkatesan~\cite{DjidjevV95}]
\label{lemma:2}
\label{lemma:djidjev}
Given an -node graph  embedded on a genus- surface, it takes
 time to compute a subset  of  with
 such that  is planar.
\end{lemma}

\section{Separation and refinement}
\label{section:separation}


\begin{figure}[t]
\centerline{\begin{picture}(0,0)\includegraphics{soda-fig3.eps}\end{picture}\setlength{\unitlength}{3947sp}\begingroup\makeatletter\ifx\SetFigFont\undefined \gdef\SetFigFont#1#2#3#4#5{\reset@font\fontsize{#1}{#2pt}\fontfamily{#3}\fontseries{#4}\fontshape{#5}\selectfont}\fi\endgroup \begin{picture}(6217,2077)(2539,-5066)
\put(6901,-4711){\makebox(0,0)[lb]{\smash{{\SetFigFont{9}{10.8}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(3376,-5011){\makebox(0,0)[lb]{\smash{{\SetFigFont{9}{10.8}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}(a)}}}}}
\put(7576,-3136){\makebox(0,0)[lb]{\smash{{\SetFigFont{9}{10.8}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(7726,-4711){\makebox(0,0)[lb]{\smash{{\SetFigFont{9}{10.8}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(5551,-3136){\makebox(0,0)[lb]{\smash{{\SetFigFont{9}{10.8}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(8401,-4711){\makebox(0,0)[lb]{\smash{{\SetFigFont{9}{10.8}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(8251,-3136){\makebox(0,0)[lb]{\smash{{\SetFigFont{9}{10.8}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(7051,-5011){\makebox(0,0)[lb]{\smash{{\SetFigFont{9}{10.8}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}(b)}}}}}
\put(6826,-3136){\makebox(0,0)[lb]{\smash{{\SetFigFont{9}{10.8}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(4051,-4711){\makebox(0,0)[lb]{\smash{{\SetFigFont{9}{10.8}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(5626,-4711){\makebox(0,0)[lb]{\smash{{\SetFigFont{9}{10.8}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(3526,-4711){\makebox(0,0)[lb]{\smash{{\SetFigFont{9}{10.8}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(2851,-4711){\makebox(0,0)[lb]{\smash{{\SetFigFont{9}{10.8}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(4351,-3661){\makebox(0,0)[lb]{\smash{{\SetFigFont{9}{10.8}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(3376,-3136){\makebox(0,0)[lb]{\smash{{\SetFigFont{9}{10.8}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\end{picture} }
\caption{(a) A -node plane graph with a separation
  .  (b) , , , and 
  form a disjoint partition of the edges of .}
\label{figure:subgraph}
\end{figure}

We say that  with  is a {\em separation} of
graph  if the following properties hold.
\begin{enumerate}[\em Property~S1:]
\addtolength{\itemsep}{-0.5\baselineskip}
\item 
\label{separation:1}
 form a disjoint partition of .
\item 
\label{separation:2}
Any two  and  with  are not adjacent
in . 
\setcounter{pcounter}{\theenumi}
\end{enumerate}
For instance, Figure~\ref{figure:subgraph}(a) shows a separation
 of graph  and Figure~\ref{figure:refinement}(a)
shows another separation  of .
For any subset  of , let  be the subgraph of 
induced by  excluding the edges of .  If
 is a separation of , then
 form a disjoint partition of the edges
of .  See Figures~\ref{figure:subgraph}(b)
and~\ref{figure:refinement}(b) for illustrations.
Let .  For any positive integer , let .  For notational brevity, for any
nonnegative integer , let

For a nonnegative integer , separation  of an
-node graph  is a {\em -separation} of  if the following
three properties hold.
\begin{enumerate}[\em Property~S1:]
\addtolength{\itemsep}{-0.5\baselineskip}
\setcounter{enumi}{\thepcounter}
\item 
\label{separation:3}
 and .

\item 
\label{separation:4}
 holds for each
.

\item
\label{separation:5}
.
\end{enumerate}
One can verify that  is a -separation of
.\footnote{The ``'' in Property~S\ref{separation:3} is
  redundant for . However, we need it so that  is a -separation of , since .}
\begin{figure}[t]
\centerline{\begin{picture}(0,0)\includegraphics{soda-fig4.eps}\end{picture}\setlength{\unitlength}{3947sp}\begingroup\makeatletter\ifx\SetFigFont\undefined \gdef\SetFigFont#1#2#3#4#5{\reset@font\fontsize{#1}{#2pt}\fontfamily{#3}\fontseries{#4}\fontshape{#5}\selectfont}\fi\endgroup \begin{picture}(7291,2578)(1936,-4991)
\put(2251,-4336){\makebox(0,0)[lb]{\smash{{\SetFigFont{9}{10.8}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(6151,-4111){\makebox(0,0)[lb]{\smash{{\SetFigFont{9}{10.8}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(3601,-4336){\makebox(0,0)[lb]{\smash{{\SetFigFont{9}{10.8}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(5251,-3811){\makebox(0,0)[lb]{\smash{{\SetFigFont{9}{10.8}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(4951,-4336){\makebox(0,0)[lb]{\smash{{\SetFigFont{9}{10.8}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(1951,-3811){\makebox(0,0)[lb]{\smash{{\SetFigFont{9}{10.8}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(3601,-4936){\makebox(0,0)[lb]{\smash{{\SetFigFont{9}{10.8}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}(a)}}}}}
\put(3601,-2536){\makebox(0,0)[lb]{\smash{{\SetFigFont{9}{10.8}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(7426,-4936){\makebox(0,0)[lb]{\smash{{\SetFigFont{9}{10.8}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}(b)}}}}}
\put(8626,-3361){\makebox(0,0)[lb]{\smash{{\SetFigFont{9}{10.8}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(2776,-3136){\makebox(0,0)[lb]{\smash{{\SetFigFont{9}{10.8}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(6001,-3361){\makebox(0,0)[lb]{\smash{{\SetFigFont{9}{10.8}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(7276,-3361){\makebox(0,0)[lb]{\smash{{\SetFigFont{9}{10.8}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(9001,-3811){\makebox(0,0)[lb]{\smash{{\SetFigFont{9}{10.8}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(7351,-3811){\makebox(0,0)[lb]{\smash{{\SetFigFont{9}{10.8}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(4726,-3136){\makebox(0,0)[lb]{\smash{{\SetFigFont{9}{10.8}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\end{picture} }
\caption{(a) Separation  is a refinement of
  separation . (b) Subgraphs , , and
   of .}
\label{figure:refinement}
\end{figure}
Let  and  be two separations of graph .
We say that  is a {\em
  refinement} of  if the following
three properties hold.
\begin{enumerate}[\em Property~R1:]
\addtolength{\itemsep}{-0.5\baselineskip}
\item 
\label{refine:1}
.

\item 
\label{refine:2}
For each index , there is an index  with  and .

\item
\label{refine:3}
For any indices , ,  with , if
, then .

\end{enumerate}
For instance, in Figure~\ref{figure:refinement}(a), 
 is a refinement of .
Below is the main lemma of the section.

\begin{lemma}
\label{lemma:lemma3.1}
Let  be a positive integer.  Let  be an -node connected graph
embedded on a genus- surface.  Given a
-separation  of , it takes  time to
compute a -separation  of  that is a refinement of
.
\end{lemma}

The proof of Lemma~\ref{lemma:lemma3.1} needs the following lemma, which
can be proved by Lemmas~\ref{lemma:goodrich} and~\ref{lemma:djidjev}.


\begin{lemma}
\label{lemma:lemma2.1}
Let  be a positive integer.  Given an -node graph  embedded
on a genus- surface, it takes  time to compute an
-node subset  of  such that each node
of  has degree at most  in  and each
connected component of  has at most  nodes.
\end{lemma}

\begin{proof}
We first apply Lemma~\ref{lemma:djidjev} to compute in  time an
-node subset  of  such that
 is planar.  We then apply Lemma~\ref{lemma:goodrich}
to compute in  time a separator decomposition  of
.  For each vertex  of , let  denote the
union of all the vertices in the subtree of  rooted at  and let
.  Let .  Let  consist of the nodes
of  with degree more than  in .  Let  be the union of
all the vertices  of  with .  Let .  By  and the definition of , each
connected component of  has at most  nodes.  By
, each node of  has degree at most
 in .  Since  has  edges,
.
It remains to show .  For each index
, let  consist of the vertices  of  with
.
By  and , each  is an internal vertex
of .  By definition of , we know that  and  are
disjoint for any two distinct elements  and  of ,
implying that  holds.  Since
 holds for each , we have
.  Since each 
is an internal vertex of ,  is a separator of .
Therefore,  holds for each vertex  in
.  We have .
The lemma is proved.
\end{proof}





\begin{algorithm}[t]
{
\begin{minipage}[t]{1cm}
\begin{tabbing}
\quad\=\quad\=\quad\=\quad\=\quad\=\quad\=\quad\=\kill
Let  and let all elements of  be initially unmarked.\\
For each , perform the following repeat-loop.\\
\>Repeat the following steps until all elements of  are marked.\\
\>\>Let  be an arbitrary node of  that is adjacent to some
unmarked element of .\\
\>\>Let  consist of the unmarked elements of  that are
adjacent to  in .\\
\>\>Let  be the elements
of  in clockwise order around  in .\\
\>\>Mark all  elements of .\\
\>\>Repeat the following four steps until .\\
\>\>\>Let  be the largest index with  and
.\\
\>\>\>Let .\\
\>\>\>Let  and .\\
\>\>\>Let .\\
Output  and .
\end{tabbing}
\end{minipage}
}
\caption{}
\label{algorithm:clustering}
\end{algorithm}

\begin{figure}[t]
\centerline{\begin{picture}(0,0)\includegraphics{soda-fig5.eps}\end{picture}\setlength{\unitlength}{3947sp}\begingroup\makeatletter\ifx\SetFigFont\undefined \gdef\SetFigFont#1#2#3#4#5{\reset@font\fontsize{#1}{#2pt}\fontfamily{#3}\fontseries{#4}\fontshape{#5}\selectfont}\fi\endgroup \begin{picture}(2494,2014)(787,-1887)
\put(1764,-1395){\makebox(0,0)[lb]{\smash{{\SetFigFont{9}{10.8}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}5}}}}}
\put(2361,-342){\makebox(0,0)[lb]{\smash{{\SetFigFont{9}{10.8}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}3}}}}}
\put(1765,-343){\makebox(0,0)[lb]{\smash{{\SetFigFont{9}{10.8}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}5}}}}}
\put(3113,-871){\makebox(0,0)[lb]{\smash{{\SetFigFont{9}{10.8}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}3}}}}}
\put(2167,-47){\makebox(0,0)[lb]{\smash{{\SetFigFont{9}{10.8}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(2414,-1823){\makebox(0,0)[lb]{\smash{{\SetFigFont{9}{10.8}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(972,-1817){\makebox(0,0)[lb]{\smash{{\SetFigFont{9}{10.8}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(1542,-563){\makebox(0,0)[lb]{\smash{{\SetFigFont{9}{10.8}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}2}}}}}
\put(861,-870){\makebox(0,0)[lb]{\smash{{\SetFigFont{9}{10.8}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}5}}}}}
\put(1242,-638){\makebox(0,0)[lb]{\smash{{\SetFigFont{9}{10.8}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}2}}}}}
\put(2367,-1394){\makebox(0,0)[lb]{\smash{{\SetFigFont{9}{10.8}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}3}}}}}
\put(2068,-1465){\makebox(0,0)[lb]{\smash{{\SetFigFont{9}{10.8}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}1}}}}}
\put(2661,-871){\makebox(0,0)[lb]{\smash{{\SetFigFont{9}{10.8}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}4}}}}}
\put(1457,-871){\makebox(0,0)[lb]{\smash{{\SetFigFont{9}{10.8}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}6}}}}}
\end{picture} }
\caption{An illustration for Algorithm~\ref{algorithm:clustering}.}
\label{figure:clustering}
\end{figure}



\begin{proof}[Proof of Lemma~\ref{lemma:lemma3.1}]
Suppose that  is the given -separation
.  Let  be the -time computable subset of
 ensured by Lemma~\ref{lemma:lemma2.1}.  We have
.  Let .  Let 
consist of the connected components of .  By
, each element of  has at most 
nodes.  By  and Properties~S\ref{separation:1}
and~S\ref{separation:2} of , each element of  is
contained by some  with .  For each
, let  consist of the elements  of  with
.  We run Algorithm~\ref{algorithm:clustering} to
obtain (a) a disjoint partition  of 
and (b)  nodes  of , which may not be
distinct. Let .  Since  is connected,
each element of  is adjacent to .  The first statement of the
outer repeat-loop is well defined.  Since each element of  has at
most  nodes, the first statement of the inner repeat-loop is
well defined.  See Figure~\ref{figure:clustering} for an illustration:
Suppose that all nodes are in .  All nodes are initially
unmarked.  Let  consist of the nine unlabeled nodes, including
the three gray nodes.  For each , let  consist of
the nodes with label . That is,  are the six
connected components of . Suppose that 
and the first two iterations of the outer repeat-loop obtain 
and . In the third iteration of the outer repeat-loop,
 are the unmarked elements of  that are adjacent
to  in clockwise order around . By
, the two iterations of the inner repeat-loop
obtain  and .

By definition of Algorithm~\ref{algorithm:clustering}, one can verify
that Properties~R\ref{refine:1},~R\ref{refine:2}, and~R\ref{refine:3}
hold for  and  (that is,  is a refinement
of ) and Properties~S\ref{separation:1}
and~S\ref{separation:2} hold for .  By
Property~S\ref{separation:3} of~, we have
.  By
, we have .  Let  consist of
the indices  with  and .  Let  consist of the
indices  with  and .  We show
 as
follows.  By Property~S\ref{separation:1} of , we have
.  To show
, we categorize the indices
 in  with  into the the following
types, where  is the index with :
\begin{description}
\addtolength{\itemsep}{-0.5\baselineskip}
\item[\rm\em Type 1:]  and .  The number of such indices  is at
  most .

\item[\rm\em Type 2:]  and .
\begin{description}
\addtolength{\itemsep}{-0.2\baselineskip}
\item[\rm\em Type 2a:] .  The number of such
  indices  is at most
  .

\item[\rm\em Type 2b:]  and
.  By
  Properties~S\ref{separation:1} and~S\ref{separation:2} of
  , we know that . By definition
  of Algorithm~\ref{algorithm:clustering},
   holds for all indices 
  with .  The number of such indices  is at
  most .

\item[\rm\em Type 2c:]  and . We have .  By definition of
  Algorithm~\ref{algorithm:clustering},
   holds for all indices 
  with .  By Property~S\ref{separation:5} of
  , the number of such indices  is at most
  .
\end{description}
\end{description}
We have .  Property~S\ref{separation:3} holds
for .  By definition of Algorithm~\ref{algorithm:clustering},
 holds for each .  By , each node of  has degree at most
. Property~S\ref{separation:4} holds for .

\begin{figure}[t]
\centerline{\begin{picture}(0,0)\includegraphics{soda-fig6.eps}\end{picture}\setlength{\unitlength}{3947sp}\begingroup\makeatletter\ifx\SetFigFont\undefined \gdef\SetFigFont#1#2#3#4#5{\reset@font\fontsize{#1}{#2pt}\fontfamily{#3}\fontseries{#4}\fontshape{#5}\selectfont}\fi\endgroup \begin{picture}(7369,2193)(187,-3716)
\put(6167,-1697){\makebox(0,0)[lb]{\smash{{\SetFigFont{9}{10.8}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(1164,-3045){\makebox(0,0)[lb]{\smash{{\SetFigFont{9}{10.8}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}5}}}}}
\put(1767,-3044){\makebox(0,0)[lb]{\smash{{\SetFigFont{9}{10.8}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}3}}}}}
\put(1761,-1992){\makebox(0,0)[lb]{\smash{{\SetFigFont{9}{10.8}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}3}}}}}
\put(1165,-1993){\makebox(0,0)[lb]{\smash{{\SetFigFont{9}{10.8}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}5}}}}}
\put(1767,-3044){\makebox(0,0)[lb]{\smash{{\SetFigFont{9}{10.8}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}3}}}}}
\put(6032,-2521){\makebox(0,0)[lb]{\smash{{\SetFigFont{9}{10.8}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}6}}}}}
\put(1567,-1697){\makebox(0,0)[lb]{\smash{{\SetFigFont{9}{10.8}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(6921,-2492){\makebox(0,0)[lb]{\smash{{\SetFigFont{8}{9.6}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(6676,-3661){\makebox(0,0)[lb]{\smash{{\SetFigFont{9}{10.8}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}(c)}}}}}
\put(4197,-1690){\makebox(0,0)[lb]{\smash{{\SetFigFont{9}{10.8}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(4617,-3044){\makebox(0,0)[lb]{\smash{{\SetFigFont{9}{10.8}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}3}}}}}
\put(4289,-2492){\makebox(0,0)[lb]{\smash{{\SetFigFont{8}{9.6}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(4611,-1992){\makebox(0,0)[lb]{\smash{{\SetFigFont{9}{10.8}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}3}}}}}
\put(4617,-3044){\makebox(0,0)[lb]{\smash{{\SetFigFont{9}{10.8}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}3}}}}}
\put(3715,-1993){\makebox(0,0)[lb]{\smash{{\SetFigFont{9}{10.8}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}5}}}}}
\put(3715,-1993){\makebox(0,0)[lb]{\smash{{\SetFigFont{9}{10.8}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}5}}}}}
\put(4126,-3661){\makebox(0,0)[lb]{\smash{{\SetFigFont{9}{10.8}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}(b)}}}}}
\put(2886,-2520){\makebox(0,0)[lb]{\smash{{\SetFigFont{9}{10.8}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}5}}}}}
\put(3482,-2521){\makebox(0,0)[lb]{\smash{{\SetFigFont{9}{10.8}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}6}}}}}
\put(5363,-2521){\makebox(0,0)[lb]{\smash{{\SetFigFont{9}{10.8}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}3}}}}}
\put(4911,-2521){\makebox(0,0)[lb]{\smash{{\SetFigFont{9}{10.8}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}4}}}}}
\put(4014,-3045){\makebox(0,0)[lb]{\smash{{\SetFigFont{9}{10.8}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}5}}}}}
\put(261,-2520){\makebox(0,0)[lb]{\smash{{\SetFigFont{9}{10.8}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}5}}}}}
\put(2513,-2521){\makebox(0,0)[lb]{\smash{{\SetFigFont{9}{10.8}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}3}}}}}
\put(2061,-2521){\makebox(0,0)[lb]{\smash{{\SetFigFont{9}{10.8}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}4}}}}}
\put(857,-2521){\makebox(0,0)[lb]{\smash{{\SetFigFont{9}{10.8}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}6}}}}}
\put(1426,-3661){\makebox(0,0)[lb]{\smash{{\SetFigFont{9}{10.8}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}(a)}}}}}
\put(1165,-1993){\makebox(0,0)[lb]{\smash{{\SetFigFont{9}{10.8}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}5}}}}}
\end{picture} }
\caption{The operation that contracts all nodes of  into a node
  , which takes over some neighbors of .}
\label{figure:operation}
\end{figure}

To see Property~S\ref{separation:5} of , we obtain a
contracted graph from  by performing the following two steps for
each .\footnote{The contraction procedure is only for
  proving Property~S\ref{separation:5} of , not needed for
  computing .}
{\em Step~1:} Let  be the elements of 
with  in clockwise
order around  in .  Split  into two adjacent nodes
 and  and let  take over the neighbors of  in
clockwise order around  from the first neighbor of  in
 to the first neighbor of  in . {\em Step~2:}
Contract all nodes of  into node  and delete multiple edges
and self-loops.  See Figure~\ref{figure:operation} for an
illustration: For each , let  consist of the nodes
with labels~ in Figure~\ref{figure:operation}(a).  Suppose that
, , and . The unlabeled circle
nodes belong to . The square nodes are two previously contracted
nodes  and  from  and  for some
indices  and  with .
Figure~\ref{figure:operation}(b) shows the result of
Step~1. Figure~\ref{figure:operation}(c) shows the result of Step~2.
Observe that each node that is adjacent to  becomes a neighbor of
 after applying Steps~1 and~2.  Also, each neighbor of 
that is not in  either remains a neighbor of  or becomes a
neighbor of  after applying Steps~1 and~2.  Therefore, for each
 and each node , there is either an
edge  or an edge  for some index  with
 and .  Thus,  is no more
than the number of edges in the resulting contracted simple graph,
which has  nodes.  Observe that Step~1
does not increase the genus of the embedding. Since the subgraph
induced by  is connected, Step~2 does not increase
the genus of the embedding, either.  The number of edges in the
resulting contracted simple genus- graph is
.  Property~S\ref{separation:5} holds for
.  The lemma is proved.
\end{proof}

\section{Our compression scheme}
\label{section:compression}
This section proves Theorem~\ref{theorem:theorem1}.


\subsection{Recovery string}

A {\em labeling} of graph  is a one-to-one mapping from  to
. For instance,
Figure~\ref{figure:labeling}(a) shows a labeling for graph .  Let
 be a graph embedded on a surface.  We say that a graph 
embedded on the same surface is a {\em triangulation} of  if  is
a subgraph of  with  such that each face of
 has three nodes.
The following lemma shows an -bit string with which the larger
embedded labeled subgraphs of  can be recovered from smaller
embedded labeled subgraphs of  in  time.

\begin{lemma}
\label{lemma:recovery}
Let  be a positive integer.  Let  be an -node graph embedded
on a genus- surface.  Let  be a
triangulation of .  Let  be a given
-separation of  and  be a
given -separation of  such that  is a
refinement of .  For any given labeling  of
 for each , the following statements hold.
\begin{enumerate}
\addtolength{\itemsep}{-0.5\baselineskip}
\item 
\label{rec1}
It takes overall  time to compute a labeling  of
subgraph  for each .

\item 
\label{rec2}
Given the above labelings  of subgraphs  with
, it takes  time to compute an -bit string
 such that  and  for all
 can be recovered in overall  time from
 and  and  for all .
\end{enumerate}
\end{lemma}

\begin{figure}[t]
\centerline{\begin{picture}(0,0)\includegraphics{soda-fig7.eps}\end{picture}\setlength{\unitlength}{3947sp}\begingroup\makeatletter\ifx\SetFigFont\undefined \gdef\SetFigFont#1#2#3#4#5{\reset@font\fontsize{#1}{#2pt}\fontfamily{#3}\fontseries{#4}\fontshape{#5}\selectfont}\fi\endgroup \begin{picture}(7141,2578)(-89,-2966)
\put(5401,-1261){\makebox(0,0)[lb]{\smash{{\SetFigFont{9}{10.8}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(3488,-2446){\makebox(0,0)[lb]{\smash{{\SetFigFont{9}{10.8}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}3}}}}}
\put(4501,-1261){\makebox(0,0)[lb]{\smash{{\SetFigFont{9}{10.8}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(3188,-2446){\makebox(0,0)[lb]{\smash{{\SetFigFont{9}{10.8}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}0}}}}}
\put(4688,-2446){\makebox(0,0)[lb]{\smash{{\SetFigFont{9}{10.8}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}2}}}}}
\put(5513,-2146){\makebox(0,0)[lb]{\smash{{\SetFigFont{9}{10.8}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}0}}}}}
\put(6638,-1621){\makebox(0,0)[lb]{\smash{{\SetFigFont{9}{10.8}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}3}}}}}
\put(6338,-1621){\makebox(0,0)[lb]{\smash{{\SetFigFont{9}{10.8}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}2}}}}}
\put(6038,-1621){\makebox(0,0)[lb]{\smash{{\SetFigFont{9}{10.8}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}0}}}}}
\put(5738,-1621){\makebox(0,0)[lb]{\smash{{\SetFigFont{9}{10.8}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}1}}}}}
\put(6638,-2446){\makebox(0,0)[lb]{\smash{{\SetFigFont{9}{10.8}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}5}}}}}
\put(6338,-2446){\makebox(0,0)[lb]{\smash{{\SetFigFont{9}{10.8}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}4}}}}}
\put(-74,-1636){\makebox(0,0)[lb]{\smash{{\SetFigFont{9}{10.8}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(1013,-1021){\makebox(0,0)[lb]{\smash{{\SetFigFont{9}{10.8}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}2}}}}}
\put(2476,-1036){\makebox(0,0)[lb]{\smash{{\SetFigFont{9}{10.8}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(1763,-1021){\makebox(0,0)[lb]{\smash{{\SetFigFont{9}{10.8}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}1}}}}}
\put(1388,-1021){\makebox(0,0)[lb]{\smash{{\SetFigFont{9}{10.8}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}0}}}}}
\put(5738,-2446){\makebox(0,0)[lb]{\smash{{\SetFigFont{9}{10.8}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}3}}}}}
\put(5438,-2446){\makebox(0,0)[lb]{\smash{{\SetFigFont{9}{10.8}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}2}}}}}
\put(4238,-1621){\makebox(0,0)[lb]{\smash{{\SetFigFont{9}{10.8}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}2}}}}}
\put(3938,-1621){\makebox(0,0)[lb]{\smash{{\SetFigFont{9}{10.8}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}0}}}}}
\put(4088,-2446){\makebox(0,0)[lb]{\smash{{\SetFigFont{9}{10.8}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}1}}}}}
\put(638,-1621){\makebox(0,0)[lb]{\smash{{\SetFigFont{9}{10.8}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}3}}}}}
\put(2288,-2296){\makebox(0,0)[lb]{\smash{{\SetFigFont{9}{10.8}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}8}}}}}
\put(1351,-2911){\makebox(0,0)[lb]{\smash{{\SetFigFont{9}{10.8}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}(a)}}}}}
\put(1688,-2296){\makebox(0,0)[lb]{\smash{{\SetFigFont{9}{10.8}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}7}}}}}
\put(2138,-1621){\makebox(0,0)[lb]{\smash{{\SetFigFont{9}{10.8}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}6}}}}}
\put(788,-2296){\makebox(0,0)[lb]{\smash{{\SetFigFont{9}{10.8}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}5}}}}}
\put(1351,-511){\makebox(0,0)[lb]{\smash{{\SetFigFont{9}{10.8}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(488,-2296){\makebox(0,0)[lb]{\smash{{\SetFigFont{9}{10.8}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}4}}}}}
\put(376,-1936){\makebox(0,0)[lb]{\smash{{\SetFigFont{9}{10.8}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(1726,-1936){\makebox(0,0)[lb]{\smash{{\SetFigFont{9}{10.8}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(2326,-1936){\makebox(0,0)[lb]{\smash{{\SetFigFont{9}{10.8}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(4051,-2911){\makebox(0,0)[lb]{\smash{{\SetFigFont{9}{10.8}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}(b)}}}}}
\put(3901,-1261){\makebox(0,0)[lb]{\smash{{\SetFigFont{9}{10.8}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(601,-1036){\makebox(0,0)[lb]{\smash{{\SetFigFont{9}{10.8}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(2776,-1636){\makebox(0,0)[lb]{\smash{{\SetFigFont{9}{10.8}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(6076,-2911){\makebox(0,0)[lb]{\smash{{\SetFigFont{9}{10.8}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}(c)}}}}}
\put(6826,-1786){\makebox(0,0)[lb]{\smash{{\SetFigFont{9}{10.8}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(5326,-1786){\makebox(0,0)[lb]{\smash{{\SetFigFont{9}{10.8}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(3076,-2086){\makebox(0,0)[lb]{\smash{{\SetFigFont{9}{10.8}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(4426,-2086){\makebox(0,0)[lb]{\smash{{\SetFigFont{9}{10.8}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(3826,-2086){\makebox(0,0)[lb]{\smash{{\SetFigFont{9}{10.8}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(3151,-1261){\makebox(0,0)[lb]{\smash{{\SetFigFont{9}{10.8}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(3338,-1921){\makebox(0,0)[lb]{\smash{{\SetFigFont{9}{10.8}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}2}}}}}
\put(6376,-1261){\makebox(0,0)[lb]{\smash{{\SetFigFont{9}{10.8}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(4538,-1621){\makebox(0,0)[lb]{\smash{{\SetFigFont{9}{10.8}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}1}}}}}
\put(3638,-1621){\makebox(0,0)[lb]{\smash{{\SetFigFont{9}{10.8}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}1}}}}}
\put(6788,-2146){\makebox(0,0)[lb]{\smash{{\SetFigFont{9}{10.8}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}1}}}}}
\put(4838,-1921){\makebox(0,0)[lb]{\smash{{\SetFigFont{9}{10.8}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}0}}}}}
\end{picture} }
\caption{(a) Graph  with a labeling.  (b) Subgraphs ,
  , and  of  with labelings.  (c) Subgraphs
   and  of  with labelings.}
\label{figure:labeling}
\end{figure}

\begin{proof}
Since  is a subgraph  with , one can
easily verify that  (respectively, ) is also a
-separation (respectively, -separation) of .
For each , let  consist of the indices  with
. Let  consist of the nodes of  that
are not in any  with . By
Properties~S\ref{separation:1} and~S\ref{separation:2} of ,
.  For instance, if  is as shown in
Figure~\ref{figure:labeling}(a), where  with 
denotes the node with label~.  We have
, , , and
.  Let the labeling  for 
be defined as follows.
\begin{itemize}
\addtolength{\itemsep}{-0.5\baselineskip}
\item 
For the nodes of  in , let  be an arbitrary
one-to-one mapping from  to . In
Figure~\ref{figure:labeling}(c), we have ,
, , ,
, and .

\item 
For the nodes of  not in , let  be the
one-to-one mapping from  to  obtained by sorting  for all
indices  and all nodes  such that
 holds for a node  of  and a node
 of  if and only if (a)  or (b)  and
.  For instance, if , , and
 are as shown in Figure~\ref{figure:labeling}(b), then
 and  can be as shown in
Figure~\ref{figure:labeling}(c) and  can be as shown in
Figure~\ref{figure:labeling}(a).
\end{itemize}
It takes  time to compute
 from all  with . By
Property~S\ref{separation:5} of~, it takes overall 
time to compute all  with  from all
 with .
Statement~\ref{rec1} is proved.

By Property~S\ref{separation:4} of , the label of each
node of  assigned by  can be represented by
 bits.
By Property~S\ref{separation:4} of , the label of each node
of  assigned by  can be represented by
 bits.
For each index , 
\begin{itemize}
\addtolength{\itemsep}{-0.5\baselineskip}
\item 
string  stores the adjacency list of the
embedded subgraph of  induced by  via the labeling
 of ,
\item 
string  stores the information required to
recover  from all  with , and
\item 
string  stores the information required to
recover the embedding of  from the embeddings of all 
with  and the embedding of the subgraph of  induced
by .
\end{itemize}
By definition of , we have . It
follows from Property~S\ref{separation:3} of  and
Property~S\ref{separation:5} of  that 

Let .  Since  form
a disjoint partition of the edges of , the overall number of edges
in the subgraphs of  induced by  for all 
is no more than the number of edges in , which is
.  Therefore,

It suffices for  to store the list of
 for all  and all .  By Property~R\ref{refine:3} of  and 
and Property~S\ref{separation:4} of , index  can be
represented by an -bit offset  such that  is the
-th smallest index in .  Thus,
.
By Property~S\ref{separation:5} of , we have .  Therefore,

It suffices for  to store the list of
 for all pairs of edges
 and  of  such that (a)  is the neighbor
of  that immediately succeeds  in clockwise order around  in
 and (b) nodes  and  are not in the same partition of
 formed by the  disjoint sets  and 
with .  By Property~S\ref{separation:2} of , node
 belongs to . Since  is a triangulation
of , the neighbors of  in  form a cycle that surrounds
 in .  Let  be the path of the cycle from  to 
in clockwise order around .  At least one node, say,  of 
belongs to , since otherwise Property~S\ref{separation:2} of
 would imply that all nodes of  belong to the same 
for some , contradicting with the choices of  and .
Edge  belongs to .
Observe that each edge of  can be identified by at most
four such edge pairs  and .  Since the edges of
 and  with  are disjoint, the
number of edge pairs stored in  is at most four
times the number of edges in . By
Property~S\ref{separation:3} of  and the fact that 
has genus , the number of edge pairs stored in
 is .  Therefore,

Let 

By Equations~(\ref{eq:1}),~(\ref{eq:2}), and~(\ref{eq:3}) and
Lemma~\ref{lemma:unary-concat}, we have . It
takes  time to compute  from all labelings
 and all embedded graphs  with  and
all labelings  and all embedded graphs  with .  It also takes  time to recover all labelings
 and all embedded graphs  with  from
 and all labelings  and all embedded graphs
 with .  Statement~\ref{rec2} holds.  The lemma
is proved.
\end{proof}

\subsection{Proving Theorem~\ref{theorem:theorem1}}
We are ready to prove the main theorem of the paper.
\begin{proof}[Proof of Theorem~\ref{theorem:theorem1}]\
Let  be the -node input graph embedded on a
genus- surface.  The encoding algorithm
 performs the following four steps on .
\begin{enumerate}[\em E1:]
\addtolength{\itemsep}{-0.5\baselineskip}

\item 
\label{e1}
Triangulate the embedded graph  into a triangulation  of
.  Let  be the -separation  of
. For each , apply Lemma~\ref{lemma:lemma3.1} to
obtain a -separation  of  that is a refinement of
.

\item 
\label{e2}
Let .  Apply Lemma~\ref{lemma:basis} with
 to compute
(a)~ and  for all distinct
graphs  in class  with  and
(b)~.  For each , apply
Lemma~\ref{lemma:basis}(\ref{basis:1}) to compute from
 the binary string
 and the labeling
.

\item 
\label{e3}
For each , perform the following two substeps.
\begin{enumerate}[\em E\ref{e3}.1:]
\item 
\label{encode:concat}
Let  and .  For
each , let binary string
, where  are the
indices  with .

\item 
Apply Lemma~\ref{lemma:recovery}(\ref{rec1}) to obtain the labelings
 of subgraphs  for all .  Apply
Lemma~\ref{lemma:recovery}(\ref{rec2}) to obtain the -bit binary
string .
\end{enumerate}

\item 
\label{e4}
By , now we have  (and a
labeling  for ).  The output binary string
.
\end{enumerate}
By Lemma~\ref{lemma:lemma3.1}, Step~E\ref{e1} takes  time.  By
Property~S\ref{separation:5} of , we have .  By Lemma~\ref{lemma:basis}, Step~E\ref{e2} takes
 time.  By Lemmas~\ref{lemma:unary-concat}
and~\ref{lemma:recovery}, Step~E\ref{e3} takes  time.  By
Lemma~\ref{lemma:unary-concat}, Step~E\ref{e4} takes  time.
Therefore, the encoding algorithm  runs in
 time. Condition~C\ref{condition:c1} holds.


\bigskip
\noindent
The decoding algorithm  performs the following five
steps on .
\begin{enumerate}[\em D1:]
\addtolength{\itemsep}{-0.5\baselineskip}
\item 
\label{d1}
Obtain , ,
, and  from .

\item 
\label{d2}
Let .  For each , perform the
following substep.
\begin{enumerate}[\em D2.1:]
\item 
Let  and .  For
each , obtain all  with
 from .
\end{enumerate}

\item 
\label{d3}
Let .  
Apply Lemma~\ref{lemma:basis}(\ref{basis:2}) to obtain  and
 from
 and
 for each .

\item 
\label{d4}
For each , perform the following substep.
\begin{enumerate}[\em D4.1:]
\item 
Let  and .
Apply Lemma~\ref{lemma:recovery}(\ref{rec2}) to recover  and
 with  from  and  with
 and .
\end{enumerate}

\item 
\label{d5}
Output .
\end{enumerate}
By Lemma~\ref{lemma:unary-concat}, Step~D\ref{d1} takes  time.
By Lemma~\ref{lemma:unary-concat}, Step~D\ref{d2} takes  time.
By
Property~S\ref{separation:5} of , we have .  
By Lemma~\ref{lemma:basis}(\ref{basis:2}), Step~D\ref{d3} takes 
time.
By Lemma~\ref{lemma:recovery}(\ref{rec2}), Step~D\ref{d4} takes 
time.  Therefore, the decoding algorithm  runs
in  time.  Condition~C\ref{condition:c2} holds.  By
, graph  is correctly
recovered from  at the end of Step~D4. Therefore,
 is a compression scheme for .

\bigskip
\noindent
To show Condition~C\ref{condition:c3}, we first prove the following
claim for each .
\begin{claim}
\label{claim:claim1}
Suppose that  and
.  If  and
 holds for each
, then  and
 holds for each
.
\end{claim}
\begin{proof}[Proof of Claim~\ref{claim:claim1}]
For each , let  consist of the indices  with
.  
By Property~S\ref{separation:4} of , we have . Therefore, , implying
. By
Property~S\ref{separation:3} of , .  By Lemma~\ref{lemma:unary-concat}, we have

We also have 

The claim is proved.
\end{proof}

Let . For each , let
.  By Property~S\ref{separation:5}
of , we have .  By Step~E\ref{e2}
of~ and Lemma~\ref{lemma:basis}, we have
.  By
Property~S\ref{separation:4} of~ and the assumption that
,

holds for each .  
We have

Combining Equations~(\ref{eq4}) and~(\ref{eq5}),
Claim~\ref{claim:claim1} for , and , we have .  By
Lemma~\ref{lemma:unary-concat} and
, we have .
Condition~C\ref{condition:c3} holds.  The theorem is proved.
\end{proof}

\section{Extension}
\label{section:extend}

This section proves Theorem~\ref{theorem:theorem2}.  The only place in
our proof of Theorem~\ref{theorem:theorem1} requiring  to be
hereditary is Step~E\ref{e2}: We need  so that
 and  can be
obtained from . For a non-hereditary class
, we can substitute  by a graph  that is close
to  for each  as long as the overall number of
bits required to encode the overall difference between  and
 is . The following corollary is an example of such an
extension.

\begin{corollary}
\label{corollary:corollary1}
Let  be a class of graphs satisfying  and that any input -node graph 
to be encoded comes with a genus- embedding.
If for any -separation  of any graph ,
there exist graphs  in  such that
each  with  can be obtained from  by first
deleting  nodes (together with their incident edges)
and then updating (adding or deleting)  edges,
then  admits an optimal compression scheme.
\end{corollary}

\begin{proof}
We revise algorithm  by updating Steps~E\ref{e2}
and~E\ref{e4} as follows.
\begin{enumerate}[\em E1':]
\addtolength{\itemsep}{-0.5\baselineskip}
\setcounter{enumi}{1}
\item 
\label{step:e2-prime}
Let .  Compute  from
.  Apply Lemma~\ref{lemma:basis} with
 to compute (a)
 and  for each distinct graph
 with  and (b) .
Apply Lemma~\ref{lemma:basis}(\ref{basis:1}) to compute
 and
 from  for all
indices .  Let  be the labeling of 
obtained from the labeling  of  such that if  and
 are two distinct nodes of  with
, then we have .
Let  be the binary string storing the difference
between  and  via labeling .  Let
.

\setcounter{enumi}{3}
\item 
\label{step:e4-prime}
By , now we have 
(and a labeling  for ).  The output binary string
 for  is
.
\end{enumerate}
By , it takes  time to compute an
-bit string  such that graphs 
satisfying the above conditions can be obtained from
 and  in  time.  By
Property~S\ref{separation:5} of  and the conditions of
, we have .  By Lemmas~\ref{lemma:unary-concat}
and~\ref{lemma:basis}, Step~E\ref{step:e2-prime}' takes  time.
By Lemma~\ref{lemma:unary-concat}, Step~E\ref{step:e4-prime}' takes
 time.  Therefore, Condition~C\ref{condition:c1} holds for the
revised .
We revise algorithm  by updating Steps~D\ref{d1}
and~D\ref{d3} as follows.
\begin{enumerate}[\em D1':]
\addtolength{\itemsep}{-0.5\baselineskip}
\item 
Obtain , ,
, , and~ from
.

\setcounter{enumi}{2}
\item 
Let .  Apply
Lemma~\ref{lemma:basis}(\ref{basis:2}) to obtain  and
 from
 and
 for each .  Apply
Lemma~\ref{lemma:unary-concat} to obtain all  with
 from .  Obtain  and 
from , , and  for all .
\end{enumerate}
Both revised steps take  time.  Condition~C\ref{condition:c2}
holds for the revised .  Subgraph  can be
obtained from  by first deleting  nodes (and their
incident edges) and then updating  edges.  It follows
from Property~S\ref{separation:4} of  that
.  By
Property~S\ref{separation:5} of , we have
. By Lemma~\ref{lemma:unary-concat}, we have
.  Condition~C\ref{condition:c3} holds the
revised .  The corollary is proved.
\end{proof}

We use 
Corollary~\ref{corollary:corollary1} to prove
Theorem~\ref{theorem:theorem2}.
\begin{proof}[Proof of Theorem~\ref{theorem:theorem2}]

\begin{figure}[t]
\centerline{\begin{picture}(0,0)\includegraphics{soda-fig8.eps}\end{picture}\setlength{\unitlength}{3947sp}\begingroup\makeatletter\ifx\SetFigFont\undefined \gdef\SetFigFont#1#2#3#4#5{\reset@font\fontsize{#1}{#2pt}\fontfamily{#3}\fontseries{#4}\fontshape{#5}\selectfont}\fi\endgroup \begin{picture}(5944,1968)(487,-4316)
\put(3676,-4261){\makebox(0,0)[lb]{\smash{{\SetFigFont{10}{12.0}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}(b)}}}}}
\put(5476,-4261){\makebox(0,0)[lb]{\smash{{\SetFigFont{10}{12.0}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}(c)}}}}}
\put(1576,-4261){\makebox(0,0)[lb]{\smash{{\SetFigFont{10}{12.0}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}(a)}}}}}
\end{picture} }
\caption{(a) A plane triangulation , where  consists of
  the gray nodes.  (b) The subgraph , where the dotted
  edges are those in . (c) A plane
  triangulation  obtained by adding the dark node  and four
  edges in the external face  of .}
\label{figure:triangulation-augment}
\end{figure}

Let  be an -node triangulation of a genus- surface.  Let
 be a -separation of .  Let  consist
of the non-triangle faces of .  Let  be the plane
triangulation obtained from  by performing the following
two steps for each face : (1) Add a node  in . (2)
For each node  on the boundary of , add an edge .  See
Figure~\ref{figure:triangulation-augment} for an illustration.  Since
 is a triangulation, the boundary of  contains at least two
nodes  with .
Therefore, at least two nodes of  belong to the boundary of
.  Let  be an edge between two arbitrary nodes of 
that belong to the boundary of .  The union of  over all faces
 has genus no more than . Therefore, the number of
added nodes to triangulate  is .  The
number of edges in  is also
. Thus,  can be obtained from 
by first deleting  nodes together with their
incident edges and then deleting  edges.  By
Corollary~\ref{corollary:corollary1},
Statement~\ref{thm2:triangulation} is proved.

\begin{figure}[t]
\centerline{\begin{picture}(0,0)\includegraphics{soda-fig9.eps}\end{picture}\setlength{\unitlength}{3947sp}\begingroup\makeatletter\ifx\SetFigFont\undefined \gdef\SetFigFont#1#2#3#4#5{\reset@font\fontsize{#1}{#2pt}\fontfamily{#3}\fontseries{#4}\fontshape{#5}\selectfont}\fi\endgroup \begin{picture}(6844,2343)(337,-1841)
\put(3676,-1786){\makebox(0,0)[lb]{\smash{{\SetFigFont{10}{12.0}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}(b)}}}}}
\put(6076,-1786){\makebox(0,0)[lb]{\smash{{\SetFigFont{10}{12.0}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}(c)}}}}}
\put(1276,-1786){\makebox(0,0)[lb]{\smash{{\SetFigFont{10}{12.0}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}(a)}}}}}
\end{picture} }
\caption{(a) A floorplan , where  consists of the gray nodes.
  (b) The subgraph . (c) A floorplan  obtained from
   by adding  nodes and edges.}
\label{figure:floorplan-augment}
\end{figure}

Let  be an -node floorplan.  Since each node of  has at most
three neighbors in , one can easily obtain a floorplan  from
 by adding  nodes and edges. See
Figure~\ref{figure:floorplan-augment} for an example.
Statement~\ref{thm2:floorplan} follows from Corollary~\ref{corollary:corollary1}.
\end{proof}

\section{Concluding remarks}
\label{section:conclude}
Our optimal compression schemes rely on a linear-time obtainable
embedding. Can this requirement be dropped?  It would be of interest
to extend our compression schemes to support efficient queries and
updates.  We leave open the problems of obtaining optimal compression
schemes for -connected genus- graphs and 3D
floorplans~\cite{CuestaAHPAM10,LiHZBYP06,SridharanDSXN09,LiMH09,WangYC09,WangZGGC08,LiHZBYPC06,CongM10}.

\small
\bibliographystyle{abbrv}
\bibliography{soda}
\end{document}
