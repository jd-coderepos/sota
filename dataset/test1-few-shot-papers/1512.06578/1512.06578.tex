\RequirePackage{fix-cm}
\documentclass[twocolumn]{svjour3}          \smartqed  \usepackage{graphicx}
\usepackage{amssymb,amsmath}
\usepackage{times}
\usepackage{color}
\usepackage{verbatim}
\usepackage{fancyhdr}
\newtheorem{assumption}{Assumption}
\begin{document}

\title{Flexible Attribute-Based Encryption Applicable to \\Secure E-Healthcare Records
}




\author{Bo Qin  \and
        Hua Deng \and
        Qianhong Wu\and
        Josep Domingo-Ferrer \and
        David Naccache \and
        Yunya Zhou }



\institute{Bo Qin \at
              Renmin University of China\\
              No. 59, Zhongguangun Street, Haidian District, Beijing, China
\and
           Hua Deng \at
           School of Computer, Wuhan University, Wuhan, China
           \and
           Qianhong Wu, Corresponding author \at
           School of Electronic and Information Engineering, Beihang University\\
           XueYuan Road No.37, Haidian District, Beijing, China\\
           Tel.: 0086 10 8233 9469\\
           \email{qianhong.wu@buaa.edu.cn}
           \and
Josep Domingo-Ferrer \at
           Universitat Rovira i Virgili, Department of Computer Engineering and Mathematics\\
           UNESCO Chair in Data Privacy, E-43007 Tarragona, Catalonia
           \and
           David Naccache \at
           \'{E}cole normale sup\'{e}rieure, D\'{e}partement d'informatique\\
           45 rue d'Ulm, F-75230, Paris Cedex 05, France
           \and
           Yunya Zhou \at
           School of Electronic and Information Engineering, Beihang University\\
           XueYuan Road No.37, Haidian District, Beijing, China
           }


\date{Received: date / Accepted: date}



\maketitle

\begin{abstract}
In e-healthcare record systems (EHRS), attribute-based encryption (ABE)
appears as a natural way to achieve fine-grained access control on health records. Some proposals exploit key-policy ABE (KP-ABE) to protect privacy in
such a way that all users are associated with specific access policies and only the ciphertexts matching the users' access policies can be decrypted.
An issue with KP-ABE is that it requires an {\em a priori} formulation
of access policies during key generation, which is not always practicable in EHRS because the policies to access health records are sometimes determined after key generation. In this paper, we  revisit KP-ABE and propose a {\em dynamic} ABE paradigm, referred to as access policy redefinable ABE (APR-ABE). To address the above issue,  APR-ABE allows users to redefine their access policies and delegate keys for the redefined ones; hence {\em a priori} precise policies are no longer mandatory. We construct an APR-ABE scheme with short ciphertexts and prove its full security in the standard model under several static assumptions.

\keywords{E-Healthcare records \and Privacy \and Access control \and Attribute-based encryption}
\end{abstract}

\section{Introduction}
\label{intro}

Attribute-based encryption (ABE) provides fine-grained access control
over encrypted data by using access policies and attributes embedded in secret keys and
ciphertexts. ABE cryptostems \cite{SW05} fall into two categories:
key-policy ABE (KP-ABE) \cite{GPS+06} systems and ciphertext-policy ABE (CP-ABE)
\cite{BSW07} systems. In a CP-ABE system, the users' secret keys are associated with sets of attributes, and a sender generates a ciphertext with an access policy specifying the attributes that the decryptors must have. Alternatively, in a KP-ABE system, the users' secret keys are labeled with access policies and the sender specifies a set of attributes; only the users whose access policies match the attribute set can decrypt.

ABE requires \emph{a priori} access policies, which are not always available. This may limit its applications in practice. The following scenario
illustrates our point.

In an e-healthcare record system (EHRS),  Alice's health records are encrypted by the doctors whom she consulted before. When Alice authorizes some doctors to access her encrypted medical records, she may have no sufficient expertise to precisely determine which doctors should access the records. Instead, according to her
experience and common sense, she may specify a policy saying that the doctor
ought to be medicine professor with five-year working experience from the
hospitals she knows. After a matching doctor Bob sees Alice's medical materials, Bob finds that Alice has something wrong with her heart. Hence, a
cardiologist's advice must be sought; thus, a cardiologist (who can be a professor or not) must be allowed to see Alice's documents.

In this application, the main obstacle to apply ABE is that Alice, serving as the key generation authority, cannot generate secret keys for access policies that are {\em a priori} 
``carv\-ed in stone'', because she does not clearly know which experts are necessary for her diagnosis.


In fact, the access policy must be dynamically modified. That is, authorized users must be able to redefine their access policies and then delegate secret keys for the redefined access policies to other users. For instance, in the above motivating scenario, Alice first authorizes doctors with some general attributes to access her encrypted medical records. After the matching doctor makes a preliminary diagnosis and finds something wrong with
Alice's heart, the doctor redefines his access policy to involve some special attributes (e.g. specialty: cardiologist) and delegates to the doctor with the redefined access policy. In this way,  {\em a priori} precise access policies are not mandatory during key generation because
they can be later redefined in delegation.

There are already some ABE schemes supporting delegation. The CP-ABE schemes in \cite{BSW07,GJP+08,Wat11} allow users to delegate 
{\em more restricted secret keys, that is, keys for attribute sets that are subsets of the original ones.} 
In KP-ABE, the schemes proposed in \cite{GPS+06,LW11,BNS13,RW13} provide a delegation mechanism, but all of them require that the access policy to be delegated be more restrictive. This {\em limited} delegation functionality is
often insufficient: for example, in the motivating
application above 
Bob should be able to delegate to a cardiologist even if Bob
is not a cardiologist himself.
Limiting the user to delegating keys for other users associated
with more restrictive access policies
is too rigid.

The challenge of providing appropriate delegation for the applications above
has to do with the underlying secret sharing scheme. In most KP-ABE schemes (\cite{GPS+06,LW11,RW13}), secret sharing schemes are employed to share a secret in key generation and reconstruct the secret during decryption. In the key generation, each attribute involved in the access policy needs to be associated with a secret share. If there are new attributes in the target access policy to be delegated to, users cannot delegate a secret key for the access policy since they are unable to generate shares for the new attributes without knowing
the secret. This is why the above mentioned KP-ABE schemes require the 
delegated access policy to be more restrictive than the original one. This hinders
applying them for the motivating application, where the doctor with general attributes would like to delegate his access rights to a 
doctor associated with
new special attributes.

\subsection{Our Work}
\label{contri}
We propose a dynamic primitive referred to as access policy redefinable ABE (APR-ABE). The functional goal of APR-ABE is to provide a more dynamic delegation mechanism. In an APR-ABE system, users can play the role of the key generation authority by delegating secret keys to their subordinates. The delegation does not require the redefined access policy to
be more restrictive than the one of the delegating key.

Noting that attributes are very
often hierarchically related in the real word,
we arrange the attribute universe of APR-ABE in a matrix.
For example, we can place the attribute ``Internal medicine''
at a higher level of the matrix than the attribute ``Cardiologist''.
Due to this arrangement, the notion of {\em attribute vector}
naturally comes up: an attribute vector can be generated by
picking single attributes from upper levels to lower levels.
By using attribute vectors, we can realize a delegation
that allows new attributes to be added into the original access policy
and a secret key to be delegated for the resulting policy.
This delegation is similar to the one of hierarchical identity-based
encryption (HIBE,\cite{BBG05}), but with the difference that
only delegation to the attributes consistent
with the attribute matrix is allowed.

We present an APR-ABE framework based on KP-ABE and define its
full security. In  APR-ABE, the users' secret keys are associated with
an access structure formalized by attribute vectors. Users
at higher levels can redefine their access structures and then
delegate secret keys to others in lower levels without the constraint that the redefined access structures of the delegated keys be more restrictive.
Ciphertexts are generated with sets of attribute vectors, and decryption succeeds if and only if the attribute set of a ciphertext satisfies the access structure associated with a secret key, just as in the ordinary KP-ABE.
In full security, a strong security notion in ABE systems, an adversary is allowed to access public keys, create attribute vectors and query secret keys for specified access structures. Full security states that
not even such an adversary can get any useful information about the plaintext encrypted in a ciphertext, provided that he does not have the correct decryption key.

We construct an  APR-ABE scheme by employing a linear secret sharing scheme (LSSS). An LSSS satisfies linearity, that is, new shares generated by multiplying existing shares by random factors can still reconstruct the secret. Hence, when delegating to new attributes, we create new attribute vectors by combining new attributes with existing attribute vectors and we generate shares for new attribute vectors by randomizing the shares of the existing vectors. In this way, all attribute vectors in the redefined access structure will obtain functional shares and the access structure need not to be more restrictive than the one
of the delegating key. One may attempt to trivially construct APR-ABE from HIBE by directly setting each attribute vector as the identity vector in HIBE. However, this trivial construction would suffer from collusion attacks because a coalition of users may collude to decrypt ciphertexts sent to none of them, 
even though the access structure of
none of the colluders matches the attribute sets of the concerned ciphertexts.
The proposed APR-ABE scheme withstands this kind of collusion attack by associating random values to the secret keys of users. The proposed  APR-ABE scheme has short ciphertexts and is proven to be fully secure in the standard model under several static assumptions.

APR-ABE can provide an efficient solution to the motivating application.
General attributes can be placed
in the first level and more specific, professional attributes in the next level. Alice authorizes doctors to access her medical records by specifying access policies in terms of general attributes. These authorized doctors can
redefine their access policies in terms of professional attributes
and they can delegate keys to other doctors. The matching doctors then can read Alice's records if their general and specific 
professional attributes match those
specified by the doctors who encrypted Alice's health records.



\subsection{Applying  APR-ABE to EHR Systems}
\label{application}

Our APR-ABE can be applied to EHR systems to circumvent the issue of {\em a priori} formulation of access policies. 
The APR-ABE solution relies on cleverly designed attribute hierarchies. We can arrange the attribute universe in a matrix such that general attributes like
hospital name (for example ``Hospital A'', ``Hospital B''), 
title (for example ``Professor'') 
or working years are placed in the first level, while 
specific professional attributes of doctors
(typically their medical specialty, with values like 
 ``Cardiologist'',  ``Gastroenterologist'', etc.)
 are placed in the next level. When delegating, doctors matching general attributes can redefine their access policies 
in terms of professional attributes.
We now describe how does APR-ABE work for such setting in an EHR system.

As depicted in Fig. \ref{application}, an EHR system employs a health record repository to store patients' health records. To protect privacy, all health records are encrypted by doctors who make diagnoses. Suppose that Alice's health records are encrypted with an 
attribute set \{Hospital A, Cardiologist, Professor, Working years\}. When Alice feels sick, she wants to authorize some doctors to read her health records. However, she may not know what exact experts are necessary for her diagnosis. Instead of generating secret keys for all doctors of Hospital A, Alice specifies an access policy \{Hospital A AND Professor AND Working years\} and generates a secret key  for a doctor matching this access policy. The matching doctor then makes a preliminary diagnosis on Alice's health records. Upon finding that Alice has
a heart condition,  the doctor redefines the access policy 
to seek greater specialization, \{\{Hospital A, Cardiologist\} AND Professor AND Working years\} and delegates a secret key for . Since the set  associated with Alice's health records satisfies access structure , the doctor with  can decrypt and read Alice's health records. 
We note that the pair 
of attributes \{Hospital A, Cardiologist\} 
that appears in  is treated as an attribute vector in our APR-ABE.
Thus in the 
redefinition of  as , the new attribute ``Cardiologist'' can be added, that is, the delegation is {\em not} more restrictive.

\begin{figure}
\includegraphics[width=0.50\textwidth]{application.jpg}
\caption{Application to EHR systems}
\label{application}       \end{figure}


\subsection{Paper Organization}

The rest of this paper is organized as follows. We recall the related work in Section \ref{related}. Section \ref{background} reviews the necessary background for our APR-ABE construction. We formalize the APR-ABE and define its security in Section \ref{model}. Section \ref{scheme} proposes an APR-ABE and proves its security in the standard model. Finally, we conclude the paper in Section \ref{conclusion}.

\section{Related Work}
\label{related}


ABE is a versatile cryptographic primitive allowing fine-grained access control over encrypted files.  ABE was introduced by Sahai and Waters
\cite{SW05}. Goyal {\it et al.} \cite{GPS+06} formulated two complementary forms of ABE, i.e., Key-Policy ABE and Ciphertext-Policy ABE, and presented the first
KP-ABE scheme. The first CP-ABE scheme was proposed by Bethencourt {\it et al.} in \cite{BSW07}, although its security proof relies on generic bilinear group
model. Ostrovsky {\it et al.} \cite{OSW07} developed a KP-ABE scheme to handle any non-monotone structure; hence, negated clauses can be included in the
policies. Waters \cite{Wat11} presented a CP-ABE construction that allows any attribute access structure to be expressed by a Linear Secret Sharing Scheme
(LSSS). Attrapadung {\it et al.} \cite{ALP11} gave a KP-ABE scheme
permitting non-monotone access structures and constant-size ciphertexts.
To reduce
decryption time, Hohenberger and Waters \cite{HW13} presented a KP-ABE with fast decryption.


The flexible encryption property of ABE made it widely adopted in e-healthcare record systems. Li {\it et al.} \cite{LYZ+13} leveraged ABE to encrypt personal health records in cloud computing and exploited multi-authority ABE to achieve a high degree of privacy of records. Yu {\it et al.} \cite{YRL11} adopted and tailored ABE for wireless sensors of e-healthcare systems. Liang {\it et al.} \cite{LBL+12} also applied ABE to secure private health records in health social networks. In their solution, users can verify
each other's identifiers  without seeing sensitive attributes, which yields a high level of privacy. Noting that the application of KP-ABE to distributed sensors in e-healthcare systems introduces several challenges regarding attribute and user revocation, Hur \cite{Hur11} proposed an access control scheme using KP-ABE that has efficient attribute and user revocation capabilities.

In order to allow delegation of access rights to encrypted data, some ABE schemes support certain key delegation. CP-ABE \cite{BSW07,GJP+08,Wat11} allow users to delegate to attribute sets that are subsets of the original ones. Since a secret sharing scheme is used in key generation, the delegation of KP-ABE is more complicated. Goyal {\it et al.} \cite{GPS+06} adopted Lagrange interpolation to realize secret sharing and achieved a KP-ABE with selective security. This scheme supports key delegation while requiring the tree structures of delegated keys to be more restrictive than the one of the delegating key when new attributes are introduced. Lewko and Waters \cite{LW11} presented a fully secure KP-ABE  which employs a more general LSSS matrix to realize secret sharing. This KP-ABE  allows key delegation while requiring the redefined access policy to be either equivalent to the original access policy or more restrictive when new attributes need to be added. The KP-ABE in \cite{RW13} is an improvement of Lewko and Waters' KP-ABE and inherits its delegation, which
is hence limited as well. Recently, Boneh  {\it et al.} \cite{BNS13} proposed an ABE where access policies are expressed as polynomial-size arithmetic circuits. Their system supports key delegation but the size of the secret keys
increases quadratically with the number of delegations.


There are some works resolving delegation in different applications. To achieve both fine-grained access control and high performance for enterprise users, Wang {\it et al.} \cite{WLW10} proposed a solution that combines
hierarchical identity-based encryption with CP-ABE to allow a performance-expressivity tradeoff. In that scheme, various authorities rather than attributes are hierarchically organized in order to generate keys for users in their domains. Wan  {\it et al.} \cite{WLD12} extended ciphertext-policy attribute-set-based encryption with a hierarchical structure of users to achieve scalability and flexibility for access control in cloud computing systems. Li {\it et al.} \cite{LWW+11} enhanced ABE by organizing attributes in a tree-like structure to achieve delegation, which is similar to our arrangement of attributes; however,
 their delegation is still limited to
increasingly restrictive access policies. Besides, the security
of the proposed scheme is only selective.  Indeed,
all these schemes are proposed to adapt ABE for specific applications,
while our APR-ABE aims at permitting users to redefine their
access policies and delegate secret keys
in a way that does not need to be increasingly restrictive.




\section{Preliminaries}
\label{background}
In this section, we overview access structures, linear secret sharing schemes (LSSS), the composite-order bilinear group equipped with a bilinear map, and several complexity assumptions.

\subsection{Access Structures \cite{Bei96}}
\label{sec21}

\begin{definition}\label{accstr} Let  be a set of parties. A collection  is
monotone if for , we have that  holds if  and . An access structure (respectively,
monotone access structure) is a collection (respectively, monotone collection)  of non-empty subsets of , i.e.,
. The sets in  are called the authorized sets, and the sets not in
 are called the unauthorized sets.
\end{definition}

In traditional KP-ABE, the role of the parties is played by the attributes. In our APR-ABE, the role of the parties is taken by
attribute vectors. Then an access structure is a collection of sets of attribute vectors. We restrict our attention to  monotone access structures in our APR-ABE. However we can realize general access structures by having the negation
of an attribute as a separate attribute, at the cost of doubling the number of attributes in the system.

\subsection{Linear Secret Sharing Schemes \cite{Bei96}}

\begin{definition} \label{LSSS}A secret-sharing scheme  over a set of parties  is called linear (over ) if
\begin{enumerate}
  \item The shares for each party form a vector over .
  \item There exists a matrix  called the share-generating matrix for , where  has  rows and  columns. For all , the -th row of  is labeled by a party , where  is a function from  to .
      When we consider the column vector , where  is the secret to be shared, and  are randomly chosen, then  is the vector of  shares of the secret s according to . Let  denote the
      -th row of , then  is the share belonging to party .
\end{enumerate}
\end{definition}


\medskip
\noindent\textbf{Linear Reconstruction.} \cite{Bei96} shows that every LSSS  enjoys the linear reconstruction property. Suppose 
is the LSSS for access structure  and  is an authorized set in , i.e.,  contains . There exist constants
 which can be found in time polynomial in the size of the share-generating matrix  such that if 
are valid shares of , then , where .

\subsection{Composite-order Bilinear Groups}

Suppose that  is a group generator and  is a
security parameter. Composite-order
bilinear groups \cite{BGN05} can be defined as
, where  and  are three distinct primes, both  and
 are cyclic groups of order  and the group operations in both  and  are computable in time polynomial in
. A map  is an efficiently computable map with the following properties.
\begin{enumerate}
  \item \textbf{Bilinearity}: for all  and , .
  \item \textbf{Non-degeneracy}:  such that  has order  in .
\end{enumerate}


Let  denote the subgroup of order  for , and ,  the subgroups of order
,  in , respectively. The \emph{orthogonality} property of  is defined as:
\begin{definition} For
all , it holds that , where .
\end{definition}
The orthogonality property is essential in our
constructions and security proofs.

\subsection{Complexity Assumptions}
We now list the complexity assumptions which will be used to prove the security of our scheme. These assumptions were introduced
by \cite{LW10} to prove fully secure HIBE and
they were also employed by some ABE schemes
(e.g., \cite{LOS+10,LW11}) to attain full security.

\begin{assumption}
Let . Define a distribution
 The advantage of an algorithm  in breaking Assumption 1 is defined as

Assumption 1 holds if  is negligible in  for any polynomial-time algorithm .
\end{assumption}

\begin{assumption}
Let . Define a distribution


The advantage of an algorithm  in breaking Assumption 2 is defined as

Assumption 2 holds if any polynomial-time algorithm  has  negligible in .
\end{assumption}


\begin{assumption} Let . Define a distribution
  The advantage of an algorithm  in breaking Assumption 3 is defined as

Assumption 3 holds if any polynomial-time algorithm  has  negligible in .
\end{assumption}


\section{Modeling Access Policy Redefinable Attribute-based Encryption}
\label{model}
\subsection{Notations}
We now model the APR-ABE system. First, we introduce some notations used in the description.
Observing that the hierarchical property exists among attributes in the real world, we arrange the APR-ABE attribute universe  in a matrix with  rows and  columns, that is,

where  is the -th row of  and contains  attributes and  denotes the transposition of a matrix . We note that there may be some {\em empty} attributes in the matrix. In that case, we use a special character ``'' to denote the empty attributes.

The attribute matrix naturally leads to the notion of attribute vector. We define an attribute vector of depth  () as

where  for each  from 1 to . This means that an attribute vector of depth  is formed by sampling single attributes from the first level to the -th level. We note that each attribute  actually corresponds to two subscripts  denoting its position in the attribute matrix, but we drop the second subscript  here to simplify notations.

We next define a set of attribute vectors. Let  denote a set of attribute vectors of depth  and  denote the set's cardinality.

For an attribute vector  of depth  and another attribute vector  of depth , we say that  is a {\em prefix} of  if

where .

As in Definition \ref{accstr}, we can define  as an access structure over attribute vectors of depth  such that  is a
collection of non-empty subsets of the set of all attribute vectors of depth . If for a set  the condition  holds, then we
say that  is an authorized set in  and  satisfies .

In an APR-ABE system, a secret key associated with an access structure  
can decrypt a ciphertext generated with a set  of attribute vectors if and only if . A secret key associated with an access structure  is allowed to delegate a secret key for an access structure  if these two access structures satisfy a natural condition. That is, each attribute vector of a set  must be a prefix of an attribute vector in some set  and all attribute vectors involved in  have prefixes in . This guarantees that the user with access structure  can use his existing shares to generate shares  for attribute vectors of authorized sets in . We note that in the delegation there is no requirement that the redefined access structure  must be
more restrictive than the original access structure  when new attributes are added. This is because those new attributes can be concatenated to the end of existing attribute vectors of  instead of being treated as new separate attributes that need to be assigned to new secret shares.

\subsection{System Model}
An APR-ABE system for message space  and access structure space  consists of the following five
polynomial-time algorithms:

\begin{itemize}
  \item  \textbf{Setup}: The setup algorithm takes no input other than the security parameter  and outputs the
      public key  and a master secret key .
  \item  \textbf{Encrypt}: The encryption algorithm takes as inputs a message , the public key  and a set  of
      attribute vectors. It outputs a ciphertext .
  \item  \textbf{KeyGen}: The key generation algorithm takes as inputs an access structure , the master
      secret  key  and public key . It outputs a secret key  for the access structure .
  \item  \textbf{Delegate}: The delegation algorithm takes as inputs a public key , a secret key  for an
      access structure  and another access structure . It outputs the secret key  for  if and only if
       and  satisfy the delegation condition.
  \item  \textbf{Decrypt}: The decryption algorithm takes as inputs a ciphertext  associated with a set  of
      attribute vectors, a secret key for an access structure , and the public key . If , it outputs ;
      otherwise, it outputs a false symbol .
\end{itemize}

The correctness property requires that for all sufficiently large , all universe descriptions , all , all , all  or , all , all , if  satisfies , then
 outputs .

\subsection{Security}
We now define the full security against chosen access structure and chosen-plaintext attacks in APR-ABE. In practice, malicious users are able to obtain the system public
key and, additionally, they may collude with other users by querying their secret keys. To capture these realistic attacks, we define an adversary  allowed to access the system public key, create attribute vectors and query secret keys for access structures he specifies. The adversary outputs two equal-length messages and a set of attribute vectors to be challenged. Then the full security states that not even such an adversary can distinguish with non-negligible
advantage the ciphertexts of the two messages
under the challenge set of attribute vectors, provided
that he has not queried the secret keys that can be used to decrypt the challenge ciphertext. Formally, the full security of APR-ABE is defined by a game played between a challenger  and an adversary  as follows.
\begin{itemize}
   \item \textbf{Setup}: The challenger  runs the setup algorithm and gives the public key  to .

   \medskip
   \item \textbf{Phase 1}:  sequentially makes queries  to , where  for 
       is one of the following three types:
   \begin{itemize}
     \item {\sf Create}.  specifies an access structure . In response,  creates a
         key for this access structure by calling the key generation algorithm, and places this key in the set  which is initialized to empty. He only gives  a reference to this key, not the key itself.
     \item {\sf Delegate}.  specifies a key  associated with  in the set  and an access structure  . If allowed by the delegation algorithm,  produces a key  for
         . He adds  to the set  and again gives  only a reference to it, not the actual key.
     \item {\sf Reveal}.  specifies a key in the set .  gives this key to the
         attacker and removes it from the set .
   \end{itemize}

\medskip
   \item \textbf{Challenge}:  declares two equal-length messages  and  and a set  of attribute vectors
       with an added restriction that for any revealed key  for access structure ,  and for any new key  for access structure
        that can be delegated from a revealed one, .  then flips a random coin , and
       encrypts  under , producing . He gives  to .

       \medskip
   \item \textbf{Phase 2}:   sequentially makes queries  to  just as in Phase 1, with the
       restriction that neither the access structure of any revealed key nor the access structure of any key that can be delegated from a revealed one
contain .

       \medskip
   \item \textbf{Guess}:  outputs a guess .
\end{itemize}

The advantage of  in this game is defined as  We note that the model above
is for {\em chosen-plaintext } attacks and one can easily extend this model to handle {\em chosen-ciphertext} attacks by allowing decryption queries in
Phase 1 and  Phase 2.

\begin{definition}\label{KP-Security}
We say that an APR-ABE system is fully secure if all Probabilistic Polynomial-Time (PPT) attackers  have at most a negligible advantage in the
above game.
\end{definition}

\section{The Access Policy Redefinable Attribute-based Encryption Scheme}
\label{scheme}
In this section, we construct an APR-ABE with short ciphertexts. The proposed scheme is proven to be fully secure in the standard model.

\subsection{Basic Idea}

We first introduce the basic idea driving
the construction of the APR-ABE scheme.
We base the scheme on the KP-ABE scheme in \cite{LOS+10} and we exploit the
delegation mechanism used in several HIBE schemes (e.g., \cite{BBG05,LW10}).
The key point of this delegation mechanism is
to hash an identity vector to a group
element, which internally associates the identity vector with a ciphertext or a secret key. When introducing this mechanism into our APR-ABE, which involves multiple attribute vectors in a ciphertext or a secret key, we assign a key component to each attribute vector and randomize every key component  to resist collusion attacks.

On the other hand, LSSS have been widely used
in many ABE schemes \cite{ALP11,LOS+10,LW11,Wat11}. In our APR-ABE scheme,
an LSSS is used to generate
a share for each attribute vector of authorized sets in an access structure. The linear reconstruction property of LSSS guarantees that the shares of all attribute vectors in an authorized set can recover the secret. To realize a delegation not limited to
 more restrictive access policies, we must additionally manage to generate shares for new incoming attributes. However, without knowing the secret, delegators cannot directly generate new shares.
To overcome this problem, we concatenate the new incoming attributes to the end of existing attribute vectors to form new attribute vectors and use the existing shares to generate shares for the new attribute vectors. Specifically, to achieve the access structure control, each share of an attribute vector is blinded in the exponent of a key component. Then, to generate new shares, we lift a key component of an existing attribute vector to the power of a random exponent and define the resulting exponent as the new blinded share for the new attribute vector. Since LSSS satisfies linearity, the randomization of shares can still reconstruct the secret.

To realize the above idea, we slightly extend LSSS to handle attribute vectors. For an access structure , we generate an 
share-generating matrix  ( is the number of attribute vectors involved in ). The inner product of the
-th row vector of  and a vector taking the secret as the first coordinate is the share for the -th row. We define an {\em injection} function 
which maps the -th row of the matrix  to an attribute vector. Then  is the LSSS for . The {\em injection}
function means that an attribute vector is associated with at most one row of .

\subsection{The Proposal}

We are now ready to describe our APR-ABE scheme, which is built from bilinear groups of a composite order , as defined in Section 2.3. The
ciphertexts are generated in the subgroup . The keys are first generated in  and then randomized in . The
subgroup  is only used to implement semi-functionality in the security proofs.
\begin{itemize}
  \item  \textbf{ Setup}: Run . Let
       denote the subgroup of order  for . Choose random generators . Choose
      random elements  for all  and .
      The public key and the master secret key arei
             
      

      \medskip
  \item  \textbf{Encrypt}: Encrypt a message  under a set  of attribute vectors of depth . Choose a random  and compute
       
       For each  from 1 to , choose a random element . Recall that for each attribute vector  of , the first coordinate  actually has two subscripts, denoted by , representing that  is the -th entry of the first row in the attribute matrix. Then, choose  corresponding to  from the public key and compute
       

      Define the ciphertext (including ) as
       

       \medskip
  \item  \textbf{KeyGen}: The algorithm generates an LSSS  for , where
       is the share-generating matrix with  rows and  columns, and  maps each row of  to an attribute vector of
      depth . Choose  random elements  to form a vector 
      For each  from 1 to , compute , where  is the -th row vector of . Let  be the attribute vector mapped by  from the -th row. Assume that the first coordinate  of  is the -th entry of the first row in the attribute matrix and choose  correspondingly. Then, select random elements  and  to compute
      
      
      
      Set the secret key (including
      ) to be
      

      \medskip
  \item \noindent \textbf{Delegate}: The algorithm generates a secret key  for  by using
      the secret key
      
      for , where  is an access structure over  attribute vectors of depth  and  is an access structure
      over  attribute vectors of depth . If  and  satisfy the delegation condition, the algorithm works as follows.

      ~~~~For each  involved in , find its prefix  in  such that
      . Suppose that  is associated with the -th row of the share-generating matrix of . Choose
      random elements  and random group elements  for each  from 1 to . Then pick the key 
component   of 
      from  to compute the key component for :


       
       
       
       
       
       This implicitly sets , where  is the random exponent used in creating the key component for
       . The value  is random since  is picked randomly.
       Finally, output
       
       Note that this key is identically distributed as the one directly generated by \textbf{KeyGen}.

\medskip
  \item  \textbf{Decrypt}: Given a ciphertext  for  of attribute
      vectors of depth  and a secret key
    for access structure  over attribute vectors of
   depth , if , compute the constants  such that 
      Let  be the -th attribute vector in . Compute:
      
      Output .
\end{itemize}

\begin{remark}
In the key delegation, when delegating a secret key for  from a secret key for , an LSSS  for  is
simultaneously generated: the share-generating matrix  is formed by setting the -th row as , where  is the
-th row of the share-generating matrix of ; the function  maps the -th row to the attribute vector . The value
 is the share for , where  is the share for
.
\end{remark}

\noindent\textbf{Correctness.} Observe that\\





It follows that . The  parts are canceled out because of the orthogonality property.

\subsubsection{Computational Complexity}

We analyze the computational complexity of the 
main algorithms of the APR-ABE scheme, i.e., key generation, key delegation, encryption and decryption. The proposed scheme is built in bilinear groups 
 and , and most computations take place in the subgroup . Therefore we evaluate the times  and  
consumed by the basic group operations, bilinear map and exponentiation in , respectively. We do not take into account the multiplication operation since it consumes negligible time compared to  and .

Table \ref{com-complexity} summarizes the time consumed by the main algorithms of the APR-ABE scheme. In this table,  denotes the maximum depth of the system,  the number of attribute vectors associated with a secret key,  the number of attribute vectors associated with a delegated key,  the depth of the user delegating a key or the attribute vectors associated with a ciphertext, and  is the number of attribute vectors of a set satisfying an access policy in the decryption. We can see that the time cost by the key generation algorithm grows linearly with the product of  and , but is independent of the user's depth. The time consumed by the delegation is related to the depth of the delegator and decreases as the depth grows. Encryption takes time linear in the product of the cardinality of the set  and the depth of the attribute vectors in . The ciphertexts of APR-ABE are short in that they are only linear in the cardinality of . This makes the time consumed by decryption linear in the number of matching attribute vectors and independent of depth. This feature 
is comparable to the up-to-date KP-ABEs \cite{GPS+06,LOS+10,HW13}, which nonetheless do not allow the flexible key delegation achieved in our scheme.


\begin{table}[!t]
\renewcommand{\arraystretch}{1.5}
\caption{Computation}
\label{com-complexity}
\centering
\begin{tabular}{|c|c|}
\hline Algorithm & Computational Complexity \\
\hline
\bfseries Key Generation & \\
\hline
\bfseries Key Delegation & \\
\hline
\bfseries Encryption &  \\
\hline
\bfseries Decryption &  \\
\hline
\end{tabular}
\end{table}

\subsubsection{Security}
The new APR-ABE scheme has full security, which means that any polynomial-time attacker cannot get useful information about the messages encrypted in ciphertexts if he does not have correct secret keys. Formally, the full security is guaranteed by Theorem \ref{KP-security}.
\begin{theorem}\label{KP-security} The Access Policy 
Redefinable Attribute-based Encryption scheme is fully secure in the standard model if Assumptions 1, 2 and 3 hold.
\end{theorem}

Our proof exploits the dual system encryption methodology \cite{Wat09}. This  approach  has been shown to be a powerful tool in proving the full security of properly designed HIBE and ABE schemes (e.g., \cite{LW10,LW11,LOS+10,Wat09}). Following this proof framework, we construct semi-functional keys and  ciphertexts for APR-ABE. A semi-functional APR-ABE key (semi-functional key for short) can be used to decrypt normal ciphertexts; and a semi-functional APR-ABE ciphertext (semi-functional ciphertext for short) can be decrypted by using normal keys. However, a semi-functional key cannot be used to decrypt a
semi-functional ciphertext. As in most proofs adopting dual system encryption, there is a subtlety that the simulator can test the nature of the challenge
key by using it to try to decrypt the challenge ciphertext. To avoid this paradox, we make sure that the decryption on input the challenge key is always
successful by cleverly setting the random values involved in the challenge key and challenge ciphertext. We also need to prove that these values are
uniformly distributed from the view of the adversary who cannot query the key able to decrypt the ciphertext.


In the following proof, we define a sequence of games arguing that an attacker cannot distinguish one game from the next. The first game is ,
which denotes the real security game as defined in Definition \ref{KP-Security}. The second game is , which is the same as 
except that the attacker  does not ask the challenger  to delegate keys. The third game is , in which all keys are normal, but the challenge ciphertext is semi-functional. Let  denote the number of key queries made by . For all , we define , in which the first  keys are semi-functional and the remaining keys are normal, while the challenge ciphertext is semi-functional. Note that when , in , all keys are semi-functional. The last game is defined as  where all keys are semi-functional and the ciphertext is a
semi-functional encryption of a random message. We will prove that these games are indistinguishable under Assumptions 1, 2 and 3.


The semi-functional ciphertexts and keys are constructed as follows.

\medskip
\noindent\textbf{Semi-functional ciphertext.} Let  denote the generator of . We first invoke \textbf{Encrypt} to form a normal
ciphertext

We choose a random element  and for all , select random exponents . Set the semi-functional ciphertext to be


\medskip
\noindent\textbf{Semi-functional key.} We first call algorithm \textbf{KeyGen} to form normal key

Then we choose random elements  for the -th row of the share-generating matrix . We choose random elements
 and a random vector  . The semi-functional key
is set as:




\medskip

\begin{remark} When we use a semi-functional key to decrypt a semi-functional ciphertext, we will have an extra term

If  and , then the extra term
happens to be one, which means that the decryption still works. We say that the keys satisfying this condition are \emph{nominally} semi-functional keys.
We will show that a nominally semi-functional key is identically distributed as a regular semi-functional key in the attacker's view.
\end{remark}

\begin{lemma}\label{lem1}~For any attacker , 
\end{lemma}
\begin{proof} From the construction of our APR-ABE, the keys from the key generation algorithm are identically distributed as the keys from the delegation
algorithm. Therefore, in 's view, there is no difference between these two kinds of games.\qed
\end{proof}
\begin{lemma}\label{lem2} If   can distinguish  from  with advantage , then we can establish an algorithm
 to break Assumption 1 with advantage .
\end{lemma}
\begin{proof} We construct an algorithm  to simulate  or  to interact with  by using the tuple
 of Assumption 1.

\medskip
\noindent\textbf{Setup}: Algorithm  selects a random . For all  and , it chooses random
elements  and computes . It provides  with public
key:


\noindent\textbf{Key generation Phase 1}, \textbf{Phase 2}: Note that  knows the master key . Therefore,  can run
\textbf{KeyGen} to generate normal keys in Phase 1 and Phase 2.

\medskip
\noindent\textbf{Challenge}:  gives two equal-length messages  and , and a set  of
attribute vectors
to .  then uses the  in the given tuple to form a semi-functional or normal ciphertext as follows.

 flips a random coin . For all , it chooses random elements . Finally,
it  sets the semi-functional ciphertext  to be:


If assuming , this implicitly sets

but there is neither unwanted correlation between values  and values , nor correlation between
 and  by the Chinese Remainder Theorem. Thus, the  part of the ciphertext is unrelated to
the  part.

\medskip
\noindent\textbf{Guess}:  If ,  is a properly distributed semi-functional ciphertext. Hence we are in . If , by implicitly setting ,  is a properly distributed normal ciphertext. Hence we are in . If  outputs
 such that , then  outputs 0. Therefore, with the tuple , we have that the advantage of  in breaking
Assumption 1 is


where  is the advantage of  in  and  is the advantage of
 in .
\qed

\end{proof}

\begin{lemma}\label{lem3} If   can distinguish  from  with advantage , then we can construct an algorithm
 to break Assumption 2 with advantage .
\end{lemma}

\begin{proof} We construct an algorithm  to simulate  or  to interact with  by using the tuple
 of Assumption 2.

\medskip
\noindent\textbf{Setup}: The public key  generated by  is the same as that in Lemma 2. Algorithm  gives  to
.

\medskip
\noindent\textbf{Challenge}: For convenience, we bring the Challenge phase before Phase1. This will not affect the security proof. When 
queries the challenge ciphertext with two equal-size messages  and a set  of attribute vectors,  flips a random coin
 and randomly chooses  for all . It sets the ciphertext to be
        
        
        
By assuming , this implicitly sets

Again there is no correlation between values  and values , nor is there any correlation between  and  by the Chinese Remainder Theorem. Thus the  part is unrelated to the  part of
this ciphertext. Therefore, this ciphertext is a well distributed semi-functional ciphertext.

\medskip
\noindent\textbf{Key generation Phase 1}, \textbf{Phase 2}: For the first  key queries,  simulates the semi-functional keys. For a
queried , it first calls the key generation algorithm to generate an LSSS  and a normal key  for this LSSS. Then, for each  from 1 to ,  picks a random element .  also chooses random elements
. Finally  chooses a random vector  and computes the
secret key:




If we assume  for some , this implicitly sets  Thus this key is identically
distributed as the semi-functional key.

For the rest of key queries but the -th one,  simulates normal keys. Because  knows the master key , it can easily
create the normal keys by running the key generation algorithm.

To respond to the -th key query on an access structure , algorithm  will either simulate a normal key or a semi-functional key
depending on . Algorithm  generates an LSSS for  to prepare for key generation. It creates a vector  with
the first coordinate equal to  and the remaining  coordinates picked randomly in .  also creates a vector
 with the first coordinate equal to 0 and the remaining  coordinates picked randomly in . For each row  of
,  chooses random elements
 and  
Then  computes:



If , by assuming , this implicitly sets
 and 
Thus this key is identically distributed as the normal key. If , by assuming , this implicitly sets:

and

Since  are created by  in  and  are created by  in , there is no unwanted correlation
between the  part and the  part by the Chinese Remainder Theorem. Similarly, the fact
 will not result in unwanted correlation between the
  and the   of this key.

When the simulator  uses the -th key to decrypt the semi-functional ciphertext  to test whether the key is normal or
semi-functional, it will obtain


This is because from the simulation of semi-functional ciphertext we have that  and from the simulation of the -th key, we have that   Moreover, since the inner product


Thus, when  uses the -th key to decrypt the semi-functional ciphertext, the decryption will still work and the -th key is
nominally semi-functional. Now, we argue that the nominally semi-functional key is identically distributed as a semi-functional key in 's
view. That is, if  is prevented from asking the -th key that can decrypt the challenge ciphertext, the fact that 
( is set as the first coordinate of ) should be information-theoretically hidden in 's view.

Because the -th key cannot decrypt the challenge ciphertext, the vector  is linearly independent of , which is a
submatrix of  and contains only those rows that satisfy . From the basics of linear algebra and similarly to Proposition 11 in
\cite{LOS+10}, we have the following proposition:

\begin{proposition}~A vector  is linearly independent of a set of vectors represented by a matrix  if and only if there exists a
vector  such that  while 
\end{proposition}

Since  is linearly independent of , a vector  must exist such that for each row , it holds that

Then for the fixed vector , we can write

where  is uniformly distributed and reveals no information about . We note that  can not be determined from
 alone, some information about  is also needed.
If , then . Thus, no information about  is revealed and  is hidden.
If , then 
This equation introduces a random element , where  is random and appears only once because  is injective. Hence if not
all of the  values are congruent to 0 modulo , no information about  is revealed. The probability that all 's are 0 modulo  is negligible.
Therefore, the value being shared in  is information-theoretically hidden in 's view with probability close to 1. Hence,
 simulates the semi-functional keys with a probability close to 1.

\medskip
\noindent\textbf{Guess}: If , we are in . If , we are in . If  outputs
,  outputs 0. Then, with the input tuple , the advantage of  in breaking Assumption 2 is:



\noindent where  is the advantage of  in  and  is the
advantage of  in .
\qed
\end{proof}

\begin{lemma}\label{lem4}~If   can distinguish  from  with advantage , then we can construct an algorithm
 that contradicts Assumption 3 with advantage .
\end{lemma}

\begin{proof} We construct  to simulate  or  to interact with  by using the tuple  of Assumption 3.

\medskip
\noindent\textbf{Setup}: For all  and all ,  chooses random exponents  and computes 
Then it sets
 and gives  to . We note that  does not know
the secret .

\medskip
\noindent\textbf{Key generation Phase 1}, \textbf{Phase 2}: To simulate the semi-functional keys for ,  first generates an LSSS
 for . It then selects two vectors: , which has the first coordinate set to 1 and the remaining 
coordinates randomly chosen in , and , which has the first coordinate set to 0 and the remaining  coordinates randomly
chosen in
. We note that this implicitly sets 

For the -th row  of , algorithm  chooses random elements 
 randomly chooses  and computes the key as follows:

By assuming , this implicitly sets 
We also note that the values being shared in  are properly randomized by . Therefore, this key is identically distributed as the
semi-functional key in 's view.

\medskip
\noindent\textbf{Challenge}: When  is given two equal-length messages  and  and a set  of attribute vectors,  flips a
random coin  and chooses  for all . Then it sets the ciphertext to be:



Assuming , this implicitly sets  and  
but again there is neither correlation between  and , nor correlation between
 and  by the Chinese Remainder Theorem.

If , then this ciphertext is the semi-functional ciphertext of message . If  is a random element in , this
ciphertext is a semi-functional encryption of a random message.

\medskip
\noindent\textbf{Guess}: If , we are in . If  is a random element in , we are in .
 outputs 0 when  outputs . Given the tuple , the advantage of
 in breaking Assumption 3 is:



where  is the advantage of  in  and  is the advantage of
 in .
\qed
\end{proof}
From all the lemmas proven above, the proof of Theorem 1 follows:
\begin{proof}
In , the ciphertext completely hides the bit , so the advantage of  in this game is negligible. 
Through Lemmas~\ref{lem1}, \ref{lem2}, \ref{lem3} and~\ref{lem4},
we have shown that the real security game  is indistinguishable from . Therefore, the advantage of
 in  is negligible. Hence, there is no polynomial-time adversary with a non-negligible advantage in breaking our
APR-ABE system. This completes the proof of Theorem 1. \qed
\end{proof}



\section{Conclusion}
\label{conclusion}
We revisited KP-ABE and proposed a dynamic ABE  referred to as APR-ABE. APR-ABE distinguishes itself from other KP-ABE schemes by providing a delegation mechanism that allows a user to redefine the access policy and delegate a secret key without making the redefined access policy more restrictive. This feature renders APR-ABE especially suitable to e-healthcare record systems where {\em a priori} specification
of access policies for secret keys is too rigid or simply not practical.
We constructed an APR-ABE scheme with short ciphertexts and proved its full security in the standard model under several non-interactive assumptions.

\section*{Acknowledgements and disclaimer}
We thank the anonymous reviewers for their valuable suggestions.
The following funding sources are gratefully acknowledged:
Natural Science Foundation of China (projects 61370190, 61173154, 61272501, 61402029, 61202465 and 61472429), China National Key Basic Research Program (973 program, project 2012CB315905), Beijing Natural Science Foundation 
(project 4132056), Fundamental Research Funds for the Central Universities of 
China, Research Funds of Renmin University (No. 14XNLF02), European 
Commission (projects FP7 ``DwB'', FP7 ``Inter-Trust'' and H2020 ``CLARUS''), 
Spanish Govt. (project TIN2011-27076-C03-01), Govt. of Catalonia 
(ICREA Acad\`emia Prize to the fourth author). The fourth author
leads the UNESCO Chair in Data Privacy, but the views in this paper
do not commit UNESCO.  



\begin{figure}
\label{fig:1}       \end{figure}
\begin{figure*}
\label{fig:2}       \end{figure*}








\begin{thebibliography}{11}




\bibitem {ALP11} Attrapadung, N., Libert, B., De Panafieu, E. Expressive Key-Policy Attribute-Based Encryption with Constant-Size Ciphertexts. PKC 2011. LNCS 6571, pp. 90-108. Springer (2011)

\bibitem {Bei96} Beimel, A. Secure Schemes for Secret Sharing and Key Distribution. PhD thesis, Israel Institute of Technology, Technion, Haifa, Israel (1996)

\bibitem {BSW07} Bethencourt, J., Sahai, A., Waters, B. Ciphertext-Policy Attribute-Based Encryption.  IEEE Symp. Sec. \& Priv. 2007, pp.
321-334. IEEE Press (2007)



\bibitem {BBG05} Boneh, D., Boyen, X., Goh, E. Hierarchical Identity Based Encryption with Constant Size Ciphertex.  EUROCRYPT 2005. 
LNCS 3493, pp. 440-456. Springer (2005)



\bibitem {BGN05} Boneh, D., Goh E., Nissim, K.: Evaluating 2-DNF Formulas on Ciphertexts.  TCC 2005. LNCS 3378, pp. 325-341. Springer (2005)

\bibitem
{BNS13} Boneh, D., Nikolaenko, V.,  Segev G. Attribute-Based Encryption for Arithmetic Circuits. Cryptology ePrint Archive, Report 2013/669, 2013, https://eprint.iacr.org/2013/669.pdf



\bibitem
{GJP+08} Goyal, V., Jain, A., Pandey, O., Sahai, A. Bounded Ciphertext Policy Attribute Based Encryption. ICALP 2008. LNCS 5126, pp. 579-591. Springer (2008)

\bibitem {GPS+06} Goyal, V., Pandey, O., Sahai, A., Waters, B. Attribute-Based Encryption for Fine-Grained Access Control of Encrypted Data.  ACM CCS 2006, pp. 89-98. ACM Press (2006)

\bibitem
{HW13} Hohenberger, S., Waters, B. Attribute-Based Encryption with Fast Decryption. PKC 2013. LNCS 7778,
pp. 162-179. Springer (2013)

\bibitem{Hur11}
Hur, J. Fine-grained Data Access Control for Distributed Sensor Networks. Wireless Networks, 17(5), 1235-1249 (2011).



\bibitem {LOS+10} Lewko, A., Okamoto, T., Sahai, A., Takashima, K., Waters, B. Fully Secure Functional Encryption: Attribute-Based Encryption and (Hierarchical)
Inner Product Encryption.  EUROCRYPT 2010. LNCS 6110, pp. 62-91. 
Springer (2010)

\bibitem {LW10} Lewko, A., Waters, B. New Techniques for Dual System Encryption and Fully Secure HIBE with Short Ciphertexts.  TCC 2010.
LNCS 5978, pp. 455-479. Springer (2010)

\bibitem {LW11} Lewko, A., Waters, B. Unbounded HIBE and Attribute-Based Encryption.  EUROCRYPT 2011. LNCS 6632, pp. 547-567.
Springer (2011)







\bibitem
{LWW+11} Li, J., Wang, Q., Wang, C., Ren, K. Enhancing Attribute-Based Encryption with Attribute Hierarchy. ChinaCom 2009, pp. 1-5. IEEE Press (2009)

\bibitem{LYZ+13}
Li, M., Yu, S., Zheng, Y., Ren, K., Lou, W. Scalable and Secure Sharing of Personal Health Records in Cloud Computing Using Attribute-based Encryption. Parallel and Distributed Systems, IEEE Transactions on, 24(1), 131-143 (2013).

\bibitem{LBL+12}
Liang, X., Barua, M., Lu, R., Lin, X., Shen, X. S. HealthShare: Achieving Secure and Privacy-preserving Health Information Sharing Through Health Social Networks. Computer Communications, 35(15), 1910-1920 (2012).







\bibitem {OSW07} Ostrovsky, R., Sahai, A., and Waters, B. Attribute-Based Encryption with Non-monotonic Access Structures. ACM CCS 2007, pp. 195-203. ACM Press (2007)



\bibitem
{RW13} Rouselakis, Y., Waters, B. Practical Constructions and New Proof Methods for Large Universe Attribute-based Encryption.  ACM CCS 2013, pp. 463-474. ACM Press (2013)

\bibitem {SW05} Sahai, A., Waters, B. Fuzzy Identity-Based Encryption.  EUROCRYPT 2005. LNCS 3494, pp. 457-473. Springer
(2005)





\bibitem {Wat09} Waters, B. Dual System Encryption: Realizing Fully Secure IBE and HIBE under Simple Assumptions. CRYPTO 2009. 
LNCS 5677, pp. 619-636. Springer (2009)

\bibitem {Wat11} Waters, B. Ciphertext-Policy Attribute-Based Encryption: An Expressive, Efficient, and Provably Secure Realization. PKC 2011. LNCS 6571, pp. 53-70. Springer (2011)

\bibitem
{WLD12} Wan, Z., Liu, J., Deng, R.H. HASBE: A Hierarchical Attribute-Based Solution for Flexible and Scalable Access Control in Cloud Computing. Information Forensics and Security, IEEE Transactions on, 7(2), pp. 743-754, 2012.

\bibitem
{WLW10} Wang, G., Liu, Q., Wu, J. Hierarchical Attribute-Based Encryption for Fine-Grained Access Control in Cloud Storage Services.  ACM CCS 2010, pp. 735-737. ACM Press (2010)

\bibitem{YRL11}
Yu, S., Ren, K., Lou, W. FDAC: Toward Fine-grained Distributed Data Access Control in Wireless Sensor Networks. Parallel and Distributed Systems, IEEE Transactions on, 22(4), 673-686 (2011).




\end{thebibliography}

\end{document}
