\documentclass{article}


\usepackage[nonatbib,final]{neurips_2019}

\usepackage[
    backend=biber,
    style=authoryear,
    maxcitenames=2,
    maxbibnames=99,
    giveninits=true,
    uniquename=init,
    natbib=true,
    dashed=false
]{biblatex}

\DeclareNameAlias{sortname}{first-last}
\setlength\bibitemsep{0.45\baselineskip}

\AtEveryBibitem{\clearfield{month}
    \clearfield{isbn}
    \clearfield{issn}
    \clearfield{pages}
    
}
\addbibresource{library.bib}

\usepackage[utf8]{inputenc} \usepackage[T1]{fontenc}    \usepackage{hyperref}       \usepackage{url}            \usepackage{booktabs}       \usepackage{amsfonts}       \usepackage{nicefrac}       \usepackage{textcomp}       \usepackage{microtype}      \usepackage{appendix}
\usepackage[table,xcdraw]{xcolor}

\usepackage{nicefrac}

\usepackage{todonotes}
\usepackage{subcaption}
\usepackage[linesnumbered,ruled,vlined]{algorithm2e}
\usepackage{bm} 

\usepackage{wrapfig} 

\usepackage{fontawesome} \usepackage[hang,flushmargin]{footmisc} 


\usepackage[normalem]{ulem} 

\usepackage[inline]{enumitem} \newlist{compactdesc}{description}{3}
\setlist[compactdesc]{topsep=0pt,partopsep=0pt,itemsep=0pt,parsep=0pt}

\usepackage{mlmacros} 

\usepackage{amsmath} \usepackage[nameinlink,capitalise]{cleveref} 

\usepackage{placeins}  

\usepackage{pifont}  \newcommand{\cmark}{\ding{51}}\newcommand{\xmark}{\ding{55}}

\usepackage{array}  

\newcommand*{\defeq}{\mathrel{\vcenter{\baselineskip0.5ex \lineskiplimit0pt
                     \hbox{\scriptsize.}\hbox{\scriptsize.}}}=}

\presetkeys{todonotes}{backgroundcolor=blue!10!white,
  linecolor=blue!10!white,
  bordercolor=blue!10!white
}{}

\usepackage[skip=5pt,font=small]{caption}
\usepackage{subcaption}
\captionsetup{font=small}
\captionsetup[sub]{font=footnotesize}

\usepackage{titlesec}


\setlength\textfloatsep{1.\baselineskip plus 3pt minus 2pt}

\newcommand{\comment}[1]{} \newcommand{\ak}[1]{\textcolor{blue}{\textbf{ak}: #1}}
\newcommand{\sas}[1]{\textcolor{pink}{\textbf{sas}: #1}}
\newcommand{\yw}[1]{\textcolor{orange}{\textbf{yw}: #1}}
\newcommand{\gh}[1]{\textcolor{purple}{\textbf{gh}: #1}}
\newcommand{\sh}[1]{\textcolor{blue}{\textbf{sh}: #1}}

\newcommand{\apart}{{\tiny \faCube}}
\newcommand{\awhole}{{\footnotesize \faCubes}}
\newcommand{\acamera}{{\footnotesize \faVideoCamera}}

\variables{a,c,d,t,u,v,x,y,z}
\probdists{p,q}

\newcommand{\MLP}{\operatorname{MLP}}
\newcommand{\RNN}{\operatorname{RNN}}
\newcommand{\STN}{\operatorname{ST}}
\newcommand{\bern}{\operatorname{Bernoulli}}
\newcommand{\cat}{\operatorname{Categorical}}
\newcommand{\dir}{\operatorname{Dirichlet}}
\newcommand{\pa}{\operatorname{pa}}

\definecolor{pink}{HTML}{ff00ff}
\definecolor{orange}{HTML}{ff9900}
\definecolor{blue}{HTML}{0000ff}

\SetKw{Continue}{continue}

\renewcommand{\baselinestretch}{0.97}

\setlength{\abovedisplayskip}{1pt}
\setlength{\belowdisplayskip}{1pt}

 \usepackage[acronym,smallcaps,nowarn,section,nogroupskip,nonumberlist]{glossaries}

\glsdisablehyper 


\newacronym{VAE}{vae}{variational auto-encoder}
\newacronym{IWAE}{iwae}{importance-weighted auto-encoder}
\newacronym{SSM}{ssm}{state-space model}
\newacronym{SGD}{sgd}{stochastic gradient descent}
\newacronym{ELBO}{elbo}{evidence lower bound}
\newacronym{KL}{kl}{Kullback-Leibler}
\newacronym{LSTM}{lstm}{long short-term memory}
\newacronym{CNN}{cnn}{convolutional neural networks}
\newacronym{MML}{mml}{maximum marginal likelihood}

\newacronym{REINFORCE}{reinforce}{REINFORCE}
\glsunset{REINFORCE}
\newacronym{RL}{rl}{reinforcement learning}

\newacronym{ADAM}{adam}{adam}
\glsunset{ADAM}
\newacronym{RMSprop}{rmsprop}{RMSprop}
\glsunset{RMSprop}

\newacronym{GAN}{gan}{generative adversarial network}
\newacronym{GRU}{gru}{gated recurrent unit}
\newacronym{MLP}{mlp}{multilayer perceptron}
\newacronym{MC}{mc}{Monte Carlo}
\newacronym[firstplural=recurrent neural networks, plural=RNNs]{RNN}{rnn}{recurrent neural network}

\newacronym{MNIST}{mnist}{mnist}
\glsunset{MNIST}

\newacronym{MI}{mi}{mutual information}
\newacronym{CPC}{cpc}{contrastive predictive coding}
\newacronym{ICA}{ica}{independent component analysis}

\newacronym{CCR}{ccr}{capsule-camera-relationship}
\newacronym{CPR}{cpr}{capsule-part-relationship}
\newacronym{GMM}{gmm}{gaussian mixture model}
\newacronym{GQN}{gqn}{generative query network}
\newacronym{CCA}{cca}{Constellaton Capsule Autoencoder}
\newacronym{SCA}{sca}{Stacked Capsule Autoencoder}
\newacronym{ICAE}{icae}{Image Capsule Autoencoder}

\newacronym{OV}{ov}{object-viewer-relationship}
\newacronym{PV}{pv}{part-viewer-relationship}
\newacronym{OP}{op}{object-part-relationship}
\newacronym{SCAu}{scae}{Stacked Capsule Autoencoder}
\newacronym{PCAu}{pcae}{Part Capsule Autoencoder}
\newacronym{OCAu}{ocae}{Object Capsule Autoencoder}
\newacronym{CCAu}{ccae}{Constellation Capsule Autoencoder}

\newacronym[firstplural=degrees of freedom, plural=DoFs]{DOF}{dof}{degree of freedom} 
\title{
Stacked Capsule Autoencoders}


\author{
  Adam R.~Kosiorek
  \!\thanks{This work was done during an internship at Google Brain.}
  \  \\
  \href{mailto:adamk@robots.ox.ac.uk}{\texttt{adamk@robots.ox.ac.uk}}
  \And
  Sara Sabour\\
  \And
  Yee Whye Teh\\
  \And
  Geoffrey E. Hinton \\
  \AND
   Applied AI Lab\\
  \ \ Oxford Robotics Institute \\
  \ \  University of Oxford
  \And
 Department of Statistics \\
  \ \ University of Oxford
  \And
   Google Brain\\
  \ \ Toronto \\
  \And
   DeepMind\\
  \ \ London \\
}

\begin{document}

\maketitle

\begin{abstract}
Objects are composed of a set of geometrically organized parts. We introduce an unsupervised capsule autoencoder (\textsc{scae}), which explicitly uses geometric relationships between parts to reason about objects.
 Since these relationships do not depend on the viewpoint, our model is robust to viewpoint changes.
\textsc{Scae} consists of two stages.
In the first stage, the model predicts presences and poses of part templates directly from the image and tries to reconstruct the image by appropriately arranging the templates.
In the second stage, \textsc{scae} predicts parameters of a few object capsules, which are then used to reconstruct part poses.
Inference in this model is amortized and performed by off-the-shelf neural encoders, unlike in previous capsule networks.
We find that object capsule presences are highly informative of the object class, which leads to state-of-the-art results for unsupervised classification on \textsc{svhn} (55\%) and \textsc{mnist} (98.7\%).
\end{abstract} \section{Introduction}

\begin{wrapfigure}{r}{.3\textwidth}
	\centering
	\includegraphics[width=\linewidth]{figs/tsne}
	\caption{
		\textsc{Scae}s learn to explain different object classes with separate object capsules, thereby doing unsupervised classification. 
		Here, we show \textsc{tsne} embeddings of object capsule presence probabilities for  \textsc{mnist} digits.
		Individual points are color-coded according to the corresponding digit class.
	}
	\label{fig:tsne}
	\vspace*{-2em}
\end{wrapfigure}

\Gls{CNN} work better than networks without weight-sharing because of their inductive bias: if a local feature is useful in one image location, the same feature is likely to be useful in other locations. It is tempting to exploit other effects of viewpoint changes by replicating features across scale, orientation and other affine degrees of freedom, but this quickly leads to cumbersome, high-dimensional feature maps.

An alternative to replicating features across the non-translational degrees of freedom is to explicitly learn transformations between the natural coordinate frame of a whole object and the natural coordinate frames of each of its parts.   Computer graphics relies on such objectpart coordinate transformations to represent the geometry of an object in a viewpoint-invariant manner. Moreover, there is strong evidence that, unlike standard \gls{CNN}s, human vision also relies on coordinate frames: imposing an unfamiliar coordinate frame on a familiar object makes it challenging to recognize the object or its geometry \citep{Rock73, Hinton79}.

A neural system can learn to reason about transformations between objects, their parts and the viewer, but each kind of transformation will likely need to be represented differently.
An \gls{OP} is viewpoint-invariant, approximately constant and could be easily coded by learned weights.  
The relative coordinates of an object (or a part) with respect to the viewer change with the viewpoint (they are viewpoint-equivariant), and could be easily coded with neural activations\footnote{
	This may explain why accessing perceptual knowledge about objects, when they are not visible, requires creating a mental image of the object with a specific viewpoint.
}.

With this representation, the pose of a single object is represented by its relationship to the viewer.
Consequently, representing a single object does not necessitate replicating neural activations across space, unlike in \glspl{CNN}.
It is only processing two (or more) different instances of the same type of object in parallel that requires spatial replicas of both model parameters and neural activations.

In this paper we propose the \gls{SCAu}, which has two stages (\cref{fig:capsule_arch}).
The first stage, the \gls{PCAu}, segments an image into constituent parts, infers their poses, and reconstructs the image by appropriately arranging affine-transformed part templates.
The second stage, the \gls{OCAu}, tries to organize discovered parts and their poses into a smaller set of objects.
These objects then try to reconstruct the part poses using a separate mixture of predictions for each part. 
Every object capsule contributes components to each of these mixtures by multiplying its pose---the \gls{OV}---by the relevant \glsreset{OP}\gls{OP}.

Stacked Capsule Autoencoders (\Cref{sec:caps_decoders}) capture spatial relationships between whole objects and their parts when trained on unlabelled data.
The vectors of presence probabilities for the object capsules tend to form tight clusters (cf.\ \Cref{fig:tsne}), and when we assign a class to each cluster we achieve state-of-the-art results for unsupervised classification on \textsc{svhn} (55\%) and \textsc{mnist} (98.7\%), which can be further improved to 67\% and 99\%, respectively, by learning fewer than 300 parameters 
(\Cref{sec:experiments}).
We describe related work in \Cref{sec:related_work} and discuss implications of our work and future directions in \Cref{sec:discussion}.
The code is available at {\small \href{https://github.com/google-research/google-research/tree/master/stacked_capsule_autoencoders}{\texttt{github.com/google-research/google-research/tree/master/stacked\_capsule\_autoencoders}}}.

\begin{figure}
    \centering
    \begin{minipage}[c]{0.68\linewidth}
        \centering
        \includegraphics[width=\linewidth]{figs/blocks_v4}
    \end{minipage}
    \hfill
    \begin{minipage}[c]{0.3\linewidth}
        \centering
        \caption{
            Stacked Capsule Autoencoder (\textsc{scae}):
            (a) \textit{part} capsules segment the input into parts and their poses. The poses are then used to reconstruct the input by affine-transforming learned templates.
            (b) \textit{object} capsules try to arrange inferred poses into objects, thereby discovering underlying structure.
            \textsc{scae} is trained by maximizing image and part log-likelihoods subject to sparsity constraints.
        }
        \label{fig:capsule_arch}
    \end{minipage}
\end{figure} \section{Stacked Capsule Autoencoders (\textsc{scae})}
\label{sec:caps_decoders}

Segmenting an image into parts is non-trivial, so we begin by abstracting away pixels and the part-discovery stage, and develop the \gls{CCAu} (\Cref{sec:constellation}).
It uses two-dimensional points as parts, and their coordinates are given as the input to the system. \Gls{CCAu} learns to model sets of points as arrangements of familiar constellations, each of which has been transformed by an independent similarity transform. The \gls{CCAu} learns to assign individual points to their respective constellations—without knowing the number of constellations or their shapes in advance.  Next, in Section 2.2, we develop the \glsreset{PCAu}\gls{PCAu} which learns to infer parts and their poses from images. Finally, we stack the \glsreset{OCAu}\gls{OCAu}, which closely resembles the \gls{CCAu}, on top of the \gls{PCAu} to form the \glsreset{SCAu}\gls{SCAu}.



\subsection{Constellation Autoencoder (\textsc{ccae})}
\label{sec:constellation}

Let  be a set of two-dimensional input points, where every point belongs to a constellation as in \Cref{fig:constellations}.
We first encode all input points (which take the role of part capsules) with Set Transformer \citep{Lee2019set}---a permutation-invariant encoder  based on attention mechanisms---into  object capsules.
An object capsule  consists of a capsule feature vector , its presence probability  and a  \glsreset{OV}\gls{OV} matrix, which represents the affine transformation between the object (constellation) and the viewer.
Note that each object capsule can represent only one object at a time.
Every object capsule uses a separate \gls{MLP}  to predict  part candidates from the capsule feature vector .
Each candidate consists of the conditional probability  that a given candidate part exists, an associated scalar standard deviation , and a  \glsreset{OP}\gls{OP} matrix, which represents the affine transformation between the object capsule and the candidate part\footnote{Deriving these matrices from capsule feature vectors allows for deformable objects, see \Cref{app:deformations} for details.}.
Candidate predictions  are given by the product of the object capsule \gls{OV} and the candidate \gls{OP} matrices.
We model all input points as a single Gaussian mixture, where  and  are the centres and standard deviations of the isotropic Gaussian components.
See \Cref{fig:capsule_arch,fig:sca_arch} for illustration; formal description follows:


The model is trained without supervision by maximizing the likelihood of part capsules in \Cref{eq:constellation_likelihood} subject to sparsity constraints, \textit{cf}.\ \Cref{sec:losses,app:constellation_caps_sparsity}.
The part capsule  can be assigned to the object capsule  by looking at the mixture component responsibility, that is .\footnote{We treat parts as independent and evaluate their probability under the same mixture model. While there are no clear 1:1 connections between parts and predictions, it seems to work well in practice.}
\begin{figure} 
	\centering
	\begin{minipage}[c]{0.35\linewidth}
		\centering
		\includegraphics[width=\linewidth]{figs/consinvert5}
	\end{minipage}
	\hfill
	\begin{minipage}[c]{0.63\linewidth}
		\centering
		\caption{
			Unsupervised segmentation of points belonging to up to three constellations of squares and triangles at different positions, scales and orientations. 
			The model is trained to reconstruct the points (top row) under the \gls{CCAu} mixture model. The bottom row colours the points based on the parent with the highest posterior probability in the mixture model. 
			The right-most column shows a failure case.
			Note that the model uses sets of points, not pixels, as its input; we use images  only to visualize the constellation arrangements.
		}
		\label{fig:constellations}
	\end{minipage}
\end{figure}
Empirical results show that this model is able to perform unsupervised instance-level segmentation of points belonging to different constellations, even in data which is difficult to interpret for humans. See \Cref{fig:constellations} for an example and \Cref{sec:constellation_expr} for details.

\subsection{Part Capsule Autoencoder (\textsc{pcae})}
\label{sec:img_capsule}
\comment{\begin{figure}
		\centering
		\includegraphics[width=.6\linewidth]{figs/image_capsule}
		\caption{\ak{}{redo the figure} Image capsule network.
			An \gls{MLP} predicts poses (black dots) of the low-level capsules that correspond to object-parts from the image.
			Higher-level object capsules are activated by another \gls{MLP} that receives the states of the low-level capsules as input. The high-level object capsules then try to predict the parameters of lower-level part capsules.
			Each object capsule predicts each part capsule separately, and the poses of the part capsules are modelled by a mixture model of different predictions.
			Finally, reconstructed poses of the part capsules are used to transform learned templates, which are then put together into an image reconstruction.
		}
		\label{fig:image_capsule}
	\end{figure}
}
Explaining images as geometrical arrangements of parts requires 1) discovering what parts are there in an image and 2) inferring the relationships of the parts to the viewer (their pose).
For the \gls{CCAu} a part is just a 2D point (that is, a (x, y) coordinate), but for the \gls{PCAu} each part capsule  has a six-dimensional pose  (two rotations, two translations, scale and shear), a presence variable  and a unique identity.
We frame the part-discovery problem as auto-encoding: the encoder learns to infer the poses and presences of different part capsules, while the decoder learns an image template  for each part (\cref{fig:learned_templates}) similar to \cite{Tieleman2014thesis,Eslami2016air}.
If a part exists (according to its presence variable), the corresponding template is affine-transformed with the inferred pose giving .
Finally, transformed templates are arranged into the image.
The \gls{PCAu} is followed by an \glsreset{OCAu}\gls{OCAu}, which closely resembles the \gls{CCAu} and is described in \Cref{sec:ocae}.

Let  be the image.
We limit the maximum number of part capsules to  and use an encoder to infer their poses , presence probabilities , and special features , one per part capsule.
Special features can be used to alter the templates in an input-dependent manner (we use them to predict colour, but more complicated mappings are possible). The special features also inform the \gls{OCAu} about unique aspects of the corresponding part (\!\eg occlusion or relation to other parts).
Templates  are smaller than the image , but have an additional alpha channel which allows occlusion by other templates. 
We use  to refer to the alpha channel and  to refer to its colours.

We allow each part capsule to be used only once to reconstruct an image, which means that parts of the same type are not repeated\footnote{We could repeat parts by using multiple instances of the same part capsule.}.
To infer part capsule parameters we use a \gls{CNN}-based encoder followed by \textit{attention-based pooling}, which is described in more detail in the \Cref{app:attention_based_pooling} and whose effects on the model performance are analyzed in \Cref{sec:ablation}.

The image is modelled as a spatial Gaussian mixture, similarly to \cite{Greff2019multi, Burgess2019monet, Engelcke2019genesis}.
Our approach differs in that we use pixels of the transformed templates (instead of component-wise reconstructions) as the centres of isotropic Gaussian components, but we also use constant variance.
Mixing probabilities of different components are proportional to the product of presence probabilities of part capsules and the value of the learned alpha channel for every template.
More formally:

Training the \gls{PCAu} results in learning templates for object parts, which resemble strokes in the case of \textsc{mnist}, see \Cref{fig:learned_templates}.
This stage of the model is trained by maximizing the image likelihood of \Cref{eq:im_likelihood}.

\subsection{Object Capsule Autoencoder (\textsc{ocae})}
\label{sec:ocae}

\begin{figure}
	\centering
	\begin{minipage}[c]{.7\linewidth}
		\includegraphics[width=\linewidth]{figs/templates}
	\end{minipage}
	\hfill
	\begin{minipage}[c]{.29\linewidth}
		\caption{Stroke-like templates learned on \textsc{mnist} (left) as well as sobel-filtered \textsc{svhn} (middle) and \textsc{cifar10} (right).
			For \textsc{svhn} they often take the form of double strokes due to sobel filtering.
		}
		\label{fig:learned_templates}
	\end{minipage}
\end{figure}
\begin{figure}
	\centering
	\begin{subfigure}[c]{.06\linewidth}
		\includegraphics[width=\linewidth]{figs/mnist/inputs}
		\caption{}
	\end{subfigure}
	\begin{subfigure}[c]{.06\linewidth}
		\includegraphics[width=\linewidth]{figs/mnist/recs}
		\caption{}
	\end{subfigure}
	\begin{subfigure}[c]{.03967\linewidth}
		\includegraphics[width=\linewidth]{figs/mnist/acts}
		\caption{}
	\end{subfigure}
	\begin{subfigure}[c]{.12\linewidth}
		\includegraphics[width=\linewidth]{figs/mnist/caps_recs}
		\caption{}
	\end{subfigure}
	\begin{subfigure}[c]{.30\linewidth}
		\includegraphics[width=\linewidth]{figs/mnist/transformed_templates}
		\caption{}
	\end{subfigure}
	\begin{minipage}[c]{.35\linewidth}
		\caption{
			\textsc{Mnist} (a) images, (b) reconstructions from part capsules in red and object capsules in green, with overlapping regions in yellow.
			Only a few object capsules are activated for every input (c) a priori (left) and even fewer are needed to reconstruct it (right).
			The most active capsules (d) capture object identity and its appearance;
			(e) shows a few o  f the affine-transformed templates used for reconstruction.
		}
		\label{fig:mnist_rec}
	\end{minipage}
\end{figure}

Having identified parts and their parameters, we would like to discover objects that could be composed of them\footnote{
	Discovered objects are {\it not} used top-down to refine the presences or poses of the parts during inference. However, the derivatives backpropagated via \gls{OCAu} refine the lower-level encoder network that infers the parts.
}.
To do so, we use concatenated poses , special features  and flattened templates  (which convey the identity of the part capsule)
as an input to the \gls{OCAu}, which differs from the \gls{CCAu} in the following ways.
Firstly, we feed part capsule presence probabilities  into the \gls{OCAu}'s encoder---these are used to bias the Set Transformer's attention mechanism not to take absent points into account.
Secondly, s are also used to weigh the part-capsules' log-likelihood, so that we do not take log-likelihood of absent points into account. 
This is implemented by raising the likelihood of the m part capsule to the power of , \textit{cf}. \Cref{eq:constellation_likelihood}.
Additionally, we stop the gradient on all of \gls{OCAu}'s inputs except the special features to improve training stability and avoid the problem of collapsing latent variables; see\eg \cite{Rasmus2015ladder}.
Finally, parts discovered by the \gls{PCAu} have independent identities (templates and special features rather than 2D points).
Therefore, every part-pose is explained as an independent mixture of predictions from object-capsules---where every object capsule makes exactly  candidate predictions , or exactly {\bf one} candidate prediction per part.
Consequently, the part-capsule likelihood is given by,

The \gls{OCAu} is trained by maximising the part pose likelihood of \Cref{eq:mod_constellation_likelihood}, and it learns to discover further structure in previously identified parts, leading to learning sparsely-activated object capsules, see \Cref{fig:mnist_rec}.
Achieving this sparsity requires further regularization, however.

\subsection{Achieving Sparse and Diverse Capsule Presences}
\label{sec:losses}
Stacked Capsule Autoencoders are trained to maximise pixel and part log-likelihoods ().
If not constrained, however, they tend to either use all of the part and object capsules to explain every data example or collapse onto always using the same subset of capsules, regardless of the input.
We want the model to use different sets of part-capsules for different input examples and to specialize object-capsules to particular arrangements of parts. 
To encourage this, we impose sparsity and entropy constraints.  We evaluate their importance in \Cref{sec:ablation}.

We first define prior and posterior object-capsule presence as follows.
For a minibatch of size {\small} with {\small} object capsules and  part capsules we define a minibatch of prior capsule presence  with dimension {\small} and posterior capsule presence  with dimension {\small} as,

respectively; the former is the maximum presence probability among predictions from object capsule  while the latter is the unnormalized mixing proportion used to explain part capsule~.
\begin{description}[leftmargin=\parindent]
	\item[Prior sparsity]
	Let  the sum of presence probabilities of the object capsule  among different training examples, and  the sum of object capsule presence probabilities for a given example.
	If we assume that training examples contain objects from different classes uniformly at random and we would like to assign the same number of object capsules to every class, then each class would obtain  capsules.
	Moreover, if we assume that only one object is present in every image, then  object capsules should be present for every input example, which results in the sum of presence probabilities of  for every object capsule.
	To this end, we minimize, 
	
	\item[Posterior Sparsity]
	Similarly, we experimented with minimizing the within-example entropy of capsule posterior presence  and maximizing its between-example entropy , where  is the entropy, and where  and  are the the normalized versions of  
	and , respectively.
	The final loss reads as
	
	Our ablation study has shown, however, that the model can perform equally well without these posterior sparsity constraints, cf. \Cref{sec:ablation}.
\end{description}
\begin{figure}
	\centering
	\includegraphics[width=\linewidth]{figs/sca_architecture_v3}
	\caption{\gls{SCAu} architecture.}
	\label{fig:sca_arch}
\end{figure}
\cref{fig:sca_arch} shows the schematic architecture of \gls{SCAu}. We optimize a weighted sum of image and part likelihoods and the auxiliary losses. 
Loss weight selection process, as well as the values used for experiments, are detailed in \Cref{app:models}.

In order to make the values of presence probabilities ( and ) closer to binary we inject uniform noise  into logits, similar to \cite{Tieleman2014thesis}.
This forces the model to predict logits that are far from zero to avoid stochasticity and makes the predicted presence probabilities close to binary.
Interestingly, it tends to work better in our case than using the Concrete distribution \citep{Maddison2017concrete}. \section{Evaluation}
\label{sec:experiments}

The decoders in the \gls{SCAu} use explicitly parameterised affine transformations
that allow the encoders’ inputs to be explained with a small set of transformed objects or parts. 
The following evaluations show how the embedded geometrical knowledge helps to discover patterns in data.
Firstly, we show that the \gls{CCAu} discovers underlying structures in sets of two-dimensional points, thereby performing instance-level segmentation.
Secondly, we pair an \gls{OCAu} with a \gls{PCAu} and investigate whether the resulting \gls{SCAu} can discover structure in real images.
Finally, we present an ablation study that shows which components of the model contribute to the results.

\subsection{Discovering Constellations}
\label{sec:constellation_expr}


We create arrangements of constellations online, where every input example consists of up to 11 two-dimensional points belonging to up to three different constellations (two squares and a triangle) as well as binary variables indicating the presence of the points (points can be missing).
Each constellation is included with probability  and undergoes a similarity transformation, whereby it is randomly scaled, rotated by up to 180\textdegree\ and shifted.
Finally, every input example is normalised such that all points lie within .
Note that we use sets of points, and not images, as inputs to our model.

We compare the \gls{CCAu} against a baseline that uses the same encoder but a simpler decoder: the decoder uses the capsule parameter vector  to directly predict the location, precision and presence probability of each of the four points as well as the presence probability of the whole corresponding constellation. 
Implementation details are listed in 
\Cref{app:constellation_model}.

Both models are trained unsupervised by maximising the part log-likelihood.
We evaluate them by trying to assign each input point to one of the object capsules.
To do so, we assign every input point to the object capsule with the highest posterior probability for this point, \textit{cf}. \Cref{sec:constellation}, and compute segmentation accuracy (\!\ie the true-positive rate).

The \gls{CCAu} consistently achieves\footnote{This result requires using an additional sparsity loss described in \Cref{app:constellation_caps_sparsity}; without it the \gls{CCAu} achieves around  error.} below  error with the best model achieving 
, while the best baseline achieved  error using the same budget for hyperparameter search.
This shows that wiring in an inductive bias towards modelling geometric relationships can help to bring down the error by an order of magnitude—at least in a toy setup where each set of points is composed of familiar constellations that have been independently transformed.

\subsection{Unsupervised Class Discovery in Images}
\label{sec:cls_experiments}



We now turn to images in order to assess if our model can simultaneously learn to discover parts and group them into objects.
To allow for multimodality in the appearance of objects of a specific class, we typically use more object capsules than the number of class labels. 
It turns out that the vectors of presence probabilities form tight clusters as shown by their \textsc{tsne} embeddings \citep{Maaten2008tsne} in \Cref{fig:tsne}---note the large separation between clusters corresponding to different digits, and that only a few data points are assigned to the wrong clusters.
Therefore, we expect object capsules presences to be highly informative of the class label.
To test this hypothesis, we train \gls{SCAu} on \textsc{mnist}, \textsc{svhn}\footnote{We note that we tie the values of the alpha channel  and the color values  which leads to better results in the \textsc{svhn} experiments.} and \textsc{cifar10} and try to assign class labels to vectors of object capsule presences.
This is done with one of the following methods: 
\textsc{lin-match}: after finding 10 clusters\footnote{All considered datasets have 10 classes.} with \textsc{kmeans} we use bipartite graph matching \citep{Kuhn1955hungarian} to find the permutation of cluster indices that minimizes the classification error---this is standard practice in unsupervised classification, see\eg \cite{Ji2018iic};
\textsc{lin-pred}: we train a linear classifier with supervision given the presence vectors; this learns  weights and  biases, where  is the number of object capsules, but it does not modify any parameters of the main model.

In agreement with previous work on unsupervised clustering \citep{Ji2018iic,Hu2017imsat,Hjelm2019deepinfomax,Haeusser2018adc}, we train our models and report results on full datasets (\textsc{train}, \textsc{valid} and \textsc{test} splits).
The linear transformation used in \textsc{lin-pred} variant of our method is trained on the \textsc{train} split of respective datasets while its performance on the \textsc{test} split is reported.

We used an \gls{PCAu} with 24 single-channel  templates for \textsc{mnist} and 24 and 32 three-channel  templates for \textsc{svhn} and \textsc{cifar10}, respectively.
We used sobel-filtered images as the reconstruction target for \textsc{svhn} and \textsc{cifar10}, as in \cite{Jaiswal2018capsule}, while using the raw pixel intensities as the input to \gls{PCAu}.
The \gls{OCAu} used 24, 32 and 64 object capsules, respectively.
Further details on model architectures and hyper-parameter tuning are available in \Cref{app:models}.
All results are presented in \Cref{tab:results}.
\gls{SCAu} achieves state-of-the-art results in unsupervised object classification on \textsc{mnist} and \textsc{svhn} and under-performs on \textsc{cifar10} due to the inability to model backgrounds, which is further discussed in \Cref{sec:discussion}.

\begin{table}
	\centering
	\begin{minipage}[c]{.28\linewidth}
		\centering
		\caption{
			Unsupervised classification results in \% with (standard deviation) are averaged over 5 runs. Methods based on mutual information are shaded. Results marked with  use data augmentation,  use \textsc{imagenet}-pretrained features instead of images, while  are taken from \cite{Ji2018iic}. We highlight the best results and those that are are within its 98\% confidence interval according to a two-sided t test.
		}
		\label{tab:results}
	\end{minipage}
	\hfill
	\begin{minipage}[c]{.7\linewidth}
		\centering
		\small
		\begin{tabular}{@{}llll@{}}
			Method & \textsc{mnist} & \textsc{cifar10} & \textsc{svhn} \\
			\midrule
			\textsc{kmeans} (\cite{Haeusser2018adc}) & 53.49 & 20.8 & 12.5 \\
			\textsc{ae} (\cite{Bengio2007greedy}) & 81.2 & 31.4 & - \\
			\textsc{gan} (\cite{Radford2016gan}) & 82.8 & 31.5 & - \\
			\rowcolor[HTML]{EFEFEF} 
			\textsc{imsat} (\cite{Hu2017imsat}) & \textbf{98.4} (0.4) & 45.6 (0.8) & \textbf{57.3} (3.9) \\ 
			\rowcolor[HTML]{EFEFEF} 
			\textsc{iic} \citep{Ji2018iic} & \textbf{98.4} (0.6) & \textbf{57.6} (5.0) & - \\
			\rowcolor[HTML]{EFEFEF} 
			\textsc{adc} \citep{Haeusser2018adc} & \textbf{98.7} (0.6) & 29.3 (1.5) & 38.6 (4.1) \\
			\midrule
			\gls{SCAu} (\textsc{lin-match}) & \textbf{98.7 (0.35)} & 25.01 (1.0) & \textbf{55.33 (3.4)} \\ 
			\gls{SCAu} (\textsc{lin-pred}) & \textbf{99.0 (0.07)} & 33.48 (0.3) & \textbf{67.27 (4.5)} \\
		\end{tabular}
	\end{minipage}
\end{table}

\subsection{Ablation study}
\label{sec:ablation}
\gls{SCAu}s have many moving parts;
an ablation study shows which model components are important and to what degree.
We train \gls{SCAu} variants on \textsc{mnist} as well as a padded-and-translated  version of the dataset, where the original digits are translated up to 6 pixels in each direction.
Trained models are tested on \textsc{test} splits of both datasets; additionally, we evaluate the model trained on the  \textsc{mnist} on the \textsc{test} split of \textsc{affnist} dataset.
Testing on \textsc{affnist} shows whether the model can generalise to unseen viewpoints.
This task was used by \cite{Rawlinson2018sparsecaps} to evaluate Sparse Unsupervised Capsules, which achieved  accuracy. \Gls{SCAu} achieves , which indicates that it is better at viewpoint generalisation.
We choose the \textsc{lin-match} performance metric, since it is the one favoured by the unsupervised classification community.

Results are split into several groups and shown in \Cref{tab:ablation}.
We describe each group in turn.
Group a) shows that sparsity losses introduced in \Cref{sec:losses} increase model performance, but that the posterior loss might not be necessary.
Group b) checks the influence of injecting noise into logits for presence probabilities, \textit{cf}. \Cref{sec:losses}.  Injecting noise into part capsules seems critical, while noise in object capsules seems unnecessary---the latter might be due to sparsity losses.
Group c) shows that using similarity (as opposed to affine) transforms in the decoder can be restrictive in some cases, while not allowing deformations hurts performance in every case.

Group d) evaluates the type of the part-capsule encoder.
The \textsc{linear} encoder entails a \gls{CNN} followed by a fully-connected layer, while the \textsc{conv} encoder predicts one feature map for every capsule parameter, followed by global-average pooling. 
The choice of part-capsule encoder seems not to matter much for within-distribution performance; however, our attention-based pooling (cf.\ \Cref{app:attention_based_pooling}) does achieve much higher classification accuracy when evaluated on a different dataset, showing better generalisation to novel viewpoints.

Additionally, e) using Set Transformer as the object-capsule encoder is essential.
We hypothesise that it is due to the natural tendency of Set Transformer to find clusters, as reported in \cite{Lee2019set}.
Finally, f) using special features  seems not less important---presumably due to effects the high-level capsules have on the representation learned by the primary encoder.

\begin{table}
	\centering
	\begin{minipage}[c]{.24\linewidth}
		\caption{
			Ablation study on \textsc{mnist}. All used model components contribute to its final performance. \textsc{Affnist} results show out-of-distribution generalization properties and come from a model trained on  \textsc{mnist}. Numbers represent average \% and (standard deviation) over 10 runs. We highlight the best results and those that are are within its 98\% confidence interval according to a two-sided t test.
		}
		\label{tab:ablation}
	\end{minipage}
	\hfill
	\begin{minipage}[c]{.75\linewidth}
		\small
		\begin{tabular}{@{}lllll@{}}
			& Method & \textsc{mnist} &  \textsc{mnist} & \textsc{affnist} \\
			\midrule
			&full model & \textbf{95.3 (4.65)} & \textbf{98.7 (0.35)} & \textbf{92.2 (0.59)} \\
			\midrule
			a)& no posterior sparsity  & \textbf{97.5 (1.55)} & \textbf{95.0    (7.20)} & \textbf{85.3    (11.67)} \\
			& no prior sparsity  & 72.4 (22.39) & 88.2    (6.98) & 71.3    (5.46) \\
			& no prior/posterior sparsity  &    84.7 (3.01) &    82.0 (5.46) & 59.0 (5.66)\\
			\midrule
			b)& no noise in object caps &    \textbf{96.7 (2.30)} &    \textbf{98.5 (0.12)} &    \textbf{93.5 (0.38)}\\
			& no noise in any caps &    \textbf{93.1 (5.09)} &    78.5 (22.69) &    64.1 (26.74)\\
			&no noise in part caps    & \textbf{93.9 (7.16)} &    82.8 (24.83) &    70.7 (25.96)\\
			\midrule
			c)& similarity transforms &    \textbf{97.5 (1.55)} &    95.9 (1.59) &    88.9 (1.58)\\
			&no deformations    & 87.3 (21.48) &    87.2    (18.54) &    79.0    (22.44)\\
			\midrule
			d)&\textsc{linear} part enc & \textbf{98.0 (0.52)} &    63.2 (31.47)    & 50.8 (26.46)\\
			&\textsc{conv} part enc &    \textbf{97.6 (1.22)} &    \textbf{97.8    (.98)} &    81.6    (1.66)\\
			\midrule
			e)& \gls{MLP} enc for object caps    & 27.1 (9.03) &    36.3    (3.70) &    25.29    (3.69)\\
			f)& no special features &    90.7 (2.25) &    58.7 (31.60) &    44.5 (21.71)\\
		\end{tabular}
	\end{minipage}
\end{table} \section{Related Work}
\label{sec:related_work}

\paragraph{Capsule Networks}
Our work combines ideas from Transforming Autoencoders \citep{Hinton2011tae} and \textsc{em} Capsules \citep{Hinton2018capsule}.
Transforming autoencoders discover affine-aware capsule \textit{instantiation parameters} by training an autoencoder to reconstruct an affine-transformed version of the original image.
This model uses an additional input that explicitly represents the transformation, which is a form of supervision.
By contrast, our model does not need any input other than the image.

Both \textsc{em} Capsules and the preceding Dynamic Capsules \citep{Sabour2017capsule} use the poses of parts and learned partobject relationships to vote for the poses of objects. When multiple parts cast very similar votes, the object is assumed to be present, which is facilitated by an interactive inference (routing) algorithm. 
Iterative routing is inefficient and has prompted further research \citep{Wang2018optimization,Zhang2018fast,Li2018encapsule}.
In contrast to prior work, we use objects to predict parts rather than vice-versa; therefore we can dispense with iterative routing at inference time---every part is explained as a mixture of predictions from different objects, and can have only one parent.
This regularizes the \gls{OCAu}'s encoder to respect the single parent constraint when learning to group parts into objects.

Additionally, since it is the objects that predict parts, the part poses can have fewer degrees-of-freedom than object poses (as in the \gls{CCAu}). 
Inference is still possible because the \gls{OCAu} encoder makes object predictions based on {\it all} the parts.
This is in contrast to each individual part making its own prediction, as was the case in previous works on capsules.

A further advantage of our version of capsules is that it can perform unsupervised learning, whereas previous capsule networks used discriminative learning. 
\cite{Rawlinson2018sparsecaps} is a notable exception and used the reconstruction \gls{MLP} introduced in \cite{Sabour2017capsule} to train Dynamic Capsules without supervision.
Their results show that unsupervised training for capsule-conditioned reconstruction helps with generalization to \textsc{affnist} classification; we further improve on their results, \textit{cf}.\ \Cref{sec:ablation}.

\paragraph{Unsupervised Classification}
There are two main approaches to unsupervised object category detection in computer vision.
The first one is based on representation learning and typically requires discovering clusters or learning a classifier on top of the learned representation.
\cite{Eslami2016air,Kosiorek2018sqair} use an iterative procedure to infer a variable number of latent variables, one for every object in a scene, that are highly informative of the object class, while \cite{Greff2019multi,Burgess2019monet} perform unsupervised instance-level segmentation in an iterative fashion.
While similar to our work, these approaches cannot decompose objects into their constituent parts and do not provide an explicit description of object shape (\!\eg templates and their poses in our model).

The second approach targets classification explicitly by minimizing mutual information (\textsc{mi})-based losses and directly learning class-assignment probabilities.
\textsc{iic} \citep{Ji2018iic} maximizes an exact estimator of \textsc{mi} between two discrete probability vectors describing (transformed) versions of the input image.
DeepInfoMax \citep{Hjelm2019deepinfomax} relies on negative samples and maximizes \textsc{mi} between the predicted probability vector and its input via noise-contrastive estimation \citep{Gutmann2010nce}.
This class of methods directly maximizes the amount of information contained in an assignment to discrete clusters, and they hold state-of-the-art results on most unsupervised classification tasks.
\textsc{Mi}-based methods suffer from typical drawbacks of mutual information estimation: they require massive data augmentation and large batch sizes.
This is in contrast to our method, which achieves comparable performance with batch size no bigger than 128 and with no data augmentation.

\paragraph{Geometrical Reasoning}
Other attempts at incorporating geometrical knowledge into neural networks include exploiting equivariance properties of group transformations \citep{Cohen2016group} or new types of convolutional filters \citep{Mallat,Kocvok2016cyclic}.
Although they achieve significant parameter efficiency in handling rotations or reflections compared to standard \glspl{CNN}, these methods cannot handle additional degrees of freedom of affine transformations---like scale. \cite{Lenssen2018group} combined capsule networks with group convolutions to guarantee equivariance and invariance in capsule networks.
Spatial Transformers (\textsc{st}; \cite{Jaderberg2015}) apply affine transformations to the image sampling grid while steerable networks \citep{Cohen2016steerable,Jacobsen2017dynamic} dynamically change convolutional filters.
These methods are similar to ours in the sense that transformation parameters are predicted by a neural network but differ in the sense that \textsc{st} uses global transformations applied to the whole image while steerable networks use only local transformations.
Our approach can use different global transformations for every object as well as local transformations for each of their parts.


 \section{Discussion}
\label{sec:discussion}

The main contribution of our work is a novel method for representation learning, in which highly structured decoder networks are used to train one encoder network that can segment an image into parts and their poses and another encoder network that can compose the parts into coherent wholes.
Even though our training objective is not concerned with classification or clustering,
\gls{SCAu} is the only method that achieves competitive results in unsupervised object classification without relying on mutual information (\textsc{mi}).
This is significant since, unlike our method, \textsc{mi}-based methods require sophisticated data augmentation.
It may be possible to further improve results by using an \textsc{mi}-based loss to train \gls{SCAu}, where the vector of capsule probabilities could take the role of discrete probability vectors in \textsc{iic} \citep{Ji2018iic}.
\gls{SCAu} under-performs on \textsc{cifar10}, which could be because of using fixed templates, which are not expressive enough to model real data.
This might be fixed by building deeper hierarchies of capsule autoencoders (\!\eg complicated scenes in computer graphics are modelled as deep trees of affine-transformed geometric primitives) as well as using input-dependent shape functions instead of fixed templates---both of which are promising directions for future work.
It may also be possible to make a much better \gls{PCAu} for learning the primary capsules by using a differentiable renderer in the generative model that reconstructs pixels from the primary capsules.

Finally, the \gls{SCAu} could be the `figure' component of a mixture model that also includes a versatile `ground' component that can be used to account for everything except the figure.  A complex image could then be analyzed using sequential attention to perceive one figure at a time.  \section{Acknowledgements}
We would like to thank Sandy H.\,Huang for help with editing the manuscript and making \Cref{fig:capsule_arch}.
Additionally, we would like to thank S.\,M.\,Ali Eslami and Danijar Hafner for helpful discussions throughout the project. We also thank Hyunjik Kim, Martin Engelcke, Emilien Dupont and Simon Kornblith for feedback on initial versions of the manuscript. 
\pagebreak

\printbibliography

\newpage
\appendix
\section{Model Details}
\label{app:models}

\subsection{Constellation Experiments}
\label{app:constellation_model}
The \gls{CCAu} uses a four-layer Set Transformer as its encoder.
Every layer has four attention heads, 128 hidden units per head, and is followed by layer norm \citep{Ba2016layern}.
The encoder outputs three 32-dimensional vectors---one for each object capsule.
The decoder uses a separate neural net for each object capsule to predict all parameters used to model its points: this includes four candidate part predictions per capsule for a total of 12 candidates.
In this experiment, each objectpart relationship \gls{OP} is just a 2-D offset in the object's frame of reference (instead of a  matrix) and it is affine transformed by the corresponding \gls{OV} matrix to predict the 2-D point.

\subsection{Image Experiments}

We use a convolutional encoder for part capsules and a set transformer encoder \citep{Lee2019set} for object capsules.
Decoding from object capsule to part capsules is done with \glspl{MLP}, while the input image is reconstructed with affine-transformed learned templates.
Details of the architectures we used are available in \Cref{tab:arch}.
\begin{center}
\centering
    \captionof{table}{
        Architecture details. \textsc{S} in the last column means that the entry is the same as for \textsc{svhn}.
    }
    \label{tab:arch}
    \small
    \begin{tabular}{@{}lllll@{}}
        Dataset & Constellation & \textsc{mnist} & \textsc{svhn} & \textsc{cifar10} \\
        \midrule
        num templates & N/A & 24 & 24 & 32\\
        template size & N/A &  &  & \textsc{s}\\
        num capsules & 3 & 24 & 32 & 64\\
        part \textsc{cnn} & N/A & 2x(128:2)-2x(128:1) & 2x(128:1)-2x(128:2) & \textsc{s} \\
        set transformer & 4x(4-128)-32  & 3x(1-16)-256 & 3x(2-64)-128 & \textsc{s}
\end{tabular}
\end{center}

We use ReLu nonlinearities except for presence probabilities, for which we use sigmoids.
(128:2) for a \gls{CNN} means 128 channels with a stride of two.
All kernels are .
For set transformer (1-16)-256 means one attention head, 16 hidden units and 256 output units; it uses layer normalization \citep{Ba2016layern} as in the original paper \citep{Lee2019set} but no dropout. All experiments (apart from constellations) used 16 special features per part capsule.

For \textsc{svhn} and \textsc{cifar10}, we use normalized sobel-filtered images as the target of the reconstruction to emphasize the shape importance. \Cref{fig:svhn_recons} in \Cref{app:recs} shows examples of \textsc{svhn} and \textsc{cifar10} reconstruction.
The filtering procedure is as follows:
1) apply sobel filtering, 2) subtract the median color, 3) take the absolute value of the image, 4) normalize for image values to be .

All models are trained with the RMSProp optimizer \citep{Tieleman2012rms}  and .
Batch size is 64 for constellations and 128 for all other datasets.
The learning rate was equal to  for \textsc{mnist} and constellation experiments (without any decay), while we run a hyperparameter search for \textsc{svhn} and \textsc{cifar10}: we searched learning rates in the range of  to  and exponential learning rate decay of 0.96 every  or  weight updates. Learning rate of  was selected for both \textsc{svhn} and \textsc{cifar10}, the decay steps was  for \textsc{svhn} and  for \textsc{cifar10}.
The  accuracy on a validation set is used as a proxy to select the best hyperparameters---including weights on different losses, reported in \Cref{tab:hparams}.
Models were trained for up to  iterations on single Tesla V100 GPUs, which took 40 minutes for constellation experiments and less than a day for \textsc{cifar10}.

\begin{center}
\centering
    \captionof{table}{
        Loss weights values. The \textit{within} and \textit{between} quantifiers in sparsity losses corresponds to different terms of \Cref{eq:prior_sparsity,eq:posterior_sparsity}.
    }
    \label{tab:hparams}
    \small
    \begin{tabular}{@{}lllll@{}}
        Dataset & Constellation & \textsc{mnist} & \textsc{svhn} & \textsc{cifar10} \\
        \midrule
        part ll weight & 1 & 1 & 2.56 & 2.075 \\
        image ll weight & N/A & 1 & 1 & 1\\
        prior within sparsity & 1  & 1 & 0.22 & 0.17 \\
        prior between sparsity & 1  & 1 & 0.1 & 0.1 \\
        posterior within sparsity & 0 & 10 & 8.62 & 1.39 \\
        posterior between sparsity & 0 & 10 & 0.26 & 7.32 \\
        too-few-active-capsules & 10 & 0 & 0 & 0
\end{tabular}
\end{center}

\section{Reconstructions}
\label{app:recs}
\begin{center}
\begin{tabular}{ >{\centering\arraybackslash}m{.1\linewidth} >{\centering\arraybackslash}m{.85\linewidth}}
SVHN & 
    \includegraphics[width=\linewidth]{figs/svhn_recons.png}
\\
CIFAR10 & 
    \includegraphics[width=\linewidth]{figs/cifar_recons.png}
    \end{tabular}
    \captionof{figure}{10 Sample SVHN and Cifar10 reconstructions. First row shows Sobel filtered target image. Second row shows the reconstruction from Part Capsule Layer directly. Third row shows the reconstruction if we use the object predictions for the Part poses instead of Part poses themselves for reconstruction. The templates in this model has the same number of channels as the image, but they have converged to black and white templates and the reconstruction do not have color diversity. The \gls{SCAu} model is trained completely unsupervised but the reconstructions tend to focus on the center digit in SVHN and filter the rest of the clutter. }
    \label{fig:svhn_recons}
\end{center}

 \section{Constellation Capsule Sparsity}
\label{app:constellation_caps_sparsity}

We noticed that we can get better instance segmentation results in the constellation experiment when we add an additional sparsity loss, which says that every active object capsule should explain at least two parts.
We say that an object capsule has `won' a part if it has the highest posterior mixing probability for that part among other object capsules.
We then create binary labels for each of object capsules, where the label is  if the capsule wins at least two parts and it is  otherwise.
The final loss takes the form of binary cross-entropy between the generated label and the prior capsule presence. This loss is used only for the stand-alone constellation model experiments on point data, \textit{cf}. \Cref{sec:constellation,sec:constellation_expr}. \section{Modelling Deformable Objects}
\label{app:deformations}

Each object capsule votes for part capsules by contributing Gaussian votes to mixture models, where the centers of these Gaussians are a product of an object-viewer \gls{OV} matrix and an object-part \gls{OP} matrix, cf.\ \Cref{eq:op,eq:ov,eq:vkn,eq:component}.
Importantly, the   matrices  are a sum of a static component , which represents the mean shape of an object, and a dynamic component , which is a function of data, and can model deformations in objects' shape.
If an object capsule is to specialise to a specific object class, it should learn its mean shape.
Therefore we discourage large deformations, which also prevents an object capsule from modelling several objects at once.
Concretely, we add the weighted Frobenius norm of the deformation matrix  to the loss, where  is a weight set to a high value, typically  in our experiments. \section{Part Capsule Encoder with Attention-based Pooling}
\label{app:attention_based_pooling}

The \gls{PCAu} encoder consists of a \gls{CNN} followed by a bottom-up attention mechanism based on global-average pooling, which we call attention-based pooling. 
When global-average pooling is typically used, a feature map with  channels is averaged along its spatial dimensions resulting into a -dimensional vector.
This is useful for\eg counting features of a particular type, which can be useful for classification.
In our case, we wanted to predict pose and existence of a particular part, with the constraint that this part can exist at at most one location in the image.
In order to support this, we predict a  dimensional feature map, where the additional dimension represents softmax logits for attention.
Finally, we compute the weighted average of the feature map along its spatial dimensions, where the weights are given by the softmax.
This allows to predict different part parameters at different locations and weigh them by the corresponding confidence.

Concretely, for every part capsule , we use the \gls{CNN} to predict a feature map  of  capsule parameters with spatial dimensions \,, as well as a single-channel attention mask .
The final parameters for that capsule are computed as , where  is along the spatial dimensions. \end{document}
