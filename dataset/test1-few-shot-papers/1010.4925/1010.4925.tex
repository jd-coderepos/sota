\documentclass[11pt,english]{article}
\usepackage{courier}
\usepackage[T1]{fontenc}
\usepackage[latin9]{inputenc}
\usepackage{verbatim}
\usepackage{amsmath}
\usepackage{amssymb}

\makeatletter
\usepackage{hyperref}
\usepackage{amsfonts}
\usepackage{amsthm}
\usepackage{amsfonts}
\usepackage{multirow}
\usepackage{courier}
\usepackage{fullpage}
\usepackage{epsfig}
\usepackage{bm}
\usepackage{times}
\@ifundefined{definecolor}
 {\usepackage{color}}


\newtheorem{theorem}{Theorem}
\newtheorem{lem}{Lemma}
\newtheorem{lemma}[lem]{Lemma}
\newtheorem{fact}{Fact}
\newtheorem{corollary}{Corollary}
\newtheorem{conjecture}{Conjecture}
\newtheorem{claim}{Claim}
\newtheorem{obs}{Observation}
\newtheorem{prop}{Proposition}

\theoremstyle{definition}
\newtheorem{defn}{Definition}
\newtheorem{example}{Example}

\theoremstyle{remark}
\newtheorem*{rem}{Remark}

\makeatletter\def\imod#1{\allowbreak\mkern10mu({\operator@font mod}\,\,#1)}\makeatother

\newcommand{\Exp}{\operatornamewithlimits{\mathbb{E}}}
\newcommand{\pcube}{\operatorname{\{\pm1\}}}
\newcommand{\eps}{\epsilon}
\newcommand{\cube}{\operatorname{\{0, 1\}}}
\newcommand{\ncube}{\F_{2}^{n}}\newcommand{\kcube}{\F_{2}^{k}}\newcommand{\Had}{\text{Had}}
\newcommand{\F}{\mathbb{F}}
\newcommand{\C}{\mathbb{C}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\Z}{{\mathbb Z}}
\newcommand{\N}{{\mathbb N}}
\newcommand{\calf}{{\cal F}}
\newcommand{\calm}{{\cal M}}
\newcommand{\eqdef}{{\stackrel{\rm def}{=}}}

\newcommand{\proP}{\mathcal{P}}
\newcommand{\proPo}{\mathcal{P}_{1}}
\newcommand{\proPt}{\mathcal{P}_{2}}
\newcommand{\ozz}{\mathcal{P}_{\text{-}}}
\newcommand{\ooo}{\mathcal{P}_{\text{-}}}
\newcommand{\ooz}{\mathcal{P}_{\text{-}}}
\newcommand{\lin}{\mathcal{P}_{\mathbf{LIN}}}
\newcommand{\LBP}{\mathcal{P}_{\mathbf{NLTF}}}
\newcommand{\dist}{\text{dist}}
\newcommand{\supp}{\text{supp}}
\newcommand{\poly}{\text{poly}}

\begin{document}

\title{Property Testing via Set-Theoretic Operations}


\author{Victor Chen\thanks{Princeton University. \texttt{vychen@princeton.edu}.} \and Madhu Sudan\thanks{Microsoft Research New England. \texttt{madhu@microsoft.com}.
Research supported in part by NSF Award CCR-0514915.} \and Ning Xie\thanks{MIT CSAIL. \texttt{ningxie@csail.mit.edu}. Research supported in part
by NSF Award CCR-0514771, 0728645 and 0732334.} }

\date{}
\maketitle
\setcounter{page}{0}
\begin{abstract}
Given two testable properties  and ,
under what conditions are the union, intersection or set-difference
of these two properties also testable?
We initiate a systematic study of these basic set-theoretic operations in the context of property
testing.
As an application, we give a conceptually different proof
that linearity is testable, albeit with much worse query complexity.
Furthermore, for the problem of testing disjunction of linear functions,
which was previously known to be one-sided testable with a super-polynomial query
complexity, we give an improved analysis and show it has query complexity , where  is the distance parameter.
\end{abstract}

\newpage




\section{\texorpdfstring{Introduction}{1. Introduction}}
\label{Sec:Introduction} 

During the last two decades, the size of data sets has been increasing at an exponential rate, 
rendering a linear scan of the whole input an unaffordable luxury. 
Thus, we need \emph{sublinear time} algorithms that read a vanishingly small 
fraction of their input and still output something intelligent and non-trivial
 about the properties of the input. 
The model of property testing~\cite{RS96,GGR98} has been
very useful in understanding the power of sublinear time. 
Property testing is concerned with the existence of a sublinear time 
algorithm that queries an input object a small number of times and
decides correctly with high probability whether the object has a given
property or whether it is  ``far away'' from having the property.

We model input objects as strings of arbitrary length, 
which can also be viewed as a function on arbitrarily large domain. 
Formally, let  be a finite set and  be a 
parametrized family of domains. 
 denote the set of all functions
mapping from  to . A \emph{property }
is simply specified by a family of functions .
A \emph{tester} for property  is a randomized algorithm
which, given the oracle access to an input function 
together with a distance parameter , distinguishes with high
probability (say, ) between the case that  satisfies 
and the case that  is \emph{-far} from satisfying .
Here, distance between functions ,
denoted , is simply the probability that ,
where  is chosen uniformly at random from , and
. We say
 is \emph{-far} from  if 
and \emph{-close} otherwise. The central parameter associated
with a tester is the number of oracle queries it makes to the function
 being tested.

Property testing was first studied by Blum, Luby and Rubinfeld~\cite{BLR93}
and was formally defined by Rubinfeld and Sudan~\cite{RS96}. The
systematic exploration of property testing for combinatorial properties
was initiated by Goldreich, Goldwasser, and Ron~\cite{GGR98}. Subsequently,
a rich collection of properties have been shown 
to be testable~\cite{AS05,AS05b,AFNS06,BCLSSV06,PRS03,AKNS00,AKKLR03,KR04,JPRZ04}.

Perhaps the most fundamental question in property testing is the following:
which properties have {\em local} testing algorithms whose running time depends
only on the distance parameter ? Are there any attributes that
make a property locally testable? Questions of this type in the
context of graph property testing were first raised in~\cite{GGR98}
and later received a lot of attention. Some very general results have
been obtained~\cite{AFKS00,AS05,AS05b,FN07,AFNS06,BCLSSV06}, leading
to an (almost) complete qualitative understanding of which graph properties
are efficiently testable in the dense graph model (see~\cite{BSS08}
for some recent progress in the sparse graph model). In addition,
for an important class of properties, namely -freeness for fixed
subgraphs , it is known exactly for which , testing -freeness
requires the query complexity to be super-polynomial in 
and for which only a polynomial number of queries suffice: This was
shown by Alon~\cite{Alo02} for one-sided error testers and by Alon
and Shapira~\cite{AS04} for general two-sided error testers. Progress
toward similar understanding has also been made for hypergraph properties~\cite{RS09,AT08,AS05b}.

However, much less is known for algebraic properties. In a systematic study, 
Kaufman and Sudan~\cite{KS08} examined the query complexity
of a broad class of algebraic properties based on the invariance of
these properties under linear transformations. Roughly speaking, they
showed that any locally-characterized linear-invariant and \emph{linear}\footnote{A property  is linear if for any  and  that are in
 necessarily implies that  is in .} properties are testable with query complexities polynomial in .
Non-linear linear-invariant properties were first shown to be testable
by Green~\cite{Gre05} and were formally studied in~\cite{BCSX09}.
The properties studied in~\cite{Gre05,BCSX09} are ``pattern-freeness''
of Boolean functions, which has been attracting 
considerable attention~\cite{Gre05,BCSX09,Sha09,KSV08,BGS10}, 
as such a study may lead to a complete characterization of testability
for functions, analogous to the setting of graphs. 

\subsection{Motivation for set-theoretic operations}

In this paper we propose a new paradigm to systematically study algebraic property
testing.  First, decompose a natural algebraic property into the union
or intersection (or some other set operation) of a set of  ``atomic properties''. 
Second, try to show that each of these atomic properties is testable. 
Finally, prove that some  ``composite'' property obtained from 
applying some set theoretic operations on the
(testable) atomic properties is also testable. 
A prominent example is the set of low-degree polynomials~\cite{AKKLR03,KR04,JPRZ04}. It is easy
to see that the property of being a degree- polynomial over GF()
is simply the \emph{intersection} of  atomic properties. 
Indeed, let  denote the set of -variate
polynomials of degree at most . Then, by the characterization
of low-degree polynomials (see, e.g., \cite{AKKLR03}), 
if and only if for every , 


Now fix an ordering of the non-trivial subsets of . 
Let  be a bit-string of length  with an odd number of ones and
 denote the set of functions  such that the string 
 is not equal to .
By definition,  is the intersection of  ``-free'' properties 
's.\footnote{In fact, some of these  properties are identical 
since the set of non-trivial subsets generated by  is invariant under permutation of the 's.} 

In order to carry out this program of decomposing an algebraic properties into atomic ones, 
one must have a solid understanding of how basic set-theoretic operations affect testability. 
For instance, given two testable properties, is the union, intersection, 
or set-difference also testable? 
Previously, Goldreich, Goldwasser and Ron 
considered such questions in their seminal paper~\cite{GGR98}. 
They observed that the union of two testable properties 
is always testable (cf. Section~\ref{Sec:union}) but
also provided examples showing that in general, testability is not
closed under other set-theoretic operations. 
Thus, current understanding of testability via set-theoretic operations 
seems insufficient to carry out the above mentioned program of attack. 

\subsection{Our results}

In this paper, we show more positive results for these basic set-theoretic
operations and illustrate several applications. We now describe our
contribution in more detail.

\paragraph{Set-theoretic operations}

We provide sufficient conditions that allow local testability to be closed
under intersection and set difference. Given two locally testable properties,
we show that if the two properties (minus their intersection) are
sufficiently far apart, then their intersection is also locally testable.
For set difference, a similar statement can also be made, albeit with
more technicality, requiring that one of the properties must be   ``tolerantly
testable''. 

A more detailed treatment of these set operations appears in Section~\ref{Sec:theory}.
We remark that in the general case, testability is not closed under
most set operations. Thus, putting restrictions on these properties
is not unwarranted. 

Applications of these set-theoretic considerations appear in Sections~\ref{Sec:linearity}
and~\ref{Sec:LB}. Furthermore, Section~\ref{Sec:LB} demonstrates
the simplicity that comes from these set-theoretic arguments. 
There, via set theory, we define a new property from an established one, and show that 
the new property's testability, in terms of both upper and lower bounds, is
inherited from the previous property. 

\paragraph{Disjunction of linear functions}
In addition to set theory, it is also natural to ask whether testability 
is preserved under the closure of some fundamental, unary operations. 
For instance, given a testable property , 
under what condition is its additive closure  testable? 
A similar question can also be asked 
for the disjunctive operator , 
which is one of the most basic operations used to combine formulas. 
Given a testable property , is its disjunctive closure  testable? 

Trivially, if  is linear, then  and testability is preserved.
Furthermore, if  and  are both linear 
and linear-invariant as introduced by Kaufman and Sudan~\cite{KS08}, 
then their sumset  is testable. 
However, in general, not much can be said 
about how these basic operations affect testability.

Here we focus on disjunction's effect on one specific property, namely the set of linear functions. 
Before we describe our result, we note some previous works in testing where disjunction played a role. 
For the disjunction of monomials,
Parnas et. al.~\cite{PRS03} gave a testing algorithm for -term monotone DNF with
query complexity . 
Diakonikolas et. al.~\cite{DLM+07} generalized Parnas et. al.'s result
to general -term DNF with query complexity .  

We take a different direction and ask how disjunction affects 
the testability of the set of linear functions.
The property of being a linear Boolean function (see next section for a full discussion), 
first studied by Blum, Luby and Rubinfeld~\cite{BLR93}, 
is testable with query complexity .
As observed in~\cite{BCSX09}, 
the class of disjunction of linear functions 
is equal to the class of -free functions (see Preliminaries for a definition). 
There they showed that a sufficiently rich class of ``pattern-free'' functions 
is testable, albeit with query complexity a tower of 's whose height is a function of .
In a different context, the authors in~\cite{GOSSW} showed implicitly\footnote{We thank an anonymous reviewer from ICS 2011 for pointing this out.}
that the disjunction of linear functions 
is testable with query complexity polynomial in , but with two-sided error.

Since both \cite{BCSX09} and \cite{GOSSW} seek to describe rich classes of testable Boolean functions, 
the bounds from both works do not adequately address how disjunction 
affects the query complexity of the underlying property, the set of linear functions. 
In Section~\ref{Sec:100-free}, we give a direct proof, 
showing that the disjunction of linear functions is testable 
with query complexity  and has one-sided error. 
Thus, the blowup from the disjunctive operator is . 
It will be interesting to see if the blowup is optimal for this problem.

\paragraph{A different proof for linearity testing}
Linearity testing, first proposed by Blum, Luby and Rubinfeld~\cite{BLR93},
is arguably the most fundamental and extensively studied problem in
property testing of Boolean functions. Due to its simplicity and important
applications in PCP constructions, much effort has been devoted to
the study of the testability of linearity~\cite{BLR93,BGLR93,BGS98,BCHKS96,Kiw03}.

For linearity, we indeed are able to carry out the program of decomposing
an algebraic property into atomic pattern-free properties, and thus
obtain a novel new proof that linearity is testable in Section~\ref{Sec:linearity}.
In particular, linearity is easily seen to be equal to the intersection
of two atomic properties, namely triangle-freeness (see Section~\ref{Sec:prelim})
and disjunction of linear functions, which are both testable. 

The query complexity of linearity in our proof is of the tower-type,
drastically worse than the optimal  bound, where 
is the distance parameter. 
We note that our effort in obtaining a new proof lies not in improving the parameters, 
but in understanding
the relationships among these atomic, testable properties. 
In fact, we believe that despite the poor upper bound, our new proof is conceptually
simple and gives evidence that set theory may uncover new testable
properties. 


\subsection{Techniques}

Our new proof that linearity is testable is built on the testability
results for triangle freeness (see definition in Section~\ref{Sec:prelim})
and the disjunction of linear functions. 
The latter was already shown to be testable in~\cite{BCSX09}.
However, in this work, we give a completely different proof using a BLR-styled approach. 
Our proof is a novel variant of the classical self-correction method. 
Consequently, the query upper bound we obtain (quadratic in ) is significantly
better than the tower-type upper bound shown in~\cite{BCSX09}. 
In fact, to the best of our knowledge, this is the first and only polynomial query 
upper bound for testing pattern-freeness properties. 
All other analysis for testing pattern-freeness properties apply some type of ``regularity lemma'', 
thus making tower-type query upper bounds unavoidable. 

We believe that both the self-correction technique and the investigation of set-operations 
may be useful in the study of testing pattern-freeness. 
From the works developed in~\cite{Sha09,KSV08}, 
we know that for every , the property  is testable.\footnote{Actually, stronger theorems were proved in~\cite{Sha09,KSV08}, 
but to state their works in full, definitions not needed in this work will have to be introduced.} 
However, for an arbitrary , 
the testability of  remains open. 
And in general very little can be said about the testability 
of an arbitrary intersection of these properties.  
Since  
is known to be testable using self-correction~\cite{AKKLR03}, 
we believe that self-correction, 
applied in conjunction with set-theory, 
may be useful for understanding these pattern-free properties. 



\section{\texorpdfstring{Preliminaries}{2. Preliminaries}}

\label{Sec:prelim} We now describe some basic notation and definitions that we use throughout the paper.
We let  denotes the set of natural numbers 
and  the set . 
We view elements in  as -bit binary strings, that is elements of .
For , we write  for the  bit of .
If  and  are two -bit strings, then  denotes bitwise
addition (i.e., XOR) of  and ,
and  denotes the inner 
product between  and .
We write  to denote
the concatenation of two bit strings  and . For convenience,
sometimes we view a -bit binary string as a subset of ,
that is, for every  there is a corresponding subset 
such that  iff  for every .
We write  to indicate the Hamming weight of , i.e., the
number of coordinates  such that . Equivalently, this
is also the cardinality of subset .
By abuse of notation, we use parentheses to denote
\emph{multisets}; for instance, 
we write  for the multiset which consists of two 's
and three 's. 

Let  be a Boolean function. The \emph{support}
of  is . Recall that for two
functions  and  defined over the same domain, the (fractional) \emph{distance}
between these two functions is .
Let  and  be two properties defined over the same
domain , then the \emph{distance} between these two
properties, , is simply defined to be
.

A Boolean function  is \emph{linear} if
for all  and  in , . We denote
the set of linear function by . Throughout this paper, we will
be working with the pattern generated by the triple .
To this end, we say that a Boolean function  is
\emph{-free} if for all  and  in , ,
where here and after we view  as well as 
as multisets\footnote{That is, for example, 
we do not distinguish the case 
from .}. 
We denote the set of -free functions by .
Similarly, a\emph{ -free} Boolean function is defined analogously.
Lastly, we say that a Boolean function  is \emph{triangle-free}
if for all  and  in , .
We denote the set of triangle-free functions by . Note that
 is \emph{monotone}: if  and we modify  by setting
some of the points in  from  to , then the new function
is clearly also triangle-free. 
We encapsulate this observation into the following statement:
\begin{obs}\label{obs:monotone}
Let  and  be two Boolean functions such that . 
Then 
\end{obs}

For concreteness, we provide a formal definition of a tester.

\begin{defn}[Testability] 
Let  be a finite set and 
 be a parametrized family of domains. 
Let  be a property. 
We say a (randomized) algorithm  is a \emph{tester} for 
with \emph{query complexity}  
if for any distance parameter , input size  
and function ,
 satisfies the following:

\begin{itemize}
\item  queries  at most  times;
\item (completeness) if , then ;
\item (soundness) if , 
then ,
where the probabilities are taken over the internal randomness used by .
\end{itemize}
\end{defn}

We say that a property is \emph{locally testable} 
if it has a tester whose query complexity is a function depending only on , 
independent of . 
In this work, we actually use the word testability to 
describe the stronger notion of \emph{local testability}. 
For our main results, we will work with the model case when 
 and . 


\section{\texorpdfstring{Basic theory of set operations}{3. Basic theory of set operations}}
\label{Sec:theory}




In this section, we present some basic testability results based on
set-theoretic operations such as union, intersection, complementation,
and set-difference. The proofs here are fairly standard and are 
thus deferred to the Appendix.


\subsection{Union}
\label{Sec:union} 
It is well known that the union of two testable properties remains testable. 
This folklore result first appeared in~\cite{GGR98};
for completeness, a proof is included in Appendix~\ref{Sec:union proof}.

\begin{prop}[Folklore]\label{prop:OR} 
Let  
be two properties defined over the same domain . 
For , suppose
 is testable with query complexity . 
Then the union  is testable with query complexity .
\end{prop}




\subsection{Intersection}

\label{Sec:intersection} 
The case of set intersection is more complicated than union. 
Goldreich et al. showed in~\cite{GGR98} (see Proposition 4.2.2) 
that there exist testable properties whose intersection is not testable. 
Thus, in general, testability does not follow from the intersection operation. 
However, testability may still follow in restricted cases. 
In particular, we show that if two testable properties 
and  minus their intersection are sufficiently far from each
other, then their intersection remains testable as well. 
A proof is included in Appendix~\ref{sec:intersection proof}.

\begin{prop}\label{prop:AND} 
Let 
be two properties defined over the same domain . 
Suppose 
for some absolute constant , and for , 
is testable with query complexity .
Then the intersection  
is testable with query complexity , 
\end{prop} 

\subsection{Complementation}

\label{Sec:complement} Here we examine the effect complementation
has on the testability of a property. 
As it turns out, all three outcomes -- both  and  are testable, only one of
 and  is testable, and neither 
nor  is testable -- are possible! 

The first outcome is the easiest to observe. Note that the property
 and the empty property are complements of each
other, and both are trivially testable. The second outcome is observed
in~Proposition 4.2.3 in~\cite{GGR98}. To our knowledge, the third
outcome has not been considered before. In fact, previous constructions
of non-testable properties, e.g.~\cite{GGR98,BHR05}, are \emph{sparse}.
Hence, the complements of these non-testable properties are trivially
testable (by the tester that accepts all input functions). One may
wonder if in general the complement of a non-testable property must
also be testable. We disprove this in the following proposition. 

\begin{prop}\label{prop:complement}
There exists some property  where 
 and , 
such that neither  nor 
is testable for any .
\end{prop} 

By utilizing coding theory, 
we can bypass the sparsity condition to prove Proposition~\ref{prop:complement}.
Essentially, property  consists of neighborhoods 
around functions that have degree  as polynomials over . 
Its complement contains functions that are polynomials of degree . 
Since  evaluations are needed to specify 
a polynomial of degree , 
any tester for  or  needs (roughly) at least  queries. 
Using a standard argument involving code concatenation, 
one can construct  and  to be 
\emph{binary} properties that require testers of
query complexity . 
A formal proof can be found in Appendix~\ref{Sec:complement proof}.
  
 


\subsection{Difference}

\label{Sec:difference} 
Let  and  be two properties
and let  denote the set difference of
the two properties. In this section, we confine our attention to the
simple case that . Since complementation is
a special case of set-difference, from Section~\ref{Sec:complement},
we know that in general we can infer nothing about the testability
of  from the fact that both  and  are testable.
However, under certain restrictions, we still can show that 
is testable.

First we observe a simple case in which  is
testable. This simple observation, which is obvious and whose proof
we omit, is utilized in the proof of Theorem~\ref{thm:LB} in Section~\ref{Sec:LB}.

\begin{obs}\label{obs:set-difference} 
Let  be two testable properties 
defined over the same domain .
If for every , 
there is some  such that ,
then  is testable by the same tester which tests property
. 
\end{obs} 

Our second observation on set difference relies on the notion of \emph{tolerant
testing}, introduced by Parnas, Ron, and Rubinfeld~\cite{PRR06}
to investigate testers that are guaranteed to accept (with high confidence)
not only inputs that satisfy the property, but also inputs that are
sufficiently close to satisfying it. 

\begin{defn}[Tolerant Tester~\cite{PRR06}]
Let  denote two distance parameters and
 be a property defined 
over the domain .
We say that property  is -\emph{tolerantly testable} 
with query complexity  
if there is a tester  that makes at most  queries,
if for all  with ,  rejects 
with probability at most , and for all  with ,
 accepts  with probability at most . 
\end{defn}

We record in the following proposition that if  and
 are sufficiently far apart and 
is tolerantly testable, then  is also testable. We include
a proof in Appendix~\ref{Sec:set-difference}.

\begin{prop}\label{thm:set-difference} 
Let  be three absolute constants.
Let  
be two properties defined over the same domain .
If for every ,  is testable with query complexity , 
 is -tolerantly testable with query complexity , 
and , 
then  is testable 
with query complexity  (and completeness .
\end{prop} 

We note that since  is tolerantly testable, 
it does not have completeness . 
Thus, the set difference  
is not guaranteed to have one-sided error, either.



\section{\texorpdfstring{Main results}{4. Main results}}

\label{Sec:applications} In this section we show two applications
of the results developed in Section~\ref{Sec:theory}. We stress
that set theoretic arguments may be used to show both upper bound
results (some properties are testable with only a few number of queries)
and lower bound results (some properties can not be tested by any
tester with less than certain number of queries).

\subsection{Testing disjunction of linear functions}
\label{Sec:100-free} 
In this section, we employ a BLR-style analysis to show that the class 
of disjunction of linear functions is testable with query complexity .
We first recall from~\cite{BCSX09} that a function is a disjunction of linear functions 
iff it is -free. (Recall that  is the set of Boolean functions
that are free of -patterns for any ,  and  in
.)

\begin{prop}[\cite{BCSX09}]\label{prop:char} 
A function  is (1,0,0)-free if and only if  is
the disjunction (OR) of linear functions (or the all  function).
\end{prop} 
\begin{proof} 
The reverse direction is obvious. 
For the forward direction, let . 
If  is empty, then  is the all  function. 
Otherwise let  and  be any two elements in  (not necessarily distinct). 
Then if  is -free, it must be the case that  is also in
. Thus  is a linear subspace of . 
Suppose the dimension of  is  with . 
Then there are  linearly independent vectors  such that  
iff .
Therefore, by De Morgan's law,  
iff  iff ,
which is equivalent to the claim. \end{proof}

 was shown to be testable with a tower-type query
upper bound in~\cite{BCSX09}. 
We now give a direct proof that  is testable with a quadratic upper bound. 
In fact, by symmetry the testability of  is the same as the testability of . 

\begin{theorem}\label{thm:100} 
For every distance parameter , the property  is testable 
with query complexity .
\end{theorem} 
\begin{proof} 
Suppose we have oracle access to some Boolean function . 
A natural -query test  for  proceeds as follows. 
 picks  and  independently and uniformly at random from , 
and accepts iff . 

Let  be the rejection probability of .
If , then , i.e.,  has completeness . 
For soundness, in a series of steps, we shall show that  
for every , if , then there exists 
a Boolean function  such that {\bf (1)}  is well-defined, {\bf (2)} , and 
{\bf (3)}  is in .

Let  denote . 
Suppose . Then , 
where  is the all-ones function. 
Then trivially, taking  completes the proof.  
Thus, henceforth we assume that .
\vskip10pt
For a fixed , let  denote , and 
and  is defined similarly. We define  as follows: 


\paragraph{Proof of (1).}  is well-defined. 

Suppose not, then there exists some  such that .
Pick  and  independently and uniformly at random from .
Let  be the event that 


By assumption, with probability at least ,  and , 
which will imply that -- regardless of the value of  -- event  must occur.
Thus, . 
On the other hand, by the union bound, , a contradiction.
\qed

\paragraph{Proof of (2).} .

Suppose  is such that .
By construction, .
This implies that the rejection probability  is at least . 
Since , .
\qed

\vskip13pt
Before proving {\bf(3)}, we first note that for every ,
\label{eq:g low violation}

To see this, note that by construction of , 
for every , .
Since , by the union bound, we can deduce that the probability that 
 has a -pattern at  is less than .

\paragraph{Proof of (3).}  is in .

Suppose not, that there exist  such that , .
Pick  uniformly at random from .
Let  denote the event that 

A case by case analysis reveals that if , then event  must occur. 
Note that the probability that  is at least ,
since  occurs with probability at least  and .
On the other hand, by union bound, we have , 
implying that 
, an absurdity.

Therefore, we have shown that on any input function that is -far from ,
the rejection probability of  is always at least . 
By repeating the basic test  independently  times, 
we can boost the rejection probability of  to , and thus completing the proof. 
\end{proof}

\subsection{A new proof that linearity is testable}
\label{Sec:linearity} 

As an application of our results in Section~\ref{Sec:intersection},
we give a new proof that linear functions are testable based on a
set-theoretic argument. 
To this end, note that the set of linear functions equals to the intersection of -free
functions and -free functions, i.e., 

From the previous section, we know that  is testable. The following
theorem due to Green~\cite{Gre05} asserts that  is also testable.

\begin{theorem}[\cite{Gre05}]\label{thm:Green} 
The property  is testable with query complexity ,
where for every ,  denotes the tower of 's of height
.\end{theorem}
By Proposition~\ref{prop:AND}, to show that linearity is testable,
it suffices to show that the two properties  and  are
essentially far apart. 
To this end, let us define a new property , 
where NLTF stands for \emph{non-linear triangle-freeness}:

\begin{lemma}\label{lemma:distance} 
We have that
 is -far from . 
\end{lemma} 
We first establish a weaker version of Lemma~\ref{lemma:distance}.
\begin{prop}\label{prop:distance-2-disj}
Suppose  is a disjunction of exactly two non-trivial linear functions. 
Then  is at least  
\end{prop}
\begin{proof} 
Set . Write , where 
 denote two -bit vectors not equal to .
We say that a tuple  where  is a triangle in  if .
We shall show that
{\bf (1)}  has  triangles and 
{\bf (2)} for every , the number of  such that  is a triangle in  is .
Together, {\bf (1)} and {\bf (2)} will imply that  is at least , 
since changing the value of  at one point removes at most  triangles. 

To prove these two assertions, let  
and .
Since , for every triangle  in , 
each of the three points  must fall in one of the following three disjoint sets:


Furthermore, each of the three points must fall into distinct sets. 
To see this, suppose that . 
Then by definition,  and , 
implying that , a contradiction. 
So  cannot contain two points of a triangle, and by symmetry, neither can .
The same calculation also reveals that  cannot contain two points of a triangle.

Thus, a triangle  in  must be such that 
, , and .
In addition, it is easy to check that 
given two points ,  from two distinct sets (say  and ), 
their sum  must be in the third set (). 
Since these three sets  all have size , 
this implies that 
the number of triangles in  is , proving {\bf (1)}.

{\bf (2)} also follows easily given the above observations. 
Suppose . For every ,  forms a triangle.
Since any triangle that has  as a point 
must also contain a point in 
 (with the third point uniquely determined by the first two), 
the number of triangles in  containing  is . 
The case when  or  is similar. This completes the proof. 
\end{proof}
Now we prove Lemma~\ref{lemma:distance}. 
\begin{proof}[Proof of Lemma~\ref{lemma:distance}]
Let  and write , 
where  is a disjunction of exactly two linear functions.  
By Proposition~\ref{prop:distance-2-disj}, it follows that  is at least . 
Since  is monotone and , 
by Observation~\ref{obs:monotone}, we know 
that . 
Since , , completing the proof. 
\end{proof}

By Theorem~\ref{thm:Green} and Theorem~\ref{thm:100}, both 
and  are testable. Now by combining Proposition~\ref{prop:AND}
and Lemma~\ref{lemma:distance}, we obtain the following: 
\begin{theorem}\label{thm:linearity}
 is testable. 
\end{theorem}

We remark that the query complexity for testing linearity in Theorem~\ref{thm:linearity}
is of the tower type (of the form  because of Theorem~\ref{thm:Green}.
This is much worse than the optimal linear query upper bound obtained
in~\cite{BLR93,BCHKS96}.


\subsection{A lower bound for testing non-linear triangle-freeness}
\label{Sec:LB} 
We first show that  is a ``thin strip'' around . 

\begin{prop}\label{prop:thin strip}
For any Boolean function , .
\end{prop}
\begin{proof}
The statement is trivially true if .
Since  is a proper subset of , 
we can assume that  is strictly larger than 
, implying that the function in  that has minimum distance to  is actually 
in . Call this function . 
Then it is easy to see that there exists some function  in  
such that . 
To this end, note that if  is the all-zero function, 
we can define  such that  for some  and  everywhere else. 
By construction  is non-linear but triangle-free. 
If  is a non-trivial linear function, then we can pick any  and define 
 and  for all . 
By construction  is non-linear, and since  is monotone,  remains triangle-free.

Thus, by Triangle inequality, we know that  is at least 
. 
This implies that .
\end{proof}
Since any linear function is -close to a function
in , intuitively we expect , which is obtained by deleting
the strip  from , to inherit the testability features
of . Indeed, we record this next by using the set-theoretic
machinery set up in Section~\ref{Sec:theory}.


\begin{theorem}\label{thm:LB} 
 is testable, but any non-adaptive
\footnote{A tester is non-adaptive if all its query points 
can be determined before the execution of the algorithm, 
i.e., the locations where a tester queries do not depend on the answers to previous queries.}
tester (with one-sided error) for  requires 
queries. 
\end{theorem}
\begin{proof} 
We first observe that  is testable with one-sided error. 
By Proposition~\ref{prop:thin strip} and Observation~\ref{obs:set-difference},
the testing algorithm for  is simply the same as the tester
for ~\cite{Gre05}. 

Next we show that the lower bound for the query complexity of 
is the same as . 
As shown in~\cite{BX10}, any one-sided, non-adaptive tester for 
 requires  queries.\footnote{The specific lower bound shown in~\cite{BX10} is 
 but can be 
improved to be  
as observed independently by Eli Ben-Sasson and the third author of the present paper.}
Suppose  is testable with one-sided error and has query complexity
.
Since  is testable with
query complexity ~\cite{BLR93}, by Proposition~\ref{prop:OR} 
is testable with one-sided error and has query complexity ,
a contradiction. \end{proof}



\section{\texorpdfstring{Concluding remarks}{5. Concluding remarks}}
\label{Sec:conclusion} 
We have initiated a general study of the closure
of testability under various set operations.  Our results show that
such a study can lead to both upper and lower bound results in property
testing. We believe our answers are far from complete, and further
investigation may lead to more interesting results. For example, the
symmetric difference between two properties  and 
is defined to be .
Under what conditions is the property 
testable if both  and  are testable? Another natural
generalization of our approach is to examine properties resulting
from a finitely many application of some set-theoretic operations. 

Our proof that the class of disjunction of linear functions is testable employs a BLR-style
self-correction approach. 
We believe that this technique may be useful in analyzing other non-monotone, pattern-free properties. 
In particular, it will be interesting to carry out our approach of decomposing
an algebraic property into atomic ones for higher degree polynomials. 
This will, in addition to giving a set-theoretic proof for testing low-degree polynomials, 
sheds light on how pattern-free properties relate to one another.

Finally, our quadratic query complexity upper bound 
for the disjunction of linear functions opens up a number of directions.
In our work, the blowup in query complexity from the disjunction is . 
One may vary the underlying properties and the operators to measure the blowup in query complexity. 
Of particular interest may be understanding 
how the disjunction affects the testability of low-degree polynomials.

\section*{Acknowledgments}
We thank the anonymous referees for numerous suggestions and the reference to~\cite{GOSSW}.

\bibliographystyle{plain}
\bibliography{papers}

\appendix


\section{Proof of Proposition~\ref{prop:OR}}
\label{Sec:union proof} 
Let  be the tester for  with query complexity 
 and  be the tester for  with query complexity 
. 
We may assume that both  and  have soundness  
with a constant blowup in their query complexity. 
Define  to be the tester which, on input function , first simulates  and then . 
If at least one of the two testers  and  accepts ,  accepts . 
Otherwise,  rejects.  


Clearly the query complexity of  is . 
For completeness, note that if  is in , then by definition  is in at least
one of  and . Thus,  accepts  with probability . 
Now suppose . 
Then we have both 
and . 
By the union bound, the probability that at least one of  and  accepts  is at most
. \qed

\section{Proof of Proposition~\ref{prop:AND}} \label{sec:intersection proof}
Let  be the tester for  with query complexity , 
and  be the tester for  with query complexities . 
First we convert  into another tester 
for  such that, on input distance parameter , 
makes  queries, where

In other words,  can be obtained from  by making more queries 
when  is larger than . 
Similarly, we can construct  from  in the same manner. 
Since  is a constant, we have  and .

Define  to be the tester that on input function , first
simulates  and then . 
If both testers  and  accept, then  accepts . 
Otherwise, it rejects. 
The query complexity of  is , which is .

For the completeness, if , then both 
and  hold. Therefore,  accepts with probability at least . 
For the soundness, suppose . We distinguish
between two cases.

\paragraph{Case 1.} . 

It suffices to show that  is -far from at least one of  or . 
This fact then implies that , in simulating  and , accepts  with probability at most 
. 

To show the  is far from at least one of the two properties, suppose not, 
that we have both  and . 
That is, there exist  and  such that 
 and .

Since ,  and
therefore  and .
By triangle inequality, ,
and consequently ,
contradicting our assumption. 

\paragraph{Case 2.} . 

There are three sub-cases depending on where  is located. 
We analyze each of them separately below. Note that in each of the sub-cases, 
 is at least -far from one of  and .
\begin{enumerate}
\item . 
Then by our assumption on the distance
between  and , 
.
It follows that 

 
\item . Analogous to the case above, we have 
.
\item . Then by triangle inequality,
.
So there is some  such that . 
Since , it follows that 
. 
\end{enumerate}
Thus, we conclude that there is some  such that .
This implies that , which makes at least  queries, 
accepts  with probability at most . 
Hence,  accepts  with probability at most  as well, completing the proof. \qed


\section{Proof of Proposition~\ref{prop:complement}}
\label{Sec:complement proof} 

We shall define a property , 
where  is
a collection of Boolean functions defined over , 
such that neither  nor  is testable.
Recall that a property  is said to be \emph{testable} if there
is a tester for  whose query complexity is independent of
the sizes of the inputs to the functions (in our case, 
independent of ).

First, let the Hadamard encoding  be
.
Note that  is isomorphic to , 
so for every function , 
the Hadamard concatenation of  can be written as 
where .

We now define  as follows. Let  
if there exists a polynomial  
of degree at most  such that . 
An important fact is that 
if  is a polynomial of degree , 
then  is not in . 
To see this, note that by the Schwartz-Zippel Lemma, 
if  is a polynomial of degree 
at most , then  . 
Therefore, for any polynomial  of degree at most , 
.
This implies that , 
since the Hadamard encoding has relative distance .\footnote{In other words, suppose  satisfies that 
. Then the number of 's such that 
 is exactly .}
Since the Hadamard encoding of  is at least -far 
from the Hadamard encoding of any degree  polynomials, 
by construction of ,  is at least -far from , 
i.e., .

Now we show that neither  nor its complement is testable for 
any distance parameter . 
By polynomial interpolation, for every set of  points, 
there exists a polynomial of degree  that agrees with  on these points.
So any tester that distinguishes between members of  
and members at least -far away from  needs at least  queries. 
Similarly, as we have just shown that 
when  is a degree- polynomial,
it follows that any tester that distinguishes between members of  
and functions at least -far away from  
also need at least  queries. 
To conclude, we have shown a property 
defined over domains of sizes 
but testing  and 
both require  queries.
Thus, neither the property or its complement 
is testable with a query complexity independent of the sizes of the domains, 
completing the proof. 
\qed




\section{Proof of Proposition~\ref{thm:set-difference}}

\label{Sec:set-difference} 
Let  be the tester for  with query complexity  
and let  be the tolerant tester for  with query complexity . 
First we convert  into another tester  such that, 
on input distance parameter ,  makes  queries, where



Set  and define its tester  as follows:
on input function ,  first simulates  and then . 
 accepts iff  accepts and  rejects. 
Since  is a constant, , and  has query complexity .

For completeness, if , then by assumption 
and . 
This implies that  always rejects ,  accepts  with
probability at most , and thus by a union bound argument  accepts  with probability at least .

For soundness, suppose . 
We consider two cases and note that in both of them,  accepts  with probability at most .

\paragraph{Case 1.} .

Since  is a tolerant tester,  rejects  with probability at most .
Thus,  accepts with probability at most  as well.
 
\paragraph{Case 2.} .

Since  is the union of  and , we can conclude that 
, which is at least 
. 
Since  makes at least  queries, we know that
 accepts  with probability at most , and
hence,  accepts  with probability at most  as well.
\qed
\end{document}
