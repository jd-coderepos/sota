\documentclass{CSML}

\def\dOi{12(1:5)2016}
\lmcsheading {\dOi}
{1--30}
{}
{}
{Jun.~\phantom04, 2014}
{Mar.~\phantom09, 2016}
{}

\ACMCCS{[{\bf Theory of computation}]: Formal languages and
  automata theory---Regular languages}
\subjclass{F.4.3}

\usepackage{enumitem}
\setlist[enumerate,1]{label=\hbox{}}
\usepackage{amsmath}
\usepackage{marvosym}
\usepackage{microtype}
\usepackage[utf8x]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{amssymb,amsthm,xspace,stmaryrd,mathrsfs,pdfsync,graphicx,verbatim}
\usepackage{tikz}
\usepackage[bookmarks=true,bookmarksopen=true,bookmarksopenlevel=1]{hyperref}
\usepackage{tabularx}

\usetikzlibrary{trees,arrows,patterns,shapes,snakes,fit,shadows,calc,automata}

\newcounter{sauvegarde}
\setcounter{sauvegarde}{42}

\newcommand\adjustc[1]{
 \setcounter{sauvegarde}{\thetheorem}
  \setcounterref{theorem}{#1}
  \addtocounter{theorem}{-1}
}

\ProvidesPackage{euscript}[2009/06/22 v3.00 Euler Script fonts]
\DeclareMathAlphabet\EuScript{U}{eus}{m}{n}
\SetMathAlphabet\EuScript{bold}{U}{eus}{b}{n}

\definecolor{my1}{cmyk}{0,.6,0,0}
\definecolor{my2}{cmyk}{.3,.0,.0,.0}

\newcommand\Ds{\ensuremath{\EuScript{D}}\xspace}
\newcommand\Ss{\ensuremath{\EuScript{S}}\xspace}
\newcommand\Gs{\ensuremath{\EuScript{G}}\xspace}
\newcommand\Ts{\ensuremath{\EuScript{T}}\xspace}
\newcommand\Rs{\ensuremath{\EuScript{R}}\xspace}
\newcommand\Hs{\ensuremath{\EuScript{H}}\xspace}
\newcommand\Cs{\ensuremath{\EuScript{C}}\xspace}

\newcommand\Kb{\ensuremath{\mathbf{K}}\xspace}
\newcommand\Lb{\ensuremath{\mathbf{L}}\xspace}
\newcommand\Hb{\ensuremath{\mathbf{H}}\xspace}
\newcommand\Fb{\ensuremath{\mathbf{F}}\xspace}

\newcommand{\efgame}{Ehrenfeucht-Fra\"iss\'e\xspace}
\newcommand\nat{\ensuremath{\mathbb{N}}\xspace}
\newcommand\As{\ensuremath{\mathcal{A}}\xspace}
\newcommand\Ps{\ensuremath{\mathcal{P}}\xspace}
\newcommand\Us{\ensuremath{\mathcal{U}}\xspace}
\newcommand\Vs{\ensuremath{\mathcal{V}}\xspace}
\newcommand\FOindist{\ensuremath{\fo\textup{-}\text{indistinguishable}}\xspace}
\newcommand\FOindisty{\ensuremath{\fo\textup{-}\text{indistinguishability}}\xspace}
\newcommand\FOindistk{\ensuremath{\fo[k]\textup{-}\text{indistinguishable}}\xspace}
\newcommand\Is{\ensuremath{\mathcal{I}}}
\newcommand\Isk{\ensuremath{\mathcal{I}_k}}
\DeclareMathOperator{\Sat}{Sat}
\DeclareMathOperator{\downclos}{\downarrow}
\newcommand{\de}{\ensuremath{\Delta_{2}}\xspace}
\newcommand{\dew}{\ensuremath{\Delta_{2}(<)}\xspace}
\newcommand{\dewn}{\ensuremath{\Delta_{2}(<,Succ)}\xspace}
\newcommand{\siw}{\ensuremath{\Sigma_{2}(<)}\xspace}
\newcommand{\siwn}{\ensuremath{\Sigma_{2}(<,Succ)}\xspace}
\newcommand{\piw}{\ensuremath{\Pi_{2}(<)}\xspace}
\newcommand{\piwn}{\ensuremath{\Pi_{2}(<,Succ)}\xspace}

\newcommand{\bsi}{\ensuremath{\mathcal{B}\Sigma_{1}(<)}\xspace}
\newcommand{\siu}{\ensuremath{\Sigma_{1}(<)}\xspace}

\newcommand{\sicd}{\ensuremath{\Sigma_{2}}\xspace}
\newcommand{\bscd}{\ensuremath{\mathcal{B}\Sigma_{2}}\xspace}
\newcommand{\dect}{\ensuremath{\Delta_{3}}\xspace}
\newcommand{\sict}{\ensuremath{\Sigma_{3}}\xspace}
\newcommand{\pict}{\ensuremath{\Pi_{3}}\xspace}

\newcommand{\utl}{\ensuremath{UTL}\xspace}
\newcommand{\ltl}{\ensuremath{\textup{LTL}}\xspace}
\newcommand{\efw}{\ensuremath{F + F^{-1}}\xspace}
\newcommand{\efwn}{\ensuremath{F + F^{-1} + X + X^{-1}}\xspace}

\newcommand\fod{\ensuremath{\textup{FO}^2}\xspace}
\newcommand\fodw{\ensuremath{\textup{FO}^2(<)}\xspace}
\newcommand\fodwn{\ensuremath{\textup{FO}^2(<,Succ)}\xspace}

\newcommand{\fo}{\ensuremath{\text{FO}}\xspace}
\newcommand{\fow}{\ensuremath{\textup{FO}(<)}\xspace}

\newcommand\subtree[2]{\ensuremath{#1|_{#2}}\xspace}

\newcommand\Cc{\ensuremath{\mathcal{C}}\xspace}
\newcommand\Dc{\ensuremath{\mathcal{D}}\xspace}

\newcommand\pata[1]{\ensuremath{#1}-pattern\xspace}
\newcommand\patas[1]{\ensuremath{#1}-patterns\xspace}

\newcommand\kpata{\pata{k}}
\newcommand\kpatas{\patas{k}}

\newcommand\patt[2]{\ensuremath{(#1,#2)}-pattern\xspace}
\newcommand\patts[2]{\ensuremath{(#1,#2)}-patterns\xspace}

\newcommand\temp[1]{\ensuremath{#1}-template\xspace}
\newcommand\temps[1]{\ensuremath{#1}-templates\xspace}
\newcommand\ltemp{\temp{l}}
\newcommand\ltemps{\temps{l}}

\newcommand\impl[1]{\ensuremath{#1}-implementation\xspace}
\newcommand\impls[1]{\ensuremath{#1}-implementations\xspace}

\newcommand\kimpl{\impl{k}}
\newcommand\kimpls{\impls{k}}

\newcommand\impv[1]{\ensuremath{#1}-implements\xspace}
\newcommand\kimpv{\impv{k}}

\newcommand\peq[1]{\ensuremath{\sim_{#1}}\xspace}
\newcommand\kpeq{\peq{\kappa}}

\newcommand\fodeq[1]{\ensuremath{\cong_{#1}}\xspace}
\newcommand\kfodeq{\fodeq{\kappa}}

\newcommand\foeq[1]{\ensuremath{\equiv_{#1}}\xspace}
\newcommand\kfoeq{\foeq{k}}
\newcommand{\foclos}[2]{\ensuremath{[#1]_{\foeq{k}}}\xspace}

\newcommand\decop[1]{\ensuremath{#1}-decomposition\xspace}
\newcommand\decops[1]{\ensuremath{#1}-decompositions\xspace}
\newcommand\kdecop{\decop{k}}
\newcommand\kdecops{\decops{k}}

\newcommand\Sep{\ensuremath{\mathsf{Sep}}\xspace}
\newcommand\um{\ensuremath{\mathbbold{1}}}
\newcommand\content[1]{\ensuremath{\contentmorphism(#1)}}
\newcommand\contentscc[2]{\ensuremath{\contentmorphism\_\mathsf{scc}(#1,#2)}}
\newcommand\arity[1]{\ensuremath{\textsf{arity}(#1)}}
\newcommand\contentmorphism{\ensuremath{\textsf{alph}}}
\newcommand\scc[2]{\ensuremath{\textsf{scc}(#1,#2)}}

\newcommand\iword{\ensuremath{\omega}-word\xspace}
\newcommand\ilang{\ensuremath{\omega}-language\xspace}
\newcommand\iwords{\ensuremath{\omega}-words\xspace}
\newcommand\ilangs{\ensuremath{\omega}-languages\xspace}
\newcommand\sisemi{sub-\ensuremath{\omega}-semigroup\xspace}
\newcommand\sisemis{sub-\ensuremath{\omega}-semigroups\xspace}
\newcommand\isemi{\ensuremath{\omega}-semigroup\xspace}
\newcommand\isemis{\ensuremath{\omega}-semigroups\xspace}
\newcommand\iclass{\ensuremath{\omega}-class\xspace}
\newcommand\iclasses{\ensuremath{\omega}-classes\xspace}

\newcommand\hword{\ensuremath{\propto}-word\xspace}
\newcommand\hlang{\ensuremath{\propto}-language\xspace}
\newcommand\hwords{\ensuremath{\propto}-words\xspace}
\newcommand\hlangs{\ensuremath{\propto}-languages\xspace}

\newcommand\Jrel{\ensuremath{{\mathscr{J}}}}
\newcommand\Hrel{\ensuremath{{\mathscr{H}}}}
\newcommand\Jleq{\ensuremath{\leqslant_{\Jrel}}}

\newcommand\upA{{\bf A}\xspace}
\newcommand\upB{{\bf B}\xspace}
\newcommand\upC{{\bf C}\xspace}
\newcommand\upS{{\bf S}\xspace}
\newcommand\upR{{\bf R}\xspace}
\newcommand\upT{{\bf T}\xspace}
\newcommand\upI{{\bf I}\xspace}

\newcommand\myhill[1]{\ensuremath{\cong_{#1}}\xspace}
\newcommand\lmyhill{\myhill{L}}

\DeclareMathOperator{\upperclos}{\uparrow}
\newcommand{\upclos}[1]{\ensuremath{\upperclos#1}\xspace}
\newcommand{\unclos}[1]{\ensuremath{\llfloor{#1}\rrfloor}\xspace}
\newcommand\setsem[1]{\ensuremath{#1}\xspace}
\newcommand\sets{\setsem{S}}
\newcommand\gen[2]{\ensuremath{\llfloor{#1(#2)}\rrfloor}\xspace}

\theoremstyle{plain}
\newtheorem{theorem}[thm]{Theorem}
\newtheorem{corollary}[thm]{Corollary}
\newtheorem{proposition}[thm]{Proposition}
\newtheorem{lemma}[thm]{Lemma}
\newtheorem{fct}[thm]{Fact}
\newtheorem{remark}[thm]{Remark}
\newtheorem*{claim}{Claim}



\usepackage[english]{babel}

\let\le\leqslant
\let\leq\leqslant
\let\ge\geqslant
\let\geq\geqslant
\let\emptyset\varnothing

\begin{document}

\title[SEPARATING REGULAR LANGUAGES WITH FIRST-ORDER LOGIC]
      {Separating Regular Languages with First-Order Logic}

\author[T.~Place]{Thomas~Place}
\author[M.~Zeitoun]{Marc~Zeitoun}

\address{LaBRI, Bordeaux University, France}
\email{\{thomas.place, marc.zeitoun\}@labri.fr} \thanks{Supported by ANR 2010 BLAN 0202 01
  FREC.\@ This study has also been carried out with financial support from the French
  State, managed by the French National Research Agency (ANR) in the frame of
  the ``Investments for the future'' Programme IdEx Bordeaux -- CPU
  (ANR-10-IDEX-03-02).}


\keywords{Words, Infinite Words, Regular Languages, Semigroups,
  First-Order Logic, Expressive Power, \efgame games, Separation}

\begin{abstract}
  Given two languages, a separator is a third language that contains the first
  one and is disjoint from the second one. We investigate the following
  decision problem, called \emph{separation}: given two regular
  languages of finite words, decide whether there exists a first-order
  definable separator. A more general problem was solved in an algebraic
  framework by Henckell in 1988, although the connection with separation was
  pointed out only in 1996, by Almeida. The result was then generalized
  by Henckell, Steinberg and Rhodes in 2010. In this paper, we present a new,
  self-contained and elementary proof of it, which actually covers the
  original result of Henckell.

  We prove that in order to answer this question, sufficient information can
  be extracted from semigroups recognizing the input languages, using a
  fixpoint computation, similar to that originally proposed by Henckell. Given
  as input a morphism recognizing both languages to be separated, this yields
  an \textsc{Exptime} algorithm for checking first-order separability.
  Moreover, the correctness proof of this algorithm yields a stronger result,
  namely a description of a possible separator. More precisely, one can
  compute a bound on the quantifier rank of potential separators, as well as a
  first-order formula that describes a separator, if there exists one.
  Finally, we prove that this technique can be generalized to answer the same
  question for regular languages of infinite words.
\end{abstract}

\maketitle

\section{Introduction}
\label{sec:intro}
In this paper, we investigate a decision problem on word languages:
the \emph{separation problem}. The problem is parametrized by a class
\Sep of \emph{separator languages} and is as follows: given as input
two regular word languages, decide whether there exists a third
language in \Sep containing the first language while being disjoint
from the second one.

More than the decision procedure itself, the primary motivation for
investigating this type of problem is the insight it gives on the class
\Sep. Indeed, the separation problem is a generalization of the
\emph{membership problem}, which is often considered as the right
approach to understand the expressive power of a class of languages.
In this restricted problem, one only needs to decide whether a single
input regular language already belongs to the class  under
investigation. Intuitively, in order to get such a decision procedure,
one has to consider \emph{all} regular languages simultaneously, which
requires a strong understanding of the \emph{expressive power} of
\Sep. Since regular languages are closed under complement, testing
membership can be achieved by testing whether the input is separable
from its complement. Therefore, membership can be reduced to
separation, which makes separation more general.

It turns out that separation is actually strictly more general than
membership and solving it requires a deeper understanding of the class
\Sep. More than the expressive power, it requires an understanding of
the \emph{discriminating power} of \Sep. This means that while
intrinsically more difficult, solving the separation problem is also
more rewarding than solving the membership problem. In both cases, the
problem amounts to finding a language in \Sep. However, in the
membership case, there is only one candidate, which is already known:
the input. Therefore, we start with a fixed recognizing device for
this unique candidate and powerful tools are available,
\emph{viz}.~the syntactic semigroup of the language, which is now
accepted as the natural tool for solving the membership problem for
word languages. In the separation case, there can be infinitely
many candidates as separators, which means that there is no fixed
recognition device that we can use. An even harder question then is to
actually construct a separator language in~\Sep.

Investigating the deeper separation problem can also be relevant when a pure
membership approach fails. Many natural classes of languages are built on top
of weaker classes. For example, in logic, more powerful classes can be built
on top of weaker ones by adding predicates to the signature. When
investigating the membership problem, a natural approach would be to first
obtain a solution for the weaker class and then to transfer it to the extended
one. However, this approach fails in general. Actually, many extensions of
classes of languages are known not to preserve decidability of
membership~\cite{ABR:Undec-Identity:92,Rhodes99-undec,DBLP:journals/ijac/Auinger10}.
The reason is that such a transfer result requires more information on the original
class than what a solution to membership provides. This makes the deeper
separation problem a more promising setting as already noted
in~\cite{AZ97-J,Steinberg:delay2001}. A recent example is the quantifier
alternation hierarchy of first-order logic: in~\cite{PZ:icalp14}, it was
proved that solving the separation problem for level  in this hierarchy
yields the solution for the membership problem at level~().

\smallskip\noindent{\bf First-order logic.} In this paper, we choose
\Sep as the class of \emph{languages definable by first-order
  sentences} (\emph{i.e.}, sets of words that satisfy some first-order
sentence).  In this context, the separation problem can be rephrased
as follows: given two regular languages as input, decide whether there
exists a first-order sentence that is satisfied by all words of the
first language, and by no word of the second one. Thus, such a
formula witnesses that the input languages are disjoint.

Within monadic second order logic, which defines on finite words
all regular languages, first-order logic is often considered as the
yardstick.  It is a robust class having several
characterizations~\cite{Diekert&Gastin:First-order-definable-languages:2008:a}. It
corresponds to star-free languages, and has the same expressive power
as linear temporal logic~\cite{kltl}.  In particular, it was the first
natural class for which the membership problem was proved to be
decidable.  This result, known as Schützenberger's
theorem~\cite{sfo,mnpfo}, served as a template and a starting point of
a line of research that successfully solved the membership problem for
a wide assortment of classes of regular languages. This makes
first-order logic the natural candidate to serve as the example for
devising a general approach to the separation~problem.

Schützenberger's theorem states that first-order definable languages
are exactly those whose syntactic semigroup is aperiodic, \emph{i.e.},
has only trivial subgroups. Since the syntactic semigroup of a
language is computable and aperiodicity is a decidable property, this
yields a decision procedure for membership. Schützenberger's original
proof has been refined over the years. Our own proof for separation by
first-order logic actually generalizes a more recent proof by
Wilke~\cite{wfo}. Similar results~\cite{tfo,pfo} make it possible to decide
first-order definability for languages of infinite words, or finite or
infinite Mazurkiewicz
traces. See~\cite{Diekert&Gastin:First-order-definable-languages:2008:a}
for a survey.

\smallskip\noindent
{\bf Contributions and main ideas.} We obtain our separation algorithm
for first-order logic by relying on a specific framework. A key idea
is that, in order to separate two regular languages with first-order
logic, one needs to consider more languages than just these two. One
has to consider a single morphism from  into a finite semigroup
 that recognizes them both and solve the separation problem simultaneously for all
pairs of languages that are recognized by it. Indeed,
the set of all languages recognized by a semigroup morphism has
structure: considering them all as a whole allows us to exploit
this structure.

More precisely, our framework is designed to reduce separation to the
following more general problem. Given a morphism  from 
into a finite semigroup , we want to construct an \fo-partition of
 (a {\bf finite} partition of  into first-order definable
languages) that is an  ``optimal approximation'' of the languages
recognized by . The main point is that a necessary condition
for an \fo-partition to be optimal (for ) is that any two
recognized languages are \fo-separable \emph{if and only if} they can
be separated by a language built as a union of languages in the
\fo-partition (however this condition is not sufficient, which is why
this problem is more general).

Our solution is presented as follows. First, we obtain a fixpoint
algorithm that, given a morphism  as input, computes an
object that we call the \emph{optimal imprint with respect to \fo on
  }. Intuitively, this ``optimal imprint'' contains
information about the \fo-partitions that are optimal for .
In fact, this information includes which pairs of languages recognized
by  are \fo-separable. In other words, this yields a decision
procedure for the separation problem associated to \fo. This fixpoint
algorithm is complemented by a generic technique for constructing
optimal \fo-partitions by induction (this is actually a byproduct of
the correctness proof of the fixpoint algorithm). This is of particular
interest as this yields an inductive way to build first-order
separators when they exist.

An important observation is that the ``\emph{optimal imprint with
respect to \fo on }'' that our fixpoint algorithm computes
is actually an alternate definition of a previously known notion:
the so-called \emph{aperiodic pointlike sets} (whose original definition is algebraic and very different from the
one we use in this paper). While we never use this fact in the paper,
it connects our results to those of
Henckell~\cite{Henckell:Pointlike-sets:-finest-aperiodic:1988:a} (see
also~\cite{DBLP:journals/ijac/HenckellRS10a,qt} which answers the problem for even more general classes). Indeed,
in~\cite{Henckell:Pointlike-sets:-finest-aperiodic:1988:a}, Henckell does not consider the separation problem: his main objective is to
find an algorithm that computes these aperiodic pointlike sets.
In fact, the connection between the separation
problem and the pointlike sets was only observed later
by Almeida~\cite{MR1709911}\footnote{This connection is the analogue of the equivalence
   in our
  Theorem~\ref{thm:seppart}.}. Hence, our fixpoint algorithm and its
proof can be viewed as a new proof of Henckell's result: one can
compute the aperiodic pointlike sets of a semigroup.

Note however that our approach is vastly different from that of
Henckell. In particular, it is more rewarding with respect to the
separation problem. Indeed, the motivations and the proofs
of~\cite{Henckell:Pointlike-sets:-finest-aperiodic:1988:a,DBLP:journals/ijac/HenckellRS10a}
are purely algebraic and provide no intuition on the underlying logic.
Our contributions differ from those of~\cite{Henckell:Pointlike-sets:-finest-aperiodic:1988:a,DBLP:journals/ijac/HenckellRS10a}
in several~ways.
\begin{itemize}[leftmargin=*]
\item First, we give a new and self-contained proof that the separation
  problem by first-order languages is decidable. It is independent from those
  of~\cite{Henckell:Pointlike-sets:-finest-aperiodic:1988:a,DBLP:journals/ijac/HenckellRS10a},
  and relies on elementary ideas and notions from language theory only, making
  it accessible to computer scientists. We do not use any involved
  construction from semigroup theory: we work directly with the logic
  itself.   As mentioned above, the proof refines Wilke's membership algorithm~\cite{wfo}.

\item Second, when the input languages are separable, our approach makes it
  possible to inductively compute a first-order formula that defines a
  separator: we have a generic way to construct optimal \fo-partitions.
  In addition, we provide a bound on the \emph{expected quantifier rank} of a
  potential separator.

\item Third, as a consequence of our algorithm, we obtain~an \textsc{Exptime}
  upper bound (while complexity is not investigated
  in~\cite{Henckell:Pointlike-sets:-finest-aperiodic:1988:a}, a rough analysis
  yields an \textsc{Expspace} upper~bound).

\item Finally, the techniques
  of~\cite{Henckell:Pointlike-sets:-finest-aperiodic:1988:a,DBLP:journals/ijac/HenckellRS10a}
  are tailored to work with finite words only. We also solve the
  separation problem for languages of \emph{infinite words} by
  first-order definable languages, by a smooth extension of our
  techniques.
\end{itemize}
Since we do not follow the proofs
of~\cite{Henckell:Pointlike-sets:-finest-aperiodic:1988:a,DBLP:journals/ijac/HenckellRS10a},
it is not surprising that we obtain a different algorithm. However, we are
able to derive two variations of it, which allows us to give an alternate
and elementary correctness proof of Henckell's original algorithms.

\medskip\noindent{\bf Related work.} First-order logic has a number of
important fragments. The separation question makes sense when choosing such
natural subclasses as classes of separators. It has already been solved for
the case of local fragments, such as locally testable (LT) and locally
threshold testable languages (LTT), although the problem is already NP-hard
starting from two DFAs as input, while membership is known to be
polynomial~\cite{Beauquier&Pin:Languages-scanners:1991:a}. The algebraic
varieties associated to the classes LT and LTT in Eilenberg's correspondence
are well-known, namely the class \textsf{LSl} of all finite local
semilattices, and the semidirect product  of
commutative and aperiodic semigroups with right zero semigroups. Using these
correspondences and the algebraic interpretation of separation given
in~\cite{MR1709911}, algebraic proofs were given, both for
LT~\cite{Costa&Nogueira:Complete-reducibility-pseudovariety:2009:a,Costa:Free-profinite-locally-idempotent:2001:a}
and for
LTT, via~\cite{Beauquier&Pin:Languages-scanners:1991:a,Straubing:Finite-semigroup-varieties-form:1985:a,Steinberg:98,Steinberg:01}.
Although indirect, these proofs actually provide more information than what is
needed for separation alone. A direct and elementary approach for both classes
was also presented in~\cite{ltltt:2013,PvRZ:LTT:14}.

The separation problem is also decidable for the fragment of first-order logic made of Boolean
combinations of \siu sentences (that is, first order sentences without any
quantifier alternation), as a consequence of~\cite{MR1709911,AZ97-J}, and then
obtained directly and independently in~\cite{sep_icalp13,PvRZ:mfcs}. It has then been shown to be decidable for
the first fragments of first-order logic in the quantifier alternation
hierarchy, namely the ones consisting of \siw\cite{PZ:icalp14}, respectively
of  sentences~\cite{pseps3} (\emph{i.e}, first order sentences
of the form , respectively of the form
, with  quantifier-free). In view
of the aforementioned transfer result, this yields decidability
of membership for the next level, . Within this hierarchy,
membership remains open for level 5 and above (hence, separation is open
for level 4 and~above).

Finally, the problem has also been
investigated for the fragment \fodw of first-order logic using 2 variables
only, and again has been proven to be decidable~\cite{PvRZ:mfcs}.

\medskip\noindent {\bf Paper outline.}  We first give the necessary
definitions and terminology: languages and semigroups for finite words are
defined in Section~\ref{sec:prelims} and first-order logic is defined in
Section~\ref{sec:fo}. Section~\ref{sec:main} is devoted to the presentation of
our algorithm solving first-order separation through the computation of sets
that cannot be distinguished by first-order logic. Sections~\ref{sec:correc}
and~\ref{sec:comp} are devoted to proving the soundness and completeness of
this algorithm, respectively. In Section~\ref{sec:altalgo}, we present
alternate versions of our algorithm. In Section~\ref{sec:omega}, we recall the
preliminary definitions for tackling the separation problem in the setting of
infinite words. In Section~\ref{sec:omegasep}, we state a
generalization to infinite words of our algorithm, for which we prove
soundness in Section~\ref{sec:corr-algor} and completeness in
Section~\ref{sec:compl-algor}.

\medskip
This paper is the journal version of~\cite{PZ:lics14}. From the
conference version, the missing proofs have been added, separation is now
presented in a generic, language-theoretic setting, and the proof
of the algorithm has been entirely rewritten so that it now
constructs an actual separator by induction when it exists.

\section{Preliminaries}
\label{sec:prelims}
\newcommand\one{\textup{1}}

In this section, we provide terminology for words, semigroups and
languages. All the definitions are for finite words. We
delay the definitions for infinite words to Section~\ref{sec:omega}.

\medskip
\noindent {\textbf{Semigroups.}} A semigroup is a set  equipped
with an associative operation  (often written ). A
monoid is a semigroup  having an identity element ,
\emph{i.e.}, such that  for all .
Finally, a group is a monoid such that every element  has an
inverse , \emph{i.e.}, such that .

Given a \emph{finite} semigroup , it is folklore and easy to see that
there is an integer  (denoted by  when  is
understood) such that for all  in ,
 is idempotent:~.

\medskip
\noindent
{\textbf{Words, Languages, Morphisms.}} We fix a finite alphabet
. We denote by  the set of all nonempty finite
words and by  the set of all finite words over . If  are words, we
denote by  or by  the word obtained by the concatenation of  and
. Observe that  (resp.\ ) equipped with the
concatenation operation is a semigroup (resp.\ a monoid).

For convenience, we only consider languages that do not contain the
empty word. That is, a language is a subset of  (this does not
affect the generality of the argument). We work with
regular languages, \emph{i.e.}, languages definable by
\emph{nondeterministic finite automata}~(NFA).

We shall exclusively work with the algebraic representation of regular
languages in terms of semigroups.  We say that a language \emph{ is
  recognized by a semigroup } if there exists a semigroup
morphism  and a subset 
such that . It is well known that a language is
regular if and only if it can be recognized by a
\emph{finite}~semigroup. Moreover, from any NFA recognizing some
language , one can compute a canonical semigroup recognizing ,
called the \emph{syntactic semigroup} of .

When working on separation, we consider as input two regular languages
. It will be convenient to have a single semigroup
recognizing both of them, rather than having to deal with two
objects. Let  be semigroups recognizing  together
with the associated morphisms , respectively. Then,  equipped with the componentwise multiplication  is a semigroup that recognizes both  and 
with the morphism .
From now on, we work with such a single semigroup recognizing both
languages, and we call  the associated morphism.

\medskip
\noindent {\bf Semigroup of Subsets.} As explained in the
introduction, our separation algorithm works by computing special
subsets of a semigroup recognizing both input languages. Intuitively,
these subsets are those that cannot be distinguished by first-order
logic. More precisely, by \emph{special subset}, we mean that any first-order
definable language has an image under  that either contains
\emph{all} elements of the subset, or \emph{none} of them. For this
reason, we work with the semigroup of~subsets.
\smallskip
Let  be a semigroup. Observe that the set  of subsets of
 equipped with the operation  is a semigroup, that we call the
\emph{semigroup of subsets of }. Note that  can be viewed as a
subsemigroup of , since  is isomorphic to the semigroup
.
We denote by  subsemigroups of a
semigroup of subsets.

\smallskip\noindent\textbf{Downset .} Let  be any subset of . We define the \emph{downset}  of \Ss as

Clearly, we have . Moreover, if  is a
subsemigroup of , it is easy to check that  is a
subsemigroup as well.

\smallskip\noindent\textbf{Union \unclos{\Ss}.} For  any subset of , we define , the
\emph{union} of , as the set

We call \emph{index} of \Ss the size of its union, \emph{i.e.},
. By definition, we have the following
fact.

\begin{fct} \label{fct:uprod}
Set  and , then .
\end{fct}

\section{First-Order Logic and Separation}
\label{sec:fo}
This section is devoted to the definition of first-order logic on
words. See~\cite{Thomas:Languages-automata-logic:1997:a,Diekert&Gastin:First-order-definable-languages:2008:a,bookstraub} for details on
this classical notion.

\medskip
\noindent
{\textbf{First-Order Logic.}} We view words  as logical structures
composed of a sequence of positions labeled over . We denote by 
the linear order over the positions. We work with first-order logic
\fow using a unary predicate  for each ,
which selects
positions  labeled with an , as well as a binary predicate for the
linear order . A language  is said to be \emph{first-order definable} if there
exists an \fow formula  such that . We write \fo for the class of all first-order definable
languages.

There are many known characterizations of the class of first-order
definable languages. Kamp's Theorem~\cite{kltl} states that it is
exactly the class of languages definable in linear temporal logic
\ltl.  In~\cite{mnpfo}, it was proven that this is also the class of
languages that can be recognized with \emph{counter-free automata} as
well as the class of star-free languages (\emph{i.e.}, languages
definable by a regular expression that may use complement, but does
not use the Kleene star). This result bridged the gap with
Schützenberger's Theorem~\cite{sfo}, which characterizes star-free
languages as those whose syntactic semigroup is \emph{aperiodic} (\emph{i.e.},
all its elements  satisfy the equality ).
The separation algorithm that we present in this paper can be viewed
as a generalization of Schützenberger's Theorem. In particular, we
reprove this theorem as a simple corollary of our algorithm.
Note that conversely, using Sch\"utzenberger's result as a black box doesn't seem
to help much to obtain a simpler proof with our approach.

\medskip\noindent{\textbf{Separation}.} Given languages ,
we say that  \emph{separates}  from  if

Given a class of languages \Cs, the pair  is said to be
\emph{\Cs-separable} if some language  separates 
from~. Note that when \Cs is closed under complementation (for
example when ),  is \Cs-separable if and only
if  is. Therefore, we simply say that  and  are
\Cs-separable in this case.

In this paper, we present an algorithm that decides whether two
regular languages are \fo-separable. Let us give an example of two
languages that are not \fo-separable.

\begin{exa} \label{ex:main}
Let ,  and


It is well known that  and  cannot be
distinguished by any \fo-sentence of quantifier rank~, see
\emph{e.g.}~\cite{bookstraub} (recall here that the \emph{quantifier rank} of a first-order formula  is the length of the largest sequence of nested
quantifiers in  --- the rank is a  usual way to classify first-order formulas).
Therefore,  and  are not
\fo-separable. Reusing this argument then shows that  and 
are not \fo-separable either. We shall explain below how this is
detected by our algorithm.
\end{exa}

The main result of the paper is the following theorem.

\begin{theorem} \label{th:main}
Let  be two regular languages recognized by a morphism
 into a finite semigroup. The two following items
hold.
\begin{enumerate}
\item\label{item:thmain:1} One can decide in {\sc Exptime} with respect to  whether
   and  are \fo-separable.
\item\label{item:thmain:2} When  and  are \fo-separable, one can construct an
  actual FO-separator defined by a formula of quantifier rank at most
  .
\end{enumerate}
\end{theorem}

\noindent The proof of Theorem~\ref{th:main} is postponed to
Sections~\ref{sec:main}, \ref{sec:correc} and~\ref{sec:comp}. In
Section~\ref{sec:main} we present our decision procedure and
Section~\ref{sec:correc} and~\ref{sec:comp} are devoted to proving
soundness and completeness of this procedure. Note that most of our
efforts are aimed to obtaining an algorithm for Item~1 of the theorem.
We actually obtain the second item as a byproduct of the completeness
proof of Section~\ref{sec:comp}: this proof is constructive and can be
used to build an actual separator by induction (which turns out to
have rank at most ), when it exists.

\section{Separation Algorithm}
\label{sec:main}
In this section, we define a general framework which is tailored
to the investigation of the separation problem. We then use it to
obtain a separation algorithm in the special case when the class
of separators is given by first-order logic, \emph{i.e.}, to prove
Theorem~\ref{th:main}. An important remark is that the problem that
we actually consider and solve is slightly more general than
separation. In particular, this problem takes an arbitrary number of
languages as input rather than just two. Let us first explain our
motivation for considering such a generalization.

In the separation problem, we are given a single semigroup morphism
 that recognizes the two input languages  that need
to be separated. However, in general, a single morphism recognizes
several different languages, not just these two. Moreover, while these
other languages are not the ones we aim at separating,  and 
are built-up from them. This makes all these languages relevant when
working with  and . Therefore, our approach is to consider
them all simultaneously in a problem that generalizes separation:
\emph{computing an \fo-partition that is optimal} for the morphism
.

\medskip
We organize the section in three parts. First, we present our
framework in a general context (\emph{i.e.}, for an arbitrary class
of
separators \Cs) and connect it to the separation problem. In the
second part, we apply this framework to first-order logic and use
it to obtain a separation algorithm and to prove Theorem~\ref{th:main}.
Finally, in the third part, we illustrate this algorithm on
Example~\ref{ex:main}.

\subsection{Definition}

For the definitions, we assume that an arbitrary class of languages
\Cs over our fixed alphabet  is fixed. Moreover, we need \Cs to satisfy the three following
properties:
\begin{enumerate}
\item \Cs is nonempty and closed under boolean operations.
\item \Cs is closed under right and left quotients: for any  and , we have
  
\item \Cs only consists of regular languages.
\end{enumerate}

It is straightforward to verify that \fo satisfies these three
properties. Note that the objects that we define below make sense even
when \Cs does not satisfy  these three properties. However, we will
need these properties to make the connection with the separation problem.

\medskip
\noindent
{\bf \Cs-Partitions and Imprints.} Assume that an alphabet  is
fixed. A \emph{\Cs-partition} (of ) is a {\bf finite} partition
 of  such that all languages  in \Kb
belong to~\Cs. Note that since \Cs is non-empty and closed under
boolean operations,  belongs to~. Therefore, there exists at least
one \Cs-partition, namely .

When we have a morphism  and a
\Cs-partition \Kb in hand, our main interest will be to know how good
\Kb is at separating languages recognized by : what are the
languages recognized by  that can be separated by a union of
languages in \Kb ? This information is captured by a new object that
we associate to each \Cs-partition and each morphism, the
\emph{imprint of the partition on the morphism}.

Given a morphism  into a finite semigroup
 and a \Cs-partition \Kb. The \emph{imprint of \Kb on } is
defined as the set

In other words,  if and only if there exists a
language in \Kb that intersects  for all .
Observe that by definition, an imprint on  is a subset of
. Hence, since  is finite, there are finitely many possible
imprints on . We present three simple properties of imprints. The first one states that an imprint always
contains some trivial elements.

\begin{fact}
  \label{fct:trivial}
  Let  be a morphism into a finite semigroup
   and \Kb be a \Cs-partition. Then, .
\end{fact}

\begin{proof}
  For any , there exists  such that  (\Kb
  is a partition of ). Hence, 
  and .
\end{proof}

The second property states that any imprint is closed under downset.

\begin{fact}
  \label{fct:downclos}
  Let  be a morphism into a finite semigroup
   and \Kb be a \Cs-partition. Then .
\end{fact}

\begin{proof}
  By definition, . Let us prove the converse inclusion. Set . By definition, there exists  such that . By definition of
  imprints, we obtain  such that .
  Therefore,  and . Note that we have shown that .
\end{proof}

The third property connects imprints to the separation problem: the
imprint of \Kb on  records which languages recognized by
 can be separated with .

\begin{lemma} \label{lem:imprint}
  Let  be a morphism into a finite semigroup
   and \Kb be a \Cs-partition. Let  be two languages
  recognized by  and let  be the
  corresponding accepting sets. The two following conditions are
  equivalent:
  \begin{enumerate}
  \item\label{ita:1} for all  and all , we have .
  \item \label{ita:2}  and  can be separated by a union of languages in
    .
  \end{enumerate}
\end{lemma}

\begin{proof}
  Assume first that Item~\ref{ita:1} holds and set . Since  is a
  partition of , we have  by definition. Moreover,
  we know from Item~\ref{ita:1} that no language 
  intersects both  and . It follows that :  separates  from  and Item~\ref{ita:2} holds.

  Assume now that Item~\ref{ita:2} holds. Since \Kb is a partition, this
  means that no language  intersects both  and . It
  follows from the definition of imprints that for all  and
  all , we have .
\end{proof}

An important remark is that, in general, the imprint of \Kb on
 contains more than just separation related information. For
example, assume that  and consider two
\Cs-partitions \Kb and  having the following imprints on
:

From the separation point of view, we know from
Lemma~\ref{lem:imprint} that \Kb and  are equally useless (they
cannot be used to separate any pair of nonempty languages recognized by
). However, we also know from the imprints that  is
``better'' as it contains no language that intersects
 and  at the same
time.

In view of Lemma~\ref{lem:imprint}, the smaller the imprint on
 of a \Cs-partition is, the better this \Cs-partition is at
separating languages recognized by . We use this remark to
define the notion of \emph{optimal} \Cs-partition.

\medskip
\noindent
{\bf Optimal \Cs-Partitions.} Given a morphism  into a finite semigroup  and a \Cs-partition \Kb,
we say that \Kb is \emph{optimal for } if for any
\Cs-partition ,

We can use the fact that \Cs is closed under intersection to prove
that for any morphism , there always exists a \Cs-partition that is
optimal for .

\begin{lemma} \label{lem:optimal}
  Let  be a morphism into a finite semigroup
  . Then there exists a \Cs-partition that is optimal for .
\end{lemma}

\begin{proof}
  We prove that for any two \Cs-partitions  and , there
  exists a third \Cs-partition  such that,  and . Since there are only finitely possible imprints
  on , the lemma will follow.

  We set . Since  and  were -partitions and \Cs is
  closed under intersection, \Kb remains a \Cs-partition. Finally, it is
  immediate from the definitions that   and .
\end{proof}

Observe that the proof of Lemma~\ref{lem:optimal} is non-constructive.
Given a morphism , computing an actual optimal \Cs-partition
for  is a difficult problem in general. In fact, as seen in
Theorem~\ref{thm:seppart} below, this is more general than solving
\Cs-separability for any pair of languages recognized by .
Before we present this theorem, let us make an important observation
about optimal \Cs-partitions.

By definition, given a morphism , all \Cs-partitions that are
optimal for  have the same imprint on . Hence, this
unique imprint is a canonical object for \Cs and . We call it
the \emph{optimal imprint with respect to\/ \Cs on\/ } and we
denote it by :

Note that, as an imprint,  satisfies
Fact~\ref{fct:trivial} and Fact~\ref{fct:downclos}:  and . Moreover, using our three hypotheses on \Cs (note
that this is where we need the second and third ones), one can prove
another convenient property:  is a subsemigroup of
 (\emph{i.e.}, it is closed under multiplication).

\begin{lemma} \label{lem:usemi}
  Let  be a morphism into a finite semigroup
  . Then  is a subsemigroup of : for all , .
\end{lemma}

\begin{proof}
  Let  with  and . We prove that . Let \Kb be
  a \Cs-partition of . We have to prove ,
  \emph{i.e.}, that there exists  such that .
  This is a consequence of the following claim.

  \begin{claim}
    There exist  and  such
    that  for  and  for
     and,
    \begin{itemize}
    \item for any , there exists  such that
      .
    \item for any , there exists  such that
      .
    \end{itemize}
  \end{claim}
  Before we prove the claim, let us finish the proof of the lemma. Using
  the first item of the claim for , we obtain a language  such that . Similarly, for all
  , we can use the second item of the claim for  and
  we obtain a language  such that . Note that each language  contains the word ,
  which also belongs to . Hence, since  is a partition of ,
  we have  and  contains the word 
  for all  and . Since ,
  this exactly says that , which terminates the
  proof of the lemma.

  \smallskip
  It now remains to prove the claim. We prove the existence of the words . The proof for that of  is
  symmetric. Observe that for any , the set  is a \Cs-partition of  (recall that
  \Cs is assumed to be closed under quotients). Moreover, since \Cs
  contains only regular languages, all  are regular
  languages and by Myhill-Nerode Theorem, they have finitely many left
  quotients. It follows that the set  is
  finite. Hence using the fact that \Cs is closed under boolean
  operations, we can construct a new \Cs-partition  that refines
  all partitions  for .

  Since  is a \Cs-partition and , we know
  that there exists  such that .
  This means that  contains  words  such that  for . We now prove that
   satisfy the conditions of the claim. Set
  , we know that there exists  such that  (\Lb refines ). This means that . Finally, by definition,  for some ,
  hence .
\end{proof}

\noindent
{\bf From \Cs-Partitions to Separation.} We can now connect
\Cs-partitions and optimal imprints to the separation problem for
\Cs.

\begin{theorem} \label{thm:seppart}
  Let  be a morphism into a finite semigroup . Let
   be two languages recognized by  and let  be the corresponding accepting sets. The following
  properties are equivalent:
  \begin{enumerate}
  \item\label{item:cov2sep1}  and  are \Cs-separable.
  \item\label{item:cov2sep2} for all  and all , we have .
  \item\label{item:cov2sep3} for any \Cs-partition \Kb that is optimal
    for ,  and  are separable by a union of languages
    in .
  \end{enumerate}

\end{theorem}

\begin{proof}
  We prove that .
  Let us first assume that  holds, \emph{i.e.},
  that for any \Cs-partition \Kb that is optimal for , 
  and  are separable by a union of languages in . Since
  there exists at least one \Cs-partition that is optimal for 
  (see Lemma~\ref{lem:optimal}),  can be separated from 
  with a union of languages in \Cs. Since \Cs is closed under union,
  this separator is in \Cs and  holds.

  We now prove that . Assume that  holds,
  \emph{i.e.}, that  is \Cs-separable from . This means that
  there exists a language  such that  and  (\emph{i.e.}, ). Since
  \Cs is closed under complementation,  and
   is a \Cs-partition. By construction,
  for all  and all , . Hence  since
   by definition.

  It remains to prove that . Assume that for all  and all ,  and let  be an
  optimal \Cs-partition for . Since \Kb is optimal, we know
  from our hypothesis that for all  and all , . Hence it
  follows from Lemma~\ref{lem:imprint} that  can be
  separated from  by a union of languages in \Kb.
\end{proof}

In view of Theorem~\ref{thm:seppart}, given a class of languages \Cs
that satisfies the appropriate properties, a general approach to the
separation problem can be devised as follows.
\begin{enumerate}
\item Present an algorithm which takes a morphism  as input and computes . Thanks to
  Theorem~\ref{thm:seppart}, this allows us to decide whether any two
  languages recognized by the input morphism  are \Cs-separable.

  Typically, this
  algorithm should be a lowest fixpoint:  is computed
  as the smallest set  which contains the singletons
   for  (see Fact~\ref{fct:trivial})
  and is closed under a set of rules that is specific to \Cs. Note
  that, in view of Fact~\ref{fct:downclos}, one of these rules should always be closure under downset , and in view of Lemma~\ref{lem:usemi}, one of these rules should
  always be closure under multiplication.

\item To prove that the algorithm is sound, \emph{i.e.}, that
  , one needs to prove that
  for any computed set , the imprint of any \Cs-partition \Kb must
  contain . This is usually simple and involves \efgame arguments.
\item To prove that the algorithm is complete, \emph{i.e.}, that
  , one needs to construct
  a \Cs-partition \Kb whose imprint on  is included in
  . By definition, this proves that , hence, this
  proves completeness. We actually get more from this construction:
  combining it with the knowledge that the algorithm is also correct,
  we obtain : the
  \Cs-partition \Kb that we construct is actually optimal for
  . By Item~\ref{item:cov2sep3} in Theorem~\ref{thm:seppart}, we get
  a way to construct an actual separator in \Cs of two \Cs-separable languages recognized
  by .
\end{enumerate}
This terminates the presentation of the general approach. We now apply
it to the special case when the class \Cs is \fo.

\subsection{A Separation Algorithm for First-Order Logic}

Fix a morphism  into a finite semigroup . We
describe a lowest fixpoint algorithm for computing the optimal imprint
with respect to \fo on : . Note that from now on
we work with \fo only. Therefore, we simply write  for
.

Set  as a subsemigroup of . We define , the
\emph{saturation of \Ss}, as the smallest subset of  that contains
\Ss and is closed under the three following operations:
\begin{enumerate}
\item\label{eq:oper1} Downset: .
\item\label{eq:oper2} Multiplication: for any , we have .
\item\label{eq:oper}  \fo-Closure: for any ,
  .
\end{enumerate}

Note that it is immediate that one can compute  from
 using a lowest fixpoint algorithm. Finally, we define
 as  for .

An interesting observation is that only Operation~\ref{eq:oper}
is specific to first-order logic in the definition of . Indeed,
we already know from the generic presentation that 
contains  and is closed under
downset and multiplication. This terminates the presentation of the
algorithm, we state its correctness in the following proposition.

\begin{proposition} \label{prop:algoworks} Set  as
  a morphism into a finite semigroup . Then,
  
\end{proposition}

Since  is computable, Proposition~\ref{prop:algoworks}
immediately implies that so is . Using
Theorem~\ref{thm:seppart}, this yields the decidability of the
separation problem for first-order logic. A simple analysis of the
lowest fixpoint procedure shows an {\sc Exptime} complexity upper
bound. This proves the first item of Theorem~\ref{th:main}, as we now
show.

\begin{proof}[Proof of the first item of Theorem~\ref{th:main}]
          By Theorem~\ref{thm:seppart}, it
  suffices to prove that one can compute  in {\sc Exptime}
  in the size of . Indeed, it then suffices to test whether there
  exists  such that  and . This can also be
  achieved in {\sc Exptime} by testing all possible candidates . By
  Proposition~\ref{prop:algoworks}, we know that computing 
  can be done by computing .

  By definition, . This means that the
  number of steps the algorithm needs to reach the fixpoint is at most
  exponential in~. Therefore, it suffices to prove that each step can be
  done in {\sc Exptime} to conclude that the whole computation can also be
  done in {\sc Exptime}. Each step requires computing  for at most  subsets . Each computation can be done
  in {\sc Exptime}, since  is equal to some  for 
  such that .   \end{proof}

We postpone the proof of Item~\ref{item:thmain:2} of Theorem~\ref{th:main} (the
bound on the quantifier rank of the separator) to
Section~\ref{sec:comp} where we prove the difficult direction of
Proposition~\ref{prop:algoworks}: . As explained, the proof amounts to constructing an
optimal \fo-partition~for~.

\smallskip
Another interesting observation about our saturation algorithm is that
it can be viewed as a generalization of Schützenberger's
Theorem~\cite{sfo,mnpfo}. Indeed, a language is first-order
\emph{definable} if and only if its syntactic semigroup is aperiodic.
One definition of aperiodicity is that a semigroup is aperiodic if and
only if it satisfies the identity . The
counterpart to this definition can be found in the main operation of
our saturation procedure, Operation~\ref{eq:oper} (which is the only
non-generic operation). This observation raises another question:
could Operation~\ref{eq:oper} be replaced to reflect alternate
definitions of aperiodicity while retaining
Proposition~\ref{prop:algoworks}? We shall see in
Section~\ref{sec:altalgo} that this is indeed~possible. Another
consequence of this observation is that we can reprove
Schützenberger's Theorem as a simple corollary of
Proposition~\ref{prop:algoworks}.

\begin{corollary}[Schützenberger's Theorem] \label{cor:carac}
  Let  be a regular language. Then  can be defined in \fo if and
  only if its syntactic semigroup is aperiodic.
\end{corollary}

\begin{proof}
  It is known that a language is definable in \fo if and only if all
  languages recognized by its syntactic semigroup are definable in
  \fo as well (this is actually not specific to \fo and true for all
  classes of languages that are ``Varieties'', see~\cite{Pin13:MPRI} for
  example). Hence, if  is the syntactic semigroup of  and  the associated (surjective) morphism,  is definable in \fo if and only if
   is an \fo-partition. The imprint on
   of this \fo-partition is , which is equal to , since
   is surjective. Therefore,  is definable in \fo if and only if
   (see Proposition~\ref{prop:algoworks}). By definition
  of , this is equivalent to  for
  all .
\end{proof}

It now remains to prove Proposition~\ref{prop:algoworks}. In
Section~\ref{sec:correc}, we prove that . This corresponds to soundness of the algorithm: all
computed sets indeed belong to . Finally, in
Section~\ref{sec:comp}, we focus on the proof of the most difficult
direction, which is the second one: . It implies completeness of the algorithm, that is, that
every set belonging to  is actually computed by the algorithm.

\smallskip
We finish this section by running the algorithm, to show that it
detects that the languages of Example~\ref{ex:main} are not
\fo-separable.

\subsection{Example~\ref{ex:main}, continued.}
To start our algorithm, we first need a semigroup morphism recognizing
both  and . Observe that both languages are recognized by
the automaton below, with 4 as final state for , and 2 as final state for~.
Therefore, its transition semigroup~ recognizes both
languages\footnote{Recall that the transition semigroup consists of
  all partial mappings induced by words from the state set to itself. It
  is easy to see that it recognizes the language accepted by the
  automaton, see~\cite[Sec.~3.1]{Pin13:MPRI}.}.
\begin{figure}[h]
  \begin{center}
    \scalebox{.89}{      \begin{tikzpicture}[node distance=2.4cm, initial text={}, ->,>=stealth',shorten >=1pt,auto, semithick]
        \tikzstyle{every
          state}=[circle,fill=black!25,draw=black!40,text=black,minimum
        size=15pt,inner sep=0pt]

        \node[initial,state] (A) {1};
        \node[state] (B) [right of=A] {2};
        \node[state] (C) [right of=B] {3};
        \node[state] (D) [below of=A, yshift=0mm] {4};
        \node[state] (E) [below of=B, yshift=0mm] {5};

        \path (A) edge node {} (B)
        (B) edge [bend left = 10] node {} (C) edge node {} (E)
        (C) edge [bend left = 10] node {} (B)
        (D) edge [bend left = 10] node {} (E) edge [bend left = 5] node [yshift=-.75mm,xshift=.5mm] {} (B)
        (E) edge [bend left = 10] node {} (D);
      \end{tikzpicture}}
  \end{center}
  \caption{Automaton recognizing both  and }
  \label{fig:automtonA}
\end{figure}
The recognizing morphism  maps a word to the partial
function it defines from states to states. We still denote the
images of  by , respectively.  It is easy
to see that  and .

We use Theorem~\ref{thm:seppart} to show that  and  are
not \fo-separable: we have to find  and  such that . We claim that
 and  satisfy this property. We actually show
that  is computed as an element of , which,
by Proposition~\ref{prop:algoworks}, implies that it belongs to
.

\smallskip

By definition, . Then, note that
 and . Therefore, by
definition of Operation~\ref{eq:oper}, we have
.  Using Operation~\ref{eq:oper2}, we then
obtain that .
Now, Operation~\ref{eq:oper} yields . Computing  shows that .
Finally, using Operation~\ref{eq:oper2}, we obtain that . One can then verify that
. Therefore, we get from
Operation~\ref{eq:oper1} that , as claimed.

\begin{comment}
  In this section, we state and prove our main result: \fo-separability
  is decidable. This result is twofold. First we prove that a bound 
  can be computed from the input languages such that if there exists a
  separator, it can be chosen with quantifier rank at most
  . This provides a description of the potential separator as well as
  a first algorithm for testing \fo-separability. Indeed, the algorithm
  only needs to test whether there exists one language that is a
  separator within the finitely many  languages.

  The second part of our result is a more efficient algorithm
  that tests \fo-separability. While more efficient than the brute-force
  approach discussed above, this algorithm still runs in exponential
  time in the size of the syntactic semigroups of the
  languages. Moreover, it only provides a binary answer without actually
  giving a separator.

  The section is divided into two subsections. In the first one, we
  present our algorithm for testing \fo-separability. In the second
  one, we state our main theorem and analyze its consequences. Note
  that the first section only contains the definition of the algorithm
  and not its correctness proof, which is part of the theorem.

  \subsection{\fo-intersection}

  Fix two regular languages  over . Let  be their product
  semigroup and  be the corresponding morphism. We set
   and .

  The main idea behind the algorithm is the following. Given a natural
  , one associates to each \foeq{k}-class in  the subset of 
  consisting of the images by  of all words in the~class.  It is
  easy to see that  are not -separable if and only if
  there exists such a subset intersecting both  and . As
   gets bigger, these subsets can only get smaller. Therefore, the
  subsets stabilize at some point: there exists  such that subsets
  generated by the \foeq{k}-classes are the same as those generated by
  the \foeq{\ell}-classes for all .  Therefore, if one can compute
  these subsets, one can decide \fo-separability. This is exactly what
  our algorithm does.  In this section, we only give the algorithm.
  Correctness will follow from Theorem \ref{th:fosep}.
\end{comment}

\begin{comment}

  \subsection{Main Theorem}

  We can now state our main theorem. As we explained before it contains
  two results. First we provide a bound on the expected size of an
  \fo-separator. Second, we prove that \fo-separability corresponds
  exactly to having empty \fo-intersection.

  \begin{theorem} \label{th:fosep}
    Let  be regular languages and let  be their
    syntactic semigroups. Let . Then the following
    conditions are equivalent:

    \begin{enumerate}
    \item\label{item:a}  and  are \fo-separable.
    \item\label{item:b}  and  are -separable.
    \item\label{item:c} The language  separates
       from .
    \item\label{item:d}  have empty \fo-intersection.
    \end{enumerate}
  \end{theorem}

  Observe that in particular, Theorem~\ref{th:fosep} yields two
  algorithms for testing \fo-separability. From items~\ref{item:b}
  and~\ref{item:c}, we get a brute-force algorithm that tests for
  all the finitely many  languages whether they are a
  separator. From item~\ref{item:d}, we get a second algorithm given
  by Proposition~\ref{prop:algosep}. Therefore, we get the
  following corollary.

  \begin{corollary} \label{cor:fosep}
    Let  be regular languages, it is decidable to test whether
    they are \fo-separable. Moreover this can be done in {\sc Exptime}
    in the size of their syntactic semigroups.
  \end{corollary}
\end{comment}

\section{Soundness of the Algorithm}
\label{sec:correc}
In this section we prove soundness of our algorithm, that is the
inclusion  in
Proposition~\ref{prop:algoworks}. Recall that we work with a morphism
 into a finite semigroup~. By definition of , we need to
prove that  contains the set  and is closed under Downset, Multiplication and
\fo-Closure.

We already know from Fact~\ref{fct:trivial} that 
contains the set . Furthermore,
closure under Downset and Multiplication follows from
Fact~\ref{fct:downclos} and Lemma~\ref{lem:usemi}. Therefore, we only
need to prove that  is closed under \fo-Closure. This is
what we do now. To present the argument, we need an alternate
definition of .

Given two words  and , we write  to denote the fact that  and  satisfy the same \fo-formulas of
quantifier rank . One can verify that for all , \foeq{k} is an
equivalence relation of finite index and that each class can be
defined in \fo.

\begin{lemma} \label{lem:optequ}
Let . Then  if and
only if for all , there exists an equivalence class 
of \foeq{k} such that .
\end{lemma}

\begin{proof}
  Assume first that for all , there exists an equivalence
  class  of \foeq{k} such that . To prove that
  , we show that  for any
  \fo-partition \Kb. By definition, there exists  such that all
  languages in \Kb can be defined by a formula of quantifier rank  (recall
  that \fo-partitions are finite partitions). It follows that elements of \Kb
  are unions of classes of \foeq{k}, hence  is included in some language 
  of . By hypothesis, . It follows that
  , which terminates the proof of
  this direction.

  Conversely, assume that  and set . Set \Kb as
  the partition of  into equivalence classes of \foeq{k}. By definition,
  \Kb is an \fo-partition. Hence, there exists an equivalence class
   of \foeq{k} such that .
\end{proof}

We can now prove that  is closed under \fo-closure to conclude
the soundness proof: set
 and set , we need to prove that . We use
Lemma~\ref{lem:optequ}: for all , we shall find an equivalence class
 of \foeq{k} such that .

Set . Using the other direction of Lemma~\ref{lem:optequ}
for , we obtain an equivalence class  of \foeq{k} such that . Set .
By definition, . Therefore, it suffices to
prove that  is included in an equivalence class of 
(\emph{i.e.}, that all words in  are pairwise equivalent).
This
is a consequence of the following lemma, which is easy and folklore, and whose
simple proof is omitted here. It relies on \efgame games, details can be
found in~\cite{bookstraub}.

\begin{lemma} \label{lem:efconcat}
Set , then.
  \begin{enumerate}
  \item\label{item:5} For all , if
     and , then .
  \item\label{item:6} For all  and all , we have .
  \end{enumerate}
\end{lemma}

Let us now conclude the proof. Pick some arbitrarily chosen word .  By
Lemma~\ref{lem:efconcat}~\ref{item:5}, it is immediate that any word of 
is -equivalent to either  or to
. To conclude that all words of
 are -equivalent, it remains to prove that ,
which follows directly from Lemma~\ref{lem:efconcat}~\ref{item:6}.

\section{Completeness of the Algorithm}
\label{sec:comp}
In this section, we prove the most interesting inclusion from
Proposition~\ref{prop:algoworks}: . We use
induction to construct an \fo-partition \Kb whose imprint on  belongs
to . This proves that
. For the rest
of this section, we assume fixed a morphism  into a
finite semigroup. We state the induction in the following proposition. Note
that, in order to set up the induction, we have to start from a morphism from
some free monoid , where  is an \emph{arbitrary} alphabet, into an \emph{arbitrary}
subsemigroup \Ss of . This is because, following a proof from
Wilke~\cite{wfo}, we argue by induction on the size of (the index of) the
semigroup, and of the alphabet.

\begin{proposition} \label{prop:pumping}
Let  be a subsemigroup of  and  be a surjective morphism. Then there exists an \fo-partition \Kb
of  such that for all ,

\begin{enumerate}
\item\label{it:c1} .
\item\label{it:c2}  can be defined by a first-order formula
  of rank at most .
\end{enumerate}
\end{proposition}

Before proving Proposition~\ref{prop:pumping}, we apply it to conclude
the proof of Proposition~\ref{prop:algoworks}. Set  and  defined by
 (note that  is surjective). Recall
that by definition, . From
Proposition~\ref{prop:pumping}, we obtain an \fo-partition \Kb of 
such that, for all ,
\begin{enumerate}
\item\label{it:c1alpha} .
\item\label{it:c2alpha}  can be defined by a first-order formula
  of rank at most .
\end{enumerate}

It is now immediate from Item~\ref{it:c1alpha} and the fact that
 is closed under downset that . We conclude that  which terminates the proof of
Proposition~\ref{prop:algoworks}. Moreover, we already know from Section~\ref{sec:correc} that
, so we actually obtain that
: \Kb is optimal for .

This is of particular interest. Indeed, we know from Theorem~\ref{thm:seppart}
that for any two languages recognized by  that are \fo-separable, one
can construct a separator as a union of languages in \Kb. Therefore, since our
proof of Proposition~\ref{prop:pumping} is constructive (\Kb is built by
induction), we obtain a method for constructing an \fo-separator for any pair
of \fo-separable languages recognized by . Finally, we know from Item~\ref{it:c2alpha} that
this separator has quantifier rank at most  which yields the
second item in Theorem~\ref{th:main}.

\begin{corollary}[Second item in Theorem~\ref{th:main}]
Given two languages  and  that are recognized by ,
if they are \fo-separable, then one can effectively construct an actual separator with
a formula of quantifier rank at most .
\end{corollary}

Note that a rough analysis of the procedure that constructs separators
yields a 2-\textsc{Exptime} upper bound on the complexity in the size of
. This is because while the rank of the formula is ``only''
exponentially large in , its size is one exponential larger in
general.

Another interesting remark is that while this paper is written from a
logical perspective (we prove that \Kb is an \fo-partition by
constructing a first-order formula for each language in \Kb), the
construction is not specific to first-order logic. In other words, the
construction could be easily adapted to obtain \emph{star-free
  expressions}, \emph{\ltl formulas} or \emph{counter-free automata}
defining the languages in \Kb.

\bigskip

It now remains to prove Proposition~\ref{prop:pumping}. The rest
of this section is devoted to this proof. We set  as a
subsemigroup of  and  as a morphism as
in the statement of the proposition. The proof is a generalization of
Wilke's argument~\cite{wfo} for deciding first-order definability. As
explained above, the proof is constructive. We construct the partition
 as well as the first-order formulas that define its languages.
We proceed by induction on the following two parameters listed by
order of importance:
\begin{enumerate}[label=]
\item the index  of ,
\item the size of .
\end{enumerate}
The proof is divided into three cases:
\begin{itemize}
\item first, we consider the case when .
\item otherwise, we distinguish two subcases, depending
on a property of  called \emph{tameness}.
\end{itemize}

\subsection{\texorpdfstring{Special Case: .}{Special Case: |B| = 1.}}

In that case,  is a singleton . Hence all words are of the
form  for some . It follows from a standard semigroup
theory argument that there exists  such that . We
partition  into  languages.

For all , we set  as the singleton .
Finally, we set . It is immediate by
definition that  is a partition of .
Moreover, one can easily construct first-order formulas of rank at
most  for : \Kb is an
\fo-partition and we obtain Item~\ref{it:c2}. It remains to prove
Item~\ref{it:c1}.

For , we have . Hence Item~\ref{it:c1} is satisfied. Assume
now that . By definition of  and ,

Since  is closed under multiplication, it suffices to
prove that for all , we have . By definition, for any ,
. Moreover, observe that

Therefore,  is
immediate by Operation~\ref{eq:oper}.

\medskip

This terminates the case . For the remainder of the proof, we
now assume that . As explained above, we distinguish two
cases depending on a property of .

\medskip
\noindent
{\bf Tameness.} We say that  is \emph{tame} if  

\subsection{\texorpdfstring{Case 1:  is tame}{Case 1: beta is
    tame}} This is the base case: we don't use induction. We use
tameness to prove that . Therefore, it
suffices to choose,  since  (recall that  is assumed to be surjective).
This is a consequence of the following lemma:

\begin{lemma} \label{lem:basecase}
There exists a group  such that .
\end{lemma}

We first use Lemma~\ref{lem:basecase} to finish the proof of this
case. Let  be a group as given by the
lemma. We prove that . Since  is a
group, we get , so 
for all~. Combining these equalities gives us the equality

By definition, for all , , hence  since  is surjective. It then follows from
Multiplication Closure, \fo-Closure and the equality above that
. Since , this terminates the proof
in Case~1.

It remains to prove Lemma~\ref{lem:basecase}. We first prove that
while \Ss might not be a group itself, it is what we call a
\emph{pseudo-group}.

\medskip
\noindent
{\bf Pseudo-groups.} Let  be a subsemigroup of . We say
that \Ts is a \emph{pseudo-group} if for all ,
 and .

\begin{lemma} \label{lem:basecase2}
\Ss is a pseudo-group.
\end{lemma}

\begin{proof}
Set . We prove that . The
equality    is
symmetrical. Since  is surjective, there exists  such
that . We proceed by induction on the length of . If
 is of length , this is by tameness of .

Assume now that the result holds for words of length  and that 
is of length . This means that  with  a word of length
. By induction hypothesis, we get that . Moreover, using tameness, we get that . It follows that , which concludes the proof.
\end{proof}

We now finish the proof of Lemma~\ref{lem:basecase}. We prove that
any pseudo-group  that is not already a group
strictly contains a subsemigroup  that remains a pseudo-group, and
such that .  Applying this result iteratively
to \Ss yields the desired group \Gs.

\smallskip
Let  be a pseudo-group that is not already a
group. An easy and standard argument implies that there
must exist  such that  or . By symmetry assume that it is the former and
set . By definition,  is closed under product
and is therefore a semigroup. It remains to prove that  and that  is a
pseudo-group.

By definition, we have  and  since  is
a pseudo-group. We conclude that . Finally, set , we need to prove that
 and . Both equalities are immediate since
 and  is a pseudo-group.

\subsection{\texorpdfstring{Case 2:  is not tame.}{Case 2: beta
    is not tame.}} This is the case where we use induction. By
hypothesis on , there exists  such that  or . By symmetry, we assume the former, \emph{i.e.},

We set  as this
letter for the remainder of the proof.

\medskip
Recall that we have to construct an \fo-partition  of 
satisfying Items~\ref{it:c1} and~\ref{it:c2} in
Proposition~\ref{prop:pumping}. We begin by giving a brief overview of
the construction. Set . Observe that any word
 can be uniquely decomposed in three (possibly empty)
parts: a prefix in , an infix in  and a suffix in
. Our construction works by using induction to construct finite
partitions of the sets of possible prefixes, infixes and suffixes,
which yields a partition of the whole set . For the sets of
prefixes and suffixes (\emph{i.e.},  and ), the partitions
are simply obtained by induction on the size of alphabet. For the set
of infixes (\emph{i.e.} ) the argument is more involved
and is obtained by induction on the index of \Ss. We now make the
construction more precise. We begin by defining the partitions of the
sets of possible prefixes, infixes and suffixes, in the three lemmas
below.

\begin{lemma}[Partition of the prefixes] \label{lem:partpref}
There exists a finite partition  of  such that for any
language :
\begin{enumerate}
\item .
\item there exists a first-order formula of
  rank at most  that defines .
\end{enumerate}
\end{lemma}

\begin{lemma}[Partition of the suffixes] \label{lem:partsuff}
There exists a finite partition  of  such that for any
language :
\begin{enumerate}
\item\label{it:c1induction2} .
\item\label{it:c2induction2} there exists a first-order formula of
  rank at most  that defines .
\end{enumerate}
\end{lemma}

\begin{lemma}[Partition of the infixes] \label{lem:partinf}
There exists a finite partition  of  such that
for any language :
\begin{enumerate}
\item .
\item there exists a first-order formula of
  rank at most  that defines .
\end{enumerate}
\end{lemma}

Lemmas~\ref{lem:partpref}, \ref{lem:partsuff} and~\ref{lem:partinf}
are proved using both our induction hypotheses. Before we present
these proofs, we use the three lemmas to construct the desired
\fo-partition  of  and conclude the proof of
Proposition~\ref{prop:pumping}. We define  as follows:

That \Kb is partition of  is immediate since  and 
are partitions and any word in  can be \emph{uniquely} decomposed
as the concatenation of a prefix in , an infix in 
and a suffix in  (each one possibly empty, but not the three of them together). That \Kb is actually
an \fo-partition is a consequence of the following fact which describes
a standard construction for first-order logic over words.

\begin{fact} \label{fct:foconcat}
  Set  and two languages , each defined by a
  first-order formula of rank at most . Then  can be defined
  by a first-order formula of rank at most .
\end{fact}

\begin{proof}
  A word is in  if and only it can be cut into a prefix in 
  and a suffix in . Therefore, in first-order logic, it suffices to
  quantify existentially the position  at which the cut is made and then
  use the formulas that define  and  (modified so that
  quantifications are restricted to the left or to the right of ) to
  test whether the prefix and suffix belong to  and . By
  construction, the formula we obtain has rank at most .
\end{proof}

Since any language in \Kb is the concatenation of at most three
languages that are defined by first-order formulas of rank at most
 (see the first items in the three
lemmas), we obtain that \Kb is an \fo-partition as well as
Item~\ref{it:c2} in Proposition~\ref{prop:pumping}.

Finally, Item~\ref{it:c1} in Proposition~\ref{prop:pumping} (\emph{i.e.}, for
all , ) is an immediate
consequence of Item~\ref{it:c1induction2} in the three lemmas and the
fact that  is closed under multiplication. This terminates
the proof of Proposition~\ref{prop:pumping}.

It now remains to prove Lemmas~\ref{lem:partpref}, \ref{lem:partsuff}
and~\ref{lem:partinf}. We first take care of Lemma~\ref{lem:partpref}
and Lemma~\ref{lem:partsuff} which are immediate by induction. Indeed,
Lemma~\ref{lem:partpref} is obtained by applying the induction hypothesis
on the second parameter (the size of the alphabet) to the restriction
of  to  (recall that ). Furthermore,
Lemma~\ref{lem:partsuff} is exactly the special case when the alphabet
is of size one which is already proved.
\medskip

The proof of Lemma~\ref{lem:partinf} is more involved and is where we
use induction on the index of \Ss as well as our choice of the letter
 (\emph{i.e.}, the fact that  is not tame). We devote the remainder
of the section to this proof.

\newcommand\frB{\ensuremath{\mathfrak{B}}\xspace}
\newcommand\frL{\ensuremath{\mathfrak{L}}\xspace}
\newcommand\frS{\ensuremath{\mathfrak{S}}\xspace}
\newcommand\frb{\ensuremath{\mathfrak{b}}\xspace}
\newcommand\frw{\ensuremath{\mathfrak{u}}\xspace}
\newcommand\pred{\ensuremath{\text{pred}}\xspace}

Recall that our goal is to find a partition of  that
meets the conditions of the lemma.  We proceed in three steps.
First, we use Lemma~\ref{lem:partpref} and Lemma~\ref{lem:partsuff}
(\emph{i.e.}, our \fo-partitions of  and ) to abstract the set
 as a finite alphabet  and in turn the set 
as the set of all words in . This allows us to abstract the
restriction of  to  as a semigroup morphism
 into a new semigroup .
Then in a second step, we use the fact that  is not tame
(through our choice of ) to prove that  has smaller index than
\Ss. This enables us to apply induction to  and obtain an
\fo-partition of . Finally, in the third step, we construct
the desired partition of  from that of~.

\medskip
\noindent
{\bf Proof of Lemma~\ref{lem:partinf}, Step 1: Abstraction of
  .} We begin with the definition of the new alphabet
\frB. Intuitively, we want to simply set .
Indeed, we know by construction of \Hb and \Lb that  is a partition of . Therefore,
such an alphabet \frB would be a satisfying abstraction of .
However, there is an issue with this definition: in the proof, we do
not keep track of the size of the partitions \Hb and \Lb. Therefore,
such a definition does not allow us to control the size of \frB. This
is a problem for proving Item~\ref{it:c2induction2} in
Lemma~\ref{lem:partinf} as the bound on the quantifier rank of the
formulas obtained by induction depends on the size of the alphabet.
For this reason we use the following slightly different definition:

Observe that to any word , one can associate a unique
letter : since  and  are partitions,
there exist unique  and  such that ,
we simply set . This means that \frB
defines a finite partition of  (it is even an \fo-partition
by Fact~\ref{fct:foconcat}): two words are in the same class of the partition if they yield the same letter over . We extend the definition to words : any such  can be uniquely decomposed as  with , we set . In particular 
defines an infinite partition of .

We finish with the definition of the morphism . We set \Ts as
the subsemigroup of  generated by . Finally, set  defined by simply evaluating in \Ts the
product of the letters of a word in . The following fact is
immediate from the definitions. It links  to .

\begin{fact} \label{fct:linkmorph}
For any , .
\end{fact}

\medskip
\noindent
{\bf Proof of Lemma~\ref{lem:partinf}, Step 2: Constructing a
  partition of .} We use induction to partition . That
we may apply induction to   is a consequence of the following
fact, which is where we use our choice of  (\emph{i.e.}, the fact that
 is not tame).

\begin{fact} \label{fct:indexdown}
The index of  is strictly smaller than the index of \Ss.
\end{fact}

\begin{proof}
By definition, for any language , we have
. Hence,

By definition of , we know that . We conclude that  which terminates the proof.
\end{proof}

It follows from Fact~\ref{fct:indexdown} that we may apply induction
on our first induction parameter (the index of \Ss) to  and
obtain an \fo-partition  of  such that for all :
\begin{enumerate}
\item .
\item  can be defined with a first-order formula of rank at most
  .
\end{enumerate}

\medskip
\noindent
{\bf Proof of Lemma~\ref{lem:partinf}, Step 3: Constructing the
  partition  of .} For any , we define
. Finally, we set
. Since \Fb is a partition of
, it is immediate that  is a partition of
. It now remains to prove that Items~\ref{it:c1induction2}
and~\ref{it:c2induction2} in Lemma~\ref{lem:partinf} hold.

Let us first prove that Item~\ref{it:c1induction2} is satisfied. Set
. By definition,  for some . By
definition of  and Fact~\ref{fct:linkmorph}, we have that,

Moreover, by construction of , we know that . Finally, since , we have . Using closure under downset, we obtain that
 which terminates the proof of
Item~\ref{it:c1induction2}.

It now remains to prove that Item~\ref{it:c2induction2} holds. Set . We need to construct an \fo formula of rank at most  that defines . Note that it is
immediate that  can be defined in \fo (with a formula of
rank ): this amounts to testing that the first letter in the word
is a  and the last is a letter of . Therefore it suffices to
construct a formula  such that for all ,
 if and only if .

By construction, there exists  such that  as well as an
\fo formula  (over \frB) of rank less than  that defines . By definition of , it
suffices to construct  so that for any ,

The construction is standard, we build  by modifying
. Consider a word . We say that a position
 in  is \emph{distinguished} if and only if  is labeled by
a ``'' and position  has label in . In other words  is
the rightmost -labeled position of an infix in  of .
Recall that by definition, every letter of  abstracts an
infix in  of . Therefore, one can associate a position
 of  to every distinguished position  of~.

\begin{fact} \label{fct:defalpha}
For every , there exists a first-order formula
 of rank at most  such that for any  and any
distinguished position  of :

\end{fact}

\begin{proof}
This amounts to testing whether the maximal infix in  ending
at position  in  and the maximal infix in  starting at
position  in  are in the appropriate languages of \Hb and
\Lb that yield letter . This can easily be done with rank at most  since any language in \Hb or \Lb can be defined
by a formula of rank at most  (see
Lemma~\ref{lem:partpref} and Lemma~\ref{lem:partsuff}).
\end{proof}

The desired formula  is obtained from  by
restricting quantifications to distinguished positions and replacing
each atomic subformula of the form  by the formula
. This can clearly be done in first-order
logic. Observe that this formula has rank at most .
Since  and , we obtain:

Note that the last inequality is justified by the fact that
, which holds in this case since otherwise  would be the trivial group. This terminates the proof of Lemma~\ref{lem:partinf}.

\section{Alternate Algorithms}
\label{sec:altalgo}
In this section, we connect our algorithm with the ones of
Henckell~\cite{Henckell:Pointlike-sets:-finest-aperiodic:1988:a} and Henckell,
Rhodes and Steinberg~\cite{DBLP:journals/ijac/HenckellRS10a,qt}. These
algorithms (there are two of them) differ in the specific \fo-operation.
Although the change is minor and the correspondence between these algorithms
is easy to prove, this is what brings a complexity improvement, from
\textsc{Expspace} to \textsc{Exptime}. We include this easy section to bridge
the gap between all three algorithms. Note that the fact that the two given by
Henckell are equivalent was already shown
in~\cite{Henckell:Pointlike-sets:-finest-aperiodic:1988:a}.

The well-known decidable characterization of first-order logic by
Schützenberger~\cite{sfo,mnpfo} states that a language is
first-order \emph{definable} if and only if its syntactic semigroup is
\emph{aperiodic}. In the literature, there are many equivalent
definitions of aperiodicity. In this paper, we consider three of them:
one is equational, the second considers subgroups and the third
considers the \Hrel-classes. The relation `\Hrel' is one of Green's
relations which are well known in semigroup theory. Two elements 
of a semigroup  are \Hrel-equivalent if  or there exist  such that , ,  and
. We state the three equivalent definitions.

\begin{lemma}[Folklore, see~\cite{Pin13:MPRI}]
  A finite semigroup  is aperiodic if and only if it satisfies one
  of the following equivalent statements:
  \begin{enumerate}
  \item for all , .
  \item all subgroups in  are trivial.
  \item all -classes in  are trivial.
  \end{enumerate}
\end{lemma}

Our saturation procedure  can be viewed as a generalization of
the first definition of aperiodicity. Indeed,
Operation~\ref{eq:oper} reflects the equation . In this section, we present two alternate and equivalent
saturation procedures that reflect the two other definitions. Let
 be a morphism into a finite semigroup.

\smallskip
Let  be a subsemigroup of . We set  as the
smallest subset of  that contains \Ss and is closed under
downset, multiplication and the following operation:

Similarly,  is the smallest subset of  that
contains \Ss and is closed under downset, multiplication and the
following operation:


 reflects the second definition of aperiodicity and
 the third. In the following proposition, we state that the
three saturation procedures are equivalent and can therefore all be
used to compute  by Proposition~\ref{prop:algoworks}.

\begin{proposition} \label{prop:alternate}
  Let  be a subsemigroup of . Then, 
\end{proposition}\smallskip

\noindent Note that the saturation procedure  is essentially Henckell's
original algorithm~\cite{Henckell:Pointlike-sets:-finest-aperiodic:1988:a}, where  was also shown to be a correct saturation operation. We
finish the section by proving Proposition~\ref{prop:alternate}.

\begin{proof}
We prove that . Let us first prove that .

\medskip\noindent
{\boldmath.} By
definition of  and , this amounts to proving
that  is closed under \fo-closure: for any , .

Set . Observe that  and 
are \Hrel-equivalent elements in the semigroup , and are
therefore both contained in some \Hrel-class . By definition of , we then have
. Hence, , which ends the
proof since  is closed under downset.

\medskip\noindent
{\boldmath}. This inclusion, which is
easy to prove, follows
from~\cite{Henckell:Pointlike-sets:-finest-aperiodic:1988:a}. We give here a
proof for the sake of completeness.

By definition of  and ,
this amounts to proving that  is closed
under~\ref{eq:oper-h}: for all  that is
an \Hrel-class, .

Let  be an \Hrel-class. We claim that
either \Hs is a singleton, or there exists a group \Gs in
 and  such that .
If \Hs is a singleton, then  is the unique element of
\Hs which belongs to . Otherwise, using closure under
multiplication, it follows that  since  by
Operation~\ref{eq:oper-g} in the definition of .

It remains to prove the claim (which actually is not specific to
subsemigroups of a semigroup of subset): every \Hrel-class \Hs of
a semigroup \Ts is either a singleton, or of the form , for
  and  a group in .  Let . If  is not a singleton, then Green's
 Lemma implies that  is nonempty, and therefore it is a
 subsemigroup of \Ts. Let \Gs be an \Hrel-class of its minimal
 ideal. By standard results in semigroup theory~\cite[Chapter~V]{Pin13:MPRI}, \Gs is a group. Let us
 check that , for any . Indeed, let 
 and let  be the identity of \Gs. Since , we have
  for some , and so . Let now
 . By definition, we have  for some
 . Note that since  is in the minimal ideal, we have
 . Hence . This proves the
 claim and establishes the inclusion.

\medskip\noindent
{\boldmath.} By definition of
 and , this amounts to proving that
 is closed under~\eqref{eq:oper-g}: for all  that is a group, .

Set  that is a group and set
 with  and let
 be the identity element of . Since  is a group,
for all , . In particular this means that
for all , .
By combining these equalities, we get

It follows from \fo-closure and closure under multiplication that
.
\end{proof}

\section{Infinite Words}
\label{sec:omega}
An advantage of our technique for proving Theorem~\ref{th:main} is
that it generalizes smoothly to the setting of infinite words, \emph{i.e.},
it can be adapted to prove that \fo-separability is decidable for
infinite words. Both the algorithm itself and its proof are very similar to
those of the finite words setting. In particular, we retain all
results that we already have for finite words:

\begin{itemize}
\item we get an {\sc Exptime} upper bound on the complexity of the
  problem.
\item we get an exponential upper bound on the quantifier rank of a
  potential separator.
\item the proof is constructive: if a separator exists, one can be
  constructed by induction.
\end{itemize}

The remainder of the paper is devoted to the presentation of this
generalization. In this section, we introduce \iwords and generalize
our definitions to this setting: we define \ilangs, \isemis and
first-order logic over \iwords. We postpone the presentation of the
separation algorithm itself (which requires generalizing our framework
to \iwords) to the next section, Section~\ref{sec:omegasep}. Finally,
Section~\ref{sec:comp-i} is devoted to the proof of this algorithm.

\subsection{\texorpdfstring{Regular Languages of \iwords}{Regular Languages of
    infinite words}}

\medskip
\noindent {\textbf{\iwords and \ilangs.}} Recall that  is a finite
alphabet. We denote by  the set of infinite words, called \emph{\iwords} over . Note
that we still use the term ``word'' to mean an element of . If
 is a word and  an \iword, we denote by  or  the \iword
obtained by concatenating  to the left of , and by  the
\iword obtained by infinite concatenation of  with
itself\,\footnote{In the literature, the \iword  is usually
  denoted by . Here, we use this non standard notation in
  order to avoid confusion with the idempotent power  in
  semigroups.}. An \emph{\ilang} is a subset of . \emph{Regular}
\ilangs are those that are accepted by \emph{nondeterministic Büchi
  automata} (NBA). Again, we will only work with the algebraic
representation of \ilangs that we recall below.

\medskip
\noindent
{\textbf{\isemis.}} We briefly recall the definition of \isemis, which
play the role of semigroups in the setting of \iwords. For more details, we
refer the reader to~\cite{Perrin&Pin:Infinite-Words:2004:a}.

An \emph{\isemi} is a pair  where  is a
semigroup and  is a set. Moreover,  is
equipped with two additional products: a \emph{mixed product}  that maps  to an element denoted , and an \emph{infinite
  product}  that maps an
infinite sequence  to an element
of  denoted by . We require these products
as well as the semigroup product of  to satisfy all possible
forms of associativity (see~\cite{Perrin&Pin:Infinite-Words:2004:a}
for details). Finally, we denote by  the element
. Observe that  is an \isemi.

The notions of subsemigroups and morphisms can be adapted to
\isemis. In particular, if  is a subsemigroup of  and
 is the set obtained by applying the infinite product to all
sequences of , then  is a \sisemi of
 called the \emph{\sisemi generated by~}.

An \isemi is said to be \emph{finite} if both  and 
are finite. Note that even if an \isemi is finite, it is not obvious
that a finite representation of the infinite product exists. However,
it was proven by Wilke~\cite{womega} that the infinite product is
fully determined by the mapping , yielding
a finite representation for finite \isemis. An \ilang~ is said to be
\emph{recognized} by an \isemi  if there exists  as well as a morphism  such that . It is well known
that an \ilang is regular if and only if it is recognized by a
\emph{finite} \isemi. Moreover~\cite{womega}, from any NBA recognizing
, one can compute a canonical smallest \isemi recognizing ,
called the \emph{syntactic \isemi of .}

As for finite words, when working on separation, it is convenient to
consider a single recognizing object for both input languages rather
than two separate objects. Again, this is not restrictive: given two
\ilangs and two associated recognizing \isemis, one can define (and
compute) a single \isemi that recognizes both languages by taking the
Cartesian product of the two original \isemis.

\medskip
\noindent
{\bf Semigroup of Subsets.} For an \isemi , note
that  is an \isemi with the products
defined in the natural way.

\subsection{\texorpdfstring{First-Order Logic over
    \iwords.}{First-Order Logic over Infinite Words.}}

As for words, an \iword can be viewed as a sequence of positions that
are labeled over  (the difference being that in the case of
\iwords, the sequences are infinite: there is a leftmost position but
no rightmost one). Therefore, first-order formulas as we defined them can
also be interpreted on \iwords and we can simply say that an \ilang
 is first-order definable if and only if there
exists an \fo formula  such that .

First-order logic over \iwords shares similar properties with
first-order logic over words. First, the equivalence with star-free
languages still holds for \ilangs: an \ilang is first-order definable
if and only if it is
star-free~\cite{Ladner:Application-model-theoretic-games:1977:a,tfo}.
Furthermore, Schützenberger's Theorem was generalized to \ilangs by
Perrin~\cite{pfo}: a regular \ilang is star-free (and hence \fo) if
and only if the finite semigroup  of its syntactic \isemi
 is aperiodic. Note that we obtain an alternate proof
of this theorem as a simple consequence of our separation algorithm.

Our main theorem for \ilangs is similar to Theorem~\ref{th:main} for
languages and is as~follows.

\begin{theorem} \label{th:main-i}
  Let  be regular \ilangs recognized by a morphism
   into a finite \isemi. The
  two following items hold.
  \begin{enumerate}
  \item One can decide in {\sc Exptime} with respect to  whether
     and  are \fo-separable.
  \item When  and  are \fo-separable, one can construct an
    actual separator with a formula of quantifier rank at most
    .
  \end{enumerate}
\end{theorem}\smallskip

\noindent The proof of Theorem~\ref{th:main-i} is very similar to the one of
Theorem~\ref{th:main} and relies on the same objects: \fo-partitions
and optimal imprints (generalized to \iwords). In particular, this
means that our proof remains constructive: it yields an inductive way
to construct an actual separator, \emph{i.e.}, an \fo-partition of 
that is optimal for the input morphism , when it exists (a
rough analysis yields a -{\sc Exptime} complexity in ).

\section{Separation Algorithm for Infinite Words}
\label{sec:omegasep}
In this section, we present our separation algorithm for first-order
logic over \iwords. As we explained, this algorithm is based on a
generalization of our finite words framework to \iwords. Therefore,
we divide this section in two parts. In the first part, we generalize
\fo-partitions, imprints and Theorem~\ref{thm:seppart} to
\iwords. Then, in the second part, we present our separation algorithm.

\subsection{Definition}

Recall that a finite alphabet  is fixed. For the definitions, we
let \Cs as an arbitrary class consisting of languages and \ilangs (\emph{i.e.}, ). Moreover, we assume that
\begin{itemize}
\item when restricted to languages, \Cs is nonempty, closed
  under Boolean operations and quotients, and contains only regular languages,
\item when restricted to \ilangs, \Cs is nonempty and closed
  under Boolean operations.
\end{itemize}

One can verify that \fo satisfies these conditions. Note that since
\Cs is assumed to contain both languages and \ilangs, one can consider
two kinds of \Cs-partitions: \Cs-partitions of  and
\Cs-partitions of .

Set  as an arbitrary
morphism into a finite \isemi . Observe that any such
morphism  can be decomposed into two maps: a morphism
 into a finite semigroup  and a map
 into a finite set .

Since  is a morphism, we may directly apply our
definition of imprints for finite words to it: if \Kb is a \Cs-partition of , then
 is well-defined. Similarly, by
hypothesis on \Cs, the optimal \Cs-partitions of  for 
are well-defined as those having the smallest possible imprint on
: . In particular, we know from
Lemma~\ref{lem:usemi} and our hypothesis on \Cs that 
is a subsemigroup of .

It turns out that aside from Lemma~\ref{lem:usemi}, these definitions
do not require  to be a semigroup morphism. Hence, they can
also be applied to . If \Kb is a \Cs-partition of ,
then the imprint of  on  is defined by,

Note that one can verify that imprints on  still verify
Fact~\ref{fct:trivial}  (\emph{i.e.}, for all ,
) and
Fact~\ref{fct:downclos} (\emph{i.e.},  is closed
under downset). Finally, the optimal \Cs-partitions of  for
 are defined as those having the smallest possible
imprint on :  (as before, we
need the fact that \Cs is closed under intersection to prove that
there exists at least one optimal \Cs-partition, see
Lemma~\ref{lem:optimal}).

\begin{remark}\label{rem:subisemi}
Note that in this case, since  is not a semigroup, it is not
true that  is a semigroup. However, with
additional hypotheses on \Cs (which correspond to the usual
generalization of closure under quotients to classes of \ilangs), one
could prove that the pair 
is a \sisemi of . We will prove this property
in the special case where .
\end{remark}

We can now generalize Theorem~\ref{thm:seppart} to \iwords.

\begin{theorem} \label{thm:sepparti}
Let  be a morphism into a
finite \isemi . Let  be two
\ilangs recognized by  and let 
be the corresponding accepting sets. The following properties are
equivalent:
\begin{enumerate}
\item\label{item:cov2sep1-inf}  and  are \Cs-separable.
\item\label{item:cov2sep2-inf} for all  and all , .
\item\label{item:cov2sep3-inf} for any \Cs-partition \Kb of 
  that is optimal for ,  and  are separable by a
  union of languages in .
\end{enumerate}\smallskip
\end{theorem}

\noindent The proof of Theorem~\ref{thm:sepparti} is identical to that of
Theorem~\ref{thm:seppart}. In view of the theorem, generalizing our
approach to \ilangs amounts to finding an algorithm that computes
 from a morphism  into a finite
\isemi. We now present such an algorithm.

\subsection{Separation Algorithm}

We can now generalize our separation algorithm to the setting of
\iwords. Let  be a morphism
into a finite \isemi . From now on, we only work with
the class \fo, therefore, we simply write
 to denote the pair
. We present an algorithm for
computing this pair.

We already know how to compute  from
:  with ``''
defined in Section~\ref{sec:main} (see
Proposition~\ref{prop:algoworks}). It turns out that
 can easily be computed from~.
For , let  be the smallest subset of  closed
under the following operations:
\begin{enumerate}
\item\label{eq:ioper1} For any , we have .
\item\label{eq:ioper2} For any  and , we have .
\item\label{eq:ioper3}  is closed under downset:
.
\end{enumerate}

In other words,  is the smallest subset of 
that is closed under downset and such that  is a
\sisemi of . This smallest subset of 
clearly exists. Finally, we set  as
.

\begin{proposition} \label{prop:algoworks-i}
Set  as a morphism
into a finite \isemi . Then,

\end{proposition}\smallskip

\noindent Since we already know how to compute  in {\sc Exptime}
with respect to  (see Proposition~\ref{prop:algoworks}), it
follows from Proposition~\ref{prop:algoworks-i} that one can compute
 in {\sc Exptime} with respect to  as well.
It then follows from Theorem~\ref{thm:sepparti} that this generalizes
our upper bound on the complexity of the separation problem to
\ilangs: one can decide in {\sc Exptime} whether two \ilangs are
\fo-separable. Therefore, we obtain the first item in
Theorem~\ref{th:main-i} as a corollary. We will obtain the second item
as a byproduct of the proof of Proposition~\ref{prop:algoworks-i}.

Another important remark is that it follows from
Proposition~\ref{prop:algoworks-i} that
 is a \sisemi of
. As explained in Remark~\ref{rem:subisemi},
this property is not specific to \fo. On the other hand, what is
specific to \fo is that  is the {\bf smallest}
subset of  that is closed under downset and such that
 is a \sisemi of
.

Finally, a consequence of
Proposition~\ref{prop:algoworks-i} is that we obtain Perrin's
theorem~\cite{pfo} as a corollary, just as we obtained Schützenberger's
one~\cite{sfo} as a corollary of Proposition~\ref{prop:algoworks}.

\begin{corollary} \label{cor:caraci}
Let  be a regular \ilang. Then  can be defined in \fo if and
only if its syntactic \isemi  is such that  is
aperiodic.
\end{corollary}

\begin{proof}
The proof is similar to that of Corollary~\ref{cor:carac}. It is
known that an \ilang is definable in \fo if and only if all languages
and \ilangs recognized by its syntactic \isemi are definable in \fo as
well (as before, this is actually not specific to \fo and true for all
classes of \ilangs that are ``Varieties'',
see~\cite{Perrin&Pin:Infinite-Words:2004:a} for example). It follows
that, if  is the syntactic
\isemi of , then  is definable in \fo if and only if 
and  contain only singletons and the empty set.
One can then verify from Proposition~\ref{prop:algoworks} that this is
is equivalent to  satisfying,  for all .
\end{proof}

\noindent
It now remains to prove Proposition~\ref{prop:algoworks-i}. We present
this proof in the next section, Section~\ref{sec:comp-i}.

\section{Correctness of the Infinite Words Algorithm}
\label{sec:comp-i}
This section is devoted to the proof
Proposition~\ref{prop:algoworks-i}. We fix a morphism  into a finite \isemi
 for the whole section. We have to prove that
. We separate the proof
in two parts, each one corresponding to an~inclusion.

\subsection{Soundness of the Algorithm}
\label{sec:corr-algor}
We begin with the easiest inclusion: . This corresponds to soundness of the algorithm:
it only computes sets belonging to . By
definition of , we need to prove that:
\begin{itemize}
\item For any , we have .
\item For any  and , we have
  .
\item  is closed under downset.
\end{itemize}

That  is closed under downset is immediate from
the definition ( is an imprint). We prove the two
other items. The proof relies on the generalization of the equivalence
 to \iwords: given two \iwords  and , we write  to denote the fact that  and
 satisfy the same formulas of quantifier rank . One can verify
that Lemma~\ref{lem:optequ} still holds for \iwords.

\begin{lemma} \label{lem:optequi}
  Let . Then  if and only if for all , there exists
  an equivalence class  of \foeq{k} such that .
\end{lemma}

We can now finish the proof of soundness. Set 
and . We use Lemmas~\ref{lem:optequi} to
prove that  and . Set .

By Lemmas~\ref{lem:optequ} and~\ref{lem:optequi}, we obtain an
equivalence class  of \foeq{k} (over finite words)
and an equivalence class  of \foeq{k} (over
\iwords) such that  and . We know from Lemma~\ref{lem:optequi} that it suffices to
prove that  and  are included in equivalence classes of
\foeq{k} in order to conclude that  and
. This can be easily verified using a
generalization of the first item of Lemma~\ref{lem:efconcat} to
\iwords: for any  and , one can verify that
any \iword in  is -equivalent to  and that
any \iword in  is -equivalent to .

\subsection{Completeness of the Algorithm}
\label{sec:compl-algor}

We now turn to the most interesting inclusion in
Proposition~\ref{prop:algoworks-i}: . The proof is a generalization of that of
Proposition~\ref{prop:pumping} to the setting of \iwords. In
particular, the proof remains constructive: we use induction to
construct an \fo-partition \Kb of  whose imprint on
 is included in . This proves that
. The induction is stated in the following
proposition.

\begin{proposition} \label{prop:pumping-i}
Let  be a \sisemi of\/  and let  be a surjective morphism. Then
there exists an \fo-partition \Kb of  such that for all :

\begin{enumerate}
\item\label{it:c1-i} .
\item\label{it:c2-i}  can be defined by a first-order formula
  of rank at most .
\end{enumerate}
\end{proposition}

Let us first use Proposition~\ref{prop:pumping-i} to conclude the
proof of Proposition~\ref{prop:algoworks-i}. Set ,  and 
defined by  for 
(note that  is surjective). Recall that we already know from
Proposition~\ref{prop:algoworks} that . Therefore, by definition, . From Proposition~\ref{prop:pumping-i}, we
obtain an \fo-partition \Kb of  such that  for all ,
\begin{enumerate}
\item .
\item any  can be defined by a first-order formula
  of rank at most .
\end{enumerate}

It is now immediate from Item~1 and the fact that
 is closed under downset that
. We conclude
that  which terminates the proof of
Proposition~\ref{prop:algoworks-i}. Moreover, since we already know
that , we actually
have :  is optimal
for . Therefore, we obtain the second item in
Theorem~\ref{th:main-i} from Item~\ref{it:c2-i} of Proposition~\ref{prop:pumping-i}.

\begin{corollary}[Second item in Theorem~\ref{th:main-i}]
Given two \ilangs  and  that are recognized by ,
if they are \fo-separable, then one can construct an actual separator with
a formula of quantifier rank at most .
\end{corollary}
\enlargethispage{\baselineskip}

It remains to prove Proposition~\ref{prop:pumping-i}. We generalize
the techniques we used to prove Proposition~\ref{prop:pumping}. Note
that in several cases, the construction will require building an
\fo-partition of  (or of a subset of ). In this cases, we
will simply use Proposition~\ref{prop:pumping}. As for
Proposition~\ref{prop:pumping}, we construct  by induction on
the following two parameters listed by order of importance:
\begin{enumerate}[label=]
\item the index  of ,
\item the size of .
\end{enumerate}

Observe that the case  is trivial in this setting: in that
case  is a singleton. We now assume that 
and distinguish two subcases, depending on whether the restriction of
 to  is \emph{tame}. Recall that we say that  is
\emph{tame} if for all ,  and  .

\medskip
\noindent
{\bf Case 1:  is tame.} As we have seen in the proof of
Proposition~\ref{prop:pumping}, in that case we have . By surjectivity of  it is immediate that
. Therefore, by Item~\ref{eq:ioper1}
in the definition of , . It is therefore sufficient to set  to satisfy Item~\ref{it:c1-i} and Item~\ref{it:c2-i}
in the proposition.

\medskip
\noindent
{\bf Case 2:   is not tame.}  By
hypothesis on , there exists  such that  or . By symmetry, we assume the former,
\emph{i.e.}, . We
set  as this letter for the remainder of the proof.

Recall that we have to construct an \fo-partition  of 
satisfying Items~\ref{it:c1-i} and~\ref{it:c2-i} in
Proposition~\ref{prop:pumping-i}. Set  and
observe that  is the (disjoint) union of the following five
sets:

Therefore, it suffices to find \fo-partitions satisfying
Items~\ref{it:c1-i} and~\ref{it:c2-i} for all five sets to obtain
the desired partition of . These partitions are defined from
\fo-partitions of  and  (obtained from
Proposition~\ref{prop:pumping}), of  and 
(obtained by induction on  in Proposition~\ref{prop:pumping-i})
and of  (obtained by induction on the index of
 in Proposition~\ref{prop:pumping-i}). Since the construction
is similar for all five sets, we only detail the case of
 (other cases are handled similarly). The
construction is based on the following two lemmas.

\begin{lemma}[Partition of ] \label{lem:partcp}
There exists a finite partition  of  such that for any
language :
\begin{enumerate}
\item .
\item there exists a first-order formula of
  rank at most  that defines .
\end{enumerate}
\end{lemma}

\begin{lemma}[Partition of ] \label{lem:partbc}
There exists a finite partition  of  such
that for any language :
\begin{enumerate}
\item .
\item there exists a first-order formula of
  rank at most  that defines .
\end{enumerate}
\end{lemma}

Lemma~\ref{lem:partcp} is obtained by applying
Proposition~\ref{prop:pumping} to the restriction of  to
. The proof of Lemma~\ref{lem:partbc} is a straightforward
generalization to \iwords of the proof of Lemma~\ref{lem:partinf} and
is left to the reader (note that this is where our choice of  and
induction on the index of  are used).

Let us now explain how to construct the desired \fo-partition of
. Consider the following partition  of
,

It is immediate from the fact that  and  are
partitions that  is a partition of
. Moreover, it follows from Item~(1) of
Lemmas~\ref{lem:partcp} and~\ref{lem:partbc} and the second item in
the definition of  that  satisfies the first item
in Proposition~\ref{prop:pumping-i}: for all ,
. Finally, that the
second item in Proposition~\ref{prop:pumping-i} holds (\emph{i.e.}, that any
language in  can be defined by a \fo formula of rank at most
) comes from the following fact
(which generalizes Fact~\ref{fct:foconcat} to \iwords).

\begin{fact} \label{fct:foconcati}
Set . Let  be a language and  be an \ilang, each
defined by a first-order formula of rank at most . Then
 can be defined by a first-order formula of rank at most
.
\end{fact}

\section{Conclusion}

We have given simple and self-contained proofs that one can decide in
\textsc{Exptime} whether two regular languages of finite or infinite words are
separable by first-order logic. Further, we have obtained an upper bound on the
quantifier rank of an expected separator. We have also described a procedure to
compute, given as input a morphism  into a finite semigroup, a finite
set of \fo-formulas whose associated languages form a partition of , and
such that any two \fo-separable languages recognized by  can be
separated by a disjunction of some of these formulas. These formulas are computed
inductively along the correctness proof of our algorithm.

There are some open questions left in this line of research. First, we do not
know if the bounds are tight. We conjecture that the problem is
\textsc{Exptime}-complete starting from semigroups. A related question is the
complexity, starting from NFAs. Our results imply a 2-\textsc{Exptime} upper
bound (for DFAs, checking first-order definability
is~\textsc{Pspace}-complete~\cite{DFA-sf-PSPACE}). Moreover, we do not know
whether the bounds on the quantifier depth and the size of the expected
separator are tight. Finally, it is likely that these techniques can be
extended to other settings without much difficulty, as for finite or infinite
Mazurkiewicz traces. A much more interesting and challenging problem is to
look at separation for tree languages, where, for first-order logic, even
getting a decidable characterization is open despite many recent attempts.

\bibliographystyle{abbrv}
\begin{thebibliography}{10}

\bibitem{ABR:Undec-Identity:92}
D.~Albert, R.~Baldinger, and J.~Rhodes.
\newblock Undecidability of the identity problem for finite semigroups.
\newblock {\em The Journal of Symbolic Logic}, 57(1):179--192, 1992.

\bibitem{MR1709911}
J.~Almeida.
\newblock Some algorithmic problems for pseudovarieties.
\newblock {\em Publ. Math. Debrecen}, 54:531--552, 1999.
\newblock {P}roc. of {Automata and Formal Languages, VIII}.

\bibitem{AZ97-J}
J.~Almeida and M.~Zeitoun.
\newblock {The pseudovariety J is hyperdecidable}.
\newblock {\em {RAIRO Inform. Théor. Appl.}}, 31(5):457--482, 1997.

\bibitem{DBLP:journals/ijac/Auinger10}
K.~Auinger.
\newblock On the decidability of membership in the global of a monoid
  pseudovariety.
\newblock {\em IJAC}, 20(2):181--188, 2010.

\bibitem{Beauquier&Pin:Languages-scanners:1991:a}
D.~Beauquier and J.~E. Pin.
\newblock Languages and scanners.
\newblock {\em Theoret. Comput. Sci.}, 84(1):3--21, 1991.

\bibitem{DFA-sf-PSPACE}
S.~Cho and D.~T. Huynh.
\newblock Finite-automaton aperiodicity is {PSPACE}-complete.
\newblock {\em Theoret. Comput. Sci.}, 88(1):99--116, 1991.

\bibitem{Costa:Free-profinite-locally-idempotent:2001:a}
J.~C. Costa.
\newblock Free profinite locally idempotent and locally commutative semigroups.
\newblock {\em J. Pure Appl. Algebra}, 163(1):19--47, 2001.

\bibitem{Costa&Nogueira:Complete-reducibility-pseudovariety:2009:a}
J.~C. Costa and C.~Nogueira.
\newblock Complete reducibility of the pseudovariety {LSl}.
\newblock {\em Internat. J. Algebra Comput.}, 19(02):247--282, 2009.

\bibitem{sep_icalp13}
W.~Czerwi\'nski, W.~Martens, and T.~Masopust.
\newblock Efficient separability of regular languages by subsequences and
  suffixes.
\newblock In {\em ICALP'13}, volume 7966 of {\em Lect. Notes Comp. Sci.}, pages
  150--161. Springer, 2013.

\bibitem{Diekert&Gastin:First-order-definable-languages:2008:a}
V.~Diekert and P.~Gastin.
\newblock First-order definable languages.
\newblock In {\em Logic and Automata: History and Perspectives}, volume~2,
  pages 261--306. Amsterdam Univ. Press, 2008.

\bibitem{Henckell:Pointlike-sets:-finest-aperiodic:1988:a}
K.~Henckell.
\newblock Pointlike sets: the finest aperiodic cover of a finite semigroup.
\newblock {\em J. Pure Appl. Algebra}, 55(1-2):85--126, 1988.

\bibitem{DBLP:journals/ijac/HenckellRS10a}
K.~Henckell, J.~Rhodes, and B.~Steinberg.
\newblock Aperiodic pointlikes and beyond.
\newblock {\em Internat. J. Algebra Comput.}, 20(2):287--305, 2010.

\bibitem{kltl}
H.~W. Kamp.
\newblock {\em Tense Logic and the Theory of Linear Order}.
\newblock Phd thesis, CS Department, University of California at Los~Angeles,
  USA, 1968.

\bibitem{Ladner:Application-model-theoretic-games:1977:a}
R.~E. Ladner.
\newblock Application of model theoretic games to discrete linear orders and
  finite automata.
\newblock {\em Inform. Control}, 33(4):281--303, 1977.

\bibitem{mnpfo}
R.~McNaughton and S.~Papert.
\newblock {\em Counter-Free Automata}.
\newblock {MIT} Press, 1971.

\bibitem{pfo}
D.~Perrin.
\newblock Recent results on automata and infinite words.
\newblock In {\em MFCS'84}, volume 176 of {\em Lect. Notes Comp. Sci.}, pages
  134--148. Springer, 1984.

\bibitem{Perrin&Pin:Infinite-Words:2004:a}
D.~Perrin and J.~E. Pin.
\newblock {\em Infinite Words}.
\newblock Elsevier, 2004.

\bibitem{Pin13:MPRI}
J.~E. Pin.
\newblock Mathematical foundations of automata theory, 2016.\\
\newblock \texttt{\url{http://www.liafa.jussieu.fr/~jep/PDF/MPRI/MPRI.pdf}}.

\bibitem{pseps3}
T.~Place.
\newblock Separating regular languages with two quantifier alternations.
\newblock In {\em Proceedings of the 30th Annual ACM/IEEE Symposium on Logic in
  Computer Science (LICS'15)}, pages 202--213. IEEE, 2015.

\bibitem{ltltt:2013}
T.~Place, L.~van Rooijen, and M.~Zeitoun.
\newblock Separating regular languages by locally testable and locally
  threshold testable languages.
\newblock In {\em FSTTCS'13}, volume~24 of {\em LIPIcs}, pages 363--375, 2013.

\bibitem{PvRZ:mfcs}
T.~Place, L.~{van Rooijen}, and M.~Zeitoun.
\newblock Separating regular languages by piecewise testable and unambiguous
  languages.
\newblock In {\em MFCS'13}, volume 8087 of {\em Lect. Notes Comp. Sci.}, pages
  729--740. Springer, 2013.

\bibitem{PvRZ:LTT:14}
T.~Place, L.~van Rooijen, and M.~Zeitoun.
\newblock On separation by locally testable and locally threshold testable
  languages.
\newblock {\em Logical Methods in Computer Science}, 10(3:24):1--28, 2014.

\bibitem{PZ:icalp14}
T.~Place and M.~Zeitoun.
\newblock Going higher in the first-order quantifier alternation hierarchy on
  words.
\newblock In {\em {ICALP'14}}, 2014.

\bibitem{PZ:lics14}
T.~Place and M.~Zeitoun.
\newblock Separating regular languages with first-order logic.
\newblock In {\em {CSL-LICS'14}}, 2014.

\bibitem{Rhodes99-undec}
J.~Rhodes.
\newblock Undecidability, automata, and pseudovarities of finite semigroups.
\newblock {\em IJAC}, 9(3-4):455--474, 1999.

\bibitem{qt}
J.~Rhodes and B.~Steinberg.
\newblock {\em The q-theory of Finite Semigroups}.
\newblock Springer, 2008.

\bibitem{sfo}
M.~P. Sch{\"u}tzenberger.
\newblock On finite monoids having only trivial subgroups.
\newblock {\em Inform. Control}, 8:190--194, 1965.

\bibitem{Steinberg:98}
B.~Steinberg.
\newblock On pointlike sets and joins of pseudovarieties.
\newblock {\em Internat. J. Algebra Comput.}, 8(2):203--231, 1998.

\bibitem{Steinberg:delay2001}
B.~Steinberg.
\newblock A delay theorem for pointlikes.
\newblock {\em Semigroup Forum}, 63(3):281--304, 2001.

\bibitem{Steinberg:01}
B.~Steinberg.
\newblock A delay theorem for pointlikes.
\newblock {\em Sem. Forum}, 63(3):281--304, 2001.

\bibitem{Straubing:Finite-semigroup-varieties-form:1985:a}
H.~Straubing.
\newblock Finite semigroup varieties of the form {}.
\newblock {\em J. Pure Appl. Algebra}, 36({C}):53--94, 1985.

\bibitem{bookstraub}
H.~Straubing.
\newblock {\em Finite Automata, Formal Logic and Circuit Complexity}.
\newblock Birkhauser, 1994.

\bibitem{tfo}
W.~Thomas.
\newblock Star-free regular sets of omega-sequences.
\newblock {\em Inform. and Control}, 42(2):148--156, 1979.

\bibitem{Thomas:Languages-automata-logic:1997:a}
W.~Thomas.
\newblock Languages, automata, and logic.
\newblock In {\em Handbook of formal languages}. Springer, 1997.

\bibitem{womega}
T.~Wilke.
\newblock An {E}ilenberg theorem for {}-languages.
\newblock In {\em ICALP'91}, volume 510 of {\em Lect. Notes Comp. Sci.}, pages
  588--599. Springer, 1991.

\bibitem{wfo}
T.~Wilke.
\newblock Classifying discrete temporal properties.
\newblock In {\em STACS'99}, volume 1563 of {\em Lect. Notes Comp. Sci.},
  pages 32--46. Springer, 1999.

\end{thebibliography}

\end{document}
