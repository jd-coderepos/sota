In this section we provide the proofs to the lemmas presented 
in Section \ref{ssec:tr-vs-rr}. Before proceeding to the proofs 
let us introduce some notation we use throughout this section. 

Let  be a set of ranked registers. Let  denote the set 
of ranked registers on which a process  
performs a  during a coverable write operation 
in an execution . , where  is the set of ranked 
register such that  performs a  that commits 
during , and 
 the set of ranked register such that  performs 
a  that aborts during . 
For any pair of write operations ,
let the set  be the set of ranked registers such that 
both  and  perform a ranked write. We finally denote by
 and , the 
set of registers where  committed (or aborted resp.) during
 and they were also written during operation .\vspace{1em}




\noindent {\bf Proof of Lemma \ref{lem:commit}.}
Let the weakly coverable register be implemented by  
ranked registers each with a highest rank  
respectively at the end of some execution fragment . 
For the rest of the proof we will construct extensions of .  
Also, let the state of the coverable object be  at the 
end of .

Assume to derive contradiction that we extend  
with a write operation 
that revises the coverable register, and 
all the write operations performed during  on the ranked 
registers abort. From that it follows that for each 
write operation  performed 
by  on some register , . 
Let the new execution be . 


We extend  with another write operation 
 by process  to obtain 
execution . \nn{Since  then by \emph{consolidation},
, and . Moreover, since  is not concurrent 
with any other operation, then 
by consolidation  is the largest version introduced in . 
Since, by \emph{continuity},  has to be equal to a version introduced by a preceding
operation, and since  (the largest version introduced), then  
 revises  to a newer version .}
Note however that for any write operation  
performed on any of the ranked registers, for ,
the highest rank for  at the time of the write was . 

Finally consider the execution  that is similar to 
 without containing . In other words 
extends  with the write operation . Observe that any 
write operation  performed by  on 
ranked register  during  observes a highest rank  
as in . So if such a write committed (or aborted) in  
will also commit (or abort) in  as well. Therefore,
since  revised the value of the coverable register in  
will revise the value of the coverable register in  
as well. \nn{However, the last proceeding write operation is of the 
form  for . 
Thus  violates the \emph{continuity} property and hence contradicts our 
initial assumption.}\hfill\vspace{1em}


\remove{
\noindent{\bf Direction 2:}
Here we need to show that if a write operation 
 on some ranked register  commits, then the write 

revises the value of the coverable register. 
Let us consider the negation of the above sentence.
In other words, if all the write operations performed 
on the ranked register during  abort, then 
does not revise the value of the register. 
Assume to derive contradiction that if all the 
write operations on the rank register abort, then 
 revises the value of the coverable register. 

We extend now  with  to obtain .
Since all the write operations 
performed during  abort it follows that 
, that performed
during , , where  the highest rank 
of register . Assume that the last state of  
is associated with version , with .

Let now extend  with another write operation 
. Since  then 
by coverability  does not revise the value 
of the coverable register. So, by our assumption 
there must exists some ranked register, say , 
such that the write operation  
commits. Note that for the highest rank on the ranked register
 when this write is executed is . 

Consider now an execution  that is similar 
to  but it does not contain . In other 
words we obtain  by extending 
 with the write operation . Notice 
that every write operation 
observes the same highest rank  as in .
Thus, if a write  committed 
in  , commits in  as well. Thus,
 cannot distinguish  from  
and hence it does not revise the value in  either. 

However  is not concurrent with any other operation 
and uses a version that is equal to the version of the last 
state in , . By coverability transitions, 
such write operation should have revised the value of 
the object and this leads us to contradiction.
}







\remove{
\begin{proof}[Proof of Lemma \ref{lem:rrabort}]
We will assume to derive contradiction that  does not write on any 
ranked register that  wrote (and committed) during . 
More formally, let  be the set of ranked registers
s.t. for all ,  for some rank 
 during .  Let  be the set of ranked registers 
s.t. for all ,  invokes  
during . Note that since  does not change the version 
of the object, then according to Lemma \ref{lem:commit}, 
no ranked register commits during  and hence  contains
all the ranked registers that  tried to write to.  
According to our assumption . 

Let us construct an execution that contain the two operations  and .
Consider an execution fragment  that ends with a state associated with a version . 
Let us assume that there exists an algorithm that uses  ranked registers 
each with a highest rank  respectively at the end of . 
We extend  with operation  and obtain . Since  
changes the version of the object, according to Lemma \ref{lem:commit},
there exists a ranked register  such that, 
 during . 

Next we extend  by  and obtain . 
Notice that  does not change the value of the coverable 
register and thus, by Lemma \ref{lem:commit}, for all the ranked 
registers , . Since 
according to our assumption, , then it 
must be the case that the highest rank observed by  in any
 is , i.e. the highest rank of  at the end of .
That includes also the ranked registers that   tried to modify and 
aborted during .

Consider now the execution  which is obtained 
by extending  with . Notice that since 
does not communicate with  then it communicates with 
the same set  of ranked registers. Every write operation 
on the ranked registers  return the same highest
rank as in . So  cannot distinguish  
from  and thus returns the same version of the object. 
However, this violates the validity condition of
weak coverability since  returns a version  
that is not yet reached by the object. Thus, this contradicts 
our assumption and the lemma follows. 
\end{proof}
}




\noindent {\bf Proof of Lemma \ref{lem:rrcommon}.}
We will assume to derive contradiction that  does not write on any 
ranked register that  wrote (and committed) during . 
More formally, let  be the set of ranked registers
s.t. for all ,  for some rank 
 during .  Let  be the set of ranked registers 
s.t. for all ,  invokes  
during . Note that since  
revises the version of the object, 
then according to Lemma \ref{lem:commit}, .  
According to our assumption . 


Let us now construct an execution that contains the two operations  and .
Consider an execution fragment  that ends with a state associated with a version . 
Let us assume that there exists an algorithm  that uses  ranked registers 
each with a highest rank  respectively at the end of . 
We extend  with operation  and obtain . Since  
changes the version of the object, by Lemma \ref{lem:commit},
there exists a ranked register  such that,  invokes an operation that commits on , 
, during . 

Next we extend  by  and obtain . 
Since according to our assumption, , then it 
must be the case that the highest rank observed by  in any
 is , i.e. the highest rank of  at the end of .
So it returns either  or  the rank used by .
That includes also the ranked registers that   tried to modify and 
aborted during . 



Consider now the execution  which is similar to ,
without operation . In particular,  is obtained 
by extending  with . Notice that since 
does not communicate with , then  appears in the 
same state in both  and  before invoking . 
Thus,  attempts to write on  
the same set of ranked registers  in both executions. 
Since  is extended by  alone, then any write operation 
on the ranked registers  is  (as in ). 
So  cannot distinguish  
from  and thus revises  in  as well. 
However,  does not contain a  operation, therefore  violates the \emph{continuity}
property of weak coverability. 
This contradicts our assumption. 
\hfill\vspace{1em}





\noindent {\bf Proof of Lemma \ref{lem:rrorder}.}
	Consider again an execution fragment  that ends with a state associated with a version . 
	Let us assume that there exists an algorithm  that uses a set  of ranked registers 
	each with a highest rank  respectively at the end of . 
	We know by Lemma \ref{lem:commit}, that each operation  that changes 
	the version of the weakly coverable register performs a write 
	that commits on at least a single ranked register in . 


We extend  with the following non-concurrent operations (listed in the order they take place) 
	to obtain execution :
	\begin{itemize}
		\item operation 
		\item operation 
\end{itemize}

By Lemma \ref{lem:rrcommon}, .
Assume to derive contradiction that , 
	performs a committed write with a rank  and  performs a write 
	with a rank   (that may commit or not). 
Since according to our assumption, 
	, the rank of  has to be smaller than 
	the rank used by , we assume w.l.o.g. that  uses the same 
	rank  for all the ranked writes. 

	
By the order of operations in  it follows that for all , 
	 appears before 
	in . Moreover, observe that, by Definition \ref{def:rr}, for each register ,
	 since the write from  aborted. 
Since  changes 
	the version of the weakly coverable register, then by Lemma \ref{lem:commit}, . 
Notice that, even though we assume that , 
	the operations in  may commit
	without violating the ranked register properties of Definition \ref{def:rr} (as a write operation
	with a smaller rank does not have to abort). In order to preserve 
	weak coverability,  changes the version  to . 


	Consider now the execution  that contains the same 
	operations but with  and  in reverse order. 
	In particular  extends  with operations:
	\begin{itemize}
		\item operation 
		\item operation 
\end{itemize}  
Since there is no communication assumed between the processes then  uses 
rank  in  as well. It is easy to see that for any register ,
 observes the same highest rank  in both executions  and .
So if the rank write of  on those registers commits in  then it also commits in .
So the only registers that may allow  to differentiate between the two executions are the 
ones in the intersection . There are two cases to consider: (i) ,
, and (ii) , and . 


\case{(i)} In case (i),  witnesses
a higher rank from all the registers in  as in . So for each register ,
if  committed in  then the write commits in  as well.
Thus,  will not be able to distinguish the two operations and it extends  in 
 as well. However,  is not written in , thus  violates \emph{continuity}
property and contradicts our assumption. 

\case{(ii)} So it remains to examine the second case were , and .
In this case  has to commit in . If the same operation committed 
in  as well then  cannot distinguish the two executions and thus violates coverability as shown before. 
Let us assume that  did not commit in . Hence,  distinguishes  from .
To preserve weak coverability,  has to extend version  to a version . At the end 
of  the highest rank of . When  is invoked it performs rank writes using rank 
, since there is no communication between the processes. Since, according to our assumption 
, it follows that  commits in 
both  and . Moreover, since for all the rest registers , ,  
 will witness the same highest rank  from each of those registers, in both executions. Thus, 
all the write operations on those registers  will commit on all those registers, and thus,  
will not be able to distinguish  from . Since, however ,it extended  in ,
then it extends  in  as well. However, as ,  
then by consolidation,  needs to extend a version larger or equal to . Since  
then consolidation is violated.  And this completes the proof.
\hfill 
\remove{	
	In  there are three cases to consider for any ranked register 
	: 
	(i)  was written during  and , (ii)  was written during 
	 and , or (iii)  was written during all three operations. 
	Let us examine a write operation 	 on some ranked 
	register . If  falls in Case (i) then  observes either 
	 or  whichever is higher. If  falls in Case (ii) then it observes either  or 
	. Since however n case (ii)  was written only by  and .
	Thus, , and thus according to our assumption . 
	So  is not changed according to Definition \ref{def:rr} during ,
	and  observes  in this case. Finally if  was written by all operations,
	then since ,  observes either  or . So  
	does not observe  in any case. 
	


	Since,  does not communicate with any other process in either  or , 
	then it should attempt to write to the same set of ranked registers  in  as well, 
	using the same ranks as in . Notice that the commits of  are the ones that 
	differentiate  from . Since, however  did not observe  in  then 
	it will not observe  in  either for any .  
Thus, will not be able to distinguish the two 
 	executions. Since,  changes version  to  in  it will do so
 	in  as well. However  was not introduced in  violating 
 	this way the validity condition of coverability. Thus,  has to commit to at least 
 	a single register with a higher rank than .
 	


}
