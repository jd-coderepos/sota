\documentclass{llncs}

\usepackage{tikz} \usepackage{multirow} \usepackage{graphicx} 

\usepackage{booktabs}
\usepackage{siunitx}


\usepackage[colorinlistoftodos]{todonotes}

\usepackage{subfig}

\begin{document}

\title{Evaluating surgical skills from kinematic data using convolutional neural networks}
\titlerunning{CNN on JIGSAWS}  \author{Hassan Ismail Fawaz, 
Germain Forestier, 
Jonathan Weber, \\
Lhassane Idoumghar \and
Pierre-Alain Muller
}

\authorrunning{Ismail Fawaz et al.} 

\institute{
IRIMAS, Universit\'{e} de Haute-Alsace,
68100 Mulhouse, France\\
\email{\{first-name\}.\{last-name\}@uha.fr}
}

\maketitle              

\begin{abstract}
The need for automatic surgical skills assessment is increasing, especially because manual feedback from senior surgeons observing junior surgeons is prone to subjectivity and time consuming. 
Thus, automating surgical skills evaluation is a very important step towards improving surgical practice. 
In this paper, we designed a Convolutional Neural Network (CNN) to evaluate surgeon skills by extracting patterns in the surgeon motions performed in robotic surgery. 
The proposed method is validated on the JIGSAWS dataset and achieved very competitive results with 100\% accuracy on the suturing and needle passing tasks. 
While we leveraged from the CNNâ€™s efficiency, we also managed to mitigate its black-box effect using class activation map. 
This feature allows our method to automatically highlight which parts of the surgical task influenced the skill prediction and can be used to explain the classification and to provide personalized feedback to the trainee.

\keywords{kinematic data, RMIS, deep learning, CNN}
\end{abstract}

\section{Introduction}

Over the past one hundred years, the classical training program of Dr. William Halsted has governed surgical training in different parts of the world~\cite{polavarapu2013100}.
His teaching philosophy of ``see one, do one, teach one'' is still one of the most practiced methods to this day~\cite{ahmidi2017a}.
The idea is that the trainee could become an expert surgeon by watching and assisting in mentored surgeries~\cite{polavarapu2013100}.
These training methods, although broadly used, lack of an objective surgical skill evaluation technique~\cite{kassahun2016surgical}. 
Conventional surgical skill assessment is currently based on checklists that are filled by an expert surgeon observing the surgery~\cite{tedesco2008simulation}.
In an attempt to evaluate surgical skills without relying on an expert's opinion, Objective Structured Assessment of Technical Skills (OSATS) has been proposed and is used in clinical practice~\cite{niitsu2013using}.
Unfortunately, this type of observational evaluation is still prone to several external and subjective variables: the checklists' development process, the inter-rater reliability and the evaluator bias~\cite{hatala2015constructing}. 

Other studies showed that a strong relationship exists between the postoperative outcomes and the technical skill of a surgeon~\cite{bridgewater2003surgeon}. 
This type of approach suffers from the fact that a surgery's outcome also depends on the patient's physiological characteristics~\cite{kassahun2016surgical}. 
In addition, acquiring such type of data is very difficult, which makes these skill evaluation methods difficult to apply for surgical training.
Recent advances in surgical robotics such as the \emph{da Vinci} surgical robot (Intuitive Surgical Inc. Sunnyvale, CA) enabled the collection of motion and video data from different surgical activities.
Hence, an alternative for checklists and outcome-based methods is to extract, from these motion data, global movement features such as the surgical task's time completion, speed, curvature, motion smoothness and other holistic features~\cite{fard2018automated,zia2017automated,kassahun2016surgical}. 
Although most of these methods are efficient, it is not clear how they could be used to provide a detailed and constructive feedback for the trainee to go beyond the simple classification into a category (i.e. novice, expert, etc.). 
This is problematic as studies \cite{islam2016affordable} showed that feedback on medical practice allows surgeons to improve their performance and reach higher skill levels.


Recently, a new field named \emph{Surgical Data Science}~\cite{maier-hein2017surgical} has emerged thanks to the increasing access to large amounts of complex data which pertain to the patient, the staff and sensors for perceiving the patient and procedure related data such as videos and kinematic variables~\cite{gao2014jhu}.
As an alternative to extracting global movement features, recent studies tend to break down surgical tasks into smaller segments called surgical gestures, manually before the training phase, and assess the performance of the surgical task based on the assessment of these gestures~\cite{lingling2012sparse}. 
Although these methods obtained very accurate and promising results in terms of surgical skill evaluation, they require a huge amount of labeled gestures for the training phase~\cite{lingling2012sparse}.
We have identified two main limits in the existing approaches that classify a surgeon's skill level based on the kinematic data.
First is the lack of an interpretable result of skill evaluation usable by the trainee to achieve higher skill levels.
Additionally current state of the art Hidden Markov Models require gesture boundaries that are pre-defined by human annotators which is time consuming and prone to inter-annotator reliability~\cite{vedula2016analysis}. 

\usetikzlibrary{quotes,arrows.meta,positioning,decorations.pathreplacing,calc,3d,arrows}
\newcommand\XS{0.4}
\newcommand\YS{0.5}
\newcommand\ZS{0.5}
\newcommand\layeroneonecoord{1.5,0,0*\ZS}
\newcommand\layeronetwocoord{1.5,0,-\ZS*10.0}
\newcommand\layeronethreecoord{1.5,0,-\ZS*12.0}
\newcommand\layeronefourcoord{1.5,0,-\ZS*14.0}

\newcommand\layertwoonecoord{3.35,0,-3}

\newcommand\layerthreeonecoord{5.2,0,-2}

\newcommand\layerfouronecoord{6.9,0,-1}

\newcommand\inputeightcoord{-0.1,0,-9.2}\newcommand\inputsevencoord{-0.1,0,-8.2}\newcommand\inputsixcoord{-0.1,0,-7.2}\newcommand\inputfivecoord{-0.1,0,-4.9}\newcommand\inputfourcoord{-0.1,0,-4}\newcommand\inputthreecoord{-0.1,0,-2.6}\newcommand\inputtwocoord{-0.1,0,-0.7}\newcommand\inputonecoord{0.15,0,+2.05}

\newcommand\novicecoord{8.0,0,2}
\newcommand\intermediatecoord{8.0,0,0}
\newcommand\expertcoord{8.0,0,-2}

\definecolor{light-gray}{gray}{0.5}
\begin{figure}
	\centering
	\begin{tikzpicture}
	\begin{scope}[rotate around y=-7,rotate around x=-5,rotate around z=0] 

\node at (-3.75,0.4,-3) (repere){
		\begin{tikzpicture}[scale=1.5,overlay]
		\draw (0,0,0) +(0.0,0pt,0pt) coordinate (x) edge [color=black,style={->}] +(0.0,0.5pt,0pt) coordinate (x1);
		\node at (0,0.3,0) [left](){\scriptsize \textsf{1}};
		\draw (0,0,0) +(0.0,0pt,0pt) coordinate (x) edge [color=black,style={->}] +(0.7,0.0pt,0pt) coordinate (x1);
		\node at (0.5,0,0)[below] (){\scriptsize \textsf{time}};
		\draw (0,0,0) +(0.0,0pt,0pt) coordinate (x) edge [color=black,style={->}] +(0.0,0.0pt,-1pt) coordinate (x1);
		\begin{scope}[canvas is yz plane at x=0pt]
		\node at (0,-1)[black,right,rotate=-0] {\scriptsize \textsf{channels}};
		\end{scope}
		\end{tikzpicture}
	};
	
\begin{scope}[canvas is yz plane at x=-1.3pt]
		\draw [gray,decorate,decoration={brace,amplitude=10pt}] (0.2,1) -- (0.2,-11);
		\node [black] at (1.5,-4.0) (s1) {\textsf{76-dimensional}};
		\node [below=-0.2 of s1] (s2) {\textsf{kinematic}};
		\node [below=-0.2 of s2] (s3) {\textsf{data}};
	\end{scope}
	
\node at (\inputeightcoord) (input-8){
		\begin{tikzpicture}[every edge quotes/.append style={auto, text=black},scale =1]
		\pgfmathsetmacro{\cubex}{\XS}
		\pgfmathsetmacro{\cubey}{\YS}
		\pgfmathsetmacro{\cubez}{\ZS*1}
		\draw [draw=black, every edge/.append style={draw=black, densely dashed, opacity=0},fill=white]
		(0,0,0) coordinate (o) -- ++(-\cubex,0,0) coordinate (a) -- ++(0,-\cubey,0) coordinate (b) edge coordinate [pos=1] (g) ++(0,0,-\cubez)  -- ++(\cubex,0,0) coordinate (c) -- cycle
		(o) -- ++(0,0,-\cubez) coordinate (d) -- ++(0,-\cubey,0) coordinate (e) edge (g) -- (c) -- cycle
		(o) -- (a) -- ++(0,0,-\cubez) coordinate (f) edge (g) -- (d) -- cycle;	
		
		\begin{scope}[canvas is yz plane at x=0pt]
		\node[black,style={transform shape},rotate=-90] at (-\cubey/2,-\cubez/2) {\tiny \textsf{\textbf{SR}}};
		\end{scope}
		
		\draw (c) +(-\cubex/3,0pt,0pt) coordinate (x) edge [color=blue] +(-\cubex/3,0.5pt,0pt) coordinate (x1);
		\draw (c) +(-\cubex/9*4,0pt,0pt) coordinate (x) edge [color=blue] +(-\cubex/9*4,0.5pt,0pt) coordinate (x1);
		\draw (c) +(-\cubex/9*5,0pt,0pt) coordinate (x) edge [color=blue] +(-\cubex/9*5,0.5pt,0pt) coordinate (x1);
		\draw (c) +(-\cubex/3*2,0pt,0pt) coordinate (x) edge [color=blue] +(-\cubex/3*2,0.5pt,0pt) coordinate (x1);
		
		\draw (c) +(-\cubex/3,0.5pt,0pt) coordinate (x) edge [color=blue] + (-\cubex/3,0.5pt,-\cubez) coordinate(x1);
		\draw (c) +(-\cubex/9*4,0.5pt,0pt) coordinate (x) edge [color=blue] + (-\cubex/9*4,0.5pt,-\cubez) coordinate(x1);
		\draw (c) +(-\cubex/9*5,0.5pt,0pt,0pt) coordinate (x) edge [color=blue] + (-\cubex/9*5,0.5pt,-\cubez) coordinate(x1);
		\draw (c) +(-\cubex/3*2,0.5pt,0pt,0pt) coordinate (x) edge [color=blue] + (-\cubex/3*2,0.5pt,-\cubez) coordinate(x1);
		
		\end{tikzpicture}};
\node at (\inputsevencoord) (input-7){
		\begin{tikzpicture}[every edge quotes/.append style={auto, text=black},scale =1]
		\pgfmathsetmacro{\cubex}{\XS}
		\pgfmathsetmacro{\cubey}{\YS}
		\pgfmathsetmacro{\cubez}{\ZS*1}
		\draw [draw=black, every edge/.append style={draw=black, densely dashed, opacity=0},fill=white]
		(0,0,0) coordinate (o) -- ++(-\cubex,0,0) coordinate (a) -- ++(0,-\cubey,0) coordinate (b) edge coordinate [pos=1] (g) ++(0,0,-\cubez)  -- ++(\cubex,0,0) coordinate (c) -- cycle
		(o) -- ++(0,0,-\cubez) coordinate (d) -- ++(0,-\cubey,0) coordinate (e) edge (g) -- (c) -- cycle
		(o) -- (a) -- ++(0,0,-\cubez) coordinate (f) edge (g) -- (d) -- cycle;	
		
		\begin{scope}[canvas is yz plane at x=0pt]
		\node[black,style={transform shape},rotate=-90] at (-\cubey/2,-\cubez/2) {\tiny \textsf{\textbf{SL}}};
		\end{scope}
		
		\draw (c) +(-\cubex/3,0pt,0pt) coordinate (x) edge [color=blue] +(-\cubex/3,0.5pt,0pt) coordinate (x1);
		\draw (c) +(-\cubex/9*4,0pt,0pt) coordinate (x) edge [color=blue] +(-\cubex/9*4,0.5pt,0pt) coordinate (x1);
		\draw (c) +(-\cubex/9*5,0pt,0pt) coordinate (x) edge [color=blue] +(-\cubex/9*5,0.5pt,0pt) coordinate (x1);
		\draw (c) +(-\cubex/3*2,0pt,0pt) coordinate (x) edge [color=blue] +(-\cubex/3*2,0.5pt,0pt) coordinate (x1);
		
		\draw (c) +(-\cubex/3,0.5pt,0pt) coordinate (x) edge [color=blue] + (-\cubex/3,0.5pt,-\cubez) coordinate(x1);
		\draw (c) +(-\cubex/9*4,0.5pt,0pt) coordinate (x) edge [color=blue] + (-\cubex/9*4,0.5pt,-\cubez) coordinate(x1);
		\draw (c) +(-\cubex/9*5,0.5pt,0pt,0pt) coordinate (x) edge [color=blue] + (-\cubex/9*5,0.5pt,-\cubez) coordinate(x1);
		\draw (c) +(-\cubex/3*2,0.5pt,0pt,0pt) coordinate (x) edge [color=blue] + (-\cubex/3*2,0.5pt,-\cubez) coordinate(x1);
		
		\end{tikzpicture}};
\node at (\inputsixcoord) (input-6){
		\begin{tikzpicture}[every edge quotes/.append style={auto, text=black},scale =1]
		\pgfmathsetmacro{\cubex}{\XS}
		\pgfmathsetmacro{\cubey}{\YS}
		\pgfmathsetmacro{\cubez}{\ZS*1}
		\draw [draw=black, every edge/.append style={draw=black, densely dashed, opacity=0},fill=white]
		(0,0,0) coordinate (o) -- ++(-\cubex,0,0) coordinate (a) -- ++(0,-\cubey,0) coordinate (b) edge coordinate [pos=1] (g) ++(0,0,-\cubez)  -- ++(\cubex,0,0) coordinate (c) -- cycle
		(o) -- ++(0,0,-\cubez) coordinate (d) -- ++(0,-\cubey,0) coordinate (e) edge (g) -- (c) -- cycle
		(o) -- (a) -- ++(0,0,-\cubez) coordinate (f) edge (g) -- (d) -- cycle;	
		
		\begin{scope}[canvas is yz plane at x=0pt]
		\node[black,style={transform shape},rotate=-90] at (-\cubey/2,-\cubez/2) {\tiny \textsf{\textbf{MR}}};
		\end{scope}
		
		\draw (c) +(-\cubex/3,0pt,0pt) coordinate (x) edge [color=blue] +(-\cubex/3,0.5pt,0pt) coordinate (x1);
		\draw (c) +(-\cubex/9*4,0pt,0pt) coordinate (x) edge [color=blue] +(-\cubex/9*4,0.5pt,0pt) coordinate (x1);
		\draw (c) +(-\cubex/9*5,0pt,0pt) coordinate (x) edge [color=blue] +(-\cubex/9*5,0.5pt,0pt) coordinate (x1);
		\draw (c) +(-\cubex/3*2,0pt,0pt) coordinate (x) edge [color=blue] +(-\cubex/3*2,0.5pt,0pt) coordinate (x1);
		
		\draw (c) +(-\cubex/3,0.5pt,0pt) coordinate (x) edge [color=blue] + (-\cubex/3,0.5pt,-\cubez) coordinate(x1);
		\draw (c) +(-\cubex/9*4,0.5pt,0pt) coordinate (x) edge [color=blue] + (-\cubex/9*4,0.5pt,-\cubez) coordinate(x1);
		\draw (c) +(-\cubex/9*5,0.5pt,0pt,0pt) coordinate (x) edge [color=blue] + (-\cubex/9*5,0.5pt,-\cubez) coordinate(x1);
		\draw (c) +(-\cubex/3*2,0.5pt,0pt,0pt) coordinate (x) edge [color=blue] + (-\cubex/3*2,0.5pt,-\cubez) coordinate(x1);
		
		\end{tikzpicture}};
	
\begin{scope}[canvas is yz plane at x=-0.5pt]
		\draw [gray,decorate,decoration={brace,amplitude=5pt}] (0.2,2) -- (0.2,-6);
		\node [style={transform shape},rotate=-90] at (0.6,-1.6) {\scriptsize \textsf{\textbf{ML}}};
\end{scope}
	
\node at (\inputfivecoord) (input-5){
		\begin{tikzpicture}[every edge quotes/.append style={auto, text=black},scale =1]
		\pgfmathsetmacro{\cubex}{\XS}
		\pgfmathsetmacro{\cubey}{\YS}
		\pgfmathsetmacro{\cubez}{\ZS}
		\draw [draw=black, every edge/.append style={draw=black, densely dashed, opacity=0},fill=white]
		(0,0,0) coordinate (o) -- ++(-\cubex,0,0) coordinate (a) -- ++(0,-\cubey,0) coordinate (b) edge coordinate [pos=1] (g) ++(0,0,-\cubez)  -- ++(\cubex,0,0) coordinate (c) -- cycle
		(o) -- ++(0,0,-\cubez) coordinate (d) -- ++(0,-\cubey,0) coordinate (e) edge (g) -- (c) -- cycle
		(o) -- (a) -- ++(0,0,-\cubez) coordinate (f) edge (g) -- (d) -- cycle;
		\begin{scope}[canvas is yz plane at x=0pt]
		\node[black,style={transform shape},rotate=-90] at (-0.25,-0.25) {};
		\end{scope}
		
		\draw (c) +(-\cubex/3,0pt,0pt) coordinate (x) edge [color=blue] +(-\cubex/3,0.5pt,0pt) coordinate (x1);
		\draw (c) +(-\cubex/9*4,0pt,0pt) coordinate (x) edge [color=blue] +(-\cubex/9*4,0.5pt,0pt) coordinate (x1);
		\draw (c) +(-\cubex/9*5,0pt,0pt) coordinate (x) edge [color=blue] +(-\cubex/9*5,0.5pt,0pt) coordinate (x1);
		\draw (c) +(-\cubex/3*2,0pt,0pt) coordinate (x) edge [color=blue] +(-\cubex/3*2,0.5pt,0pt) coordinate (x1);
		
		\draw (c) +(-\cubex/3,0.5pt,0pt) coordinate (x) edge [color=blue] + (-\cubex/3,0.5pt,-\cubez) coordinate(x1);
		\draw (c) +(-\cubex/9*4,0.5pt,0pt) coordinate (x) edge [color=blue] + (-\cubex/9*4,0.5pt,-\cubez) coordinate(x1);
		\draw (c) +(-\cubex/9*5,0.5pt,0pt,0pt) coordinate (x) edge [color=blue] + (-\cubex/9*5,0.5pt,-\cubez) coordinate(x1);
		\draw (c) +(-\cubex/3*2,0.5pt,0pt,0pt) coordinate (x) edge [color=blue] + (-\cubex/3*2,0.5pt,-\cubez) coordinate(x1);
		
		\end{tikzpicture}};
	
\node at (\inputfourcoord) (input-4){
		\begin{tikzpicture}[every edge quotes/.append style={auto, text=black},scale =1]
		\pgfmathsetmacro{\cubex}{\XS}
		\pgfmathsetmacro{\cubey}{\YS}
		\pgfmathsetmacro{\cubez}{\ZS}
		\draw [draw=black, every edge/.append style={draw=black, densely dashed, opacity=0},fill=white]
		(0,0,0) coordinate (o) -- ++(-\cubex,0,0) coordinate (a) -- ++(0,-\cubey,0) coordinate (b) edge coordinate [pos=1] (g) ++(0,0,-\cubez)  -- ++(\cubex,0,0) coordinate (c) -- cycle
		(o) -- ++(0,0,-\cubez) coordinate (d) -- ++(0,-\cubey,0) coordinate (e) edge (g) -- (c) -- cycle
		(o) -- (a) -- ++(0,0,-\cubez) coordinate (f) edge (g) -- (d) -- cycle;
		
		\draw (c) +(-\cubex/3,0.5pt,0pt) coordinate (x) edge [color=blue] + (-\cubex/3,0.5pt,-\cubez) coordinate(x1);
		\draw (c) +(-\cubex/9*4,0.5pt,0pt) coordinate (x) edge [color=blue] + (-\cubex/9*4,0.5pt,-\cubez) coordinate(x1);
		\draw (c) +(-\cubex/9*5,0.5pt,0pt,0pt) coordinate (x) edge [color=blue] + (-\cubex/9*5,0.5pt,-\cubez) coordinate(x1);
		\draw (c) +(-\cubex/3*2,0.5pt,0pt,0pt) coordinate (x) edge [color=blue] + (-\cubex/3*2,0.5pt,-\cubez) coordinate(x1);
		
		\draw (c) +(-\cubex/3,0pt,0pt) coordinate (x) edge [color=blue] +(-\cubex/3,0.5pt,0pt) coordinate (x1);
		\draw (c) +(-\cubex/9*4,0pt,0pt) coordinate (x) edge [color=blue] +(-\cubex/9*4,0.5pt,0pt) coordinate (x1);
		\draw (c) +(-\cubex/9*5,0pt,0pt) coordinate (x) edge [color=blue] +(-\cubex/9*5,0.5pt,0pt) coordinate (x1);
		\draw (c) +(-\cubex/3*2,0pt,0pt) coordinate (x) edge [color=blue] +(-\cubex/3*2,0.5pt,0pt) coordinate (x1);
		
		\begin{scope}[canvas is yz plane at x=0pt]
		\node[black,style={transform shape},rotate=-90] at (-\cubey/2,-\cubez/2) {R};
		\end{scope}
		\end{tikzpicture}};
	
\node at (\inputthreecoord) (input-3){
		\begin{tikzpicture}[every edge quotes/.append style={auto, text=black},scale =1]
		\pgfmathsetmacro{\cubex}{\XS}
		\pgfmathsetmacro{\cubey}{\YS}
		\pgfmathsetmacro{\cubez}{\ZS*3}
		\draw [draw=black, every edge/.append style={draw=black, densely dashed, opacity=0},fill=white]
		(0,0,0) coordinate (o) -- ++(-\cubex,0,0) coordinate (a) -- ++(0,-\cubey,0) coordinate (b) edge coordinate [pos=1] (g) ++(0,0,-\cubez)  -- ++(\cubex,0,0) coordinate (c) -- cycle
		(o) -- ++(0,0,-\cubez) coordinate (d) -- ++(0,-\cubey,0) coordinate (e) edge (g) -- (c) -- cycle
		(o) -- (a) -- ++(0,0,-\cubez) coordinate (f) edge (g) -- (d) -- cycle;
		
		\begin{scope}[canvas is yz plane at x=0pt]
		\node[black,style={transform shape},rotate=-90] at (-0.25,-0.25) {};
		\end{scope}
		
		\draw (c) +(0pt,0pt,-0.5) coordinate (x) edge [color=black]  +(0,0.5pt,-0.5pt) coordinate (x1);
		
		\begin{scope}[canvas is yz plane at x=0pt]
		\node[black,style={transform shape},rotate=-90] at (-0.25,-0.75) {};
		\end{scope}
		
		\draw (c) +(0pt,0pt,-1) coordinate (x) edge [color=black]  +(0,0.5pt,-1pt) coordinate (x1);
		
		\draw (c) +(-\cubex/3,0.5pt,0pt) coordinate (x) edge [color=blue] + (-\cubex/3,0.5pt,-\cubez) coordinate(x1);
		\draw (c) +(-\cubex/9*4,0.5pt,0pt) coordinate (x) edge [color=blue] + (-\cubex/9*4,0.5pt,-\cubez) coordinate(x1);
		\draw (c) +(-\cubex/9*5,0.5pt,0pt,0pt) coordinate (x) edge [color=blue] + (-\cubex/9*5,0.5pt,-\cubez) coordinate(x1);
		\draw (c) +(-\cubex/3*2,0.5pt,0pt,0pt) coordinate (x) edge [color=blue] + (-\cubex/3*2,0.5pt,-\cubez) coordinate(x1);
		
		\draw (c) +(-\cubex/3,0pt,0pt) coordinate (x) edge [color=blue] +(-\cubex/3,0.5pt,0pt) coordinate (x1);
		\draw (c) +(-\cubex/9*4,0pt,0pt) coordinate (x) edge [color=blue] +(-\cubex/9*4,0.5pt,0pt) coordinate (x1);
		\draw (c) +(-\cubex/9*5,0pt,0pt) coordinate (x) edge [color=blue] +(-\cubex/9*5,0.5pt,0pt) coordinate (x1);
		\draw (c) +(-\cubex/3*2,0pt,0pt) coordinate (x) edge [color=blue] +(-\cubex/3*2,0.5pt,0pt) coordinate (x1);
		
		\begin{scope}[canvas is yz plane at x=0pt]
		\node[black,style={transform shape},rotate=-90] at (-0.25,-1.25) {};
		\end{scope}
		\end{tikzpicture}};
	
\node at (\inputtwocoord) (input-2){
		\begin{tikzpicture}[every edge quotes/.append style={auto, text=black},scale =1]
		\pgfmathsetmacro{\cubex}{\XS}
		\pgfmathsetmacro{\cubey}{\YS}
		\pgfmathsetmacro{\cubez}{\ZS*3}
		\draw [draw=black, every edge/.append style={draw=black, densely dashed, opacity=.0},fill=white]
		(0,0,0) coordinate (o) -- ++(-\cubex,0,0) coordinate (a) -- ++(0,-\cubey,0) coordinate (b) edge coordinate [pos=1] (g) ++(0,0,-\cubez)  -- ++(\cubex,0,0) coordinate (c) -- cycle
		(o) -- ++(0,0,-\cubez) coordinate (d) -- ++(0,-\cubey,0) coordinate (e) edge (g) -- (c) -- cycle
		(o) -- (a) -- ++(0,0,-\cubez) coordinate (f) edge (g) -- (d) -- cycle;
		
		\begin{scope}[canvas is yz plane at x=0pt]
		\node[black,style={transform shape},rotate=-90] at (-0.25,-0.25) {};
		\end{scope}
		
		\draw (c) +(0pt,0pt,-0.5) coordinate (x) edge [color=black]  +(0,0.5pt,-0.5pt) coordinate (x1);
		
		\begin{scope}[canvas is yz plane at x=0pt]
		\node[black,style={transform shape},rotate=-90] at (-0.25,-0.75) {};
		\end{scope}
		
		\draw (c) +(0pt,0pt,-1) coordinate (x) edge [color=black]  +(0,0.5pt,-1pt) coordinate (x1);
		
		\draw (c) +(-\cubex/3,0.5pt,0pt) coordinate (x) edge [color=blue] + (-\cubex/3,0.5pt,-\cubez) coordinate(x1);
		\draw (c) +(-\cubex/9*4,0.5pt,0pt) coordinate (x) edge [color=blue] + (-\cubex/9*4,0.5pt,-\cubez) coordinate(x1);
		\draw (c) +(-\cubex/9*5,0.5pt,0pt,0pt) coordinate (x) edge [color=blue] + (-\cubex/9*5,0.5pt,-\cubez) coordinate(x1);
		\draw (c) +(-\cubex/3*2,0.5pt,0pt,0pt) coordinate (x) edge [color=blue] + (-\cubex/3*2,0.5pt,-\cubez) coordinate(x1);
		
		\draw (c) +(-\cubex/3,0pt,0pt) coordinate (x) edge [color=blue] +(-\cubex/3,0.5pt,0pt) coordinate (x1);
		\draw (c) +(-\cubex/9*4,0pt,0pt) coordinate (x) edge [color=blue] +(-\cubex/9*4,0.5pt,0pt) coordinate (x1);
		\draw (c) +(-\cubex/9*5,0pt,0pt) coordinate (x) edge [color=blue] +(-\cubex/9*5,0.5pt,0pt) coordinate (x1);
		\draw (c) +(-\cubex/3*2,0pt,0pt) coordinate (x) edge [color=blue] +(-\cubex/3*2,0.5pt,0pt) coordinate (x1);
		
		\begin{scope}[canvas is yz plane at x=0pt]
		\node[black,style={transform shape},rotate=-90] at (-0.25,-1.25) {};
		\end{scope}
		\end{tikzpicture}};
	
\node at (\inputonecoord) (input-1){
		\begin{tikzpicture}[every edge quotes/.append style={auto, text=black},scale =1]
		\pgfmathsetmacro{\cubex}{\XS}
		\pgfmathsetmacro{\cubey}{\YS}
		\pgfmathsetmacro{\cubez}{\ZS*3}
		\draw [draw=black, every edge/.append style={draw=black, densely dashed, opacity=0},fill=white]
		(0,0,0) coordinate (o) -- ++(-\cubex,0,0) coordinate (a) -- ++(0,-\cubey,0) coordinate (b) edge coordinate [pos=1] (g) ++(0,0,-\cubez)  -- ++(\cubex,0,0) coordinate (c) -- cycle
		(o) -- ++(0,0,-\cubez) coordinate (d) -- ++(0,-\cubey,0) coordinate (e) edge (g) -- (c) -- cycle
		(o) -- (a) -- ++(0,0,-\cubez) coordinate (f) edge (g) -- (d) -- cycle;
		
		\draw (b) + (0,-0.1pt,0) coordinate (b1) edge ["\scriptsize "',style={<->}] +(\cubex,-0.1,0) coordinate (b11);
		
		
		\draw (b) +(-0.1,0,0) coordinate (b2) edge ["\scriptsize 1", style={<->}] +(-0.1,\cubey,0) coordinate (b22);
		
		\begin{scope}[canvas is yz plane at x=0pt]
		\node[black,style={transform shape},rotate=-90] at (-0.25,-0.25) {};
		\end{scope}
		
		\draw (c) +(0pt,0pt,-0.5) coordinate (x) edge [color=black]  +(0,0.5pt,-0.5pt) coordinate (x1);
		
		\begin{scope}[canvas is yz plane at x=0pt]
		\node[black,style={transform shape},rotate=-90] at (-0.25,-0.75) {};
		\end{scope}
		
		\draw (c) +(0pt,0pt,-1) coordinate (x) edge [color=black]  +(0,0.5pt,-1pt) coordinate (x1);
		
		\draw (c) +(-\cubex/3,0pt,0pt) coordinate (x) edge [color=blue] +(-\cubex/3,0.5pt,0pt) coordinate (x1);
		\draw (c) +(-\cubex/9*4,0pt,0pt) coordinate (x) edge [color=blue] +(-\cubex/9*4,0.5pt,0pt) coordinate (x1);
		\draw (c) +(-\cubex/9*5,0pt,0pt) coordinate (x) edge [color=blue] +(-\cubex/9*5,0.5pt,0pt) coordinate (x1);
		\draw (c) +(-\cubex/3*2,0pt,0pt) coordinate (x) edge [color=blue] +(-\cubex/3*2,0.5pt,0pt) coordinate (x1);
		
		\begin{scope}[canvas is yz plane at x=0pt]
		\node[black,style={transform shape},rotate=-90] at (-0.25,-1.25) {};
		\end{scope}
		
		\draw (c) +(-\cubex/3,0.5pt,0pt) coordinate (x) edge [color=blue] + (-\cubex/3,0.5pt,-\cubez) coordinate(x1);
		\draw (c) +(-\cubex/9*4,0.5pt,0pt) coordinate (x) edge [color=blue] + (-\cubex/9*4,0.5pt,-\cubez) coordinate(x1);
		\draw (c) +(-\cubex/9*5,0.5pt,0pt,0pt) coordinate (x) edge [color=blue] + (-\cubex/9*5,0.5pt,-\cubez) coordinate(x1);
		\draw (c) +(-\cubex/3*2,0.5pt,0pt,0pt) coordinate (x) edge [color=blue] + (-\cubex/3*2,0.5pt,-\cubez) coordinate(x1);
		
		\end{tikzpicture}
	};
	
\draw () coordinate (x) edge [color=blue]  	() coordinate(x1);
	\draw () coordinate (x) edge [color=blue]  	() coordinate(x1);
\draw () coordinate (x) edge [color=blue]  	() coordinate(x1);
	\draw () coordinate (x) edge [color=blue]  	() coordinate(x1);
\draw () coordinate (x) edge [color=blue]  	() coordinate(x1);
	\draw () coordinate (x) edge [color=blue]  	() coordinate(x1);
\draw () coordinate (x) edge [color=blue]  	() coordinate(x1);
	\draw () coordinate (x) edge [color=blue]  	() coordinate(x1);
\draw () coordinate (x) edge [color=blue] 	() coordinate(x1);
	\draw () coordinate (x) edge [color=blue]  	() coordinate(x1);
\draw () coordinate (x) edge [color=blue] 	() coordinate(x1);
	\draw () coordinate (x) edge [color=blue]  	() coordinate(x1);
\draw () coordinate (x) edge [color=blue] 	() coordinate(x1);
	\draw () coordinate (x) edge [color=blue]  	() coordinate(x1);
	
\node at (\layeronefourcoord) (layer1-4){
		\begin{tikzpicture}[every edge quotes/.append style={auto, text=black},scale =1]
		\pgfmathsetmacro{\cubex}{\XS}
		\pgfmathsetmacro{\cubey}{\YS}
		\pgfmathsetmacro{\cubez}{\ZS*1}
		\draw [draw=black, every edge/.append style={draw=black, densely dashed, opacity=0},fill=white]
		(0,0,0) coordinate (o) -- ++(-\cubex,0,0) coordinate (a) -- ++(0,-\cubey,0) coordinate (b) edge coordinate [pos=1] (g) ++(0,0,-\cubez)  -- ++(\cubex,0,0) coordinate (c) -- cycle
		(o) -- ++(0,0,-\cubez) coordinate (d) -- ++(0,-\cubey,0) coordinate (e) edge (g) -- (c) -- cycle
		(o) -- (a) -- ++(0,0,-\cubez) coordinate (f) edge (g) -- (d) -- cycle;	
		
		\begin{scope}[canvas is yz plane at x=0pt]
		\node[black,style={transform shape},rotate=-90] at (-\cubey/2,-\cubez/2) {\tiny \textsf{\textbf{SR}}};
		\end{scope}
		
		\draw (c) +(-\cubex/3,0pt,0pt) coordinate (x) edge [color=blue] +(-\cubex/3,0.5pt,0pt) coordinate (x1);
		\draw (c) +(-\cubex/9*4,0pt,0pt) coordinate (x) edge [color=blue] +(-\cubex/9*4,0.5pt,0pt) coordinate (x1);
		\draw (c) +(-\cubex/9*5,0pt,0pt) coordinate (x) edge [color=blue] +(-\cubex/9*5,0.5pt,0pt) coordinate (x1);
		\draw (c) +(-\cubex/3*2,0pt,0pt) coordinate (x) edge [color=blue] +(-\cubex/3*2,0.5pt,0pt) coordinate (x1);
		
		\draw (c) +(-\cubex/3,0.5pt,0pt) coordinate (x) edge [color=blue] + (-\cubex/3,0.5pt,-\cubez) coordinate(x1);
		\draw (c) +(-\cubex/9*4,0.5pt,0pt) coordinate (x) edge [color=blue] + (-\cubex/9*4,0.5pt,-\cubez) coordinate(x1);
		\draw (c) +(-\cubex/9*5,0.5pt,0pt,0pt) coordinate (x) edge [color=blue] + (-\cubex/9*5,0.5pt,-\cubez) coordinate(x1);
		\draw (c) +(-\cubex/3*2,0.5pt,0pt,0pt) coordinate (x) edge [color=blue] + (-\cubex/3*2,0.5pt,-\cubez) coordinate(x1);
		
		\end{tikzpicture}};
	
	\node at (\layeronethreecoord) (layer1-3){
		\begin{tikzpicture}[every edge quotes/.append style={auto, text=black},scale =1]
		\pgfmathsetmacro{\cubex}{\XS}
		\pgfmathsetmacro{\cubey}{\YS}
		\pgfmathsetmacro{\cubez}{\ZS*1}
		\draw [draw=black, every edge/.append style={draw=black, densely dashed, opacity=0},fill=white]
		(0,0,0) coordinate (o) -- ++(-\cubex,0,0) coordinate (a) -- ++(0,-\cubey,0) coordinate (b) edge coordinate [pos=1] (g) ++(0,0,-\cubez)  -- ++(\cubex,0,0) coordinate (c) -- cycle
		(o) -- ++(0,0,-\cubez) coordinate (d) -- ++(0,-\cubey,0) coordinate (e) edge (g) -- (c) -- cycle
		(o) -- (a) -- ++(0,0,-\cubez) coordinate (f) edge (g) -- (d) -- cycle;	
		
		\begin{scope}[canvas is yz plane at x=0pt]
		\node[black,style={transform shape},rotate=-90] at (-\cubey/2,-\cubez/2) {\tiny \textsf{\textbf{SL}}};
		\end{scope}
		
		\draw (c) +(-\cubex/3,0pt,0pt) coordinate (x) edge [color=blue] +(-\cubex/3,0.5pt,0pt) coordinate (x1);
		\draw (c) +(-\cubex/9*4,0pt,0pt) coordinate (x) edge [color=blue] +(-\cubex/9*4,0.5pt,0pt) coordinate (x1);
		\draw (c) +(-\cubex/9*5,0pt,0pt) coordinate (x) edge [color=blue] +(-\cubex/9*5,0.5pt,0pt) coordinate (x1);
		\draw (c) +(-\cubex/3*2,0pt,0pt) coordinate (x) edge [color=blue] +(-\cubex/3*2,0.5pt,0pt) coordinate (x1);
		
		\draw (c) +(-\cubex/3,0.5pt,0pt) coordinate (x) edge [color=blue] + (-\cubex/3,0.5pt,-\cubez) coordinate(x1);
		\draw (c) +(-\cubex/9*4,0.5pt,0pt) coordinate (x) edge [color=blue] + (-\cubex/9*4,0.5pt,-\cubez) coordinate(x1);
		\draw (c) +(-\cubex/9*5,0.5pt,0pt,0pt) coordinate (x) edge [color=blue] + (-\cubex/9*5,0.5pt,-\cubez) coordinate(x1);
		\draw (c) +(-\cubex/3*2,0.5pt,0pt,0pt) coordinate (x) edge [color=blue] + (-\cubex/3*2,0.5pt,-\cubez) coordinate(x1);
		
		\end{tikzpicture}};
	\node at (\layeronetwocoord) (layer1-2){
		\begin{tikzpicture}[every edge quotes/.append style={auto, text=black},scale =1]
		\pgfmathsetmacro{\cubex}{\XS}
		\pgfmathsetmacro{\cubey}{\YS}
		\pgfmathsetmacro{\cubez}{\ZS*1}
		\draw [draw=black, every edge/.append style={draw=black, densely dashed, opacity=0},fill=white]
		(0,0,0) coordinate (o) -- ++(-\cubex,0,0) coordinate (a) -- ++(0,-\cubey,0) coordinate (b) edge coordinate [pos=1] (g) ++(0,0,-\cubez)  -- ++(\cubex,0,0) coordinate (c) -- cycle
		(o) -- ++(0,0,-\cubez) coordinate (d) -- ++(0,-\cubey,0) coordinate (e) edge (g) -- (c) -- cycle
		(o) -- (a) -- ++(0,0,-\cubez) coordinate (f) edge (g) -- (d) -- cycle;	
		
		\begin{scope}[canvas is yz plane at x=0pt]
		\node[black,style={transform shape},rotate=-90] at (-\cubey/2,-\cubez/2) {\tiny \textsf{\textbf{MR}}};
		\end{scope}
		
		\draw (c) +(-\cubex/3,0pt,0pt) coordinate (x) edge [color=blue] +(-\cubex/3,0.5pt,0pt) coordinate (x1);
		\draw (c) +(-\cubex/9*4,0pt,0pt) coordinate (x) edge [color=blue] +(-\cubex/9*4,0.5pt,0pt) coordinate (x1);
		\draw (c) +(-\cubex/9*5,0pt,0pt) coordinate (x) edge [color=blue] +(-\cubex/9*5,0.5pt,0pt) coordinate (x1);
		\draw (c) +(-\cubex/3*2,0pt,0pt) coordinate (x) edge [color=blue] +(-\cubex/3*2,0.5pt,0pt) coordinate (x1);
		
		\draw (c) +(-\cubex/3,0.5pt,0pt) coordinate (x) edge [color=blue] + (-\cubex/3,0.5pt,-\cubez) coordinate(x1);
		\draw (c) +(-\cubex/9*4,0.5pt,0pt) coordinate (x) edge [color=blue] + (-\cubex/9*4,0.5pt,-\cubez) coordinate(x1);
		\draw (c) +(-\cubex/9*5,0.5pt,0pt,0pt) coordinate (x) edge [color=blue] + (-\cubex/9*5,0.5pt,-\cubez) coordinate(x1);
		\draw (c) +(-\cubex/3*2,0.5pt,0pt,0pt) coordinate (x) edge [color=blue] + (-\cubex/3*2,0.5pt,-\cubez) coordinate(x1);
		
		\end{tikzpicture}};
	
	\node at (\layeroneonecoord) (layer1-1){
		\begin{tikzpicture}[every edge quotes/.append style={auto, text=black},scale =1]
		\pgfmathsetmacro{\cubex}{\XS}
		\pgfmathsetmacro{\cubey}{\YS}
		\pgfmathsetmacro{\cubez}{\ZS*2.5*5}
		\draw [draw=black, every edge/.append style={draw=black, densely dashed, opacity=0},fill=white]
		(0,0,0) coordinate (o) -- ++(-\cubex,0,0) coordinate (a) -- ++(0,-\cubey,0) coordinate (b) edge coordinate [pos=1] (g) ++(0,0,-\cubez)  -- ++(\cubex,0,0) coordinate (c) -- cycle
		(o) -- ++(0,0,-\cubez) coordinate (d) -- ++(0,-\cubey,0) coordinate (e) edge (g) -- (c) -- cycle
		(o) -- (a) -- ++(0,0,-\cubez) coordinate (f) edge (g) -- (d) -- cycle;
		
		\draw (c) +(0,\cubey/3*2,-\cubez/5*0-0.1) coordinate (c1) edge [dashed,style= {<->}] + (0,\cubey/3*2,-\cubez/5+0.1) coordinate (c11);
		\node at () (){\tiny 8};
		\draw (c) +(0,\cubey/3*2,-\cubez/5*1-0.1) coordinate (c1) edge [dashed,style= {<->}] + (0,\cubey/3*2,-\cubez*2/5+0.1) coordinate (c11);
		\node at () (){\tiny 8};
		\draw (c) +(0,\cubey/3*2,-\cubez/5*2-0.1) coordinate (c1) edge [dashed,style= {<->}] + (0,\cubey/3*2,-\cubez*3/5+0.1) coordinate (c11);
		\node at () (){\tiny 8};
		\draw (c) +(0,\cubey/3*2,-\cubez/5*3-0.1) coordinate (c1) edge [dashed,style= {<->}] + (0,\cubey/3*2,-\cubez*4/5+0.1) coordinate (c11);
		\node at () (){\tiny 8};
		\draw (c) +(0,\cubey/3*2,-\cubez/5*4-0.1) coordinate (c1) edge [dashed,style= {<->}] + (0,\cubey/3*2,-\cubez*5/5+0.1) coordinate (c11);
		\node at () (){\tiny 8};
		
		\draw (c) +(-\cubex/3,0pt,0pt) coordinate (x) edge [color=blue] +(-\cubex/3,0.5pt,0pt) coordinate (x1);
		\draw (c) +(-\cubex/9*4,0pt,0pt) coordinate (x) edge [color=blue] +(-\cubex/9*4,0.5pt,0pt) coordinate (x1);
		\draw (c) +(-\cubex/9*5,0pt,0pt) coordinate (x) edge [color=blue] +(-\cubex/9*5,0.5pt,0pt) coordinate (x1);
		\draw (c) +(-\cubex/3*2,0pt,0pt) coordinate (x) edge [color=blue] +(-\cubex/3*2,0.5pt,0pt) coordinate (x1);
		
		\draw (c) +(-\cubex/3,0.5pt,0pt) coordinate (x) edge [color=blue] + (-\cubex/3,0.5pt,-\cubez) coordinate(x1);
		\draw (c) +(-\cubex/9*4,0.5pt,0pt) coordinate (x) edge [color=blue] + (-\cubex/9*4,0.5pt,-\cubez) coordinate(x1);
		\draw (c) +(-\cubex/9*5,0.5pt,0pt,0pt) coordinate (x) edge [color=blue] + (-\cubex/9*5,0.5pt,-\cubez) coordinate(x1);
		\draw (c) +(-\cubex/3*2,0.5pt,0pt,0pt) coordinate (x) edge [color=blue] + (-\cubex/3*2,0.5pt,-\cubez) coordinate(x1);
		
		\draw (c) +(0pt,0pt,-\cubez*1/5) coordinate (x) edge [color=black]  +(0,0.5pt,-\cubez*1/5) coordinate (x1);
		\draw (c) +(0pt,0pt,-\cubez*2/5) coordinate (x) edge [color=black]  +(0,0.5pt,-\cubez*2/5) coordinate (x1);
		\draw (c) +(0pt,0pt,-\cubez*3/5) coordinate (x) edge [color=black]  +(0,0.5pt,-\cubez*3/5) coordinate (x1);
		\draw (c) +(0pt,0pt,-\cubez*4/5) coordinate (x) edge [color=black]  +(0,0.5pt,-\cubez*4/5) coordinate (x1); 
		
		\draw (c) +(0pt,0.5pt,-\cubez*4/5) coordinate (x) edge [color=black]  +(-\cubex,0.5pt,-\cubez*4/5) coordinate (x1);
		\draw (c) +(0pt,0.5pt,-\cubez*3/5) coordinate (x) edge [color=black]  +(-\cubex,0.5pt,-\cubez*3/5) coordinate (x1);
		\draw (c) +(0pt,0.5pt,-\cubez*2/5) coordinate (x) edge [color=black]  +(-\cubex,0.5pt,-\cubez*2/5) coordinate (x1);
		\draw (c) +(0pt,0.5pt,-\cubez*1/5) coordinate (x) edge [color=black]  +(-\cubex,0.5pt,-\cubez*1/5) coordinate (x1); 
		
		\node at (0,0.4,2){
		\begin{tikzpicture}[overlay]
		\node at (1,-0.4,0.5) {\textsf{layer-1}};
		\end{tikzpicture}};
		
		\end{tikzpicture}
	};
	
\draw () coordinate (x) edge [color=blue]  	() coordinate(x1);
	\draw () coordinate (x) edge [color=blue]  () coordinate(x1);
\draw () coordinate (x) edge [color=blue] 	() coordinate(x1);
	\draw () coordinate (x) edge [color=blue]  	() coordinate(x1);
\draw () coordinate (x) edge [color=blue] 	() coordinate(x1);
	\draw () coordinate (x) edge [color=blue]  	() coordinate(x1);
\draw () coordinate (x) edge [color=blue] 	() coordinate(x1);
	\draw () coordinate (x) edge [color=blue]  	() coordinate(x1);       
	
\node at (\layertwoonecoord) (layer2-1){
		\begin{tikzpicture}[every edge quotes/.append style={auto, text=black},scale =1]
		\pgfmathsetmacro{\cubex}{\XS}
		\pgfmathsetmacro{\cubey}{\YS}
		\pgfmathsetmacro{\cubez}{\ZS*3.5*4}
		\draw [draw=black, every edge/.append style={draw=black, densely dashed, opacity=0},fill=white]
		(0,0,0) coordinate (o) -- ++(-\cubex,0,0) coordinate (a) -- ++(0,-\cubey,0) coordinate (b) edge coordinate [pos=1] (g) ++(0,0,-\cubez)  -- ++(\cubex,0,0) coordinate (c) -- cycle
		(o) -- ++(0,0,-\cubez) coordinate (d) -- ++(0,-\cubey,0) coordinate (e) edge (g) -- (c) -- cycle
		(o) -- (a) -- ++(0,0,-\cubez) coordinate (f) edge (g) -- (d) -- cycle;
		
		\draw (c) +(0.1pt,0,-\cubez*0/4-0.1) coordinate (c1) edge [dashed,style= {<->}] + (0.1pt,0,-\cubez*1/4+0.1) coordinate (c11);		
		\node at () (){\tiny 16};
		\draw (c) +(0.1pt,0,-\cubez*1/4-0.1) coordinate (c1) edge [dashed,style= {<->}] + (0.1pt,0,-\cubez*2/4+0.1) coordinate (c11);
		\node at () (){\tiny 16};
		\draw (c) +(0.1pt,0,-\cubez*2/4-0.1) coordinate (c1) edge [dashed,style= {<->}] + (0.1pt,0,-\cubez*3/4+0.1) coordinate (c11);
		\node at () (){\tiny 16};
		\draw (c) +(0.1pt,0,-\cubez*3/4-0.1) coordinate (c1) edge [dashed,style= {<->}] + (0.1pt,0,-\cubez*4/4+0.1) coordinate (c11);
		\node at () (){\tiny 16};
		
		\draw (c) +(-\cubex/3,0pt,0pt) coordinate (x) edge [color=blue] +(-\cubex/3,0.5pt,0pt) coordinate (x1);
		\draw (c) +(-\cubex/9*4,0pt,0pt) coordinate (x) edge [color=blue] +(-\cubex/9*4,0.5pt,0pt) coordinate (x1);
		\draw (c) +(-\cubex/9*5,0pt,0pt) coordinate (x) edge [color=blue] +(-\cubex/9*5,0.5pt,0pt) coordinate (x1);
		\draw (c) +(-\cubex/3*2,0pt,0pt) coordinate (x) edge [color=blue] +(-\cubex/3*2,0.5pt,0pt) coordinate (x1);
		
		\draw (c) +(-\cubex/3,0.5pt,0pt) coordinate (x) edge [color=blue] + (-\cubex/3,0.5pt,-\cubez) coordinate(x1);
		\draw (c) +(-\cubex/9*4,0.5pt,0pt) coordinate (x) edge [color=blue] + (-\cubex/9*4,0.5pt,-\cubez) coordinate(x1);
		\draw (c) +(-\cubex/9*5,0.5pt,0pt,0pt) coordinate (x) edge [color=blue] + (-\cubex/9*5,0.5pt,-\cubez) coordinate(x1);
		\draw (c) +(-\cubex/3*2,0.5pt,0pt,0pt) coordinate (x) edge [color=blue] + (-\cubex/3*2,0.5pt,-\cubez) coordinate(x1);
		
		\draw (c) +(0pt,0pt,-\cubez*1/4) coordinate (x) edge [color=black]  +(0,0.5pt,-\cubez*1/4) coordinate (x1);
		\draw (c) +(0pt,0pt,-\cubez*2/4) coordinate (x) edge [color=black]  +(0,0.5pt,-\cubez*2/4) coordinate (x1);
		\draw (c) +(0pt,0pt,-\cubez*3/4) coordinate (x) edge [color=black]  +(0,0.5pt,-\cubez*3/4) coordinate (x1);
		\draw (c) +(0pt,0pt,-\cubez*4/4) coordinate (x) edge [color=black]  +(0,0.5pt,-\cubez*4/4) coordinate (x1); 
		
		\draw (c) +(0pt,0.5pt,-\cubez*4/4) coordinate (x) edge [color=black]  +(-\cubex,0.5pt,-\cubez/4*4) coordinate (x1);
		\draw (c) +(0pt,0.5pt,-\cubez*3/4) coordinate (x) edge [color=black]  +(-\cubex,0.5pt,-\cubez/4*3) coordinate (x1);
		\draw (c) +(0pt,0.5pt,-\cubez*2/4) coordinate (x) edge [color=black]  +(-\cubex,0.5pt,-\cubez/4*2) coordinate (x1); 
		\draw (c) +(0pt,0.5pt,-\cubez*1/4) coordinate (x) edge [color=black]  +(-\cubex,0.5pt,-\cubez/4*1) coordinate (x1); 
		
		\begin{scope}[canvas is yz plane at x=0pt]
		\node[black,style={transform shape},rotate=-90] at (-\cubey/2,-\cubez/2*1/4) {\scriptsize \textsf{\textbf{ML}}};
		\end{scope}
		
		\begin{scope}[canvas is yz plane at x=0pt]
		\node[black,style={transform shape},rotate=-90] at (-\cubey/2,-\cubez/2*3/4) {\scriptsize \textsf{\textbf{MR}}};
		\end{scope}
		
		\begin{scope}[canvas is yz plane at x=0pt]
		\node[black,style={transform shape},rotate=-90] at (-\cubey/2,-\cubez/2*5/4) {\scriptsize \textsf{\textbf{SL}}};
		\end{scope}        
		
		\begin{scope}[canvas is yz plane at x=0pt]
		\node[black,style={transform shape},rotate=-90] at (-\cubey/2,-\cubez/2*7/4) {\scriptsize \textsf{\textbf{SR}}};
		\end{scope}
		
		\node at (0,0.4,2){
			\begin{tikzpicture}[overlay]
			\node at (1,-0.4,0.5) {\textsf{layer-2}};
			\end{tikzpicture}
		};
		
		\end{tikzpicture}
	};
	
\draw () coordinate (x) edge [color=blue]  	() coordinate(x1);
	\draw () coordinate (x) edge [color=blue]  	() coordinate(x1);
	
\node at (\layerthreeonecoord) (layer3-1){
		\begin{tikzpicture}[every edge quotes/.append style={auto, text=black},scale =1]
		\pgfmathsetmacro{\cubex}{\XS}
		\pgfmathsetmacro{\cubey}{\YS}
		\pgfmathsetmacro{\cubez}{\ZS*3*3}
		\draw [draw=black, every edge/.append style={draw=black, densely dashed, opacity=0},fill=white]
		(0,0,0) coordinate (o) -- ++(-\cubex,0,0) coordinate (a) -- ++(0,-\cubey,0) coordinate (b) edge coordinate [pos=1] (g) ++(0,0,-\cubez)  -- ++(\cubex,0,0) coordinate (c) -- cycle
		(o) -- ++(0,0,-\cubez) coordinate (d) -- ++(0,-\cubey,0) coordinate (e) edge (g) -- (c) -- cycle
		(o) -- (a) -- ++(0,0,-\cubez) coordinate (f) edge (g) -- (d) -- cycle;
		
		\draw (c) +(0,\cubey/3*2,-\cubez*0-0.1) coordinate (c1) edge [dashed,style= {<->}] + (0,\cubey/3*2,-\cubez*1+0.1) coordinate (c11);
		\node at () (){\tiny 32};
		
		\node at (0,0.4,2.2){
			\begin{tikzpicture}[overlay]
			\node at (1,-0.4,0.5) {\textsf{layer-3}};
			\end{tikzpicture}
		};
		
		\end{tikzpicture}};
	
\draw () coordinate (x) edge [color=blue]  	() coordinate(x1);
	\draw () coordinate (x) edge [color=blue]  	() coordinate(x1);        
	
\draw () coordinate (x) edge [color=red]  	() coordinate(x1);
	\draw () coordinate (x) edge [color=red]  	() coordinate(x1);
	\draw () coordinate (x) edge [color=red]  	() coordinate(x1);
	\draw () coordinate (x) edge [color=red]  	() coordinate(x1);
	\draw () coordinate (x) edge [color=red]  	() coordinate(x1);
	\draw () coordinate (x) edge [color=red]  	() coordinate(x1);
	\draw () coordinate (x) edge [color=red]  	() coordinate(x1);
	\draw () coordinate (x) edge [color=red]  	() coordinate(x1);
	
\node at (\layerfouronecoord) (layer4-1){
		\begin{tikzpicture}[every edge quotes/.append style={auto, text=black},scale =1]
		\pgfmathsetmacro{\cubex}{\XS*0}
		\pgfmathsetmacro{\cubey}{\YS}
		\pgfmathsetmacro{\cubez}{\ZS*3*3}
		\draw [draw=black, every edge/.append style={draw=black, densely dashed, opacity=0},fill=white]
		(0,0,0) coordinate (o) -- ++(-\cubex,0,0) coordinate (a) -- ++(0,-\cubey,0) coordinate (b) edge coordinate [pos=1] (g) ++(0,0,-\cubez)  -- ++(\cubex,0,0) coordinate (c) -- cycle
		(o) -- ++(0,0,-\cubez) coordinate (d) -- ++(0,-\cubey,0) coordinate (e) edge (g) -- (c) -- cycle
		(o) -- (a) -- ++(0,0,-\cubez) coordinate (f) edge (g) -- (d) -- cycle;
		
		\draw (c) +(0,\cubey/3*2,-\cubez*0-0.1) coordinate (c1) edge [dashed,style= {<->}] + (0,\cubey/3*2,-\cubez*1+0.1) coordinate (c11);
		\node at () (){\tiny 32};
		
		\end{tikzpicture}};
	
\draw () coordinate (x) edge [color=green]  	() coordinate(x1);
	\draw () coordinate (x) edge [color=green]  	() coordinate(x1);
	\draw () coordinate (x) edge [color=green]  	() coordinate(x1);
	
	\draw () coordinate (x) edge [color=green]  	() coordinate(x1);
	\draw () coordinate (x) edge [color=green]  	() coordinate(x1);
	\draw () coordinate (x) edge [color=green]  	() coordinate(x1);
	
	\draw () coordinate (x) edge [color=green]  	() coordinate(x1);
	\draw () coordinate (x) edge [color=green]  	() coordinate(x1);
	\draw () coordinate (x) edge [color=green]  	() coordinate(x1);
	
	\draw () coordinate (x) edge [color=green]  	() coordinate(x1);
	\draw () coordinate (x) edge [color=green]  	() coordinate(x1);
	\draw () coordinate (x) edge [color=green]  	() coordinate(x1);
	
\node at (\novicecoord) (novice){
		\begin{tikzpicture}[every edge quotes/.append style={auto, text=black},scale =1]
		\coordinate (O) at (0,0,5);
		\fill [white] (O) circle[radius = 5pt];
		\shade[ball color = gray, opacity = 0.2] (O) circle [radius = 5pt];
		\draw (O) circle [radius=5pt];
		\node at (O) {\scriptsize \textsf{N}};
		\end{tikzpicture}
	};
	\node at (\intermediatecoord) (intermediate){
		\begin{tikzpicture}[every edge quotes/.append style={auto, text=black},scale =1]
		\coordinate (O) at (0,0,5);
		\fill [white] (O) circle[radius = 5pt];
		\shade[ball color = gray, opacity = 0.2] (O) circle [radius = 5pt];
		\draw (O) circle [radius=5pt];
		\node at (O) {\scriptsize \textsf{I}};
		\end{tikzpicture}
	};
	\node at (\expertcoord) (expert){
		\begin{tikzpicture}[every edge quotes/.append style={auto, text=black},scale =1]
		\coordinate (O) at (0,0,5);
		\fill [white] (O) circle[radius = 5pt];
		\shade[ball color = gray, opacity = 0.2] (O) circle [radius = 5pt];
		\draw (O) circle [radius=5pt];
		\node at (O) {\scriptsize \textsf{E}};
		\end{tikzpicture}
	};
	
\begin{scope}[canvas is xz plane at y=0]
		\draw [gray,decorate,decoration={brace,amplitude=5pt,mirror}] (8.3,2.8) -- (8.3,-2);
	\end{scope}
	\begin{scope}[canvas is yz plane at x=9.5]
		\node [black] at (0.1,0.4) (s1) {\scriptsize \textsf{Surgical}};
		\node [below=-0.2 of s1] (s2) {\scriptsize \textsf{skill}};
		\node [below=-0.15 of s2] (s3) {\scriptsize \textsf{prediction}};
	\end{scope}
	
\node at (8,3.2,0) (legend){
		\begin{tikzpicture}[overlay]
		\begin{scope}[canvas is xy plane at z=0]
		\draw[black] (-2.0,-0.75) rectangle (1.3,0.65);
		
		\node [black] at (-0.85,0.3) (s1) {\scriptsize \textsf{Convolution}};
		\node [left=-0.2 of s1] (){
			\begin{tikzpicture}
            \fill[blue] (0,0)rectangle (0.3,0.08);
            \draw[black]  (0,0)rectangle (0.3,0.08);
			\end{tikzpicture}
		};
		\node [black,below=0.4  of s1.west,anchor=west] (s2) {\scriptsize \textsf{Global Average Pooling}};
		\node [left=-0.2 of s2] (){
			\begin{tikzpicture}
            \fill[red] (0,0)rectangle (0.3,0.08);
            \draw[black]  (0,0)rectangle (0.3,0.08);
			\end{tikzpicture}
		};
		\node [black,below=0.4*2  of s1.west,anchor=west] (s3) {\scriptsize \textsf{Fully-connected}};
		\node [left=-0.2 of s3] (){
			\begin{tikzpicture}
            \fill[green] (0,0)rectangle (0.3,0.08);
            \draw[black]  (0,0)rectangle (0.3,0.08);
			\end{tikzpicture}
		};
	\end{scope}
\end{tikzpicture}
};




\end{scope}
\end{tikzpicture}
\caption{The network architecture whose input is a surgical task with variable length \textbf{\textit{l}} recorded by the four manipulators (\textbf{ML}: master left, \textbf{MR}: master right, \textbf{SL}: slave left, \textbf{SR}: slave right) of the da Vinci surgical system. The output is a surgical skill prediction (\textbf{N}: Novice, \textbf{I}: Intermediate and \textbf{E}: Expert).}
\label{fig:archi}
\end{figure}




 In this paper, we propose a new architecture of Convolutional Neural Networks (CNN) dedicated to surgical skill evaluation (Figure~\ref{fig:archi}).
By using one dimensional filters over the kinematic data, we mitigate the need to pre-define sensitive and unreliable gesture boundaries.
The original hierarchical structure of our deep learning model enables us to represent the gestures in latent low-level variables (first and second layers), as well as capturing global information related to the surgical skill level (third layer).
To provide interpretable feedback, instead of using a final fully-connected layer like most traditional approaches~\cite{zhou2016learning}, we place a Global Average Pooling (GAP) layer which enables us to benefit from the Class Activation Map~\cite{zhou2016learning} (CAM) to visualize which parts of the surgical task contributed the most to the surgical skill classification (Figure~\ref{fig:trials}).
We demonstrate the accuracy of our approach using a standardized experimental setup on the largest publicly available dataset for surgical data analysis: the JHU-ISI Gesture and Skill Assessment Working Set (JIGSAWS)~\cite{gao2014jhu}.
The main contribution of our work is to show that deep learning can be used to understand the latent and complex structures of what constitutes a surgical skill, especially that there is still much to be learned on what is exactly a surgical skill~\cite{kassahun2016surgical}.

\section{Method}

\subsection{Dataset}
We first present briefly the dataset used in this paper as we rely on features definition to describe our method.
The JIGSAWS~\cite{gao2014jhu} dataset has been collected from eight right-handed subjects with three different skill levels (Novice (N), Intermediate (I) and Expert (E)) performing three different surgical tasks (suturing, needle passing and knot tying) using the \emph{da Vinci} surgical system.
Each subject performed five trials of each task.
For each trial the kinematic and video data were recorded.

In our work, we only focused on kinematic data which are numeric variables of four manipulators: left and right masters (controlled directly by the subject's hands) and left and right slaves (controlled indirectly by the subject via the master manipulators). 
These kinematic variables (76 in total) are captured at a frequency equal to 30 frames per second for each trial.  
We considered each trial as a multivariate time series (MTS) and designed a one dimensional CNN dedicated to learn automatically useful features for surgical skill classification.   

\subsection{Architecture}
Our approach takes inspiration of the recent success of CNN for time series classification~\cite{wang2017time}. 
The proposed architecture (Figure~\ref{fig:archi}) has been specifically designed to classify surgical skills using kinematic data. 
The input of the CNN is a MTS with variable length  and 76 channels.
The output layer contains the surgical skill level (N, I, E).
Comparing to CNNs for image classification, where usually the network's input has two dimensions (width and height) and 3 channels (RGB), our network's input is a time series with one dimension (length  of the surgical task) and 76 channels (the kinematic variables , etc.).

The main challenge we encountered when designing our network was the huge number of input channels (76) compared to the RGB channels (3) for the image classification task. 
Therefore, instead of applying the convolutions over the 76 channels, we proposed to carry out different convolutions for each cluster and sub-cluster of channels.
In order to decide which channels should be grouped together, we used domain knowledge when clustering the channels.

First we divide the 76 variables into four different clusters, such as each cluster contains the variables from one of the four manipulators: the  and  clusters correspond respectively to the four manipulators (ML: master left, MR: master right, SL: slave left and SR: slave right) of the \emph{da Vinci} surgical system. 
Thus, each cluster contains 19 of the 76 total kinematic variables.  

Next, each cluster of 19 variables is split into five different sub-clusters such as each sub-cluster contains variables that we hypothesize are highly correlated.
For each cluster, the variables are grouped into five sub-clusters: 
 sub-cluster with 3 variables for the Cartesian coordinates ();
 sub-cluster with 3 variables for the linear velocity ();
 sub-cluster with 3 variables for the rotational velocity ();
 sub-cluster with 9 variables for the rotation matrix R;
 sub-cluster with 1 variable for the gripper angular velocity ().  

Figure~\ref{fig:archi} shows how the convolutions in the first layer are different for each sub-cluster of channels. 
Following the same reasoning, the convolutions in the second layer are different for each cluster of channels (ML, MR, SL and SR). 
However, in the third layer, the same convolutions are applied for all channels. 

In order to reduce the number of parameters in our model and benefit from the CAM method~\cite{zhou2016learning}, we replaced the fully-connected layer with a GAP operation after the third convolutional layer. 
This results in a summarized MTS that shrinks from a length  to 1, while preserving the same number of channels in the third layer.
As for the output layer, we use a fully-connected softmax layer with three neurons, one for each class (N, I, E).

Without any cross-validation, we choose to use  filters at the first convolutional layer, then we increase the number of filters (by a factor of ), thus balancing the number of parameters for each layer while going deeper into the network. 
The Rectified Linear Unit (ReLU) activation function is employed for the three convolutional layers with a filter size of  and a stride of . 

\subsection{Training \& Testing}
To train the network, we used the multinomial cross-entropy as our objective cost function. 
The network's parameters were optimized using Adam~\cite{kingma2015adam}. 
Following~\cite{wang2017time}, without any fine-tuning, the learning rate was set to  and the exponential decay rates of the first and second moment estimates were set to  and  respectively.
Each trial was used in a forward-pass followed by a back-propagation update of the weights which were initialized using Glorot's uniform initialization~\cite{glorot2010understanding}.
Before each training epoch, the train set was randomly shuffled.
We trained the network for  epochs, then by saving the model at each training epoch, we chose the one that minimized the objective cost function on a random (non-seen) split from the training set.
Thus, we only validate the number of epochs since no extra-computation is needed to perform this step. 
Finally, to avoid overfitting, we added a  regularization parameter equal to . 
  Since we did not fine-tune the model's hyper-parameters, the same network architecture with the same hyper-parameters was trained on each surgical task resulting in three different models\footnote{\scriptsize Our source code is available on \url{https://germain-forestier.info/src/miccai2018/}}.

To evaluate our approach we adopted the standard benchmark configuration, Leave One Super Trial Out (LOSO)~\cite{ahmidi2017a}: for each iteration of cross-validation (five in total), one trial of each subject was left out for the test and the remaining trials were used for training.

\subsection{Class Activation Map}\label{sec:cam}
By employing a GAP layer, we benefit from the CAM~\cite{zhou2016learning} method, which makes it possible to identify which regions of the surgical task contributed the most to a certain class identification. 
Let  be the result of the third convolutional layer which is a MTS with  channels (in our case  is equal to 32 filters and  denotes the time dimension). 
Let  be the weight between the output neuron of class  and the  filter. 
Since a GAP layer is used, the input to the output neuron of class  () and the CAM () can be defined as:
In order to avoid upsampling the CAM, we padded the input of each convolution with zeros, thus preserving the initial MTS length  throughout the convolutions. 

\section{Results}
\subsection{Surgical skill classification}
Table~\ref{table:results} reports the micro and macro measures (defined in~\cite{ahmidi2017a}) of four different methods for the surgeons' skill classification of the three surgical tasks. 
For our approach (CNN), we report the average of 40 runs to eliminate any bias due to the random seed. 
From these results, it appears that the CNN method is much more accurate than the other approaches with 100\% accuracy for the suturing and needle passing tasks.
As for the knot tying task, we report 92.1\% and 93.2\% respectively for the micro and macro configurations. 
Indeed, for knot tying, the model is less accurate compared to the other two.
This is due to the complexity of this task, which is in compliance with the results of the other approaches.  

In~\cite{lingling2012sparse}, the authors designed Sparse Hidden Markov Models (S-HMM) to evaluate the surgical skills. 
Although the latter method utilizes the gesture boundaries during the training phase, our approach achieves much higher accuracy while still providing the trainee with interpretable skill evaluation. 

Approximate Entropy (ApEn) is used to extract features from each trial~\cite{zia2017automated}, which are then fed to a nearest neighbor classifier. 
Although both methods (ApEn and CNN) achieve state of the art results with 100\% accuracy for the suturing and needle passing surgical tasks, it is not clear how ApEn could be extended to provide feedback for the trainee. 
In addition, we hypothesize that by doing cross-validation and hyper-parameters fine tuning, we could squeeze higher accuracy from the CNN, especially for the knot tying task.

Finally, in~\cite{forestier2017discovering}, the authors introduce a sliding window technique with a discretization method to transform the MTS into bag of words. 
Then, they build a vector for each class from the frequency of the words, which is compared to vectors of the MTS in the test set to identify the nearest neighbor with a cosine similarity metric.   
The authors emphasized the need to obtain \emph{interpretable} surgical skill evaluation, which justified their relatively low accuracy. 
On contrast, our approach does not trade off accuracy for feedback: CNN is much more \emph{accurate} and equally \emph{interpretable}.   
\begin{table}
	\centering
	\caption{Surgical skill classification results (\%)}
	\begin{tabular}{l|cc|cc|cc}
		\toprule
		\multirow{2}{*}{\scriptsize Method} &
		\multicolumn{2}{c}{\scriptsize Suturing} &
		\multicolumn{2}{c}{\scriptsize Needle Passing} &
		\multicolumn{2}{c}{\scriptsize Knot Tying} \\
		& {\scriptsize Micro} & {\scriptsize Macro} & {\scriptsize Micro} & {\scriptsize Macro} & {\scriptsize Micro} & {\scriptsize Macro} \\
		\midrule
		S-HMM~\cite{lingling2012sparse} & 97.4 & n/a  & 96.2 & n/a & 94.4 & n/a \\
		ApEn~\cite{zia2017automated} & \textbf{100} & n/a & \textbf{100} & n/a & \textbf{99.9} & n/a \\
		Sax-Vsm~\cite{forestier2017discovering} & 89.7 & 86.7 & 96.3 & 95.8 & 61.1 & 53.3 \\
		CNN (proposed) & \textbf{100} & \textbf{100} & \textbf{100} & \textbf{100} & 92.1 & \textbf{93.2} \\
		\bottomrule
	\end{tabular}
    \label{table:results}
\end{table}

\begin{figure}
\centering
\subfloat[The last frame of subject (Novice) H's fourth trial of the suturing task.]{
    
 \includegraphics[width=.35\linewidth]{img/Suturing_H004.png}
      \label{sub:screenshot}}
 \hspace{.1cm}
    \subfloat[Trial's corresponding trajectory for the left master manipulator (best viewed in color).]{
 \includegraphics[height=0.235\textheight,width=.35\linewidth]{img/Suturing_H004_Vector.pdf}
      \label{sub:feedback}
      }
    \caption{Example of feedback using Class Activation Map (a video illustrating this feedback is available on \url{https://germain-forestier.info/src/miccai2018/}).
    }
    \label{fig:trials}
\end{figure}

\subsection{Feedback visualization}\label{sec:feedback}
The CAM technique allows us to visualize which parts of the trial contributes the most to a certain skill classification. 
Patterns in movements could be understood by identifying for example discriminative behaviors specific to a novice or an expert.
We can also pinpoint to the trainees their good/bad movements in order to improve themselves and achieve potentially higher skill levels.  

Figure~\ref{fig:trials} gives an example on how to visualize the feedback for the trainee by constructing a heatmap from the CAM. 
A trial of a novice subject is studied: its last frame is shown in Figure~\ref{sub:screenshot} and its corresponding heatmap is illustrated in Figure~\ref{sub:feedback}. 
In the latter, the model was able to detect which movements (red area) were the main reason behind subject H's classification (as a novice). 
This feedback could be used to explain to a young surgeon which movements are classifying him/her as a novice and which ones are classifying another subject as an expert. 
Thus, the feedback could guide the novices into becoming experts.


\section{Conclusion}
In this paper, we presented a new method for classifying surgical skills. 
By designing a specific CNN, we achieved 100\% accuracy, while providing interpretability that justifies a certain skill evaluation, which reduces the CNN's black-box effect.

In our future work, due to the natural extension of CNNs to image classification, we aim at developing a unified CNN framework that uses both video and kinematic data to classify surgical skills accurately and to provide highly interpretable feedback for the trainee. 


\bibliographystyle{splncs03}
\bibliography{biblio}


\end{document}
