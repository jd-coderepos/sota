\documentclass[10pt,twocolumn,letterpaper]{article}

\usepackage{iccv}
\usepackage{times}
\usepackage{epsfig}
\usepackage{amsmath}
\usepackage{amssymb}

\usepackage{algorithm}
\usepackage{algpseudocode}
\renewcommand{\algorithmicrequire}{\textbf{Input:}}
\renewcommand{\algorithmicensure}{\textbf{Output:}}

\usepackage{indentfirst}
\usepackage{longtable}
\usepackage{subfigure}
\usepackage{multirow}
\usepackage{graphicx}
\usepackage{makecell}
\usepackage{url}
\def\Figref#1{Figure~\ref{#1}}
\def\Tabref#1{Table~\ref{#1}}
\def\Secref#1{Section~\ref{#1}}
\def\Algref#1{Algorithm~\ref{#1}}
\def\Eqref#1{{Eq.~\eqref{#1}}}
\def\RMw{\mathrm{UniformSample}}
\def\RMo{\mathrm{OrderedUniformSample}}
\def\LLB{\textcolor{black}}
\def\NAME{{SETN}}
\usepackage{amsmath,amsfonts,bm}

\def\vzero{{\bm{0}}}
\def\vone{{\bm{1}}}
\def\vmu{{\bm{\mu}}}
\def\vtheta{{\bm{\theta}}}
\def\va{{\bm{a}}}
\def\vb{{\bm{b}}}
\def\vc{{\bm{c}}}
\def\vd{{\bm{d}}}
\def\ve{{\bm{e}}}
\def\vf{{\bm{f}}}
\def\vg{{\bm{g}}}
\def\vh{{\bm{h}}}
\def\vi{{\bm{i}}}
\def\vj{{\bm{j}}}
\def\vk{{\bm{k}}}
\def\vl{{\bm{l}}}
\def\vm{{\bm{m}}}
\def\vn{{\bm{n}}}
\def\vo{{\bm{o}}}
\def\vp{{\bm{p}}}
\def\vq{{\bm{q}}}
\def\vr{{\bm{r}}}
\def\vs{{\bm{s}}}
\def\vt{{\bm{t}}}
\def\vu{{\bm{u}}}
\def\vv{{\bm{v}}}
\def\vw{{\bm{w}}}
\def\vx{{\bm{x}}}
\def\vy{{\bm{y}}}
\def\vz{{\bm{z}}}


\def\mA{{\bm{A}}}
\def\mB{{\bm{B}}}
\def\mC{{\bm{C}}}
\def\mD{{\bm{D}}}
\def\mE{{\bm{E}}}
\def\mF{{\bm{F}}}
\def\mG{{\bm{G}}}
\def\mH{{\bm{H}}}
\def\mI{{\bm{I}}}
\def\mJ{{\bm{J}}}
\def\mK{{\bm{K}}}
\def\mL{{\bm{L}}}
\def\mM{{\bm{M}}}
\def\mN{{\bm{N}}}
\def\mO{{\bm{O}}}
\def\mP{{\bm{P}}}
\def\mQ{{\bm{Q}}}
\def\mR{{\bm{R}}}
\def\mS{{\bm{S}}}
\def\mT{{\bm{T}}}
\def\mU{{\bm{U}}}
\def\mV{{\bm{V}}}
\def\mW{{\bm{W}}}
\def\mX{{\bm{X}}}
\def\mY{{\bm{Y}}}
\def\mZ{{\bm{Z}}}

\def\gA{{\mathcal{A}}}
\def\gB{{\mathcal{B}}}
\def\gC{{\mathcal{C}}}
\def\gD{{\mathcal{D}}}
\def\gE{{\mathcal{E}}}
\def\gF{{\mathcal{F}}}
\def\gG{{\mathcal{G}}}
\def\gH{{\mathcal{H}}}
\def\gI{{\mathcal{I}}}
\def\gJ{{\mathcal{J}}}
\def\gK{{\mathcal{K}}}
\def\gL{{\mathcal{L}}}
\def\gM{{\mathcal{M}}}
\def\gN{{\mathcal{N}}}
\def\gO{{\mathcal{O}}}
\def\gP{{\mathcal{P}}}
\def\gQ{{\mathcal{Q}}}
\def\gR{{\mathcal{R}}}
\def\gS{{\mathcal{S}}}
\def\gT{{\mathcal{T}}}
\def\gU{{\mathcal{U}}}
\def\gV{{\mathcal{V}}}
\def\gW{{\mathcal{W}}}
\def\gX{{\mathcal{X}}}
\def\gY{{\mathcal{Y}}}
\def\gZ{{\mathcal{Z}}}

\def\sA{{\mathbb{A}}}
\def\sB{{\mathbb{B}}}
\def\sC{{\mathbb{C}}}
\def\sD{{\mathbb{D}}}
\def\sE{{\mathbb{E}}}
\def\sF{{\mathbb{F}}}
\def\sR{{\mathbb{R}}}
\def\sW{{\mathbb{W}}} 
\usepackage{etoolbox}
\makeatletter
\patchcmd{\maketitle}
 {\def\@makefnmark}
 {\def\@makefnmark{}\def\useless@macro}
 {}{}
\makeatother



\usepackage[pagebackref=true,breaklinks=true,,colorlinks,bookmarks=false]{hyperref}

\iccvfinalcopy 

\def\iccvPaperID{0126} \def\httilde{\mbox{\tt\raisebox{-.5ex}{\symbol{126}}}}

\ificcvfinal\pagestyle{empty}\fi

\begin{document}

\title{One-Shot Neural Architecture Search via Self-Evaluated Template Network}

\author{
Xuanyi Dong\thanks{This paper was accepted to the IEEE ICCV 2019.}\thanks{This work was done when Xuanyi Dong was a research intern with Baidu Research.} and Yi Yang \\
Baidu Research, ReLER, University of Technology Sydney\\
{\tt\small xuanyi.dxy@gmail.com}, {\tt\small yi.yang@uts.edu.au}
}

\maketitle
\ificcvfinal\thispagestyle{empty}\fi


\begin{abstract}
Neural architecture search (NAS) aims to automate the search procedure of architecture instead of manual design. Even if recent NAS approaches finish the search within days, lengthy training is still required for a specific architecture candidate to get the parameters for its accurate evaluation. Recently one-shot NAS methods are proposed to largely squeeze the tedious training process by sharing parameters across candidates. In this way, the parameters for each candidate can be directly extracted from the shared parameters instead of training them from scratch. However, they have no sense of which candidate will perform better until evaluation so that the candidates to evaluate are randomly sampled and the top-1 candidate is considered the best. In this paper, we propose a Self-Evaluated Template Network ({\NAME}) to improve the quality of the architecture candidates for evaluation so that it is more likely to cover competitive candidates. {\NAME} consists of two components: (1) an evaluator, which learns to indicate the probability of each individual architecture being likely to have a lower validation loss. The candidates for evaluation can thus be selectively sampled according to this evaluator. (2) a template network, which shares parameters among all candidates to amortize the training cost of generated candidates. In experiments, the architecture found by {\NAME} achieves the state-of-the-art performance on CIFAR and ImageNet benchmarks within comparable computation costs. Code is publicly available on GitHub: \url{https://github.com/D-X-Y/AutoDL-Projects}.
\end{abstract}



\section{Introduction}

Representation learning~\cite{bengio2013representation} is a fundamental research problem in computer vision, because it is beneficial to a variety of computer vision applications, such as detection and segmentation.
Due to the success of deep learning, it has undergone a transition from ``feature engineering''~\cite{lowe1999object,dalal2005histograms} to ``architecture engineering''~\cite{szegedy2015going,huang2017densely,simonyan2015very,liu2019ppn,he2016deep,dong2017more}. However, a large amount of expert knowledge and ample computational resources are still required to secure an architecture for good feature representations~\cite{zoph2017NAS}.
Fortunately, neural architecture search (NAS) brings hope to deep learning researchers and alleviate their labours~\cite{Zoph_2018_CVPR,pmlr-v80-pham18a}.



The goal of NAS is to discover an optimal network in the search space, which can maximize the validation accuracy after training. Typical algorithms apply reinforcement learning (RL)~\cite{zoph2017NAS,Zoph_2018_CVPR,pmlr-v80-pham18a,chen2019renas} or evolutionary strategy~(EA)~\cite{liu2018hierarchical,real2019regularized} to solve this problem, and most are computationally expensive, e.g., 500 GPUs over four days~\cite{Zoph_2018_CVPR}. Such huge computational costs motivate the researchers to focus on efficient architecture search algorithms. Recently, several works reduced the computational cost through weight sharing~\cite{pmlr-v80-pham18a,cai2018efficient}, weight generation~\cite{brock2018smash,bender2018understanding}, accuracy prediction~\cite{baker2018accelerating,klein2017learning}, progressive strategy~\cite{Liu_2018_ECCV}, etc.\looseness-1



\begin{figure}[t!]
\begin{center}
\includegraphics[width=\linewidth]{resources/SETN.pdf}
\end{center}
\vspace{-3mm}
\caption{
An overview of the self-evaluated template network ({\NAME}). 
{\NAME} consists of a template network and an evaluator.
Architectures for evaluation are generated by sampling candidates in the template network using the evaluator.
The template network shares the parameters for different candidates as indicated by connections of arrow lines in different colors. The evaluator learns the distribution of the architectures being likely to have a lower validation loss.
}
\vspace{-2mm}
\label{fig:intro}
\end{figure}



One-shot NAS approaches stand out among these efficient NAS approaches~\cite{bender2018understanding,brock2018smash}, because they can significantly squeeze the tedious training process by sharing parameters across architecture candidates.
A typical one-shot NAS paradigm is to (1) randomly sample hundreds of architecture candidates {from the parameter-shared network}; (2) evaluate these candidates; and (3) find the candidate with the highest validation accuracy.
We observed that most of these randomly sampled candidates are useless, since most of them have a poor performance. Besides, these sampled candidates are only a small portion of the whole search space; therefore {the probability for inclusion of the best architecture is extremely low}.



To solve the above problem, we propose \textit{Self-Evaluated Template Network ({\NAME})} for one-shot NAS.
{\NAME} equips a template network with an evaluator.
The \textit{template network} contains all possible candidate convolutional neural networks (CNNs) and shares its parameters (template parameters) with all candidates. We train this template network in \textit{a stochastic strategy}: during one iteration, we uniformly sample one candidate and only optimize partial template parameters for this sampled candidate. In this way, after training, each candidate CNN can directly use the corresponding template parameters without additional training.
Some previous methods coupled the shared parameters with a learnable distribution of architectures, such as~\cite{liu2019darts,dong2019search,pmlr-v80-pham18a}.
These methods will introduce the bias into the template parameters.
Since some shallow and light-weight network will quickly converged, the learnable distribution will bias to these ``simple'' networks, and other networks may not have a chance to be updated.
In contrast to them, our uniformly stochastic training strategy allows each candidate to be treated equally. In this way, each candidate with shared template parameters would be trained fully, and their validation accuracy would be closer to the ground truth validation accuracy.


The \textit{evaluator} learns to indicate the probability of each individual candidate CNN being likely to have a lower validation loss. We train this evaluator on the validation data with the assistance of the template network.
After training, according to the learned probability, our evaluator can pick up low-validation-loss candidates for one-shot evaluation.
As a result, the probability of including the best CNN in the search space can be dramatically improved.
Compared to previous random sampling algorithms~\cite{bender2018understanding,brock2018smash}, {\NAME} can potentially search for a CNN with a higher accuracy.

In experiments, {\NAME} can discover a superior CNN on CIFAR-10 within two GPU days.
This {\NAME}-searched architecture achieves state-of-the-art performance on three benchmarks, i.e., CIFAR-10, CIFAR-100, and ImageNet.









\section{Related Work}\label{sec:related-work}

Automatically discovering effective networks has attracted more and more researchers~\cite{brock2018smash,baker2017designing,zoph2017NAS,liu2018hierarchical,fang2020densely,dong2019network}. Various kinds of searching algorithms have been proposed, such as RL-based~\cite{zoph2017NAS,Zoph_2018_CVPR,pmlr-v80-pham18a}, EA-based~\cite{real2019regularized,real2017large}, gradient-based~\cite{liu2019darts,luo2018neural} approaches. Each of these algorithm has its unique advantage.
For simplicity, we summarize some ubiquitous algorithms in \Tabref{table:compare-method-attribute} regarding five aspects.
Our {\NAME} has advantages when compared to them, and we will introduce these related works at below. Note that we focus on searching CNN models, and thus approaches about recurrent neural network or downstream applications are out of the scope of this paper.



\begin{table}[t!]
\centering
\setlength{\tabcolsep}{2.6pt}
\begin{tabular}{| c | c | c | c | c | c |}\hline
                                         & Search    &   Eff.    & Share    & Eval.  & Gen. \\
\hline
  ResNet~\cite{he2016deep}               & Manual    &   &       &     &     \\
\hline
  MetaQNN~\cite{baker2017designing}      & RL        &   &  &     &     \\
  NASNet~\cite{Zoph_2018_CVPR}           & RL        &   &  &     &     \\
  AmoebaNet~\cite{real2019regularized}   & EA        &   &  &     &     \\
   H-NAS~\cite{liu2018hierarchical}      & EA        &   &  &     &     \\
  EAS~\cite{cai2018efficient}            & RL        &    &   &     &     \\
  PNAS~\cite{Liu_2018_ECCV}              & SMBO      &   &  & slow   &     \\
  SMASH~\cite{brock2018smash}            & Gradient  &    &  & quick  & random \\
Understand~\cite{bender2018understanding}& Gradient  &    &   & quick  & random \\
  DARTS~\cite{liu2019darts}              & Gradient  &    &   &     &     \\
  GDAS~\cite{dong2019search}             & Gradient  &    &   &     &     \\\hline
  Our {\NAME}                            & Gradient  &    &   & quick  & selective  \\
\hline
\end{tabular}
\vspace{1mm}
\caption{
We compare different algorithms with five aspects.
``Search'' shows the search algorithm type.
``Eff.'' indicates efficient, and we consider the algorithm that can discover CNN within five GPU days as efficient.
``Share'' indicates whether the algorithm shares parameters over different candidate networks or not.
``Eval.'' means whether the algorithm is able to quickly evaluate a network.
``Gen.'' indicates the network sampling strategy during \textit{the one-shot evaluation procedure}.
``-'' indicates not available, which means those methods do not have these steps.
}
\vspace{-4mm}
\label{table:compare-method-attribute}
\end{table}


Early approaches train a large amount of candidate networks by tens epochs and use the validation accuracy of these networks as the supervisory signal~\cite{liu2018hierarchical,real2019regularized,zoph2017NAS,Zoph_2018_CVPR,real2017large}.
For example, Zoph~et~al.~\cite{zoph2017NAS,Zoph_2018_CVPR} learn an RL policy to sample networks with high accuracy.
Real~et~al.~\cite{real2017large,real2019regularized} utilize EA algorithms to mutate low-quality networks to high-quality networks.
Unfortunately, these approaches cost too much computational resources.
Recent approaches aim to solve the searching problem in an affordable computation cost.
Liu~et~al.~\cite{Liu_2018_ECCV} progressively search CNN from simple to complex. Barker~et~al.~\cite{baker2018accelerating} accelerate the searching procedure by performance prediction. Pham~et~al.~\cite{pmlr-v80-pham18a} share the parameters of different networks.
Liu~et~al.~\cite{liu2019darts} propose DARTS, allowing efficient search of the architecture using gradient descent.
DARTS~\cite{liu2019darts} and GDAS~\cite{dong2019search} choose the best architecture using the  over a continues architecture representation, while the performance of an architecture cannot be correctly estimated without fully training it.
Our {\NAME} can more accurately estimate the performance (validation loss) of all candidates without separately training each of them one by one. 




Our {\NAME} is one-shot NAS, and is closely related to previous one-shot approaches \cite{zhang2019graph,bender2018understanding,brock2018smash}.
Brock~et~al.~\cite{brock2018smash} train hypernetworks~\cite{ha2017hypernetworks} to generate suitable weights for every network in the search space. Zhang~et~al.~\cite{zhang2019graph} encode the network as a computation graph and use a graph neural network to predict weights.
Bender~et~al.~\cite{bender2018understanding} deliver thorough experimental analysis for one-shot architecture search.
These approaches can estimate the network performance correctly without additional training, while the architecture candidates for evaluation are randomly picked with uneven quality~\cite{bender2018understanding,brock2018smash}.
Our approach can selectively sample low-validation-loss architecture candidates.
In this way, our sampled candidates would have much lower validation loss (better performance) than that of the random strategy~\cite{bender2018understanding,brock2018smash}, and thus we can potentially discover a more effective CNN architecture.









\section{Background}\label{sec:background}


Early works search for the whole CNN structure~\cite{zoph2017NAS,bello2017neural}, whereas recent works propose that finding a good neural cell is more effective than finding a whole CNN~\cite{Liu_2018_ECCV,liu2019darts,zhang2019graph,dong2019search}.
Therefore, we also search for a good cell instead of a full CNN model.
As shown in \Figref{fig:intro}, a cell is a fully convolutional structure, mapping a tensor  to another tensor .
If we use the stride of 1, the cell is named normal cell, which has =; and if we use the stride of 2, the cell is named reduction cell, which has =.
Each cell contains  nodes, where each of them is specified as a quadruple ~\cite{Liu_2018_ECCV}.
Specifically, the -th node in the -the cell takes two inputs  and generates a tensor .
 are transformation functions to apply to inputs.
The output of the -th cell is the concatenation of each intermediate output tensor from each node, denoted as .


The set of possible inputs  is the output set of all previous nodes adding the outputs of two previous cells: {}. The candidate function set  contains several pre-defined functions.
In this paper, we apply our {\NAME} on the candidate function set  following previous methods~\cite{liu2019darts,dong2019search} as follows:
\begin{table}[H]
\small
\vspace{-3mm}
\setlength{\tabcolsep}{0.3em} \centering
\def\arraystretch{1.0}
\begin{tabular}{lll}
 3x3 max pooling     &  3x3 avg pooling  &  skip connection     \\
 3x3 separable conv  &  5x5 separable conv &  1x3 \& 3x1 conv \\
\end{tabular}
\vspace{-3mm}
\end{table}
\noindent We set the number of nodes in a cell as .
Therefore, the number of candidates in the search space of  is .



Once we obtain the topology structures of the normal cell and the reduction cell, we follow previous works to construct the overall CNN~\cite{Liu_2018_ECCV,liu2019darts,dong2019search}.
For CIFAR, the overall CNN is [image]  [N-Cell]N  [R-Cell]  [N-Cell]N  [R-Cell]  [N-Cell]N  [Softmax];
and for ImageNet, the overall CNN is [image]  [a pair of 3x3 Conv]  [3x3 Conv]  [N-Cell]N  [R-Cell]  [N-Cell]N  [R-Cell]  [N-Cell]N  [Softmax], where [N-Cell] and [R-Cell] indicate the normal and reduction cells, respectively.




\section{Methodology}







\subsection{Template Network}\label{sec:template-net}

The template network contains all candidate CNNs in the search space. The parameters of each candidate CNN are shared by a single template network.
It is non-trivial to make billions of candidate CNNs perform well after optimizing one template network.
To achieve this goal, we introduce a stochastic training strategy to optimize the template network by stochastically selecting the operations and inputs as below:
{\small

}\noindent where\hspace{-3mm}
\footnotetext[2]{ indicates a set of  elements chosen randomly from set  with replacement via a uniform distribution.}
\footnotetext[3]{ indicates a set of  elements chosen randomly from set  via a uniform distribution, in the mean time, the index of a later sampled element should be not larger than the index of former element.
In implementation, we uniformly random sample an integer  from [0, N(N+1)/2) and use \Eqref{eq:cal-r} to compute these two indexes.}, at the -th node, we randomly sample two inputs  and  from the set  with replacement; random sample two functions  and  from the set  by restricting the index of  in   the index of . This sample strategy can avoid the redundant candidates in the search space. For example, (=3x3 conv,=5x5 conv,=,=) is the same architecture as (=5x5 conv,=3x3 conv,=,=), but these two combinations are considered as different architectures during searching in some previous works~\cite{liu2019darts,pmlr-v80-pham18a,dong2019search}.

At each training iteration, the template network uniformly samples a candidate CNN, decided by \Eqref{eq:hybrid-net}\Eqref{eq:choice-F}, and then it only optimizes template parameters of this sampled CNN.
This strategy allows us to optimize each candidate with equal opportunity, thus avoiding the Matthew effect. As a result, each candidate CNN is more likely to be fully trained compared to that in previous joint optimization strategies~\cite{liu2019darts,dong2019search,cai2019proxylessnas}.
We use ``the Matthew effect'' to refer that some quickly-converged candidates will get more chances to be further optimized in some NAS algorithms~\cite{liu2019darts,dong2019search,cai2019proxylessnas,pmlr-v80-pham18a}.
Besides, if we increase the cardinality of the function set , the search space will grow exponentially, but the size of the template network will grow only linearly. This property allows us to search over large search space but only using a relatively small template network.




\subsection{Evaluator}\label{sec:network-evaluator}

We only optimize the template parameters on the training data, and a candidate CNN would thus be considered to generalize well if it can use learned template parameters to yield a low validation loss.
To find the best CNN, a trivial solution is traversing all candidates and evaluate them one by one, yet it would cost unaffordable computation time to cross over 10 candidates.
Some one-shot methods~\cite{bender2018understanding,brock2018smash} uniformly select a small amount of candidates to evaluate, where most uniformly selected candidates are useless.
To solve these issues, we design an evaluator to indicate the probability of each individual candidate CNN being likely to have a lower validation loss.
To represent this probability of each candidate, we encode one candidate CNN as a set of quadruples, and then define the probabilities over these quadruples.




\begin{algorithm}[t!]
\small
\caption{
The Searching Algorithm of {\NAME}
}
\label{alg:{\NAME}}
\small
\begin{algorithmic}
\Require        the whole available training data \\
\hspace{0.65cm} a template network with  and an evaluator with 
\State Split the whole available training data into the training set  and the validation set  for searching
\While{not converge}       \Comment{Optimize  and }
  \State Sample training batch {\small } from 
  \State Calculate {\small} based on \Eqref{eq:hybrid-net}
  \State Update  via gradients from the training loss {\small }
  \State Sample validation batch {\small } from 
  \State Calculate {\small} based on \Eqref{eq:generator}
  \State Update  via gradients from the validation loss {\small }
\EndWhile \\
After the above steps, we obtain the optimized  and . \\
Initialize  \Comment{Obtain Low-Validation-Loss Candidates}
\For{i=1; i  ; i++}
  \State Sample an architecture  using \Eqref{eq:softmax-fg} to \Eqref{eq:assign-f}
  \State 
\EndFor \\
Evaluate all candidates in  with parameters extracted from  \\
Select the candidate with the lowest validation loss
\Ensure the final selected candidate
\end{algorithmic}
  
\end{algorithm}


We introduce the encoding approach for the -th node in the -th cell, and one can easily infer the steps for other nodes. For simplicity, suppose we only search for one neural cell.
At first, we encode the choices of  and . Based on \Eqref{eq:choice-I}, there are  choices for  and  choices for  (we omit the subscript and superscript for simplicity). We thus use two vectors  and  to indicate the categorical choice for  and , and use its softmax-normalized value as the choice probability, which can be formulated as:
{\small

}\noindent where  represents the categorical distribution drawn by the vector , so as .
 and  are chosen as the -th and -th element in .
Similarly, there are  combination choices for  and , and therefore, we leverage a vector  to indicate the categorical choice, which is formulated as:
{\small

}\noindent where  represents the categorical distribution drawn by the vector .  and  are the -th and -th functions in , respectively. \Eqref{eq:cal-r} guarantees the indexes , which is consistent with \Eqref{eq:choice-F}.
\Eqref{eq:softmax-fg} to \Eqref{eq:assign-f} can sample one quadruple  for one node based on the probabilities , , and , which are encoded by , , and .
The set of quadruples for all nodes  can represent one candidate architecture in the search space.



To enable the evaluator being able to indicate whether a candidate could result in a low validation loss, we need to optimize the parameters of this evaluator  on the validation set.
Since \Eqref{eq:softmax-fg} to \Eqref{eq:assign-f} are discrete, we use continues relaxation to calculate the output  of a node, as follows:
{\small

}
\noindent Based on \Eqref{eq:generator}, we can back-propagate gradients through the architecture encoding . To enforce the learned evaluator being able to reflect the validation loss of an architecture candidate, our objective for this evaluator is to minimize the validation loss.
Specifically, we forward the validation images through the template network with assistance of the evaluator via \Eqref{eq:generator}, and backward the validation loss\footnote{the validation loss could be a simple softmax with cross-entropy loss, and could also integrate other constrains about latency or memory size~\cite{cai2019proxylessnas}} to the evaluator's parameters.
In this way, after optimizing the evaluator, candidates sampled by the learned probabilities (\Eqref{eq:distribution_fg} and \Eqref{eq:distribution-h}) would be more likely to result in a high performance on the validation set.






\subsection{The Searching Algorithm of {\NAME}}\label{sec:searching}

We use  to denote the parameters of the template network, i.e., the parameters of candidate functions in each node of each cell.
The searching algorithm of {\NAME} should (1) optimize parameters of the template network  and parameters of the evaluator ; (2) sample =1000 low-validation-loss architecture candidates via the evaluator; and (3) evaluate these sampled candidates with the template parameters  and choose the candidate with the lowest validation loss.

We show the overall searching algorithm in \Algref{alg:{\NAME}}, where  indicates the standard classification loss based on an input image  with its label .
We optimize  based on \Eqref{eq:generator} and  based on \Eqref{eq:hybrid-net} in an alternative way.
The parameters of the template network are optimized on the training set, while the parameters of the evaluator are optimized on the validation set to guarantee the generalization ability of the searched model~\cite{liu2019darts}.

\textbf{Note that} we use different forward procedures for the template network and the evaluator: the template network uses \Eqref{eq:hybrid-net} and can enable each candidate perform well with the shared template network; the evaluator uses \Eqref{eq:generator} can help squeeze the candidate set for evaluation. 
After optimizing  and , we sample =1000 low-validation-loss candidates and select the one with the best one-shot performance.






\subsection{Connections with Other NAS Approaches}\label{sec:discussion}




Our proposed {\NAME} generalized over DARTS~\cite{liu2019darts} and one-shot NAS approaches~\cite{bender2018understanding,brock2018smash}.
DARTS directly can pick the best architecture, while this network capacity can not be correctly estimated in the validation set without fully training it. Besides, the architecture found by DARTS yields a performance with a high variance.
Comparatively, one-shot NAS can estimate the network performance correctly without additional training, while the architecture candidates are randomly picked with uneven quality instead of generating the ``best'' candidate~\cite{bender2018understanding,brock2018smash}.
Our {\NAME} is a new framework, which generalizes the above two typical streams and assimilates their benefits of accurate evaluation and high-quality architecture candidates selection.

To analyze the difference of technique details between our approach and others~\cite{liu2019darts}, we consider the following variants of our methods. \\
\textbf{{\NAME}}: our proposed search algorithm.\\
\textbf{{\NAME}-LR}: use a stochastic strategy to train the template network with less randomness, where the indexes of the sampled inputs/functions are the same for different cells.\\
\textbf{{\NAME}-NON}: optimize the template network without randomness, in which  is the weighted sum of all possible function and input combinations as \Eqref{eq:generator}.\\
\textbf{{\NAME}-RAND}: randomly sample candidates for evaluation as previous one-shot approaches.\\
{\NAME}-NON is the same strategy as~\cite{liu2019darts}, and {\NAME}-RAND is the same strategy as~\cite{bender2018understanding,brock2018smash}.
We will show that {\NAME} is superior to {\NAME}-LR, {\NAME}-NON, and {\NAME}-RAND in experiments.







\begin{table*}[t!]
\centering
\setlength{\tabcolsep}{11pt}
\begin{tabular}{| l | c | c | c | c | c | c | c |} \hline
          Method                            & \makecell{GPU\\Days} &  M  &  C  & \makecell{Parameters} & \makecell{Error on \\CIFAR-10 (\%)}& \makecell{Error on\\CIFAR-100 (\%)} \\\hline
  DenseNet-BC~\cite{huang2017densely}       &        &  &  &  25.6 MB      &          3.46             &    17.18  \\
  PyramidNet~\cite{han2017deep}             &        &  &  &  26.0 MB      &          3.31             &    16.35  \\
      \hline\hline
 MetaQNN~\cite{baker2017designing}          & 80     &  &  &   11.2 MB     &          6.92             &    27.14  \\
 Net Transformation~\cite{cai2018efficient} & 10        &  &  &   19.7 MB     &          5.70             &        \\
 SMASH~\cite{brock2018smash}                & 1.5       &  &  &   16.0 MB     &          4.03             &        \\
 Hierarchical NAS~\cite{liu2018hierarchical}& 300       & 6   & 64  &            &          3.75             &    20.3   \\
 Progressive NAS~\cite{Liu_2018_ECCV}       & 150       & 11  & 48  &    3.2 MB       &          3.63             &     19.53  \\
 NASNet-A~\cite{Zoph_2018_CVPR}             & 2000      & 20  & 32  &    3.3 MB       &          3.41             &     19.70   \\
 AmoebaNet-A~\cite{real2019regularized}     & 3150      & 20  & 36  &    3.2 MB   &        3.34               &          \\
 ENAS~\cite{pmlr-v80-pham18a}               & 0.45      & 20  & 36  &    4.6 MB       &          3.54             &     19.43         \\
 NAONet~\cite{luo2018neural}                & 200       & 20  & 36  &    10.6 MB     &          3.18             &         \\
 \hline
 NASNet-A + CutOut~\cite{Zoph_2018_CVPR}    & 2000      & 20  & 32  &    3.3 MB    &   \textbf{2.65}           &  17.81     \\
PNAS + CutOut~\cite{Liu_2018_ECCV}          & 150       & 11  & 48  &    3.2 MB    &                        &     17.63   \\
 DARTS + CutOut~\cite{liu2019darts}         & 4         & 20  & 36  &    3.4 MB    &          2.83             &         \\
 GHN + CutOut~\cite{zhang2019graph}         & 0.84      & 18  & 32  &    5.7 MB    &          2.84             &          \\
 ENAS + CutOut~\cite{pmlr-v80-pham18a}      & 0.45      & 20  & 36  &    4.6 MB    &          2.89             &  18.91   \\
 GDAS + CutOut~\cite{dong2019search}        & 0.84      & 20  & 36  &    3.4 MB    &          2.93             &  18.38     \\
    \hline
 {\NAME}-LR (=1K) + CutOut               &   1.8      & 20  & 36  &  5.5 MB    &          2.81             &  17.88     \\
 {\NAME}-NON (=1K) + CutOut              &   1.8      & 20  & 36  &  3.7 MB    &          3.12             &  18.27     \\
 {\NAME} (=1) + CutOut                   &   1.7      & 20  & 36  &  4.5 MB    &          3.41             &  18.12     \\
 {\NAME} (=1K)                           &   1.8      & 20  & 36  &  4.6 MB    &          3.56             &  19.38     \\
{\NAME} (=1K) + CutOut                  &   1.8      & 20  & 36  &  4.6 MB    &          2.69             &  \textbf{17.25} \\\hline
\end{tabular}
\vspace{2mm}
\caption{
We compare {\NAME} and other algorithms on CIFAR-10 and CIFAR-100.
The top block presents state-of-the-art architectures designed by human experts.
The bottom block presents architectures that are automatically discovered by machine.
``'' indicates the total number of cells in the CNN, and ``'' denotes the number of the filter channel in the first cell.
``CutOut'' indicates the data argumentation approach~\cite{CUTOUT}.
 denotes the results reproduced by ourself.
The bottom five lines show results for different variants of our approach.
We run each model three times and report the mean error (lower is better).
}
\vspace{-2mm}
\label{table:CIFAR}
\end{table*}





\section{Experiments}\label{sec:experiments}



\subsection{Experimental Setup}\label{sec:setup}

\textbf{Datasets.} CIFAR-10~\cite{krizhevsky2009learning} contains 60,000 images categorized into 10 classes. The training set has 5000 images per class, 50,000 images in total.
The test set contains 1000 images per class, 10,000 images in total.
{CIFAR-100}~\cite{krizhevsky2009learning} is similar to CIFAR-10.
It contains 50,000 training and 10,000 test images, categorized into 100 classes. All images are 32x32 colored ones.
{ImageNet}~\cite{russakovsky2015imagenet} is a large-scale image classification dataset, containing 1000 classes, 1.28 million training images and 50,000 validation images.



\textbf{Searching Setup.}
We search the normal CNN cell and the reduction CNN cell on CIFAR-10. For searching, the official training images are randomly split into the searching training set  and the search validation set  in \Algref{alg:{\NAME}}.  contains 50\% of the official CIFAR-10 dataset, i.e., 25,000 images.  contains the rest images.
The candidate function set  has 6 different operations as introduced in \Secref{sec:background}.
The hyper-parameters to construct the whole CNN model are:
the number of nodes in a cell , the initial channels of the first layer , the number of repeated normal cells .
By default, we set , , and  to search the CNN cells.
Note that, the number of operations in  is the same as ENAS~\cite{pmlr-v80-pham18a} and DARTS~\cite{liu2019darts}.


We train the template network and the evaluator with the batch size of 64 in 400 epochs.
To optimize the parameters  of template network, we use the SGD optimization.
We start the learning rate of 0.025 and anneal it down to 0 following a cosine schedule. We use the momentum of 0.9 and the weight decay of 3e-4. We set the probability of path dropout as 0.1.
To optimize the parameters  of the evaluator, we use the Adam optimization~\cite{kingma2015adam} with the learning rate of 3e-3 and the weight decay of 1e-3.
To avoid the gradient explosion, we clip the gradient for both  and  by 10 during training.


\textbf{Computational Costs.}
Our {\NAME} would take about 40 hours to optimize both template network and evaluator on a single NVIDIA Tesla V100 GPU.
Evaluating =1000 candidates costs less than three hours on a single GPU (about 13 seconds per candidate). Therefore, it requires about 43 GPU hours to obtain the final CNN structure.
Note that when different NAS methods report their searching costs, they may use different hardware, e.g., NVIDIA GTX 1080Ti~\cite{liu2019darts} and NVIDIA P100~\cite{Zoph_2018_CVPR}.
We did not normalize the GPU cost of compared methods across different devices, and we use the numbers from their original papers.





\subsection{Compared with State-of-the-art Approaches}\label{sec:comparison}

{\bf Experiments on CIFAR.}
After we discover outstanding cells in the search space, we use the discovered topology with  and  to construct the CNN model for CIFAR-10 and CIFAR-100 following~\cite{liu2019darts,luo2018neural}.
We train this network by 600 epochs with the initial learning rate of 0.025.
We anneal the learning rate down to 0 with the cosine schedule.
The batch size is 96; the momentum is 0.9; and the weight decay is 5e-4.
The ratio of drop path is 0.2. Following~\cite{Liu_2018_ECCV,zoph2017NAS,Zoph_2018_CVPR,liu2019darts,dong2019search}, we use an auxiliary tower with the weight of 0.4 to train the network. We train each network three times and report the mean error.

{\bf Comparison with the state-of-the-art on CIFAR-10 and CIFAR-100.}
We compare the results of the found network with other state-of-the-art networks in \Tabref{table:CIFAR}.
``{\NAME} (=1K)'' indicates the network found by our approach.
First, our {\NAME} is one of the most efficient algorithms, in which we complete the search procedure in 1.8 GPU days.
Second, among those efficient NAS approaches~\cite{zhang2019graph,pmlr-v80-pham18a,liu2019darts} (less than five GPU days), the network found by {\NAME} achieves the lowest error with similar or fewer parameters.
Other NAS approaches need more than 100 times computational costs than ours, whereas models found by most approaches have higher error with more parameters than our {\NAME}.
On CIFAR-100, our network achieves the best performance (a error of 17.25\%) among all compared methods.
On CIFAR-10, our network is slightly worse than NASNet-A (2.69\% test error vs. 2.65\% test error), however, NASNet-A needs more than 1000 computational costs than {\NAME}.





\begin{table*}[t!]
\centering
\setlength{\tabcolsep}{5pt}
\begin{tabular}{| c | l | c | c | c | c | c |} \hline
 &   Method  & \makecell{GPU days}          & Parameters &  (million) & Top-1 Accuracy & Top-5 Accuracy \\ \hline
\multirow{4}{*}{\makecell{Human\\Expert}}
 & Inception-v1~\cite{szegedy2015going}             &   &  6.6 MB  &      1448     &    69.8\%      & 89.9\%         \\
 & ResNet~\cite{he2016deep}                         &   &  11.7 MB &      1814     &    69.8\%      & 89.1\%         \\
 & MobileNet-v2~\cite{sandler2018mobilenetv2}       &   &  3.4 MB  &      300      &    72.0\%      &  \\
 &  ShuffleNet~\cite{Zhang_2018_CVPR}               &   &  5 MB &      524      &    73.7\%      &  \\ \hline\hline
\multirow{4}{*}{\makecell{NAS with\\more than\\100 GPU days}}
 & Progressive NAS~\cite{Liu_2018_ECCV}             & 150  & 5.1 MB   &    588        &    74.2\%      & 91.9\%         \\
 & NASNet-A~\cite{Zoph_2018_CVPR}                   & 2000 & 5.3 MB   &    564        &    74.0\%      & 91.6\%         \\
 & NASNet-B~\cite{Zoph_2018_CVPR}                   & 2000 & 5.3 MB   &    488        &    72.8\%      & 91.3\%         \\
 & NASNet-C~\cite{Zoph_2018_CVPR}                   & 2000 & 4.9 MB   &    558        &    72.5\%      & 91.0\%         \\
\hline\hline
\multirow{8}{*}{\makecell{NAS with\\less than\\5 GPU days}}
 & DARTS~\cite{liu2019darts}                        & 4    & 4.9 MB   &    595        &    73.1\%      & 91.0\%  \\
 & GHN~\cite{zhang2019graph}                        & 0.84 & 6.1 MB   &    569        &    73.0\%      & 91.3\%  \\
 & SNAS~\cite{xie2019snas}                          & 1.5  & 4.3 MB   &    522        &    72.7\%      & 90.8\%  \\
 & GDAS~\cite{dong2019search}                       & 0.84 & 5.3 MB   &    581        &    74.0\%      & 91.5\%  \\ \cline{2-7}
 & {\NAME} (N=1 \& C=73)                            & 1.8  & 5.2 MB   &    597        &    73.3\%      & 91.4\%  \\
 & {\NAME} (N=2 \& C=58)                            & 1.8  & 5.3 MB   &    600        &    74.3\%      & 91.6\%  \\
 & {\NAME} (N=3 \& C=49)                            & 1.8  & 5.3 MB   &    584        &    74.1\%      & 91.9\%  \\
 & {\NAME} (N=4 \& C=44)                            & 1.8  & 5.4 MB   &    599        &    74.3\%      & 92.0\%  \\
\hline
\end{tabular}
\vspace{2mm}
\caption{
We compare networks found by {\NAME} and other approaches on ImageNet.
We report the model size, the computation cost, the top-1 accuracy, and the top-5 accuracy.
The top block shows the manually designed CNNs. The bottom two blocks indicate the automatically design CNNs.
 indicates the number of multiply-add operations.
}
\vspace{-2mm}
\label{table:ImageNet}
\end{table*}



{\bf Comparison with other {\NAME} variants.}
In \Tabref{table:CIFAR}, we compare several variants of {\NAME} introduced in \Secref{sec:discussion}.
{\NAME}-NON is a straightforward approach to optimize the evaluator, however, the model found by {\NAME}-NON leads to the highest error.
{\NAME}-LR finds the model with more parameters but is inferior to the model found by {\NAME}.
In conclusion, the proposed {\NAME} is superior to its baselines, i.e., {\NAME}-LR and {\NAME}-NON.
``{\NAME} (=1)'' indicates that we directly choose the best architecture from the evaluator via  over / as~\cite{liu2019darts}.
From \Tabref{table:CIFAR}, ``{\NAME} (=1)'' finds a small CNN, however, this CNN yields a relatively higher error than our {\NAME}.
Therefore, the stochastic training strategy and the final candidate evaluation strategy are necessary to find a good architecture.





{\bf Scalability.}
We compare the search cost between the small space using the candidate function set  and the large space using another candidate function set .
This set  adds two more functions into : 3x3 dilated conv and 5x5 dilated conv.
It has eight functions in total, and its search space has about 9.110 candidates.
With the large search space, training {\NAME} costs 50 GPU hours using the default hyper-parameters, and evaluating =1K candidates takes less than three hours.
Therefore, even though the large search space is 100 larger than the small one, {\NAME} needs only about 18\% more GPU days to complete the search procedure.
Besides, the network found with  achieves a similar performance compared to that of . This shows that our {\NAME} can be successfully applied to much larger search space.







{\bf Experiments on ImageNet.}
We use the same cell structures found on the CIFAR-10 dataset to construct the CNN for ImageNet.
We adjust hyper-parameters  and  to make the network align with the ImageNet-mobile setting, i.e., under 600M FLOPs.
We train the network with a batch size of 256 over four GPUs in 250 epochs totally.
We warm-up at the first five epochs, start the learning rate with 0.1, and decrease it to 0 via the cosine scheduler~\cite{warmup2017}.
We set the momentum as 0.9 and the weight decay as 3e-5. Besides, the label smoothing is applied with a epsilon of 0.1.
An auxiliary tower with the weight of 0.4 is applied during training.


{\bf Comparison with the state-of-the-art on ImageNet.}
Since the training procedure of {\NAME} does not use any ImageNet images, this experiment can investigate the transfer-ability of the discovered network.
We use the same CNN structure found on CIFAR-10 with different  and  configurations.
These networks strictly matche the ImageNet-mobile setting.
We show the top-1 and top-5 accuracy in \Tabref{table:ImageNet}.
``{\NAME} (N=2 \& C=58)'' achieves a top-1 accuracy of 74.3\% on ImageNet.
Our network obtains competitive accuracy compared to efficient NAS approaches~\cite{liu2019darts,xie2019snas,zhang2019graph}.
AmoebaNet~\cite{real2019regularized} achieves a similar accuracy than ours, but it costs 3150 GPU days, which is 1750 more than ours.
In sum, our network is competitive to state-of-the-art networks, whereas {\NAME} needs acceptable search costs.





\subsection{Ablation Studies}\label{sec:ablation}

In \Secref{sec:comparison}, we deliver a brief comparison between {\NAME} and its variants w.r.t. the model size and the model accuracy.
In this section, we will give a more comprehensive analysis for different aspects of {\NAME}.



\begin{figure}[t!]
\begin{center}
\subfigure[{\NAME}]{
\label{subfig:sts-learn}
\includegraphics[width=0.47\columnwidth]{NAS-VIS-HIST/hist-sts-A.pdf}
}
\subfigure[{\NAME}-RAND]{
\label{subfig:sts-random}
\includegraphics[width=0.47\columnwidth]{NAS-VIS-HIST/hist-random.pdf}
}
\subfigure[{\NAME}-LR]{
\label{subfig:STS-LR}
\includegraphics[width=0.47\columnwidth]{NAS-VIS-HIST/hist-sts-B.pdf}
}
\subfigure[{\NAME}-NON]{
\label{subfig:Non-STS}
\includegraphics[width=0.47\columnwidth]{NAS-VIS-HIST/hist-sts-C.pdf}
}
\end{center}
\vspace{-2mm}
\caption[Captioning]{
Comparison of the candidate networks generated by different strategies.
\ref{subfig:sts-learn} shows the generated candidates from the proposed {\NAME}. \ref{subfig:STS-LR}, \ref{subfig:Non-STS}, and \ref{subfig:sts-random} show statistics of other three {\NAME} variants.
In each sub-figure, the x-axis and y-axis indicate the number of candidate networks and the validation accuracy, respectively.
}
\vspace{-3mm}
\label{fig:random-vs-learn}
\end{figure}



\textbf{The quality of estimated candidates.}
There are four options to generate candidate CNNs.
(a) the proposed {\NAME}. (b) {\NAME}-RAND~\cite{bender2018understanding}. (c) {\NAME}-LR, sharing the sampled indexes of operations and inputs for different cells (d) {\NAME}-NON, directly training the template network in the standard classification fashion as~\cite{liu2019darts}.
We use these four methods to generate 1000 candidate CNN and count their one-shot accuracy in a histogram.
In each sub-figure of \Figref{fig:random-vs-learn}, the x-axis indicates the one-shot validation accuracy and y-axis indicates the number of candidate CNNs.
Several conclusion can be made.
First, randomly generated candidates have much lower accuracy than all other compared strategies.
Second, {\NAME}-NON is better than the random approach but still inferior to {\NAME} and {\NAME}-LR.
Third, the performance of {\NAME} generated candidates is similar to that of {\NAME}-LR. However, taking a close look at the histogram, {\NAME} generate more accurate candidates than {\NAME}-LR, e.g., there are more candidates with the accuracy between 85\%90\%.


\textbf{Can the validation accuracy with template parameters reflect the ground truth validation accuracy?}
We want to investigate whether the validation accuracy using the template parameters can provide a robust relative ranking of different networks or not.
To achieve, we randomly sample 2000 networks, i.e., 1000 pairs.
We first evaluate these 2000 networks by using the template parameters on .
We denote the obtained validation accuracy as \textit{acc}.
Then we retrain these 2000 networks from scratch from scratch by 100 epochs on , and other hyper-parameters are the same as experiments in \Tabref{table:CIFAR}.
We evaluate these re-trained networks on  and denote the accuracy as \textit{acc}, indicating the ground truth accuracy.
For each pair, if the comparison of \textit{acc} is the same with the comparison of \textit{acc}, we count this pair is good; otherwise, we count this pair is bad.
Finally, we obtain more than 80\% pairs are good.


The above two analysis paragraphs did not directly evaluate (1) how good the candidate sampled by the evaluator is and (2) how accurate the one-shot accuracy is.
To answer these two questions, we need a NAS dataset with ground truth accuracy of each candidate, where NAS-Bench-101~\cite{ying2019bench} is the only one.
However, our {\NAME} can not be directly evaluated on NAS-Bench-101~\cite{ying2019bench} due to its limitation.
We would investigate these open questions once a suitable NAS dataset being public.


\textbf{The effect of the number of generated candidates.}
In \Tabref{table:CIFAR}, we show that using =1 finds a model with a higher error than using =1K.
A small number of , e.g., 10, will cause a high variance of the accuracy of discovered CNN.
If we increase the number of , we could reduce the variance. In our experiments, =1K is enough to discover a good network.
If we increase  to 10K, we could potentially find better networks, but the search cost will be more than five GPU days.
Some approaches apply a progressive strategy to select the final CNN~\cite{bender2018understanding,zhang2019graph}.
For example, they first select the top 10 networks (ranked by the validation accuracy) and then retrain these networks with more epochs to get a precise validation accuracy.
These strategies are able to further reduce the performance variance of the discovered CNN.






\textbf{Visualization.}
We visualize the discovered cells in \Figref{fig:visualization}.
Compared to manually designed cells~\cite{he2016deep,szegedy2016rethinking,xie2017aggregated}, the automatically discovered cells are much more complex and difficult to be designed by human experts.
Given the superior performance of NAS-discovered networks, it is necessary to devote more effort on this topic.



\textbf{Discussions.}
One limitation of {\NAME} is that when the search space is very large, e.g., 10 candidates, a small number of  may not be able to find a good model. In this case, we have to increase the number of , which will also increase the corresponding evaluation cost.
A more efficient training strategy for the template network and the evaluator can alleviate this problem.
We leave such interesting extensions for future work.




\begin{figure}[t!]
\begin{center}
\includegraphics[width=\linewidth]{resources/visualization.pdf}
\end{center}
\caption[Captioning]{
The left figure is the normal CNN cell that {\NAME} discovered on CIFAR-10.
The right figure is the reduction CNN cell that {\NAME} discovered on CIFAR-10.
}
\vspace{-2mm}
\label{fig:visualization}
\end{figure}






\section{Conclusion}

We propose the self-evaluated template network ({\NAME}) to search for the CNN with higher accuracy.
Compared to previous one-shot NAS approaches, {\NAME} significantly improves the quality of architecture candidates for the one-shot evaluation procedure. In this way, the sampled candidates of {\NAME} can cover better architectures, and thus can finally find an architecture with higher performance.
In experiments, {\NAME} can complete the search procedure within two GPU days. It finds a good CNN from more than 10 network possibilities, and this CNN achieves state-of-the-art performance on three benchmarks.














{\small
\bibliographystyle{ieee_fullname}
\bibliography{egbib}
}

\end{document}
