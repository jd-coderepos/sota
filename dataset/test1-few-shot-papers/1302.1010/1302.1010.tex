\pdfoutput=1
\documentclass[10pt, conference, compsocconf, final]{IEEEtran}


\usepackage{color}                  \usepackage[english]{babel}         \usepackage{amsfonts}               \usepackage{amssymb}                \usepackage{amsmath}
\usepackage{float}                  \usepackage{listings}
\usepackage{fancyhdr}
\usepackage{amsthm}
\usepackage{algorithmic}
\usepackage[ruled,vlined]{algorithm2e}
\usepackage{cite}
\usepackage{paralist}

\usepackage{pdftricks}
\begin{psinputs}
  \usepackage{multido}
  \usepackage{pst-all}
  \usepackage{pst-grad} \usepackage{pst-plot} \usepackage{epsfig}
\end{psinputs}
\usepackage[anchorcolor=blue,citebordercolor={1 1 1},citecolor=blue,colorlinks=true]{hyperref}
\theoremstyle{definition}
\newtheorem{property}{Property}
\newtheorem{assumption}{Assumption}
\newtheorem{theorem}{Theorem}
\newtheorem{definition}{Definition}
\newtheorem{lemma}{Lemma}
\newtheorem{remark}{Remark}
\newtheorem{exmpl}{Example}
\newtheorem{constraint}{Constraint}
\newtheorem{corollary}{Corollary}
\newtheorem{condition}{Condition}
\newtheorem{proposition}{Proposition}
\usepackage{ifthen} 

\fancypagestyle{temp}{\cfoot{page \thepage\hspace{1pt}}}
\pagestyle{temp}

\abovedisplayskip=5pt
\belowdisplayskip=5pt
\intextsep=2pt
\floatsep=2pt
\setlength{\belowcaptionskip}{-2ex}

\setlength{\intextsep}{0pt}

\setlength{\parskip}{0pt}
\setlength{\parsep}{0pt}
\setlength{\headsep}{0pt}
\setlength{\topskip}{0pt}
\setlength{\topsep}{0pt}


\newcommand{\mode}{public}
\newcommand*{\MyDef}{\mathrm{def}}
\newcommand*{\eqdef}{\ensuremath{\mathop{\overset{\MyDef}{=}}}}
\newcommand*{\nctiw}{{\bar{\texttt{I}}^\texttt{NC}}}
\newcommand*{\citiw}{{\bar{\texttt{I}}^\texttt{CI}}}
\newcommand*{\difftiw}{{\bar{\texttt{I}}^\texttt{DIFF}}}
\newcommand*{\upinter}{\bar{\texttt{I}}}
\newcommand*{\inter}{\texttt{I}}





\newfloat{script}{thp}{lop}

\definecolor{scriptbg}{rgb}{0.9,0.9,0.9}			\definecolor{colKeys}{rgb}{0,0,1}			\definecolor{colIdentifier}{rgb}{0,0,0}			\definecolor{colComments}{rgb}{0,0.5,1}			\definecolor{colString}{rgb}{0.6,0.1,0.1}		

\lstset{float=hbp,basicstyle=\ttfamily\small, columns=flexible, backgroundcolor=\color{scriptbg},
 tabsize=2, frame=single, extendedchars=true, showspaces=false, showstringspaces=true, numbers=left, numberstyle=\tiny, breaklines=true, breakautoindent=true, captionpos=b,xrightmargin=0.5cm, xleftmargin=0.5cm, 					keywordstyle=\color{blue},				extendedchars=false,
    } 							



\lstdefinelanguage{rbacpol}
{
    keywords={subject,role,user},
    sensitive=true,
}

\lstloadlanguages{rbacpol}









\newtheorem{guess}{Property}
\newtheorem{hypothesis}{Hypothesis}

\newcommand{\FIXME}[1]{\colorbox{yellow}{\textcolor{red}{FIXME: #1}}}
\newcommand{\lcm}{\mathrm{lcm}}
\renewcommand{\algorithmicforall}{\textbf{for each}}

\renewcommand{\headrulewidth}{0pt}


\begin{document}

\title{\LARGE
	Improving Mixed-Criticality System Consistency and Behavior on Multiprocessor Platforms by Means of Multi-Moded Approaches
}

\author{Fran\c cois Santy \hspace{40 mm} Geoffrey Nelissen \hspace{40mm} Jo\"el Goossens \
	\tau_i = \{	&\tau_i^{M_1} = \{T_i^{M_1}, D_i^{M_1}, C_i^{M_1}\},... \\
			&\tau_i^{M_\mathnormal{L}} = \{T_i^{M_\mathnormal{L}}, D_i^{M_\mathnormal{L}}, C_i^{M_\mathnormal{L}}\}\}

	\tau_i = \{	\tau_i^{1} &= \{T_i, D_i, C_i(1)\},... \\
			\tau_i^{L_i} &= \{T_i, D_i, C_i(L_i)\}\}	
\label{eq:upperBoundTotIntWorkload}
		\upinter_i(\Delta, \ell) = \sum_{\tau_j\in\texttt{hp}(\tau_i)} \nctiw_{j,i}(\Delta,\ell) + \sum_{\tau_j\in\texttt{hp}_{m-1}(\tau_{i})} \difftiw_{j,i}(\Delta,\ell)
	
		R_i(\ell) = C_i(\ell) + \left\lfloor \dfrac{\upinter_{i}(R_i(\ell), \ell)}{m} \right\rfloor
	\label{eq:case1:step1}
				\inter_{i-1}^*(\Delta,\ell) \leq \sum\limits_{\tau_j\in\texttt{hp}(\tau_{i-1})}\nctiw_{j,i-1}(\Delta,\ell) \\ 
					+ \sum_{\tau_j\in\texttt{hp}_{m-2}(\tau_{i-1})}\difftiw_{j,i-1}(\Delta,\ell)
			\label{eq:case1:step2}
				\inter_{i-1,i}^*(\Delta, \ell) \leq \nctiw_{i-1,i}(\Delta, \ell) + \difftiw_{i-1,i}(\Delta, \ell)
			
				\inter_i^*(\Delta, \ell) \leq \inter_{i-1}^*(\Delta,\ell) + \nctiw_{i,i-1}(\Delta, \ell) + \difftiw_{i,i-1}(\Delta,\ell)
			
				\difftiw_{i,i-1}(\Delta,\ell) + \sum_{\tau_j\in\texttt{hp}_{m-2}(\tau_{i-1})} \difftiw_{j,i-1}(\Delta,\ell) \\
					\leq \sum_{\tau_j\in\texttt{hp}_{m-1}(\tau_{i})} \difftiw_{j,i}(\Delta,\ell)
			\label{eq:case1:step5}
				\inter_i^*(\Delta,\ell) \leq \sum_{\tau_j\in\texttt{hp}(\tau_i)} \nctiw_{j,i}(\Delta,\ell) \\
					+ \sum_{\tau_j\in\texttt{hp}_{m-1}(\tau_{i})} \difftiw_{j,i}(\Delta,\ell) = \upinter_i(\Delta, \ell)
			
				\upinter_{i-1,i}(\Delta,\ell) \leq \nctiw_{i-1,i}(\Delta,\ell)
			\label{eq:step2}
				\inter_i^*(\Delta,\ell) \leq \inter_{i-1}^*(\Delta,\ell) + \nctiw_{i-1,i}(\Delta,\ell)
			\label{eq:step3}
				\inter_i^*(\Delta,\ell) \leq \sum\limits_{\tau_j\in\texttt{hp}(\tau_i)}\nctiw_{j,i}(\Delta,\ell) \\
					+ \sum_{\tau_j\in\texttt{hp}_{m-1}(\tau_{i-1})}\difftiw_{j,i}(\Delta,\ell) 
			\label{eq:step4}
				\sum_{\tau_j\in\texttt{hp}_{m-1}(\tau_{i-1})}\difftiw_{j,i}(\Delta,\ell) \leq \sum_{\tau_j\in\texttt{hp}_{m-1}(\tau_{i})}\difftiw_{j,i}(\Delta,\ell)
			
				\inter_i^*(\Delta,\ell) \leq \sum\limits_{\tau_j\in\texttt{hp}(\tau_i)}\nctiw_{j,i}(\Delta,\ell) \\
					+ \sum_{\tau_j\in\texttt{hp}_{m-1}(\tau_{i})}\difftiw_{j,i}(\ell) = \upinter_i(\Delta,\ell)
			
		Equation~\ref{eq:case2:step5} proves that the actual total interfering workload suffered by  will not exceed , implying that  will complete its execution after no more than  time units.
\end{IEEEproof}

\begin{corollary}\label{corollary:main}
Each job  released by a task  will complete its execution no later than  time units after  in any scenario of criticality level , if every job  released by a task  completes its execution exactly  time units after .
\end{corollary}

From Corollary~\ref{corollary:main}, we propose an alternative increasing transition protocol, that slightly adapts the  scheduler during the transition phase resulting from the triggering of . Upon the completion of a job  released by a task  such that  at time , the scheduler would simulate the availability of  in the interval , thus acting as if  had suffered an interference equal to the upper-bound , and had completed its execution exactly at time . The following theorem proves that this approach will preserve both the ()-periodicity and ()-feasibility.

\begin{theorem}
Upon an , the protocol that simulates the availability of each job  such that  until time , to complete the execution of the rem-jobs of criticality , is a valid increasing transition protocol.
\end{theorem}
\begin{IEEEproof}
This is an immediate consequence of Theorem~\ref{theo:mainTheo}. Indeed, by simulating the availability of each job  released by task  until time , we simulate the upper-bound on the interference suffered by . According to Corollary~\ref{corollary:main}, this will not increase the WCRT of tasks . As a consequence, the proposed increasing transition protocol is valid.
\end{IEEEproof}

\subsubsection{Conclusion and Discussion}~\\
In this section, we have proposed several approaches to handle the transition from criticality level  to criticality level . The proposed approaches have a common goal, as they all allow to reach a compromise between a high safety, which is implied by the high level of pessimism adopted during the offline analysis phase, and an efficient usage of the platform, by recovering the unused resources to execute the less critical tasks during the online phase. In our opinion, this is an important aspect of our work, as it highlights the crucial fact that a high level of assurance does not necessarily imply that resources are doomed to be wasted.\\
Finally, note that the proposed approaches do not assume anything on the execution order of the rem-jobs. We will thus briefly discuss what management policy can be implemented in the case the system switches from operating mode  to operating mode  at time  while some rem-jobs of criticality equal to  are still available. This means that at time , the system has to complete the execution of rem-jobs the criticality of which is less than . In that case, either it is assumed that since their criticality is less than the current criticality of the system, they are all equal in terms of importance, meaning that a global strategy can be applied to complete their execution (complete the rem-jobs with the shortest deadline first, complete the rem-jobs with the shortest remaining processing time first, etc.). Or we can assume that even though the current criticality of the system is higher than their own criticality, the relative importance of the rem-jobs remains the same, meaning it is safer to complete the rem-jobs in decreasing order of criticality level (the rem-jobs with a criticality equal to  have to be completed before the rem-jobs with a criticality equal to ).

\subsection{Handling Decreasing Mode Change Requests}\label{subsec:decreasing}
In our previous work~\cite{Santy:2012:RMS:2354411.2355225}, we focused on \emph{uni}processor platforms, and proved that whenever an idle time was detected, while the system had reached criticality level , it was safe to re-enable \emph{every} task that had previously been suspended. However, the occurrence of a simultaneous idle time on every processors of a multiprocessor platform is unlikely. In this section, we will therefore suggest an alternative approach to re-enable the suspended tasks without relying on the occurrence of idle times. Before going any further, let us introduce the following property, which highlights two important requirements regarding task re-enablement. \\
\begin{property}\label{prop:dmcr:safe}
When the system is switching from operating mode  to operating mode  upon a  at time , the re-enablement of a previously suspended task  belonging to  at time  may be carried out provided that the following two conditions hold:
\begin{compactitem}
	\item[] The re-enablement at time  of task  must not jeopardize the -periodicity and -feasibility of the system;
	\item[] Task  must be guaranteed to meet its deadline from time  onward if no  occurs at a time .
\end{compactitem}
\end{property}
In the rest of this paper, we will say that it is \emph{safe} to re-enable a task  if Property~\ref{prop:dmcr:safe} holds upon the re-enablement of . The way new-mode tasks are re-enabled leads to distinguish two types of protocols.
\begin{definition}[Synchronous/Asynchronous protocol~\cite{Real:2004:MCP:969960.969963}]\label{def:sync:async}
Assuming the system is switching from operating mode  to operating mode , a \emph{synchronous} protocol is a protocol that re-enables each suspended task belonging to operating mode  simultaneously. An \emph{asynchronous} protocol is a protocol that enables every suspended task belonging to operating mode  independently from the others, i.e.\@ some tasks belonging to  might be enabled earlier than others.
\end{definition}
\begin{figure}
	\centering
	\includegraphics[scale=0.39]{DMCR.png}
	\caption{The decreasing mode transition protocol iteratively identifies the time instants  for every task .}\label{figure:dmcr}
\end{figure}
Assuming the system is executing in operating mode , and depending on the set of functionalities the system is willing to re-enable, once the rem-jobs of criticality less than  are completed, a ,  can be triggered. For the sake of clarity, we will assume that no  is triggered during the decreasing mode change (we will shortly discuss this potential event later). We suggest a synchronous protocol, illustrated by Figure \ref{figure:dmcr}, that works as follows: starting at time , the protocol identifies the first job  released by task  that completes its execution at time . From time , the protocol then identifies the first job  released by task  that completes its execution at time . The procedure then keeps on identifying one such job for each task , in order of their priority (i.e.\@ it identifies such a job for task  only when it has previously identified such a job for task ). The re-enablement of the previously suspended tasks having a criticality at least equal to  can then take place when the procedure identifies a job  that completes its execution at time . In the following, we will assume that if the protocol identifies a job  that completes its execution at time , then this means that the procedure has already identified such a job for every tasks .

\begin{lemma}\label{lemma:decreasing:interferingworkload}
Whenever a task  releases a job  that completes its execution at time , and no  is triggered during the mode change, then the actual interfering workload suffered by tasks  from task , from time  onward will be less than or equal to  (resp. ) over any window of length , if  is a carry-in (resp. non carry-in) task for .
\end{lemma}
\begin{proof}
The upper-bound on the interfering workload suffered by task  from task  over an interval of length , in any -interval, is computed assuming  will release jobs that will execute for no more than  time units. However, if no  is triggered, then it must be the case that every job released by task  executes for no more than  time units. Therefore, from  onward, the actual total interfering workload suffered by tasks  from task  will be less than or equal to  (resp. ) over any window of length  if  is a carry-in (resp. non carry-in) task for .
\end{proof}

\begin{lemma}\label{lemma:decreasing:totalInterferingWorkload}
Let us assume the protocol identified a job  that completed its execution at time . From time  onward the actual total interfering workload  suffered by task  over any window of size  will be less than or equal to .
\end{lemma}
\begin{proof}
From Lemma~\ref{lemma:decreasing:interferingworkload}, we know that from time  onward, the actual interfering workload of every task  on  is less than or equal to  or , depending whether  is a carry-in task for  or not. Furthermore, from Equation \ref{eq:upperBoundTotIntWorkload}, we know that an upper-bound on the total interfering workload suffered by task  is given by summing   with the  largest values of . Thus, the actual total interfering workload suffered by  will be less than or equal to .
\end{proof}

\begin{corollary}\label{decreasing:corollaryTotIntWork}
Upon a , when the protocol identifies a job  that completed its execution at time , then from time  onward, the actual total interfering workload suffered by any task  is less than or equal to .
\end{corollary}

From Corollary \ref{decreasing:corollaryTotIntWork}, we will now show that it is safe to re-enable every suspended task  at time .

\begin{lemma}\label{lemma:decreasing:safeNewModeTasks}
Upon a , when protocol identifies a job  that completed its execution at time , then the jobs released by every suspended task  from time  onward will meet their deadlines in any scenario of criticality level at most .
\end{lemma}
\begin{proof}
The WCRT at criticality level  of each task  was computed assuming a total interfering workload of . But from Corollary \ref{decreasing:corollaryTotIntWork}, we know that at time , the actual total interfering workload suffered by any task  in the system is less than or equal to . Since the system was deemed -schedulable, every job released by a task  from time  onward will meet its deadline in any scenario of criticality level at most .
\end{proof}

\begin{lemma}\label{lemma:decreasing:safeOldModeTasks}
Assume the system is executing in operating mode . Upon a , when protocol identifies a job  that completed its execution at time , the re-enablement of every suspended task  will not jeopardize the -periodicity and -feasibility.
\end{lemma}
\begin{proof}
From Corollary \ref{decreasing:corollaryTotIntWork}, we know that at time , the actual total interfering workload suffered by any task  in the system is less than or equal to . However, this upper-bound is computed assuming that \emph{every} task  will release jobs that complete their execution after no more than  time units. Therefore, the actual total interfering workload suffered by any task  upon the re-enablement of every suspended task  will still be less than or equal to . Furthermore, since the system was deemed -schedulable, it follows that every job released by tasks  will meet its deadline in any scenario of criticality up to level . It follows that both the -periodicity and -feasibility are preserved upon the re-enablement of every suspended task .
\end{proof}

\begin{theorem}\label{theo:decreasing:mainResult}
Let us assume the system is executing in operating mode . Upon a , when the protocol identifies a job  that completed its execution at time , it is safe to re-enable the suspended task belonging to the operating mode  at time .
\end{theorem}
\begin{IEEEproof}
To prove this theorem, we have to show that Property \ref{prop:dmcr:safe} holds upon the re-enablement of every suspended task  at time . Lemma \ref{lemma:decreasing:safeNewModeTasks} proved that every suspended task  belonging to the operating mode  could release jobs that would be able to meet their deadline if  was re-enabled at time , and provided that no  was triggered. Furthermore, Lemma \ref{lemma:decreasing:safeOldModeTasks} proved that the re-enablement of every suspended task  belonging to the operating mode  would not jeopardize the -periodicity and -feasibility. It follows that at time , it is safe to re-enable every suspended task belonging to the operating mode .
\end{IEEEproof}
Theorem \ref{theo:decreasing:mainResult} proves that it will eventually be possible to decrease the criticality level of the system, provided the computational demand of the tasks having a criticality higher than or equal to  decreases. It follows that the suspension delay suffered by tasks having a criticality less than  is reduced. In practice however, if an  is triggered during during the  handling, then the procedure that consists in finding the first job  that completes its execution a time  is aborted. Indeed, in that case, we can no longer guarantee that the additional interfering workload generated by tasks having a criticality equal to  will not jeopardize the -periodicity and -feasibility.
\begin{corollary}
Upon a , reenabling every suspended task belonging to operating mode  upon the identification of a job  that completed its execution at time  is a valid decreasing transition protocol.
\end{corollary}

\section{Conclusion}\label{sec:conclusion}
In this work, the first contribution consisted in formalizing mixed-criticality systems in terms of multi-moded systems, thus giving a new outlook to the problem. As a second contribution, we have shown that multi-moded approaches could help solve the consistency problems that arise when less critical tasks are brutally discarded, by enabling for a softer switch from a lower criticality level to a higher one. Finally, as a third contribution, we have highlighted the fact that the behavior of such systems could be greatly enhanced, by proving that task re-enablement was possible without compromising its safety. Those approaches allow to achieve a much more adept usage of the platform, by avoiding to vainly waste computational resources. Future work will concentrate, among other things, on suggesting asynchronous decreasing transition protocols, which allow for a progressive re-enablement of the less critical tasks.

\nocite{*}
\bibliographystyle{IEEEtran}
\bibliography{bibliographie}

\end{document}
