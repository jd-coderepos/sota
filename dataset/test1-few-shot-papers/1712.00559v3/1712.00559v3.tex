

\documentclass[runningheads]{llncs}
\usepackage{graphicx}
\usepackage{amsmath,amssymb} \usepackage{color}


\usepackage{float}
\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage{booktabs}

\usepackage{hyperref}
\usepackage[noabbrev,capitalize,nameinlink]{cleveref}
\usepackage{tablefootnote}

\newcommand{\NAS}{NAS}
\newcommand{\NASRL}{\NAS}
\newcommand{\NAScell}{\NAS}

\newcommand{\eat}[1]{}

\begin{document}

\title{Progressive Neural Architecture Search} 



\titlerunning{Progressive Neural Architecture Search}
\author{Chenxi Liu\inst{1}\thanks{Work done while an intern at Google.} \and
Barret Zoph\inst{2} \and
Maxim Neumann\inst{2} \and
Jonathon Shlens\inst{2} \and
Wei Hua\inst{2} \and 
Li-Jia Li\inst{2} \and 
Li Fei-Fei\inst{2,3} \and 
Alan Yuille\inst{1} \and 
Jonathan Huang\inst{2} \and 
Kevin Murphy\inst{2}
}
\authorrunning{C. Liu et al.}


\institute{Johns Hopkins University \and
Google AI \and 
Stanford University}
\maketitle              \begin{abstract}
We propose a new method for learning the structure of convolutional neural networks (CNNs) that is more efficient than recent state-of-the-art methods based on reinforcement learning and evolutionary algorithms. Our approach uses a sequential model-based optimization (SMBO) strategy, in which we search for structures in order of increasing complexity, while simultaneously learning a surrogate model to guide the search through structure space. Direct comparison under the same search space shows that our method is up to 5 times more efficient than the RL method of Zoph et al. (2018) in terms of number of models evaluated, and 8 times faster in terms of total compute. The structures we discover in this way achieve state of the art classification accuracies on CIFAR-10 and ImageNet.
\end{abstract} 

\section{Introduction}

There has been a lot of recent interest in automatically learning good neural net architectures.
Some of this work is summarized in \cref{sec:related}, but at a high level,
current techniques
usually fall into one of two categories: evolutionary algorithms 
(see e.g. \cite{DBLP:conf/icml/RealMSSSTLK17,Miikkulainen2017,DBLP:journals/corr/XieY17})
or reinforcement learning
(see e.g., \cite{DBLP:journals/corr/ZophL16,DBLP:journals/corr/ZophVSL17,Zhong2018,Cai2017,DBLP:journals/corr/BakerGNR16}).
When using evolutionary algorithms (EA), each neural network structure is encoded as a string, and random mutations and recombinations of the strings are performed during the search process;
each string (model) is then trained and evaluated on a validation set,
and the top performing models generate  ``children''.
When using reinforcement learning (RL),  the agent performs a sequence of actions, which specifies the structure of the model; this model is then trained and its validation performance is returned as the reward, which is used to update the RNN controller.
Although both EA and RL methods have been able to learn network structures that outperform manually designed architectures, they require significant computational resources.
For example, the RL method in
\cite{DBLP:journals/corr/ZophVSL17} 
trains and evaluates 20,000 neural networks across 500 P100 GPUs over 4 days.


In this paper, we describe a method that is able to learn a CNN which matches previous state of the art in terms of accuracy,
while requiring 5 times fewer model evaluations during the architecture search.
Our starting point is the structured search space
proposed by \cite{DBLP:journals/corr/ZophVSL17}, in which the search algorithm is tasked with searching for a good convolutional ``cell'', as opposed to a full CNN.
A cell contains  ``blocks'', where a block is a combination operator (such as addition) applied to two inputs (tensors), each of which can be transformed (e.g., using convolution) before being combined.
This cell structure is then stacked a certain number of times, depending on the size of the training set, and the desired running time of the final CNN
(see \cref{sec:space} for details).
This modular design also allows easy architecture transfer from one dataset to another,
as we will show in experimental results.


We propose to use  heuristic search to search the space of cell structures,
starting with simple (shallow) models and progressing to complex ones, pruning out unpromising structures as we go.
At iteration  of the algorithm, we have a set of  candidate cells (each of size  blocks), which we train and evaluate on a dataset of interest. Since this process is expensive,
we also learn a model or surrogate function which can predict the performance of a structure
without needing to training it.
We expand the  candidates of size  into  children, each of size .
We apply our surrogate function to rank all of the  children,
pick the top , and then train and evaluate them.
We continue in this way until , which is the maximum number of blocks we want to use in our cell.
See \cref{sec:method} for details.

Our progressive (simple to complex) approach has several advantages over other techniques that directly search in the space of fully-specified structures. First, the simple structures train faster, so we get some initial results to train the surrogate quickly. Second, we only ask the surrogate to predict the quality of structures that are slightly different
(larger) from the ones it has seen
(c.f., trust-region methods). 
Third, we factorize the search space into a product of smaller search spaces, 
allowing us to potentially search models with many more blocks.
In \cref{sec:results} we show that our approach 
is 5 times more efficient than the RL method of \cite{DBLP:journals/corr/ZophVSL17} in terms of number of models evaluated, and 8 times faster in terms of total compute.
We also show that the structures we discover achieve state of the art classification accuracies on CIFAR-10 and ImageNet.\footnote{The code and checkpoint for the PNAS model trained on ImageNet can be downloaded from the TensorFlow models repository at \url{http://github.com/tensorflow/models/}. Also see \url{https://github.com/chenxi116/PNASNet.TF} and \url{https://github.com/chenxi116/PNASNet.pytorch} for author's reimplementation.}
 
\section{Related Work}
\label{sec:related}

Our paper is based on the ``neural architecture search'' (NAS) method proposed in
\cite{DBLP:journals/corr/ZophL16,DBLP:journals/corr/ZophVSL17}.
In the original paper  \cite{DBLP:journals/corr/ZophL16},
they
use the REINFORCE algorithm \cite{Williams92} to estimate the parameters of a
recurrent neural network (RNN),
which represents a policy to generate a sequence of symbols (actions) specifying the structure of the CNN; the reward function is the classification accuracy on the validation set of a CNN generated from this sequence.
\cite{DBLP:journals/corr/ZophVSL17} extended this by using a more structured search space,
in which the CNN was defined in terms of a series of stacked ``cells''.
(They also replaced  REINFORCE with 
proximal policy optimization (PPO) \cite{PPO}.)
This method was able to learn CNNs which outperformed almost all previous methods
in terms of accuracy vs speed on image classification (using
CIFAR-10 \cite{krizhevsky2009learning} and ImageNet \cite{DBLP:conf/cvpr/DengDSLL009})
and object detection (using COCO \cite{DBLP:conf/eccv/LinMBHPRDZ14}).

There are several other papers that use RL to learn network structures.
\cite{Zhong2018}  use the same model search space as \NAScell,  but replace policy gradient with Q-learning.
\cite{DBLP:journals/corr/BakerGNR16} also use Q-learning, but without exploiting cell structure.
\cite{Cai2017} use policy gradient to train an RNN, but the actions are now to widen an existing layer, or to deepen the network by adding an extra layer. This requires specifying an initial model and then gradually learning how to transform it.
The same approach, of applying ``network morphisms'' to modify a network,
was used in 
\cite{Elsken2017}, but in the context of hill climbing search, rather than RL.
\cite{ENAS} use parameter sharing among child models to substantially accelerate the search process.


An alternative  to RL is to use evolutionary algorithms (EA; ``neuro-evolution'' \cite{Stanley2017}).
Early work
(e.g., \cite{Stanley2002})
used EA to learn both the structure and the parameters of the network,
but more recent methods,
such as \cite{DBLP:conf/icml/RealMSSSTLK17,Miikkulainen2017,DBLP:journals/corr/XieY17,Liu2017,DBLP:journals/corr/abs-1802-01548},
just use EA to search the structures, and use SGD to estimate the parameters.


RL and EA are local search methods that search through the space of fully-specified graph structures. An alternative approach, which we adopt, is to use heuristic search, in which we search through the space of structures in a progressive way, from simple to complex.
There are several pieces of prior work that explore this approach.
\cite{Negrinho2017} use Monte Carlo Tree Search (MCTS),
but at each node in the search tree, it uses random selection to choose which branch to expand,
which is very inefficient.
Sequential Model Based Optimization (SMBO) \cite{Hutter2011} improves on MCTS by learning a predictive model, which can be used to decide which nodes to expand.
This technique has been applied to neural net structure search in
\cite{Negrinho2017},
but they used a flat CNN search space, rather than our hierarchical cell-based space.
Consequently, their resulting CNNs do not perform very well.
Other related works include
\cite{Mendoza2016}, who focus on MLP rather than CNNs;
\cite{Stanley2002}, who used an incremental approach in the context of evolutionary algorithms; \cite{DBLP:journals/corr/ZophL16} who used a schedule of increasing number of layers;
and \cite{Grosse2012} who 
search through the space of latent factor models specified by a grammar.
Finally, \cite{Cortes2016,Huang2017boosting} grow CNNs sequentially using boosting.


Several other papers learn a surrogate function to predict the performance of a candidate structure, either ``zero shot'' (without training it)
(see e.g., \cite{SMASH}),
or after training it for a small number of epochs and extrapolating the learning curve
(see e.g.,  \cite{Domhan2015,Baker2017acc}).
However, most of these methods have been applied to fixed sized structures, and would not work with our progressive search approach.
 
\section{Architecture Search Space}
\label{sec:search}
\label{sec:space}


In this section we describe the neural network architecture search space used in our work.
We build on the hierarchical approach
proposed in  \cite{DBLP:journals/corr/ZophVSL17},
in which we first learn a cell structure, and then stack this cell a desired number of times,
in order to create the final CNN.

\subsection{Cell Topologies}

A cell is a fully convolutional network
that maps an  tensor
to another  tensor.
If we use stride 1 convolution, then  and ;
if we use stride 2, then  and .
We employ a common heuristic to double the number of filters (feature maps)
whenever the spatial activation is halved,
so  for stride 1, and  for stride 2.

The cell can be represented 
by a DAG consisting of  blocks. Each block is a mapping from 2 input
tensors to 1 output tensor.
We can specify a block  in a cell  as a 5-tuple,
,
where
 specifies the 
inputs to the block,
 specifies the operation to apply to input ,
and  specifies how to combine  and  to generate the feature map (tensor) corresponding to  the output of this block,
which we denote by .

The set of possible inputs,
 , is the
set of all previous blocks in this cell,
,
plus the output of the previous cell,
,
plus the output of the previous-previous cell,
.


The operator space  
is the following set of 8 functions, each of which
operates on a single tensor\footnote{The depthwise-separable convolutions are in fact two repetitions of ReLU-SepConv-BatchNorm; 1x1 convolutions are also inserted when tensor sizes mismatch.}:

\begin{minipage}{0.5\textwidth}
\renewcommand\labelitemi{}
\footnotesize
\bigbreak
\begin{itemize}
\item 3x3 depthwise-separable convolution
\item 5x5 depthwise-separable convolution
\item 7x7 depthwise-separable convolution
\item 1x7 followed by 7x1 convolution
\end{itemize}
\bigbreak
\end{minipage}
\begin{minipage}{0.5\textwidth}
\renewcommand\labelitemi{}
\footnotesize
\bigbreak
\begin{itemize}
\item identity
\item 3x3 average pooling
\item 3x3 max pooling
\item 3x3 dilated convolution
\end{itemize}
\bigbreak
\end{minipage}
This is less than the 13 operators used in \cite{DBLP:journals/corr/ZophVSL17},
since 
we removed the ones that their RL method discovered were never used.
 
For the space of possible combination operators ,
 \cite{DBLP:journals/corr/ZophVSL17} considerd both
 elementwise addition and concatenation.
However, they discovered that the RL method never chose to use concatenation,
so to reduce our search space, we always use addition as the combination operator.
Thus in our work, a block can be specified by a 4-tuple.


We now quantify the size of the search space to highlight the magnitude of the search problem. 
Let the space of possible structures for the 'th block
be ;
this has size
,
where 
,
 and .
For , we have 
,
which 
are the final outputs of the previous two cells,
so there are  possible block structures. 


If we allow cells of up to  blocks,
the total number of cell structures
is given by
. 
However, there are certain symmetries in this space that allow us to prune it
to a more reasonable size.
For example, there are only 136 unique cells composed of 1 block.
The total number of unique cells is .
This is much smaller than the search space used in 
 \cite{DBLP:journals/corr/ZophVSL17}, which has size
 ,
but it is still an extremely large space to search, and requires efficient 
optimization methods.



\subsection{From Cell to CNN}

\begin{figure}[t]
\centering
\includegraphics[width=0.5\textwidth]{figs/PNASNet-5-new-shrink.pdf}
\qquad
\includegraphics[width=0.3\textwidth]{figs/PNASNet-high-level-shrink2.pdf}
\caption{
\emph{Left}: 
The best cell structure found by our Progressive Neural Architecture Search, consisting of 5 blocks.
\emph{Right}:
We employ a similar strategy as \cite{DBLP:journals/corr/ZophVSL17} when constructing CNNs from cells on CIFAR-10 and ImageNet. 
Note that we learn a single cell type instead of distinguishing between Normal and Reduction cell.
}
\label{fig:network}
\end{figure}

To evaluate a cell, we have to convert it into a CNN.
To do this, 
we stack a predefined number of copies of the basic cell (with the same structure, but untied weights),
using either stride 1 or stride 2, as shown in 
Figure~\ref{fig:network} (right). 
The number of stride-1 cells between stride-2 cells is then adjusted accordingly with up to  number of repeats.
At the top of the network, we use global average pooling, followed by a softmax classification layer.
We then train the stacked model on the relevant dataset.

In the case of CIFAR-10, we use  images.
In the case of ImageNet, we consider two settings,
one with high resolution images of size ,
and one with smaller images of size .
The latter results in less accurate models, but they are faster.
For ImageNet,
we also add an initial  convolutional filter layer  with stride 2 at the start of the network, to further reduce the cost.

The overall CNN construction process is identical to  \cite{DBLP:journals/corr/ZophVSL17},
except we only use one cell type (we do not distinguish between Normal and Reduction cells, but instead emulate a Reduction cell by using a Normal cell with stride 2),
and the cell search space is slightly smaller (since we use fewer operators and combiners). 
\section{Method}
\label{sec:methods}
\label{sec:method}

\subsection{Progressive Neural Architecture Search}
\label{sec:pnas}


\begin{algorithm}[t]
\begin{algorithmic}
\STATE {\bfseries Inputs:}
 (max num blocks),
 (max num epochs),
 (num filters in first layer),
 (beam size),
 (num times to unroll cell),
trainSet,
valSet.
\STATE  =  // {\it Set of candidate structures with one block}
\STATE  = cell-to-CNN(, , ) // {\it Construct CNNs from cell specifications}
\STATE  = train-CNN(, , trainSet) //  {\it Train proxy CNNs}
\STATE  = eval-CNN(, valSet) //  {\it Validation accuracies}
\STATE  = fit(,  // {\it Train the reward predictor from scratch}
\FOR{}
\STATE  = expand-cell() // {\it Expand current candidate cells by one more block}
\STATE  = predict(, ) // {\it Predict accuracies using reward predictor}
\STATE  = top-K(, , ) // {\it Most promising cells according to prediction}
\STATE  = cell-to-CNN(, , )
\STATE  = train-CNN(, , trainSet) 
\STATE  = eval-CNN(, valSet) 
\STATE  = update-predictor(, , ) // {\it Finetune reward predictor with new data}
\ENDFOR
\STATE Return top-K(, , 1) 
\end{algorithmic}
\caption{Progressive Neural Architecture Search (PNAS).
}
\label{alg:pnas}
\end{algorithm}


\begin{figure}[t]
    \centering
    \begin{minipage}[c]{0.49\textwidth}
    \includegraphics[width=\textwidth]{figs/expand-and-shrink}
    \end{minipage} \hfill
    \begin{minipage}[c]{0.5\textwidth}
    \caption{Illustration of the PNAS search procedure when the maximum number of blocks is .
    Here  represents the set of candidate cells with  blocks.
    We start by considering all cells with 1 block, ;
    we train and evaluate all of these cells, and update the predictor.
    At iteration 2, we expand each of the cells in  
    to get all cells with 2 blocks, ;
    we predict their scores, pick the top  to get ,
    train and evaluate them, and update the predictor.
    At iteration 3, we expand each of the cells in ,  to get a subset of cells with 3 blocks,
    ;
     we predict their scores, pick the top  to get , train and evaluate them,
     and return the winner.
  is the number of possible blocks at level 
    and  is the beam size (number of models we
    train and evaluate per level of the search tree).
    }
    \label{fig:PNAStree}
    \end{minipage}
\end{figure}


Many previous approaches directly search in the space of full cells,
or worse,
full CNNs.
For example, \NAScell\ uses a 50-step RNN\footnote{5 symbols per block, times 5 blocks, times 2 for Normal and Reduction cells.
} as a controller to generate cell specifications.
In \cite{DBLP:journals/corr/XieY17} a fixed-length binary string encoding of CNN architecture is defined and used in model evolution/mutation.
While this is a more direct approach, we argue that it is difficult to directly navigate in an exponentially large search space, especially at the beginning where there is no knowledge of what makes a good model.

As an alternative, we propose to search the space in a progressive order,
simplest models first.
In particular, we start by constructing all possible cell structures 
from  (i.e., composed of 1 block),
and add them to a queue.
We train and evaluate all the models in the queue (in parallel),
and then expand each one by
adding all of the possible  block structures from ;
this gives us a set of
 candidate cells of depth 2.
Since 
we cannot afford to 
train and evaluate  all of these child networks,
 we refer to a learned predictor function
(described in \cref{sec:surrogate});
it is trained based on the measured performance of the cells we have visited so far.
(Our predictor takes negligible time to train and apply.)
We then use the predictor to evaluate all the candidate cells,
and pick the  most promising ones.
We add these to the queue, and repeat the process,
until we find cells with a sufficient number  of blocks.
See \cref{alg:pnas} for the pseudocode,
and \cref{fig:PNAStree} for an illustration.


\subsection{Performance Prediction with Surrogate Model}
\label{sec:surrogate}


As explained above, we need a mechanism to predict the final
performance of a cell before we actually train it.
There are at least three desired properties of such a predictor:
\begin{itemize}
    \item \textit{Handle variable-sized inputs}: We need the predictor to work for variable-length input strings.
    In particular, it should be able to predict the performance of any cell with  blocks, even if it has only been trained on cells with up to  blocks.
    


  \item \textit{Correlated with  true performance}: we do not necessarily need to achieve low mean squared error, but we do want the predictor to rank models in roughly the same order as their true performance values.
 
    
    \item \textit{Sample efficiency}: We want to train and evaluate as few cells as possible, which means the training data for the predictor will be scarce. 
\end{itemize}

The requirement that the predictor be able to handle variable-sized strings 
immediately suggests the use of an RNN, and indeed this is one of the methods we try.
In particular, we use an LSTM that reads a sequence of length 
(representing , ,  and  for each block), and the input at each step is a one-hot vector of size  or , followed by embedding lookup.
We use a shared embedding of dimension  for the tokens ,
and another shared embedding for .
The final LSTM hidden state goes through a fully-connected layer and sigmoid to regress the validation accuracy. 
We also try a simpler MLP baseline in which we convert the cell to a fixed length vector as follows:
we embed each token into an -dimensional vector,
concatenate the embeddings for each block to get an -dimensional vector,
and then average over blocks.
Both models are trained using  loss.


When training the predictor,
one approach is to
update the parameters of the predictor using the new data
using a few steps of SGD.
However, since the sample size is very small, we fit
an ensemble of 5 predictors, each fit (from scratch)
to 4/5 of all the data available at each step of the search process.
We observed empirically that this reduced the variance of the predictions.


In the future, we plan to investigate other kinds of predictors,
such as Gaussian processes with string kernels (see e.g., \cite{Baisero2015}),
which may be more sample efficient to train and produce predictions with uncertainty estimates.
 
\section{Experiments and Results}
\label{sec:results}

\subsection{Experimental Details}

Our  experimental setting follows \cite{DBLP:journals/corr/ZophVSL17}.
In particular, we conduct most of our experiments on CIFAR-10 \cite{krizhevsky2009learning}.
CIFAR-10  has 50,000 training images and 10,000 test images.
We use 5000 images from the training set as a validation set.
All images are whitened, and  patches are cropped from images upsampled to .
Random horizontal flip is also used.
After finding a good model on CIFAR-10, we evaluate its quality on
ImageNet classification in \cref{sec:imagenet}.


For the MLP accuracy predictor, the embedding size is 100,
and we use 2 fully connected layers, each with 100 hidden units.
For the RNN accuracy predictor, we use an LSTM, 
and the hidden state size and embedding size are both 100.
The embeddings use uniform initialization in range [-0.1, 0.1].
The bias term in the final fully connected layer is initialized to 1.8 (0.86 after sigmoid) to account for the mean observed accuracy of all  models.
We use the Adam optimizer \cite{DBLP:journals/corr/KingmaB14} with learning rate 0.01 for the  level and 0.002 for all following levels.


Our training procedure for the CNNs follows the one used in
 \cite{DBLP:journals/corr/ZophVSL17}.
 During the search we evaluate  networks at each stage
 (136 for stage 1, since there are only 136 unique cells with 1 block),
we use a maximum cell depth of  blocks,
we use   filters in the first convolutional cell,
we unroll the cells for  times,
and each child network is trained for 20 epochs using initial learning rate of 0.01 with cosine decay \cite{DBLP:journals/corr/LoshchilovH16a}.
 
\subsection{Performance of the Surrogate Predictors}
\label{sec:predictor}

In this section, we compare the performance of different surrogate predictors.
Note that at step  of PNAS, we train the predictor
on the observed performance of cells with up to  blocks,
but we apply it to cells with  blocks.
We therefore consider predictive accuracy both for cells with sizes that have been seen before
(but which have not been trained on),
and for cells which are one block larger than the training data.


\newcommand{\loss}[1]{L(#1)}
\newcommand{\acc}[1]{A(#1)}

\begin{algorithm}[b]
\begin{algorithmic}
\FOR{}
\FOR{}
\STATE  = random sample of  models from 
\STATE  = fit(, ) // {\it Train or finetune predictor}
\STATE  = predict(, ) // {\it Predict on same }
\STATE  = predict(, ) // {\it Predict on next }
\ENDFOR
\ENDFOR
\end{algorithmic}
\caption{Evaluating performance of a predictor  on a random dataset.
}
\label{alg:pred}
\end{algorithm}


More precisely, let  be a set of randomly chosen cells with  blocks,
where .
(For , there are only 136 unique cells.)
We convert each of these to CNNs, and  train them for  epochs.
(Thus in total we train  models for 20 epochs each.)
We now use this random dataset to evaluate the performance of the predictors
using the pseudocode in \cref{alg:pred},
where  returns the true validation set accuracies of the models in some set .
In particular, for each size , and for each trial  (we use ),
we do the following:
randomly select  models (each of size )  from  to generate
a training set ;
fit the predictor on the training set;
evaluate the predictor on the training set;
and finally 
evaluate the predictor on the set of all unseen random models of size .


\begin{figure}[t]
\centering
\includegraphics[width=0.9\linewidth]{figs/scatter_plot_mlp_plus.png}
\caption{Accuracy of MLP-ensemble predictor.
Top row: true vs predicted accuracies on models from the training set over different trials.
Bottom row:  true vs predicted accuracies on models from the set of all unseen larger models. Denoted is the mean rank correlation from individual trials.
}
\label{fig:MLP}
\end{figure}


\begin{table}[t]
\begin{center}
\begin{tabular}{l|cc|cc|cc|cc|}
\toprule
&
\multicolumn{2}{|c|}{}
&
\multicolumn{2}{|c|}{}
&
\multicolumn{2}{|c|}{}
&
\multicolumn{2}{|c|}{}
\\
Method
&  & 
&  & 
&  & 
&  & 
\\
\midrule
MLP & 0.938 & 0.113 & 0.857 & 0.450 & 0.714 & 0.469 & 0.641 & 0.444 \\
RNN & 0.970 & {\bf 0.198} & {\bf 0.996} & 0.424 & 0.693 & 0.401 & {\bf 0.787} & 0.413 \\
MLP-ensemble & 
{\bf 0.975} & 0.164 & 0.786 & {\bf 0.532} & 0.634 & {\bf 0.504} & 0.645 & {\bf 0.468} \\
RNN-ensemble &
0.972 & 0.164 & 0.906 & 0.418 & {\bf 0.801} & 0.465 & 0.579 & 0.424 \\
\bottomrule
\end{tabular}
\end{center}
\caption{Spearman rank correlations of different predictors
on the training set, ,
and when extrapolating to unseen larger models,
.
See text for details.
}
\label{tab:spearman}
\end{table}

The top row of \cref{fig:MLP} shows a scatterplot of
the true accuracies of the models in the training sets, ,
vs the predicted accuracies,
 (so there are  points in each plot,
at least for ).
The bottom row plots 
the true accuracies on the set of larger models,
,
vs the predicted accuracies
 (so there are K points in each plot).
We see that the predictor performs well on models from the training set,
but not so well when predicting larger models.
However, performance does increase as the predictor is trained on 
more (and larger) cells.

\cref{fig:MLP} shows the results
using an ensemble of MLPs.
The scatter plots for the other predictors look similar.
We can summarize each scatterplot using the Spearman rank correlation coefficient.
Let   = rank-correlation(,  )
and
  = rank-correlation(,  ).
\cref{tab:spearman} summarizes these statistics across different levels.
We  see that for predicting the training set, the RNN does better than the MLP,
but for predicting the performance on unseen larger models
(which is the setting we care about in practice),
the MLP seems to do slightly better.
This will be corroborated by our end-to-end test in \cref{sec:efficiency}, and is likely due to overfitting.
We also see that for the extrapolation task, ensembling seems to help.

 
\subsection{Search Efficiency}
\label{sec:efficiency}


\begin{figure}[t]
    \centering
    \includegraphics[width=0.65\linewidth]{figs/mlp_nas_rand_with_arrow}
\caption{
    Comparing the relative efficiency of NAS,  PNAS and random search under the same search space.
    We plot mean accuracy (across 5 trials) on CIFAR-10 validation set of the top
     models, for , found by each method
    vs number of models which are trained and evaluated.
    Each model is trained for 20 epochs.
    Error bars and the colored regions denote standard deviation of the mean.
    }
    \label{fig:efficiency}
\end{figure}


In this section, we compare the efficiency of PNAS to two other methods:
random search and the \NAScell\ method.
To perform the comparison,
we run PNAS for ,
and at each iteration , we record the set   of  models of size 
that it picks,
and evaluate them on the CIFAR-10 validation set (after training for 20 epochs each).
We then compute the validation accuracy of the top  models
for .
To capture the variance in performance of a given model due to randomness of
the parameter initialization and optimization procedure, we repeat this process 5 times.
We plot the mean and standard error of this statistic in \cref{fig:efficiency}.
We see that the mean performance of the top  models steadily increases, as we search
for larger models.
Furthermore, performance is better when using an MLP-ensemble (shown in \cref{fig:efficiency})
instead of an RNN-ensemble (see supplementary material),
which is consistent with
\cref{tab:spearman}.

For our random search baseline, we uniformly sample 6000 cells of size  blocks from
the random set of models 
described in \cref{sec:predictor}.
 \cref{fig:efficiency} shows that PNAS significantly outperforms this baseline.

Finally, we compare to \NASRL.
Each trial sequentially searches 6000 cells of size  blocks.
At each iteration , we define  to be the set of all cells visited so far
by the RL agent. We compute the 
validation accuracy of the top   models in , and
plot the mean and standard error of this statistic in \cref{fig:efficiency}.
We see that the mean performance  steadily increases, but at a slower rate than PNAS.

To quantify the speedup factor compared to \NASRL,
we compute the number of models that are trained and evaluated until
the mean performance of PNAS and \NASRL\ are equal
(note that PNAS produces models of size 
after evaluating
  models, which is  1160 for ).
The results are shown in
\cref{tab:speedup}.
We see that PNAS is up to 5 times faster in terms of the number of models
it trains and evaluates.


\begin{table}[t]
    \begin{center}
    \begin{tabular}{l|r|c|c|c|c|c}
    \toprule
     & Top & Accuracy & \;PNAS & \;\NASRL\ & Speedup ( models) & Speedup ( examples) \\ 
    \midrule
    5 & 1 & 0.9183 & 1160 & 5808 & 5.0 & 8.2 \\
    5 & 5 & 0.9161 & 1160 & 4100 & 3.5 & 6.8 \\
    5 & 25 & 0.9136 & 1160 & 3654 & 3.2 & 6.4 \\ 
\bottomrule
    \end{tabular}
    \end{center}
    \caption{Relative efficiency of PNAS (using MLP-ensemble predictor) and NAS under the same search space.
     is the size of the cell, 
    ``Top'' is the number of top models we pick,
    ``Accuracy'' is their average validation accuracy,
    `` PNAS'' is the number of models evaluated by PNAS,
    `` NAS'' is the number of models evaluated by NAS to achieve the desired accuracy.
Speedup measured by number of examples is greater than speedup in terms of number of models, because NAS has an additional reranking stage, that trains the top 250 models for 300 epochs each before picking the best one.
    }
    \label{tab:speedup}
\end{table}

Comparing the number of models explored during architecture search is one measure of efficiency.
However, some methods, such as NAS, employ a secondary reranking stage to determine the best model; PNAS does not perform a reranking stage but uses the top model from the search directly. 
A more fair comparison is therefore to count the total number of examples processed through SGD throughout the search.
Let  be the number of models trained during search,
and let  be the number of examples used to train each model.\footnote{The number of examples is equal to the number of SGD steps
times the batch size.
Alternatively, it can be measured in terms of number of epoch (passes through the data),
but since different papers use different sized training sets, we avoid this measure.
In either case, we assume the number of examples is the same for every model, since none of the methods
we evaluate use early stopping.
} The total number of examples is therefore .
However, for methods with the additional reranking stage,
the top  models from the search procedure are trained using  examples each, before returning the best.
This results in a total cost of 
.
For NAS and PNAS, 
 K for NAS and PNAS since they use 20 epochs on a training set of size 45K.
The number of models searched to achieve equal top-1 accuracy is
 for PNAS and  for NAS.
For the second stage, NAS trains the top  models for 
 epochs before picking the best.\footnote{This additional stage is quite important for NAS, as the NASNet-A cell was originally ranked 70th among the top 250.
}
Thus we see  that PNAS is about 8 times faster than NAS when taking into account the total cost.


\newcommand{\MPNAS}{1160} 
\newcommand{\MNAS}{20000} 
\newcommand{\MNAStwo}{250}
\newcommand{\MEA}{7000} 

\newcommand{\EPNAS}{} \newcommand{\ENAS}{} \newcommand{\ENAStwo}{} \newcommand{\EEA}{} 

\newcommand{\numPNAS}{}
\newcommand{\numNAS}{}
\newcommand{\numEA}{}




\newcommand{\ShlensEPNAS}{M} \newcommand{\ShlensENAS}{M} \newcommand{\ShlensENAStwo}{M} \newcommand{\ShlensEEA}{M} 


\newcommand{\ShlensnumPNAS}{B}
\newcommand{\ShlensnumNAS}{B}
\newcommand{\ShlensnumEA}{B}

 
\subsection{Results on CIFAR-10 Image Classification}
\label{sec:cifar}


\begin{table}[t]
\begin{center}
\begin{tabular}{l c c c|c c|c c c c c}
\toprule
Model &  &  &  & Error & Params &  &  &  &  & Cost
\\
\midrule
NASNet-A \cite{DBLP:journals/corr/ZophVSL17} & 5 & 6 & 32 & 3.41 & 3.3M & 20000 & 0.9M & 250 & 13.5M & 21.4-29.3B
\\
NASNet-B \cite{DBLP:journals/corr/ZophVSL17} & 5 & 4 & N/A & 3.73 & 2.6M & 20000 & 0.9M & 250 & 13.5M & 21.4-29.3B
\\
NASNet-C \cite{DBLP:journals/corr/ZophVSL17} & 5 & 4 & N/A  & 3.59 & 3.1M & 20000 & 0.9M & 250 & 13.5M & 21.4-29.3B
\\
\midrule
Hier-EA \cite{Liu2017} & 5 & 2 & 64 &  3.750.12 & 15.7M & 7000 & 5.12M & 0 & 0 & 35.8B\tablefootnote{In Hierarchical EA, the search phase trains 7K models (each for 4 times to reduce variance) for 5000 steps of batch size 256. Thus, the total computational cost is 7K  5000  256  4 = 35.8B. }  \\
AmoebaNet-B \cite{DBLP:journals/corr/abs-1802-01548} & 5 & 6 & 36 & 3.370.04 & 2.8M & 27000 & 2.25M & 100 & 27M & 63.5B\tablefootnote{The total computational cost for AmoebaNet consists of an architecture search and a reranking phase. The architecture search phase trains over 27K models each for 50 epochs. Each epoch consists of 45K examples. The reranking phase searches over 100 models each trained for 600 epochs. Thus, the architecture search is 27K  50  45K = 60.8B examples. The reranking phase consists of 100  600  45K = 2.7B examples. The total computational cost is 60.8B + 2.7B = 63.5B.} \\
AmoebaNet-A \cite{DBLP:journals/corr/abs-1802-01548} & 5 & 6 & 36 & 3.340.06 & 3.2M & 20000 & 1.13M & 100 & 27M & 25.2B\tablefootnote{The search phase trains 20K models each for 25 epochs. The rest of the computation is the same as AmoebaNet-B.} \\
\midrule
PNASNet-5 & 5 & 3 & 48  & 3.410.09 & 3.2M & 1160 & 0.9M & 0 & 0 & 1.0B  \\
\bottomrule
\end{tabular}
\end{center}
\caption{Performance of different CNNs on CIFAR test set.
All model comparisons employ a comparable number of parameters and exclude cutout data augmentation \cite{Cutout}. 
``Error'' is the top-1 misclassification rate on the CIFAR-10 test set.
(Error rates have the form ,
where  is the average over multiple trials and  is the standard deviation. In PNAS we use 15 trials.)
``Params'' is the  number of model parameters.
``Cost'' is the total number of examples processed through SGD () before the architecture search terminates.
The number of filters  for NASNet-\{B, C\} cannot be determined (hence N/A), and the actual ,  may be larger than the values in this table (hence the range in cost),
according to the original authors.
}
\label{tab:resultsWithTimes}
\end{table}


We now discuss the performance of our final model,
and compare it to the results of other methods in the literature.
Let PNASNet-5 denote the best CNN we discovered on CIFAR using PNAS, also visualized in \cref{fig:network} (left).
After we have selected the cell structure,
we try various  and  values such that the number of model parameters is around 3M,
train them each for 300 epochs using initial learning rate of 0.025 with cosine decay,
and pick the best combination based on the validation set.
Using this best combination of  and , we train it for
600 epochs on the union of training set and validation set.
During training we also used auxiliary classifier located at 2/3 of the maximum depth weighted by 0.4, and drop each path with probability 0.4 for regularization.

The results are shown in \cref{tab:resultsWithTimes}.
We see that PNAS can find a model with the same accuracy as NAS,
but using 21 times less compute.
PNAS also outperforms the Hierarchical EA method of \cite{Liu2017}, while using 36 times less compute.
Though the the EA method called ``AmoebaNets''
\cite{DBLP:journals/corr/abs-1802-01548}
currently give the highest accuracies (at the time of writing),
it also requires the most compute, taking 63 times more resources than PNAS.
However, these comparisons must be taken with a grain of salt, 
since the methods are searching through different spaces.
By contrast, in \cref{sec:efficiency}, we fix the search space for NAS and PNAS,
to make the speedup comparison fair.

 
\subsection{Results on ImageNet Image Classification}
\label{sec:imagenet}

We further demonstrate the usefulness of our learned cell by applying it to ImageNet classification.
Our experiments reveal that CIFAR accuracy and ImageNet accuracy are strongly correlated (; see supplementary material).

To compare the performance of PNASNet-5 
to the results in other papers,
we conduct experiments under two settings:
\begin{itemize}
    \item \textit{Mobile}: Here we restrain the representation power of the CNN.
    Input image size is , and the number of multiply-add operations is under 600M.
    \item \textit{Large}: Here we compare PNASNet-5 against the state-of-the-art models on ImageNet.
    Input image size is .
\end{itemize}


In both experiments we use RMSProp optimizer, label smoothing of 0.1, auxiliary classifier located at 2/3 of the maximum depth weighted by 0.4, weight decay of 4e-5,
and dropout of 0.5 in the final softmax layer.
In the \textit{Mobile} setting, we use distributed synchronous SGD with 50 P100 workers.
On each worker, batch size is 32, initial learning rate is 0.04, and is decayed every 2.2 epochs with rate 0.97.
In the \textit{Large} setting, we use 100 P100 workers.
On each worker, batch size is 16, initial learning rate is 0.015, and is decayed every 2.4 epochs with rate 0.97.
During training, we drop each path with probability 0.4.



The results of the \textit{Mobile} setting are summarized in \cref{tab:imagenet-mobile}.
PNASNet-5 achieves slightly better performance than NASNet-A (74.2\% top-1 accuracy for PNAS vs 74.0\% for NASNet-A).
Both methods significantly surpass
the previous state-of-the-art,
which includes the manually
designed MobileNet \cite{DBLP:journals/corr/HowardZCKWWAA17} (70.6\%)
and ShuffleNet \cite{DBLP:journals/corr/ZhangZLS17} (70.9\%).
AmoebaNet-C performs the best, but note that this is a different model than their best-performing CIFAR-10 model.
\cref{tab:imagenet-large} shows that under the \textit{Large} setting, PNASNet-5 achieves higher performance (82.9\% top-1; 96.2\% top-5) than previous state-of-the-art approaches,
including SENet \cite{DBLP:journals/corr/abs-1709-01507}, NASNet-A, and AmoebaNets under the same model capacity.

\begin{table}[t]
\begin{center}
\begin{tabular}{lcccc}
    \toprule
         Model &  Params & Mult-Adds & Top-1 & Top-5 \\
        \midrule
        MobileNet-224 \cite{DBLP:journals/corr/HowardZCKWWAA17} & 4.2M & 569M & 70.6 & 89.5 \\
        ShuffleNet (2x) \cite{DBLP:journals/corr/ZhangZLS17} & 5M & 524M & 70.9 & 89.8 \\
        \midrule
        NASNet-A (, )
        \cite{DBLP:journals/corr/ZophVSL17} & 5.3M & 564M & 74.0 & 91.6 \\
        AmoebaNet-B (, ) \cite{DBLP:journals/corr/abs-1802-01548} & 5.3M & 555M & 74.0 & 91.5 \\
        AmoebaNet-A (, ) \cite{DBLP:journals/corr/abs-1802-01548} & 5.1M & 555M & 74.5 & 92.0 \\
AmoebaNet-C (, ) \cite{DBLP:journals/corr/abs-1802-01548} & 6.4M & 570M & 75.7 & 92.4 \\
        \midrule
        PNASNet-5 (, ) & 5.1M & 588M & 74.2 & 91.9 \\
    \bottomrule
    \end{tabular}
\end{center}
\caption{ImageNet classification results in the \textit{Mobile} setting.
}
\label{tab:imagenet-mobile}
\end{table}
\begin{table}[t]
\begin{center}
    \begin{tabular}{lccccc}
    \toprule
        Model & Image Size & Params & Mult-Adds & Top-1 & Top-5 \\
        \midrule
        ResNeXt-101 (64x4d) \cite{DBLP:journals/corr/XieGDTH16} &  & 83.6M & 31.5B & 80.9 & 95.6\\
        PolyNet \cite{DBLP:journals/corr/ZhangLLL16} &  & 92M & 34.7B & 81.3 & 95.8\\
        Dual-Path-Net-131 \cite{DBLP:journals/corr/ChenLXJYF17} &  & 79.5M & 32.0B & 81.5 & 95.8\\
        Squeeze-Excite-Net \cite{DBLP:journals/corr/abs-1709-01507} &  & 145.8M & 42.3B & 82.7 & 96.2\\
        \midrule
        NASNet-A (, ) \cite{DBLP:journals/corr/ZophVSL17} &  & 88.9M & 23.8B & 82.7 & 96.2\\
        AmoebaNet-B (, ) \cite{DBLP:journals/corr/abs-1802-01548} &  & 84.0M & 22.3B & 82.3 & 96.1 \\
        AmoebaNet-A (, ) \cite{DBLP:journals/corr/abs-1802-01548} &  & 86.7M & 23.1B & 82.8 & 96.1 \\
AmoebaNet-C (, ) \cite{DBLP:journals/corr/abs-1802-01548} &  & 155.3M & 41.1B & 83.1 & 96.3 \\
        \midrule
        PNASNet-5 (, ) &  & 86.1M & 25.0B & 82.9 & 96.2 \\
    \bottomrule
    \end{tabular}
\end{center}
\caption{ImageNet classification results in the \textit{Large} setting.}
\label{tab:imagenet-large}
\end{table}
  
\section{Discussion and Future Work}
\label{sec:discuss}

The main contribution of this work is to show how we can accelerate the search for good CNN structures by using progressive search through the space of increasingly complex graphs, combined with a learned prediction function to efficiently identify the most promising models to explore.
The resulting models achieve the same level of performance as previous work but with a fraction of the computational cost.



There are many possible directions for future work,
including:
the use of better surrogate predictors,
such as Gaussian processes with string kernels;
the use of model-based early stopping,
such as 
\cite{Baker2017acc},
so we can stop the training of ``unpromising'' models before reaching  epochs;
the use of ``warm starting'', to initialize the training of a larger -sized model
 from its smaller parent;
 the use of Bayesian optimization,
in which we use an acquisition function,
such as expected improvement or upper confidence bound,
to rank the candidate models, rather than greedily picking the top 
(see e.g., \cite{Snoek2012,Shahriari2016});
adaptively varying the number of models  evaluated at each step (e.g., reducing it over time);
the automatic exploration of speed-accuracy tradeoffs (cf., \cite{PPPnet}),
etc.



 
\clearpage
\section*{Acknowledgements}
We thank Quoc Le for inspiration, discussion and support; George Dahl for many fruitful discussions; Gabriel Bender, Vijay Vasudevan for the development of much of the critical infrastructure and the larger Google Brain team for the support and discussions. CL also thanks Lingxi Xie for support.


\bibliographystyle{splncs04}
\bibliography{pnas}


\clearpage
\title{Progressive Neural Architecture Search (Supplementary Material)} 



\titlerunning{Progressive Neural Architecture Search}
\author{Chenxi Liu\inst{1}\thanks{Work done while an intern at Google.} \and
Barret Zoph\inst{2} \and
Maxim Neumann\inst{2} \and
Jonathon Shlens\inst{2} \and
Wei Hua\inst{2} \and 
Li-Jia Li\inst{2} \and 
Li Fei-Fei\inst{2,3} \and 
Alan Yuille\inst{1} \and 
Jonathan Huang\inst{2} \and 
Kevin Murphy\inst{2}
}
\authorrunning{C. Liu et al.}


\institute{Johns Hopkins University \and
Google AI \and 
Stanford University}
\maketitle              \appendix

\section{Search Efficiency of PNAS with RNN-ensemble}

In \cref{sec:efficiency} of the paper, we focused on the performance of MLP-ensemble as the surrogate model.
Here we provide analysis of RNN-ensemble as well.

\begin{figure}[h]
\centering
\includegraphics[width=0.65\textwidth]{figs/rnn_nas_rand_with}
\caption{Comparing the relative efficiency of PNAS (using RNN-ensemble) with NAS and random search under the same search space.}
\label{fig:efficiency-appendix}
\end{figure}

\begin{table}[H]
    \begin{center}
    \begin{tabular}{l|r|c|c|c|c|c}
    \toprule
     & Top & Accuracy & \;PNAS & \;NAS & Speedup ( models) & Speedup ( examples) \\ 
    \midrule
    5 & 1 & 0.9161 & 1160 & 2222 & 1.9 & 5.1 \\
    5 & 5 & 0.9148 & 1160 & 2489 & 2.1 & 5.4 \\
    5 & 25 & 0.9128 & 1160 & 2886 & 2.5 & 5.7 \\ 
    \bottomrule
    \end{tabular}
    \end{center}
    \caption{Relative efficiency of PNAS (using RNN-ensemble predictor) and NAS under the same search space.
}
    \label{tab:speedup-appendix}
\end{table}

Again, each method is repeated 5 times to reduce the randomness in neural architecture search, and both performance mean and the variance are plotted in \cref{fig:efficiency-appendix}.
A more quantitative breakdown is given in \cref{tab:speedup-appendix}.
We see that PNAS with RNN-ensemble is about twice as efficient than NAS in terms of number of models trained and evaluated, and five times as efficient by the number of examples.
Speedup measured by number of examples is greater than speedup in terms of number of models, because NAS has an additional reranking stage, that trains the top 250 models for 300 epochs each before picking the best one.



\section{Searching Cells with More Blocks}

Using the MLP-ensemble predictor, we tried to continue the progressive search beyond cells with 5 blocks, all the way till .
The result of this experiment is visualized in \cref{fig:b10}, which extends \cref{fig:efficiency} of the main paper.
As can be seen, PNAS is able to find good performing models over the much larger search spaces of . Note that the unconstrained search space size increases by about 4 orders of magnitude for every  level, reaching  possible model configurations at . This is one of the main advantages of PNAS, to examine a highly focused search space of arbitrary size progressively.
Notice that the NAS curve for comparison is still for , and if we search cells with more blocks using NAS, this curve is likely to go down, because of the growth in search space.

\begin{figure}[h]
\centering 
\includegraphics[width=0.65\textwidth]{figs/mlp_b10}
\caption{Running PNAS (using MLP-ensemble) from cells with 1 block to cells with 10 blocks.}
\label{fig:b10}
\end{figure}

\section{Intermediate Level PNASNet Models}

Our Progressive Neural Architecture Search algorithm explores cells from simple to complex by growing the number of blocks.
We choose , and indeed the best model found in the final level (PNASNet-5; visualized in the left plot of \cref{fig:network}) demonstrates state-of-the-art performance.
In this section, however, we are interested in the best models found in smaller, intermediate levels, namely .
We call these models PNASNet-\{1, 2, 3, 4\}.

\begin{figure}[h]
\centering
\includegraphics[height=0.36\textwidth]{figs/PNASNet-1-new-short}
\includegraphics[height=0.36\textwidth]{figs/PNASNet-2-new-short}
\includegraphics[height=0.36\textwidth]{figs/PNASNet-3-new-short}
\includegraphics[height=0.36\textwidth]{figs/PNASNet-4-new-short}
\caption{Cell structures used in PNASNet-\{1, 2, 3, 4\}.}
\label{fig:pnasnets}
\end{figure}

\begin{table}[h!]
\begin{center}
\begin{tabular}{l c c c|c c|c c c c c}
\toprule
Model &  &  &  & Error & Params &  &  &  &  & Cost
\\
\midrule
PNASNet-4 & 4 & 4 & 44 &  3.500.10 & 3.0M & 904 & 0.9M & 0 & 0 & 0.8B \\
PNASNet-3 & 3 & 6 & 32  & 3.700.12 & 1.8M & 648 & 0.9M & 0 & 0 & 0.6B \\
PNASNet-2 & 2 & 6 & 32 & 3.730.09 & 1.7M & 392 & 0.9M & 0 & 0 & 0.4B \\
PNASNet-1 & 1 & 6 & 44  & 4.010.11 & 1.6M & 136 & 0.9M & 0 & 0 & 0.2B \\
\bottomrule
\end{tabular}
\end{center}
\caption{Image classification performance on CIFAR test set.
``Error'' is the top-1 misclassification rate on the CIFAR-10 test set.
(Error rates have the form ,
where  is the average over multiple trials and  is the standard deviation. In PNAS we use 15 trials.)
``Params'' is the  number of model parameters.
``Cost'' is the total number of examples processed through SGD () before the architecture search terminates.}
\label{tab:cifar}
\end{table}

We visualize their cell structures in \cref{fig:pnasnets}, and report their performances on CIFAR-10 in \cref{tab:cifar}.
We see that the test set error rate decreases as we progress from  to , and the performances of these PNASNets with smaller number of blocks are still competitive.

\section{Transferring from CIFAR-10 to ImageNet}

\cref{fig:cifar-vs-imagenet} shows that the accuracy on CIFAR-10 (even for models which are only trained for 20 epochs) is strongly correlated with the accuracy on ImageNet, which proves that searching for models using CIFAR-10 accuracy as a fast proxy for ImageNet accuracy is a reasonable thing to do.


\begin{figure}[H]
    \centering
    \includegraphics[height=0.5\textwidth]{figs/mobilenet3_current_20180313.png}
    \caption{
    Relationship between performance on CIFAR-10 and ImageNet for different neural network architectures. The high rank correlation of 0.727 (top-1) suggests that the best architecture searched on CIFAR-10 is general and transferable to other datasets.
(Note, however, that rank correlation for the higher-value points (with CIFAR score above 0.89)
    is a bit lower: 0.505 for top-1, and 0.460 for top-5.)
    }
    \label{fig:cifar-vs-imagenet}
\end{figure} 
\end{document}
