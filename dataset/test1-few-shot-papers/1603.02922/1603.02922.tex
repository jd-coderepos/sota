For our proofs about transformer \wpsymbol, we observe that ``''
endows the set of unbounded expectations \UEX with the structure of an upper
--cpo\footnote{Given a binary relation  over a set , we say
  that  is an \emph{upper (resp.\ lower) -cpo} if  is
  reflexive, transitive and antisymmetric, and every increasing -chain
  \chain{a}{\leq} (resp.\ decreasing -chain \chain{a}{\geq}) in  has
  a supremum  (resp.\ an infimum ) in .}, where the
supremum of an increasing --chain  is given
pointwise, \ie . Likewise,
``'' endows the set of bounded expectations \BEX with the structure of
a lower --cpo, where the infimum of a decreasing --chain
 is given pointwise, \ie
. Upper --cpo 
has as botom element the constant expectation , while lower
--cpo  has as top element the constant expectation
. 

In what follows, we usually refer to the set of upper continuous expectation
transformers\footnote{A function  between two upper (resp.\
  lower) -cpos  and  is \emph{upper}
  (resp. \emph{lower}) \emph{continuous} iff for every increasing -chain
   (resp.\ decreasing -chain ),
   (resp.\ ).}
over  and the set of lower continuous expectation transformers
over . We use  and  to
denote such sets.





\subsection{Basic Properties of the --Transformer}
\label{app:basicproperties}



\begin{proof}[Proof of Continuity]
We prove continuity by induction on the program structure.
Let  and 
For the base cases we have:
\paragraph{:}

\paragraph{:}

\paragraph{:}

For the induction hypothesis we assume that for any two programs  and  continuity holds.
Then we can perform the induction step:
\paragraph{:}

\paragraph{:}

\paragraph{:}

\paragraph{:}

Since  is call--free for every  and we have already proven continuity for all call--free programs, we have

for every  and hence

\end{proof}



\begin{proof}[Proof of Monotonicity]
Assume . Then

which implies .
\end{proof}



\begin{proof}[Proof of Linearity]
We prove linearity by induction on the program structure.
For the base cases we have:
\paragraph{:}
\abovedisplayskip=-1\baselineskip
\normalsize
\paragraph{:}

\paragraph{:}
\abovedisplayskip=-1\baselineskip

\normalsize
For the induction hypothesis we assume that for any two programs  and  linearity holds.
Then we can perform the induction step:
\paragraph{:}

\paragraph{:}

\paragraph{:}

\paragraph{:}
\abovedisplayskip=-1\baselineskip

\normalsize
Since  is call--free for every  and we have already proven linearity for all call--free programs, we have

for every  and hence
\belowdisplayskip=-1\baselineskip
\normalsize
\end{proof}





\begin{proof}[Proof of Preservation of  and ]
We prove preservation of  and  by induction on the program structure.
For the base cases we have:
\paragraph{:}

\paragraph{:}

\paragraph{:}

For the induction hypothesis we assume that for any two programs  and  preservation of  and  holds.
Then we can perform the induction step:
\paragraph{:}

\paragraph{:}

\paragraph{:}

\paragraph{:}

Since  is call--free for every  and we have already proven preservation of  and  for all call--free programs, we have

for every  and hence

\end{proof}




\subsection{Fixed Point Characterization of Recursive Procedures}
\label{sec:app-fixed-point-sem}


Establishing the results from \autoref{thm:fp-rec} requires a subsidiary
result connecting  with  in the presence of
non--recursive procedure calls.
\begin{lemma}
\label{thm:wp-ewp}
 For every command  and closed command ,

\end{lemma}
\begin{proof}
  By induction on the structure of . Except for procedure calls, the proof
  for all other program constructs follows immediately from de definition of
  ,  and the inductive hypotheses in the case of
  compound instructions. For the case of procedure calls, the proof relies on
  the fact that as  is a closed command,
   for all . Concretely, we reason as follows:
2pt]
= & \qquad \by{def.~}\displaybreak[0]\2pt]
= & \qquad \by{sup.\ of a constant sequence}\displaybreak[0]\2pt]
= & \qquad \by{observation above}\displaybreak[0]\6pt]
= & \qquad \by{}\6pt]
= & \qquad \by{def.~\wp{\cdot}}\displaybreak[0]\-\normalbaselineskip]\tag*{\qedhere}

\wpd{\Call{\PName}}{\decl} \:=\: \lfpsymbol_{\sqsubseteq} \, \Bigl(\underbrace{\lambda \theta\!:\!\SEnv \mydot
\ewp{\decl(\PName)}{\theta}}_F \Bigr)~.

\lfp{\sqsubseteq}{F} \:=\: \sup\nolimits_n F^n(\bot_\SEnv)~,

\forall f\colon\! \UEX \mydot F^n(\bot_\SEnv)(f) \:=\: \wp{\Calln{\PName}{n}{\decl}}\!(f) 

\wpd{\Call{\PName}}{\decl}\!(f) \:=\: \sup\nolimits_{n}
\wp{\Calln{\PName}{n}{\decl}}\!(f) \\ 
\:=\: \sup\nolimits_n F^n(\bot_\SEnv) (f) \:=\: \lfp{\sqsubseteq}{F} (f)~.

F^0(\bot_\SEnv)(f) \:=\: \bot_\SEnv (f) \:=\: \CteFun{0} \\
=\: \wp{\Abort}(f) \:=\: \wp{\Calln{\PName}{0}{\decl}}\!(f)~.

\begin{array}{c@{\:\:} l@{} }
& F^{n+1}(\bot_\SEnv)(f) \displaybreak[0]\2pt]
& F \bigl(F^{n}(\bot_\SEnv) \bigr) (f) \displaybreak[0]\2pt]
& \ewp{\decl(\PName)}{F^{n}(\bot_\SEnv)} \!(f)\displaybreak[0]\2pt]
& \ewp{\decl(\PName)}{\wp{\Calln{\PName}{n}{\decl}}} \!(f)\displaybreak[0]\2pt]
& \wpd{\decl(\PName)}{\PName \triangleright \Calln{\PName}{n}{\decl}}\!(f)\displaybreak[0]\2pt]
& \wp{\decl(\PName)
 \subst{\Call{\PName}}{\Calln{\PName}{n}{\decl}}}\!(f)\displaybreak[0]\2pt]
& \wp{\Calln{\PName}{n+1}{\decl}}\!(f) \displaybreak[0]\

Now we turn to the fixed point characterization 

The proof follows a dual argument. We first apply Kleene's Fixed Point Theorem
to show that

where  is the constantly
 environment. Next we show by induction on  that

The proof concludes combining these two results since




\begin{lemma}
\label{thm:diag-sup-cpo}
\textnormal{\cite[p.~127]{Winskel:1993}}
 Suppose  are elements of upper -cpo 
  with the property that  whenever  and . Then,

\end{lemma}

\begin{lemma}[Monotone Sequence Theorem]
\label{thm:MST}
If  is a monotonic increasing sequence in a closed interval
, then the supremum 
coincides with . Dually, if  is a
monotonic decreasing sequence in a closed interval
, the infimum  coincides with
.
\end{lemma}


\subsection{Soundness of \wllpsymbol Rules}
\label{sec:app-om-rule-sound}

\begin{fact}
\label{fact:deriv-elim}
To carry on the proofs we use the fact that from 

it follows that for all environment ,

\end{fact}

We provide detailed proofs for rules \lrule{wp-rec} and \lrule{wp-rec};
the proof of rules \lrule{wlp-rec} and \lrule{wlp-rec} follows a dual
argument.

\medskip
\noindent \textbf{Soundness of rule \lrule{wp-rec}.} 
Since by definition,
  ,
  to establish the conclusion of the rule it suffices to show that

which we do by induction on . The base case is immediate since
 and . For the
inductive case, we reason as follows:

\belowdisplayskip=0pt
2pt]
\Leftrightarrow & \wp{\decl(\PName)
 \subst{\Call{\PName}}{\Calln{\PName}{n}{\decl}}}\!(f) \preceq g &
                                                       \by{\autoref{thm:subst-env}
                                                                   }\displaybreak[0]\2pt]
\Leftarrow & \wpd{\Call{\PName}}
   {\PName \, \triangleright \, \Calln{\PName}{n}{\decl}}
   \!(f) \preceq g & \by{\autoref{thm:subst-env}}\displaybreak[0]\2pt]
\Leftrightarrow & \wp{\Calln{\PName}{n}{\decl}}\!(f) \preceq g &
                                                                  \by{I.H.} 
\end{array}

\begin{array}{c@{\:\:} l@{} }
& l_{n+1} \preceq \wp{\Calln{\PName}{n+1}{\decl}}\!(f) \preceq u_{n+1} \displaybreak[0]\2pt]
& l_{n+1} \preceq  \wp{\decl(\PName)
 \subst{\Call{\PName}}{\Calln{\PName}{n}{\decl}}}\!(f) \preceq u_{n+1}\displaybreak[0]\2pt]
& l_{n+1} \preceq \wpd{\decl(\PName)}
  {\PName \, \triangleright \, \Calln{\PName}{n}{\decl}}
  \!(f) \preceq u_{n+1}\displaybreak[0]\2pt]
& l_{n} \preceq \wpd{\Call{\PName}}
   {\PName \, \triangleright \, \Calln{\PName}{n}{\decl}}
   \!(f) \preceq u_{n}\displaybreak[0]\2pt]
& l_{n} \preceq  \wp{ \Call{\PName}
  \subst{\Call{\PName}}{\Calln{\PName}{n}{\decl}}}\!(f) \preceq u_{n}\displaybreak[0]\2pt]
& l_{n} \preceq  \wp{\Calln{\PName}{n}{\decl}}\!(f) \preceq u_{n}\displaybreak[0]\2pt]
& \true
\end{array} \



\subsection{Substitution of Procedure Calls}
\label{sec:subst}

\begin{figure}[h]
\scalebox{0.87}{
}
\caption{Syntactic replacement of procedure calls.}
\label{fig:command-subst}
\end{figure}


\begin{lemma} 
\label{thm:subst-env}
  For every command  and closed command ,

\end{lemma}
\begin{proof}
  By induction on the structure of . Except for procedure calls, the proof
  for all other program constructs follows from de definition of
   and some simple calculations (and the inductive hypotheses in the case
  of compound instructions). For the case of procedure calls, the proof relies
  on the fact that as  is a closed command,
   for all . Concretely, we reason as follows:
2pt]
= & \qquad \by{def.~subst.}\displaybreak[0]\2pt]
= & \qquad \by{sup.\ of a constant sequence}\displaybreak[0]\2pt]
= & \qquad \by{observation above}\displaybreak[0]\6pt]
= & \qquad \by{}\6pt]
= & \qquad \by{def.~\wp{\cdot}}\displaybreak[0]\-\normalbaselineskip]\tag*{\qedhere}
1.5pt]
\Ass{x}{E}  & f\!\subst{x}{E} \1.5pt]
\Cond{G}{c_1}{c_2}  & 
    \ToExp{G} \cdot \ewp{c_1}{\theta} (f) + \ToExp{\lnot G} \cdot \ewp{c_2}{\theta}
    (f) \3pt]
\Call{\PName} &  \theta(f) \10pt]
\specialrule{0.8pt}{0pt}{2pt}
\boldsymbol{c} & \boldsymbol{\ewlp{c}{\theta}(f)}\\
\specialrule{0.8pt}{2pt}{6pt}
\Abort & \CteFun{1} \
  \ewp{c}{(\cdot)} &\colon (\SEnv, \sqsubseteq) \To
  (\SEnv, \sqsubseteq) \\
\ewlp{c}{(\cdot)} &\colon (\LSEnv, \sqsubseteq) \To
  (\LSEnv, \sqsubseteq)

  \ewp{c}{(\cdot)} &\colon \ucont{(\SEnv, \sqsubseteq)}{(\SEnv, \sqsubseteq)}\\
\ewlp{c}{(\cdot)} &\colon \lcont{(\LSEnv, \sqsubseteq)}{(\LSEnv, \sqsubseteq)}

  \ewp{c}{\theta} (\sup\nolimits_n f_n) \:=\: \sup\nolimits_n \,
  \ewp{c}{\theta} \!(f_n)~.
  
  \ewlp{c}{\theta} (\inf\nolimits_n f_n) \:=\: \inf\nolimits_n \,
  \ewlp{c}{\theta} \!(f_n)~.
  
\begin{array}{c@{\:\:} l@{} }
& \ewp{\Call{\PName}}{\theta} (\sup\nolimits_n  f_n) \2pt]
& \theta \, (\sup\nolimits_n  f_n)\displaybreak[0]\2pt]
& \sup\nolimits_n \, \theta (f_n) \displaybreak[0]\2pt]
& \sup\nolimits_n \, \ewp{\Call{\PName}}{\theta} \!(f_n)~.
\end{array}

	\ewlp{\Call{\PName}}{\theta} (\inf\nolimits_n  f_n) ~=~ \inf\nolimits_n \ewlp{\Call{\PName}}{\theta} (f_n)

  \ewp{c}{\sup\nolimits_n \theta_n} \:=\: \sup\nolimits_n
  \ewp{c}{\theta_n}~.
  
   \ewlp{c}{\inf\nolimits_n \theta_n} \:=\: \inf\nolimits_n
  \ewlp{c}{\theta_n}~.
  
\begin{array}{c@{\:\:} l@{} }
& \ewp{\Call{\PName}}{\sup\nolimits_n \theta_n} \!(f) \2pt]
& (\sup\nolimits_n \theta_n) (f)\displaybreak[0]\2pt]
& \sup\nolimits_n \theta_n(f) \displaybreak[0]\2pt]
& \sup\nolimits_n \ewp{\Call{\PName}}{\theta_n} \!(f)~.
\end{array}

\begin{array}{c@{\:\:} l@{} }
& \ewp{c_1;\, c_2}{\sup\nolimits_n \theta_n} \!(f)\displaybreak[0]\2pt]
& \ewp{c_1}{\sup\nolimits_m \theta_m} \!\bigl(\ewp{c_2}{\sup\nolimits_n \theta_n}\!(f)
   \bigr)\displaybreak[0]\2pt]
& \ewp{c_1}{\sup\nolimits_m \theta_m} \!\bigl(\sup\nolimits_n \ewp{c_2}{\theta_n}\!(f)
   \bigr)\displaybreak[0]\2pt]
& \sup\nolimits_n \ewp{c_1}{\sup\nolimits_m \theta_m} \!\bigl(\ewp{c_2}{\theta_n}\!(f)
   \bigr)\displaybreak[0]\2pt]
& \sup\nolimits_n \sup\nolimits_m \ewp{c_1}{\theta_m} \!\bigl(\ewp{c_2}{\theta_n}\!(f)
   \bigr)\displaybreak[0]\2pt]
& \sup\nolimits_i \ewp{c_1}{\theta_i} \!\bigl(\ewp{c_2}{\theta_i}\!(f)
   \bigr)\displaybreak[0]\2pt]
& \sup\nolimits_i \ewp{c_1;\, c_2}{\theta_i} \!(f)
\end{array}

\ewp{c_1}{\theta_m} \!\bigl(\ewp{c_2}{\theta_n}\!(f)
   \bigr) \preceq \ewp{c_1}{\theta_{m'}} \!\bigl(\ewp{c_2}{\theta_{n'}}\!(f)
   \bigr)

\ewp{c_1}{\theta_m} \!\bigl(\ewp{c_2}{\theta_n}\!(f)
   \bigr) \preceq \ewp{c_1}{\theta_{m}} \!\bigl(\ewp{c_2}{\theta_{n'}}\!(f)
   \bigr) \label{eq:1}\\
\ewp{c_1}{\theta_m} \!\bigl(\ewp{c_2}{\theta_{n'}}\!(f)
   \bigr) \preceq \ewp{c_1}{\theta_{m'}} \!\bigl(\ewp{c_2}{\theta_{n'}}\!(f)
   \bigr) \label{eq:2}

\begin{array}{c@{\:\:} l@{} }
& \ewp{\Call{\Cond{G}{c_1}{c_2}}}{\sup\nolimits_n \theta_n} \!(f) \2pt]
& 
\ToExp{G} \cdot \ewp{c_1}{\sup\nolimits_n \theta_n} (f) + \ToExp{\lnot G} \cdot
  \ewp{c_2}{\sup\nolimits_n \theta_n}(f) \displaybreak[0]\2pt]
& 
\ToExp{G} \cdot \sup\nolimits_n \ewp{c_1}{\theta_n} (f) + \ToExp{\lnot G} \cdot
  \sup\nolimits_n \ewp{c_2}{\theta_n}(f) \displaybreak[0]\2pt]
& \ToExp{G} \cdot \lim\limits_{n \To \infty} \ewp{c_1}{\theta_n} (f) + \ToExp{\lnot G} \cdot
  \lim\limits_{n \To \infty} \ewp{c_2}{\theta_n}(f) \2pt]
& \lim\limits_{n \To \infty} \bigl( \ToExp{G} \cdot \ewp{c_1}{\theta_n} (f) +
  \ToExp{\lnot G} \cdot \ewp{c_2}{\theta_n}(f) \bigr) \displaybreak[0]\2pt]
& \sup_n \bigl( \ToExp{G} \cdot \ewp{c_1}{\theta_n} (f) +
  \ToExp{\lnot G} \cdot \ewp{c_2}{\theta_n}(f) \bigr) \displaybreak[0]\2pt]
& \sup\nolimits_n \ewp{\Call{\Cond{G}{c_1}{c_2}}}{\theta_n}
\end{array}

  \eeet{c}{\sup\nolimits_n \eta_n} \:=\: \sup\nolimits_n
  \eeet{c}{\eta_n}~.
  
\eetd{\Call{\PName}}{\decl} \:=\: \sup\nolimits_n F^n(\bot_\RtEnv)~,

\rt_1 - \rt_0 \succeq k \cdot (\CteFun{1}
{-} f) + \CteFun{\Delta}

\eta_1(\rt_1) - \eta_0(\rt_0) \succeq  k \cdot \bigl(\CteFun{1}
- \theta(f)\bigr) + \CteFun{\Delta}

\rt_1 - \rt_0 \succeq k \cdot (\CteFun{1}
{-} f) + \CteFun{\Delta}

\eeet{c}{\eta_1} \!(\rt_1) - \eeet{c}{\eta_0} \!(\rt_0) \succeq  k \cdot \bigl(\CteFun{1}
- \ewp{c}{\theta} \!(f) \bigr) + \CteFun{\Delta}

\begin{array}{c@{\:\:} l@{}}
& \eeet{\Skip}{\eta_1}\!(\rt_1) - \eeet{\Skip}{\eta_0}\!(\rt_0)\displaybreak[0]\2pt]
\Leftrightarrow & \qquad \by{def.~of , }\displaybreak[0]\2pt]
\Leftarrow & \qquad \by{hypothesis}\displaybreak[0]\


\medskip
\noindent \emph{Assignment:}
2pt]
& \succeq k \cdot \bigl(\CteFun{1}
- \ewp{\Ass{x}{E}}{\theta} \!(f) \bigr) + \CteFun{\Delta} \displaybreak[0]\2pt]
& (\CteFun{1} + \rt_1)\subst{x}{E} - (\CteFun{1} + \rt_0)\subst{x}{E} \succeq k \cdot \bigl(\CteFun{1}
- f\subst{x}{E} \bigr) + \CteFun{\Delta} \displaybreak[0]\2pt]
& (\rt_1 - \rt_0)\subst{x}{E} \succeq \bigl( k \cdot (\CteFun{1}
{-} f) + \CteFun{\Delta}\bigr) \subst{x}{E} \displaybreak[0]\2pt]
& \true
\end{array}

\begin{array}{c@{\:\:} l@{} }
& \eeet{\Call{\PName}}{\eta_1}\!(\rt_1) - \eeet{\Call{\PName}}{\eta_0}\!(\rt_0)\displaybreak[0]\2pt]
\Leftrightarrow & \qquad \by{def.~of , }\displaybreak[0]\2pt]
\Leftarrow & \qquad \by{ is
--\emph{expanding}}\displaybreak[0]\2pt]
\Leftarrow & \qquad \by{hypothesis}\displaybreak[0]\


\medskip
\noindent \emph{Probabilistic Choice:} 
2pt]
& \succeq k \cdot \bigl(\CteFun{1}
- \ewp{\PChoice{c_1}{p}{c_2}}{\theta} \!(f) \bigr) + \CteFun{\Delta} \displaybreak[0]\2pt]
& p \cdot  \bigl(  \eeet{c_1}{\eta_1}\!(\rt_1)  - \eeet{c_1}{\eta_0}\!(\rt_0)
  \bigr) \displaybreak[0]\2pt]
& \succeq k \cdot \bigl(\CteFun{1}
- \bigl( p \cdot \ewp{c_1}{\theta}\!(f) + (1{-}p) \cdot \ewp{c_2}{\theta}\!(f)
  \bigr) \bigr) + \CteFun{\Delta} \displaybreak[0]\2pt]
& p \cdot  \bigl( k \cdot \bigl(\CteFun{1}
- \ewp{c_1}{\theta} \!(f) \bigr) + \CteFun{\Delta}
  \bigr) \displaybreak[0]\2pt]
& \succeq k \cdot \bigl(\CteFun{1}
- \bigl( p \cdot \ewp{c_1}{\theta}\!(f) + (1{-}p) \cdot \ewp{c_1}{\theta}\!(f)
  \bigr) \bigr) + \CteFun{\Delta} \displaybreak[0]\2pt]
& \true
\end{array}

\begin{array}{c@{\:\:} l@{} }
& \eeet{c_1;c_2}{\eta_1}\!(\rt_1) - \eeet{c_1;c_2}{\eta_0}\!(\rt_0)\displaybreak[0]\2pt]
\Leftrightarrow & \qquad \by{def.~of , }\displaybreak[0]\2pt]
& \succeq k \cdot \bigl(\CteFun{1}
- \ewp{c_1}{\theta} \bigl( \ewp{c_2}{\theta}\!(f) \bigr) \bigr) + \CteFun{\Delta} \displaybreak[0]\2pt]
& \eeet{c_2}{\eta_1} \!(\rt_1)  -
  \eeet{c_2}{\eta_0} \!(\rt_0)  \succeq k \cdot \bigl(\CteFun{1}
- \ewp{c_2}{\theta}\!(f) \bigr) + \CteFun{\Delta} \displaybreak[0]\2pt]
& \rt_1 - \rt_0 \succeq k \cdot (\CteFun{1}
{-} f) + \CteFun{\Delta} \displaybreak[0]\2pt]
& \true
\end{array}\

\end{proof}

\begin{lemma} \label{thm:ert-call-div}
 Let \PName be an --free procedure with declaration . Then for
 every runtime ,

\end{lemma}
\begin{proof}
  Let .  Since by
  \autoref{thm:eet-proc-call-iter},
  , the result follows
  from showing that for all ,
  
To establish this, we first prove by induction on  that whenever ,

and then conclude using a telescopic sum argument as follows:

For the inductive proof we reason as follows. For the base case we have
2pt]
\Leftrightarrow & \qquad \by{def.~of , }\displaybreak[0]\2pt]
\Leftrightarrow & \qquad \by{def.~of }\displaybreak[0]\2pt]
\Leftarrow & \qquad \by{}\displaybreak[0]\
while for the inductive case we have, 
2pt]
\Leftrightarrow & \qquad \by{def.~of }\displaybreak[0]\2pt]
& \succeq \CteFun{1} - \wpd{\Call{\PName}}{\decl}\!(\CteFun{1}) \displaybreak[0]\2pt]
&\eeet{\decl(\PName)}{ F^{i+1}(\bot)}\!(\rt_1) - 
 \eeet{\decl(\PName)}{ F^{i}(\bot)}\!(\rt_0)  \displaybreak[0]\2pt]
\Leftrightarrow & \qquad \by{ by \autoref{thm:fp-rec}}\displaybreak[0]\2pt]
& \succeq 1 \cdot \bigl(\CteFun{1} - \ewp{\decl(\PName)}{\wpd{\Call{\PName}}{\decl}}\!(\CteFun{1}) \bigr) + 0 \displaybreak[0]\2pt]
& \rt_1 - \rt_0 \succeq 1 \cdot (\CteFun{1} - \CteFun{1}) + \CteFun{0} \text{ and}\displaybreak[0]\2pt]
\Leftarrow & \qquad \by{hypothesis}\displaybreak[0]\2pt]
\Leftarrow & \qquad \by{IH}\displaybreak[0]\-\normalbaselineskip]\tag*{\qedhere}

\eetd{c}{\decl} \!(\ctert{k}) \succeq \ctert{k}~.

\MoveEqLeft[2] \eetd{\Call{\PName}}{\decl}\!(\ctert{k})(s)\\
&\:=\: \eetd{\Call{\PName}}{\decl}\!(\ctert{0}) (s) +  \wpd{\Call{\PName}}{\decl}\!(\ctert{k}) (s)\\
&\:\geq\: \wpd{\Call{\PName}}{\decl}\!(\ctert{k}) (s)\\
&\:=\: k \cdot \wpd{\Call{\PName}}{\decl}\!(1) (s) \:=\: k

\MoveEqLeft[2] \eetd{\Call{\PName}}{\decl}\!(\ctert{k})(s) \\
&\:\geq\: \sup\nolimits_{n} \: n \,{\cdot}\, \bigl(\underbrace{\CteFun{1}
- \wpd{\Call{\PName}}{\decl}\!(\CteFun{1})(s)}_{>0} \bigr)\

\end{proof}

For stating the following lemma we use the notion of ``constant separable''
runtime environment. We say that  is
\emph{constant separable into}  iff for all  and , . 

\begin{lemma}\label{thm:cte-sep-rtenv}
Let  be a runtime environment constant separable\footnote{See paragraph
  above.} into . Then for all command ,

\end{lemma}
\begin{proof}
By induction on the structure of . 

\medskip
\noindent \emph{No--op:}
2pt]
= & \qquad \by{def.~of }\displaybreak[0]\2pt]
= & \qquad \by{def.~of }\displaybreak[0]\2pt]
\end{array}

\begin{array}{c@{\:\:} l@{} }
& \eeet{\Ass{x}{E}}{\eta}\!(\ctert{k} + \rt) \displaybreak[0]\2pt]
& (\ctert{k} + \rt)\subst{x}{E} \displaybreak[0]\2pt]
& \ctert{k} + \rt\subst{x}{E} \displaybreak[0]\2pt]
& \ctert{k} + \eeet{\Ass{x}{E}}{\upsilon}\!(\rt) 
\end{array}

\begin{array}{c@{\:\:} l@{} }
& \eeet{\Call{\PName}}{\eta_1}\!(\ctert{k} + \rt) \displaybreak[0]\2pt]
& \eta(\ctert{k} + \rt) \displaybreak[0]\2pt]
& \ctert{k} + \upsilon(\rt) \displaybreak[0]\2pt]
& \ctert{k} + \eeet{\Call{\PName}}{\upsilon}\!(\rt) 
\end{array}

\begin{array}{c@{\:\:} l@{} }
& \eeet{\PChoice{c_1}{p}{c_2}}{\eta}\!(\ctert{k} + \rt) \displaybreak[0]\2pt]
& p \cdot  \eeet{c_1}{\eta}\!(\ctert{k} + \rt) + (1{-}p) \cdot
  \eeet{c_2}{\eta}\!(\ctert{k} + \rt) \displaybreak[0]\2pt]
& p \cdot  \bigl( \ctert{k} + \eeet{c_1}{\upsilon}\!(\rt) \bigr) + (1{-}p) \cdot
 \bigl(\ctert{k} + \eeet{c_2}{\upsilon}\!(\rt) \bigr) \displaybreak[0]\2pt]
& \ctert{k} +  p \cdot  \eeet{c_1}{\upsilon}\!(\rt) + (1{-}p) \cdot
 \eeet{c_2}{\upsilon}\!(\rt) \displaybreak[0]\2pt]
& \ctert{k} + \eeet{\PChoice{c_1}{p}{c_2}}{\upsilon}\!(\rt) 
\end{array}

\begin{array}{c@{\:\:} l@{} }
& \eeet{c_1;c_2}{\eta_1}\!(\ctert{k} + \rt) \displaybreak[0]\2pt]
& \eeet{c_1}{\eta}\!\bigl(\eeet{c_2}{\eta} \!(\ctert{k} + \rt)\bigr)  \displaybreak[0]\2pt]
& \eeet{c_1}{\eta}\!\bigl(\ctert{k} + \eeet{c_2}{\upsilon}\!(\rt) \bigr)
  \displaybreak[0]\2pt]
& \ctert{k} + \eeet{c_1}{\upsilon}\!\bigl(\eeet{c_2}{\upsilon}\!(\rt) \bigr)
  \displaybreak[0]\2pt]
& \ctert{k} + \eeet{c_1; c_2}{\upsilon}\!(\rt) 
\end{array}\
  
\end{proof}

\begin{lemma}\label{thm:fix-point-compos}
  Let ,   and   be upper --cpos with botom elements ,  and ,
  respectively. Moreover let , , ,  be upper continuous
  and . If
\begin{enumerate}
  \item \label{it-1}  and  ,
  \item \label{it-2}  and , and
  \item \label{it-3}  and ,
  \end{enumerate}
then

\end{lemma}
\begin{proof}

2pt]
\Leftrightarrow & \qquad \by{"" is a partial order over }\displaybreak[0]\2pt]
\Leftrightarrow & \qquad \by{Kleene's Fixed Point Theorem,  continuous}\displaybreak[0]\2pt]
\Leftrightarrow & \qquad \by{ continuous}\displaybreak[0]\2pt]
\Leftarrow & \qquad \by{}\displaybreak[0]\2pt]
\end{array}

\begin{array}{c@{\:\:} l@{} }
& f_1 \bigl(F_1^{n+1}(\bot_1)\bigr) \displaybreak[0]\2pt]
& f_1 \bigl(F \bigl(F_1^n(\bot_1)\bigr)\bigr) \displaybreak[0]\2pt]
& h_1 \bigl(f_1 \bigl(F_1^n(\bot_1)\bigr)\bigr) \displaybreak[0]\2pt]
& h_1 (f_2(\lfp{\!}{F_2})) \displaybreak[0]\2pt]
& f_2(\lfp{\!}{F_2})
\end{array} \
  
\end{proof}


\paragraph{Proof of \autoref{thm:eet-prop}.} 
The proof of all properties proceeds by induction on the program
structure. Except for the case of probabilistic choice and procedure call, all
other programs constructs have already been dealt with in
\cite{Kaminski:arXiv:2016,Kaminski:ETAPS:2016}. For probabilistic choice we
follow the same reasoning as for conditional branches. We are left to analyze
then only the case of procedure calls. For each of the properties we reason as
follows:

\medskip
\noindent \emph{Continuity.} Let
. 

2pt]
= & \qquad \by{\autoref{thm:eet-proc-call-iter}}\displaybreak[0]\2pt]
= & \qquad \by{ continuous; see below}\displaybreak[0]\2pt]
= & \qquad \by{\autoref{thm:diag-sup-cpo}}\displaybreak[0]\2pt]
= & \qquad \by{\autoref{thm:eet-proc-call-iter}}\displaybreak[0]\2pt]
\end{array}

\bigl( \lambda \eta^\star \!\mydot \lambda \rt^\star \!\mydot \eta^\star (\ctert{k} +
\rt^\star)  \bigr) (\lfp{\!}{F}) \:=\: \bigl( \lambda \eta^\star \!\mydot \lambda
\rt^\star \!\mydot \ctert{k} + \eta^\star (\rt^\star)  \bigr) (\lfp{\!}{F})~.

  F_1 &= F_2 = F\\
f_1 &= \lambda \eta^\star \!\mydot \lambda \rt^\star \!\mydot \eta^\star (\ctert{k} +
\rt^\star) \\
f_2 &=  \lambda \eta^\star \!\mydot \lambda
\rt^\star \!\mydot \ctert{k} + \eta^\star (\rt^\star) \\
h_1 &= \lambda \eta^\star \!\mydot \lambda \rt^\star \!\mydot \ctert{1} +
      \eeet{\decl(\PName)}{\lambda t' \mydot \eta^\star(t' - \ctert{k})}
      (\ctert{k} + \rt^\star)\\
h_2 &= \lambda \eta^\star \!\mydot \lambda \rt^\star \!\mydot \ctert{k} + \ctert{1} +
      \eeet{\decl(\PName)}{\lambda t' \mydot \eta^\star(t') - \ctert{k}}
      (\rt^\star )

\begin{array}{c@{\:\:} l@{} }
& h_1(f_2(\lfp{\!}{F}))(t) \preceq f_2(\lfp{\!}{F})(t) \displaybreak[0]\2pt]
& \ctert{1} + \eeet{\decl(\PName)}{\eta}(\ctert{k} + \rt) \preceq \ctert{k} +
  \eetd{\Call{\PName}}{\decl}\!(\rt)\displaybreak[0]\2pt]
& \ctert{1} + \ctert{k} + \eeet{\decl(\PName)}{\eetd{\Call{\PName}}{\decl}} (t)
  \preceq \ctert{k} + \eetd{\Call{\PName}}{\decl}\!(\rt)\displaybreak[0]\2pt]
& \ctert{k} + F (\eetd{\Call{\PName}}{\decl}) (t)
  \preceq \ctert{k} + \eetd{\Call{\PName}}{\decl}\!(\rt)\displaybreak[0]\2pt]
& \ctert{k} + F (\lfp{\!}{F}) (t)
  \preceq \ctert{k} + \lfp{\!}{F}(\rt)\displaybreak[0]\2pt]
& \ctert{k} + \lfp{\!}{F} (t)
  \preceq \ctert{k} + \lfp{\!}{F}(\rt)\displaybreak[0]\2pt]
& \true
\end{array} 

\begin{array}{c@{\:\:} l@{} }
& h_2(f_1(\lfp{\!}{F}))(t) \preceq f_1(\lfp{\!}{F})(t) \displaybreak[0]\2pt]
& \ctert{k} + \ctert{1} + \eeet{\decl(\PName)}{\upsilon}(\rt) \preceq 
  \eetd{\Call{\PName}}{\decl}\!(\ctert{k} + \rt)\displaybreak[0]\2pt]
& \ctert{k} + \ctert{1} + \bigl(
  \eeet{\decl(\PName)}{\eetd{\Call{\PName}}{\decl}} (\ctert{k} {+} \rt) -
  \ctert{k} \bigr)\displaybreak[0]\2pt]
\Leftrightarrow & \qquad \by{algebra; def.~of }\displaybreak[0]\2pt]
\Leftrightarrow & \qquad \by{def.~of }\displaybreak[0]\2pt]
\Leftrightarrow & \qquad \by{def.~of }\displaybreak[0]\2pt]
\Leftarrow & \qquad \by{"" is a partial order}\displaybreak[0]\



\medskip
\noindent \emph{Preservation of infinity.} By the monotonicity of
 and \autoref{thm:ert-of-constant}, we have 

which itself entails . 



\subsection{Relation between Transformers \boldeetsymbol\ and \boldwpsymbol}
\label{sec:eet-wp}
To establish \autoref{thm:eet-wp} we make use of a subsidiary result. This
result relies on the notion of \emph{separable} runtime environment. We
say that a runtime environment  is \emph{separable} into runtimes
environments  and  iff we have  for every any two runtimes  and . 


\begin{lemma}
\label{thm:eeet-ewp-sep}
 For every command  and runtime environment  separable into  and
 ,

\end{lemma}
\begin{proof}
 For the basic
instructions (,  and assignment), the statement follows
immediately from the definitions of  and .  For the
remaining program constructs we reason as follows:

\medskip
\noindent \emph{Conditional Branching:}
2pt]
= & \qquad \by{def.~of }\displaybreak[0]\2pt]
= & \qquad \by{I.H. on ,}\displaybreak[0]\2pt]
& \quad\! + \ToExp{\lnot G} \cdot \bigl(\eeet{c_2}{\eta_1} \!(\rt_1) +
\ewp{c_2}{\eta_2} \!(\rt_2) \bigr)\displaybreak[0]\2pt]
& \ctert{1} + 
    \ToExp{G} \cdot \eeet{c_1}{\eta_1} \!(\rt_1) + 
 \ToExp{\lnot G} \cdot \eeet{c_2}{\eta_1} \!(\rt_1) \displaybreak[0]\2pt]
= & \qquad \by{def.~of }\displaybreak[0]\2pt]
& \quad\! + \ewp{\Cond{G}{c_1}{c_2}}{\eta_2}\!(\rt_2)
\end{array}

\begin{array}{c@{\:\:} l@{} }
& \eeet{c_1;c_2}{\eta}\!(\rt_1 + \rt_2) \displaybreak[0]\2pt]
& \eeet{c_1}{\eta}\!\bigl(\eeet{c_2}{\eta}(\rt_1 + \rt_2)\bigr) \displaybreak[0]\2pt]
& \eeet{c_1}{\eta}\!\bigl(\eeet{c_2}{\eta_1} \!(\rt_1) +
\ewp{c_2}{\eta_2} \!(\rt_2)  \bigr)
  \displaybreak[0]\2pt]
& \eeet{c_1}{\eta_1}\!\bigl(\eeet{c_2}{\eta_1} \!(\rt_1) \bigr)  +  \ewp{c_1}{\eta_2}\!\bigl(\ewp{c_2}{\eta_2} \!(\rt_2)  \bigr)
  \displaybreak[0]\2pt]
& \eeet{c_1; c_2}{\eta}\!(\rt_1) + \ewp{c_1; c_2}{\eta}\!(\rt_2)
\end{array}

\begin{array}{c@{\:\:} l@{} }
& \eeet{\Call{\PName}}{\eta}\!(\rt_1 + \rt_2) \displaybreak[0]\2pt]
& \eta(\rt_1 + \rt_2)\displaybreak[0]\2pt]
& \eta_1(\rt_1) + \eta_2(\rt_2)\displaybreak[0]\2pt]
& \eeet{\Call{\PName}}{\eta_1}\!(\rt_1) + \ewp{\Call{\PName}}{\eta_2}\!(\rt_2)
  \hfill 
\end{array} \
\end{proof}


\paragraph{Proof of \autoref{thm:eet-wp}.} 
The proof proceeds by induction on the program structure, but for the inductive
reasoning to work we need to consider a stronger statement, namely

(We recover the original statement by taking ). For all
program constructs  different from a procedure call, establishing
\autoref{eq:ert-wp} follows exactly the same argument as that used in
\autoref{thm:eeet-ewp-sep} for establishing

since  and  obey the same definition rule for
such program constructs. 

For the case of a procedure call we have to prove that

Since

and both  and  are continuous (see \autoref{thm:ewp-cont-env} and
\autoref{thm:eeet-cont-env}), by Kleene's Fixed Point Theorem our statement can
be recast as
\

where ,
,
 denotes the repeated
application of  from   times and likewise for
. Since a standard property of complete partial orders ensures
that  and  are monotonic \wrt , we can use
the Monotone Sequence Theorem (\autoref{thm:MST}) to replace  with
 in the above equation and this way ``merge'' the two
limits in the RHS into a single limit. The above equation is then entailed by
formula

which we prove by induction on . The base case is immediate
since for every runtime , . For the inductive case we reason as follows:


2pt]
& \quad F^{n+1}(\bot_\RtEnv)(\rt_1) + G^{n+1}(\bot_\SEnv)(\rt_2) \displaybreak[0]\2pt]
&  \ctert{1} + \eeet{\decl(\PName)}{F^{n}(\bot_\RtEnv)} (\rt_1 + \rt_2) \:=\displaybreak[0]\2pt]
\Leftrightarrow & \qquad \by{algebra}\displaybreak[0]\2pt]
& \quad \eeet{\decl(\PName)}{F^{n}(\bot_\RtEnv)}
  (\rt_1)  + \ewp{\decl(\PName)}{G^n(\bot_\SEnv)} (\rt_2) \2pt]
& \quad \true 
\end{array} \

\subsection{Soundness of Proof Rules for \boldeetsymbol}
\label{sec:eet-rules-sound}

To establish the soundness of rules \lrule{eet-rec} and
\lrule{eet-rec} we make use of the following result.

\begin{fact}
\label{fact:deriv-eeet}
The derivability assertion 

implies that for every runtime environment ,

The result remain valid if we reverse all inequalities. 
\end{fact}
\noindent We have already used a similar result for establishing the soundness of rules
\lrule{wp-rec} and \lrule{wp-rec} (even though in that case the
conclusion was stated using  instead of ).

\medskip
\noindent \textbf{Soundness of rule \lrule{eet-rec}.} Let runtime environment
 map  to  and all other runtimes to (the constant runtime)
. The validity of the rule follows from the following
reasoning:

2pt]
\Leftrightarrow & \qquad \by{def.  (\autoref{fig:eet})}\displaybreak[0]\2pt]
\Leftrightarrow & \qquad \by{def. ,}\displaybreak[0]\2pt]
\Leftarrow & \qquad \by{Park's Lemma\footnotemark, \autoref{fact:RtEnv-cpo}, \autoref{thm:eeet-cont-env}}\displaybreak[0]\2pt]
\Leftrightarrow & \qquad \by{def. ,}\displaybreak[0]\2pt]
\Leftrightarrow & \qquad \by{algebra}\displaybreak[0]\2pt]
\Leftarrow & \qquad \by{\autoref{fact:deriv-eeet}, rule premise}\displaybreak[0]\2pt]
\Leftrightarrow & \qquad \by{def. }\displaybreak[0]\-\normalbaselineskip]\tag*{\qedhere}

\begin{array}{c}
\infrule{ l_0=\CteFun{0} \\
 \ctert{1} + l_n \preceq \eet{\Call{\PName}}\!(\rt) \derivsymbol l_{n+1} \preceq \eet{\decl(\PName)}\!(\rt)} 
{~\ctert{1} {+} \sup_n l_n \preceq \eetd{\Call{\PName}}{\decl}\!(\rt) }\\
\end{array}

\begin{array}{c@{\:\:} l@{} }
& \ctert{1} + \sup_n l_n \preceq \eetd{\Call{\PName}}{\decl}\!(\rt)\displaybreak[0]\2pt]
&  \ctert{1} + \sup_n l_n \preceq \lfp{\sqsubseteq}{F} (\rt)\displaybreak[0]\2pt]
& \ctert{1} + \sup_n l_n \preceq \sup_n F^n(\bot_\RtEnv) (t)
\end{array} 

\hspace*{-4.5em} \begin{array}{c@{\:\:} l@{} }
\Leftrightarrow & \displaybreak[0]\2pt]
\Leftrightarrow & \qquad \by{}\displaybreak[0]\2pt]
\Leftarrow & \displaybreak[0]\


\smallskip
\noindent  We prove the above statement by induction on . For the base case we have
2pt]
\Leftrightarrow & \qquad \by{rule premise, def }\displaybreak[0]\2pt]
\Leftarrow & \qquad \by{} \displaybreak[0]\
For the inductive case we have
2pt]
\Leftrightarrow & \qquad \by{def }\displaybreak[0]\2pt]
\Leftrightarrow & \qquad \by{algebra} \displaybreak[0]\4pt]
\Leftarrow & \qquad \by{\autoref{fact:deriv-eeet}, rule premise}\displaybreak[0]\2pt]
\Leftrightarrow & \qquad \by{} \displaybreak[0]\


\subsection{Operational Model of \pGCL}
\label{sec:operational-model}



\begin{definition}[Pushdown Markov Chains with Rewards]
	A \textbf{pushdown Markov chain with rewards (PRMC)} is a tuple , where
	\begin{itemize}
\item  is a countable set of control states,
		\item  is the initial control state,
		\item  is a finite stack alphabet,
		\item  is a special bottom--of--stack symbol,
		\item  (where  denotes the set of probability distributions over ) is a probabilistic transition relation,
		\item  is a reward function.
	\end{itemize}
	A \textbf{path of } is a finite sequence , where , , and for all  holds  and  and  and , such that  and  and  and .
	The \textbf{set of paths in } is denoted by .
	In the following let .
	The \textbf{probability of } is given by  be a path.
	The \textbf{reward of a path } is given by .
	The \textbf{expected reward for reaching a set of target states}  is given by  where .
	We stick to the convention that an empty sum yields value zero, i.e.\ in particular .
\end{definition}
We assume a given labeling for each program  that specifies the control flow of  as illustrated in \autoref{sec:operational-model}. Let  denote the finite set of labels used in a given program . We assume a special symbol  to denote successful termination of a program. Furthermore, we make use of the following operations between statements and labels.
\begin{itemize}
 \item  gives the label corresponding to the beginning of a given program.
 \item  gives the statement associated to a label used in a program,
 \item  give the first and second successor label of a given program label. 
       In case  has no such successor, we define  and , respectively.
\end{itemize}
\begin{definition}[Operational PRMCs]
 Let  and . 
 The \emph{operational PRMC} of program  starting in initial state  with respect to post--expectation  is given by  where 
 \begin{itemize}
  \item ,
  \item ,
  \item ,
  \item  is given by the least partial function satisfying the rules provided in \autoref{fig:operational},
  \item  for each   and , if  is not of the form .
 \end{itemize}
\end{definition}

\subsection{Soundness of Transformer \boldwpsymbol}
\label{sec:eet-soundness}

\paragraph{Proof of \autoref{thm:correspondance}.}
For simplicity in the remainder we will assume the program declaration 
fixed and therefore, omit it. Consider first an automaton  that behaves exactly the same as , but counts the number of symbols that currently lie on top of  on the stack and which self--loops if that number is exactly  and  would perform another push onto the stack.
It is evident that 
 
since  exhibits a partial behavior of  in the sense that every path of  that reaches  is (up to renaming) also a path of .
In the other direction, every path  of  that reaches  can be implemented with finite stack size.
Therefore, there exists an  such that for all  the path  is also a path of .

Consider now that by \autoref{thm:fp-rec} and its proof we can conclude that

It is therefore only left to show that the missing link

holds for all .
The proof of this equality proceeds by induction on :

\paragraph{The base case :}
We have to show that

holds.
Whenever the automaton  would perform the push action associated with a procedure call, the automaton  immediately self--loops as \emph{no} push to the stack whatsoever is allowed in this restricted automaton.
Therefore, we can syntactically replace every call in  by an  and still obtain the same behavior for the corresponding restricted automaton. Formally,

Now, since syntactically  we have

and therefore, it is left to show that

holds.
The proof of this equality proceeds by structural induction on :
For the base cases we have:

\subparagraph{The effectless program :}

On the denotational side, we have


On the operational side we have . 
Let , , and .
The only path of  reaching  is 
 and its reward is 

As  is the only path reaching , we have 



\subparagraph{The diverging program :}

On the denotational side, we have 


On the operational side we have . 
Let , , and .
The paths of  are all of the form 

and none of them ever reaches .
Thus the expected reward is an empty sum and we therefore have 



\subparagraph{The assignment :}

On the denotational side, we have 


On the operational side we have . 
Let , , and .
The only path of  reaching  is 

 and its reward is 

As  is the only path reaching , we have 



\subparagraph{The call :}

On the denotational side, we have 


On the operational side we have . 
Therefore, we can fall back to the base case .


\subparagraph{The inductive hypothesis on  and :} We now assume that for arbitrary but fixed programs , with , holds

We can then proceed with the inductive steps:


\subparagraph{The sequential composition :}

On the denotational side, we have 


Operationally, we have 

We furthermore observe that any path of the automaton 

reaching  is of the form

and any such a path's reward is given by 

Next, we observe that for any such path  a suffix of it, namely 

is a path of  reaching  with reward 

Moreover, we can think of the expected reward of 

as an expectation

which by the inductive hypothesis on  is equal to 
 
Therefore,  and  have the same expected reward, as in the former all paths reaching  have the form

and reward 

Keeping that in mind and applying the inductive hypothesis to  now yields the desired statement:



\subparagraph{The conditional choice :}

We distinguish two cases:

In Case 1 we have .
Then on the denotational side, we have 


On the operational side we have 

Regarding the control flow, let the following hold:\\
 ,\\
 ,\\
 , and finally\\
 .
We observe that any path of  finally reaching  is of the form

and it's reward is given by

Next, observe that removing from any such path  the initial segment, i.e.\ removing , gives a path of the form

which is a path of  reaching  with reward 

Notice that if we remove the initial segments from every path in  we obtain exactly the set .
Thus
  as well as  have the same expected reward.
This immediately yields the desired statement:

The reasoning for Case 2, i.e. , is completely analogous using the inductive hypothesis on 



\subparagraph{The probabilistic choice :} 

On the denotational side, we have 


On the operational side we have

Let , , let\\
, and let\\
.
We observe that any path of  reaching  is either of the form

and it's reward is given by

or it is of the form

and it's reward is given by

Notice that there is a possibility to partition the set 
 
into two sets  containing those paths starting with\\
, and a set  containing those paths starting with .

Next, observe that removing from any path in  the initial segment, i.e.\ removing , gives exactly the set .
The paths of  reaching  are of the form

and have reward 


Dually, removing from any path in  the initial segment, i.e.\ removing , gives exactly the set 

The paths of  reaching  are of the form

and have reward 


Since  and  was a partition of the path set 
 we can conclude:


This ends the proof for the base case of the induction on  and we can now state the inductive hypothesis:


\paragraph{Inductive hypothesis on :}
We assume that for an arbitrary but fixed  holds

 \emph{for all programs} .
 We can then proceed with the inductive step:

\paragraph{Inductive step :}
We now have to show that 

holds assuming the inductive hypothesis on .
The proof of this equality proceeds quite analogously, again by structural induction on :

\subparagraph{The base cases , , :}
The proofs for these base cases are completely analogous to the proofs conducted in the base case .

\subparagraph{The procedure call :}
The procedure call is technically a base case in the structural induction on  as it is an atomic statement.
It does, however, require using the inductive hypothesis on .
The proof goes as follows:
By an argument on the transition relation  of  we see that 

To the right hand side, we can apply the inductive hypothesis on  and then obtain the desired result:


\subparagraph{Inductive hypothesis and all inductive steps:}
The inductive hypothesis and the proofs for the inductive steps are completely analogous to the inductive hypothesis and the proofs conducted in the base case .
Exemplarily, we shall sketch the proof for the sequential composition: 
By a lengthy argument and application of the inductive hypothesis on  (completely analog to the base case for ) one arrives at

Applying the inductive hypothesis on  then yields the desired result:
\belowdisplayskip=-1\baselineskip




\subsection{Case Study}
\label{app:casestudy}
The omitted details for proving the second partial correctness property are provided in \autoref{fig:binarysearch:partial:not-exists}.
\begin{figure}[t]
-2pt]
    &\hphantom{\boldsymbol{\colon}}\;\; \text{\footnotesize }\-2pt]
&\hphantom{\boldsymbol{\colon}}\;\; \text{\footnotesize }\-2pt]
    &\hphantom{\boldsymbol{\colon}}\;\; \text{\footnotesize }\-2pt]
&\hphantom{\boldsymbol{\colon}}\;\; \qquad\text{\footnotesize }\-2pt]
&\hphantom{\boldsymbol{\colon}}\;\; \qquad\qquad \text{\footnotesize }\-2pt]
&\hphantom{\boldsymbol{\colon}}\;\; \qquad\qquad \text{\footnotesize }\-2pt]
&\hphantom{\boldsymbol{\colon}}\;\; \qquad\qquad \text{\footnotesize }\-2pt]
&\hphantom{\boldsymbol{\colon}}\;\; \qquad\qquad\text{\footnotesize }\-2pt]
&\hphantom{\boldsymbol{\colon}}\;\; \qquad\qquad\qquad \text{\footnotesize }\-2pt]
&\hphantom{\boldsymbol{\colon}}\;\; \qquad\qquad\qquad \text{\footnotesize }\-2pt]
&\hphantom{\boldsymbol{\colon}}\;\; \qquad\qquad\qquad \text{\footnotesize }\-2pt]
\text{\scriptsize 11} &\boldsymbol{\colon}\;\; \qquad\boldsymbol{\}} ~ \text{\footnotesize } \
\caption{Proof that  finds an index at which the value at this position is unequal to  when started in a sorted array  in which the value  does not exist. We write jh for . Recall that  and , and that we assume .}
\label{fig:binarysearch:partial:not-exists}
\end{figure}
