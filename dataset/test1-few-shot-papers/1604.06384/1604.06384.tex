\documentclass{article}
\pdfoutput=1
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage[pdflatex=true]{gastex}   \usepackage{graphicx}
\usepackage{subfig}
\usepackage{comment}
\usepackage{amsthm}     \newtheorem{definition}{Definition}
\newtheorem{theorem}{Theorem}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{problem}{Problem}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{example}{Example}
\newtheorem{remark}{Remark}
\newtheorem{algorithm}{Algorithm}
\def\fract#1/#2{\leavevmode
 \kern.1em \raise .5ex \hbox{\the\scriptfont0 #1}\kern-.1em \kern-.15em \lower .25ex \hbox{\the\scriptfont0 #2}}
\def\abs#1{\ensuremath{\lvert #1\rvert}} 
\def\norm#1{\ensuremath{\lVert #1\rVert}}
\makeatletter
\DeclareRobustCommand\sfrac[1]{\@ifnextchar/{\@sfrac{#1}}{\@sfrac{#1}/}}
\def\@sfrac#1/#2{\leavevmode\scalebox{.9}{\kern.1em\raise.5ex
         \hbox{}\kern-.1em
         /\kern-.15em\lower.25ex
          \hbox{}}}
\DeclareRobustCommand\numfrac[1]{\@ifnextchar/{\@numfrac{#1}}{\@numfrac{#1}}}
\def\@numfrac#1{\leavevmode \hbox{}}
\makeatother
\newcommand{\nat}{\mathbb N}
\newcommand{\real}{\mathbb R}
\newcommand{\tuple}[1]{\langle #1 \rangle}


\newcommand{\true}{{\sf true}}
\newcommand{\false}{{\sf false}}

\newcommand{\nnf}{{\sf nnf}}

\renewcommand{\L}{{\cal L}}
\newcommand{\T}{{\mathcal T}}
\renewcommand{\next}{\mathop{\mathcal X}}
\newcommand{\nextq}{\mathop{\mathcal X\!\!\;Q} }
\newcommand{\qnext}{\mathop{Q \mathcal X}}
\newcommand{\anext}{\mathop{\forall \mathcal X}}
\newcommand{\enext}{\mathop{\exists \mathcal X}}
\newcommand{\until}{\mathop{\mathcal U}}
\newcommand{\release}{\mathop{\mathcal R}}
\newcommand{\auntil}{\mathop{\forall \mathcal U}}\newcommand{\euntil}{\mathop{\exists \mathcal U}}\newcommand{\quntil}{\mathop{Q \mathcal U}}
\newcommand{\untila}{\mathop{\mathcal U\!\!\; \forall}}\newcommand{\untile}{\mathop{\mathcal U\!\!\; \exists}}\newcommand{\untilq}{\mathop{\mathcal U\!\!\;Q}}
\renewcommand{\r}{{\tt r}}
\def\sg{\mathrel[\joinrel\mathrel[}
\def\sd{\mathrel]\joinrel\mathrel]}
\newcommand{\sem}[1]{\sg \mathrel{#1} \sd}

\newcommand{\first}{{\sf first}}
\newcommand{\last}{{\sf last}}

\def\mynote#1{{\sf  #1 }}







\sloppy



\title{{\bf Computation Tree Logic for Synchronization 
Properties}\footnote{This research was partially supported by Austrian Science Fund (FWF) 
NFN Grant No S11407-N23 (RiSE/SHiNE), ERC Start grant (279307: Graph Games), 
Vienna Science and Technology Fund (WWTF) through project ICT15-003,
and European project Cassting (FP7-601148).
}}

\author{
Krishnendu Chatterjee \quad  Laurent Doyen \\ 
\normalsize
  IST Austria \quad  CNRS \& LSV, ENS Cachan 
}


\date{}

















\begin{document}
\sloppy
\providecommand*{\donothing}[1]{}

\maketitle 
\pagestyle{plain}

\begin{abstract}
We present a logic that extends CTL (Computation Tree Logic) 
with operators that express synchronization properties.
A property is synchronized in a system if it holds in all 
paths of a certain length. 
The new logic is obtained by using the same path quantifiers 
and temporal operators as in CTL, but allowing a different order
of the quantifiers. This small syntactic variation induces 
a logic that can express non-regular properties for which known extensions
of MSO with equality of path length are undecidable.
We show that our variant of CTL is decidable and that the model-checking
problem is in , and is hard
for the class of problems solvable in polynomial time using a
parallel access to an NP oracle.
We analogously consider quantifier exchange in extensions of CTL, and 
we present operators defined using basic operators of CTL* that express
the occurrence of infinitely many synchronization points.
We show that the model-checking problem remains in .
The distinguishing power of CTL and of our new logic coincide
if the Next operator is allowed in the logics, thus the classical 
bisimulation quotient can be used for state-space reduction before model checking.
\end{abstract}


\section{Introduction}
In computer science, it is natural to view computations as a tree, where each branch 
represents an execution trace, and all possible execution traces are arranged in a tree. 
To reason about computations, the logical frameworks that express properties of 
trees have been widely studied~\cite{CGP01,Lenzi10,Thomas97}, such as CTL, CTL*, -calculus, MSO, etc. 
These logics can express -regular properties about trees. 



A key advantage of logics is to provide concise and formal semantics, and 
a rigorous language to express properties of a system. 
For example, the logic CTL is widely used in verification tools such as NuSMV~\cite{CCGR00}, 
and hyperproperties, i.e. tree-based properties that cannot be defined over individual traces, 
are relevant in security~\cite{CFKMRS14,CS10}.

One key property that has been studied in different contexts is the property of 
synchronization, which intuitively requires that no matter how the system behaves 
it synchronizes to a common good point. 
Note that the synchronization property is inherently a tree-based property, 
and is not relevant for traces. 
Synchronization has been studied for automata~\cite{Volkov08,CMS16}, 
probabilistic models such as Markov decision processes~\cite{DMS14a,DMS14b}, 
as well as partial-information, weighted, and timed models~\cite{LLS14,KLLS15,DJLMS14}, 
and has a rich collection of results as well as open problems, e.g., \v{C}ern\'{y}'s 
conjecture about the length of synchronizing words in automata is one of the long-standing 
and well-studied problems in automata theory~\cite{Cer64,Volkov08}. 
A natural question is how can synchronization be expressed in a logical framework.

First, we show that synchronization is a property that is not -regular. 
Hence it cannot be expressed in existing tree-based logics, such as MSO, CTL*, etc. 
A natural candidate to express synchronization in a logical framework is to consider 
MSO with quantification over path length. Unfortunately the quantification over path length in MSO
leads to a logic for which the model-checking problem is undecidable~\cite[Theorem 11.6]{Thomas90}. 
Thus an interesting question is how to express synchronization in a logical framework 
where the model-checking problem is decidable. 

\paragraph*{Contributions}
In this work we introduce an elegant logic, obtained by a natural variation of CTL. 
The logic allows to exchange the temporal and path quantifiers in classical CTL formulas. 
For example, consider the CTL formula  expressing the property 
that in all paths there exists a position where  holds (quantification pattern ). 
In our logic, the formula  with quantifiers exchanged expresses that 
there exists a position  such that for all paths,  holds at position  (quantification pattern ),
see \figurename~\ref{fig:eventually}.
Thus  eventually holds in all paths at the same position, expressing that
the paths are eventually synchronized. 

We show that the model-checking problem is decidable for our logic,
which we show is in  (in the third 
level of the polynomial hierarchy) and is hard
for the class  of problems solvable in polynomial time using a
parallel access to an NP oracle (Theorem~\ref{theo:CTL+Sync-complexity}).
The problems in  can be solved by a 
polynomial-time algorithm that uses an oracle for a problem in ,
and the problems in  can be solved by a non-deterministic
polynomial-time algorithm that uses an oracle for an NP-complete problem;
the problems in  can be solved by a 
polynomial-time algorithm that works in two phases, where in the first phase
a list of queries is constructed, and in the second phase the queries are
answered by an NP oracle (giving a list of yes/no answers) and the algorithm
proceeds without further calling the oracle~\cite{Wagner87,Spako05}. 


We present an extension of our logic that can express the occurrence
of infinitely many synchronization points (instead of one as in eventually
sychronizing), and the absence of synchronization from some point on, 
with the same complexity status (Section~\ref{sec:extension}). 
These properties are the analogue of the classical liveness and co-liveness 
properties in the setting of synchronization. 
We show that such properties cannot be expressed in our basic logic (Section~\ref{sec:expressivity}).
In Section~\ref{sec:CTL*}, we consider the possibility to further extend 
our logic with synchronization to CTL*, and show that the exchange of quantifiers
in CTL* formulas would lead to either a counter-intuitive semantics,
or an artificial logic that would be inelegant.

We study the distinguishing power of the logics in Section~\ref{sec:distinguising},
that is the ability of the logics, given two models, to provide a formula
that holds in one model, and not in the other. The distinguishing power is
different from the expressive power of a logic, as two logics with the
same expressive power have the same distinguishing power but not vice versa.
The distinguishing power can be used for state-space reduction before running
a model-checking algorithm, in order to obtain a smaller equivalent model,
that the logic cannot distinguish from the original model, and thus for which 
the answer of the model-checking algorithm is the same.
We show that if the Next operator is allowed in the logic, then 
the distinguishing power coincides with that of CTL (two models are
indistinguishable if and only if they are bisimilar), and if 
the Next operator is not allowed, then the distinguishing power lies
between bisimulation and stuttering bisimulation, and is NP-hard to decide.
In particular, it follows that with or without the Next operator the state-space reduction 
with respect to bisimulation, which is computable in polynomial time, is sound 
for model-checking.




\section{CTL + Synchronization}

We introduce the logic CTL+Sync after presenting basic definitions 
related to Kripke structures.
A \emph{Kripke structure} is a tuple 
where  is a finite set of states,  is a finite set of atomic propositions,
 is a labeling function that maps each state~ 
to the set  of propositions that are true at~,
and  is a transition relation.
We denote by  the set of successors of a state~ according to~,
and given a set  of states, let .
A Kripke structure is \emph{deterministic} if  is a singleton for all 
states .
A \emph{path} in  is an infinite sequence  such that 
for all . For , we denote by  the suffix .


\subsection{Syntax and semantics}\label{sec:ss}
In the CTL operators, a path quantifier always precedes the temporal quantifiers 
(e.g.,  or ). 
We obtain the logic CTL+Sync from traditional CTL by allowing to switch the order of
the temporal and path quantifiers. For example, the CTL formula 
holds in a state~ if for all  paths  from , there is a position
where  holds, and such that  holds in all positions before .
In the CTL+Sync formula , the quantifiers are exchanged, and
the formula holds in  if there exists a position , such that for all positions  before ,
in all paths  from , we have that  holds at position  and 
 holds at position~, see \figurename~\ref{fig:UA}.
Thus the formula  requires that  holds synchronously 
after the same number of steps in all paths, while the formula 
does not require such synchronicity across several paths.

The syntax of the formulas in CTL+Sync is as follows:

where  and .
We define  and additional Boolean connectives as usual, and let 
\begin{itemize}
\item , and , etc. 
\item , etc. 
\end{itemize}

Note that the Next operators  has only one quantifier,
and thus there is no point in switching quantifiers or defining
an operator .  

Given a Kripke structure , and a state , 
we define the satisfaction relation  as follows. The first cases
are standard and exist already in CTL:

\begin{itemize}
\item  if .

\item  if .

\item  if  or .

\item  if  for some .

\item  if  for all .
\end{itemize}

\noindent The interesting new cases are built using the until operator of CTL:

\begin{itemize}

\item  if there exists a path  in  with  and 
there exists  such that:
, and  for all .\smallskip

\item  if there exists  such that for all , 
there exists a path  in  with  such that  and .\smallskip

\item  if for all paths  in  with ,
there exists  such that:
, and  for all .\smallskip

\item  if there exists  such that for all  and 
for all paths  in  with , we have  and .\smallskip
\end{itemize}

We often write  (or )  when the Kripke structure  (or the initial state ) 
is clear from the context.
\begin{figure}[!tb]\begin{center}
	\hrule
		\subfloat[Eventually synchronizing.\label{fig:eventually}]{


\begin{gpicture}(35,37)(0,0)



\gasset{Nw=1,Nh=1,Nmr=.5, ExtNL=y, NLangle=180, NLdist=1, rdist=1, loopdiam=6}   






\node[Nmarks=n, Nfill=n, NLdist=2, NLangle=170](s0)(17,33){}



\gasset{dash={1}0}   \drawline[AHnb=0, linegray=.8](0,30)(35,30)
\drawline[AHnb=0, linegray=.8](0,24)(35,24)
\drawline[AHnb=0, linegray=.8](0,18)(35,18)
\drawline[AHnb=0, linegray=.8](0,12)(35,12)
\drawline[AHnb=0, linegray=.8](0,6)(35,6)
\gasset{dash={}0}   

\node[Nmarks=n, Nfill=n](s10)(13,27){}
\node[Nmarks=n, Nfill=n](s11)(21,27){}

\node[Nmarks=n, Nfill=n](s20)(9,21){}
\node[Nmarks=n, Nfill=n](s21)(17,21){}
\node[Nmarks=n, Nfill=n](s22)(25,21){}

\node[Nmarks=n, Nfill=n](s30)(5,15){}
\node[Nmarks=n, Nfill=n](s31)(11,15){}
\node[Nmarks=n, Nfill=n](s32)(17,15){}
\node[Nmarks=n, Nfill=n](s33)(22,15){}
\node[Nmarks=n, Nfill=n](s34)(28,15){}

\node[Nmarks=n, Nfill=y](s40)(5,9){}
\node[Nmarks=n, Nfill=y](s41)(11,9){}
\node[Nmarks=n, Nfill=y](s42)(15,9){}
\node[Nmarks=n, Nfill=y](s43)(19,9){}
\node[Nmarks=n, Nfill=y](s44)(22,9){}
\node[Nmarks=n, Nfill=y](s45)(26,9){}
\node[Nmarks=n, Nfill=y](s46)(30,9){}

\node[Nmarks=n, Nfill=n](s50)(3,3){}
\node[Nmarks=n, Nfill=n](s51)(7,3){}
\node[Nmarks=n, Nfill=n](s52)(9,3){}
\node[Nmarks=n, Nfill=n](s53)(13,3){}
\node[Nmarks=n, Nfill=n](s54)(15,3){}
\node[Nmarks=n, Nfill=n](s55)(19,3){}
\node[Nmarks=n, Nfill=n](s56)(22,3){}
\node[Nmarks=n, Nfill=n](s57)(26,3){}
\node[Nmarks=n, Nfill=n](s58)(28,3){}
\node[Nmarks=n, Nfill=n](s59)(32,3){}

\drawedge[ELpos=50, ELside=r, curvedepth=0](s0,s10){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](s0,s11){}

\drawedge[ELpos=50, ELside=r, curvedepth=0](s10,s20){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](s10,s21){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](s11,s22){}

\drawedge[ELpos=50, ELside=r, curvedepth=0](s20,s30){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](s20,s31){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](s21,s32){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](s22,s33){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](s22,s34){}

\drawedge[ELpos=50, ELside=r, curvedepth=0](s30,s40){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](s31,s41){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](s32,s42){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](s32,s43){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](s33,s44){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](s34,s45){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](s34,s46){}

\drawedge[ELpos=50, ELside=r, curvedepth=0](s40,s50){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](s40,s51){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](s41,s52){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](s41,s53){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](s42,s54){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](s43,s55){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](s44,s56){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](s45,s57){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](s46,s58){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](s46,s59){}












\end{gpicture}

 }
\quad
		\subfloat[Not eventually synchronizing.\label{fig:globally}]{


\begin{gpicture}(35,37)(0,0)



\gasset{Nw=1,Nh=1,Nmr=.5, ExtNL=y, NLangle=180, NLdist=1, rdist=1, loopdiam=6}   






\node[Nframe=y, Nfill=y, Nw=3,Nh=3,Nmr=1.5, fillgray=0.8, linegray=0.8](s0)(17,33){}
\node[Nmarks=n, Nfill=n, NLdist=2, NLangle=170](s0)(17,33){}



\gasset{dash={1}0}   \drawline[AHnb=0, linegray=.8](0,30)(35,30)
\drawline[AHnb=0, linegray=.8](0,24)(35,24)
\drawline[AHnb=0, linegray=.8](0,18)(35,18)
\drawline[AHnb=0, linegray=.8](0,12)(35,12)
\drawline[AHnb=0, linegray=.8](0,6)(35,6)
\gasset{dash={}0}   

\node[Nmarks=n, Nfill=n](s10)(13,27){}
\node[Nframe=y, Nfill=y, Nw=3,Nh=3,Nmr=1.5, fillgray=0.8, linegray=0.8](s11)(21,27){}
\node[Nmarks=n, Nfill=n](s11)(21,27){}

\node[Nmarks=n, Nfill=n](s20)(9,21){}
\node[Nframe=y, Nfill=y, Nw=3,Nh=3,Nmr=1.5, fillgray=0.8, linegray=0.8](s21)(17,21){}
\node[Nmarks=n, Nfill=n](s21)(17,21){}
\node[Nmarks=n, Nfill=n](s22)(25,21){}

\node[Nframe=y, Nfill=y, Nw=3,Nh=3,Nmr=1.5, fillgray=0.8, linegray=0.8](s30)(5,15){}
\node[Nmarks=n, Nfill=n](s30)(5,15){}
\node[Nmarks=n, Nfill=n](s31)(11,15){}
\node[Nmarks=n, Nfill=n](s32)(17,15){}
\node[Nmarks=n, Nfill=n](s33)(22,15){}
\node[Nmarks=n, Nfill=n](s34)(28,15){}

\node[Nframe=y, Nfill=y, Nw=3,Nh=3,Nmr=1.5, fillgray=0.8, linegray=0.8](s40)(5,9){}
\node[Nmarks=n, Nfill=n](s40)(5,9){}
\node[Nmarks=n, Nfill=n](s41)(11,9){}
\node[Nmarks=n, Nfill=n](s42)(15,9){}
\node[Nmarks=n, Nfill=n](s43)(19,9){}
\node[Nmarks=n, Nfill=n](s44)(22,9){}
\node[Nmarks=n, Nfill=n](s45)(26,9){}
\node[Nmarks=n, Nfill=n](s46)(30,9){}

\node[Nmarks=n, Nfill=n](s50)(3,3){}
\node[Nmarks=n, Nfill=n](s51)(7,3){}
\node[Nmarks=n, Nfill=n](s52)(9,3){}
\node[Nmarks=n, Nfill=n](s53)(13,3){}
\node[Nmarks=n, Nfill=n](s54)(15,3){}
\node[Nmarks=n, Nfill=n](s55)(19,3){}
\node[Nframe=y, Nfill=y, Nw=3,Nh=3,Nmr=1.5, fillgray=0.8, linegray=0.8](s56)(22,3){}
\node[Nmarks=n, Nfill=n](s56)(22,3){}
\node[Nmarks=n, Nfill=n](s57)(26,3){}
\node[Nmarks=n, Nfill=n](s58)(28,3){}
\node[Nmarks=n, Nfill=n](s59)(32,3){}

\drawedge[ELpos=50, ELside=r, curvedepth=0](s0,s10){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](s0,s11){}

\drawedge[ELpos=50, ELside=r, curvedepth=0](s10,s20){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](s10,s21){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](s11,s22){}

\drawedge[ELpos=50, ELside=r, curvedepth=0](s20,s30){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](s20,s31){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](s21,s32){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](s22,s33){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](s22,s34){}

\drawedge[ELpos=50, ELside=r, curvedepth=0](s30,s40){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](s31,s41){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](s32,s42){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](s32,s43){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](s33,s44){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](s34,s45){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](s34,s46){}

\drawedge[ELpos=50, ELside=r, curvedepth=0](s40,s50){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](s40,s51){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](s41,s52){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](s41,s53){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](s42,s54){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](s43,s55){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](s44,s56){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](s45,s57){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](s46,s58){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](s46,s59){}












\end{gpicture}

 }
		\quad
		\subfloat[Every subtree is eventually synchronizing.\label{fig:subtrees}]{


\begin{gpicture}(35,37)(0,0)



\gasset{Nw=1,Nh=1,Nmr=.5, ExtNL=y, NLangle=180, NLdist=1, rdist=1, loopdiam=6}   






\node[Nmarks=n, Nfill=y, NLdist=2, NLangle=170](s0)(17,33){}



\gasset{dash={1}0}   \drawline[AHnb=0, linegray=.8](0,30)(35,30)
\drawline[AHnb=0, linegray=.8](0,24)(35,24)
\drawline[AHnb=0, linegray=.8](0,18)(35,18)
\drawline[AHnb=0, linegray=.8](0,12)(35,12)
\drawline[AHnb=0, linegray=.8](0,6)(35,6)
\gasset{dash={}0}   

\node[Nmarks=n, Nfill=y](s10)(13,27){}
\node[Nmarks=n, Nfill=y](s11)(21,27){}

\node[Nmarks=n, Nfill=n](s20)(9,21){}
\node[Nmarks=n, Nfill=n](s21)(17,21){}
\node[Nmarks=n, Nfill=n](s22)(25,21){}

\node[Nmarks=n, Nfill=y](s30)(5,15){}
\node[Nmarks=n, Nfill=y](s31)(11,15){}
\node[Nmarks=n, Nfill=n](s32)(17,15){}
\node[Nmarks=n, Nfill=y](s33)(22,15){}
\node[Nmarks=n, Nfill=y](s34)(28,15){}

\node[Nmarks=n, Nfill=y](s42)(15,9){}
\node[Nmarks=n, Nfill=y](s43)(19,9){}
\node[Nmarks=n, Nfill=y](s44)(22,9){}
\node[Nmarks=n, Nfill=n](s45)(26,9){}
\node[Nmarks=n, Nfill=n](s46)(30,9){}

\node[Nmarks=n, Nfill=y](s57)(26,3){}
\node[Nmarks=n, Nfill=y](s58)(28,3){}
\node[Nmarks=n, Nfill=y](s59)(32,3){}

\drawedge[ELpos=50, ELside=r, curvedepth=0](s0,s10){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](s0,s11){}

\drawedge[ELpos=50, ELside=r, curvedepth=0](s10,s20){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](s10,s21){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](s11,s22){}

\drawedge[ELpos=50, ELside=r, curvedepth=0](s20,s30){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](s20,s31){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](s21,s32){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](s22,s33){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](s22,s34){}

\drawedge[ELpos=50, ELside=r, curvedepth=0](s32,s42){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](s32,s43){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](s33,s44){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](s34,s45){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](s34,s46){}

\drawedge[ELpos=50, ELside=r, curvedepth=0](s45,s57){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](s46,s58){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](s46,s59){}












\end{gpicture}

 }
		\quad
		\subfloat[Until universal. \label{fig:UA}]{


\begin{gpicture}(35,40)(0,0)



\gasset{Nw=1,Nh=1,Nmr=.5, ExtNL=y, NLangle=180, NLdist=1, rdist=1, loopdiam=6}   






\node[Nframe=y, Nfill=y, Nw=3,Nh=3,Nmr=1.5, fillgray=0.8, linegray=0.8](s0)(17,33){}
\node[Nmarks=n, Nfill=n, NLdist=2, NLangle=170](s0)(17,33){}



\gasset{dash={1}0}   \drawline[AHnb=0, linegray=.8](0,30)(35,30)
\drawline[AHnb=0, linegray=.8](0,24)(35,24)
\drawline[AHnb=0, linegray=.8](0,18)(35,18)
\drawline[AHnb=0, linegray=.8](0,12)(35,12)
\drawline[AHnb=0, linegray=.8](0,6)(35,6)
\gasset{dash={}0}   


\node[Nframe=y, Nfill=y, Nw=3,Nh=3,Nmr=1.5, fillgray=0.8, linegray=0.8](s10)(13,27){}
\node[Nmarks=n, Nfill=n](s10)(13,27){}
\node[Nframe=y, Nfill=y, Nw=3,Nh=3,Nmr=1.5, fillgray=0.8, linegray=0.8](s11)(21,27){}
\node[Nmarks=n, Nfill=n](s11)(21,27){}

\node[Nframe=y, Nfill=y, Nw=3,Nh=3,Nmr=1.5, fillgray=0.8, linegray=0.8](s20)(9,21){}
\node[Nmarks=n, Nfill=n](s20)(9,21){}
\node[Nframe=y, Nfill=y, Nw=3,Nh=3,Nmr=1.5, fillgray=0.8, linegray=0.8](s21)(17,21){}
\node[Nmarks=n, Nfill=n](s21)(17,21){}
\node[Nframe=y, Nfill=y, Nw=3,Nh=3,Nmr=1.5, fillgray=0.8, linegray=0.8](s22)(25,21){}
\node[Nmarks=n, Nfill=n](s22)(25,21){}


\node[Nframe=y, Nfill=y, Nw=3,Nh=3,Nmr=1.5, fillgray=0.8, linegray=0.8](s30)(5,15){}
\node[Nmarks=n, Nfill=n](s30)(5,15){}
\node[Nframe=y, Nfill=y, Nw=3,Nh=3,Nmr=1.5, fillgray=0.8, linegray=0.8](s31)(11,15){}
\node[Nmarks=n, Nfill=n](s31)(11,15){}
\node[Nframe=y, Nfill=y, Nw=3,Nh=3,Nmr=1.5, fillgray=0.8, linegray=0.8](s32)(17,15){}
\node[Nmarks=n, Nfill=n](s32)(17,15){}
\node[Nframe=y, Nfill=y, Nw=3,Nh=3,Nmr=1.5, fillgray=0.8, linegray=0.8](s33)(22,15){}
\node[Nmarks=n, Nfill=n](s33)(22,15){}
\node[Nframe=y, Nfill=y, Nw=3,Nh=3,Nmr=1.5, fillgray=0.8, linegray=0.8](s34)(28,15){}
\node[Nmarks=n, Nfill=n](s34)(28,15){}

\node[Nmarks=n, Nfill=y](s40)(5,9){}
\node[Nmarks=n, Nfill=y](s41)(11,9){}
\node[Nmarks=n, Nfill=y](s42)(15,9){}
\node[Nmarks=n, Nfill=y](s43)(19,9){}
\node[Nmarks=n, Nfill=y](s44)(22,9){}
\node[Nmarks=n, Nfill=y](s45)(26,9){}
\node[Nmarks=n, Nfill=y](s46)(30,9){}

\node[Nmarks=n, Nfill=n](s50)(3,3){}
\node[Nmarks=n, Nfill=n](s51)(7,3){}
\node[Nmarks=n, Nfill=n](s52)(9,3){}
\node[Nmarks=n, Nfill=n](s53)(13,3){}
\node[Nmarks=n, Nfill=n](s54)(15,3){}
\node[Nmarks=n, Nfill=n](s55)(19,3){}
\node[Nmarks=n, Nfill=n](s56)(22,3){}
\node[Nmarks=n, Nfill=n](s57)(26,3){}
\node[Nmarks=n, Nfill=n](s58)(28,3){}
\node[Nmarks=n, Nfill=n](s59)(32,3){}

\drawedge[ELpos=50, ELside=r, curvedepth=0](s0,s10){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](s0,s11){}

\drawedge[ELpos=50, ELside=r, curvedepth=0](s10,s20){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](s10,s21){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](s11,s22){}

\drawedge[ELpos=50, ELside=r, curvedepth=0](s20,s30){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](s20,s31){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](s21,s32){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](s22,s33){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](s22,s34){}

\drawedge[ELpos=50, ELside=r, curvedepth=0](s30,s40){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](s31,s41){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](s32,s42){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](s32,s43){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](s33,s44){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](s34,s45){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](s34,s46){}

\drawedge[ELpos=50, ELside=r, curvedepth=0](s40,s50){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](s40,s51){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](s41,s52){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](s41,s53){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](s42,s54){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](s43,s55){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](s44,s56){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](s45,s57){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](s46,s58){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](s46,s59){}












\end{gpicture}

 }
		\quad
		\subfloat[Until existential. \label{fig:UE}]{


\begin{gpicture}(35,40)(0,0)



\gasset{Nw=1,Nh=1,Nmr=.5, ExtNL=y, NLangle=180, NLdist=1, rdist=1, loopdiam=6}   






\node[Nframe=y, Nfill=y, Nw=3,Nh=3,Nmr=1.5, fillgray=0.8, linegray=0.8](s0)(17,33){}
\node[Nmarks=n, Nfill=n, NLdist=2, NLangle=170](s0)(17,33){}



\gasset{dash={1}0}   \drawline[AHnb=0, linegray=.8](0,30)(35,30)
\drawline[AHnb=0, linegray=.8](0,24)(35,24)
\drawline[AHnb=0, linegray=.8](0,18)(35,18)
\drawline[AHnb=0, linegray=.8](0,12)(35,12)
\drawline[AHnb=0, linegray=.8](0,6)(35,6)
\gasset{dash={}0}   

\node[Nframe=y, Nfill=y, Nw=3,Nh=3,Nmr=1.5, fillgray=0.8, linegray=0.8](s10)(13,27){}
\node[Nmarks=n, Nfill=n](s10)(13,27){}
\node[Nmarks=n, Nfill=n](s11)(21,27){}

\node[Nmarks=n, Nfill=n](s20)(9,21){}
\node[Nmarks=n, Nfill=n](s21)(17,21){}
\node[Nframe=y, Nfill=y, Nw=3,Nh=3,Nmr=1.5, fillgray=0.8, linegray=0.8](s22)(25,21){}
\node[Nmarks=n, Nfill=n](s22)(25,21){}

\node[Nmarks=n, Nfill=n](s30)(5,15){}
\node[Nframe=y, Nfill=y, Nw=3,Nh=3,Nmr=1.5, fillgray=0.8, linegray=0.8](s31)(11,15){}
\node[Nmarks=n, Nfill=n](s31)(11,15){}
\node[Nmarks=n, Nfill=n](s32)(17,15){}
\node[Nmarks=n, Nfill=n](s33)(22,15){}
\node[Nmarks=n, Nfill=n](s34)(28,15){}

\node[Nmarks=n, Nfill=y](s40)(5,9){}
\node[Nmarks=n, Nfill=y](s41)(11,9){}
\node[Nmarks=n, Nfill=n](s42)(15,9){}
\node[Nmarks=n, Nfill=y](s43)(19,9){}
\node[Nmarks=n, Nfill=n](s44)(22,9){}
\node[Nmarks=n, Nfill=y](s45)(26,9){}
\node[Nmarks=n, Nfill=n](s46)(30,9){}

\node[Nmarks=n, Nfill=n](s50)(3,3){}
\node[Nmarks=n, Nfill=n](s51)(7,3){}
\node[Nmarks=n, Nfill=n](s52)(9,3){}
\node[Nmarks=n, Nfill=n](s53)(13,3){}
\node[Nmarks=n, Nfill=n](s54)(15,3){}
\node[Nmarks=n, Nfill=n](s55)(19,3){}
\node[Nmarks=n, Nfill=n](s56)(22,3){}
\node[Nmarks=n, Nfill=n](s57)(26,3){}
\node[Nmarks=n, Nfill=n](s58)(28,3){}
\node[Nmarks=n, Nfill=n](s59)(32,3){}

\drawedge[ELpos=50, ELside=r, curvedepth=0](s0,s10){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](s0,s11){}

\drawedge[ELpos=50, ELside=r, curvedepth=0](s10,s20){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](s10,s21){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](s11,s22){}

\drawedge[ELpos=50, ELside=r, curvedepth=0](s20,s30){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](s20,s31){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](s21,s32){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](s22,s33){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](s22,s34){}

\drawedge[ELpos=50, ELside=r, curvedepth=0](s30,s40){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](s31,s41){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](s32,s42){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](s32,s43){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](s33,s44){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](s34,s45){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](s34,s46){}

\drawedge[ELpos=50, ELside=r, curvedepth=0](s40,s50){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](s40,s51){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](s41,s52){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](s41,s53){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](s42,s54){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](s43,s55){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](s44,s56){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](s45,s57){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](s46,s58){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](s46,s59){}












\end{gpicture}

 }
		\quad
		\subfloat{


\begin{gpicture}(38,40)(0,0)



\gasset{Nw=1,Nh=1,Nmr=.5, ExtNL=y, NLangle=180, NLdist=1, rdist=1, loopdiam=6}   








\node[Nframe=y, Nfill=y, Nw=3,Nh=3,Nmr=1.5, fillgray=0.8, linegray=0.8](s10)(5,24){}
\node[Nmarks=n, Nfill=n](s10)(5,24){}
\put(8,24){\makebox(0,0)[l]{\small  holds}}

\node[Nmarks=n, Nfill=y](s10)(5,18){}
\put(8,18){\makebox(0,0)[l]{\small  holds}}

\node[Nmarks=n, Nfill=n](s10)(5,12){}
\put(8,12){\makebox(0,0)[l]{\small neither  nor  holds}}











\end{gpicture}

 }
	\smallskip
	\hrule
	\smallskip
		\caption{Formulas of CTL+Sync.\label{fig:example}}\end{center}
\end{figure}
\begin{comment}
\begin{figure}[!tb]
  \begin{center}
\input{figures/example.tex}
\caption{Examples.\label{fig:example}}
  \end{center}
\end{figure}
\end{comment}
Examples of formulas are given in \figurename~\ref{fig:example}.
The examples show the first steps of the unravelling of Kripke structures
defined over atomic propositions .
The formula  expresses that 
eventually holds synchronously on all paths, after the same 
number of steps (\figurename~\ref{fig:eventually}). 
This is different from the CTL formula , which expresses that all paths
eventually visit a state where  holds, but not necessarily
after the same number of steps in all paths.
The dual formula  requires that at every depth (i.e., for all positions ),
there exists a path where  holds at depth  (\figurename~\ref{fig:globally}). 
On the other hand note that  and dually .
Another example is the formula  expressing
that every subtree is eventually synchronizing (\figurename~\ref{fig:subtrees}).
The until universal formula  holds if  holds at a certain position
in every path (like for the formula ), and  holds in all
positions before (\figurename~\ref{fig:UA}). The until existential 
formula  says that it is possible to find path(s)
where  holds at the same position, and such that for all smaller positions 
there is one of those paths where  holds at that position (\figurename~\ref{fig:UE}).

\begin{remark}\label{rmk:not-regular}
The definition of CTL+Sync, although very similar to the definition of CTL,
interestingly allows to define non-regular properties, thus not expressible in CTL (or even in MSO over trees).
It is easy to show using a pumping argument that the property  
of eventually sychronizing is not regular (\figurename~\ref{fig:eventually}).
This property of eventually sychronizing can be expressed in MSO extended with
a length predicate, by a formula such as  where  and  is a monadic predicate 
for the proposition  over the binary tree , where  means that  holds in the last state of .
However, model-checking for the logic MSO extended with the ``equal-length'' predicate  defined by
 is undecidable~\cite[Theorem 11.6]{Thomas90}.
In contrast, we show in Theorem~\ref{theo:CTL+Sync-complexity} that the logic CTL+Sync is decidable.
\end{remark}


\subsection{Model-checking}\label{sec:mc}

Given a CTL+Sync formula , a Kripke structure , and a state , 
the \emph{model-checking problem for CTL+Sync} is to decide whether  holds.

Model-checking of CTL+Sync can be decided by considering a powerset construction for
the Kripke structure, and evaluating a CTL formula on it. 
For example, to evaluate a formula  from state  in a Kripke structure , 
it suffices to consider the sequence  defined by 
and  for all , where a set  is labeled by 
if  for all  (and analogously for ).
The formula  holds in  if and only if 
the formula  holds in the sequence 
(note that on a single sequence the operators  and  are 
equivalent, thus we simply write ).


For the formula , intuitively it 
holds in  if there exists a set  of finite paths  
from  in , all of the same length , such that  holds in the last state of 
for all , and for every  there is a path  such that 
 holds in the th state of . 
To evaluate  from , we construct
the Kripke structure 
where  if for all  there exists  such that
, thus we have to choose (nondeterministically) at least one 
successor from each state in , that is
for every set  of paths  as above,
there is a path  (with ) in 
where the sets  are obtained by following simultaneously the 
finite paths , thus such that  is the set of states at position~
of the paths in .
The path  in  corresponds to a set  of finite paths in 
that show that  holds if   holds in all states 
of , and ~ holds in some state of  ().
Hence we define the labeling function  in  as follows: 
for all  
let  if  for all , and
let  if  for some .
Finally it suffices to check whether the CTL formula  holds in  from .



This approach gives an exponential algorithm, and even a PSPACE algorithm 
by exploring the powerset construction on the fly. 
However, we show that the complexity of the model-checking problem is much below PSPACE. 
For example our model-checking algorithm for the formula 
relies on guessing a position  (in binary) and checking that  holds on all paths at position~. 
To compute the states reachable after exactly  steps, we compute the th
power of the transition matrix  where 
if there is a transition from state  to state . The power  can be computed 
in polynomial time by successive squaring of . For this formula, we obtain
an NP algorithm. For the whole logic, combining the guessing and squaring technique
with a dynamic programming algorithm that evaluates all subformlas, 
we obtain an algorithm in  for the model-checking problem.
We present a hardness result for the class  of
problems solvable in polynomial time using a parallel access to an NP oracle~\cite{Wagner87,Spako05}.


\begin{theorem}\label{theo:CTL+Sync-complexity}
The model-checking problem for CTL+Sync lies in  and is -hard.
\end{theorem}

\begin{proof}
{\bf Upper bound }. 
The upper bound is obtained by a labelling algorithm, similar to a standard
algorithm for CTL model-checking, that computes the set  
of states that satisfy a formula  in a recursive manner, following the structure of the formula: 
the algorithm is executed first on the subformulas of , and then the
result is used to compute the states satisfying the formula .
For the following formulas, the labelling algorithm for CTL+Sync is the same as 
the algorithm for CTL, thus in polynomial time~\cite{Schnoebelen02}:
\begin{itemize}
\item for , we use  , 
\item for , we have  is the complement of , 
\item for , we have  is the union of  and , and
\item for , we have ,
\item for , we have ,
\item for , we obtain  by a reachability analysis. 
\end{itemize}


For , we show that
deciding, given the sets  and  and a state , 
whether the state  belongs to  is a problem in NP 
as follows: guess a position  (represented in binary) 
and check that all paths of length~ from  end up in a state where  holds. This can be done in polynomial time by successive squaring of the transition
matrix of the Kripke structure~\cite[Theorem 6.1]{SM73}. 
Then, we need to check that  holds on all positions of all paths 
from~ of length smaller than~.
For , this condition is equivalent to ask that all reachable states 
satisfy  (because all reachable states are reachable in at most  steps), 
thus can be checked in polynomial time. 
For , we can compute in polynomial time all states reachable 
in at most  steps and check that  holds in all such states. 

For , we present an algorithm in 
 to decide if a given state  belongs to .
First guess a position  (represented in binary) and 
then decide the following problem: given , decide if 
for all  there exists a path  in  such that 
 holds in , and  holds in . This problem
can be solved in coNP as follows: guess  (represented in binary) 
and compute the set  of states that can be reached from  in exactly  steps
(using matrix squaring as above). From the set   of states that satisfy  in , compute the set of states reachable
in exactly  steps, and check that none satisfies  to show that
the instance of the problem is negative. Thus we obtain an algorithm in
. 

It follows that the model-checking problem for CTL+Sync is in .

{\bf Lower bound}.
The proof is based on the results of Lemma~\ref{lem:CTL+Sync-lower-bounds} 
that show NP-hardness of the model-checking problem for the formula .
Given a Boolean propositional formulas  in CNF, we can construct 
a Kripke structures  such that  is satisfiable if and only if the formula 
 holds in . 

By~\cite[Theorem~5.2]{Wagner87}, given  instances  of an NP-complete problem P (here 3SAT~\cite{Cook71}),
such that  implies  for all , in order to 
prove -hardness\footnote{The result of~\cite[Theorem~5.2]{Wagner87} 
shows -hardness, 
and ~\cite[Theorem~1]{BH91}.}  of the model-checking problem 
it is sufficient to construct a CTL+Sync formula  and a Kripke structure  such that 
 if and only if  is odd.
For each single instance  we can construct a CTL+Sync formula  
and Kripke structure  such that  if and only if  (i.e.,
the 3SAT formula  is satisfiable). Since CTL+Sync is closed under Boolean
operations , , and , it suffices to show that there exists
a polynomial-size Boolean formula  over variables  that holds if and only if
an odd number of the variables  are true, which is easy. 
Replacing in  the variables  by , and taking the union of 
the Kripke structures  (merging their initial states) and labeling all 
states of  by , we obtain a Kripke structure where  
the CTL+Sync formula  holds if and only if the number of yes-instances
among  is odd, thus showing -hardness of 
the model-checking problem.
\end{proof}

The complexity lower bounds for the model-checking problem in Theorem~\ref{theo:CTL+Sync-complexity}
are based on Lemma~\ref{lem:CTL+Sync-lower-bounds} where we establish complexity bounds for fixed formulas.
We recall that the problems in DP can be solved by a polynomial-time algorithm 
that uses only two calls to an oracle for an NP-complete problem. 
A classical DP-complete problem is to decide, given two Boolean formulas  
and , whether both  is satisfiable and  is valid.

\begin{lemma}\label{lem:CTL+Sync-lower-bounds}
Let  be two atomic propositions. The model-checking problem is:
\begin{itemize}
\item NP-complete for the formulas  and , 
\item DP-hard for the formula , and      \item coNP-complete for the formula .
\end{itemize}
\end{lemma}


\begin{proof}
We prove the hardness results (complexity lower bounds), since the complexity 
upper bounds follow from the proof of Theorem~\ref{theo:CTL+Sync-complexity}. 




The proof technique is analogous to the NP-hardness proof of~\cite[Theorem 6.1]{SM73},
and based on the following. Given a Boolean propositional formula  over variables
, consider the first  prime numbers . 
For a number , if  for all ,
then the binary vector  defines an assignment 
to the variables of the formula. Note that conversely, every such binary vector 
can be defined by some number  (by the Chinese remainder theorem).

{\bf NP-hardness of  (and thus of )}. 
The proof is by a reduction from the Boolean satisfiability problem 3SAT which is NP-complete~\cite{Cook71}.
Given a Boolean propositional formula  in CNF, with set  of (disjunctive) clauses
over variables  (where each clause contains three 
variables), we construct a Kripke structure  as follows:
for each clause , we construct a cycle  of length
 where the three variables in the clause are
, , and . We call  the origin of the cycle,
and we assign to every state  the label~ if the number  
defines an assignment that satisfies the clause .
The Kripke structure  is the disjoint union of the cycles corresponding to 
each clause, and an initial state  with transitions from  to the 
origin of each cycle. Note that the Kripke structure  can be constructed in 
polynomial time, as the sum of the first  prime numbers is bounded by a polynomial
in : ~\cite{BS96}.



It follows that a number  defines an assignment that satisfies the formula~ 
(i.e., satisfies all clauses of ) if and only if every path of 
length  from  reaches a state labelled by . 
Therefore the formula  is satisfiable if and only if ,
and it follows that the model-checking problem is NP-hard for the formulas 
 and for  (let  hold in every state of ).



\begin{figure}[!tb]
  \begin{center}
    	\hrule
		

\begin{gpicture}(120,76)(0,0)



\gasset{Nw=1,Nh=1,Nmr=.5, ExtNL=y, NLangle=180, NLdist=1, rdist=1, loopdiam=6}   





\rpnode[Nframe=n, Nfill=y, fillgray=.95](NodeName)(15,27)(12,8){}
\rpnode[Nframe=n, Nfill=y, fillgray=.95](NodeName)(35,27)(12,8){}
\rpnode[Nframe=n, Nfill=y, fillgray=.95](NodeName)(55,27)(12,8){}
\node[Nframe=n, iangle=90, ExtNL=n, NLangle=0, NLdist=0](NodeName)(70,27){}
\rpnode[Nframe=n, Nfill=y, fillgray=.95](NodeName)(85,27)(12,8){}

\node[Nframe=n, iangle=90, ExtNL=n, NLangle=0, NLdist=0](u10)(15,27){}
\node[Nframe=n, iangle=90, ExtNL=n, NLangle=0, NLdist=0](u10)(35,27){}
\node[Nframe=n, iangle=90, ExtNL=n, NLangle=0, NLdist=0](u10)(55,27){}
\node[Nframe=n, iangle=90, ExtNL=n, NLangle=0, NLdist=0](u10)(85,27){}


\put(100,51){\makebox(0,0)[l]{\small \begin{tabular}{l} holds \\ at th state \\ of th path.\end{tabular}}}
\put(100,27){\makebox(0,0)[l]{\small \begin{tabular}{l} holds \\ everywhere \\ in the cycles.\end{tabular}}}

\drawline[AHnb=0, linegray=.8, dash={1.5}0](5,67)(110,67)
\drawline[AHnb=0, linegray=.8, dash={1.5}0](5,36)(110,36)
\drawline[AHnb=0, linegray=.8, dash={1.5}0](5,18)(110,18)

\node[Nmarks=i, iangle=90, NLangle=145, Nfill=n](s0)(55,69){}
\node[Nmarks=i, iangle=90, NLangle=40, Nfill=n](s0)(55,69){}

\node[Nmarks=n, iangle=90, Nfill=n](s1)(15,64){}
\node[Nmarks=n, iangle=90](s2)(35,64){}
\node[Nmarks=n, iangle=90](s3)(55,64){}
\node[Nframe=n, iangle=90, ExtNL=n, NLangle=0, NLdist=0](s4)(68,64){}
\node[Nmarks=n, iangle=90](s4)(85,64){}

\drawedge[ELpos=50, ELside=r, curvedepth=0](s0,s1){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](s0,s2){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](s0,s3){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](s0,s4){}

\node[Nmarks=n, iangle=90](t1)(15,59){}
\node[Nmarks=n, iangle=90, Nfill=n](t2)(35,59){}
\node[Nmarks=n, iangle=90](t3)(55,59){}
\node[Nmarks=n, iangle=90](t4)(85,59){}

\drawedge[ELpos=50, ELside=r, curvedepth=0](s1,t1){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](s2,t2){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](s3,t3){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](s4,t4){}

\node[Nmarks=n, iangle=90](s1)(15,54){}
\node[Nmarks=n, iangle=90](s2)(35,54){}
\node[Nmarks=n, iangle=90, Nfill=n](s3)(55,54){}
\node[Nmarks=n, iangle=90](s4)(85,54){}

\drawedge[ELpos=50, ELside=r, curvedepth=0](t1,s1){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](t2,s2){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](t3,s3){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](t4,s4){}

\node[Nframe=n, iangle=90](t1)(15,49){}
\node[Nframe=n, iangle=90](t2)(35,49){}
\node[Nframe=n, iangle=90](t3)(55,49){}
\node[Nframe=n, iangle=90](t4)(85,49){}

\drawedge[ELpos=50, ELside=r, curvedepth=0](s1,t1){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](s2,t2){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](s3,t3){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](s4,t4){}

\node[Nframe=n, iangle=90, ExtNL=n, NLangle=0, NLdist=0](t1)(15,49){}
\node[Nframe=n, iangle=90, ExtNL=n, NLdist=0](t2)(35,49){}
\node[Nframe=n, iangle=90, ExtNL=n, NLdist=0](t3)(55,49){}
\node[Nframe=n, iangle=90, ExtNL=n, NLdist=0](t4)(85,49){}

\node[Nframe=n, iangle=90](s1)(15,45){}
\node[Nframe=n, iangle=90](s2)(35,45){}
\node[Nframe=n, iangle=90](s3)(55,45){}
\node[Nframe=n, iangle=90](s4)(85,45){}

\node[Nmarks=n, iangle=90](t1)(15,40){}
\node[Nmarks=n, iangle=90](t2)(35,40){}
\node[Nmarks=n, iangle=90](t3)(55,40){}
\node[Nframe=n, iangle=90, ExtNL=n, NLangle=0, NLdist=0](t4)(69,40){}
\node[Nmarks=n, iangle=90, Nfill=n](t4)(85,40){}


\drawedge[ELpos=50, ELside=r, curvedepth=0](s1,t1){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](s2,t2){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](s3,t3){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](s4,t4){}

\node[Nmarks=n, iangle=90, Nfill=y, NLangle=270](s1)(15,35){}
\node[Nmarks=n, iangle=90](s2)(35,35){}
\node[Nmarks=n, iangle=90, Nfill=y, NLangle=270](s3)(55,35){}
\node[Nmarks=n, iangle=90, Nfill=y, NLangle=270](s4)(85,35){}

\drawedge[ELpos=50, ELside=r, curvedepth=0](t1,s1){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](t2,s2){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](t3,s3){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](t4,s4){}




\node[Nmarks=n, iangle=90, Nfill=y, NLangle=290](u1)(11,34){}
\node[Nmarks=n, iangle=90](u2)(8,31){}
\node[Nmarks=n, iangle=90](u3)(7,27){}
\node[Nframe=n, iangle=90](u4)(8,23){}
\drawarc[dash={.2 1}0](15,27,8,220,260)

\node[Nframe=n, iangle=90](u6)(15,19){}
\node[Nmarks=n, iangle=90, Nfill=y, NLangle=120](u7)(19,20){}
\node[Nmarks=n, iangle=90](u8)(22,23){}
\node[Nmarks=n, iangle=90](u9)(23,27){}
\node[Nmarks=n, iangle=90](u10)(22,31){}
\node[Nmarks=n, iangle=90](u11)(19,34){}


\drawedge[ELpos=50, ELside=r, curvedepth=0](s1,u1){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](u1,u2){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](u2,u3){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](u3,u4){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](u6,u7){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](u7,u8){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](u8,u9){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](u9,u10){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](u10,u11){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](u11,s1){}


\node[Nmarks=n, iangle=90, Nfill=y, NLangle=290](u1)(31,34){}
\node[Nmarks=n, iangle=90](u2)(28,31){}
\node[Nframe=n, iangle=90](u3)(27,27){}

\drawarc[dash={.2 1}0](35,27,8,190,18)

\node[Nframe=n, iangle=90](u10)(42,31){}
\node[Nmarks=n, iangle=90](u11)(39,34){}


\drawedge[ELpos=50, ELside=r, curvedepth=0](s2,u1){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](u1,u2){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](u2,u3){}

\drawedge[ELpos=50, ELside=r, curvedepth=0](u10,u11){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](u11,s2){}




\node[Nmarks=n, iangle=90](u1)(51,34){}
\node[Nmarks=n, iangle=90, Nfill=y, NLangle=330](u2)(48,31){}
\node[Nframe=n, iangle=90](u3)(47,27){}

\drawarc[dash={.2 1}0](55,27,8,190,18)

\node[Nframe=n, iangle=90](u10)(62,31){}
\node[Nmarks=n, iangle=90](u11)(59,34){}


\drawedge[ELpos=50, ELside=r, curvedepth=0](s3,u1){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](u1,u2){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](u2,u3){}

\drawedge[ELpos=50, ELside=r, curvedepth=0](u10,u11){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](u11,s3){}



\node[Nmarks=n, iangle=90, Nfill=y, NLangle=290](u1)(81,34){}
\node[Nmarks=n, iangle=90](u2)(78,31){}
\node[Nframe=n, iangle=90](u3)(77,27){}

\drawarc[dash={.2 1}0](85,28,8,190,18)

\node[Nframe=n, iangle=90](u10)(92,31){}
\node[Nmarks=n, iangle=90](u11)(89,34){}


\drawedge[ELpos=50, ELside=r, curvedepth=0](s4,u1){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](u1,u2){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](u2,u3){}

\drawedge[ELpos=50, ELside=r, curvedepth=0](u10,u11){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](u11,s4){}




\put(7,14){\makebox(0,0)[l]{}} 
\put(7,9){\makebox(0,0)[l]{}} 
\put(7,4){\makebox(0,0)[l]{}}













\end{gpicture}

 \hrule
	\smallskip
	\caption{Reduction to show NP-hardness of  in Lemma~\ref{lem:CTL+Sync-lower-bounds}.\label{fig:redcution}}
  \end{center}
\end{figure}

{\bf NP-hardness of }. 
The proof is by a reduction from 3SAT~\cite{Cook71}.
The reduction is illustrated in \figurename~\ref{fig:redcution}.
Given a Boolean propositional formula  in CNF, with set  of (disjunctive) 
clauses over variables  (where each clause contains three 
variables), we construct a Kripke structure  as follows: let 
be the number of clauses in , and construct  disjoint simple paths  
from  of length  (of the form ), where the last state 
of each path  has a transition to the origin of a cycle corresponding to the th clause (the cycles 
and their labeling are as defined in the NP-hardness proof of ). 
The state  and all states of the cycles are also labelled by~, 
and in the th path from , the th state after  is labelled by~.
The construction can be obtained in polynomial time.

We show that  is satisfiable if and only if the formula   
holds from  in . Recall that  holds
if there exists  such that for all , there exists
a path  in  with  and  and 
.

For the first direction of the proof, if  is satisfiable,
then let  define a satisfying assignment, and let . 
Then all paths of length  from  in  end up in a state labelled by~. 
Now we consider an arbitrary  and show that there exists a path of length 
from  that ends up in a state labelled by~, and with the th state labelled
by . For  and for , the conditions are satisfied by all paths,
and for , the conditions are satisfied by the th path from .

For the second direction of the proof, let  be a position such that for all , 
there exists a path  in  with  and 
 and . Then  since only the states
in the cycles are labelled by~. Consider the set  containing, for each ,
a path  in  with  and . 
It is easy to see by the construction of  that  contains all the paths 
of length  in . Therefore, all paths of length  from the
origin of each cycle end up in a state labelled by~. It follows that 
defines an assignment that satisfies all clauses in , thus 
is satisfiable.

{\bf DP-hardness of }. 
First we present a coNP-hardness proof for  that uses a reduction of the same flavor as 
in the NP-hardness of ,
by a reduction from the Boolean validity problem (dual of 3SAT) which is coNP-complete~\cite{Cook71}.
Given a Boolean propositional formula  in DNF, with set  of (conjunctive)
clauses over variables  (where each clause contains 
three variables), we construct a Kripke structure  with the same structure
as in the NP-hardness of , only the labeling is different, and defined
as follows: in each cycle , we label by  the last state 
, and we label by  all states  such that either  the number  
defines an assignment that satisfies the clause corresponding to the cycle,
or  the number  does not define a binary assignment.
Finally, we label by  the initial state~.

It follows from this construction that the following are equivalent:
\begin{itemize}
\item there exists an assignment that falsifies the formula  (i.e., falsifies
all clauses in );
\item there is a length  such that every path of length  from  in 
ends up in a state that is not labeled by  (in fact the number  
corresponds to a binary assignment by , that falsifies all clauses by ),
that is the formula  does not hold from .
\end{itemize}

We show that  is valid (is satisfied by all assignments) if and only if
 holds from  in .

For the first direction of the proof, if  is valid,
then let  and note that every path
of length  from  ends up in a state labeled by . Now for every
, either  defines a binary assignment and since  is valid, 
the assignment satisfies some clause in , or  does not define a binary 
assignment. In both cases (and also for ), there exists a path of length  
from  that ends up in a state labeled by , that can be prolonged to 
a path of length , thus ending up in a state labeled by . This shows that
 holds.

For the second direction of the proof, let  be such that for all , 
there exists a path  in  with  and 
 and . Consider the set of all such paths
corresponding to , and the set of cycles visited by these
paths (each path starts in  and visits one cycle). We claim that 
the subformula of  consisting of the clauses corresponding to those cycles
is valid, which entails the validity of . To show this, we can assume
without loss of generality that every cycle is visited for some  (we can ignore
the cycles that are not visited, and remove from  the corresponding clauses).
It follows that , and every assignment of the 
variables in  is represented by some number . For all such~,
there is a path of length  that ends up in a state labeled by , hence
the corresponding assignment satisfies a clause in , thus satisfies .
It follows that  is satisfied by all assignments, and  is valid. 

The DP-hardness follows by carefully  combining the NP-hardness and coNP-hardness proofs
of . 

{\bf coNP-hardness of }. The result follows from
the NP-hardness of  since  is equivalent to .
\end{proof}





The complexity result of Theorem~\ref{theo:CTL+Sync-complexity} is not tight, with a  upper bound and a -hard lower bound.
Even for the fixed formula , the gap between our 
upper bound and the DP-hardness result provides an interesting open question for future work. 

\section{Extension of CTL+Sync with Always and Eventually} \label{sec:extension}

We consider an extension of CTL+Sync with formulas of the form 
where  is a sequence of unary temporal operators Eventually (F) and Always (G).
For example, the formula  expresses strong synchronization, 
namely that from some point on, all positions on every path satisfy ;
the formula  expresses weak synchronization, namely that
there are infinitely many positions such that, on every path at those positions
 holds. In fact only the combination of operators  and  need to be 
considered, as the other combinations of operators reduce to either 
 or  using the LTL identities  
and . 

Formally, define:

\begin{itemize}
\item  if for all , there exists  
such that for all paths  in  with , we have .

\item  if for all , there exists  and
there exists a path  in  with  such that .





\item  if .

\item  if .
\end{itemize}


The model-checking problem for the formula  is NP-complete:
guess positions  (represented in binary) and 
check in polynomial time that the states reachable by all paths of length  satisfy ,
and that set of the states reachable after  steps is the same as the set
of states reachable after  steps, where . 
This corresponds to finding a lasso in the subset construction for the Kripke 
structure~. A matching NP lower bound follows from the reduction in the
NP-hardness proof of  (Lemma~\ref{lem:CTL+Sync-lower-bounds}).

The model-checking problem for the formula  can be solved
in polynomial time, as this formula is equivalent to saying that there exists
a state labeled by  that is reachable from a reachable non-trivial 
strongly connected component (SCC) --- an SCC is trivial if it consists of a single state without self-loop. 
To prove this, note that if a state  labeled by  is reachable 
from a reachable non-trivial SCC, then  can be reached by an arbitrarily 
long path, thus the formula  holds. For the other direction,
if no state labeled by~ is reachable from a reachable non-trivial SCC,
then every path to a state labeled by  is acyclic (otherwise, the path 
would contain a cycle, belonging to an SCC). Since acyclic paths have length at
most , it follows that the formula  does not
hold, which concludes the proof.

From the above arguments, it follows that the complexity status of the 
model-checking problem for this extension of CTL+Sync is the same as the 
complexity of CTL+Sync model-checking in Theorem~\ref{theo:CTL+Sync-complexity}.

\begin{theorem}\label{theo:CTL+Sync-extended-complexity}
The model-checking problem for CTL+Sync extended with sequences of unary 
temporal operators lies in  and is -hard.
\end{theorem}

\section{Expressive Power}\label{sec:expressivity}

The expressive power of CTL+Sync (even extended with Always and Eventually) 
is incomparable with the expressive power of MSO. 
By the remark at the end of Section~\ref{sec:ss}, CTL+Sync can express non-regular
properties, and thus is not subsumed by MSO, and standard argument based on counting properties~\cite{Wolper83}
showing that CTL is less expressive than MSO apply straightforwardly to show that 
formulas of MSO are not expressible in CTL+Sync~\cite{CGP01}.

We show that the formulas  and  for weak and strong synchronization
cannot be expressed in the logic CTL+Sync, thus CTL+Sync extended with sequences of unary 
temporal operators is strictly more expressive than CTL+Sync. 
The result holds if the Next operator is not allowed, and also if the 
Next operator is allowed.



\begin{figure}[!tb]\begin{center}
    	\hrule
		


\begin{gpicture}(48,44)(0,0)



\gasset{Nw=1.5,Nh=1.5,Nmr=.75, ExtNL=y, NLangle=180, NLdist=1, rdist=1, loopdiam=6}   






\node[Nmarks=n, Nfill=y, NLdist=1, NLangle=160](s1)(5,40){}
\node[Nmarks=n, Nfill=n, NLdist=1, NLangle=160](s2)(5,34){}
\node[Nmarks=n, Nfill=y, NLdist=1, NLangle=160](s3)(5,28){}
\node[Nmarks=n, Nfill=n, NLdist=1, NLangle=160](s4)(5,22){}
\node[Nmarks=n, Nfill=y, NLdist=1, NLangle=160](s5)(5,16){}
\node[Nmarks=n, Nfill=n, NLdist=1, NLangle=160](s6)(5,10){}
\node[Nframe=n, Nfill=n, ExtNL=n, NLdist=0, NLangle=160, Nh=3](s7)(5,4){}

\drawedge[ELpos=50, ELside=r, curvedepth=0](s1,s2){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](s2,s3){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](s3,s4){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](s4,s5){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](s5,s6){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](s6,s7){}


\node[Nmarks=n, Nfill=y, NLdist=1, NLangle=160](t1)(20,40){}
\node[Nmarks=n, Nfill=n, NLdist=1, NLangle=170](t2)(17,34){}
\node[Nmarks=n, Nfill=n, NLdist=1, NLangle=10](t3)(23,34){}
\node[Nmarks=n, Nfill=y, NLdist=1, NLangle=170](t4)(17,28){}
\node[Nmarks=n, Nfill=n, NLdist=1, NLangle=10](t5)(23,28){}
\node[Nmarks=n, Nfill=n, NLdist=1, NLangle=10](t6)(17,22){}
\node[Nmarks=n, Nfill=y, NLdist=1, NLangle=10](t7)(23,22){}
\node[Nmarks=n, Nfill=y, NLdist=1, NLangle=10](t8)(17,16){}
\node[Nmarks=n, Nfill=n, NLdist=1, NLangle=10](t9)(23,16){}
\node[Nmarks=n, Nfill=n, NLdist=1, NLangle=10](t10)(17,10){}
\node[Nmarks=n, Nfill=y, NLdist=1, NLangle=10](t11)(23,10){}
\node[Nframe=n, Nfill=n, ExtNL=n, NLdist=0, NLangle=160, Nh=3](t12)(17,4){}
\node[Nframe=n, Nfill=n, ExtNL=n, NLdist=0, NLangle=160, Nh=3](t13)(23,4){}

\drawedge[ELpos=50, ELside=r, curvedepth=0](t1,t2){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](t1,t3){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](t2,t4){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](t3,t5){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](t4,t6){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](t5,t7){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](t6,t8){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](t7,t9){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](t8,t10){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](t9,t11){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](t10,t12){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](t11,t13){}


\node[Nmarks=n, Nfill=y, NLdist=1, NLangle=160](s4)(40,28){}
\put(43,28){\makebox(0,0)[l]{\small }}

\node[Nmarks=n, Nfill=n, NLdist=1, NLangle=160](s5)(40,22){}
\put(43,22){\makebox(0,0)[l]{\small }}















\end{gpicture}

 \hrule
	\smallskip
	\caption{States  and  are indistinguishable by formulas of CTL+Sync.\label{fig:FG}}\end{center}
\end{figure}


\begin{comment}
\begin{theorem}\label{theo:CTL+Sync-extended-expressive-power}
The logic CTL+Sync without the Next operator extended with sequences of unary 
temporal operators is strictly more expressive than CTL+Sync (without the Next operator).
\end{theorem}

\begin{proof}
Consider the Kripke structure in \figurename~\ref{fig:FG} where the states
reachable from  are satisfying alternately  and ,
and the states reachable from  and  are satisfying alternately  and .
Call black states the states where  holds, and white states the states where  holds.
It is easy to see that  and .
We now show that for all CTL+Sync formulas , we have
, which shows that no formula in
CTL+Sync is equivalent to .
To prove this, we show that for all states  if , then
for all CTL+Sync formulas , we have ,
that is all black states satisfy the same set of CTL+Sync formulas, and all 
white states satisfy the same set of CTL+Sync formulas.
The proof is by induction on the nesting depth of formulas (i.e., the largest number
of nested operators in the formula).
First the result holds trivially for formulas of nesting depth , that
is atomic propositions. For the induction, assume that the result holds for all CTL+Sync formulas 
of nesting depth at most , and consider a formula  of nesting depth .
Let  be two states with , and consider the following cases:
\begin{itemize}
\item if  or  
where  and  are of nesting depth at most , then 
the result holds since  and  agree on the satisfaction of  and 
by the induction hypothesis.

\item if  or , 
then since from  and  all paths have the same alternation sequence between
black and white states (on all paths, there are infinitely many alternations of black and white 
state), and since all black (resp., white) states agree on the satisfaction
of  and  by the induction hypothesis, 
it easy to check that all paths from  and  agree on the satisfaction of 
the until formulas  and .

\item if  or , 
then if  is satisfied from , either 
\begin{itemize}
\item  holds in , and then  also holds in , thus 
 is satisfied from ,
\item or  holds in the other color than the color of , and then
 holds in ; it follows that  holds in , and either
 holds in all successors of  (if ), or 
 holds in the successor of  and  holds in the
successor of the successor of  (if ); thus  is 
satisfied from  (only  has more than one successor, and the successors
of  satisfy both the same formulas of nesting depth at most ).
\end{itemize}

\end{itemize}
\end{proof}
\end{comment}

\begin{comment}
\begin{figure}[!tb]\begin{center}
    \hrule
		\input{figures/next.tex}\hrule
	\end{center}
	\caption{States  and  are indistinguishable by formulas of CTL+Sync with the Next operator,
of nesting depth at most .\label{fig:next}}\end{figure}
\end{comment}

\begin{theorem}\label{theo:CTL+Sync-extended-expressive-power-2}
The logic CTL+Sync (even without the Next operator) extended with sequences of unary 
temporal operators is strictly more expressive than CTL+Sync (even using the Next operator).
\end{theorem}

\begin{proof}
We show that the formula  cannot be expressed in CTL+Sync, even using
the Next operator. To prove this, given an arbitrary CTL+Sync formula ,
we construct two Kripke structures such that  holds in both Kripke structures,
but the formula  holds in one and not in the other. It follows that 
 is not equivalent to .



Given the formula , we construct the two Kripke structures as follows.
First, consider two Kripke structures whose unravelling is shown in \figurename~\ref{fig:FG}
where the states reachable from  are satisfying alternately  and ,
and the states reachable from  and  are satisfying alternately  and .
Call black states the states where  holds, and white states the states where  holds.
If  is the maximum number of nested Next operators in , 
then we construct the -stuttering of the two Kripke structures in \figurename~\ref{fig:FG},
where the -stuttering of a Kripke structure 
is the Kripke structure  
where  for all , and 
the transition relation  contains
all pairs  for all  and ,
and all pairs  for all .

We claim that the formula  holds either in both  and ,
or in none of  and , while the formula  holds in  and not in .
We show by induction on the nesting depth of CTL+Sync formulas  (that
have at most  nested Next operators)
that  and  are equivalent for  (for all ),
and that for all black states , the copies  and  are equivalent for ,
and analogously for all pairs of white states.

The result holds trivially for formulas of nesting depth , that is atomic propositions.
For the induction step, assume the claim holds for formulas of nesting depth ,
and consider a formula  of nesting depth . If the outermost operator
of  is a Boolean operator, or a CTL operator ( or ), 
then the result follows from the induction hypothesis and the result of~\cite[Theorem~2]{KS05}
showing two paths that differ only in the number of consecutive repetitions of a state,
as long as the number of repetitions is at least , are equivalent for the formulas 
with at most  nested Next operators.
If the outermost operator of  is either  or , that is
 or ,
then consider a state where  holds: either  holds in that state,
and by the induction hypothesis,  also holds in the corresponding state (that we
claimed to be equivalent),
or  holds in the states of the other color than the current state, 
and  holds on the path(s) at all positions before. By the induction 
hypothesis, at the same distance from the claimed equivalent states, 
we can find a state where  holds in all paths, and  holds on all positions before,
which concludes the proof for the induction step.
\end{proof}


\section{Distinguishing Power}\label{sec:distinguising}


\begin{comment}
\begin{figure}[!tb]
  \begin{center}
    \hrule
    


\begin{gpicture}(50,34)(0,0)



\gasset{Nw=1.5,Nh=1.5,Nmr=.75, ExtNL=y, NLangle=180, NLdist=1, rdist=1, loopdiam=6}   






\node[Nmarks=n, Nfill=y, NLdist=1, NLangle=160](s1)(31,29){}
\node[Nmarks=n, Nfill=y, NLdist=1, NLangle=160](s2)(31,21){}
\node[Nmarks=n, Nfill=n, NLdist=1, NLangle=160](s3)(31,13){}


\node[Nmarks=n, Nfill=y, NLdist=1, NLangle=160](t1)(21,29){}
\node[Nmarks=n, Nfill=y, NLdist=1, NLangle=160](t2)(21,21){}
\node[Nmarks=n, Nfill=y, NLdist=1, NLangle=160](t3)(21,13){}
\node[Nmarks=n, Nfill=n, NLdist=1, NLangle=160](t4)(21,5){}


\drawedge[ELpos=50, ELside=r, curvedepth=0](s1,s2){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](s1,t2){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](s2,s3){}
\drawloop[ELpos=50, loopangle=225, loopdiam=3](s3){}


\drawedge[ELpos=50, ELside=r, curvedepth=0](t1,t2){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](t2,t3){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](t3,t4){}
\drawloop[ELpos=50, loopangle=225, loopdiam=3](t4){}




















\end{gpicture}


     \hrule
    \caption{The states  and  are stuttering bisimilar (they satisfy the same CTL formulas
without the Next operator), but they can be distinguished by the CTL+Sync formula
 which holds in  but not in . \label{fig:stut-bisimilar-distinguishable}}
  \end{center}
\end{figure}
\end{comment}

Two states of a Kripke structure can be distinguished by a logic if there 
exists a formula in the logic that holds in one state but not in the other.
Each logic induces an indistinguishability relation (which is an equivalence)
on Kripke structures that characterizes the distinguishing power of the logic.
Two states  and  of a Kripke structure  are indistinguishable by 
a logic  if they satisfy the same formulas of , that is
.

For CTL (with the Next operator), the distinguishing power is standard bisimulation,
and for CTL without the Next operator, the distinguishing power is stuttering
bisimulation~\cite{BCG88}. Stuttering bisimulation is a variant of bisimulation
where intuitively several transitions can be used to simulate a single transition,
as long as the intermediate states of the transitions are all equivalent (for 
stuttering bisimulation). We omit the definition of bisimulation and
stuttering bisimulation~\cite{BCG88}, and in this paper we consider that they 
are defined as the distinguishing power of respectively CTL and CTL without 
the Next operator.

It is easy to show by induction on the nesting depth of formulas that the distinguishing 
power of CTL+Sync is the same as for CTL, since  CTL+Sync contains CTL, and 
 if two states  and 
are bisimilar, there is a correspondence between the paths starting
from  and the paths starting from  (for every path from , there is a
path from  such that their states at position~ are bisimilar, for all , and analogously for every path
of ~\cite[Lemma 3.1]{BCG88}), which implies the satisfaction of the same formulas in CTL+Sync.
The same argument holds for CTL+Sync extended with unary temporal operators (Section~\ref{sec:extension}).




\begin{theorem}\label{theo:CTL+Sync-bisimulation}
Two states  and  of a Kripke structure  
are indistinguishable by CTL+Sync formulas (even extended with unary temporal operators)
if and only if  and  are bisimilar. 
\end{theorem}

Without the Next operator, the logic CTL+Sync has a distinguishing power that
lies strictly between bisimulation and stuttering bisimulation, as shown
by the examples in \figurename~\ref{fig:stut-bisimilar-distinguishable} 
and \figurename~\ref{fig:indistinguishable-not-bisimilar}.
Indistinguishability by CTL+Sync formulas without the Next operator implies
indistinguishability by standard CTL without the Next operator, and thus
stuttering bisimilarity. We obtain the following result.

\begin{theorem}\label{theo:CTL+Sync-without-next-indistinguishability}
The following implications hold for all states  of a Kripke structure :
\begin{itemize}

\item if  and  are bisimilar, then  and  are indistinguishable 
by CTL+Sync formulas without the Next operator (even extended with unary temporal operators);

\item if  and  are indistinguishable by CTL+Sync formulas without the Next operator
(even extended with unary temporal operators), then  and  are stuttering bisimilar.

\end{itemize}
\end{theorem}

It follows from the first part of Theorem~\ref{theo:CTL+Sync-without-next-indistinguishability}
that the state-space reduction techniques based on computing a bisimulation quotient before evaluating
a CTL formula will work for CTL+Sync. Although the exact indistinguishability
relation for CTL+Sync is coarser than bisimulation, we show that deciding this 
relation is NP-hard, and thus it may not be relevant to compute it for
quotienting before model-checking, but rather use the polynomial-time
computable bisimulation.

\begin{figure}[!tb]\begin{center}
    \hrule
		\subfloat[The states  and  are stuttering bisimilar (they satisfy the same CTL formulas
without the Next operator), but they can be distinguished by the CTL+Sync formula
 which holds in  but not in . \label{fig:stut-bisimilar-distinguishable}]{


\begin{gpicture}(50,34)(0,0)



\gasset{Nw=1.5,Nh=1.5,Nmr=.75, ExtNL=y, NLangle=180, NLdist=1, rdist=1, loopdiam=6}   






\node[Nmarks=n, Nfill=y, NLdist=1, NLangle=160](s1)(31,29){}
\node[Nmarks=n, Nfill=y, NLdist=1, NLangle=160](s2)(31,21){}
\node[Nmarks=n, Nfill=n, NLdist=1, NLangle=160](s3)(31,13){}


\node[Nmarks=n, Nfill=y, NLdist=1, NLangle=160](t1)(21,29){}
\node[Nmarks=n, Nfill=y, NLdist=1, NLangle=160](t2)(21,21){}
\node[Nmarks=n, Nfill=y, NLdist=1, NLangle=160](t3)(21,13){}
\node[Nmarks=n, Nfill=n, NLdist=1, NLangle=160](t4)(21,5){}


\drawedge[ELpos=50, ELside=r, curvedepth=0](s1,s2){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](s1,t2){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](s2,s3){}
\drawloop[ELpos=50, loopangle=225, loopdiam=3](s3){}


\drawedge[ELpos=50, ELside=r, curvedepth=0](t1,t2){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](t2,t3){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](t3,t4){}
\drawloop[ELpos=50, loopangle=225, loopdiam=3](t4){}




















\end{gpicture}


 }
		\quad
		\subfloat[The states  and  are indistinguishable by CTL+Sync formulas,
but they are not bisimilar, i.e. they can be distinguished by CTL formulas 
with the Next operator, for example  which holds
in  but not in . \label{fig:indistinguishable-not-bisimilar}]{


\begin{gpicture}(52,34)(0,0)



\gasset{Nw=1.5,Nh=1.5,Nmr=.75, ExtNL=y, NLangle=180, NLdist=1, rdist=1, loopdiam=6}   






\node[Nmarks=n, Nfill=y, NLdist=1, NLangle=160](s1)(31,29){}
\node[Nmarks=n, Nfill=n, NLdist=1, NLangle=160](s2)(31,21){}
\node[Nmarks=n, Nfill=n, NLdist=1, NLangle=160](s3)(31,13){}
\node[Nmarks=n, Nfill=y, NLdist=1, NLangle=160](s4)(31,5){}

\node[Nmarks=n, Nfill=y, NLdist=1, NLangle=160](t1)(21,29){}
\node[Nmarks=n, Nfill=n, NLdist=1, NLangle=160](t2)(21,21){}
\node[Nmarks=n, Nfill=y, NLdist=1, NLangle=160](t3)(21,13){}
\node[Nmarks=n, Nfill=n, NLdist=1, NLangle=160](t4)(21,5){}


\drawedge[ELpos=50, ELside=r, curvedepth=0](s1,s2){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](s1,t2){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](s2,s3){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](s3,s4){}
\drawedge[ELpos=50, ELside=r, curvedepth=-3](s4,s3){}

\drawedge[ELpos=50, ELside=r, curvedepth=0](t1,t2){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](t2,t3){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](t3,t4){}
\drawedge[ELpos=50, ELside=r, curvedepth=3](t4,t3){}



















\end{gpicture}


 }
\quad
		\subfloat{


\begin{gpicture}(10,34)(0,0)



\gasset{Nw=1.5,Nh=1.5,Nmr=.75, ExtNL=y, NLangle=180, NLdist=1, rdist=1, loopdiam=6}   






\node[Nmarks=n, Nfill=y, NLdist=1, NLangle=160](s4)(2,21){}
\put(5,21){\makebox(0,0)[l]{\small }}

\node[Nmarks=n, Nfill=n, NLdist=1, NLangle=160](s5)(2,13){}
\put(5,13){\makebox(0,0)[l]{\small }}















\end{gpicture}


 }
\hrule
	\smallskip
	\caption{The distinguishing power of CTL+Sync lies strictly between bisimulation and stuttering bisimulation. \label{fig:distinguishing}}\end{center}
\end{figure}


\begin{comment}
\begin{figure}[!tb]
  \begin{center}
    \hrule
    


\begin{gpicture}(52,34)(0,0)



\gasset{Nw=1.5,Nh=1.5,Nmr=.75, ExtNL=y, NLangle=180, NLdist=1, rdist=1, loopdiam=6}   






\node[Nmarks=n, Nfill=y, NLdist=1, NLangle=160](s1)(31,29){}
\node[Nmarks=n, Nfill=n, NLdist=1, NLangle=160](s2)(31,21){}
\node[Nmarks=n, Nfill=n, NLdist=1, NLangle=160](s3)(31,13){}
\node[Nmarks=n, Nfill=y, NLdist=1, NLangle=160](s4)(31,5){}

\node[Nmarks=n, Nfill=y, NLdist=1, NLangle=160](t1)(21,29){}
\node[Nmarks=n, Nfill=n, NLdist=1, NLangle=160](t2)(21,21){}
\node[Nmarks=n, Nfill=y, NLdist=1, NLangle=160](t3)(21,13){}
\node[Nmarks=n, Nfill=n, NLdist=1, NLangle=160](t4)(21,5){}


\drawedge[ELpos=50, ELside=r, curvedepth=0](s1,s2){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](s1,t2){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](s2,s3){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](s3,s4){}
\drawedge[ELpos=50, ELside=r, curvedepth=-3](s4,s3){}

\drawedge[ELpos=50, ELside=r, curvedepth=0](t1,t2){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](t2,t3){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](t3,t4){}
\drawedge[ELpos=50, ELside=r, curvedepth=3](t4,t3){}



















\end{gpicture}


     \hrule
    \caption{The states  and  are indistinguishable by CTL+Sync formulas,
but they are not bisimilar, i.e. they can be distinguished by CTL formulas 
with the Next operator, for example  which holds
in  but not in . \label{fig:indistinguishable-not-bisimilar}}
  \end{center}
\end{figure}
\end{comment}

\begin{theorem}\label{theo:CTL+Sync-without-next-NP-hard}
Deciding whether two states of a Kripke structure are indistinguishable 
by CTL+Sync formulas without the Next operator is NP-hard.
\end{theorem}

\begin{proof}
The proof is by a reduction from the Boolean satisfiability problem 3SAT which is NP-complete~\cite{Cook71}.
Given a Boolean propositional formula  in CNF, we construct 
two Kripke structures  and  that are indistinguishable (from their initial state)
if and only if  is satisfiable, where:
\begin{itemize}
\item  is the Kripke structure shown in \figurename~\ref{fig:indistinguishable}, and 
\item  is the Kripke structure constructed in the NP-hardness proof of  (Lemma~\ref{lem:CTL+Sync-lower-bounds}).
\end{itemize}

We assume that  contains at 
least one clause with both a positive and a negative literal 
and one clause with only negative literals. This assumption 
induces no loss of generality because we can always add two
such clauses to a formula without changing its satisfiability 
status (e.g., by introducing new variables).
This assumption ensures that at least one successor of  satisfies~ 
and at least one successor of  satisfies , exactly like from  in . 
This ensures, for example, that  and  agree on the formula  
(which does not hold). 

We know from the proof of Lemma~\ref{lem:CTL+Sync-lower-bounds}
that  if and only if  is satisfiable.
Hence, it suffices to show that  and  are indistinguishable
if and only if the formula  holds in . 
Since the formula  holds in , we only need to show that 
if  holds in , then  and  are indistinguishable.

To do this, we assume that  holds in , and we show that 
for all CTL+Sync formulas  without the Next operator, 
 if and only if .

First note that from every state  of  or  that is not
an initial state ( and ), the transitions are
deterministic (i.e., there is only one path starting from ), and it follows
that the existential path quantifiers is equivalent to the universal path quantifier
and they can be freely switched with other quantifiers
and put in front of formulas without changing their truth value. 
Hence the operators  and  are equivalent, 
as well as  and , and thus CTL+Sync is the same as just CTL in those states. 
Moreover, the sequence of states on those paths alternate (up to stuttering) 
between states that satisfy  and states that satisfy  (or vice versa).
Therefore, all such states that satisfy~ are stuttering bisimilar and thus
satisfy all the same CTL+Sync formulas, and all such states that satisfy  are stuttering 
bisimilar and thus also satisfy all the same CTL+Sync formulas~\cite{BCG88}.


\begin{figure}[!tb]
  \begin{center}
	\hrule
		

\begin{gpicture}(120,40)(0,0)












\node[Nmarks=i, iangle=90, NLangle=145, Nfill=n](s0)(55,30){}
\node[Nmarks=i, iangle=90, ExtNL=y, NLdist=1, NLangle=130, Nfill=n](s0)(55,30){}


\node[Nmarks=n, iangle=90, Nfill=n](s1)(42,20){}
\node[Nmarks=n, iangle=90, ExtNL=y, NLdist=1, NLangle=130, Nfill=n](s1)(42,20){}
\node[Nmarks=n, iangle=90, Nfill=n](s2)(42,5){}
\node[Nmarks=n, iangle=90, ExtNL=y, NLdist=1, NLangle=150, Nfill=n](s2)(42,5){}

\node[Nmarks=n, iangle=90, ExtNL=n, Nfill=n](s3)(68,20){}
\node[Nmarks=n, iangle=90, ExtNL=y, NLdist=1, NLangle=50, Nfill=n](s3)(68,20){}
\node[Nmarks=n, iangle=90, Nfill=n](s4)(60,5){}
\node[Nmarks=n, iangle=90, ExtNL=y, NLdist=1, NLangle=130, Nfill=n](s4)(60,5){}
\node[Nmarks=n, iangle=90, Nfill=n](s5)(76,5){}
\node[Nmarks=n, iangle=90, ExtNL=y, NLdist=1, NLangle=50, Nfill=n](s5)(76,5){}



\drawedge[ELpos=50, ELside=r, curvedepth=0](s0,s1){}
\drawedge[ELpos=50, ELside=r, curvedepth=-4](s1,s2){}
\drawedge[ELpos=50, ELside=r, curvedepth=-4](s2,s1){}


\drawedge[ELpos=50, ELside=r, curvedepth=0](s0,s3){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](s3,s4){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](s4,s5){}
\drawedge[ELpos=50, ELside=r, curvedepth=0](s5,s3){}














\end{gpicture}

 \hrule
	\smallskip
	\caption{The Kripke structure  in the proof of Theorem~\ref{theo:CTL+Sync-without-next-NP-hard}. \label{fig:indistinguishable}}
  \end{center}
\end{figure}

Now we prove by induction on the structure of the CTL+Sync formulas  that 
the states  and  satisfy the same formulas, and thus  and  
are indistinguishable. 
The result holds when  is an atomic proposition. 
We assume that the result holds for all CTL+Sync formulas
with at most  nested operators, and we consider an arbitrary formula 
with at most  nested operators, and show that the result hold for .

Note that by the induction hypothesis, we can partition the states into three kinds 
such that all states of a kind satisfy the same formulas with at most  nested operators:
the states of the first kind are the initial states  and ,
the second kind is the states that are not initial and satisfy ,
and the third kind is the states that satisfy  (which are also not initial).
Hence the formulas with at most  nested operators can be classified
according to which kind of states satisfy them, thus in  classes.
Therefore, the proof for the induction case boils down to a tedious but straightforward
case analysis, summarized as follows: 



\begin{itemize}
\item If  or ,
then the claim holds easily by the induction hypothesis.

\item If , then 

\begin{itemize}
\item either  holds in the states that satisfy , and for example 
 holds in the states that satisfy . Then 
holds in all states, thus both in  and in ;

\item or  holds in the states that satisfy , and then 
(and also ) holds in all states that satisfy , by the induction
hypothesis. Hence  holds both in  and in .
\end{itemize}

\item If , then the interesting case 
is when  holds in the states that satisfy , and for example 
 holds in the states that satisfy . By our assumption
on the Boolean CNF formula , we have that  does not hold in 
 nor in . Other cases are treated analogously, in particular
for , we have , 
which holds in  and in .

\item If , the analysis is analogous to the previous case.

\end{itemize}

\end{proof}






\section{CTL* + Synchronization}\label{sec:CTL*}
CTL* is a branching-time extension of LTL (and of CTL) where several nested temporal 
operators and Boolean connectives can be used under the scope of a single
path quantifier. For example the CTL* formula  says that 
there exists a path in which either  does not hold in every position,
or  holds at every position. Note that  and  may also
contain path quantifiers.

Extending CTL+Sync with formula quantification analogous to CTL* presents some difficulties. Even considering only Boolean connectives and  operators
leads to a logic that is hard to define. For example, one may consider
a formula like  which could be 
naturally interpreted as there exist two positions  such that 
on all paths , either  holds at position  in , or  holds at
position  in . In this definition the  operator would not be idempotent, 
that is  is not equivalent to ,
where  means that the set of all paths can be partitioned into
two sets of paths where  holds synchronously at some position, 
but not necessarily the same position in both sets, while  expresses the
property that  holds synchronously at some position in all paths. 

Another difficulty with binary operators is the semantics induced by the order of the operands. 
For instance, the formula 
can be interpreted as  there exists a position  such that for all positions ,
on all paths , either  or ;
or it can be interpreted as  for all , there exists  
such that on all paths , either  or .
These two interpretations differ on the Kripke structure that produces exactly
two paths  and  such that  and  hold at the following 
positions ( holds nowhere except at position  in  and position 
in , and  holds everywhere except position  in  and position 
in ): 
\begin{center}
\begin{tabular}{lccccccc}
in : &  &  &  &   &   &  & \dots \\
in : &  &  &  &   &   &  & \dots \\
             & 0 & 1 & 2 & 3 & 4 & 5 &  \\
\end{tabular}
\end{center} 
Note that the two paths agree on their initial position, and we can
construct a Kripke structure that produces exactly those two paths.
It is easy to see that the formula  does not hold 
according to the first interpretation (indeed, for  we can take  and consider the path 
where  does not hold at position  and  does not hold at position ,
and for all other values of , take  and consider the path 
where  does not hold at position  and  does not hold at position ), 
but it does hold according to the second interpretation
(for  take , for  take , and for all other values
of  take arbitrary value of , for example ).
The trouble is that the order of the existential
quantifier (associated to the left operand ) and the universal quantifier
(associated to the right operand ) actually matters in the semantics
of the formula, leading to an annoying situation that 
is not equivalent to  in any of the interpretations.
One way could be to use the branching Henkin quantifiers, like 
where the existential choice of  does not depend on the universal choice of .
This interpretation suffers from lack of symmetry, as the negation of such 
a branching Henkin quantifier is in general not expressible as a 
branching Henkin quantifier~\cite{BG86}.




\section{Conclusion}

The logic CTL+Sync and its extensions presented in this paper provide an elegant 
framework to express non-regular properties of synchronization. 
It is intriguing that the exact optimal complexity of the model-checking problem remains open,
specially even for the fixed formula  (which we show is in ,
and DP-hard).
Extending CTL+Sync to an elegant logic \emph{\`{a} la} CTL* seems challenging.
One may want to express natural properties with the flavor of synchronization, such as the 
existence of a fixed number of synchronization points, or the property that all 
paths synchronize in either of a finite set of positions, etc. (see also Section~\ref{sec:CTL*}).
Another direction is to consider alternating-time temporal logics (ATL~\cite{AHK02})
with synchronization. ATL is a game-based extension of CTL for which the 
model-checking problem remains in polynomial time. For instance, ATL can express the existence
of a winning strategy in a two-player reachability game. For the synchronized version of 
reachability games (where the objective for a player is to reach a target
state after a number of steps that can be fixed by this player, independently of the
strategy of the other player), it is known that deciding the winner is PSPACE-complete~\cite{DMS14a}.
Studying general game-based logics such as ATL or strategy logic~\cite{CHP10} 
combined with quantifier exchange is an interesting direction for future work.\medskip



{\bf Acknowledgment.} We thank Stefan G\"oller and anonymous reviewers for 
their insightful comments and suggestions.




\bibliographystyle{plain}
\bibliography{biblio} 




















\end{document}
