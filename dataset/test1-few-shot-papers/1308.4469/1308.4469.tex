

\chapter[Traversal in Planar Graphs]{I/O-Efficient Path Traversal in Planar 
  Graphs}\label{chp:succinct_graphs}
\chaptermark{Traversal in Planar Graphs}

\section{Introduction}


External memory (EM) data structures and succinct data structures both
address the problem of representing very large data sets.
In the EM model, the goal is to structure data that are too large to fit into
internal memory in a way that minimizes the transfer of data between
internal and external memory when answering certain queries.
For succinct data structures, the aim is to encode the structural
component of the data structure using as little space as is
theoretically possible while still permitting efficient navigation of
the structure.
Thus, EM data structures deal with the I/O bottleneck
that arises when the data are too large to fit into memory, while
succinct data structures help to avoid this bottleneck as they allow
more data to be stored in memory.
Succinct EM data structures maximize the amount of data that fits on a disk of
a given size or in a disk block.
The former is important because an increasing number of
large-scale applications find themselves limited by the amount of data
that fits on a disk.
The latter helps to reduce the I/O bottleneck further, as more data
can be swapped between memory and disk in a single I/O operation.

In this chapter, we develop a succinct EM data structure for path
traversal in planar graphs.
Given a bounded-degree planar graph ,
our goal is to simultaneously minimize the amount of space used to
store  on disk as well as the number of I/O operations required to report
a path of length  in .
As practical applications of our
structure, we show how it can be used to answer a range of important
queries on triangular irregular network (TIN) models of terrains.

\subsection{Background}\label{sec:background}


In the \emph{external memory} (EM) model \cite{DBLP:journals/cacm/AggarwalV88}, the
computer is assumed to be equipped with a two-level memory hierarchy
consisting of \emph{internal} and (disk-based) \emph{external memory}.
The external memory is assumed to have infinite size, but accessing data
elements in external memory is several orders of magnitude slower than accessing
data in internal memory.
Conversely, while internal memory permits efficient operations, its size is limited 
to  data elements.
Data is transferred between internal and external memory by means of
\emph{I/O operations} (\emph{I/Os} for short), each of which transfers
a block of  consecutive data items. 
The efficiency of a data structure in the EM model is measured in terms of the
space it uses and the number of I/Os required to answer certain queries.
In order to take advantage of blockwise disk accesses, it is necessary that .
Throughout this work, we assume  and ,
where  denotes the input size. Furthermore, we assume that the machine
word size is  bits, an assumption commonly used 
in papers on succinct data structures in internal 
memory~\cite{DBLP:journals/talg/RamanRS07}.

Nodine~\etal~\cite{ngv_1996} first explored the problem of blocking
graphs in external memory for efficient path traversal. 
They stored the
 graph in disk blocks (possibly with duplication of
vertices and edges), so that any path in the graph could be traversed
using few I/Os relative to the path's length.
The efficiency of the blocking is expressed in terms
of the \emph{blocking speed-up}, which is the minimum ratio between
the length of a traversed path and the number of I/Os required to
traverse it, taken over all paths that require more than  I/Os to
traverse, for some constant , and assuming that only one block can
be held in memory at any point in time.
The authors identified the optimal bounds for the worst-case blocking speed-up
for several classes of graphs.
Agarwal \etal~\cite{DBLP:conf/soda/AgarwalAMVV98} proposed a
blocking of bounded-degree planar graphs such that any path of length
 can be traversed using  I/Os.

Succinct data structures represent their structural
components using space as near the information-theoretic lower bound as
possible while still permitting efficient operations.
These were originally proposed by Jacobson
\cite{jac_1989}, who designed succinct representations of trees and
graphs.
To represent graphs, Jacobson relied on the technique of book
embeddings by Bernhart and Kainen
\cite{DBLP:journals/jct/BernhartK79}.
A -page book embedding of a graph is an ordering of the graph's vertices,
along with a partition of its edges into  ``pages'',
each of which is a subset of edges that induces an outerplanar embedding of
the graph consistent with the chosen vertex ordering.
Yannakakis \cite{DBLP:conf/stoc/Yannakakis86}
demonstrated that  is necessary and sufficient to partition
planar graphs.
Jacobson's data structure embeds each page of a graph
on  vertices using  bits, and can thus represent
-page graphs using  bits and planar graphs using
 bits.
The structure supports adjacency queries using
 bit probes, and the listing of the neighbours of a
vertex  of degree  using  bit
probes.

Jacobson's result was improved upon by Munro and Raman
\cite{DBLP:conf/focs/MunroR97} under the word-RAM model.
They showed how to represent a -page graph with  vertices and  edges
using  bits such that adjacency and
vertex degree queries can be answered in  time.
The neighbours of a vertex  can be reported in  time.
For planar graphs, this result translates to an -bit
representation that answers adjacency and degree queries in constant
time, and lists neighbours in  time.
Gavoille and Hanusse \cite{DBLP:journals/dmtcs/GavoilleH08} proposed an encoding
for -edge -page-embeddable graphs that allows multiple edges and
loops.
For a graph with no isolated vertices, their structure uses  bits, which is an improvement over Munro and Raman's
structure whenever .
By adding an auxiliary table of  bits, this encoding
supports calculating vertex degrees in constant time, answering adjacency
queries in  time (constant for planar graphs), and
accessing all neighbours of a vertex in  time.

An alternate approach to book embeddings of planar graphs, which uses
canonical orderings of the graph's vertices and edges, was presented
by Chuang \etal~\cite{chuang_et_al_1998}.
Their solution represents a planar graph using
 bits, for any  
(with ), and supports constant-time adjacency 
and degree queries.
If the graph is simple, this bound becomes
.
For triangulated planar graphs, they reduced the space
bound to  bits.
The space bound for general planar graphs was reduced by Chiang
\etal~\cite{DBLP:journals/siamcomp/ChiangLL05}, who showed that a
graph with no multiple edges or self loops can be represented using
 bits to support the same set of
operations.
For the case of triangulated planar graphs, Yamanaka and
Nakano~\cite{DBLP:conf/walcom/YamanakaN08} presented an encoding that
uses  bits and supports adjacency, degree, and
clockwise neighbour queries in constant time.

Barbay \etal~\cite{DBLP:conf/isaac/BarbayAHM07} presented several
results with respect to both planar graphs, triangulations, and
-page graphs, including the first results for labeled graphs and
triangulations.
For planar triangulations, they added support for
rank/select queries of edges in counterclockwise order using  bits.
For plane graphs, their structures support
standard queries, as well as rank/select queries in counterclockwise
order, using 
bits (for ).
For -page graphs
with large values of , they proposed a representation using  bits and supporting
adjacency queries in  time, degree queries in
constant time, and the listing of neighbours in  time.
An alternative representation uses
 bits and
supports adjacency queries in  time, degree queries in
constant time, and the listing of neighbours in  time.

A third strategy for succinct graph representations is based on graph
partitions.
Aleardi \etal~\cite{DBLP:conf/wads/AleardiDS05}
introduced a succinct representation for triangulations with a
boundary based on a hierarchical partition of the triangulation.
The combinatorial structure of the triangulation is partitioned into small
sub-triangulations which are further partitioned into tiny
sub-triangulations.
The representation stores the connectivity
information with asymptotically 2.175 bits per triangle, and supports
navigation between triangles in constant time.
The same authors presented an improved result of 1.62 bits per triangle for
triangulations without a boundary, and also demonstrated that
3-connected planar graphs can be represented with 2 bits per edge
\cite{DBLP:journals/tcs/AleardiDS08}.
For both planar triangulations and 3-connected planar graphs, this
representation permits constant-time navigation using additional
 bits of storage.
A partitioning approach was also
employed by Blandford \cite{DBLP:conf/soda/BlandfordBK03}, who showed
that graphs with small separators can be represented using 
bits such that adjacency and degree queries can be answered in
constant time and listing the neighbours of a vertex takes
 time.

Farzan and Munro \cite{DBLP:conf/esa/FarzanM08} considered
the case of succinct representations of arbitrary graphs.
They described an encoding that requires
 bits,
for an arbitrarily small constant ,
and supports adjacency and degree queries in constant
time, and the listing of neighbours in  time.

Little work has focused on obtaining succinct EM data structures.
The only results of which we are aware focus on text indexing 
\cite{DBLP:conf/dcc/ChienHSV08,  clark_96}, and on path traversals in 
trees \cite{DillabaughHM08}.

\subsection{Our Contributions}


In this chapter we present the following results:

\begin{enumerate}
\item In Section \ref{sec:graph_rep}, we present a data structure that
  uses  bits to represent a planar graph with 
  vertices, each with a label of size , and which allows the traversal of
  any path of length  using  I/Os.
  This path traversal cost matches that achieved by the data structure of
  Agarwal \etal~\cite{DBLP:conf/soda/AgarwalAMVV98}, but the latter
  uses  bits to store the graph.
  In the context of large datasets, this space saving represents a
  considerable improvement
  (e.g., with keys of constant size, the space bound improves by
  a factor of ).
\item In Section \ref{sec:tins}, we apply our structure to store
  triangulations.
  If storing a point requires  bits, we are able to store a triangulation in
   bits so that any path crossing 
  triangles can be traversed using  I/Os.
  Again, the I/O efficiency of our structure matches that
  of~\cite{DBLP:conf/soda/AgarwalAMVV98} with a similar space improvement
  as for bounded-degree planar graphs.
\item In Section \ref{sec:point_location}, we show how to
  augment our triangulation representation with  bits of extra
  information in order to support point location 
  queries using  I/Os.
  Asymptotically, this does not change the space requirements.
\item In Section \ref{sec:applications}, we describe several
  applications that make use of our representation for triangulations 
  from Section~\ref{sec:tins}.
  We demonstrate that reporting terrain profiles and trickle paths takes
   I/Os.
  We show that connected-component queries---that is, reporting a set of
  triangles that share a common attribute and induce a connected
  subgraph in the triangulation's dual---can be performed using
   I/Os when the component being reported is convex and consists
  of  triangles.
  For non-convex regions with holes, we achieve a query bound of
  , where  is the number
  of edges on the component's boundary.
  In order to achieve this query bound, the query procedure uses
   extra space.
  Without using any extra space, the same query can be answered using
   I/Os, where  is the number of
  triangles that are incident on the boundary of the component.
\end{enumerate}

\section{Preliminaries}


\paragraph{Rank and select queries on bit vectors.}


The basic definitions for, and operations on, bit vectors have
been described in Chapter~\ref{chp:background}, 
Section~\ref{sec:bckgrnd-succint-ds}.
We repeat here a key lemma which summarizes results on
bit vectors used in the current Chapter.
Part (a) is from Jacobson~\cite{jac_1989} and Clark and 
Munro~\cite{clark_96}
while part (b) is from Raman~\etal~\cite{DBLP:journals/talg/RamanRS07}:

\begin{lemma}
  \label{lem:rank_select}
  A bit vector  of length  and containing  s can be
  represented using either (a)  bits or (b)  bits to support the access to each bit, as
  well as  and  operations, in  time (or
   I/Os in external memory).\footnote{Note that  as long as .}
\end{lemma}


\paragraph{Planar graph partitions.}


Frederickson \cite{Frederickson87} introduced the notion of an
\emph{-partition} of an -vertex graph , which is a collection of
 subgraphs of size at most  such that for every
edge  of~ there exists a subgraph that contains both  and .
A vertex  is \emph{interior} to a subgraph if no other
subgraph in the partition contains , otherwise  is a
\emph{boundary vertex}.
Frederickson showed the following result for planar graphs.

\begin{lemma}[\cite{Frederickson87}]
  \label{lem:fred_graph_sep}
  Every -vertex planar graph of bounded degree has an -partition
  with  boundary vertices.
\end{lemma}


\section{Notation}\label{sec_notation}


The following tables provide a summary of the various notations used in this chapter,
in particular in Section~\ref{sec:graph_rep}.

\begin{table}[H]
\centering
\begin{tabular}{l | l}
  Data Structure & Description \\ \hline
   & A bit-vector of length  the 'th bit of which \\
              & marks that  as the first element of its region. \\
   & A bit-vector of length  the 'th bit of which marks that\\
              &   is the first element of its subregion. \\
   & Bit vector marking the number of subregion boundary vertices per \\
              & region. \\
   & Bit vector of length  which marks if vertex  is a subregion \\
              &  boundary vertex. \\
   & Vector each mapping subregion boundary vertex to its defining \\
              & subregion and label within that subregion. The length of this\\
			  & vector is the sum of the subregion boundary vertices for each \\
			  & region. \\
   & Vector recording the region label of all subregion boundary \\
			  & vertices within the sub-regions. The length of this vector is \\
			  & the sum of the subregion boundary vertices for each subregion \\
			  & (Due to duplicates, .). \\ \hline
\end{tabular}
\caption{Data structures used to convert between graph, region, and subregion labels}
\label{tab:ds_label_conv}
\end{table}

\begin{table}[H]
	\centering
		\begin{tabular}{ l | l}
			Notation & Description \\ \hline
			 & Order of vertices within a subregion. \\
			 & Block size in number of elements. \\
			 & Block in number of elements for a succinctly-encoded block. \\
			 & A planar graph of bounded degree on N vertices. \\
			 & Unique graph label of vertex .\\
			 & Unique region label of vertex  in region . \\
			 & Unique region label of vertex  in sub-region . \\
			 & The -neighbourhood of vertex . \\
			 & Key size in bits. \\
			 & The number of subregions in region . \\
			 & The number of regions in . \\
			 & Denotes the number of vertices in region . \\
			 & Denotes the total number of vertices in all sub-regions of~ (This \\
			  & differs from  in that duplicates may be counted several times.).\\
			 & Denotes the total number of vertices in all subregions of .\\
			 & Region , a subgraph of  in the top level partition. \\
			 & Subregion , a subgraph of , and subset of region . \\
			 & Denotes the number of vertices in subregion . \\
			 & Upper bound on the number of bits required to encode a subregion \\
			& -neighbourhood. \\
			 & Upper bound on the number of bits required to encode a region. \\		
			 & Set of region boundary vertices selected to build \\
			& -neigbhourhoods for (Section~\ref{sec:alt_block_scheme}). \\
			 & Set of subregion boundary vertices selected to build \\
			& -neigbhourhoods for (Section~\ref{sec:alt_block_scheme}). \\ 
			 & Vector formed by concatenating all subregions of .\\
			 & Vector formed by concatenating all regions of .\\ 
			 & Vector on all vertices of .\\
			 & Word size in bits. \\ \hline
		\end{tabular}
	\caption{Notations used in describing graph representation}
	\label{tab:notation}
\end{table}

\begin{table}[H]
	\centering
		\begin{tabular}{ l | l}
			Data Structures & Description \\ \hline
			 & Bit vector of length  marking region boundary vertices. \\
			 & Bit vector of length  marking sub-region boundary vertices. \\
			 & Array storing all subregions, packed. \\
			 & Per subregion bit-vector marking if subregion is first sub-region in its region. \\
			 & Per subregion bit-vector marking if subregion starts in different block of  \\
			& than the preceeding subregion. \\
			 & Array storing -neighbourhoods of all sub-region boundary vertices. \\
			 & Array storing -neighbourhoods of all region boundary vertices. \\
			 & Vector recording the minimum graph label of interior vertices of each sub-region. \\
			 & Vector recording the minimum graph label of interior vertices of each region. \\
			 & The number of vertices stored in subregion  (part of  \\
			 & subregion encoding).\\
			 & A succinct encoding of the graph structure of subregion  (part of  \\
			 & sub-region encoding).\\
			 & A bit-vector marking vertices in a subregion as either region or subregion \\
			& boundaries (part of sub-region encoding).\\
			 & An array storing the  bit-keys for each vertex within a subregion \\
			 & (part of sub-region encoding). \\
			 & A succinct encoding of the graph structure of  \\
			 & (part of -neighbourhood encoding).\\
			 & A bit vector marking the terminal vertices in an  -neighbourhood. \\
			 & (part of -neighbourhood encoding). \\
			 & Position of  in  (permutation of vertices in \\
			 & (part of -neighbourhood encoding) \\
			 & An array storing keys associated with vertices in   . \\
			 & (part of -neighbourhood encoding) \\		
			 & An array storing labels of the vertices in . \\
			& (part of -neighbourhood encoding) \\ 
			 & -neighbourhood pointer table for region boundary \\
			& vertices. \\
			 & -neighbourhood pointer table for subregion boundary\\
			& vertices. \\ \hline
		\end{tabular}
	\caption{Data structures used to represent graph components}
	\label{tab:data_structs}
\end{table}

\section{Succinct Representation of Bounded-Degree Planar Graphs}
\label{sec:graph_rep}


Our main result considers planar graphs of degree 
where the degree of a graph is the maximum degree of its vertices.
Let  be such a graph.
Each vertex  in  stores a -bit key
to be reported when visiting .
We assume that , but
 is not necessarily related to the size of the graph.
It may take on a small constant value, e.g., the labels may be colours
chosen from a constant-size set.

Our data structure is based on a two-level partition of , similar to
that used in \cite{DBLP:journals/talg/BoseCHMM12}.
More precisely, we compute an
-partition of , for some parameter  to be
defined later.
We refer to the subgraphs in this partition as \emph{regions}, and
denote them by .
Each region  is further
divided into smaller subgraphs, called \emph{subregions}, that form
an -partition of , for some parameter
.
We use  to denote the number of subregions of , and  to denote the subregions themselves.
According to the definitions from the previous section, we classify
every vertex in a region  as a \emph{region-interior} or
\emph{region boundary vertex}, and every vertex in a subregion
 as a \emph{subregion-interior} or \emph{subregion boundary
  vertex}.
Every region boundary vertex is also considered to be a
subregion boundary vertex in any subregion that contains it
(see Fig.~\ref{fig:partitioned_graph} for an illustration).
Note that if a vertex is a region boundary vertex of one region, it is a region
boundary vertex for all regions that contain it.
The same is true for subregion boundary vertices.
Thus, we can refer to a vertex as a region or subregion boundary or interior
vertex without reference to a specific region or subregion.

\begin{figure}[t]
  \centering
  \includegraphics[width=0.6\textwidth]{images/partitioned_graph}
  \caption[Recursively-partitioned graph]{A graph  partitioned into two 
	regions (delineated by solid lines), which are further partitioned into two 
	subregions each (delineated by dashed lines).
    Region boundary vertices are shown as large hollow disks while subregion 
	boundary vertices interior to their regions are shown as large solid disks.
    Vertices interior to their subregions are shown as small solid disks.}
  \label{fig:partitioned_graph}
\end{figure}


In our data structure, all subregions are stored explicitly while
regions are represented implicitly as unions of their subregions.
In addition, we store the \emph{-neighbourhoods} of all (region
and subregion) boundary vertices.
These neighbourhoods are defined
as follows~\cite{DBLP:conf/soda/AgarwalAMVV98}.
For a vertex , consider a breadth-first search in  starting at .
Then the -neighbourhood  of  is the subgraph of 
induced by the first  vertices visited by the search.
For a region boundary vertex, we store its entire -neighbourhood.
For a subregion boundary vertex interior to a region , we store
only those vertices of its -neighbourhood that belong to
.
A vertex  is an \emph{interior vertex} of
 if all its neighbours belong to ;
otherwise  is \emph{terminal}
(see Fig.~\ref{fig:alpha_neighbourhoods} for an illustration of the
definitions pertaining to -neighbourhoods).

\begin{figure}[t]
  \centering
  \includegraphics{images/alpha_neighbourhoods}
  \caption[-neighbourhood of a boundary vertex]{The 
	-neighbourhood  of a vertex ,
    for .
    Vertex  is interior to  while vertex  is terminal.}
  \label{fig:alpha_neighbourhoods}
\end{figure}


We refer to subregions and -neighbourhoods---that is, to the
subgraphs of  we store explicitly---as \emph{components} of .
We store each component succinctly so as to allow for the efficient
traversal of edges in the component.
The traversal of a path in  must be able to visit different components.
In order to facilitate this, we assign a unique \emph{graph label} to each vertex of ,
and provide mechanisms to (1) identify a component containing a vertex  and
locate  in that component, given its graph label, and (2) determine
the graph label of any vertex in a given component.

The rest of this section is organized as follows.
In Section~\ref{sec:graph_labelling}, we define a number of labels
assigned to the vertices of , including the graph labels just
mentioned, and provide -bit data structures that allow us to
convert any such label into any other label using  I/Os.
In Section~\ref{sec:datastructs}, we discuss the succinct
representations we use to store subregions and
-neighbourhoods.
In Section~\ref{sec:navigation},
we discuss how to traverse paths I/O efficiently using this
representation.
In Section \ref{sec:alt_block_scheme}, we describe an 
alternative scheme
for blocking planar graphs that can improve I/O efficiency in 
some instances.

\subsection{Graph Labeling}


\label{sec:graph_labelling}

In this section, we describe the labeling scheme that underlies our
data structure.
Our scheme is based on the one used in
Bose~\etal~\cite{DBLP:journals/talg/BoseCHMM12}.
It assigns three labels to each vertex.
As already mentioned, the \emph{graph label}  identifies each vertex
 uniquely.
The \emph{region label}  of a vertex  in a region 
identifies  uniquely among the vertices in , and the
\emph{subregion label}  of a vertex  in a subregion
 identifies  uniquely
among the vertices in .
(Note that a region boundary vertex appears in more than one region and,
thus, receives one region label per region that contains it.
Similarly, every region or subregion boundary vertex receives multiple
subregion labels.)

A standard data structure would identify vertices by their graph labels, and
store these labels for every vertex.
Since there are  vertices, every graph label must use at least
 bits, and such a representation uses at least  bits of space.
In our structure, we store graph labels for only a small subset of the vertices, 
region labels for yet another subset of the vertices, and subregion labels for 
a third subset. 
Many vertices in the graph have no label explicitly stored.
Since regions and subregions are small, and region and subregion labels have to
be unique only within a region or subregion, they can be stored using
less than  bits each.
Next we define these labels.

In the data structure described in the next section, the vertices of
each subregion  are stored in a particular order .
We use the position of a vertex  in  as its
subregion label  for subregion~.

For a region  and a vertex , we say an occurrence of
 in a subregion  \emph{defines}  if there is no
subregion  with  that contains~; otherwise the
occurrence is a \emph{duplicate}.
If the occurrence of  in a subregion  defines , we also call
 the \emph{defining subregion} of .
Clearly, all occurrences of subregion interior vertices are
defining.
We order\footnote{This ordering, as with the ordering used for assigning 
graph labels, is employed strictly for labeling purposes. It does not imply
any arrangement of vertices within the structures used to represent the graph.}
the vertices of  so that all subregion boundary vertices
precede all subregion-interior vertices, and the vertices in each of these two
groups are sorted primarily by their defining subregions and secondarily by
their subregion labels within these subregions.
The region labels of the vertices in  are now obtained by numbering the
vertices in this order.


Graph labels are defined analogously to region labels.
Again, we say an occurrence of a vertex  in a region  defines
 if , for all .
We then order the vertices of  so that the region boundary vertices precede
the region-interior vertices, and the vertices in each of these two groups are
sorted primarily by their defining regions and secondarily by their region
labels inside their defining regions.
The graph labels of the vertices in  are
then obtained by numbering the vertices in order.

Observe that this labeling scheme ensures that all vertices interior
to a region  receive consecutive graph labels, and all vertices
interior to a subregion  receive consecutive graph and
region labels.
The labeling of subregion vertices at the region level is depicted in 
Figure~\ref{fig:region_labeling}.
Generating graph labels is an analogous process.

\begin{figure}[t]
  \centering
  \includegraphics[width=0.8\textwidth]{images/graph_labeling}
  \caption[Assigning region labels]{
    The generation of region labels for region  is depicted,
    where  is composed of subregions , ,
    and .
    The dashed lines along the top indicate equivalence between vertices.
    Each subregion has five vertices, assigned subregion labels 1 through
    5.
    Assigned region labels are indicated below subregion labels. 
    Region labels of boundary vertices are bold while the dash indicates
    a vertex is a duplicate, and therefore not assigned an additional
    region label.
  }
  \label{fig:region_labeling}
\end{figure}


Our data structure for representing the graph  will make use of
the following result, which extends a result from \cite{DBLP:journals/talg/BoseCHMM12}.
In particular, parts~\ref{item:subregion-to-region}
and~\ref{item:region-to-graph} were proved in \cite{DBLP:journals/talg/BoseCHMM12} for a slightly
different vertex labeling than we use here while
parts~\ref{item:graph-to-region} and~\ref{item:region-to-subregion} are new.
For completeness, we prove all parts of the lemma here.

\begin{lemma}
  \label{lem:label_ops}
  There is a data structure of  bits that allows the following
  conversion between vertex labels of  to be performed using
   I/Os.
  \begin{enumerate} \item Given the graph label  of a vertex , compute the defining
    region  of  and the region label  of  in
    .\label{item:graph-to-region}
  \item Given the region label  of a vertex  in a region
    , compute the defining subregion  of  and the
    subregion label  of  in
    .\label{item:region-to-subregion}
  \item Given the subregion label of a vertex  in a subregion
     of , compute the region label 
    of  in .\label{item:subregion-to-region}
  \item Given the region label of a vertex  in a region ,
    compute the graph label  of .\label{item:region-to-graph}
  \end{enumerate}
\end{lemma}


\begin{proof}
  We construct separate -bit data structures in order to accomplish parts
  \ref{item:region-to-subregion} and~\ref{item:subregion-to-region}, and to
  accomplish parts \ref{item:graph-to-region} and~\ref{item:region-to-graph}.
  Since these data structures are very similar, we discuss those for
  parts \ref{item:region-to-subregion} and~\ref{item:subregion-to-region} in detail,
  and only provide a space analysis for the second structure.
  We use  to denote the number of vertices in region ,
   to denote the number of vertices in subregion ,
   to denote the total number of
  vertices in all subregions of~, where  is the number of
  subregions of region , and  to
  denote the total number of vertices in all subregions.

  Our data structure for converting between region and subregion labels consists
  of a number of vectors.
  We introduce them as required for the operations we discuss.
  Most of these vectors are bit vectors representing a vector 
  of the vertices in all subregions of .
  We define this vector first.
   is the concatenation of  subvectors  storing the vertices in the regions of .
  Each such vector  is itself the concatenation of
  subvectors  representing
  the subregions of .
  Each such vector  stores the vertices in 
  sorted by their subregion labels.
  Note that our data structure does not store .
  We only introduce it here as a reference for discussing the vectors our
  data structure does store.
  Throughout this proof, when we define a bit vector, we store it using
  the second part of Lemma~\ref{lem:rank_select} to support constant-I/O
  accesses to its elements, as well as constant-I/O  and 
  operations.

\begin{table*}[ht]
	\centering
		\begin{tabular}{ l | l}
			Operator & Description \\ \hline
			 & Returns the number of 's in bit-vector  up to
				position , where .\\
			 & Returns the \textsuperscript{th}  in bit-vector 
				where .\\
			 & Returns the first element of region  in . \\
			 & Returns the first element of sub-region 
				in . \\
			 & Returns the sub-region index  from  where
				. \\
			 & Calculates in  the number of sub-region boundary vertices
				in . \\ \hline
		\end{tabular}
	\caption{Summary of bit-vector operations used in this section. }
	\label{tab:succ_operators}
\end{table*}

\paragraph{Locating subvectors.}


  The first two vectors that our data structure stores are bit vectors
   and  that
  allow us to identify, for a region , the index of the first
  element of  in  and, for a subregion ,
  the index of the first element of  in .
  Both vectors have length .
  The th bit in  is  if and only if  is the
  first element of , for some region ,
  and the th bit of  is 
  if and only if  is the first element of , for some
  subregion .
  Using these two bit vectors, we can implement the following three operations
  using  I/Os.
  \begin{itemize}
  \item  returns the index of the first element of 
    in  and is implemented as .
  \item  returns the index of the first element of 
    in  and is implemented as
    .
  \item  returns the index  of the subregion 
    of  such that  is an element of  ,
    provided  is an element of .
    This operation can be implemented as
    .
  \end{itemize}

\paragraph{Identifying subregion boundary vertices.}


  The next two vectors we store,  and , help us decide whether
  a vertex is a subregion boundary vertex based only on its region or subregion
  label.
  This is useful because the conversion between region and subregion
  labels is done differently for subregion boundary and subregion-interior
  vertices.
  Vector  is the concatenation of  bit vectors
  .
  For , the subvector  has length equal to the
  number of subregion boundary vertices in .
  Its first bit is , all other bits are .
  The last subvector  stores a single  bit.
  Vector  is a bit vector of length .
   if and only if  is a subregion boundary
  vertex.

  Now observe that a vertex  with region label  in region
   is a subregion boundary vertex if and only if
   is no greater than the number of subregion boundary vertices
  in  because, in the ordering used to define
  the region labels of the vertices in , all subregion boundary
  vertices precede all subregion-interior vertices.
  In order to test this condition, we need to compute the number of subregion
  boundary vertices in , which we can do using  I/Os
  as .
 
  For a vertex  with subregion label  in subregion
  , observe that the subvector  of 
  stores the vertices of  sorted by their subregion labels.
  Thus,  appears at position  in ,
  which is position  in .
  The corresponding bit  in  is  if and only if
   is a subregion boundary vertex.
  Thus, testing whether  is a subregion boundary vertex requires calculating
  , which takes  I/Os followed by a single lookup
  in the bit vector .

\paragraph{Subregion-interior vertices.}


  For the set of subregion-interior vertices, the vectors we have already
  defined suffice to convert between region
  and subregion labels.

  Given a subregion-interior vertex  in  and its region label
   in , observe that the subregion-interior vertices in
   appear in  sorted by their region labels, and
  that these are exactly the vertices in  whose corresponding
  bits in  are .
  Thus, since subregion-interior vertices have greater region labels than
  subregion boundary vertices, we can find the position  of the only
  occurrence of  in  as
  , which takes  I/Os to compute.
  Vertex  belongs to the subregion  such that
   belongs to .
  The index  of this subregion is easily computed using  I/Os, as
  .
  Since vertices in  are sorted by their subregion labels in
  , the subregion label of  is the index of 
  in , which can be computed using  I/Os as
  .

  To compute the region label in  for a subregion-interior
  vertex  in , we perform this conversion in the reverse
  direction.
  Firstly, we find the position  of  in  as
  .
  Secondly, we compute the region label of  in  as
  ,
  which is correct by the argument from the previous paragraph.
  Thus, the conversion from subregion labels to region labels also takes
   I/Os.

\paragraph{Subregion boundary vertices.}


  For subregion boundary vertices in , the vectors we have defined so
  far cannot be used to convert between region and subregion labels, mainly
  because these vertices by definition appear more than once in .
  On the other hand, there are only a few such vertices, which allows us to
  store their region and subregion labels explicitly.
  In particular, we store two vectors  and~.
  Vector  is the concatenation of subvectors , one per region  of .
  The length of  is the number of subregion boundary vertices
  in , and  is the pair  such that the
  subregion  is the defining subregion of the vertex 
  with region label , and  is 's subregion label in .
  We represent the index  using  bits, and the subregion
  label  using  bits.
  The length of vector  equals the number of s in vector
  .
   is the region label of the vertex in  corresponding
  to the th  in .
  We store each such region label in  using  bits.

  Now consider a subregion boundary vertex  with region label
   in .
  The index of the entry in  storing the index of the defining
  subregion of  and 's subregion label in this subregion is 
  , which takes
   I/Os to compute.
  Another I/O suffices to retrieve .

  Given a subregion boundary vertex  with subregion label
   in subregion , the index of  in
   is .
  The corresponding bit  in  is , and the
  region label of  can be retrieved from
  , which takes  I/Os.

\paragraph{Space bound.}


  The vectors  and  have length
   because their length
  equals that of ; only subregion boundary vertices appear more
  than once in , and the total number of occurrences of subregion
  boundary vertices in  is  by
  Lemma~\ref{lem:fred_graph_sep}.
  Every -bit in such a vector corresponds to the start of a region
  or subregion.
  Thus, both vectors contain  s.
  By Lemma~\ref{lem:rank_select}(b), this implies that both vectors can
  be represented using  bits.

  The vector  has length 
  because every bit in  corresponds to a unique subregion boundary
  vertex.
  Thus, by Lemma~\ref{lem:rank_select}(a), we can store  using
   bits.

  The vector  has length  and contains
   s, one per occurrence of a subregion boundary
  vertex in a subregion.
  Hence, by Lemma~\ref{lem:rank_select}(b), we can store  using
   bits.

  Finally, the number of entries in vectors  and  is
  bounded by the number of occurrences of subregion boundary vertices in
  subregions, which is .
  Each entry in such a vector is represented using
   bits.
  Thus, the total space used by these two vectors is
  ,
  which is  because .
  To summarize, the vectors we use to convert between region and subregion
  labels use  space and allow us to convert between these labels
  using  I/Os.
  This proves parts (b) and (c) of the lemma.

\paragraph{Conversion between region and graph labels.}


  The data structure for conversion between region and graph labels is
  identical, with the following modifications.
  \begin{itemize}
  \item The vector  is the concatenation of  subvectors
    .
    Vector  stores the vertices in region  sorted
    by their region labels.
  \item The th bit in  is one if and only if the vertex
     is a region boundary vertex.
  \item There is no need for vectors  and .
    Instead, we store a single -bit integer counting the number
    of region boundary vertices of .
  \item The entries in  are pairs of indices of defining
    regions and region labels in these regions, and the entries in
     are graph labels.
  \end{itemize}
  Using these modified vectors, the conversion between graph and region labels
  can be accomplished using straightforward modifications of the procedures
  described in this proof.

  Vectors  and  have length
   and contain  and
   s, respectively, which are both .
  Hence, by Lemma~\ref{lem:rank_select}(b), they can both be stored using
   bits.
  The number of region boundary vertices is stored using 
  bits.
  Each entry in vectors  and  uses  bits
  of space, and the number of these entries is .
  Hence, the total size of these vectors is ,
  which is  because .
  This proves parts (a) and (d) of the lemma.
\end{proof}

\subsection{Data Structures}\label{sec:datastructs}


Our representation of  consists of three parts: (1) succinct
representations of the subregions, packed into an array , (2)
succinct representations of the -neighbourhoods of boundary
vertices, packed into two arrays  and , and (3) two
vectors  and  recording the minimum graph labels of
the interior vertices in each region or subregion.
Throughout this section, we use total orders  and  of the
regions and subregions of~, respectively.
For two regions  and , we define  if
.
For two subregions  and , we define
 if  or  and .

\paragraph{Minimum graph labels.}


The first part of our data structure consists of two arrays  and
.
The \textsuperscript{th} position of  stores the minimum graph
label of the interior vertices in region .
The \textsuperscript{th} position in  stores the minimum graph label of the
interior vertices in the subregion  at position  in the
sequence of subregions defined by .

\paragraph{Succinct encoding of subregions.}


We represent each subregion  using four data structures:
\begin{enumerate}
\item Its number of vertices  stored in 
  bits.\footnote{ bits would suffice; however it simplifies the
    analysis to use  bits.}
\item The graph structure of  encoded succintly as
	, using the encoding of 
	\cite{DBLP:journals/siamcomp/ChiangLL05}.
  This encoding involves a permutation  of
  the vertices in .
\item A bit vector  of length  with
   if and only if the corresponding vertex in 
  is a  (region or subregion) boundary vertex.
\item An array  of length  that stores the
  -bit key for each vertex.
  These labels are stored according to the permutation .
\end{enumerate}
The representation of  is the concatenation of ,
, , and .

Let  be the maximum integer such that a subregion with 
vertices can be encoded in this manner. 
We choose the parameters of our two-level partition as  and .
This ensures that every subregion fits in a disk block.
However, a given subregion may be much smaller, and storing
each subregion in its own disk block may be wasteful.
Instead, we pack the representations of all subregions into an array ,
without gaps, using a construction proposed 
in~\cite{DBLP:journals/algorithmica/DillabaughHM12} as follows.
The subregion representations in  are ordered according to 
and the array  is stored in consecutive disk blocks; the first
 bits of each block are reserved for a \emph{block offset}
value.
Note that the representation of each region  is
distributed over at most two consecutive blocks in .
If  is distributed over two blocks  and ,
the block offset of the second block, , records the number of bits
of  stored in .
Any other block stores a block offset of~.
In other words, the block offset of each block stores the starting
position of the first region  in this block that is not
stored partially in the previous block.
Since we use  bits per block to store the block offset, each subregion
of size  must be stored in at most  bits.
This representation of  is illustrated in Figure~\ref{fig:block-packing}.
 

\begin{figure}[t]
  \centering
  \includegraphics{images/block_packing}
  \caption[Packing graph blocks in memory]{Arrays , , and , 
	and the packing of  into blocks.
    The dark portion at the beginning of each block stores the block offset.
    The black portion of the last block is unused.}
  \label{fig:block-packing}
\end{figure}


In order to facilitate the efficient lookup of subregions in , we augment
it with two bit vectors  and , each represented to support
constant-time  and  queries (see Lemma~\ref{lem:rank_select}).
If  is the total number of subregions in~, each of the two vectors has
length .
Their entries are defined as follows:
\begin{enumerate}
\item  if and only if the th subregion 
  is the first subregion in , that is, if .
\item  if and only if the th subregion starts in
  a different block from the st subregion; that is, if
  the first bits of these two regions belong to different blocks in
  .
\end{enumerate}

\paragraph{\boldmath Succinct encoding of -neighbourhoods.}


The third piece of our data structure consists of succinct encodings
of the -neighbourhoods of (region and subregion) boundary
vertices, for .
Recall that the -neighbourhood of a subregion boundary vertex interior
to its region includes only vertices inside this region.
Each -neighbourhood  is represented using the
following structures:
\begin{enumerate}
\item A succinct encoding  of the graph structure of
  .
  This encoding involves a permutation  of the vertices in
  .
\item A bit vector  of length  for which
   if and only if the th vertex in  is a terminal
  vertex of .
\item A -bit integer  that records the position of
   in .
\item An array  of length  that stores the
  key associated with each vertex in .
  These keys are stored according to the permutation .
\item An array  of length  that stores
  labels of the vertices in .
  The specific labels stored in  depend on whether  is a region
  boundary vertex or a subregion boundary vertex interior to a region.
  \begin{itemize}
  \item If  is a region boundary vertex,  is the graph
    label of the th vertex in .
    Each such graph label is stored using  bits.
  \item If  is a subregion boundary vertex interior to a region
    , the label stored in  depends on the type of the
    \textsuperscript{th} vertex  in .
    If  is an interior vertex of ---that is,
    ---then  is the difference between the graph
    label of  and the minimum graph label of the interior vertices in
    ,  which is stored in .
    We call this the \emph{region offset} of .
    If  is a terminal vertex of ---that is,
    ---then  is the region label of .
    We note that each of these two types of labels can be stored using
     bits.
    For region labels this is obvious, as each region has at most 
    vertices.
    For region offsets, we observe that every interior vertex of
     must also be interior to  because every
    boundary vertex of  has at least one neighbour outside of
     and, hence, must be terminal for  (if it is
    contained in ) because  contains only
    vertices in .
    The bound on the number of bits required to store region offsets now
    follows because  has at most  vertices, and all interior
    vertices of  receive consecutive graph labels.
  \end{itemize}
\end{enumerate}

Given that each -neighbourhood contains at most 
vertices, there exist upper bounds,  and , on the number of
bits required to encode the -neighbourhood of any region or
subregion boundary vertex, respectively.
We pad every -neighbourhood  to size  or
 using extra bits, depending on whether  is a region boundary
vertex.
We store the -neighbourhoods of all region boundary vertices in
an array , and the -neighbourhoods of all subregion boundary
vertices interior to their regions in an array .
The -neighbourhoods in each array are ordered according to the graph
labels of their defining boundary vertices.

In order to be able to locate the -neighbourhoods of boundary vertices
in  and , we store two bit vectors,
 and , of length  that support 
and  queries;
 if and only if the vertex with graph label  is a region
boundary vertex;  if and only if the vertex is a subregion
boundary vertex interior to its region.

\paragraph{Space analysis.}


Before discussing how to traverse a path in  using this
representation, we prove a bound on its size.

\begin{lemma}
  \label{lem:main_space}
  The above representation of a bounded-degree planar graph  with
   vertices, each with an associated -bit key, uses 
   bits.
\end{lemma}


\begin{proof}
  First we determine .
  Let  be the number of bits per vertex used in the succinct
  representation  of the graph structure of each subregion
  .
  Then the representation of each subregion uses at most 
   bits.
  Since a block can hold  bits, with the first  bits used
  for the block offset in , we have
  
  assuming for the sake of simplicity that  divides 
  .
  Now we analyze the space consumption of the different parts of our structure.

  \textit{Minimum graph labels.}  The arrays  and 
  together store  graph labels, each of size .
  By (\ref{eqn:block_size}) and because , 
  .
  Hence, these two arrays use  bits of space.

  \textit{Subregions.}  Storing every vertex once uses  bits.
  However, boundary vertices are stored once per subregion in which they are 
contained.
  By Lemma~\ref{lem:fred_graph_sep}, there are  region
  boundary vertices and  subregion boundary
  vertices, counting each occurrence separately.
  Since , storing boundary
  vertices therefore requires
  
  bits.
  In addition, we store a -bit size  for each
  subregion .
  These numbers use 
  bits, as there are  subregions.
  In total, the size of array  is ,
  excluding block offsets.
  There is one block offset of size  per block of  bits.
  Thus, the total space used by block offsets is .

  The final part of the representation of subregions is the vectors
   and .
  Each vector stores one bit per subregion.
  Thus, their total size is , and they can be stored
  in  space to support  and  operations.
  In summary, we use  bits to represent all
  subregions.

  \textit{-Neighbourhoods.}  We bound the sizes of the
  -neighbourhoods of region and subregion boundary vertices
  separately.
  By Lemma~\ref{lem:fred_graph_sep}, there are 
  region boundary vertices.
  The representation of the -neighbourhood of each such vertex uses
  
  bits.
  Hence, the total size of the -neighbourhoods of all
  region boundary vertices stored in  is:
  
  
  The -neighbourhood of every subregion boundary vertex is
  represented using
  
  bits.
  Since there are 
  subregion boundary vertices, the total size of their
  -neighbourhoods stored in  is therefore
  
  The last equality follows because .
  Together, arrays  and  use  space.

  The bit vectors  and  have length  each and
  contain  1 bits each.
  Thus, by Lemma \ref{lem:rank_select}(b), they
  can be stored in  bits.

  In summary, we use  bits to store all -neighbourhoods.
  By summing the sizes of the three parts of
  our data structure, we obtain the space bound claimed in the lemma.
\end{proof}

\subsection{Navigation}


\label{sec:navigation}

To traverse a path  in , we use a strategy similar to that used 
by Agarwal \etal~\cite{DBLP:conf/soda/AgarwalAMVV98},
alternately using subregions and -neighbourhoods in order to
progress along .
We assume we are given a function, , that takes the graph label
and key of the current vertex, , as an argument, and either reports that 
is the last vertex of  (in which case the traversal should stop), or outputs
the graph label and key of the successor of  in .
To make this decision,  may
use state information computed during the traversal of  up to 
and needs access to the set of neighbours of .
Therefore, the task of our traversal procedure is to ensure that, during each step
along , the neighbours of the current vertex are in memory.

Assume, without loss of generality, that the start vertex of  is 
interior to a
subregion~.
This is easy to ensure initially by loading the
representation of  into memory.
Then we follow the path  by repeated application of the  function
and by invoking the following paging procedure for each visited vertex before
applying  to it.
\begin{itemize}
\item If the current vertex  is interior to the current component
  (subregion or -neighbourhood) in memory, we do not do
  anything, as all of 's neighbours are in memory.
\item If the current component is a subregion  and  is a
  boundary vertex of , or the current component is an
  -neighbourhood  and  is a terminal vertex of
  , then  has neighbours outside the current
  component.
  We load a component containing  and all its neighbours into memory:
  \begin{itemize}
  \item If  is a region or subregion boundary vertex, we load its
    -neighbourhood  into memory.
  \item If  is interior to a subregion , we load
     into memory.
  \end{itemize}
\end{itemize}

Our paging strategy ensures that, for every vertex , we have
a succinct representation of a component of  containing all
neighbours of  in memory when  is visited.
To show that this allows us to traverse any path of length 
using  I/Os, we need to show that
(1) given the graph label of a vertex , we can identify and load its
-neighbourhood, or the subregion  is interior to, using 
I/Os; (2) the graph labels of the vertices in the component currently
in memory and the graph structure of this component
can be determined without performing any I/Os; and (3) for every
 steps along path , we load only  components into memory.

Before proving these claims, we prove that we can efficiently convert between
graph, region, and subregion labels of a vertex , and identify the region and
subregion to which  is interior, or, if  is a region or subregion boundary vertex,
the region or subregion which defines .
The following lemma states this formally.
Its proof is the same as in~\cite{DBLP:journals/talg/BoseCHMM12}.
We include it here for completeness.

The results of the previous lemma lead to the following lemma.

\begin{lemma}
\label{lem:component_ios}
When the traversal algorithm encounters a terminal or boundary
vertex , the next component containing  in which the traversal
may be resumed can be loaded in  I/O operations.
\end{lemma}


\begin{proof}
Consider firstly the case of a boundary vertex, , for a subregion.
The vertex may be a region or subregion boundary.
By Lemmas \ref{lem:label_ops}(c) and \ref{lem:label_ops}(d), the graph
label of  can be determined in  I/O operations.
If  is a region boundary vertex, this graph label serves as a direct 
index into the array of region boundary vertex -neighbourhoods 
(recall that all region boundary vertices are labeled with consecutive 
graphs labels).
Loading the -neighbourhood requires an additional I/O operation.

If  is a subregion boundary vertex, the region and region
label can be determined by Lemma \ref{lem:label_ops}(a). 
By Lemma \ref{lem:label_ops}(d) we can determine the graph label. 
For the subregion boundary vertex, , with graph label , we can
determine the position of the -neighbourhood of  in
 in  I/Os by 
.
In order to report the graph labels of vertices in the
  -neighbourhood, we must know the graph label of the first
  interior vertex of the region, which we can read from
   with at most a single additional I/O operation.

  Further,  consider the case of a terminal node in a
  -neighbourhood. If this is the -neighbourhood of a
  subregion boundary vertex, the region  and region label are
  known, so by Lemma \ref{lem:label_ops}(d) we can determine the graph
  label, and load the appropriate component with  I/O
  operations. Likewise, for -neighbourhoods of a region
  boundary vertex, the graph label is obtained directly from the vertex
  key.

  Finally, we show that a subregion can be loaded in 
  I/Os. Assume that we wish to load subregion . Let  mark the start of the region . We can
  then locate the block, , in which the representation for
  subregion  starts by . 
  There may be other subregions stored entirely in  prior to
  . 
  We know that if , then  is the
  first subregion stored in  that has its representation start in
  .  
  If this is not the case, the result of
   will indicate the position
  of  among the subregions stored in .  
  We can now read subregion  as follows: 
  we load block  into memory and
  read the block offset which indicates where the first subregion in
   starts. 
  If this is , we read the subregion offset in order to
  determine its length, and read  into memory, possibly
  reading into block  if there is an overrun. 
  If  is not
  the first subregion starting in block , then we note how many
  subregions we must skip from the start of , and by reading only
  the subregion offsets we can jump to the location in  where
   starts. 
  The  and  operations require
   I/Os, and we read portions of at most two blocks  and
   to read a subregion, therefore we can load a subregion with 
  I/Os.
\end{proof}


\begin{lemma}
  \label{lem:report_int_labels}
  Given a subregion or -neighbourhood, the graph labels of
  all interior (subregions) and internal (-neighbourhoods)
  vertices can be reported without incurring any additional I/Os
  beyond what is required when the component is loaded to main memory.
\end{lemma}


\begin{proof}
  The encoding of a subregion induces an order on all vertices, both
  interior and boundary, of that subregion. Consider the interior
  vertex at position  among all vertices in the subregion. 
  The position of this vertex among all interior vertices may be
  determined by the result of . 
  Recall that graph labels assigned to all interior vertices in a subregion are
  consecutive; therefore, by adding one less this value to the
  graph label of the first vertex in the subregion, the graph label
  of interior vertex at position  is obtained.

  For the -neighbourhood of a region boundary vertex, the graph
  labels from  can be reported directly.  
  For the -neighbourhoods of subregion boundary vertices, we can
  determine from  the graph label of the first vertex
  in the parent region. 
  This potentially costs an I/O; however, we can pay for this when the 
component is loaded. 
  We can then report graph
  labels by adding the offset stored in  to the
  value from .
\end{proof}

\begin{lemma}
  \label{lem:main_IO_bound}
  Using the data structures and navigation scheme described above, a
  path of length  in graph  can be traversed in  I/O operations.
\end{lemma}

\begin{proof}
  The -neighbourhood components are generated by performing a
  breadth-first traversal, from the boundary vertex , which
  defines the neighbourhood. A total of  vertices are added
  to each -neighbourhood component. Since the degree of  is
  bounded by , the length of a path from  to the terminal
  vertices of the -neighbourhood is
  . 
  However, for subregion boundary vertices, the
  -neighbourhoods only extend to the boundary vertices of the
  region, such that the path from  to a terminal node may be less
  than . 
  In the later case the terminal vertex
  corresponds to a region boundary vertex.

  Without loss of generality, assume that traversal starts with an
  interior vertex of some subregion. Traversal will continue in the
  subregion until a boundary vertex is encountered, at which time the
  -neighbourhood of that vertex is loaded. In the worst case
  we travel one step before arriving at a boundary vertex of the
  subregion. If the boundary vertex is a region boundary, the
  -neighbourhood is loaded, and we are guaranteed to travel at
  least  steps before another component must be
  visited.  If the boundary vertex is a subregion boundary, then the
  -neighbourhood is loaded, and there are again two possible
  situations. In the first case, we are able to traverse
   steps before another component must be visited. In
  this case, by visiting two components, we have progressed a minimum
  of  steps. In the second case, a terminal vertex in
  the -neighbourhood is reached before  steps
  are taken. This case will only arise if the terminal vertex
  encountered is a region boundary vertex. Therefore, we load the
  -neighbourhood of this region boundary vertex, and progress
  at least  steps along the path before another I/O
  will be required.

  Since we traverse  vertices with a constant number
  of I/Os, we visit  components
  to traverse a path of length . By Lemma \ref{lem:component_ios},
  loading each component requires a constant number of I/O operations,
  and by Lemma \ref{lem:report_int_labels} we can report the graph
  labels of all vertices in each component without any additional
  I/Os. Thus, the path may be traversed in  I/O operations.
\end{proof}

\begin{theorem}
  \label{thm:planar_graph}
  Given a planar graph  of bounded degree, where each vertex stores
  a key of  bits, there is a data structure that represents  in
   bits that permits traversal of a path of length
   with  I/O operations.
\end{theorem}

\begin{proof}
  Proof follows directly from Lemmas \ref{lem:main_space} and
  \ref{lem:main_IO_bound}. We substitute  for , using
  Eq.~\ref{eqn:block_size} (), as this is standard for
  reporting results in the I/O model.
\end{proof}

Due to the need to store keys with each vertex, it is impossible to
store the graph with fewer than  bits.  The space savings in our
data structure are obtained by reducing the space required to store
the actual graph representation.
Agrawal~\etal~\cite{DBLP:conf/soda/AgarwalAMVV98} do not attempt to
analyze their space complexity in bits but, assuming they use
 bit pointers to represent the graph structure, their
structure requires  bits for any size . If  is
a small constant, our space complexity becomes , which represents a savings of  bits compared to
the  space of of Agarwal~\etal. In the worst case
when , our space complexity is 
, which is asymptotically equivalent to that of
Agarwal~\etal. However, even in this case, our structure can save a
significant amount of space due to the fact that we store the actual
graph structure with  bits (the  and 
terms in our space requirements are related directly to space required
to store keys), compared to  bits in their
representation.

\subsection{An Alternate Blocking Scheme}\label{sec:alt_block_scheme}


In this section, we describe a blocking scheme based on that
of Baswana and Sen \cite{DBLP:journals/algorithmica/BaswanaS02}, which
allows us to improve the I/O efficiency of our data structure for some
planar graphs. 
As with the blocking strategy of
\cite{DBLP:conf/soda/AgarwalAMVV98} employed previously, this new
strategy recursively identifies a separator on the nodes of the graph
, until  is divided into regions of size  which can fit on a
single block (in this context, region is used generically to refer to
the size of partitions in the graph as in Lemma
\ref{lem:fred_graph_sep}). However, rather than store
-nieghbourhoods of size  for each boundary vertex,
larger -neighbourhoods are stored for a subset of the boundary
vertices. In order for this scheme to work, it is necessary that
boundary vertices be packed close together, in order that the selected
-nieghbourhoods cover a sufficiently large number of boundary
vertices. This closeness of boundary vertices is not guaranteed using
the technique of \cite{DBLP:conf/soda/AgarwalAMVV98}, but if the
alternate separator algorithm of Miller~\cite{miller_1986} is
incorporated, then region boundary vertices are sufficiently packed.

For an embedded graph  with maximum face size ,
the separator result of Miller~\cite{miller_1986} is 
stated in Lemma~\ref{lem:miller_cycle_sep}.

\begin{lemma}[Miller~\cite{miller_1986}]\label{lem:miller_cycle_sep}
If  is an embedded planar graph consisting of  vertices, then
there exists a balanced separator which is a single vertex, or a simple cycle
of size at most ,
where  is the maximum face size.
\end{lemma}

Baswana and Sen~\cite{DBLP:journals/algorithmica/BaswanaS02}
construct a graph permitting {I/O}-efficient traversal by recursively
applying this separator.
If the separator is a single vertex , then an -neighbourhood
is constructed for  with . 
If the separator is a cycle, then the following rule is applied.
Let  be the minimum depth of a
breadth-first search tree of size  built on any vertex .
From this cycle every \textsuperscript{th}
vertex is selected, and an -neighbourhood is constructed 
by performing a breadth-first search from each of the selected 
vertices.
In this case, we let , where  is
a number in the range , a precise value that will be
defined shortly.
Vertices on the cycle which are not selected are associated with the
-neighbourhood constructed for the nearest selected vertex .

Let  be the total space required to block 
the graph in this fashion.
This value includes both the space for blocks storing the
regions, and for those storing -neighbourhoods.
The value for  following recursive application of the 
separator defined in Lemma~\ref{lem:miller_cycle_sep} is
given by



where  and  are constants independent of .
In order to maximize  while maintaining ,
select for  the largest value  such that 
.
This is achieved by choosing 
.

This construction is summarized in the following lemma.

\begin{lemma}[\cite{DBLP:journals/algorithmica/BaswanaS02}]
  A planar graph  of size  with maximum face size  
  can be stored in
   blocks so that a path of length  can
  be traversed using  I/O operations
  where .
\end{lemma}

Our succinct graph representation relies on a two-level partitioning of 
the graph.
Before determining a bound on the space for such a succinct representation,
it is useful to bound the total number of boundary vertices 
resulting from the recursive application of Miller's separator; this is 
done in Lemma~\ref{lem:cycle_sep_size}.

\begin{lemma}
  \label{lem:cycle_sep_size}
  For an embedded planar graph  on  nodes, with faces of
  bounded maximum size , recursively partitioned into regions of
  size  using the cycle separator algorithm of Miller
  \cite{miller_1986}, the separator  has 
  vertices.
\end{lemma}

\begin{proof}
  Miller's simple cycle separator on a graph of  nodes has size at
  most , which
  is  for constant . At each step in the
  partitioning,  is subdivided into a separator , plus subsets  and , each containing at
  most  nodes plus the separator. Thus if , we can characterize the size of the
  resulting subsets by  and
  . Following the proof of
  Lemma 1 in \cite{Frederickson87}, the total separator size require to
  split  into regions of size at most  then becomes
  .
\end{proof}

We now describe how this technique is applied in order to achieve a succinct graph
encoding. 
Let  be the set of separator vertices selected as boundary
vertices.
We distinguish between the region separator vertices, 
, and the sub-region separator vertices .
Select every \textsuperscript{th} separator vertex 
for which to build an -neighbourhood.
Each boundary vertex, , is assigned to a single -neighbourhood, namely
the -neighbourhood centred nearest  (or possibly at
, if  was an element of  or ). 
The graph is then encoded using the encoding described in 
Section~\ref{sec:datastructs}, with two small additions.
We add two arrays; one for region boundaries, which we denote 
, and the second for subregion boundaries,
which we denote .
The length of these arrays is equal to the number of region boundary 
vertices and the number of sub-region boundary vertices, respectively.
Each of  (and ) is an array of tuples, where
the first tuple element is an index into  (), 
and the second tuple element records the position of the vertex within
its -neighbourhood. 
By adding these structures to our existing succinct encoding, we have the
 following lemma.

\begin{lemma}
\label{lem:ptable_ios}
When the traversal algorithm encounters a terminal or boundary
vertex , the next component containing  in which the traversal
may be resumed can be loaded in  I/O operations.
\end{lemma}


\begin{proof}
The proof of this lemma is the same as that in 
Lemma~\ref{lem:component_ios}, with the addition that we must
use  and  to lookup the correct 
-neighbourhood and the position of boundary vertex 
within it.

We begin with the case of a region boundary vertex.
In Lemma~\ref{lem:component_ios} it was shown that for a region
boundary vertex, we can locate its graph label in  I/O
operations.
The graph label serves as a direct index into .
In the current case, we let the graph label of a region boundary
vertex serve as an index into .
The first element in the corresponding tuple is a pointer to the
, and the second element of the tuple indicates from where
to resume traversal.
Using  incurs at most a single additional I/O.
Thus, lookup for region boundary vertices is .

For subregion boundary vertices, we apply the same indirection
to locate the proper -neighbourhood.
The result of the lookup , rather
than serving as a direct index into , is used 
as an index into .
The pointer stored in the first element of the returned
tuple can then be used to locate the correct -neighbourhood
in . 
Again, this extra array lookup results in only a single 
additional I/O.
\end{proof}

\begin{lemma}\label{lem:cycle_sep_space}
  The representation described above of a bounded-degree planar graph , 
  with  vertices, each with an associated -bit key, uses 
   bits.
\end{lemma}

\begin{proof}
By Lemma \ref{lem:cycle_sep_size}, our two-level partitioning results
in  region boundary vertices, and
 subregion boundary vertices. From the separators
we select every 'th vertex to add to ,
so that we have  and .

We now demonstrate that the succinct encoding of the data structures
required to represent this partitioning requires the same amount of
storage as our previous result. 
We now store fewer, but larger,
-neighbourhoods, and we must store the tables  and
.
For , the first pointer in the tuple points to a block 
associated with an -neighbourhood in
, and therefore requires 
 
bits, while the
vertex pointer requires  bits. The total space requirement in
bits for  is thus:



For , the respective pointer sizes are

and  bits and, similarly, the total space is 
bits.

Finally, we must account for the space required for the
-neighbourhoods. Before doing so, we must determine the actual
size of the -neighbourhoods, which we will denote . Let ; we
then have the following space complexities for region boundary
vertices (the term  represents the constant from the 
notation):







\end{proof}

These results match the space requirements obtained for region and
subregion -neighbourhoods using our original partitioning
scheme (see Eqs. \ref{eqn:space_region_bound_scs} and
\ref{eqn:space_sub_reg_bound}), and lead to the following theorem.

\begin{theorem}
  Given a planar graph  of bounded degree and with face size
  bounded by , where each vertex stores a key of  bits, there is
  a data structure representing  in  bits that
  permits traversal of a path of length  with  I/O operations, where .
\end{theorem}

\begin{proof}
The succinct structure and navigation technique is the same as
described in Theorem~\ref{thm:planar_graph}.
The only change is the addition of  and .
Lemma~\ref{lem:ptable_ios} demonstrates that the new structures do not alter the
bounds on I/Os, while Lemma~\ref{lem:cycle_sep_space} establishes that the 
space complexity is unchanged.
\end{proof}

\section{Triangulations Supporting Efficient Path Traversal}
\label{sec:tins}


In this section, we describe how our data structures may be used to 
represent triangulations in a manner that permits efficient path
traversal in the EM setting.
In Section \ref{ssec:triangulation_rep}, we describe this representation in the 
general, non-EM setting, giving a compact representation for triangulations 
based on succinct representations of planar graphs.
Later, in Section \ref{ssec:compact_tin_external}, we detail how our succinct
and I/O-efficient planar graph representation can be applied to this representation 
to yield a compact representation for 
triangulations permitting I/O-efficient path traversal.

\subsection{Representing Triangulations}
\label{ssec:triangulation_rep}


Let  be a set of points in , then the triangulation 
of  is the planar graph with  vertices and all faces 
(except the outer face) of size .
The set of all edges adjacent to the outer face of the triangulation is the
convex hull of . 
Let  be the triangulation with vertices , 
edges , and 
triangles (faces) . 
The dual graph of  is , it has a node
  for each triangle , a face  for each 
vertex , and an edge  connecting vertices  and
 , if and only if triangles  and  share an edge in .

We further define the \emph{augmented dual graph} 
 .
Figure \ref{fig:aug_tri} shows an example of a triangulation, its dual, 
and its augmented dual graph.
The vertex set of  is formed by the union of the vertex set 
 of  and the nodes  of . 
We will distinguish between two types of vertices in , 
depending on from which set the vertex is drawn. 
The vertices taken from the dual graph, denoted , 
are referred to as the \emph{triangle nodes}. 
The vertices drawn from the set of vertices in the primal, , 
are refereed   
to as the \emph{point vertices} and are denoted .

For the edges of , we again distinguish two types
 of edges. 
The \emph{triangle edges} are exactly the edge set in the dual, . 
A \emph{point edge} is added between a triangle node and a point vertex
 if the point vertex is one of the corresponding triangle's three vertices in 
 the primal.  
We denote this set , and define it formally as:\\

\begin{centering}

\end{centering}
\vspace{12pt}


\noindent where  and  are the vertex and triangle, respectively, corresponding to 
 and . 
 also contains a set of faces , but these faces 
do not figure in our discussion. 


For purposes of quantifying bit costs, we denote by  
the number of bits required to represent a point in our data structures. 
Many applications for triangulations will not require that a key be stored 
with the triangles, therefore we assume that there is no  bit key associated 
with each triangle node. 
We show that the space used by keys in our graph structure is effectively 
the same as the space used by the point set in our triangulation, but that 
if we wish to maintain keys we can do so without significantly increasing 
the space used.

\begin{figure}
\centering
	\includegraphics[width=0.8\textwidth]{images/augmented_triangulation_wads}
\caption[Representation of a triangulation as a planar graph]{Representation 
	of a triangulation as a planar graph. 
  (a) The dual graph  of a triangulation, with vertices as hallow 
circles and edges as dashed lines. 
Edges in the triangulation  are shown as solid lines. 
(b) The augmented graph  is shown;
hallow points are triangle vertices, solid points are point 
vertices, black dashed lines are triangle edges, and solid green lines are point 
edges. }\label{fig:aug_tri}
\end{figure}


We begin with the following lemma. 

\begin{lemma}\label{lem:points_for_dual}
Given the dual graph , of triangulation  with 
 triangles, the augmented dual graph  has at most  
vertices.
\end{lemma}

\begin{proof}
The vertex set  includes the nodes  for which 
, and the vertex set . 
We prove by induction that , thus . 
For the base case, we have a terrain  with a single triangle in which case 
, and . 
Now assume that  holds for all terrains of  triangles. 
Let  be the dual graph of a triangulation  with  
triangles and  vertices. 
The dual graph  is created by adding a single triangle 
to . 
This new triangle, , has three adjacent points; however, 
since  is connected, at least one dual edge is added 
connecting a vertex  with the new vertex 
. 
In , this dual edge represents the fact that  and  are 
adjacent, and two of the vertices from  adjacent to  are already 
in . Therefore, adding a new triangle adds at most one 
additional point to  and .
\end{proof}

We encode  using a succinct planar graph data structure.
The various encodings all involve a permutation of the vertices of 
.
Let , the \emph{augmented graph label} of  be 
the position of a vertex  in this permutation. 
For every point vertex  in this set, 
we store the point coordinates in an array  ordered by the 
augmented graph label, . 
Finally, we create a bit vector  of length , where 
 if  is a triangle vertex and  if  is a 
point vertex. 
To summarize this structure we have the following lemma.

\begin{lemma}\label{lem:terrain_space}
The data structures described above can represent a terrain  composed 
of  triangles with  bit point coordinates, using 
 bits, such that given the label of a triangle, the adjacent
 triangles and points can be reported in  time.
\end{lemma}

\begin{proof}
Since the augmented planar graph is simple, we can encode it with 
 bits 
using the encoding of~\cite{DBLP:journals/siamcomp/ChiangLL05}. 
By Lemma \ref{lem:points_for_dual}, if  then 
, which bounds the number of vertices. 
Each triangle node is connected by an edge to at most three
other triangles, thus there are at most  triangle edges. 
Additionally, there are  point edges connecting the 
triangle vertices with point vertices, therefore in total there are no 
more than  edges. 
Thus the augmented graph can be encoded using at most  bits. 

In~\cite{DBLP:journals/siamcomp/ChiangLL05} adjacency and degree queries
 can be performed in . 
We must still demonstrate that given a label, we can identify the corresponding 
triangle vertex, and show that for a vertex we can distinguish between point 
vertex and triangle node neighbours. 
We assign to each triangle a unique graph label as follows. 
Consider the set of triangles in , the graph label of each 
triangle corresponds to that of its dual vertex . 
In , each of these vertices has an augmented graph label.  
The graph label of dual node , and therefore the 
corresponding triangle is equal to the rank of the corresponding 
triangle vertex 's augmented graph label among all 
vertices from the set . 

Given the graph label of a triangle node ,
 the augmented graph label is calculated as .
Conversely, given  for a triangle vertex 
, we can report the graph label 
of  by . 
In order to report the triangles adjacent to , we check in 
the succinct encoding for  to find all neighbours of 
. 
Since , this operation takes constant time. 
Let  be a neighbour of  in 
. 
The value of  indicates whether  is a 
triangle node or point vertex. 
We can recover the coordinates of a point vertex  by 
.

The array  stores at most  points. 
If each point requires  bits, then  
requires  bits. 
Finally, by Lemma \ref{lem:rank_select}(b) we can store the bit array 
 such that  and  can be performed in constant time 
with  bits.
\end{proof}

\subsection{Compact External Memory Representation}
\label{ssec:compact_tin_external}


In this section, we extend our data structures for I/O-efficient traversal in 
bounded-degree planar graphs (Section \ref{sec:graph_rep}) to triangulations. 
We thereby obtain a triangulation that is compact, but which also 
permits efficient traversal. 
We represent  by its dual graph . 
Since the dual graph of the triangulation (and subsequently each component) is a 
bounded-degree planar graph, it can be represented with the data structures 
described in Section \ref{sec:graph_rep}. 
Each component is a subgraph of , for which we generate the 
augmented subgraph, as described in Section~\ref{ssec:triangulation_rep}.

\begin{lemma}\label{lem:terrain_components}
The space requirement, in bits, to store a component (-neighbourhood
 or sub-region) representing a triangulation is within a constant factor of the 
space required to store the triangulation's dual graph. 
\end{lemma}

\begin{proof}
We first consider the case of -neighbourhoods. 
To store a triangulation, we require additional space to store: the points in  
adjacent to the component's triangles; the augmented 
graph, which includes more vertices and edges; and the bit-vector . 
By Lemma~\ref{lem:points_for_dual}, the points array is of size at most 
 bits. 
Since the -bit array of keys is no longer needed, storing the 
points incurs no additional space over that used to store the dual graph 
in our construction in Section \ref{sec:graph_rep}. 
However, if the keys are needed, we require 
 bits to 
store both the points and the key values.  
For the graph representation, again by Lemma \ref{lem:points_for_dual}, in 
the augmented graph we at most double the size of the vertex set, and add 
no more than  edges. 
The graph encoding is a linear function of the number of edges and 
vertices. 
Therefore, the number of bits required for the graph encoding 
increases by a constant factor. 
Finally, for  we require fewer than two bits per vertex, thus we can add 
this cost to the constant cost of representing the graph.

For subregions, the analysis is more complex. 
A subregion may be composed of multiple connected components, thus we cannot 
assume that there will be at most  point vertices in the 
augmented subgraph.  
By Lemma \ref{lem:fred_graph_sep}, there are no more than 
 boundary vertices in . 
Since each connected component in a subregion must have at least one boundary vertex, 
this bounds the number of distinct connected components in all subregions. 
Each subregion is composed of at most  individual 
components, therefore, in the worst case there are no more than 
 point vertices. 
Thus, the total number of vertices in the augmented graph is less than 
, which adds at most an additional  edges. 
As demonstrated with the -neighbourhoods, the additional storage, 
for all data structures used to represent a subregion, 
increases by only a constant factor.
\end{proof}

One important feature of our representation is that each triangle stores 
very limited topological information. 
Consider the information available to some triangle 
 in the augmented dual graph. 
We can determine the - up to three - triangles adjacent to , which 
correspond to the adjacent triangle vertices, as well as the three 
adjacent point vertices, but we have no information about how these are related.  
The only way to acquire this information is to actually visit each of 
's neighbours, and thereby construct the topological 
information. 
Fortunately, the need to visit the neighbours of a triangle in order to reconstruct 
its topological information will not increase the I/O costs of path traversal. 
If  corresponds to an interior vertex (in a subregion), or an 
internal vertex (in an -neighbourhood), then all of its neighbours are 
represented in the current component. 
If  corresponds to a boundary (subregion) or terminal 
(-neighbourhood) vertex, the traversal algorithm already requires 
that a new subregion, or -neighbourhood, be loaded. 
If we must load an -neighbourhood, we are ensured that all of 
's neighbours are in the new component. 
In the worst case,  is a terminal vertex in a 
-neighbourhood, and a boundary vertex in the newly loaded region. 
This forces us to load a second -neighbourhood; however, observe that 
the same sequence of I/Os is necessary even if we were not required to 
reconstruct 's local topology. 
Thus, at no point during a traversal is it necessary to load a component 
merely in order to construct the topology of a triangle in an adjacent, or overlapping, 
component.

Due to Theorem~\ref{thm:planar_graph} and Lemma~\ref{lem:terrain_components} we
have the following theorem.

\begin{theorem}\label{thm:terrain_traversal}
Given triangulation , where each point coordinate may be stored in 
 bits, there is a data structure that represents  in 
 bits, that permits traversal of a path 
which crosses  faces in  with 
 I/O operations.
\end{theorem} 

For the case in which we wish to associate a  bit key with each 
triangle we also have the following theorem.

\begin{theorem}\label{thm:terrain_keys_traversal}
Given triangulation , where each point coordinate may be stored 
in  bits, and where each triangle has associated with it a 
 bit key, there is a data structure that represents 
 in 
 bits, that 
permits traversal of a path which crosses  faces in  
with  I/O operations.
\end{theorem}

\begin{proof}
In our proof of Lemma \ref{lem:terrain_components}, we demonstrated 
that the number of triangles (dual nodes with an associated  
bit key) and points (of  bits) is within a constant factor 
of each other in the worst case. 
Assuming this worst case does occur, we are effectively assuming each 
triangle is associated with a  bit key in our data structures. 
This yields the desired space bound.
\end{proof}


\section{Point Location for Triangulations}\label{sec:point_location}



A common operation in any partition of space is point location, or more
specifically in  planar point location.
In Section \ref{sec:applications}, we describe a number of queries
that require, as part of the query, identification of the triangle 
containing a point. 
For example, in order to perform a rectangular window query, we start by
identifying the triangle containing one of the rectangle's four
corner points.
In this section, we describe how to extend our data structure
for triangulations (see Section \ref{sec:tins}) in order to answer point 
location queries efficiently.

Our point location structure is based on that of 
Bose~\etal~\cite{DBLP:journals/talg/BoseCHMM12}.
One important difference between our technique and theirs is that we use
a different data structure as the basis for performing point location.
Their construction relies on the point location structure of 
Kirkpatrick~\cite{DBLP:journals/siamcomp/Kirkpatrick83} for which there is no
known external memory version.  
We use the structure of Arge~\etal~\cite{DBLP:conf/alenex/ArgeDT03},
which uses linear space, and answers vertical ray shooting queries in 
 I/Os.

We want to design a point location structure which, given a query point , 
will return the label of the sub-region containing . 
Since the subregion fits in internal memory, point location can be carried
out within the subregion at no additional I/O cost.
We use a two-level search structure.  
The first level allows us to locate the region containing  while the 
second allows us to locate the subregion containing .
As the structure is effectively the same at each level, we will only 
describe the structure for locating the region in detail.

Consider the set of region boundary vertices used to partition . 
These correspond to a subset of the triangles in .
We select all the edges of this subset of the triangles of ,
and insert these into a search structure which we denote .
With each edge in , we associate the label of the region
immediately below it.
If the triangle below an edge is shared by more than one region, as
will often be the case, we can arbitrarily select one. 
Our search structure  is built using the persistent B-tree structure of 
Arge~\etal~\cite{DBLP:conf/alenex/ArgeDT03} which answers vertical
ray shooting queries.
We repeat this process for each region, creating a search structure
 for each region .


In order to determine to which region the query point  belongs, we perform a vertical 
ray shooting query from  to report the first edge encountered in 
above that point. 
Since we associate with each edge the region below it, the result of this query 
yields the region,  containing .
We then search in  to locate the sub-region  containing .
Finally, we perform an exhaustive search on the triangles of 
to locate the triangle containing .
It is possible, in the event that , that the search yields
no result at the cost of searching , , plus the
the exhaustive search of .
This is of course the same cost incurred by a successful search in the worst
case.

There is one important addition yet to make to the search structure .
Consider the situation depicted in Fig.~\ref{fig:pl_structure}(a), where
we wish to find the triangles containing points  and . 
The ray-shooting query from  correctly returns an edge of the separator
vertically above it; however, the ray starting from  never intersects a 
segment from the separator.

\begin{figure}
  \includegraphics[width=\textwidth]{images/suc_point_loc.pdf}
  \caption[Point location by vertical ray shooting]{In (a), a 
    partitioned triangulation is depicted along with two vertical
    ray shooting queries  and .
    Separator triangles between regions are shaded.
    Recall that the separator is calculated on the dual graph, thus
    the jagged appearance of the separator when drawn in the 
    triangulation.
    Inserting just the edges of boundary triangles into  is 
    sufficient to handle query  but query  fails.
    In (b), the complete search structure is shown.
    The segments added to  (drawn as black and heavy) 
    include all boundary triangle edges and the segments generated
    by partitioning .
    Region labels for a small subset of  are indicated just below
    their respective segments.
    Note that any query falling within , and even some outside,
    will return a region to search.
  }
  \label{fig:pl_structure}
\end{figure}
              
In order to ensure that the ray shooting query always reports a valid region, we 
extend our search structure  as follows.
Let  be a line segment with endpoints at the min and max 
 coordinates of , and with  coordinate .
We scan  from left to right and split  at any
point where the region immediately below the upper hull changes,
and record for each such segment the region immediately below.
If we insert all the newly-generated segments in , all vertical ray 
shooting queries within  now return a valid result.

\begin{lemma}\label{lem:size_s_infty}
The number of segments added to  by partitioning 
is bounded by the size of the region separator for the subdivision
at the region level. Likewise, the number of segments added 
to all  is bounded by the size of the subregion separators.
\end{lemma}

\begin{proof}
We begin with proving this claim for .
By definition,  is only split when the region immediately
below the upper hull of  changes.
Any such change must occur at a vertex in .
Let  be this vertex and an let  be a triangle in  
immediately to its left, and  a triangle in  immediately
to its right, where  and  are on the upper hull of
 (see Fig.~\ref{fig:pl_s_infty}).
Assume for the sake of contradiction that none of the triangles
adjacent to  is a boundary triangle. 
In our construction, no two edge adjacent triangles in 
can be in different regions unless at least one of them is
a boundary triangle.
Since  and  are in separate regions if we walk 
from  to  around , we must arrive at two 
triangles which do not have the same region, since the
region label changes at some point along this walk.
This contradicts the claim that no triangle adjacent to  is 
a boundary triangle.

The proof on the bound for the sizes of each  is 
analogous to that for .
There is one matter that must be addressed;
the separator algorithm of \cite{Frederickson87} does
not guarantee contiguous regions in .
Within a region, this may introduce discontinuities 
that increase the complexity of .
However, the number of such discontinuities is in no case
worse than the size of the region separator over
all . 

\end{proof}

\begin{figure}
  \centering
  \includegraphics[scale=1.0]{images/bound_on_S_infty.pdf}
  \caption[Bound on size of ]{
  Illustration of proof that region boundary triangle must
  exists at a break in .
  }
  \label{fig:pl_s_infty}
\end{figure}



\begin{lemma}\label{lem:point_location_space}
By augmenting our terrain data structure with a structure using an additional 
 bits, point location queries can be answered in 
 I/Os.
\end{lemma}

\begin{proof}
In the top level, region finding, data structure there are 
 region boundary vertices. 
For each such vertex we insert at most six edges into our search structure;
this includes three edges for each triangle in the separator, plus any edges
added to  by Lemma~\ref{lem:size_s_infty}.
Associated with each edge we must store  bits for the endpoints, 
plus a region label requiring  
bits. 
Thus the total space, in bits, required by this structure will be:



For the subregion search structures we will consider their space cumulatively.
We add  edges, each requiring  bits 
for the endpoints,
and  bit references to the  sub-regions within the region. 
Again, by Lemma~\ref{lem:size_s_infty}, the addition of edges in  does not 
asymptotically increase the size of the .
The space required for this structure is then:



The first term of this equation is clearly . 
Recall that  and that . 
Thus, for the second term of Eq.(\ref{eqn:pl_subregion_space}) we have:

 

The total space we use is thus bounded by  bits. 
The I/O complexity stems from the fact that we perform two point location 
queries on data structures that answer the query in  I/Os.
\end{proof}

\begin{theorem}\label{thm:terrain_with_point_location}
Given a terrain , where each point coordinate may be stored in  
bits, there is a data structure that represents  in 
 bits that permits traversal of a path crossing 
 faces in  with  I/Os, and which 
supports point location queries with  I/Os.
\end{theorem} 

\begin{proof}
The terrain data structure requires  bits by 
Theorem \ref{thm:terrain_traversal}. 
By Lemma \ref{lem:point_location_space}, adding point location requires only 
 bits, thus the overall space bound is the same and queries 
can be answered in  I/Os.
\end{proof}


\section{Applications}
  \label{sec:applications}


  In this section, we present a number of applications involving path traversal
  in triangulations.
  These applications employ the data structures described in Sections \ref{sec:tins}
  and \ref{sec:point_location}.
  The applications, in particular those described in 
  Section~\ref{ssec:ter_profile_tpath}, deal with triangulations used to model 
  terrains.
  A terrain model is a digital model of some surface.
  Most often the surface being modeled is some region of the earth, but any surface
  with relief can be modeled.
  Triangulations, commonly refered to as Triangular Irregular Networks, or TINs 
  in this context, are one means of modeling a digital terrain.
  In a TIN, the point set  is a set of points of known elevation. 
  Given a triangulation, , built on , the elevation for any
  point, say , on the surface can be readily estimated from the vertices
  of the triangle containing .
  In addition to  and  coordinates, each point in  stores a 
  coordinate which records the elevation.
  Such models are sometimes refered to as 2.5 dimensional, since they cannot 
  properly represent a truly three-dimensional surface (for example there is no
  way for a planar triangulation to represent an overhanging cliff). 

  We begin by describing two simple and closely related queries, 
  reporting terrain profiles, and trickle paths, in 
  Section~\ref{ssec:ter_profile_tpath}.  
  In Section~\ref{sec:con_comp_queries}, we present a slightly more complex 
  application of our data structures, 
  reporting connected components of a triangulation (or terrain). 
  We start with the simpler case of reporting a component which is a convex
  subregion of the triangulation, and then describe methods for the more 
  general case where the connected component may represent a non-convex region.
  As all the queries we describe in this section require that a starting 
  triangle in the mesh be identified, we will assume that this triangle
  is given as part of the query.
  In practice, most of the queries we describe here can use a start triangle,
  identified by answering a
  single planar point location query using the technique outlined in 
  Section~\ref{sec:point_location}.

  \subsection{Terrain Profiles and Trickle Paths}\label{ssec:ter_profile_tpath}

  Terrain profiles are a common tool in GIS visualization. 
  The input is a line segment, or chain of line segments possibly forming a polygon, 
  and the output is a profile of the elevation along the line segment(s). 
  The trickle path, or path of steepest descent, from a point  is the path on
  the terrain, represented by , 
  that begins at  and follows the direction of steepest descent until it reaches 
  a local minimum or the boundary of  \cite{DBLP:conf/cccg/BergBDKOGRSY96}. 
  Both queries involve traversing a path over , with the fundamental 
  difference being that in the terrain profile the path is given, whereas in 
  reporting the trickle path, the path is unknown beforehand and must be 
  determined based on local terrain characteristics.

  In analyzing these algorithms, we measure the complexity of a path by length 
  of the sequence of triangles visited, which we denote by . 
  When a path intersects a vertex, we consider all triangles adjacent to that 
  vertex to have been visited. 
  Given this definition, we have the following result for terrain profile and 
  trickle path queries:

  \begin{lemma}\label{lem:tprofile_tpath}
  Let  be a terrain stored using the representation described
  in Theorem~\ref{thm:terrain_traversal}, then:
  \begin{enumerate}
  \item{ Given a chain of line segments, , the profile of the intersection 
  of  with  can be reported with  I/Os.}
  \item{ Given a point  the trickle path from  can be reported with 
   I/Os.}
  \end{enumerate}
  \end{lemma}

  \begin{proof}
  Let  be a chain of  segments, denoted . 
  In order to report an elevation profile, start at the endpoint of , and 
  let  be the triangle which contains this endpoint. 
  We calculate the intersection of  with the boundary of  in order to determine 
  which triangle to visit next. 
  If at any point in reporting the query the next endpoint of the current segment 
   falls within the current triangle, we advance to the next segment 
  . 
  This procedure is repeated until the closing endpoint of  is reached.
  This query requires walking a path through  that visits exactly  triangles.

  For the trickle path, we are given triangle  and some point interior to . 
  The trickle path from , and its intersection with the boundary of , 
  can be calculated from the coordinates of the point vertices adjacent to . 
  If the path crosses only the faces of triangles, we can simply report the 
  intersection of the path with those triangles.
  By Theorem \ref{thm:terrain_traversal}, it 
  requires  I/Os to report a path crossing  triangles. 
  When an edge is followed, visiting both faces adjacent to that edge no more 
  than doubles the number of triangles visited. 
  The only possible problem occurs when the path intersects a point vertex. 
  Such cases require a walk around the point vertex in order to determine 
  through which triangle 
  (or edge) the path exits, or if the point vertex is a local minima. 
  In this case, the path must visit each triangle adjacent to the point vertex 
  through which it passes, thus all triangles visited during the cycle around a 
  point vertex are accounted for in the path length .
  \end{proof}

\subsection{Connected Component Queries}\label{sec:con_comp_queries}


  In this section, we describe how connected component queries can be reported 
  using our data structures. 
  We begin by defining \emph{connected component} and \emph{connected
  component query} in this setting.
  Let  be a triangulation, and let  be a triangle in . 
  We denote by  some property that is true for .
  This property may be some value stored for each triangle, or some value that
  can be computed locally, such as slope or aspect if  is a terrain.
  The connected component of  with respect to  is the 
  subset , such that following conditions hold for
  all :

  \begin{enumerate}
    \item  is true, and
    \item there exists a path  where  and 
     such that  is true for all , and  
    and  are adjacent.
  \end{enumerate}

  In order to simplify the discussion that follows, we adopt two conventions that we use
  throughout this section. 
  Firstly, while we assume that  is represented by its augmented dual
  graph , we will describe the various algorithms in terms
  of operations on the dual graph . 
  Furthermore, when we can do so without confusion, we use a single identifier
  to represent both a triangle and its corresponding node in the dual.
  For example, if we have triangle  corresponding to  
  , we may use  in reference to both the
  triangle and the dual node.

  The second convention we will adopt relates to .
  If  is true, then we call  a \emph{red} node (triangle).  
  If  is false, then we call  a \emph{black} node (triangle).







  In Section~\ref{ssec:conv_con_comp} we address queries 
  where the component being reported is convex. 
  This constraint is not as limiting as it may seem.
  For example, rectangular window queries, a very common type of query, 
  may be viewed as a specialized case of reporting a convex 
  component.
  In Section~\ref{ssec:gen_con_comp}, we deal with the more challenging 
  problem of reporting
  connected components where the component may be non-convex.

\subsubsection{Convex Connected Components}\label{ssec:conv_con_comp}


  Before describing the reporting of convex connected components, we show how 
  to solve a related problem. 
  Given the dual of a convex triangulation, , and a 
  vertex , 
  perform a depth-first traversal of , starting at , without 
  using mark bits.
  Mark bits are commonly used in depth-first traversal to record which vertices 
  have already been visited. 
  However, their use is infeasible with our data structures, due to the 
  duplication of the vertices of .
  Mark bits would require that we find and mark all duplicates of 
  a vertex whenever it is visited.
  This entirely defeats the purpose of our data structure.

  In order to avoid the use of mark bits, we select from among the edges incident 
  to each node a single \emph{entry} edge for that node. 
  While performing a depth-first traversal, we extend the traversal 
  to a node only along its entry edge.
  This leaves us with the problem of determining how to select the entry edge
  for a node.  
  Gold and Maydell~\cite{gold_maydell_1978} and Gold and 
  Cormack~\cite{gold_cormack86} demonstrated how such an entry edge could 
  be selected to enable depth-first traversal on a triangulation.
  Their approach identified one of the three edges of a triangle as its 
  entry edge.
  Since there is a one-to-one correspondence between the edges in  
  and , we can apply such a rule to identifying entry
  edges for nodes in . 
  De~Berg~\etal~\cite{DBLP:journals/gis/BergKOO97} showed that the same technique can 
  be applied to the more general case of planar subdivisions, and 
  gave an entry-edge selection rule for polygons that, naturally, also works 
  for triangles.
  De~Berg's selection rule operates as follows\footnote{We 
  omit some minor details that are not relevant to triangles.}:

  \begin{enumerate}
  \item Let  be a triangle in , and let  be a point interior
  to .
  \item Let  be the triangle for which we wish to identify an entry edge.
  Calculate the distance from  to the closures of all edges of .
  Let  be the point on  that minimizes . 
  \item If  is interior to an edge of ; select this edge as the
  entry edge, otherwise,  must be a vertex of . In this case, let
   and  be the edges adjacent to . If  is \emph{exposed}
  to , such that the line  induced by  has
   strictly to its right, then select  as the entry edge, otherwise
  select . 
  \end{enumerate}

  Now consider the graph .
  If we remove all edges from  that
  do not correspond to entry edges in , we are left with a tree, 
  rooted at  (see Figure \ref{fig:imp_tree_entry}).
  Proof of this claim can be found in~\cite{DBLP:journals/gis/BergKOO97}.
  The triangle , which contains , has no entry edges itself.

  \begin{figure}[th]
	  \centering
		  \includegraphics[width=0.6\textwidth]{images/imp_tree_entry.pdf}
	  \caption[Dual graph with non-entry edges removed forms a tree]{ 
	    A triangulation is shown with its dual graph. 
	    The blue arrows indicate the entry edges selected for each triangle when
	    triangle  is selected as the root ( is circled). 
	    The arrows are directed from child to parent.
	    Removing the non-entry edges results in a tree in the dual, rooted at 
	    .
	    So long as a connected component is convex (e.g., the shaded area) this 
	    tree property holds for the subgraph consisting of only nodes in the
	    component.} \label{fig:imp_tree_entry}
  \end{figure}
	  
  \begin{figure}[th]
	  \centering 
	  \includegraphics[width=0.6\textwidth]{images/imp_tree_convex.pdf}
	  \caption[Tree rooted at ]{ The tree rooted at . 
	    The red nodes indicate nodes of the subtree contained within the 
	    connected component; this subtree is still connected even when all 
	    (black) nodes - which are not part of the component - 
	    are removed.} \label{fig:implicit_tree}
  \end{figure}

  This result leads to a simple traversal algorithm for connected 
  components, in the case where we know that the region to be reported 
  is convex.
  We summarize with the following lemma.

  \begin{lemma}\label{lem:report_convex_component}
  Let  be a connected, convex component.
  Given  we can report all triangles in  with 
   I/Os.
  \end{lemma}

  \begin{proof}
  Performing a depth-first search on a tree on  vertices is equivalent 
  to walking a path of length at most .
  By Theorem \ref{thm:terrain_traversal}, our data structures permit a walk along 
  such a path with a total I/O cost of .

  Let  be some point interior to , and let  be
  the triangle containing .
  Starting with , we implicitly construct a tree in  using the 
  selection method of~\cite{DBLP:journals/gis/BergKOO97}.
  Since  is convex, removing all subtrees rooted at black nodes results 
  in an implicit tree, rooted at , which includes all red nodes in 
  (see Figures \ref{fig:imp_tree_entry} and \ref{fig:implicit_tree}).
  It remains to be proven that the removal of all subtrees rooted at black nodes
  will not result in the removal of any red nodes from the tree.
  Assume that removing the subtree rooted at some black node,  removes some
  red node . 
  Let  be the parent of  in . 
  The entry edge corresponding to dual edge  must be on the convex
  hull of .
  However, this means that  must be outside the convex hull of , which
  is a contradition.
  Therefore, no such triangle (node)  can be removed.
  \end{proof}
  
  We give the following corollary to Lemma \ref{lem:report_convex_component}
  with application to rectangular window queries.
  Such queries are a specialization of reporting a convex region 
  and occur commonly in practice.

  \begin{corollary}\label{cor:window_query}
  Given a terrain , and a query window , the set of 
  triangles which intersect the query window can be 
  reported with  I/Os. 
  \end{corollary}

  \begin{proof}
  The query window problem is equivalent to reporting 
  a connected component where the selection property is that a triangle 
  intersects the query window . 
  The region to be reported is convex, but care must be taken with 
  triangles that intersect the query window boundary. 
  In \cite{DBLP:journals/gis/BergKOO97} it is shown that the entry edge selection 
  rule can be modified to disqualify any edge (or portion thereof) that 
  is outside . 
  Using this modification, an implicit rooted tree is still formed on 
  the triangles of , and we can perform a memoryless 
  depth-first traversal.
  \end{proof}

\subsubsection{General Connected Components}\label{ssec:gen_con_comp}


  In this section, we present an algorithm that reports connected components 
  that may be non-convex and/or contain holes.
  Using the terminology developed in Section~\ref{ssec:conv_con_comp}, we 
  say  is a connected component in , corresponding 
  to  in . 
  Recall that  forms a connected component of red nodes 
  in the subgraph formed by all red nodes in .
  In , we can think of the boundary of a connected component being 
  formed by all edges along the outer perimeter of the component 
  in addition to any edges along the perimeters of holes. 
  In the dual, the boundary corresponds to the set of edges connecting 
  red vertices in , with black vertices in . 

  In order to report , we select some triangle  as our
  start triangle. 
  We select entry edges relative to an arbitrary point interior to .
  Since  itself is convex, we can construct an implicit tree
  on the nodes of , rooted at .
  We denote this tree .
  
  Let  and  be red and black vertices in
  , corresponding to adjacent triangles in .
  Let  be the edge of  separating triangles  and .
  In ,  corresponds to the edge .
   While this edge is undirected in , for the sake of the
  discussion that follows we will assume that in , it
  is directed towards the root, .
  We call such edges \emph{boundary} edges, and classify them according
  to their role in the implicit tree , as follows 
  (see Fig.\ref{fig:imp_tree_non-convex}):
  
  \begin{enumerate}
    \item if , then  is a \emph{wall}\footnote{
    All edges on the convex hull of  are considered wall edges.} edge,
    \item if  is the parent of , then  is an \emph{access} edge, and 
    \item if  is the parent of , then  is an \emph{exit} edge.
  \end{enumerate}

  \begin{figure}[th]
	  \centering
		  \includegraphics[width=0.6\textwidth]{images/imp_tree_non-convex.pdf}
	  \caption[Boundary edge definitions]{A triangulation and the implicit tree 
	  formed by the entry edges selected for the circled vertex . 
	  In this case, the connected component of  is non-convex so that the tree 
	  formed by only red nodes is disconnected. 
	  The boundary edges of the triangulation are indicated by the heavy dashed 
	  blue line. 
	  Using our notation for boundary edges, A is a \emph{wall} edge, B is an 
	  \emph{access} edge where the tree enters the component, and C is an 
	  \emph{exit} edge where the tree leaves the component. }
	  \label{fig:imp_tree_non-convex}
  \end{figure}

  We report the triangles in  using the algorithm 
   listed in Fig. \ref{fig:traverse_graph_algorithm}.
   performs a standard depth-first traversal in 
  , with one important modification. 
  If a branch of the algorithm's execution terminates at an access boundary 
  edge, then the function  (Fig. \ref{fig:scanhandrail_alg}) 
  is invoked. 
   traverses the chain of boundary edges, and recursively calls 
   at each exit edge. 
  A search structure, , is maintained to ensure that no boundary edge is 
  scanned more than once.  
  Whenever an access edge is visited during the  
  or  
  processes, it is added to the search structure  if it is not already 
  present. 
  If an access edge is encountered that is already in , then execution 
  of  is halted. 
  Likewise, when  encounters an access edge already in 
  , it does not invoke . 
  Figure \ref{fig:cmp_with_holes} demonstrates the operation of
   and .

  \begin{figure}[h]
  \protect \framebox[0.95\linewidth]
  {
  \begin{minipage}{0.90\linewidth}

  \textbf{Algorithm } \\
  1. \hspace{3pt}  \\
  2. \hspace{3pt} \textbf{do} \\
  3. \hspace{18pt} \textbf{if}( has unvisited children) \\
  4. \hspace{33pt}  next unvisited child of  \\
  5. \hspace{33pt} \textbf{if}() \\
  6. \hspace{48pt}  boundary edge corresponding to  \\
  7. \hspace{48pt} \textbf{if}( is an access edge \textbf{and} ) \\
  8. \hspace{63pt}  \\
  9. \hspace{48pt} \textbf{endif} \\
  10. \hspace{30pt} \textbf{else} \\
  11. \hspace{45pt}  \\
  12. \hspace{30pt} \textbf{endif} \\
  13. \hspace{15pt} \textbf{else} \\
  14. \hspace{30pt}  parent of  \\
  15. \hspace{15pt} \textbf{endif} \\
  16. \textbf{until}( has no more unvisited children \textbf{and} ) \\
  \end{minipage}
  }
  \caption{Algorithm . }
  \label{fig:traverse_graph_algorithm}
  \end{figure}

  \begin{figure}[h]
  \protect \framebox[0.95\linewidth]
  {
  \begin{minipage}{0.90\linewidth}

  \textbf{Algorithm } \\
  1. \hspace{3pt}  next boundary edge in counterclockwise direction from  \\
  2. \hspace{3pt} \textbf{do} \\
  3. \hspace{18pt} \textbf{if}( is an access edge) \\
  4. \hspace{33pt} \textbf{if}() \\
  5. \hspace{48pt} \textbf{break} \\
  6. \hspace{33pt} \textbf{else} \\
  7. \hspace{48pt} add  to  \\
  8. \hspace{33pt} \textbf{endif} \\
  9. \hspace{18pt} \textbf{endif} \\
  10. \hspace{15pt} \textbf{if}( is an exit edge) \\
  11. \hspace{30pt} select triangle  adjacent to  \\
  12. \hspace{30pt}  \\
  13. \hspace{15pt} \textbf{endif} \\
  14. \textbf{until}(e' == e) \\
  \end{minipage}
  }
  \caption{Algorithm . }
  \label{fig:scanhandrail_alg}
  \end{figure}

  \begin{figure}[th]
	  \centering
		  \includegraphics[width=0.8\textwidth]{images/component_with_holes.pdf}
	  \caption[Traversal example on non-convex region with holes]{On the left is shown a 
	  triangulation  and connected component  (shaded) 
	  with a non-convex boundary and holes. 
	  The original tree  is shown on the right, with vertices labeled by preorder 
	  number for the entire triangulation . 
	  Hallow vertices correspond to vertices removed from  by holes and/or 
	  concavities in the boundary of . 
	  The parent-child relationships, as well as the vertex labels are also shown on . 
	  In  boundary edges are thick lines, with entry edges being dashed 
	  and exit edges dotted. 
	  The original call to  first encounters the 
	  entry edge 
	  (8,7), from which  will visit exit edges (9,8), 
	  (12,11), and 
	  (14,13), in that order, before terminating back at . 
	  This initial call to  results in subtrees rooted
	  at vertices 
	  , , and  being reported. 
	   is not invoked from entry edge (10,2), as this 
	  edge is added 
	  to  during the invocation of  from 
	  . 
	   is, however, called from , which results 
	  in entry 
	  edges ,  and  being visited and the subtrees 
	  rooted at vertices , , and  being reported.
	  The dashed arrows represent cases where  jumps 
	  between
	  \emph{access} edges and \emph{exit} edges.}
	  \label{fig:cmp_with_holes}
  \end{figure}

  \begin{lemma}\label{lem:cc_holes_alg_correctness}
  Given a triangle , the algorithms 
   and  report all
  triangles in . 
  \end{lemma}

  \begin{proof}
  Let  be the start triangle selected for ,
  and let  be a node in  not reported by 
  .
  Since  is the root of , there is a path connecting  
  to  in  . 
  If all nodes on the path from  to  in  are red, then
  clearly  reports .
  Thus, there must be black nodes on the path , corresponding to
  the path leaving .
  Let  and  be the first, and last, nodes encountered on the first such
  black subpath on  (it may be the case that ).
  Let  be the red node preceeding  on , and let  be
  the red node following  on the same path (see 
  Figure~\ref{fig:component_subpaths}).
  The edge  is an exit edge, while  is an access edge under
  our definitions. 
  The subpath  is wholly contained in , thus the call
  to  from  reaches .
  If the access edge corresponding to  has not 
  been previously visited, the  algorithm is invoked.
  The call to  visits the edge , unless it
  is blocked when it encounters a previously visisted access edge in 
  .
  This may  occur if one of the recursive 
  calls to  made at exit edges during 
   
  encounters the same boundary. 
  However, if  is blocked from visiting  in 
  such a fashion, then  must have been called
  from the blocking access edge. 
  Let  be a sequence of such blocking calls to 
   along the boundary chain between  
  and . 
  Clearly, the last such call, , will result in  being visited. 
  This same argument can be applied to any other subpaths leaving 
   on , and as such  is visited by 
  .
  \end{proof}

  \begin{figure}[th]
	  \centering
		  \includegraphics[width=0.6\textwidth]{images/component_subpaths.pdf}
	  \caption[General component subpaths]{The path through the tree 
	   connecting nodes  and , which are both
	  part of the connected component . The path
	  leaves  at  and re-enters at .}
	  \label{fig:component_subpaths}
  \end{figure}
  
  The I/O cost of reporting a general connected component includes
  the cost to walk the triangles of , plus the cost
  of walking the boundary of .
  We denote by  the size of the boundary, and summarize our I/O
  costs with the following lemma.

  \begin{lemma}\label{lem:io_eff_ccomp}
  The algorithm  reports a connected 
  component 
   with  boundary edges using 
   I/Os.
  \end{lemma} 

  \begin{proof}
  Performing depth-first traversal is equivalent to a walk of 
  length at most , which can be performed in 
   I/Os. 
  We must also account for the length of the paths traversed by calls 
  to . 
  Any triangle in  may be visited at most three times, since 
  it may be adjacent to no more than three different boundary chains. 
  Thus, the total additional length of the walks associated with calls 
  to  is bounded by , which 
  increases the length of the path traversed by a constant factor. 

  We must also account for the number of I/Os required to maintain 
  and query the boundary edge structure . 
  There are  boundary edges, and in the worst case most of these 
  edges may be access edges. 
  Using a B-tree to store  
  supports insertions and queries in  time.  
  An access edge is added to  only once, and is visited at 
  most one additional time. 
  Thus the total cost to maintain and query  is .  
  \end{proof}

  Finally, we account for the space used to store . 
  Since our triangulation does not store edges, we must have some
  way of uniquely identifying the edges in .
  We do so by storing the coordinates of the midpoint of each edge, which
  serves as our search key.
  For  we use a B-tree, and for each edge store a -bit 
  key plus a  bit pointer. 
  Thus the space for this structure is  
  bits. 
  In theory, the size of this structure could be as large as ,
  but in many scenarios it will be significantly smaller.  
  The following theorem summarizes our results 
  for convex and general connected components. 
  The space bound adds the space for  to the bound from
  Theorem \ref{thm:terrain_traversal}.
  The I/O bounds are obtained from Lemmas \ref{lem:report_convex_component} 
  and \ref{lem:io_eff_ccomp}.

  \begin{theorem}\label{thm:conn_comp}
  A triangulation , with -bit keys per triangle, may be 
  stored using 
   
  bits such that a 
  connected component  may be reported using 
   I/Os if 
  is convex.  
  If  may be non-convex or have holes, then the query requires 
   
  I/Os, plus an additional  bits of storage, 
  where  is the number of boundary edges of 
  .
  \end{theorem}

\subsection{Connected Components Without Additional Storage}
  \label{ssec:no_add_storage}


  One drawback with our technique for reporting connected components 
  in Section~\ref{ssec:gen_con_comp} is that 
  we must store the search structure  in order to complete the 
  traversal. 
  In this section, we present a revised version of the algorithm that removes 
  the need for this additional data structure, at the cost of performing 
  additional I/O operations.

  Our technique is based on the algorithm of Bose and 
  Morin~\cite{DBLP:conf/isaac/BoseM00}, for the more general case of subdivision 
  traversal in planar subdivisions. 
  That paper, in turn, is a refinement of the algorithm presented by 
  de~Berg~\etal~\cite{DBLP:journals/gis/BergKOO97}. 
  The strategy in both papers is to identify a single entry edge on each face. 
  When an edge is visited while reporting the edges of a face, a check is made 
  to determine if it is the (unique) entry edge for an adjacent face. 
  If the edge proves to be an entry edge, then the adjacent face is entered. 
  The resulting traversal is a depth-first traversal of the faces of the 
  subdivision. 
  In both papers, (\cite{DBLP:conf/isaac/BoseM00} and \cite{DBLP:journals/gis/BergKOO97}),
  the subdivision is assumed 
  to be represented as a doubly-connected edge list, or a similar 
  topological structure. 

  Bose and Morin~\cite{DBLP:conf/isaac/BoseM00} select entry edges based 
  on a total order  on the edges of the subdivision. 
  The position of each edge,  in , is determined based on 
  the edge's key. 
  The key is a 4-tuple of properties that can be calculated locally for 
  each edge, based on the edge's geometry. 
  As with our previous entry edge selection rule, the keys are calculated 
  with respect to a known point interior to the start triangle.
  To determine if an edge is the entry point of a face, the following 
  \emph{both-ways} search is performed.
  Starting at edge , the face is scanned in both directions 
  until either (a) an edge  is encountered with 
  a lower key than  in , or (b) the scans meet without 
  having found any such edge.  
  In case (b), the edge  is then selected as the entry edge for 
  the face.

  The main result of Bose and Morin is that for a subdivision 
  with  vertices, all faces (including edges and vertices) can be 
  reported in  steps. 
  Their approach can also be applied to reporting a connected 
  component of the subdivision in  time, where the 
   is the number of vertices in the component.  

  In this chapter, all faces are triangles, thus to find the entry edge
  at the triangle level is a constant-time operation using any
  selection technique.
  Where the 'search both ways' technique proves useful in our setting 
  is in dealing with the boundary of the component. 
  A hole may consist of 
  one or many faces (triangles), but we treat a hole as if it were a 
  single face.
  For each hole, we want to identify a unique entry edge from among
  the access edges on its boundary.
  Since edges are not explicitly stored in our construction, walking
  the boundary involves walking the set of triangles that touch the boundary. 
  This includes all triangles in  that:
  
  \begin{enumerate}
  \item have an edge on the boundary, or
  \item have an adjacent vertex, , that lies on the boundary.
  \end{enumerate}
  
  Let  denote the number of triangles touching the boundary of
  . 
  This includes both holes in  and its outer boundary.
  A triangle can be adjacent to the boundary at no more than three 
  points (or edges), therefore 
  . 
  
  Assume  is some hole in our component. 
  In order to apply the analysis of Bose and Morin directly to our results, 
  we conceptually add zero length
  \emph{pseudo-edges} to  at any point on the boundary of  that 
  is adjacent to a triangle  which touches  at a point, but which 
  does not share an edge with  (see Fig. \ref{fig:pseudo-face} ). 
  With respect to the key values in , we set the value of 
  a key for a pseudo-edge to . 
  Since the entry edge in any hole is the edge of minimum key value, 
  no pseudo-edge will ever be selected. 
  Given this definition of a pseudo-edge, the value  can also 
  be considered the sum of real and pseudo-edges over all holes 
  and the exterior boundary of the component .

  \begin{figure}[th]
	  \centering
		  \includegraphics[width=0.8\textwidth]{images/expand_points.pdf}
	  \caption[Pseudo-edges in region boundaries]{The figure on the left 
    shows a portion of a component (gray) with a hole (white). 
	  The dashed box indicates the detailed area shown in the figure on the
	  right. 
	  The right-hand figure shows conceptually how additional edges are 
	  added to the hole boundary, corresponding to triangles in the component.
	  At the point marked , a single pseudo-edge is added as there is 
	  only one non-edge adjacent triangle adjacent to this point. 
	  The point  has two non-edge adjacent triangles, therefore two pseudo-edges 
	   and  are added to the hole boundary. }
	  \label{fig:pseudo-face}
  \end{figure}

  The following lemma summarizes results for Bose and Morin that can now be 
  applied directly to our setting.

  \begin{lemma}\label{lem:bose_morin_time}
  For a connected component  requiring  triangles to be visited 
  in order to walk the boundary of all holes plus the exterior boundary of 
  , the both-ways search technique can find entry edges for all 
  holes (and the perimeter) in at most  steps, 
  or  I/Os. 
  \end{lemma}

  \begin{proof}
  Theorem 1 in Bose and Morin \cite{DBLP:conf/isaac/BoseM00} states that 
  a planar subdivision of faces with  vertices can be traversed in 
   time. 
  By adding zero-length pseudo-edges, we effectively make 
  the set of holes and the exterior boundary equivalent to faces with 
  a total of  edges. 
  Thus, using the both-ways search, we can locate entry edges with 
   steps. 
  Since we can travel  steps during such 
  searches before incurring an I/O, we can perform all such searches in 
   I/Os.
  \end{proof}

  Applying the both-ways search technique presented above requires only 
  minor modifications to our algorithms. 
  In the  algorithm (Fig. 
  \ref{fig:traverse_graph_algorithm}) at line 7, rather than check 
  if , we perform the both-ways search to determine 
  if  is the unique entry edge. 
  If this is true, we then perform  starting with . 
  The only alteration to the  algorithm 
  (Fig. \ref{fig:scanhandrail_alg}) is that we can omit steps 3 
  through 9, since following the both-ways search we know that  
  is the  unique entry edge for the boundary or hole.  

  To summarize we have the following theorem.

  \begin{theorem}\label{thm:conn_comp_without_add_storage}
  A triangulation , with -bit keys per triangle, 
  may be stored using  bits such 
  that a connected component  may be reported using 
   I/Os, where 
   is the total number of triangles that touch all holes in, 
  plus the boundary of, .
  \end{theorem}
  
  \section{Conclusions}\label{sec:graph_conclusions}
  
  In this chapter we have presented succinct structures supporting
  I/O efficient path traversal in planar graphs.
  In fact, our results are somewhat more general than this.
  The key features of planar graphs which our data structures rely
  on are; first, planar graphs are -page embeddable, and second, 
  planar graphs of bounded degree have an -partition with
  a suitably small separator. 
  Any class of graphs for which these two properties hold should 
  permit construction of the succinct data structures.

