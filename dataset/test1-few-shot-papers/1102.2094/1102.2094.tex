\documentclass{article}
\usepackage[a4paper, centering, margin=2cm]{geometry}
\usepackage{amsmath,algorithmic,graphicx,charter}

\hyphenation{op-tical net-works semi-conduc-tor}



\newtheorem{Definition}{Definition}
\newtheorem{validity test}{Validity Test}
\newtheorem{Lemma}{Lemma} 
\newtheorem{proof}{Proof} 
\newtheorem{Corollary}{Corollary}
\newtheorem{Property}{Property}
\newtheorem{Example}{Example}
\newtheorem{KeyResult}{Key Result}
\newtheorem{Observation}{Observation}

\renewcommand{\algorithmicrequire}{\textbf{Input:}}
\renewcommand{\algorithmicensure}{\textbf{Output:}}
\newcommand{\cpu}{\operatorname{CPU}}
\newcommand{\avl}{\operatorname{avl}}

\renewcommand{\arraystretch}{1.3}


\newcommand{\equals}{\stackrel{\mathrm{def}}{=}}
\newcommand{\gp}[1]{\stackrel{(#1)}{\tiny >}}

\newenvironment{DIFnomarkup}{}{}
\newcommand{\dm}{\mbox{\textsf{DM}}} 
\newcommand{\edf}{\operatorname{\sc EDF}}
\newcommand{\edfmin}{\tiny{\operatorname{\sc EDF}}}
\newcommand{\BCL}{\mbox{\textsf{BCL}}} 
\newcommand{\BAK}{\mbox{\textsf{BAK}}}
\newcommand{\BB}{\mbox{\textsf{BB}}}
\newcommand{\edfk}{\mbox{\textsf{EDF(k)}}} 
\newcommand{\ffd}{\mbox{\textsf{FFDD}}} 
\newcommand{\bfd}{\mbox{\textsf{BFDD}}} 
\newcommand{\wfd}{\mbox{\textsf{WFDD}}} 
\newcommand{\ga}{\mbox{\textsf{GA}}} 
\newcommand{\sa}{\mbox{\textsf{SA}}} 

\newcommand{\speed}{\mbox{\textsf{speed}}}
\newcommand{\Usum}{U_{\mbox{\footnotesize\textsf{sum}}}}
\newcommand{\Umax}{U_{\mbox{\footnotesize\textsf{max}}}}
\newcommand{\Ssum}{S_{\mbox{\footnotesize\textsf{sum}}}}
\newcommand{\Smax}{S_{\mbox{\footnotesize\textsf{max}}}}
\newcommand{\Ceil}[1]{\left\lceil #1 \right\rceil}


\newcommand{\lp}{\operatorname{lp}}
\newcommand{\hp}{\operatorname{hp}}
\newcommand{\LP}{\operatorname{LP}}
\newcommand{\HP}{\operatorname{HP}}
\newcommand{\x}{\operatorname{x}}
\newcommand{\random}{\operatorname{Random}}
\newcommand{\prob}{\operatorname{Prob}}
\newcommand{\getTemp}{\operatorname{getTemperature}}
\newcommand{\cutvector}{\operatorname{CutVector}}
\newcommand{\taskindex}{\operatorname{index}}
\newcommand{\sched}{\operatorname{sched}}
\newcommand{\schededf}{\mbox{\textsf{\scriptsize EDF}}}
\newcommand{\scheddm}{\mbox{\textsf{\scriptsize DM}}}
\newcommand{\current}{\operatorname{cur}}
\newcommand{\neighbor}{\operatorname{neighbor}}
\newcommand{\dmp}{\operatorname{DMP}}
\newcommand{\Pdmp}{\pi^{\operatorname{\sc dmp}}}
\newcommand{\Pident}{\pi^{\operatorname{\sc ident}}}
\newcommand{\td}{\operatorname{3d}}
\newcommand{\CPU}{\mbox{\sc cpu}}
\newcommand{\LOAD}{\mbox{\sc load}}
\newcommand{\DBF}{\mbox{\sc dbf}}
\newcommand{\busy}{\operatorname{busy}}
\newcommand{\idlemark}{\operatorname{idle}}
\newcommand{\somme}{\operatorname{sum}}
\newcommand{\opedf}{\mbox{\rm \footnotesize \ edf}}

\newcommand{\Energy}{E}
\newcommand{\Power}{\operatorname{Pwr}}
\newcommand{\total}{\operatorname{tot}}
\newcommand{\dynamic}{\operatorname{dyn}}
\newcommand{\shortcircuit}{\operatorname{short}}
\newcommand{\leak}{\operatorname{leak}}

\newcommand{\cumulspeed}[1]{s(#1)}
\newcommand{\totalspeed}{\cumulspeed{1}}
\newcommand{\schedulable}{\operatorname{sched}}
\newcommand{\old}{\operatorname{old}}
\newcommand{\new}{\operatorname{new}}
\newcommand{\trans}{\operatorname{trans}}
\newcommand{\mode}{M}
\newcommand{\wait}{\operatorname{wait}}
\newcommand{\run}{\operatorname{run}}
\newcommand{\act}{\operatorname{active}}
\newcommand{\wcremjobs}[1]{{\cal J}^{\operatorname{wc}}_{#1}}
\newcommand{\idle}[1]{{\operatorname{idle}}_{#1}}
\newcommand{\maxidle}[1]{{\overline{\operatorname{idle}}}_{#1}}
\newcommand{\minidle}[1]{{\underline{\operatorname{idle}}}_{#1}}


\newcommand{\comp}[1]{\operatorname{comp}_{#1}}
\newcommand{\maxcomp}[1]{\overline{\operatorname{comp}}_{#1}}
\newcommand{\maxcompTwo}[1]{\overline{\operatorname{comp}}_{#1}^{(2)}}
\newcommand{\maxcompThree}[1]{\overline{\operatorname{comp}}_{#1}^{(3)}}
\newcommand{\work}[1]{w_{#1}}
\newcommand{\procwork}[2]{\operatorname{Work}_{#1}^{#2}}
\newcommand{\enabled}{\operatorname{enabled}}
\newcommand{\disabled}{\operatorname{disabled}}
\newcommand{\MCR}{\operatorname{MCR}}
\newcommand{\maxmakespan}{\overline{\operatorname{ms}}}
\newcommand{\makespan}{\operatorname{ms}}

\newcommand{\minmakespanIdent}{\underline{\operatorname{ms}}^{\operatorname{ident}}}
\newcommand{\maxmakespanIdent}{\overline{\operatorname{ms}}^{\operatorname{ident}}}
\newcommand{\maxmakespanUnifZero}{\overline{\operatorname{ms}}^{\operatorname{unif}}_0}
\newcommand{\maxmakespanUnifOne}{\overline{\operatorname{ms}}^{\operatorname{unif}}_1}
\newcommand{\maxmakespanUnifTwo}{\overline{\operatorname{ms}}^{\operatorname{unif}}_2}
\newcommand{\maxmakespanUnifThree}{\overline{\operatorname{ms}}^{\operatorname{unif}}_3}
\newcommand{\maxmakespanUnifMin}{\overline{\operatorname{ms}}^{\operatorname{unif}}_{\operatorname{min}}}
\newcommand{\mkerrorIdent}{E^{\operatorname{ident}}}

\newcommand{\mkerrorUnifOne}{E^{\operatorname{unif}}_1}
\newcommand{\mkerrorUnifTwo}{E^{\operatorname{unif}}_2}
\newcommand{\mkerrorUnifThree}{E^{\operatorname{unif}}_3}
\newcommand{\mkerrorUnifMin}{E^{\operatorname{unif}}_{\operatorname{min}}}

\newcommand{\equilibrium}[1]{\operatorname{equ}^{#1}}
\newcommand{\available}[1]{\operatorname{avbl}(#1)}
\newcommand{\area}[1]{\operatorname{area}(#1)}
\newcommand{\width}[1]{\operatorname{width}(#1)}
\newcommand{\height}[1]{\operatorname{height}(#1)}
\newcommand{\any}{\operatorname{any}}
\newcommand{\low}{\operatorname{low}}
\newcommand{\other}{\operatorname{other}}
\newcommand{\MIT}{\operatorname{mit}}
\newcommand{\workload}{\operatorname{w}}
\newcommand{\partmakespan}[1]{t^{\operatorname{part}}_{#1}}
\newcommand{\uppartmakespan}[1]{\hat{t}^{\operatorname{part}}_{#1}}
\newcommand{\step}{\overline{\operatorname{step}}}
\newcommand{\minstep}{\operatorname{step}}
\newcommand{\exms}{\operatorname{exms}}
\newcommand{\MSO}{\operatorname{MSO}}
\newcommand{\SMMSO}{\operatorname{SM-MSO}}
\newcommand{\AMMSO}{\operatorname{AM-MSO}}

\newcommand{\iedfmax}{\mbox{\textsf{I-EDF}}^{\max}}
\newcommand{\iedf}{\mbox{\textsf{I-EDF}}}
\newcommand{\moraedf}{\mbox{\textsf{MORA-EDF}}}
\newcommand{\moteedf}{\mbox{\textsf{MOTE-EDF}}}
\newcommand{\moraoteedf}{\mbox{\textsf{MORAOTE-EDF}}}
\newcommand{\iedfk}{\mbox{\textsf{I-EDF}}^{(k)}}
\newcommand{\moraedfk}{\mbox{\textsf{MORA-EDF}}^{(k)}}
\newcommand{\moteedfk}{\mbox{\textsf{MOTE-EDF}}^{(k)}}
\newcommand{\moraoteedfk}{\mbox{\textsf{MORAOTE-EDF}}^{(k)}}
\newcommand{\CLRV}{\mbox{\textsf{CLV}}}
\newcommand{\WCCLRV}{\mbox{\textsf{WC-CLRV}}}



\newcommand{\qed}{\rule{7pt}{7pt}}
\newcommand{\enoncefont}{\sl}


\newcommand{\condBCL}{\mbox{\sc [BCL]}}
\newcommand{\condBAK}{\mbox{\sc [BAK]}}
\newcommand{\condBCLtwo}{\mbox{\sc [BCL2]}}
\newcommand{\condBB}{\mbox{\sc [BB]}}
\newcommand{\agr}{\mbox{\textsf{AGR}}}
\newcommand{\mora}{\mbox{\textsf{MORA}}}
\newcommand{\mote}{\mbox{\textsf{MOTE}}}
\newcommand{\moraote}{\mbox{\textsf{MORAOTE}}}
\newcommand{\maxmethod}{\mbox{\textsf{MAX}}}
\newcommand{\off}{\mbox{\textsf{OFF}}}
\newcommand{\depoff}{\mbox{\textsf{DEP-OFF}}}
\newcommand{\indepoff}{\mbox{\textsf{INDEP-OFF}}}
\newcommand{\dra}{\mbox{\textsf{DRA}}}
\newcommand{\smax}{\operatorname{Smax}}
\newcommand{\soff}{\operatorname{Soff}}
\newcommand{\cumul}{\operatorname{cum}}
\newcommand{\offline}{\operatorname{off}}
\newcommand{\identical}{\operatorname{ident}}
\newcommand{\individual}{\operatorname{indiv}}
\newcommand{\rem}{\operatorname{rem}}
\newcommand{\Next}{\operatorname{next}}
\newcommand{\disp}{\operatorname{disp}^{\operatorname{off}}}
\newcommand{\overhead}{\operatorname{ovhd}}
\newcommand{\nextdisp}{\operatorname{nextdisp}^{\operatorname{off}}}
\newcommand{\edff}[1]{\mbox{\textsf{EDF}}}
\newcommand{\actual}{\operatorname{actual}}
\newcommand{\opt}{\operatorname{opt}}
\newcommand{\limit}{\operatorname{limit}}
\newcommand{\potact}{\operatorname{PotAct}}
\newcommand{\potrel}{\operatorname{PotRel}}
\newcommand{\lastrel}{\operatorname{LastRel}}
\newcommand{\arem}{\rem^{\offline}}


\newcommand{\TS}{\operatorname{TS}}
\newcommand{\mand}{\operatorname{mand}}
\newcommand{\mandzero}{{}^0 \! \mand}
\newcommand{\mandone}{{}^1 \! \mand}
\newcommand{\lag}{\operatorname{lag}}
\newcommand{\lub}{\operatorname{lub}}
\newcommand{\RU}{\operatorname{RU}}
\newcommand{\TSlength}{\operatorname{L}}
\newcommand{\OTS}{\operatorname{O}_{\operatorname{TS}}}
\newcommand{\OPRE}{\operatorname{O}_{\operatorname{P}}}
\newcommand{\OEOT}{\operatorname{O}_{\operatorname{EOT}}}
\newcommand{\OMIG}{\operatorname{O}_{\operatorname{MIG}}}

\newcommand{\BF}{\operatorname{BF}}
\newcommand{\PF}{\operatorname{PF}}
\newcommand{\PD}{\operatorname{PD}}
\newcommand{\LRETL}{\operatorname{LRE-TL}}
\newcommand{\NTS}{\operatorname{NTS}}
\newcommand{\UF}{\operatorname{UF}}
\newcommand{\som}{\operatorname{sum}}


\begin{document}
\title{Global Scheduling of Multi-Mode Real-Time Applications upon Multiprocessor Platforms}


\author{Vincent~N\'elis \and  Patrick~Meumeu~Yomsi \and
          Bj{\"{o}}rn Andersson
         \and
         Jo\"el~Goossens
        }





\markboth{IEEE Transactions on Industrial Informatics}
{Shell \MakeLowercase{\textit{et al.}}: Bare Demo of IEEEtran.cls for Journals}












\date{}

\maketitle


\begin{abstract}
\boldmath
Multi-mode real-time systems are those which support applications with different modes of operation, where each mode is characterized by a specific set of tasks. At run-time, such systems can, at any time, be requested to switch from its current operating mode to another mode (called ``new mode'') by replacing the current set of tasks with that of the new-mode. Thereby, ensuring that all the timing requirements are met not only requires that a schedulability test is performed on the tasks of each mode but also that \mbox{(i) a}~protocol for transitioning from one mode to another is specified and \mbox{(ii) a}~schedulability test for each transition is performed. We propose two distinct protocols that manage the mode transitions upon uniform and identical multiprocessor platforms at run-time, each specific to distinct task requirements. For each protocol, we formally establish schedulability analyses that indicate beforehand whether all the timing requirements will be met during any mode transition of the system. This is performed assuming both Fixed-Task-Priority and Fixed-Job-Priority schedulers. 
\end{abstract}




\section{Introduction}
\label{sec:Introduction} 

Hard real-time systems require both functionally correct executions and \emph{results that are produced on time}. Control of the traffic (ground or air), control of engines, control of chemical and nuclear power plants are just some examples of such systems. Currently, numerous techniques exist that enable engineers to design real-time systems while guaranteeing that all the temporal requirements are met. These techniques generally model each functionality of the application by a \emph{recurrent} task, characterized by a computing requirement, a temporal deadline and an activation rate. Commonly, real-time applications are simply modeled by a single and finite set of such tasks. However, practical applications often exhibit multiple behaviors issued from several operating modes (e.g.,~an initialization mode, an emergency mode, a fault recovery mode, etc.), where each mode is characterized by its own set of functionalities, i.e., its set of tasks. During the execution of such \emph{multi-mode} real-time applications, switching from the current mode (called the \emph{old-mode}) to any other mode (called the \emph{new-mode}) requires to substitute the currently executing task set with the set of tasks of the new-mode. This substitution introduces a {\em transient phase}, where tasks of both the old- and new-mode may be scheduled \emph{simultaneously}, thereby leading to a possible overload that can compromise the system schedulability---indeed it can be the case that both the old- and new-mode have been asserted schedulable by the schedulability analysis but the transition between them fails at run-time.

The scheduling problem during a transition between two modes has multiple aspects, depending on the behavior and requirements of the old- and new-mode tasks when a mode change is initiated. Upon a mode change request: 
\begin{itemize}
\item an \emph{old-mode} task may be allowed to be immediately aborted or, on the contrary, can be required to complete the execution of its current active job (so that it preserves data consistency for instance). Using scheduling algorithms such as the one considered in this study, we will prove in Section~\ref{sec:Multimode:prelim_validity_tests} that aborting tasks upon a mode change request does not jeopardize the schedulability of the mode transitions. Hence, we assume in this paper the most problematic scenario in which \emph{every old-mode task must complete its current active job} (if any) when a mode change is requested.
\item a \emph{new-mode} task either requires to be activated as soon as possible when a mode change is requested or requires to be activated only when all the active jobs issued from the old-mode have totally completed their execution. 
\end{itemize}

Finally, there may be some tasks (called mode-independent tasks in the literature) that belong to more than one mode and such that their activation pattern must not be jeopardized during the transition between those modes\footnote{In practice, mode-independent tasks typically allow to model daemon functionalities.}. However this paper will  consider only systems that do \emph{not} include such tasks. 

Transition scheduling protocols for tasks without mode-independent tasks are often classified with respect to the way they schedule the old- and new-mode tasks during the transitions. In the literature (see for instance~\cite{JoAlfons:04} which considers uniprocessor systems), the following definitions are used. 

\begin{Definition}[Synchronous/asynchronous protocol~\cite{JoAlfons:04}] 
\label{def:Multimode:synchronous_asynchronous}
A transition protocol is said to be synchronous if it schedules new-mode tasks only when all the old-mode tasks have completed. Otherwise, it is said to be asynchronous. 
\end{Definition}

\begin{Definition}[Protocol with/without periodicity~\cite{JoAlfons:04}]
\label{def:Multimode:with_without_periodicity}
A transition protocol is said to be ``with periodicity'' if and only if it is able to deal with mode-independent tasks. Otherwise, it is said to be ``without periodicity''.
\end{Definition}

\subsection{Related work}

Numerous transition protocols have been proposed for \emph{uni}processor platforms (a survey about this concern is presented in~\cite{JoAlfons:04}). In such environments, existing researches \cite{JoAlfons:04, Henia:07, Pedro:98} have shown that even if two modes of the application have been proven feasible, the transition between the two modes can cause violation of timing constraints, hence needing explicit analyses. Such analyses have been proposed in~\cite{Sha:89}, considering the popular Rate Monotonic Algorithm. Unfortunately three years later, this analysis was shown optimistic~\cite{Tindell:92} in the sense that some unfeasible task sets could be asserted schedulable. In the same paper~\cite{Tindell:92}, the authors improved the previous analysis and proposed a new one which considers the popular Deadline Monotonic Algorithm. An analysis of sporadic tasks scheduled on EDF is known as well~\cite{Andersson:08}. In \cite{Stoimenov:09}, the authors proposed an analysis which considers Fixed-Task-Priority scheduling (FTP), Earliest-Deadline-First~\cite{Liu:73} scheduling and arbitrary task activation pattern. Furthermore, for applications that were initially proven not schedulable during the transition phases, they derived the required offsets for delaying the initialization of transition between two modes in order to make the application schedulable. \\
\noindent Among the uniprocessor synchronous protocols, the authors of~\cite{Bailey:93, Tindell:96, JoAlfons:04} proposed the following protocols.
\begin{itemize}
\renewcommand{\labelitemi}{}
\item The \emph{Minimum Single Offset Protocol} (MSO)~\cite{JoAlfons:04} where the last activation of each old-mode task completes and then, the new-mode tasks are released. 

\item The \emph{Idle Time Protocol} (IT)~\cite{Tindell:96} where the periodic activations of the old-mode tasks are suspended at the first idle time-instant occurring during the transition and then, the new-mode tasks are released.

\item The~\emph{Maximum-Period Offset Protocol} (MPO)~\cite{Bailey:93} where the delays of first activation of each new-mode task is equal to the period of the less frequent task in both modes, \end{itemize}

\noindent Among the uniprocessor \emph{asynchronous} protocols, the authors of~\cite{Tindell:92,Pedro:99,Andersson:08} proposed the following protocols.
\begin{itemize}
\renewcommand{\labelitemi}{}
\item A protocol \emph{without periodicity}~\cite{Pedro:99} where tasks are assigned priorities according to the Deadline Monotonic Scheduling algorithm and are scheduled with time offsets during the mode change only. 

\item A protocol \emph{with periodicity} has been introduced by Sha et al. in~\cite{Sha:88}, assuming Fixed-Task-Priority scheduling. Then, the authors of~\cite{Andersson:08} extended this protocol to the Earliest Deadline First~\cite{Liu:73} scheduling algorithm.

\item The authors of~\cite{Tindell:92} introduced a particular protocol which allows tasks to modify their parameters (period, execution time, etc.) during the mode changes.  As in~\cite{Pedro:99}, this study assumes that the tasks are scheduled according to the Deadline Monotonic scheduling algorithm.
\end{itemize}

\subsection{Contribution and paper organization}

In this paper we propose two protocols \emph{without periodicity} ( which is \emph{synchronous} and  which is \emph{asynchronous}) for managing mode transitions during the execution of multi-mode real-time applications on \emph{multi}processor platforms. Both protocols can be considered as a generalization to multiprocessors of the MSO protocol proposed in~\cite{JoAlfons:04}. We assume that every operating mode of the application is scheduled by a \emph{global}, \emph{work-conserving}, \emph{preemptive} and \emph{Fixed-Job-Priority} (FJP) scheduling algorithm (formal definitions are given in Section~\ref{sec:Multimode:scheduler_specifications}). Some of the results presented here have already been published (see~\cite{MeumeuNelisGoossens:10, NelisAnderssonGoossens:09, NelisGoossensAndersson:09, NelisGoossens:08}). It is worth noticing that the problem of scheduling multi-mode applications upon multiprocessor platforms is much more complex than upon uniprocessor platforms, especially due to the presence of scheduling anomalies (see Chapter 5 of~\cite{Andersson:03} for a definition) and it is now well known that real-time multiprocessor scheduling problems are typically not solved by applying straightforward extensions of techniques used for solving similar uniprocessor problems. 

The paper is organized as follows. Section~\ref{sec:Multimode:Models_of_computation} defines the computational model used throughout the paper. Sections~\ref{sec:Multimode:SMMSO} and~\ref{sec:Multimode:AMMSO} describe the synchronous and asynchronous protocols  and , respectively. Section~\ref{sec:Multimode:prelim_validity_tests} introduces some definitions and basic results necessary for the establishment of our schedulability analyses. These four first Sections~\ref{sec:Multimode:Models_of_computation}--\ref{sec:Multimode:prelim_validity_tests} are a common base of the paper, in the sense that these~\pageref{sec:Multimode:ident_FJP} pages describe both the models of computation and protocols independently of the platform and scheduler characteristics. Then, the four next Sections~\ref{sec:Multimode:ident_FJP}--\ref{sec:Multimode:unif_FTP} are each specific to a platform and scheduler model. More precisely, they provide a schedulability analysis for both  and , assuming in turn identical platforms and Fixed-Job-Priority schedulers (in Section~\ref{sec:Multimode:ident_FJP}), identical platforms and Fixed-Task-Priority schedulers (in Section~\ref{sec:Multimode:ident_FTP}), uniform platforms and Fixed-Job-Priority schedulers (in Section~\ref{sec:Multimode:unif_FJP}) and uniform platforms and Fixed-Task-Priority schedulers (in Section~\ref{sec:Multimode:unif_FTP})\footnote{Even though Fixed-Job-Priority schedulers encompass the family of Fixed-Task-Priority schedulers, the particular case of Fixed-Task-Priority schedulers is treated separately so that the schedulability analyses are more specific and therefore more accurate.}. Finally, Section~\ref{sec:Multimode:Conclusion} gives our conclusions and future work, together with some remaining open problems. 








\section{Models of computation and specifications}
\label{sec:Multimode:Models_of_computation}

\subsection{Application specifications}

We define a multi-mode real-time application  as a set of  operating modes denoted by  where each mode  has to execute its associated task set  composed of  tasks by following the scheduler . At run-time, the application is either running in one and only one mode, i.e., it is executing only the set of tasks associated to that mode, or it is switching from one mode to another one. Since we do \emph{not} consider mode-independent tasks in this study, it holds that . 

Each task  is modeled by a \emph{sporadic} and \emph{constrained-deadline} task characterized by three parameters ---a worst-case execution time , a minimum inter-arrival time  and a relative deadline ---with the interpretation that, during the execution in mode , task  generates successive \emph{jobs}  (with ) released at times  such that  (with ), each such job has an execution requirement of at most , and must be completed at (or before) its absolute deadline noted . In the particular case where , the task  is said to be {\em periodic} instead of sporadic. In the same vein, if  then the task  is said to be {\em implicit-deadline} instead of constrained-deadline. 

\begin{Definition}[Active job]
We say that a job  is \emph{active} at time  if it has been already released (i.e., ) and it is not completed yet. 
\end{Definition}

Since we assume , there cannot be two jobs of a same task  active at a same time in any feasible schedule. All the tasks are assumed to be independent, i.e., there is no communication, no precedence constraint and no shared resource (except the processors) between them. In~\cite{NelisGoossensAndersson:09}, we introduced the following concept of enabled/disabled tasks.

\begin{Definition}[Enabled/disabled tasks~\cite{NelisGoossensAndersson:09}]
\label{def:Multimode:enabled_disabled}
At run-time, any task  of the application can generate jobs if and only if  is enabled. Symmetrically, a disabled task cannot generate jobs. 
\end{Definition}

As such, disabling a task  prevents future job releases from . When all the tasks of any mode  are \emph{enabled} and all the tasks of all the other modes are {\em disabled}, the application is said to be running in mode  (since only the tasks of mode  can release jobs). We denote by  and  the subsets of {\em enabled} and {\em disabled} tasks of  at time , respectively.  

\subsection{Platform specifications}

Many recent embedded systems are built upon multiprocessor platforms in order to fulfill the high computational requirements of applications. As pointed out in~\cite{Baruah:03, Baruah:04}, another advantage of such a choice is the fact that multiprocessor systems are more energy efficient than equally powerful uniprocessor platforms. Indeed, raising the frequency of a single  results in a \emph{multiplicative} increase of the consumption while adding s results in an \emph{additive} increase. Two distinct multiprocessor architectures are commonly used in the industrial world and thus, are considered in this paper: identical and uniform platforms.

\textit{Identical platform.} In such multiprocessor platforms, all the s have the same computational capabilities, with the interpretation that in any interval of time two s execute the same amount of work (assuming that none of them is idling). In the remainder of this paper, any platform composed of  identical s will be modeled by  where  denotes the   of the platform.

\textit{Uniform platform.} In such multiprocessor platforms, the s are allowed to have different computational capabilities. That is, a \emph{parameter}  is associated to every   with the interpretation that in any time interval of length ,   executes  units of execution (if it is not idling). This parameter can be seen as the \emph{execution speed} of the . In the remainder of this paper, any platform composed of  uniform s is modeled by , where  is the execution speed of  . Without loss of generality, we assume that  , meaning that   is the fastest  while  is the slowest one. For all , we denote by  the cumulated speed of the  fastest s, i.e., 


Notice that identical platforms are a particular case of uniform platforms where  . In this particular case we assume without any loss of generality that : . 

\subsection{Mode transition specifications}
\label{sec:Multimode:mode_transition_specifications}

While the application is running in any mode , a mode change can be initiated by any task of  or by the system itself, whenever it detects a change in the environment or in its internal state for instance. This is performed by invoking a  (i.e., a Mode Change Request), where  is the destination mode. We denote by  the invoking time of the \emph{last} . From the time at which a mode change is requested to the time at which the transition phase ends,  and  are referred to as the old- and new-mode, respectively. 

At run-time, mode transitions are managed as follows. Suppose that the application is running in mode  and the system (or any task of ) comes to request a mode change to mode , with . At time , the system entrusts the scheduling decisions to a transition protocol which \emph{immediately} disables all the old-mode tasks, thus preventing them from releasing new jobs. At this time, the active jobs issued from these disabled tasks, henceforth called the \emph{rem-jobs} (for ``\emph{rem}aining \emph{jobs}''), may have two distinct behaviors: either \emph{they can be aborted} upon the  or \emph{they can complete their execution}. From the schedulability point of view, we will show that aborting some (or all) rem-jobs upon a mode change request does not jeopardize the system schedulability during the transition phase. Consequently, we assume the worst-case scenario for every mode transition, i.e., the scenario in which \emph{every old-mode task has to complete its last released job (if any) during every mode transition}\footnote{Aborting a job consists in suddenly stopping its execution and removing it from the system memory. But in the real world, suddenly killing a process may cause system failures and the rem-jobs often have to complete their execution.}. The fact that the rem-jobs have to complete their execution upon the  brings the following problem. Even if both task sets  and  (from the old- and new-mode, respectively) have been asserted to be schedulable upon the  s at system design-time, the presence of the rem-jobs may cause an \emph{overload} during the transition phase (at run-time) if all the new-mode tasks of  are enabled \emph{immediately} upon the mode change request. Indeed, the schedulability analysis performed beforehand on  did not take into account the additional work generated by the rem-jobs. To solve this problem, transition protocols usually delay the enablement of each new-mode task until it is safe to do so. However, these delays are also subject to hard constraints. More precisely, we denote by  \emph{the relative transition deadline of task  during every transition from mode  to mode }, with the following interpretation: the transition protocol must ensure that  is enabled not later than time . Finally, when all the rem-jobs are completed and all the new-mode tasks of  are enabled, the system entrusts the scheduling decisions to the scheduler  of the new-mode  and the transition phase ends. 

In short, the goal of any transition protocol is to fulfill the following requirements during every mode change:
\begin{enumerate}
\item Complete each rem-job  by its absolute deadline .
\item Enable each new-mode task  by its absolute transition deadline .
\item Complete each new-mode job\footnote{This requirement is automatically fulfilled for synchronous protocols since no new-mode jobs are scheduled during the mode transitions.}  by its absolute deadline .

\end{enumerate}

\begin{Definition}[Valid protocol~\cite{NelisGoossensAndersson:09}]
A transition protocol  is said to be \emph{valid} for a given application  and platform  if and only if  meets all the job and transition deadlines during every transition between every pair of operating modes of . 
\end{Definition}

This notion of ``valid protocol'' is directly related to that of a ``validity test'' defined as follows. 

\begin{Definition}[Validity test~\cite{NelisGoossensAndersson:09}]
For a given transition protocol , a validity test is a condition based on the tasks and platform characteristics that indicates \emph{a priori} whether  is valid for a given application  and platform . 
\end{Definition}

\subsection{Scheduler specifications}
\label{sec:Multimode:scheduler_specifications}

We consider the \emph{global} preemptive scheduling problem of sporadic constrained-deadline tasks upon multiprocessor platforms. ``Global'' schedulers, in contrast to partitioned ones, allow different tasks and \emph{different} jobs of the same task to be executed upon \emph{different} s. When preemptive, global schedulers allow any job to be interrupted at any time prior to completion on any  and resumed (possibly later) on any other . We consider that every mode  uses its own scheduler denoted by  which can be either {\em Fixed-Task-Priority (FTP)} or {\em Fixed-Job-Priority (FJP)} according to the following interpretations.
\begin{itemize}
\item FTP schedulers assign a priority to each task at system design-time (i.e., before the execution of the application) and then at run-time, every released job uses the priority of its task  and the priority of a job is kept constant until it completes.  
\item FJP schedulers assign a priority to each job at run-time (i.e., as soon as it arrives in the system) and every job keeps its priority constant until it completes. As such, different jobs issued from the same task may have different priorities\footnote{According to these interpretations, FTP schedulers are a particular case of FJP schedulers in which all the jobs issued from a same task receive the same priority determined beforehand.}. 
\end{itemize}

\noindent Without loss of generality we assume that, at any time, two active jobs cannot have the same priority. Furthermore, we consider \emph{work-conserving} schedulers according to the following definition.

\begin{Definition}[Work-conserving global scheduler]
\label{def:work-conserving}
A  cannot be idle if there is a job awaiting execution. Usually, priority-based schedulers assign at each instant in time the  highest priority active jobs (if any) to the  s.
\end{Definition}

The above definition of work-conserving schedulers encompasses a large family of schedulers, but suffers from an important lack of \emph{determinism}. Indeed for a given set of jobs, multiple (and different) schedules can sometimes be derived from the same work-conserving scheduler (and thus from the same job priority assignment). The following example illustrates this drawback.

\begin{Example}\label{scheduler_example}
Let us consider the set  of  jobs with respective processing time 4, 8, 4, 4 and 6.  Suppose that  is scheduled on a -processors identical platform  by an FTP, global, preemptive and \emph{work-conserving} scheduler such that . According to Definition~\ref{def:work-conserving}, Figures~\ref{fig:Multimode:ident_work_conserving_1} and~\ref{fig:Multimode:ident_work_conserving_2} depict two possible different schedules corresponding to this priority assignment. 
\begin{figure}[h]
\begin{center}
\includegraphics*[width=0.5\linewidth, viewport=0 0 600 200]{work_conserving_identical_1.pdf}
\caption{A possible schedule of  and .}
\label{fig:Multimode:ident_work_conserving_1}
\end{center}
\end{figure}

\begin{figure}[h]
\begin{center}
\includegraphics*[width=0.5\linewidth, viewport=0 0 600 200]{work_conserving_identical_2.pdf}
\caption{Another possible schedule of  and .}
\label{fig:Multimode:ident_work_conserving_2}
\end{center}
\end{figure}
\end{Example}

In order to get around this lack of determinism, we introduce two refinements of Definition~\ref{def:work-conserving} that we name \emph{weakly} and \emph{strongly} work-conserving schedulers, respectively. Weakly work-conserving schedulers concern only identical platforms whereas strongly work-conserving schedulers concern only in uniform (and non-identical) platforms. The rationale for introducing these two refinements is to have \emph{one and only one possible schedule} for any given set of synchronous\footnote{The term ``synchronous'' jobs is commonly used in the literature to refer to jobs that are all ready for execution at the same time.} jobs, multiprocessor platform and job priority assignment.  

\begin{Definition}[Weakly work-conserving scheduler]
\label{def:Multimode:weakly_work_conserving}
A scheduler  is weakly work-conserving if and only if:
\begin{itemize}
\item no  idles while there are active jobs awaiting execution, and
\item if there are more than one job awaiting execution and more than one CPU available for the execution of those jobs then {\cal S} assigns the highest priority waiting job to the available  with the highest index. 
\end{itemize}
\end{Definition}

\begin{Property}[Unique schedule]
For any given finite set  of jobs, any \emph{weakly} work-conserving scheduler  and any \emph{identical} multiprocessor platform , there exists \emph{one and only one} possible schedule of  upon  following . 
\end{Property}

In order to illustrate this property, let us consider the set of  jobs used in Example~\ref{scheduler_example}, a 2-processors identical platform  and any \emph{weakly} work-conserving scheduler assigning priorities such that . The unique possible schedule of  upon  is the one depicted in Figure~\ref{fig:Multimode:ident_work_conserving_1}. Indeed at time , s  and  are idle and the second condition of Definition~\ref{def:Multimode:weakly_work_conserving} imposes  to execute on . From the same rule,  must execute on  at time . Notice that the refinement of ``weakly'' work-conserving scheduler clarifies only the job-to- assignment rule when the highest-priority waiting job has to be dispatched to a . 

\begin{Definition}[Strongly work-conserving scheduler]
\label{def:Multimode:strongly_work_conserving}
A scheduler  is strongly work-conserving if and only if:
\begin{itemize}
\item no  idles while there are active jobs awaiting execution, and 
\item at \emph{every time} during the system execution, the job-to- assignment uses the rule: highest priority active job upon highest indexed . 
\end{itemize}
\end{Definition}

In contrast to the refinement of ``weakly'' work-conserving schedulers, the ``strongly''-refinement clarifies the job-to- assignment rule \emph{at each time-instant} during the system execution. It is \emph{essential} to keep in mind that in our study weakly work-conserving schedulers will be used \emph{only} on \emph{identical} platforms whereas strongly work-conserving schedulers will be used \emph{only} on \emph{uniform} and \emph{non-identical} platforms. For strongly work-conserving schedulers, the concept of migrating jobs to faster s as soon as possible (as specified by the second condition of Definition~\ref{def:Multimode:strongly_work_conserving}) has been widely used over the years on uniform platforms (see~\cite{BaruahGoossens:08:2,BaruahGoossens:03,GoossensFunkBaruah:02,BaruahGoossens:08,CucuGoossens:10,FunkGoossensBaruah:01}). This refinement is extremely important, especially because it yields the following property. 

\begin{Property}[Staircase property]
Let  denote any finite set of synchronous jobs,  any \emph{uniform} multiprocessor platform and  any \emph{strongly} work-conserving scheduler. In the schedule of  upon  by ,  idles before or at the same time-instant as  for all . 
\end{Property}

Informally speaking, the schedule of  upon  by  forms a \emph{staircase} (see Figure~\ref{fig:Multimode:unif_staircase}).

\begin{figure}
\begin{center}
\includegraphics*[width=0.5\linewidth, viewport=0 0 600 400]{staircase_steps.pdf}
\caption{For any fixed set of jobs and uniform platform, the schedule generated by any strongly work-conserving scheduler forms a staircase.}
\label{fig:Multimode:unif_staircase}
\end{center}
\end{figure}

This property stems from the fact that the s are indexed in such a manner that  . Thus, it holds from the second condition of Definition~\ref{def:Multimode:strongly_work_conserving} that at any instant , if  idles the -slowest  then  also idles the  slowest s for all . Also, it results from the same condition that the   that starts idling is always . 

The following definition introduces the fundamental notion of \emph{predictability}, and Lemmas \ref{lem:Multimode:weakly_schedulers_predictable} and \ref{lem:Multimode:strongly_schedulers_predictable} are essential for the rest of the paper. 

\begin{Definition}[Predictability~\cite{HaLiu:94}]
\label{def:Multimode:predictability}
Let  denote a scheduler, and let  be a potentially infinite set of jobs, where each job  is characterized by an arrival time , a computing requirement  and an absolute deadline . Let  and  denote the time at which job  starts and completes its execution (respectively) when  is scheduled by . Now, consider any set  of jobs obtained from  as follows. Job  has an arrival time , an execution requirement , and a deadline . Let  and  denote the time at which job  starts and completes its execution (respectively) when  is scheduled by . Algorithm  is said to be predictable if and only if for any set of jobs  and for any such  obtained from , it is the case that  and  . 
\end{Definition}

Informally speaking, Definition~\ref{def:Multimode:predictability} claims that an upper-bound on the starting time and on the completion time of each job can be determined by analyzing the situation under the assumption that each job executes for its WCET. The result from~\cite{Ha:95, HaLiu:94, HaLiu:93} that we will be using can be stated as follows. 

\begin{Lemma}[See~\cite{Ha:95, HaLiu:94, HaLiu:93}]
\label{lem:Multimode:weakly_schedulers_predictable}
On identical multiprocessor platforms, any FJP, global, preemptive and weakly work-conserving scheduler is predictable. 
\end{Lemma}

In the same vein, the result from~\cite{CucuGoossens:10} that we will be using can be stated as follows. 

\begin{Lemma}[See~\cite{CucuGoossens:10}]
\label{lem:Multimode:strongly_schedulers_predictable}
On uniform multiprocessor platforms, any FJP, global, preemptive and strongly work-conserving scheduler is predictable.  
\end{Lemma}

We use the notation  to refer to a specific job priority assignment. A job priority assignment can be seen as a key component of any scheduler, but the definition of a scheduler is more general since, in addition to a job priority assignment, a scheduler must also provide specifications like ``global or partitioned'', ``preemptive or non-preemptive'', etc. For any job priority assignment , we denote by  the fact that job  has a higher priority than  according to , and we assume that every assigned priority is distinct from the others. That is,  such that  we have either  xor . Similarly, and without any distinction with the interpretation given above, we will sometimes use the notations  and  where  is the scheduler of mode , and we will sometimes use the notations  and  when the job priority assignment has no label (for instance, when we will depict some examples of schedules, we will just say ``'' without giving a name to the job priority assignment). Finally, the problems and solutions presented in this paper are addressed under the following assumptions:

\begin{itemize}
\renewcommand{\labelitemi}{}
\label{null:assumption1}
\item \textbf{Assumption~1.} The set  of tasks of every mode  can be scheduled by  on  s without missing any deadline. 

\item \textbf{Assumption~2.} Job migrations and preemptions are permitted and are carried out at no loss or penalty.

\item \textbf{Assumption~3.} Job parallelism is forbidden, i.e., jobs execute on at most one  at any instant in time. 

\item \textbf{Assumption~4.} For every mode  it holds that , where  is the number of tasks in mode . 
\end{itemize}

Regarding Assumption~1, it allows us to focus only on the schedulability of the application during the {\em transient phases} corresponding to mode transitions, rather than on the schedulability of the application during the execution in a given mode. 

Regarding Assumption~4, it is worth noticing that since job parallelism is forbidden and tasks are assumed to be constrained-deadline, there are at most  jobs active at a same time during the execution of any mode . As a result, it holds for each mode  that in every schedulable application where , there are always  s that constantly idle. We will see later that these  idling s are the slowest ones and the problem in that case thereby reduces to the same problem upon the subset of the  fastest s among these  s. 




\section{The synchronous protocol SM-MSO}
\label{sec:Multimode:SMMSO}

\subsection{Description of the protocol}

The protocol  (which stands for ``Synchronous Multiprocessor Minimum Single Offset'' protocol) is an extension to multiprocessor platforms of the protocol  defined in~\cite{JoAlfons:04} for uniprocessor platforms. This protocol supports both uniform and identical platforms. The main idea of  is the following: upon a MCR(), , all the tasks of the old-mode (say ) are disabled and the rem-jobs continue to be scheduled by the old-mode scheduler  upon the  s. Once \emph{all} the rem-jobs are completed, \emph{all} the new-mode tasks (i.e., the tasks of ) are simultaneously enabled. Algorithm~\ref{algo:SMMSO} gives the pseudo-code of this protocol and Example~\ref{example_protocol_smmso} illustrates how  handles the mode transitions. 

\begin{figure}
\begin{center}
\begin{minipage}{10cm}
\begin{algorithmic}[1]
\REQUIRE : the old mode
\REQUIRE : the new-mode
\REQUIRE the rem-jobs
\WHILE{\TRUE}
	\STATE Schedule the rem-jobs according to 
	\IF{(any rem-job  completes at time )} 
		\IF{()}
			\STATE enable all the new-mode tasks of 
			\STATE enter the new-mode 
		\ENDIF
	\ENDIF
\ENDWHILE
\end{algorithmic}
\end{minipage}
\end{center}
\caption{ protocol}
\label{algo:SMMSO}
\end{figure}

\begin{Example}\label{example_protocol_smmso}
Let us consider a platform  composed of only 2 \emph{identical} s and an application composed of 2 modes  and  depicted in blue and red, respectively. We assume that these two modes contain only synchronous implicit-deadline periodic tasks. The old-mode  contains 4 tasks with characteristics given in Table~\ref{tab:scheduler_example_smmso1} and uses an FTP scheduler  such that .

\begin{table}[h!]
\centering
\begin{tabular}{| c | c | c |}
\hline
Tasks &  &   \\
\hline
 & 40 & 120 \\
\hline
 & 20 & 120 \\
\hline
 & 40 & 120 \\
\hline
 & 60 & 120 \\
\hline
\end{tabular}
\caption{Characteristics of the tasks in .}
\label{tab:scheduler_example_smmso1}
\end{table}

\noindent The new-mode  contains 3 tasks  and uses an FTP scheduler  such that . The characteristics of these tasks are:  and . The deadline and period of these new-mode tasks do not have any importance in this example and we intentionally omitted to specify them. Figure~\ref{fig:Multimode:SMMSO_example} illustrates the  transition protocol between these two modes. 

\begin{figure}
\begin{center}
\includegraphics*[width=0.5\linewidth, viewport=0 0 750 430]{SMMSO.pdf}
\caption{Illustration of a mode transition handled by .}
\label{fig:Multimode:SMMSO_example}
\end{center}
\end{figure}

At time 120, every task of  releases its second job and the scheduler  starts the execution of  and  on   and , respectively. Then, suppose that the system requests a mode change at time 130. Here starts the transition phase from mode  to mode . As specified by the protocol , all the old-mode tasks are immediately disabled and the remaining active jobs  and  (named the rem-jobs from this point forward) continue to be scheduled according to the old-mode scheduler . These rem-jobs execute until time 220, time at which they are all completed. At this instant 220, the condition at line 4 of Algorithm~\ref{algo:SMMSO} is verified. Thus,  enables all the new-mode tasks and starts scheduling the incoming new-mode jobs according to the new-mode scheduler . Notice that at any time \emph{during every transition phase}, our protocol  allows the system (or any task) to request any other mode change. At the very end of the current transition phase (at time 220 in this example),  enables all the tasks of the mode  assuming that  is the last mode change that has been requested.
\end{Example}

\subsection{Design of a validity test}
\label{sec:Multimode:SMMSO_main_idea}

In order to establish a {\em validity test} for the protocol , two key results are required:

\begin{enumerate}
\item It must be proved for every mode transition that disabling the old-mode tasks upon a MCR does not jeopardize the schedulability of the rem-jobs when they continue to be scheduled by the old-mode scheduler. That is, it must be guaranteed that the absolute deadline  of every rem-job  is met during every mode transition from every mode .

\item It must be proved for every mode transition that the length of the transition phase \emph{can never be larger} than the minimum transition deadline of all new-mode tasks. Indeed, it follows from this statement and the definition of  that all the transition deadlines would be met during every mode transition. 
\end{enumerate} 

We provided a proof for the first key result in~\cite{NelisGoossensAndersson:09} (the proof is replicated in Section~\ref{sec:Multimode:prelim_validity_tests}, page~\pageref{lem:Multimode:remjobs_meet_deadline}), and this result holds for any uniform platform (including identical platforms). About the second key result, it is worth noticing that there is \emph{no job release} (and therefore no preemption) during every transition phase since we consider only FJP schedulers and all the old-mode tasks are disabled upon any mode change request. As a consequence, the length of any transition phase corresponds to \emph{the time needed to complete all the rem-jobs} (this clearly appears in Figure~\ref{fig:Multimode:SMMSO_example}). In the literature (and hereafter as well), the time needed to complete a given set of synchronous jobs upon a given platform is called the \emph{makespan} defined as follows.

\begin{Definition}[Makespan]
\label{def:Multimode:makespan}
Let  denote any set of  jobs of processing times . Let  denotes any uniform multiprocessor platform composed of  s. Let  denote any job priority assignment and  denotes the schedule of  upon  by any work-conserving scheduler (including weakly and strongly work-conserving schedulers) using the priority assignment . The makespan denoted by  is the earliest instant in  such that the  jobs of  are completed. 
\end{Definition}

According to Definition~\ref{def:Multimode:makespan}, the length of any transition phase corresponds to the makespan generated by the set of jobs that are active in the system when the mode change is requested, i.e., the set of rem-jobs. Since the value of the makespan obviously depends on the number and processing times of the jobs (as well as on the  speeds), then the length of any transition phase from any mode  to any other mode  depends on both the number of rem-jobs and their remaining processing time at time . From this observation, determining an \emph{upper-bound} on the makespan requires to consider the worst-case scenario, i.e., the scenario in which the number and the remaining processing time of the rem-jobs at time  is such that the generated makespan is maximum. This worst-case scenario is thus entirely defined by a specific set of rem-jobs that we name the \emph{critical rem-job set} defined as follows.

\begin{Definition}[Critical rem-job set ]
\label{def:Multimode:worst_case_configuration}
Assuming any transition from a specific mode  to any other mode , the critical rem-job set  is the set of jobs issued from the tasks of  that leads to the largest makespan. 
\end{Definition}

For any work-conserving FJP scheduler (including FTP schedulers) and uniform platform (including identical platform), we will show that the critical rem-job set  of every transition from mode  to mode  is the one where each task  has a rem-job at time  with a remaining processing time equals to  (i.e., the WCET of ). This result is very intuitive: the makespan is as large as the number and processing times of the rem-jobs are large. 

In this paper we address the problem of establishing mathematical expressions that provide the \emph{maximum makespan} for any given set of \emph{synchronous}\footnote{During every mode transition, the considered jobs are assumed to be synchronous because every rem-job is active and ready to execute upon the mode change request.} jobs and especially for the critical rem-job set during each mode transition. This intention stems from the fact that the knowledge of the maximum makespan allows us to assert (or refute) that every new-mode task will meet its transition deadline during any mode transition using , thus ensuring the validity of  for a given application  and platform  as follows. 

\begin{validity test}[For protocol ]
\label{test:Multimode:SMMSO_first}
For any multi-mode real-time application  and any uniform multiprocessor platform , protocol  is valid provided that, for every mode ,

\noindent where  is the job priority assignment derived from the old-mode scheduler  and  is an upper-bound on the makespan, considering the set  of jobs, the platform  and the job priority assignment . 
\end{validity test}

The above expression can be interpreted as follows: all the transition deadlines will be met during the execution of the system if, for every mode , the maximum makespan (i.e., the maximum transition latency) generated by the rem-jobs issued from the tasks of  cannot be larger than the minimum transition deadline of every task of every mode . 

This validity test is a \emph{sufficient} condition that indicates, a priori, if all the deadlines will be met during all possible mode changes using the protocol . Unfortunately, to the best of our knowledge, the problem of determining the maximum makespan has never been studied in the literature. Rather, authors usually address the problem of determining a job priority assignment that minimizes the makespan~\cite{Goyal:05, Garey:90}. The goal in that framework being to ultimately reduce the completion times of the jobs as much as possible. This problem of finding priorities that minimize the makespan can be cast as a strongly NP-hard bin-packing problem~\cite{Goyal:05, Garey:90} for which numerous heuristics have been proposed in the literature. On the contrary, we provide in Sections~\ref{sec:Multimode:ident_FJP}--\ref{sec:Multimode:unif_FTP} different \emph{upper-bounds} on the makespan, assuming in turn {\em identical platforms and FJP schedulers}, {\em identical platforms and FTP schedulers}, {\em uniform platforms and FJP schedulers} and finally, {\em uniform platforms and FTP schedulers}. 

\subsection{FTP schedulers vs. FJP schedulers}

As mentioned in Section \ref{sec:Multimode:scheduler_specifications}, FTP schedulers are a particular case of FJP schedulers. However the remainder of this study distinguishes between these two scheduler families because FTP schedulers allow to determining a more precise upper-bound  than FJP schedulers. The reason of this stems from the fact that the priority of each task (and thus the priority of every job) is known \emph{at system design-time} for FTP schedulers whereas it is \emph{un}known beforehand for FJP schedulers. 

At first blush, assuming that the job priority assignment  is unknown for FJP schedulers can seem inconsistent since during every mode transition, we consider the critical rem job set in the computation of  (and this critical rem-job set is determined \emph{at system design-time}). Therefore, it could be thought that  can simply be derived from . But this intuition is \emph{erroneous} because for a given FJP scheduler, several job priority assignments can be derived from the same critical rem-job set as shown in the following example. Actually, given set of jobs, we are not aware of any job priority assignment leading to the maximum makespan.

\begin{Example}
\label{lem:Multimode:FJP_priority_assignment_not_unique}

Let us consider a platform  composed of only 2 \emph{identical} s and an application  composed of 2 modes  and . Suppose that a mode change is requested from  to  and the old-mode scheduler  is . The old-mode  contains 3 tasks with characteristics given in Table~\ref{tab:priority_example1}.

\begin{table}[h!]
\centering
\begin{tabular}{| c | c | c |}
\hline
Tasks &  &   \\
\hline
 & 5 & 15 \\
\hline
 & 5 & 16 \\
\hline
 & 7 & 18 \\
\hline
\end{tabular}
\caption{Characteristics of the tasks in .}
\label{tab:priority_example1}
\end{table}

As introduced earlier, the critical rem-job set for this mode transition is given by  with processing time  and , respectively. This will be formally proved in Corollary~\ref{cor:Multimode:worst_case_rem_jobs_set} (on page~\pageref{cor:Multimode:worst_case_rem_jobs_set}), assuming any FJP scheduler and any uniform platform. Actually, this critical rem-job set specifies \emph{only} the processing time of the jobs, \emph{not} the release time, neither the absolute deadline. Consequently, different job priority assignments can be derived from . We depict two of them in Figures~\ref{fig:Multimode:multiple_JPA_1} and~\ref{fig:Multimode:multiple_JPA_2}. In both figures the time is relative to the instant  (i.e., ). The release time and the absolute deadline of each job  are denoted by  and , respectively. These two job priority assignments are obtained as follows.

\noindent \textbf{Job priority assignment 1.} If we assume that the three jobs are released \emph{exactly} at the  invoking time , i.e., , then the absolute deadline of each job  is given by . In Figure~\ref{fig:Multimode:multiple_JPA_1}, the deadline of each job is thus: ,  and  and according to , this leads to the job priority assignment  (and to a makespan of ).  

\begin{figure}[h]
\begin{center}
\includegraphics*[width=0.5\linewidth, viewport=0 0 720 220]{multiple_JPA_1.pdf}
\caption{Assuming that the three jobs are released simultaneously upon the  allows to derive a first job priority assignment.}
\label{fig:Multimode:multiple_JPA_1}
\end{center}
\end{figure}

\noindent \textbf{Job priority assignment 2.} Starting from the previous release pattern in which all the jobs are released simultaneously at time , one can slightly move backward the release time of job  (for instance) in such a manner that  is released at time  (see Figure~\ref{fig:Multimode:multiple_JPA_2}). Its absolute deadline  is thus shifted to time  and since no assumption is made about the schedule before time , we can suppose that  did not execute before . Therefore, the processing time of  at time  is  and the job priority assignment resulting from this new release pattern is  (leading to a makespan of ). 

\begin{figure}[h]
\begin{center}
\includegraphics*[width=0.5\linewidth, viewport=0 0 720 220]{multiple_JPA_2.pdf}
\caption{Another job priority assignment can be derived by slightly modifying the release pattern of the jobs. Note that this modification leads to another makespan.}
\label{fig:Multimode:multiple_JPA_2}
\end{center}
\end{figure}

\noindent In the particular case of , shifting the absolute deadline of these three jobs by distinct amplitudes can modify their relative priorities and a possibly large number of job priority assignments can be derived from the same critical rem-job set .
\end{Example}

Because the prior knowledge of the critical rem-job set does not allow determining a unique job priority assignment, FJP schedulers require to consider every possible job priority assignment in order to determine an upper-bound on the makespan. Hence, we refine the notation of  as follows: the upper-bound on the makespan is denoted by  when  is explicitly specified (in the context of FTP scheduler) and by  otherwise (in the context of FJP scheduler), with the interpretation that for every job priority assignment : 
\label{null:Multimode:maxidle_instant_no_JPA}


It goes without saying that the prior knowledge of the jobs priority assignment allows for establishing tighter upper-bounds on the makespan, i.e., the upper-bound  is tighter than . From these refined notations, Expression~\ref{equ:basic_SMMSO_validity_test} of Validity Test~\ref{test:Multimode:SMMSO_first} can be rewritten as
 
for FJP schedulers, and as 
 
for FTP schedulers, where  is the job priority assignment derived from the old-mode FTP scheduler .




\section{The asynchronous protocol AM-MSO}
\label{sec:Multimode:AMMSO}

\subsection{Description of the protocol}
\label{sec:Multimode:AMMSO_description}

The protocol  (which stands for ``Asynchronous Multiprocessor Minimum Single Offset'' protocol) is an asynchronous version of the protocol . This protocol supports both uniform and identical platforms. The main idea of this second protocol is to reduce the delay applied to the enablement of the new-mode tasks, by enabling them as soon as possible. In contrast to SM-MSO, rem-jobs and new-mode tasks can be scheduled \emph{simultaneously} during the transition phases according to the scheduler  defined as follows: (i) the priorities of the rem-jobs are assigned according to the old-mode scheduler; (ii) the priorities of the new-mode jobs are assigned according to the new-mode scheduler, and (iii) the priority of each rem-job is higher than the priority of every new-mode job. 

Formally, suppose that the system is transitioning from mode  to mode  and let  and  be two active jobs during this transition. According to these notations we have  if and only if one of the following conditions is satisfied:


 proceeds as follows: upon a , , all the old-mode tasks are disabled and the rem-jobs continue to be scheduled by  (assuming that  is the old-mode). Whenever any rem-job completes (say at time ), if there is no more waiting rem-jobs  immediately enables some new-mode tasks, in contrast to  which waits for the completion of \emph{all} the rem-jobs. In order to select the new-mode tasks to enable at time ,  uses the following \emph{heuristic}: it considers every disabled new-mode task by non-decreasing order of transition deadline and enables those which can be scheduled by  upon the current available CPUs, i.e., the CPUs that are not running a rem-job and are therefore available for executing some new-mode tasks. The following example illustrates how  manages mode transitions.

\begin{Example}
\label{example:AMMSO}
Let us consider the same task sets as in Example~\ref{example_protocol_smmso}. Figure~\ref{fig:Multimode:AMMSO_example} illustrates the  transition protocol on a 2-processors platform. 
\begin{figure}[h!]
\begin{center}
\includegraphics*[width=0.5\linewidth, viewport=0 0 750 430]{AMMSO.pdf}
\caption{Illustration of a mode transition handled by .}
\label{fig:Multimode:AMMSO_example}
\end{center}
\end{figure}

Similarly to protocol ,  schedules the rem-jobs according to the old-mode scheduler from time  to time . Then at time , the rem-job  completes on   and there is no more waiting rem-jobs. Here  reacts differently from : it scans every disabled task of  (in non-decreasing order of transition deadline) and enables some of them in such a manner that the resulting set of enabled new-mode tasks can be scheduled by  upon 1  (since at this time , only the   is available for executing some new-mode tasks). We actually have no guarantee that scanning all the disabled tasks in non-decreasing order of transition deadline is optimal, but this \emph{heuristic} appears as the most intuitive choice. At time 220,  performs the same treatment as at time . But since we assumed that every task set , , is schedulable by  on , we know that \emph{all} the remaining disabled new-mode tasks can be enabled at this time 220. 
\end{Example}

Notice that, in contrast to , the protocol  allows mode changes to be requested during the mode transitions \emph{only} until some new-mode tasks have been enabled (the instant  in Figure~\ref{fig:Multimode:AMMSO_example}). Indeed, if the system is transitioning from any mode  to any other mode  and a mode change is requested to any mode  before time , then  can consider that the system is transitioning from mode  to mode  and the new-mode therefore becomes the mode . However after time , some tasks of mode  have already been enabled and  does not allow the system to request any other mode change until the end of the transition phase from  to , i.e., until all the tasks of mode  are enabled. 

In order to determine whether a task can be safely enabled, protocol  uses a binary function  that returns  if and only if the task set  is schedulable by  upon . This function is essential as we must always guarantee that all the deadlines are met for \emph{all} the jobs in the system, including the deadlines of \emph{all} the new-mode jobs. Considering a specific scheduler , such a function can be derived from schedulability tests proposed for  in the literature\footnote{To the best of our knowledge, there is no efficient \emph{necessary and sufficient} schedulability test for any multiprocessor scheduler that complies with the requirements specified in Section~\ref{sec:Multimode:scheduler_specifications}. Theodore Baker has proposed in~\cite{Baker:07} a necessary and sufficient schedulability test for arbitrary-deadline sporadic tasks scheduled by Global- but its time-complexity is very high so only small applications can be tested. Fortunately, many sufficient schedulability tests have been proposed for scheduler such as Global- (see for instance~\cite{BakerBaruah:09,Baruah:10,BaruahGoossens:08,BaruahBaker:08,BertCiriLipari:05}) and Global- (see for instance~\cite{Baker:03,BaruahGoossens:08:2,BaruahFisher:07}).}. Algorithm~\ref{algo:AMMSO} provides a pseudo-code for protocol .

\begin{figure}
\begin{center}
\begin{minipage}{15cm}
\begin{algorithmic}[1]
\REQUIRE : the old mode
\REQUIRE : the new-mode
\REQUIRE the rem-jobs
\REQUIRE : the current time during the transition
\REQUIRE : the platform (uniform or identical)

\IF{( is the  invoking time)}
 \STATE Disable all the tasks of 
 \STATE Sort the task set ``'' by non-decreasing order of transition deadlines
 \STATE  
\ENDIF

\STATE Schedule the rem-jobs according to 
\IF{(any rem-job  completes at  on any  )}
	\STATE  number of active rem-jobs at time 	
	\IF{()}		
		\STATE \textit{/* Due to the completion of , one   becomes available. */}
		\IF{( is identical)}
			\STATE \textit{/* The scheduler is weakly work-conserving. Thus, the  that becomes available is  */}
			\STATE 
		\ELSE
			\STATE \textit{/* The scheduler is strongly work-conserving. Thus, the  that becomes available is the  slowest . */}
			\STATE 
		\ENDIF
	\ENDIF
   	\FOR{each }
		\STATE 
		\IF{()}
    			\STATE enable 
		\ENDIF
	\ENDFOR
	\IF{()}
		\STATE enter the new-mode 
	\ELSE
		\STATE Schedule all the rem-jobs and new-mode jobs according to 
  	\ENDIF
\ENDIF
\end{algorithmic}
\end{minipage}
\end{center}
\caption{ protocol}
\label{algo:AMMSO}
\end{figure}

\begin{Observation}
\label{obs:compressed_algorithm}
The whole ``if--else--endif'' block within lines 11--17 could be replaced with  as adding  (instead of ) to  does not make any difference if  is identical. However, we preferred to provide the reader with this longer version of the algorithm for sake of pedagogy. The shorter version explained here will be used in the Validity Algorithm~\ref{algo:AMMSO_test} presented on page~\pageref{algo:AMMSO_test}.
\end{Observation}

\subsection{Design of a validity test}
\label{sec:Multimode:AMMSO_validity_test}

For a given application  and platform , the main idea to determine whether  allows to meet all the transition deadlines is to run Algorithm~\ref{algo:AMMSO} for every possible mode transition, while considering the worst-case scenario for each one---the scenario in which the new-mode tasks are enabled as late as possible. From our definition of protocol , we know that every instant at which some new-mode tasks are enabled corresponds to an instant at which at least one  has no more rem-job to execute, i.e., an ``idle-instant'' defined as follows.

\begin{Definition}[Idle-instant ]
\label{def:Multimode:idle_instants}
Let  be any finite set of  synchronous jobs. Let  be a uniform multiprocessor platform and let  be the job priority assignment used during the schedule of  upon . If  denotes that schedule then the idle-instant  (with ) is the earliest instant in  such that at least  s idle. 
\end{Definition}

By definition of the protocol , and in particular from the definition of , a new-mode job never preempts a rem-job during the transition phases. Thereby, during every transition phase, new-mode tasks are enabled at each idle-instant  () where  is the set of rem-jobs at the  invoking time and  is the job priority assignment derived from the old-mode scheduler when the mode change is requested. For obvious reasons, the \emph{exact} values of these idle-instants depend on both the number of jobs in  and their \emph{actual} execution times. Therefore, these exact value cannot be determined at system design-time and the main idea of our validity test is the following. 

{\bf First}, for every mode  we determine the set  of rem-jobs that leads to the largest idle-instants  (). From this point forward, we thus refine the definition of the \emph{critical rem-job set} as follows. 

\begin{Definition}[Critical rem-job set ]
\label{def:Multimode:worst_case_configuration_2}
Assuming any transition from a specific mode  to any other mode , the critical rem-job set  is the set of jobs issued from the tasks of  that leads to the largest idle-instants. 
\end{Definition}

As it will be shown in Corollary~\ref{cor:Multimode:worst_case_rem_jobs_set} (page~\pageref{cor:Multimode:worst_case_rem_jobs_set}), the critical rem-job set  of every mode  is the one that contains one job  for each task  and such that every job  has a processing time equals to , i.e., the WCET of . Informally speaking, the worst-case scenario during any mode transition is the one in which (i) every old-mode task releases a job \emph{exactly} when the mode change is requested and (ii) every released job executes for its WCET. 

{\bf Second}, we determine (for any given set  of jobs) an upper-bound on each idle-instant  (for ). As in the previous section (and for the same reason), we distinguish between FTP and FJP schedulers. That is, for FTP schedulers we focus on determining an upper-bound  on each  idle-instant  (for ) assuming that the job priority assignment  is known beforehand, whereas for FJP schedulers, we determine an upper-bound  on each  idle-instant , with the interpretation that for every job priority assignment : 


{\bf Finally}, we simulate Algorithm~\ref{algo:AMMSO} at each of these upper-bounds. That is, we verify whether all the transition deadlines are met while enabling the new-mode tasks at each instant   (or  depending on the family of the old-mode scheduler). Obviously, if every transition deadline is met during this simulation then it will be met during the \emph{actual} execution of the application. 

It goes without saying that the prior knowledge of the jobs priority assignment allows for establishing tighter upper-bounds on the idle-instants, i.e., the upper-bounds  are tighter than . Notice that it results from these notations that  and  correspond to the upper-bounds  and  introduced in Validity Test~\ref{test:Multimode:SMMSO_first}, respectively. 

Mathematical expressions of these upper-bounds  and  on the  idle-instants are defined for both identical and uniform platforms in Sections~\ref{sec:Multimode:ident_FJP}--\ref{sec:Multimode:unif_FTP}. Algorithm~\ref{algo:AMMSO_test} provides details on the validity test for , where the upper-bounds  must be replaced with  at line~9 if the old-mode scheduler is FTP. 

\begin{figure}[h!]
\begin{center}
\begin{minipage}{10cm}
\begin{algorithmic}[1]
\REQUIRE 
\FOR{(all  such that )}
	\STATE 
	\STATE 
	\STATE  
	\STATE Sort  by non-decreasing order of transition deadlines
	\FOR{()}
		\STATE 
		\FOR{(all )}
			\IF{()}
				\RETURN \FALSE
			\ENDIF
			\IF{()}
				\STATE 
				\STATE 
			\ENDIF
		\ENDFOR
	\ENDFOR
\ENDFOR
\RETURN \TRUE
\end{algorithmic}
\end{minipage}
\end{center}
\caption{Validity Test for }
\label{algo:AMMSO_test}
\end{figure}

Notice that Algorithm~\ref{algo:AMMSO_test} enables new-mode tasks only at the instants  (with ). That is, it implicitly considers that every instant at which s become available to the new-mode tasks are as late as possible. As a consequence, if all the transition deadlines are met while running Algorithm~\ref{algo:AMMSO_test} then all these deadlines will be met during every transition phase at run-time\footnote{Because Algorithm~\ref{algo:AMMSO_test} considers every transition between every pair of modes of the application.}. Nevertheless, the fact that Algorithm~\ref{algo:AMMSO_test} simulates every idle-instant of every mode transition by its corresponding upper-bound  brings about the following situation: during the actual execution of the application, there could be some intervals of time (during any mode transition) during which the set of currently enabled new-mode tasks benefits from more (and \emph{faster}) s than during the execution of Algorithm~\ref{algo:AMMSO_test}. This kind of situation can occur upon identical and uniform platforms and for both FJP and FTP schedulers as shown in the following example. 

\begin{Example}
Let us consider a -processors uniform platform~ and a system which is transitioning from mode  to mode . Other details such as the  speeds, the characteristics of the jobs and the job priority assignment are not relevant in the scope of this example. Figures~\ref{fig:Multimode:early_activation_1} and~\ref{fig:Multimode:early_activation_2} illustrate a situation where during some intervals of time the set of currently enabled new-mode tasks benefits from more (and \emph{faster}) s than during the execution of Algorithm~\ref{algo:AMMSO_test}. 
\begin{figure}[h!]
\begin{center}
\includegraphics*[width=0.5\linewidth, viewport=0 0 650 320]{early_activation_1.pdf}
\caption{Illustration of the schedule assumed by the execution of Algorithm~\ref{algo:AMMSO_test}. In this schedule, new-mode tasks are enabled at each instant , .}
\label{fig:Multimode:early_activation_1}
\end{center}
\end{figure}

\begin{figure}[h!]
\begin{center}
\includegraphics*[width=0.5\linewidth, viewport=0 0 650 380]{early_activation_2.pdf}
\caption{Illustration of a possible schedule during a transition from mode  to mode  in the \emph{actual} execution of the application. Here, new-mode tasks are enabled at each instant , , where .}
\label{fig:Multimode:early_activation_2}
\end{center}
\end{figure}

For sake of clarity, Figure~\ref{fig:Multimode:early_activation_2} uses the notations  and  instead of  and , respectively. In this latter schedule, there can be less rem-jobs and/or rem-jobs with lower processing times than in the schedule of Figure~\ref{fig:Multimode:early_activation_1} since the schedule of Figure~\ref{fig:Multimode:early_activation_1} is drawn while assuming the critical rem-job set of mode . This is the reason why the schedule of Figure~\ref{fig:Multimode:early_activation_2} seems less ``loaded'' than the one of Figure~\ref{fig:Multimode:early_activation_1}. Due to the fact that (i) the validity test provided by Algorithm~\ref{algo:AMMSO_test} uses the same function  as protocol  at run-time and (ii) this function  is independent of the current time, we know that the set of tasks enabled at each instant  () in Figure~\ref{fig:Multimode:early_activation_2} \emph{is the same as} the set of tasks enabled at each instant  in Figure~\ref{fig:Multimode:early_activation_1}. Let us temporarily name this property the ``equivalence property''. Let  temporarily denote the set of tasks enabled at time ,  and suppose that at time  in Figure~\ref{fig:Multimode:early_activation_1} some tasks are enabled (i.e., ) and at time  no task is enabled, i.e., . Thanks to the equivalence property, we know that the tasks enabled at time  in Figure~\ref{fig:Multimode:early_activation_2} are the tasks of  and those enabled at time  are the tasks of . Since we assumed in Figure~\ref{fig:Multimode:early_activation_2} that , it holds that the tasks enabled at time  are the tasks of  (since ). It follows that in the time interval , only  s are available to the task set  in Figure~\ref{fig:Multimode:early_activation_1} while  s are available to this task set in Figure~\ref{fig:Multimode:early_activation_2}. Moreover, during this time interval, the additional   in Figure~\ref{fig:Multimode:early_activation_2} is faster (or of equal speed) than every  in the subset of s  available to  in Figure~\ref{fig:Multimode:early_activation_1}. 
\end{Example}

Lemma~\ref{lem:Multimode:no_anomalies} proves that this kind of situation does not jeopardize the schedulability of the application during its execution. 

\begin{Lemma}[See~\cite{MeumeuNelisGoossens:10}]
\label{lem:Multimode:no_anomalies}
Any strongly work-conserving scheduler that is able to schedule a task set  upon a uniform platform  is also able to schedule  upon any uniform platform  such that (i)  and (ii)  and  we have .
\end{Lemma} 
\begin{proof}
To obtain the proof, it is sufficient to show the lemma for  where . The proof is made by contradiction. Suppose there exists a task set  that is schedulable by a strongly work-conserving scheduler  upon , but not upon . Consider the schedule upon  of a particular set  of jobs issued from  that leads to a deadline miss, and let  be another set of jobs derived from  by reducing the processing time of each job  by the amount of time  executes upon the sub-platform , i.e., upon . Since the scheduler is strongly work-conserving, the schedule of  by  upon the s in common with  is the same as the one that would be produced by  for  upon platform . Since a deadline is missed in the schedule of  upon , then a deadline is missed also in the schedule of  upon . But since the scheduler is predictable from Lemma~\ref{lem:Multimode:strongly_schedulers_predictable}, a deadline would be missed on  even (a fortiori) with the more demanding jobs set , leading to a contradiction. The lemma follows. 
\end{proof}

Lemma~\ref{lem:Multimode:no_anomalies} is proved while considering uniform platforms and strongly work-conserving schedulers but one can easily show that it also holds for identical platforms and weakly work-conserving schedulers. 



\section{Some basic results for determining validity tests}
\label{sec:Multimode:prelim_validity_tests}

\subsection{Introduction to the three required key results}
\label{sec:Multimode:three_key_results}

\emph{Three} key results are required to establish a validity test for  and . 

\begin{KeyResult}
It must be proved that disabling the old-mode tasks upon any MCR does not jeopardize the schedulability of the rem-jobs when they continue to be scheduled by the old-mode scheduler. That is, it must be guaranteed that the absolute deadline  of every rem-job  is met during any mode transition from every mode .
\end{KeyResult}

\begin{KeyResult}
The critical rem-job set  for every mode  must be determined. Indeed, for every mode transition from mode  to any other mode , our validity test (see Algorithm~\ref{algo:AMMSO_test}) determines the upper-bounds on the idle-instants by basing the computations on the corresponding critical rem-job sets  (at line~10). In all cases (i.e., identical or uniform platforms and FJP or FTP schedulers), we will provide a proof that the critical rem-job set  of every mode  is the one that contains one job  for each task  and such that every job  has a processing time equals to , i.e., the WCET of the task .
\end{KeyResult}

\begin{KeyResult}
A mathematical expression must be established that provides, for any given set  of jobs and platform :
\begin{enumerate}
\item an upper-bound  () on each idle-instant , for every job priority assignment . This concerns FJP schedulers.
\item an upper-bound  () on each idle-instant , for a specific job priority assignment . This concerns FTP schedulers.
\end{enumerate}
\end{KeyResult}

Note that the protocol  requires only an upper-bound on the makespan, i.e., on the  idle-instant  and .

\subsection{Proof of the first key result}
\label{sec:Multimode:prelim_validity_tests_first_result}

Lemma \ref{lem:Multimode:remjobs_meet_deadline} proves the first key result introduced above for any uniform platform and strongly work-conserving scheduler, as well as any identical platform and weakly work-conserving scheduler. This result, which is essential to the validity tests of both protocols  and , is based on the notion of \emph{predictability} introduced on page \pageref{def:Multimode:predictability}. It has been drawn from~\cite{NelisGoossensAndersson:09} and extended to uniform platforms.

\begin{Lemma}
\label{lem:Multimode:remjobs_meet_deadline}
Let  and  denote two distinct modes of the application. If the application is running in mode  and a  occurs at time  then every rem-job meets its deadline during the transition phase while being scheduled by the old-mode scheduler .
\end{Lemma} 
\begin{proof}
From our first assumption on page~\pageref{null:assumption1}, the set of tasks  of the mode  is schedulable by  upon . When the  is invoked at time , the transition protocol disables every old-mode task, which is equivalent to set the processing time of all their future jobs to zero. Since  is predictable (from Lemma~\ref{lem:Multimode:weakly_schedulers_predictable} or~\ref{lem:Multimode:strongly_schedulers_predictable} depending on the scheduler family), the deadline of every rem-job is still met in the produced schedule. The lemma follows.
\end{proof}

\subsection{Proof of the second key result}
\label{sec:Multimode:prelim_validity_tests_second_result}

Corollary~\ref{cor:Multimode:worst_case_rem_jobs_set} proves the second key result introduced above for any uniform platform and strongly work-conserving FTP (or FJP) scheduler, as well as any identical platform and weakly work-conserving FTP (or FJP) scheduler. It has been drawn from the following Lemma~\ref{lem:Multimode:worst_case_rem_jobs_set_base}.

\begin{Lemma}
\label{lem:Multimode:worst_case_rem_jobs_set_base}
Let  be any uniform multiprocessor platforms (including identical platforms) and let  and  be any fixed set of  synchronous jobs such that  of processing times  and  of processing times . For any job priority assignment , if there exists a bijective function between  and  such that every job  is mapped to exactly one job  and such that , then the  idle-instant  () in the schedule of  upon  is not lower than the  idle-instant  in the schedule of , i.e., it holds  that

\end{Lemma} 
\begin{proof}
The proof is a \emph{consequence} of the predictability of work-conserving schedulers (including both weakly and strongly work-conserving schedulers). Let  and  denote the schedule of  and  upon  with , respectively. We denote by  and  the completion time of any job  in  and  in , respectively. It follows from the fact that  () and from the predictability of the considered schedulers (see Lemma~\ref{lem:Multimode:weakly_schedulers_predictable} or~\ref{lem:Multimode:strongly_schedulers_predictable} depending on the scheduler family) that :

The proof is made by contradiction. Suppose that there exists  such that 

Figures~\ref{fig:Multimode:worst_case_rem_job_set1_1} and~\ref{fig:Multimode:worst_case_rem_job_set1_2} illustrate an example of schedules  and  on a -processors \emph{uniform} platform, respectively, where . 
\begin{figure}[t!]
\begin{center}
\includegraphics*[width=0.5\linewidth, viewport=0 0 700 270]{worst_case_rem_job_set1_1.pdf}
\caption{An example of schedule  upon a -processors uniform platform. The idle-instants  are denoted by  for sake of clarity.}
\label{fig:Multimode:worst_case_rem_job_set1_1}
\end{center}
\end{figure}

\begin{figure}[t!]
\begin{center}
\includegraphics*[width=0.5\linewidth, viewport=0 0 700 330]{worst_case_rem_job_set1_2.pdf}
\caption{An example of schedule  upon the same -processors uniform platform. Also for sake of clarity, the idle-instants  and  are denoted by  and , respectively. In this figure, we have by contradiction .}
\label{fig:Multimode:worst_case_rem_job_set1_2}
\end{center}
\end{figure}

\noindent Since the platform is uniform in these examples, the scheduler is strongly work-conserving and both schedules  and  form a staircase. In both Figures~\ref{fig:Multimode:worst_case_rem_job_set1_1} and~\ref{fig:Multimode:worst_case_rem_job_set1_2}, we voluntarily omit the details about the  speeds, the jobs characteristics, etc. since they are useless in the scope of these examples.

Similarly, Figures~\ref{fig:Multimode:worst_case_rem_job_set2_1} and~\ref{fig:Multimode:worst_case_rem_job_set2_2} illustrate an example of schedules  and  on a -processors \emph{identical} platform, respectively, where . Since the platform is identical in these examples, the scheduler is assumed to be weakly work-conserving.  Furthermore, note that in both examples no job is released after time . 

\begin{figure}[t!]
\begin{center}
\includegraphics*[width=0.5\linewidth, viewport=0 0 700 270]{worst_case_rem_job_set2_1.pdf}
\caption{An example of schedule  upon a -processors identical platform. The idle-instants  are denoted by  for sake of clarity.}
\label{fig:Multimode:worst_case_rem_job_set2_1}
\end{center}
\end{figure}

\begin{figure}[t!]
\begin{center}
\includegraphics*[width=0.5\linewidth, viewport=0 0 700 330]{worst_case_rem_job_set2_2.pdf}
\caption{An example of schedule  upon the same -processors identical platform. Also for sake of clarity, the idle-instants  and  are denoted by  and , respectively. In this figure, we have by contradiction .}
\label{fig:Multimode:worst_case_rem_job_set2_2}
\end{center}
\end{figure}

By definition of the idle-instants, the schedule of \emph{any} set  of jobs upon \emph{any} uniform or identical multiprocessor platform is such that :
\begin{itemize}
\item the idle-instant  corresponds to the completion time of a job,
\item there is no waiting job at time  and,
\item there are \emph{at most} () running jobs at time . ``At most'' since there can exist some  such that .
\end{itemize}

Since every idle-instant corresponds to the completion of a job, this implies that within the time interval  there are \emph{at most}  running jobs in  while there are \emph{at least}  running jobs in . Therefore, within , at least one job (say ) is already completed in  while  is still running in . The fact that  completes later in  than  in  leads to a direct contradiction of Inequality~\ref{equ:Multimode:ident_FTP_worst_case_configuration_temp1}. As we can see in Figures~\ref{fig:Multimode:worst_case_rem_job_set1_2} and~\ref{fig:Multimode:worst_case_rem_job_set2_2}, three jobs are running in  during the time interval  while only two jobs are running in , meaning that there is one job which is completed in  and still running in . The lemma follows.
\end{proof}

\begin{Corollary}
\label{cor:Multimode:worst_case_rem_jobs_set}
For any uniform multiprocessor platforms  and for any transition of the system from mode  to mode , let  denote any set of rem-jobs issued from the old-mode tasks and let  be the set of rem-jobs that contains one job  for each task  and such that every job  has a processing time equals to . The  idle-instants  () in the schedule of  is never lower than the  idle-instant  in the schedule of , i.e., it holds  that

\end{Corollary} 
\begin{proof}
The proof is a \emph{consequence} of Lemma~\ref{lem:Multimode:worst_case_rem_jobs_set_base}. Let  and  denote the processing time of job  in  and , respectively. By definition,  contains one job  of processing time  for each task , i.e., it holds  that
  
and thus we know by definition of  that , 

In addition, we know that there could be some jobs  such that  (since  does not necessarily contain one job for each old-mode task). For each such job  we add a fake job  in  with . It results from this operation that the number of jobs in both  and  are the same (we denote this number by ) and there is a bijective function between  and  such that every job  is mapped to by exactly one job  and such that . Thanks to this bijection, we know from Lemma~\ref{lem:Multimode:worst_case_rem_jobs_set_base} that  we have

and the corollary follows.
\end{proof}

By definition, for every mode transition from any mode  upon , each  is an upper-bound on the  idle-instant in the schedule of  (this also holds for each upper-bound  if the job priority assignment  is known beforehand). Thanks to Corollary~\ref{cor:Multimode:worst_case_rem_jobs_set}, we are now aware that each upper-bound  (and ) is also an upper-bound on the  idle-instant in the schedule of \emph{any} other set of rem-jobs issued from the old-mode tasks (i.e., the tasks of ). That is, for every mode transition from any mode  we have :
 \mbox{and} , where  denotes any set of rem-jobs issued from the tasks of . As a result, the instants  (and ), with , can be considered as the \emph{largest} instants at which new-mode tasks are enabled during every transition from mode  and thus, these instants can be used in our validity test given by Algorithm~\ref{algo:AMMSO_test}. 

\subsection{Organization for the third key result}
The third key result consists in determining a mathematical expression for each upper-bound  (or ) depending on the scheduler family, i.e., FJP or FTP), for all . Depending on the type of the platform (uniform or identical) and on the scheduler family (FJP or FTP), we distinguish between four different cases that are studied in turn in the following four sections. More precisely:

\begin{itemize}
\renewcommand{\labelitemi}{}
\item Section~\ref{sec:Multimode:ident_FJP} addresses the \emph{identical} and \emph{FJP} case.
\item Section~\ref{sec:Multimode:ident_FTP} addresses the \emph{identical} and \emph{FTP} case. 
\item Section~\ref{sec:Multimode:unif_FJP} addresses the \emph{uniform} and \emph{FJP} case.
\item Section~\ref{sec:Multimode:unif_FTP} addresses the \emph{uniform} and \emph{FTP} case. 
\end{itemize}

Recall that the protocol  requires only an upper-bound on the makespan, i.e., on the  idle-instant. The organization for the third key result is as follows. 




\section{Identical platforms and FJP schedulers}
\label{sec:Multimode:ident_FJP}

This section is organized as follows. First, Section~\ref{sec:Multimode:ident_FJP_upper_bounds} determines an \emph{upper-bound}  on the earliest time-instant where at least  s are idle and derives an upper-bound  on the maximum makespan. Then, Section \ref{sec:FJP_Accuracy} shows that this upper-bound  is 2-competitive, with the interpretation that  is at most twice the exact value of the maximum makespan. Finally, Section \ref{sec:Multimode:ident_FJP_validity_test} establishes a \emph{sufficient} validity test for protocols  and . 

\subsection{Upper-bounds  on the idle-instants}
\label{sec:Multimode:ident_FJP_upper_bounds}

Throughout this section,  refers to any set of  jobs. For sake of clarity, we will use the notation  instead of  and similarly, we will use the notation  to denote the \emph{exact} value of the  idle-instant. Before introducing the computation of these upper-bounds , , let us introduce the following result taken from~\cite{NelisGoossensAndersson:09}. 

\begin{Lemma}[See~\cite{NelisGoossensAndersson:09}]
\label{lem:Multimode:ident_FJP_lem1}
Suppose that  is sorted by non-decreasing job processing times, i.e., . Then, whatever the job priority assignment we have  such that :

\end{Lemma} 

Based on this Lemma~\ref{lem:Multimode:ident_FJP_lem1}, the following result was proved in our previous work~\cite{NelisGoossensAndersson:09}. 

\begin{Lemma}[See~\cite{NelisGoossensAndersson:09}]
\label{lem:Multimode:ident_FJP_maxidle_old}
Suppose that  is sorted by non-decreasing job processing times, i.e., . Then, whatever the job priority assignment, an upper-bound  on the idle-instant , , is given by  if  or by

\begin{small}

\end{small}
otherwise ().
\end{Lemma} 

Holding this result, we improve here this previous analysis by (i) successfully establishing \emph{another} upper-bound  on each idle-instant  and (ii) proving that these alternative upper-bounds are always tighter than those proposed in Lemma~\ref{lem:Multimode:ident_FJP_maxidle_old}. In short, we complete our previous work~\cite{NelisGoossensAndersson:09} as follows.

\begin{itemize}
\renewcommand{\labelitemi}{}
\item Lemma~\ref{lem:Multimode:ident_FJP_maxidle_old_max} shows that Expression~\ref{equ:Multimode:ident_FJP_maxidle_old} of  is always maximal for .
\item Lemma~\ref{lem:Multimode:ident_FJP_maxidle} proposes another upper-bound  on each idle-instant .
\item Lemma~\ref{lem:Multimode:ident_FJP_maxidle_better} shows that these alternative upper-bounds , , are never larger than those provided by Expression~\ref{equ:Multimode:ident_FJP_maxidle_old}. 
\item Finally, based on these alternative upper-bounds, Corollary~\ref{cor:Multimode:ident_FJP_makespan} derives an upper-bound on the makespan. 
\end{itemize}

\begin{Lemma}
\label{lem:Multimode:ident_FJP_maxidle_old_max}
If , Expression~\ref{equ:Multimode:ident_FJP_maxidle_old} is maximal for .
\end{Lemma} 
\begin{proof}
This result is presented in Lemma~2.10 in~\cite{Nelis:10}. Due to the space limitation and because the proof is simply based on algebra, we do not repeat it here.
\end{proof}

Thanks to Lemma~\ref{lem:Multimode:ident_FJP_maxidle_old_max}, Expression~\ref{equ:Multimode:ident_FJP_maxidle_old} can be rewritten as follows:  if  or 

otherwise (). 

\begin{Lemma}
\label{lem:Multimode:ident_FJP_maxidle}
Suppose that  is sorted by non-decreasing job processing times, i.e., . Then, whatever the job priority assignment, an upper-bound  on the idle-instant , , is given by  if  or by

otherwise ().
\end{Lemma} 
\begin{proof}
The case where  is obvious. Otherwise, the proof is made by contradiction. Suppose that there exists  such that . The following properties hold:
\begin{itemize}
\item \textbf{Prop. (a):} :  (by definition of the idle-instants).
\item \textbf{Prop. (b):} :  (from Lemma~\ref{lem:Multimode:ident_FJP_lem1}).
\end{itemize}
\noindent The proof starts with this obvious equality:

\noindent Then, applying properties (a) and (b) to the right-hand side yields

Since by hypothesis , replacing  with  in the above inequality leads to

\noindent This leads to a contradiction since it obviously holds by definition of the idle-instants that . The lemma follows.
\end{proof}

\begin{Lemma}
\label{lem:Multimode:ident_FJP_maxidle_better}
The upper-bounds  (with ) provided by Expression~\ref{equ:Multimode:ident_FJP_maxidle} are never larger than those provided by Expression~\ref{equ:Multimode:ident_FJP_maxidle_old_2}.
\end{Lemma} 
\begin{proof}
The proof is made by contradiction. Let  be any integer in . Let  and  denote the upper-bound provided by Expressions~\ref{equ:Multimode:ident_FJP_maxidle_old_2} and~\ref{equ:Multimode:ident_FJP_maxidle}, respectively, and suppose that . From Expressions~\ref{equ:Multimode:ident_FJP_maxidle_old_2} and~\ref{equ:Multimode:ident_FJP_maxidle} we get


\noindent By multiplying both sides by  we get


\noindent Thus, 

\noindent If  then we obviously get  and the lemma follows. Otherwise, if  then dividing both sides by  yields

\noindent In this case, in the right-hand side of the above inequality, there are  terms that are not lower than  each. This therefore leads to a contradiction since . The lemma follows.
\end{proof}

The following corollary derives an upper-bound on the makespan from  provided by Expression~\ref{equ:Multimode:ident_FJP_maxidle}.

\begin{Corollary}
\label{cor:Multimode:ident_FJP_makespan}
Suppose that  is sorted by non-decreasing job processing times, i.e., . Then, whatever the job priority assignment, an upper-bound  on the makespan is given by  if , or by

otherwise.
\end{Corollary} 
\begin{proof}
Since the makespan corresponds to the  idle-instant, an upper-bound on the makespan is given by . Therefore, the proof is obtained by simply replacing  with  in Expression~\ref{equ:Multimode:ident_FJP_maxidle}.
\end{proof}

\subsection{Accuracy of the upper-bound }
\label{sec:FJP_Accuracy}

In this section, Lemma~\ref{lem:Multimode:ident_accuracy_alpha} proves that the upper-bound  is -competitive, according to the following definition. 
\begin{Definition}[-competitive]
Any upper-bound is said to be -competitive if it provides \emph{at most}  times the \emph{exact} value of the approximated parameter. 
\end{Definition}

This is achieved under the assumption that during any mode transition all the rem-jobs execute for their WCET. Without this assumption, the minimum makespan that could be produced is always  since it can always be the case that no old-mode task has an active job when the mode change is requested. For instance in Figure~\ref{fig:Multimode:SMMSO_example}, the makespan would be zero if the  was released at time . However, in order to guarantee that our approach always provides an \emph{upper-bound} on the makespan we have to consider the worst-case scenario in which every old-mode task releases a job \emph{exactly} upon the mode change request and all these jobs executes for their WCET during the transition. 

\begin{Lemma}
\label{lem:Multimode:ident_accuracy_alpha}
For any set  of jobs sorted by non-decreasing job processing time and for any identical multiprocessor platform  composed of  s, the upper-bound  is -competitive.
\end{Lemma} 
\begin{proof}
Recall from Expression~\ref{equ:Multimode:ident_FJP_makespan} that, 

Let  denote the \emph{exact} makespan for the set  of jobs and the  identical s. Since we do not have any mathematical expression for determining this exact makespan , our analysis is performed while considering a lower-bound  on the makespan rather than its exact value, i.e.,  is determined in such a manner that 
 
where

The case where  obviously leads to  since both  and  return a makespan of . Otherwise (if ) the ``max'' operator in the definition of  leads to two different cases.

\noindent\emph{Case 1:} If  then we get

and since in this case we have , it holds that


\noindent\emph{Case 2:} If  then

and since in this case we have , it holds that

\noindent The lemma follows.
\end{proof}
     
It holds from Lemma~\ref{lem:Multimode:ident_accuracy_alpha} that, for any set  of jobs and any identical platform composed of  s, the upper-bound on the maximum makespan provided by  is at most twice the \emph{exact} value of the maximum makespan. Additionally we can show that \emph{in some particular cases} as the one provided in the following example, the upper-bounds  () defined on page~\pageref{lem:Multimode:ident_FJP_maxidle} are \emph{exact}. 

\begin{Example}
Let us consider the set of  jobs with characteristics given in Table~\ref{tab:Multimode:tight_upper_bound_example} to be scheduled on a -processors identical platform. 
\begin{table}[h!]
\centering
\begin{tabular}{| c | c | c | c | c | c |}
\hline
 &  &  &  &  & \\
\hline
1 & 1 & 1 & 1 & 1 & 1 \\
\hline
 &  &  &  &  & \\
\hline
3 & 3 & 6 & 6 & 9 & 12 \\
\hline
\end{tabular}
\caption{Processing times of the 12 jobs in .}
\label{tab:Multimode:tight_upper_bound_example}
\end{table}

\noindent For this set of jobs,
\begin{itemize}
\item the upper-bound  is reached with the job priority assignment .
\item the upper-bound  is reached with the job priority assignment .
\item the upper-bound  is reached with the job priority assignment .
\end{itemize}

\noindent Due to the space limitation, we did not drew the schedules corresponding to these priority assignments.
\end{Example}

\subsection{Validity tests for  and }
\label{sec:Multimode:ident_FJP_validity_test}

From Corollaries~\ref{cor:Multimode:worst_case_rem_jobs_set} and~\ref{cor:Multimode:ident_FJP_makespan}, the \emph{sufficient} validity test given by Test \ref{test:Multimode:SMMSO_first} on page \pageref{test:Multimode:SMMSO_first} can be rewritten as follows. 

\begin{validity test}[, Identical and FJP]
\label{validitytest:Multimode:ident_FJP_SMMSO}
For any multi-mode real-time application  and any identical platform  composed of  s, the protocol  is valid provided that, for every mode ,

where  is defined as in Expression~\ref{equ:Multimode:ident_FJP_makespan} and  is defined as follows: 
\begin{itemize}
\renewcommand{\labelitemi}{}
\item 
\item each job  has a processing time equal to the WCET  of task 
\item  is sorted by non-decreasing processing time.
\end{itemize}
 \end{validity test}

Concerning the protocol , the upper-bounds  (for all ) defined as in Lemma~\ref{lem:Multimode:ident_FJP_maxidle} can be used at line 10 of the validity algorithm given by Algorithm~\ref{algo:AMMSO_test} (on page~\pageref{algo:AMMSO_test}).
 



\section{Identical platforms and FTP schedulers}
\label{sec:Multimode:ident_FTP}

This section is organized as follows. First, Section~\ref{sec:Multimode:ident_FTP_upper_bounds} determines an \emph{upper-bound}  on each idle-instant  for any \emph{given} job priority assignment  and derives an upper-bound  on the maximum makespan. Then, Section \ref{sec:FTP_Accuracy} shows that this upper-bound  is 1-competitive, with the interpretation that  corresponds to the exact value of the maximum makespan. Finally, Section \ref{sec:Multimode:ident_FTP_validity_test} establishes a \emph{sufficient} validity test for the protocols  and . 

\subsection{Upper-bounds  on the idle-instants}
\label{sec:Multimode:ident_FTP_upper_bounds}

As introduced earlier, this section focuses on determining a mathematical expression for the upper-bounds  where  refers to any set of  jobs,  denotes any identical multiprocessor platform composed of  s and  is a specific given job priority assignment. Indeed, for a given FTP scheduler the priority of every task (and thus of every job) is know beforehand. This prior knowledge allows us to determine tighter upper-bounds than those proposed in the previous section. Once again, for sake of clarity, we will use the notations  and  instead of  and , respectively. 

For any transition from a given mode  to any other mode , the knowledge of the critical rem-job set  and the fact that the job priority assignment is known beforehand allow us to compute the \emph{exact} maximum idle-instants ---exact in the sense that they are actually reached if every job executes for its WCET---simply by drawing the schedule of  and by measuring the idle-instants  in that schedule. Indeed, from Corollary~\ref{cor:Multimode:worst_case_rem_jobs_set} (on page~\pageref{cor:Multimode:worst_case_rem_jobs_set}), each idle-instant  is an upper-bound on the idle-instant  derived from the schedule of any other set  of rem-jobs. Before expressing these exact maximum idle-instants, let us introduce the following definition. 

\begin{Definition}[Processed work ]
\label{def:Multimode:processed_work}
Let  denote any identical multiprocessor platform and let  be any global, weakly work-conserving and FTP scheduler. Let  denote any set of  jobs sorted by decreasing -priority, i.e.,  and let  denote the schedule by  of the  highest priority jobs of  upon . The processed work  ( and ) denotes the amount of processing time executed on   in .
\end{Definition}

In order to familiarize the reader with this notation , we provide the following example.

\begin{Example}
Let us consider the set  of  jobs with characteristics given in Table~\ref{tab:Multimode:tight_upper_bound_example2} to be scheduled on a -processors identical platform, following the priority assignment: . 
\begin{table}[h!]
\begin{center}
\begin{tabular}{| c | c | c | c | c | c | c |}
\hline
 &  &  &  &  &  &   \\
\hline
7 & 2 & 5 & 16 & 6 & 5 & 5 \\
\hline
\end{tabular}
\end{center}
\caption{Processing times of the 7 jobs in .}
\label{tab:Multimode:tight_upper_bound_example2}
\end{table}

\begin{figure}[!h]
\begin{center}
\includegraphics*[width=0.5\linewidth, viewport=0 0 700 500]{notations.pdf}
\caption{Illustration of the notion of processed work .}
\label{fig:MM_proofs_ident_notations}
\end{center}
\end{figure}

Figure~\ref{fig:MM_proofs_ident_notations} illustrates the schedule of  upon the  s. In this schedule, we have  because, in the schedule  of the  highest priority jobs , the amount of processing time units executed on  is . Similarly,  and  because, in the schedule  of jobs , we can see that  processing time units are executed on  (i.e., job ),  processing time units are executed on  (i.e., job ),  processing time units are executed on  (i.e., job ) and no processing time unit is executed on . Notice that  . 
\end{Example}

Lemma~\ref{lem:Multimode:ident_FTP_processed_work} provides the exact values of  ( and ) when each job executes for its WCET. Then, Corollary~\ref{cor:Multimode:ident_FTP_maxidle} derives the exact maximum idle-instants  , for the scheduling of any set  of  jobs upon any -processors identical platform. 

\begin{Lemma}
\label{lem:Multimode:ident_FTP_processed_work}
Let  denote any identical multiprocessors platform composed of  s. Let  be any global, weakly work-conserving and FTP scheduler and let  be any set of  jobs sorted by decreasing -priority, i.e., . It holds  and  that

\begin{small}

\end{small}
where   by definition of the processed work.
\end{Lemma} 
\begin{proof}
The proof directly follows from the definition of   and from the second condition of our definition of a weakly work-conserving scheduler (see Definition~\ref{def:Multimode:weakly_work_conserving}, page~\pageref{def:Multimode:weakly_work_conserving}). Indeed, whenever a subset  of several s idle (or complete a job) at the same time,  dispatches the waiting job (if any) with the highest priority to the  of  with the highest index (this is the reason for the condition ``if  is the highest value of  that minimizes ''). 
\end{proof}

\begin{Corollary}
\label{cor:Multimode:ident_FTP_maxidle}
An upper-bound , , is given by the  element of the vector  sorted by non-decreasing order.
\end{Corollary} 
\begin{proof}
The proof directly follows from the definition of the processed work , . 
\end{proof}

\begin{Corollary}
\label{cor:Multimode:ident_FTP_makespan}
The maximum makespan  is given by , where  is determined as in Corollary~\ref{cor:Multimode:ident_FTP_maxidle}. 
\end{Corollary}

\subsection{Accuracy of the upper-bound }
\label{sec:FTP_Accuracy}

In this section we prove that the upper-bound  is -competitive, i.e., {\em exact}---exact in the sense that it can actually be reached if every job executes for its WCET. Again, this is achieved under the assumption that during any mode transition all the rem-jobs execute for their WCET as we have to consider the worst-case scenario in which every old-mode task releases a job \emph{exactly} upon the mode change request and all these jobs executes for their WCET during the transition. 

For any transition from a given mode  to any other mode , the knowledge of the critical rem-job set  and the fact that we proceed by simulation allow us to compute the \emph{exact} maximum idle-instants simply by drawing the schedule of  following  and by measuring the idle-instants in this schedule. Using this approach, the measured upper-bound  is nothing else but -competitive.

\subsection{Validity tests for  and }
\label{sec:Multimode:ident_FTP_validity_test}

From Corollary~\ref{cor:Multimode:ident_FTP_makespan}, the \emph{sufficient} validity test given by Test~\ref{test:Multimode:SMMSO_first} (on page \pageref{test:Multimode:SMMSO_first}) can be rewritten as follows. 

\begin{validity test}[, identical and FTP]
\label{validitytest:Multimode:ident_FTP_SMMSO}
For any multi-mode real-time application  and any identical platform  composed of  s, the protocol  is valid provided that, for every mode ,

where  is defined as in Corollary~\ref{cor:Multimode:ident_FTP_makespan},  is obtained from the old-mode scheduler  and  is defined as follows: 
\begin{itemize}
\renewcommand{\labelitemi}{}
\item 
\item each job  has a processing time equal to the WCET  of task 
\item  is sorted by decreasing -priority. 
\end{itemize}
\end{validity test}

Concerning the protocol , the upper-bounds  (for all ) determined in Corollary~\ref{cor:Multimode:ident_FTP_maxidle} can be used at line 10 of the validity algorithm given by Algorithm~\ref{algo:AMMSO_test} on page~\pageref{algo:AMMSO_test}). 




\section{Uniform platforms and FJP schedulers}
\label{sec:Multimode:unif_FJP}

\subsection{Some useful observations}
\label{sec:Multimode:unif_observations}

In this section, we show that the maximum makespan determination problem is highly counter-intuitive upon \emph{uniform} platforms and the methods for solving this problem cannot be straightforwardly extended from those proposed for \emph{identical} multiprocessor platforms. First, recall that the schedulers are assumed to be \emph{strongly} work-conserving here since we focus on uniform platforms. 

\begin{Observation} 
For a given set of jobs, an intuitive idea for maximizing the makespan upon any -processor uniform platform is to execute, at any time, the longest job upon the slowest , i.e., the shorter the computation requirement of a job, the higher its priority. We name this priority assignment ``Shortest Job First'' (SJF). However, we can show by using the following example that this intuitive idea is {\em erroneous}, as SJF does not lead to the maximum makespan. 
\end{Observation}

\begin{Example}
Let us consider the set  of  jobs  of respective processing times 4, 4, 16 and 22, and suppose that they are scheduled on the -processors uniform platform . The priority assignment SJF (i.e., ) provides a makespan of  whereas the priority assignment  leads to a makespan of~. Notice that the problem of determining in a polynomial time (i.e., without trying every priority assignment) a priority assignment leading to the maximum makespan remains an open question and is out of the scope of this study. 
\end{Example}

\begin{Observation}
Another intuitive idea is to naively extend to uniform platforms the result (replicated below) of Corollary~\ref{cor:Multimode:ident_FJP_makespan} on page~\pageref{cor:Multimode:ident_FJP_makespan}, i.e., for any identical platform  composed of  s, an upper-bound on the makespan is given by

where  is assumed to be such that  . 
\end{Observation}

Upon \emph{identical} platforms there is a sense in distinguishing the case  from the case , because the rem-jobs never migrate between s during mode transitions. Therefore, in the particular case where , the maximum makespan does \emph{not} depend on the job priority assignment and can be determined \emph{exactly} by . In contrast, we can easily show that this property does not hold upon \emph{uniform} platforms. That is, the maximum makespan in the case  is \emph{not} independent from the job priority assignment upon uniform platforms. This is shown through the following example.

\begin{Example}
Consider the uniform platform  and the two jobs  of processing time  and , respectively. If  then  completes on  at time ---time during which  executes 2 execution units on ---and  completes on  at time , thus leading to a makespan of . On the other hand, if  then  completes on  at time ---time during which  executes  execution units on ---and  completes on  at time , thus leading to a makespan of . As a result, the maximum makespan in the case  \emph{depends} on the job priority assignment on uniform platforms and the case  can no longer be distinguished from the case . 
\end{Example}

From the previous example, naively extending Expression~\ref{equ:Multimode:ident_FJP_makespan_recall} to uniform platforms yields the following ``1-piece'' expression\footnote{recall that }:


Unfortunately, we show in the following example that this extension does not provide an upper-bound on the maximum makespan.

\begin{Example}
\label{ex:under_approximation}
Let us consider the set  of  jobs  of respective processing times 50, 80 and 99, and suppose that they are scheduled on the -processors uniform platform . The maximum makespan is , reached using the job priority assignment  (see Figure~\ref{fig:Multimode:unif_observation2_example1}). On the other hand, Expression~\ref{equ:Multimode:unif_FJP2_naive_extend} yields . This approximation made by Expression~\ref{equ:Multimode:unif_FJP2_naive_extend} is illustrated in Figure~\ref{fig:Multimode:unif_observation2_example2}. This simple example is \emph{much} more important than what it seems to be at first blush and we will deeply examine its impacts in Section~\ref{sec:Multimode:unif_FJP2_improvements} (page~\pageref{sec:Multimode:unif_FJP2_improvements}). 
\end{Example}

\begin{figure}[h]
\begin{center}
\includegraphics*[width=0.5\linewidth, viewport=0 0 700 400]{observation2_1.pdf}
\caption{This picture depicts a priority assignment leading to a makespan of . The speed of each  is indicated into brackets next to its label. The numbers next to each job name  is the amount of work processed by  upon the allocated . For instance, job  executes  execution units from time 0 to 5 on  , leading to its label .}
\label{fig:Multimode:unif_observation2_example1}
\end{center}
\end{figure}

\begin{figure}[h]
\begin{center}
\includegraphics*[width=0.5\linewidth, viewport=0 0 700 400]{observation2_2.pdf}
\caption{Approximation error made by Expression~\ref{equ:Multimode:unif_FJP2_naive_extend}.}
\label{fig:Multimode:unif_observation2_example2}
\end{center}
\end{figure}

\subsection{Upper-bounds  on the idle-instants}
\label{sec:Multimode:unif_FJP_upper_bounds}

Once more but this time for any \emph{uniform} platform , we focus on determining a mathematical expression that provides an upper-bound  on the  idle-instant, . For sake of clarity, the following two lemmas use the notations  instead of  and similarly, the notation  will be used to denote the \emph{exact} value of the  idle-instant. First, Lemma~\ref{lem:Multimode:unif_FJP_minidle} determines a \emph{lower-bound}  on each idle-instant , . Then, Lemma~\ref{lem:Multimode:unif_FJP_maxidle} determines an \emph{upper-bound}  on each idle-instant . Finally, Corollary~\ref{cor:Multimode:unif_FJP_makespan} derives an upper-bound on the maximum makespan (recall that the maximum makespan is simply given by ). 

\begin{Lemma}[See~\cite{MeumeuNelisGoossens:10}]
\label{lem:Multimode:unif_FJP_minidle}
Let  be any -processors uniform platform such that  , . Let  be any set of  jobs of respective processing times  such that . Let  be the schedule of  upon  following any global, strongly work-conserving and FJP scheduler. A lower bound  on each idle-instant  () in  is given by

\end{Lemma} 
\begin{proof}
According to the definition of the idle-instants, at most  jobs are not completed at time , meaning that \emph{at least}  jobs are already completed. Let  be any subset of  composed of  jobs, where . Obviously, a lower bound  on the instant at which the  jobs of  are completed is given by 

and since ,  is minimal if (i) the number of jobs in  is low as possible, i.e., , \emph{and} (ii) the processing time of each job of  is low as possible. As a result,  is minimum for  and then yields a lower-bound for . 
\end{proof}

\begin{Lemma}[See~\cite{MeumeuNelisGoossens:10}]
\label{lem:Multimode:unif_FJP_maxidle}
Using the same notations as in the previous lemma, an upper-bound  on each idle-instant  () in  is given by

where  (as defined in Expression~\ref{equ:Multimode:cumul_speed}, page~\pageref{equ:Multimode:cumul_speed}).
\end{Lemma} 
\begin{proof}
From the ``staircase'' property derived from the definition of a strongly work-conserving scheduler on uniform platform (see page~\pageref{sec:Multimode:scheduler_specifications} for details) and from the fact that all the jobs are assumed to be synchronous at time , we know that   becomes idle at time , . Let  () denotes the amount of work executed on ~ within , i.e., . The proof is made by contradiction. Let  be any integer in  and suppose that . By definition of , we know that 

and from the definition of  we know that 

By definition of the idle-instants, it holds  that . Therefore, replacing ``'' with ``'' in the second term of the right-hand side of the above equality yields

By hypothesis we have . Therefore, replacing  with  in the right-hand side of the above inequality yields
\begin{small}

\end{small}
\noindent Since from Lemma~\ref{lem:Multimode:unif_FJP_minidle} it holds that  , it holds that 

and thus
 
leading to a contradiction with Equality~\ref{equ:workissumci}. The lemma follows. 
\end{proof}

\begin{Corollary}[See~\cite{MeumeuNelisGoossens:10}]
\label{cor:Multimode:unif_FJP_makespan}
Whatever the job priority assignment, an upper-bound  on the makespan is given by

\end{Corollary} 
\begin{proof}
Since the makespan corresponds to the idle-instant , an upper-bound on the makespan is given by . Therefore, the proof is obtained by simply replacing  with  in Expression~\ref{equ:Multimode:unif_FJP_maxidle}. \\
\end{proof}

\subsection{Accuracy of the upper-bound }

In this section we prove that the upper-bound  is -competitive, with the interpretation that the value returned by  is {\em at most}  times the {\em exact} value of the maximum makespan for any given set  of jobs and uniform platform . Once again, this is achieved under the assumption that during any mode transition all the rem-jobs execute for their WCET as we have to consider the worst-case scenario in which every old-mode task releases a job exactly upon the mode change request and all these jobs executes for their WCET during the transition.

\begin{Lemma}
\label{lem:Multimode:unif_accuracy_alpha}
For any set  of jobs sorted by non-decreasing job processing time and any uniform platform  with  ,  is -competitive, where .
\end{Lemma} 
\begin{proof}
Recall from Expression~\ref{equ:Multimode:unif_FJP_makespan} that

Let  denote the \emph{exact} makespan for any given set  of jobs and any uniform platform . Since we do not have any mathematical expression for determining this exact makespan , our analysis of  is performed while considering a lower-bound  on the makespan rather than its exact value, i.e.,  is determined in such a manner that 

Obviously, we know that  and this implies that  is a lower-bound on the makespan. This yields

and thus,

\begin{small}

\end{small}
Notice the important loss of accuracy that this inequality underwent when we ignored the term  while passing from Inequality~\ref{lem:Multimode:unif_accuracy_alpha_exp1} to Inequality~\ref{lem:Multimode:unif_accuracy_alpha_exp2}. The lemma follows.
\end{proof}

\subsection{Another analysis of the maximum makespan}
\label{sec:Multimode:unif_FJP2_improvements}

In Example~\ref{ex:under_approximation} on page \pageref{ex:under_approximation}, we have showed that the naive extension of  (given by  in Expression \ref{equ:Multimode:unif_FJP2_naive_extend}, page~\pageref{equ:Multimode:unif_FJP2_naive_extend}) does not provide an upper-bound on the maximum makespan considering uniform platforms. Essentially, in addition to refute the fact that  provides an upper-bound on the maximum makespan, this example also refutes the \emph{main concept behind the expression of }. Indeed, in the expression of , it can be easily shown that the term  is an upper-bound on the time at which  starts its execution, i.e., its \emph{dispatching} time. Therefore, the whole expression can be interpreted as follows: upper-bound on the makespan = upper-bound on the dispatching time of  + , where  is the (or any) job with the largest processing time. That is, this expression of  is based on the intuition that the maximum makespan is reached when the longest job is dispatched as late as possible and executes for its WCET. This intuition has revealed to be true for the case of identical platforms, but not for the uniform case (as shown by Example~\ref{ex:under_approximation})\footnote{Indeed, we can also easily show that the term  in Expression~\ref{equ:Multimode:unif_FJP2_naive_extend} is an upper-bound on the dispatching time of  and at that time  is dispatched to the fastest  , leading to a WCET of .}. The whole concept is not extendable to uniform platforms and in order to figure out the underlying cause, let us focus on Example~\ref{ex:under_approximation}.

\begin{figure}
\begin{center}
\includegraphics*[width=0.5\linewidth]{improvement_principle.pdf}
\caption{Example of schedule in which the makespan is larger than that returned by .}
\label{fig:Multimode:unif_FJP2_improvement_principle}
\end{center}
\end{figure}

Let  and  denote the two schedules depicted in Figure~\ref{fig:Multimode:unif_FJP2_improvement_principle}, issued from the approximation  and from the priority assignment  which leads to the maximum makespan, respectively. The reason why  \emph{under}-approximates the maximum makespan comes from the following fact: \emph{if  denotes the instant at which job  is dispatched to   in  (here, ), then during the time interval ,  has executed a lower amount of execution units in the stairs of  than upon  in }. In other words the \emph{cumulated} green areas  in Figure~\ref{fig:Multimode:unif_FJP2_improvement_principle} represent a lower amount of execution units than the red area. Indeed,  executes  execution units within  in  whereas it executes  execution units on  in . As a result, the remaining processing time of  at time  is higher in  (here, 80) than in  (here, 79), implying that  completes later in  than in . This is the reason why the expression  does not provide the maximum makespan in the example above: on uniform platforms, \emph{the schedule in which any job  reaches its maximum completion time is not necessarily the schedule in which  is dispatched as late as possible}. 

Based on this fundamental observation, we propose and prove correct in \cite{Nelis:10} (pages 138--163 and 351--367) two additional upper-bounds  and  on the maximum makespan, considering uniform platforms and FJP schedulers. These upper-bounds are replicated below.

where  is such that ,

\noindent and

where 

and  is such that ,


Each of these two upper-bounds is based on a distinct upper-bound on the amount of execution units that can be executed in the green areas (see~Figure~\ref{fig:Multimode:unif_FJP2_improvement_principle}), and then derives an upper-bound on the completion time of every job, and finally on the makespan.

\subsection{Validity tests for  and }
\label{sec:Multimode:unif_FJP_validity_test}

\noindent From Expressions~\ref{equ:Multimode:unif_FJP_makespan}, \ref{equ:Multimode:unif_FJP_makespan2}, \ref{equ:Multimode:unif_FJP_makespan3}, and Corollary~\ref{cor:Multimode:worst_case_rem_jobs_set}, a \emph{sufficient} validity test for the protocol  can therefore be formalized as follows. 

\begin{validity test}[, uniform and FJP]
\label{validitytest:Multimode:unif_FJP_SMMSO}
For any multi-mode real-time application  and any uniform platform  composed of  s, the protocol  is valid provided that, for every mode ,

where  is defined as 

\noindent and ,  and  are defined as in Expressions~\ref{equ:Multimode:unif_FJP_makespan}, \ref{equ:Multimode:unif_FJP_makespan2} and~\ref{equ:Multimode:unif_FJP_makespan3}, respectively. This is performed considering the set  composed of  jobs of processing time  such that  . 
\end{validity test}

Concerning the protocol , the upper-bounds  (for all ) defined as in Lemma~\ref{lem:Multimode:unif_FJP_maxidle} can be used at line 10 of the validity algorithm given by Algorithm~\ref{algo:AMMSO_test} (on page~\pageref{algo:AMMSO_test}).

\subsection{Simulation results}
\label{sec:Multimode:simulations}

Because our analysis of the competitive factor did not lead to a constant  for the upper-bound  (as well as for the upper-bounds  and  as shown in \cite{Nelis:10}), this section reports on the results of simulations in order to quantify the precision of the three upper-bounds ,  and . These simulations are performed considering a single set  of jobs scheduled and multiple uniform platforms. We consider only a single set  of jobs for which the \emph{exact} processing times are given in Table~\ref{tab:Multimode:simulations_jobs_processing_time}. We will explain below where these parameters are drawn from and why we consider only a single set of jobs rather than generating numerous job sets. \\ 

\begin{table}[h!]
\centering
\begin{tabular}{| c | c | c | c | c |}
\hline
 &  &  &  &  \\
\hline
3896 & 3964 & 878 & 1378 & 2228 \\
\hline
 &  &  &  &  \\
\hline
3612 & 1230 & 1232 & 1668 & 4672 \\
\hline
\end{tabular}
\caption{Processing times of the 10 jobs in .}
\label{tab:Multimode:simulations_jobs_processing_time}
\end{table}

For experimental purposes, let us introduce the parameter  defined in \cite{FunkGoossensBaruah:01} for any -processor uniform platform , 
 
Informally speaking, this parameter  measures the ``degree'' by which  differs from an identical multiprocessor platform, i.e., its ``degree of heterogeneity''. For any identical platform composed of  s, it holds that  and thus,  is maximum for , leading to . The more homogeneous the platform  is, the closer to  is its corresponding . For instance, the uniform platform  has a corresponding  whereas  for the uniform platform  and  for the platform . In short,  if  is comprised of  identical s and becomes progressively smaller as the speeds of the s differ from each other by greater amounts. 

The platform  considered in our simulations is composed of  s for which we make their computing speed varying within  with an increment of . More precisely, we consider all possible combinations of the  speeds in the range  with an increment of , i.e., the first simulation is performed considering , the second simulation considers , the third one considers , and so on until reaching the speed assignment . For every speed assignment, we determine the corresponding parameter  as well as the \emph{exact} value  of the maximum makespan. This exact maximum makespan  is determined by building the schedule of  upon  for \emph{every} job priority assignment and by retaining only the maximum generated makespan. This is a highly computational-intensive operation that requires the exhaustive enumeration of every possible job priority assignment. This is the reason why we consider only a single set  of jobs in our simulations. Indeed, according to this approach, our simulation process considers  different speeds for each , leading to a total of  different platforms . For each platform , the computation of the exact makespan requires to generate the schedules derived from every job priority assignment. Since there are  jobs, the number of considered priority assignments is . Multiplied by the number of platforms, this leads to  operations. Our simulations were performed on HYDRA, the Scientific Computer Configuration at the VUB/ULB Computing Centre, where we fully distributed the computations among 15 processors AMD Opteron dual-core @ 2.8GHz. Distributing the computations allowed us to complete the simulation in about 2 hours but unfortunately, the computation time grows exponentially with the number of s and in a factorial manner with the number of jobs. For instance, considering  jobs would result in  operations,  jobs to approximately  operations, resulting in a computation time of about  years. The processing times of the jobs have been drawn from~\cite{IainBate:98} where the authors present realistic parameters that concern the avionic domain. But since the number of operations of our algorithm is strongly restricted by the number of jobs, we arbitrarily selected  WCETs from these parameters. 

For each speed assignment of the platform we computed the error  corresponding to the difference (in percent) between  and . Formally, 

and in a similar way we also computed the errors  and .

The errors ,  and  are displayed in Figure~\ref{fig:Multimode:simulations_result_1} relative to the corresponding . The horizontal black line is the error ``E\_EXACT\_MAKESPAN'' of  over the exact value of the maximum makespan. Obviously, this error is always . Also, for every speed assignment of , we define the estimator  as in Expression~\ref{maxmakespanUnifMin} and its associated error . This error is displayed in Figure~\ref{fig:Multimode:simulations_result_2} relative to the corresponding . Finally, Table~\ref{tab:Multimode:simulations_outline} provides the reader with some statistics issued from the simulation. 

\begin{figure}
\includegraphics[width=\linewidth]{exp_result.pdf}
\caption{The three estimation errors ,  and  displayed relative to the corresponding .}
\label{fig:Multimode:simulations_result_1}
\end{figure}

\begin{figure}
\includegraphics[width=\linewidth]{exp_result_min.pdf}
\caption{The estimation error  displayed relative to the corresponding .}
\label{fig:Multimode:simulations_result_2}
\end{figure}

\begin{table}[h!]
\centering
\begin{tabular}{| c | c | c | c | c |}
\hline
&  &  &  &  \\
\hline
Min. & 1.57\% & 1.89\% & 2.7\% & 1.57\% \\
\hline
1st Qu. & 6\% & 21.74\% & 13.28\% & 5.3\% \\
\hline
Median & 12.72\% & 41.07\% & 27.11\% & 9.92\% \\
\hline
Mean & 13.68\% & 37.91\% & 29.25\% & 10.44\% \\
\hline
3rd Qu. & 20.72\% & 55.5\% & 43.99\% & 15.08\% \\
\hline
Max. & 32.96\% & 88.78\% & 68.01\% & 22.89\% \\
\hline
Variance & 69.76 & 359.37 & 320.47 & 33.36 \\
\hline
SD\footnote{Squared distance} & 8.35\% & 18.96\% & 17.9\% & 5.78\% \\
\hline
Bias & 42.35\% & 133.69\% & 94.05\% & 26.93\% \\
\hline
MSE\footnote{Mean Square Error} & 1863.25 & 18233.15 & 9165.97 & 758.43 \\
\hline
\end{tabular}
\caption{Statistics issued from the simulation}
\label{tab:Multimode:simulations_outline}
\end{table}

For obvious reason, the most accurate estimator (i.e., the most accurate upper-bound on the maximum makespan) is . As presented in Table~\ref{tab:Multimode:simulations_outline}, the most important error that we obtained for  is  and the minimal one is . The average error is  with a squared distance of . Hence, we believe that this is a promising path to go for more competitive bounds and for practical use. An open question remains however. For , we can see in Figure~\ref{fig:Multimode:simulations_result_1} that  is clearly lower than both  and , i.e.,  for . Within this interval , when the parameter  reaches an integer value (here,  and ), something happens that considerably improves the accuracy of . But up to now, we did not find any interpretation to that phenomenon. 



\section{Uniform platforms and FTP schedulers}
\label{sec:Multimode:unif_FTP}

This section follows the same reasoning as the one for identical platforms and FTP schedulers. For any transition from a specific mode  to any other mode , the knowledge of the critical rem-job set  and the fact that the priorities are known beforehand enable us to compute the \emph{exact} maximum idle-instants , , simply by simulating the scheduling of the critical rem-job set and by measuring the idle-instants , , in that schedule (from Corollary~\ref{cor:Multimode:worst_case_rem_jobs_set} presented on page~\pageref{cor:Multimode:worst_case_rem_jobs_set}). Thus, each idle-instant  measured in the schedule of the critical rem-job set is an upper-bound on the idle-instants  in the schedule derived from any other set of rem-jobs. In conclusion, FTP schedulers enable us to determine the \emph{exact}\footnote{Exact in the sense that this value is actually reached if every job executes for its WCET.} maximum idle-instants , , rather than over-approximating them (as done for the FJP schedulers). 

\subsection{Upper-bounds  on the idle-instants}
\label{sec:Multimode:unif_FTP_upper_bounds}

Lemma~\ref{lem:Multimode:unif_FTP_idle_ki} provides the exact values of   and , assuming that every job  executes for its WCET. However, in this particular case of FTP scheduler, we redefine the idle-instants  as follows.

\begin{Definition}[Idle-instant ]
\label{def:Multimode:unif_FTP_idle_ij_redefined}
If  denotes the schedule upon  of only the jobs with a higher (or equal) priority than  according to , then  is the earliest instant in  at which at least  s idle. 
\end{Definition}

The only difference w.r.t. the previous one resides in the ``higher \emph{(or equal)} priority than (...)''. The reason for this redefinition is that, with the previous one, it was not possible to express the idle-instants  (for ) as in Definition~\ref{def:Multimode:idle_instants} (page~\pageref{def:Multimode:idle_instants}). Indeed, these idle-instants  consider that every job of  are scheduled while the previous definition of the idle-instants  requires a job index  and considers that only the jobs with a higher priority than  are scheduled. Thereby, this previous definition always excludes the job  in the computation of the idle-instants. Now, thanks to this new definition, the idle-instants  (for ) can be expressed by , where  is the lowest priority job according to . Once again, we use in Corollary~\ref{cor:Multimode:unif_FTP_maxidle} the notations  to refer to the idle-instants  defined as in Definition~\ref{def:Multimode:unif_FTP_idle_ij_redefined}. 

\begin{Lemma}[See~\cite{MeumeuNelisGoossens:10}]
\label{lem:Multimode:unif_FTP_idle_ki}
Let  denote any uniform multiprocessor platform composed of  s and assume that , . Let  be any set of  jobs, all released at time , with respective computation time . Let  denote any global, FTP and strongly work-conserving scheduler and suppose that  is sorted by decreasing -priority, i.e., . If these jobs are scheduled by  upon , then  is inductively defined as follows: \\

\noindent Initialization:


\noindent Iteration:

for ( to )

\hspace{0.2cm} for ( to ) \\

\noindent  

\end{Lemma} 
\begin{proof} 
Initially, the  s idle and thus, , , . We find convenient to define , which means that we have at most  s available. In the following, we prove the correctness of the value of  (, ) assuming that  are defined (). The idle-instants  define a staircase as illustrated in Figure~\ref{fig:Multimode:unif_FTP_idle_ki} for the scheduling of jobs . Thus, job  can only progress into the blue areas and two cases have to be distinguished:

\paragraph{Case 1} , meaning that \emph{at least} one  faster than  becomes available at time  (the blue area on   is void in that case). This situation is depicted in Figure~\ref{fig:Multimode:unif_FTP_idle_ki} where  and the blue area is void on s  and . In this kind of situation, the job  is executed (if not completed) upon a faster  and the first instant at which at least  s idle remains unchanged after having scheduled the job , i.e., .

\paragraph{Case 2} Otherwise,  is dispatched to   at instant  and keeps executing on  as long as (i) no faster s become idle or (ii)  completes. In the first case,  executes on  until the next idle-instant , leading to the first sub-case . In the second case,  executes on   but completes before time . Thus, the idle-instant  is the instant  at which  was dispatched to  \emph{plus} its remaining processing time on   at time . Since  corresponds to the amount of work that  has executed in the interval of time , its remaining processing time on   at time  is given by , leading to the second sub-case. 
\end{proof}

\begin{figure}
\includegraphics[width=\linewidth, viewport=0 0 800 500]{staircase_migration_times.pdf}
\caption{Staircase defined by the }
\label{fig:Multimode:unif_FTP_idle_ki}
\end{figure}

\begin{Corollary}[See~\cite{MeumeuNelisGoossens:10}]
\label{cor:Multimode:unif_FTP_maxidle}
The maximum idle-instant  () is given by  computed as in Lemma~\ref{lem:Multimode:unif_FTP_idle_ki}. 
\end{Corollary}

\begin{Corollary}
\label{cor:Multimode:unif_FTP_makespan}
The maximum makespan  is given by  computed as in Lemma~\ref{lem:Multimode:unif_FTP_idle_ki}.
\end{Corollary}

\subsection{Validity tests for  and }
\label{sec:Multimode:unif_FTP_validity_test}

From Corollary~\ref{cor:Multimode:unif_FTP_makespan}, a \emph{sufficient} validity test for the protocol  can therefore be formalized as follows. 

\begin{validity test}[, uniform and FTP]
\label{validitytest:Multimode:unif_FTP_SMMSO}
For any multi-mode real-time application  and any identical platform  composed of  s, the protocol  is valid provided that, for every mode ,

where  is computed as  in Lemma~\ref{lem:Multimode:unif_FTP_idle_ki}, considering the critical rem-job set  composed of  jobs  of respective processing time  and such that  is sorted by decreasing -priority.
\end{validity test}

Similarly, the upper-bounds  (where  and  corresponds to the job priority assignment of the old-mode scheduler ) determined in Lemma~\ref{lem:Multimode:unif_FTP_idle_ki} can be used at line 10 of the validity algorithm of  (see Algorithm~\ref{algo:AMMSO_test} page~\pageref{algo:AMMSO_test}), as long as these upper-bounds are computed while assuming the critical rem-job set  for the transitions from every mode . 
 


\section{Conclusion and open problems}
\label{sec:Multimode:Conclusion}

In this paper, we addressed the scheduling problem of multi-mode real-time applications upon identical and uniform multiprocessor platforms. We assumed that every mode of the application was scheduled by following a global and Fixed-Task-Priority or Fixed-Job-Priority scheduler. Under these assumptions, we proposed two protocols for managing every transition between every pair of modes of the system, namely  and . For both protocols, we established validity tests that allow the system designer to predict whether the given application can meet all the expected timing requirements upon the given platform. We prove the correctness of our schedulability analyses by extending the theory about the makespan determination problem. 

In our future work, we aim at taking into account mode-independent tasks, i.e., tasks whose the periodic (or sporadic) activation pattern is not affected by the mode changes. Moreover, instead of scheduling the rem-jobs by using the scheduler of the old-mode during the transitions, it could be better, in term of the enablement delays applied to the new-mode tasks, to propose a \emph{dedicated priority assignment} which meets the deadline of every rem-job, \emph{while} minimizing the makespan. To the best of our knowledge, the problem of minimizing the makespan while meeting job deadlines is not yet addressed in the literature and remains open.  Table~\ref{tab:open_problem} outlines a brief overview of all different problems, considering the task and platform model introduced in this paper. For each problem, we indicated either the reference(s) where solutions have been proposed or T.W. (\textbf{T}his \textbf{W}ork) or F.W. (\textbf{F}uture \textbf{W}ork) or O.P. (\textbf{O}pen \textbf{P}roblem).

\begin{table}[h!]
\centering
\begin{tabular}{| c | c | c | c |}
\hline
\multicolumn{4}{| c |}{Protocols without periodicity} \\
\hline
Protocol & Platform & Scheduler & Existing results \\
\hline
Synchronous & identical & FJP & \cite{NelisGoossens:08, NelisGoossensAndersson:09, Nelis:10}, T.W. \\
\hline
Synchronous & identical & FTP &  \cite{NelisGoossens:08, NelisGoossensAndersson:09, Nelis:10}, T.W. \\
\hline
Synchronous & uniform & FJP & \cite{MeumeuNelisGoossens:10, Nelis:10}, T.W. \\
\hline
Synchronous & uniform & FTP & \cite{MeumeuNelisGoossens:10, Nelis:10}, T.W. \\
\hline
Asynchronous & identical & FJP &  \cite{NelisGoossensAndersson:09, Nelis:10}, T.W.\\
\hline
Asynchronous & identical & FTP & \cite{NelisGoossensAndersson:09, Nelis:10}, T.W.\\
\hline
Asynchronous & uniform & FJP & \cite{MeumeuNelisGoossens:10, Nelis:10}, T.W. \\
\hline
Asynchronous & uniform & FTP &  \cite{MeumeuNelisGoossens:10, Nelis:10}, T.W. \\
\hline
\hline
\multicolumn{4}{| c |}{Protocols with periodicity} \\
\hline
Protocol & Platform & Scheduler & Existing results \\
\hline
Synchronous & identical & FJP &  \cite{NelisAnderssonGoossens:09}, F.W. \\
\hline
Synchronous & identical & FTP &  \cite{NelisAnderssonGoossens:09}, F.W. \\
\hline
Synchronous & uniform & FJP &  F.W. \\
\hline
Synchronous & uniform & FTP &  F.W. \\
\hline
Asynchronous & identical & FJP &  O.P. \\
\hline
Asynchronous & identical & FTP &  O.P. \\
\hline
Asynchronous & uniform & FJP & O.P. \\
\hline
Asynchronous & uniform & FTP & O.P. \\
\hline
\end{tabular}
\caption{State-of-the-art at a glance.}
\label{tab:open_problem}
\end{table}

























\bibliographystyle{acm}
\bibliography{biblio}
\end{document}
