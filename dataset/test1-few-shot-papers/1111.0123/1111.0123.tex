\documentclass{LMCS}

\def\doi{7 (4:05) 2011}
\lmcsheading {\doi}
{1--25}
{}
{}
{Mar.~31, 2010}
{Nov.~23, 2011}
{}



\usepackage{enumerate}
\usepackage{hyperref}


\usepackage{proof}    \usepackage{verbatim}

\usepackage{url}
\usepackage{amsmath}[1999/12/15] \usepackage{amssymb}
\usepackage{amsthm}              \usepackage{stmaryrd}            \usepackage{relsize}             \let\citep=\cite
\theoremstyle{plain}



\theoremstyle{definition}
 \newtheorem{bsp}[thm]{Example}
 \newtheorem{remm}[thm]{Remark}




\newcommand{\cala}{\mathcal{A}}
\def\calc{\mathcal{C}}
\def\cald{\mathcal{D}}
\def\calf{\mathcal{F}}
\def\cali{\mathcal{I}}
\def\calif{\mathcal{IF}}
\newcommand{\call}{\mathcal{L}}
\newcommand{\calr}{\mathcal{R}}
\def\calp{\mathcal{P}}
\def\calr{\mathcal{R}}
\newcommand{\cals}{\mathcal{S}}
\def\calu{\mathcal{U}}
\def\calv{\mathcal{V}}
\def\calw{\mathcal{W}}

\def\consc{\textbf{c}}
\def\consd{\textbf{d}}

\newcommand*{\setn}{\mathbb{N}}
\newcommand*{\setb}{\mathbb{B}}
\newcommand*{\sett}{\mathbb{T}}
\newcommand*{\setr}{\mathbb{R}}
\newcommand*{\setz}{\mathbb{Z}}

\def\oto{\overrightarrow}
\def\tto{\twoheadrightarrow}

\def\lrbk#1{\llbracket#1\rrbracket}
\def\cons#1{\langle #1\rangle}

\newcommand*{\hilfminus}[1]{\stackrel{#1\cdot}{\relbar}}
\newcommand*{\dotminus}{\mathbin{\mathchoice
{\hilfminus{\displaystyle}}{\hilfminus{\textstyle}}{\hilfminus{\scriptstyle}}{\hilfminus{\scriptscriptstyle}}}}

\def\al{\alpha}
\def\be{\beta}
\def\de{\delta}
\def\De{\Delta}
\def\ga{\gamma}
\def\Ga{\Gamma}
\def\ka{\kappa}
\def\la{\lambda}
\def\si{\sigma}
\def\Th{\Theta}

\newcommand{\bdash}{\vdash_\beta}
\def\bd{\bdash}
\newcommand{\edash}{\vdash}
\def\ed{\edash}
\def\vd{\vdash}

\newcommand{\dom}{{\mathrm d}{\mathrm o}{\mathrm m}}
\newcommand{\ran}{{\mathrm r}{\mathrm a}{\mathrm n}}
\newcommand{\tm}{\subseteq}
\def\tminus{\text{-}}

\def\app{\textup{\textsf{app}}}
\def\lam{\textup{\textsf{lam}}}
\def\paar{\textup{\textsf{pair}}}

\def\menge#1#2{\{ #1 \, | \, #2\}}
\def\single#1{\{#1\}}

\def\bdiz{{\be\de\iota\zeta}}

\newcommand{\rbe}[1]{\raisebox{.8ex}[-0.8ex]{#1}}
\newcommand{\rbf}[1]{\raisebox{.5ex}[-0.5ex]{#1}}
\newcommand{\rbm}[1]{\raisebox{-1.5ex}[0.5ex]{}}
\newcommand{\rbmm}[1]{\raisebox{-2.7ex}[0.7ex]{}}

\newcommand*{\equote}[1]{\textquotedblleft#1\textquotedblright}
\newcommand*{\tquote}[1]{\textquoteleft#1\textquoteright}

\newcommand{\textblue}[1]{\textcolor{blue}{#1}}
\newcommand{\textgreen}[1]{\textcolor{green}{#1}}
\newcommand{\textred}[1]{\textcolor{red}{#1}}

\def\cc{\textup{\textsc{CC}}}
\def\cic{\textup{\textsc{CIC}}}
\def\ecc{\textup{\textsc{ECC}}}

\def\lafn#1#2{\la #1\,.\,#2}
\def\pifn#1#2{\Pi #1\,.\,#2}

\def\sd{\,.\,}

\def\bs{\backslash}
\def\vs{\,\mathop{|}\,}

\def\tril{\triangleleft}

\def\acceptable{\textup{\textsf{Acceptable}}}
\def\arity{\textup{\textsf{Arity}}}
\def\constructor{\textup{\textsf{Constructor}}}
\def\correct{\textup{\textsf{Correct}}}
\def\frei{\textup{\textsf{Free}}}
\def\spos{\textup{\textsf{SPos}}}

\def\sort{\textup{\textsf{Sort}}}
\def\sortarg{\textup{\textsf{SortArg}}}

\def\case#1{\textup{\textsf{case}}(#1)}
\def\fix#1#2{\textup{\textsf{fix}}\,\,#1\,\{#2\}}

\def\ind{\textup{\textsf{Ind}}}
\def\indic#1{\ind_{#1}\hspace{-.05cm}\single{\De_I:=\De_C}}
\def\indu#1#2#3{\ind_{#1}\hspace{-.05cm}\single{#2:=#3}}
\def\indt#1{\textup{\textsf{IndT}}\{#1\}}
\def\indc#1{\textup{\textsf{IndC}}\{#1\}}

\def\lett#1#2{\textup{\textsf{let}}\,\,#1\,\, \textup{\textsf{in}}\,\,#2}

\def\wf{\calw\calf}

\def\inn{\,\,\mathop{\textup{\textsf{in}}}\,\,}
\def\match{\mathop{\textup{\textsf{case}}}}
\def\fixx{\mathop{\textup{\textsf{fix}}}\,\,}

\def\tnat{\textup{\texttt{nat}}}
\def\tprop{\textup{\texttt{Prop}}}
\def\tset{\textup{\texttt{Set}}}
\def\ttype{\textup{\texttt{Type}}}
\def\ttt#1{\textup{\texttt{#1}}}

\def\uscore{\mathunderscore}

\def\lh{\mathit{lh}}




\def\sma#1{<\!\!\!#1}
\def\equ#1{=\!\!\!#1}

\def\vect#1{\overset{\shortrightarrow}{#1}}


 



\begin{document}

\title[Proof-irrelevant model of CC with pred. induction and judg. equality]{Proof-irrelevant model of  CC with predicative induction and judgmental equality}

\author[G.~Lee]{Gyesik Lee\rsuper a}	\address{{\lsuper a}Hankyong National University, Anseong-si, Kyonggi-do, Korea}	\email{gslee@hknu.ac.kr}  \thanks{{\lsuper a} Corresponding author:\
For Gyesik Lee, this work was partly supported by Mid-career Researcher Program through NRF funded by the MEST (2010-0022061).}

\author[B.~Werner]{Benjamin Werner\rsuper b}	\address{{\lsuper b} INRIA Saclay and LIX, Ecole Polytechnique, 91128 Palaiseau Cedex, France}	\email{Benjamin.Werner@inria.fr}  







\keywords{Calculus of Constructions, judgmental equality, proof-irrelevance, consistency}
\subjclass{F.4.1, F.3.1}




\begin{abstract}
  \noindent We present a set-theoretic, proof-irrelevant model for Calculus of Constructions (CC) with predicative induction and judgmental equality in Zermelo-Fraenkel set theory with an axiom for countably many inaccessible cardinals. 
  We use Aczel's trace encoding which is universally defined for any function type, regardless of being impredicative. Direct and concrete interpretations of simultaneous induction and mutually recursive functions are also provided by extending Dybjer's interpretations on the basis of Aczel's rule sets.
  Our model can be regarded as a higher-order generalization of the truth-table methods. We provide a relatively simple consistency proof of type theory, which can be used as the basis for a theorem prover.
\end{abstract}

\maketitle



\section{Introduction}\label{S:one}

\subsection*{Informal motivation}
The {\it types-as-sets} interpretation of type theory in a sufficiently strong classical axiomatic set theory, such as the Zermelo-Fraenkel (ZF) set theory, has been regarded as the most straightforward approach to demonstrating the consistency of type theory (cf. \cite{aczel-relating} and \cite{coquand-meta}). It can be construed as a higher-order generalization of the truth-table methods. Such a model captures the intuitive meaning of the constructs: the product, -abstraction, and application correspond to the ordinary set-theoretic product, function, and application, respectively.


A straightforward model of type theory is very useful for establishing the consistency of type theory, and it can be used to determine the proof-theoretic strength of type theory (cf. \cite{aczel-relating,dybjer,dybjer00,werner-set}). However, a higher-order generalization of the trivial Boolean model is {\it not so simple} (cf. \cite{miwe}). The main cause of this problem, as identified by \cite{reynolds}, is the fact that type systems containing Girard-Reynolds' second-order calculus cannot have the usual set-theoretic interpretation of types. The only way to provide a set-theoretic meaning for an impredicative proposition type is to identify all the proof terms of that proposition type: Proposition types are interpreted either by the empty set or a singleton with a canonical element. Thus, proof-irrelevant models are necessary for interpreting reasonable higher-order type systems.

Set-theoretic models of type theory can be understood in a straightforward manner. \cite{werner-proof} showed that they can be used as the basis of proof assistants in programming with dependent types. This is because they provide a mechanism to distinguish between computational and logical parts. 
Werner's system is a proof-irrelevant version of Luo's Extended Calculus of Constructions (ECC; \citep{luo89-lics}), and the set-theoretic model is an extension of that of Calculus of Constructions (CC) defined by \cite{miwe}.

Luo's ECC is a Martin-L\"of-style extension of CC, with strong sum types and a fully cumulative type hierarchy. At the lowest level, there is an impredicative type  of propositions. This is followed by a hierarchy of predicative type universes , :

\begin{iteMize}{}
\item  is of type ;

\item  is of type ;

\item .
\end{iteMize}

Werner's system, however, does not include the subtyping rule , which could complicate the model construction, as identified by \cite{miwe}. Their model constructions cannot be extended to ECC. We will explain this in detail in Remark \ref{counter-subtyping}.

In this paper, we investigate the inclusion of , and we show that type theory with judgmental equality, {\it \`{a} la} \cite{ml-84}, can have a simple proof-irrelevant model. We expect our results to play a key role in the theoretical justification of proof systems based on Martin-L\"of-style type theory.

\subsection*{Overview of the work}
Martin-L\"of type theory and Logical Framework include typing rules for the equality of objects and types:\medskip

In particular, Barendregt's PTS-style -conversion side condition
turns into an explicit judgment. Two objects are not just equal; they are equal with respect to a type (cf. \cite{nordstroem,goguen-phd,aczel-relating}).

The type system considered in our study is CC with predicative induction and judgmental equality. It is a type system with the following features: dependent types, impredicative type  of propositions, a cumulative hierarchy of predicative universes , predicative inductions, and judgmental equality.

The main difficulty in the construction of a set-theoretic model of our system stems from the impredicativity of  and the subtyping property . Without subtyping, one could use the solution provided by \cite{miwe} and \cite{werner-proof}, whereby proof-terms are syntactically distinguished from other function terms. Thus, the problem lies in the case distinction between the impredicative type  and the predicative types , whereas the subsumption eliminates the difference. An interpretation function  is required, where  is a set universe, that is different from the identity function. See Section \ref{interpretation} for further details.

For a set-theoretic interpretation of the cumulative type universes and predicative inductions, it is sufficient to assume countably many (strongly) inaccessible cardinals. \cite{werner-set} showed that ZF with an axiom guaranteeing the existence of infinitely many inaccessible cardinals is a good candidate. However, it is not clear whether the inaccessible cardinal axiom is necessary for our construction. The required feature of an inaccessible cardinal  is the closure property of the universe  under the powerset operation. This is a necessary condition for the interpretation of inductive types. Following \cite{dybjer}, we use Aczel's rule sets to obtain a direct and concrete interpretation of induction and recursion rules.

The remainder of this paper is organized as follows. In Section \ref{cc}, we provide a formal presentation of CC with predicative induction and judgmental equality. Examples are presented to enable the reader to understand the syntax and typing rules. This section can be regarded as an introduction to the base theory of the proof assistant Coq. Indeed, the syntax we have provided is as close to Coq syntax as that used in practice, except for the judgmental equality and the restriction on predicative inductions.\footnote{We remark that many impredicative inductive types can be coded by impredicative definitions (cf. \cite{girard-proofs,coquand-meta,werner-set}).}

The difficulties in providing set-theoretic interpretations of impredicative or polymorphic types, subtypes, etc., are discussed in Section \ref{interpretation}. We use the computational information about the domains saved in the interpretation of  to avoid these difficulties. This means that for the construction of set-theoretic models, type systems with judgmental equality are more explicit than systems without it. Using some typical examples, we explain the construction of a set-theoretic interpretation of inductive types and recursive functions. 

Finally, in Section \ref{soundness}, we prove the soundness of our interpretation. The proof itself is relatively simple, and it can also be used to verify the consistency of our system. This is because some types such as  will be interpreted as the empty set; hence, they cannot be inhabited in the type system.

In Section \ref{conclusion}, we summarize the main results, and we discuss related work for future investigation.


\section{Formal presentation of CC with judgmental equality}\label{cc}

First, we provide the full presentation of the system, i.e.,  Coquand's  with judgmental equality and predicative induction over infinitely many cumulative universes.

\subsection{Syntax}
We assume an infinite set of countably many variables, and we let  vary over the variables. We also use special constants  and , . They are called \emph{sorts}. Sorts are usually denoted by  etc.\footnote{In this paper, we do not consider the sort . Indeed, when (the impredicative or predicative sort)  is placed at the lowest level in the hierarchy of sorts, as in the case of the current development of Coq, there is no way to provide a universal set-theoretic interpretation of both  and , as identified by \cite{reynolds}. Note, however, that  in our system plays the role of the predicative .}


\begin{defi}[Terms and contexts]
  The syntax of the objects is given as follows.
.5ex]
  & & \mid \case{t,t',\vec{t}\,} \mid \ind_n\single{\De:=\De'}\cdot x  & \2ex]

\De, \De' & ::= & [\,] \mid \De, (x:t) & (\textit{declarations})\
Here,  denotes the empty sequence.
\end{defi}

\begin{defi}[Atomic terms]
\emph{Atomic terms} are either variables, sorts, or terms of the form .
\end{defi}

\begin{defi}[Domain of contexts]
The domain of a context is defined as follows:

\end{defi}

\begin{remm}\hfill
\begin{enumerate}[(1)]
\item Vector notations are used instead of some sequences of expressions:
-2ex]
\vec t  :=  t_1, ..., t_n &  f\, \vec t := f\, t_1\cdots t_n \1ex]
\multicolumn{2}{|l|}{\bullet\,\,\oto{x / k :A := t} :=  x_0 / k_0 : A_0 := t_0, ...  , x_n / k_n : A_n := t_n}\

\item Note that we use two subscript styles. One is of the form , and the other is of the form , where  is a natural number. The latter style will be used only in the definition of mutually recursive functions, i.e., in combination with .\smallskip

\item Given a sequence , let  denote its length.\smallskip

\item In the examples presented below, character strings are used instead of single character variables in order to emphasize the correspondence with real Coq-expressions.\smallskip

\item Given a declaration  and a variable , let  when  is the only term such that  occurs in .\smallskip

\item There are standard definitions of the sets of free variables in a context or a term, and of the substitution , where  are terms and  a variable. Formal definitions are given in Appendix \ref{A-defi}.\smallskip

\item Given a sequence  and a term , let  denote consecutive substitution. 
On the other hand, the simultaneous substitution of terms  for , respectively, in  is denoted by .

\end{enumerate}
\end{remm}

\noindent To enable the reader to understand the intended meaning of terms and contexts, we explain some notations with examples. The examples will also be used in Section \ref{interpretation} to explain our model.

\begin{remm}\label{rem-treeforest}
  The expression  denotes a \emph{(mutually) inductive type}, and the subscript  denotes the number of \emph{parameters}.  and  are two declarations containing inductive types and their constructors, respectively. The \emph{Parameters} are binders shared by all the constructors of the definition, and they are used to construct polymorphic types.
The parameters differ from other non-parametric binders in that the conclusion of each type of constructor invokes the inductive type with the same parameter values as its specification.
We refer to Lemma \ref{ind-fam} and Lemma \ref{ind-para}, which show the difference between parameters and non-parametric binders.\medskip

The mutual definition of trees and forests can be represented, for instance, by , where

The subscript  implies that  is a parameter.
\medskip
\end{remm}

\begin{remm}\label{rem-nat}
If  and , then  corresponds to the names of defined inductive types or their constructors.\medskip

The type for natural numbers and its two constructors can be represented by 
, and ,
respectively, where , and \,. \medskip

In the examples presented below, however, we use character strings for better readability. Thus, for example, \ttt{nat}, \ttt{0}, and \ttt{S} are used instead of , and , respectively.
\end{remm}

\begin{remm}[\textsf{case} and \textsf{fix}]\label{size}
The term  corresponds to the following Coq-expression
\begin{center}
\ttt{match  as  in  return  with  =>  end}
\end{center}
where
\begin{iteMize}{}
\item the term  is of an inductive type  for some terms ,
\item ,
\item  for some terms , 
\item the term  is a fresh variable bound in ,
\item each  is a constructor of type  for some terms , and
\item each  for some term \,.
\end{iteMize}

The term  denotes the th function defined by a mutual recursion. The number  denotes the position of the inductive binder on which recursion is performed for . It corresponds to Coq's \ttt{struct} annotation used for the \equote{\emph{guarded}} condition in the termination check (cf. \cite{gimenez}).

\begin{enumerate}[(1)]
\item The addition function \ttt{plus} can be defined as follows:
\begin{center}
\,,
\end{center}
where , , and \,. 

\item The functions for measuring the size of trees and forests can be represented by 
 and ,
 where , , and
1ex]
t_0 & = & \la (A:\ttype_0).\, \la (t:\ttt{tree} \, A).\, \case{t, Q_0, h_0}\,, \\
t_1 & = & \la (A:\ttype_0).\, \la (f:\ttt{forest} \, A).\, \case{f, Q_1, h_1, h_2}\,,\\
Q_0  &= & \la (t: \ttt{tree} \, A).\, \tnat\,,\\
Q_1  & = &  \la (f : \ttt{forest}\, A).\, \tnat\,,\\
h_0  & = &  \la (a:A). \la(f: \ttt{forest} \, A).\, \ttt{S}\, (g_1\, A \, f)\,,\\
h_1  & = &  \ttt{O}\,,\\
h_2  & = &  \la (t: \ttt{tree } A).\, \la (f:\ttt{forest } A).\ttt{plus}\,(g_0\, A\, t)\,(g_1\, A \, f).
5ex]

 \hfill \rbm{\infer{\Ga\edash \tprop:\ttype_i}{\wf(\Ga)}}
 \hfill \rbm{\infer{\Ga\edash \ttype_i:\ttype_j}{\wf(\Ga) & i<j}}
 \hfill \5ex]

 \hfill \rbm{\infer{\Ga\edash \lett{x:=t}{u}:U[x\bs t]}
   {\Ga, (x:=t :A)\edash u:U} }
\hfill \5ex]





\hfill \rbm{
  \infer
  {\Ga\edash \Pi x:A.B:s_3}
  {\Ga\edash A:s_1 & \Ga,x:A\edash B:s_2 & \calp(s_1,s_2,s_3)}
}\hfill \5ex]

\hfill \rbm{
  \infer
  {\Ga\edash \la x:A.M:\Pi x:A.B}
  {\Ga, x:A\edash M:B & \Ga\edash \Pi x:A.B:s}    
 } 
\hfill \5ex]



\hfill \rbm{\infer{\Ga\edash MN: B[x\bs N]}
   {\Ga\edash M:\Pi x:A.B & \Ga\edash N:A} } 
\hfill \2ex]
\hline
\end{tabular}
\end{center}
\caption{Basic terms and valid contexts}
\label{fig:basic}
\end{figure}

Typing rules for standard constructions of - and -terms are given.\medskip


\noindent : Well-formed contexts contain well-typed terms, and they can be extended by well-typed inductive types, as in rule  of Figure \ref{fig:inductive}.\medskip

\noindent  and :  implies that
\begin{iteMize}{}
\item , or
\item  and  where .
\end{iteMize}

\subsection*{Typing rules for inductive types and recursive functions (Figure \ref{fig:inductive})}

\begin{figure}[h]
\begin{center}
\begin{tabular}{|p{14.5cm}|}\hline\5ex]

\hfill \rbm{
  \infer
  {\Ga\edash \cald\cdot d : \De_I(d)[.\bs \cald]} 
  {\wf(\Ga) & \cald = \indic{n} \in \Ga & d\in\dom(\De_I)}
}
\hfill \11.5ex]

\hfill \rbm{
  \infer
  {\Ga\edash\case{e,Q,(h_k)_{k}}: Q\, \vec u\, e}
  {\deduce
    {\Ga\edash h_k : \Pi\vec v : \vec V_k.\, Q\, \vec w_k\,(c_k\,\vec p\, \vec v) \text{ for all } (c_k : \Pi\vec p : \vec P.\, \Pi\vec v:\vec V_k.\, d_i\, \vec p\, \vec w_k)\in \De_C}
    {\deduce
      {\Ga\edash Q:B \quad \calc(d_i\,\vec{p}:A ; B) \quad \Ga\edash e : d_i \,\vec{p}\,\vec{u}}
      {\indic{n}\in\Ga & (d_i:\Pi \vec p : \vec P.\, A)\in \De_I & \lh(\vec p)=n }
    }
  }
}
\hfill \5.5ex]

\hfill \rbmm{
  \infer
  {\Ga\edash \fix{f_j}{\oto{f / k : A := t}} : A_j}
  {\calf(\vec f, \vec A, \vec k, \vec t) & n=\lh(\vec k) & (\Ga\edash A_i: s_i)_{\forall i\le n}\quad (\Ga, \vec f : \vec A \edash t_i : A_i)_{\forall i\le n} & j\le n}
}
\hfill \3.5ex]
\hline
\end{tabular}
\end{center}
\caption{Inductive types and recursive functions}
\label{fig:inductive}
\end{figure}

\begin{figure}
\begin{center}
\begin{tabular}{|p{14.5cm}|}\hline\\
 \hfill \rbm{\infer{\Ga\edash M= M:A}{\Ga\edash M:A}}\hfill \rbm{\infer{\Ga\edash N= M:A}{\Ga\edash M=N:A}}\hfill \5ex]

 \hfill \rbm{\infer{\Ga\edash M:B}{\Ga\edash M:A & \Ga\edash A= B:s}}\hfill \rbm{\infer{\Ga\edash M= N:B}{\Ga\edash M= N:A & \Ga\edash A= B:s}}\hfill \5ex]



\hfill \rbm{\infer{\Ga\edash x = t:A}
{\wf(\Ga) & (x:=t:A)\in \Ga} }
\hfill \11ex]

\hfill \rbm{
  \infer
  {\Ga\edash\case{c_j\, \vec p\, \vec a, Q,(h_k)_{k}} = h_j\, \vec a: Q\, \vec{u}\, (c_j\, \vec p\, \vec a)}
  {\deduce
    {\Ga\edash h_k : \Pi\vec v : \vec V_k.\, Q\, \vec{w_k}\,(c_k\,\vec p\, \vec{v}) \text{ for all } (c_k : \Pi\vec p : \vec P.\, \Pi\vec v : \vec V_k.\, d_i\, \vec p\, \vec w_k)\in \De_C}
    {\deduce
      { \Ga\edash Q:B \quad \calc(d_i\,\vec{p}:A ; B) \quad \Ga\edash c_j\, \vec p\, \vec a : d_i \,\vec{p}\,\vec{u} }
      {\indic{n}\in\Ga & (d_i:\Pi \vec p : \vec P.\, A)\in \De_I & \lh(\vec p)=n }
    }
  }
}
\hfill \7ex] 

\hfill  
\hfill \hfill  \5ex]
 
 \hfill \rbm{\infer{\Ga, x:C\edash A\prec B}{\Ga\edash A\prec B & \Ga\edash C:s & x\notin \dom(\Ga)}}\hfill \5ex]

 \hfill \rbm{\infer{\Ga\edash N\prec P}{\Ga\edash M = N:s & \Ga\edash M\prec P}}\hfill \rbm{\infer{\Ga\edash P\prec N}
{\Ga\edash M = N:s & \Ga\edash P\prec M}}\hfill  \2ex]
\hline
\end{tabular}
\end{center}
\caption{Judgmental equality and cumulative type universes}
\label{fig:equality}
\end{figure}

Typing rules for (mutually) inductive types, case distinctions, and (mutually) recursive functions are given.

\noindent : The positivity condition is crucial for defining an inductive type. A term  is an \emph{arity ending in sort} , , if it is convertible to  or a product , where  is an arity ending in sort .  is called an \emph{arity}, , if  is an arity ending in sort  for some sort .

A term  satisfies the \emph{positivity condition} for a variable  when
 for some terms  and
the variable  occurs \emph{strictly positively} in .
A variable  occurs \emph{strictly positively} in  when
\begin{iteMize}{}
\item  does not occur in , or
\item  and  does not occur in .\medskip
\end{iteMize}

Now,  represents the following conditions:
\begin{iteMize}{}
\item All the names contained in the domains of  and  must be mutually distinct and new.


\item All the types of  and  start with the same  products, say, .

\item Any occurrence of some  in  is of the form , which is not applicable any more.
    
\item For all ,  is an arity ending in sort  such that . Thus, we do not use inductive definitions of type . Some propositions defined inductively can be constructed using an impredicative coding. See \cite{girard-proofs,coquand-meta}, and \cite{werner-set} for further details.
    
\item For all ,  is the type of a constructor for an inductive type , i.e.,  is of the form . In this case, the sort  in the third premise of the rule must be .
    
\item  satisfies the positivity condition for all .\smallskip
\end{iteMize}

\noindent\textbf{Notation.}
We use  when all the premises of  are satisfied.\bigskip
    
\noindent  and : Given  and a term ,  implies that every occurrence of  in  is replaced with .\medskip

\noindent  and :  and  denote  and , respectively. Furthermore, .\medskip

For an inductive type  and an arity , the relation  is defined as follows:
    \begin{iteMize}{}
    \item ;
   \item  iff  is an inductive type that is empty or has only one constructor\footnote{This reflects the fact that no pattern matching is allowed on proof-terms, which would otherwise result in a paradox, as shown by \cite{coquand-meta}.}
    such that all the non-parametric arguments are of sort ;
    \item  for any sort ;
    \item  iff .
    \end{iteMize}
This means that an object of the inductive type  can be eliminated for proving a property  of type . Let  denote , where  is the type of .\medskip

\noindent  and :
 represents the following conditions:
\begin{iteMize}{}
\item ,



\item for each , there is an inductive type , where , and a term  such that 
  \begin{iteMize}{}
  \item , where , and
    
  \item there is a \emph{constrained derivation} with respect to  and  such that
    
    where  is the context composed of
    
    if  is from   and .\medskip
  \end{iteMize}
  
  The condition for \emph{constrained derivation} ensures that the constructed terms are normalizing terms. A formal definition is given in Appendix \ref{constraint}. Informally, it means that  can only contain decreasing recursive calls: if  appears in , then it must have at least  arguments, and its th argument must be structurally smaller than the initial inductive argument  Thus, any subterm of an inductive term obtained by going through at least one constructor is structurally smaller than the initial term..
\end{iteMize}


\subsection*{Judgmental equality and type universes (Figure \ref{fig:equality})}
The rules in Figure \ref{fig:equality} stipulate that the judgmental equality based on reductions is an equivalence relation. De Bruijn's {\it telescope} notation is very useful:  with  implies that
\begin{iteMize}{}
\item  for all , and

\item  for all .
\end{iteMize}



\section{Set-theoretic model construction}\label{interpretation}

\subsection{Background}
We must resolve a dilemma related to the construction of a set-theoretic model of CC and its extensions. In a proof-irrelevant model, each type expression should have an obvious set-theoretic interpretation; however, it is well known that impredicative or polymorphic types, such as , can only have a trivial set-theoretic interpretation, as shown by \cite{reynolds}. Hence, it is necessary to assign a singleton or the empty set to each term of type . 

In constructing a set-theoretic model of Coquand's CC, \cite{miwe} provided the following solution. Under the assumption of the existence of a urelement  that does not belong to the standard universe of set theory, the sort  is associated with . Furthermore, the application and -abstraction terms are interpreted by  and , respectively, which are defined as follows:


\begin{rem}\label{counter-subtyping}
This construction does not correctly model the cumulative relation between  and , as demonstrated in the following example; \cite{werner-proof} showed that it can be easily extended to the cumulative type universes when the subtyping relation between  and  does not exist\smallskip

Consider . Then, its type of set-theoretic interpretation is not deterministic. Suppose that  is a true proposition. Then,  depends on the type we have assigned to , that is,  or . In the former case,  since  is a tautology, whereas in the latter case,  since . 
\end{rem}

Another solution was provided by \cite{aczel-relating}. He used the trace encoding of functions in order to provide an adequate interpretation of the impredicative type  of propositions and its relationship with . For this reason, we adopt Aczel's solution.

\begin{defi}[Trace encoding of set-theoretic functions]
Let  denote sets. Then,

\end{defi}

Note that for any function  and any , we have


\noindent\textbf{Notations.}
\begin{enumerate}[(1)]
\item In the remainder of this paper,  is used if something is well defined, and  is used otherwise.
\item Given sets , , let  denote the set of all functions  such that  and  for all .

\item Given a function , we use the notation  (resp. and ) for the -times application of  (resp. ):

\end{enumerate}

We suppress the subscript  when the number of times we want to apply  or  is obvious from the context. Note that  and .
\begin{lem}[\cite{aczel-relating}]\label{A-poly}
Given a set , assume  for all .
\begin{enumerate}[\em(1)]
\item .
\item  iff\, .
\end{enumerate}
\end{lem}
\begin{proof}
Let , i.e.,
  
  Then, we have
  
  This also implies that  iff .
\end{proof}

\begin{rem}
A useful feature of trace encoding is that  and  are always defined for any sets , including the empty set. This, however, implies that we sometimes lose the information of the domain of a given function , i.e., we cannot trace back to  starting from . We will see that the use of judgmental equality enables us to avoid such a loss when only well-typed terms are involved.
\end{rem}

\subsection{Inductive types and rule sets}

Here, we follow the approaches of \cite{aczel-relating} and \cite{dybjer} for the construction of a set-theoretic interpretation of inductive types. We are particularly interested in \emph{rule sets}.

We are going to work on the basis of ZF set theory with an axiom guaranteeing the existence of countably many (strongly) inaccessible cardinals. Note that such an axiom is independent of ZFC. \cite{werner-set} showed that such an axiom is sufficient for a set-theoretic interpretation of the cumulative type universes and predicatively inductive types.
However, it is not clear whether this axiom is necessary for our construction. Indeed, the required feature of an inaccessible cardinal  is the closure property of the universe  under the powerset operation. This is a necessary condition for the interpretation of inductive types.

Henceforth, assume that there are countably many (strongly) inaccessible cardinals. Let  and ,  ... enumerate these inaccessible cardinals. We associate each sort  with its . If  denotes the (standard) universe of sets defined as follows, then  is a model of ZF:

 denotes the class of all ordinals,  denotes a limit ordinal, and  denotes the power set operator. In particular, if  is an inaccessible cardinal, , and for every , , then, . Let  and  for convenience.  Refer to \cite{drake} for further details about inaccessible cardinals.

A \emph{rule} on a base set  is a pair of sets , often written as , such that  and . A set of rules on  is called a \emph{rule set} on . Given a rule set  on , a set  is -closed if for any ,  whenever . Note that there is the least -closed set

In fact, it is well known that each rule set  on  generates a monotone operator on 

such that  is the least fixed point of . Assuming that  is a rule set on ,  defines a family  of sets in  over  as

for each . 

A rule set is \emph{deterministic} provided that it contains at most one rule with a given conclusion. The rule sets  defined below by an inductive definition are deterministic. This makes it possible to interpret functions defined by structural recursion on a certain inductive type as set-theoretic functions. The interpretations are defined on the corresponding set-theoretic inductively defined set, which is the fixpoint of a monotone operator. Refer to \cite{aczel-induction} and \cite{moschovakis74,moschovakis} for further details about rule sets, monotone operators, and fixpoints.

Below, we describe the interpretations of inductive and recursive types with some examples. Given a well-defined (mutually) inductive type , where

let . \bigskip

\noindent\textbf{Notations.}
\begin{enumerate}[(1)]
\item With each context , we associate a set  of -{\it valuations} of the form , where  is the length of  and  denotes a sequence of  a finite length. Given a sequence  and a natural number , we set
. If  itself is a sequence of length , then we write  for  if , etc.

\item  vary over single values while  vary over valuations.  denotes the empty sequence. Given two valuations  and  , the notation  denotes their concatenation. If , then we write  instead of .

\item With each pair  formed by a context  and a term , we associate a function   that is partially defined on -valuations:  denotes  when .

\item In the following, we write  for  if  and  are fixed in the context. Similarly, we use the notation  for , ...,  for some context  and -valuation .
\end{enumerate}

\subsection{Interpretation of inductive types}\label{int-ind}

Here, we claim the existence of the interpretations of inductive types that satisfy the soundness of the rules  and  when the conditions in the typing rules are fullfilled. The formal definition is given in Appendix \ref{A-inductive}. Refer to \cite{dybjer}, whose idea is generalized in this paper.

\begin{lem}
  Suppose , where . Let  be given. As mentioned before, we suppress  and  for better readability. Further suppose that 
2ex]
  A_i  :=  \Pi\vec p : \vec P.\, \Pi\vec b_i : \vec B_i .\, s_i\,,\,\,
  T_k  := \Pi\vec p : \vec P.\, \Pi\vec z_k : \vec Z_k.\, d_{i_{k}}\, \vec p\, \vec t_k \,.
\end{array}

  \displaystyle \Phi_{\ttt{nat}}  & = & 
  \Bigg \{ \frac{\varnothing}{\cons{0, \cons{1} } }\Bigg \}\,\,\cup\,\, 
  \Bigg \{ \frac{\single{v } }{\cons{0, \cons{2,v} } }
  \,\, \Big\lvert\,\, 
  v\in \calv_{\ka_0} \Bigg \}\,,

  \De_I & := & \ttt{toto}\,:\ttype_1\to \ttype_1\,,\\
  \De_C & := & \ttt{Y}_1: \Pi x:\ttype_1.\, \ttt{toto}\,\, x, \quad \ttt{Y}_2: \Pi x:\ttype_1.\, \ttt{toto}\,\, \tnat \to \ttt{toto}\,\, x\to \ttt{toto}\,\,\, x\,.

  \Phi_{\ttt{toto}} =
  \Bigg \{ 
  \frac{\varnothing}{\cons{0, x,\cons{1,x} } } 
  \,\,\Big\lvert \,\, x\in\calv_{\ka_1} \Bigg \}
  \,\, \cup \,\,
  \Bigg \{ \frac{\single{\cons{0, \lrbk{\tnat}, v_1}, \cons{0, x, v_2} } }
                       {\cons{0, x,\cons{2,x, v_1, v_2 } } }
    \,\, \Big\lvert\,\, 
  x,  v_1, v_2\in \calv_{\ka_1} \Bigg \}\,,

  \De_I & := & \ttt{titi}\,:\ttype_1\to \ttype_0\,,\\
  \De_C & := & \ttt{Z}_1: \Pi x:\ttype_1.\, \ttt{titi}\,\, x, \quad  \ttt{Z}_2: \Pi x:\ttype_1.\, \ttt{titi}\,\, \tnat \to \ttt{titi}\,\, x\to \ttt{titi}\,\, x\,.

  \Phi_{\ttt{titi}} = 
  \Bigg \{ 
  \frac{\varnothing}{\cons{0, x,\cons{1}} } 
  \,\,\Big\lvert \,\, x\in\calv_{\ka_1} \Bigg \}\,\, \cup  \,\,\Bigg \{ \frac{\single{\cons{0, \lrbk{\tnat}, v_1}, \cons{0, x, v_2} } }
    {\cons{0, x,\cons{2, v_1, v_2 } } }
    \,\, \Big\lvert\,\, 
  x\in\calv_{\ka_1},\,\, v_1, v_2\in \calv_{\ka_0} \Bigg \}\,,

  \displaystyle \Phi & := & 
  \Bigg \{ \frac{\single{\cons{1, A, v_1} } }{\cons{0, A, \cons{1,a, v_1 } } }
  \,\, \Big\lvert\,\,  A, v_1\in \calv_{\ka_0}, a\in A \Bigg \}\
\end{bsp}


\subsection{Interpretation of well-founded structured recursion}\label{int-rec}


A set defined by a (mutual) induction generates a canonical well-founded relation on the set, i.e., the relation defined according to the inductive construction of the elements, the so-called {\em structurally-smaller-than-relation}. This is the basis for the discipline of structural recursion, which stipulates that recursive calls consume structurally smaller data. 


Here, we claim the existence of the interpretations of recursive types that satisfy the soundness of the rules , , and . A formal definition  is given in Appendix \ref{A-recursion}. Refer to \cite{dybjer}, whose study provides the basic idea.

\begin{lem}
Suppose , where
2ex]
(\Ga\edash A_i: s_i)_{\forall i\le n}, \quad (\Ga, \vec f : \vec A \edash t_i : A_i)_{\forall i\le n}, \quad \calf(\vec f, \vec A, \vec k, \vec t) \,.
\end{array}

B &  = & \Pi (A:\ttype_i).\, \Pi (g:A).\, \Pi (h:\tnat\to A \to A).\, \Pi (n:\tnat).\,\tnat\,, \\
t & = & \la (A:\ttype_i).\, \la (g:A).\, \la (h:\tnat\to A \to A).\, \la (n:\tnat).\, \case{n,P,h_1, h_2}\,,

  & &\Bigg \{ \frac{\varnothing}{\cons{A, g, h,\cons{1}, g}}\,\,\Big\lvert\,\, A\in \calv_{\ka_i}, g \in A, h\in \lrbk{\tnat \to A \to A} \Bigg \}\\
& & \,\,\cup\,\, 
\Bigg \{ \frac{\single{\cons{A, g, h,p, v}}}{\cons{A, g, h, \cons{2,p}, \vec \app(h, p, v) }}\,\, \Big\lvert \,\, A\in \calv_{\ka_i}, g \in A, h\in \lrbk{\tnat \to A \to A}, p \in \lrbk{\tnat}, v\in A \Bigg \}\,.

\vec \app(\lrbk{\ttt{plus}}, m, n )= \calif(\ttt{Prec})(\lrbk{\tnat}, m, \lrbk{h}, n)

  & & \Bigg \{ \frac{\single{\cons{A, f, v'}} }
  {\cons{A, \cons{1, a, f}, \lrbk{\ttt{S}\, v'}} }\,\,
  \Big\lvert\,\, 
  A \in \calv_{\ka_0}, f\in \app(\lrbk{\ttt{forest}}, A), v' \in \lrbk{\tnat}, a\in A \Bigg \}\\
  & & \,\,\cup\,\, 
  \Bigg \{ \frac{\varnothing }
  {\cons{A, \cons{2}, \lrbk{\ttt{O}}} }\,\,
  \Big\lvert\,\, 
  A \in \calv_{\ka_0} \Bigg \}\\
  & & \,\,\cup\,\, 
  \Bigg \{ \frac{\single{\cons{A, t, v_1' }, \cons{A, f', v_2' } }}
  {\cons{A, \cons{3, t, f'}, \app(\lrbk{\ttt{plus}}, v_1', v_2')} }\,\,\Big\lvert \,\,  A\in \calv_{\ka_0}, t \in \app(\lrbk{\ttt{tree}}, A), \\
& & \hspace{6.7cm} f' \in \app(\lrbk{\ttt{forest}}, A), v_1', v_2' \in \lrbk{\tnat}\Bigg \}\,.

  \lrbk{[\,]} & :=  \{\texttt{nil}\}, \.3ex]
  \lrbk{\Ga, x:=t:A} & :=  \menge{\ga,\al}{\ga\in\lrbk{\Ga},\, \lrbk{\Ga\vd A}_\ga\downarrow,\, \lrbk{\Ga\vd t}_\ga\downarrow\\
    & \hspace*{1cm}\hfill \text{ and } \al=\lrbk{\Ga\vd t}_{\ga}  \in \lrbk{\Ga\vd A}_\ga }, \



\item The interpretation  of a term  in a context  is a partial function defined on : Given ,


\noindent  If , then the occurrence should be unique.

\noindent   could be any term with the given property since the interpretation, when defined, is independent of it. 
  \end{enumerate}

\end{defi}

The following lemma is crucial for the soundness proof.

\begin{lem}[Substitutivity]\label{substitution}
Let  be a context and let  be terms such that  for some  (assuming that both of them are defined), and write \,.
\begin{enumerate}[\em(1)]
\item Suppose . Then, .
\item Suppose  and . Then,
  \begin{iteMize}{}
  \item .
  \item \,.
  \end{iteMize}
\end{enumerate}
\end{lem}
\begin{proof}
The assertions are proved for each  and  by a mutual induction on the size of their arguments. In particular, given , the first assertion is proved before the second one for all . In the case of , the claims are obvious. Assume that  and . The other cases can be considered similarly.
\begin{enumerate}[(1)]
\item . Then, using the I.H. of the second claim, we have
  
That is, . 

\item We proceed by induction on . If , the claim follows because  implies that  and . This is because the interpretation of  does not depend on . Other cases can be easily shown by using induction hypotheses.
\end{enumerate}
\end{proof}

\begin{thm}[Soundness]\label{thm-soundness} Our type system is sound with respect to the set-theoretic interpretation defined in Definition \ref{def-interpretation} in the following sense:
\begin{enumerate}[\em(1)]
\item If , then  is defined.
\item If , then  is defined, and for any , it holds that  and  are defined, and that

\item If , then  is defined, and for any , it holds that , , and  are defined, and that

\item If , then  is defined, and for any , it holds that  and  are defined, and that

\end{enumerate}
\end{thm}
\begin{proof}
  We proceed by a simultaneous induction over the typing derivation. The cases , and  are obvious.\medskip

\noindent  Suppose

By I.H., it holds that  and  for all . Now, we need to show that 

If , then Lemma \ref{A-poly} implies the claim. Assume , and . Then, , where  is the th inaccessible cardinal; hence,  is closed under the power set operation.\medskip

\noindent The cases , , and  are obvious.\medskip


\noindent  Suppose 

By induction hypothesis, it holds that  and  for some function  with  and  for any . Thus, we have

The cases , , and  are similar.\medskip

The soundness of , , and  are obvious from the interpretation constructions. The interpretations of inductive types and constructors are possible because of the induction hypotheses. This is the same for , , , and .\medskip

\noindent The cases , , , and  are obvious.\medskip

\noindent  Suppose

It remains to show that :

by Lemma \ref{substitution} because we know that  by induction hypothesis. The judgmental equality plays a crucial role in this case.\medskip

The case  is obvious, and the case  follows from Lemma \ref{substitution} and induction hypothesis. The case  is obvious by definition. The cumulativity rules are obviously sound. Finally, the soundness of the the constrained typing rules in Figure \ref{fig:constraint} follows directly from the arguments stated above. 
\end{proof}

\begin{thm}[Consistency]
  There is no term  such that \,.
\end{thm}
\begin{proof}
 Note that  \,.
\end{proof}

\section{Conclusion}\label{conclusion}
We identified some critical issues in constructing a set-theoretic, proof-irrelevant model of CC with cumulative type universes. Our construction reconfirmed that proof-irrelevance is a subtle and difficult subject to tackle when it is combined with the subtyping of the universes, in particular, . We showed that the set-theoretic interpretation can be relatively easy when we work with judgmental equality. We believe that our study provides a (relatively) easy way for justifying the correctness of type theory in Martin-L\"of-styled, i.e., with simple model and, in particular, no proof of the strong normalization, which is usually very difficult to establish.

Besides the historical importance of Martin-L\"of-style type theory and the technical difficulties with external -reduction, there is another theoretical and practical reason for studying type systems with judgmental equality. In general, the equivalence of two systems with or without judgmental equality remains an open problem. Proving the equivalence of two systems with or without judgmental equality is not a simple task, even though some positive results have been achieved by \cite{coquand-algo}, \cite{goguen-phd, goguen-sound}, \cite{adams-eq}, and \cite{siles}. However, they are not sufficiently general to cover the case with cumulative type universes. Although \cite{adams-eq} mentioned that it might be possible to extend his proof to more general systems with unique principal types instead of type uniqueness as in the case of Luo's ECC \citep{luo-ecc, luo-utt} and Coquand's CIC, it still remains an open question.

A positive consequence of the work of \cite{adams-eq} and \cite{siles} is that the failed attempt of \cite{miwe}, i.e., without using sorted variables, would work if one first considers the system CC with judgmental equality and uses its equivalence to the usual CC. This is indeed the case for the model construction described in this paper, where we restrict the model construction to CC.


\section*{Acknowledgment}
We would like to express our sincere gratitude to Hugo Herbelin and Bruno Barras for their insightful discussions and advice. We would also like to thank the anonymous referees whose comments enabled us to improve this paper significantly.





\bibliographystyle{plain}
 \begin{thebibliography}{[10]}
\providecommand{\natexlab}[1]{#1}
\providecommand{\url}[1]{\texttt{#1}}
\expandafter\ifx\csname urlstyle\endcsname\relax
  \providecommand{\doi}[1]{doi: #1}\else
  \providecommand{\doi}{doi: \begingroup \urlstyle{rm}\Url}\fi

\bibitem[Aczel(1977)]{aczel-induction}
Peter Aczel.
\newblock An introduction to inductive definition.
\newblock In Jon Barwise, editor, \emph{Handbook of Mathematical Logic}, pages
  739--782. North-Holland, 1977.

\bibitem[Aczel(1998)]{aczel-relating}
Peter Aczel.
\newblock On relating type theories and set theories.
\newblock In \emph{Proceedings of Types '98}, volume 1657 of \emph{Lecture
  Notes in Comput. Sci.}, pages 1--18. Springer, 1998.

\bibitem[Adams(2006)]{adams-eq}
Robin Adams.
\newblock Pure type systems with judgemental equality.
\newblock \emph{J. Funct. Program.}, 16\penalty0 (2):\penalty0 219--246, 2006.

\bibitem[Bertot and Cast\'eran(2004)]{coqman}
Yves Bertot and Pierre Cast\'eran.
\newblock \emph{Interactive Theorem Proving and Program Development. Coq'Art:
  The Calculus of Inductive Constructions}.
\newblock Springer Verlag, 2004.

\bibitem[Coquand(1990)]{coquand-meta}
Thierry Coquand.
\newblock {Metamathematical Investigation on a Calculus of Constructions}.
\newblock In P.~Odifreddi, editor, \emph{Logic and Computer Science}, volume 31
  of APIC series, pages 91--122. Academic Press, 1990.

\bibitem[Coquand(1991)]{coquand-algo}
Thierry Coquand.
\newblock An algorithm for testing conversion in type theory.
\newblock In \emph{Logical frameworks}, pages 255--279. Cambridge University
  Press, 1991.

\bibitem[Drake(1974)]{drake}
Frank~R. Drake.
\newblock \emph{Set Theory: An Introduction to Large Cardinals}, volume~76 of
  \emph{Studies in logic and the foundations of mathematics}.
\newblock North Holland, 1974.

\bibitem[Dybjer(1991)]{dybjer}
Peter Dybjer.
\newblock Inductive sets and families in {M}artin-{L}\"of's type theory and
  their set-theoretic semantics.
\newblock In \emph{Logical frameworks (Sophia-Antipolis, 1990)}, pages
  280--306. Cambridge Univ. Press, 1991.

\bibitem[Dybjer(2000)]{dybjer00}
Peter Dybjer.
\newblock {A General Formulation of Simultaneous Inductive-Recursive
  Definitions in Type Theory}.
\newblock \emph{J. Symb. Log.}, 65\penalty0 (2):\penalty0 525--549, 2000.

\bibitem[Gim{\'e}nez(1995)]{gimenez}
Eduardo Gim{\'e}nez.
\newblock Codifying guarded definitions with recursive schemes.
\newblock In \emph{Types for proofs and programs (B\aa stad, 1994)}, volume 996
  of \emph{Lecture Notes in Comput. Sci.}, pages 39--59. Springer, 1995.

\bibitem[Girard et~al.(1989)Girard, Taylor, and Lafont]{girard-proofs}
Jean-Yves Girard, Paul Taylor, and Yves Lafont.
\newblock \emph{Proofs and types}, volume~7 of \emph{Cambridge Tracts in
  Theoretical Computer Science}.
\newblock Cambridge University Press, 1989.

\bibitem[Goguen(1994)]{goguen-phd}
Healfdene Goguen.
\newblock \emph{A {T}yped {O}perational {S}emantics for {T}ype {T}heory}.
\newblock PhD thesis, University of Edinburgh, 1994.

\bibitem[Goguen(1999)]{goguen-sound}
Healfdene Goguen.
\newblock {Soundness of the Logical Framework for Its Typed Operational
  Semantics}.
\newblock In \emph{Typed Lambda Calculi and Applications, TLCA'99}, pages
  177--197, 1999.

\bibitem[Letouzey(2004)]{letouzey}
Pierre Letouzey.
\newblock \emph{Programmation fonctionnelle certifi{\'e}e -- L'extraction de
  programmes dans l'assistant {Coq}}.
\newblock PhD thesis, Universit{\'e} Paris-Sud, July 2004.

\bibitem[Luo(1989)]{luo89-lics}
Zhaohui Luo.
\newblock Ecc, an extended calculus of constructions.
\newblock In \emph{LICS}, pages 386--395. IEEE Computer Society, 1989.

\bibitem[Luo(1990)]{luo-ecc}
Zhaohui Luo.
\newblock \emph{An {E}xtended {C}alculus of {C}onstructions}.
\newblock PhD thesis, University of Edinburgh, November 1990.

\bibitem[Luo(1994)]{luo-utt}
Zhaohui Luo.
\newblock \emph{Computation and reasoning: a type theory for computer science},
  volume~11 of \emph{International Series of Monographs on Computer Science}.
\newblock Oxford University Press, Inc., 1994.

\bibitem[Martin-L{\"o}f(1984)]{ml-84}
Per Martin-L{\"o}f.
\newblock \emph{Intuitionistic type theory}, volume~1 of \emph{Studies in Proof
  Theory. Lecture Notes}.
\newblock Bibliopolis, 1984.

\bibitem[Miquel and Werner(2003)]{miwe}
Alexandre Miquel and Benjamin Werner.
\newblock The not so simple proof-irrelevant model of {CC}.
\newblock In \emph{Types for proofs and programs}, volume 2646 of \emph{Lecture
  Notes in Comput. Sci.}, pages 240--258. Springer, 2003.

\bibitem[Moschovakis(1974)]{moschovakis74}
Yiannis~N. Moschovakis.
\newblock \emph{Elementary induction on abstract structures}, volume~77 of
  \emph{Studies in logic and the foundations of mathematics}.
\newblock North Holland, 1974.

\bibitem[Moschovakis(1980)]{moschovakis}
Yiannis~N. Moschovakis.
\newblock \emph{Descriptive set theory}, volume 100 of \emph{Studies in logic
  and the foundations of mathematics}.
\newblock North Holland, 1980.

\bibitem[Nordstr\"om et~al.(1990) Nordstr\"om, Petersson, and Smith]{nordstroem}
Bengt Nordstr\"om, Kent Petersson, and Jan~M. Smith.
\newblock \emph{{Programming in Martin-L\"of's type theory: An introduction.}}
\newblock Oxford University Press, 1990.

\bibitem[Paulin-Mohring(1996)]{pm-habili}
Christine Paulin-Mohring.
\newblock \emph{D\'{e}finitions {I}nductives en {T}h\'{e}orie des {T}ypes
  d'{O}rdre {S}up\'{e}rieur}.
\newblock Habilitation \'{a} diriger les recherches. Universit\'{e} Claude
  Bernard Lyon I, 1996.

\bibitem[Reynolds(1984)]{reynolds}
John~C. Reynolds.
\newblock Polymorphism is not set-theoretic.
\newblock In \emph{Semantics of Data Types}, volume 173 of \emph{Lecture Notes
  in Comput. Sci.}, pages 145--156. Springer, 1984.

\bibitem[Siles and Herbelin(2010)]{siles}
Vincent Siles and Hugo Herbelin.
\newblock Equality is typable in semi-full pure type systems.
\newblock In \emph{LICS}, pages 21--30, 2010.

\bibitem[Werner(1997)]{werner-set}
Benjamin Werner.
\newblock {Sets in Types, Types in Sets}.
\newblock In \emph{Theoretical Aspects of Computer Software}, volume 1281 of
  \emph{Lecture Notes in Comput. Sci.}, pages 530--546. Springer, 1997.

\bibitem[Werner(2008)]{werner-proof}
Benjamin Werner.
\newblock On the strength of proof-irrelevant type theories.
\newblock \emph{Logical Methods in Computer Science}, 4\penalty0 (3), 2008.

\end{thebibliography}






\appendix
\section{Definition of free variables and substitution}\label{A-defi}

The definitions of the sets of free variables in a context or term are standard. 

 By using -conversion, if needed,  is assumed to be not free in  such that the variable condition is satisfied.

\noindent  The variable condition here implies that the names of inductive types, constructors, and recursive functions are uniquely determined, and that they will never be changed once they are defined. Thus, these names are bound variables that differ from variables bound by  and .


\section{Constrained typing}\label{constraint}
\begin{figure}[t]
\begin{center}
\noindent \begin{tabular}{|p{14.5cm}|}\hline \4ex]

\hfill \rbm{ \infer{ \wf(\Ga, x:^\consc M)}
{\Ga\edash M: s } } 
 \hfill
\rbm{ \infer{ \Ga\edash x:^\consc A} 
  {\wf(\Ga) & x:^\consc A\in\Ga } }
\hfill \rbm{ \infer{ \Ga\edash t:^\epsilon A} 
  {\Ga\edash t:^\consc A } }
 \hfill \4ex]
 
 \hfill \rbm{\infer{\Ga\edash \Pi x:^\consc A.B= \Pi x:^\consc A'.B':^\epsilon s_3}
   {\Ga\edash A= A':^\epsilon s_1 & \Ga,x:^\consc A\edash B= B':^\epsilon s_2 & \calp(s_1,s_2,s_3)} }
\hfill \7ex]

\hfill \rbm{\infer{\Ga\edash \la x:^\consc A.M = \la x:^\consc A'.M':^\consd \Pi x:^\consc A.B}
  {\deduce{\Ga, x:^\consc A\edash M= M':^\consd B}
    {\Ga\edash A= A':^\epsilon s_1 & \Ga,x:^\consc A\edash B:^\epsilon s_2} } }
\hfill \4ex] 

 \hfill \rbm{\infer{\Ga\edash MN= M'N':^\consd B[x\bs N]}
   {\Ga\edash M= M':^\consd\Pi x:^\consc A.B & \Ga\edash N= N:^\consc A} }
\hfill \
  <\epsilon := \epsilon\,,\qquad <\equ z := \sma z\,,\qquad <\sma z  := \sma z\,.

([\,])^{<\! z} & := [\,], \\
(\De, x:A)^{<\! z} & := \De^{<\! z}, x:^{\epsilon} A \quad\,\,\, \text{if } FV(A) \cap \dom(\De_I, \De_C) = \varnothing, \\
(\De, x:A)^{<\! z} & := \De^{<\! z}, x:^{<\! z} A \quad \text{if } FV(A) \cap \dom(\De_I, \De_C) \neq \varnothing.

\begin{array}{c}
  \De_I := d_0:A_0,..., d_\ell:A_\ell\,,\,\,
  \De_C := c_1:T_1,..., c_m:T_m\,, \
where ,
,
,  
, and 
\,. 
Furthermore,  is defined as
1ex]
           \Pi \vec u_{k,j} : \vec H_{k,j} .\, d'_{i_{k,j}} & \text{ if }j\in\nu_k,
         \end{array}\right .

\bigcup_{i\le \ell}\,\, \bigcup_{k \in \mu_i} 
\Bigg \{
  \frac{\bigcup_{j\in\nu_k} \menge{\cons{i_{k,j} , \vec p, \lrbk{\vec w_{k,j}}_{\vec p, \vec z_k, \vec u}, \vec\app (z_{k,j}, \vec{u}\, )} }   
      {\vec{u}\in\lrbk{\vec H_{k,j}}_{\vec p, \vec z_k} }} 
    {\cons{i,\vec p, \lrbk{\vec t_{k}}_{\vec p, \vec z_k}, \cons{k, \vec z_k} }} 
  \,\,\,\,\Big \lvert\,\,  \vec p, \vec z_k \in \lrbk{\vec P}, \lrbk{\vec Z'_k}_{\rho_k} 
\Bigg \}\,.

\begin{array}{c}
R := \oto{f / k : A := t}, \quad A_i\equiv \Pi \vec x_i : \vec B_i.\, A'_i, \quad \lh(\vec B_i)=k_i+1, \quad \ell\le n, \
Let  be given. We suppress  and  for better readability. Then,  will depend on the -reduction. 

Suppose , where , and , i.e., , and that  are all fresh variables, while  represents a branch in the tree-like structure. All the free variables occurring in  should be fresh. Then,  -, -reduces to the term  which is obtained from the node term of the branch which  represents. 

Suppose that for some ,  list all the subterms of  that are structurally smaller than . Each  with   occurs as the th argument of . Thus,

is a subterm of  for some . Note that each  is an argument of some constructor  such that the head of  is of some type  and that  if . Furthermore, we suppose that  are all terms among , which are headed by some variables.


Thus,  for a variable  of type  

and for some terms . Note that  are exactly the free variables occurring in . Suppose that  are all such terms structurally smaller than . Then,

for some . Similarly,  can be written as follows:

where 

Further, set

of type 
,
where  ranges over .
Lastly, let  be obtained from  by replacing  with a fresh variable .\smallskip

Then,  will  correspond to the fixpoint of the following rule set:
1ex]
  & & \hspace{1.9cm} \vec \al \in \lrbk{B_{\ell,1}},...,\lrbk{B_{\ell,k_\ell}},\\
& & \hspace{1.9cm} v_{q_r} \in \lrbk{\Pi \vec{u}_{m_{q_r},j_{q_r}}: \vec H_{m_{q_r},j_{q_r}} .\, x_{i_{m_{q_r},j_{q_r}}}\, \vec p\,\, \vec{w}_{m_{q_r},j_{q_r}} },\\
  & & \hspace{1.9cm} \text{ associates  to ,  to , ,}\\
& & \hspace{1.9cm} v'_{q} \in \lrbk{(\Pi \vec u_{m_{q_{r_c}},j_{q_{r_c}}}  : \vec H_{m_{q_{r_c}},j_{q_{r_c}}})_c .\, 
  A'_{n_q}\single{\vec x_{n_q} : \vec b_{n_q}, u'_q} }_{\rho},\\
& & \hspace{1.9cm} \text{ associates  to ,  to , , and  to }.
\Bigg \} 

h(a_1,...,a_{k_\ell},\cons{k,\vec z_k}) = \calif (\Psi) (a_1,...,a_{k_\ell},\cons{k,\vec z_k})

where .



\end{document}
