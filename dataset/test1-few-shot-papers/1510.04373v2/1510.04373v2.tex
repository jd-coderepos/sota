\newcommand{\CLASSINPUTinnersidemargin}{0.5in} \newcommand{\CLASSINPUToutersidemargin}{0.5in} \newcommand{\CLASSINPUTtoptextmargin}{0.5in}   \newcommand{\CLASSINPUTbottomtextmargin}{0.5in}

\documentclass[10pt,journal,compsoc]{IEEEtran}
\ifCLASSOPTIONcompsoc
  \usepackage[nocompress]{cite}
\else
  \usepackage{cite}
\fi

\ifCLASSINFOpdf
\else
 
\fi
\hyphenation{op-tical net-works semi-conduc-tor}


\usepackage{times,graphicx,amsthm,comment,algorithm,algorithmic,amsmath,amsfonts,hyperref, mathtools, url, color, subfigure}
\usepackage{enumitem}



\DeclareMathOperator*{\Tr}{Tr}
\DeclareMathOperator*{\expec}{\mathbb E}
\newcommand{\MMD}{\text{MMD}}
\DeclareMathOperator*{\diag}{diag}
\DeclareMathOperator*{\argmax}{argmax}
\DeclareMathOperator*{\argmin}{argmin}
\DeclareMathOperator*{\cov}{Cov}
\DeclareMathOperator*{\var}{Var}
\DeclareMathOperator*{\hyp}{{Hyp}}
\DeclareMathOperator*{\disc}{\mathrm{disc}}
\DeclareMathOperator*{\spn}{\mathrm{span}}
\DeclareMathOperator*{\discl}{\mathrm{disc}_{\ell}}
\DeclareMathOperator*{\disclb}{\mathrm{disc}_{\textrm{L}_b}}
\DeclareMathOperator*{\radem}{\mathfrak{R}}

\newcommand{\theHalgorithm}{\arabic{algorithm}}

\renewcommand{\algorithmicrequire}{\textbf{Input:}}
\renewcommand{\algorithmicensure}{\textbf{Output:}}

\newcommand{\DBA}[1]{{\bf\color{red} [DBA: #1]}}
\newcommand{\GIF}[1]{{\bf\color{red} [GIF: #1]}}

\newcommand{\cC}{{\mathcal C}}
\newcommand{\cD}{{\mathcal D}}
\newcommand{\cF}{{\mathcal F}}
\newcommand{\cH}{{\mathcal H}}
\newcommand{\cI}{{\mathcal I}}
\newcommand{\cL}{{\mathcal L}}
\newcommand{\cM}{{\mathcal M}}
\newcommand{\cX}{{\mathcal X}}
\newcommand{\cY}{{\mathcal Y}}
\newcommand{\ba}{{\mathbf a}}
\newcommand{\bb}{{\mathbf b}}
\newcommand{\bB}{{\mathbf B}}
\newcommand{\bh}{{\mathbf h}}
\newcommand{\bH}{{\mathbf H}}
\newcommand{\bI}{{\mathbf I}}
\newcommand{\bK}{{\mathbf K}}
\newcommand{\bL}{{\mathbf L}}
\newcommand{\bm}{{\mathbf m}}
\newcommand{\bM}{{\mathbf M}}
\newcommand{\bN}{{\mathbf N}}
\newcommand{\bP}{{\mathbf P}}
\newcommand{\bQ}{{\mathbf Q}}
\newcommand{\bS}{{\mathbf S}}
\newcommand{\bt}{{\mathbf t}}
\newcommand{\bT}{{\mathbf T}}
\newcommand{\bW}{{\mathbf W}}
\newcommand{\bx}{{\mathbf x}}
\newcommand{\bX}{{\mathbf X}}
\newcommand{\bz}{{\mathbf z}}
\newcommand{\bZ}{{\mathbf Z}}


\newcommand{\bmu}{\boldsymbol{\mu}}

\newcommand{\bbI}{{\mathbb I}}
\newcommand{\bbP}{{\mathbb P}}
\newcommand{\bbQ}{{\mathbb Q}}
\newcommand{\bbD}{{\mathbb D}}
\newcommand{\bbR}{{\mathbb R}}

\newtheorem{thm}{Theorem}
\newtheorem*{thm*}{Theorem}
\newtheorem{cor}[thm]{Corollary}
\newtheorem{prop}[thm]{Proposition}
\newtheorem{lem}[thm]{Lemma}
\newtheorem{defn}{Definition}
\newtheorem{assn}{Assumption}
\newtheorem{rem}{Remark}
\newtheorem{eg}{Example}

\begin{document}

\title{Scatter Component Analysis: A Unified Framework for Domain Adaptation and Domain Generalization}

\author{Muhammad~Ghifary,
	David Balduzzi, 
        W. Bastiaan~Kleijn,
        and~Mengjie~Zhang \\
Victoria University of Wellington \\
{\tt\small \{muhammad.ghifary,bastiaan.kleijn,mengjie.zhang\}@ecs.vuw.ac.nz, david.balduzzi@vuw.ac.nz}
}

\markboth{}{Ghifary \MakeLowercase{\textit{et al.}}}

\IEEEtitleabstractindextext{

\begin{abstract}
This paper addresses classification tasks on a particular target domain in which labeled training data are only available from source domains different from (but related to) the target. Two closely related frameworks, domain adaptation and domain generalization, are concerned with such tasks, where the only difference between those frameworks is the availability of the unlabeled target data: domain adaptation can leverage unlabeled target information, while domain generalization cannot.
We propose \emph{Scatter Component Analyis} (SCA), a fast representation learning algorithm that can be applied to both domain adaptation and domain generalization. 
SCA is based on a simple geometrical measure, i.e., \emph{scatter}, which operates on \emph{reproducing kernel Hilbert space}.
SCA finds a representation that trades between maximizing the separability of classes, minimizing the mismatch between domains, and maximizing the separability of data; each of which is quantified through \emph{scatter}. The optimization problem of SCA can be reduced to a generalized eigenvalue problem, which results in a fast and exact solution. 
Comprehensive experiments on benchmark cross-domain object recognition datasets verify that SCA performs much faster than several state-of-the-art algorithms and also provides state-of-the-art classification accuracy in both domain adaptation and domain generalization.
We also show that \emph{scatter} can be used to establish a theoretical generalization bound in the case of domain adaptation.

\end{abstract}

\begin{IEEEkeywords}
Domain adaptation, domain generalization, feature learning, kernel methods, scatter, object recognition.
\end{IEEEkeywords}
}
\maketitle


\section{Introduction}
\label{sec:intro}
Supervised learning is perhaps the most popular task in machine learning and has recently achieved dramatic successes in many applications such as object recognition~\cite{Krizhevsky:2012aa,Simonyan2015}, object detection~\cite{girshick14CVPR}, speech recognition~\cite{dahl:13}, and machine translation~\cite{sutskever:14}.
These successes derive in large part from the availability of massive \emph{labeled} datasets such as PASCAL VOC2007 \cite{pascal-voc-2007} and ImageNet \cite{Krizhevsky:2009aa}.
Unfortunately, obtaining labels is often a time-consuming and costly process that requires human experts.
Furthermore, the process of collecting samples is prone to \emph{dataset bias}~\cite{Ponce2006,Torralba2011}, i.e., a learning algorithm trained on a particular dataset generalizes poorly across datasets.
In object recognition, for example, training images may be collected under specific conditions involving camera viewpoints, backgrounds, lighting conditions, and object transformations.
In such situations, the classifiers obtained with learning algorithms operating on samples from one dataset cannot be directly applied to other related datasets.
Developing learning algorithms that are robust to label scarcity and dataset bias is therefore an important and compelling problem.

\emph{Domain adaptation}~\cite{Blitzer:2006aa} and \emph{domain generalization}~\cite{Blanchard2011} have been proposed to overcome the fore-mentioned issues.  
In this context, a \emph{domain} represents a probability distribution from which the samples are drawn and is often equated with a dataset.
The domain is usually divided into two different types: the \emph{source domain} and the \emph{target domain}, to distinguish between a domain with labeled samples and a domain without labeled samples.
These two domains are related but different, which limits the applicability of standard supervised learning models on the target domain.
In particular, the basic assumption in standard supervised learning that training and test data come from the same distribution is violated.

The goal of domain adaptation is to produce good models on a target domain, by training on labels from the source domain(s) and leveraging \emph{unlabeled} samples from the target domain as supplementary information during training.
Domain adaptation has demonstrated significant successes in various applications, such as sentiment classification \cite{Chen:2012ab,Glorot:2011aa}, 
visual object recognition~\cite{Hoffman:2013aa,Long2014a,Saenko:2010aa,Shekhar:2013}, and WiFi localization~\cite{Pan:2009aa}.

Finally, the problem of domain generalization arises in situations where unlabeled target samples are not available, but samples from multiple source domains can be accessed.
Examples of domain generalization applications are automatic gating of flow cytometry~\cite{Blanchard2011,Muandet2013} and visual object recognition~\cite{Fang2013,Khosla2012,Xu2014}.

The main practical issue is that several state-of-the-art domain adaptation and domain generalization algorithms for object recognition result in optimization problems that are inefficient to solve~\cite{Long:2013aa,Long2014a,Shekhar:2013,Xu2014}.
Therefore, they may not be suitable in situations that require a real-time learning stage.
Furthermore, although domain adaptation and domain generalization are closely related problems, domain adaptation algorithms \emph{cannot} in general be applied directly to domain generalization, since they rely on the availability of (unlabeled) samples from the target domain.
It is highly desirable to develop algorithms that can be computed more efficiently, are compatible with both domain adaptation and domain generalization, and provides state-of-the-art performance.

\vspace{-1em}
\subsection{Goals and Objectives}
To address the fore-mentioned issues, we propose a fast unified algorithm for reducing dataset bias that can be used for both domain adaptation and domain generalization. 
The basic idea of our algorithm is to learn representations as inputs to a classifier that are invariant to dataset bias.
Intuitively, the learnt representations should incorporate four requirements: 
(i) separate points with different labels and 
(ii) separate the data as a whole (high variance), whilst 
(iii) not separating points sharing a label and 
(iv) reducing mismatch between the two or more domains.
The main contributions of this paper are as follows:
\begin{itemize}[leftmargin=*]
 \item The first contribution is \emph{scatter}, a simple geometric function that quantifies the mean squared distance of a distribution from its centroid. 
 We show that the above four requirements can be encoded through scatter and establish the relationship with Linear Discriminant Analysis \cite{Fisher1936}, Principal Component Analysis, Maximum Mean Discrepancy \cite{Borgwardt:2006aa} and Distributional Variance \cite{Muandet2013}.
 \item The second contribution is a fast scatter-based feature learning algorithm that can be applied to both domain adaptation and domain generalization problems, \emph{Scatter Component Analysis} (SCA), see Algorithm~1. To the best of our knowledge, SCA is the first multi-purpose algorithm applicable across a range of domain adaptation and generalization tasks. 
 The SCA optimization reduces to a generalized eigenproblem that admits a fast and exact solution on par with Kernel PCA~\cite{Scholkopf1998} in terms of time complexity.
 \item The third contribution is the derivation of a theoretical bound for SCA in the case of domain adaptation.
 Our theoretical analysis shows that \emph{domain scatter} controls the generalization performance of SCA.
 We demonstrate that \emph{domain scatter} controls the \emph{discrepancy distance} under certain conditions. The discrepancy distance has previously been shown to control the generalization performance of domain adaptation algorithms~\cite{Mansour2009}. 
\end{itemize}

We performed extensive experiments to evaluate the performance of SCA against a large suite of alternatives in both domain adaptation and domain generalization settings.
We found that SCA performs considerably faster than the prior state-of-the-art across a range of visual object cross-domain recognition, with competitive or better performance in terms of accuracy.

\vspace{-1em}
\subsection{Organization of the Paper}
This paper is organized as follows.
Section~\ref{sec:litrev} describes the problem definitions and reviews existing work on domain adaptation and domain generalization.
Sections \ref{sec:scatter} and \ref{sec:sca} describes our proposed tool and also the corresponding feature learning algorithm, \emph{Scatter Component Analysis} (SCA).
The theoretical domain adaptation bound for SCA is then presented in Section \ref{sec:bound}.
Comprehensive evaluation results and analyses are provided in Sections~\ref{sec:exp1} and \ref{sec:exp2}.
Finally, Section \ref{sec:conc} concludes the paper.

\vspace{-1em}
\section{Background and Literature Review}
\label{sec:litrev}
This section establishes the basic definitions of domains, domain adaptation, and domain generalization.
It then reviews existing work in domain adaptation and domain generalization, particularly in the area of computer vision and object recognition.

A \emph{domain} is a probability distribution  on , where  and  are the input and label spaces respectively. 
For the sake of simplicity, we equate  with .
The terms domain and distribution are used interchangeably throughout the paper. 
Let  be an i.i.d. sample from a domain. It is convenient to use the notation  for the corresponding empirical distribution , where  is the Dirac delta.
We define \emph{domain adaptation} and \emph{domain generalization} as follows.
\begin{defn}[\textbf{Domain Adaptation}]
  \label{def:domadap}
 Let  and  be a source and target domain respectively, where .
 Denote by  and  samples drawn from both domains.
 The task of domain adaptation is to learn a good labeling function  given  and  as the training examples.
\end{defn}

\begin{defn}[\textbf{Domain Generalization}]
  \label{def:domgen}
  Let  be a set of  source domains and  be a target domain.
  Denote by  samples drawn from  source domains.
  The task of domain generalization is to learn a labeling function  given  as the training examples.
\end{defn}
It is instructive to compare these two related definitions.
The main difference between domain adaptation and domain generalization is on \emph{the availability of the unlabeled target samples}.
Both have the same goal: learning a labeling function  that performs well on the target domain.
In practice, domain generalization requires  to work well although  might not violate Definition~\ref{def:domgen}.
Note that domain generalization can be exactly reduced to domain adaptation if  and .


Domain adaptation and domain generalization have recently attracted great interest in machine learning.
We present a review of recent literature that is organized into two parts: i) domain adaptation and ii) domain generalization.

\vspace{-1em}
\subsection{Domain Adaptation}
Earlier studies on domain adaptation focused on natural language processing, see, e.g., \cite{Jiang:2008aa} and references therein.
Domain adaptation has gained increasing attention in computer vision for solving dataset bias in object recognition \cite{Saenko:2010aa,Gong:2012aa,Tommasi:2013ab,Fernando:2013aa,Hoffman_CVPR2014,Long2014a} and object detection \cite{Sun:BMVC2014}.
The reader is encouraged to consult the recent survey in visual domain adaptation~\cite{patel_dasurvey:2015} for a more comprehensive review.
We classify domain adaptation algorithms into three categories: i) the classifier adaptation approach, ii) the selection/reweighting approach, and iii) the feature transformation-based approach.

The \emph{classifier adaptation approach} aims to learn a good, adaptive classifier on a target domain by leveraging knowledge from source or auxiliary domains \cite{Yang:2007aa,DAM:2012,DuanTPAMI2012a,DuanTPAMI2012b,Niu_IJCV16}.
Adaptive Support Vector Machines (A-SVMs)~\cite{Yang:2007aa} utilize \emph{auxiliary classifiers} to adapt a \emph{primary classifier} that performs well on a target domain, where the optimization criterion is similar to standard SVMs. 
The Domain Adaptation Machine (DAM)~\cite{DAM:2012} employs both a domain-dependent regularizer based on a smoothness assumption and a sparsity regularizer in Least-Squares SVMs~\cite{LSSVM:2004}.
Recently, a multi-instance learning based classifier for action and event recognition, trained on weakly labeled web data, was proposed \cite{Niu_IJCV16}.
 

The \emph{reweighting/selection approach} reduces sample bias by reweighting or selecting source instances that are `close' to target instances -- selection can be considered as the `hard' version of reweighting.
The basic idea has been studied under the name of \emph{covariate shift}~\cite{Shimodaira:2000aa}.
Gong et al.\cite{Gong:2013ab} applied a convex optimization strategy to select some source images that are maximally similar to the target images according to Maximum Mean Discrepancy~\cite{Borgwardt:2006aa} -- referred to as \emph{landmarks}.
The landmarks are then used to construct multiple auxiliary tasks as a basis for composing domain-invariant features.
Transfer Joint Matching (TJM)~\cite{Long2014a} uses a reweighting strategy as a regularizer based on -norm structured sparsity on the source subspace bases.

The \emph{feature transformation-based approach} is perhaps the most popular approach in domain adaptation.
Daume III \cite{Daume-III:2007aa} proposed a simple feature augmentation method by replicating the source and target data, both are in , as well as zero-padding such that the resulting features are in . 
Li et al. \cite{Li_HFA:TPAMI2014} extended the method for the case of heterogeneous features, i.e., source and target features have different dimensionality, by introducing a common subspace learnt via the standard SVM formulation.
A subspace learning-based algorithm, Transfer Component Analysis (TCA) and its semi-supervised version SSTCA~\cite{Pan2011}, utilizes the Maximum Mean Discrepancy (MMD)~\cite{Gretton:2007aa} to minimize dataset bias in WiFi localization and text classification applications.
Metric learning-based domain adaptation approaches have been proposed \cite{Saenko:2010aa, Kulis:2011aa}, which were early studies in object recognition on the Office dataset.
The idea of extracting `intermediate features' to minimize dataset bias by projecting data onto multiple intermediate subspaces was also considered.
Sampling Geodesic Flow (SGF) \cite{Gopalan:2011aa} and Geodesic Flow Kernel (GFK) \cite{Gong:2012aa} generate multiple subspaces via an interpolation between the source and the target subspace on a Grassmann manifold -- a point on the manifold is a subspace.
Subspace Alignment (SA) \cite{Fernando:2013aa} transforms a source PCA subspace into a new subspace that is well-aligned to a target PCA subspace without requiring intermediate subspaces.
A recent method called Correlation Alignment (CORAL) facilitates adaptive features by aligning the source and target covariance matrices \cite{Sun:AAAI2016}.
Other subspace learning-based methods such as Transfer Sparse Coding (TSC) \cite{Long:2013aa} and Domain Invariant Projection (DIP) \cite{Baktashmotlagh:2013} make use of MMD, following TCA, to match the source and target distributions in the feature space.
One of the methods proposed in \cite{Baktashmotlagh:2014} follows a similar intuition by using Hellinger distance as an alternative to MMD.
Algorithms based on hierarchical non-linear features or deep learning are also capable of producing powerful domain adaptive features 
\cite{Chopra:2013aa,Donahue:2014aa,Ganin2015,Ghifary2014b,Hoffman:2013aa,Long_DAN:2015}.


Several works have addressed Probably Approximately Correct theoretical bounds for domain adaptation.
Ben-David et al.~\cite{Ben-David:2007aa} presented the first theoretical analysis of domain adaptation, that is, an adaptation bound in classification tasks based on the -distance \cite{Kifer:2004}.
Mansour et al.~\cite{Mansour2009} extended this work in several ways built on Rademacher complexity~\cite{Bartlett:2002} and the \emph{discrepancy distance}, as an alternative to -distance.
In this paper, we provide a domain adaptation bound for our new algorithm based on the latter analysis.

\vspace{-0.5em}
\subsection{Domain Generalization}
Domain generalization is a newer line of research than domain adaptation.
Blanchard et al.~\cite{Blanchard2011} first studied this issue and proposed an augmented SVM that encodes empirical marginal distributions into the kernel for solving automatic gating of flow cytometry.
A feature projection-based algorithm, Domain-Invariant Component Analysis (DICA)~\cite{Muandet2013}, was then introduced to solve the same problem.
DICA extends Kernel PCA~\cite{Scholkopf1998} by incorporating the \emph{distributional variance} to reduce the dissimilarity across domains and the central subspace~\cite{COIR:2011} to capture the functional relationship between the features and their corresponding labels.

Domain generalization algorithms also have been used in object recognition.
Khosla et al.~\cite{Khosla2012} proposed a multi-task max-margin classifier, which we refer to as Undo-Bias, that explicitly encodes dataset-specific biases in feature space.
These biases are used to push the dataset-specific weights to be similar to the global weights. 
Fang et al.\cite{Fang2013} developed Unbiased Metric Learning (UML) based on a learning-to-rank framework. 
Validated on weakly-labeled web images, UML produces a less biased distance metric that provides good object recognition performance.
Xu et al.\cite{Xu2014} extended an exemplar-SVM~\cite{Malisiewicz:2011} to domain generalization by adding a nuclear norm-based regularizer that captures the likelihoods of all positive samples. 
The proposed model is referred to as LRE-SVM that provides the state-of-the-art performance.
More recently, an autoencoder based algorithm to extract domain-invariant features via multi-task learning has been proposed \cite{Ghifary:ICCV2015}.

Although both domain adaptation and domain generalization have the same goal (reducing dataset bias), the approaches are generally not compatible to each other -- domain adaptation methods cannot be directly applied to domain generalization or vice versa.
To our best knowledge, only LRE-SVM can be applied to both domain adaptation and domain generalization.
The domain generalization algorithm formulation as in DICA, Undo-Bias, or UML typically does not allow to take into account unlabeled data from the target domain.
Furthermore, several state-of-the-art domain adaptation and domain generalization algorithms such as TJM and LRE-SVM, require the solution of a computationally complex optimization that induces high complexity in time.
In this work, we establish a fast algorithm that overcomes the above issues.

\section{Scatter}
\label{sec:scatter}
We work in a feature space that is a reproducing kernel Hilbert space (RKHS) .
The main motivation is to transform original inputs onto , which is high or possibly infinite dimensional space, with the hope that the new features are linearly separable.
The most important property of RKHS is perhaps to allow a computationally feasible transformation onto  by virtue of the \emph{kernel trick}.
\begin{defn}[\textbf{Reproducing Kernel Hilbert Space}] 
\label{d:rkhs}
 Let  be an arbitrary set and  a Hilbert space of functions on . Define the evaluation functional  by . Then  is a \textbf{reproducing kernel Hilbert space (RKHS)} if the functional  is always bounded: i.e.  for all  there exists an  such that
 
 It follows that there is a function  (referred to as the \textbf{canonical feature map}) satisfying: 
  
  Consequently, for each , one can write
  
  The function  is referred to as the \textbf{reproducing kernel}.
\end{defn}
\noindent Expression (\ref{eq:rkhs}) is the weakest condition that ensures the existence of an inner product and also the ability to evaluate each function in  at every point in the domain, while (\ref{eq:repprop}) provides more useful notion in practice.

Before introducing scatter, it is convenient to first represent domains as points in RKHS using the mean map \cite{smola:07}:
\begin{defn}[\textbf{Mean map}]
  \label{d:meanmap}
	Suppose that  is equipped with a kernel, and that  is the corresponding RKHS with feature map . Let  denote the set of probability distributions on . The mean map takes distributions on  to points in :
	
\end{defn}
\noindent Geometrically, the mean map is the centroid of the image of the distribution under .
We define \emph{scatter} as the variance of points in the image around its centroid:

\begin{defn}[\textbf{Scatter}]
	\label{d:scatter}
	The \textbf{scatter} of distribution  on  relative to  is
	
	where  is the norm on .
\end{defn}

The scatter of a domain cannot be computed directly; instead it is estimated from observations. 
The scatter of a finite set of observations  is computed with respect to the empirical distribution 


We provide a theorem that shows how the difference between the true scatter and a finite sample estimate decreases with the sample size.
\begin{thm}[\textbf{Scatter Bound}] 
	\label{t:bound}
	Suppose  is a true distribution over all samples of size  and  is its empirical distribution. Further suppose that  for all . Then, with probability ,
	
\end{thm}

\begin{proof} See Supplementary material. \end{proof}
\noindent Note that the right hand site of the bound is smaller for lower values of  and higher values of . 
Furthermore, if  is in the form of Gaussian kernel, the bound only depends on  since .

We provide an example for later use. If the input space is a vector space and  is the identity then it follows immediately that
\begin{lem}[\textbf{Total variance as scatter}]	
	\label{t:total_variance}
	The scatter of the set of -dimensional points (in a matrix form)  relative to the identity map 
	, is the total variance:
	
	where  denotes the trace operation and  with .
\end{lem}


We utilize \emph{scatter} to formulate a feature learning algorithm referred to as Scatter Component Analysis (SCA).
Specifically, \emph{scatter} quantifies requirements needed in SCA to develop an effective solution for both domain adaptation and generalization, which will be described in the next section.


\vspace{-1em}
\section{Scatter Component Analysis (SCA)}
\label{sec:sca}
SCA aims to efficiently learn a representation that improves both domain adaptation and domain generalization. 
The strategy is to convert the observations into a configuration of points in feature space such that the domain mismatch is reduced. 
SCA then finds a representation of the problem (that is, a linear transformation of feature space) for which 
(i) the source and target domains are similar and 
(ii) elements with the same label are similar; whereas 
(iii) elements with different labels are well separated and 
(iv) the variance of the whole data is maximized.
Each requirement can be quantified through \emph{scatter} that leads to four consequences: (i) \emph{domain scatter}, (ii) \emph{between-class scatter}, (iii) \emph{within-class scatter}, and (iv) \emph{total scatter}.

The remainder of the subsection defines the above four scatter quantities in more detail (along the way relating the terms to principal component analysis, the maximum mean discrepancy, and Fisher's linear discriminant) and describes the SCA's learning algorithm.
We will also see that SCA can be easily switched to either domain adaptation or domain generalization by modifying the configuration of the input domains.


\subsection{Total Scatter}
Given  domains  on , we define the total domain as the mean .
The \emph{total scatter} is then defined by

It is worth emphasizing that this definition is general in the sense that it covers both domain adaptation ( and one of them is the target domain) and domain generalization ().

Total scatter is estimated from data as follows. 
Let  be the matrix of unlabeled samples from all  domains (, where  is the number of examples in the -th domain).
Given a feature map  corresponding to kernel , define a set of functions arranged in a column vector .
After centering  by subtracting the mean,
the covariance matrix is . By Lemma~\ref{t:total_variance}, 


We are interested in the total scatter after applying a linear transform to a finite relevant subspace .
To avoid the direct computation of , which could be expensive or undoable, we use the \emph{kernel trick}.
Let  be the  transformed feature vectors and
.
After fixing  such that , 
the total transformed scatter is 

We remark that, in our notation, Kernel Principal Component Analysis (KPCA)~\cite{Scholkopf1998} corresponds to the optimization problem



\subsection{Domain Scatter}
Suppose we are given  domains  on . 
We can think of the \emph{set}  as a sample from some latent distribution on domains. Equipping the sample with the empirical distribution and computing scatter relative to the identity map on  yields \emph{domain scatter}:

where .
Note that domain scatter coincides with the \emph{distributional variance} introduced in \cite{Muandet2013}.
Domain scatter is also closely related to the Maximum Mean Discrepancy (MMD), used in some domain adaptation algorithms~\cite{Huang:2007,Pan2011,Long2014a}.


\begin{defn}
	Let  be a set of functions . The \textbf{maximum mean discrepancy} between domains  and  is
	
\end{defn}
The MMD measures the extent to which two domains resemble one another from the perspective of function class . 
The following theorem relates domain scatter to MMD given two domains, where the case of interest is bounded linear functions on the feature space:

\begin{lem}[\textbf{Scatter recovers MMD}]
	\label{t:mmd}
	The scatter of domains  and  on  is their (squared) maximum mean discrepancy:
	
	where .

	In particular, if  is induced by a characteristic kernel on  then  if and only if .
\end{lem}

\begin{proof}
	Note that the theorem involves two levels of probability distributions: 
	(i) the domains  and  on , and 
	(ii) the empirical distribution on  that assigns probability  to the points  and , and  to everything else.
	Let . By Definition~\ref{d:scatter},
	
	The result follows from Theorem~2.2 of \cite{Borgwardt:2006aa}.
\end{proof}
Lemma~\ref{t:mmd} also tells that the domain scatter is a valid metric if the kernel on  is characteristic~\cite{sriperumbudur:10}. The most important example of a characteristic kernel is the Gaussian RBF kernel, which is the kernel used in the theoretical results and experiments below.
We also remark that MMD can be estimated from observed data with bound provided in \cite{Gretton:2012aa}, which is analogous to Theorem~\ref{t:bound}.

Domain scatter in a transformed feature space in  is estimated as follows. Suppose we have  samples .
Recall that , where  contains projected samples from all domains:  and

is the corresponding kernel matrix, where .
By some algebra, the domain scatter is

where  is a coefficient matrix
with  if , and  otherwise.




\subsection{Class Scatter}
For each class , let  denote the conditional distribution on  induced by the total labeled domain  when   (the number of labeled domains  does not necessarily equal to the number of source domains ). 
We define the \emph{within-class scatter} and \emph{between-class scatter} as



The class scatters are estimated as follows. Let  denote the -tuple of source samples in class . The centroid of  is . Furthermore, let  denote the -tuple of all class centroids \emph{where centroid  appears  times in }. The centroid of  is then the centroid of the source domain: . It follows that the within-class scatter is

 and the between-class scatter is

The right-hand sides of the above equations are the classical definitions of within- and between- class scatter \cite{Fisher1936}. The classical linear discriminant is thus a ratio of scatters

Maximizing Fisher's linear discriminant increases the separation of the data points with respect to the class clusters.

Given a linear transformation , it follows from Lemma~\ref{t:total_variance} that the class scatters in the projected feature space  are 

where

with 
, 
,
, and 
the centering matrix , where
 denotes a  identity matrix and  denotes a vector of ones.


\subsection{The Algorithm}
Here we formulate the SCA's learning algorithm by incorporating the above four quantities.
The objective of SCA is to seek a representation by solving an optimization problem in the form of the following expression


Using (\ref{eq:total_scatter}), (\ref{eq:domain_scatter}), (\ref{eq:bclass_scatter}), and (\ref{eq:wclass_scatter}),
the above expression can then be specified in more detail:

Maximizing the numerator encourages SCA to preserve the total variability of the data and the separability of classes. Minimizing the denominator encourages SCA to find a representation for which the source and target domains are similar, and source samples sharing a label are similar.

\textbf{Objective function.}
We reformulate \eqref{eq:ftca_general} in three ways. 
First, we express it in terms of linear algebra. 
Second, we insert hyper-parameters that control the trade-off between scatters as one scatter quantity could be more important than others in a particular case.
Third, we impose the constraint that  is small to control the scale of the solution.

Explicitly, SCA finds a projection matrix  that solves the constrained optimization

where 

and  are the trade-off parameters controlling the total and between-class scatter, and domain scatter respectively.

Observe that the above optimization is invariant to rescaling .
Therefore, optimization (\ref{eq:ftca_opt}) can be rewritten as

which results in Lagrangian

To solve (\ref{eq:ftca_opt}), set the first derivative , inducing the generalized eigenproblem

where  are the  leading eigenvalues and  contains the corresponding eigenvectors.\footnote{In the implementation, a numerically more stable variant is obtained by using (\ref{eq:ftca_eigenprob}) using 
,
where  is a fixed small constant.
}
Algorithm~\ref{alg:sca} provides a complete summary of SCA.

\begin{algorithm}[tb]
   \caption{Scatter Component Analysis}
   \label{alg:sca}
	\algorithmicrequire\; \\
		 Sets of training datapoints  and their corresponding matrices , where ; \\
		 Training labels ; \\
		 Hyper-parameters ; kernel bandwidth ; \\
		 Number of subspace bases ;
	\begin{algorithmic}[1]
		\STATE Construct kernel matrix  from , 
			matrices ,  and  based on (\ref{eq:kernel}),  (\ref{eq:between_class_kernel}), (\ref{eq:within_class_kernel}), and (\ref{eq:big_pq});
		\STATE Apply the centering operation 
			,
			where  and ;
		\STATE Obtain the transformation  and its corresponding eigenvalues  by solving the generalized eigendecomposition problem in Eq. (\ref{eq:ftca_eigenprob}) and selecting the  leading eigenvectors;
		\STATE Target feature extraction: Let  be the total training sample and  be a target sample (for domain adaptation, ). Construct a kernel matrix . The extracted features are given by 
	\end{algorithmic}
	\algorithmicensure\; \\
		 Optimal transformation matrix ;\\
		 Feature matrix .
\end{algorithm}

\subsection{Relation to other methods}
\label{s:related}
SCA is closely related to a number of feature learning and domain adaptation methods.
To see this, let us observe Lagrangian (\ref{eq:ftca_lagrang}).
Setting the hyper-parameters  and  in (\ref{eq:ftca_lagrang}) recovers KPCA. 
Setting  and  recovers the Kernel Fisher Discriminant (KFD) method \cite{Mika1999}. 
KFD with linear kernel is equivalent to Fisher's linear discriminant, which is the basis of a domain adaptation method for object detection proposed in \cite{Sun:BMVC2014}.


Setting  and  (that is, ignoring class separation) yields a new algorithm: unsupervised Scatter Component Analysis (uSCA), which is closely related to TCA. 
The difference between the two algorithms is that TCA constrains the total variance and regularizes the transform, 
whereas uSCA trades-off the total variance and constrains the transform (recall that  should be small) motivated by Theorem~\ref{t:bound}. 
It turns out that uSCA consistently outperforms TCA in the case of domain adaptation, see Section~\ref{sec:exp1}.

Eliminating the term  from the denominator in (\ref{eq:ftca_opt}) from uSCA yields TCA~\cite{Pan2011}.
The semi-supervised extension SSTCA of TCA differs markedly from SCA. Instead of incorporating within- and between- class scatter into the objective function, SSTCA incorporates a term derived from the Hilbert-Schmidt Independence Criterion that maximizes the dependence of the embedding on labels. 

uSCA is essentially equivalent to unsupervised Domain Invariant Component Analysis (uDICA) in the case of two domains \cite{Muandet2013}. However, as for SSTCA, \emph{supervised} DICA incorporates label-information differently from SCA -- via the notion of a central subspace. In particular, supervised DICA requires that all data points are labeled, and so it cannot be applied in our experiments.

\vspace{-1em}
\subsection{Computational Complexity}
\label{s:runtime}
Here we analyze the computation complexity of the SCA algorithm.
Suppose that we have  domains with  are the number of samples for each domain ( covers the domain generalization case).
Denote the total number of samples by  and the number of leading eigenvectors by .
Computing the matrices , , , and  takes  (Line 1 at Algorithm~\ref{alg:sca}). 
Hence, the total complexity of SCA after solving the eigendecomposition problem (Line 2) takes , or quadratic in .
This complexity is similar to that of KPCA and Transfer Component Analysis~\cite{Pan2011}.

In comparison to Transfer Joint Matching (TJM)~\cite{Long2014a}, the prior state-of-the-art domain adaptation algorithm for object recognition, TJM uses an alternating eigendecomposition procedure in which  iterations are needed.
Using our notation, the complexity of TJM is , i.e., TJM is  times slower than SCA.

\vspace{-1em}
\subsection{Hyper-parameter Settings}
Before reporting the detailed evaluation results, it is important to explain how SCA hyper-parameters were tuned.
The formulation of SCA described in Section~\ref{sec:sca} has four hyper-parameters: 
1) the choice of the kernel,
2) the number of subspace bases ,
3) the between-class and total scatters trade-off , and
4) the domain scatter ,.
Tuning all those hyper-parameters using a standard strategy, e.g., a grid-search, might be impractical due to two reasons.
The first is of the computational complexity.
The second, which is crucial, is that cross-validating a large number of hyper-parameters may worsen the generalization on the target domain, since labeled samples from the target domain are not available.

Our strategy to deal with the issue is to reduce the number of tunable hyper-parameters. 
For the kernel selection, we chose the RBF kernel , where the kernel bandwidth  was set analytically to the median distance between samples in the aggregate domain following~\cite{Gretton:2012aa},

For domain adaptation,  was fixed at . Thus, only two hyper-parameters remain tunable:  and .
For domain generalization,  was set at 1, i.e., the total scatter was eliminated, and  was allowed to be tuned  -- the number of tunable hyper-parameters remains unchanged.
The configuration is based on an empirical observation that setting  is no better (if not worse) than  in terms of both the cross-validation and test performance for domain generalization cases.
In all evaluations, we used 5-fold cross validation using source labeled data to find the optimal  and .
We found that this strategy is sufficient to produce good SCA models for both domain adaptation and generalization cases.



\section{Analysis of Adaptation Performance}
\label{sec:bound}
We derive a bound for domain adapation that shows how the MMD controls generalization performance in the case of the squared loss . 
Despite the widespread use of the MMD for domain adaptation~\cite{DAML:2011,DAM:2012,Long:2013aa,Long2014a,Pan2011}, to the best of our knowledge, this is the first generalization bound. 
The main idea is to incorporate the MMD (that is, domain scatter) into the adaptation bound proven for the \emph{discrepancy distance}~\cite{Mansour2009}. A generalization bound for domain generalization in terms of domain scatter is given in \cite{Muandet2013}, see remark~\ref{rem:gen_scatter}.

Let   denote a hypothesis class of functions from  to  where  is a compact set. Given a loss function defined over pairs of labels
 and a distribution  over , let 
 denote the expected loss for any two hypotheses .
We consider the case where the hypothesis set  is a subset of an RKHS .

We first introduce discrepancy distance, , which measures the difference between two distributions  and .

\begin{defn}[\textbf{Discrepancy Distance}~\cite{Mansour2009}]
\label{def:disc}
Let  be a set of functions mapping from  to .
The \textbf{discrepancy distance} between two distributions  and  over  is defined by

\end{defn}
The discrepancy is symmetric and satisfies the triangle inequality, but it does not define a distance in general:  such that ~\cite{Mansour2009}. 

If we assume that we have a \emph{universal kernel}~\cite{Steinwart:2002aa,micchelli:06}, i.e.  as topological spaces, and the loss  is the squared loss~\cite{Cortes:2014} then the discrepancy is a metric. The most important example of a universal kernel is the Gaussian RBF kernel, which is the kernel used in the experiments below.

The main step of the proof is to find a relationship between domain scatter and the discrepancy distance. We are able to do so in the special case where the kernel is universal and the loss is the mean-square error. The main technical challenge is that the discrepancy distance is quadratic in the hypotheses (involving terms of the form  and ) whereas the MMD is linear. We therefore need to bound the effects of the multiplication operator:


\begin{defn}[\textbf{Multiplication Operator}]
 \label{def:mulop}
 Let  be the space of continuous functions on the compact set  equipped with the supremum norm . 
 Given , define the multiplication operator as the bounded linear operator  given by
 
\end{defn}

Note that a general RKHS is \emph{not} closed under the multiplication operator~\cite{Grunewalder:2013}. However, since the kernel is universal, it follows that  is closed under multiplication since the space of continuous functions  is closed under multiplication. Moreover, we can define the sup-norm  on  using its identification with .

The following Lemma upper bounds the norm of multiplication operator, which will be useful to prove our main theorem.
 \begin{lem}\label{lem:mult}
   Given , , where  is equipped with a universal kernel, it holds that
   .
 \end{lem}
 \begin{proof}
    Straightforward calculation. The Lemma requires a universal kernel since  is only defined if .
 \end{proof}


We now show that the domain scatter of two distributions upper-bounds the discrepancy distance.
\begin{lem}[\textbf{Domain scatter bounds discrepancy}]
\label{t:disc_scatter}
  Let  be an RKHS with a universal kernel.
  Suppose that  is the square loss, and consider the hypothesis set

where  is a constant
Let  and  be two domains over . 
Then the following inequality holds:	

\end{lem}

\begin{proof} 
See Supplementary material. 
\end{proof}

Lemma \ref{t:disc_scatter} allows us to relate \emph{domain scatter} to generalization bounds for domain adaptation proven in \cite{Mansour2009}. 
Before stating the bounds, we introduce Rademacher complexity~\cite{Bartlett:2002}, which measures the degree to which a class of functions can fit random noise.
This measure is the basis of bounding the empirical loss and expected loss.

\begin{defn}[\textbf{Rademacher Complexity}]
\label{d:radem}
Let  be a family of functions mapping from  to  and  be a fixed sample of size .
The empirical Rademacher complexity of  with respect to the sample  is

where  are Rademacher variables, with s independent uniform random variables taking values in .
The \textbf{Rademacher complexity} over all samples of size  is

 
\end{defn}

The supplementary material discusses how to associate a family of functions to a loss function, and provides a useful Rademacher bound.  We now have all the ingredients to derive domain adaptation bounds in terms of domain scatter.

Let  and  be the true labeling functions on domain  and  respectively, 
and  and  be the minimizers.
For a successful domain adaptation, we shall assume that  is small.
The following theorem provides a domain adaptation bound in terms of scatter (recall that the MMD is a special case of scatter by Lemma~\ref{t:mmd}).

\begin{thm}[\textbf{Adaptation bounds with domain scatter}]
\label{t:adapt_bound}
Let  be a family of functions mapping from  to ,
 and  be a source and target sample respectively.
Let the rest of the assumptions be as in Lemma~\ref{t:disc_scatter} and Theorem~8 in the supplementary material.
For any hypothesis , with probability at least , the following adaptation bound holds:

\end{thm}
\begin{proof}
Fix . Since the square loss is symmetric and obeys the triangle inequality, Theorem 8 in \cite{Mansour2009} (see supplementary material) implies that

The result then follows by Lemma~\ref{t:disc_scatter} combined with the Rademacher bound in the supplementary material.
\end{proof}
\noindent It is instructive to compare Theorem \ref{t:adapt_bound} above with Theorem 9 in \cite{Mansour2009}, 
which is the analog if we expand  in (\ref{eq:triangle_loss}) with its empirical measure.
It is also straightforward to rewrite the bound in term of the \emph{empirical scatter}  by applying Theorem~\ref{t:bound}.

The significance of Theorem \ref{t:adapt_bound} is twofold. 
First, it highlights that the scatter  controls the generalization performance in domain adaptation.
Second, the bound shows a direct connection between \emph{scatter} (also MMD) and the domain adaptation theory proposed in \cite{Mansour2009}.
Note that the bound might not be useful for practical purposes, since it is loose and pessimistic as they hold for all hypotheses and all possible data distributions.


\begin{rem}[\textbf{The role of scatter in domain generalization}]\label{rem:gen_scatter}
 Theorem~5 of \cite{Muandet2013} shows that the domain scatter (or, alternatively, the distributional variance) is one of the key terms arising in a generalization bound in the setting of domain generalization.  
\end{rem}

\vspace{-1em}

\section{Experiment I : Domain Adaptation}
\label{sec:exp1}
The first set of experiments evaluated the domain adaptation performance of SCA on synthetic data and real-world object recognition tasks.
The synthetic data was designed to understand the behavior of the learned features compared to other algorithms, 
whereas the real-world images were utilized to verify the performance of SCA.

The experiments are divided into two parts.
Section~\ref{sec:toy} visualizes performance on synthetic data.
Section~\ref{sec:exp1_vals} evaluates performance on a range of cross-domain object recognition tasks with a standard yet realistic hyper-parameter tuning.
Some additional results with a tuning protocol established in the literature are also reported in the supplementary material for completeness.


\begin{figure*}[htp]
	\centering
	\subfigure{\includegraphics[width=1.2in]{toydataset.png}} \quad 
	\subfigure{\includegraphics[width=1.2in]{kpca_toy.png}} \quad 
	\subfigure{\includegraphics[width=1.2in]{sstca_toy.png}} \quad
	\subfigure{\includegraphics[width=1.2in]{tjm_toy.png}} \quad 
	\subfigure{\includegraphics[width=1.2in]{sca_toy.png}}
	\setcounter{subfigure}{0}
	\subfigure[{\small Raw (}]{\label{fig:toydataset}\includegraphics[width=1.2in]{toydataset_c.png}} \quad 
	\subfigure[{\small KPCA ()}]{\label{fig:kpca_toy}\includegraphics[width=1.2in]{kpca_toy_c.png}} \quad
	\subfigure[SSTCA ()]{\label{fig:sstca_toy}\includegraphics[width=1.2in]{sstca_toy_c.png}} \quad
	\subfigure[TJM ()]{\label{fig:tjm_toy}\includegraphics[width=1.2in]{tjm_toy_c.png}} \quad 
	\subfigure[SCA ()]{\label{fig:sca_toy}\includegraphics[width=1.2in]{sca_toy_c.png}}
	\vspace{-1em}    
	\caption{\textbf{Visualization.}
	Projections of synthetic data onto the first two leading eigenvectors.
	Numbers in brackets indicate the classification accuracy on the target using 1-nearest neighbor (1NN).
	The top and bottom rows show the domains and classes respectively.
	}
	\label{fig:toy}
\end{figure*}
\vspace{-1em}
\subsection{Synthetic data}
\label{sec:toy}
Figure~1 depicts synthetic data that consists of two dimensional data points under three classes with six clusters.
The data points in each cluster were generated from a Gaussian distribution , 
where  and  is the mean and standard deviation of the -th cluster.
The RBF kernel  was used for all algorithms.
All tunable hyper-parameters were selected according to 1-nearest neighbor's test accuracy.
We compare features extracted from Kernel Principal Component Analysis (KPCA), Semi-Supervised Transfer Component Analysis (SSTCA)~\cite{Pan2011}, Transfer Joint Matching (TJM)~\cite{Long2014a}, and SCA.

The top row of Figure~\ref{fig:toy} illustrates how the features extracted from the MMD-based algorithms (SSTCA, TJM, and SCA) reduce the domain mismatch. 
Red and blue colors indicate the source and target domains, respectively.
Good features for domain adaptation should have a configuration of which the red and blue colors are mixed.
This effect can be seen in features extracted from SSTCA, TJM, and SCA, which indicates that the domain mismatch is successfully reduced in the feature space.
In classification, domain adaptive features should also have a certain level of class separability.
The bottom row highlights a major difference between SCA and the other algorithms in terms of the class separability: the SCA features are more clustered with respect to the classes, with more prominent gaps among clusters.
This suggests that it would be easier for a simple function to correctly classify SCA features.


\subsection{Real world object recognition}
\label{sec:exp1_vals}
We summarize the complete domain adaptation results over a range of cross-domain object recognition tasks.
Several real-world image datasets were utilized such as handwritten digits (MNIST~\cite{LeCun:1998aa} and USPS~\cite{usps1994}) and general objects (MSRC~\cite{msrc2005}, VOC2007~\cite{pascal-voc-2007}, Caltech-256~\cite{Griffin2007}, Office~\cite{Saenko:2010aa}).
Three cross-domain pairs were constructed from these datasets: USPS+MNIST, MSRC+VOC2007, and Office+Caltech.


\subsubsection{Data Setup}
\label{sec:exp1_datasetup}
\textbf{The USPS+MNIST}
pair consists of raw images subsampled from datasets of handwritten digits.
MNIST contains 60,000 training images and 10,000 test images of size .
USPS has 7,291 training images and 2,007 test images of size  \cite{LeCun:1998aa} .
The pair was constructed by randomly sampling 1,800 images from USPS and 2,000 images from MNIST.
Images were uniformly rescaled to size  and encoded into feature vectors representing the gray-scale pixel values.
Two \textsc{source}  \textsc{target} classification tasks were constructed: \textsc{usps}  \textsc{mnist} and \textsc{mnist}  \textsc{usps}.

\textbf{The MSRC+VOC2007}
pair consist of 240-dimensional images that share 6 object categories: ``aeroplane'', ``bicycle'',``bird'', ``car'', ``cow'', and ``sheep'' taken from the MSRC and VOC2007~\cite{pascal-voc-2007} datasets.
The pair was constructed by selecting all 1,269 images in MSRC and 1,530 images in VOC2007.
As in \cite{Long:2013aa}, features were extracted from the raw pixels as follows.
First, images were uniformly rescaled to be 256 pixels in length.  
Second, 128-dimensional dense SIFT (DSIFT) features were extracted using the VLFeat open source package~\cite{vedaldi08vlfeat}. 
Finally, a 240-dimensional codebook was created using K-means clustering to obtain the codewords.

\textbf{The Office+Caltech}
consists of 2,533 images of ten categories (8 to 151 images per category per domain), that forms four domains:
() {\sc amazon}, () {\sc dslr}, () {\sc webcam}, and () {\sc caltech}.
{\sc amazon} images were acquired in a controlled environment with studio lighting.
{\sc dslr} consists of high resolution images captured by a digital SLR camera in a home environment under natural lighting.
{\sc webcam} images were acquired in a similar environment to {\sc dslr}, but with a low-resolution webcam.
Finally, {\sc caltech} images were collected from Google Images~\cite{Griffin2007}.
Taking all possible source-target combinations yields 12 cross-domain datasets denoted by 
.
We used two types of extracted features from these datasets that are publicly available: SURF-BoW\footnote{\url{http://www-scf.usc.edu/~boqinggo/da.html}}~\cite{Saenko:2010aa} and \footnote{\url{http://vc.sce.ntu.edu.sg/transfer_learning_domain_adaptation/domain_adaptation_home.html}}~\cite{Donahue:2014aa}.
\textbf{SURF-BoW} features were extracted using SURF~\cite{Bay:2008aa} and quantized into 800-bin histograms with codebooks computed by K-means on a subset of {\sc amazon} images.
The final histograms were standardized to have zero mean and unit standard deviation in each dimension.
\textbf{Deep Convolutional Activation Features (DeCAF)}
were constructed by \cite{Donahue:2014aa} using the deep convolutional neural network architecture in \cite{Krizhevsky:2012aa}.
The model inputs are the mean-centered raw RGB pixel values that are forward propagated through 5 convolutional layers and 3 fully-connected layers.
We used the outputs from the 6th layer as the features, leading to  dimensional  features.


\begin{table*}[!htb]
    \caption{Accuracy \% on the USPS+MNIST and MSRC+VOC2007 datasets.
    Bold-red and bold-black indicate the best and second best performance.
    }
    \vspace{-1em}
    \centering
\begin{tabular}{| c || c | c | c | c | c | c | c | c | c | c |}
    \hline
    Dataset & Raw & KPCA & TCA & SSTCA &GFK & TSC & SA &  TJM & uSCA & SCA \\
    \hline
    
    \textsc{usps}  \textsc{mnist} & 
       &   &  &  &  &  &  & {\color{red}} & &  \\
      
    \textsc{mnist}  \textsc{usps} & 
       &  &  &  &  &  &  &  &  & {\color{red} } \\
    
    \textsc{msrc}  \textsc{voc} & 
       &  &  &  &  &  &  & & {\color{red} } &  \\
    
    \textsc{voc}  \textsc{msrc} & 
       &  &  &  &  &  &  &  &  {\color{red} } &  \\
    
    \hline
    \hline
    
    Avg. &  &  &  &  &  &  &  &  &  & {\color{red} }\\
    
    \hline
    \end{tabular}
\label{tab:exp1_results_cv}
\end{table*}

\begin{table*}[!htb]
\caption{Accuracy \% on the Office+Caltech images with SURF-BoW features.
    1NN was used as the base classifier.}
    \vspace{-1em}
\centering
\begin{tabular}{| c || c | c | c  | c | c | c | c | c | c | c | }
\hline
Dataset           & Raw     & KPCA      &  TCA     & SSTCA &  GFK & TSC & SA      & TJM     & uSCA    & SCA    \\
\hline
\hline
 &  &  &  &   & {\color{red}} &  &  &  &  &                                  \\
 &  &   &  &   &  &  &  & {\color{red} } &  &                                  \\
 &  &   &  &   & {\color{red}} &  &   &  &  &                                  \\
 &  &   &  &  &  &  & {\color{red}} &  &  &                                  \\
 &  &    &    &   &  &  &    &  &  & {\color{red}}                                   \\
 &  &   &  &  &  &  &  &  &  & {\color{red}}                                 \\
 &  &   &  &  &  &  & {\color{red}} &  &  &                                  \\
 &  &   &  &  &  &  &  & {\color{red}} &  &                                  \\
 &  &   &  &  &  &  &  &  &  & {\color{red}}                                 \\
 &  &   &  &  &  &  &  & {\color{red}} &  &                                  \\
 &  &   &  &  & {\color{red}} &  &  &  &  &                                  \\
 &  &   &  &  &  &  & {\color{red}} &  &  &                                   \\
\hline
\hline
Avg.              &  &   &  &  &  &  &  &  &  & {\color{red} } \\
\hline
\end{tabular}
\label{tab:office_results_surf_cv}
\end{table*}



\begin{table*}[!htb]
\caption{Accuracy \% on the Office+Caltech images with  features.
    1NN was used as the base classifier.}
    \vspace{-1em}
\centering
\begin{tabular}{| c || c | c | c  | c | c | c | c | c | c | c | }
\hline
Dataset           & Raw     & KPCA       & TCA     & SSTCA & GFK & TSC & SA      & TJM     & uSCA    & SCA    \\
\hline
\hline
 &  &   &  &  &  &  &  &  &  & {\color{red}}                                 \\
 &  &   &  &  &  &  &  & {\color{red}} &  &                                   \\
 &  &   &  &  &  &  & {\color{red}} &  &  &                                  \\
 &  &   &  &  &  &  &  &  &  & {\color{red}}                                 \\
 &  & {\color{red}}   & {\color{red}} & {\color{red}}   & {\color{red}} &   {\color{red}} & {\color{red}}   & {\color{red}} & {\color{red}}   & {\color{red}}                                   \\
 &  &   &  &  &  &  &  & {\color{red}} &  &                                  \\
 &  &   &  &  &  &  &  & {\color{red}} &  &                                  \\
 &  &   &  &  &  &  & {\color{red}} &  &  &                                  \\
 &  &   &  &  &  &  &  & {\color{red} } &  &                                  \\
 &  &   &  &  &  &  &  & {\color{red}} &  &                                  \\
 &  &   &  &  & &  &  &  &  & {\color{red} }                                 \\
 &  &   &  &  &  &  &  &  &  &  {\color{red}}                               \\
\hline
\hline
Avg.              &  &   &  &  &  &  &  &  &  & {\color{red} } \\
\hline
\end{tabular}
\label{tab:office_results_decaf_cv}
\end{table*}



\vspace{-0.5em}
\subsubsection{Baselines and Protocol}
\label{sec:exp1_baseline}
We compared the classification performance of the following algorithms:
1) a classifier on raw features (Raw),
2) KPCA,
3) Transfer Component Analysis (TCA)~\cite{Pan2011},
4) SSTCA,
5) Geodesic Flow Kernel (GFK)~\cite{Gong:2012aa},
6) Transfer Sparse Coding (TSC)~\cite{Long:2013aa},
7) Subspace Alignment (SA)~\cite{Fernando:2013aa},
8) TJM~\cite{Long2014a},
9) unsupervised Scatter Component Analysis, and
10) SCA.
For a realistic setting, the tunable hyper-parameters were selected via 5-fold cross validation, according to labels from source domains only.

The above feature learning algorithms were evaluated on three different classifiers: 
1) 1-nearest neighbor (1NN), 2) support vector machines with linear kernel (L-SVM) \cite{Boser:1992aa}, and 3) domain adaptation machines (DAM) \cite{DAM:2012}.
1NN and L-SVM are the standard off-the-shelf classifiers, while DAM is specifically designed for domain adaptation. 
DAM is an extension of SVM that incorporates a domain-dependent regularization to encourage the target classifier sharing similar prediction values with the source classifiers.
We also utilize the linear kernel for DAM.


\subsubsection{Classification Accuracy with 1-Nearest Neighbor}
\label{sec:exp1_acc}
We first report the classification accuracy of the competing algorithms according to 1NN classifier.
The goal is to clearly highlight the adaptation impact induced purely from the representations,
since 1NN basically just measures the distance between features.


Table~\ref{tab:exp1_results_cv} summarizes the classification accuracy on the USPS+MNIST and MSRC+VOC2007 pairs.
We can see that SCA is the best model on average, while the prior state-of-the-art TJM is the second best.
Other domain adaptation algorithms (TCA, SSTCA, GFK, and TSC) do not perform well, even worse than one without adaptation strategy: KPCA.
Surprisingly, the unsupervised version of our algorithm, uSCA, has the highest accuracy on two MSRC+VOC2007 cases.
This indicates that the label incorporation does not help improve domain adaptation on the MSRC+VOC2007, while it clearly does on the USPS+MNIST.
Furthermore, SCA and uSCA always provide improvement over the raw features, while other algorithms, including TJM, fail to do so in  case.

Surprisingly, SSTCA, which also incorporates label information during training, does not perform competitively. 
The first possible explanation is that SCA \emph{directly} improves class separability, whereas SSTCA maximizes a dependence criterion that relates \emph{indirectly} to separability.
The second is that SSTCA incorporates the manifold regularization that requires a similarity graph, i.e., affinity matrix. 
This graph is parameterized by k-nearest neighbor with  distance, which might not be suitable in these cases.

The results on the Office+Caltech pair are summarized in Table~\ref{tab:office_results_surf_cv} (SURF-BoW) and Table~\ref{tab:office_results_decaf_cv} ().
In general,  induces stronger discriminative performance than SURF-BoW features, since  with 1NN only has already provided significantly better performance.
SCA consistently has the best average performance on both features, slightly better than the prior state-of-the-art, TJM. 
On SURF-BoW, SCA is the best model on 3 out of 12 cases and the second best on other 4 cases.
The trend on  is better -- SCA has the best performance on 5 out of 12 cases, while comes second on other 6 cases.
Although the closest competitor, TJM, has the highest number of individual best cross-domain performance, it requires higher computational complexity than SCA, see Section~\ref{sec:exp1_runtime} below.



Recall that the algorithms' hyper-parameters used to produce all the above results were tuned using labels from the source domain only.
This is the only valid tuning protocol for the unsupervised domain adaptation setting.
Nevertheless, some of the best results established in the literature were obtained using the hyper-parameter tuning on target labels.
For completeness, we also report the results under this tuning-on-target protocol in the supplementary material.


\begin{figure*}[htp]
	\centering
	\subfigure[MNIST+USPS, MSRC+VOC]{\includegraphics[width=2.3in]{digobj_relative_raw.png}} \label{fig:digobj}\quad
	\subfigure[Office+Caltech (SURF-BoW)]{\includegraphics[width=2.3in]{surf_relative_raw.png}} \label{fig:office_surf} \quad
	\subfigure[Office+Caltech ()]{\includegraphics[width=2.3in]{decaf6_relative_raw.png}} \label{fig:office_decaf}
	\caption{L-SVM and DAM average performance accuracy (\%) relative to the performance on Raw features. The numbers on the top or bottom of the bars show the absolute accuracy. 
	The red line indicates the Raw baseline performance, see Table \ref{tab:raw_summ} for the exact numbers.
	}
	\label{fig:svm_dam}
\end{figure*}

\vspace{-1em}
\begin{table}[!htb]
\centering
\caption{Average accuracy (\%) on Raw features.}
\vspace{-1em}
\begin{tabular}{| c || c | c | c  | }
\hline
Dataset & 1-NN & L-SVM & DAM \\
\hline
MNIST+USPS, MSRC+VOC &  &  &  \\
Office+Caltech (SURF-BoW) &  &  &  \\
Office+Caltech () &  &  &  \\
\hline
\end{tabular}
\label{tab:raw_summ}
\end{table}

\vspace{-1em}
\subsubsection{Classification Accuracy with L-SVM and DAM}
Next we report the results with L-SVM and DAM as the base classifiers for the feature learning algorithms.
For succinctness, we compare the performance of five algorithms: KPCA, SSTCA, SA, TJM, and SCA, presented in Figure \ref{fig:svm_dam}.
The bar chart shows the average accuracies relative to the performance on Raw features (indicated by line  in red); the numbers alongside the bars indicate the absolute accuracies.
Table \ref{tab:raw_summ} summarizes the absolute accuracies on Raw features.


In general, all feature learning algorithms rectify the domain adaptation performances over Raw features, except in two cases: 
SA on the Office+Caltech with SURF-BoW features and KPCA on the Office+Caltech with  features.
Considering the absolute accuracies, we find that the best average performances on each dataset are still provided by SCA, a similar trend as in the 1NN results.
This confirms the effectiveness of SCA regardless of the classifier choice, at least, among 1NN, L-SVM, and DAM.


Let us now compare the absolute average performance of L-SVM and DAM with the performance of 1NN. 
L-SVM and DAM evidently provide a considerable performance improvement only on the Office+Caltech dataset.
Their performances on less powerful features, that is, the features extracted from the MNIST+USPS and MSRC+VOC, are even worse than 1NN.
A useful lesson from this finding is that one should make use better features to take the real benefit of more advanced classifiers in the context of domain adaptation.


Finally, we seek to investigate the performance impact induced by DAM in comparison to L-SVM.
DAM is expected to provide a better performance, since it is specifically designed for domain adaptation.
From Table \ref{tab:raw_summ} we can see that DAM outperforms L-SVM when operating on Raw features.
Surprisingly, that is not always the case when a feature learning algorithm is applied.
Moreover, L-SVM always produces higher performance gain relative to Raw features.than DAM.
This could be attributed to overfitting considering that DAM has more hyper-parameters than L-SVM.
That is, combining DAM with a feature learning algorithm complicates the whole processs -- recall that the hyper-parameter selection is based on a validation on source data.


\subsubsection{Runtime Performance}
\label{sec:exp1_runtime}
Table~\ref{tab:runtime} compares the average runtime performance of SCA with some other algorithms: KPCA, TCA, SA, TSC, and TJM, on the MNIST+USPS, MSRC+VOC, and Office+Caltech (with ).
All algorithms were executed with MATLAB R2014b by a machine with Intel Core i5-240 CPU, Arch Linux 64-bit OS, and 4GB RAM.
Note that KPCA, TCA, and SCA basically utilizes the same optimization procedure: a single iteration of the eigenvalue decomposition.
TJM requires several iterations of the eigenvalue decomposition with an additional gradient update in each iteration, 
while TSC solves the dictionary learning and sparse coding with an iterative procedure.

In general, SCA is significantly faster than TJM, the closest competitor in accuracy, and TSC.
Specifically, SCA is  to  faster than TJM, and  faster than TSC.
SCA runs at about the same speed as TCA on the MNIST+USPS and MSRC+VOC, and the same speed as SA on the Office+Caltech.
In several other cases, SCA performs slower than KPCA, TCA, and SA.
Note that KPCA, TCA, and SA are less competitive in accuracy compared to SCA and TJM so that the runtime gap is less interesting to be concerned about.

\vspace{-1em}
\begin{table}[!htb]
	\caption{Average runtime (seconds) over all cross-domain tasks in each dataset.}
	\vspace{-1em}
	\centering
\begin{tabular}{| c || c | c | c  | c | c | c | }
	\hline
	Dataset & KPCA & TCA & SA & TJM & TSC &  SCA \\
	\hline
	MNIST+USPS &  &  &  &  &  &  \\
	MSRC+VOC &  &  &  &  &  &  \\
	Office+Caltech &  &  &  &  &  &  \\
	\hline
	\end{tabular}
\label{tab:runtime}
\end{table}



\vspace{-1em}
\section{Experiment II : Domain Generalization} 
\label{sec:exp2}
In the second set of experiments, we show that our proposed algorithm is also applicable for domain generalization 
and achieves state-of-the-art performance on some object and action recognition datasets.
We evaluated our algorithms on three cross-domain datasets: the  VLCS, Office+Caltech, and IXMAS~\cite{Ixmas2006}.


\vspace{-0.5em}
\subsection{Data setup}
\label{exp2:data_setup}
The first cross-domain dataset, which we refer to as the \textbf{VLCS}  consists of images from PASCAL VOC2007 (V)~\cite{pascal-voc-2007}, LabelMe (L)~\cite{LabelMe}, Caltech-101 (C)~\cite{Griffin2007}, and SUN09 (S)~\cite{SUN09} datasets, each of which represents one domain.
These datasets share five object categories: 
\emph{bird}, \emph{car}, \emph{chair}, \emph{dog}, and \emph{person}.
Each domain in the VLCS dataset was divided into a training set () and a test set () by random selection from the overall dataset.
The detailed training-test configuration for each domain is summarized in the supplementary material.
We employed the  features \cite{Donahue:2014aa} with dimensionality of 4,096 as inputs to the algorithms.
These features are publicly available.\footnote{\url{http://www.cs.dartmouth.edu/~chenfang/proj_page/FXR_iccv13/index.php}}

The second cross-domain dataset is the \textbf{Office+Caltech} dataset, see Section~\ref{sec:exp1_datasetup} for a detailed explanation about this dataset.
We also used  features extracted from this dataset.\footnote{\url{http://vc.sce.ntu.edu.sg/transfer_learning_domain_adaptation/}}
The third dataset is the \textbf{IXMAS} dataset~\cite{Ixmas2006} that contains videos of the 11 actions, recorded with different actors, cameras, and viewpoints.
This dataset has been used as a benchmark for evaluating human action recognition models.
To simulate the domain generalization problem, we followed the setup proposed in \cite{Xu2014}: only frames from five actions were utilized (\emph{check watch}, \emph{cross arms}, \emph{scratch head}, \emph{sit down}, and \emph{get up}) with domains represented represented by camera viewpoints (Cam 0, Cam 1, ..., Cam 4). 
The task is to learn actions from particular camera viewpoints and classify actions on unseen viewpoints.
In the experiment, we used the dense trajectories features~\cite{DTrajectory2013} extracted from the raw frames and applied K-means clustering to build a codebook with 1,000 clusters 
for each of the five descriptors: trajectory, HOG, HOF, MBHx, MBHy. 
The bag-of-words features were then concatenated forming a 5,000 dimensional features for each frame.

\begin{table*}[!htb]
\caption{The groundtruth 1NN accuracy  of five-class classification when training on one dataset (the left-most column) and testing on another (the upper-most row).
The bold black numbers indicate \emph{in-domain} performance, while the plain black indicate  \emph{cross-domain} performance. 
``Self'' refers to training and testing on the same dataset, same as the bold black numbers and ``mean others'' refers to the average performance over all cross-domain cases.
}
\vspace{-1em}
  \centering
\begin{tabular}{| c || c | c | c | c || c | c | c |}
    \hline
    Training/Test & VOC2007  & LabelMe & Caltech-101 & SUN09 & Self & Mean others & Percent drop ()\\
    \hline
    VOC2007 &  &  &  &  &  &  & {\color{red}}\\
    LabelMe &  &  &  &  &  &  & {\color{red} }\\ 
    Caltech-101 &  &  &  &  &  &  & {\color{red}}\\
    SUN09 &  &  &  &  &  &  & {\color{red}}\\
    \hline
    Mean others &  &  &  &  &  &  & {\color{red}}\\
    \hline
    \end{tabular}
\label{tab:vlcs_bias}
\end{table*}
\begin{table*}[!htb]
	\caption{Domain generalization performance accuracy () on the VLCS dataset with  features as inputs. 
	The accuracy of all feature learning-based algorithms: Raw, KPCA, uSCA, DICA, SCA is according to 1-nearest neighbor (1NN) classifier.
	Bold red and bold black indicate the best and the second best performance, respectively.}
	\vspace{-1em}
	\centering
\begin{tabular}{| c | c || c | c || c | c | c | c | c | c | c | }
	\hline
	Source & Target & 1NN & L-SVM & KPCA & Undo-Bias & UML & LRE-SVM & uSCA & DICA & SCA \\
	\hline
	L,C,S & V &  &  &  &  &  &  &  & & {\color{red} } \\	
	V,C,S & L &  &  &  &  &  & {\color{red}} &  & &  \\
	V,L,S & C &  &  &  &  & {\color{red} } &  &  &  &  \\
	V,L,C & S &  &  &  &  &  &  &  &  & {\color{red} }\\
	C,S & V,L &  &  &  &  &  &  &  &  & {\color{red} }\\
	C,L & V,S &  &  &  & &  &  & &  & {\color{red}}\\
	V,C & L,S &  &  &  & {\color{red}} &  &  &  &  &  \\
	\hline
	 \multicolumn{2}{| c ||}{Avg.}&   &  &  &  &  &  &  &  & {\color{red}}\\

	\hline
	\end{tabular}
\label{tab:exp2_vlcs}
\end{table*}
\begin{table*}[!htb]
	\caption{Domain generalization performance accuracy () on the Office+Caltech dataset with  features as inputs.}
	\vspace{-1em}
	\centering
	\begin{tabular}{| c | c || c | c ||  c | c | c | c | c | c | c |}
	\hline
Source & Target & 1NN & L-SVM & KPCA & Undo-Bias & UML & LRE-SVM & uSCA &  DICA & SCA\\
	\hline
W, D, C & A    &   &  &  &  &  &  &  &  &  {\color{red}} \\
	A,W,D   & C    &   &  &  &   &  &  &  &  &  {\color{red}} \\
	A,C      & D,W &   &  &  &  &  &  &  &  & {\color{red}}\\
	D,W     & A,C  &   &  &  &  &  & {\color{red}} &  &   & \\
\hline
	\multicolumn{2}{ | c ||}{Avg.} &  &  &  &  &  & {\color{red} } &  &  &  \\
	\hline
	\end{tabular}
	\label{tab:office_results}
\end{table*}
\begin{table*}[!htb]
	\caption{Domain generalization performance accuracy () on the IXMAS dataset with dense trajectory-based features.}
	\vspace{-1em}
	\centering
	\begin{tabular}{| c | c || c | c || c | c | c | c | c | c | c | }
	\hline
	Source & Target & 1NN & L-SVM & KPCA & Undo-Bias & UML &  LRE-SVM & uSCA & DICA & SCA \\
	\hline
	Cam 0,1 & Cam 2,3,4 &  &  &   &  &  &  &  &  & {\color{red}}\\
	Cam 2,3,4 & Cam 0,1 &  &  &  &  &  &  &  &  & {\color{red} }\\
	Cam 0,1,2,3 & Cam 4 &  &  &  &  &  & {\color{red} } &  &   & \\
	\hline
\multicolumn{2}{| c ||}{Avg.} &  &  &  &  &  &   & &  & {\color{red}} \\
	\hline
	\end{tabular}
	\label{tab:ixmas_results}
\end{table*}

\subsection{Baselines and Protocol}
\label{sec:exp2_protocol}
We compared our algorithms with the following baselines:

\begin{itemize}[leftmargin=*]
 \item \textbf{1NN}: 1-nearest neighbor classifier.
 \item \textbf{L-SVM}: SVM classifier with linear kernel.
 \item \textbf{KPCA}~\cite{Scholkopf1998}: Kernel Principal Component Analysis.
 \item \textbf{Undo-Bias}~\cite{Khosla2012}: a multi-task SVM-based algorithm for undoing dataset bias. Three hyper-parameters () require tuning. 
 Since the original formulation was designed for binary classification, we performed the following setup for multi-class classification purposes.
 We trained  individual Undo-Bias classifiers , where  is the number of classes.
 At the prediction stage, given a test instance  we computed .
 Finally, we verified whether .
 \item \textbf{UML}~\cite{Fang2013}: a structural metric learning-based algorithm that aims to learn a less biased distance metric for classification tasks.
 The initial tuning proposal for this method was using a set of weakly-labeled data retrieved from querying class labels to search engine. However, here we tuned the hyper-parameters using the same k-fold cross-validation strategy as others for a fair comparison.
 \item \textbf{DICA}~\cite{Muandet2013}: a kernel feature extraction method for domain generalization. DICA has three tunable hyper-parameters.
 \item \textbf{LRE-SVM}~\cite{Xu2014}: a non-linear exemplar-SVMs model with a nuclear norm regularization to impose a low-rank \emph{likelihood matrix}. 
 LRE-SVM has four hyper-parameters (, , , ) that require tuning.
\end{itemize}
Undo-Bias, UML, and LRE-SVM are the prior state-of-the-art domain generalization algorithms for object recognition tasks.
Note that Undo-Bias, DICA, and UML cannot be applied to the domain adaptation setting -- they do not all

We used 1-nearest neighbor (1NN) as the base classifier for all feature learning-based algorithms: KPCA, DICA, uSCA/uDICA, and SCA.
The tunable hyper-parameters were selected according to labels from source domains.
For all kernel-based methods, the kernel function is the RBF kernel, , with a kernel bandwidth  computed by \emph{median heuristic}.
Note that the unsupervised DICA (uDICA) is almost identical to uSCA in this case. The only difference is that uSCA has a control parameter  for the domain scatter/distributional variance term.

\vspace{-1em}
\subsection{Results on the VLCS Dataset}
On this dataset, we first conducted the standard training-test evaluation using 1-nearest neighbor (1NN), i.e., learning the model on a training set from one domain and testing it on a test set from another domain, to check the groundtruth performance and also to identify the existence of the dataset bias.
The groundtruth evaluation results are summarized in Table~\ref{tab:vlcs_bias}.
In general, the dataset bias indeed exists despite the use of the state-of-the-art deep convolution neural network features .
For example, the average cross-domain performance, i.e., "Mean others", is , which is  drop from the corresponding in-domain performance: .
In particular, Caltech-101 has the highest bias, while LabelMe is the least biased dataset indicated by the largest and smallest performance drop, respectively.

We then evaluated the domain generalization performance over seven cross-domain recognition tasks.
The complete results are summarized in Table~\ref{tab:exp2_vlcs}.
We can see that SCA is the best model on 5 out of 7 tasks, outperforms the prior state-of-the-art, LRE-SVM.
It almost always has better performance than the `raw' baseline, except when Caltech-101 is the target domain.
On average, SCA is about  better than its closest competitor on this dataset, Undo-Bias.
The VLCS cross-domain recognition is a hard task in general, since the best model (SCA) only provides  average improvement over the raw baseline.
Furthermore, three algorithms, two of which are the domain generalization-based methods (uSCA, DICA), cannot achieve even better performance than the raw baseline.


\subsection{Results on the Office+Caltech Dataset}
We evaluated our algorithms on several cross-domain cases constructed from the Office+Caltech dataset. 
The detailed evaluation results on four cases with  are reported in Table~\ref{tab:office_results}.
We do not report other cross-domain cases that are possibly constructed from this dataset, such as  and , 
since 1NN on Raw features has already provided high accuracies ().


The closest competitor to SCA is LRE-SVM.
Although LRE-SVM performs best on average, SCA has the best performance on three out of four cross-domain cases and comes second on average.
The only case when SCA underperforms LRE-SVM is that of .
Note that the LRE-SVM algorithm is more complex than SCA both in the optimization procedure and in the number of tunable hyper-parameters.


However, the unsupervised version of our algorithm, uSCA, which is the same as uDICA~\cite{Muandet2013} in the domain generalization case, cannot compete with the state-of-the-art models. 
It is only slightly better than KPCA on average.
This suggests that incorporating labeled information from source domains during feature learning does improve domain generalization on the Office+Caltech cases.

\subsection{Results on the IXMAS dataset}
Table~\ref{tab:ixmas_results} summarizes the classification accuracies on the IXMAS dataset over three cross-domain cases.
We can see that the standard baselines (Raw, KPCA) cannot match other algorithms with domain generalization strategies.
In this dataset, SCA has the best performance on two out of three cases and on average. 
In particular, SCA is significantly better than others on Cam 2,3,4  Cam 0,1 case.
LRE-SVM remains the closest competitor of SCA -- it has the second best average performance with one best cross-domain case.

\vspace{-1em}
\subsection{Runtime Performance}
Next we report the average (training) runtime performance over all cross-domain recognition tasks in each dataset.
All algorithms were executed using the same software and machine as described in Section~\ref{sec:exp1_runtime}.
From Table~\ref{tab:runtime_dg}, we can see that the runtime of SCA is on par with KPCA and DICA, which is expected since they utilize the same optimization procedure: a single run with a generalized eigenvalue decomposition.


SCA is significantly faster than some prior state-of-the-art domain generalization methods (Undo-Bias, UML, and LRE-SVM).
For example, on the VLCS dataset, Undo-Bias, UML, and LRE-SVM require  minutes, while SCA only needs  minutes average training time.
An analogous trend can also be seen in the case of Office+Caltech and IXMAS datasets.
This outcome indicates that SCA is better suited for domain generalization tasks than the competing algorithms if a training stage in real time is required.

\begin{table}[!htb]
	\caption{Average domain generalization runtime (seconds) over all cross-domain recognition tasks in each dataset.}
	\vspace{-1em}
	\centering
	\scalebox{0.82}{
	\begin{tabular}{| c || c | c | c | c | c | c |}
	\hline
	Dataset & KPCA & Undo-Bias & DICA & UML & LRE-SVM & SCA \\
	\hline
	VLCS 		&  &  &  &  &  & \\
	Office+Caltech 	&  &   &   &  &   &  \\
	IXMAS 		&  &  &   &  &  &  \\
	\hline
	\end{tabular}
	}
	\label{tab:runtime_dg}
\end{table}


\vspace{-1em}
\section{Conclusions}
\label{sec:conc}
The scatter-based objective function is a straightforward way to encode the relevant structure of the domain adaptation and domain generalization problems. 
SCA uses variances between subsets of the data to construct a linear transformation that dampens unimportant distinctions (within labels and between domains) and amplifies useful distinctions (between labels and overall variability). 
Extensive experiments on several cross-domain image datasets show that SCA is much faster than competing algorithms and provides the state-of-the-art performance on both domain adaptation and domain generalization.

Our theoretical analysis shows that scatter with two input domains, i.e., domain scatter, provides generalization bounds for domain adaptation~\cite{Mansour2009}. In the setting of domain generalization, recall remark~\ref{rem:gen_scatter}, prior work has shown that the distributional variance (which is a special case of scatter) arises as one of the terms controlling generalization performance \cite{Muandet2013}. Scatter is thus a unifying quantity that controls generalization performance in domain adaptation and generalization.

SCA is a natural extension of Kernel PCA, Kernel Fisher Discriminant and TCA. 
In contrast, many domain adaptation methods use objective functions that combine the total variance and MMD with quantities that are fundamentally different in kind such as the graph Laplacian \cite{Long:2013aa}, sparsity constraints \cite{Long:2013aa,Long2014a}, the Hilbert-Schmidt independence criterion \cite{Pan2011} or the central subspace \cite{Muandet2013}. SCA can easily be extended to semi-supervised domain adaptation, by incorporating target labels into the class scatters. 
Finally, we remark that it should be possible to speed up SCA for large-scale problems using random features~\cite{Rahimi:07}. 




In general, dataset bias remains far from solved. 
Existing algorithms perform satisfactorily ( accuracy) only in several cross-domain tasks, even when using powerful feature extraction methods such as  (for images) and dense trajectory-based features (for videos).
Using less powerful features (raw pixels or SURF-BoW) is clearly unsatisfactory.
Thus, it is crucial to develop more fundamental feature learning algorithms that significantly reduce dataset bias in a wide range of situations.

\vspace{-1em}
\section{Acknowledgments} 
The authors would like to thank Zheng Xu for sharing the extracted dense trajectories features from the IXMAS dataset, and also Chen Fang for sharing the \emph{Unbiased Metric Learning} code and useful discussions.
\vspace{-1em}


\bibliographystyle{IEEEtran}
{
\footnotesize
\bibliography{pamirefs}
}


\begin{IEEEbiography}[{\includegraphics[width=1in,height=1.25in,clip,keepaspectratio]{gif_color.png}}]{Muhammad Ghifary} 
received BEng and MEng degrees from Institut Teknologi Bandung (ITB), Indonesia, 
and has been awarded a PhD degree from Victoria University of Wellington, New Zealand.
He is currently working at Weta Digital as a research intern.
Previously, he worked at ITB and Catholic Parahyangan University as a lecturer.
He is a student member of the IEEE and AAAI. 
He has published his work at conferences such as ICASSP, ICCV, and ICML.
His main research interests include domain adaptation, transfer learning, representation learning, deep learning, and their applications in computer vision.
\end{IEEEbiography}
\vspace{-3em}
\begin{IEEEbiography}[{\includegraphics[width=1in,height=1.25in,clip,keepaspectratio]{david.jpg}}]{David Balduzzi}
received a PhD degree in mathematics from the University of Chicago in 2006. He subsequently held positions at the Max Planck Institute for Intelligent Systems and ETH Zurich. He is currently a senior lecturer in the School of Mathematics and Statistics at Victoria University Wellington. His research interests are machine learning and computational neuroscience. He has published his work at conferences such as NIPS, ICML, UAI, AAAI, AAMAS and ICCV, and in journals such as Annals of Statistics, Network Science and PLoS Computational Biology.
\end{IEEEbiography}
\vspace{-3em}
\begin{IEEEbiography}[{\includegraphics[width=1in,height=1.25in,clip,keepaspectratio]{BastiaanKleijn.jpg}}]{W. Bastiaan Kleijn}
has been a Professor at Victoria University of Wellington since 2010. 
He is also a Professor at Delft University of Technology (part-time) and was a Professor at KTH, where he headed the Sound and Image Processing Laboratory until he moved to New Zealand. Before joining KTH in 1996, he worked at AT \&T Bell Laboratories (Research) on speech processing. 
He was a founder of Global IP Solutions, which developed voice and video processing engines for, among others, Google, Skype, and Yahoo and was sold to Google in 2010. 
He holds a Ph.D. in electrical engineering from Delft University of Technology and an M.S.E.E. from Stanford. 
He also earned a Ph.D. in soil science and an M.S. in physic from the University of California, Riverside. 
He is a Fellow of the IEEE.
\end{IEEEbiography}
\vspace{-3em}
\begin{IEEEbiography}[{\includegraphics[width=1in,height=1.25in,clip,keepaspectratio]{mengjie-new.jpg}}]{Mengjie Zhang}
received the B.E. and M.E. degrees from Artificial Intelligence Research Center, Agricultural University of Hebei, Hebei, China, and the Ph.D. degree in computer science from RMIT
University, Melbourne, VIC, Australia, in 1989, 1992, and 2000, respectively.
Since 2000, he has been with the Victoria University of Wellington, Wellington, New Zealand, where he is currently Professor of Computer Science, Head of the Evolutionary Computation Research Group, and the Associate Dean (Research and Innovation) in the Faculty of Engineering.
His current research interests include evolutionary computation, particularly genetic programming, particle swarm optimization, and learning classifier systems with application areas of image analysis, multiobjective optimization, classification with unbalanced data, feature selection and reduction, and job shop scheduling. 
He has published over 350 academic papers in refereed international journals
and conferences.


\end{IEEEbiography} 
\end{document} 
