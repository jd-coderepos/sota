\documentclass[copyright]{eptcs}


\providecommand{\event}{QAPL 2012}
\providecommand{\volume}{??}
\providecommand{\anno}{2012}
\providecommand{\firstpage}{1}
\providecommand{\eid}{??}

\usepackage{amssymb}
\usepackage{epsf}





\def\ms#1{\null\ifmmode\mathord{\mathcode`-="702D\it #1\mathcode`\-="2200}\else\fi}

\newcommand{\cws}[2]
	{\\ \centerline{} \\begin{array}{|rcll|}
\hline
P & \; ::= \; & \nil & \hspace{0.5cm} \textrm{inactive process} \\
& | & \lap a, \lambda \rap . P & \hspace{0.5cm} \textrm{exponentially timed action prefix} \\
& | & P + P & \hspace{0.5cm} \textrm{alternative composition} \\
& | & X & \hspace{0.5cm} \textrm{process variable} \\
& | & {\rm rec} \, X : P & \hspace{0.5cm} \textrm{recursion} \\
& | & P / H & \hspace{0.5cm} \textrm{hiding} \\
& | & P \pco{S} P & \hspace{0.5cm} \textrm{parallel composition} \\
\hline
\end{array}\begin{array}{|c|}
\hline
\hspace*{1.4cm} (\textsc{Pre}_{\rm M}) \hspace{0.2cm} {\infr{}{\lap a, \lambda \rap . P \arrow{a,
\lambda}{\rm M} P}} \hspace{0.8cm}
(\textsc{Rec}_{\rm M}) \hspace{0.2cm} {\infr{P \{ \textrm{rec} \, X : P \hookrightarrow X \} \arrow{a,
\lambda}{\rm M} P'}{\textrm{rec} \, X : P \arrow{a, \lambda}{\rm M} P'}} \0.8cm]
(\textsc{Hid}_{\rm M, 1}) \hspace{0.2cm} {\infr{P \arrow{a, \lambda}{\rm M} P' \hspace{0.5cm} a \notin H}{P
/ H \arrow{a, \lambda}{\rm M} P' / H}} \hspace{0.8cm}
(\textsc{Hid}_{\rm M, 2}) \hspace{0.2cm} {\infr{P \arrow{a, \lambda}{\rm M} P' \hspace{0.5cm} a \in H}{P / H
\arrow{\tau, \lambda}{\rm M} P' / H}} \0.8cm]
(\textsc{Syn}_{\rm M}) \hspace{0.2cm} {\infr{P_{1} \arrow{a, \lambda_{1}}{\rm M} P'_{1} \hspace{0.5cm} P_{2}
\arrow{a, \lambda_{2}}{\rm M} P'_{2} \hspace{0.5cm} a \in S}{P_{1} \pco{S} P_{2} \arrow{a, \lambda_{1}
\otimes \lambda_{2}}{\rm M} P'_{1} \pco{S} P'_{2}}} \\
\hline
\end{array}\begin{array}{|lrcl|}
\hline
(\cala_{{\rm MB}, 1}) \quad & P_{1} + P_{2} & = & P_{2} + P_{1} \\
(\cala_{{\rm MB}, 2}) \quad & (P_{1} + P_{2}) + P_{3} & = & P_{1} + (P_{2} + P_{3}) \\
(\cala_{{\rm MB}, 3}) \quad & P + \nil & = & P \\
(\cala_{{\rm MB}, 4}) \quad & \lap a, \lambda_{1} \rap . P + \lap a, \lambda_{2} \rap . P & = & \lap a,
\lambda_{1} + \lambda_{2} \rap . P \\
\hline
\end{array}\begin{array}{|lrcl|}
\hline
(\cala_{{\rm MB}, 5}) \quad & \lap a, \lambda \rap . \sum\limits_{i \in I} \lap \tau, \mu_{i} \rap .
\sum\limits_{j \in J_{i}} \hspace{-0.1cm} \lap \tau, \gamma_{i, j} \rap . P_{i, j} & = & \
where  is a finite index set,  is a finite index set for all , , and  for all .

\item  induces a CTMC-level aggregation called W-lumpability, which is exact only at steady
state and performs reductions consistent with . Moreover,  preserves
transient properties expressed in terms of the mean time to certain events.

\item  can be decided in polynomial time only for those finite-state processes that are not
divergent, i.e., that have no cycles of exponentially timed -transitions.

	\end{itemize}



\section{Compositionality for Concurrent Processes}\label{concproc}


The relation  is not a congruence with respect to the parallel composition operator, thus
restricting the usefulness for compositional state space reduction purposes of the framework developed
in~\cite{Ber}.

	\begin{example}\label{wmbenocongrparex}

Assuming parallel composition to have lower priority than any other operator, it holds that:
\cws{0}{\lap a, \lambda \rap . \lap \tau, \mu \rap . \lap \tau, \gamma \rap . \nil \: \obis{\rm MB} \: \lap
a, \lambda \rap . \lap \tau, {\mu \cdot \gamma \over \mu + \gamma} \rap . \nil}
while:
\cws{0}{\lap a, \lambda \rap . \lap \tau, \mu \rap . \lap \tau, \gamma \rap . \nil \pco{\emptyset} \lap a',
\lambda' \rap . \nil \: \not\obis{\rm MB} \: \lap a, \lambda \rap . \lap \tau, {\mu \cdot \gamma \over \mu +
\gamma} \rap . \nil \pco{\emptyset} \lap a', \lambda' \rap . \nil}
First of all, we note that:
\cws{0}{\lap \tau, \mu \rap . \lap \tau, \gamma \rap . \nil \pco{\emptyset} \lap a', \lambda' \rap . \nil \:
\not\wbis{\rm MB} \: \lap \tau, {\mu \cdot \gamma \over \mu + \gamma} \rap . \nil \pco{\emptyset} \lap a',
\lambda' \rap . \nil}
In fact, for  the two process terms are not fully unstable with:
\cws{0}{\begin{array}{rcl}
\ms{rate}(\lap \tau, \mu \rap . \lap \tau, \gamma \rap . \nil \pco{\emptyset} \lap a', \lambda' \rap . \nil,
\tau, [\lap \tau, \gamma \rap . \nil \pco{\emptyset} \lap a', \lambda' \rap . \nil]_{\wbis{\rm MB}}) & = &
\mu \\
\ms{rate}(\lap \tau, {\mu \cdot \gamma \over \mu + \gamma} \rap . \nil \pco{\emptyset} \lap a', \lambda'
\rap . \nil, \tau, [\lap \tau, \gamma \rap . \nil \pco{\emptyset} \lap a', \lambda' \rap . \nil]_{\wbis{\rm
MB}}) & = & 0 \\
\end{array}}
On the other hand, for  the two process terms are fully unstable with:
\cws{0}{\begin{array}{rcl}
\ms{pbtm}(\lap \tau, \mu \rap . \lap \tau, \gamma \rap . \nil \pco{\emptyset} \lap a', \lambda' \rap . \nil,
[\nil \pco{\emptyset} \nil]_{\wbis{\rm MB}}) & = & \lmp ({\mu \over \mu + \lambda'} \cdot {\gamma \over
\gamma + \lambda'}) \cdot ({1 \over \mu + \lambda'} + {1 \over \gamma + \lambda'} + {1 \over \lambda'}), \\
& & \hspace*{0.3cm} ({\mu \over \mu + \lambda'} \cdot {\lambda' \over \gamma + \lambda'}) \cdot ({1 \over
\mu + \lambda'} + {1 \over \gamma + \lambda'} + {1 \over \gamma}), \\
& & \hspace*{0.3cm} ({\lambda' \over \mu + \lambda'}) \cdot ({1 \over \mu + \lambda'} + {1 \over \mu} + {1
\over \gamma}) \rmp \\
\ms{pbtm}(\lap \tau, {\mu \cdot \gamma \over \mu + \gamma} \rap . \nil \pco{\emptyset} \lap a', \lambda'
\rap . \nil, [\nil \pco{\emptyset} \nil]_{\wbis{\rm MB}}) & = & \lmp ({{\mu \cdot \gamma \over \mu + \gamma}
\over {\mu \cdot \gamma \over \mu + \gamma} + \lambda'}) \cdot ({1 \over {\mu \cdot \gamma \over \mu +
\gamma} + \lambda'} + {1 \over \lambda'}), \\
& & \hspace*{0.3cm} ({\lambda' \over {\mu \cdot \gamma \over \mu + \gamma} + \lambda'}) \cdot ({1 \over {\mu
\cdot \gamma \over \mu + \gamma} + \lambda'} + {1 \over {\mu \cdot \gamma \over \mu + \gamma}}) \rmp \\
\end{array}}
Thus:
\cws{0}{[\lap \tau, \mu \rap . \lap \tau, \gamma \rap . \nil \pco{\emptyset} \lap a', \lambda' \rap .
\nil]_{\wbis{\rm MB}} \cap [\lap \tau, {\mu \cdot \gamma \over \mu + \gamma} \rap . \nil \pco{\emptyset}
\lap a', \lambda' \rap . \nil]_{\wbis{\rm MB}} \: = \: \emptyset}
and hence:
\cws{0}{\ms{rate}(\lap a, \lambda \rap . \lap \tau, \mu \rap . \lap \tau, \gamma \rap . \nil \pco{\emptyset}
\lap a', \lambda' \rap . \nil, a, [\lap \tau, \mu \rap . \lap \tau, \gamma \rap . \nil \pco{\emptyset} \lap
a', \lambda' \rap . \nil]_{\wbis{\rm MB}}) \: = \: \lambda}
whereas:
\cws{0}{\ms{rate}(\lap a, \lambda \rap . \lap \tau, {\mu \cdot \gamma \over \mu + \gamma} \rap . \nil
\pco{\emptyset} \lap a', \lambda' \rap . \nil, a, [\lap \tau, \mu \rap . \lap \tau, \gamma \rap . \nil
\pco{\emptyset} \lap a', \lambda' \rap . \nil]_{\wbis{\rm MB}}) \: = \: 0}
Also the two divergent process terms  and , , are related by  but this no longer holds when placing them in the context , .
\fullbox

	\end{example}

Taking inspiration from the weak isomorphism of~\cite{Hil}, in this section we show how to retrieve full
compositionality by enhancing the abstraction capability of  in the case of concurrent
computations. The price to pay is that exactness will hold at steady state only for a certain class of
processes.


\subsection{Revising Weak Markovian Bisimilarity}\label{wmberedef}


As we have seen,  and  abstract from sequences of exponentially timed
-actions while preserving (at the computation level) their execution probability and average duration
and (at the system level) \linebreak transient properties expressed in terms of the mean time to certain
events as well as steady-state performance measures. This kind of abstraction has been done in the simplest
possible case: sequences of exponentially timed -actions labeling computations that traverse
\textit{fully unstable states}.

In order to achieve compositionality when dealing with concurrent processes, a revision of the notion of
reducible computation is unavoidable. More precisely, we need to address the case of sequences of
exponentially timed -actions labeling computations that traverse \textit{unstable states satisfying
certain conditions}. The reason is that, if we view a system description as the parallel composition of
several sequential processes, any of those processes may have local computations traversing \textit{fully
unstable local states}, but in the overall system those local states may be \textit{part of global states
that are not fully unstable}.

For instance, this is the case with the process , whose underlying labeled multitransition system is depicted
below on the left: \0.1cm]
\centerline{\epsfbox{concproc2.eps}}
In this case, for each replica we view its return state as being its final state. In the figure above, for
both replicas the final state coincides with the initial state.

The new notion of replicated reducible computation must be accompanied by an adjustment of the way measure
 and multiset  are calculated. Given a computation  of the form \linebreak
 that is reducible in the sense of Def.~\ref{reducompdef}, the denominator of
the -th fraction occurring in each of the two factors of  can indifferently be
 or : those two values coincide because
 for all . In contrast, if the reducible computation  is
replicated, each of its replicas has a possibly different context and it is fundamental that
 values are taken as denominators, so as to focus on
-transitions. Since there can be -transitions also in the context, each destination of those
exit rates needs to be a specific set  containing only the states traversed by the replicas rather
than the generic set . Taking into account only -transitions leading to states in
 ensures \textit{context independence} in this concurrent setting, which opens the way to the
achievement of the same  value for all the replicas of a reducible computation.

We are by now ready to provide the definition of replicated reducible computation together with the revision
of both  and . Since several reducible computations can depart from the same state
(see the second and the third pair of process terms of Ex.~\ref{wmbeex}), in general we will have to handle
\textit{replicated trees of reducible computations} rather than replicated individual reducible
computations.

In the sequel, we consider  process terms  different from each other. We suppose that  for all
, with  having a nonempty tree of computations that are locally reducible for
all  (see  and  in our example). This tree is formalized as the set
 of all the finite-length computations starting from  such that each of them (i)~is
labeled with a sequence of exponentially timed -actions, (ii)~traverses states that are all different
with the possible exception of the final state and one of its preceding states, and (iii)~shares no
transitions with computations in  for all .

We further suppose that the union of  can be partitioned
into  \textit{groups of replicas} each consisting of  computations from all the
~sets, such that all the computations in the same group have the same length and are labeled with the
same sequence of exponentially timed -actions. As a consequence, for all  we can
write:
\cws{0}{C^{\tau}_{k} \: = \: \{ c_{k, i} \equiv P_{k, i, 1} \arrow{\tau, \lambda_{i, 1}}{\rm M} P_{k, i, 2}
\arrow{\tau, \lambda_{i, 2}}{\rm M} \dots \arrow{\tau, \lambda_{i, l_{i}}}{\rm M} P_{k, i, l_{i} + 1} \mid 1
\le i \le n \}}
where  is the initial state and  is the length of the
computation for all .

	\begin{definition}\label{greducompdef}

The family of computations  is said to
be generally reducible, or g-reducible for short, iff \underline{either}  and for all :

		\begin{itemize}

\item  for all ;

\item  or  for some ;

		\end{itemize}

\noindent
\underline{or} , with  for all  and  when , and for all :

		\begin{itemize}

\item For all , , and :

			\begin{enumerate}

\item \mbox{\rm [Deviation from the replica]} If  with , then:

				\begin{enumerate}

\item[a.] \mbox{\rm [change of replica via context]} either  for some ;

\item[b.] \mbox{\rm [change of computation]} or  with  and  for some  other than  and some .

				\end{enumerate}

\item \mbox{\rm [Context preservation along the replica]} For all , it holds that  iff  for
all .

\item \mbox{\rm [Stage preservation across replicas]} For all  other than  and , \linebreak it holds that  iff
 for all .

			\end{enumerate}

\item \mbox{\rm [Termination]} One of the following holds:

			\begin{enumerate}

\item[.] Whenever there exists  such that  for all ,
then at least one of conditions~1, 2, and~3 above is not satisfied by  for some .

\item[.] There is no  such that  for all .

\item[.]  for all  and some .
\fullbox

			\end{enumerate}

		\end{itemize}

	\end{definition}



\noindent
Some comments are now in order:

	\begin{itemize}

\item In the case that  and all the traversed states are fully unstable (see the ``either'' option),
Def.~\ref{greducompdef} coincides with Def.~\ref{reducompdef} except for the fact that the former considers
a tree of computations whilst the latter considers a single computation.

\item The case  with  for every  and  happens when all the sequential process terms in parallel with the one originating the tree of
locally reducible computations repeatedly execute a single action (selfloop transition), thus causing no
replica of the tree to be formed. Both this case and the case  are subject to conditions~1, 2, 3,
and~4.

\item Condition 1 establishes that each transition deviating (see ) from the
replica of the considered computation of :

		\begin{itemize}

\item either is a vertical transition of the context that preserves the current stage of the replicas and
hence causes the passage to the corresponding state of another replica () or to the same state of
the same replica (, meaning that one of the sequential process terms in parallel with the one
originating the considered computation repeatedly executes a single action);

\item or is a transition belonging to some other computation in  starting from the same
process term  as the considered computation.

		\end{itemize}

These two facts together imply the maximality of , because taking into account deviating
transitions causes all replicas to be included. In addition, they prevent process terms like \linebreak
 and  --
which do not contain occurrences of parallel composition () and have no fully unstable states when  -- from being deemed to be equivalent.

\item Condition 2 is related to condition 1.a and ensures that the context of a replica is preserved along
each state traversed by the replica.

\item Condition 3 is related to condition 1.b and ensures that any transition belonging neither to the
considered computation nor to its context (i.e., belonging to some other computation in ) is
present at the same stage of each replica of the considered computation.

\item The three variants of condition 4 establish the boundary of the replicas of the considered computation
in a way that guarantees the maximality of the length of the replicas themselves under (i)~conditions~1, 2,
and~3, (ii) the constraint that all of their transitions are labeled with exponentially timed
-actions, (iii) and the constraint that all the traversed states are different with the possible
exception of the final state and one of its preceding states.

	\end{itemize}

Let  and  be the sets of initial states and final states of the
computations in . In order to avoid interferences between the computations in  and the transitions belonging to the context of those computations, for
any computation  in  we consider the following context-free measure:
\cws{0}{\ms{probtime}_{\rm cf}(c_{k, i}) \: = \: \left( \prod\limits_{j = 1}^{l_{i}} {\lambda_{i, j} \over
\ms{rate}(P_{k, i, j}, \tau, \calp_{k})} \right) \cdot \left( \sum\limits_{j = 1}^{l_{i}} {1 \over
\ms{rate}(P_{k, i, j}, \tau, \calp_{k})} \right)}
where . In this way, all
replicas of the same computation will have the same  measure, as shown below.

	\begin{proposition}\label{probtimecfprop}

Whenever  is g-reducible, then for all  and :
\cws{12}{\ms{probtime}_{\rm cf}(c_{k, i}) \: = \: \ms{probtime}_{\rm cf}(c_{k', i})}
\fullbox

	\end{proposition}

Moreover, we replace the generic multiset  with the more specific multisets  for all . The latter
multisets are based on  instead of  as well as on  instead of , where 
is the multiset of computations identical to those in  that go from  to  and have average duration~. We point out that computations of length zero are
not considered as , so that whenever , then the calculation of  does take into account computations identical to those in  going
from  to itself.

	\begin{proposition}\label{pbtmcfprop}

Whenever  is g-reducible, then for all :
\cws{12}{\ms{pbtm}_{\rm cf}(P_{k}, \ms{final}(\calc^{\tau})) \: = \: \ms{pbtm}_{\rm cf}(P_{k'},
\ms{final}(\calc^{\tau}))}
\fullbox

	\end{proposition}

We are finally ready to introduce the revised definition of weak Markovian bisimilarity.

	\begin{definition}

An equivalence relation  over  is a g-weak Markovian bisimulation iff, whenever
, then:

		\begin{itemize}

\item For all visible action names  and equivalence classes :
\cws{12}{\hspace*{-0.6cm} \ms{rate}(P_{1}, a, D) \: = \: \ms{rate}(P_{2}, a, D)}

\item If  is not an initial state of any g-reducible family of computations, then  is not an
initial state of any g-reducible family of computations either, and for all equivalence classes :
\cws{12}{\hspace*{-0.6cm} \ms{rate}(P_{1}, \tau, D) \: = \: \ms{rate}(P_{2}, \tau, D)}

\item If  is an initial state of some g-reducible family of computations, then  is an initial
state of some g-reducible family of computations too, and for all g-reducible families of computations
 with  there exists a g-reducible family of
computations  with  such that for all
equivalence classes :
\cws{12}{\hspace*{-0.6cm} \ms{pbtm}_{\rm cf}(P_{1}, D \cap \ms{final}(\calc^{\tau}_{1})) \: = \:
\ms{pbtm}_{\rm cf}(P_{2}, D \cap \ms{final}(\calc^{\tau}_{2}))}

		\end{itemize}

\noindent
G-weak Markovian bisimilarity  is the largest g-weak Markovian bisimulation.
\fullbox

	\end{definition}

	\begin{example}\label{gwmbeex}

The process terms mentioned in each of the three cases of Ex.~\ref{wmbeex} are still related by~. Note that each of those process terms is the only initial state of a g-reducible family of
computations composed by a single computation (first case) or a single tree of computations (second and
third case) traversing only fully unstable states, thus  and the ``either'' option of
Def.~\ref{greducompdef} applies.
\fullbox

	\end{example}

	\begin{example}\label{gwmbecongrparex}

Let us reconsider the two process terms at the beginning of Ex.~\ref{wmbenocongrparex}. Now we have:
\cws{0}{\lap a, \lambda \rap . \lap \tau, \mu \rap . \lap \tau, \gamma \rap . \nil \: \wbis{\rm MB, g} \:
\lap a, \lambda \rap . \lap \tau, {\mu \cdot \gamma \over \mu + \gamma} \rap . \nil}
and:
\cws{0}{\lap a, \lambda \rap . \lap \tau, \mu \rap . \lap \tau, \gamma \rap . \nil \pco{\emptyset} \lap a',
\lambda' \rap . \nil \: \wbis{\rm MB, g} \: \lap a, \lambda \rap . \lap \tau, {\mu \cdot \gamma \over \mu +
\gamma} \rap . \nil \pco{\emptyset} \lap a', \lambda' \rap . \nil}
because it holds that:
\cws{0}{\lap \tau, \mu \rap . \lap \tau, \gamma \rap . \nil \pco{\emptyset} \lap a', \lambda' \rap . \nil \:
\wbis{\rm MB, g} \: \lap \tau, {\mu \cdot \gamma \over \mu + \gamma} \rap . \nil \pco{\emptyset} \lap a',
\lambda' \rap . \nil}
In fact, for  the two process terms are the initial states of two g-reducible families of
computations  and , respectively, each composed of two replicas -- the
first one having context  and final state  and the second one having empty context and final state  --
with:
\cws{0}{\begin{array}{rcl}
\ms{pbtm}_{\rm cf}(\lap \tau, \mu \rap . \lap \tau, \gamma \rap . \nil \pco{\emptyset} \lap a', \lambda'
\rap . \nil, D \cap \ms{final}(\calc^{\tau}_{1})) & = & \lmp {1 \over \mu} + {1 \over \gamma} \rmp \\
\ms{pbtm}_{\rm cf}(\lap \tau, {\mu \cdot \gamma \over \mu + \gamma} \rap . \nil \pco{\emptyset} \lap a',
\lambda' \rap . \nil, D \cap \ms{final}(\calc^{\tau}_{2})) & = & \lmp {\mu + \gamma \over \mu \cdot \gamma}
\rmp \\
\end{array}}
whenever  contains the final state , as the way of
calculating  and  does not take the context into account. \\
For , in addition to  and , the two process terms are the
initial states of two further g-reducible families of computations  and
, respectively, each composed of two replicas of length 1 labeled with . In this case:
\cws{0}{\begin{array}{rcl}
\ms{pbtm}_{\rm cf}(\lap \tau, \mu \rap . \lap \tau, \gamma \rap . \nil \pco{\emptyset} \lap a', \lambda'
\rap . \nil, D \cap \ms{final}(\calc'^{\tau}_{1})) & = & \lmp {1 \over \lambda'} \rmp \0.1cm]
\pi[s_{1, 4}] & = & {2 \over 13} & &
\pi[s_{1, 5}] & = & {3 \over 13} & &
\pi[s_{1, 6}] & = & {4 \over 13} \0.1cm]
\pi[s_{2, 3}] & = & {4 \over 10} & &
\pi[s_{2, 4}] & = & {3 \over 10} \0.1cm]
\pi[s_{1, 4}] + \pi[s_{1, 5}] & \neq & \pi[s_{2, 3}] & &
\pi[s_{1, 6}] & \neq & \pi[s_{2, 4}] \0.1cm]
\pi[s_{3, 4}] & = & {1 \over 6} & &
\pi[s_{3, 5}] & = & {1 \over 6} & &
\pi[s_{3, 6}] & = & {1 \over 6} \0.1cm]
\pi[s_{4, 3}] & = & {2 \over 6} & &
\pi[s_{4, 4}] & = & {1 \over 6} \0.1cm]
\pi[s_{3, 4}] + \pi[s_{3, 5}] & = & \pi[s_{4, 3}] & &
\pi[s_{3, 6}] & = & \pi[s_{4, 4}] \0.1cm]
\end{array}}
\fullbox

	\end{example}



\section{Conclusion}\label{concl}


In this paper, we have introduced  and  as variants of the weak
Markovian bisimulation equivalences  and  proposed in~\cite{Ber}, which suffer
from a limited usefulness for state space reduction purposes as they are not congruences with respect to the
parallel composition operator. The motivation behind  and  is thus that
of retrieving full compositionality. Taking inspiration from the idea of preserving the context
of~\cite{Hil}, this has been achieved by enhancing the abstraction capability -- with respect to  and  -- when dealing with concurrent computations. The price to pay for the resulting
compositional abstraction capability is that the exactness at steady state of the induced CTMC-level
aggregation does not hold for all the considered processes -- as it was for  and  -- but only for sequential processes with abstraction and concurrent processes whose synchronizations
do not take place right before the beginning of computations to be reduced. Additionally, not even transient
properties expressed in terms of the mean time to certain events are preserved in general.

With regard to~\cite{Hil}, where weak isomorphism has been studied, our equivalences  and
 have been developed in the more liberal bisimulation framework. A more important novelty
with respect to weak isomorphism is that we have considered not only individual sequences of exponentially
timed -actions. In fact, we have addressed trees of exponentially timed -actions and we have
established the conditions under which such trees can be reduced -- also in the presence of parallel
composition -- by locally preserving both the average duration and the execution probability of their
branches.

Another approach to abstracting from -actions in an exponentially timed setting comes from~\cite{Bra},
where a variant of Markovian bisimilarity was defined that checks for exit rate equality with respect to all
equivalence classes apart from the one including the processes under examination. Congruence and
axiomatization results were provided for the proposed equivalence, and a logical characterization based on
CSL was illustrated in~\cite{BKHW}. However, unlike  and , nothing was
said about exactness.

As far as future work is concerned, we would like to investigate equational and logical characterizations of
 as well as conduct case studies for assessing its usefulness in practice (especially with
respect to the constraint on synchronizations that guarantees steady-state exactness). With regard to
verification issues, since  for non-divergent process terms,
we have that the equivalence checking algorithm developed for  in~\cite{Ber} can be exploited
for compositional state space reduction with respect to , by applying it to each of the
sequential processes composed in parallel.


\bigskip
\noindent
\textbf{Acknowledgment}: This work has been funded by MIUR-PRIN project \textit{PaCo -- Performability-Aware
Computing: Logics, Models, and Languages}.



\bibliographystyle{eptcs}

\begin{thebibliography}{MM}

\providecommand{\urlalt}[2]{\href{#1}{#2}}
\providecommand{\doi}[1]{doi:\urlalt{http://dx.doi.org/#1}{#1}}

\bibitem{ABC} A.~Aldini, M.~Bernardo, and F.~Corradini,
{\it ``A Process Algebraic Approach to Software Architecture Design''},
Springer, 2010, \doi{10.1007/978-1-84800-223-4}.

\bibitem{BKHW} C.~Baier, J.-P.~Katoen, H.~Hermanns, and V.~Wolf,
{\it ``Comparative Branching-Time Semantics for Markov Chains''},
in Information and Computation~200:149--214, 2005, \doi{10.1016/j.ic.2005.03.001}.

\bibitem{Ber} M.~Bernardo,
{\it ``Weak Markovian Bisimulation Congruences and Exact CTMC-Level Aggregations for Sequential
Processes''},
in Proc.\ of TGC~2011,
LNCS~7173:89--103.

\bibitem{Bra} M.~Bravetti,
{\it ``Revisiting Interactive Markov Chains''},
in Proc.\ of MTCS~2002,
ENTCS~68(5):1--20, \doi{10.1016/S1571-0661(04)80520-6}.

\bibitem{BBG} M.~Bravetti, M.~Bernardo, and R.~Gorrieri,
{\it ``A Note on the Congruence Proof for Recursion in Markovian Bisimulation Equivalence''},
in Proc.\ of PAPM~1998,
pp.~153--164.

\bibitem{Buc} P.~Buchholz,
{\it ``Exact and Ordinary Lumpability in Finite Markov Chains''},
in Journal of Applied Probability~31:59--75, 1994, \doi{10.2307/3215235}.

\bibitem{DHS} S.~Derisavi, H.~Hermanns, and W.H.~Sanders,
{\it ``Optimal State-Space Lumping in Markov Chains''},
in Information Processing Letters~87:309--315, 2003, \doi{10.1016/S0020-0190(03)00343-0}.

\bibitem{HL} W.~Henderson and D.~Lucic,
{\it ``Aggregation and Disaggregation Through Insensitivity in Stochastic Petri Nets''},
in Performance Evaluation~17:91--114, 1993, \doi{10.1016/0166-5316(93)90002-C}.

\bibitem{Her} H.~Hermanns,
{\it ``Interactive Markov Chains''},
LNCS~2428, 2002, \doi{10.1007/3-540-45804-2}.

\bibitem{HR} H.~Hermanns and M.~Rettelbach,
{\it ``Syntax, Semantics, Equivalences, and Axioms for MTIPP''},
in Proc.\ of PAPM~1994,
pp.~71--87.

\bibitem{Hil} J.~Hillston,
{\it ``A Compositional Approach to Performance Modelling''},
Cambridge University Press, 1996, \doi{10.1017/CBO9780511569951}.

\bibitem{Mat} K.~Matthes,
{\it ``Zur Theorie der Bedienungsprozesse''},
in Proc.\ of the {\it 3rd Prague Conf.\ on Information Theory, Statistical Decision Functions and Random
Processes},
pp.~513--528, 1962.

\bibitem{Mil} R.~Milner,
{\it ``Communication and Concurrency''},
Prentice Hall, 1989.

\bibitem{RS} G.~Rubino and B.~Sericola,
{\it ``Sojourn Times in Finite Markov Processes''},
in Journal of Applied Probability~27:744--756, 1989, \doi{10.2307/3214379}.

\bibitem{Ste} W.J.~Stewart,
{\it ``Introduction to the Numerical Solution of Markov Chains''},
Princeton University Press, 1994.

\end{thebibliography}


\end{document}
