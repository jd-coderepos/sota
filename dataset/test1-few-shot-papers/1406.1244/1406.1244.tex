
\documentclass[11pt]{article}
\usepackage[hmargin=3cm,vmargin=3cm]{geometry}
\usepackage{llncsdoc}
\usepackage{pdfpages}
\usepackage{color}
\usepackage{fixltx2e} \usepackage{mparhack} \usepackage{epsfig}
\usepackage[english]{babel}
\usepackage[section]{algorithm}
\usepackage{algpseudocode}
\usepackage{xcolor}
\usepackage{fmtcount} \usepackage[cmex10]{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{mathtools}
\usepackage{amsmath}
\usepackage{wrapfig}
\usepackage{comment}
\usepackage{color}
\usepackage{graphicx}
\usepackage{psfrag}
\usepackage[T1]{fontenc}


\renewcommand{\algorithmiccomment}[1]{// #1}
\newtheorem{theorem}{Theorem}[section]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{example}[theorem]{Example}
\newtheorem{remark}[theorem]{Remark}
\newtheorem{claim}[theorem]{Claim}
\newtheorem{fact}[theorem]{Fact}
\newtheorem{main}[theorem]{Main Theorem}
\newtheorem{invariant}[theorem]{Invariant}
\newtheorem{assumption}[theorem]{Assumption}
\newtheorem{problem}[theorem]{Problem}
\newcommand{\BO}{\mathcal{O}}

\begin{document}
	
\title{
Distributed Approximation of Minimum Routing Cost Trees\thanks{This is a full and extended version of \cite{MRCT-SIROCCO}.} 
}


\author{
Alexandra Hochuli
\\
ETH Zurich
\\
hochulia@ethz.ch\and
Stephan Holzer\footnote{Part of this work was done at ETH Zurich. At MIT the author was supported by the following grants: AFOSR Contract Number FA9550-13-1-0042, NSF Award 0939370-CCF, NSF Award CCF-1217506, NSF Award number CCF-AF-0937274.}
\\
MIT
\\
holzer@mit.edu\and
Roger Wattenhofer
\\
ETH Zurich
\\
wattenhofer@ethz.ch}


\maketitle

\begin{abstract}
We study the NP-hard problem of approximating a Minimum Routing Cost Spanning Tree in the message passing model with limited bandwidth (CONGEST model). In this problem one tries to find a spanning tree of a graph  over  nodes that minimizes the sum of distances between all pairs of nodes. In the considered model every node can transmit a different (but short) message to each of its neighbors in each synchronous round. We provide a randomized -approximation with runtime  for unweighted graphs. Here,  is the diameter of . This improves over both, the (expected) approximation factor  and the runtime  stated in~\cite{khan2008efficient}. 

Due to stating our results in a very general way, we also derive an (optimal) runtime of  when considering -approximations as in~\cite{khan2008efficient}. In addition we derive a deterministic -approximation.


\end{abstract}

\section{Introduction}\label{sec:intro}
A major goal in network design is to minimize the cost of communication between any two
vertices in a network while maintaining only a substructure of the network. Despite the fact that a tree is the sparsest substructure of a network it can be surprisingly close to the optimal solution. Every network contains a tree whose total cost of communication between all pairs of nodes is only a factor two worse than the communication cost when all edges in the graph are allowed to be used!

The problem of finding trees that provide a low routing cost is studied since the early days of computing in the 1960s~\cite{scott1969optimal}
and is known to be NP-hard~\cite{johnson1978complexity} on weighted and unweighted graphs\footnote{Even for seemingly simpler versions than those which we study the problem remains NP-hard~\cite{ye2002polynomial}.}. These days networks of computers and electric devices are omnipresent and trees offer easy and fast implementations for applications. In addition, trees serve as the basis for control structures as well as for information gathering/aggregation and information dissemination. This explains why routing trees are computed and used by wide spread protocols such as the IEEE 802.1D standard~\cite{campos2008fast}. When bridging~\cite{wiki2} is used in Local Area Networks (LAN) and Personal Area Networks (PAN), a spanning tree is computed to define the (overlay)
network topology. Finding such a tree with low routing cost is crucial. As~\cite{campos2008fast} demonstrates, current implementations do not perform well under the aspect of optimizing the routing costs and there is the need to find better and faster solutions. The nature of this problem and growth of wired and wireless networks calls for fast and good distributed implementations. 


In this paper we present new approaches for distributed approximation of a Minimum Routing Cost Spanning Tree (MRCT) while extending previous work for approximation of those. By doing so we improve both, the round complexity and the approximation factor of the best known (randomized) result in a distributed setting for unweighted graphs. Our main contribution is an algorithm that computes a -approximation in time  w.h.p.\footnote{A more precise statement can be found in Theorem~\ref{thm:mrct-rand}. This Theorem also considers a generalized version of MRCT.}. Previously, the best known distributed approximation for MRCT~\cite{khan2008efficient} (on weighted graphs) achieved an (expected) approximation-ratio of  using randomness. The bound on the runtime of the algorithm of~\cite{khan2008efficient} is  in the worst case -- even when the network is fully connected (a clique). For unweighted graphs, the authors of~\cite{khan2008efficient} specify this runtime to be . The distributed algorithms we present in this paper are for unweighted graphs as well\footnote{They extend to graphs with certain realistic weight-functions.} and compared to the (expected) approximation-ratio  of~\cite{khan2008efficient} we essentially obtain a (guaranteed) approximation-ratio  in time  w.h.p.. This follows from choosing  for an arbitrary small . When choosing , we obtain the same approximation ratio as in~\cite{khan2008efficient} in time . To be general, we leave the choice of  to the reader depending on the application.




Besides this randomized solution we present a deterministic algorithm running in linear time  achieving an approximation-ratio of .








\section{Model and Basic Definitions}

Our network is represented by an undirected graph . Nodes  correspond to processors, computers or routers. Two nodes are connected by an edge from set  if they can communicate directly with each other. We denote the number of nodes of a graph by , and the number of its edges by . Furthermore we assume that each node has a unique ID in the range of , i.e. each node can be represented by  bits. Nodes initially have no knowledge of the graph , other than their immediate neighborhood.

We consider a synchronous communication model, where every node can send  bits of information over all its adjacent edges in one synchronous round of communication. We also consider a modified model, where time is partitioned into synchronized slots, but a message might receive a delay when traversing an edge. This delay might not be uniform but fixed for each edge. In principle it is allowed that in each round a node can send different messages of size  to each of its neighbors and likewise receive different messages from each of its neighbors. Typically we use  bits, which allows us to send a constant number of node or edge IDs per message.
Since communication cost usually dominates the cost of local computation, local computation is considered to be negligible.
For  this message passing model is known as CONGEST model~\cite{peleg}.
We are interested in the number of rounds that a distributed algorithm needs to solve some problem. This is the time complexity of the algorithm.

To be more formal, we are interested in evaluating a function , where  is the set of all graphs over  vertices and  is e.g. ,  or , and define distributed round complexity as follows:
\begin{definition}[Distributed round complexity]
Let  be the set of distributed deterministic algorithms that evaluate a function  on the underlying graph  over  nodes (representing the network). Denote by  the distributed round complexity (indicated by dc) representing the number of rounds that an algorithm  needs in order to compute . We define
	
to be the smallest amount of rounds/time slots any algorithm needs in order to compute .
\end{definition}
We denote by  the randomized round complexity of  when the algorithms have access to randomness and compute the desired output with an error probability smaller than . By w.h.p. (with high probability) we denote a success probability larger than .



The unweighted shortest path in  between two nodes  and  is a path with minimum number of edges among all -paths. Denote by  the unweighted distance between two nodes  and  in  which is the length of an unweighted shortest -path in . We also say  and  are  hops apart. By  we denote a graph's weight function and by  the weight of an edge in . By 

 we define the weighted distance between two nodes  and , that is the weight of a shortest weighted path in a graph  connecting  and \footnote{ Note that in the context of MRCT,  often corresponds to the cost of an edge. In the literature the routing cost between any node  and  in a given spanning tree  of  is usually denoted by , while in generalized versions of MRCT, the weight of an edge can be different from the cost. In this paper we use .}. 

The time-bounds of our algorithms as well as those of previous algorithms depend on the diameter of a graph. We also use the eccentricity of a node.
\begin{definition}[Eccentricity, diameter]
The \emph{weighted eccentricity}  in  of a node  is the largest weighted distance to any other node in the , i.e. . The \emph{weighted diameter}  of a graph  is the maximum weighted distance between any two nodes of the graph. The \emph{unweighted diameter} (or hop diameter)  of a graph  is the maximum number of hops between any two nodes of the graph. Here  indicates the number of edges on path .
\end{definition}
We often write  and  instead of  and  when we refer to the diameter of a graph  in context. Observe that  for unweighted graphs. 

Finally, we define the problems that we study.

\begin{definition}[-Minimum Routing Cost Tree (-MRCT)]
Let  be a subset of the vertices  in . The -routing cost of a subgraph  is defined as  and denotes the routing cost of  with respect to . An -MRCT is a subgraph  of  that is a tree, contains all nodes  and has minimum -routing cost  among all spanning trees of . 
\end{definition}
This is a generalization of the MRCT problem~\cite{WuLBCRT99}. According to this definition -MRCT (i.e. ) and MRCT of~\cite{WuLBCRT99} are equivalent. Therefore all results are valid for the classical MRCT problem when choosing .

In this paper we consider approximation algorithms for these problems. Given an optimization problem , denote by  the cost of the optimal solution for  and by  the cost of the solution of an algorithm  for . We say  is -approximative for  if  for any input.

\begin{fact}\label{fact:ecc-approx-diam}
The eccentricity of any node is a good approximation of the diameter. For any node  we know that .
\end{fact}

\section{Our Results}\label{sec:results}
In Section~\ref{sec:final} we prove the following two theorems.
\begin{theorem}\label{thm:mrct}
In the CONGEST model, the deterministic algorithm proposed in Section~\ref{sec:final} needs time  to compute a -approximation for -MRCT when using either uniform weights for all edges or a weight function  that reflects the delay/edge traversal time of edge .
\end{theorem} 


\begin{theorem}\label{thm:mrct-rand}
Let  be some function in  and . The randomized algorithm proposed in Section~\ref{sec:final} computes w.h.p. a 
-approximation for -MRCT in the CONGEST model in time  when using either uniform weights for all edges or a weight function  that reflects the delay/edge traversal time of edge .
\end{theorem} 



We emphasize that the analysis of~\cite{wong1980worst} yields a -approximation when compared to the routing cost in the original graph\footnote{Note that most other approximation algorithms are with respect to  the routing cost of a minimal routing cost tree of the graph. In Section~\ref{sec:cant} we provide an example that shows that sometimes even no subgraph with  edges exists that yields better approximations to the routing cost in the original graph than the trees presented here. From this we conclude that algorithms that compare their result only to the routing cost of the minimum routing cost tree do not always yield better results than those presented here.} and that we modify this analysis.


\section{Related Work}\label{sec:related}
Minimum Routing Cost Trees are also known as uniform Minimum Communication Cost Spanning Trees~\cite{peleg2002low,reshef1999approximating} and shortest Total Path Length Spanning Trees~\cite{wu2000approximation}. Furthermore the MRCT problem is a special case of the Optimal Network Problem, first studied in the 1960s by~\cite{scott1969optimal} and later by~\cite{dionne1979exact}. In~\cite{wong1980worst} Wong presented heuristics and approximations to the Optimal Network Problem with a restriction that makes the problem similar to the MRCT problem and obtained a -approximation. In~\cite{johnson1978complexity} it is shown that this restricted version, which Wong studied on unweighted graphs, is NP-hard as well. It seems that earlier the authors of~\cite{hu1974optimum} formulated a similar problem under the name ''Optimum communication spanning tree" where in addition to costs on edges, we are given a requirement-value  for each pair of vertices that needs to be taken into account when computing the routing cost. In this setting one wants to find a tree  such that  is minimized. In~\cite{WuLBCRT99} it is argued that for metric graphs, the results by~\cite{bartal1996probabilistic,bartal1998approximating,charikar1998rounding} yield a -approximation to this problem. Using a result presented in~\cite{fakcharoenphol2003tight}, this can be improved to be an -approximation. In~\cite{khan2008efficient} it is shown how to implement this result in a distributed setting. They state their result depending on the shortest path diameter  is a shortest weighted   of a graph. This diameter represents the maximum number of hops of any shortest weighted path between any two nodes of the graph. The authors of~\cite{khan2008efficient} obtain a randomized approximation of the MRCT with expected approximation-ratio  in time . Observe that this might be only a -approximation even in a graph with  and , such as a clique where all edges have weight  except  edges of weight  forming a line as a subgraph.\footnote{According to~\cite{WuLBCRT99} it is NP-hard to find an MRCT in a clique.} In our distributed setting we know that it is hard to approximate an MRCT due to Theorem~\ref{thm:randomized_approximation}. 
\begin{theorem}[Version of Theorem 5.1. of~\cite{sarma2012distributed}]\label{thm:randomized_approximation}
For any polynomial function , numbers , , and , there exists a constant  such that in the CONGEST model any distributed -approximation algorithm for the MRCT problem whose error probability is smaller than  requires  time on some -vertex graph of diameter .
\end{theorem}

For certain realistic weight-functions our randomized algorithm breaks this -time lower bound. This is no contradiction, as the construction of~\cite{sarma2012distributed} heavily relies on being able to choose highly different weights, which might not always appear in practice: in current LAN/PAN networks, weights (delays) usually differ only by a small factor. In case the weights are indeed the delay-times, the runtime of our algorithm just depends on the maximal delay that occurs between any two nodes in the network. Observe that also the runtime of the algorithm of~\cite{khan2008efficient} stated for arbitrary weight functions does not contradict this approximation lower bound. The algorithm's runtime depends on the shortest path diameter , which is  in the worst case graphs provided in~\cite{sarma2012distributed}. Finally we want to point out that for weighted graphs it might be possible to combine the recent result of~\cite{nanongkai2014distributed} with the techniques developed in this paper. This might improve over the approximation factor of~\cite{khan2008efficient} for weighted graphs while getting a better runtime in some cases.

Related work in the non-distributed setting includes~\cite{WuLBCRT99}, where a PTAS to find the MRCT of a weighted undirected graph is presented. It is shown how to compute a -approximation for any  in time . 


Already for , the PTAS of~\cite{WuLBCRT99} yields a time bound of  and we cannot expect to obtain a distributed algorithm running in time  since we can only hope for a distributed speedup by at most . Setting  yields a -approximation in (sequential) time  and we could hope at most to obtain a distributed runtime of  from this. While one could try to transform this algorithm into our distributed setting, our algorithm based on~\cite{wong1980worst} is simpler and yields the same approximation ratio of . In addition we derive a fast randomized version from this.

Further related work on parallel approximations for MRCT in RNC circuits was published in~\cite{chang2007parallelized}. Here, RNC abbreviates the complexity class \emph{Randomized Nick's Class}, which consists of all decision problems decidable by uniform Boolean circuits with a polynomial number of gates of at most two inputs and depth .  Wu considered in~\cite{ye2002polynomial} the version of MRCT, where one is only interested in minimizing the routing cost from two source vertices to all nodes in the network and is hence denoted by -MRCT. He does this in a non-distributed setting and proves NP-hardness. He also presents a polynomial time approximation scheme (PTAS) for this version of the problem. Note that the -MRCT problem is different from the special case of the -MRCT problem with , where only a tree that connects nodes in  should be found. 
Recent speedups on exact solutions and heuristics for the MRCT problem can be found in~\cite{campos2008fast,fischetti2002exact}.

There is also a large body of work on Low Stretch Spanning Trees~\cite{DBLP:conf/focs/AbrahamBN08,elkin2008low,peleg2002low}. The stretch for an edge  in  using spanning tree  of  is defined to be  and the average stretch is . A tree with maximum stretch  yields an -approximation to the routing cost in . However, the maximal stretch can be high and thus in general does not yield better bounds on the routing cost than the trees presented here. Still, algorithms that yield good bounds on the average stretch are known --  can be achieved and was lower bounded by  in~\cite{elkin2008low}. Average stretch and routing cost quality are unrelated.






\section{Trees that -Approximate the Routing Cost}\label{sec:det-ana}
The main structure we need in this section are shortest path trees:
\begin{definition}[Shortest path tree]
A shortest path tree (SP-tree) rooted in a node , is a tree that connects any node  to the root  by a shortest path in . In unweighted graphs, this is simply a breadth first-search tree.
\end{definition}
Previously it was known due to Wong~\cite{wong1980worst}, Theorem , that there is an SP-tree, which -approximates the routing cost of an MRCT. We restate this result by using an insight stated in Wong's analysis such that this tree not only -approximates the routing cost  of an MRCT  of  (which is a -MRCT) as Wong stated it, but even yields a -approximation of the routing cost  when using shortest paths in the network  itself. Thus, on average the distances between two pairs in the tree are only a factor  worse than the distances in . 

The algorithm that corresponds to Wong's analysis computes and evaluates  SP-trees, one for each node in . We show, that for the -MRCT problem it is sufficient to consider only those shortest path trees rooted in nodes of . At the same time, a slightly more careful analysis yields a slightly improved approximation factor of , which is of interest for small sets . Before we start, we define a useful measure for the analysis.
\begin{definition}[Single source routing cost]
By  we denote the sum of the single source routing costs from node  to every other node in  by using edges in .
\end{definition}
Note that for simplicity we defined an SP-tree to contain all nodes of . However, one could also consider the subtree where all leaves are nodes in . The measures  and  would not change, as any additional edges are never used by any shortest paths and thus do not contribute to the -routing cost of the tree. Such a tree can easily be obtained from the tree we compute.
\begin{theorem}\label{thm:det-ana}
Let  be at least . In weighted graphs, the SP-tree  rooted in a node  with minimal single source routing cost  over all SP-trees rooted in nodes of  is a -approximation to the -routing cost  in .
\end{theorem}
\begin{corollary}\label{cor:improved}
In weighted graphs, an SP-tree with minimum routing cost over all SP-trees rooted in nodes of  is a -approximation to an -MRCT.
\end{corollary}
The proof of this theorem uses and modifies the ideas of the proof of Theorem 3 in~\cite{wong1980worst}. The following proof is an adapted version of this proof. 

\begin{proof}
Let  be the node for which the SP-tree  has minimal single source routing cost with respect to  among all SP-trees, that is . 

The cost of connecting a node  to all other nodes in  using edges in  is upper bounded by . This essentially describes the cost of connecting  to each other node by a path via the root  and using edges in . Therefore the total routing cost  for  using the network  can be bounded by

As , this can be further transformed and bounded to be 

Where the last bound follows, as  is minimal among all  for . Since  is the same as , we obtain that .
\end{proof}

\section{Considering few Randomly Chosen SP-Trees is Almost as Good}\label{sec:rand-ana}
We show that when investigating a small subset of all SP-trees chosen uniformly at random, with high probability one of these trees is a good approximation as well.
\begin{lemma}\label{lem:rand-ana}
Let  be a positive function in  and  and define . Assume  is of size at least . Let  in turn be a subset of  chosen uniformly at random among all subsets of  of size . Let  be a node such that . Then .   
\end{lemma}
\begin{proof}
For simplicity, without loss of generality we assume that  is a multiple of . Denote by  the nodes in  such that  That is they are ordered corresponding to their single source routing costs. We say a node  is good, if the corresponding SP-tree  is among the -fraction of the SP-trees with lowest single source routing cost\footnote{Due to the choice of  a good tree is among the  cheapest trees.} . Therefore  is good if  with respect to the above order of the trees.

First we prove that w.h.p. set  contains a good node. Second we prove, that the corresponding SP-tree yields the desired approximation ratio.

\emph{1) Probability analysis:} We know that  is good. Furthermore each node  is included in set  independent of the other nodes. Therefore we can conclude that the probability that at least one of the nodes  in  is good is  and thus high.


\emph{2) Approximation-ratio analysis:} Let  be a good node. 
As in the proof of Theorem~\ref{thm:det-ana} we know that 
.As  and  is good, we can conclude that 

as there are at most  nodes  with .
Equality is approached in the worst case, where  and  for each  and  for all . 

Combined with Bound (\ref{eqn:1}) it follows that 
 Due to the choice of  we conclude the statement of the Lemma.

\end{proof}


\section{How to Compute the Routing Cost of many SP-trees in Parallel}

In Theorem~\ref{thm:det-ana} (and Lemma~\ref{lem:rand-ana}) we demonstrated that an SP-tree  with minimum single source routing cost yields a -approximation for . The single source routing cost of a tree can be computed by computing distances between the root of a tree and nodes in . However, instead of finding an SP-tree with smallest single source routing cost the literature usually considers finding an SP-tree with smallest routing cost. This is done e.g. in~\cite{wong1980worst}. The reason for this is that the bound in the proof of Lemma~\ref{thm:det-ana} is not sharp when using the single source routing cost. To see this, we recall that while obtaining the bound, one approximates the distance between two nodes in the tree by adding up their distance to the root. Thus the bound considers the single source routing cost of an SP-tree. Compared to this, the routing cost takes the actual distance of the two nodes in an SP-tree into account. An explicit example for a graph that contains a node  such that , where  has minimum single source routing cost is given in Example~\ref{ex:example22}. Like in~\cite{wong1980worst} we focus on this more powerful version of finding a tree of small routing cost. 

\begin{example}\label{ex:example22}
Consider the graph  in Figure~\ref{fig:example22}. The tree  has smallest single source routing cost . At the same time the tree  has single source routing cost , while its routing cost  is lower than the routing cost  of . Note that the actual routing cost in  is . 
\begin{figure}[!htb]
\begin{center}
\includegraphics[scale=0.5]{graph.pdf}
\caption{Unweighted graph  with distinguished vertices  and  as well as SP-trees  and  corresponding to Example \ref{ex:example22}.}
\label{fig:example22}
\end{center}
\end{figure} 
\end{example}




\begin{lemma}\label{lem:RC-comp}
Let  be a subset\footnote{Note that  used here can be e.g.  as in Section~\ref{sec:det-ana} or the smaller set  as in Section~\ref{sec:rand-ana}.}  of all nodes of a graph. Then we can compute the values  in time  when using either uniform weights for all edges or a weight function implied by the delay/edge traversal time.
\end{lemma}

The proof of this lemma can be found at the end of this section. First, we describe our algorithm that is used to prove this lemma. In Part  of this algorithm we start by computing SP-trees  for each . A pseudocode for this algorithm can be found as Algorithm~\ref{alg:S-MRCT-Part-1}. Part 2 deals with computing the routing cost of a single tree and is described later in this section.

We start by noting that for the weight functions we consider an SP-tree is just a Breath First Search tree (BFS-tree). This part is essentially the same as in the -SP algorithm of~\cite{holzer2012optimal} extended to edge-weights derived from the delays to send a message. We also store some additional data that is used later in Algorithm~\ref{ALGRAND} to compute routing costs but was not needed for the -SP computation in~\cite{holzer2012optimal}. In Algorithm~\ref{ALGRAND}, for each node  an SP-tree  is constructed using what we call delayed breadth first search (DBFS). By DBFS we think of a breadth first search, where traversing edge  takes  time slots. In the end each node  in the graph knows . In addition each node  knows for each  its parent in the corresponding tree . Furthermore node  knows at what time the DBFS, that computed , sent its message to  via 's parent. During Algorithm~\ref{ALGRAND}, these timestamps are used to compute the routing cost of all these trees in time . 




\begin{algorithm}[!h]
\begin{algorithmic}[1]
\State ; ; ;
\State   // **new**
\If{}
\State ;
\State ;
\State ; // **new**
\EndIf
\State ;
\If{  equals }
\State \textbf{compute} ; //** According to Fact~\ref{fact:ecc-approx-diam},  is smaller than .
\State \textbf{broadcast} ;
\Else
\State \textbf{wait until}  was \textbf{received};
\EndIf
\algstore{myalg}
\end{algorithmic}\caption{Computing  for each  Part 1 (executed by node )}\label{alg:S-MRCT-Part-1}
\end{algorithm}
\newpage
\begin{algorithm} [!h]                    
\begin{algorithmic} [1]                  \algrestore{myalg}
\State //** Compute  shortest path trees
\For{}
\For{}
\State L_i\setminus \cap L_{delay}=\emptyset\arg\min\left\{v\in L_i\setminus L_{delay}|\right.\left.\tau[v]+\omega_G(u,v)\geq t\right\}
\EndFor
\State within one time slot:
\newline \hspace*{0.8cm}\textbf{if}  \textbf{then send}  to neighbor ;
\newline  \hspace*{0.8cm}\textbf{receive}  from ;
\newline  \hspace*{0.8cm}\textbf{if}  \textbf{then send}  to neighbor ;
\newline  \hspace*{0.8cm}\textbf{receive}  from ;
\newline  \hspace*{0.8cm} 
\newline  \hspace*{0.8cm}\textbf{if}  \textbf{then send}  to neighbor ; \newline  \hspace*{0.8cm}\textbf{receive}  from ;
\State  and 
\State L_{delay} = \emptyset
\If{}
	\State ;
\EndIf
\For{}
\If{}
\State //** 's message is delayed due to .
\If{}
\State ; // **new**
\State ;
\State ;
\If{}
\State 
\EndIf
\State  neighbor ;
\EndIf
\Else
\State ; //**  's message was successfully sent to neighbor .
\EndIf
\EndFor
\EndFor
\end{algorithmic}
\end{algorithm}
\newpage

\begin{remark}
Compared to Algorithm -SP presented in~\cite{holzer2012optimal} we added Lines 2, 6 and 26 in Algorithm~\ref{alg:S-MRCT-Part-1} and extended the algorithm to certain delay functions as mentioned above (the proof in~\cite{holzer2012optimal} can be naturally extended to those.) By doing so, we can store in  the time when a message of the computation of tree  was received the first time (via edge ). In the end,  stores the distance  to  and  indicates the first edge of a -path witnessing this. 
\end{remark}

Despite its similarity to algorithm -SP in~\cite{holzer2012optimal}, we describe Algorithm~\ref{alg:S-MRCT-Part-1} in more detail for completeness. For the simplicity of the writeup, we refer to  not only as a node, we use  to refer to 's ID as well. Each node  stores  sets , one for each of the  neighbors  of , and the sets   and  to keep track of which messages were received, transmitted or need to be delayed. At the beginning, if , all these sets contain just , else they are empty (Lines 1--7). Set  is always initialized to be empty. Furthermore  maintains an array  that eventually stores at position  (indicated by ) the distance  to node . Initially  is set to infinity for all  and is updated as soon as the distance is known (Line 27). In each node , array  stores at position  the time when a message of the computation of tree  was received the first time in . At any time, set  contains all node IDs corresponding to the tree computations (where each node with a stored ID is the root initiating the computation of such a tree) that already reached  until now.
The set  contains all root IDs that reached  until time  but are marked to be delayed before forwarded. This ensures that we indeed compute BFS-trees.

Set  contains all IDs of  except those that could be forwarded successfully to neighbor  in the past. We say an ID  is forwarded successfully to neighbor , if  is not sending a smaller ID  to  at the same time.

To compute the trees in Algorithm~\ref{alg:S-MRCT-Part-1}, the unique node with ID  computes  and thus a -approximation to the distance-diameter . This value is subsequently broadcast to the network (Lines 8--12). Then the computation of the  trees starts and runs for  time steps. Lines 14--17 make sure that at any time the smallest ID, that is not marked to be delayed and was not already  forwarded successfully to neighbor  is sent to  together with the length of the shortest -path that contains . In Line 18 we define the set  of all IDs that are received successfully in this time slot for the first time. This set is then used to decide whether to remove an ID  from  in Lines 20 and 21, since all IDs that cause a delay to  are transmitted successfully by now. ID  is computed in Line 20. ID  is the smallest element of  and is removed from  if no other ID smaller than  was received successfully for the first time in this timeslot.

If a node ID  was received successful for the first time (verified in Lines 23 and 25), we update  and , add  to the according lists (Lines 28--30) and remember who 's parent is in  (Line 31). In case the ID  was received the first time from several neighbors, the algorithm as we stated it chooses the edge with lowest index . On the other hand if we did not successfully receive a message from neighbor  but sent successfully a message to neighbor , the transmitted ID is removed from  (Line 33).
\begin{lemma}\label{lem:S-MRCT-Part-1-Runtime}
Algorithm~\ref{alg:S-MRCT-Part-1} computes an SP-tree  for each  in time .
\end{lemma}
\begin{proof}
This is essentially Theorem 6.1. in~\cite{holzer2012optimal-merge} stated for Algorithm~\ref{alg:S-MRCT-Part-1} instead of Algorithm -SP of~\cite{holzer2012optimal-merge}. Those parts of the two algorithms which contribute to the runtime and correctness are equivalent. 
\end{proof}


Now Part 2 of our algorithm calculates the routing cost of each tree  in parallel in time .
A pseudocode of this algorithm is stated in  Algorithm~\ref{ALGRAND}.


To compute the routing cost of a tree, we look at each edge  in each tree  and compute the number of -paths in  that contain the edge , for . The sum of these numbers for each edge in a tree is the tree's routing cost. Given a tree , for each edge  in , the edge partitions the tree into two trees (when  was removed). To be more precise, denote by  the two vertices to which  is incident. Edge  partitions the vertices of  into two subsets, which we call  and  defined by: 

Example~\ref{ex:Ue1} visualizes this definition. 
We observe that edge  occurs in all  paths from any node  to any node . Note that the total number of paths in which  occurs is . This fact is later used to compute . 

\begin{algorithm}[!htbp]
\begin{algorithmic}[1]
\State ; //** is updated during the runtime of the algorithm.
\If{}
\State ; //** is updated during the runtime of the algorithm.
\Else
\State ;
\EndIf
\For{}
\State within one time slot:
\newline \hspace*{0.8cm}\textbf{For each}  \textbf{such that}  \textbf{send}  to
\newline \hspace*{0.8cm};
\newline \hspace*{0.8cm}\textbf{receive}  from neighbor ; //**  equals ,
\newline \hspace*{6.2cm}//**  equals 
\newline \hspace*{0.8cm}\textbf{receive}  from neighbor ; //**  equals ,
\newline \hspace*{6.2cm}//**  equals 
\newline \hspace*{0.8cm}
\newline \hspace*{0.8cm}\textbf{receive}  from ; //**  equals ,
\newline \hspace*{6.3cm}//**  equals 
\For{}
\If{}
\State ;
\State ;
\EndIf
\EndFor
\EndFor
\State //** Now  equals  in case that . Else it is  and was never modified. 
\end{algorithmic}
\caption{Computing  for each  alternative Part 2 (executed by node )}\label{ALGRAND}
\vspace*{0.5cm}
\end{algorithm}

\begin{example}\label{ex:Ue1}
In Figure~\ref{fig:mrcst} we consider a graph  and edge  and assume  and  are elements of . Then  and  . Edge  is part of all  paths from  to a node  and also on all  paths from  to all nodes . Thus in total  occurs in  paths. 
\begin{figure}[ht]
\centering
\includegraphics{mrcst2.pdf}
\caption{Example of vertex sets  and  in a graph.}
\label{fig:mrcst}
\end{figure} 
\end{example}


\begin{lemma}\label{lem:lem}
For a tree , the routing cost  can be restated as .
\end{lemma}

\begin{proof}
We define a function  indicating whether an edge is part of the unique path between two nodes in . 

and restate


Where we use in the last transformation the fact that  is the total number of -paths which contain the edge , which can be expressed as  as noted in the text before Example~\ref{ex:Ue1}. 
\end{proof}




To formulate the definition of  in this way helps us to argue that we can compute  recursively in a bottom-up fashion for any . To do so, we consider trees to be oriented such that we use the notion of child/parent. 

\begin{definition}[Subtree, partial routing cost]
Given a tree , for each node  in an oriented tree , we define  to be the subtree of  rooted in  containing all descendants of  in . Denote by  the vertices in . Given node , denote by  the part of the routing cost  that is due to the edges in . We define  in a recusive way. In case that  consists of only one node,  contains no edges that could contribute to  and we set . In case that  contains more than one node, we denote the children of  in  by  and define .
\end{definition}

Note that  is a measure with respect to the routing cost in  and thus different from . Besides  being undefined when  does not contain all nodes in ,  would take only routing cost within  into account.

We now formally prove that  essentially describes the contribution of edges in subtree  to the total routing cost and conclude:
\begin{lemma}\label{lem:part-rc}
Let  be a tree rooted in node . Then .
\end{lemma}
\begin{proof} We know due to Lemma~\ref{lem:lem} that 

Observe that  consists of the subtrees  induced by 's children and the edges  . Thus we can split the above term to be 

which in turn is

\end{proof} 


Using this insight we are able to compute  for all  in parallel recursively in a bottom-up fashion. This is by computing  for each  based on aggregating  for each of 's children. For each  these computations of  run in parallel. A schedule on how to do these bottom-up computations in time  is provided by using the inverted entries of . 

In more detail each node  computes for each  the costs  (stored in ) of its subtree of  as well as the number of nodes in  (stored in  and sends this information to its parent in . When we computed  in Algorithm~\ref{alg:S-MRCT-Part-1}, we connected  via edge  to  at time . To avoid congestion we send information from  to its parent in  only at time  (Line 7). Note that this schedule differs from the one that is implied by the computation of the trees in the sense that now only edges in the tree are used, while more edges were scheduled while building the trees. The edges used now in time slot  are a subset of those scheduled at time  while constructing the trees, such that there is no congestion from this modification.   


At the same time as  sends,  receives messages from its neighbors. E.g. neighbor  might send  and  for another node . In Lines  node  updates its memory depending on the received values. In the end the node with ID  computes  via aggregation using . Node  informs the network that tree  is a -approximation to an -MRCT.
\begin{theorem}\label{thm:exact_RC}
The algorithm presented in this section computes all  values  for each node  in time .
\end{theorem}
\begin{proof}
\textbf{Runtime:} The construction of the  trees in Algorithm~\ref{alg:S-MRCT-Part-1} takes at most  rounds as stated in Lemma~\ref{lem:S-MRCT-Part-1-Runtime}. To forward/compute the costs from the leaves to the roots  in Algorithm~\ref{ALGRAND} takes  since we just use the schedule  of this length computed in Algorithm~\ref{alg:S-MRCT-Part-1}. Thus the total time used is .

\textbf{Correctness:} 
We consider time slot . If  is a leaf of , it sends  to its parent in  in case , else it sends , which is correct. In case  is not a leaf, each child  has sent  (stored in ) as well as  (stored in ) to  at an earlier point in time. This is true as time-stamp  stored in  is always larger than time-stamp  stored in , as  is a child of . Each time  received some of these values from its children in , it updated its memory according to Lemma~\ref{lem:part-rc} (Lines  of Algorithm~\ref{ALGRAND}), leading to sending the correct values  and  to its parent in  at time . Thus in any case  sends the correct values.

We conclude that each node  has computed  after Algorithm~\ref{ALGRAND} has finished. 
\end{proof}








\section{Proofs of Main Results}\label{sec:final}
We put the tools of the previous sections together and prove the Theorems of Section~\ref{sec:intro}.
\begin{proof}(of Theorem~\ref{thm:mrct}).
First, Algorithms~\ref{alg:S-MRCT-Part-1} and~\ref{ALGRAND} are used to compute  for each . For each such node , the value  is stored in node  itself. A leader node (e.g. with lowest ID, which can be found in time ) computes  via aggregation using , where  is the leader node. As stated in Theorem~\ref{thm:det-ana} the tree  is a -approximation of a -MRCT. The leader node informs the network that tree  is a -approximation to an -MRCT.
The runtime follows from Lemma~\ref{lem:RC-comp} and the fact, that to determine  by aggregating the corresponding minimum and to broadcast  can be done in time .
\end{proof}
\begin{proof}(of Theorem~\ref{thm:mrct-rand}).
First we select a subset  of the size stated in Lemma~\ref{lem:rand-ana}. 
Each node joins a set  with probability , where  is the (desired) size of  stated in Lemma~\ref{lem:rand-ana} and  a constant depending on a Chernoff bound used now. Using such a Chernoff Bound, w.h.p.  is of size  or some constant . Now all IDs of nodes in  are sent to the leader who selects and broadcasts a subset  of the desired size among the IDs of .  
 
From now on the algorithm works exactly as in the proof of Theorem~\ref{thm:mrct}, except that the algorithm is run on  instead of  (it computes and aggregates each  for  instead of ). As stated in Lemma~\ref{lem:rand-ana}, a tree  is found that is a -approximation of an -MRCT. The leader node informs the network that tree  is a -approximation to an -MRCT. Choosing  yields the desired approximation ratio of , as stated in the Theorem.

\emph{Runtime analysis:} As , selecting a set  and deriving  can be done w.h.p. in time 

which is  due to the choice of . The same runtime follows from Lemma~\ref{lem:RC-comp} for computing the single source routing costs for all . Combined with the fact that the aggregation and broadcast of  can be done in time , the stated result is obtained.
\end{proof}

\section{Why -Approximations Can't be Improved Cheap}\label{sec:cant}
The following example demonstrates a setting where an SP-tree yields a -approximation to the routing cost of the underlying graph , while no subgraph  with  edges can yield a -approximation, which  demonstrates the strength of the tree that is able to provide a -approximation while it has only  edges while . 
\begin{example} 
Let  be the clique with uniform edge-weights . For  we obtain that the routing cost  is . Any SP-tree  yields : the routing cost between the root  and all other nodes is . The routing cost of each of the remaining  nodes  to the nodes  via paths of length  is . The routing costs from nodes  to  is . Thus  is a factor  off from . As all paths between two nodes using edges of  are of length at most two, the only way to reduce the routing cost by a factor of  is to carefully add more than  edges to the tree. Thus the total cost of such an approximation structure is a factor  higher than the cost of a tree. 
\end{example}


\section*{Acknowledgment}
We would like to thank Benjamin Dissler and Mohsen Ghaffari for helpful discussions and insights.

\addcontentsline{toc}{section}{References} 
\bibliographystyle{plain}
\bibliography{references}


\end{document}
