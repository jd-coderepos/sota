In this chapter we define Free Short-Circuit Logic on evaluation trees and
present the set of equations , which we will prove axiomatizes this
logic in Section \ref{sec:felcpl}. Formally, -terms are built up from
atomic propositions that may have side effects, called atoms, the truth value
constants  for true and  for false and the connectives 
for negation,  for (short-circuit) left-sequential conjunction and
 for (short-circuit) left-sequential disjunction.
\begin{definition}
Let  be a countable set of atoms. \textbf{-terms } have the
following grammar presented in Backus-Naur Form.

\end{definition}
As is the case with , if  then resulting logic is
trivial.

First we return for a moment to our motivation for left-sequential logics,
i.e., propositional terms as used in programming languages. We will consider
the -term  and informally describe its evaluation,
naturally using a short-circuit evaluation strategy. We start by evaluating 
and let its yield determine our next action. If  yielded  we proceed
by evaluating , i.e., the yield of the term as a whole will be the yield of
. If  yielded , we already know at this point that 
will yield .  We skip the evaluation of  and let the term yield
, i.e.,  is short-circuited.

Considering the more complex term , we find that we
start by evaluating  and if it yields  we proceed by
evaluating . If it yields  we skip the evaluation of , because we
know the term will yield . This example shows that evaluating
-terms is an interactive procedure, where the yield of the previous atom
is needed to determine which atom to evaluate next. We believe these semantics
are best captured in trees. Hence we will define equality of -terms
using (evaluation) trees. We define the set  of finite binary trees over
 with leaves in  recursively. We have that

In the expression  the root is represented by , the left
branch by  and the right branch by . We define the depth of a tree 
recursively by  and  for . The reason for our choice of notation for
trees will become apparent in Chapter \ref{chap:rel}. We refer to trees in 
as evaluation trees, or trees for short.  Figure \ref{fig:exse} shows the trees
corresponding to the evaluations of  and .

Returning to our example, we have seen that the tree corresponding to the
evaluation of  can be composed from the tree
corresponding to the evaluation of  and that corresponding to the
evaluation of . We said above that if  yielded , we
would proceed with the evaluation of . This can be seen as replacing each
-leaf in the tree corresponding to the evaluation of  with
the tree that corresponds to the evaluation of . Formally we define the leaf
replacement operator, `replacement' for short, on trees in  as follows. Let
 and . The replacement of  with  and
 with  in , denoted , is defined
recursively as

We note that the order in which the replacements of the leaves of  is listed
inside the brackets is irrelevant. We will adopt the convention of not listing
any identities inside the brackets, i.e.,

Furthermore we let replacements associate to the left. We also use that fact
that

if  does not contain , which can be shown by a trivial induction.
Similarly,

if  does not contain .  We now have the terminology and notation to
formally define the mapping from -terms to evaluation trees.

\begin{definition}
Let  be a countable set of atoms and let  be the set all finite binary
trees over  with leaves in . We define the unary
\textbf{Short-Circuit Evaluation} function  as:

\end{definition}
As we can see from the definition on atoms, the evaluation continues in the
left branch if an atom yields  and in the right branch if it yields
. Revisiting our example once more, we indeed see how the evaluation of
 is composed of the evaluation of  followed by the evaluation
of  in case  yields . We can compute

Now the evaluation of  is a composition of this
tree and , as can be seen in Figure
\ref{fig:exfe2}.

\begin{figure}[thbp]
\hrule
\centering
\subfloat[]{\label{fig:exse1}
\beginpgfgraphicnamed{scl1}
\begin{tikzpicture}[level distance=7.5mm,
level 1/.style={sibling distance=30mm},
level 2/.style={sibling distance=15mm},
level 3/.style={sibling distance=7.5mm}
]
\node (a) {}
  child {node (b1) {}
    child {node (c1) {}}
    child {node (c2) {}
      child {node (d3) {}} 
      child {node (d4) {}}
    }
  }
  child {node (b2) {}
    child {node (d5) {}} 
    child {node (d6) {}}
  };
\end{tikzpicture}\endpgfgraphicnamed}
\qquad
\subfloat[]{\label{fig:exse2}
\beginpgfgraphicnamed{scl2}
\begin{tikzpicture}[level distance=7.5mm,
level 1/.style={sibling distance=30mm},
level 2/.style={sibling distance=15mm},
level 3/.style={sibling distance=7.5mm}
]
\node (a) {}
  child {node (b1) {}
    child {node (d1) {}} 
    child {node (d2) {}}
  }
  child {node (b2) {}
    child {node (c3) {}
      child {node (d5) {}} 
      child {node (d6) {}}
    }
    child {node (c4) {}}
  };
\end{tikzpicture}\endpgfgraphicnamed}
\vspace{1em}
\hrule
\vspace{1em}
\caption{Trees depicting the evaluation of two -terms. The evaluation
starts at the root. When (the atom at) an inner node yields  the
evaluation continues in its left branch and when it yields  it
continues in its right branch. The leaves indicate the yield of the terms as a
whole.}
\label{fig:exse}
\end{figure}

These trees show us that a function of the yield of the atoms in an -term
is insufficient to determine the semantics of the term as a whole. They show us
that we must also consider the (conditional) order in which the atoms occur in
the term. In particular we see that in ,  will be
short-circuited if  yields , while in , it will be
short-circuited if  yields . We are now ready to define
Short-Circuit Logic on evaluation trees.
\begin{definition}
\textbf{Free Short-Circuit Logic } is the logic that satisfies
exactly the consequences of -equality, i.e., for all ,

\end{definition}
Using the completeness result we shall prove in Section \ref{sec:sclcpl}, we
will show that  is in fact equivalent to  as defined by Bergstra
and Ponse in \cite{scl}. This should come as no surprise given the tree-like
structure that Proposition Algebra terms exhibit, see, e.g., \cite{pa} or
\cite{pascl}.

We choose a representation of  as trees rather than as sets of traces,
i.e., the paths of those trees annotated with truth values for the atoms,
because the tree notation allows us to be more succinct. These tree semantics
were first given, although presented as trace semantics, by Ponse in
\cite{tt}.

We now turn to the set of equations , listed in Table
\ref{tab:eqfscl}, which we will show in Section \ref{sec:sclcpl} is an
axiomatization of . This set of equations is based on one presented by
Bergstra and Ponse in \cite{scl}. If two -terms  and , where we
extend the definition to allow for terms containing variables, are derivable by
equational logic and , we denote this by  and
say that  and  are derivably equal. As a consequence of \eqref{ax:scl1}
through \eqref{ax:scl3},  is the dual of  and hence the
duals of the equations in  are also derivable. We will use this fact
implicitly throughout our proofs. Observe that unlike with , we have
an equation in  for (a special case of) distributivity, i.e.,
\eqref{ax:scl10s}.

\begin{table}[htbp]
\hrule

\hrule
\vspace{1em}
\caption{The set of equations \textbf{\EqFSCL}.}
\label{tab:eqfscl}
\end{table}



The following lemma shows some equations that will prove useful in Section
\ref{sec:snf}. These equations show how terms of the form 
and  can be used to change the order in which atoms occur in
an -term. This is very different from the situation with , where
terms that contain the same atoms, but in a different order, are never
derivably equal. In terms of a comparison between  and  this
can be seen as a consequence of \eqref{ax:scl10s}.
\clearpage
\begin{lemma}
\label{lem:seqs}
The following equations can all be derived by equational logic and .
\begin{enumerate}[itemsep=5pt]
\item 
  \label{eq:b1}
\item 
  \label{eq:b2}
\item 
  \label{eq:b3}
\end{enumerate}
\end{lemma}
\begin{proof}
We derive the equations in order.
5pt]
(x \sleftor (y &\sleftand \false)) \sleftand (z \sleftand
  \false)\\
&= (\neg x \sleftor (z \sleftand \false)) \sleftand ((y \sleftand \false)
  \sleftand (z \sleftand \false))
  &\textrm{by part \eqref{eq:b1} of this lemma} \\
&= (\neg x \sleftor (z \sleftand \false)) \sleftand (y \sleftand \false)
  &\textrm{by \eqref{ax:scl6} and \eqref{ax:scl7}} \
\end{proof}

\begin{theorem}
\label{thm:sclsnd}
For all , if  then .
\end{theorem}
\begin{proof}
To see that identity, symmetry, transitivity and congruence hold in ,
we refer the reader to the proof of Theorem \ref{thm:felsnd} and note that the
proofs for  are highly similar.

Verifying the validity of the equations in  is cumbersome, but not
difficult. As an example we show it for \eqref{ax:scl3}. We have 

by a trivial structural induction on evaluation trees.  
\end{proof}

\section{SCL Normal Form}
\label{sec:snf}
To aid in our completeness proof we define a normal form for -terms.
Because the atoms in -terms may have side effects common normal forms for
PL such as Conjunctive Normal Form or Disjunctive Normal Form are not normal
forms for . For example, the term  would be
written as  in Disjunctive Normal
Form, but a trivial examination shows that the evaluation trees of these terms
are not the same. Our normal form is inspired by the  Normal Form
presented in Chapter \ref{chap:fel}. We present the grammar for our normal form
before we motivate it.



\begin{definition}
\label{def:snf}
A term  is said to be in \textbf{ Normal Form } if it
is generated by the following grammar.

where . We refer to -forms as -terms, to -forms as
-terms, to -forms as -terms and to -forms as
-terms. A term of the form  is referred to as a
--term.
\end{definition}

Without the presence of  and  in our language, a traditional
Negation Normal Form would have sufficed. Furthermore, if , an
even more trivial normal form could be used, i.e., just  or .

When considering trees in the image of  we note that some trees only have
-leaves, some only -leaves and some both -leaves and
-leaves. For any -term ,  is a tree
with only -leaves, as can easily be seen from the definition of .
All terms  such that  is a tree with only -leaves are
rewritten to -terms. Similarly, for any term ,  is a tree with only -leaves. All  such that  has
only -leaves are rewritten to -terms. The simplest trees in the
image of  that have both types of leaves are  for . Any
(occurrence of an) atom that determines (in whole or in part) the yield of the
term, such as  in this example, is referred to as a determinative (occurrence
of an) atom. This as opposed to a non-determinative (occurrence of an) atom,
such as the  in , which does not determine (either in
whole or in part) the yield of the term.  Note that a term  such that
 contains both  and  must contain at least one
determinative atom.

Terms that contain at least one determinative atom will be rewritten to
--terms. In --terms we encode each determinative atom
together with the non-determinative atoms that occur between it and the next
determinative atom in the term (reading from left to right) as an -term.
Observe that the first atom in an -term is the (only) determinative atom
in that -term and that determinative atoms only occur in -terms.
Also observe that the yield of an -term is the yield of its determinative
atom. This is intuitively convincing, because the remainder of the atoms in any
-term are non-determinative and hence do not contribute to its yield. The
non-determinative atoms that may occur before the first determinative atom are
encoded as a -term. A --term is the conjunction of a
-term encoding such atoms and a -term, which contains only
conjunctions and disjunctions of -terms. We could also have encoded such
atoms as an -term and then taken the disjunction with a -term to
obtain a term with the same semantics. We consider -terms to be `basic'
in -terms in the sense that they are the smallest grammatical unit that
influences the yield of the -term.

The -terms in  are more complex than those in  Normal Form,
because short-circuiting allows for the possibility of evaluating different
non-determinative atoms depending on the yield of the determinative atom. This
is also the reason why the -terms and the -terms are more
complex. Although the atoms occurring in them are not determinative, their
yield can influence which atoms in the -term (-term) are
evaluated next.

We use , , etc.~both to denote grammatical categories and as
variables for terms in those categories. The remainder of this section is
concerned with defining and proving correct the normalization function . We will define  recursively using the functions

The first of these will be used to rewrite negated -terms to -terms
and the second to rewrite the conjunction of two -terms to an
-term. By \eqref{ax:scl2} we have no need for a dedicated function that
rewrites the disjunction of two -terms to an -term.

We start by defining . Analyzing the semantics of -terms and
-terms together with the definition of  on negations, it becomes
clear that  must turn -terms into -terms and vice versa.
We also remark that  must preserve the left-associativity of the
-terms in --terms, modulo the associativity within -terms.
We define  as follows, using the auxiliary function
 to `push down' or `push in' the negation symbols when
negating a --term. We note that there is no ambiguity between the
different grammatical categories present in an -term, i.e., any
-term is in exactly one of the grammatical categories identified in
Definition
\ref{def:snf}.


Now we turn to defining . These definitions have a great deal of
inter-dependence so we first present the definition for  when the first
argument is a -term. We see that the conjunction of a -term with
another terms always yields a term of the same grammatical category as the
second conjunct. 


For defining  where the first argument is an -term, we make use
of \eqref{ax:scl6}. This immediately shows that the conjunction of an
-term with another term is itself an -term.


The case where the first conjunct is a --term and the second conjunct
is a -term is defined next. We will use an auxiliary function,
, to turn conjunctions of a -term with
a -term into -terms. Together with \eqref{ax:scl7} this allows us to
define  for this case.


When the second conjunct is an -term, the result will naturally be an
-term itself. So we need to convert the --term to an
-term. Using \eqref{ax:scl7} we reduce this problem to converting a
-term to an -term, for which we use the auxiliary function
.


Finally we are left with conjunctions of two --terms, thus completing
the definition of .  We use the auxiliary function  to ensure that the result is a
--term.


As promised, we now define the normalization function 
recursively, using  and , as follows.


\begin{restatable}{theorem}{thmnfscorrect}
\label{thm:nfs}
For any ,  terminates,  and .
\end{restatable}

In Appendix \ref{sec:sclnf} we first prove a number of lemmas showing that the
definitions  and  are correct and use those to prove the
theorem. We have chosen to use a function rather than a rewriting system to
prove the correctness of the normal form, because the author lacks experience
with term rewriting systems and because using a function relieves us of the
task of proving confluence for the underlying rewriting system.

In Section \ref{sec:ffelfscl} we show that  is a sublogic of  and
that any -term can be rewritten to an -term with the same
semantics. There we will pay special attention to the application of that
translation to terms in  Normal Form.

\section{Tree Structure}
In Section \ref{sec:sclcpl} we will prove that  axiomatizes 
by showing that if  we can invert . To do this we need to
prove several structural properties of the trees in the image of . In the
definition of  we can see how  is assembled from
 and  and similarly for . To decompose these
trees we will introduce some notation. The trees in the image of  are all
finite binary trees over  with leaves in , i.e.,
. We will now also consider the set  of binary
trees over  with leaves in , where `' is
pronounced `box'. The box will be used as a placeholder when composing or
decomposing trees. Replacement of the leaves of trees in  by trees in
 or  is defined analogous to replacement for trees in , adopting
the same notational conventions.

For example we have by definition of  that  can be
decomposed as

where  and . We note that
this only works because the trees in the image of , or in  in general,
do not contain any boxes. We start by analyzing the -image of
-terms.

\begin{lemma}[Structure of -terms]
\label{lem:slitstf}
There is no -term  such that  can be decomposed as
 with  and , where , but
does contain , and  contains occurrences of both  and
.
\end{lemma}
\begin{proof}
Let  be some -term. When we analyze the grammar of  we find that
one branch from the root of  will only contain  and not 
and the other branch vice versa. Hence if  and 
contains occurrences of both  and , then  must contain the
root and hence .
\end{proof}

By definition a -term contains at least one -term and hence for any
-term ,  contains both  and . The following lemma
provides the -image of the rightmost -term in a -term to witness
this fact.

\begin{lemma}[Determinativeness]
\label{lem:sperttf}
For all -terms ,  can be decomposed as  with  and  such that  contains  and  for
some -term . Note that  may be . We will refer to  as the
witness for this lemma for .
\end{lemma}
\begin{proof}
By induction on the complexity of -terms  modulo the complexity of
-terms. In the base case  is an -term and  is the desired decomposition by Lemma
\ref{lem:slitstf}. For the induction we have to consider both  and .

We start with  and let  be the
decomposition for  which we have by induction hypothesis. Since by
definition of  on  we have

we also have

The last equality is due to the fact that  does not contain any boxes.
This gives our desired decomposition. The case for  is
analogous.
\end{proof}

The following lemma illustrates another structural property of trees in the
image of -terms under , namely that the left branch of any
determinative atom in such a tree is different from its right branch.

\begin{lemma}[Non-decomposition]
\label{lem:snondectf}
There is no -term  such that  can be decomposed as
 with  and , where  and 
contains , but not  or .
\end{lemma}
\begin{proof}
By induction on  modulo the complexity of -terms. The base case covers
-terms and follows immediately from Lemma~\ref{lem:sperttf} (
contains occurrences of both  and ) and Lemma~\ref{lem:slitstf}
(no non-trivial decomposition exists that contains both). For the induction we
assume that the lemma holds for all -terms with lesser complexity than  and .

We start with the case for . Suppose for contradiction that
 with  and  not containing
any occurrences of  or . Let  be a witness of Lemma
\ref{lem:sperttf} for . Now note that  has a subtree
. Because  must contain both the occurrences of
 in the one branch of  as well as the occurrences
of  in the other (because they contain  and ), Lemma
\ref{lem:slitstf} implies that  must (strictly) contain . Hence
there is a  such that , which violates the
induction hypothesis. The case for  is symmetric.
\end{proof}

We now arrive at two crucial definitions for our completeness proof. When
considering -terms, we already know that  can be
decomposed as

Our goal now is to give a definition for a type of decomposition so that this
is the only such decomposition for . We also ensure that
 does not have a decomposition of that type, so that we can
distinguish  from . Similarly, we need
to define another type of decomposition so that  can only be
decomposed as 

and that  does not have a decomposition of that type.

\begin{definition}
The pair  is a \textbf{candidate conjunction
decomposition (ccd)} of , if
\begin{itemize}
\item ,
\item  contains ,
\item  contains , but not , and
\item  contains both  and .
\end{itemize}
Similarly,  is a \textbf{candidate disjunction decomposition (cdd)} of
, if
\begin{itemize}
\item ,
\item  contains ,
\item  contains , but not , and
\item  contains both  and .
\end{itemize}
\end{definition}

We note that the ccd and cdd are not necessarily the decompositions we are
looking for, because, for example,  has a ccd
, whereas the decomposition we
need is . Therefore we refine
these definitions to obtain the decompositions we seek.

\begin{definition}
The pair  is a \textbf{conjunction decomposition
(cd)} of , if it is a ccd of  and there is no other ccd 
of  where the depth of  is smaller than that of . Similarly, 
is a \textbf{disjunction decomposition (dd)} of , if it is a cdd of  and
there is no other cdd  of  where the depth of  is smaller than
that of .
\end{definition}

\begin{theorem}
\label{thm:scddd}
For any -term , i.e., with  and ,
 has the (unique) cd

and no dd. For any -term , i.e., with  and ,  has no cd and its (unique) dd is

\end{theorem}
\begin{proof}
By simultaneous induction on  and  modulo the
complexity of -terms. In the basis we have to consider, for -terms
 and , the terms  and . Both of these are
covered by the cases in the induction where the second conjunct (or disjunct)
 is an -term. This is valid reasoning, since we don't call upon the
induction hypothesis in those cases. For the induction we assume that the
theorem holds for all -terms with lesser complexity than  and
. We first treat the case for .

First for the cd. Note that  is a ccd of
 by definition of  on  (for the first
condition) and Lemma \ref{lem:sperttf} (for the third and fourth condition). We
also know that for any ccd  either  contains or is contained in
. For suppose otherwise, then  will contain an occurrence of
, namely the one we know by Lemma \ref{lem:sperttf} that  has.
By the above it suffices to show that there is no ccd  where  is
strictly contained in . Suppose for contradiction that such a ccd  does exist.

By definition of -terms  is either an -term or a disjunction. If
 is an -term and  is strictly contained in  then 
does not contain both  and  by Lemma \ref{lem:slitstf}.
Therefore  is the \emph{unique} cd for
.

If  is a disjunction, then if  is strictly contained in  we can
decompose  as  for some  that
contains but is not equal to . By Lemma~\ref{lem:snondectf} this implies
that  contains either  or . If it contains , then so
does , because 

and  is not a ccd for . If it only contains
 then  is a ccd for  which violates the induction
hypothesis. Therefore  is the \emph{unique}
cd for .

Now for the dd. It suffices to show that there is no cdd for . Again  is either an -term or a disjunction. Suppose for
contradiction that  is a cdd for . If  is an
-term, then  must contain all occurrences of  in . So in particular it must contain all occurrences of  in
. It must also contain at least one occurrence of . Hence by
Lemma \ref{lem:slitstf}  must contain . But then  contains all
the occurrences of  in  and hence  does not
contain any occurrences of .  Therefore there is no cdd for .

If  is a disjunction then  must contain all occurrences of  in
. Let  be a witness of Lemma \ref{lem:sperttf} for .
Now note that  is a subtree of . Also
note that Lemma \ref{lem:slitstf} implies that there is no way to decompose
 such that  for
some  that contains but is not equal to  and some 
containing occurrences of both  and . So because  must
contain all occurrences of  in , it must strictly
contain . But all the occurrences of  in 
are in occurrences of . Hence  does not contain any occurrences of
. Therefore there is no cdd for .  The case for
 is symmetric.
\end{proof}

At this point we have the tools necessary to invert  on -terms, at
least down to the level of -terms. We can easily detect if a tree in the
image of  is in the image of , because all leaves to the left of
the root are one truth value, while all the leaves to the right are the other.
To invert  on --terms we still need to be able to reconstruct
 and  from . To this end we
define a --decomposition, as with cds and dds we first define a
candidate --decomposition.

\begin{definition}
The pair  is a \textbf{candidate
--decomposition (ctsd)} of , if , 
does not contain  or  and there is no decomposition  of  such that
\begin{itemize}
\item ,
\item  contains ,
\item , and
\item  contains neither  nor .
\end{itemize}
\end{definition}

Unlike with , this is not the decomposition we seek in this case.
Consider for example that there is a -term with the following semantics:
\begin{center}
\beginpgfgraphicnamed{scl3}
\begin{tikzpicture}[level distance=7.5mm,
level 1/.style={sibling distance=30mm},
level 2/.style={sibling distance=15mm},
level 3/.style={sibling distance=7.5mm}
]
\node (a) {}
  child {node (b1) {}
    child {node (c1) {}
      child {node (d1) {}} 
      child {node (d2) {}}
    }
    child {node (c2) {}
      child {node (d3) {}} 
      child {node (d4) {}}
    }
  }
  child {node (b2) {}
    child {node (c3) {}
      child {node (d5) {}} 
      child {node (d6) {}}
    }
    child {node (c4) {}
      child {node (d7) {}} 
      child {node (d8) {}}
    }
  };
\end{tikzpicture}
\endpgfgraphicnamed
\end{center}
Let  be the -term with these semantics and observe that
 has a ctsd

But the decomposition we seek is .
Hence we will refine this definition to aid in the theorem below.

\begin{definition}
The pair  is a \textbf{--decomposition
(tsd)} of , if it is a ctsd of  and there is no other ctsd  of  where the depth of  is smaller than that of .
\end{definition}

\begin{theorem}
\label{thm:stsd}
For any -term  and -term  the (unique) tsd of  is

\end{theorem}
\begin{proof}
First we observe that  is a ctsd because by
definition of  on  we have  and  is non-decomposable by Lemma \ref{lem:snondectf}.

Suppose for contradiction that there is ctsd  such that the depth of
 is smaller than that of . Now  must contain or be contained in
 for otherwise  would contain  or , i.e., the ones we
know  has by Lemma \ref{lem:sperttf}. Clearly the former cannot be the
case, for then  would have a greater depth than . So the latter is
the case and  for some  that is not equal
to  and does not contain  or  (because then  would
too). But this violates Lemma \ref{lem:snondectf}, which states that no such
decomposition exists.
\end{proof}

\section{Completeness}
\label{sec:sclcpl}
With the two theorems from the previous section, we can prove completeness for
. We define three auxiliary functions to aid in our definition of the
inverse of  on . Let  be the function
that returns the conjunction decomposition of its argument,  of the same
type its disjunction decomposition and , also of the same type, its
--decomposition. Naturally, these functions are undefined when their
argument does not have a decomposition of the specified type. Each of these
functions returns a pair and we will use  (, ) to denote
the first element of this pair and  (, ) to denote the
second element.

We define  using the functions  for
inverting trees in the image of -terms and , 
and  of the same type for inverting trees in the image of
-terms, -terms and -terms, respectively. These functions are
defined as follows.


\begin{restatable}{theorem}{thminvscorrect}
\label{thm:sclinv}
For all , .
\end{restatable}

The proof for this theorem can be found in Appendix \ref{sec:sclinv}. For the
sake of completeness, we separately state the completeness result below.

\begin{theorem}
\label{thm:sclcpl}
For all , if  then .
\end{theorem}
\begin{proof}
It suffices to show that for ,  implies . To see this suppose that  and  are two -terms and
. We know that  is derivably equal to an -term
, i.e., , and that  is derivably equal to an
-term , i.e., . Theorem \ref{thm:sclsnd} then
gives us  and . Hence by the result  and in particular . Transitivity then gives us
 as desired.

The result follows immediately from Theorem \ref{thm:sclinv}.
\end{proof}

In Section \ref{sec:fsclpa} we use this result to prove that  is
equivalent to  as it is defined by Bergstra and Ponse in \cite{scl}.
