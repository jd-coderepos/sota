\myparagraph{Lessons Learned and Insights}
We summarize some of the most important lessons learned from the deployment of
previous revocation schemes (for more details see \S\ref{sec:related}):
\begin{inparaenum}[\itshape 1)]
	\item \textit{During the connection establishment process a client cannot make
		any dedicated connection to check whether a certificate is revoked.}
    Otherwise, an additional latency is introduced, privacy may be violated, and
    the connection can be established only when the third party is available.
    (See CRL and OCSP.)
	\item \textit{Due to large bandwidth and storage overheads, clients cannot be
	  constantly equipped with complete lists of revocations.} Moreover, due to
    the expected increase in the number of TLS clients and servers, this might
    become even more problematic in the future. (See CRL and CRLSet.)
	\item \textit{It is very unlikely that a significant fraction of all servers
    be rapidly updated to use a new security enhancement.} (See OCSP Stapling
    and log-based approaches.)
\end{inparaenum}

Our first observation is that, as clients and servers cannot be updated with
fresh revocations and clients should avoid obtaining revocation status via a
dedicated connection, the only remaining possibility to provide revocation
status to clients is to implement a network functionality that will support it.

The second observation is that an efficient, robust, and fast dissemination
network is a necessary component of a satisfactory revocation system in the
current TLS ecosystem, and CDN infrastructures fulfill all these requirements.

Finally, the current formats of revocation lists do not allow to efficiently
monitor the revocations issued by CAs. For instance, it is challenging to detect
a misbehavior when a CA shows different CRLs (or OCSP messages) to different
clients (for instance to hide the fact that a given certificate is revoked).

\myparagraph{High-level Design}
Taking into consideration the lessons learned and our observations, the
high-level idea is to
\begin{inparaenum}[\itshape 1)]
  \item propagate revocations through a CDN,
  \item piggyback revocation status to standard TLS communications, and
  \item enhance the format of revocation lists to enable a more efficient
    monitoring of CAs.
\end{inparaenum}
In this setting, every revocation is distributed through a dissemination
network, and for every TLS connection, a dedicated middlebox (that is connected
to the dissemination network) on the path between the client and the server will
put fresh, authentic, and accountable revocation status along with the native
TLS message towards the client.

\begin{figure}[h!]
	\centering
    \includegraphics[width=0.8\linewidth]{diss_net}
    \caption{High-level architecture of \name.}\label{fig:diss_net}
\end{figure}

\name's high-level architecture is depicted in Fig.~\ref{fig:diss_net}. The
essential element of \name is a network middlebox called the \textit{Revocation
Agent} (RA). RAs are designed to fulfill several purposes. First, they connect
to the dissemination network used to propagate revocations. As opposed to client
machines, middleboxes are usually always turned on, which allows them to
constantly receive and collect new revocations from the dissemination network
(steps 1, 2, 3). Then, for every TLS connection, an RA provides fresh revocation
status to the \name-supported clients (step 4). For non-supported clients and
for non-TLS traffic, RAs act as transparent middleboxes. Finally, RAs are able
to keep CAs accountable, as they monitor the revocations they issue, compare
their views of revocations with other parties of the system, and report any
detected misbehavior in a provable manner (step 5).

\myparagraph{Revocation Lists}\label{sec:details:dict}
One challenge is to find a format of revocation list that meets our
requirements.  Ideally, it should be realized in a way that allows to keep CAs
accountable and that supports efficient, authentic, and fresh proofs of
certificate status.  To achieve this, \name extends the concept of
\textit{authenticated dictionary}~\cite{naor2000certificate}. This structure
allows a non-trusted \textit{prover} to prove to a \textit{verifier} that the
queried object is (or is not) an element of a given dictionary created by a
trusted third party. In our scenario, the RA is a prover, the client acts as a
verifier, and the CA is a trusted third party. Every CA maintains a dictionary
of its own revocations, while every RA stores copies of all the dictionaries.
These dictionaries are constantly updated (by the CAs through the dissemination
network) with new revocations and metadata, which ensures that a given
dictionary is fresh and consistent. Dictionaries are append-only
(\S\ref{sec:discussion} discusses this property and optimizations), and the
proof generated by a prover:
\begin{inparaenum}[\itshape 1)]
    \item can efficiently express presence/absence of a given revocation in/from
      a given dictionary,
    \item is authentic, i.e., the verifier is sure that the statement was
      produced by the CA, and
    \item is timestamped, so that a verifier can reject a stale proof.
\end{inparaenum}
Moreover, authenticated dictionaries allow to keep CAs accountable, as they help
to maintain a consistent view across the system. For instance, entities with a
short proof can check whether their dictionary views are consistent.
Consequently, all inconsistencies can be eventually detected and proven.

\begin{figure}
	\centering
	\footnotesize
	\setlength{\tabcolsep}{10pt}
	\noindent\rule{\linewidth}{0.5pt}

	\begin{description}
		\item[\texttt{insert}] (executed by a CA that revokes a certificate with
      serial number ):
	\end{description}

	 : size of the dictionary with  appended, \quad  : parameter chosen
  by CA

	\begin{enumerate}
	  \item Insert  into the tree and rebuild it.
	  \item For random value  compute .
	  \item Return \textbf{signed root}:
	    \begin{centredequ}\label{eq:signed_root}
	      \{\textit{root}, n, H^m(v), \textit{time}()\}_{K_{\textit{CA}}^{-}}
	    \end{centredequ}
	\end{enumerate}

	\begin{description}
		\item[\texttt{update}] (executed by an RA on input
      ):
	\end{description}

	\begin{enumerate}
	  \item Verify the signature and timestamp .
	  \item Insert  into the tree and rebuild it.
	  \item Accept the applied changes only if the newly-built root equals
       and  is a number of leaves in the new tree.
	\end{enumerate}

	\begin{description}
		\item[\texttt{refresh}] (executed by a CA at least every  if there
      is no new revocation):
	\end{description}

	\begin{description}
		\item  : timestamp of the latest signed root
	\end{description}

	\begin{enumerate}
	    \item .
	    \item If  return \textbf{freshness statement}:
	        \begin{centredequ}\label{eq:fresh_statement}
	            H^{m-p}(v).
	        \end{centredequ}
	    \item If  create a new signed root (see
	        Eq.~(\ref{eq:signed_root})) and go to step 1.
	\end{enumerate}

	\begin{description}
		\item[\texttt{prove}] (executed by an RA on input ):
	\end{description}

	\begin{enumerate}
	  \item Produce presence/absence proof for .
	  \item Return \textbf{revocation status}:
	    \begin{centredequ}\label{eq:proof_root}
	      \textit{proof}, \{\textit{root}, n, H^m(v), t\}_{K_{CA}^{-}}, H^{m-p}(v),
	    \end{centredequ}
	    where  is the latest (current) freshness statement.
	\end{enumerate}

	\noindent\rule{\linewidth}{0.5pt}
	\caption{Interactions with an authenticated dictionary. Operations
	\texttt{insert} and \texttt{update} can be performed in batch (to add multiple
	revocations to the tree simultaneously).}\label{fig:auth_dict_api}
\end{figure}


\name implements authenticated dictionaries with hash trees (see
\S\ref{sec:pre:hash_trees}).  Every leaf of a tree is a serial number of the
revoked certificate concatenated with the number of that revocation.  For each
dictionary, revocations are numbered consecutively, starting from~1.  The
numbering ensures that revocations are inserted into the tree in the correct
order, which helps to maintain a consistent copy of the dictionary and detect
attacks (such as revocation reordering). Leaves are sorted in lexicographical
order (using their serial numbers), which allows to prove that a given leaf is
or is not an element of the tree. We define the message names and the
dictionary's interface in Fig.~\ref{fig:auth_dict_api}.

\myparagraph{Dissemination}\label{sec:details:diss}
\name can employ an existing CDN infrastructure as a dissemination network, and
such a deployment brings many benefits. CDNs are efficient and robust in
large-scale deployments~\cite{al2011overclocking}, and we show that they provide
an excellent environment for dissemination of revocation messages. As our study
shows, a CDN-based deployment is also cost-effective (see
\S\ref{sec:eval:cost}).


\begin{table}[b!]
\centering
\footnotesize
\begin{tabular}{@{}lcc@{}}
	\toprule
    \textbf{Time} & \textbf{Revoked serial number} & \textbf{Disseminated message} \\
    \midrule
     & , ,  & , , ,  \\
     & none &  \1ex]
     &  & ,  \\
    \bottomrule
\end{tabular}
\caption{Example of messages disseminated over time.}\label{tab:diss}
\end{table}

Whenever a CA wishes to revoke some certificate(s), it updates its local
dictionary through the \texttt{insert} operation (see
Fig.~\ref{fig:auth_dict_api}). Then, the CA contacts the network's distribution
point with the \textit{revocation issuance} message, i.e., the revoked serial
number(s) with a new signed root (e.g., at times  and  in
Tab.~\ref{tab:diss}). The distribution point verifies this message and initiates
the dissemination process by sending the message to edge servers. Eventually,
all RAs obtain the message from the corresponding edge server and update their
local copy of the CA's dictionary through the \texttt{update} operation (see
\S\ref{sec:details:dict}).

\begin{figure}
    \centering
    \includegraphics[width=0.9\linewidth]{example}
    \caption{An example of \name-supported TLS connection.}\label{fig:example}
\end{figure}

When no new revocations are issued during a time period , CAs are still
obliged to keep their dictionaries fresh. In order to achieve this, every CA
creates and disseminates a freshness statement (Eq.~\ref{eq:fresh_statement})
periodically (e.g., at times  and  in
Tab.~\ref{tab:diss}). Therefore, to keep dictionaries fresh when there is no new
revocation within a time period  (which is a common case), CAs
disseminate only a freshness statement that in practice is significantly shorter
than a signed message.  Moreover, due to hash chain properties
(see~\S\ref{sec:pre:hash_trees}), the message is authentic, as only a CA can
create a valid freshness statement for a given time period. The dissemination
process of a freshness statement is the same as before, and RAs, after
verification, replace the freshness statement with the new one.

\name provides a simple synchronization protocol to keep the dictionary copies
of RAs correctly updated.  As every revocation issuance message contains a value
 that denotes the number of revocations that the CA has issued, an RA can
easily detect whether his local copy is desynchronized from CA's original copy
based on . Whenever a desynchronization is detected, the RA contacts an edge
server specifying the number of valid consecutive revocations it has observed.
The signed root with a timestamp (Eq.~(\ref{eq:signed_root})) also guarantees
integrity, as it is impossible to alter a dictionary without changing the root.

\myparagraph{Validation}\label{sec:details:valid}
Our technique relies on the fact that the negotiation phase of TLS is performed
in plaintext. Thus, RAs can detect new TLS connections and the corresponding
server certificates that must be validated. A \name-supported TLS connection is
presented in Fig.~\ref{fig:example}, and we describe below the different steps
in detail.

\begin{enumerate}[leftmargin=*]
  \item The TLS connection is initiated by a \texttt{ClientHello} message. The
    client sends it with a dedicated TLS extension~\cite{rfc5246}, to inform
    potential RAs on the path that this TLS connection should be protected by
    \name.

  \item An RA on the path observes the traffic for TLS messages. Whenever it
    receives a \texttt{ClientHello} message with the \name extension, it creates
    the following state:
    
    \texttt{sIP, dIP, sPort, dPort} denote source/destination IP addresses and ports;
    \texttt{lastStatus} is the latest time at which a revocation status was sent
    to the client; \texttt{stage} describes the current stage of the TLS
    connection; \texttt{CA} allows the RA to identify the correct dictionary;
    and \texttt{SN} is the certificate's serial number. The RA identifies
    supported TLS connections using this state information.

    When the state is created, the \texttt{ClientHello} message is passed to
    the next hop on the path towards the server.

  \item The server responds with a \texttt{ServerHello} message followed by
    the server's certificate. (The server ignores the \name's
    \texttt{ClientHello} extension.)

  \item When an RA receives a \texttt{ServerHello} message that matches the
    previously-created state, it inspects the content of the message to
    obtain the server's certificate and to determine the CA that issued the
    certificate. Then, the RA executes the \texttt{prove} procedure (see
    Fig.~\ref{fig:auth_dict_api}) over the CA's dictionary. A revocation status
    (i.e., proof, signed root, and a freshness statement as in
    Eq.~(\ref{eq:proof_root})) is appended to the \texttt{ServerHello} message
    and passed to the client. The RA updates the state from
    Eq.~(\ref{eq:state0}) by setting
    \texttt{lastStatus} to the current time, \texttt{stage} to
    \texttt{ServerHello}, \texttt{CA} to the CA identifier, and
    \texttt{SN} to the serial number of the server's certificate.

  \item When the client receives a \texttt{ServerHello} message with a
    revocation status (Eq.~(\ref{eq:proof_root})), he removes the status from
    the message (to not influence the TLS protocol), and a standard
    certificate-validation procedure is executed.  Additionally, the client
    verifies the revocation status sent by the RA. The server's certificate
    is accepted when:
    \begin{enumerate}
        \item it passes the standard validation,
        \item the revocation status contains a valid revocation absence proof
        (validated against a signed root), and
    	\item the freshness statement is no older than  (see
        \S\ref{sec:analysis:short}), i.e., for received revocation status
        as in Eq.~(\ref{eq:proof_root}),  or
         equals , where
        .
    \end{enumerate}

  \item Finally, when the TLS connection is accepted (i.e., when the server
    sends a \texttt{Finished} message), the RA updates the \texttt{stage} field
    to \texttt{established}.  From this moment on, the client and the server
    communicate securely. Whenever the RA detects that  time has passed
    since it has received a revocation status for a supported connection (i.e.,
    ), the RA uses the first
    TLS packet from the server to the client to piggyback a fresh revocation
    status (similarly as in step 4). After the fresh status is sent, the RA
    updates \texttt{lastStatus} to .

  \item Whenever the client receives the packet with a revocation status, he
    checks the status, similarly as in step 5.
\end{enumerate}
Steps 6 and 7 are conducted periodically, at least every , and the
connection is interrupted by the client, when a fresh absence proof is not
provided. Whenever a supported connection is finished or timed out, the RA
removes the corresponding state.

\name supports two mechanisms of TLS resumption, namely \textit{session
identifiers}~\cite{rfc5246}, and \textit{session tickets}~\cite{rfc5077}.
Although the TLS handshake for these modes is abbreviated, the presented
mechanism is similar. We present \name in a setting where the revocation status
is provided to the client piggybacked on standard TLS traffic. However, in
\S\ref{sec:discussion} we discuss other implementation choices to achieve this
functionality.

\myparagraph{Consistency Checking}\label{sec:details:consist}
\name enables RAs and clients to monitor CA actions related to certificate
revocations. Through the construction of trusted dictionaries and validation
logic, a CA has to provide freshness statements, which are short, unique, and
unforgeable pieces of information about a dictionary's content. This message can
be used directly by RAs to monitor the consistency of dictionaries. The goal is
to ensure that a given party of the system has the same view of the dictionaries
as the rest of the system.  In order to achieve this property, an RA can
periodically request a random edge server for its copy of the signed root. Only
by comparing local and downloaded values, the RA can confirm that a copy stored
by the edge server is identical to the RA's copy. Simply exchanging the latest
signed root is enough to keep CAs accountable, as dictionaries are append-only,
and as a violation from the append-only property is easily detectable.

Due to nature of the CDN environment an RA can detect and contact only a limited
number of edge servers (usually, a list of the closest edge servers can be
obtained via a DNS query). This limitation may decrease the effectiveness of the
consistency checking procedure. To address this problem, a \textit{map server}
can be introduced. That server would store addresses of RAs (and optionally edge
servers), so that they can communicate directly to exchange their current
freshness statements. An alternative way is to deploy a gossip protocol (for
example, as proposed by Chuat et al.~\cite{gossip2015}), where clients would
exchange signed roots obtained during TLS connections, or to deploy dedicated
parties to monitor CAs as proposed in log-based
approaches~\cite{KimHuaPerJacGli13}.

Such procedures can protect from various possible attacks launched by a
malicious CA (for details see \S\ref{sec:analysis}). Moreover, any detected
misbehavior can be cryptographically proved and reported, for example to the
software vendors.
