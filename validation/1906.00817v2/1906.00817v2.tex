\documentclass{article}







\usepackage[final, nonatbib]{neurips_2019}



\usepackage[utf8]{inputenc} \usepackage[T1]{fontenc}    \usepackage{hyperref}       \usepackage{url}            \usepackage{booktabs}       \usepackage{amsfonts}       \usepackage{nicefrac}       \usepackage{microtype}      \usepackage{multirow}
\usepackage[table]{xcolor}
\usepackage{array}
\usepackage{float}
\usepackage{graphicx}
\usepackage{mathtools}
\usepackage{makecell}
\usepackage{tikz}
\usepackage{subcaption}
\usepackage{soul,colortbl}
\usepackage{sidecap}

\usepackage{enumitem}
\definecolor{col_person}{RGB}{192,128,128}
\definecolor{col_cycle}{RGB}{1,128,7}
\definecolor{col_bike}{RGB}{66,127,128}
\definecolor{col_plane}{RGB}{220,20,60}
\definecolor{col_cat}{RGB}{124,0,0}
\definecolor{col_train}{RGB}{129,92,0}
\definecolor{col_chair}{RGB}{192,0,2}
\definecolor{col_sky}{RGB}{0,191,64}
\definecolor{col_bird}{RGB}{127,128,0}
\definecolor{col_boat}{RGB}{2,0,129}
\definecolor{col_bus}{RGB}{0,128,130}
\definecolor{col_dog}{RGB}{192,0,133}
\definecolor{col_horse}{RGB}{75,0,130}
\definecolor{col_sofa}{RGB}{0,255,0}
\definecolor{col_chair}{RGB}{220,20,60}
\definecolor{col_car}{RGB}{211,211,211}
\definecolor{col_cow}{RGB}{34,139,34}
\definecolor{col_table}{RGB}{255,140,0}





\definecolor{FIGBLUE}{HTML}{0b5394}
\definecolor{FIGORANGE}{HTML}{b45f06}
\definecolor{FIGGREEN}{HTML}{38761d}
\definecolor{Gray}{gray}{0.9}



\newcommand{\ppc}[1]{\textcolor{orange}{[PP: #1]}}
\newcommand{\pp}[1]{\textcolor{orange}{#1}}
\newcommand{\mco}[1]{\textcolor{red}{[MC: #1]}}
\newcommand{\thv}[1]{\textcolor{magenta}{[THV: #1]}}
\newcommand{\mx}[1]{\textcolor{blue}{[MB: #1]}}

\newcommand{\mbf}[1]{\ensuremath{\mathbf{#1}}} 
\newcommand{\mbs}[1]{\ensuremath{\boldsymbol{#1}}} 
\newcommand{\mc}[1]{\ensuremath{\mathcal{#1}}} 
\newcommand{\bx}{\mbf{x}}
\newcommand{\by}{\mbf{y}}
\newcommand{\ba}{\mbf{a}}
\newcommand{\bw}{\mbf{w}}
\newcommand{\bz}{\mbf{z}}
\newcommand{\cC}{\mc{C}}
\newcommand{\cS}{\mc{S}}
\newcommand{\cU}{\mc{U}}
\newcommand{\cD}{\mc{D}}
\newcommand{\cX}{\mc{X}}
\newcommand{\cY}{\mc{Y}}

\title{Zero-Shot Semantic Segmentation}



\author{
   Maxime Bucher \\
   valeo.ai  \\
   \texttt{maxime.bucher@valeo.com} 
   \And
   Tuan-Hung Vu \\
   valeo.ai  \\
   \texttt{tuan-hung.vu@valeo.com} 
   \AND
   Matthieu Cord \\
   Sorbonne Université\\valeo.ai  \\
   \texttt{matthieu.cord@lip6.fr} 
   \And
   Patrick Pérez \\
   valeo.ai  \\
   \texttt{patrick.perez@valeo.com} 
}

\begin{document}

\maketitle

\begin{abstract}
    Semantic segmentation models are limited in their ability to scale to large numbers of object classes. In this paper, we introduce the new task of zero-shot semantic segmentation: learning pixel-wise classifiers for \emph{never-seen} object categories with zero training examples. To this end, we present a novel architecture, ZS3Net, combining a deep visual  segmentation model with an approach to generate visual representations from semantic word embeddings. By this way, ZS3Net addresses pixel classification tasks where both seen and unseen categories are faced at test time (so called ``generalized'' zero-shot classification). Performance is further improved by a self-training step that relies on automatic pseudo-labeling of pixels from unseen classes. On the two standard segmentation datasets, Pascal-VOC and Pascal-Context, we propose zero-shot benchmarks and set competitive baselines. For complex scenes as ones in the Pascal-Context dataset, we extend our approach by using a graph-context encoding to fully leverage spatial context priors coming from class-wise segmentation maps.
    
    Code and models are available at: \textit{\textcolor{blue}{\url{https://github.com/valeoai/ZS3}}}.
\end{abstract} 
\section{Introduction}

Semantic segmentation has achieved great progress using convolutional neural networks (CNNs).
Early CNN-based approaches classify region proposals to generate segmentation predictions~\cite{girshick2014rich}.
FCN~\cite{long2015fully} was the first framework adopting fully convolutional networks to address the task in an end-to-end manner.
Most recent state-of-the-art models like UNet~\cite{ronneberger2015u}, SegNet~\cite{badrinarayanan2017segnet}, DeepLabs~\cite{chen2017deeplab, chen2018encoder}, PSPNet~\cite{zhao2017pyramid} are FCN-based.
An effective strategy for semantic segmentation is to augment CNN features with contextual information, e.g. using atrous/dilated convolution~\cite{chen2017deeplab,yu2015multi}, pyramid context pooling~\cite{zhao2017pyramid} or a context encoding module~\cite{zhang2018context}.

Segmentation approaches are mainly supervised, but there is an increasing interest in weakly-supervised segmentation models using annotations at the image-level~\cite{papandreou2015weakly,pathak2015constrained} or box-level~\cite{dai2015boxsup}.
We propose in this paper to investigate a complementary learning problem where part of the classes are missing altogether during the training. Our goal is to re-engineer existing recognition architectures to effortlessly accommodate these never-seen, a.k.a. unseen, categories of scenes and objects.
No manual annotations or real samples, only unseen labels are needed during training. This line of works is usually coined \textit{zero-shot} learning (ZSL).


ZSL for image classification has been actively studied in recent years.  Early approaches address it as an embedding problem \cite{akata2015label, akata2015evaluation, bucher2016improving, changpinyo2016synthesized, frome2013devise, kodirov2017semantic, norouzi2013zero, romera2015embarrassingly, socher2013zero, verma2017simple, xian2016latent, zhang2015zero}.
They learn how to map image data and class descriptions into a common space where semantic similarity translates into spacial proximity. There are different variants in the literature on how the projections or the similarity measure are computed: simple linear projection  \cite{akata2015label, akata2015evaluation, bucher2016improving, frome2013devise, kodirov2017semantic, romera2015embarrassingly},  non-linear  multi-modal embeddings \cite{socher2013zero, xian2016latent} or even hybrid methods \cite{changpinyo2016synthesized, norouzi2013zero, verma2017simple, zhang2015zero}. 

Recently, \cite{bucher2017generating, kumar2018generalized, xian2018feature} proposed to generate synthetic instances of unseen classes by training a conditional generator from the seen classes. There are very few extensions of zero-shot learning to other tasks than classification. Very recently \cite{bansal2018zero, demirel2018zero, rahman2018zero, zhu2019zero} attacked object detection: unseen objects are detected while box annotation is only available for seen classes. As far as we know, there is no approach considering zero-shot setting for segmentation.

In this paper, we introduce the new task of zero-shot semantic segmentation (ZS3) and propose an architecture, called ZS3Net, to address it: Inspired by most recent zero shot classification apporaches, we combine a backbone deep net for image embedding with a generative model of class-dependent features. This allows the generation of visual samples from unseen classes, which are then used to train our final classifier with real visual samples from seen classes and synthetic ones from unseen classes. 
Figure~\ref{fig:bp} illustrates the potential of our approach for visual segmentation.
We also propose a novel self-training step in a relaxed zero-shot setup where unlabelled pixels from unseen classes are already available at training time. The whole zero-shot pipeline including self-training is coined as ZS5Net (ZS3Net with Self-Supervision) in this work.

Lastly, we further extend our model by exploiting contextual cues from spatial region relationship. This strategy is motivated by the fact that similar objects not only share similar properties but also similar contexts. For example, `cow' and `horse' are often seen in fields while most `motorbike' and `bicycle' show in urban scenes.

We report evaluations of ZS3Net on two datasets (Pascal-VOC and Pascal-Context) and in zero-shot setups with varying numbers of unseen classes. Compared to a ZSL baseline, our method delivers excellent performances, which are further boosted using self-training and semantic contextual cues. 

\begin{figure*}[t!]
\captionsetup[subfigure]{labelformat=empty}
	\begin{center}
		\begin{subfigure}[t]{0.32\textwidth}\centering
			\caption{Input image}\vspace{-0.2cm}
			\includegraphics[trim=3cm 1.4cm 2cm 2.2cm, clip=true, width=.9\textwidth]{./figure_voc/img1.PNG}
		\end{subfigure}
		\begin{subfigure}[t]{0.32\textwidth}\centering
			\caption{w/o Zero-Shot Segmentation}\vspace{-0.2cm}
			\includegraphics[trim=4cm 1.8cm 2cm 2.7cm, clip=true, width=.9\textwidth]{./figure_voc/deep1.PNG}
		\end{subfigure}
		\begin{subfigure}[t]{0.32\textwidth}\centering
			\caption{Our ZS3Net Segmentation}\vspace{-0.2cm}
			\includegraphics[trim=4cm 1.8cm 2cm 2.7cm, clip=true, width=.9\textwidth]{./figure_voc/pred1.PNG}
		\end{subfigure}\\\vspace{0.1cm}
	\end{center}
	\vspace{-0.3cm}
	\caption{\small \textbf{Introducing and addressing zero shot semantic segmentation}. 
	In this example, there are no `motorbike' examples in the training set. As a consequence, a supervised model (middle) fails on this object, 
	seeing it as a mix of the seen classes 
	\setlength{\fboxsep}{1pt}\colorbox{col_person}{\textcolor{white}{person}}, 
	\setlength{\fboxsep}{1pt}\colorbox{col_cycle}{\textcolor{white}{bicycle}} and 
	\setlength{\fboxsep}{1pt}\colorbox{black}{\textcolor{white}{background}}. 
	With proposed ZS3Net method (right), pixels of the never-seen 
	\setlength{\fboxsep}{1pt}\colorbox{col_bike}{\textcolor{white}{motorbike}}
	class are recognized.}
	\vspace{-0.5cm}
	\label{fig:bp}
\end{figure*}
 \section{Zero-shot semantic segmentation}

\subsection{Introduction to our strategy}
Zero-shot learning addresses recognition problems where not all the classes are represented in the training examples.
This is made possible by using a high-level description of the categories that helps relate the new classes (the {\em unseen classes}) to classes for which training examples are available (the {\em seen classes}).
Learning is usually done by leveraging an intermediate level of representation, which provides semantic information about the categories to classify.

A common idea is to transfer semantic similarities between linguistic identities from some suitable text embedding space to a visual representation space.
Effectively, classes like `zebra' and `donkey' that share a lot of semantic attributes are likely to stay closer in the representation space than very different classes, `bird' and `television' for instance. Such a joint visual-text perspective enables statistical training of zero-shot recognition models.

We address in this work the problem of learning a semantic segmentation network capable of discriminating between a given set of classes where training images are only available for a subset of it.
To this end, we start from an existing semantic segmentation model trained with a supervised loss on seen data (DeepLabv3+ in Fig.~\ref{method}).
This model is limited to trained categories and, hence, unable to recognize new unseen classes.
In Figure~\ref{fig:bp}-(middle) for instance, 
the person (a seen class) is correctly segmented unlike the motorbike (an unseen class) whose pixels are wrongly predicted as a mix of `person', `bicycle' and `background'.

To allow the semantic segmentation model to recognize both seen and unseen categories, we propose to generate synthetic training data for unseen classes.
This is obtained with a generative model
conditioned on the semantic representation of target classes.
This generator outputs pixel-level multi-dimensional features 
that the segmentation model relies on  (blue zone 1 in Fig.~\ref{method}).

Once the generator is trained, many synthetic features can be produced for unseen classes, and combined with real samples from seen classes.
This new set of training data is used to retrain the classifier of the segmentation network (orange zone 2 in Fig.~\ref{method}) so that it can now handle both seen and unseen classes.
At test time, an image is passed through the semantic segmentation model equipped with the retrained classification layer, allowing prediction for both seen and unseen classes. Figure~\ref{fig:bp}-(right) shows a result after this procedure, with the model now able to delineate correctly the motorbike category. 

\begin{figure}[t]
\centering
\includegraphics[scale=0.80]{images/method.png}
\caption{\small \textbf{Our deep ZS3Net for zero-shot semantic segmentation.}
The figure is separated into two parts by colors corresponding to: \textcolor{FIGBLUE}{(1)} training generative model and \textcolor{FIGORANGE}{(2)} fine-tuning classification layer.
In \textcolor{FIGBLUE}{(1)}, the generator, conditioned on the word2vec (\textcolor{FIGGREEN}{w2c}) embedding of seen classes' labels, learns to generate synthetic features that match real DeepLab's ones on seen classes.
Later in \textcolor{FIGORANGE}{(2)}, the classifier is trained to classify real features from seen classes and synthetic ones from unseen classes.
At run-time, the classifier operates on real DeepLab features stemming from both types of classes.}
\vspace{-0.5cm}
\label{method}
\end{figure}

\subsection{Architecture and learning of ZS3Net}\label{sec:arch_design}

We denote the set of all classes as $\cC = \cS \cup \cU$, with $\cS$ the set of seen classes and $\cU$ the set of unseen ones, where $\cS \cap  \cU =  \emptyset$. Each category $c\in\cC$ can be mapped through word embedding to a vector representation $\ba[c]\in\mathbb{R}^{d_a}$ of dimension $d_a$. In the experiments, we will use to this end the `word2vec' model~\cite{mikolov2013distributed} learned on a dump of the Wikipedia corpus (approx. 3 billion words). This popular embedding is based on the skip-gram language model which is learned through predicting the context (nearby words) of words in the target dictionary. As a result of this training strategy, words that frequently share common contexts in the corpus are located in close proximity in the embedded vector space. In other words, this semantic representation is expected to capture geometrically the semantic relationship between the classes of interest.

In FCN-based segmentation frameworks, the input images are forwarded through an encoding stack consisting of fully convolutional layers, which results in smaller feature maps compared to the original resolution.
Effectively, logit prediction maps have small resolutions and often require an additional up-sampling step to match the input size~\cite{chen2017deeplab, chen2018encoder, long2015fully}.
In the current context, with a slight abuse of notation, we attach each spatial location on the encoded feature map to a pixel of input image down-sampled to a comparable size. We can therefore assign class labels to encoded features and construct training data in the feature space.
From now on, `pixel' will refer to pixel locations in this down-sampled image.

\vspace{-0.3cm}
\paragraph{Definition and collection of pixel-wise data (step 0).}
We start from DeepLabv3+ semantic segmentation model~\cite{chen2018encoder}, pre-trained with a supervised loss on annotated data from seen classes. 
Based on this architecture, we need to choose suitable features, out of several feature maps that can be used independently for classification.
Conversely, the classifier to be later fine-tuned must be able to operate on individual pixel-wise features.
As a result, we choose the last $1\times1$ convolutional classification layer of DeepLabv3+ and the features it ingests as our classifier $f$ and targeted features $\bx$ respectively.

Let the training set $\cD_s = \left\{(\bx^s_i, \by^s_i, \ba^s_i) \right\}$ be composed of triplets where $\bx^s_i\in \mathbb{R}^{M\times N \times d_x}$ is 
a $d_x$-dimensional feature map, 
$\by^s_i \in \cS^{M\times N}$ is the associated ground-truth
segmentation map and $\ba^s_i \in \mathbb{R}^{M\times N \times d_a}$ is the class embedding map that associates to each pixel the semantic embedding of its class.

We note that $M\times N$ is the resolution of the encoded feature maps, as well as of the down-sampled image and segmentation ground-truth.\footnote{Final softmax and decision layers operate in effect after logits are up-sampled back to full resolution.}
For the $K = |\cU|$ unseen classes, no training data is available, only the category embeddings $\ba[c],~c\in\cU$.

On seen data, the DeepLabv3+ model is trained with full-supervision using the standard cross-entropy loss.
After this training phase, we remove the last classification layer and only use the remaining network for extracting seen features, as illustrated in blue part (1) of~Figure~\ref{fig:bp}.
To avoid supervision leakage from unseen classes~\cite{xian2018zero}, we retrain the backbone network on ImageNet~\cite{russakovsky2015imagenet} on seen classes solely.
Details are given later in Section~\ref{sec:exp_detail}.

\vspace{-0.3cm}
\paragraph{Generative model (step 1).}
Key to our approach is the ability to generate image features conditioned on a class embedding vector, without access to any images of this class.
Given a random sample $\bz$ from a fixed multivariate Gaussian distribution, and the semantic description $\ba$, new pixel features will be generated as $\widehat{\bx} = \mathbf{G}(\ba, \bz;\bw)\in\mathbb{R}^{d_x}$, where $\mathbf{G}$ is a trainable generator with parameters $\bw$.
Toward this goal, we can leverage any generative approach like GAN~\cite{goodfellow2014generative}, GMMN~\cite{li2015generative} or VAE~\cite{kingma2013auto}. This feature generator is trained under supervision of features from seen classes.


We follow~\cite{bucher2017generating} and adopt the ``Generative Moment Matching Network''~(GMMN)~\cite{li2015generative} for the feature generator.
GMNN is a parametric random generative process $\mathbf{G}$ using a differential criterion to compare the target data distribution and the generated one.
The generative process will be considered as good if, for each semantic description $\mathbf{a}$, two random populations $\mathcal{X}(\mathbf{a})\subset \mathbb{R}^{d_x}$ from $\mathcal{D}_s$ and $\widehat{\mathcal{X}}(\mathbf{a};\mathbf{w})$ sampled with the generator have low \emph{maximum mean discrepancy} (a classic divergence measure between two probability distributions):

$ L_{\text{GMMN}}(\mathbf{a}) =\sum_{\bx,\bx'\in\cX(\ba)} k(\bx,\bx')
 +\sum_{\widehat{\bx},\widehat{\bx}'\in\widehat{\cX}(\ba;\bw) } k(\widehat{\bx},\widehat{\bx}')
 - 2 \sum_{\bx\in\cX(\ba)} \sum_{\widehat{\bx}\in\widehat{\cX}(\ba,\bw)} k(\bx,\widehat{\bx}),
$
where $k$ is a kernel that we choose as Gaussian, $k(\bx, \bx') = \exp(-\frac{1}{2\sigma^2} \|\bx-\bx' \|^{2})$ with bandwidth parameter $\sigma$.
The parameters $\mathbf{w}$ of the generative network are optimized by Stochastic Gradient Descent~\cite{bottou2010large}.


\vspace{-0.3cm}
\paragraph{Classification model (step 2).}
Similar to DeepLabv3+, the classification layer $f$ consists of a $1\times1$ convolutional layer.
Once $\mathbf{G}$ is trained in step $1$, arbitrarily many pixel-level features can be sampled for any classes, unseen ones in particular.
We build this way a synthetic unseen training set $\widehat{\cD}_u = \{(\widehat{\bx}_j^u,y_j^u,\ba_j^u)\}$ of triplets in $\mathbb{R}^{d_x} \times \cU \times \mathbb{R}^{d_a}$.
Combined with the real features from seen classes in $\cD_s$, this set of synthetic features for unseen categories allows the fine-tuning of the classification layer $f$.
The new pixel-level classifier for categories in $\cC$ becomes $\widehat{y} = f(\bx; \widehat{\mathcal{D}}_u, \mathcal{D}_s)$. 
It can be used to conduct the semantic segmentation of images that exhibit objects from both types of classes. 


\vspace{-0.3cm}
\paragraph{Zero-shot learning and self-training.}

Self-training is a useful strategy in semi-supervised learning that leverages a model's own predictions on unlabelled data to heuristically obtain additional pseudo-annotated training data~\cite{zhu2005semi}.
Assuming that unlabelled images with objects from unseen classes are now available (this is thus a relaxed setting compared to pure ZSL), such a self-supervision can be mobilized to improve our zero-shot model. 
The trained ZS3Net (one gotten after step 2) can indeed be used to ``annotate'' these additional images automatically, and for each one, the top $p\%$ of the most confident among these pseudo-labels provide new training features for unseen classes. 
The semantic segmentation network is then retrained accordingly.
We coin this new model ZS5Net for ZS3Net with Self-Supervision.


Note that there exists a connection between ZS5Net and transductive zero-shot learning~\cite{li2017zero, song2018transductive, zhang2016zero}, but that our model is not transductive.
Indeed, under purely transductive settings, no data even unlabelled, is available at train time for unseen classes.
Differently, our ZS5Net learns from a mix of labelled and unlabelled training data, and is evaluated on a different test set (effectively, a form of semi-supervised learning).



\vspace{-0.3cm}
\paragraph{Graph-context encoding.} 

\begin{figure}[h]
\centering
\includegraphics[scale=0.7]{images/GC_generator.png}
\caption{\small \textbf{Graph-context encoding in the generative pipeline}. The segmentation mask is encoded as an adjacency graph of semantic connected components (represented as nodes with different colors in the graph). Each semantic node is attached to its corresponding word2vec embedding vector. The generative process is conditioned on this graph. The generated output is also a graph with the same structure as the input's, except that attached to each output node is a generated visual feature.  Best viewed in color.}
\vspace{-0.3cm}
\label{fig:gc_gen}
\end{figure}

Understanding and utilizing contextual information is very important for semantic segmentation, especially in complex scenes.
Indeed, by design, FCN-based architectures already encode context with convolutional layers.
For more context encoding, DeepLabv3+ applies several parallel dilated convolutions at different rates.
In order to reflect this mechanism we propose to leverage contextual cues for our feature generation.
To this end, we introduce a graph-based method to encode the semantic context for complex scenes with lots of objects as ones in the Pascal-Context dataset. 

In general, the structural object arrangement contains informative cues for recognition.
For example, it is common to see `dog' sitting on `chairs' but very rare to have `horses' doing the same thing. Such spatial priors are naturally captured by a form of relational graph, that can be constructed in different ways, \textit{e.g.}, using manual sketches or semantic segmentation masks of synthetic scenes. What matters most is the relative spatial arrangement, not the precise shapes of the objects. As a proof of concept, we simply exploit true segmentation masks during the training of the generative model. It it important to note that the images associated to these masks are not used during training if they contain unseen classes.      

A segmentation mask is represented by the adjacency graph $\mathcal{G=(\mathcal{V}, \mathcal{E})}$ of its semantic connected components: each node corresponds to one connected group of single class labels, and two such groups are neighbors if they share a boundary (hence being of two different classes). 
We re-design the generator to accept $\mathcal{G}$ as additional input using graph convolutional layers~\cite{kipf2016semi}.
As shown in Figure~\ref{fig:gc_gen}, each input node $\nu \in \mathcal{V}$ is represented by concatenating its corresponding semantic embedding $\mathbf{a}_{\nu}$ with a random Gaussian sample $\mathbf{z}_{\nu}$.
This modified generator outputs features attached to the nodes of the input graph.

 \section{Experiments}




\subsection{Experimental details}\label{sec:exp_detail}
\vspace{-0.3cm}
\paragraph{Datasets.} Experimental evaluation is done on the two datasets: Pascal-VOC 2012~\cite{everingham2015pascal} and Pascal-Context~\cite{mottaghi2014role}.
Pascal-VOC contains $1,464$ training images with segmentation annotations of $20$ object classes.
Similar to~\cite{chen2018encoder}, we adopt additional supervision from semantic boundary annotations~\cite{hariharan2011semantic} during training.
Pascal-Context provides dense semantic segmentation annotations for Pascal-VOC 2010, which comprises $4,998$ training and $5,105$ validation images of $59$ object/stuff classes.


\vspace{-0.3cm}
\paragraph{Zero-shot setups.}
We consider different zero-shot setups varying in number of unseen classes, we randomly construct the $2$-, $4$-, $6$-, $8$- and $10$-class unseen sets.
We extend the unseen set in an incremental manner, meaning that for instance the $4$- unseen set contains the $2$-. Details of the splits are as follows:

\begin{description}[noitemsep,topsep=0pt]
\vspace{-0.1cm}
\small{
\item[\,\,\,\,\,\,\,\,\,\,\textit{Pascal-VOC:}] 2-cow/motorbike, 4-airplane/sofa, 6-cat/tv, 8-train/bottle, 10-chair/potted-plant; 
\item[\,\,\,\,\,\,\,\,\,\,\textit{Pascal-Context:}] 2-cow/motorbike, 4-sofa/cat, 6-boat/fence, 8-bird/tvmonitor, 10-keyboard/aeroplane.
}
\end{description}

\vspace{-0.3cm}
\paragraph{Evaluation metrics.}
In our experiments we adopt standard semantic segmentation metrics~\cite{long2015fully}, i.e. pixel accuracy (PA), mean accuracy (MA) and mean intersection-over-union (mIoU).
Similar to~\cite{xian2018zero}, we also report harmonic mean (hIoU) of seen and unseen mIoUs.
The reason behind choosing harmonic rather than arithmetic mean is that seen classes often have much higher mIoUs, which will significantly dominate the overall result.
As we expect ZS3 models to produce good performance for both seen and unseen classes, the harmonic mean is an interesting indicator.
 
\vspace{-0.3cm}
\paragraph{A zero-shot semantic segmentation baseline.}

As a baseline, we adapt the ZSL classification approach in~\cite{frome2013devise} to our task.
To this end, we first modify the vanilla segmentation network, i.e. DeepLabv3+, to not produce class-wise probabilistic predictions for all the pixels, but instead to regress corresponding semantic embedding vectors.
Effectively, the last classification layer of DeepLabv3+ is replaced by a projection layer which transforms $256-$channel features maps into $300-$channel word2vec embedding maps.
The model is trained to maximize the cosine similarity between the output and target embeddings. 

At run-time, the label predicted at a pixel is the one with the text embedding which the most similar (in cosine sense) to the regressed embedding for this pixel.


\vspace{-0.3cm}
\paragraph{Implementation details.}
We adopt the DeepLabv3+ framework~\cite{chen2018encoder} built upon the ResNet-101 backbone~\cite{he2016deep}.
Segmentation models are trained by SGD~\cite{bottou2010large} optimizer using polynomial learning rate decay with the base learning rate of $7e^{-3}$, weight decay $5e^{-4}$ and momentum $0.9$.

The GMMN is a multi-layer perceptron with one hidden layer, leaky-RELU non-linearity~\cite{maas2013rectifier} and dropout~\cite{srivastava2014dropout}.
In our experiments, we fix the number of hidden neurons to $256$ and set the kernel bandwidths as $\{2, 5, 10, 20, 40, 60\}$.
These hyper-parameters are chosen with the ``zero-shot cross-validation procedure'' in~\cite{bucher2017generating}.
The input Gaussian noise has the same dimension as used w2c embeddings, namely $300$.
The generative model is trained using Adam optimizer~\cite{kingma2014adam} with the learning rate of $2e^{-4}$.
To encode the graph context as described in Section~\ref{sec:arch_design}, we replace the linear layers in GMMN by graph convolutional layers~\cite{kipf2016semi}, with no change in other hyper-parameters.

\begin{table} 
\caption{\small \textbf{Zero-shot semantic segmentation on Pascal-VOC.\vspace{3pt}}}
\small{
\begin{tabular}{clrrrrrrrrrrrr}  \toprule
 & & \multicolumn{3}{c}{Seen}  && \multicolumn{3}{c}{Unseen} && \multicolumn{4}{c}{Overall} \\ \cline{3-5} \cline{7-9} \cline{11-14} \noalign{\smallskip}
 $K$ &  Model  &  PA    &  MA    &  mIoU  &&  PA    &  MA  &  mIoU   &&  PA    &  MA & mIoU  & hIoU \\ \midrule[1.1pt]
 & Supervised & -- & --  & -- && -- & -- & -- && 94.7  & 87.2 & 76.9 & -- \\ \hline\noalign{\smallskip}
 \multirow{3}{*}{2} & Baseline  & 92.1 & 79.8  & 68.1  && 11.3 & 10.5 & 3.2 && 89.7  & 73.4 & 44.1 & 6.1 \\ 
                    & ZS3Net    & \bf 93.6 &  \bf 84.9  & \bf 72.0  && \bf 52.8 & \bf 53.7  & \bf 35.4 && \bf 92.7 & \bf 81.9 & \bf 68.5  & \bf 47.5 \\ \hline\noalign{\smallskip}
 \multirow{3}{*}{4} & Baseline  & 89.9 & 72.6  & 64.3 && 10.3  & 10.1  & 2.9  && 86.3  & 62.1 & 38.9 & 5.5\\ 
                    & ZS3Net    & \bf 92.0 & \bf  78.3 & \bf 66.4  && \bf 43.1 &  \bf 45.7 & \bf 23.2 &&  \bf 89.8 & \bf 72.1  & \bf 58.2 & \bf 34.4  \\ \hline\noalign{\smallskip}
 \multirow{3}{*}{6} & Baseline  & 79.5 & 45.1  & 39.8 && 8.3 & 8.4 & 2.7 && 71.1 & 38.4 & 33.4 &  5.1\\ 
                    & ZS3Net     & \bf 85.5 & \bf  52.1  & \bf  47.3 && \bf 67.3  & \bf 60.7  &\bf  24.2 && \bf 84.2 & \bf 54.6 & \bf 40.7   & \bf 32.0 \\ \hline\noalign{\smallskip}
 \multirow{3}{*}{8} & Baseline  & 75.8 & \bf 41.3  & \bf 35.7 && 6.9  & 5.7 & 2.0 &&  68.3 & 34.7 &   24.3 & 3.8\\ 
                    & ZS3Net     & \bf 81.6 &   31.6 &  29.2  && \bf 68.7  & \bf  62.3 & \bf 22.9 && \bf 80.3 & \bf 43.3 & \bf 26.8 & \bf 25.7  \\ \hline\noalign{\smallskip}
 \multirow{3}{*}{10}& Baseline  & 68.7 & 33.9  & 31.7  && 6.7 & 5.8 & 1.9  && 60.1  & 26.9 & 16.9 & 3.6\\ 
                     & ZS3Net     & \bf 82.7  &  \bf 37.4 & \bf 33.9 && \bf 55.2 & \bf  45.7 & \bf 18.1  && \bf 79.6 & \bf 41.4 & \bf 26.3  & \bf 23.6  \\ \bottomrule 
\vspace{-0.5cm}
\end{tabular}
}
\label{pascalvoc_res}
\end{table}

\begin{SCtable}
\centering
\caption{\textbf{Generalized- vs. vanilla ZSL evaluation}. Results are reported with mIoU metric on the $10$-unseen split from Pascal-VOC dataset.}
\small{
\begin{tabular}{lccll}\toprule
Models &  Generalized eval. & Vanilla eval.  \\ \midrule[1.1pt]
Baseline   &        ~1.9     &    41.7       \\ \midrule
ZS3Net       &        \bf 18.1   & \bf 46.2  \\ \bottomrule
\end{tabular}
}
\vspace{-0.5cm}
\label{vanillia_zsc}
\end{SCtable}

\subsection{Zero-shot semantic segmentation}\label{sec:exp_results}
We report in Tables~\ref{pascalvoc_res} and \ref{pascalcontext_res} results on Pascal-VOC and Pascal-Context datasets, according to the three metrics.
Instead of only evaluating on the unseen set (which does not show the strong prediction bias toward seen classes), we jointly evaluate on all classes and report results for seen, unseen, and all classes.
Such an evaluation protocol is more challenging for zero-shot settings, known as ``generalized ZSL evaluation''~\cite{chao2016empirical}.
In both Tables~\ref{pascalvoc_res} and \ref{pascalcontext_res}, we report in the first line the `oracle' performance of the model trained with full-supervision on the complete dataset (including both seen and unseen).


\begin{table}
\caption{\small \textbf{Zero-shot semantic segmentation on Pascal-Context.}\vspace{3pt}}
\setlength{\tabcolsep}{5pt}
\small{
\begin{tabular}{clrrrrrrrrrrrr} \toprule
& & \multicolumn{3}{c}{Seen} && \multicolumn{3}{c}{Unseen} && \multicolumn{4}{c}{Overall}     \\\cline{3-5} \cline{7-9} \cline{11-14}\noalign{\smallskip}
$K$ &Model           & PA    &MA    & mIoU  && PA    & MA    & mIoU    && PA    & MA   & mIoU  & hIoU \\ \midrule[1.1pt] 
&Supervised & -- & --  & -- && -- & -- & -- && 73.9  & 52.4 & 42.2 & -- \\ \hline\noalign{\smallskip}
\multirow{4}{*}{2} & Baseline & 70.2 & 47.7 & 35.8 && 9.5 & 10.2  & 2.7 && 66.2  & 43.9 & 33.1 &5.0 \\ 
&  ZS3Net & 71.6 &  52.4  & \bf 41.6 && 49.3  &   46.2  & 21.6 &&  71.2 & 52.2 &  41.0   & 28.4\\
&  ZS3Net + GC &  \bf 73.0 & \bf 52.9  &  41.5 && \bf 65.8  \bf  &  \bf 62.2  & \bf 30.0 && \bf 72.6  & \bf 53.1 & \bf 41.3 & \bf 34.8 \\ 
\hline\noalign{\smallskip}
\multirow{4}{*}{4} & Baseline & 66.2 & 37.9  & 33.4 && 9.0 & 8.4 & 2.5 && 62.8 & 34.6 & 30.7 & 4.7 \\ 
&  ZS3Net & 68.4 & 46.1  &  37.2 && \bf 58.4  \bf  &  \bf 53.3  &  24.9  &&  67.8 &  46.6 & 36.4 &  29.8 \\
&  ZS3Net + GC & \bf 70.3 & \bf 49.1  & \bf 39.5 &&  61.0  &  56.3  & \bf 29.1 && \bf 69.0 & \bf 49.7 & \bf 38.6 & \bf  33.5  \\ 
\hline\noalign{\smallskip}
\multirow{4}{*}{6} & Baseline &  60.8 & 36.7  & 31.9 && 8.8 & 8.0 & 2.1  && 55.9  & 33.5 & 28.8 & 3.9 \\ 
&  ZS3Net  &  63.3 &  38.0  &   32.1 && \bf  63.6  &  \bf 55.8 &  20.7 &&  63.3 &  39.8 & 30.9 &  25.2\\
&  ZS3Net + GC  & \bf 64.5  & \bf 42.7   & \bf 34.8 &&  57.2 &  53.3  & \bf 21.6  && \bf 64.2 & \bf 43.7  & \bf 33.5 & \bf 26.7 \\ \hline\noalign{\smallskip}
\multirow{4}{*}{8} & Baseline & 54.1 & 24.7  & 22.0 && 7.3 & 6.8 & 1.7 && 49.1 & 20.9 & 19.2 & 3.2 \\ 
&  ZS3Net  & 51.4 &  23.9 &  20.9   &&  68.2 \bf  & 59.9 \bf  &  16.0\bf  &&  53.1 &  28.7  &  20.3 & 18.1 \\
&  ZS3Net + GC  &  \bf 53.0  & \bf 27.1  & \bf 22.8 &&  \bf 68.5  &  \bf 61.1  & \bf 16.8 && \bf  54.6 & \bf 31.4  & \bf 22.0 & \bf  19.3 \\
\hline\noalign{\smallskip}
\multirow{4}{*}{10} & Baseline & 50.0 & 20.8  & 17.5 && 5.7 & 5.0 & 1.3 &&  45.1 & 16.8 & 14.3 & 2.4  \\ 
&  ZS3Net  & \bf 53.5 &   23.8 &  20.8  &&  58.6   &   43.2  &  12.7 && \bf 52.8  &  27.0  &  19.4 &  15.8 \\
&  ZS3Net + GC  & 50.3 & \bf 27.9   & \bf 24.0 && \bf 62.6  &  \bf 47.8  & \bf 14.1 && 51.2 & \bf 31.0 & \bf 22.3 & \bf  17.8 \\ \hline
\end{tabular}
}
\vspace{-0.4cm}
\label{pascalcontext_res}
\end{table}

\paragraph{Pascal-VOC.} Table~\ref{pascalvoc_res} reports segmentation performance on $5$ different splits comparing the ZSL baseline and our approach ZS3Net.
We observe that the embedding-based ZSL baseline (DeViSe~\cite{frome2013devise}), while nicely performing on seen classes, produces much worse results for the unseen. 
We conducted additional experiments, adapting ALE~\cite{akata2015label} with $K=2$.
They yielded $68.1\%$ and $4.6\%$ mIoU for seen and unseen classes (harmonic mean of $8.6\%$), on a par with the DeViSe-based baseline.

Not strongly harmed by the bias toward seen classes, the proposed ZS3Net provides significant gains (in PA, MA and most importantly mIoU) on the unseen classes, e.g. $+32.2\%$ mIoU in the $2$-split, similarly large gaps in other splits.
As for seen classes, the ZS3Net performs comparably to the ZSL baseline, with slight improvement in some splits.
Overall, we have favourable results on all the classes using our generative approach.
The last column of Table~\ref{pascalvoc_res} shows harmonic mean of the seen and unseen mIoUs, denoted as hIoU ($\%$).
As discussed in~\ref{sec:exp_detail}, the harmonic mean is a good indicator of effective zero-shot performance.
Again according to this metric, ZS3Net outperforms the baseline by significant margins.


As mentioned in~\ref{sec:arch_design}, our framework is agnostic to the choice of the generative model.
We experimented a variant of ZS3Net based on GAN \cite{xian2018feature}, which turned out to be on a par with the reported GMMN-based one.
In our experiments, GMMN was chosen due to its better stability.



In all experiments, we only report results with the generalized ZSL evaluation. Table~\ref{vanillia_zsc} shows the difference between this evaluation protocol and the common vanilla one.
In the vanilla case, prediction scores of seen classes are completely ignored, only unseen scores are used to classify the unseen objects.
As a result, this evaluation protocol does not show how well the models discriminate the seen and unseen pixels.
In zero-shot settings, predictions are mostly biased toward seen classes given the strong supervision during training.
To clearly reflect such a bias, the generalized ZSL evaluation is a better choice.
We see that the ZSL baseline achieves reasonably good result using the vanilla ZSL evaluation while showing much worse figures with the generalized one.
With ZS3Net, leveraging both real features from seen classes and synthetic ones from unseen classes to train the classifier helps reduce the performance bias toward the seen set.

The two first examples in Fig.~\ref{fig:sup_qual_seg_context} illustrate the merit of our approach. Model trained only on seen classes (`w/o ZSL')  interprets unseen objects as background or as one of the seen classes.
For example, `cat' and `plane' (unseen) are detected as `dog' and `boat' (seen); a large part of the `plane' is considered as `background'.
The proposed ZS3Net correctly recognizes these unseen objects.


\begin{figure*}
	\begin{center}
	    \begin{subfigure}[t]{0.24\textwidth}\centering 
						\caption{Input image}\vspace{-0.2cm}
			\includegraphics[trim=0cm 0.4cm 0cm 0.4cm, clip=true,width=.98\textwidth]{./figure_voc/img2.PNG}
		\end{subfigure} 
		\begin{subfigure}[t]{0.24\textwidth}\centering
			\caption{GT}\vspace{-0.2cm}
			\includegraphics[trim=0cm 0.8cm 0cm 0.4cm, clip=true,width=.98\textwidth]{./figure_voc/gt2.PNG}
		\end{subfigure} 
		\begin{subfigure}[t]{0.24\textwidth}\centering
			\caption{w/o ZSL}\vspace{-0.2cm}
			\includegraphics[trim=0cm 0.4cm 0cm 0.4cm, clip=true,width=.98\textwidth]{./figure_voc/deep2.PNG}
		\end{subfigure} 
		\begin{subfigure}[t]{0.24\textwidth}\centering
		\caption{ZS3Net segmentation}\vspace{-0.2cm}
			\includegraphics[trim=0cm 0.8cm 0cm 0.4cm, clip=true,width=.98\textwidth]{./figure_voc/pred2.PNG}
		\end{subfigure}\\ 
		\begin{subfigure}[t]{0.24\textwidth}\centering 
			\includegraphics[trim=0cm 0cm 0cm 2.1cm, clip=true,width=.98\textwidth]{./figure_voc/img3_bis.PNG}
		\end{subfigure} 
		\begin{subfigure}[t]{0.24\textwidth}\centering
			\includegraphics[trim=0cm 0cm 0cm 3.2cm, clip=true,width=.98\textwidth]{./figure_voc/gt3_bis.PNG}
		\end{subfigure} 
		\begin{subfigure}[t]{0.24\textwidth}\centering
			\includegraphics[trim=0cm 0cm 0cm 2.5cm, clip=true,width=.98\textwidth]{./figure_voc/deep3_bis.PNG}
		\end{subfigure} 
		\begin{subfigure}[t]{0.24\textwidth}\centering
			\includegraphics[trim=0cm 0cm 0cm 2.5cm, clip=true,width=.98\textwidth]{./figure_voc/pred3_bis.PNG}
		\end{subfigure}\\
		\begin{subfigure}[t]{0.24\textwidth}\centering
			\includegraphics[trim=0cm 0.4cm 0cm 1.2cm,clip=true,width=.98\textwidth]{./figure_context/img1.PNG}
		\end{subfigure}
		\begin{subfigure}[t]{0.24\textwidth}\centering
			\includegraphics[trim=0cm 0.8cm 0cm 1.7cm,clip=true,width=.98\textwidth]{./figure_context/gt1.PNG}
		\end{subfigure}
		\begin{subfigure}[t]{0.24\textwidth}\centering
			\includegraphics[trim=0cm 0.8cm 0cm 1.7cm,clip=true,width=.98\textwidth]{./figure_context/deep1.PNG}
		\end{subfigure}
		\begin{subfigure}[t]{0.24\textwidth}\centering
			\includegraphics[trim=0cm 0.8cm 0cm 1.7cm,clip=true,width=.98\textwidth]{./figure_context/pred1.PNG}
		\end{subfigure}\\
			\begin{subfigure}[t]{0.24\textwidth}\centering 
			\includegraphics[trim=0cm 1.0cm 0cm 1.7cm,clip=true,width=.98\textwidth]{./figure_context/img3.PNG}
		\end{subfigure}
		\begin{subfigure}[t]{0.24\textwidth}\centering
			\includegraphics[trim=0cm 1.5cm 0cm 2.1cm,clip=true,width=.98\textwidth]{./figure_context/gt3.PNG}
		\end{subfigure}
		\begin{subfigure}[t]{0.24\textwidth}\centering
			\includegraphics[trim=0cm 1.5cm 0cm 2.1cm,clip=true,width=.98\textwidth]{./figure_context/deep3.PNG}
		\end{subfigure}
		\begin{subfigure}[t]{0.24\textwidth}\centering
			\includegraphics[trim=0cm 1.5cm 0cm 2.1cm,clip=true,width=.98\textwidth]{./figure_context/pred3.PNG}
		\end{subfigure}
	\end{center}
	\vspace{-0.3cm}
	\caption{\small \textbf{Qualitative results on Pascal-VOC and Pascal-Context}. (a) Input image, (b) semantic segmentation ground-truth, (c) segmentation without zero-shot learning, (d) results with proposed ZS3Net. 
	Unseen classes:
	\setlength{\fboxsep}{1pt}\colorbox{col_plane}{\textcolor{white}{plane}}
	\setlength{\fboxsep}{1pt}\colorbox{col_cat}{\textcolor{white}{cat}}
    \setlength{\fboxsep}{1pt}\colorbox{col_cow}{\textcolor{white}{cow}}
    \setlength{\fboxsep}{1pt}\colorbox{col_boat}{\textcolor{white}{boat}};
	Some seen classes:
	\setlength{\fboxsep}{1pt}\colorbox{col_horse}{\textcolor{white}{dog}}
	\setlength{\fboxsep}{1pt}\colorbox{col_bird}{\textcolor{white}{bird}}
	\setlength{\fboxsep}{1pt}\colorbox{col_dog}{\textcolor{white}{horse}}
	\setlength{\fboxsep}{1pt}\colorbox{col_table}{\textcolor{white}{dining-table}}.
	Best viewed in color. 
	}
	\vspace{-0.3cm}
	\label{fig:sup_qual_seg_context}
\end{figure*}

\vspace{-0.3cm}


\paragraph{Pascal-Context.}
In Table~\ref{pascalcontext_res}, we provide results on the Pascal-Context dataset, a more challenging benchmark compared to Pascal-VOC.
Indeed Pascal-Context scene pixels are densely annotated with $59$ object/stuff classes, compared to only a few annotated objects (most of the time 1-2 objects) per scene in Pascal-VOC.
As a result, segmentation models universally report lower performance on Pascal-Context.
Regardless of such difference, we observe similar behaviors from the ZSL baseline and our method.
The ZS3Net outperforms the baseline by significant margins on all evaluation metrics.
We emphasize the important improvements on the seen classes, as well as the overall harmonic mean of the seen and unseen mIoUs. We visualize in the two last rows of Figure~\ref{fig:sup_qual_seg_context} qualitative ZS3 results on Pascal-Context.
Unseen objects, i.e. `cow' and `boat', while being wrongly classified as some seen classes without ZSL, can be fully recognized by our zero-shot framework.

As mentioned above, Pascal-Context scenes are more complex with much denser object annotations.
We argue that, in this case, context priors on object arrangement convey beneficial cues to improve recognition performance.
We have introduced a novel graph-context mechanism to encode such prior in Section~\ref{sec:arch_design}.
Proposed models enriched with this graph context, denoted as~`ZS3Net + GC' in Table~\ref{pascalcontext_res}, show consistent improvements over the ZS3Net models.
We note that for semantic segmentation, the pixel accuracy metric (PA) is biased toward the more dominant classes and might suggest misleading conclusions~\cite{csurka2013good}, as opposed to IoU metrics. 


\subsection{Zero-shot segmentation with self-training}\label{sec:self_training_results}




\begin{table}
	\caption{\small \textbf{Zero-shot with self-training}. ZS5Net results on Pascal-VOC and Pascal-Context datasets.\vspace{3pt}}
	\small{
		\begin{tabular}{clrrrrrrrrrrrr} \toprule
			&                & \multicolumn{3}{c}{Seen} && \multicolumn{3}{c}{Unseen}  && \multicolumn{4}{c}{Overall}     \\ \cline{3-5} \cline{7-9} \cline{11-14}\noalign{\smallskip}
			$K$ & Dataset           & PA    & MA    & mIoU  &&  PA    & MA    & mIoU && PA    &  MA     & mIoU  &  hIoU\\ \midrule[1.1pt] 
			\multirow{2}{*}{2}
			& VOC & 94.3   & 85.2   & 75.7  && 89.5 & 89.9  & 75.8  &&  94.2  & 85.9   & 75.8  & 75.7  \\
			& Context &  72.9  & 53.6  & 41.8 &&  81.0  & 78.1 & 55.5 && 71.8   & 50.6  & 42.0  & 47.7\\ \hline\noalign{\smallskip}
			\multirow{2}{*}{4} 
			 & VOC & 93.9 & 84.8 & 74.0 && 57.5 & 62.9  & 53.0 && 92.4  & 80.9  & 69.8 & 61.8 \\ 
		
				& Context &  66.0 & 46.3   & 37.5 &&  86.4 & 82.8   & 45.1 && 68.0    & 48.5   & 38.0 & 41.0\\ 
			\hline\noalign{\smallskip}
			\multirow{2}{*}{6} 
			& VOC & 93.8 & 82.0 & 71.2 && 68.3 & 61.2  & 53.1  &&  92.1 &  75.8 & 66.1 &  60.8\\ 
			& Context & 59.7  &  42.2 & 34.6 && 80.9 & 76.8 & 36.0 && 62.1 & 45.8 & 35.2 & 35.2 \\\hline\noalign{\smallskip}
			\multirow{2}{*}{8} 
			 & VOC & 92.6 & 77.8 & 68.3 && 68.2 & 62.0  & 50.0 &&  90.2 &  71.9 & 61.3 & 57.7 \\ 
			& Context &  51.8 & 34.1   & 28.5 && 76.2  &71.3 & 24.1 && 54.3    & 39.5   & 27.8  & 26.1 \\
			\hline\noalign{\smallskip}
			\multirow{2}{*}{10} 
			&  VOC & 90.1 & 83.9 & 72.3 && 57.8 & 48.0 & 34.5 &&  86.8 &  66.9 & 54.4 & 46.7 \\ 
			& Context  &  46.8  & 32.3 & 27.0  &&  70.2  & 57.1  & 20.7 && 49.5   & 36.4   & 26.0  & 23.4 \\ 
			\bottomrule
		\end{tabular}
	}
	\label{self_training}
\end{table}


\begin{SCfigure}[50][ht]
\centering
\includegraphics[scale=0.40]{images/2_unseen.png}
\caption{\small \textbf{Influence of parameter $p$ on ZS5Net}.  Evolution of the mIoU performance as a function of percentage of high-scoring unseen pixels, on the 2-unseen classes split from Pascal-VOC and Pascal-Context datasets.}
\vspace{-0.5cm}
\label{self_p}
\end{SCfigure}

We report performance of ZS5Net (ZS3Net with self-training) on Pascal-VOC and Pascal-Context in~Table~\ref{self_training} (with different splits according to datasets).
For performance comparison, the reader is referred to ZS3Net results in Tables~\ref{pascalvoc_res} and \ref{pascalcontext_res}.
Through zero-shot cross-validation we fixed the percentage of high-scoring unseen pixels as $p=25\%$ for Pascal-VOC and $p=75\%$ for Pascal-Context.
We show in Figure \ref{self_p} the influence of this percentage on the final performance. 
In general, the additional self-training step strongly boosts the performance in seen, unseen and all classes.
Remarkably, on the $2$-unseen split in both datasets, the overall performance in all metrics is very close to the supervised performance (reported in the first lines of Tables~\ref{pascalvoc_res} and~\ref{pascalcontext_res}).
Figure \ref{fig:self_training} shows semantic segmentation results on Pascal-VOC and Pascal-Context datasets. On both cases, self-training helps to disambiguate pixels wrongly classified as seen classes. 




\begin{figure*}[t!]
	\begin{center}
		\begin{subfigure}[t]{0.24\textwidth}\centering 
			\caption{Input image}\vspace{-0.2cm}
			\includegraphics[trim=0cm 0.8cm 0cm 0.8cm, clip=true,width=.98\textwidth]{./figure_voc/img1_bis.PNG}
		\end{subfigure}
		\begin{subfigure}[t]{0.24\textwidth}\centering
			\caption{GT}\vspace{-0.2cm}
			\includegraphics[trim=0cm 1.0cm 0cm 1.1cm, clip=true,width=.98\textwidth]{./figure_voc/gt1_bis.PNG}
		\end{subfigure}
		\begin{subfigure}[t]{0.24\textwidth}\centering
			\caption{ZS3Net}\vspace{-0.2cm}
			\includegraphics[trim=0cm 1.4cm 0cm 1.1cm, clip=true,width=.98\textwidth]{./figure_voc/pred1_bis.PNG}
		\end{subfigure}
		\begin{subfigure}[t]{0.24\textwidth}\centering
			\caption{ZS5Net}\vspace{-0.2cm}
			\includegraphics[trim=0cm 1.4cm 0cm 1.1cm, clip=true,width=.98\textwidth]{./figure_voc/self1_bis.PNG}
		\end{subfigure}\\
		\begin{subfigure}[t]{0.24\textwidth}\centering
			\includegraphics[trim=0cm 0.8cm 0cm 0.8cm, clip=true,width=.98\textwidth]{./figure_self/img1.PNG}
		\end{subfigure}
		\begin{subfigure}[t]{0.24\textwidth}\centering
			\includegraphics[trim=0cm 1.0cm 1.0cm 1.7cm, clip=true,width=.98\textwidth]{./figure_self/gt1.PNG}
		\end{subfigure}
		\begin{subfigure}[t]{0.24\textwidth}\centering
			\includegraphics[trim=0cm 1.0cm 1.0cm 1.7cm, clip=true,width=.98\textwidth]{./figure_self/pred1.PNG}
		\end{subfigure}
		\begin{subfigure}[t]{0.24\textwidth}\centering
			\includegraphics[trim=0cm 1.0cm 1.0cm 1.7cm, clip=true,width=.98\textwidth]{./figure_self/self1.PNG}
		\end{subfigure}\\\vspace{0.1cm}
	\end{center}
	\vspace{-0.3cm}
	\caption{\small \textbf{Zero shot segmentation with self-training}. (a) Input image, (b) semantic segmentation ground-truth, (c) segmentation with ZS3Net, (d) result with additional self-training (ZS5Net). Unseen classes:
		\setlength{\fboxsep}{1pt}\colorbox{col_bike}{\textcolor{white}{motorbike}}
		\setlength{\fboxsep}{1pt}\colorbox{col_sofa}{\textcolor{white}{sofa}};
		Some seen classes
		\setlength{\fboxsep}{1pt}\colorbox{col_car}{\textcolor{white}{car}}
		\setlength{\fboxsep}{1pt}\colorbox{col_chair}{\textcolor{white}{chair}}.
		Best viewed in color.
	}
	\vspace{-0.4cm}
	\label{fig:self_training}
\end{figure*}






 \section{Conclusion}
In this work, we introduced a deep model to deal with the task of zero-shot semantic segmentation.
Based on zero-shot classification, our ZS3Net model combines rich text and image embeddings, generative modeling and classic classifiers to learn how to segment objects from already seen classes as well as from new, never-seen ones at test time.  
First of its kind, proposed ZS3Net shows good behavior on the task of zero shot semantic segmentation, setting competitive baselines on various benchmarks.
We also introduced a self-training extension of the approach for scenarios where unlabelled pixels from unseen classes are available at training time. Finally, a graph-context encoding has been used to improve the semantic class representation of ZS3Net when facing complex scenes.  
\clearpage

\bibliographystyle{plain}
{\small
\bibliography{1-paper}
}
\clearpage



\begin{figure*}[h]
	\begin{center}
		\includegraphics[width=1.0\textwidth]{./figure_voc/sup_pascal_voc.PNG}
	\end{center}
	\vspace{-0.3cm}
	\caption{
	\textbf{Additional qualitative results on Pascal-VOC}. From top to bottom, results of the $2$-, $4$-, $6$-, $8$- and $10$-unseen set-ups. 
	(a) Input image, (b) semantic segmentation ground-truth, (c) segmentation without zero-shot learning, (d) results with proposed ZS3Net. 
Unseen classes:
		\setlength{\fboxsep}{1pt}\colorbox{col_bike}{\textcolor{white}{motorbike}}
	\setlength{\fboxsep}{1pt}\colorbox{col_plane}{\textcolor{white}{plane}}
	\setlength{\fboxsep}{1pt}\colorbox{col_cat}{\textcolor{white}{cat}}
		\setlength{\fboxsep}{1pt}\colorbox{col_sofa}{\textcolor{white}{sofa}}
   \setlength{\fboxsep}{1pt}\colorbox{col_train}{\textcolor{white}{train}}
    \setlength{\fboxsep}{1pt}\colorbox{col_chair}{\textcolor{white}{chair}};
    Some seen classes: \setlength{\fboxsep}{1pt}\colorbox{col_cycle}{\textcolor{white}{bicycle}}
    \setlength{\fboxsep}{1pt}\colorbox{col_boat}{\textcolor{white}{boat}}
    \setlength{\fboxsep}{1pt}\colorbox{col_horse}{\textcolor{white}{dog}}
	\setlength{\fboxsep}{1pt}\colorbox{col_person}{\textcolor{white}{person}}
	\setlength{\fboxsep}{1pt}\colorbox{black}{\textcolor{white}{background}}. Best seen in colors.}
	\vspace{-0.4cm}
	\label{fig:sup_pascal}
\end{figure*}


\begin{figure*}[t!]
	\begin{center}
	\includegraphics[width=1.0\textwidth]{./figure_context/sup_pascal_context.PNG}
	\end{center}
	\vspace{-0.3cm}
	\caption{
	\textbf{Additional qualitative results on Pascal-Context}. From top to bottom, results of the $2$-, $4$-, $6$-, $8$- and $10$-unseen set-ups. 
	(a) Input image, (b) semantic segmentation ground-truth, (c) segmentation without zero-shot learning, (d) results with proposed ZS3Net. Unseen classes:
	\setlength{\fboxsep}{1pt}\colorbox{col_cow}{\textcolor{white}{cow}}
	\setlength{\fboxsep}{1pt}\colorbox{col_cat}{\textcolor{white}{cat}}
	\setlength{\fboxsep}{1pt}\colorbox{col_boat}{\textcolor{white}{boat}}
		\setlength{\fboxsep}{1pt}\colorbox{col_bird}{\textcolor{white}{bird}}
	\setlength{\fboxsep}{1pt}\colorbox{col_plane}{\textcolor{white}{plane}};
    Some seen classes: 
    \setlength{\fboxsep}{1pt}\colorbox{col_dog}{\textcolor{white}{horse}}
    \setlength{\fboxsep}{1pt}\colorbox{col_horse}{\textcolor{white}{dog}}
	\setlength{\fboxsep}{1pt}\colorbox{black}{\textcolor{white}{background}} 
	\setlength{\fboxsep}{1pt}\colorbox{col_sky}{\textcolor{white}{sky}}.
	Best viewed in colors.}
	\vspace{-0.4cm}
	\label{fig:sup_context}
\end{figure*}



\begin{figure*}[t!]
	\begin{center}
		\includegraphics[width=1.0\textwidth]{./figure_voc_self/sup_pascal_voc_self.PNG}
	\end{center}
	\vspace{-0.3cm}
	\caption{
	\textbf{Additional qualitative results with self-training on Pascal-VOC}. 
	From top to bottom, results of the $2$-, $4$-, $6$-, $8$- and $10$-unseen set-ups. 
	(a) Input image, (b) semantic segmentation ground-truth, (c) segmentation with ZS3Net, (d) result with additional self-training (ZS5Net).
Unseen classes:
		\setlength{\fboxsep}{1pt}\colorbox{col_bike}{\textcolor{white}{motorbike}}
	\setlength{\fboxsep}{1pt}\colorbox{col_plane}{\textcolor{white}{plane}}
	\setlength{\fboxsep}{1pt}\colorbox{col_cat}{\textcolor{white}{cat}}
   \setlength{\fboxsep}{1pt}\colorbox{col_train}{\textcolor{white}{train}}
    \setlength{\fboxsep}{1pt}\colorbox{col_chair}{\textcolor{white}{chair}};
    Some seen classes: \setlength{\fboxsep}{1pt}\colorbox{col_cycle}{\textcolor{white}{bicycle}}
    \setlength{\fboxsep}{1pt}\colorbox{col_boat}{\textcolor{white}{boat}}
	\setlength{\fboxsep}{1pt}\colorbox{col_person}{\textcolor{white}{person}}
	\setlength{\fboxsep}{1pt}\colorbox{black}{\textcolor{white}{background}}.
	Best seen in colors.}
	\vspace{-0.4cm}
	\label{fig:sup_voc_self}
\end{figure*}



\begin{figure*}[t!]
	\begin{center}
		\includegraphics[width=1.0\textwidth]{./figure_context_self/sup_pascal_context_self.PNG}
	\end{center}
	\vspace{-0.3cm}
	\caption{
\textbf{Additional qualitative results with self-training on Pascal-Context}. 
	From top to bottom, results of the $2$-, $4$-, $6$-, $8$- and $10$-unseen set-ups. 
	(a) Input image, (b) semantic segmentation ground-truth, (c) segmentation with ZS3Net, (d) result with additional self-training (ZS5Net).
Unseen classes:
		\setlength{\fboxsep}{1pt}\colorbox{col_cow}{\textcolor{white}{cow}}
	\setlength{\fboxsep}{1pt}\colorbox{col_cat}{\textcolor{white}{cat}}
		\setlength{\fboxsep}{1pt}\colorbox{col_sofa}{\textcolor{white}{sofa}}
	\setlength{\fboxsep}{1pt}\colorbox{col_boat}{\textcolor{white}{boat}}
		\setlength{\fboxsep}{1pt}\colorbox{col_bird}{\textcolor{white}{bird}}
	\setlength{\fboxsep}{1pt}\colorbox{col_plane}{\textcolor{white}{plane}};
Some seen classes: 
\setlength{\fboxsep}{1pt}\colorbox{col_dog}{\textcolor{white}{horse}}
\setlength{\fboxsep}{1pt}\colorbox{col_horse}{\textcolor{white}{dog}}
	\setlength{\fboxsep}{1pt}\colorbox{black}{\textcolor{white}{background}} 
	\setlength{\fboxsep}{1pt}\colorbox{col_sky}{\textcolor{white}{sky}}.
	Best viewed in colors.}
	\vspace{-0.4cm}
	\label{fig:sup_context_self}
\end{figure*}
 
\end{document}